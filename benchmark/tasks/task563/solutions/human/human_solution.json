[
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\nvoid tostr(ll x,string& res){while(x)res+=('0'+(x%10)),x/=10; reverse(ALL(res)); return;}\ntemplate<class T> inline bool chmax(T& a,T b){ if(a<b){a=b;return 1;}return 0; }\ntemplate<class T> inline bool chmin(T& a,T b){ if(a>b){a=b;return 1;}return 0; }\n//end\n\nstruct dice{\n    ll x, y, z;\n};\n\ndice roll(dice d, ll dir){\n    ll x = d.x, y = d.y, z = d.z;\n    if(dir == 0) d.x = y, d.y = 7 - x;\n    if(dir == 1) d.x = z, d.z = 7 - x;\n    if(dir == 2) d.x = 7 - y, d.y = x;\n    if(dir == 3) d.x = 7 - z, d.z = x;\n    return d;\n}\n\ntypedef pair<int,int> pos;\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nint main(){\n   int h,w; scanf(\"%d%d\",&h,&w);\n   string s[110]; rep(i,0,h)cin>>s[i];\n   queue<pair<pos,dice>> que; que.push({{0,0},{6,2,3}});\n   bool used[110][110]={}; used[0][0]=1;\n   while(!que.empty()){\n      auto p=que.front(); que.pop();\n      pos xy=p.first; dice d=p.second;\n      if(s[xy.first][xy.second]!=(d.x+'0'))continue;\n      if(xy.first==h-1&&xy.second==w-1){puts(\"YES\"); return 0;}\n      rep(i,0,4){\n         int nx=xy.first+dx[i],ny=xy.second+dy[i];\n         if(nx<0||nx>=h||ny<0||ny>=w||used[nx][ny])continue;\n         que.push({{nx,ny},roll(d,i)}); used[nx][ny]=1;\n      }\n   } puts(\"NO\");\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                  Charlotteまだ見てない人は見ような！！！！！！！\n\n                  ／　 /:／　　　　　　　　　　　 　 ＼:ヽ　＼\n  　　　　　　　 /　　／　　　　　　 　 　 　 　 　 　 　 ＼　　ヽ\n  　　　　　＼__L 彡　　　　　　　　　　　　　　　　　　　 ヽ　　',\n  　　　　　　　ﾌ /　　　/　　/　 /　　　,　　 　 　 　 ヽ　　', 　ｊ\n  　　　　　　　ﾚ　　　 /　　/ 　/　 　 　 　 　 　 　 　 ', 　ヽ　j\n  　　　 　 　 // 　 　 !　/_l＿/__ノ 　　{ ＼}　　　　 　 ',　　',/\n  　　　　　　i ﾊ 　 　 {　从j　ﾊ　i　　　 ',　 ト-､}　 i i　 }　　jj\n  　　　　　　( ﾊ　　　(　 川　ハ ﾊ　 !　 '　ﾊ　 ﾊ　j j　,' 　 八\n  　　　 ＜＿,ｨ∧　　　斗芹ﾃミxハ ﾊ　 ﾚ　} /__ﾚﾚ　/ 　 ∧ ＼　ﾉ\n  　　　 　 　 ∨　＼ 　ゝ　辷:ソ　　 　)　芹ﾚ心ヾレ′　/ ト--　´\n  　　　＼ｰ‐'　ﾉ　　 ＼ゝ　　　　　　 　 　 ゞ:_ソ \"/ 　／ 　ヽ\n  　　　　 　 フ　　　　i八 \" \"　　　,　　　　　　　ム彡　　　　＼\n  　　　　 　/　　/　　j　 ト　　　　　　 　 　 \" \"イト＜　 　 　 ＼＼\n  　　　　 /　　/　　　j　/／ヽ､ 　 ∩　　 　 イ　{ {　　￣ フフへ ＼＼\n  　　　　(　／　　　 ,/ / 　　i　＞――＜ニニニﾆ┐　 〃／: : ヽ　ヽヽ\n  　　　　／　　ィT´/ /┌―　￣￣ /::: , ,)　 　 　 〃／／: : : : : :}　ヽヽ)\n  　　　/ /　 ∧ヾi┌― { {￣　　　 ﾉ:::トﾟ<　 　 　 ∥//: : : : : : : : i　 ﾉ ﾉ\n  . 　　( 人　 {:ヽヾi∨　∧V　　　 /:::/　､ヽ　　　 ∥/: : : : : : : : : :}　/\n  　　　V　( ∧: :＼'∨　∧V　　 ﾉ:::/　 ∧ 〉＿__∥: : : : : :／: : : :ﾚ\n  　　 　 　 /∧: : : : ∨　∧V┬ｲ:::ﾉ　 〈 TT　|　|{{: : : : ／: : : : : ∧　　 ﾉ\n  　　　 　 (　ハ: : : : :∨'T∧Vi　i (　 　 V　!　!　{{: : ／ : : : : : : /　ｰ　ノ\n  　　　　　V　ハ: : : : :∨ﾍ∧V　i ゝゝ　 i／⌒＼{／ : : : : : : : /ｰ― ´\n  　　　　　 ∨　ヽ: : : : :∨ﾍ∧∨i　〉 〉 /　/二　 ): : : : : : : : :/\n\n          (https://seesaawiki.jp/asciiart/d/Charlotte より)\n*/\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long; using ull = unsigned long long;\n// #define int ll\n// #define DEBUG 42\ninline void nprint(){}\ntemplate <class Head, class... Tail>\ninline void nprint(Head &&head, Tail &&... tail) {\n    cout << head << endl;\n    nprint(move(tail)...);\n}\n#ifdef DEBUG\n  #define eprint(...) nprint(__VA_ARGS__)\n#else\n  #define eprint(...) if(0==1) cout << 1 << endl;\n#endif\n#define Yes(a) cout << (a ? \"Yes\" : \"No\") << endl\n#define YES(a) cout << (a ? \"YES\" : \"NO\") << endl\n#define POSSIBLE(a) cout << (a ? \"POSSIBLE\" : \"IMPOSSIBLE\") << endl\nusing cmp = complex<double>;\nusing vb = vector<bool>; using vvb = vector<vb>;\nusing vi = vector<int>; using vvi = vector<vi>;\nusing vl = vector<ll>; using vvl = vector<vl>;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<V<T>>;\n#define fi first\n#define se second\n#define maxs(x,y) (x=max<ll>(x,y))\n#define mins(x,y) (x=min<ll>(x,y))\nusing pii = pair<int,int>; using pll = pair<ll,ll>;\n#define FOR(i,a,b) for(ll i = (a); i < (ll)(b); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORS(i,a,b) FOR(i,a,b+1)\n#define REPS(i,n) REP(i,n+1)\n#define RFOR(i,a,b) for(ll i = (ll)(b)-1;i >= a;--i)\n#define RREP(i,n) RFOR(i,0,n)\n#define RREPS(i,n) RREP(i,n+1)\n#define RFORS(i,a,b) RFOR(i,a,b+1)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define PERM(c) sort(ALL(c)); for(bool cp = true;cp;cp = next_permutation(ALL(c)))\n#define eb(val) emplace_back(val)\n#define bitcnt(val) __builtin_popcountll(val)\nconstexpr double PI = acos((long double)-1);\nconstexpr double EPS = 1e-10;\nconstexpr ll MOD = 1E9+7;\n// constexpr ll MOD = 998244353;\nconstexpr int dx[] = {1,0,-1,0}; constexpr int dy[] = {0,1,0,-1};\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& p){\n  return s << \"(\" << p.first << \", \" << p.second << \")\";\n}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &st){\n  for(size_t i=0;i<st.size();++i) is >> st[i];\n  return is;\n}\ntemplate<class T> istream& operator>>(istream &is,vector<vector<T>> &st){\n  for(size_t i=0;i<st.size();++i) is >> st[i];\n  return is;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &st){\n  for(size_t i=0;i<st.size();++i){\n    if(i==st.size()-1) os << st[i];\n    else os << st[i] << \" \";\n  }\n  return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const vector<vector<T>> &st){\n  for(size_t i=0;i<st.size();++i){\n    os << st[i];\n    if(i!=st.size()-1) os << endl;\n  }\n  return os;\n}\nstruct dice{\n  int up,s,e,w,n,dn;\n  void to(char dir){\n    if(dir=='N'){\n      int tmp = n;\n      n = up;\n      up = s;\n      s = dn;\n      dn = tmp;\n    }else if(dir=='S'){\n      int tmp = s;\n      s = up;\n      up = n;\n      n = dn;\n      dn = tmp;\n    }else if(dir=='E'){\n      int tmp = e;\n      e = up;\n      up = w;\n      w = dn;\n      dn = tmp;\n    }else if(dir=='W'){\n      int tmp = w;\n      w = up;\n      up = e;\n      e = dn;\n      dn = tmp;\n    }else if(dir=='R'){\n      int tmp = e;\n      e = n;\n      n = w;\n      w = s;\n      s = tmp;\n    }else if(dir=='L'){\n      int tmp = e;\n      e = s;\n      s = w;\n      w = n;\n      n = tmp;\n    }\n  }\n  void to(string dirs){\n    REP(i,dirs.size()) to(dirs[i]);\n  }\n  bool operator==(dice di){\n    return up==di.up && n==di.n && e==di.e && w==di.w && s==di.s && dn==di.dn;\n  }\n};\nstring dirs = \"ESWN\";\nstruct dicewithfield{\n  int x,y;\n  dice d;\n  int lx, ly;\n  dicewithfield(){\n    x = y = 0;\n    lx = ly = -1;\n    d = {1,2,3,4,5,6};\n  }\n  dicewithfield move(int i){\n    dicewithfield res;\n    res.lx = x, res.ly = y;\n    res.x = x + dx[i], res.y = y + dy[i];\n    res.d = d;\n    res.d.to(dirs[i]);\n    return res;\n  }\n};\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  int h,w;\n  cin >> h >> w;\n  V<string> s(h);\n  cin >> s;\n  queue<dicewithfield> q;\n  q.emplace(dicewithfield());\n  vvi can_reach(h,vi(w,0));\n  can_reach[0][0] = 1;\n  auto check = [&](dicewithfield z){\n    return z.x>=0&&z.y>=0&&z.x<w&&z.y<h&&s[z.y][z.x]=='0'+z.d.dn;\n  };\n  while(!q.empty()){\n    auto cur = q.front();\n    q.pop();\n    REP(i,4){\n      auto nx = cur.move(i);\n      // eprint(nx.d.dn);\n      if(check(nx)){\n        if(can_reach[nx.y][nx.x]) continue;\n        can_reach[nx.y][nx.x] = 1;\n        q.emplace(nx);\n      }\n    }\n  }\n  // eprint(can_reach);\n  YES(can_reach[h-1][w-1]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n#define rep(i, n) for(int i = 0; (i) < (n); (i)++)\n#define FOR(i, m, n) for(int i = (m); (i) < (n); (i)++)\n#define All(v) (v).begin(), (v).end()\n#define MP make_pair\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1 << 30;\nconst ll LINF = 1LL << 61;\nconst int MOD = 1e9 + 7;\n\nint check(int i, int j) {\n    if((i + j) % 4 == 0)\n        return 6;\n    else if((i + j) % 4 == 2)\n        return 1;\n    else if(j % 4 == 1)\n        return 3;\n    else if(j % 4 == 3)\n        return 4;\n    else if(i % 4 == 1)\n        return 2;\n    else if(i % 4 == 3)\n        return 5;\n}\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> s(H);\n    rep(i, H) cin >> s[i];\n    vector<vector<bool>> ok(H, vector<bool>(W));\n    rep(i, H) rep(j, W) {\n        if(check(i, j) == s[i][j] - '0') {\n            ok[i][j] = 1;\n        }\n    }\n    vector<vector<bool>> reach(H, vector<bool>(W));\n    queue<pii> que;\n    que.push(MP(0, 0));\n    reach[0][0] = 1;\n    while(!que.empty()) {\n        auto p = que.front();\n        que.pop();\n        int y = p.first;\n        int x = p.second;\n        rep(i, 4) {\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(nx >= 0 && nx < W && ny >= 0 && ny < H) {\n                if(!reach[ny][nx] && ok[ny][nx]) {\n                    reach[ny][nx] = 1;\n                    que.push(MP(ny, nx));\n                }\n            }\n        }\n    }\n    if(reach[H - 1][W - 1]) {\n        cout << \"YES\" << endl;\n    } else {\n        cout << \"NO\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\nusing Int = long long;\nconst char newl = '\\n';\n\n\nstruct Die{\n  array<int, 6> s;\n  int &top()   {return s[0];}\n  int &south() {return s[1];}\n  int &east()  {return s[2];}\n  int &west()  {return s[3];}\n  int &north() {return s[4];}\n  int &bottom(){return s[5];}\n  void roll(char c){\n    //the view from above\n    // N\n    //W E\n    // S\n    string b(\"EWNSRL\");\n    int v[6][4]={{0,3,5,2},\n                 {0,2,5,3},\n                 {0,1,5,4},\n                 {0,4,5,1},\n                 {1,2,4,3},\n                 {1,3,4,2}};\n    for(int k=0;k<6;k++){\n      if(b[k]!=c) continue;\n      int t=s[v[k][0]];\n      s[v[k][0]]=s[v[k][1]];\n      s[v[k][1]]=s[v[k][2]];\n      s[v[k][2]]=s[v[k][3]];\n      s[v[k][3]]=t;\n    }\n  }\n  using ll = long long;\n  ll hash(){\n    ll res=0;\n    for(int i=0;i<6;i++) res=res*256+s[i];\n    return res;\n  }\n  bool operator==(const Die &d) const{\n    for(int i=0;i<6;i++) if(s[i]!=d.s[i]) return 0;\n    return 1;\n  }\n};\n\nvector<Die> makeDice(Die d){\n  vector<Die> res;\n  for(int i=0;i<6;i++){\n    Die t(d);\n    if(i==1) t.roll('N');\n    if(i==2) t.roll('S');\n    if(i==3) t.roll('S'),t.roll('S');\n    if(i==4) t.roll('L');\n    if(i==5) t.roll('R');\n    for(int k=0;k<4;k++){\n      res.push_back(t);\n      t.roll('E');\n    }\n  }\n  return res;\n}\n\n\ntemplate<typename T> void drop(const T &x){cout<<x<<endl;exit(0);}\n\n//INSERT ABOVE HERE\nint dp[100][200][200];\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int h,w;\n  cin>>h>>w;\n  vector<string> ss(h);\n  for(int i=0;i<h;i++) cin>>ss[i];\n\n  Die d;\n  d.top()='1';\n  d.bottom()='6';\n  d.north()='5';\n  d.south()='2';\n  d.east()='3';\n  d.west()='4';\n\n  auto ds=makeDice(d);\n  map<array<int, 6>, int> idx;\n  for(int i=0;i<(int)ds.size();i++)\n    idx[ds[i].s]=i;\n\n  memset(dp,0,sizeof(dp));\n  using T = tuple<int, int, int>;\n  queue<T> que;\n\n  dp[idx[d.s]][0][0]=1;\n  que.emplace(idx[d.s],0,0);\n\n  while(!que.empty()){\n    int k,i,j;\n    tie(k,i,j)=que.front();que.pop();\n    if(i==h-1 and j==w-1) drop(\"YES\");\n    d=ds[k];\n\n    // cout<<k<<\" \"<<i<<\" \"<<j<<endl;\n\n    if(i+1<h){\n      int ni=i+1,nj=j;\n      Die nd(d);\n      nd.roll('S');\n      if(nd.bottom()==ss[ni][nj] and !dp[idx[nd.s]][ni][nj]){\n        dp[idx[nd.s]][ni][nj]=1;\n        que.emplace(idx[nd.s],ni,nj);\n      }\n    }\n    if(i-1>=0){\n      int ni=i-1,nj=j;\n      Die nd(d);\n      nd.roll('N');\n      if(nd.bottom()==ss[ni][nj] and !dp[idx[nd.s]][ni][nj]){\n        dp[idx[nd.s]][ni][nj]=1;\n        que.emplace(idx[nd.s],ni,nj);\n      }\n    }\n\n    if(j+1<w){\n      int ni=i,nj=j+1;\n      Die nd(d);\n      nd.roll('E');\n      if(nd.bottom()==ss[ni][nj] and !dp[idx[nd.s]][ni][nj]){\n        dp[idx[nd.s]][ni][nj]=1;\n        que.emplace(idx[nd.s],ni,nj);\n      }\n    }\n    if(j-1>=0){\n      int ni=i,nj=j-1;\n      Die nd(d);\n      nd.roll('W');\n      if(nd.bottom()==ss[ni][nj] and !dp[idx[nd.s]][ni][nj]){\n        dp[idx[nd.s]][ni][nj]=1;\n        que.emplace(idx[nd.s],ni,nj);\n      }\n    }\n  }\n\n  drop(\"NO\");\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cmath>\n#include <tuple>\n#include <cstring>\n#include <map>\n#include <iomanip>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <climits>\n#include <bitset>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define _ << \" \" <<\n#define all(X) (X).begin(), (X).end()\n#define len(X) (X).size()\n#define Pii pair<int, int>\n#define Pll pair<ll, ll>\n#define Tiii tuple<int, int, int>\n#define Tlll tuple<ll, ll, ll>\n#define PI 3.14159265358979324\n\nint h, w, dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nchar s[105][105];\nbool b[105][105] = {};\n\nvoid dfs(int x, int y) {\n    b[x][y] = 1;\n    if (x == h - 1 && y == w - 1) return;\n    \n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (nx < 0 || nx >= h || ny < 0 || ny >= w) continue;\n        if (!b[nx][ny] && s[nx][ny] >= '1' && s[nx][ny] <= '6') {\n            dfs(nx, ny);\n        }\n    }\n}\n\nint main() {\n    cin >> h >> w;\n\n    for (int i =0 ; i < h; i++) cin >> s[i];\n\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            if (j % 2 == 0 && i % 2 == 0) {\n                if ((i + j) % 4 == 0 && s[i][j] != '6') s[i][j] = '0';\n                if ((i + j) % 4 == 2 && s[i][j] != '1') s[i][j] = '0';\n            }\n            else {\n                if (j % 4 == 1) {\n                    if (i % 2 == 0 && s[i][j] != '3') s[i][j] = '0';\n                }\n                if (j % 4 == 3) {\n                    if (i % 2 == 0 && s[i][j] != '4') s[i][j] = '0';\n                }\n                if (i % 4 == 1) {\n                    if (j % 2 == 0 && s[i][j] != '2') s[i][j] = '0';\n                }\n                if (i % 4 == 3) {\n                    if (j % 2 == 0 && s[i][j] != '5') s[i][j] = '0';\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < h; i++ ) {\n        for (int j = 0; j < w; j++) {\n            //cerr << s[i][j];\n        }\n        //cerr << endl;\n    }\n\n    dfs(0, 0);\n\n    cout << (b[h-1][w-1] ? \"YES\" : \"NO\") << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n  int H, W;\n  cin >> H >> W;\n  \n  vector<vector<char>> grid(H, vector<char>(W));\n  for(int i = 0; i < H; i++){\n    for(int j = 0; j < W; j++) cin >> grid[i][j];\n  }\n  \n  char c[4][4] = {{'6', '3', '1', '4'},\n                  {'2', '0', '2', '0'},\n                  {'1', '3', '6', '4'},\n                  {'5', '0', '5', '0'}};\n  \n  \n  vector<vector<bool>> reach(H, vector<bool>(W, false));\n  reach[0][0] = true;\n  queue<pair<int, int>> q;\n  \n  q.push({0, 0});\n  while(!q.empty()){\n    int i = q.front().first, j = q.front().second;\n    q.pop();\n    \n    if(i - 1 >= 0 && grid[i - 1][j] == c[(i + 3) % 4][j % 4]){\n      if(!reach[i - 1][j]){\n        reach[i - 1][j] = true;\n        q.push({i - 1, j});\n      }\n    }\n    if(j - 1 >= 0 && grid[i][j - 1] == c[i % 4][(j + 3) % 4]){\n      if(!reach[i][j - 1]){\n        reach[i][j - 1] = true;\n        q.push({i, j - 1});\n      }\n    }\n    if(i + 1 < H && grid[i + 1][j] == c[(i + 1) % 4][j % 4]){\n      if(!reach[i + 1][j]){\n        reach[i + 1][j] = true;\n        q.push({i + 1, j});\n      }\n    }\n    if(j + 1 < W && grid[i][j + 1] == c[i % 4][(j + 1) % 4]){\n      if(!reach[i][j + 1]){\n        reach[i][j + 1] = true;\n        q.push({i, j + 1});\n      }\n    }\n  }\n  \n  puts(reach[H - 1][W - 1] ? \"YES\" : \"NO\");\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vec>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\n\nint s[4][4]={\n    {6,3,1,4},\n    {2,0,2,0},\n    {1,3,6,4},\n    {5,0,5,0}\n};\nint check(int x,int y){\n    return s[x%4][y%4];\n}\n\nmain(){\n    int h=in(),w=in();\n    int mp[110][110];\n    rep(i,h){\n        string s;cin>>s;\n        rep(j,w){\n            mp[i][j]=(s[j]-'0');\n        }\n    }\n    int t[110][110]={};\n    t[0][0]=1;\n    if(mp[0][0]!=6){\n        cout<<\"NO\\n\";return 0;\n    }\n    rep(i,h){\n        rep(j,w){\n            if(mp[i][j]==check(i,j))t[i+1][j+1]=1;\n        }\n    }\n    queue<pii> q;\n    q.emplace(1,1);\n    int visited[110][110]={};\n    visited[1][1]=1;\n    int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n    while(!q.empty()){\n        int x,y;\n        tie(x,y)=q.front();\n        q.pop();\n        rep(i,4){\n            if(t[x+dx[i]][y+dy[i]]){\n                if(!visited[x+dx[i]][y+dy[i]]) {\n                    q.emplace(x+dx[i],y+dy[i]);\n                    visited[x+dx[i]][y+dy[i]]=1;\n                }\n            }\n        }\n    }\n    cout <<(visited[h][w] ? \"YES\\n\" : \"NO\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <math.h>\n#include <map>\n#include <numeric>\n#include <string>\n#include <queue>\nusing namespace std;\ntypedef long long int ll;\n\nbool can[101][101];\n\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\n\nint num[6][2][4]=\n{{{2,5,4,3},{5,2,3,4}},\n{{1,6,3,4},{6,1,4,3}},\n{{2,5,1,6},{5,2,6,1}},\n{{2,5,6,1},{5,2,1,6}},\n{{1,6,4,3},{6,1,3,4}},\n{{2,5,3,4},{5,2,4,3}}\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int h,w; cin >> h >> w;\n    char fi[h][w];\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            cin >> fi[i][j];\n        }\n    }\n    can[0][0]=1;\n    queue<pair<pair<int,int>,pair<int,int>>> q;\n    q.push(make_pair(make_pair(0,0),make_pair(6,0)));\n    while(q.size()){\n        auto p=q.front(); q.pop();\n        int x=p.first.first,y=p.first.second;\n        for(int i=0;i<4;i++){\n            int nx=dx[i]+x,ny=dy[i]+y;\n            if(0<=nx&&nx<h&&0<=ny&&ny<w){\n                if(can[nx][ny])continue;\n                if(fi[nx][ny]=='#')continue;\n                if(fi[nx][ny]-'0'!=num[p.second.first-1][p.second.second][i])continue;\n                can[nx][ny]=1;\n                int v=fi[x][y]-'0';\n                int w=fi[nx][ny]-'0';\n                int t=0;\n                if(i==0||i==1){\n                    if(v>=4&&i==1)t=1;\n                    if(v<=3&&i==0)t=1;\n                }\n                else{\n                    if(num[p.second.first-1][p.second.second][0]>=4)t=1;\n                }\n                q.push(make_pair(make_pair(nx,ny),make_pair(fi[nx][ny]-'0',t)));\n            }\n        }\n    }\n    if(can[h-1][w-1]){\n        cout << \"YES\" << endl;\n    }else{\n        cout << \"NO\" << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define _for(i,j,N) for(int i = (j);i < (N);i++)\n#define _rep(i,j,N) for(int i = (j);i <= (N);i++)\n#define _dec(i,N,j) for(int i = (N-1);i >= (j);i--)\n#define _rec(i,N,j) for(int i = (N);i >=(j);i--)\n#define ALL(x) x.begin(),x.end()\n#define MEM(a,n) memset(a,n,sizeof(a))\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\n\nint get_int(){int x;scanf(\"%d\",&x);return x;}\nLL get_ll(){LL x;scanf(\"%lld\",&x);return x;}\ndouble get_db(){double x;scanf(\"%lf\",&x);return x;}\n\ntemplate<typename T> int chmin(T &a,T b){if(a > b){a = b;return 1;}else return 0;}\ntemplate<typename T> int chmax(T &a,T b){if(a < b){a = b;return 1;}else return 0;}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& v) {_for(i,0,v.size()) os << v[i] << \" \";return os;}\ntemplate<typename T>\nostream& operator<<(ostream& os,const set<T>& v){for(auto a:v) os << a <<\" \";return os;}\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& v){os << v.fst <<\" \"<<v.scd << \" \";return os;}\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const map<T1,T2>& v){for(auto a:v) cout << a << endl;return os;}\n\nstatic const int dx[8] = { -1,  0, 1, 0,  1, -1,  1, -1};\nstatic const int dy[8] = {0,  1, 0,  -1,  1, -1, -1,  1};\nconst double pi  = acos(-1.0);\nconst double eps = 1e-8;\nconst LL  INF  = 0x3f3f3f3f3f3f3f3f;\nconst int inf  = 0x3f3f3f3f;\n\nchar G[105][105];\nint vis[105][105][7][7];\nint H,W;\n\nstruct dice{\n    int a[6];\n    int x,y;\n    dice(int x = 0,int y = 0):x(x),y(y){\n        a[0] = 1;\n        a[1] = 6;\n        a[2] = 4;\n        a[3] = 3;\n        a[4] = 2;\n        a[5] = 5;\n    }\n    int rr(){\n        int temp = a[0];\n        a[0] = a[2];\n        a[2] = a[1];\n        a[1] = a[3];\n        a[3] = temp;\n        y += 1;\n        return a[1];\n    }\n    int lr(){\n        int temp = a[0];\n        a[0] = a[3];\n        a[3] = a[1];\n        a[1] = a[2];\n        a[2] = temp;\n        y -= 1;\n        return a[1];\n    }\n    int ur(){\n        int temp = a[0];\n        a[0] = a[4];\n        a[4] = a[1];\n        a[1] = a[5];\n        a[5] = temp;\n        x -= 1;\n        return a[1];\n\n    }\n    int dr(){\n        int temp = a[0];\n        a[0] = a[5];\n        a[5] = a[1];\n        a[1] = a[4];\n        a[4] = temp;\n        x += 1;\n        return a[1];\n    }\n    bool mark(){\n        //cout << x <<\" \" <<y << endl;\n        if(x < 0 || y < 0 || x >= H || y >= W) return false;\n        if( (vis[x][y][a[3]][a[4]]) || (a[1] != G[x][y] - '0') ) return false;\n        else{\n            vis[x][y][a[3]][a[4]] = 1;\n            return true;\n        }\n    }\n\n};\n\n\n\n\nint main()\n{\n    cin >> H >> W;\n    getchar();\n    _for(i,0,H){\n        _for(j,0,W){\n            char c = getchar();\n            G[i][j] = c;\n        }\n        getchar();\n    }\n    MEM(vis,0);\n    dice d;\n    d.mark();\n    queue<dice> que;\n    que.push(d);\n    while(!que.empty()){\n        dice dd = que.front();que.pop();\n        dice k;\n\n        memcpy(&k,&dd,sizeof(dd));\n        k.rr();\n        if(k.mark()){\n            que.push(k);\n            //cout << \"ok\" << endl;\n        }\n\n        memcpy(&k,&dd,sizeof(dd));\n        k.lr();\n        if(k.mark()){\n            que.push(k);\n        }\n\n       memcpy(&k,&dd,sizeof(dd));\n        k.ur();\n           if(k.mark()){\n            que.push(k);\n        }\n\n        memcpy(&k,&dd,sizeof(dd));\n        k.dr();\n           if(k.mark()){\n            que.push(k);\n            //cout << \"ok\" << endl;\n        }\n    }\n\n    int OK = 0;\n    _for(i,0,7){\n        _for(j,0,7){\n            if(vis[H-1][W-1][i][j]) OK = 1;\n        }\n    }\n    if(OK) cout <<\"YES\"<< endl;\n    else cout << \"NO\" << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n#define REP(i,m,n) for(int i=(m);i<(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define pb push_back\n#define all(a) a.begin(),a.end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef long double ld;\nconst ll inf=1e9+7;\nconst ll mod=1e9+7;\nint main(){\n    ll h,w;\n    cin>>h>>w;\n    vector<vector<char> >s(h+2,vector<char>(w+2));\n    REP(i,1,h+1){\n        REP(j,1,w+1){\n            cin>>s[i][j];\n        }\n    }\n    vector<vector<ll> >visited(h+2,vector<ll>(w+2));\n    queue<pll>q;\n    visited[1][1]=1;\n    q.push(mp(1,1));\n    while(!q.empty()){\n        pll k=q.front();\n        q.pop();\n        ll x=k.first,y=k.second;\n        if(x%4==1){\n            if(y%4==1){\n                if(x+2<=h){\n                    if(s[x+1][y]=='2'&&s[x+2][y]=='1'&&!visited[x+2][y]){\n                        q.push(mp(x+2,y));\n                        visited[x+2][y]=1;\n                    }\n                }\n                if(x+1<=h){\n                    if(s[x+1][y]=='2'){\n                        visited[x+1][y]=1;\n                    }\n                }\n                if(x-2>=0){\n                    if(s[x-1][y]=='5'&&s[x-2][y]=='1'&&!visited[x-2][y]){\n                        q.push(mp(x-2,y));\n                        visited[x-2][y]=1;\n                    }\n                }\n                if(x-1>=0){\n                    if(s[x-1][y]=='5'){\n                        visited[x-1][y]=1;\n                    }\n                }\n                if(y+2<=w){\n                    if(s[x][y+1]=='3'&&s[x][y+2]=='1'&&!visited[x][y+2]){\n                        q.push(mp(x,y+2));\n                        visited[x][y+2]=1;\n                    }\n                }\n                if(y+1<=w){\n                    if(s[x][y+1]=='3'){\n                        visited[x][y+1]=1;\n                    }\n                }\n                if(y-2>=0){\n                    if(s[x][y-1]=='4'&&s[x][y-2]=='1'&&!visited[x][y-2]){\n                        q.push(mp(x,y-2));\n                        visited[x][y-2]=1;\n                    }\n                }\n                if(y-1>=0){\n                    if(s[x][y-1]=='4'){\n                        visited[x][y-1]=1;\n                    }\n                }\n            }else{\n                if(x+2<=h){\n                    if(s[x+1][y]=='2'&&s[x+2][y]=='6'&&!visited[x+2][y]){\n                        q.push(mp(x+2,y));\n                        visited[x+2][y]=1;\n                    }\n                }\n                if(x+1<=h){\n                    if(s[x+1][y]=='2'){\n                        visited[x+1][y]=1;\n                    }\n                }\n                if(x-2>=0){\n                    if(s[x-1][y]=='5'&&s[x-2][y]=='6'&&!visited[x-2][y]){\n                        q.push(mp(x-2,y));\n                        visited[x-2][y]=1;\n                    }\n                }\n                if(x-1>=0){\n                    if(s[x-1][y]=='5'){\n                        visited[x-1][y]=1;\n                    }\n                }\n                if(y+2<=w){\n                    if(s[x][y+1]=='4'&&s[x][y+2]=='6'&&!visited[x][y+2]){\n                        q.push(mp(x,y+2));\n                        visited[x][y+2]=1;\n                    }\n                }\n                if(y+1<=w){\n                    if(s[x][y+1]=='4'){\n                        visited[x][y+1]=1;\n                    }\n                }\n                if(y-2>=0){\n                    if(s[x][y-1]=='3'&&s[x][y-2]=='6'&&!visited[x][y-2]){\n                        q.push(mp(x,y-2));\n                        visited[x][y-2]=1;\n                    }\n                }\n                if(y-1>=0){\n                    if(s[x][y-1]=='3'){\n                        visited[x][y-1]=1;\n                    }\n                }\n            }\n        }\n        if(x%4==3){\n            if(y%4==1){\n                if(x+2<=h){\n                    if(s[x+1][y]=='5'&&s[x+2][y]=='6'&&!visited[x+2][y]){\n                        q.push(mp(x+2,y));\n                        visited[x+2][y]=1;\n                    }\n                }\n                if(x+1<=h){\n                    if(s[x+1][y]=='5'){\n                        visited[x+1][y]=1;\n                    }\n                }\n                if(x-2>=0){\n                    if(s[x-1][y]=='2'&&s[x-2][y]=='6'&&!visited[x-2][y]){\n                        q.push(mp(x-2,y));\n                        visited[x-2][y]=1;\n                    }\n                }\n                if(x-1>=0){\n                    if(s[x-1][y]=='2'){\n                        visited[x-1][y]=1;\n                    }\n                }\n                if(y+2<=w){\n                    if(s[x][y+1]=='3'&&s[x][y+2]=='6'&&!visited[x][y+2]){\n                        q.push(mp(x,y+2));\n                        visited[x][y+2]=1;\n                    }\n                }\n                if(y+1<=w){\n                    if(s[x][y+1]=='3'){\n                        visited[x][y+1]=1;\n                    }\n                }\n                if(y-2>=0){\n                    if(s[x][y-1]=='4'&&s[x][y-2]=='6'&&!visited[x][y-2]){\n                        q.push(mp(x,y-2));\n                        visited[x][y-2]=1;\n                    }\n                }\n                if(y-1>=0){\n                    if(s[x][y-1]=='4'){\n                        visited[x][y-1]=1;\n                    }\n                }\n            }else{\n                if(x+2<=h){\n                    if(s[x+1][y]=='5'&&s[x+2][y]=='1'&&!visited[x+2][y]){\n                        q.push(mp(x+2,y));\n                        visited[x+2][y]=1;\n                    }\n                }\n                if(x+1<=h){\n                    if(s[x+1][y]=='5'){\n                        visited[x+1][y]=1;\n                    }\n                }\n                if(x-2>=0){\n                    if(s[x-1][y]=='2'&&s[x-2][y]=='1'&&!visited[x-2][y]){\n                        q.push(mp(x-2,y));\n                        visited[x-2][y]=1;\n                    }\n                }\n                if(x-1>=0){\n                    if(s[x-1][y]=='2'){\n                        visited[x-1][y]=1;\n                    }\n                }\n                if(y+2<=w){\n                    if(s[x][y+1]=='4'&&s[x][y+2]=='1'&&!visited[x][y+2]){\n                        q.push(mp(x,y+2));\n                        visited[x][y+2]=1;\n                    }\n                }\n                if(y+1<=w){\n                    if(s[x][y+1]=='4'){\n                        visited[x][y+1]=1;\n                    }\n                }\n                if(y-2>=0){\n                    if(s[x][y-1]=='3'&&s[x][y-2]=='1'&&!visited[x][y-2]){\n                        q.push(mp(x,y-2));\n                        visited[x][y-2]=1;\n                    }\n                }\n                if(y-1>=0){\n                    if(s[x][y-1]=='3'){\n                        visited[x][y-1]=1;\n                    }\n                }\n            }\n        }\n    }\n    if(visited[h][w])cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<numeric>\n#include<functional>\n#include<algorithm>\n#include<bitset>\n#include<tuple>\n#include<unordered_set>\n#include<unordered_map>\n#include<random>\n#include<array>\n#include<cassert>\nusing namespace std;\n#define INF (1<<29)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define uniq(v) v.erase(unique(all(v)),v.end())\n\n\nclass Dice {\npublic:\n\tint top, front, r;\n\tDice() :top(1), front(2), r(3) {}\n\tDice(int a, int b,int c) :top(a), front(b), r(c) {}\n\tvoid north() {\n\t\tint a = top;\n\t\ttop = front;\n\t\tfront = 7 - a;\n\t}\n\tvoid east() {\n\t\tint a = top;\n\t\ttop = 7 - r;\n\t\tr = a;\n\t}\n\tvoid west() {\n\t\tint a = top;\n\t\ttop = r;\n\t\tr = 7 - a;\n\t}\n\tvoid south() {\n\t\tint a = top;\n\t\ttop = 7 - front;\n\t\tfront = a;\n\t}\n\tvoid right() {\n\t\tint a = front;\n\t\tfront = r;\n\t\tr = 7 - a;\n\t}\n\tvoid left() {\n\t\tint a = front;\n\t\tfront = 7 - r;\n\t\tr = a;\n\t}\n};\n\n\nchar f[100][100];\n\nbool vis[100][100][6][6][6];\n\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint h, w;\n\tcin >> h >> w;\n\trep(i, h)rep(j, w)cin >> f[i][j];\n\n\tqueue<tuple<int, int, int, int, int>> q;\n\tvis[0][0][5][1][2] = true;\n\tq.emplace(0, 0, 5, 1, 2);\n\n\tstring ans = \"NO\";\n\n\twhile (!q.empty()) {\n\t\tauto t = q.front();\n\t\tq.pop();\n\n\t\tint y, x, soko, fr, ri;\n\t\ttie(y, x, soko, fr, ri) = t;\n\t\tDice dice(7 - (soko + 1), fr + 1, ri + 1);\n\n\t\tif (y==h-1 && x==w-1) {\n\t\t\tans = \"YES\";\n\t\t\tbreak;\n\t\t}\n\n\t\tif (0 < y) {\n\t\t\tDice d = dice;\n\t\t\td.north();\n\t\t\tif (f[y - 1][x] - '0' == 7 - d.top && !vis[y - 1][x][7 - d.top - 1][d.front - 1][d.r - 1]) {\n\t\t\t\tvis[y - 1][x][7 - d.top - 1][d.front - 1][d.r - 1] = true;\n\t\t\t\tq.emplace(y - 1, x, 7 - d.top - 1, d.front - 1, d.r - 1);\n\t\t\t}\n\t\t}\n\t\tif (y + 1< h) {\n\t\t\tDice d = dice;\n\t\t\td.south();\n\t\t\tif (f[y + 1][x] - '0' == 7 - d.top && !vis[y + 1][x][7 - d.top - 1][d.front - 1][d.r - 1]) {\n\t\t\t\tvis[y + 1][x][7 - d.top - 1][d.front - 1][d.r - 1] = true;\n\t\t\t\tq.emplace(y + 1, x, 7 - d.top - 1, d.front - 1, d.r - 1);\n\t\t\t}\n\t\t}\n\t\tif (0 < x) {\n\t\t\tDice d = dice;\n\t\t\td.west();\n\t\t\tif (f[y][x - 1] - '0' == 7 - d.top && !vis[y][x - 1][7 - d.top - 1][d.front - 1][d.r - 1]) {\n\t\t\t\tvis[y][x - 1][7 - d.top - 1][d.front - 1][d.r - 1] = true;\n\t\t\t\tq.emplace(y, x - 1, 7 - d.top - 1, d.front - 1, d.r - 1);\n\t\t\t}\n\t\t}\n\t\tif (x + 1 < w) {\n\t\t\tDice d = dice;\n\t\t\td.east();\n\t\t\tif (f[y][x + 1] - '0' == 7 - d.top && !vis[y][x + 1][7 - d.top - 1][d.front - 1][d.r - 1]) {\n\t\t\t\tvis[y][x + 1][7 - d.top - 1][d.front - 1][d.r - 1] = true;\n\t\t\t\tq.emplace(y, x + 1, 7 - d.top - 1, d.front - 1, d.r - 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<typename T> T gcd(T a,T b){return b?gcd(b,a%b):a;}\nconst LL mod=998244353;\nconst LL LINF=1LL<<62;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0,1,-1,1,-1};\nint dy[]={0,1,0,-1,1,-1,-1,1};\n\nstruct Dice\n{\n    //int x, y;\n    int l, r, f, b, d, u;\n\n    void RollN()\n    {\n        //  --y;\n        int buff = d;\n        d = f;\n        f = u;\n        u = b;\n        b = buff;\n    }\n\n    void RollS()\n    {\n        // ++y;\n        int buff = d;\n        d = b;\n        b = u;\n        u = f;\n        f = buff;\n    }\n\n    void RollL() // ----->\n    {\n        int buff = f;\n        f = l;\n        l = b;\n        b = r;\n        r = buff;\n    }\n\n    void RollR() // <------\n    {\n        int buff = f;\n        f = r;\n        r = b;\n        b = l;\n        l = buff;\n    }\n\n    void RollE() // .o -> o.\n    {\n        // --x;\n        int buff = d;\n        d = l;\n        l = u;\n        u = r;\n        r = buff;\n    }\n\n\n    void RollW() // o. -> .o\n    {\n        //  ++x;\n        int buff = d;\n        d = r;\n        r = u;\n        u = l;\n        l = buff;\n    }\n\n\n    vector< Dice > makeDice()\n    {\n        vector< Dice > ret;\n        for(int i = 0; i < 6; i++) {\n            Dice d(*this);\n            if(i == 1) d.RollN();\n            if(i == 2) d.RollS();\n            if(i == 3) d.RollS(), d.RollS();\n            if(i == 4) d.RollL();\n            if(i == 5) d.RollR();\n            for(int j = 0; j < 4; j++) {\n                ret.emplace_back(d);\n                d.RollE();\n            }\n        }\n        return (ret);\n    }\n};\n\nint h,w;\nvector<string> s(100);\nbool vis[100][100];\n\nbool dfs(int y,int x,Dice dice){\n    if(y == h - 1 && x == w - 1) return true;\n    if(vis[y][x]) return false;\n    vis[y][x] = true;\n    for (int i = 0; i < 4; i++) {\n        int ny = y + dy[i], nx = x + dx[i];\n        if(0<=ny&&ny<h&&0<=nx&&nx<w){\n            Dice ndice = dice;\n            if(i == 0) ndice.RollW();\n            if(i == 1) ndice.RollN();\n            if(i == 2) ndice.RollE();\n            if(i == 3) ndice.RollS();\n            if(ndice.d == s[ny][nx] - '0' && dfs(ny, nx, ndice)) return true;\n        }\n    }\n    return false;\n}\n\nint main(){\n    cin >> h >> w;\n    for (int i = 0; i < h; i++) {\n        cin >> s[i];\n    }\n    Dice dice;\n    dice.d = 6;\n    dice.u = 1;\n    dice.r = 3;\n    dice.l = 4;\n    dice.f = 2;\n    dice.b = 5;\n    if(dfs(0,0,dice)) puts(\"YES\");\n    else puts(\"NO\");\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pii;\ntypedef long double D;\n//typedef complex<D> P;\n#define F first\n#define S second\nconst ll MOD=1000000007;\n//const ll MOD=998244353;\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){int i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\n\nvector<int> uft;\n\nint parent(int a){return uft[a]==a?a:uft[a]=parent(uft[a]);}\n\nvoid merge(int a,int b){uft[parent(a)]=parent(b);}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int H,W;\n  cin>>H>>W;\n  vector<string> A(H);\n  cin>>A;\n  vector<string> C={{'6','3','1','4'},{'2','#','2','#'},{'1','3','6','4'},{'5','#','5','#'}};\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(A[i][j]!=C[i%4][j%4]){A[i][j]='#';}\n    }\n  }\n  uft.resize(H*W);\n  for(int i=0;i<H*W;i++){uft[i]=i;}\n  vector<int> dx={1,0,-1,0};\n  vector<int> dy={0,1,0,-1};\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      for(int k=0;k<4;k++){\n        int x=i+dx[k],y=j+dy[k];\n        if(0<=x && x<H && 0<=y && y<W && A[i][j]!='#' && A[x][y]!='#'){merge(x*W+y,i*W+j);}\n      }\n    }\n  }\n  cout<<(parent(H*W-1)==parent(0)?\"YES\":\"NO\")<<endl;\n  \n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\ntypedef long long int ll;\nusing ll = long long int;\nusing ull = long long unsigned int;\nusing Int = long long int;\nusing Double = long double;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\nstruct BFS01 {\n    struct edge {\n        ll to, cost;\n    };\n    typedef pair<ll, ll> P;//firstは最短距離、secondは頂点の番号\n\n    int V;//超点数\n    vector<vector<edge> > G;//グラフ,G[i]はiから出る辺の集合,G[i][j]はiから出る辺のj番目の辺\n    vector<ll> d; //最短距離\n\n    BFS01(int N) {\n        V = N;\n        G.resize(N);\n        d = vector<ll>(N);\n    };\n\n    void addEdge(int from, int to, int cost) {\n        edge e;\n        e.to = to;\n        e.cost = cost;\n        G[from].push_back(e);\n    }\n\n    void calc(int s) {\n//        priority_queue<P,vector<P>,greater<P> > que;\n        deque<P> que;\n        fill(d.begin(), d.end(), INFl);\n        d[s] = 0;\n        que.push_back(P(0, s));\n\n        while (!que.empty()) {\n            P p = que.front();\n            que.pop_front();\n            ll v = p.second;\n            if (d[v] < p.first) continue;\n            for (int i = 0; i < G[v].size(); i++) {\n                edge e = G[v][i];\n                if (d[e.to] > d[v] + e.cost && !(d[e.to] == INFl && d[v] == INFl)) {\n                    d[e.to] = d[v] + e.cost;\n                    if (e.cost == 0) {\n                        que.push_front(P(d[e.to], e.to));\n                    } else {\n                        que.push_back(P(d[e.to], e.to));\n                    }\n                }\n            }\n        }\n\n    }\n};\n\n\n//edit\nconst int TOP = 0;\nconst int FRONT = 1;\nconst int RIGHT = 2;\nconst int LEFT = 3;\nconst int BACK = 4;\nconst int BOTTOM = 5;\nvector<vector<Int>> rot(720, vector<Int>(6));\nvector<vector<Int>> dices;\n\nvector<Int> hash_d(Int hash) {\n    vector<Int> rest = {1, 2, 3, 4, 5, 6};\n    vector<Int> ret;\n    Int base = 120;\n\n    for (int i = 0; i < 6; ++i) {\n//        ret.push_back(1 + hash / base);\n        ret.push_back(rest[hash / base]);\n        rest.erase(rest.begin() + hash / base);\n\n\n        hash %= base;\n        if ((5 - i) > 0) {\n            base /= 5 - i;\n        }\n    }\n\n    return ret;\n}\n\nInt fact(Int n) {\n    if (n > 0) return fact(n - 1) * n;\n    return 1;\n}\n\nInt d_hash(vector<Int> d) {\n    if (d.size() == 1) {\n        return 0;\n    }\n    //今ある数字が何番目に小さいか\n    Int cnt = 0;\n    Int base = fact(static_cast<Int>(d.size()) - 1);\n\n    for (auto e : d) {\n        if (e < d[0]) cnt++;\n    }\n    Int ret = cnt * base;\n    d.erase(d.begin());\n    ret += d_hash(d);\n\n    return ret;\n//    Int ret = 0;\n//    Int base = 1;\n//    for (int i = 0; i < 6; ++i) {\n//        Int tmp = base * (d[5 - i] - 1);\n//        ret += tmp;\n//\n//        base *= (i + 1);\n//    }\n//\n//    return ret;\n}\n\nInt rot_any(Int hash, vector<Int> dir) {\n    vector<Int> dice = hash_d(hash);\n    vector<Int> val;\n    for (auto e : dir) val.push_back(dice[e]);\n    rotate(val.begin(), val.begin() + 1, val.end());\n    vector<Int> new_dice = dice;\n\n//    for (int i = 0, ii = 0; i < 6; ++i) {\n//        if (ii < 4 && i == dir[ii]) {\n//            new_dice[i] = val[dir[ii]];\n//            ii++;\n//        }\n//    }\n\n    for (int i = 0; i < 4; ++i) {\n        int j = (i + 1) % 4;\n\n        new_dice[dir[i]] = dice[dir[j]];\n    }\n\n    return d_hash(new_dice);\n}\n\nInt rot_R(Int hash) {\n//    vector<Int> dice = hash_d(hash);\n    vector<Int> dir = {TOP, LEFT, BOTTOM, RIGHT};\n//    vector<Int> val;\n//    for (auto e : idx) val.push_back(dice[e]);\n//    rotate(val.begin(), val.begin() + 1, val.end());\n//    vector<Int> new_dice = dice;\n//\n//    for (int i = 0, ii = 0; i < 6; ++i) {\n//        if (ii < 4 && i == idx[ii]) {\n//            new_dice[i] = idx[ii];\n//            ii++;\n//        }\n//    }\n//\n//    return d_hash(new_dice);\n\n    return rot_any(hash, dir);\n}\n\nInt rot_L(Int hash) {\n    vector<Int> dir = {TOP, RIGHT, BOTTOM, LEFT};\n    return rot_any(hash, dir);\n}\n\nInt rot_F(Int hash) {\n    vector<Int> dir = {TOP, BACK, BOTTOM, FRONT};\n    return rot_any(hash, dir);\n}\n\nInt rot_B(Int hash) {\n    vector<Int> dir = {TOP, FRONT, BOTTOM, BACK};\n    return rot_any(hash, dir);\n}\n\nvoid print_vec(vector<Int> v) {\n    for (auto e : v) cout << e << \" \";\n    cout << endl;\n}\n\nclass Solve {\npublic:\n    void init() {\n        vector<Int> dice = {1, 2, 3, 4, 5, 6};\n        do {\n            Int hash = d_hash(dice);\n            rot[hash][RIGHT] = rot_R(hash);\n            rot[hash][LEFT] = rot_L(hash);\n            rot[hash][FRONT] = rot_F(hash);\n            rot[hash][BACK] = rot_B(hash);\n            dices.push_back(dice);\n        } while (next_permutation(all(dice)));\n\n\n    }\n\n    void solve() {\n        init();\n\n        Int H, W;\n        cin >> H >> W;\n\n        vector<string> S(H);\n        for (int i = 0; i < H; ++i) cin >> S[i];\n\n        auto get_cell = [&](Int hash, Int h, Int w) -> Int {\n            return w + (W * h) + (W * H * hash);\n        };\n\n        auto i_get_cell = [&](Int tapu) {\n            Int w = tapu % W;\n            Int h = ((tapu - w) / W) % H;\n            Int hash = (tapu - w - W * h) / (W * H);\n            return make_tuple(hash, h, w);\n        };\n\n\n//        BFS01 neri(W * H * 720);\n        queue<Int> que;\n        vector<vector<vector<bool>>> tapi(720, vector<vector<bool>>(H, vector<bool>(W, false)));\n        tapi[0][0][0] = true;\n        que.push(get_cell(0, 0, 0));\n\n        while (!que.empty()) {\n            Int val = que.front();\n            que.pop();\n            Int h, w, hash;\n            tie(hash, h, w) = i_get_cell(val);\n\n            vector<Int> dh = {0, 1, 0, -1};\n            vector<Int> dw = {1, 0, -1, 0};\n            for (int k = 0; k < 4; ++k) {\n                Int nh = h + dh[k];\n                Int nw = w + dw[k];\n                if (!(nh >= 0 && nh < H && nw >= 0 && nw < W)) continue;\n\n                vector<Int> next_dice;\n                if (k == 0) {\n                    //右へ転がす\n//                            next_dice = hash_d(rot_R(hash));\n//                            next_dice = hash_d(rot[hash][RIGHT]);\n                    next_dice = dices[rot[hash][RIGHT]];\n                } else if (k == 1) {\n//                            next_dice = hash_d(rot[hash][FRONT]);\n                    next_dice = dices[rot[hash][FRONT]];\n                } else if (k == 2) {\n//                            next_dice = hash_d(rot[hash][LEFT]);\n                    next_dice = dices[rot[hash][LEFT]];\n                } else {\n//                            next_dice = hash_d(rot[hash][BACK]);\n                    next_dice = dices[rot[hash][BACK]];\n                }\n\n                Int next_hash = d_hash(next_dice);\n\n                //底面が条件に合わなければ飛ばす\n                if (next_dice[BOTTOM] + '0' != S[h + dh[k]][w + dw[k]]) {\n                    continue;\n                }\n\n//                        neri[get_cell(h,w,hash)][]\n//                neri.addEdge(get_cell(hash, h, w), get_cell(next_hash, nh, nw), 1);\n                if (!tapi[next_hash][nh][nw]) {\n                    tapi[next_hash][nh][nw] = true;\n                    que.push(get_cell(next_hash, nh, nw));\n                }\n            }\n        }\n\n//        for (int h = 0; h < H; ++h) {\n//            for (int w = 0; w < W; ++w) {\n//                for (int hash = 0; hash < 720; ++hash) {\n//                    //底面がS[h][w]となるものをすべて転がす\n////                    if (h == 1 && w == 0 && hash == 489) {\n////                        int ei = 13 + 33;\n////                    }\n//\n//                    vector<Int> dice = hash_d(hash);\n//\n//                    //底面が条件に合わなければ飛ばす\n//                    if (dice[BOTTOM] + '0' != S[h][w]) continue;\n//\n//                    vector<Int> dh = {0, 1, 0, -1};\n//                    vector<Int> dw = {1, 0, -1, 0};\n//\n//                    for (int k = 0; k < 4; ++k) {\n//                        Int nh = h + dh[k];\n//                        Int nw = w + dw[k];\n//                        if (!(nh >= 0 && nh < H && nw >= 0 && nw < W)) continue;\n//\n//                        vector<Int> next_dice;\n//                        if (k == 0) {\n//                            //右へ転がす\n////                            next_dice = hash_d(rot_R(hash));\n////                            next_dice = hash_d(rot[hash][RIGHT]);\n//                            next_dice = dices[rot[hash][RIGHT]];\n//                        } else if (k == 1) {\n////                            next_dice = hash_d(rot[hash][FRONT]);\n//                            next_dice = dices[rot[hash][FRONT]];\n//                        } else if (k == 2) {\n////                            next_dice = hash_d(rot[hash][LEFT]);\n//                            next_dice = dices[rot[hash][LEFT]];\n//                        } else {\n////                            next_dice = hash_d(rot[hash][BACK]);\n//                            next_dice = dices[rot[hash][BACK]];\n//                        }\n//\n//                        Int next_hash = d_hash(next_dice);\n//\n//                        //底面が条件に合わなければ飛ばす\n//                        if (next_dice[BOTTOM] + '0' != S[h + dh[k]][w + dw[k]]) {\n//                            continue;\n//                        }\n//\n////                        neri[get_cell(h,w,hash)][]\n//                        neri.addEdge(get_cell(hash, h, w), get_cell(next_hash, nh, nw), 1);\n//                    }\n//                }\n//            }\n//        }\n\n//        neri.calc(get_cell(0, 0, 0));\n\n//        if (!true) {\n//            while (true) {\n//                Int tmp = 0;\n//                cin >> tmp;\n//                if (tmp == -1) break;\n//\n//                for (auto e : neri.G[tmp]) {\n//                    Int tapu = e.to;\n//                    Int w = tapu % W;\n//                    Int h = ((tapu - w) / W) % H;\n//                    Int hash = (tapu - w - W * h) / (W * H);\n//                    cout << e.to << endl;\n//                    cout << hash << \" \" << w << \" \" << h << endl;\n//                }\n//            }\n//        }\n\n        for (int i = 0; i < 720; ++i) {\n//            if (neri.d[get_cell(i, H - 1, W - 1)] != INFl) {\n            if (tapi[i][H - 1][W - 1]) {\n\n                cout << \"YES\" << endl;\n                return;\n            }\n        }\n\n\n        cout << \"NO\" << endl;\n    }\n\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    Solve().solve();\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"base.hpp\"//2\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve(\n#ifdef GCJ_CASE\nlong long case_id\n#endif\n);\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n#define debug true\n#define _GLIBCXX_DEBUG\n// #define _LIBCPP_DEBUG 0\n#define _LIBCPP_DEBUG2 0\n#else\n#define NDEBUG\n#define debug false\n#endif\n#include<algorithm>\n#include<bitset>\n#include<functional>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<type_traits>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL\n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define rep(f,t,i,c,u)for(int Rb_=(t),i=(f);i c Rb_;u(i))\n#define upto(f,t,i)rep(f,t,i,<=,++)\n#define uptil(f,t,i)rep(f,t,i,<,++)\n#define downto(f,t,i)rep(f,t,i,>=,--)\n#define downtil(f,t,i)rep(f,t,i,>,--)\n#define times(n,i)uptil(0,n,i)\n#define rtimes(n,i)downto((n)-1,0,i)\n#define iter(v)begin(v),end(v)\n#define citer(v)cbegin(v),cend(v)\n#define riter(v)rbegin(v),rend(v)\n#define criter(v)crbegin(v),crend(v)\n#define IF(a,b,c)((a)?(b):(c))\n#if debug\n#define ln <<endl\n#else\n#define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n#line 1 \"base_util.hpp\"//2b\n#define BINOPa(t,u,op)t OP op(CS u&o)CS{RT t(*this)op##=o;}\n#define CMPOP(t,op,f1,f2,x)bool OP op(CS t&x)CS{RT f1 op f2;}\n#define CMPOPS(t,f1,f2,x)CMPOP(t,==,f1,f2,x)CMPOP(t,!=,f1,f2,x)\\\nCMPOP(t,<,f1,f2,x)CMPOP(t,<=,f1,f2,x)CMPOP(t,>,f1,f2,x)CMPOP(t,>=,f1,f2,x)\n#line 1 \"mod.hpp\"//2b\n#ifndef MOD\n#define MOD 1000000007\n#endif\n#if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n#error mod\n#endif\n#line 1 \"power.hpp\"//2bm\nTL<TN T>IL T power(T x,int n){T r(1);for(;n;n/=2){if(n%2)r*=x;x*=x;}RT r;}IL int pow_mod(int x,int n,int m){int r=1;\nfor(;n;n/=2){if(n%2)r=r*x%m;x=x*x%m;}RT r;}\n#line 2001 \"mod.hpp\"//2b\nIL CX int modulo(int a,int b){a%=b;RT a&&(a>0)!=(b>0)?a+b:a;}IL CX int divide(int a,int b){RT(a-modulo(a,b))/b;}\nTL<int d=MOD>struct MInt{\n/*!https://ei1333.github.io/luzhiled/snippets/other/mod-int.html*/\nint v;CX MInt():v(0){}explicit CX MInt(int i):v(modulo(i,d)){}MInt&OP+=(CS MInt&m){v+=m.v;if(v>=d)v-=d;RT*this;}\nMInt&OP-=(CS MInt&m){v-=m.v;if(v<0)v+=d;RT*this;}MInt&OP*=(CS MInt&m){v=v*m.v%d;RT*this;}MInt&OP/=(CS MInt&m){\nRT*this*=m.inv();}BINOPa(MInt,MInt,+)BINOPa(MInt,MInt,-)BINOPa(MInt,MInt,*)BINOPa(MInt,MInt,/)MInt OP-()CS{\nRT MInt()-=*this;}CMPOP(MInt,==,v,m.v,m)CMPOP(MInt,!=,v,m.v,m)MInt pow(int n)CS{RT power(*this,n);}MInt inv()CS{\nint a=v,b=d,x=1,y=0;while(b){swap(y,x-=a/b*y);swap(b,a%=b);}RT(MInt)x;}\nfriend ostream&OP<<(ostream&o,CS MInt&m){RT o<<m.v;}friend istream&OP>>(istream&i,MInt&m){i>>m.v;m.v%=d;RT i;}};\nusing mint=MInt<>;CX mint OP\"\" _m(ULL n){RT mint(n);}CX MInt<998244353>OP\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nCX MInt<1000000007>OP\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nCX MInt<1000000009>OP\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n#line 1 \"typedefs.hpp\"//2b\nusing unit = tuple<>;using LD=long double;TL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;TL<TN T>using vvvec=vec<vvec<T>>;TL<TN T>using vvvvec=vec<vvvec<T>>;\nusing VS=vec<string>;using TIII=tuple<int, int, int>;\n#line 1 \"alias.hpp\"//2b\n#define EB emplace_back\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n#line 1 \"util.hpp\"//2b\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,1);}TL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,1);}\nTL<TN T>IL int sizeRAB(T t){RT t.size();}\n#define size sizeRAB\n#define clamp clampRAB\nTL<TN T>IL CX CS T&clamp(CS T&a,CS T&l,CS T&r){RT a<l?l:r<a?r:a;}TL<TN V>IL void uniq2(V&v){\nv.erase(unique(iter(v)),v.end());}TL<TN V>IL void uniq(V&v){sort(iter(v));uniq2(v);}\n#define leftmost_ge lower_bound\n#define leftmost_gt upper_bound\nTL<TN C,TN D>IL C rightmost_le(CS C&from,CS C&to,CS D&d){auto l=leftmost_gt(from,to,d);RT l==from?to:--l;}\nTL<TN C,TN D>IL C rightmost_lt(CS C&from,CS C&to,CS D&d){auto l=leftmost_ge(from,to,d);RT l==from?to:--l;}\nnamespace rab{TL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}TL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){\nRT 0<=i&&i<size(v)?v[i]:d;}}\n#line 1 \"debug.hpp\"//2b\nTL<TN T>IL istream&OP>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}TL<TN T,TN S>\nIL ostream&OP<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\n#define Rdebug1(sep, ...)IL ostream& OP<<(ostream&s,CS __VA_ARGS__&v){\\\nint i=0;for(CS auto&e:v){i++&&s<<sep;s<<e;}RT s;}\nTL<TN T>Rdebug1(' ',vec<T>)TL<TN T,TN S>Rdebug1(' ',map<T,S>)TL<TN T>Rdebug1('\\n',vvec<T>)\nTL<TN T,TN S>Rdebug1('\\n',vec<map<T,S>>)\n#line 6001 \"base.hpp\"//2\nsigned main(){if(debug)cerr<<\"MOD: \"<<MOD ln;else cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\nauto p=setprecision(20);cout<<fixed<<p;cerr<<fixed<<p;\n#ifdef GCJ_CASE\nint T;cin>>T;times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n#else\nsolve();\n#endif\nRT 0;}\n#line 1 \"consts.hpp\"//2\nint di4[]={-1,0,1,0},dj4[]={0,1,0,-1},di8[]={-1,-1,0,1,1,1,0,-1},dj8[]={0,1,1,1,0,-1,-1,-1,-1},\ndi_knight[]={-2,-1,1,2,2,1,-1,-2},dj_knight[]={1,2,2,1,-1,-2,-2,-1};namespace dict{\nCX char\nYES[]=\"YES\",Yes[]=\"Yes\",yes[]=\"yes\",NO[]=\"NO\",No[]=\"No\",no[]=\"no\",WIN[]=\"WIN\",Win[]=\"Win\",win[]=\"win\",\nLOSE[]=\"LOSE\",Lose[]=\"Lose\",lose[]=\"lose\",OK[]=\"OK\",ok[]=\"ok\",NG[]=\"NG\",ng[]=\"ng\",NA[]=\"NA\",na[]=\"na\",\nAC[]=\"AC\",ac[]=\"ac\",WA[]=\"WA\",wa[]=\"wa\",FIRST[]=\"FIRST\",First[]=\"First\",first[]=\"first\",\nSECOND[]=\"SECOND\",Second[]=\"Second\",second[]=\"second\",\nPOSSIBLE[]=\"POSSIBLE\",Possible[]=\"Possible\",possible[]=\"possible\",\nIMPOSSIBLE[]=\"IMPOSSIBLE\",Impossible[]=\"Impossible\",impossible[]=\"impossible\",\nPRIME[]=\"PRIME\",Prime[]=\"Prime\",prime[]=\"prime\",\nNOT_PRIME[]=\"NOT PRIME\",Not_Prime[]=\"Not Prime\",not_prime[]=\"not prime\",\nUNBOUNDED[]=\"UNBOUNDED\",Unbounded[]=\"Unbounded\",unbounded[]=\"unbounded\",\nALICE[]=\"ALICE\",Alice[]=\"Alice\",alice[]=\"alice\",BOB[]=\"BOB\",Bob[]=\"Bob\",bob[]=\"bob\",\nBROWN[]=\"BROWN\",Brown[]=\"Brown\",brown[]=\"brown\",SAME[]=\"SAME\",Same[]=\"Same\",same[]=\"same\",\nDIFFERENT[]=\"DIFFERENT\",Different[]=\"Different\",different[]=\"different\",\nTAKAHASHI[]=\"TAKAHASHI\",Takahashi[]=\"Takahashi\",takahashi[]=\"takahashi\",AOKI[]=\"AOKI\",Aoki[]=\"Aoki\",aoki[]=\"aoki\";}\n#line 2001 \"2.cpp\"//\n\n#define split(dice) \\\n  int t = dice & 7, b = (dice >> 3) & 7, n = (dice >> 6) & 7, s = (dice >> 9) & 7, w = (dice >> 12) & 7, e = (dice >> 15) & 7; \\\n  assert(t + b == 7 && n + s == 7 && w + e == 7)\n\ninline int make(int t, int b, int n, int s, int w, int e) {\n  return t | (b << 3) | (n << 6) | (s << 9) | (w << 12) | (e << 15);\n}\n\nint flip(int dice) {\n  return (7 | 7 << 3 | 7 << 6 | 7 << 9 | 7 << 12 | 7 << 15) - dice;\n}\n\nint goSouth(int dice) {\n  split(dice);\n  return make(n, s, b, t, w, e);\n}\n\nint goNorth(int dice) {\n  split(dice);\n  return make(s, n, t, b, w, e);\n}\n\nint goWest(int dice) {\n  split(dice);\n  return make(e, w, n, s, t, b);\n}\n\nint goEast(int dice) {\n  split(dice);\n  return make(w, e, n, s, b, t);\n}\n\nvoid solve() {\n  int H, W; cin >> H >> W;\n  VS S(H); times(H, i) cin >> S[i];\n\n  queue<TIII> q; q.push(TIII(0, 0, make(1, 6, 5, 2, 4, 3)));\n  map<TIII, bool> ok;\n\n  while(!q.empty()) {\n    int i, j, dice; tie(i, j, dice) = q.front(); q.pop();\n    if(ok[(TIII(i, j, dice))]) continue;\n    ok[(TIII(i, j, dice))] = true;\n    if(i == H-1 && j == W-1) {\n      cout << \"YES\" ln;\n      return;\n    }\n    times(4, d) {\n      int ii = i + di4[d], jj = j + dj4[d];\n      int nd = d == 0 ? goNorth(dice) : d == 1 ? goEast(dice) : d == 2 ? goSouth(dice) : goWest(dice);\n\n      if(0 <= ii && ii < H && 0 <= jj && jj < W &&\n         ((nd >> 3) & 7) + '0' == S[ii][jj] && !ok[(TIII(ii, jj, nd))]) {\n        q.push(TIII(ii, jj, nd));\n      }\n    }\n  }\n\n  cout << \"NO\" ln;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct dsu {\n  int cc;\n  vector<int> p, sz;\n  dsu(int n = 0) : cc(n), p(n, -1), sz(n, 1) {}\n  int root(int v) const {\n    while (p[v] != -1) v = p[v];\n    return v;\n  }\n  bool unite(int u, int v) {\n    u = root(u), v = root(v);\n    if (u == v) return false;\n    --cc;\n    if (sz[u] < sz[v]) swap(u, v);\n    p[v] = u;\n    sz[u] += sz[v];\n    return true;\n  }\n  bool same(int u, int v) const { return root(u) == root(v); }\n  int size(int v) const { return sz[root(v)]; }\n};\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int h, w;\n  cin >> h >> w;\n  vector<string> s(h);\n  for (auto&& e : s) {\n    cin >> e;\n  }\n  dsu d(h * w);\n  auto $ = [&](int i, int j) {\n    return i * w + j;\n  };\n  vector<string> t{\"6314\", \"2.2.\", \"1364\", \"5.5.\"};\n  auto chk = [&](int i, int j) {\n    return s[i][j] == t[i % 4][j % 4];\n  };\n  for (int i = 0; i < h; ++i) {\n    for (int j = 0; j < w; ++j) {\n      if (i + 1 < h and chk(i, j) and chk(i + 1, j)) {\n        d.unite($(i, j), $(i + 1, j));\n      }\n      if (j + 1 < w and chk(i, j) and chk(i, j + 1)) {\n        d.unite($(i, j), $(i, j + 1));\n      }\n    }\n  }\n  if (d.same($(0, 0), $(h - 1, w - 1))) {\n    cout << \"YES\\n\";\n  } else {\n    cout << \"NO\\n\";\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n//const ull mod = 1e9 + 7;\nconst ll mod = 1e9 + 7;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\n// debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){\n  os << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<T> v){\n  for(int i = 0; i < (int)v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<vector<T>> v){\n  for(int i = 0; i < (int)v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\n// conversion number to bit\nstring num2bit(ll num, ll len){\n  string bit = \"\";\n  REP(i, len){\n    bit += char('0'+(num>>i & 1));\n  }\n  return bit;\n}\n\nvector<ll> dx = {1, 0, -1, 0};\nvector<ll> dy = {0, 1, 0, -1};\n\nbool check[105][105];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n \tll H, W;\n \tcin >> H >> W;   \n\n \tvector<string> S(H);\n \tREP(i, H) cin >> S[i];\n\n \tREP(i, 105)REP(j, 105) check[i][j] = false;\n\n \tqueue<pll> qu;\n \tqu.push({0, 0});\n \tcheck[0][0] = true;\n \twhile(!qu.empty()){\n \t\tpll tmp = qu.front();\n \t\tqu.pop();\n \t\tREP(i, 4){\n \t\t\tll nx = tmp.first + dx[i];\n \t\t\tll ny = tmp.second + dy[i];\n \t\t\tif(nx<0) continue;\n \t\t\tif(nx>H-1) continue;\n \t\t\tif(ny<0) continue;\n \t\t\tif(ny>W-1) continue;\n \t\t\tif(!check[nx][ny]){\n\n \t\t\t\tbool ok = false;\n \t\t\t\tif(nx%2==0){\n \t\t\t\t\tif(ny%2==0){\n \t\t\t\t\t\tif((nx+ny)%4==0){\n \t\t\t\t\t\t\tif(S[nx][ny] == '6') ok = true;\n \t\t\t\t\t\t}else{\n \t\t\t\t\t\t\tif(S[nx][ny] == '1') ok = true;\n \t\t\t\t\t\t}\n \t\t\t\t\t}else{\n \t\t\t\t\t\tif((ny)%4==1){\n \t\t\t\t\t\t\tif(S[nx][ny] == '3') ok = true;\n \t\t\t\t\t\t}else{\n \t\t\t\t\t\t\tif(S[nx][ny] == '4') ok = true;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}else{\n \t\t\t\t\tif((nx)%4==1){\n\t\t\t\t\t\tif(S[nx][ny] == '2') ok = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(S[nx][ny] == '5') ok = true;\n\t\t\t\t\t}\n \t\t\t\t}\n\n \t\t\t\tif(ok){\n \t\t\t\t\tqu.push({nx, ny});\n \t\t\t\t\tcheck[nx][ny] = true;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \tcout << (check[H-1][W-1] ? \"YES\" : \"NO\") << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <numeric>\n#include <functional>\n#include <cctype>\n#include <list>\n#include <limits>\n#include <cassert>\n#include <random>\n#include <time.h>\n#include <unordered_set>\n\nusing namespace std;\nusing Int = long long;\n\nconstexpr double EPS = 1e-10;\nconstexpr long long MOD = 1000000007;\n\nlong long mod_pow(long long x, long long n) {\n    long long res = 1;\n    for (int i = 0;i < 60; i++) {\n        if (n >> i & 1) res = res * x % MOD;\n        x = x * x % MOD;\n    }\n    return res;\n}\n\nlong long my_mod_pow(long long x, long long n) {\n\tlong long ret = 1;\n\tfor (; n > 0; n >>= 1, x = x * x % MOD) {\n\t\tif (n & 1) {\n\t\t\tret = ret * x % MOD;\n\t\t}\n\t}\n\treturn ret;\n}\n\ntemplate<typename T>\nT gcd(T a, T b) {\n    return b != 0 ? gcd(b, a % b) : a;\n}\n\ntemplate<typename T>\nT lcm(T a, T b) {\n    return a * b / gcd(a, b);\n}\n\nvoid fastInput() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n}\n\nint can_move[10][10] = {{6, 3, 1, 4},\n                        {2, 0, 2, 0},\n                        {1, 3, 6, 4},\n                        {5, 0, 5, 0}\n                        };\n\nint main(void) {\n    vector<vector<int>> field(105, vector<int>(105, -1));\n    int H, W; cin >> H >> W;\n    for (int i = 1; i <= H; i++) {\n        for (int j = 1; j <= W; j++) {\n            char c; cin >> c;\n            if (c == '#') field[i][j] = -1;\n            else field[i][j] = c - '0';\n        }\n    }\n\n    vector<vector<int>> reachable_cell(105, vector<int>(105));\n    reachable_cell[1][1] = 1;\n    int dh[] = {1, 0, -1, 0};\n    int dw[] = {0, 1, 0, -1};\n    queue<pair<int, int>> q;\n    q.push({1, 1});\n    while (!q.empty()){\n        auto crt = q.front();\n        q.pop();\n        int h = crt.first;\n        int w = crt.second;\n\n        for (int k = 0; k < 4; k++) {\n            int next_h = h + dh[k];\n            int next_w = w + dw[k];\n            if (reachable_cell[next_h][next_w] == 1 || field[next_h][next_w] == -1) continue;\n            if (can_move[(next_h-1)%4][(next_w-1)%4] == field[next_h][next_w]) {\n                reachable_cell[next_h][next_w] = 1;\n                q.push({next_h, next_w});\n            }\n        }\n    }\n    if (reachable_cell[H][W]) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;   \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nstruct dice{ int a[6]; };\nvoid rot(int &a,int &b,int &c,int &d){ int tmp=a; a=b; b=c; c=d; d=tmp; }\nvoid roll_f(dice &d){ rot(d.a[0],d.a[3],d.a[2],d.a[1]); }\nvoid roll_b(dice &d){ rot(d.a[0],d.a[1],d.a[2],d.a[3]); }\nvoid roll_l(dice &d){ rot(d.a[3],d.a[5],d.a[1],d.a[4]); }\nvoid roll_r(dice &d){ rot(d.a[3],d.a[4],d.a[1],d.a[5]); }\n\nbool vis[101][101][7][7][7]; // 0,3,5\n\nstruct state{\n\tint i,j;\n\tdice d;\n};\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int h,w;\n  cin>>h>>w;\n\n  vector<string> b(h);\n  rep(i,h)cin>>b[i];\n\n  dice ini;\n  ini.a[0]=2; ini.a[1]=6; ini.a[2]=5; ini.a[3]=1; ini.a[4]=4; ini.a[5]=3;\n  queue<state> que;\n  que.push((state){0,0,ini});\n  vis[0][0][ini.a[0]][ini.a[3]][ini.a[5]]=true;\n  while(que.size()){\n  \tstate s=que.front(); que.pop();\n  \tdice crt=s.d;\n  \tint i=s.i,j=s.j;\n  \tif(i+1<h&&b[i+1][j]!='#'){\n  \t\troll_f(crt);\n  \t\tif(crt.a[1]==b[i+1][j]-'0'&&!vis[i+1][j][crt.a[0]][crt.a[3]][crt.a[5]]){\n  \t\t\tvis[i+1][j][crt.a[0]][crt.a[3]][crt.a[5]]=true;\n  \t\t\tque.push((state){i+1,j,crt});\n  \t\t}\n  \t\troll_b(crt);\n  \t}\n  \tif(i-1>=0&&b[i-1][j]!='#'){\n  \t\troll_b(crt);\n  \t\tif(crt.a[1]==b[i-1][j]-'0'&&!vis[i-1][j][crt.a[0]][crt.a[3]][crt.a[5]]){\n  \t\t\tvis[i-1][j][crt.a[0]][crt.a[3]][crt.a[5]]=true;\n  \t\t\tque.push((state){i-1,j,crt});\n  \t\t}\n  \t\troll_f(crt);\n  \t}\n  \tif(j+1<w&&b[i][j+1]!='#'){\n  \t\troll_r(crt);\n  \t\tif(crt.a[1]==b[i][j+1]-'0'&&!vis[i][j+1][crt.a[0]][crt.a[3]][crt.a[5]]){\n  \t\t\tvis[i][j+1][crt.a[0]][crt.a[3]][crt.a[5]]=true;\n  \t\t\tque.push((state){i,j+1,crt});\n  \t\t}\n  \t\troll_l(crt);\n  \t}\n  \tif(j-1>=0&&b[i][j-1]!='#'){\n  \t\troll_l(crt);\n  \t\tif(crt.a[1]==b[i][j-1]-'0'&&!vis[i][j-1][crt.a[0]][crt.a[3]][crt.a[5]]){\n  \t\t\tvis[i][j-1][crt.a[0]][crt.a[3]][crt.a[5]]=true;\n  \t\t\tque.push((state){i,j-1,crt});\n  \t\t}\n  \t\troll_r(crt);\n  \t}\n  }\n\n  bool res=false;\n  rep(x,7)rep(y,7)rep(z,7){\n  \tres|=vis[h-1][w-1][x][y][z];\n  }\n  if(res)cout<<\"YES\"<<endl;\n  else cout<<\"NO\"<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nconst ll INF=1LL<<60;\nint h,w;\nconst int nmax=102;\nchar c[nmax][nmax];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint p[4][6]={{1,5,2,3,0,4},{2,1,5,0,4,3},{3,1,0,5,4,2},{4,0,2,3,5,1}};\nbool vis[nmax][nmax];\nbool bfs(int i,int j,vector<int> a){\n    vis[i][j]=true;\n    if(i==h-1&&j==w-1){\n        return true;\n    }\n    bool f=false;\n    vector<int> r(6);\n    for(int l=0;l<4;l++){\n        int x=i+dx[l],y=j+dy[l];\n        if(x<0||x>h-1||y<0||y>w-1){\n            continue;\n        }\n        if(c[x][y]=='#'||vis[x][y]){\n            continue;\n        }\n        if(c[x][y]-'0'==a[l+1]){\n            for(int s=0;s<6;s++){\n                r[s]=a[p[l][s]];\n            }\n            f=f|bfs(x,y,r);\n        }\n    }\n    return f;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> h >> w;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            cin >> c[i][j];\n        }\n    }\n    vector<int> n(6);\n    for(int i=0;i<6;i++){\n        n[i]=6-i;\n    }\n    if(bfs(0,0,n)){\n        cout << \"YES\" << endl;\n    }\n    else{\n        cout << \"NO\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\ntypedef pair<int, int> P;\n\nint main()\n{\n    int h, w;\n    cin >> h >> w;\n    string s[102];\n    for(int i = 0; i < h; i++) cin >> s[i];\n    bool used[102][102];\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++) used[i][j] = false;\n    }\n    queue<P> que;\n    que.push(P(0, 0));\n    while(que.size()){\n        P p = que.front();\n        que.pop();\n        char r, l, f, b, u;\n        if(p.first % 4){\n            f = '2';\n            b = '5';\n        }\n        else{\n            f = '5';\n            b = '2';\n        }\n        if(p.second % 4){\n            r = '4';\n            l = '3';\n        }\n        else{\n            r = '3';\n            l = '4';\n        }\n        if((p.first + p.second) % 4){\n            u = '6';\n        }\n        else{\n            u = '1';\n        }\n        if(p.first == h - 1 && p.second == w - 1){\n            cout << \"YES\" << endl;\n            return 0;\n        }\n        if(p.first == h - 1 && p.second == w - 2){\n            if(s[p.first][p.second + 1] == r){\n                cout << \"YES\" << endl;\n                return 0;\n            }\n        }\n        if(p.first == h - 2 && p.second == w - 1){\n            if(s[p.first + 1][p.second] == b){\n                cout << \"YES\" << endl;\n                return 0;\n            }\n        }\n        if(p.first + 2 < h && !used[p.first + 2][p.second] && \n           s[p.first + 1][p.second] == b && s[p.first + 2][p.second] == u){\n            used[p.first + 2][p.second] = true;\n            que.push(P(p.first + 2, p.second));\n        }\n        if(p.second + 2 < w && !used[p.first][p.second + 2] &&\n           s[p.first][p.second + 1] == r && s[p.first][p.second + 2] == u){\n            used[p.first][p.second + 2] = true;\n            que.push(P(p.first, p.second + 2));\n        }\n        if(p.first - 2 >= 0 && !used[p.first - 2][p.second] &&\n           s[p.first - 1][p.second] == f && s[p.first - 2][p.second] == u){\n            used[p.first - 2][p.second] = true;\n            que.push(P(p.first - 2, p.second));\n        }\n        if(p.second - 2 < w && !used[p.first][p.second - 2] &&\n           s[p.first][p.second - 1] == l && s[p.first][p.second - 2] == u){\n            used[p.first][p.second - 2] = true;\n            que.push(P(p.first, p.second - 2));\n        }\n    }\n    cout << \"NO\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <bitset>\n#include <random>\n#include <complex>\n#include <assert.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 1LL << 60;\n\ntemplate<typename T>\ninline bool chmin(T& x, T a) {\n\tif (x >= a) { x = a; return true; }\n\treturn false;\n}\n\ntemplate<typename T>\ninline bool chmax(T& x, T a) {\n\tif (x <= a) { x = a; return true; }\n\treturn false;\n}\n\nbool f[100][100];\nbool reach[100][100];\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tconst char table[4][4] = {\n\t\t{'6', '3', '1', '4'},\n\t\t{'2', '0', '2', '0'},\n\t\t{'1', '3', '6', '4'},\n\t\t{'5', '0', '5', '0'}\n\t};\n\t\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\treach[i][j] = false;\n\t\t\tf[i][j] = false;\n\t\t\tchar c; cin >> c;\n\t\t\tf[i][j] = (c == table[i % 4][j % 4]);\n\t\t}\n\t}\n\n\tqueue<pair<int, int>> q;\n\tq.push({ 0,0 });\n\treach[0][0] = true;\n\n\twhile (q.size() != 0) {\n\t\tpair<int, int> p = q.front();\n\t\tq.pop();\n\n\t\tint i = p.first, j = p.second;\n\t\tif (i < H - 1 && f[i + 1][j] == true) {\n\t\t\tif (reach[i + 1][j] == false) {\n\t\t\t\tq.push({ i + 1, j });\n\t\t\t\treach[i + 1][j] = true;\n\t\t\t}\n\t\t}\n\t\tif (i > 0 && f[i - 1][j] == true) {\n\t\t\tif (reach[i - 1][j] == false) {\n\t\t\t\tq.push({ i - 1, j });\n\t\t\t\treach[i - 1][j] = true;\n\t\t\t}\n\t\t}\n\t\tif (j < W - 1 && f[i][j + 1] == true) {\n\t\t\tif (reach[i][j + 1] == false) {\n\t\t\t\tq.push({ i, j + 1 });\n\t\t\t\treach[i][j + 1] = true;\n\t\t\t}\n\t\t}\n\t\tif (j > 0 && f[i][j - 1] == true) {\n\t\t\tif (reach[i][j - 1] == false) {\n\t\t\t\tq.push({ i, j - 1 });\n\t\t\t\treach[i][j - 1] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (reach[H - 1][W - 1] == true) {\n\t\tcout << \"YES\" << endl;\n\t}\n\telse {\n\t\tcout << \"NO\" << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dy[4] = {0, 1, 0, -1};\nconst int dx[4] = {1, 0, -1, 0};\n\nconst vector<string> A {\n    \"6314\",\n    \"2.2.\",\n    \"1364\",\n    \"5.5.\",\n};\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> S(H);\n    for(auto &e : S) cin >> e;\n    queue<pair<int, int>> que;\n    vector<vector<int>> dist(H, vector<int>(W, -1));\n    que.emplace(0, 0);\n    dist[0][0] = 0;\n    while(!que.empty()) {\n        auto cur = que.front(); que.pop();\n        int y = cur.first, x = cur.second;\n        for(int i = 0; i < 4; ++i) {\n            int ny = y + dy[i], nx = x + dx[i];\n            if(ny < 0 || nx < 0 || ny >= H || nx >= W) continue;\n            if(dist[ny][nx] != -1) continue;\n            if(S[ny][nx] == A[ny % 4][nx % 4]) {\n                que.emplace(ny, nx);\n                dist[ny][nx] = dist[y][x] + 1;\n            }\n        }\n    }\n    cout << (dist[H - 1][W - 1] != -1 ? \"YES\" : \"NO\") << '\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=105,INF=1<<30;\n\nstruct data{\n    int h;\n    int w;\n    int d;\n    int f;\n    int r;\n};\n\nbool can[MAX][MAX][7][7][7];\nvector<data> G[MAX][MAX][7][7][7];\n\nint S[MAX][MAX];\nint H,W;\n\nvoid DFS(data u,data p){\n    for(data to:G[u.h][u.w][u.d][u.f][u.r]){\n        if(to.h==p.h&&to.w==p.w&&to.d==p.d&&to.f==p.f&&to.r==p.r) continue;\n        \n        if(to.h<0||to.h>=H||to.w<0||to.w>=W) continue;\n        \n        if(to.d!=S[to.h][to.w]) continue;\n        \n        if(can[to.h][to.w][to.d][to.f][to.r]) continue;\n        \n        can[to.h][to.w][to.d][to.f][to.r]=1;\n        DFS(to,u);\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    cin>>H>>W;\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            char c;cin>>c;\n            if(c=='#') S[i][j]=0;\n            else S[i][j]=c-'0';\n        }\n    }\n    \n    can[0][0][6][2][3]=1;\n    \n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            for(int d=1;d<=6;d++){\n                for(int f=1;f<=6;f++){\n                    for(int r=1;r<=6;r++){\n                        if(d==f) continue;\n                        if(d==r) continue;\n                        if(f==r) continue;\n                        \n                        G[i][j][d][f][r].push_back({i+1,j,f,7-d,r});\n                        G[i][j][d][f][r].push_back({i,j+1,r,f,7-d});\n                        G[i][j][d][f][r].push_back({i-1,j,7-f,d,r});\n                        G[i][j][d][f][r].push_back({i,j-1,7-r,f,d});\n                    }\n                }\n            }\n        }\n    }\n    \n    DFS({0,0,6,2,3},{-1,-1,-1,-1,-1});\n    \n    bool ok=false;\n    \n    for(int f=1;f<=6;f++){\n        for(int r=1;r<=6;r++){\n            if(can[H-1][W-1][S[H-1][W-1]][f][r]) ok=true;\n        }\n    }\n    \n    if(ok) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define _overload3(_1,_2,_3,name,...)name\n#define _rep(i,n)repi(i,0,n)\n#define repi(i,a,b)for(int i=int(a),i##_len=(b);i<i##_len;++i)\n#define MSVC_UNKO(x)x\n#define rep(...)MSVC_UNKO(_overload3(__VA_ARGS__,repi,_rep,_rep)(__VA_ARGS__))\n#define all(c)c.begin(),c.end()\n#define write(x)cout<<(x)<<'\\n'\nusing namespace std; typedef long long ll; template<class T>using vv = vector<vector<T>>;\ntemplate<class T>auto vvec(int n, int m, T v) { return vv<T>(n, vector<T>(m, v)); }\nconstexpr int INF = 1 << 29, MOD = int(1e9) + 7; constexpr ll LINF = 1LL << 60;\nstruct aaa { aaa() { cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10); }; }aaaa;\n\nstruct Die {\n    array<int, 6> s;\n    int& top() { return s[0]; }\n    int& south() { return s[1]; }\n    int& east() { return s[2]; }\n    int& west() { return s[3]; }\n    int& north() { return s[4]; }\n    int& bottom() { return s[5]; }\n    void roll(char c) {\n        //the view from above\n        // N\n        //W E\n        // S\n        string b(\"EWNSRL\");\n        int v[6][4] = { {0,3,5,2},\n                     {0,2,5,3},\n                     {0,1,5,4},\n                     {0,4,5,1},\n                     {1,2,4,3},\n                     {1,3,4,2} };\n        for (int k = 0; k < 6; k++) {\n            if (b[k] != c) continue;\n            int t = s[v[k][0]];\n            s[v[k][0]] = s[v[k][1]];\n            s[v[k][1]] = s[v[k][2]];\n            s[v[k][2]] = s[v[k][3]];\n            s[v[k][3]] = t;\n        }\n    }\n    using ll = long long;\n    ll hash() {\n        ll res = 0;\n        for (int i = 0; i < 6; i++) res = res * 256 + s[i];\n        return res;\n    }\n    bool operator==(const Die& d) const {\n        for (int i = 0; i < 6; i++) if (s[i] != d.s[i]) return 0;\n        return 1;\n    }\n    bool operator <(const Die& d) const {\n        return s < d.s;\n    }\n};\n\nconstexpr int dy[4] = { 0,1,0,-1 }, dx[4] = { 1,0,-1,0 };\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> S(H);\n    rep(i, H) cin >> S[i];\n\n    vv<set<Die>> dist = vvec(H, W, set<Die>());\n    Die start;\n    start.top() = 1; start.south() = 2; start.east() = 3;\n    start.west() = 4; start.north() = 5; start.bottom() = 6;\n    dist[0][0].insert(start);\n    queue<pair<pair<int, int>, Die>> q;\n    q.emplace(make_pair(0, 0), start);\n    while (!q.empty()) {\n        auto v = q.front().first;\n        auto dc = q.front().second;\n        q.pop();\n        constexpr char dirchar[] = { 'E','S','W','N' };\n        rep(d, 4) {\n            int nx = v.first + dy[d], ny = v.second + dx[d];\n            Die dcn = dc;\n            dcn.roll(dirchar[d]);\n            if (nx < 0 || nx >= H || ny < 0 || ny >= W || dist[nx][ny].find(dcn) != dist[nx][ny].end() || S[nx][ny] == '#') continue;\n            if (dcn.bottom() != S[nx][ny] - '0') continue;\n            dist[nx][ny].insert(dcn);\n            q.emplace(make_pair(nx, ny), dcn);\n        }\n    }\n    write(dist[H - 1][W - 1].empty() ? \"NO\" : \"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\n//const ll mod = 1000000007;\nint H, W;\nbool field[105][105];\nstring S[105];\nbool reach[105][105];\n\n\nint main() {\n    cin >> H >> W;\n    for(int h = 0; h < H; h++) {\n        cin >> S[h];\n    }\n    for(int h = 0; h < H; h++) {\n        for(int w = 0; w < W; w++) {\n            if((h&1) & (w & 1)) continue;\n            if(h % 2 == 0 and w % 2 == 0) {\n                if((h + w) % 4 == 0) {\n                    if(S[h][w] == '6') field[h][w] = true;\n                } else {\n                    if(S[h][w] == '1') field[h][w] = true;\n                }\n            } else {\n                if(h % 4 == 1) {\n                    if(S[h][w] == '2') field[h][w] = true;\n                }\n                if(h % 4 == 3) {\n                    if(S[h][w] == '5') field[h][w] = true;\n                }\n                if(w % 4 == 1) {\n                    if(S[h][w] == '3') field[h][w] = true;\n                }\n                if(w % 4 == 3) {\n                    if(S[h][w] == '4') field[h][w] = true;\n                }\n            }\n        }\n    }\n    reach[0][0] = true;\n    queue<i_i> que;\n    que.push({0, 0});\n    int dh[4] = {1, -1, 0, 0};\n    int dw[4] = {0, 0, 1, -1};\n    while(!que.empty()) {\n        auto now = que.front();\n        que.pop();\n        int nowh = now.first;\n        int noww = now.second;\n        for(int i = 0; i < 4; i++) {\n            int newh = nowh + dh[i];\n            int neww = noww + dw[i];\n            if(newh < 0 or newh >= H) continue;\n            if(neww < 0 or neww >= W) continue;\n            if(!field[newh][neww]) continue;\n            if(reach[newh][neww]) continue;\n            que.push({newh, neww});\n            reach[newh][neww] = true;\n        }\n    }\n    if(reach[H-1][W-1]) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint PREP = (cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(9), 0);\n//int SEGV = getenv(\"D\") || (exit(system(\"D= SEGFAULT_SIGNALS=all catchsegv ./prog.exe\") >> 8), 0);\nint dice[7][4] = {\n    { -1, -1, -1, -1 },\n    {  2,  3,  5,  4 },\n    {  1,  4,  6,  3 },\n    {  1,  2,  6,  5 },\n    {  1,  5,  6,  2 },\n    {  1,  3,  6,  4 },\n    {  2,  4,  5,  3 },\n};\nint dp[100][100][7][7];\nint f(int k, int l) {\n    for (int i = 0; i < 4; i++) {\n        if (dice[l][i] == k) {\n            return dice[l][(i + 1) % 4];\n        }\n    }\n    return -1;\n}\nint main() {\n    int H, W; cin >> H >> W;\n    vector<string> S(H);\n    for (auto &s : S) cin >> s;\n    stack<tuple<int, int, int, int>> st;\n    st.emplace(0, 0, 6, 2);\n    while (!st.empty()) {\n        int i, j, k, l; tie(i, j, k, l) = st.top(); st.pop();\n        if (dp[i][j][k][l]) continue;\n        if (S[i][j] == '#' || S[i][j] - '0' != k) continue;\n        dp[i][j][k][l] = 1;\n        if (i - 1 >= 0) st.emplace(i - 1, j, 7 - l, k);\n        if (i + 1 < H) st.emplace(i + 1, j, l, 7 - k);\n        if (j - 1 >= 0) st.emplace(i, j - 1, 7 - f(k, l), l);\n        if (j + 1 < W) st.emplace(i, j + 1, f(k, l), l);\n    }\n    bool ans = false;\n    for (int k = 1; k <= 6; k++) {\n        for (int l = 1; l <= 6; l++) {\n            ans |= dp[H - 1][W - 1][k][l];\n        }\n    }\n    cout << (ans ? \"YES\" : \"NO\") << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class T, class U> using Pa = pair<T, U>;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\n\nclass Dice{\nprivate:\n    int l[7][7] = {}; \npublic:\n    int x,y,z;\n    int top,front,bottom,back,right,left;\n    Dice(int t,int f){\n        l[1][2] = 4; l[1][3] = 2; l[1][4] = 5; l[1][5] = 3;\n        l[2][3] = 6; l[2][4] = 1; l[2][6] = 4; l[3][5] = 6; l[3][6] = 2;\n        l[4][5] = 1; l[4][6] = 5; l[5][6] = 3;\n        top = t; front = f;\n        if(t<f) left = l[t][f];\n        else left = 7-l[f][t];\n        bottom = 7-top; back = 7-front; right = 7-left;\n    }\n    int num(int d){\n        if(d==0) return front;\n        if(d==1) return right;\n        if(d==2) return back;\n        if(d==3) return left;\n    }\n    void roll(int d){\n        int buf;\n        if(d==0){//手前\n            buf=top;top=back;back=bottom;bottom=front;front=buf;x--;\n        }else if(d==1){//右\n            buf=top;top=left;left=bottom;bottom=right;right=buf;z++;\n        }else if(d==2){//後\n            buf=top;top=front;front=bottom;bottom=back;back=buf;x++;\n        }else if(d==3){//左\n            buf=top;top=right;right=bottom;bottom=left;left=buf;z--;\n        }\n        y--;\n    }\n};\n\nint dp[110][110][7][7] = {};\n\nstruct state{\n    int x,y,top,front;\n};\n\nvec<int> dx = {1,0,-1,0},dy = {0,1,0,-1};\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int H,W;\n    cin >> H >> W;\n    auto in = [&](int x,int y){\n        return 0<=x && x<H && 0<=y && y<W;\n    };\n    vvec<char> F(H,vec<char>(W));\n    for(int i=0;i<H;i++) for(int j=0;j<W;j++) cin >> F[i][j];\n    queue<state> Q;\n    Q.push({0,0,1,2});\n    dp[0][0][1][2] = 1;\n    while(!Q.empty()){\n        state now = Q.front(); Q.pop();\n        Dice D(now.top,now.front);\n        for(int k=0;k<4;k++){\n            int nx = now.x+dx[k],ny = now.y+dy[k];\n            if(!in(nx,ny)) continue;\n            Dice D(now.top,now.front);\n            int n = F[nx][ny]-'0';\n            D.roll(k);\n            if(n!=D.bottom) continue;\n            if(!dp[nx][ny][D.top][D.front]){\n                dp[nx][ny][D.top][D.front] = 1;\n                Q.push({nx,ny,D.top,D.front});\n            }\n        }\n    }\n    bool ok = false;\n    for(int i=1;i<7;i++) for(int j=1;j<7;j++) ok |= dp[H-1][W-1][i][j];\n    cout << (ok? \"YES\\n\":\"NO\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing grid = vector<vector<char>>;\n\n//constexpr ll MOD = 1000000007;\n\nconstexpr ll MOD = 998244353;\n\nconstexpr ll INF = 1050000000;\nconstexpr ll LONGINF = 1050000000000000000;\nstruct all_init {\n    all_init() {\n        cout.tie(nullptr);\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(11);\n    };\n} ALL_INIT;\nstruct edge {\n \n    int from, to;\n    ll cost;\n    ll capa;\n \n    edge(int s, int d) : from(s), to(d) {\n        cost = 0;\n        capa = 0;\n    }\n    edge(int s, int d, ll w) : from(s), to(d), cost(w) { capa = 0; }\n    edge(int s, int d, ll x, ll y) : from(s), to(d), cost(x), capa(y) {}\n \n    bool operator<(const edge& x) const { return cost < x.cost; }\n};\nusing graph = vector<vector<edge>>;\n \n#define CIN(vector_array_etc, n)         \\\n  for (int loop = 0; loop < n; loop++) { \\\n    cin >> vector_array_etc[loop];       \\\n  }\n#define COUT(vector_array_etc, n)                                   \\\n  for (int LOOP = 0; LOOP < n; LOOP++) {                            \\\n    cout << vector_array_etc[LOOP] << (LOOP == n - 1 ? '\\n' : ' '); \\\n  }\n#define VC(Type_name) vector<Type_name>\n#define SORT(vector_etc) sort(vector_etc.begin(), vector_etc.end())\n#define ALL(vec_etc) vec_etc.begin(), vec_etc.end()\n#define VCVC(Type_name) vector<vector<Type_name>>  \n#define WARSHALL vector<vector<ll>> g(n, vector<ll>(n, LONGINF))\n#define endl '\\n'\n\n \ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <typename T>\nistream& operator>>(istream& is, vector<T>& Vec) {\n    for (T& x : Vec) {\n        is >> x;\n    }\n    return is;\n}\ntemplate <typename V, typename H>\nvoid resize(vector<V>& vec, const H head) {\n    vec.resize(head);\n}\ntemplate <typename V, typename H, typename... T>\nvoid resize(vector<V>& vec, const H& head, const T... tail) {\n    vec.resize(head);\n    for (auto& v : vec) {\n        resize(v, tail...);\n    }\n}\ntemplate <ll mod>\nstruct ModInt {\n    long long val;\n    constexpr ModInt(long long v = 0) noexcept : val(v% mod) {\n        if (val < 0) val += mod;\n    }\n    constexpr int getmod() { return mod; }\n    constexpr ModInt operator-() const noexcept { return val ? mod - val : 0; }\n    constexpr ModInt operator+(const ModInt& r) const noexcept {\n        return ModInt(*this) += r;\n    }\n    constexpr ModInt operator-(const ModInt& r) const noexcept {\n        return ModInt(*this) -= r;\n    }\n    constexpr ModInt operator*(const ModInt& r) const noexcept {\n        return ModInt(*this) *= r;\n    }\n    constexpr ModInt operator/(const ModInt& r) const noexcept {\n        return ModInt(*this) /= r;\n    }\n    constexpr ModInt& operator+=(const ModInt& r) noexcept {\n        val += r.val;\n        if (val >= mod) val -= mod;\n        return *this;\n    }\n    constexpr ModInt& operator-=(const ModInt& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += mod;\n        return *this;\n    }\n    constexpr ModInt& operator*=(const ModInt& r) noexcept {\n        val = val * r.val % mod;\n        return *this;\n    }\n    constexpr ModInt& operator/=(const ModInt& r) noexcept {\n        long long a = r.val, b = mod, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        val = val * u % mod;\n        if (val < 0) val += mod;\n        return *this;\n    }\n    constexpr bool operator==(const ModInt& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator!=(const ModInt& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt<mod>& x) noexcept {\n        return os << x.val;\n    }\n    friend istream& operator>>(istream& is, ModInt<mod>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr ModInt<mod> modpow(const ModInt<mod>& a,\n        long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\ntemplate <class T>\nstruct nCk {\n    vector<T> fact_, inv_, finv_;\n    constexpr nCk() {}\n    constexpr nCk(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        ll MOD = 1000000007;\n        for (ll i = 2; i < n; i++) {\n            fact_[i] = fact_[i - 1] * i;\n            inv_[i] = -inv_[MOD % i] * (MOD / i);\n            finv_[i] = finv_[i - 1] * inv_[i];\n        }\n    }\n    constexpr T com(ll n, ll k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n - k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n \nint dx[] = { 0, 1, -1, 0, 1, -1, 1, -1 };  // i<4:4way i<8:8way\nint dy[] = { 1, 0, 0, -1, 1, -1, -1, 1 };\n \n\n\nint main() {\n    vector<string> s={\n        \"6314\",\n        \"2!2!\",\n        \"1364\",\n        \"5!5!\",\n    };\n\n    int h,w;cin>>h>>w;\n\n    vector<vector<char>> a(h,vector<char>(w));\n    vector<vector<char>> x(h,vector<char>(w,'.'));\n    vector<vector<int>> f(h,vector<int>(w,INF));\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            cin>>a[i][j];\n            if(a[i][j]!=s[i%4][j%4]){\n                x[i][j]='#';\n            }\n        }\n    }\n    queue<pair<int, int>> q;\n    q.push(make_pair(0, 0));\n    f[0][0]=0;\n \n\twhile (!q.empty()) {\n\t\tpair<int, int> check = q.front(); q.pop();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint ny = check.first + dy[i];\n\t\t\tint nx = check.second + dx[i];\n            if(nx<0||nx>=w||ny<0||ny>=h){\n                continue;\n            }\n\t\t\tif (x[ny][nx] == '.'&&f[ny][nx]==INF) {\n\t\t\t\tf[ny][nx] = f[check.first][check.second] + 1;\n\t\t\t\tq.push(make_pair(ny, nx));\n\t\t\t}\n\t\t}\n\t}\n    /*\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            cout<<x[i][j];\n        }\n        cout<<endl;\n    }\n    */\n\n    if(f[h-1][w-1]!=INF){\n        cout<<\"YES\"<<endl;\n    }\n    else{\n        cout<<\"NO\"<<endl;\n    }\n\n\n\n\n\n    ;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// I SEint YOU...! \n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<queue>\n#include<chrono>\n#include<iomanip>\n#include<map>\n#include<set>\nusing namespace std;\nvoid init_io(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << setprecision(10);\n}\nstring d[110];\nbool used[110][110]={};\nsigned main(){\n  init_io();\n  int h,w;\n  int arr[]={6,3,1,4},idx;\n  cin >> h >> w;\n  for(int i=0;i<h;i++){\n    cin >> d[i];\n    if(i%4==0) idx = 0;\n    else idx = 2;\n    for(int j=0;j<w;j++){\n      if(i%2==0){\n        if((d[i][j]-'0')!=arr[idx]){\n          d[i][j]='#';\n        }\n        if(i%4==0) idx = (idx+1)%4;\n        else idx = (idx+3)%4;\n      }else{\n        if((i+1)%4==0&&(d[i][j]-'0')!=5){\n          d[i][j] = '#';\n        }else if((i+1)%4!=0&&(d[i][j]-'0')!=2){\n          d[i][j] = '#';\n        }\n      }\n    }\n  }\n  queue<pair<int,int> > que;\n  que.push(pair<int,int>(0,0));\n  int vx[]={1,0,-1,0},vy[]={0,1,0,-1};\n  while(!que.empty()){\n    pair<int,int> tmp = que.front();\n    que.pop();\n    int x = tmp.first, y=tmp.second;\n    if(used[x][y]) continue;\n    used[x][y] = true;\n    for(int i=0;i<4;i++){\n      int nx = x + vx[i];\n      int ny = y + vy[i];\n      if(nx>=0&&ny>=0&&nx<h&&ny<w){\n        if(d[nx][ny]!='#'){\n          que.push(pair<int,int>(nx,ny));\n        }\n      }\n    }\n  }\n  if(used[h-1][w-1]){\n    cout <<\"YES\\n\";\n  }else{\n    cout <<\"NO\\n\";\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl; \n#define INF 1000000000\n#define mod 1000000007\nusing ll=long long;\nconst ll LINF=1001002003004005006ll;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return true;}return false;}\n\nstruct Dice\n{\n  // int x, y;\n  int l, r, f, b, d, u;\n\n  void RollN()\n  {\n    //  --y;\n    int buff = d;\n    d = f;\n    f = u;\n    u = b;\n    b = buff;\n  }\n\n  void RollS()\n  {\n    // ++y;\n    int buff = d;\n    d = b;\n    b = u;\n    u = f;\n    f = buff;\n  }\n\n  void RollL() // ----->\n  {\n    int buff = f;\n    f = l;\n    l = b;\n    b = r;\n    r = buff;\n  }\n\n  void RollR() // <------\n  {\n    int buff = f;\n    f = r;\n    r = b;\n    b = l;\n    l = buff;\n  }\n\n  void RollE() // .o -> o.\n  {\n    // --x;\n    int buff = d;\n    d = l;\n    l = u;\n    u = r;\n    r = buff;\n  }\n\n\n  void RollW() // o. -> .o\n  {\n    //  ++x;\n    int buff = d;\n    d = r;\n    r = u;\n    u = l;\n    l = buff;\n  }\n\n    void o(){\n        cout<<d<<endl;\n    }\n\n  vector< Dice > makeDice()\n  {\n    vector< Dice > ret;\n    for(int i = 0; i < 6; i++) {\n      Dice d(*this);\n      if(i == 1) d.RollN();\n      if(i == 2) d.RollS();\n      if(i == 3) d.RollS(), d.RollS();\n      if(i == 4) d.RollL();\n      if(i == 5) d.RollR();\n      for(int j = 0; j < 4; j++) {\n        ret.emplace_back(d);\n        d.RollE();\n      }\n    }\n    return (ret);\n  }\n};\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int h,w;cin>>h>>w;\n    string s[h];\n    rep(i,h) cin>>s[i];\n    bool check[h][w]={};\n    \n    queue<pair<Dice,pair<int,int>>> que;\n    Dice d[h][w];\n    d[0][0].r=3;d[0][0].l=4;d[0][0].f=2;\n    d[0][0].b=5;d[0][0].d=6;d[0][0].u=1;\n    check[0][0]=true;\n    que.push(make_pair(d[0][0],make_pair(0,0)));\n    \n    while(!que.empty()){\n        auto p=que.front();que.pop();\n        auto pos=p.second;auto dice=p.first;\n        int i=pos.first,j=pos.second;\n        // cout<<\"ima \";dice.o();\n        if(i-1>=0 and !check[i-1][j]){\n            dice.RollS();\n            // dice.o();\n            if(dice.d+'0'==s[i-1][j]){\n                check[i-1][j]=true;\n                que.push(make_pair(dice,make_pair(i-1,j)));\n            }\n            dice.RollN();\n        }\n        if(i+1<h and !check[i+1][j]){\n            dice.RollN();\n            // dice.o();\n            if(dice.d+'0'==s[i+1][j]){\n                check[i+1][j]=true;\n                que.push(make_pair(dice,make_pair(i+1,j)));\n            }\n            dice.RollS();\n        }\n        if(j-1>=0 and !check[i][j-1]){\n            dice.RollE();\n            // dice.o();\n            if(dice.d+'0'==s[i][j-1]){\n                check[i][j-1]=true;\n                que.push(make_pair(dice,make_pair(i,j-1)));\n            }\n            dice.RollW();\n        }\n        if(j+1<w and !check[i][j+1]){\n            dice.RollW();\n            // dice.o();\n            if(dice.d+'0'==s[i][j+1]){\n                check[i][j+1]=true;\n                que.push(make_pair(dice,make_pair(i,j+1)));\n            }\n            dice.RollE();\n        }\n    }\n    \n    if(check[h-1][w-1])     cout<<\"YES\"<<endl;\n    else                    cout<<\"NO\"<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vl = vector<ll>;\ntemplate<class T> using vc = vector<T>;\ntemplate<class T> using vvc = vector<vector<T>>;\n\nconst ll MOD = 1e9 + 7;\n// const ll MOD = 998244353;\nconst ll INF = 1e16;\nconst ld EPS = 1e-11;\nconst ld PI = acos(-1.0L);\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define repr(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define repe(i, l, r) for (ll i = (l); i < (r); i++)\n#define reper(i, l, r) for (ll i = (r)-1; i >= (l); i--)\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\nvoid init() {cin.tie(0);ios::sync_with_stdio(false);cout << fixed << setprecision(15);}\n//--------------------------------------------------------------------------------//\nll H,W;\nbool can=false;\nvvc<bool> used;\nvoid dfs(ll h,ll w, ll lpre, ll upre, ll now, vc<string>& S){\n    used[h][w] = true;\n    if(h==H-1&&w==W-1){\n        can = true;\n        return;\n    }\n\n    if(h+1<H&&!used[h+1][w]&&S[h+1][w]=='0'+7-upre){\n        dfs(h + 1, w, lpre, now, 7 - upre, S);\n    }\n    if(h-1>=0&&!used[h-1][w]&&S[h-1][w]=='0'+upre){\n        dfs(h - 1, w, lpre, 7 - now, upre, S);\n    }\n    if(w+1<W&&!used[h][w+1]&&S[h][w+1]=='0'+7-lpre){\n        dfs(h, w + 1, now, upre, 7 - lpre, S);\n    }\n    if(w-1>=0&&!used[h][w-1]&&S[h][w-1]=='0'+lpre){\n        dfs(h, w - 1, 7 - now, upre, lpre, S);\n    }\n\n}\nint main() {\n    init();\n    cin >> H >> W;\n    vc<string> S(H);\n    rep(i, H) cin >> S[i];\n    if(H%2==0&&W%2==0){\n        cout << \"NO\" << endl;\n        return 0;\n    }\n    used.resize(H);\n    rep(i, H) used[i].resize(W);\n\n    dfs(0, 0, 4, 5, 6, S);\n    cout << (can ? \"YES\" : \"NO\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define ll long long\nusing namespace std;\n//typedef vector<unsigned int>vec;\n//typedef vector<ll>vec;\n//typedef vector<vec> mat;\ntypedef pair<int, int> P;\ntypedef pair<ll,ll> LP;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst int INF = 1000000000;\nconst ll LINF = 1000000000000000000;//1e18\nconst ll  MOD = 1000000007;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-10;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n//template<class T> inline void add(T &a, T b){a = ((a+b) % MOD + MOD) % MOD;};\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int H, W;\n    cin >> H >> W;\n    vector<string> fi(H);\n    REP(i,H) cin >> fi[i];\n    string ans = \"NO\";\n    vector<int> dice(4);\n    dice[0] = 2, dice[1] = 3, dice[2] = 5, dice[3] = 4;\n    vector<vector<bool>> used(H, vector<bool>(W));\n\n    auto dfs = [&](auto && self, int h, int w, vector<int> D) -> void{\n        if(used[h][w]) return;\n        used[h][w] = true;\n        if(h == H-1 && w == W-1){\n            ans = \"YES\";\n            return;\n        }\n        REP(i,4){\n            int nh = h + dx[i], nw = w + dy[i];\n            if(nh < 0 || nh >= H || nw < 0 || nw >= W) continue;\n            if(fi[nh][nw] == '#') continue;\n            int next = fi[nh][nw] - '0';\n            int d = D[i];\n            // cout << nh << \" \" << nw << \" \" << next << \" \" << d << endl;\n            // cout << \"DICE : \";\n            vector<int> dd = D;\n            // REP(i,4) cout << D[i] << \" \";\n            // cout << endl;\n            if(next != d) continue;\n            int cur = fi[h][w] - '0';\n            if(i == 0) dd[0] = 7 - cur, dd[2] = cur;\n            else if(i == 1) dd[1] = 7 - cur,  dd[3] = cur;\n            else if(i == 2) dd[0] = cur, dd[2] = 7 - cur;\n            else dd[1] = cur, dd[3] = 7 - cur;\n            self(self, nh, nw,dd);\n        }\n    };\n    dfs(dfs, 0, 0, dice);\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=110;\n\nset<VI> grid[N][N];\nqueue<VI> q;\nchar g[N][N];\nint h,w;\n\n// f,b,u,d,l,r\nconst int F=0,B=1,U=2,D=3,L=4,R=5;\n\nvoid add(int x,int y,VI s) {\n\tif (grid[x][y].count(s)) return;\n\tgrid[x][y].insert(s);\n\ts.pb(x); s.pb(y);\n\tq.push(s);\n}\n\nint main() {\n\tscanf(\"%d%d\",&h,&w);\n\trep(i,0,h) scanf(\"%s\",g[i]);\n\tadd(0,0,VI{2,5,1,6,4,3});\n\twhile (!q.empty()) {\n\t\tauto v=q.front(); q.pop();\n\t\tVI d(v.begin(),v.begin()+6);\n\t\tint x=v[6],y=v[7];\n\t\tif (x==h-1&&y==w-1) { puts(\"YES\"); return 0; }\n\t\tif (y<w-1&&g[x][y+1]!='#') {\n\t\t\tVI newd{d[F],d[B],d[L],d[R],d[D],d[U]};\n\t\t\tif (newd[D]==g[x][y+1]-'0') {\n\t\t\t\tadd(x,y+1,newd);\n\t\t\t}\n\t\t}\n\n\t\tif (y>0&&g[x][y-1]!='#') {\n\t\t\tVI newd{d[F],d[B],d[R],d[L],d[U],d[D]};\n\t\t\tif (newd[D]==g[x][y-1]-'0') {\n\t\t\t\tadd(x,y-1,newd);\n\t\t\t}\n\t\t}\n\n\t\tif (x<h-1&&g[x+1][y]!='#') {\n\t\t\tVI newd{d[U],d[D],d[B],d[F],d[L],d[R]};\n\t\t\tif (newd[D]==g[x+1][y]-'0') {\n\t\t\t\tadd(x+1,y,newd);\n\t\t\t}\n\t\t}\n\n\t\tif (x>0&&g[x-1][y]!='#') {\n\t\t\tVI newd{d[D],d[U],d[F],d[B],d[L],d[R]};\n\t\t\tif (newd[D]==g[x-1][y]-'0') {\n\t\t\t\tadd(x-1,y,newd);\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"NO\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <numeric>\n#include <algorithm>\n#include <deque>\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <map>\n#include <stack>\n#include <queue>\n#include <functional>\n#include <climits>\n#include <bitset>\n#include <random>\n#include <tuple>\n#include <initializer_list>\n#include <fstream>\nstruct Dice {\n\tint top, front, right_face;\n\tint bottom_face() const { return 7 - top; }\n\tDice right() const {\n\t\treturn Dice{ 7 - right_face, front, top };\n\t}\n\tDice left() const {\n\t\treturn Dice{ right_face, front, 7 - top };\n\t}\n\tDice up() const {\n\t\treturn Dice{ front, 7 - top, right_face };\n\t}\n\tDice down() const {\n\t\treturn Dice{ 7 - front, top, right_face };\n\t}\n};\nstruct Coordinate {\n\tint i, j;\n\tCoordinate right() const {\n\t\treturn Coordinate{ i, j + 1 };\n\t}\n\tCoordinate left() const {\n\t\treturn Coordinate{ i, j - 1 };\n\t}\n\tCoordinate up() const {\n\t\treturn Coordinate{ i - 1, j };\n\t}\n\tCoordinate down() const {\n\t\treturn Coordinate{ i + 1, j };\n\t}\n};\nstd::vector<std::pair<Coordinate, Dice>> neighbors(const std::pair<Coordinate, Dice> pair) {\n\treturn std::vector<std::pair<Coordinate, Dice>> {std::make_pair(pair.first.right(), pair.second.right()), std::make_pair(pair.first.left(), pair.second.left()), std::make_pair(pair.first.up(), pair.second.up()), std::make_pair(pair.first.down(), pair.second.down())};\n}\nint main() {\n\tint height, width; std::cin >> height >> width;\n\tstd::vector<std::string> state(height); for (auto& line : state) std::cin >> line;\n\tstd::vector<std::vector<std::vector<std::vector<std::vector<bool>>>>> memo(height, std::vector<std::vector<std::vector<std::vector<bool>>>>(width, std::vector<std::vector<std::vector<bool>>>(6, std::vector<std::vector<bool>>(6, std::vector<bool>(6, false)))));\n\tstd::stack<std::pair<Coordinate, Dice>> stack;\n\tmemo[0][0][0][1][2] = true;\n\tstack.emplace(Coordinate{ 0, 0 }, Dice{ 1, 2, 3 });\n\twhile (!stack.empty()) {\n\t\tconst auto top = stack.top(); stack.pop();\n\t\tfor (const auto next : neighbors(top)) {\n\t\t\tif (0 > next.first.i || 0 > next.first.j || height <= next.first.i || width <= next.first.j) continue;\n\t\t\tif (memo[next.first.i][next.first.j][next.second.top - 1][next.second.front - 1][next.second.right_face - 1]) continue;\n\t\t\tif (state[next.first.i][next.first.j] - '0' == next.second.bottom_face()) {\n\t\t\t\tmemo[next.first.i][next.first.j][next.second.top - 1][next.second.front - 1][next.second.right_face - 1] = true;\n\t\t\t\tstack.push(next);\n\t\t\t}\n\t\t}\n\t}\n\tbool can_reach = false;\n\tfor (auto t = 0; t < 6; ++t) for (auto f = 0; f < 6; ++f) for (auto r = 0; r < 6; ++r) if (memo.back().back()[t][f][r]) can_reach = true;\n\tstd::cout << (can_reach ? \"YES\" : \"NO\") << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nstruct dice {\n    int u, d, l, r, f, b;\n\n    void spinl(){ // f -> l\n        int tmp = f; f = r; r = b; b = l; l = tmp;\n    }\n    void spinr(){\n        for (int i = 0; i < 3; ++i) spinl();\n    }\n\n    void gof(){\n        int tmp = f; f = u; u = b; b = d; d = tmp;\n    }\n\n    void gob(){\n        for (int i = 0; i < 3; ++i) gof();\n    }\n\n    void gor(){\n        int tmp = u; u = l; l = d; d = r; r = tmp;\n    }\n\n    void gol(){\n        for (int i = 0; i < 3; ++i) gor();\n    }\n\n    dice(int a, int x) {\n        u = 1, d = 6, f = 2, b = 5, l = 4, r = 3;\n        if(a == 2) gob();\n        else if(a == 3) gol();\n        else if(a == 4) gor();\n        else if(a == 5) gof();\n        else if(a == 6) gof(), gof();\n        while(f != x) spinl();\n    }\n    dice(){\n        u = 0, d = 0, f = 0, b = 0, l = 0, r = 0;\n    }\n};\n\nint main() {\n    dice D(1, 2);\n    int h, w;\n    cin >> h >> w;\n    vector<vector<int>> v(h+2, vector<int>(w+2, 0));\n\n    for (int i = 0; i < h; ++i) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < w; ++j) {\n            if(s[j] != '#') v[i+1][j+1] = s[j] - '0';\n        }\n    }\n    vector<vector<dice>> a(h+2, vector<dice>(w+2));\n    a[1][1] = D;\n    queue<pair<int, int>> Q;\n    Q.emplace(1, 1);\n    while(!Q.empty()){\n        int y, x; tie(y, x) = Q.front(); Q.pop();\n        dice d = a[y][x];\n        if(v[y-1][x] && a[y-1][x].r == 0){\n            d.gob();\n            if(d.d == v[y-1][x]){\n                Q.emplace(y-1, x);\n                a[y-1][x] = d;\n            }\n            d.gof();\n        }\n        if(v[y+1][x] && a[y+1][x].r == 0){\n            d.gof();\n            if(d.d == v[y+1][x]){\n                Q.emplace(y+1, x);\n                a[y+1][x] = d;\n            }\n            d.gob();\n        }\n        if(v[y][x-1] && a[y][x-1].r == 0){\n            d.gol();\n            if(d.d == v[y][x-1]){\n                Q.emplace(y, x-1);\n                a[y][x-1] = d;\n            }\n            d.gor();\n        }\n        if(v[y][x+1] && a[y][x+1].r == 0){\n            d.gor();\n            if(d.d == v[y][x+1]){\n                Q.emplace(y, x+1);\n                a[y][x+1] = d;\n            }\n            d.gol();\n        }\n    }\n    if(a[h][w].d){\n        puts(\"YES\");\n    }else {\n        puts(\"NO\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, a, b) for(int i = a; i < b; i++)\n#define rrep(i, a, b) for(int i = b - 1; i >= a; i--)\n#define ALL(a) a.begin(), a.end()\n#define pii pair<int,int>\n#pragma GCC optimize(\"Ofast\")\n#define pcnt __builtin_popcount\n#define buli(x) __builtin_popcountll(x)\n#define pb push_back\n#define mp make_pair\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define isSquare(x) (sqrt(x)*sqrt(x) == x)\ntemplate<class T>bool chmax(T &a, const T &b) {if(a<b){a = b; return 1;} return 0; };\ntemplate<class T>bool chmin(T &a, const T &b) {if(a>b){a = b; return 1;} return 0; };\ninline void IN(void){return;}\ntemplate <typename First, typename... Rest> void IN(First& first, Rest&... rest){cin >> first;IN(rest...);return;}\ninline void OUT(void){cout << \"\\n\";return;}\ntemplate <typename First, typename... Rest> void OUT(First first, Rest... rest){cout << first << \" \";OUT(rest...);return;}\nconst double EPS = 1e-9;\nconst int mod = 1e9 + 7;\nconst int INF = 1e9;\nconst long long LLINF = 1e18;\nlong long lcm(ll a, ll b){return a * b / __gcd(a,b);}\nstruct IoSetup { IoSetup() {\n    cin.tie(nullptr);ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n} } iosetup;\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 >& p) {\n    os << p.first << \" \" << p.second;\n    return os;\n}\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n    is >> p.first >> p.second;\n    return is;\n}\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n    for(int i = 0; i < (int) v.size(); i++) {\n        os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n    }\n    return os;\n}\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n    for(T &in : v) is >> in;\n    return is;\n}\ntemplate <typename T> void Exit(T first){cout << first << endl;exit(0); };\ntemplate< int mod > struct ModInt {\n    int x; ModInt() : x(0) {}\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n    ModInt &operator+=(const ModInt &p) {if((x += p.x) >= mod) x -= mod;return *this;}\n    ModInt &operator-=(const ModInt &p) {if((x += mod - p.x) >= mod) x -= mod;return *this;}\n    ModInt &operator*=(const ModInt &p) {x = (int) (1LL * x * p.x % mod);return *this;}\n    ModInt &operator/=(const ModInt &p) {*this *= p.inverse();return *this;}\n    ModInt operator-() const { return ModInt(-x); }\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n    bool operator==(const ModInt &p) const { return x == p.x; }\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n    ModInt inverse() const {int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) { t = a / b; swap(a -= t * b, b); swap(u -= t * v, v); }return ModInt(u);}\n    ModInt pow(int64_t n) const {ModInt ret(1), mul(x); while(n > 0) {if(n & 1) ret *= mul;mul *= mul;n >>= 1;}return ret;}\n    friend ostream &operator<<(ostream &os, const ModInt &p) { return os << p.x;}\n    friend istream &operator>>(istream &is, ModInt &a) { int64_t t; is >> t; a = ModInt< mod >(t); return (is); }\n    static int get_mod() { return mod; }\n}; using modint = ModInt< mod >;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nint H, W; \nvector<string> S;\nvector<vector<bool>> used;\nbool dfs(int x, int y, vector<int>& v){\n    if(x == H - 1 && y == W - 1) return true;\n    // cerr << x << \" \" << y << endl;\n    used[x][y] = true;\n    bool flag = false;\n    rep(i, 0, 4){\n        int nx = x + dx[i], ny = y + dy[i];\n        if(0 <= x + dx[i] && x + dx[i] < H && 0 <= y + dy[i] && y + dy[i] < W){\n            if(!used[nx][ny]&&S[nx][ny] != '#'){\n                if((S[nx][ny] - '0') + (S[x][y] - '0') != 7 && S[nx][ny] != S[x][y]){\n                    vector<int> tmp(6);\n                    if(i == 0) tmp = {v[4], v[0], v[2], v[3], v[5], v[1]};\n                    else if(i == 1) tmp = {v[3], v[1], v[0], v[5], v[4], v[2]};\n                    else if(i == 2) tmp = {v[1], v[5], v[2], v[3], v[0], v[4]};\n                    else if(i == 3) tmp = {v[2], v[1], v[5], v[0], v[4], v[3]};\n                    if(tmp[5] == S[nx][ny] - '0'){\n                        bool tt = dfs(nx, ny, tmp);\n                        if(tt) flag = tt;\n                    }\n                }\n            }\n        }\n    }\n    return flag;\n}\n\nint main(){\n    iosetup;\n    cin >> H >> W;\n    S.resize(H);\n    rep(i, 0, H) cin >> S[i];\n    used.resize(H, vector<bool>(W, false));\n    vector<int> v(6);\n    v = {1,2,3,4,5,6};\n    if(dfs(0, 0, v)) puts(\"YES\");\n    else puts(\"NO\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint H, W;\nstring s[100];\nbool vis[100][100];\nbool dfs(int x, int y) {\n    if (x == H-1 && y == W-1) return true;\n    vis[x][y] = true;\n    const int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n    for (int i = 0; i < 4; i++) {\n        int u = x + dx[i], v = y + dy[i];\n        if (0 <= u && u < H && 0 <= v && v < W\n            && s[u][v] != '#' && !vis[u][v] && dfs(u, v))\n            return true;\n    }\n    return false;\n}\n\nint main() {\n    cin >> H >> W;\n    for (int i = 0; i < H; i++) cin >> s[i];\n    const string req[4] = {\"6314\", \"2020\", \"1364\", \"5050\"};\n    for (int i = 0; i < H; i++)\n        for (int j = 0; j < W; j++)\n            if (s[i][j] != req[i%4][j%4]) s[i][j] = '#';\n    cout << (dfs(0, 0) ? \"YES\\n\" : \"NO\\n\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(v) v.begin(), v.end()\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\n#define fs first\n#define sc second\n#define _GLIBCXX_DEBUG\n\nint dxy[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};\nint h, w;\nvector<vector<bool>> visited(100, vector<bool>(100, false));\nvector<vector<int>> s(100, vector<int>(100, 0));\n\nvector<vector<int>> rotate(int k, vector<vector<int>> dice)\n{\n    if(k==1){\n        dice[1][2] = dice[1][1];\n        dice[1][1] = dice[1][0];\n        dice[1][0] = 7-dice[1][2];\n    }\n    if (k == 0)\n    {\n        dice[1][0] = dice[1][1];\n        dice[1][1] = dice[1][2];\n        dice[1][2] = 7 - dice[1][0];\n    }\n    if (k == 3)\n    {\n        dice[2][1] = dice[1][1];\n        dice[1][1] = dice[0][1];\n        dice[0][1] = 7 - dice[2][1];\n    }\n    if (k == 2)\n    {\n        dice[0][1] = dice[1][1];\n        dice[1][1] = dice[2][1];\n        dice[2][1] = 7 - dice[0][1];\n    }\n    return dice;\n}\n\nvoid dfs(int x, int y, vector<vector<int>> dice)\n{\n    if(x == h-1 && y == w-1){\n        cout << \"YES\\n\";\n        exit(0);\n    }\n    visited[x][y] = true;\n    rep(i,4){\n        int x2 = x+dxy[i][0];\n        int y2 = y+dxy[i][1];\n        if(0 <= x2 && x2 < h && 0 <= y2 && y2 < w){\n            if(s[x2][y2] == dice[1+dxy[i][0]][1+dxy[i][1]] && !visited[x2][y2]){\n                dfs(x2,y2,rotate(i,dice));\n            }\n        }\n    }\n}\n\nint main(void){\n    vector<vector<int>> dice(3, vector<int>(3, 0));\n    dice[1][1] = 6;\n    dice[1][0] = 4;\n    dice[1][2] = 3;\n    dice[0][1] = 5;\n    dice[2][1] = 2;\n    cin >> h >> w;\n    rep(i,h){\n        string tmp;\n        cin >> tmp;\n        rep(j,w){\n            if(tmp[j] != '#'){\n                s[i][j] = tmp[j] - '0';\n            }\n        }\n    }\n    dfs(0,0,dice);\n    cout << \"NO\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n \nconst double pi = 3.141592653589793238462643383279;\n \n \nusing namespace std;\n \n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n \n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n \n \n//container util\n \n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n \n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n \n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n \n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n \nclass UnionFind {\npublic:\n    vector <int> par; \n    vector <int> siz; \n\n    UnionFind(int sz_): par(sz_), siz(sz_, 1) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(int sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n \n    int root(int x) { \n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n \n    bool merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n \n    bool issame(int x, int y) { \n        return root(x) == root(y);\n    }\n \n    int size(int x) { \n        return siz[root(x)];\n    }\n};\n \n \nll modPow(ll x, ll n, ll mod = MOD){\n    ll res = 1;\n    while(n){\n        if(n&1) res = (res * x)%mod;\n \n        res %= mod;\n        x = x * x %mod;\n        n >>= 1;\n    }\n    return res;\n}\n \n#define SIEVE_SIZE 5000000+10\nbool sieve[SIEVE_SIZE];\nvoid makeSieve(){\n    for(int i=0; i<SIEVE_SIZE; ++i) sieve[i] = true;\n    sieve[0] = sieve[1] = false;\n    for(int i=2; i*i<SIEVE_SIZE; ++i) if(sieve[i]) for(int j=2; i*j<SIEVE_SIZE; ++j) sieve[i*j] = false;\n}\n \nbool isprime(ll n){\n    if(n == 0 || n == 1) return false;\n    for(ll i=2; i*i<=n; ++i) if(n%i==0) return false;\n    return true;\n}\n \nconst int MAX = 2000010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n \n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n \n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n \nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK) \ninline long long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n \n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m) {\n    long long x, y;\n    extGCD(a, m, x, y);\n    return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b){\n    \n    if(b == 0) return a;\n    return GCD(b, a%b);\n}\n\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nmat mul(mat &A, mat &B) {\n    mat C(A.size(), vec((int)B[0].size()));\n    for(int i=0; i<A.size(); ++i){\n        for(int k=0; k<B.size(); ++k){\n            for(int j=0; j<B[0].size(); ++j){\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j] %MOD) % MOD;\n            }\n        }\n    }\n    return C;\n}\nmat matPow(mat A, ll n) {\n    mat B(A.size(), vec((int)A.size()));\n \n    for(int i=0; i<A.size(); ++i){\n        B[i][i] = 1;\n    }\n \n    while(n > 0) {\n        if(n & 1) B = mul(B, A);\n        A = mul(A, A);\n        n >>= 1;\n    }\n    return B;\n}\nconst int UP = 0;\nconst int FRONT = 1;\nconst int RIGHT = 2;\nconst int LEFT = 3;\nconst int BACK = 4;\nconst int DOWN = 5;\nstruct Dice {\n    vector<int> d;\n\n    Dice(vector<int> v, int N = 6){\n        d.resize(N);\n        for(int i=0; i<N; i++){\n            d[i] = v[i];\n        }\n    }\n\n    void rotate(char s){\n        vector<int> tmp = d;\n        if(s == 'S'){\n            d[0] = tmp[4];\n            d[1] = tmp[0];\n            d[5] = tmp[1];\n            d[4] = tmp[5];\n        }\n\n        if(s == 'E'){\n            d[0] = tmp[3];\n            d[2] = tmp[0];\n            d[5] = tmp[2];\n            d[3] = tmp[5];\n        }\n\n        if(s == 'W'){\n            d[0] = tmp[2];\n            d[3] = tmp[0];\n            d[5] = tmp[3];\n            d[2] = tmp[5];\n        }\n\n        if(s == 'N'){\n            d[0] = tmp[1];\n            d[1] = tmp[5];\n            d[5] = tmp[4];\n            d[4] = tmp[0];\n        }\n    }\n\n    void spin(){\n        vector<int> tmp = d;\n        d[1] = tmp[2];\n        d[2] = tmp[4];\n        d[4] = tmp[3];\n        d[3] = tmp[1];\n    }\n    bool issame(Dice &d2){\n        bool res = true;\n\n        for(int i=0; i<6; i++){\n            if(d[i] != d2[i]) res = false;\n        }\n\n        return res;\n    }\n    int operator[](const int &k){ return d[k]; }\n};\n\nbool visited[110][110];\nint dxy[5] = {-1,0,1,0,-1};\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n\n    int H, W; cin >> H >> W;\n\n    vector<string> s;\n    REP(i,H){\n        string t; cin >> t;\n        s.push_back(t);\n    }\n\n    if(H%2 == 0 && W % 2 == 0){\n        cout << \"NO\" << endl;\n        return 0;\n    }\n\n    vector<int> vv={1,2,3,4,5,6};\n    Dice d = Dice(vv);\n\n    queue<pair<Dice, pair<int, int>>> q;\n    q.push(make_pair(d, make_pair(0,0)));\n    visited[0][0] = true;\n    while(q.size()){\n        auto p = q.front(); q.pop();\n        //cout << p.second.first << \" \" << p.second.second << endl;\n        for(int i=0; i<4; i++){\n            int ny = p.second.first+dxy[i], nx = p.second.second + dxy[i+1];\n            if(ny < 0 || ny >= H || nx < 0 || nx >= W) continue;\n            if(s[ny][nx] == '#') continue;\n\n            auto tmp = p.first;\n            if(i == 0){\n                tmp.rotate('N');\n            }else if(i == 1){\n                tmp.rotate('E');\n            }else if(i == 2){\n                tmp.rotate('S');\n            }else if(i == 3){\n                tmp.rotate('W');\n            }\n            if(tmp.d[DOWN] != s[ny][nx] - '0') continue;\n            if(visited[ny][nx]) continue;\n            q.push(make_pair(tmp, make_pair(ny, nx)));\n            visited[ny][nx] = true;\n        }\n    }\n    bool ok = visited[H-1][W-1];\n    if(ok) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing uint = unsigned int;\nusing pcc = pair<char, char>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\nusing tuplis = array<ll, 3>;\ntemplate<class T> using pq = priority_queue<T, vector<T>, greater<T>>;\nconst ll LINF=0x1fffffffffffffff;\nconst ll MINF=0x7fffffffffff;\nconst int INF=0x3fffffff;\nconst int MOD=1000000007;\nconst int MODD=998244353;\nconst ld DINF=numeric_limits<ld>::infinity();\nconst ld EPS=1e-9;\nconst ld PI=3.1415926535897932;\nconst ll dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst ll dy[] = {1, 0, -1, 0, 1, -1, 1, -1};\n#define overload4(_1,_2,_3,_4,name,...) name\n#define overload3(_1,_2,_3,name,...) name\n#define rep1(n) for(ll i=0;i<n;++i)\n#define rep2(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i<b;++i)\n#define rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) overload4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rrep1(n) for(ll i=(n)-1;i>=0;i--)\n#define rrep2(i,n) for(ll i=(n)-1;i>=0;i--)\n#define rrep3(i,a,b) for(ll i=(b)-1;i>=(a);i--)\n#define rrep4(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rrep(...) overload4(__VA_ARGS__,rrep4,rrep3,rrep2,rrep1)(__VA_ARGS__)\n#define each(i,...) for(auto&& i:__VA_ARGS__)\n#define all1(i) begin(i),end(i)\n#define all2(i,a) begin(i),begin(i)+a\n#define all3(i,a,b) begin(i)+a,begin(i)+b\n#define all(...) overload3(__VA_ARGS__,all3,all2,all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(),(i).rend()\n#define rall2(i,k) (i).rbegin(),(i).rbegin()+k\n#define rall3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rall(...) overload3(__VA_ARGS__,rall3,rall2,rall1)(__VA_ARGS__)\n#define sum(...) accumulate(all(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(all(__VA_ARGS__),0.0L)\n#define elif else if\n#define unless(a) if(!(a))\n#define mp make_pair\n#define mt make_tuple\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;in(__VA_ARGS__)\n#define Sort(a) sort(all(a))\n#define Rev(a) reverse(all(a))\n#define Uniq(a) sort(all(a));a.erase(unique(all(a)),end(a))\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));in(name)\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\ntemplate<class T> auto max(const T& a){ return *max_element(all(a)); }\ntemplate<class T> auto min(const T& a){ return *min_element(all(a)); }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nll intpow(ll a, ll b){ ll ans = 1; while(b){ if(b & 1) ans *= a; a *= a; b /= 2; } return ans; }\nll modpow(ll a, ll b, ll p){ ll ans = 1; while(b){ if(b & 1) (ans *= a) %= p; (a *= a) %= p; b /= 2; } return ans; }\ntemplate<class T, class U> bool chmin(T& a, const U& b){ if(a > b){ a = b; return 1; } return 0; }\ntemplate<class T, class U> bool chmax(T& a, const U& b){ if(a < b){ a = b; return 1; } return 0; }\nvector<pll> factor(ull x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<ll> divisor(ull x){ vector<ll> ans; for(ll i = 1; i * i <= x; i++) if(x % i == 0) ans.push_back(i); rrep(ans.size() - (ans.back() * ans.back() == x)) ans.push_back(x / ans[i]); return ans; }\ntemplate<class T> unordered_map<T, ll> press(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); unordered_map<T,ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\ntemplate<class T> map<T, ll> press_map(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); map<T,ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\nint scan(){ return getchar(); }\nvoid scan(int& a){ scanf(\"%d\", &a); }\nvoid scan(unsigned& a){ scanf(\"%u\", &a); }\nvoid scan(long& a){ scanf(\"%ld\", &a); }\nvoid scan(long long& a){ scanf(\"%lld\", &a); }\nvoid scan(unsigned long long& a){ scanf(\"%llu\", &a); }\nvoid scan(char& a){ do{ a = getchar(); }while(a == ' ' || a == '\\n'); }\nvoid scan(float& a){ scanf(\"%f\", &a); }\nvoid scan(double& a){ scanf(\"%lf\", &a); }\nvoid scan(long double& a){ scanf(\"%Lf\", &a); }\nvoid scan(vector<bool>& a){ for(unsigned i = 0; i < a.size(); i++){ int b; scan(b); a[i] = b; } }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid in(){}\ntemplate <class Head, class... Tail> void in(Head& head, Tail&... tail){ scan(head); in(tail...); }\nvoid print(){ putchar(' '); }\nvoid print(bool a){ printf(\"%d\", a); }\nvoid print(int a){ printf(\"%d\", a); }\nvoid print(unsigned a){ printf(\"%u\", a); }\nvoid print(long a){ printf(\"%ld\", a); }\nvoid print(long long a){ printf(\"%lld\", a); }\nvoid print(unsigned long long a){ printf(\"%llu\", a); }\nvoid print(char a){ printf(\"%c\", a); }\nvoid print(char a[]){ printf(\"%s\", a); }\nvoid print(const char a[]){ printf(\"%s\", a); }\nvoid print(float a){ printf(\"%.15f\", a); }\nvoid print(double a){ printf(\"%.15f\", a); }\nvoid print(long double a){ printf(\"%.15Lf\", a); }\nvoid print(const string& a){ for(auto&& i : a) print(i); }\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ print(p.first); putchar(' '); print(p.second); }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\n#ifdef DEBUG\nvoid err(){ putchar('\\n'); }\ntemplate<class T> void err(const T& t){ print(t); putchar('\\n'); }\ntemplate<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\ntemplate<class... T> void err(const T&...){}\n#endif\nint first(bool i = true){ return out(i?\"first\":\"second\"); }\nint yes(bool i = true){ return out(i?\"yes\":\"no\"); }\nint Yes(bool i = true){ return out(i?\"Yes\":\"No\"); }\nint No(){ return out(\"No\"); }\nint YES(bool i = true){ return out(i?\"YES\":\"NO\"); }\nint NO(){ return out(\"NO\"); }\nint Yay(bool i = true){ return out(i?\"Yay!\":\":(\"); }\nint possible(bool i = true){ return out(i?\"possible\":\"impossible\"); }\nint Possible(bool i = true){ return out(i?\"Possible\":\"Impossible\"); }\nint POSSIBLE(bool i = true){ return out(i?\"POSSIBLE\":\"IMPOSSIBLE\"); }\nvoid Case(ll i){ printf(\"Case #%lld: \", i); }\n\n\n\nsigned main(){\n    LL(h,w);\n    VEC(string,s,h);\n    char a[4][5]={\"6314\",\"2.2.\",\"1364\",\"5.5.\"};\n    vv(bool,ok,h,w);\n    ok[0][0]=1;\n    queue<pll>q;\n    q.emplace(0,0);\n    while(q.size()){\n        ll x,y;\n        tie(x,y)=q.front();\n        q.pop();\n        rep(4){\n            ll x2=x+dx[i],y2=y+dy[i];\n            if(x2<0||h<=x2||y2<0||w<=y2)continue;\n            if(s[x2][y2]==a[x2&3][y2&3]&&!ok[x2][y2]){\n                ok[x2][y2]=1;\n                q.emplace(x2,y2);\n            }\n        }\n    }\n    YES(ok.back().back());\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//#line 2 \"SubstringQueries.cpp\"\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <random>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\n#include <cstdint>\nusing namespace std;\nusing LL = long long;\n\nint H, W;\nvector<string>B;\nbool flag[123][123];\n\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; ++i) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tB.push_back(s);\n\t}\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tif (i % 2 && j % 2) {\n\t\t\t}\n\t\t\telse if (i % 2 == 0 && j % 2 == 0) {\n\t\t\t\tif ((i + j) % 4 == 0 && B[i][j] != '6') {\n\t\t\t\t\tB[i][j] = '#';\n\t\t\t\t}\n\t\t\t\tif ((i + j) % 4 == 2 && B[i][j] != '1') {\n\t\t\t\t\tB[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (i % 2) {\n\t\t\t\tif (i % 4 == 1 && B[i][j] != '2') {\n\t\t\t\t\tB[i][j] = '#';\n\t\t\t\t}\n\t\t\t\tif (i % 4 == 3 && B[i][j] != '5') {\n\t\t\t\t\tB[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (j % 2) {\n\t\t\t\tif (j % 4 == 1 && B[i][j] != '3') {\n\t\t\t\t\tB[i][j] = '#';\n\t\t\t\t}\n\t\t\t\tif (j % 4 == 3 && B[i][j] != '4') {\n\t\t\t\t\tB[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tqueue<pair<int, int>>que;\n\tque.push({ 0,0 });\n\tflag[0][0] = true;\n\tint dx[4] = { 0,1,0,-1 };\n\tint dy[4] = { 1,0,-1,0 };\n\twhile (!que.empty()) {\n\t\tint i = que.front().first;\n\t\tint j = que.front().second;\n\t\tque.pop();\n\t\tfor (int d = 0; d < 4; ++d) {\n\t\t\tint ii = i + dx[d];\n\t\t\tint jj = j + dy[d];\n\t\t\tif (ii < 0 || jj < 0 || ii >= H || jj >= W)continue;\n\t\t\tif (B[ii][jj] != '#' && !flag[ii][jj]) {\n\t\t\t\tque.push({ ii,jj });\n\t\t\t\tflag[ii][jj] = true;\n\t\t\t}\n\t\t}\n\t}\n\tcout << (flag[H - 1][W - 1] ? \"YES\" : \"NO\") << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int H, W;\n    cin >> H >> W;\n    int S[100][100];\n    for(int i=0; i<H; i++){\n        string s;\n        cin >> s;\n        for(int j=0; j<W; j++) S[i][j] = (s[j] == '#' ? -1 : s[j]-'0');\n    }\n\n    auto inside = [&](int i, int j){ return i>=0 && i<H && j>=0 && j<W && S[i][j] != -1; };\n    int dx[] = {-1, 1, 0, 0};\n    int dy[] = {0, 0, -1, 1};\n    auto bottom = [](int i, int j){\n        if(i%4 == 0){\n            vector<int> v = {6, 3, 1, 4};\n            return v[j%4];\n        }\n        if(i%4 == 2){\n            vector<int> v = {1, 3, 6, 4};\n            return v[j%4];\n        }\n        if(j%4 == 0){\n            vector<int> v = {6, 2, 1, 5};\n            return v[i%4];\n        }\n        if(j%4 == 2){\n            vector<int> v = {1, 2, 6, 5};\n            return v[i%4];\n        }\n        exit(-1);\n    };\n\n    bool exist[100][100] = {0};\n    exist[0][0] = 1;\n    queue<vector<int>> que;\n    que.push({0, 0});\n    while(que.size()){\n        auto v = que.front(); que.pop();\n        int i = v[0], j = v[1];\n        for(int k=0; k<4; k++){\n            int x = i+dx[k], y = j+dy[k];\n            if(!inside(x, y)) continue;\n            if(exist[x][y]) continue;\n            if(S[x][y] == bottom(x, y)){\n                exist[x][y] = 1;\n                que.push({x, y});\n            }\n        }\n    }\n    cout << (exist[H-1][W-1] ? \"YES\" : \"NO\") << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> vvec;\ntypedef vector<vvec> vvvec;\ntypedef vector<vvvec> vvvvec;\n\nstruct state {\n    int x, y;\n    int front, right, down;\n};\n\nconst int INF = 1145141919;\nint h, w;\n\nbool inRange(int x, int y) {\n    return 0 <= x && x < h && 0 <= y && y < w;\n}\n\nint main() {\n    cin >> h >> w;\n    vector<string> ban(h);\n    for (int i = 0; i < h; i++)cin >> ban[i];\n\n    vvvvec dis(h, vvvec(w, vvec(7, vec(7, INF))));\n    dis[0][0][2][3] = 0;\n    queue<state> que;\n    que.push({0, 0, 2, 3, 6});\n    while (!que.empty()) {\n        auto now = que.front();\n        que.pop();\n        int cost = dis[now.x][now.y][now.front][now.right] + 1;\n\n        if (inRange(now.x - 1, now.y)) {\n            state after = {now.x - 1, now.y, now.down, now.right, 7 - now.front};\n            if (ban[after.x][after.y] - '0' == after.down && dis[after.x][after.y][after.front][after.right] > cost) {\n                dis[after.x][after.y][after.front][after.right] = cost;\n                que.push(after);\n            }\n        }\n        if (inRange(now.x + 1, now.y)) {\n            state after = {now.x + 1, now.y, 7 - now.down, now.right, now.front};\n            if (ban[after.x][after.y] - '0' == after.down && dis[after.x][after.y][after.front][after.right] > cost) {\n                dis[after.x][after.y][after.front][after.right] = cost;\n                que.push(after);\n            }\n        }\n        if (inRange(now.x, now.y - 1)) {\n            state after = {now.x, now.y - 1, now.front, now.down, 7 - now.right};\n            if (ban[after.x][after.y] - '0' == after.down && dis[after.x][after.y][after.front][after.right] > cost) {\n                dis[after.x][after.y][after.front][after.right] = cost;\n                que.push(after);\n            }\n        }\n        if (inRange(now.x, now.y + 1)) {\n            state after = {now.x, now.y + 1, now.front, 7 - now.down, now.right};\n            if (ban[after.x][after.y] - '0' == after.down && dis[after.x][after.y][after.front][after.right] > cost) {\n                dis[after.x][after.y][after.front][after.right] = cost;\n                que.push(after);\n            }\n        }\n    }\n\n    bool ret = false;\n    for (int i = 0; i <= 6; i++) {\n        for (int j = 0; j <= 6; j++) {\n            if (dis[h - 1][w - 1][i][j] < INF)ret = true;\n        }\n    }\n\n    cout << (ret ? \"YES\" : \"NO\") << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma target(\"avx\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef unordered_map<ll, ll> U_MAP;\ntypedef priority_queue<ll> pq;\ntypedef priority_queue<ll, vector<ll>, greater<ll>> rpq;\nconstexpr ll INF = 1e9, MOD = 1e9 + 7, ohara = 1e6 + 10;\nconstexpr ll LINF = 1e18;\n\n#define rep(i, n) for (ll(i) = 0; (i) < (int)(n); (i)++)\n#define rrep(i, a, b) for (ll i = (a); i < (b); i++)\n#define rrrep(i, a, b) for (ll i = (a); i >= (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define Size(n) (n).size()\n#define Cout(x) cout << (x) << endl\n#define doublecout(a) cout << fixed << setprecision(15) << a << endl;\n#define fi first\n#define se second\n#define m_p make_pair\n#define p_b push_back\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(const char* s) { return to_string((string)s); }\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto& x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n\n//------ Believe yourself as a genius!!!!!! ------\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, 1, 0, -1};\n// int dy[]={-1,0,1,-1,1,-1,0,1};int dx[]={-1,-1,-1,0,0,1,1,1};\nstring alph(\"abcdefghijklmnopqrstuvwxyz\");\nchar s[200][200];\nll n, cnt, ans, a, b, c, d, tmp, m, h, w, x, y, sum, k, q;\nll yoko1[] = {6, 3, 1, 4};\nll tate1[] = {6, 2, 1, 5};\nll yoko2[] = {1, 3, 6, 4};\nll tate2[] = {5, 1, 2, 6};\nll fil[200][200];\n\nint main(void) {\n  cin.tie(0);\n  cout.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> h >> w;\n  rep(i, h) rep(j, w) cin >> s[i][j];\n  rep(i, h) {\n    rep(j, w) {\n      if (i % 2 == 1) continue;\n      if ((i / 2) % 2 == 0)\n        fil[i][j] = yoko1[j % 4];\n      else\n        fil[i][j] = yoko2[j % 4];\n    }\n  }\n  rep(i, h) {\n    rep(j, w) {\n      if (i % 2 == 0) continue;\n      if (j % 2 == 1) continue;\n      if ((i - 1) / 2 % 2 == 0)\n        fil[i][j] = 2;\n      else\n        fil[i][j] = 5;\n    }\n  }\n\n  ll min_cost[h + 10][w + 10];\n  rep(i, h) rep(j, w) min_cost[i][j] = LINF;\n  queue<P> qu;\n  qu.push({0LL, 0LL});\n  min_cost[0][0] = 0;\n\n  while (!qu.empty()) {\n    auto p = qu.front();\n    qu.pop();\n    rep(i, 4) {\n      int nx = p.se + dx[i], ny = p.fi + dy[i];\n      if (nx < 0 || ny < 0 || nx >= w || ny >= h) continue;\n      if (s[ny][nx] == '#') continue;\n      if (min_cost[p.fi][p.se] + 1 >= min_cost[ny][nx]) continue;\n      if ((s[ny][nx] - '0') != fil[ny][nx]) continue;\n      min_cost[ny][nx] = min_cost[p.fi][p.se] + 1;\n      qu.push({ny, nx});\n    }\n  }\n  ans = min_cost[h - 1][w - 1];\n  if (ans == LINF)\n    Cout(\"NO\");\n  else\n    Cout(\"YES\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\nstruct UnionFind\n{\n    vector<int> par, sz;\n    int n_cc;\n\n    UnionFind(int N){\n        par = vector<int>(N);\n        REP(i, N) par[i] = i;\n        sz = vector<int>(N, 1);\n        n_cc = N;\n    }\n\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return;\n\n        if(sz[x] < sz[y]) swap(x, y);\n\n        par[y] = x;\n        sz[x] += sz[y];\n        n_cc--;\n    }\n\n    bool is_union(int x, int y){\n        x = find(x);\n        y = find(y);\n        return x == y;\n    }\n\n    int union_size(int x){\n        return sz[find(x)];\n    }\n\n};\n\n\nsigned main(){\n\n    int H, W; cin >> H >> W;\n    vector<string> s(H); cin >> s;\n\n    int r0[4] = {6, 3, 1, 4}, r1[4] = {1, 3, 6, 4};\n    int h0[4] = {6, 2, 1, 5}, h1[4] = {1, 2, 6, 5};\n\n    REP(i, H) REP(j, W) if(i % 2 == 0 || j % 2 == 0){\n        int x;\n        if(i % 2 == 0){\n            if((i / 2) % 2 == 0){\n                x = r0[j % 4];\n            }else{\n                x = r1[j % 4];\n            }\n        }else{\n            if((j / 2) % 2 == 0){\n                x = h0[i % 4];\n            }else{\n                x = h1[i % 4];\n            }\n        }\n        if(s[i][j] != '0' + x) s[i][j] = '#';\n    }\n    //vdebug(s);\n\n    UnionFind UF(H * W);\n    REP(i, H) REP(j, W) if(s[i][j] != '#'){\n        if(i > 0 && s[i - 1][j] != '#') UF.unite(i * W + j, (i - 1) * W + j);\n        if(j > 0 && s[i][j - 1] != '#') UF.unite(i * W + j, i * W + j - 1);\n    }\n    Ans(UF.is_union(0, H * W - 1), \"YES\", \"NO\");\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <climits>\n#include <numeric>\n#include<stdio.h>\n#include <queue>\n#include <iomanip>\n#include <float.h>\n#include <set>\n#include<functional>\n#include <stack>\n#include <time.h>\n#include <climits>\n#include <bitset>\n#include <fstream>\nusing namespace std;\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\ntypedef pair<int, int> p;\nvector< int64_t > divisor(int64_t n) {\n\tvector< int64_t > ret;\n\tfor (int64_t i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(begin(ret), end(ret));\n\treturn (ret);\n}\nlong long mod = 1e9 + 7;\np mov[4] = { p(0,1),p(1,0),p(-1,0),p(0,-1) };\nint main(int argc, char* argv[]) {\n\tint h, w;\n\tcin >> h >> w;\n\tint grid[103][103];\n\tint visit[103][103];\n\tfor (int i = 0; i < 103; i++) {\n\t\tfor (int j = 0; j < 103; j++) {\n\t\t\tvisit[i][j] = 0;\n\t\t}\n\t}\n\tfor (int i = 1; i <= h; i++) {\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor (int j = 1; j <= w; j++) {\n\t\t\tif (i % 2 == 0 && j % 2 == 0) {\n\t\t\t\tgrid[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint num;\n\t\t\tint s = i / 2;\n\t\t\tint t = j / 2;\n\t\t\tif (i % 2 == 1 && j % 2 == 1) {\n\t\t\t\tif ((s + t) % 2 == 0)num = 6;\n\t\t\t\telse num = 1;\n\t\t\t}\n\t\t\tif (i % 2 == 1 && j % 2 == 0) {\n\t\t\t\tif (t % 2 == 1)num = 3;\n\t\t\t\telse num = 4;\n\t\t\t}\n\t\t\tif (i % 2 == 0 && j % 2 == 1) {\n\t\t\t\tif (s % 2 == 1)num = 2;\n\t\t\t\telse num = 5;\n\t\t\t}\n\t\t\tif (str[j-1] - '0' == num)grid[i][j] = 1;\n\t\t\telse grid[i][j] = 0;\n\t\t}\n\t}\n\tqueue<p>que;\n\tque.push(p(1, 1));\n\tvisit[1][1] = 1;\n\twhile (!que.empty()) {\n\t\tp now = que.front();\n\t\tque.pop();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tp next = p(now.first + mov[i].first, now.second + mov[i].second);\n\t\t\tif (next.first <= h &&next.first>=1&& next.second <= w &&next.second>=1&& visit[next.first][next.second] == 0 && grid[next.first][next.second] == 1) {\n\t\t\t\tque.push(next);\n\t\t\t\tvisit[next.first][next.second] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (visit[h][w] == 1) {\n\t\tcout << \"YES\\n\";\n\t}\n\telse {\n\t\tcout << \"NO\\n\";\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\nint h, w;\nchar c[110][110];\nstring s[4] = {\"6314\", \"2020\", \"1364\", \"5050\"};\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\nbool used[110][110];\n\nvoid dfs(int x, int y){\n    if(used[x][y]) return;\n    used[x][y] = true;\n    rep(i, 4){\n        int nx = x+dx[i], ny = y+dy[i];\n        if(0<=nx && nx<100 && 0<=ny && ny<100){\n            if(c[x][y] == s[x%4][y%4] && c[nx][ny] == s[nx%4][ny%4]){\n                dfs(nx, ny);\n            }\n        }\n    }\n}\n\nint main(){\n    scanf(\"%d%d\", &h, &w);\n    rep(i, 100)rep(j, 100) c[i][j] = '/';\n    rep(i, h)rep(j, w) scanf(\" %c\", &c[i][j]);\n    rep(i, 100)rep(j, 100) used[i][j] = false;\n    dfs(0, 0);\n    puts(used[h-1][w-1] ? \"YES\" : \"NO\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\ntypedef pair<int, int> P;\ntypedef long long ll;\nbool dp[110][110];\nvector<int> dx = {0, 1, 0, -1};\nvector<int> dy = {1, 0, -1, 0};\nvector<string> tugi = {\n    \"6314\",\n    \"2#2#\",\n    \"1364\",\n    \"5#5#\"\n};\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int h, w;\n    cin >> h >> w;\n    vector<string> s(h);\n    rep(i, h)\n    {\n        cin >> s[i];\n    }\n    dp[0][0] = true;\n    queue<P> que;\n    que.push(P(0, 0));\n    while (!que.empty())\n    {\n        P p = que.front();\n        que.pop();\n        for (int i = 0; i < 4; i++)\n        {\n            if (p.first + dx[i] < 0 || p.first + dx[i] >= w)\n            {\n                continue;\n            }\n            if (p.second + dy[i] < 0 || p.second + dy[i] >= h)\n            {\n                continue;\n            }\n            if (s[p.second + dy[i]][p.first + dx[i]] == '#')\n            {\n                continue;\n            }\n            if (dp[p.second + dy[i]][p.first + dx[i]])\n            {\n                continue;\n            }\n            int val = s[p.second + dy[i]][p.first + dx[i]] - '0';\n            int now = s[p.second][p.first] - '0';\n            char c = tugi[(p.second + dy[i])%4][(p.first + dx[i])%4];\n            if (val != c-'0')\n            {\n                continue;\n            }\n            dp[p.second + dy[i]][p.first + dx[i]] = true;\n            que.push(P(p.first + dx[i], p.second + dy[i]));\n        }\n    }\n    if (dp[h - 1][w - 1])\n    {\n        cout << \"YES\" << endl;\n    }\n    else\n    {\n        cout << \"NO\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> s(H + 2);\n    rep(i, W + 2) {\n        s[0].push_back('#');\n        s[H + 1].push_back('#');\n    }\n    rep(i, H) {\n        cin >> s[i + 1];\n        s[i + 1] = \"#\" + s[i + 1] + \"#\";\n    }\n    //rep(i, H + 2) cout << s[i] << \"\\n\";\n    vector<vector<vector<bool>>> grid(H + 2, vector<vector<bool>>(W + 2, vector<bool>(6, false)));\n    queue<vector<int>> q;\n    q.push({1, 1, 4, 0, 5, 4, 1, 3, 2});//xyzUDFBLR\n    grid[1][1][5] = true;\n    while (!q.empty()) {\n        auto p = q.front();\n        q.pop();\n        int x = p[0], y = p[1], z = p[2];\n        if (!grid[x - 1][y][p[3]] && s[x - 1][y] - '1' == p[5]) {\n            q.push({x - 1, y, p[3], p[6], p[5], p[3], p[4], p[7], p[8]});\n            grid[x - 1][y][p[3]] = true;\n        }\n        if (!grid[x + 1][y][p[4]] && s[x + 1][y] - '1' == p[6]) {\n            q.push({x + 1, y, p[4], p[5], p[6], p[4], p[3], p[7], p[8]});\n            grid[x + 1][y][p[4]] = true;\n        }\n        if (!grid[x][y - 1][p[5]] && s[x][y - 1] - '1' == p[7]) {\n            q.push({x, y - 1, p[5], p[8], p[7], p[5], p[6], p[3], p[4]});\n            grid[x][y - 1][p[5]] = true;\n        }\n        if (!grid[x][y + 1][p[5]] && s[x][y + 1] - '1' == p[8]) {\n            q.push({x, y + 1, p[5], p[7], p[8], p[5], p[6], p[4], p[3]});\n            grid[x][y + 1][p[5]] = true;\n        }\n    }\n    rep(i, 6) {\n        if (grid[H][W][i]) {\n            cout << \"YES\\n\";\n            return 0;\n        }\n    }\n    cout << \"NO\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long int;\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); ++i)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); --i)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); ++i)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); --i)\n#define inc(i, n)  incID(i, 0, n)\n#define dec(i, n)  decID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec1(i, n) decII(i, 1, n)\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define FR front()\n#define BA back()\n#define ALL(v) v.begin(), v.end()\n#define RALL(v) v.rbegin(), v.rend()\nauto setmin   = [](auto & a, auto b) { return (b <  a ? a = b, true : false); };\nauto setmax   = [](auto & a, auto b) { return (b >  a ? a = b, true : false); };\nauto setmineq = [](auto & a, auto b) { return (b <= a ? a = b, true : false); };\nauto setmaxeq = [](auto & a, auto b) { return (b >= a ? a = b, true : false); };\n#define SI(v) static_cast<int>(v.size())\n#define RF(e, v) for(auto & e: v)\n#define until(e) while(! (e))\n#define if_not(e) if(! (e))\n#define ef else if\n#define UR assert(false)\n#define IN(T, ...) T __VA_ARGS__; IN_(__VA_ARGS__);\nvoid IN_() { };\ntemplate<typename T, typename ... U> void IN_(T & a, U & ... b) { cin >> a; IN_(b ...); };\ntemplate<typename T> void OUT(T && a) { cout << a << endl; }\ntemplate<typename T, typename ... U> void OUT(T && a, U && ... b) { cout << a << \" \"; OUT(b ...); }\n\n// ---- ----\n\nclass UnionFind {\nprivate:\n\tint n, s;\n\tvector<int> t;\n\tvector<vector<int>> v;\npublic:\n\tUnionFind(int arg_n = 0) { init(arg_n); }\n\tvoid init(int arg_n) {\n\t\tn = s = arg_n;\n\t\tt.clear();\n\t\tv.clear();\n\t\tinc(i, n) { t.PB(i); v.EB(1, i); }\n\t}\n\tint get_n() { return n; }\n\tint size() { return s; }\n\tint id(int x) { return t.at(x); }\n\tconst vector<vector<int>> & get_v() { return v; }\n\tbool unite(int x, int y) {\n\t\tx = id(x);\n\t\ty = id(y);\n\t\tif(x == y) { return false; }\n\t\tif(v[x].size() < v[y].size()) { swap(x, y); }\n\t\tfor(auto & e: v[y]) { v[x].PB(e); t[e] = x; }\n\t\tv[y].clear();\n\t\ts--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return (id(x) == id(y)); }\n\tconst vector<int> & operator[](int x) { return v[id(x)]; }\n\tfriend ostream & operator<<(ostream & os, const UnionFind & uf) {\n\t\tinc(i, uf.n) { os << i << \": \"; for(auto & e: uf.v[i]) { os << e << \" \"; } os << \"\\n\"; }\n\t\treturn os;\n\t}\n};\n\n// ---- ----\n\ntemplate<typename T> istream & operator>>(istream & s, vector<T> & v) { RF(e, v) { s >> e; } return s; }\ntemplate<typename T> ostream & operator<<(ostream & s, vector<T> const & v) {\n\tinc(i, SI(v)) { s << (i == 0 ? \"\" : \" \") << v[i]; }\n\treturn s;\n}\n\nint main() {\n\tIN(int, h, w);\n\tvector<string> s(h);\n\tcin >> s;\n\t\n\tvector<string> t = {\n\t\t\"6314\",\n\t\t\"2-2-\",\n\t\t\"1364\",\n\t\t\"5-5-\",\n\t};\n\t\n\tinc(i, h) {\n\tinc(j, w) {\n\t\tif(s[i][j] == t[i % 4][j % 4]) { s[i][j] = 'O'; }\n\t}\n\t}\n\t\n\tauto id = [&](int i, int j) { return w * i + j; };\n\tUnionFind uf(h * w);\n\tinc(i, h) {\n\tinc(j, w) {\n\t\tif_not(s[i][j] == 'O') { continue; }\n\t\tif(i + 1 < h && s[i + 1][j] == 'O') { uf.unite(id(i, j), id(i + 1, j)); }\n\t\tif(j + 1 < w && s[i][j + 1] == 'O') { uf.unite(id(i, j), id(i, j + 1)); }\n\t}\n\t}\n\t\n\tOUT(uf.same(id(0, 0), id(h - 1, w - 1)) ? \"YES\" : \"NO\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief ユーザ定義リテラル\n * @author えびちゃん\n */\n\n#ifndef H_int_literals\n#define H_int_literals\n\n#include <cstddef>\n#include <cstdint>\n\nconstexpr intmax_t  operator \"\"_jd(unsigned long long n) { return n; }\nconstexpr uintmax_t operator \"\"_ju(unsigned long long n) { return n; }\nconstexpr size_t    operator \"\"_zu(unsigned long long n) { return n; }\nconstexpr ptrdiff_t operator \"\"_td(unsigned long long n) { return n; }\n\n#endif  /* !defined(H_int_literals) */\n\n/**\n * @brief 多次元 vector の作成\n * @author えびちゃん\n */\n\n#ifndef H_make_vector\n#define H_make_vector\n\n#include <cstddef>\n#include <type_traits>\n#include <vector>\n\nnamespace detail {\n  template <typename Tp, size_t N>\n  std::vector<Tp> make_vector(\n      std::vector<size_t>& sizes,\n      typename std::enable_if<(N == 1), Tp const&>::type x\n  ) {\n    return std::vector<Tp>(sizes[0], x);\n  }\n  template <typename Tp, size_t N>\n  auto make_vector(\n      std::vector<size_t>& sizes,\n      typename std::enable_if<(N > 1), Tp const&>::type x\n  ) {\n    size_t size = sizes[N-1];\n    sizes.pop_back();\n    return std::vector<decltype(make_vector<Tp, N-1>(sizes, x))>(\n        size, make_vector<Tp, N-1>(sizes, x)\n    );\n  }\n}  // detail::\n\ntemplate <typename Tp, size_t N>\nauto make_vector(size_t const(&sizes)[N], Tp const& x = Tp()) {\n  std::vector<size_t> s(N);\n  for (size_t i = 0; i < N; ++i) s[i] = sizes[N-i-1];\n  return detail::make_vector<Tp, N>(s, x);\n}\n\n#endif  /* !defined(H_make_vector) */\n\n#include <cstdio>\n#include <cstdint>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <array>\n#include <tuple>\n\nstd::array<size_t, 4> const di{{-1_zu, 0, 1, 0}};\nstd::array<size_t, 4> const dj{{0, -1_zu, 0, 1}};\n\nint main() {\n  size_t h, w;\n  scanf(\"%zu %zu\", &h, &w);\n\n  std::vector<std::string> s(h);\n  for (auto& si: s) {\n    char buf[128];\n    scanf(\"%s\", buf);\n    si = buf;\n  }\n\n  std::vector<std::string> t(h, std::string(w, '.'));\n  for (size_t i = 0; i < h; ++i) {\n    for (size_t j = 0; j < w; ++j) {\n      if (s[i][j] == '#') {\n        t[i][j] = '#';\n      } else if (i % 4 == 1 && s[i][j] == '2') {\n        t[i][j] = '.';\n      } else if (i % 4 == 3 && s[i][j] == '5') {\n        t[i][j] = '.';\n      } else if (j % 4 == 1 && s[i][j] == '3') {\n        t[i][j] = '.';\n      } else if (j % 4 == 3 && s[i][j] == '4') {\n        t[i][j] = '.';\n      } else if ((i+j) % 4 == 0 && s[i][j] == '6') {\n        t[i][j] = '.';\n      } else if ((i+j) % 4 == 2 && s[i][j] == '1') {\n        t[i][j] = '.';\n      } else {\n        t[i][j] = '#';\n      }\n    }\n  }\n\n  using zahyo = std::pair<size_t, size_t>;\n  auto dp = make_vector({h, w}, false);\n  std::queue<zahyo> q;\n  q.emplace(0, 0);\n  dp[0][0] = true;\n  while (!q.empty()) {\n    size_t i, j;\n    std::tie(i, j) = q.front();\n    q.pop();\n\n    for (size_t k = 0; k < 4; ++k) {\n      size_t ni = i + di[k];\n      size_t nj = j + dj[k];\n      if (!(ni < h && nj < w)) continue;\n      if (t[ni][nj] == '#') continue;\n      if (dp[ni][nj]) continue;\n      dp[ni][nj] = true;\n      q.emplace(ni, nj);\n    }\n  }\n\n  puts(dp[h-1][w-1]? \"YES\": \"NO\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> rot = {\n  {4, 2, 0, 3, 1, 5},\n  {2, 4, 1, 3, 0, 5},\n  {5, 3, 2, 0, 4, 1},\n  {3, 5, 2, 1, 4, 0},\n};\nint dx[] = {1, -1, 0, 0}, dy[] = {0, 0, 1, -1};\nset<vector<int>> g[101][101];\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  int h, w;\n  cin >> h >> w;\n  vector<string> in(h);\n  for (int i = 0; i < h; i++) cin >> in[i];\n  g[0][0].insert({6, 1, 2, 3, 5, 4});\n  vector<pair<int, int>> que;\n  vector<vector<bool>> vis(h, vector<bool>(w));\n  vis[0][0] = true;\n  que.emplace_back(0, 0);\n  for (int u = 0; u < (int) que.size(); u++) {\n    for (int i = 0; i < 4; i++) {\n      int x = que[u].first + dx[i];\n      int y = que[u].second + dy[i];\n      if (x < 0 || x >= h || y < 0 || y >= w || in[x][y] == '#') continue;\n      for (auto& v : g[que[u].first][que[u].second]) {\n        vector<int> nxt(6);\n        for (int j = 0; j < 6; j++) {\n          nxt[rot[i][j]] = v[j];\n        }\n        if (nxt[0] != (in[x][y] - '0')) continue;\n        g[x][y].insert(nxt);\n        if (!vis[x][y]) {\n          vis[x][y] = true;\n          que.emplace_back(x, y);\n        } else {\n        }\n      }\n    }\n  }\n  // for (int i = 0; i < h; i++) {\n  //   for (int j = 0; j < w; j++) cerr << vis[i][j] << \" \";\n  //   cerr << endl;\n  // }\n  cout << (vis[h - 1][w - 1] ? \"YES\\n\" : \"NO\\n\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define Fr(i,n) for(int i=1;i<=(n);++i)\n#define ifr(i,n) for(int i=(n)-1;i>=0;--i)\n#define iFr(i,n) for(int i=(n);i>0;--i)\nusing P=pair<int,int>;\n\nstruct Dice\n{\n    // int x, y;\n    int l, r, f, b, d, u;\n\n    void RollN()\n    {\n        //  --y;\n        int buff = d;\n        d = f;\n        f = u;\n        u = b;\n        b = buff;\n    }\n\n    void RollS()\n    {\n        // ++y;\n        int buff = d;\n        d = b;\n        b = u;\n        u = f;\n        f = buff;\n    }\n\n    void RollL() // ----->\n    {\n        int buff = f;\n        f = l;\n        l = b;\n        b = r;\n        r = buff;\n    }\n\n    void RollR() // <------\n    {\n        int buff = f;\n        f = r;\n        r = b;\n        b = l;\n        l = buff;\n    }\n\n    void RollE() // .o -> o.\n    {\n        // --x;\n        int buff = d;\n        d = l;\n        l = u;\n        u = r;\n        r = buff;\n    }\n\n\n    void RollW() // o. -> .o\n    {\n        //  ++x;\n        int buff = d;\n        d = r;\n        r = u;\n        u = l;\n        l = buff;\n    }\n\n\n    vector< Dice > makeDice()\n    {\n        vector< Dice > ret;\n        for(int i = 0; i < 6; i++) {\n            Dice d(*this);\n            if(i == 1) d.RollN();\n            if(i == 2) d.RollS();\n            if(i == 3) d.RollS(), d.RollS();\n            if(i == 4) d.RollL();\n            if(i == 5) d.RollR();\n            for(int j = 0; j < 4; j++) {\n                ret.emplace_back(d);\n                d.RollE();\n            }\n        }\n        return (ret);\n    }\n};\n\nstruct PD{\n    P p;\n    Dice d;\n    PD(P p,Dice d):p(p),d(d){}\n    bool operator<(const PD &x) const {return this->p<x.p;}\n};\n\nmap<PD,bool> mp;\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    istream& in(cin);\n    ostream& out(cout);\n    Dice D;\n    D.u=1;D.f=2;D.r=3,D.l=4,D.b=5,D.d=6;\n    int h,w;\n    in>>h>>w;\n    vector<string> s(h);\n    for(auto&c:s) in>>c;\n    if(s[0][0]!='6') return puts(\"NO\"),0;\n    queue<pair<P,Dice>> q;\n    q.emplace(make_pair(0,0),D);\n    while(!q.empty()){\n        P p;\n        int i,j;\n        Dice d;\n        tie(p,d)=q.front();\n        tie(i,j)=p;\n        q.pop();\n        if(i==h-1&&j==w-1) return puts(\"YES\"),0;\n        if(i>0&&s[i-1][j]!='#'){\n            d.RollS();\n            if(d.d==s[i-1][j]-'0'&&!mp[PD(P(i-1,j),d)]){\n                mp[PD(P(i-1,j),d)]=true;\n                q.emplace(make_pair(i-1,j),d);\n            }\n            d.RollN();\n        }\n        if(i<h-1&&s[i+1][j]!='#'){\n            d.RollN();\n            if(d.d==s[i+1][j]-'0'&&!mp[PD(P(i+1,j),d)]){\n                mp[PD(P(i+1,j),d)]=true;\n                q.emplace(make_pair(i+1,j),d);\n            }\n            d.RollS();\n        }\n        if(j>0&&s[i][j-1]!='#'){\n            d.RollE();\n            if(d.d==s[i][j-1]-'0'&&!mp[PD(P(i,j-1),d)]){\n                mp[PD(P(i,j-1),d)]=true;\n                q.emplace(make_pair(i,j-1),d);\n            }\n            d.RollW();\n        }\n        if(j<w-1&&s[i][j+1]!='#'){\n            d.RollW();\n            if(d.d==s[i][j+1]-'0'&&!mp[PD(P(i,j+1),d)]){\n                mp[PD(P(i,j+1),d)]=true;\n                q.emplace(make_pair(i,j+1),d);\n            }\n            d.RollE();\n        }\n    }\n    puts(\"NO\");\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n　　　∫ ∫ ∫\n　　　ノヽ\n　　（＿　 ）\n　（＿　　　 ）\n（＿＿＿＿＿＿ ）\n　ヽ(´･ω･)ﾉ　\n　　 |　 /\n　　 UU\n*/\n#pragma region macro\n#include <bits/stdc++.h>\ntypedef long long int64;\nusing namespace std;\nusing P = pair<int64, int64>;\ntypedef vector<int> vi;\nconst int MOD = (int)1e9 + 7;\nconst int64 INF = 1LL << 62;\nconst int inf = 1<<30;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i,s,n) for (int i = s; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end() //コンテナじゃないと使えない!!\n#define debug(x) cerr << #x << \": \" << x << \"\\n\";\n#define mp make_pair\n#define bn '\\n'\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T> &V){\n    int N = V.size();\n    REP(i,N){\n        os << V[i];\n        if (i!=N-1) os << \" \";\n    }\n    os << \"\\n\";\n    return os;\n}\ntemplate <typename T,typename S>\nostream& operator<<(ostream& os, pair<T,S> const&P){\n    os << \"(\";\n    os << P.first;\n    os << \" , \";\n    os << P.second;\n    os << \")\";\n    return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, set<T> &S){\n    auto it=S.begin();\n    while(it!=S.end()){\n        os << *it;\n        os << \" \";\n        it++;\n    }\n    os << \"\\n\";\n    return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, queue<T> q){\n    while(q.size()){\n        os << q.front();\n        os << \",\";\n        q.pop();\n    }\n    return os;\n}\nvector<pair<int,int>> dxdy = {mp(0,1),mp(1,0),mp(-1,0),mp(0,-1)};\n#pragma endregion\n//fixed<<setprecision(10)<<ans<<endl;\n\n\nvector<string> grid;\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int H,W;\n    cin >> H >> W;\n    grid.resize(H);\n    if(H%2==0 and W%2==0){\n        cout << \"NO\" << bn;\n        return 0;\n    }\n    REP(i,H){\n        cin >> grid[i];\n    }\n    //とりあえずH&1 and W&1を仮定して解く\n    int H_half = (H+1)/2;\n    int W_half = (W+1)/2;\n    queue<pair<int,int>> q;\n    q.push(mp(0,0));\n    vector<vector<bool>> visited(H,vector<bool> (W,false));\n    string pattern_col_1 = \"156\", pattern_col_1_rev = \"126\";\n    string pattern_row_1 = \"146\", pattern_row_1_rev = \"136\";\n    string pattern_col_6 = \"621\", pattern_col_6_rev = \"651\";\n    string pattern_row_6 = \"631\", pattern_row_6_rev = \"641\";\n    int h,w;\n    while(not q.empty()){\n        tie(h,w) = q.front(); q.pop();\n        // debug(mp(h,w))\n        if(visited[h][w]) continue;\n        visited[h][w] = true;\n        //うえ\n        if(h and not visited[h-2][w]){\n            string s;\n            s += grid[h][w];\n            s += grid[h-1][w];\n            s += grid[h-2][w];\n            // debug(s)\n            string t;\n            if(grid[h][w] == '1'){\n                if((w/2)&1){ //反転\n                    t = pattern_col_1;\n                }else{\n                    t = pattern_col_1_rev;\n                }\n                // debug(t)\n                if(s==t){\n                    if(visited[h-2][w]) continue;\n                    q.push(mp(h-2,w));\n                }\n            }else{\n                if((w/2)&1){ //反転\n                    t = pattern_col_6;\n                }else{\n                    t = pattern_col_6_rev;\n                }\n                if(s==t){\n                    if(visited[h-2][w]) continue;\n                    q.push(mp(h-2,w));\n                }\n            }\n        }\n        //した\n        if(h+2<H and not visited[h+2][w]){\n            string s;\n            s += grid[h][w];\n            s += grid[h+1][w];\n            s += grid[h+2][w];\n            // debug(s)\n            string t;\n            if(grid[h][w] == '1'){\n                if((w/2)&1){ //反転\n                    t = pattern_col_1_rev;\n                }else{\n                    t = pattern_col_1;\n                }\n                if(s==t){\n                    if(visited[h+2][w]) continue;\n                    q.push(mp(h+2,w));\n                }\n            }else{\n                if((w/2)&1){ //反転\n                    t = pattern_col_6_rev;\n                }else{\n                    t = pattern_col_6;\n                }\n                if(s==t){\n                    if(visited[h+2][w]) continue;\n                    q.push(mp(h+2,w));\n                }\n            }\n        }\n        //ひだり\n        if(w and not visited[h][w-2]){\n            string s;\n            s += grid[h][w];\n            s += grid[h][w-1];\n            s += grid[h][w-2];\n            // debug(s)\n            string t;\n            if(grid[h][w] == '1'){\n                if((h/2)&1){ //反転\n                    t = pattern_row_1;\n                }else{\n                    t = pattern_row_1_rev;\n                }\n                if(s==t){\n                    if(visited[h][w-2]) continue;\n                    q.push(mp(h,w-2));\n                }\n            }else{\n                if((h/2)&1){ //反転\n                    t = pattern_row_6;\n                }else{\n                    t = pattern_row_6_rev;\n                }\n                if(s==t){\n                    if(visited[h][w-2]) continue;\n                    q.push(mp(h,w-2));\n                }\n            }\n        }\n        //みぎ\n        if(w+2<W and not visited[h][w+2]){\n            string s;\n            s += grid[h][w];\n            s += grid[h][w+1];\n            s += grid[h][w+2];\n            // debug(s)\n            string t;\n            if(grid[h][w] == '1'){\n                if((h/2)&1){ //反転\n                    t = pattern_row_1_rev;\n                }else{\n                    t = pattern_row_1;\n                }\n                // debug(t)\n                if(s==t){\n                    if(visited[h][w+2]) continue;\n                    q.push(mp(h,w+2));\n                }\n            }else{\n                if((h/2)&1){ //反転\n                    t = pattern_row_6_rev;\n                }else{\n                    t = pattern_row_6;\n                }\n                if(s==t){\n                    if(visited[h][w+2]) continue;\n                    q.push(mp(h,w+2));\n                }\n            }\n        }\n        // debug(q)\n    }\n    // debug(visited)\n    if(H&1 and W&1){\n        if(visited[H-1][W-1]){\n            cout << \"YES\" << bn;\n        }else{\n            cout << \"NO\" << bn;\n        }\n    }else{\n        if(H%2==0){\n            if(visited[H-2][W-1]){\n                if(grid[H-2][W-1] == '1'){\n                    if(((W-1)/2)&1){ //反転 \n                        if(grid[H-1][W-1] == '2'){\n                            cout << \"YES\" << bn;\n                        }else{\n                            cout << \"NO\" << bn;\n                        }\n                    }else{\n                        if(grid[H-1][W-1] == '5'){\n                            cout << \"YES\" << bn;\n                        }else{\n                            cout << \"NO\" << bn;\n                        }\n                    }\n                }else{\n                    if(((W-1)/2)&1){ //反転 \n                        if(grid[H-1][W-1] == '5'){\n                            cout << \"YES\" << bn;\n                        }else{\n                            cout << \"NO\" << bn;\n                        }\n                    }else{\n                        if(grid[H-1][W-1] == '2'){\n                            cout << \"YES\" << bn;\n                        }else{\n                            cout << \"NO\" << bn;\n                        }\n                    }\n                }\n            }else{\n                cout << \"NO\" << bn;\n            }\n        }else{\n            if(visited[H-1][W-2]){\n                if(grid[H-1][W-2] == '1'){\n                    if(((H-1)/2)&1){ //反転 \n                        if(grid[H-1][W-1] == '3'){\n                            cout << \"YES\" << bn;\n                        }else{\n                            cout << \"NO\" << bn;\n                        }\n                    }else{\n                        if(grid[H-1][W-1] == '4'){\n                            cout << \"YES\" << bn;\n                        }else{\n                            cout << \"NO\" << bn;\n                        }\n                    }\n                }else{\n                    if(((H-1)/2)&1){ //反転 \n                        if(grid[H-1][W-1] == '4'){\n                            cout << \"YES\" << bn;\n                        }else{\n                            cout << \"NO\" << bn;\n                        }\n                    }else{\n                        if(grid[H-1][W-1] == '3'){\n                            cout << \"YES\" << bn;\n                        }else{\n                            cout << \"NO\" << bn;\n                        }\n                    }\n                }\n            }else{\n                cout << \"NO\" << bn;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<tuple>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef tuple<int, int, vector<int>> T3;//座標、\n\nint H, W;\nchar field[100 + 10][100 + 10];\nbool visited[100 + 10][100 + 10];\n\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++)cin >> field[i][j];\n\t}\n\t\n\tqueue<T3> Q;\n\tvector<int> state = {1, 2, 3, 5, 4, 6};\n\tQ.push(make_tuple(0, 0, state));\n\twhile (Q.size()) {\n\t\tauto now = Q.front();\n\t\tint x = get<0>(now), y = get<1>(now);\n\t\tauto ns = get<2>(now);\n\t\tQ.pop();\n\t\tif (x == H - 1 && y == W - 1) {\n\t\t\tcout << \"YES\" << endl;\n\t\t\treturn 0;\n\t\t}\n\n\t\t//上向き\n\t\tif (x > 0 && field[x - 1][y] != '#' && !visited[x - 1][y]) {\n\t\t\tvector<int> newstate(6);\n\t\t\tnewstate[0] = ns[1], newstate[1] = ns[5], newstate[2] = ns[2];\n\t\t\tnewstate[3] = ns[0], newstate[4] = ns[4], newstate[5] = ns[3];\n\t\t\tif (newstate[5] == field[x - 1][y] - '0') {\n\t\t\t\tvisited[x - 1][y] = true;\n\t\t\t\tQ.push(make_tuple(x - 1, y, newstate));\n\t\t\t}\n\t\t}\n\t\t\n\t\t//下向き\n\t\tif (x < H - 1 && field[x + 1][y] != '#' && !visited[x + 1][y]) {\n\t\t\tvector<int> newstate(6);\n\t\t\tnewstate[0] = ns[3], newstate[1] = ns[0], newstate[2] = ns[2];\n\t\t\tnewstate[3] = ns[5], newstate[4] = ns[4], newstate[5] = ns[1];\n\t\t\tif (newstate[5] == field[x + 1][y] - '0') {\n\t\t\t\tvisited[x + 1][y] = true;\n\t\t\t\tQ.push(make_tuple(x + 1, y, newstate));\n\t\t\t}\n\t\t}\n\t\t\n\t\t//左向き\n\t\tif (y > 0 && field[x][y - 1] != '#' && !visited[x][y - 1]) {\n\t\t\tvector<int> newstate(6);\n\t\t\tnewstate[0] = ns[2], newstate[1] = ns[1], newstate[2] = ns[5];\n\t\t\tnewstate[3] = ns[3], newstate[4] = ns[0], newstate[5] = ns[4];\n\t\t\tif (newstate[5] == field[x][y - 1] - '0') {\n\t\t\t\tvisited[x][y - 1] = true;\n\t\t\t\tQ.push(make_tuple(x, y - 1, newstate));\n\t\t\t}\n\t\t}\n\t\t\n\t\t//右向き\n\t\tif (y < W - 1 && field[x][y + 1] != '#' && !visited[x][y + 1]) {\n\t\t\tvector<int> newstate(6);\n\t\t\tnewstate[0] = ns[4], newstate[1] = ns[1], newstate[2] = ns[0];\n\t\t\tnewstate[3] = ns[3], newstate[4] = ns[5], newstate[5] = ns[2];\n\t\t\tif (newstate[5] == field[x][y + 1] - '0') {\n\t\t\t\tvisited[x][y + 1] = true;\n\t\t\t\tQ.push(make_tuple(x, y + 1, newstate));\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"NO\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(long long i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) {rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;}\n#define show2d(v) {rep(__,v.size())show1d(v[__]);}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={-1,0,1,0};\nint dy[]={0,1,0,-1};\n#define yes cout<<\"YES\\n\"\n#define no cout<<\"NO\\n\"\n\nint n,m;\nvs in;\nvoid dfs(int x,int y){\n\tif(in[x][y]=='!'||in[x][y]=='#')return;\n\tin[x][y]='!';\n\trep(i,4){\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(nx<0||nx>=n||ny<0||ny>=m)continue;\n\t\tdfs(nx,ny);\n\t}\n}\nsigned main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t\n\tcin>>n>>m;\n\tin=vs(n);\n\trep(i,n)cin>>in[i];\n\tstring t[4]={\"6314\",\"2#2#\",\"1364\",\"5#5#\"};\n\trep(i,n)rep(j,m)if(in[i][j]-t[i%4][j%4])in[i][j]='#';\n\t\n\tdfs(0,0);\n\tif(in[n-1][m-1]=='!')yes;\n\telse no;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> // cin, cout, cerr\n#include <algorithm> // minmax, sort, swap\n#include <numeric> // iota\n#include <cstdio> // printf, scanf\n#include <string> // string, stoi, to_string\n#include <vector> // vector\n#include <queue> // queue, priority_queue\n#include <deque> // deque\n#include <map> // key-value pairs sorted by keys\n#include <set> // set\n#include <iomanip> // cout<<setprecision(n)\n#include <functional> // function<void(int)>\n#include <cmath>\n#include <cassert>\n#include <bitset>\n\n#ifdef DEBUG\n#include \"debug.hpp\"\n#else\n#define debug(...)\n#endif\n\n#define int long long // at least int64 > 9*10^18\n#define EL '\\n'\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define print(i) std::cout << (i) << '\\n'\n#define all(v) (v).begin(), (v).end()\n/* libraries */\n\nstruct UnionFind\n{\n  int n;\n  std::vector<int> par,size;\n  UnionFind(int sz) : n(sz), par(sz,0), size(sz,1) {\n    std::iota(par.begin(),par.end(),0);\n  }\n  int find(int x) {\n    if(par[x]==x) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(size[x]<size[y]) std::swap(x,y);\n    size[x]+=size[y];\n    par[y]=x;\n  }\n};\n\n\nsigned main() {\n\tint clar[4][4] = {\n\t\t6,3,1,4,\n\t\t2,-1,2,-1,\n\t\t1,3,6,4,\n\t\t5,-1,5,-1\n\t};\n\tint h,w;\n\tstd::cin >> h >> w;\n\tstd::vector<std::string> g(h);\n\trep(i,h) std::cin >> g[i];\n\tauto enc = [&w](int x, int y) -> int {\n\t\treturn x*w+y;\n\t};\n\tUnionFind uf(h*w);\n\trep(i,h) {\n\t\trep(j,w) {\n\t\t\tif(g[i][j]-'0'!=clar[i%4][j%4]) continue;\n\t\t\trep(dx,2) rep(dy,2) {\n\t\t\t\tdebug(dx,dy);\n\t\t\t\tif(dx==0 && dy==0) continue;\n\t\t\t\tif(dx*dy!=0) continue;\n\t\t\t\tif(i+dx>=h || j+dy>=w) continue;\n\t\t\t\tif(g[i+dx][j+dy]-'0'!=clar[(i+dx)%4][(j+dy)%4]) continue;\n\t\t\t\tdebug(enc(i,j),enc(j+dx,j+dy));\n\t\t\t\tuf.unite(enc(i,j),enc(i+dx,j+dy));\n\t\t\t}\n\t\t}\n\t}\n\tdebug(uf.par);\n\tif(uf.find(0)==uf.find(h*w-1)) print(\"YES\");\n\telse print(\"NO\");\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nconst int INF = 1LL << 29;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n\n// Dice library\n//         ---------\n//         | back  |\n//         |  (5)  |\n// --------+-------+-------+--------+\n// | left  |  top  | right | bottom |\n// |  (4)  |  (1)  |  (2)  |   (3)  |\n// --------+-------+-------+---------\n//         | front |\n//         |  (0)  |\n//         ---------\n\nenum Direction {\n    // 北、南、東、西方向 および 右、左回り に 90 度回転\n    NORTH = 0, SOUTH = 1, EAST = 2, WEST = 3, ROT_R = 4, ROT_L = 5,\n};\n\nenum View {\n    // どこから見た時の値か？\n    FRONT = 0, TOP = 1, RIGHT = 2, BOTTOM = 3, LEFT = 4, BACK = 5,\n};\n\nstruct Dice {\n    vector<int> value;\n    Dice(int front, int top, int right) {\n        int sum = 7;\n        assert(front + top   != sum);\n        assert(top   + right != sum);\n        assert(front + right != sum);\n        value = {front, top, right, sum-top, sum-right, sum-front};\n    }\n\n    void rotate(int dir) {\n        vector<int> fnc, swp(6);\n        if(dir == NORTH) fnc = {1, 5, 2, 0, 4, 3};\n        if(dir == SOUTH) fnc = {3, 0, 2, 5, 4, 1};\n        if(dir == EAST ) fnc = {0, 2, 3, 4, 1, 5};\n        if(dir == WEST ) fnc = {0, 4, 1, 2, 3, 5};\n        if(dir == ROT_R) fnc = {4, 1, 0, 3, 5, 2};\n        if(dir == ROT_L) fnc = {2, 1, 5, 3, 0, 4};\n\n        for(int i=0; i<6; i++) swp[ fnc[i] ] = value[i];\n        swap(value, swp);\n    }\n\n    int get_value(int view) {\n        return value[view];\n    }\n};\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, 1, -1};\nconst Direction dd[] = {NORTH, SOUTH, EAST, WEST};\n\nbool visited[110][110][300];\nvector< vector<int> > perm;\nint nxt[300][4];\n\nbool check(vector<int> P) {\n    int front = P[0], top = P[1], right = P[2], sum = 7;\n    bool ok = true;\n    ok &= front + top   != sum;\n    ok &= top   + right != sum;\n    ok &= front + right != sum;\n    return ok;\n}\n\nint main() {\n    vector<int> P(6);\n    for(int i=0; i<6; i++) P[i] = i+1;\n    do {\n        if(!check(P)) continue;\n        perm.emplace_back(P);\n    }while(next_permutation(P.begin(), P.end()));\n    \n    int ini = -1;\n    {\n        Dice dice(2, 1, 3);\n        int idx = lower_bound(perm.begin(), perm.end(), dice.value) - perm.begin();\n        ini = idx;\n    }\n\n    for(size_t i=0; i<perm.size(); i++) {\n        int f = perm[i][0], t = perm[i][1], r = perm[i][2];\n        Dice dice(f, t, r);\n        for(int k=0; k<4; k++) {\n            dice.rotate(dd[k]);\n            int idx = lower_bound(perm.begin(), perm.end(), dice.value) - perm.begin();\n            nxt[i][k] = idx;\n            dice.rotate(dd[k^1]);\n        }\n    }\n    \n    int H, W; cin >> H >> W;\n    vector<string> vs(H);\n    for(int i=0; i<H; i++) cin >> vs[i];\n\n    queue< tuple<int, int, int> > que;\n    que.emplace(0, 0, ini);\n    visited[0][0][ini] = true;\n    while(que.size()) {\n        int x, y, p; tie(x, y, p) = que.front(); que.pop();\n\n        int f = perm[p][0], t = perm[p][1], r = perm[p][2];\n        Dice dice(f, t, r);\n\n        for(int k=0; k<4; k++) {\n            int nx = x + dx[k], ny = y + dy[k];\n            if(nx < 0 or nx >= H or ny < 0 or ny >= W) continue;\n\n            /*\n            fprintf(stderr, \"x = %d, y = %d, p = %d\\n\", x, y, p);\n            int iidx = lower_bound(perm.begin(), perm.end(), dice.value) - perm.begin();\n            for(auto e : perm[iidx]) cerr << e << \" \";\n            cerr << endl;\n            */\n\n            dice.rotate(dd[k]);\n            int np = nxt[p][k];\n            \n            /*\n\n\n            fprintf(stderr, \"nx = %d, ny = %d, np = %d\\n\", nx, ny, np);\n            int idx = lower_bound(perm.begin(), perm.end(), dice.value) - perm.begin();\n            for(auto e : perm[idx]) cerr << e << \" \";\n            cerr << endl;\n            \n\n            cerr << dice.get_value(BOTTOM) << \" \" << vs[nx][ny] << endl;\n            */\n\n            if(isdigit(vs[nx][ny]) and\n               vs[nx][ny] - '0' == dice.get_value(BOTTOM) and\n               !visited[nx][ny][np]) {\n                // fprintf(stderr, \"nx = %d, ny = %d\\n\", nx, ny);\n                visited[nx][ny][np] = true;\n                que.emplace(nx, ny, np);\n            }\n            dice.rotate(dd[k^1]);\n        }\n    }\n\n    for(int i=0; i<300; i++) {\n        if(visited[H-1][W-1][i]) {\n            cout << \"YES\" << endl;\n            return 0;\n        }\n    }\n    \n    cout << \"NO\" << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <array>\nusing namespace std;\nusing ULL = unsigned long long;\nusing UL = unsigned;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\ntemplate<class Ty>\nusing passive_queue = priority_queue<Ty, vector<Ty>, greater<Ty>>;\n\nstruct Problem {\n\n\tbool dp[102][102][4] = {};\n\tUL G[102][102];\n\n\tvoid Solve() {\n\t\tconst UL nx[6][4][2] = {\n\t\t\t{{4,0}, {3,1}, {1,2}, {2,3}},\n\t\t\t{{0,0}, {3,0}, {5,2}, {2,0}},\n\t\t\t{{4,1}, {0,1}, {1,1}, {5,1}},\n\t\t\t{{4,3}, {5,3}, {1,3}, {0,3}},\n\t\t\t{{5,0}, {3,2}, {0,2}, {2,2}},\n\t\t\t{{1,0}, {3,3}, {4,2}, {2,1}}\n\t\t};\n\t\tUL H, W; cin >> H >> W;\n\t\trep(y, H + 2) rep(x, W + 2) G[x][y] = -1;\n\t\trep(y, H) rep(x, W) {\n\t\t\tchar c; cin >> c;\n\t\t\tif (c == '#') G[x + 1][y + 1] = -1;\n\t\t\telse G[x + 1][y + 1] = 6 - (c - '0');\n\t\t}\n\t\tqueue<pair<pair<UL, UL>, UL>> Q;\n\t\tQ.push({ { 1, 1 }, 0 });\n\t\twhile (Q.size()) {\n\t\t\tUL x = Q.front().first.first;\n\t\t\tUL y = Q.front().first.second;\n\t\t\tUL i = Q.front().second;\n\t\t\tQ.pop();\n\t\t\tif (dp[x][y][i]) continue;\n\t\t\tdp[x][y][i] = true;\n\t\t\tUL t = G[x][y];\n\t\t\tif (G[x][y + 1] == nx[t][i][0])\n\t\t\t\tQ.push({ {x, y + 1}, nx[t][i][1] });\n\t\t\tif (G[x - 1][y] == nx[t][(i + 3) & 3][0])\n\t\t\t\tQ.push({ {x - 1, y}, (nx[t][(i + 3) & 3][1] + 1) & 3 });\n\t\t\tif (G[x][y - 1] == nx[t][(i + 2) & 3][0])\n\t\t\t\tQ.push({ {x, y - 1}, (nx[t][(i + 2) & 3][1] + 2) & 3 });\n\t\t\tif (G[x + 1][y] == nx[t][(i + 1) & 3][0])\n\t\t\t\tQ.push({ {x + 1, y}, (nx[t][(i + 1) & 3][1] + 3) & 3 });\n\t\t}\n\t\tbool ans = false;\n\t\trep(i, 4) if (dp[W][H][i]) ans = true;\n\n\t\tcout << (ans ? \"YES\" : \"NO\") << endl;\n\t}\n\n\tProblem();\n};\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\nProblem::Problem() {\n\tcout << fixed << setprecision(10);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct dice {\npublic:\n    int soko;\n    int r;\n    int oku;\n    dice(int soko,int r,int oku):soko(soko),r(r),oku(oku) {}\n\n    dice rotr(){\n        return dice(r,7-soko,oku);\n    }\n\n    dice rotd(){\n        return dice(7-oku,r,soko);\n    }\n\n    dice rotl() {\n        return dice(7-r,soko,oku);\n    }\n\n    dice rotu(){\n        return dice(oku,r,7-soko);\n    }\n\n\n};\nbool operator< (dice a,dice b){\n    return true;\n}\n\nint main() {\n    int h,w;\n    cin>>h>>w;\n    vector<string> mp(h);\n    for(int i = 0;i < h;++i) {\n        cin>>mp[i];\n    }\n    queue<pair<pair<int,int>,dice>> q;\n    q.push(make_pair(make_pair(0,0),dice(6,3,5)));\n    bool ok=false;\n    vector<vector<bool>> visited(h,vector<bool>(w,false));\n    while(!q.empty()){\n        auto t=q.front();\n        int y=t.first.first;\n        int x=t.first.second;\n    //cerr<<\"y:\"<<y<<\" x:\"<<x<<endl;\n        auto d=t.second;\n        q.pop();\n        if(y==h-1&&x==w-1){\n            ok=true;\n            break;\n        }\n//cerr<<d.rotr().soko<<endl;\n\n        if(x+1<w&&!visited[y][x+1]&&mp[y][x+1]!='#'&&d.rotr().soko+'0'==mp[y][x+1]){\n            q.push(make_pair(make_pair(y,x+1),d.rotr()));\n            visited[y][x+1]=true;\n        }\n        if(y+1<h&&!visited[y+1][x]&&mp[y+1][x]!='#'&&d.rotd().soko+'0'==mp[y+1][x]){\n            q.push(make_pair(make_pair(y+1,x),d.rotd()));\n            visited[y+1][x]=true;\n        }\n        if(x-1>=0&&!visited[y][x-1]&&mp[y][x-1]!='#'&&d.rotl().soko+'0'==mp[y][x-1]){\n            q.push(make_pair(make_pair(y,x-1),d.rotl()));\n            visited[y][x-1]=true;\n        }\n        if(y-1>=0&&!visited[y-1][x]&&mp[y-1][x]!='#'&&d.rotu().soko+'0'==mp[y-1][x]){\n            q.push(make_pair(make_pair(y-1,x),d.rotu()));\n            visited[y-1][x]=true;\n        }\n    }\n    if(ok)cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n - 1); i >= 0; i--)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) int(x.size())\n#define get_unique(x) x.erase(unique(all(x)), x.end());\ntypedef long long ll;\ntypedef complex<double> Complex;\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\nconst ll LINF = 1e18;\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\nvector<T> make_vec(size_t a) {\n    return vector<T>(a);\n}\ntemplate <class T, class... Ts>\nauto make_vec(size_t a, Ts... ts) {\n    return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\nstruct DICE {\n    int L, R, U, D, B, F;\n    void right() {\n        int x;\n        x = R;\n        R = U;\n        U = L;\n        L = D;\n        D = x;\n    }\n    void left() {\n        int x;\n        x = L;\n        L = U;\n        U = R;\n        R = D;\n        D = x;\n    }\n    void down() {\n        int x;\n        x = F;\n        F = U;\n        U = B;\n        B = D;\n        D = x;\n    }\n    void up() {\n        int x;\n        x = B;\n        B = U;\n        U = F;\n        F = D;\n        D = x;\n    }\n};\nint main() {\n    int h, w;\n    cin >> h >> w;\n    auto v = make_vec<int>(h, w);\n    rep(i, h) rep(j, w) {\n        char c;\n        cin >> c;\n        if (c == '#')\n            v[i][j] = -1;\n        else\n            v[i][j] = c - '0';\n    }\n\n    auto d = make_vec<DICE>(h, w);\n    auto dp = make_vec<int>(h, w);\n\n    d[0][0] = {4, 3, 1, 6, 5, 2};\n    dp[0][0] = 1;\n    rep(_, 1000) {\n        rep(i, h) {\n            rep(j, w) {\n                if (j + 1 < w && v[i][j + 1] != -1) {\n                    d[i][j].right();\n                    if (d[i][j].D == v[i][j + 1]) {\n                        d[i][j + 1] = d[i][j];\n                        dp[i][j + 1] |= dp[i][j];\n                    }\n                    d[i][j].left();\n                }\n                if (i + 1 < h && v[i + 1][j] != -1) {\n                    d[i][j].down();\n                    if (d[i][j].D == v[i + 1][j]) {\n                        d[i + 1][j] = d[i][j];\n                        dp[i + 1][j] |= dp[i][j];\n                    }\n                    d[i][j].up();\n                }\n                if (j - 1 >= 0 && v[i][j - 1] != -1 && dp[i][j] == 1 &&\n                    dp[i][j - 1] == 0) {\n                    d[i][j].left();\n                    if (d[i][j].D == v[i][j - 1]) {\n                        d[i][j - 1] = d[i][j];\n                        dp[i][j - 1] |= dp[i][j];\n                    }\n                    d[i][j].right();\n                }\n                if (i - 1 >= 0 && v[i - 1][j] != -1 && dp[i][j] == 1 &&\n                    dp[i - 1][j] == 0) {\n                    d[i][j].up();\n                    if (d[i][j].D == v[i - 1][j]) {\n                        d[i - 1][j] = d[i][j];\n                        dp[i - 1][j] |= dp[i][j];\n                    }\n                    d[i][j].down();\n                }\n            }\n        }\n    }\n    /*\n    cout << endl;\n    rep(i, h) {\n        rep(j, w) cout << d[i][j].D;\n        cout << endl;\n    }\n    */\n    cout << (dp[h - 1][w - 1] ? \"YES\" : \"NO\") << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nclass B {\npublic:\n\n    struct Dice {\n      int i{}, j{}, k{}, x{}, y{};\n      Dice(int i, int j, int k, int x, int y):\n        i(i), j(j), k(k), x(x), y(y){}\n    };\n\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int h, w; cin >> h >> w;\n      vector<vector<int>> mat(h, vector<int>(w));\n      rep(i, h) {\n        rep(j, w) {\n          char c; cin >> c;\n          if (c == '#') {\n            mat[i][j] = 100;\n          } else {\n            mat[i][j] = c-'0';\n          }\n          debug(i, j, mat[i][j]);\n        }\n      }\n      vector<vector<bool>> dp(h, vector<bool>(w));\n      queue<Dice> que;\n      que.emplace(1, 2, 3, 0, 0);\n      dp[0][0] = true;\n\n      while(!que.empty()) {\n        auto d = que.front(); que.pop();\n        debug(d.i, d.j, d.k, d.x, d.y);\n        if (d.x > 0 && (!dp[d.x-1][d.y]) && mat[d.x-1][d.y] == 7-d.j) {\n          dp[d.x-1][d.y] = true;\n          que.emplace(d.j, 7-d.i, d.k, d.x-1, d.y);\n        }\n        if (d.x < h-1 && (!dp[d.x+1][d.y]) && mat[d.x+1][d.y] == d.j) {\n          dp[d.x+1][d.y] = true;\n          que.emplace(7-d.j, d.i, d.k, d.x+1, d.y);\n        }\n        if (d.y > 0 && (!dp[d.x][d.y-1]) && mat[d.x][d.y-1] == 7-d.k) {\n          dp[d.x][d.y-1] = true;\n          que.emplace(d.k, d.j, 7-d.i, d.x, d.y-1);\n        }\n        if (d.y < w-1 && (!dp[d.x][d.y+1]) && mat[d.x][d.y+1] == d.k) {\n          debug(d.x, d.y);\n          dp[d.x][d.y+1] = true;\n          que.emplace(7-d.k, d.j, d.i, d.x, d.y+1);\n        }\n      }\n\n      if (dp[h-1][w-1]) {\n        cout << \"YES\" << endl;\n      } else {\n        cout << \"NO\" << endl;\n      }\n\n    }\n};\n\nsigned main() {\n  B solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,N) for(int i=0;i<int(N);++i)\n#define rep1(i,N) for(int i=1;i<int(N);++i)\n#define all(a) (a).begin(),(a).end()\n#define print(v) { cerr<<#v<<\": [ \"; for(auto _ : v) cerr<<_<<\", \"; cerr<<\"]\"<<endl; }\n#define printpair(v) { cerr<<#v<<\": [ \"; for(auto _ : v) cerr<<\"{\"<<_.first<<\",\"<<_.second<<\"}\"<<\", \"; cerr<<\"]\"<<endl; }\n#define dump(x) cerr<<#x<<\": \"<<x<<endl;\n#define bit(k) (1LL<<(k))\n#define Yes \"Yes\"\n#define No \"No\"\n#define YES \"YES\"\n#define NO \"NO\"\ntypedef long long ll;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nconst int INF = (ll)1e9;\nconst ll INFLL = (ll)1e18+1;\nconst ll MOD = (ll)1e9+7;\nconst double PI = acos(-1.0);\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst string sdir = \"DRUL\";\n\nint H,W;           \nint dir_v[4][6] =   {{4, 1, 0, 3, 5, 2},\n                     {1, 5, 2, 0, 4, 3},\n                     {2, 1, 5, 3, 0, 4},\n                     {3, 0, 2, 5, 4, 1}\n                  };\nint v_idx[] = {4, 1, 2, 3};\nbool visited[110][110];\nbool IsIn(int x,int y){\n    return 0<=x&&x<H&&0<=y&&y<W;\n}\nvector<string> s, tmp;\nvoid debug(){\n    rep(i,H){\n        cerr << s[i] << endl;\n    }\n    cerr << endl;\n}\nbool can_move(vector<int>& v, int nx, int ny, int dir){\n    //cerr <<sdir[dir] << endl;\n    //dump(v[v_idx[dir]]);\n    //cerr << \"can_move: \" << nx << \" \" << ny << \" \" << v[v_idx[dir]] << \" \" << s[nx][ny] << endl;\n    //print(v);\n    return v[v_idx[dir]] == s[nx][ny] - '0';\n}\n \nvector<int> next_v(vector<int>& v, int dir){\n    vector<int> res(6, 0);\n    rep(i,6){\n        res[i] = v[dir_v[dir][i]];\n    }\n    return res;\n}\n\nvoid dfs(int sx, int sy, vector<int>& t){\n    if(visited[sx][sy])return;\n    //cerr << endl << \"now: \" << sx << \" \" << sy << endl;\n    visited[sx][sy] = true;\n    rep(i,4){\n        int nx = sx + dx[i];\n        int ny = sy + dy[i];\n        if(!IsIn(nx, ny))continue;\n        if(can_move(t, nx, ny, i)){\n            vector<int> nv = next_v(t, i);\n            dfs(nx, ny, nv);\n        }\n    }\n    return;\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    cin >> H >> W;\n    s.resize(H);\n    rep(i,H)cin >> s[i];\n    vector<int> ts = {6, 3, 5, 4, 2, 1};\n    rep(i,H)rep(j,W){\n        visited[i][j] = false;\n    }\n    dfs(0, 0, ts);\n    if(visited[H-1][W-1]){\n        cout << YES << endl;\n    }\n    else{\n        cout << NO << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <bitset>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef pair<ll,ll> P;\ntypedef vector<P> vpl;\n#define rep(i,n) for(ll i=0; i<(n); i++)\n#define REP(i,a,b) for(ll i=(a); i<(b); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nconst int inf = 1<<30;\nconst ll linf = 1LL<<62;\nconst int MAX = 1020000;\nll dy[8] = {0,1,0,-1,1,-1,1,-1};\nll dx[8] = {1,0,-1,0,1,-1,-1,1};\nconst double pi = acos(-1);\nconst double eps = 1e-7;\ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){\n\tif(a>b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){\n\tif(a<b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline void print2(T1 a, T2 b){cout << a << \" \" << b << endl;}\ntemplate<typename T1,typename T2,typename T3> inline void print3(T1 a, T2 b, T3 c){\n\tcout << a << \" \" << b << \" \" << c << endl;\n}\nconst int mod = 998244353;\n\n\n\ntypedef pair<P,vl> pp;\nll h,w;\nchar s[105][105];\nmap<pair<P,vl>,ll> f;\n\nbool in(ll y, ll x){\n\treturn 0 <= y && y < h && 0 <= x && x < w;\n}\n\nint main(){\n\tcin >> h >> w;\n\trep(i,h) rep(j,w) cin >> s[i][j];\n\tqueue<pp> q;\n\tvl t(6);\n\tt[0] = 6, t[1] = 1, t[2] = 2, t[3] = 3, t[4] = 5, t[5] = 4;\n\tf[pp(P(0,0),t)]++;\n\tq.emplace(P(0,0),t);\n\twhile(!q.empty()){\n\t\tauto u = q.front(); q.pop();\n\t\tll y = u.first.first;\n\t\tll x = u.first.second;\n\t\tvl v = u.second;\n\t\tll now = s[y][x] - '0';\n\t\trep(i,4){\n\t\t\tll ny = y + dy[i];\n\t\t\tll nx = x + dx[i];\n\t\t\tif(s[ny][nx] == '#') continue;\n\t\t\tif(in(ny,nx)){\n\t\t\t\tvl nnxt(6);\n\t\t\t\tif(dy[i]==1){\n\t\t\t\t\tnnxt[0] = v[2];\n\t\t\t\t\tnnxt[1] = v[4];\n\t\t\t\t\tnnxt[2] = v[1];\n\t\t\t\t\tnnxt[3] = v[3];\n\t\t\t\t\tnnxt[4] = v[0];\n\t\t\t\t\tnnxt[5] = v[5];\n\t\t\t\t}else if(dy[i]==-1){\n\t\t\t\t\tnnxt[0] = v[4];\n\t\t\t\t\tnnxt[1] = v[2];\n\t\t\t\t\tnnxt[2] = v[0];\n\t\t\t\t\tnnxt[3] = v[3];\n\t\t\t\t\tnnxt[4] = v[1];\n\t\t\t\t\tnnxt[5] = v[5];\n\t\t\t\t}else if(dx[i]==1){\n\t\t\t\t\tnnxt[0] = v[3];\n\t\t\t\t\tnnxt[1] = v[5];\n\t\t\t\t\tnnxt[2] = v[2];\n\t\t\t\t\tnnxt[3] = v[1];\n\t\t\t\t\tnnxt[4] = v[4];\n\t\t\t\t\tnnxt[5] = v[0];\n\t\t\t\t}else if(dx[i]==-1){\n\t\t\t\t\tnnxt[0] = v[5];\n\t\t\t\t\tnnxt[1] = v[3];\n\t\t\t\t\tnnxt[2] = v[2];\n\t\t\t\t\tnnxt[3] = v[0];\n\t\t\t\t\tnnxt[4] = v[4];\n\t\t\t\t\tnnxt[5] = v[1];\n\t\t\t\t}\n\t\t\t\tll nxt = s[ny][nx] - '0';\n\t\t\t\tif(nxt != nnxt[0]) continue;\n\t\t\t\tif(f.find(pp(P(ny,nx),nnxt)) == f.end()){\n\t\t\t\t\tf[pp(P(ny,nx),nnxt)]++;\n\t\t\t\t\tq.emplace(P(ny,nx),nnxt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbool flag = false;\n\tvl vv(6);\n\trep(i,6) vv[i] = i+1;\n\tdo{\n\t\tif(f.find(pp(P(h-1,w-1),vv)) != f.end()){\n\t\t\tflag = true;\n\t\t\tbreak;\n\t\t}\n\t}while(next_permutation(all(vv)));\n\tif(flag) puts(\"YES\");\n\telse puts(\"NO\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst int INF = (1<<25);\nconst ll INFLL = (1ll<<60);\nconst ll MOD = (ll)(1e9+7);\n\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\ta = (a<MOD)?a:(a-MOD);\n\tb = (b<MOD)?b:(b-MOD);\n\ta += b;\n\ta = (a<MOD)?a:(a-MOD);\n}\n\nstruct vtx{\n\tint x,y,f,r;\n};\n\nstring s[111];\nint h,w;\n\nqueue<vtx> que;\n\nbool check(int i, int j){\n\treturn (0<=i && i<h && 0<=j && j<w && s[i][j]!='#');\n}\n\nbool dist[111][111][6][6];\n\nint main(void){\n\tint i,j;\n\tvtx u,v;\n\tcin >> h >> w;\n\tfor(i=0; i<h; ++i){\n\t\tcin >> s[i];\n\t\tfor(j=0; j<w; ++j){\n\t\t\tif(s[i][j]!='#'){\n\t\t\t\ts[i][j] -= '1';\n\t\t\t}\n\t\t}\n\t}\n\tdist[0][0][1][2] = true;\n\tv.x = 0; v.y = 0; v.f = 1; v.r = 2;\n\tque.push(v);\n\twhile(!que.empty()){\n\t\tu = que.front();\n\t\tque.pop();\n\t\ti = u.x; j = u.y;\n\t\tif(i==(h-1)&&j==(w-1)){\n\t\t\tcout << \"YES\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(check(i-1,j)){\n\t\t\tif((!dist[i-1][j][s[i][j]][u.r]) && s[i-1][j]==(5-u.f)){\n\t\t\t\tdist[i-1][j][s[i][j]][u.r] = true;\n\t\t\t\tv.x = i-1; v.y = j; v.f = s[i][j]; v.r = u.r;\n\t\t\t\tque.push(v);\n\t\t\t}\n\t\t}\n\t\tif(check(i+1,j)){\n\t\t\tif((!dist[i+1][j][5-s[i][j]][u.r]) && s[i+1][j]==u.f){\n\t\t\t\tdist[i+1][j][5-s[i][j]][u.r] = true;\n\t\t\t\tv.x = i+1; v.y = j; v.f = 5-s[i][j]; v.r = u.r;\n\t\t\t\tque.push(v);\n\t\t\t}\n\t\t}\n\t\tif(check(i,j-1)){\n\t\t\tif((!dist[i][j-1][u.f][s[i][j]]) && s[i][j-1]==5-u.r){\n\t\t\t\tdist[i][j-1][u.f][s[i][j]] = true;\n\t\t\t\tv.x = i; v.y = j-1; v.f = u.f; v.r = s[i][j];\n\t\t\t\tque.push(v);\n\t\t\t}\n\t\t}\n\t\tif(check(i,j+1)){\n\t\t\tif((!dist[i][j+1][u.f][5-s[i][j]]) && s[i][j+1]==u.r){\n\t\t\t\tdist[i][j+1][u.f][5-s[i][j]] = true;\n\t\t\t\tv.x = i; v.y = j+1; v.f = u.f; v.r = 5-s[i][j];\n\t\t\t\tque.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"NO\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#define rep(i, start, end) for (int i = (int)start; i < (int)end; ++i)\n#define rrep(i, start, end) for (int i = (int)start - 1; i >= (int)end; --i)\n#define all(x) (x).begin(), (x).end()\nusing namespace std;\nusing ll = long long;\ntemplate<typename T> inline bool chmax(T& a, T b) {if (a < b) {a = b; return true;} return 0;}\ntemplate<typename T> inline bool chmin(T& a, T b) {if (a > b) {a = b; return true;} return 0;}\n\nstruct dice {\n    vector<int> side, front;\n    dice() {\n        side = vector<int>({1, 3, 6, 4});  // top -> right -> bottom -> left\n        front = vector<int>({1, 2, 6, 5});  // top -> front -> bottom -> back\n    }\n    void rotateFront() {\n        int tail = front.back();\n        rrep(i, 4, 1) {\n            front[i] = front[i - 1];\n        }\n        front[0] = tail;\n        side[0] = front[0];\n        side[2] = front[2];\n    }\n    void rotateBack() {\n        int head = front.front();\n        rep(i, 0, 3) {\n            front[i] = front[i + 1];\n        }\n        front[3] = head;\n        side[0] = front[0];\n        side[2] = front[2];\n    }\n    void rotateRight() {\n        int tail = side.back();\n        rrep(i, 4, 1) {\n            side[i] = side[i - 1];\n        }\n        side[0] = tail;\n        front[0] = side[0];\n        front[2] = side[2];\n    }\n    void rotateLeft() {\n        int head = side.front();\n        rep(i, 0, 3) {\n            side[i] = side[i + 1];\n        }\n        side[3] = head;\n        front[0] = side[0];\n        front[2] = side[2];\n    }\n    int getBottom() const {\n        return side[2];\n    }\n};\n\nusing P = pair<dice, pair<int, int>>;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    // dice D;\n    // cout << \"First bottom=\" << D.getBottom() << endl;\n    // int T;\n    // cin >> T;\n    // rep(_, 0, T) {\n    //     cout << \"ROTATE -> \";\n    //     flush(cout);\n    //     char dir;\n    //     cin >> dir;\n    //     if (dir == 'L') {\n    //         D.rotateLeft();\n    //     }\n    //     else if (dir == 'R') {\n    //         D.rotateRight();\n    //     }\n    //     else if (dir == 'F') {\n    //         D.rotateFront();\n    //     }\n    //     else {\n    //         D.rotateBack();\n    //     }\n    //     cout << \"Bottom=\" << D.getBottom() << endl;\n    // }\n    int H, W;\n    cin >> H >> W;\n    vector<string> grid(H);\n    for (auto& g : grid) {\n        cin >> g;\n    }\n    dice D;\n    queue<P> que;\n    vector<vector<bool>> visited(H, vector<bool>(W, false));\n    que.push(P(D, make_pair(0, 0)));\n    visited[0][0] = true;\n    while (!que.empty()) {\n        P now = que.front();\n        que.pop();\n        dice now_d = now.first;\n        int now_h = now.second.first;\n        int now_w = now.second.second;\n        dice d1(now_d);\n        d1.rotateFront();\n        if (now_h + 1 < H && grid[now_h + 1][now_w] != '#' && d1.getBottom() == (int)(grid[now_h + 1][now_w] - '0') && !visited[now_h + 1][now_w]) {\n            visited[now_h + 1][now_w] = true;\n            que.push(P(d1, make_pair(now_h + 1, now_w)));\n        }\n        dice d2(now_d);\n        d2.rotateRight();\n        if (now_w + 1 < W && grid[now_h][now_w + 1] != '#' && d2.getBottom() == (int)(grid[now_h][now_w + 1] - '0') && !visited[now_h][now_w + 1]) {\n            visited[now_h][now_w + 1] = true;\n            que.push(P(d2, make_pair(now_h, now_w + 1)));\n        }\n        dice d3(now_d);\n        d3.rotateBack();\n        if (now_h - 1 >= 0 && grid[now_h - 1][now_w] != '#' && d3.getBottom() == (int)(grid[now_h - 1][now_w] - '0') && !visited[now_h - 1][now_w]) {\n            visited[now_h - 1][now_w] = true;\n            que.push(P(d3, make_pair(now_h - 1, now_w)));\n        }\n        dice d4(now_d);\n        d4.rotateLeft();\n        if (now_w - 1 >= 0 && grid[now_h][now_w - 1] != '#' && d4.getBottom() == (int)(grid[now_h][now_w - 1] - '0') && !visited[now_h][now_w - 1]) {\n            visited[now_h][now_w - 1] = true;\n            que.push(P(d4, make_pair(now_h, now_w - 1)));\n        }\n    }\n    if (visited[H - 1][W - 1]) {\n        cout << \"YES\" << endl;\n    }\n    else {\n        cout << \"NO\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n#define mt make_tuple\n#define ALL(a) (a).begin(),(a).end()\n#define FST first\n#define SEC second\n#define DEB cerr<<\"!\"<<endl\n#define SHOW(a,b) cerr<<(a)<<\" \"<<(b)<<endl\n#define vi vector<int>\n\nusing ll = long long;\nconst int INF = (INT_MAX/2);\nconst ll LLINF = (LLONG_MAX/2);\nconst double eps = 1e-8;\nconst ll DIV =1e9+7;\n//const double PI = M_PI;\ninline ll pow(ll x,ll n,ll m){ll r=1;while(n>0){if((n&1)==1)r=r*x%m;x=x*x%m;n>>=1;}return r%m;}\ninline ll lcm(ll d1, ll d2){return d1 / __gcd(d1, d2) * d2;}\ninline ll inv(ll x, ll div){return pow(x, div - 2, div);}\n#define chmax(a,b) a=max(a,b)\n\n/*Coding Space*/\nclass Dice{\npublic:\n  int ue;\n  int temae;\n  int migi;\n  Dice(int u, int t, int m){\n    ue = u, temae = t, migi = m;\n  }\n};\n\nusing tiiiii = tuple<int,int,int,int,int>;\n\nDice rotate_r(Dice a){\n  return Dice(7-a.migi,a.temae,a.ue);\n}\nDice rotate_l(Dice a){\n  return Dice(a.migi,a.temae,7-a.ue);\n}\nDice rotate_oku(Dice a){\n  return Dice(a.temae,7-a.ue,a.migi);\n}\nDice rotate_temae(Dice a){\n  return Dice(7-a.temae,a.ue,a.migi);\n}\nDice dice(1,2,3);\n\nint h,w;\nvector<string> m;\nmap<tiiiii,bool> memo;\nbool s(Dice d, int x, int y){\n  if(x < 0 || x >= w || y < 0 || y >= h || m[y][x] == '#' || m[y][x] != 7 - d.ue + '0' || memo.count(tiiiii{d.ue,d.temae,d.migi,x,y}) == 1) return false;\n  memo[tiiiii{d.ue,d.temae,d.migi,x,y}] = true;\n  //cerr << x  << ' ' << y << ' ' << 7 - d.ue << endl;\n  if(x == w - 1 && y == h - 1) return true;\n  else{\n    bool ret = false;\n    ret |= s(rotate_r(d), x+1, y);\n    ret |= s(rotate_l(d), x-1, y);\n    ret |= s(rotate_oku(d), x, y-1);\n    ret |= s(rotate_temae(d), x, y+1);\n    return ret;\n  }\n}\nint main(){\n  cin >> h >> w;\n  m.resize(h);\n  rep(i,h) cin >> m[i];\n  if(s(dice,0,0)) cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#include <tuple>\n#define mkp make_pair\n#define mkt make_tuple\n#define rep(i,n) for(int i = 0; i < (n); ++i)\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1e9+7;\ntemplate<class T> void chmin(T &a,const T &b){if(a>b) a=b;}\ntemplate<class T> void chmax(T &a,const T &b){if(a<b) a=b;}\n\nint H,W;\nvector<string> S;\n\nint dp[101][101][7][7][7];//dw,fr,ri\nstruct State{\n    int dw,fr,ri;\n    State(int dw,int fr,int ri):dw(dw),fr(fr),ri(ri){}\n    State(){}\n};\n\nState toR(State now){\n    State nex=now;\n    nex.ri=7-now.dw;\n    nex.fr=now.fr;\n    nex.dw=now.ri;\n    return nex;\n}\nState toL(State now){\n    State nex=now;\n    nex.ri=now.dw;\n    nex.fr=now.fr;\n    nex.dw=7-now.ri;\n    return nex;\n}\nState toD(State now){\n    State nex=now;\n    nex.ri=now.ri;\n    nex.fr=7-now.dw;\n    nex.dw=now.fr;\n    return nex;\n}\nState toU(State now){\n    State nex=now;\n    nex.ri=now.ri;\n    nex.fr=now.dw;\n    nex.dw=7-now.fr;\n    return nex;\n}\n\nconst int INF=1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nbool bfs(){\n    rep(i,H) rep(j,W) rep(k,7) rep(l,7) rep(m,7) dp[i][j][k][l][m]=INF;\n    queue<pair<pair<int,int>,State>> Q;\n    Q.push(mkp(mkp(0,0),State{6,2,3}));\n    dp[0][0][6][2][3]=0;\n\n    while(!Q.empty()){\n        auto f=Q.front();\n        Q.pop();\n        int x=f.first.first;\n        int y=f.first.second;\n        State now=f.second;\n\n        rep(k,4){\n            int nx=x+dx[k];\n            int ny=y+dy[k];\n            if(nx<0||ny<0||nx>=H||ny>=W) continue;\n            State nex;\n            if(k==0) nex=toR(now);\n            else if(k==1) nex=toD(now);\n            else if(k==2) nex=toL(now);\n            else nex=toU(now);\n\n            if(S[nx][ny]=='#') continue;\n            if(S[nx][ny]-'0'!=nex.dw) continue;\n            \n            if(dp[nx][ny][nex.dw][nex.fr][nex.ri]==INF){\n                dp[nx][ny][nex.dw][nex.fr][nex.ri]=0;\n                Q.push(mkp(mkp(nx,ny),nex));\n            }\n        }\n    }\n\n    rep(k,7) rep(l,7) rep(m,7) if(dp[H-1][W-1][k][l][m]!=INF) return true;\n    return false;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin>>H>>W;\n  S.resize(H);\n  rep(i,H) cin>>S[i];\n\n  if(bfs()) cout<<\"YES\"<<endl;\n  else cout<<\"NO\"<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_H = 110;\nint H, W;\nint mp[MAX_H][MAX_H];\nint cp[MAX_H][MAX_H];\nchar S[MAX_H];\nint Base[5][5] = {  {6, 3, 1, 4, 6},\n                    {2,-1, 2,-1, 2},\n                    {1, 3, 6, 4, 1},\n                    {5,-1, 5,-1, 5},\n                    {6, 3, 1, 4, 6}};\n\nint dx[4] = {0,1,-1, 0};\nint dy[4] = {1,0, 0,-1};\nbool visited[MAX_H][MAX_H];\n\nvoid solve() {\n    \n    stack<pair<int,int> > task;\n    task.push(pair<int,int>(0,0));\n    while(!task.empty()) {\n        pair<int,int> p = task.top(); task.pop();\n        int x = p.first, y = p.second;\n        if(visited[x][y]) continue;\n        visited[x][y] = true;\n        if(x == H-1 && y == W-1) { printf(\"YES\\n\"); return;}\n        for(int i = 0; i < 4; ++i) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n            if(mp[nx][ny] == -1 || cp[nx][ny] == -1 || mp[nx][ny] != cp[nx][ny]) continue;\n            task.push(pair<int,int>(nx,ny));\n        }\n    }\n    printf(\"NO\\n\");\n}\n\nint main()\n{\n    scanf(\"%d %d\", &H, &W);\n    for(int i = 0; i < H; ++i) {\n        scanf(\"%s\", S);\n        for(int j = 0; j < W; ++j) {\n            if(S[j] == '#') mp[i][j] = -1;\n            else mp[i][j] = S[j] - '0';\n        }\n    }\n    for(int i = 0; i < H; ++i) {\n        for(int j = 0; j < W; ++j) {\n            cp[i][j] = Base[i%4][j%4];\n        }\n    }\n    /*\n    printf(\"cp:\\n\");\n    for(int i = 0; i < H; ++i) {\n        for(int j = 0; j < W; ++j) {\n            if(cp[i][j] == -1) { printf(\"#\"); }\n            else printf(\"%d\",cp[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    */\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\n\n//0:中央 1:南 2:東 3:西 4:北 5:裏側\nstruct Dice{\n\n\tvoid roll(char dst){\n\t\tfor(int i = 0; i < 6; i++) work[i] = number[i];\n\t\tswitch(dst){\n\t\tcase 'E':\n\t\t\tsetNumber(work[3],work[1],work[0],work[5],work[4],work[2]);\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tsetNumber(work[1],work[5],work[2],work[3],work[0],work[4]);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tsetNumber(work[4],work[0],work[2],work[3],work[5],work[1]);\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\tsetNumber(work[2],work[1],work[5],work[0],work[4],work[3]);\n\t\t\tbreak;\n\t\t}\n\t};\n\n\tint getBottom(){\n\t\treturn number[5];\n\t}\n\tint getS(){\n\n\t\treturn number[1];\n\t}\n\tint getE(){\n\n\t\treturn number[2];\n\t}\n\n\tvoid copy(Dice arg_dice){\n\n\t\tfor(int i = 0; i < 6; i++){\n\n\t\t\tnumber[i] = arg_dice.number[i];\n\t\t}\n\t}\n\n\tvoid setNumber(int n0,int n1,int n2,int n3,int n4,int n5){\n\t\tnumber[0] = n0;\n\t\tnumber[1] = n1;\n\t\tnumber[2] = n2;\n\t\tnumber[3] = n3;\n\t\tnumber[4] = n4;\n\t\tnumber[5] = n5;\n\t}\n\n\tint number[6],work[6];\n};\n\nstruct Info{\n\n\tInfo(int arg_row,int arg_col,Dice arg_dice){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tdice = arg_dice;\n\t}\n\tint row,col;\n\tDice dice;\n};\n\n\nint H,W;\nchar table[105][105];\nbool visited[105][105][7][7][7];\n\nbool rangeCheck(int row,int col){\n\n\treturn row >= 0 && row <= H-1 && col >= 0 && col <= W-1;\n}\n\n\nint main(){\n\n\tscanf(\"%d %d\",&H,&W);\n\n\tfor(int row = 0; row < H; row++){\n\n\t\tscanf(\"%s\",table[row]);\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tfor(int a = 1; a <= 6; a++){\n\t\t\t\tfor(int b = 1; b <= 6; b++){\n\t\t\t\t\tfor(int c = 1; c <= 6; c++){\n\n\t\t\t\t\t\tvisited[row][col][a][b][c] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tDice dice;\n\tdice.setNumber(1,2,3,4,5,6);\n\n\tvisited[0][0][dice.getBottom()][dice.getS()][dice.getE()] = true;\n\n\tqueue<Info> Q;\n\tQ.push(Info(0,0,dice));\n\n\tint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\tchar DIR[4] = {'N','W','E','S'};\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().row == H-1 && Q.front().col == W-1){\n\n\t\t\tprintf(\"YES\\n\");\n\t\t\treturn 0;\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\n\t\t\t\tint adj_row = Q.front().row+diff_row[i];\n\t\t\t\tint adj_col = Q.front().col+diff_col[i];\n\n\t\t\t\tif(!rangeCheck(adj_row,adj_col)||table[adj_row][adj_col] == '#')continue;\n\n\t\t\t\tdice.copy(Q.front().dice);\n\t\t\t\tdice.roll(DIR[i]);\n\n\t\t\t\tif(dice.getBottom() != table[adj_row][adj_col]-'0')continue;\n\n\t\t\t\tif(visited[adj_row][adj_col][dice.getBottom()][dice.getS()][dice.getE()])continue;\n\t\t\t\tvisited[adj_row][adj_col][dice.getBottom()][dice.getS()][dice.getE()] = true;\n\n\t\t\t\tQ.push(Info(adj_row,adj_col,dice));\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"NO\\n\");\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#include <boost/multiprecision/cpp_ll.hpp>\n//typedef boost::multiprecision::cpp_ll ll;\ntypedef long double dd;\n#define i_7 (ll)(1E9+7)\n//#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\ntypedef pair<ll,ll> l_l;\nll inf=(ll)1E16;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\ndd EPS=1E-9;\nstring alp=\"abcdefghijklmnopqrstuvwxyz\";\n//#define endl \"/n\"\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\nstruct sai{\n    ll ue,mae,migi;\n};\nint main(){\n    ll h,w;cin>>h>>w;\n    string st[h];\n    rep(i,0,h-1)cin>>st[i];\n    bool b[h][w];\n    rep(i,0,h-1){\n        rep(j,0,w-1){\n            b[i][j]=false;\n        }\n    }\n    b[0][0]=true;\n    queue<pair<sai,l_l>> q;\n    sai s;\n    s.ue=1;s.migi=3;s.mae=2;\n    q.push(make_pair(s,make_pair(0,0)));\n    while(q.size()>0){\n        pair<sai,l_l> p=q.front();q.pop();\n        s=p.first;\n        sai sa;\n        ll x=p.second.first;ll y=p.second.second;\n        //cout<<x<<' '<<y<<endl;\n        if(x>0){\n            if(st[x-1][y]!='#' && b[x-1][y]==false){\n                if(7-s.mae==st[x-1][y]-'0'){\n                    b[x-1][y]=true;\n                    sa.ue=s.mae;\n                    sa.mae=7-s.ue;\n                    sa.migi=s.migi;\n                    q.push(make_pair(sa,make_pair(x-1,y)));\n                }\n            }\n        }\n        if(y>0){\n            if(st[x][y-1]!='#' && b[x][y-1]==false){\n                if(7-s.migi==st[x][y-1]-'0'){\n                    b[x][y-1]=true;\n                    sa.ue=s.migi;\n                    sa.mae=s.mae;\n                    sa.migi=7-s.ue;\n                    q.push(make_pair(sa,make_pair(x,y-1)));\n                }\n            }\n        }\n        if(x<h-1){\n            if(st[x+1][y]!='#' && b[x+1][y]==false){\n                if(s.mae==st[x+1][y]-'0'){\n                    b[x+1][y]=true;\n                    sa.ue=7-s.mae;\n                    sa.mae=s.ue;\n                    sa.migi=s.migi;\n                    q.push(make_pair(sa,make_pair(x+1,y)));\n                }\n            }\n        }\n        if(y<w-1){\n            if(st[x][y+1]!='#' && b[x][y+1]==false){\n                if(s.migi==st[x][y+1]-'0'){\n                    b[x][y+1]=true;\n                    sa.ue=7-s.migi;\n                    sa.mae=s.mae;\n                    sa.migi=s.ue;\n                    q.push(make_pair(sa,make_pair(x,y+1)));\n                }\n            }\n        }\n    }\n    if(b[h-1][w-1]){\n        cout<<\"YES\"<<endl;\n    }else{\n        cout<<\"NO\"<<endl;\n    }\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\nauto constexpr INF32 = numeric_limits<int32_t>::max()/2-1;\nauto constexpr INF64 = numeric_limits<int64_t>::max()/2-1;\nauto constexpr INF   = numeric_limits<int>::max()/2-1;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#define dump(...) cerr << \"[\" << setw(3) << __LINE__ << \":\" << __FUNCTION__ << \"] \", dump_impl(#__VA_ARGS__, __VA_ARGS__)\n#define say(x) cerr << \"[\" << __LINE__ << \":\" << __FUNCTION__ << \"] \" << x << endl\n#define debug if (1)\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class F> int ppt(C const& v, F f) {\n    return partition_point(v.begin(), v.end(), f)-v.begin();\n}\n// <<<\n// >>> union find\nstruct UnionFind {\n    int n, sz; // id : 0...n-1\n    vector<int> par;\n\n    UnionFind(int n = 0) : n(n), sz(n), par(n,-1) { }\n    int root(int x) {\n        assert(0 <= x); assert(x < n);\n        return par[x] < 0 ? x : par[x] = root(par[x]);\n    }\n    bool unite(int x, int y) {\n        x = root(x), y = root(y);\n        if (x == y) return false;\n        sz--;\n        if (par[x] < par[y]) swap(x,y);\n        par[y] += par[x];\n        par[x] = y;\n        return true;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return -par[root(x)]; }\n    int size() const { return sz; }\n    struct groups_t {\n        vector<vector<int> > grp;\n        vector<pair<int,int> > id;\n    };\n    groups_t groups() {\n        vector<vector<int> > g(n);\n        rep (i,n) if (par[i] < 0) g[i].reserve(-par[i]);\n        rep (i,n) g[root(i)].push_back(i);\n        vector<vector<int> > grp; grp.reserve(size());\n        rep (i,n) if (g[i].size()) grp.emplace_back(move(g[i]));\n        vector<pair<int,int> > id(n);\n        rep (i,grp.size()) rep (j,grp[i].size()) {\n            id[grp[i][j]] = make_pair(i,j);\n        }\n        return { grp, id };\n    }\n};\n// <<<\nll mod(ll x, ll m) { return (x %= m) < 0 ? x+m : x; }\n\nint32_t main() {\n    int h,w; cin >> h >> w;\n    vector<string> s(h); cin >> s;\n\n    auto valid = [&](int i, int j) {\n        if (!(0 <= i && i < h &&\n              0 <= j && j < w)) return false;\n        if (i%4 == 0)  {\n            const int a[] = { 6,3,1,4 };\n            return s[i][j]-'0' == a[j%4];\n        } else if (i%4 == 2) {\n            const int a[] = { 1,3,6,4 };\n            return s[i][j]-'0' == a[j%4];\n        } else if (j%4 == 0) {\n            const int a[] = { 6,2,1,5 };\n            return s[i][j]-'0' == a[i%4];\n        } else if (j%4 == 2) {\n            const int a[] = { 1,2,6,5 };\n            return s[i][j]-'0' == a[i%4];\n        } else {\n            assert(s[i][j] == '#');\n            return false;\n        }\n    };\n\n    UnionFind uf(h*w);\n    auto id = [&](int i, int j) { return i*w+j; };\n    rep (i,h) rep (j,w-1) if (valid(i,j) && valid(i,j+1)) {\n        uf.unite(id(i,j),id(i,j+1));\n    }\n    rep (i,h-1) rep (j,w) if (valid(i,j) && valid(i+1,j)) {\n        uf.unite(id(i,j),id(i+1,j));\n    }\n\n    cout << (uf.same(id(0,0),id(h-1,w-1)) ? \"YES\" : \"NO\") << endl;\n\n    debug {\n        auto a = make_v<int,2>(h,w);\n        rep (i,h) rep (j,w) a[i][j] = valid(i,j);\n        dump(as_mat(a));\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <limits>\n#include <iostream>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <iomanip>\n#include <functional>\n#include <complex>\n\nusing namespace std;\n\n\ntemplate<class T,class U>inline constexpr bool chmin(T&a,const U b){if(a<=b)return false;a=b;return true;}\ntemplate<class T,class U>inline constexpr bool chmax(T&a,const U b){if(a>=b)return false;a=b;return true;}\n#define bit(n,k) ( (n>>k)&1 )\n\nstruct Dice\n{\n  // int x, y;\n  int l, r, f, b, d, u;\n\n  void RollN()\n  {\n    //  --y;\n    int buff = d;\n    d = f;\n    f = u;\n    u = b;\n    b = buff;\n  }\n\n  void RollS()\n  {\n    // ++y;\n    int buff = d;\n    d = b;\n    b = u;\n    u = f;\n    f = buff;\n  }\n\n  void RollL() // ----->\n  {\n    int buff = f;\n    f = l;\n    l = b;\n    b = r;\n    r = buff;\n  }\n\n  void RollR() // <------\n  {\n    int buff = f;\n    f = r;\n    r = b;\n    b = l;\n    l = buff;\n  }\n\n  void RollE() // .o -> o.\n  {\n    // --x;\n    int buff = d;\n    d = l;\n    l = u;\n    u = r;\n    r = buff;\n  }\n\n\n  void RollW() // o. -> .o\n  {\n    //  ++x;\n    int buff = d;\n    d = r;\n    r = u;\n    u = l;\n    l = buff;\n  }\n};\n\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr); \n    cout<<fixed<<setprecision(20);\n\n    Dice d;\n    d.u=1;\n    d.f=2;\n    d.d=6;\n    d.l=3;\n    d.r=4;\n    d.b=5;\n    int H,W;\n    cin>>H>>W;\n    char S[110][110];\n    for(int i=1;i<=H;i++){\n        for(int j=1;j<=W;j++){\n            cin>>S[i][j];\n        }\n    }\n    using T=tuple<int,int,int,int,int,int,int,int>;\n    queue<T> que;\n    set<T> se;\n\n    se.insert(T(1,1,d.u,d.d,d.r,d.l,d.f,d.b));\n    que.emplace(1,1,d.u,d.d,d.r,d.l,d.f,d.b);\n    bool flag=false;\n    while(!que.empty()){\n        int x,y;\n        Dice d;\n        tie(x,y,d.u,d.d,d.r,d.l,d.f,d.b)=que.front(); que.pop();\n        if(x==H && y==W) flag=true;\n        Dice w=d; w.RollW();\n        Dice e=d; e.RollE();\n        Dice n=d; n.RollN();\n        Dice s=d; s.RollS();\n        if(y<=W-1 && e.d==S[x][y+1]-'0'){\n            d=e;\n            if(se.find(T(x,y+1,d.u,d.d,d.r,d.l,d.f,d.b))==se.end()){\n                se.insert(T(x,y+1,d.u,d.d,d.r,d.l,d.f,d.b));\n                que.emplace(x,y+1,d.u,d.d,d.r,d.l,d.f,d.b);\n            }\n        }\n        if(y>=2 && w.d==S[x][y-1]-'0'){\n            d=w;\n            if(se.find(T(x,y-1,d.u,d.d,d.r,d.l,d.f,d.b))==se.end()){\n                se.insert(T(x,y-1,d.u,d.d,d.r,d.l,d.f,d.b));\n                que.emplace(x,y-1,d.u,d.d,d.r,d.l,d.f,d.b);\n            }\n        }\n        if(x<=H-1 && n.d==S[x+1][y]-'0'){\n            d=n;\n            if(se.find(T(x+1,y,d.u,d.d,d.r,d.l,d.f,d.b))==se.end()){\n                se.insert(T(x+1,y,d.u,d.d,d.r,d.l,d.f,d.b));\n                que.emplace(x+1,y,d.u,d.d,d.r,d.l,d.f,d.b);\n            }\n        }\n        if(x>=2 && s.d==S[x-1][y]-'0'){\n            d=s;\n            if(se.find(T(x-1,y,d.u,d.d,d.r,d.l,d.f,d.b))==se.end()){\n                se.insert(T(x-1,y,d.u,d.d,d.r,d.l,d.f,d.b));\n                que.emplace(x-1,y,d.u,d.d,d.r,d.l,d.f,d.b);\n            }\n        }\n\n    }\n    if(flag) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n}   \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2020/03/20] 13:02:32\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nusing max_heap = std::priority_queue<T>;\ntemplate<typename T>\nusing min_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\nauto mfp = [](auto&& f) { return [=](auto&&... args) { return f(f, std::forward<decltype(args)>(args)...); }; };\n\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\nstruct io_init\n{\n    io_init()\n    {\n        std::cin.tie(nullptr), std::ios::sync_with_stdio(false);\n        std::cout << std::fixed << std::setprecision(20);\n    }\n    void clear()\n    {\n        std::cin.tie(), std::ios::sync_with_stdio(true);\n    }\n} io_setting;\n\nint out() { return 0; }\ntemplate<typename T>\nint out(const T& v) { return std::cout << v, 0; }\ntemplate<typename T>\nint out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    return 0;\n}\ntemplate<typename T1, typename T2>\nint out(const std::pair<T1, T2>& v) { return out(v.first), std::cout << ' ', out(v.second), 0; }\ntemplate<typename T, typename... Args>\nint out(const T& v, const Args... args) { return out(v), std::cout << ' ', out(args...), 0; }\ntemplate<typename... Args>\nint outln(const Args... args) { return out(args...), std::cout << '\\n', 0; }\ntemplate<typename... Args>\nint outel(const Args... args) { return out(args...), std::cout << std::endl, 0; }\n#    define SHOW(...) static_cast<void>(0)\nconstexpr ull TEN(const usize n) { return n == 0 ? 1ULL : TEN(n - 1) * 10ULL; }\n\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type, const T& v = T{}) { return v; }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type szs, const T& v = T{})\n{\n    const usize s = (usize)szs[i];\n    return std::vector<decltype(make_v<T, Uint, n, i + 1>(szs, v))>(s, make_v<T, Uint, n, i + 1>(szs, v));\n}\ntemplate<typename T, typename Uint, usize n>\nauto make_v(c_arr<Uint, n> szs, const T& t = T{}) { return make_v<T, Uint, n, 0>(szs, t); }\nint main()\n{\n    const auto H = in<int>(), W = in<int>();\n    auto fss = in_v<std::string>({H});\n    for (int i = 0; i < H; i++) {\n        if (i % 4 == 0) {\n            constexpr const char* s = \"6314\";\n            for (int j = 0; j < W; j++) {\n                if (fss[i][j] != s[j % 4]) { fss[i][j] = '#'; }\n            }\n        } else if (i % 4 == 1) {\n            constexpr const char* s = \"2#2#\";\n            for (int j = 0; j < W; j++) {\n                if (fss[i][j] != s[j % 4]) { fss[i][j] = '#'; }\n            }\n        } else if (i % 4 == 2) {\n            constexpr const char* s = \"1364\";\n            for (int j = 0; j < W; j++) {\n                if (fss[i][j] != s[j % 4]) { fss[i][j] = '#'; }\n            }\n        } else {\n            constexpr const char* s = \"5#5#\";\n            for (int j = 0; j < W; j++) {\n                if (fss[i][j] != s[j % 4]) { fss[i][j] = '#'; }\n            }\n        }\n    }\n    auto used  = make_v<bool>({H, W}, false);\n    used[0][0] = true;\n    using pii  = std::pair<int, int>;\n    std::queue<pii> Q;\n    Q.push({0, 0}), used[0][0] = true;\n    while (not Q.empty()) {\n        const auto p = Q.front();\n        Q.pop();\n        const int y         = p.first;\n        const int x         = p.second;\n        constexpr int dxs[] = {0, 0, -1, 1};\n        constexpr int dys[] = {-1, 1, 0, 0};\n        for (int d = 0; d < 4; d++) {\n            const int dy = dys[d], dx = dxs[d];\n            const int ny = y + dy, nx = x + dx;\n            if (ny < 0 or ny >= H or nx < 0 or nx >= W or fss[ny][nx] == '#' or used[ny][nx]) { continue; }\n            used[ny][nx] = true, Q.push({ny, nx});\n        }\n    }\n    outln(used[H - 1][W - 1] ? \"YES\" : \"NO\");\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#include <stack>\n#include <queue>\n#include <map>\n#include <algorithm>\n#include <iomanip>\n#include <math.h>\n#include <string.h>\nusing namespace std; using ll = long long; using pll = pair<ll, ll>;\nusing vl = vector<ll>; using vll = vector<vl>; using vpll = vector<pll>;\nint ctoi(char c) {\n\tswitch (c) {\n\tcase '0': return 0; case '1': return 1; case '2': return 2;\n\tcase '3': return 3; case '4': return 4; case '5': return 5;\n\tcase '6': return 6; case '7': return 7; case '8': return 8;\n\tcase '9': return 9;  default: return 0;\n\t}\n}\nbool pairCompare(const pll firstElof, pll secondElof)\n{\n\treturn firstElof.second < secondElof.second;\n}\n//**Snippetリスト**//\n//rep, vin, all//\n//gcdlcm, isPrime, eratos, modinv, bitSearch, dfs, bfs, dijkstra, UnionFind, COM, digitDP//\nll i, j, k, l, m, n; ll N, M, K, H, W, L;\nll MOD = 1000000007; ll INF = 9999999999999; ll ans = 0;\nvll flag, color; vll path; vl D;\n//***********//\nvll R;\nvoid dfs(ll i, ll j) {\n\tstack<pll> S;\n\tS.push(make_pair(i, j));\n\tflag[i][j] = 1;\n\twhile (!S.empty()) {\n\t\tpll u = S.top();\n\t\tS.pop();\n\t\tif (u.first == H - 1 && u.second == W - 1) {\n\t\t\tans = 1;\n\t\t}\n\t\tif (i != 0) {\n\t\t\tif (flag[i - 1][j] == 0 && R[i-1][j] == 1)dfs(i - 1, j);\n\t\t}\n\t\tif (i != H-1) {\n\t\t\tif (flag[i + 1][j] == 0 && R[i+1][j] == 1)dfs(i + 1, j);\n\t\t}\n\t\tif (j != 0) {\n\t\t\tif (flag[i][j-1] == 0 && R[i][j-1] == 1)dfs(i, j-1);\n\t\t}\n\t\tif (j != W-1) {\n\t\t\tif (flag[i][j+1] == 0 && R[i][j+1] == 1)dfs(i, j+1);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> H >> W;\n\tR.resize(H, vl(W));\n\tflag.resize(H, vl(W));\n\tvector<string> S(H);\n\tvll P(H, vl(W, 0));\n\tfor (i = 0; i < H; i++) {\n\t\tcin >> S[i];\n\t\tfor (j = 0; j < W; j++) {\n\t\t\tif (S[i][j] == '#') {\n\t\t\t\tP[i][j] = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP[i][j] = ctoi(S[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tvll Q(H, vl(W, 0));\n\tfor (i = 0; i < H; i++) {\n\t\tfor (j = 0; j < W; j++) {\n\t\t\tll key;\n\t\t\tif (i % 4 == 0) {\n\t\t\t\tif (j % 4 == 0) key = 6;\n\t\t\t\tif (j % 4 == 1) key = 3;\n\t\t\t\tif (j % 4 == 2) key = 1;\n\t\t\t\tif (j % 4 == 3) key = 4;\n\t\t\t}\n\t\t\tif (i % 4 == 1) {\n\t\t\t\tif (j % 4 == 0) key = 2;\n\t\t\t\tif (j % 4 == 1) key = 3;\n\t\t\t\tif (j % 4 == 2) key = 2;\n\t\t\t\tif (j % 4 == 3) key = 4;\n\t\t\t}\n\t\t\tif (i % 4 == 2) {\n\t\t\t\tif (j % 4 == 0) key = 1;\n\t\t\t\tif (j % 4 == 1) key = 3;\n\t\t\t\tif (j % 4 == 2) key = 6;\n\t\t\t\tif (j % 4 == 3) key = 4;\n\t\t\t}\n\t\t\tif (i % 4 == 3) {\n\t\t\t\tif (j % 4 == 0) key = 5;\n\t\t\t\tif (j % 4 == 1) key = 3;\n\t\t\t\tif (j % 4 == 2) key = 5;\n\t\t\t\tif (j % 4 == 3) key = 4;\n\t\t\t}\n\t\t\tQ[i][j] = key;\n\t\t}\n\t}\n\tfor (i = 0; i < H; i++) {\n\t\tfor (j = 0; j < W; j++) {\n\t\t\tif (P[i][j] == Q[i][j]) {\n\t\t\t\tR[i][j] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tR[i][j] = 0;\n\t\t\t}\n\t\t\t//cout << R[i][j];\n\t\t\tflag[i][j] = 0;\n\t\t}\n\t\t//cout << endl;\n\t}\n\tdfs(0, 0);\n\tif (ans)cout << \"YES\" << endl;\n\telse cout << \"NO\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main() {\n\tint H, W, dx[4] = { 1, -1, 0, 0 }, dy[4] = { 0, 0, 1, -1 };\n\tcin >> H >> W;\n\tvector<string> S(H);\n\tfor (int i = 0; i < H; i++) cin >> S[i];\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (i % 2 == 0 && j % 2 == 0) {\n\t\t\t\tif ((i + j) % 4 == 0) {\n\t\t\t\t\tif (S[i][j] != '6') {\n\t\t\t\t\t\tS[i][j] = '#';\n\t\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tint nx = i + dx[k], ny = j + dy[k];\n\t\t\t\t\t\t\tif (0 <= nx && nx < H && 0 <= ny && ny < W) {\n\t\t\t\t\t\t\t\tS[nx][ny] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (S[i][j] != '1') {\n\t\t\t\t\t\tS[i][j] = '#';\n\t\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tint nx = i + dx[k], ny = j + dy[k];\n\t\t\t\t\t\t\tif (0 <= nx && nx < H && 0 <= ny && ny < W) {\n\t\t\t\t\t\t\t\tS[nx][ny] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (i % 2 != 0 || j % 2 != 0) continue;\n\t\t\tchar v[4];\n\t\t\tif (i % 4 == 0 && j % 4 == 0) v[0] = '2', v[1] = '5', v[2] = '3', v[3] = '4';\n\t\t\tif (i % 4 == 0 && j % 4 == 2) v[0] = '2', v[1] = '5', v[2] = '4', v[3] = '3';\n\t\t\tif (i % 4 == 2 && j % 4 == 0) v[0] = '5', v[1] = '2', v[2] = '3', v[3] = '4';\n\t\t\tif (i % 4 == 2 && j % 4 == 2) v[0] = '5', v[1] = '2', v[2] = '4', v[3] = '3';\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tint nx = i + dx[k], ny = j + dy[k];\n\t\t\t\tif (0 <= nx && nx < H && 0 <= ny && ny < W) {\n\t\t\t\t\tif (S[nx][ny] != v[k]) S[nx][ny] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (S[i][j] != '#') S[i][j] = '.';\n\t\t}\n\t}\n\tqueue<pair<int, int> > Q;\n\tbool V[100][100] = {};\n\tV[0][0] = true;\n\tQ.push({ 0, 0 });\n\twhile (!Q.empty()) {\n\t\tpair<int, int> P = Q.front();\n\t\tQ.pop();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = P.first + dx[i], ny = P.second + dy[i];\n\t\t\tif (0 <= nx && nx < H && 0 <= ny && ny < W) {\n\t\t\t\tif (S[nx][ny] == '.' && !V[nx][ny]) {\n\t\t\t\t\tQ.push({ nx, ny });\n\t\t\t\t\tV[nx][ny] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << (V[H - 1][W - 1] ? \"YES\" : \"NO\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-5L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\n// geometry library\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < eps) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < eps);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist + eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n            (aa * target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor() {\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a) {\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this->data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this->data[i][0]) * (obj.data[0][q]);\n                for (int t = 1; t < obj.data[i].size(); ++t) {\n                    hoge += this->data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix& operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    u64 mod;\n    modint(ll a, ll b) : value(((a% b) + 2 * b) % b), mod(b) {\n\n    }\n    modint operator+(const modint rhs) const {\n        return modint(*this) += rhs;\n    }\n    modint operator-(const modint rhs) const {\n        return modint(*this) -= rhs;\n    }\n    modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    modint operator/(const modint rhs) const {\n        return modint(*this) /= rhs;\n    }\n    modint& operator+=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    modint& operator-=(const modint rhs) {\n        assert(rhs.mod == mod);\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    modint& operator*=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value = (value * rhs.value) % mod;\n        return *this;\n    }\n    modint& operator/=(modint rhs) {\n        assert(rhs.mod == mod);\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    bool operator <(modint rhs) const {\n        return value < rhs.value;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nclass Dice {\npublic:\n    vector<ll> vertexs;\n    //Up: 0,Left: 1,Center: 2,Right: 3,Adj: 4, Down: 5\n    Dice(vector<ll> init) :vertexs(init) {\n\n    }\n    //Look from Center\n    void RtoL() {\n        for (int q = 1; q < 4; ++q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void LtoR() {\n        for (int q = 3; q >= 1; --q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void UtoD() {\n        swap(vertexs[5], vertexs[4]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[0], vertexs[2]);\n    }\n    void DtoU() {\n        swap(vertexs[0], vertexs[2]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[5], vertexs[4]);\n    }\n    bool ReachAble(Dice now) {\n        set<Dice> hoge;\n        queue<Dice> next;\n        next.push(now);\n        hoge.insert(now);\n        while (next.empty() == false) {\n            Dice seeing = next.front();\n            next.pop();\n            if (seeing == *this) return true;\n            seeing.RtoL();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.LtoR();\n            seeing.LtoR();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.RtoL();\n            seeing.UtoD();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.DtoU();\n            seeing.DtoU();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n        }\n        return false;\n    }\n    bool operator ==(const Dice& a) {\n        for (int q = 0; q < 6; ++q) {\n            if (a.vertexs[q] != (*this).vertexs[q]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool operator <(const Dice& a) const {\n        return (*this).vertexs < a.vertexs;\n    }\n};\n\npair<Dice, Dice> TwoDimDice(int center, int up) {\n    int target = 1;\n    while (true) {\n        if (center != target && 7 - center != target && up != target && 7 - up != target) {\n            break;\n        }\n        target++;\n    }\n    return mp(Dice(vector<ll>{up, target, center, 7 - target, 7 - center, 7 - up}), Dice(vector<ll>{up, 7 - target, center, target, 7 - center, 7 - up}));\n}\n\ntuple<Dice, Dice, Dice, Dice> OneDimDice(int center) {\n    int bo = min(center, 7 - center);\n    pair<int, int> goa;\n    if (bo == 1) {\n        goa = mp(2, 3);\n    }\n    else if (bo == 2) {\n        goa = mp(1, 3);\n    }\n    else if (bo == 3) {\n        goa = mp(1, 2);\n    }\n    tuple<Dice, Dice, Dice, Dice> now = make_tuple(Dice(vector<ll>{goa.first, goa.second, center, 7 - goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{goa.first, 7 - goa.second, center, goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{7 - goa.first, goa.second, center, 7 - goa.second, 7 - center, goa.first}),\n        Dice(vector<ll>{7 - goa.first, 7 - goa.second, center, goa.second, 7 - center, goa.first}));\n    return now;\n}\n\ntemplate<typename A, typename B>\nclass Dijkstra {\npublic:\n    vector<vector<pair<int, A>>> vertexs;\n    B Cost_Function;\n    Dijkstra(int n, B cost) : Cost_Function(cost) {\n        vertexs = vector<vector<pair<int, A>>>(n, vector<pair<int, A>>{});\n    }\n    ~Dijkstra() {\n        vertexs.clear();\n    }\n    void add_edge(int a, int b, A c) {\n        vertexs[a].push_back(mp(b, c));\n    }\n    vector<ll> build_result(int StartPoint) {\n        vector<ll> dist(vertexs.size(), 2e18);\n        dist[StartPoint] = 0;\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> next;\n        next.push(make_pair(0, StartPoint));\n        while (next.empty() == false) {\n            pair<ll, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (auto x : vertexs[now.second]) {\n                ll now_cost = now.first + Cost_Function(x.second);\n                if (dist[x.first] > now_cost) {\n                    dist[x.first] = now_cost;\n                    next.push(mp(now_cost, x.first));\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nclass Dinic {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n    vector<vector<edge>> Graph;\n    vector<int> level;\n    vector<int> itr;\n    Dinic(int n) {\n        Graph = vector<vector<edge>>(n, vector<edge>());\n    }\n    void add_edge(int a, int b, int cap) {\n        Graph[a].push_back(edge{ b, cap ,(int)Graph[b].size() });\n        Graph[b].push_back(edge{ a,0,(int)Graph[a].size() - 1 });\n    }\n    void bfs(int s) {\n        level = vector<int>(Graph.size(), -1);\n        level[s] = 0;\n        queue<int> next;\n        next.push(s);\n        while (next.empty() == false) {\n            int now = next.front();\n            next.pop();\n            for (auto x : Graph[now]) {\n                if (x.cap == 0) continue;\n                if (level[x.to] == -1) {\n                    level[x.to] = level[now] + 1;\n                    next.push(x.to);\n                }\n            }\n        }\n    }\n    int dfs(int now, int goal, int val) {\n        if (goal == now) return val;\n        for (int& i = itr[now]; i < (int)Graph[now].size(); ++i) {\n            edge& target = Graph[now][i];\n            if (target.cap > 0 && level[now] < level[target.to]) {\n                int d = dfs(target.to, goal, min(val, target.cap));\n                if (d > 0) {\n                    target.cap -= d;\n                    Graph[target.to][target.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int run(int s, int t) {\n        int ans = 0;\n        int f = 0;\n        while (bfs(s), level[t] >= 0) {\n            itr = vector<int>(Graph.size(), 0);\n            while ((f = dfs(s, t, 1e9)) > 0) {\n                ans += f;\n            }\n        }\n        return ans;\n    }\n};\n\n//by ei1333\n//https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz + 1, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cin.tie(0);\n}\n#define int ll\nint grid[1000][1000];\nvoid solve() {\n    int h, w;\n    cin >> h >> w;\n    set<tuple<Dice, int, int>> already;\n    \n    REP(i, h) {\n        string s;\n        cin >> s;\n        REP(q, w) {\n            if (s[q] != '#') {\n                grid[i][q] = s[q] - '0';\n            }\n        }\n    }\n    queue<tuple<Dice, int, int>> next;\n    next.push(make_tuple(Dice(vector<int>{2,4,6,3,1,5}), 0, 0));\n    while (next.empty() == false) {\n        tuple<Dice, int, int> now = next.front();\n        if (get<1>(now) == h - 1 && get<2>(now) == w - 1) {\n            cout << \"YES\" << endl;\n            return;\n        }\n        next.pop();\n        if (get<1>(now) != 0) {\n            //go down!\n            tuple<Dice, int, int> gogo = now;\n            get<0>(gogo).DtoU();\n            get<1>(gogo)--;\n            if (get<0>(gogo).vertexs[2] == grid[get<1>(gogo)][get<2>(gogo)]) {\n                if (already.find(gogo) == already.end()) {\n                    already.insert(gogo);\n                    next.push(gogo);\n                }\n            }\n        }\n        if (get<1>(now) != h - 1) {\n            tuple<Dice, int, int> gogo = now;\n            get<0>(gogo).UtoD();\n            get<1>(gogo)++;\n            if (get<0>(gogo).vertexs[2] == grid[get<1>(gogo)][get<2>(gogo)]) {\n                if (already.find(gogo) == already.end()) {\n                    already.insert(gogo);\n                    next.push(gogo);\n                }\n            }\n        }\n        if (get<2>(now) != 0) {\n            tuple<Dice, int, int> gogo = now;\n            get<0>(gogo).LtoR();\n            get<2>(gogo)--;\n            if (get<0>(gogo).vertexs[2] == grid[get<1>(gogo)][get<2>(gogo)]) {\n                if (already.find(gogo) == already.end()) {\n                    already.insert(gogo);\n                    next.push(gogo);\n                }\n            }\n        }\n        if (get<2>(now) != w - 1) {\n            tuple<Dice, int, int> gogo = now;\n            get<0>(gogo).RtoL();\n            get<2>(gogo)++;\n            if (get<0>(gogo).vertexs[2] == grid[get<1>(gogo)][get<2>(gogo)]) {\n                if (already.find(gogo) == already.end()) {\n                    already.insert(gogo);\n                    next.push(gogo);\n                }\n            }\n        }\n    }\n    cout << \"NO\" << endl;\n    return;\n}\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int di[] = {+1,-1, 0, 0};\nconst int dj[] = { 0, 0,+1,-1};\nint main() {\n\tint H, W;\n\tcin >> H >> W;\n\tvector<string> S(H);\n\tfor (auto& x : S) cin >> x;\n\n\tvector<string> ptn = {\n\t\t\"6314\",\n\t\t\"2 2 \",\n\t\t\"1364\",\n\t\t\"5 5 \",\n\t};\n\n\tvector<vector<bool>> a(H, vector<bool>(W));\n\tfor (int i = 0; i < H; ++ i) for (int j = 0; j < W; ++ j) a[i][j] = S[i][j] == ptn[i%4][j%4];\n\n\tqueue<pair<int,int>> q;\n\tq.push({0,0});\n\twhile (!q.empty()) {\n\t\tint i = q.front().first;\n\t\tint j = q.front().second;\n\t\tq.pop();\n\t\tif (i == H-1 && j == W-1) {\n\t\t\tcout << \"YES\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tfor (int k = 0; k < 4; ++ k) {\n\t\t\tint ii = i + di[k];\n\t\t\tint jj = j + dj[k];\n\t\t\tif (0 <= ii && ii < H && 0 <= jj && jj < W && a[ii][jj]) {\n\t\t\t\ta[ii][jj] = false;\n\t\t\t\tq.push({ii,jj});\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"NO\" << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nint h, w;\nstruct indata\n{\n    vector<int> masme;\n    int inh, inw;\n};\nvector<int> dx;\nvector<int> dy;\n\nint main() {\n    cin >> h >> w;\n    vector< vector < int > > s(h, vector<int>(w, 0));\n    vector< vector < bool > > sb(h, vector<bool>(w, false));\n    for(int i = 0; i < h; ++i) {\n        for(int j = 0; j < w; ++j) {\n            char ins;\n            cin >> ins;\n            if(ins == '#') {\n                s.at(i).at(j) = -1;\n            }else {\n                s.at(i).at(j) = ins - '0';\n            }\n        }\n    }\n\n    dx.push_back(0);\n    dx.push_back(1);\n    dx.push_back(0);\n    dx.push_back(-1);\n    dy.push_back(-1);\n    dy.push_back(0);\n    dy.push_back(1);\n    dy.push_back(0);\n\n    indata first;\n    first.masme.push_back(5);\n    first.masme.push_back(3);\n    first.inh = 0;\n    first.inw = 0;\n    queue<indata> que;\n    que.push(first);\n    sb.at(first.inh).at(first.inw) = true;\n\n    bool flg = false;\n    int ue = 0;\n    int migi = 0;\n    int sita = 0;\n    int hidari = 0;\n    while(!que.empty()) {\n        indata exe = que.front();\n        que.pop();\n        if(exe.inh == h-1 && exe.inw == w-1) {\n            flg = true;\n            break;\n        }else {\n            int under = s.at(exe.inh).at(exe.inw);\n            for(int i = 0; i < 4; ++i) {\n                int nex = exe.inw + dx.at(i);\n                int ney = exe.inh + dy.at(i);\n                if(nex >= 0 && nex < w && ney >= 0 && ney < h && s.at(ney).at(nex) != -1 && (!sb.at(ney).at(nex))) {\n                    ue = exe.masme.at(0); migi = exe.masme.at(1);\n                    sita = 7-ue; hidari = 7-migi;\n                    vector<int> check;\n                    check.push_back(ue);\n                    check.push_back(migi);\n                    check.push_back(sita);\n                    check.push_back(hidari);\n                    if(s.at(ney).at(nex) == check.at(i)) {\n                        indata next;\n                        next.inh = ney;\n                        next.inw = nex;\n                        sb.at(ney).at(nex) = true;\n                        if(i == 0) {\n                            next.masme.push_back(7-under);\n                            next.masme.push_back(check.at(1));\n                        }else if(i == 1) {\n                            next.masme.push_back(check.at(0));\n                            next.masme.push_back(7-under);\n                        }else if(i == 2) {\n                            next.masme.push_back(under);\n                            next.masme.push_back(check.at(1));\n                        }else {\n                            next.masme.push_back(check.at(0));\n                            next.masme.push_back(under);\n                        }\n                        que.push(next);\n                    }\n                }\n            }\n        }\n    }\n    if(flg) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n\treturn vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n\tfor(auto &e:u) fill_v<T>(e,v...);\n}\n\nint64 d[4][4] = {{6, 3, 1, 4}, {2, 3, 5, 4}, {1, 3, 6, 4}, {5, 3, 2, 4}};\n\nint64 dx[4] = {-1, 0, 1, 0};\nint64 dy[4] = {0, -1, 0, 1};\nstring dir = \"WNES\";\n\nstruct Die{\n  int s[6];\n  int &top()   {return s[0];}\n  int &south() {return s[1];}\n  int &east()  {return s[2];}\n  int &west()  {return s[3];}\n  int &north() {return s[4];}\n  int &bottom(){return s[5];}\n  void roll(char c){\n    //the view from above\n    // N\n    //W E\n    // S\n    string b(\"EWNSRL\");\n    int v[6][4]={{0,3,5,2},\n                 {0,2,5,3},\n                 {0,1,5,4},\n                 {0,4,5,1},\n                 {1,2,4,3},\n                 {1,3,4,2}};\n    for(int k=0;k<6;k++){\n      if(b[k]!=c) continue;\n      int t=s[v[k][0]];\n      s[v[k][0]]=s[v[k][1]];\n      s[v[k][1]]=s[v[k][2]];\n      s[v[k][2]]=s[v[k][3]];\n      s[v[k][3]]=t;\n    }\n  }\n  using ll = long long;\n  ll hash(){\n    ll res=0;\n    for(int i=0;i<6;i++) res=res*256+s[i];\n    return res;\n  }\n  bool operator==(const Die &d) const{\n    for(int i=0;i<6;i++) if(s[i]!=d.s[i]) return 0;\n    return 1;\n  }\n\n  bool operator<(const Die &d) const {\n    return s[0] < d.s[0];\n  }\n};\n\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint64 H, W;\n\tcin >> H >> W;\n\tvector<string> f(H);\n\tREP(i, H) {\n\t  cin >> f[i];\n\t}\n\tauto d = make_v<int64>(H, W);\n\tfill_v<int64>(d, INF_LL);\n\tauto in = [&](int64 y, int64 x) {\n\t  return 0<=y&&y<H&&0<=x&&x<W&&(f[y][x]!='#');\n\t};\n\tusing T = tuple<int64, int64, int64, Die>;\n\tpriority_queue<T, vector<T>, greater<T>> pq;\n\tDie init;\n\tinit.top() = 1; init.south() = 2; init.bottom() = 6; init.north() = 5; init.west() = 4; init.east() = 3;\n\tpq.emplace(0, 0, 0, init);\n\td[0][0] = 0;\n\twhile (pq.size()) {\n\t  int64 dd, y, x;\n\t  Die dice;\n\t  tie(dd, y, x, dice) = pq.top(); pq.pop();\n\t  if (d[y][x] < dd) continue;\n\t  REP(i, 4) {\n\t    int64 yy = y + dy[i], xx = x + dx[i];\n\t    Die nxt = dice;\n\t    nxt.roll(dir[i]);\n\t    if (!in(yy, xx) || nxt.bottom() != (f[yy][xx] - '0')) continue;\n\t    if (d[yy][xx] > dd+1) {\n\t      d[yy][xx] = dd+1;\n\t      pq.emplace(dd+1, yy, xx, nxt);\n\t    }\n\t  }\n\t}\n\tif (d[H-1][W-1] != INF_LL) {\n    cout << \"YES\" << endl;\n\t} else {\n\t  cout << \"NO\" << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <math.h>\n#include <map>\n#include <numeric>\n#include <string>\n#include <queue>\nusing namespace std;\ntypedef long long int ll;\n\nbool can[101][101];\n\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\n\nint num[6][2][4]=\n{{{2,5,4,3},{5,2,3,4}},\n{{1,6,3,4},{6,1,4,3}},\n{{2,5,1,6},{5,2,6,1}},\n{{2,5,6,1},{5,2,1,6}},\n{{1,6,4,3},{6,1,3,4}},\n{{2,5,3,4},{5,2,4,3}}\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int h,w; cin >> h >> w;\n    char fi[h][w];\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            cin >> fi[i][j];\n        }\n    }\n    can[0][0]=1;\n    queue<pair<pair<int,int>,pair<int,int>>> q;\n    q.push(make_pair(make_pair(0,0),make_pair(6,0)));\n    while(q.size()){\n        auto p=q.front(); q.pop();\n        int x=p.first.first,y=p.first.second;\n        for(int i=0;i<4;i++){\n            int nx=dx[i]+x,ny=dy[i]+y;\n            if(0<=nx&&nx<h&&0<=ny&&ny<w){\n                if(can[nx][ny])continue;\n                if(fi[nx][ny]=='#')continue;\n                if(fi[nx][ny]-'0'!=num[p.second.first-1][p.second.second][i])continue;\n                can[nx][ny]=1;\n                int v=fi[x][y]-'0';\n                int w=fi[nx][ny]-'0';\n                int t=0;\n                if(i==0||i==1){\n                    if(v>=4&&i==1)t=1;\n                    if(v<=3&&i==0)t=1;\n                }\n                else{\n                    if(num[p.second.first-1][p.second.second][0]>=4)t=1;\n                }\n                q.push(make_pair(make_pair(nx,ny),make_pair(fi[nx][ny]-'0',t)));\n            }\n        }\n    }\n    if(can[h-1][w-1]){\n        cout << \"YES\" << endl;\n    }else{\n        cout << \"NO\" << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define rep(i, n) for(int i=0;i<n;i++)\nusing P = pair<int, int>;\nint H, W;\nvector<vector<int>> G;\nvector<vector<int>> used;\nvoid dfs(P v) {\n  used[v.first][v.second] = true;\n  if(v.first == H && v.second == W) return;\n\n  if(G[v.first+1][v.second] && !used[v.first+1][v.second]) dfs(make_pair(v.first+1, v.second));\n  if(G[v.first-1][v.second] && !used[v.first-1][v.second]) dfs(make_pair(v.first-1, v.second));\n  if(G[v.first][v.second-1] && !used[v.first][v.second-1]) dfs(make_pair(v.first, v.second-1));\n  if(G[v.first][v.second+1] && !used[v.first][v.second+1]) dfs(make_pair(v.first, v.second+1));\n}\nint main() {\n  int h, w;\n  cin >> h >> w;\n  H = h; W = w;\n  G.resize(h+2);\n  rep(i, h+2) G[i].resize(w+2);\n  used = G;\n  rep(i, h) rep(j, w) {\n    if((i+1) % 2 == 0 && (j+1) % 2 == 0) {\n      char c;\n      cin >> c;\n    }\n    else {\n      char c;\n      cin >> c;\n      if(c == '#') G[i+1][j+1] = 0;\n      else G[i+1][j+1] = c - '0';\n    }\n  }\n  if(G[h][w] == 0) {\n    cout << \"NO\" << endl;\n    return 0;\n  }\n  rep(i, h) rep(j, w) {\n    if((i+1) % 2 == 0 && (j+1) % 2 == 0) continue;\n    int x = (j+1) % 4;\n    int y = (i+1) % 4;\n    if(y == 1) {\n      if(x == 1) {\n        if(G[i+1][j+1] != 6) G[i+1][j+1] = 0;\n      }\n      else if(x == 2) {\n        if(G[i+1][j+1] != 3) G[i+1][j+1] = 0;\n      }\n      else if(x == 3) {\n        if(G[i+1][j+1] != 1) G[i+1][j+1] = 0;\n      }\n      else if(x == 0) {\n        if(G[i+1][j+1] != 4) G[i+1][j+1] = 0;\n      }\n    }\n    else if(y == 2) {\n      if(G[i+1][j+1] != 2) G[i+1][j+1] = 0;\n    }\n    else if(y == 3) {\n      if(x == 1) {\n        if(G[i+1][j+1] != 1) G[i+1][j+1] = 0;\n      }\n      else if(x == 2) {\n        if(G[i+1][j+1] != 3) G[i+1][j+1] = 0;\n      }\n      else if(x == 3) {\n        if(G[i+1][j+1] != 6) G[i+1][j+1] = 0;\n      }\n      else if(x == 0) {\n        if(G[i+1][j+1] != 4) G[i+1][j+1] = 0;\n      }\n    }\n    else if( y == 0) {\n      if(G[i+1][j+1] != 5) G[i+1][j+1] = 0;\n    }\n  }\n  if(G[h][w] == 0) {\n    cout << \"NO\" << endl;\n    return 0;\n  }\n  P init = make_pair(1, 1);\n  dfs(init);\n  if(used[h][w]) cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define repr(i, n) for(int i = (n-1); i >= 0; --i)\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int MAX = 200005;\nconst int INF = 1001001001;\nconst int MOD = 1000000007;\n\nstruct dice {\n    int front, right, bottom;\n    dice(){\n        front = 2;\n        right = 3;\n        bottom = 6;\n    }\n    void b() {\n        int tmp = front;\n        front = bottom;\n        bottom = 7 - tmp;\n    }\n    void f() {\n        int tmp = bottom;\n        bottom = front;\n        front = 7 - tmp;\n    }\n    void l() {\n        int tmp = right;\n        right = bottom;\n        bottom = 7 - tmp;\n    }\n    void r() {\n        int tmp = bottom;\n        bottom = right;\n        right = 7 - tmp;\n    }\n};\n\nint main(){\n    int H, W;\n    cin >> H >> W;\n\n    vector<string> IN(H);\n    rep(i, H) cin >> IN[i];\n\n    vector<vector<int>> S(H, vector<int>(W));\n    rep(i, H)rep(j, W) {\n        if (IN[i][j] != '#') S[i][j] = IN[i][j] - '0';\n        else IN[i][j] = -1;\n    }\n\n    queue<pair<P, dice>> q;\n    dice di;\n    q.emplace(P(0, 0), di);\n    vector<vector<bool>> used(H, vector<bool>(W));\n    used[0][0] = true;\n    bool ans = false;\n    while (!q.empty()) {\n        auto p = q.front(); q.pop();\n        int i = p.first.first, j = p.first.second;\n        dice d = p.second;\n        if (i == H-1 && j == W-1) {\n            ans = true;\n            break;\n        }\n        if (i+1 < H && !used[i+1][j] && d.front == S[i+1][j]) {\n            dice nd(d); nd.f();\n            q.emplace(P(i+1, j), nd);\n            used[i+1][j] = true;\n        }\n        if (j+1 < W && !used[i][j+1] && d.right == S[i][j+1]) {\n            dice nd(d); nd.r();\n            q.emplace(P(i, j+1), nd);\n            used[i][j+1] = true;\n        }\n        if (i-1 >= 0 && !used[i-1][j]) {\n            dice nd(d); nd.b();\n            if (nd.bottom == S[i-1][j]) {\n                q.emplace(P(i-1, j), nd);\n                used[i-1][j] = true;\n            }\n        }\n        if (j-1 >= 0 && !used[i][j-1]) {\n            dice nd(d); nd.l();\n            if (nd.bottom == S[i][j-1]) {\n                q.emplace(P(i, j-1), nd);\n                used[i][j-1] = true;\n            }\n        }\n    }\n\n    if (ans) puts(\"YES\");\n    else puts(\"NO\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nconst ll MOD = 998244353;\nint h, w;\nvector<string> sq;\nbool ans = false;\n\n// state[0] = 上\n// state[1] = 手前\n// state[2] = 右\n// state[3] = 左\n// state[4] = 奥\n// state[5] = 下\n\nint used[101][101];\n\nvoid dfs(vector<char> state, int x, int y) {\n  if (used[x][y] == 1) { return; }\n  used[x][y] = 1;\n  if (x == h - 1 && y == w - 1) {\n    ans = true;\n    return;\n  }\n  if (y - 1 >= 0) {\n    if (sq[x][y - 1] == state[3]) {\n      dfs({state[2], state[1], state[5], state[0], state[4], state[3]}, x,\n          y - 1);\n    }\n  }\n  if (x - 1 >= 0) {\n    if (sq[x - 1][y] == state[4]) {\n      dfs({state[1], state[5], state[2], state[3], state[0], state[4]}, x - 1,\n          y);\n    }\n  }\n  if (y + 1 < w) {\n    if (sq[x][y + 1] == state[2]) {\n      dfs({state[3], state[1], state[0], state[5], state[4], state[2]}, x,\n          y + 1);\n    }\n  }\n  if (x + 1 < h) {\n    if (sq[x + 1][y] == state[1]) {\n      dfs({state[4], state[0], state[2], state[3], state[5], state[1]}, x + 1,\n          y);\n    }\n  }\n}\n\nsigned main() {\n\n  cin >> h >> w;\n  sq.resize(h);\n  vector<char> state(6);\n  for (int i = 0; i < 6; i += 1) {\n    state[i] = char(int('1') + i);\n  }\n  for (int i = 0; i < h; i += 1) {\n    cin >> sq[i];\n  }\n  dfs(state, 0, 0);\n  if (ans) {\n    cout << \"YES\" << endl;\n  } else {\n    cout << \"NO\" << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,...) for(int i = (a)*(strlen(#__VA_ARGS__)!=0);i<(int)(strlen(#__VA_ARGS__)?__VA_ARGS__:(a));++i)\n#define per(i,a,...) for(int i = (strlen(#__VA_ARGS__)?__VA_ARGS__:(a))-1;i>=(int)(strlen(#__VA_ARGS__)?(a):0);--i)\n#define foreach(i, n) for(auto &i:(n))\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define all(x) (x).begin(), (x).end()\n#define bit(x) (1ll << (x))\nusing ll = long long;\n//const ll MOD = (ll)1e9+7;\nconst ll MOD = 998244353;\nconst int INF = (ll)1e9+7;\nconst ll INFLL = (ll)1e18;\nusing namespace std;\ntemplate<class t>\nusing vvector = vector<vector<t>>;\ntemplate<class t>\nusing vvvector = vector<vector<vector<t>>>;\ntemplate<class t>\nusing priority_queuer = priority_queue<t, vector<t>, greater<t>>;\ntemplate<class t, class u> bool chmax(t &a, u b){if(a<b){a=b;return true;}return false;}\ntemplate<class t, class u> bool chmin(t &a, u b){if(a>b){a=b;return true;}return false;}\n#ifdef DEBUG\n#define debug(x) cout<<\"LINE \"<<__LINE__<<\": \"<<#x<<\" = \"<<x<<endl;\n#else\n#define debug(x) (void)0\n#endif\n\nll modpow(ll x, ll b){\n  ll res = 1;\n  while(b){\n    if(b&1)res = res * x % MOD;\n    x = x * x % MOD;\n    b>>=1;\n  }\n  return res;\n}\n\nll modinv(ll x){\n  return modpow(x, MOD-2);\n}\n\nbool was_output = false;\ntemplate<class t>\nvoid output(t a){\n  if(was_output)cout << \" \";\n  cout << a;\n  was_output = true;\n}\nvoid outendl(){\n  was_output = false;\n  cout << endl;\n}\nll in(){\n  ll res;\n  scanf(\"%lld\", &res);\n  return res;\n}\n\ntemplate<class t>\nistream& operator>>(istream&is, vector<t>&x){\n  for(auto &i:x)is >> i;\n  return is;\n}\n\ntemplate<class t, class u>\nistream& operator>>(istream&is, pair<t, u>&x){\n  is >> x.first >> x.second;\n  return is;\n}\n\ntemplate<class t>\nvoid in(t&x){\n  cin >> x;\n}\n\nint h;\nint w;\nvvector<int> tile;\n\nvvector<set<vector<int>>> dp;\n\nvoid input(){\n  h = in();\n  w = in();\n  tile.resize(h,vector<int>(w,-1));\n  foreach(i,tile){\n    foreach(j,i){\n      char d;\n      in(d);\n      if(d!='#'){\n        j = d-'0';\n      }\n    }\n  }\n  dp.resize(h,vector<set<vector<int>>>(w));\n}\n\n\nbool func(int y,int x,vector<int> dice){\n  if(y==h-1&&x==w-1)return true;\n  if(dp[y][x].count(dice))return false;\n  dp[y][x].insert(dice);\n  auto isin = [&](int y,int x){\n                return y<h && x<w && 0<=y&&0<=x;\n              };\n  auto right = [](vector<int> dice){\n                 swap(dice[0],dice[2]);\n                 swap(dice[3],dice[0]);\n                 swap(dice[5],dice[3]);\n                 return dice;\n               };\n  auto down = [](vector<int> dice){\n                swap(dice[0],dice[1]);\n                swap(dice[4],dice[0]);\n                swap(dice[5],dice[4]);\n                return dice;\n              };\n  auto left = [&](vector<int> dice){\n              return right(right(right(dice)));\n            };\n  auto up = [&](vector<int> dice){\n              return down(down(down(dice)));\n            };\n  vector<int> nd = right(dice);\n  if(isin(y,x+1)&&tile[y][x+1]==nd[5]){\n    if(func(y,x+1,nd))return true;\n  }\n  nd = down(dice);\n  if(isin(y+1,x)&&tile[y+1][x]==nd[5]){\n    if(func(y+1,x,nd))return true;\n  }\n  nd = left(dice);\n  if(isin(y,x-1)&&tile[y][x-1]==nd[5]){\n    if(func(y,x-1,nd))return true;\n  }\n  nd = up(dice);\n  if(isin(y-1,x)&&tile[y-1][x]==nd[5]){\n    if(func(y-1,x,nd))return true;\n  }\n  return false;\n}\n\nint main(){\n  input();\n\n  cout << (func(0,0,{1,2,3,4,5,6})?\"YES\":\"NO\") << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing VI = vector<int>;\nusing VL = vector<ll>;\nusing loop = int;\ntemplate<class T> using PQ = priority_queue<T, vector<T>, greater<T>>;\n#define FOR(i,a,n) for(loop (i)=(a);(i)<(n);++(i))\n#define eFOR(i,a,n) for(loop (i)=(a);(i)<=(n);++(i))\n#define rFOR(i,a,n) for(loop (i)=(n)-1;(i)>=(a);--(i))\n#define erFOR(i,a,n) for(loop (i)=(n);(i)>=(a);--(i))\n#define each(i, a) for(auto &i : a)\n#define SORT(i) sort((i).begin(),(i).end())\n#define rSORT(i,a) sort((i).begin(),(i).end(),(a))\n#define all(i) (i).begin(),(i).end()\n#define out(y,x) ((y) < 0 || h <= (y) || (x) < 0 || w <= (x))\n#define line cout << \"------------------------\\n\" \n#define ENDL(i,n) ((i) == (n) - 1 ? \"\\n\" : \" \")\n//#define stop system(\"pause\") //comment out this on AOJ.\nconstexpr ll INF = 1000000000;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr ll mod = 1000000007;\nconstexpr ll MOD = 998244353;\nconstexpr ld eps = 1e-10;\nconstexpr ld pi = 3.1415926535897932;\ntemplate<class T>inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T>inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; }return false; }\ninline void init() { cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); }\ntemplate<class T>inline istream& operator>>(istream& is, vector<T>& v) { for (auto& elemnt : v)is >> elemnt; return is; }\ntemplate<class T, class U>inline istream& operator>>(istream& is, pair<T, U>& p) { is >> p.first >> p.second; return is; }\ntemplate<class T>inline vector<T> vec(size_t a) { return vector<T>(a); }\ntemplate<class T>inline vector<T> defvec(T def, size_t a) { return vector<T>(a, def); }\ntemplate<class T, class... Ts>inline auto vec(size_t a, Ts... ts) { return vector<decltype(vec<T>(ts...))>(a, vec<T>(ts...)); }\ntemplate<class T, class... Ts>inline auto defvec(T def, size_t a, Ts... ts) { return vector<decltype(defvec<T>(def, ts...))>(a, defvec<T>(def, ts...)); }\n\nint main() {\n    init();\n\n    int yd[] = { 6,2,1,5 }, xd[] = { 6,3,1,4 };\n    int yd2[] = { 6,5,1,2 }, xd2[] = { 6,4,1,3 };\n\n    int h, w; cin >> h >> w;\n    vector<string> s(h); cin >> s;\n    vector<VI> g(h * w);\n\n    for (int y = 0; y < h; y += 2) {\n        FOR(x, 0, w - 1) {\n            bool ok = false;\n            FOR(j, 0, 4) {\n                if ((y / 2) % 2 == 0) {\n                    ok |= (s[y][x] - '0' == xd[j] && s[y][x + 1] - '0' == xd[(j + 1) % 4]);\n                }\n                else {\n                    ok |= (s[y][x] - '0' == xd2[j] && s[y][x + 1] - '0' == xd2[(j + 1) % 4]);\n                }\n            }\n            if (ok) {\n                g[y * w + x].push_back(y * w + x + 1);\n                g[y * w + x + 1].push_back(y * w + x);\n            }\n        }\n    }\n    for (int x = 0; x < w; x += 2) {\n        FOR(y, 0, h - 1) {\n            bool ok = false;\n            FOR(j, 0, 4) {\n                if ((x / 2) % 2 == 0) {\n                    ok |= (s[y][x] - '0' == yd[j] && s[y + 1][x] - '0' == yd[(j + 1) % 4]);\n                }\n                else {\n                    ok |= (s[y][x] - '0' == yd2[j] && s[y + 1][x] - '0' == yd2[(j + 1) % 4]);\n                }\n            }\n            if (ok) {\n                g[y * w + x].push_back((y + 1) * w + x);\n                g[(y + 1) * w + x].push_back(y * w + x);\n            }\n        }\n    }\n\n    auto vis = vec<bool>(h * w);\n    vis[0] = true;\n    queue<int> bfs;\n    bfs.push(0);\n    while (!bfs.empty()) {\n        int now = bfs.front();\n        bfs.pop();\n        each(to, g[now]) {\n            if (vis[to])continue;\n            vis[to] = true;\n            bfs.push(to);\n        }\n    }\n\n    cout << (vis[h * w - 1] ? \"YES\" : \"NO\") << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n#define NL <<\"\\n\"\n\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#include \"benri.h\"\n#else\n#define out(args...)\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=1e9+7; //998244353\n\nvector<string> ok\n\t{\"6314\",\n\t \"2!2!\",\n\t \"1364\",\n\t \"5!5!\"};\n\nint dst[112][112];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1,0};\n\nint main(){\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  cout<<fixed<<setprecision(0);\n\tint h,w;\n\tcin>>h>>w;\n\tvector<string> mp(h);\n\trep(i,h) cin>>mp[i];\n\tfill(dst[0],dst[112],MOD);\n\tdst[0][0]=0;\n\tqueue<pii> que; que.emplace(0,0);\n\twhile(que.size()){\n\t\tint x,y;\n\t\ttie(x,y)=que.front(); que.pop();\n\t\trep(d,4){\n\t\t\tint nx=x+dx[d];\n\t\t\tint ny=y+dy[d];\n\t\t\tif(nx<0||ny<0||nx>=w||ny>=h||mp[ny][nx]!=ok[ny%4][nx%4]) continue;\n\t\t\tif(MN(dst[ny][nx],0)) que.emplace(nx,ny);\n\t\t}\n\t}\n\t// rep(i,h){rep(j,w) cout<<!!dst[i][j];cout NL;}\n\tcout<<(dst[h-1][w-1]?\"NO\":\"YES\") NL;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cfloat>\n#include<climits>\n#include<cmath>\n#include<deque>\n#include<functional>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<string>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<vector>\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n\treturn vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\ntemplate<typename T, typename V>\ntypename enable_if<is_class<T>::value == 0>::type\nfill_v(T& t, const V& v) { t = v; }\ntemplate<typename T, typename V>\ntypename enable_if<is_class<T>::value != 0>::type\nfill_v(T& t, const V& v) {\n\tfor (auto& e : t) fill_v(e, v);\n}\n\n\n// aよりもbが大きいならばaをbで更新する\n// (更新されたならばtrueを返す)\ntemplate <typename T>\nbool chmax(T & a, const T & b) {\n\tif (a < b) {\n\t\ta = b;  // aをbで更新\n\t\treturn true;\n\t}\n\treturn false;\n}\n// aよりもbが小さいならばaをbで更新する\n// (更新されたならばtrueを返す)\ntemplate <typename T>\nbool chmin(T & a, const T & b) {\n\tif (a > b) {\n\t\ta = b;  // aをbで更新\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n#define ARRAY_MAX 100005\nconst int INF = 1e9 + 7;\nconst ll MOD = 1e9 + 7;\n\nint dx4[4] = { 1,0,0,-1 };\nint dy4[4] = { 0,1,-1,0 };\n\nint dx2[2] = { 1,0 };\nint dy2[2] = { 0,1 };\n\n/******************************************************************************************/\n\n\nchar mp[105][105];\nint check[105][105];\n\nchar dice[4][4]={{'6' ,'3' ,'1' ,'4'},\n\t\t\t\t{'2' ,'#' ,'2' ,'#'},\n\t\t\t\t{'1' ,'3' ,'6' ,'4'},\n\t\t\t\t{'5' ,'#' ,'5' ,'#'}};\n\nint main() {\n\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(10);\n\n\n\tint h,w;\n\tcin >> h >> w;\n\n\tfor (int i = 0; i < h; i++)\n\t{\n\t\tfor (int j = 0; j < w; j++)\n\t\t{\n\t\t\tcin >> mp[i][j];\n\t\t\tif(mp[i][j]=='#'){\n\t\t\t\tcheck[i][j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(mp[h-1][w-1]=='#'){\n\t\tcout << \"NO\" << endl;\n\t\treturn 0;\n\t}\n\t\n\tqueue<pii> que;\n\n\n\tvector<int> hoge = {0,6,2,3,4,5,1};\n\n\tque.push(pii(0,0));\n\n\twhile(!que.empty()){\n\n\t\tpii now = que.front();\n\t\tque.pop();\n\t\t//cout << \"( \" << now.first << \" , \" << now.second << \")\" << endl;\n\t\tif(check[now.first][now.second])continue;\n\t\tcheck[now.first][now.second]=1;\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tint ny = now.first+dy4[i];\n\t\t\tint nx = now.second+dx4[i];\n\t\t\t//cout << \"a\" << endl;\n\t\t\tif(0 <= nx && nx < w && 0 <= ny && ny < h && mp[ny][nx] != '#' && check[ny][nx] == 0){\n\t\t\t\t//cout << ny << \" \" << nx  << endl;\n\t\t\t\t//cout << mp[nx][nx] << \" \" << dice[ny%4][nx%4] << endl;\n\t\t\t\tif(mp[ny][nx] == dice[ny%4][nx%4]){\n\t\t\t\t\tque.push(pii(ny,nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(check[h-1][w-1]){\n\t\tcout << \"YES\" << endl;\n\t}else{\n\t\tcout << \"NO\" << endl;\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\nll rand_int(ll l, ll r) //[l, r]\n{\n    static mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int maxn=105;\nstring maze[maxn];\nbool vis[maxn][maxn][7][7];\nint h,w;\nbool dfs(int x,int y,int up=1,int ft=2,int bt=6,int bk=5,int lf=4,int rt=3)\n{\n    if(x<0||x>=h||y<0||y>=w) return false;\n    if(vis[x][y][up][ft]||maze[x][y]=='#'||maze[x][y]-'0'!=bt) return false;\n    if(x==h-1&&y==w-1) return true;\n    vis[x][y][up][ft]=1;\n    assert(up+bt==7&&ft+bk==7&&lf+rt==7);\n    bool ret=0;\n    ret|=dfs(x+1,y,bk,up,ft,bt,lf,rt);\n    ret|=dfs(x-1,y,ft,bt,bk,up,lf,rt);\n    ret|=dfs(x,y+1,lf,ft,rt,bk,bt,up);\n    ret|=dfs(x,y-1,rt,ft,lf,bk,up,bt);\n    return ret;\n}\nint main()\n{\n    cin>>h>>w;\n    for(int i=0;i<h;i++) cin>>maze[i];\n    if(dfs(0,0)) cout<<\"YES\\n\";\n    else cout<<\"NO\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "//https://onlinejudge.u-aizu.ac.jp/beta/room.html#KUPC2020Spring/problems/B\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧\n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     @hamayanhamayan0\n　　　　／　　　＼　 　  |　|\n　　　 /　　 /￣￣￣￣/　　|\n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿\n　 　　　＼/＿＿＿＿/　（u　⊃\n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n//              v back\n//          .-------.\n//         /  up   /|\n//        /_______/ |\n// left > |       | | < right\n//        | front | /\n//        |       |/\n//        '-------'\n//            ^ down\nstruct Dice {\n\tint up, down, left, right, front, back;\n\tDice() {}\n\tDice(int up, int down, int left, int right, int front, int back) : up(up), down(down), left(left), right(right), front(front), back(back) {}\n};\nDice rotateToLeft(Dice from) { return Dice(from.right, from.left, from.up, from.down, from.front, from.back); }\nDice rotateToRight(Dice from) { return rotateToLeft(rotateToLeft(rotateToLeft(from))); }\nDice rotateToFront(Dice from) { return Dice(from.back, from.front, from.left, from.right, from.up, from.down); }\nDice rotateToBack(Dice from) { return rotateToFront(rotateToFront(rotateToFront(from))); }\nDice rotateByDxdy(Dice from, int dxdy) {\n\tif (dxdy == 0) return rotateToBack(from);\n\telse if (dxdy == 1) return rotateToRight(from);\n\telse if (dxdy == 2) return rotateToFront(from);\n\telse return rotateToLeft(from);\n}\n\nint H, W;\nstring S[100];\n//---------------------------------------------------------------------------------------------------\nbool vis[100][100][7][7];\nint dx[4] = { 0, 1, 0, -1 }, dy[4] = { -1, 0, 1, 0 };\nDice cache[7][7];\n#define yes \"YES\"\n#define no \"NO\"\nstring solve() {\n\tDice initialDice(1, 6, 4, 3, 2, 5);\n\n\tqueue<pair<int, int>> que;\n\tvis[0][0][initialDice.down][initialDice.right] = true;\n\tcache[initialDice.down][initialDice.right] = initialDice;\n\tque.push({ 0, initialDice.down * 10 + initialDice.right });\n\n\twhile (!que.empty()) {\n\t\tauto q = que.front(); que.pop();\n\n\t\tint x = q.first % 100;\n\t\tint y = q.first / 100;\n\t\tint downValue = q.second / 10;\n\t\tint rightValue = q.second % 10;\n\t\tauto dice = cache[downValue][rightValue];\n\n\t\tif (y == H - 1 && x == W - 1) return yes;\n\n\t\trep(d, 0, 4) {\n\t\t\tint xx = x + dx[d];\n\t\t\tint yy = y + dy[d];\n\t\t\tif (0 <= xx && xx < W && 0 <= yy && yy < H) {\n\t\t\t\tauto dice2 = rotateByDxdy(dice, d);\n\t\t\t\tcache[dice2.down][dice2.right] = dice2;\n\t\t\t\tif (S[yy][xx] - '0' == dice2.down && !vis[yy][xx][dice2.down][dice2.right]) {\n\t\t\t\t\tvis[yy][xx][dice2.down][dice2.right] = true;\n\t\t\t\t\tque.push({ yy * 100 + xx, dice2.down * 10 + dice2.right });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn no;\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n\tcin >> H >> W;\n\trep(y, 0, H) cin >> S[y];\n\tcout << solve() << endl;\n}\n\n\n\n\n\n/* ///////////////////////// writeup1 start\n///////////////////////// writeup2 start\n到達可能性といえばBFS。BFSだろうなぁと思って考えていくと解ける。\n状態は(x座標, y座標, サイコロの下の面の数字, サイコロの右の面の数字)で表現する。\n遷移は4方向なので、BFSしても間に合う。\n\nサイコロについては、真面目にサイコロクラスを作ってBFSをした。満足。\n…と思ったらMLE！\n泣く泣く、queueに突っ込むのはサイコロの数字だけにして、\nサイコロクラスのインスタンスはキャッシュに突っ込んで使いまわしたらAC。\n///////////////////////// writeup2 end */\n//　\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint     = long long;\nconst lint inf = 1LL << 60;\nconst lint mod = 1000000007;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int h, w;\n    cin >> h >> w;\n    vector<string> s(h);\n    for (int i = 0; i < h; ++i) {\n        cin >> s[i];\n    }\n    vector<vector<vector<vector<vector<int>>>>> visited(\n        h, vector<vector<vector<vector<int>>>>(\n               w, vector<vector<vector<int>>>(6, vector<vector<int>>(6, vector<int>(6, 0))))); // bottom, right,\n    struct state {\n        int i, j, k, l, m;\n    };\n    queue<state> q;\n    q.push({0, 0, 5, 2, 1});\n    visited[0][0][5][2][1] = 1;\n    while (!q.empty()) {\n        auto c = q.front();\n        q.pop();\n        if (c.i == h - 1 && c.j == w - 1) {\n            cout << \"YES\"\n                 << \"\\n\";\n            return 0;\n        }\n        // up\n        if (c.i != 0) {\n            int nk    = 5 - c.m;\n            int nl    = c.l;\n            int nm    = c.k;\n            state nxt = {c.i - 1, c.j, nk, nl, nm};\n            if (s[c.i - 1][c.j] - '1' == nk)\n                if (visited[nxt.i][nxt.j][nxt.k][nxt.l][nxt.m] == 0) {\n                    visited[nxt.i][nxt.j][nxt.k][nxt.l][nxt.m] = 1;\n                    q.push(nxt);\n                }\n        }\n        // right\n        if (c.j != w - 1) {\n            int nk    = c.l;\n            int nl    = 5 - c.k;\n            int nm    = c.m;\n            state nxt = {c.i, c.j + 1, nk, nl, nm};\n            if (s[c.i][c.j + 1] - '1' == nk)\n                if (visited[nxt.i][nxt.j][nxt.k][nxt.l][nxt.m] == 0) {\n                    visited[nxt.i][nxt.j][nxt.k][nxt.l][nxt.m] = 1;\n                    q.push(nxt);\n                }\n        }\n        // left\n        if (c.j != 0) {\n            int nk    = 5 - c.l;\n            int nl    = c.k;\n            int nm    = c.m;\n            state nxt = {c.i, c.j - 1, nk, nl, nm};\n            if (s[c.i][c.j - 1] - '1' == nk)\n                if (visited[nxt.i][nxt.j][nxt.k][nxt.l][nxt.m] == 0) {\n                    visited[nxt.i][nxt.j][nxt.k][nxt.l][nxt.m] = 1;\n                    q.push(nxt);\n                }\n        }\n        // down\n        if (c.i != h - 1) {\n            int nk    = c.m;\n            int nl    = c.l;\n            int nm    = 5 - c.k;\n            state nxt = {c.i + 1, c.j, nk, nl, nm};\n            if (s[c.i + 1][c.j] - '1' == nk)\n                if (visited[nxt.i][nxt.j][nxt.k][nxt.l][nxt.m] == 0) {\n                    visited[nxt.i][nxt.j][nxt.k][nxt.l][nxt.m] = 1;\n                    q.push(nxt);\n                }\n        }\n    }\n    cout << \"NO\"\n         << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (n);i++)\n#define sz(x) int(x.size())\ntypedef long long ll;\ntypedef pair<int,int> P;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nstruct dice {\n  int front, bottom, top;\n  int d[4];\n\n  void init(){\n    top = 1;\n    front = 2;\n    bottom = 6;\n    d[0] = front;\n    d[1] = 3;\n    d[2] = 5;\n    d[3] = 4;\n  }\n\n  void roll(int id) {\n    int tmp_t, tmp_b;\n    if (id == 0) {\n      tmp_t = d[2];\n      tmp_b = d[0];\n      d[0] = top;\n      d[2] = bottom;\n      top = tmp_t;\n      bottom = tmp_b;\n    } \n    if (id == 1) {\n      tmp_t = d[3];\n      tmp_b = d[1];\n      d[1] = top;\n      d[3] = bottom;\n      top = tmp_t;\n      bottom = tmp_b;\n    }\n    if (id == 2) {\n      tmp_t = d[0];\n      tmp_b = d[2];\n      d[0] = bottom;\n      d[2] = top;\n      top = tmp_t;\n      bottom = tmp_b;\n    }\n    if (id == 3) {\n      tmp_t = d[1];\n      tmp_b = d[3];\n      d[1] = bottom;\n      d[3] = top;\n      top = tmp_t;\n      bottom = tmp_b;\n    }\n  }\n\n};\n\nint main(){\n  int h, w;\n  cin >> h >> w;\n  vector<string> s(h);\n  rep(i,h) cin >> s[i];\n  \n  dice now;\n  now.init();\n  vector<vector<int>> ok(h, vector<int>(w,0));\n  \n  queue<pair<dice, P>> que;\n\n  que.push(make_pair(now,make_pair(0, 0)));\n  ok[0][0] = 1;\n\n  while (!que.empty()) {\n    auto p = que.front(); que.pop();\n    \n    for (int i = 0; i < 4; i++) {\n      int x = p.second.first + dx[i], y = p.second.second + dy[i];\n      if (x < 0 || y < 0 || x >= h || y >= w) continue;\n      if (s[x][y] == '#') continue;\n      auto tmp = p.first;\n      tmp.roll(i);\n      if (tmp.bottom != s[x][y] - '0') continue;\n      if (ok[x][y]) continue;\n      que.push(make_pair(tmp, make_pair(x, y)));\n      ok[x][y] = 1;\n    }\n  }\n  cout << (ok[h-1][w-1] ? \"YES\" : \"NO\") << endl;\n  return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<utility>\n\nusing namespace std;\n\n#define int long long\n#define endl \"\\n\"\n\nconstexpr long long INF = (long long)1e18;\nconstexpr long long MOD = 1'000'000'007; \n\nstruct fast_io {\n\tfast_io(){\n\t\tstd::cin.tie(nullptr);\n\t\tstd::ios::sync_with_stdio(false);\n\t};\n// } fio;\n} ;\n\nclass union_find\n{\n\tint  _setnum;\n\tvector<int> par, nume;\npublic:\n\tunion_find(){\n\t}\n\t\n\tunion_find(int x){\n\t\tpar.resize(x);\n\t\tnume.resize(x);\n\t\tinit();\n\t}\n\t\n\t~union_find(){\n\t\t//\n\t\t\n\t}\n\t\n\tvoid clear(){\n\t\t_setnum = 0;\n\t\tpar.clear();\n\t\tnume.clear();\n\t}\n\t\n\tvoid init(){\n\t\t_setnum = par.size();\n\t\tfor(int i = 0; i < par.size(); i++){\n\t\t\tpar[i] = i;\n\t\t\tnume[i] = 1;\n\t\t}\n\t}\n\t\n\tvoid resize(int x){\n\t\t\n\t\tpar.resize(x);\n\t\tnume.resize(x);\n\t\tinit();\n\t}\n\n\tint find(int x){\n\t\treturn par[x] == x ? x : par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\n\t\tif(x == y)return;\n\t\t\n\t\t_setnum--;\n\t\t\n\t\tif(nume[x] > nume[y]) std::swap(x,y);\n\t\t\n\t\tpar[x] = y;\n\t\tnume[y] += nume[x];\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tint numel(int x){\n\t\treturn nume[find(x)];\n\t}\n\t\n\tint size(){\n\t\treturn par.size();\n\t}\n\t\n\tint setnum(){\n\t\treturn _setnum;\n\t}\n};\n\nsigned main(){\n\tcout<<fixed<<setprecision(10);\n\t\n\tint H, W;\n\tvector<string> s;\n\tvector<vector<int>> num;\n\tunion_find uf;\n\t\n\tcin>>H>>W;\n\t\n\tuf.resize(H * W);\n\ts.resize(H);\n\t// num.resize(H + 100, vector<int>(W + 100));\n\tnum.resize(200, vector<int>(200));\n\t\n\tfor(int i = 0; i < H; i++){\n\t\tcin>>s[i];\n\t}\n\t\n\tfor(int i = 0; i + 5 < num.size(); i += 4){//cout<<i<<endl;\n\t\tfor(int j = 0; j + 5 < num[0].size(); j += 4){ \n\t\t\tnum[i][j] = 6;\n\t\t\tnum[i][j+1] = 3;\n\t\t\tnum[i][j+2] = 1;\n\t\t\tnum[i][j+3] = 4;\n\t\t\t\n\t\t\tnum[i+1][j] = 2;\n\t\t\tnum[i+1][j+1] = 2;\n\t\t\tnum[i+1][j+2] = 2;\n\t\t\tnum[i+1][j+3] = 2;\n\t\t\t\n\t\t\tnum[i+2][j] = 1;\n\t\t\tnum[i+2][j+1] = 3;\n\t\t\tnum[i+2][j+2] = 6;\n\t\t\tnum[i+2][j+3] = 4;\n\t\t\t\n\t\t\tnum[i+3][j] = 5;\n\t\t\tnum[i+3][j+1] = 5;\n\t\t\tnum[i+3][j+2] = 5;\n\t\t\tnum[i+3][j+3] = 5;\n\t\t}\n\t}\n\t\n\t\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){ //cout<<num[i][j];\n\t\t\tif(s[i][j] == '#') continue;\n\t\t\tif(num[i][j] != s[i][j] - '0') continue;\n\t\t\t\n\t\t\tif(i && s[i-1][j] != '#' && num[i-1][j] == s[i-1][j] - '0') {\n\t\t\t\tuf.unite(i * W + j, (i - 1) * W + j);\n\t\t\t}\n\t\t\tif(j  && s[i][j-1] != '#' && num[i][j-1] == s[i][j-1] - '0') {\n\t\t\t\tuf.unite(i * W + j, i * W + j - 1);\n\t\t\t}\n\t\t}//cout<<endl;\n\t}\n\t\n\tif(uf.same(0, (H-1) * W + W-1)) cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconstexpr int inf=1e9+7;\nconstexpr ll longinf=1LL<<60 ;\nconstexpr ll mod=1e9+7 ;\n\n\nint dp[111][111];\n\n\nstruct UnionFind{\n   vector<int> par;\n   UnionFind(int n):par(n,-1){}\n   int find(int x){\n       if(par[x]<0)return x;\n       return par[x]=find(par[x]);\n   }\n   bool unite(int x,int y){\n       x=find(x);\n       y=find(y);\n       if(x==y)return false;\n       if(par[x]>par[y]){\n           par[y]+=par[x];\n           par[x]=y;\n       }\n       else{\n           par[x]+=par[y];\n           par[y]=x;\n       }\n       return true;\n   }\n\n   bool same(int x,int y){\n       return find(x)==find(y);\n   }\n   int size(int x){\n       return -par[find(x)];\n   }\n};\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int h,w;\n    cin>>h>>w;\n    string s[h];\n    rep(i,h)cin>>s[i];\n    rep(i,h)rep(j,w){\n        if(i%2==0 && j%2 ==0){\n            if((i-j)%4==0 && s[i][j]!='6')s[i][j]='#';\n            if((i-j)%4!=0 && s[i][j]!='1')s[i][j]='#';\n        }\n        if(i%2==0 && j%2 != 0){\n            if(j%4 == 1 && s[i][j]!='3')s[i][j]='#';\n            if(j%4 == 3 && s[i][j]!='4')s[i][j]='#';\n        }\n        if(i%2==1 && j%2 == 0){\n            if(i%4 == 1 && s[i][j]!='2')s[i][j]='#';\n            if(i%4 == 3 && s[i][j]!='5')s[i][j]='#';\n        }\n    }\n    UnionFind uf(h*w);\n    rep(i,h)rep(j,w-1){\n        if(s[i][j]!='#'&&s[i][j+1]!='#')uf.unite(i*w+j,i*w+j+1);\n    }\n    rep(i,h-1)rep(j,w){\n        if(s[i][j]!='#'&&s[i+1][j]!='#')uf.unite(i*w+j,i*w+j+w);\n    }\n    if(uf.same(0,h*w-1))cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <string>\n#include <algorithm>\n#define llint long long\n#define inf 1e18\n#define rep(x, s, t) for(llint (x) = (s); (x) < (t); (x)++)\n#define Rep(x, s, t) for(llint (x) = (s); (x) <= (t); (x)++)\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nllint h, w;\nchar c[105][105];\nbool used[105][105];\nint dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n\nvoid bfs()\n{\n\tqueue<P> Q;\n\tQ.push(P(0, 0));\n\tused[0][0] = true;\n\t\n\tint x, y;\n\twhile(Q.size()){\n\t\tx = Q.front().first, y = Q.front().second;\n\t\tQ.pop();\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\tif(c[nx][ny] == '#') continue;\n\t\t\tif(used[nx][ny]) continue;\n\t\t\tQ.push(P(nx, ny));\n\t\t\tused[nx][ny] = true;\n\t\t}\n\t}\n}\n\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> h >> w;\n\tfor(int y = 0; y < h; y++){\n\t\tfor(int x = 0; x < w; x++){\n\t\t\tcin >> c[x][y];\n\t\t}\n\t}\n\t\n\tfor(int y = 0; y < h; y++){\n\t\tfor(int x = 0; x < w; x++){\n\t\t\tif(x%4 == 1){\n\t\t\t\tif(c[x][y] != '3') c[x][y] = '#';\n\t\t\t}\n\t\t\tif(x%4 == 3){\n\t\t\t\tif(c[x][y] != '4') c[x][y] = '#';\n\t\t\t}\n\t\t\tif(y%4 == 1){\n\t\t\t\tif(c[x][y] != '2') c[x][y] = '#';\n\t\t\t}\n\t\t\tif(y%4 == 3){\n\t\t\t\tif(c[x][y] != '5') c[x][y] = '#';\n\t\t\t}\n\t\t\tif(x%2 == 0 && y%2 == 0){\n\t\t\t\tif((x/2+y/2)%2){\n\t\t\t\t\tif(c[x][y] != '1') c[x][y] = '#';\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(c[x][y] != '6') c[x][y] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbfs();\n\t\n\tif(used[w-1][h-1]) cout << \"YES\" << endl;\n\telse cout << \"NO\" << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\nint h, w;\nvector<string> s;\nconst int dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\nvector<vector<bool>> used;\n\nbool dfs(int x, int y, int a, int b, int c, int d, int e, int f) {\n    if (x == h - 1 && y == w - 1) {\n        return true;\n    }\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (nx < h && nx >= 0 && ny < w && ny >= 0 && !used[nx][ny]) {\n            used[nx][ny] = true;\n            if (i == 0) {// 前\n                if (b != s[nx][ny] - '0') {\n                    continue;\n                }\n                else if (dfs(nx, ny, e, a, c, d, f, b)) {\n                    return true;\n                }\n            }\n            else if (i == 1) {// 右\n                if (c != s[nx][ny] - '0') {\n                    continue;\n                }\n                else if (dfs(nx, ny, d, b, a, f, e, c)) {\n                    return true;\n                }\n            }\n            else if (i == 2) {// 後\n                if (e != s[nx][ny] - '0') {\n                    continue;\n                }\n                else if (dfs(nx, ny, b, f, c, d, a, e)) {\n                    return true;\n                }\n            }\n            else {// 左\n                if (d != s[nx][ny] - '0') {\n                    continue;\n                }\n                else if (dfs(nx, ny, c, b, f, a, e, d)) {\n                    return true;\n                }\n            }\n        }\n    }\n    //cout << x << \" \" << y << \" \" << a << \" \" << b << \" \" << c << endl;\n    return false;\n}\n\nint main() {\n    cin >> h >> w;\n    s.resize(h);\n    used.resize(h, vector<bool>(w, false));\n    for (int i = 0; i < h; i++) {\n        cin >> s[i];\n    }\n    used[0][0] = true;\n    if (dfs(0, 0, 1, 2, 3, 4, 5, 6)) {\n        puts(\"YES\");\n    }\n    else {\n        puts(\"NO\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// https://onlinejudge.u-aizu.ac.jp/beta/room.html#KUPC2020Spring/problems/B\n#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n#define REP(i, n) FOR(i, 0, n)\n#define REPR(i, n) for (int i = n - 1; i >= 0; i--)\n#define FOR(i, s, n) for (int i = (s), i##_len = (n); i < i##_len; ++i)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define ALLR(obj) (obj).rbegin(), (obj).rend()\n#define DIV(a, b) ((a - 1) / b + 1)\n\nstruct Dice {\n    // Left, Right, Front, Back, Down, Up\n    int l, r, f, b, d, u;\n    bool operator<(const Dice &rhs) const {\n        return l * 10 + r > rhs.l * 10 + rhs.r;\n    }\n\n    // y軸方向にプラス\n    void RollN() {\n        // ++y;\n        int buff = d;\n        d = b;\n        b = u;\n        u = f;\n        f = buff;\n    }\n\n    // y軸方向にマイナス\n    void RollS() {\n        //  --y;\n        int buff = d;\n        d = f;\n        f = u;\n        u = b;\n        b = buff;\n    }\n\n    // x軸方向にプラス\n    void RollE() {\n        // ++x;\n        int buff = d;\n        d = r;\n        r = u;\n        u = l;\n        l = buff;\n    }\n\n    // x軸方向にマイナス\n    void RollW() {\n        // --x;\n        int buff = d;\n        d = l;\n        l = u;\n        u = r;\n        r = buff;\n    }\n\n    // 90度→方向に回転\n    void RollL() {\n        // ----->\n        int buff = f;\n        f = l;\n        l = b;\n        b = r;\n        r = buff;\n    }\n\n    // 90度←方向に回転\n    void RollR() {\n        // <------\n        int buff = f;\n        f = r;\n        r = b;\n        b = l;\n        l = buff;\n    }\n};\n\nstruct dir {\n    int y, x;\n    Dice dice;\n};\n\nint H, W;\nqueue<dir> q;\nvector<set<Dice>> st;\nvoid qin(int y, int x, Dice d) {\n    if (st[y * W + x].count(d) == 0) {\n        q.push({y, x, d});\n        st[y * W + x].insert(d);\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> H >> W;\n    vector<string> v(H);\n    for (auto &x : v) {\n        cin >> x;\n    }\n    auto dice = Dice();\n    dice.u = 1;\n    dice.f = 2;\n    dice.r = 3;\n    dice.l = 4;\n    dice.b = 5;\n    dice.d = 6;\n\n    st.resize(H * W);\n    // Y座標、X座標\n    q.push({0, 0, dice});\n    while (!q.empty()) {\n        auto t = q.front();\n        q.pop();\n        if (t.y == H - 1 && t.x == W - 1) {\n            cout << \"YES\\n\";\n            return 0;\n        }\n        if (t.y < H - 1) {\n            auto u = t.dice;\n            u.RollS();\n            if (u.d == v[t.y + 1][t.x] - '0') {\n                qin(t.y + 1, t.x, u);\n            }\n        }\n        if (t.y > 0) {\n            auto u = t.dice;\n            u.RollN();\n            if (u.d == v[t.y - 1][t.x] - '0') {\n                qin(t.y - 1, t.x, u);\n            }\n        }\n        if (t.x < W - 1) {\n            auto u = t.dice;\n            u.RollE();\n            if (u.d == v[t.y][t.x + 1] - '0') {\n                qin(t.y, t.x + 1, u);\n            }\n        }\n        if (t.x > 0) {\n            auto u = t.dice;\n            u.RollW();\n            if (u.d == v[t.y][t.x - 1] - '0') {\n                qin(t.y, t.x - 1, u);\n            }\n        }\n    }\n    cout << \"NO\\n\";\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\nさいころ\n\nmapを使っているところは普通のサイコロとかなら配列で大丈夫\nまぁ、せいぜいO(log24)なのでOKか\n\n参考:\nhttp://www.prefield.com/algorithm/misc/dice.html\n参考:\nhttps://onlinejudge.u-aizu.ac.jp/beta/review.html#KUPC2020Spring/4276858\nverify:\nhttps://onlinejudge.u-aizu.ac.jp/beta/room.html#KUPC2020Spring/workspace\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\n//up(上),down(下),front(前),back(後ろ),right(右),left(左)\nenum FACE{UP,DOWN,FRONT,BACK,RIGHT,LEFT};\ntemplate<typename T>\nstruct Dice{\n    T var[6];\n    T& operator[](FACE f){return var[f];}\n\n    void rollR(){roll(UP,LEFT,DOWN,RIGHT);}\n    void rollL(){roll(UP,RIGHT,DOWN,LEFT);}\n    void rollU(){roll(UP,FRONT,DOWN,BACK);}\n    void rollD(){roll(UP,BACK,DOWN,FRONT);}\n    void rollT(){roll(FRONT,RIGHT,BACK,LEFT);}\n    void rollH(){roll(FRONT,LEFT,BACK,RIGHT);}\n    void roll(FACE a,FACE b,FACE c,FACE d){\n        int tmp=var[a];\n        var[a]=var[b];\n        var[b]=var[c];\n        var[c]=var[d];\n        var[d]=tmp;\n    }\n    bool operator==(const Dice &d)const noexcept{\n        for(int i=0;i<6;i++){\n            if(var[i]!=d.var[i]) return false;\n        }\n        return true;\n    }\n\n};\n\ntemplate<typename T>\nstruct allDice{\n    using ptt=pair<T,T>;\n    map<ptt,int> M;\n    vector<Dice<T>> V;\n\n    allDice(Dice<T> d){\n        int cnt=0;\n        V.resize(24);\n        for(int k=0;k<6;(k&1?d.rollR():d.rollD()),k++){\n            for(int i=0;i<4;d.rollT(),i++,cnt++){\n                V[cnt]=d;\n                M[ptt(d[UP],d[FRONT])]=cnt;\n            }\n        }\n    }\n    Dice<T> operator[](int idx){return V[idx];};\n\n    Dice<T> find(T up,T front){return V[ M[ptt(up,front)] ];}\n\n    Dice<T> find(FACE f,T a,FACE g,T b){\n        for(int i=0;i<24;i++){\n            if(V[i][f]==a && V[i][g]==b) return V[i];\n        }\n    }\n\n    int id(Dice<T> &d){return M[ptt(d[UP],d[FRONT])];}\n\n};\n\nsigned main(){\n    int H,W;\n    cin>>H>>W;\n    Dice<int> d;\n    d[UP]=1; d[DOWN]=6; d[RIGHT]=3; d[LEFT]=4; \n    d[FRONT]=2; d[BACK]=5;\n    allDice<int> D(d);\n    queue<tuple<int,int,int>> que;\n    char S[110][110];\n    bool flag[110][110][24];\n    for(int i=0;i<110;i++){\n        for(int j=0;j<110;j++){\n            for(int k=0;k<24;k++){\n                flag[i][j][k]=false;\n            }\n        }\n    }\n    for(int i=1;i<=H;i++){\n        for(int j=1;j<=W;j++) cin>>S[i][j];\n    }\n    que.emplace(1,1,D.id(d));\n    flag[1][1][D.id(d)]=true;\n    while(!que.empty()){\n        int h,w,id;\n        tie(h,w,id)=que.front(); que.pop();\n        auto d=D[id];\n        auto r=d; r.rollR();\n        auto l=d; l.rollL();\n        auto dow=d; dow.rollD();\n        auto u=d; u.rollU();\n        if(r[DOWN]==(int)(S[h][w+1]-'0')){\n            if(!flag[h][w+1][D.id(r)]) que.emplace(h,w+1,D.id(r)),flag[h][w+1][D.id(r)]=true;\n        }\n        if(l[DOWN]==(int)(S[h][w-1]-'0')){\n            if(!flag[h][w-1][D.id(l)]) que.emplace(h,w-1,D.id(l)),flag[h][w-1][D.id(l)]=true;\n        }\n        if(dow[DOWN]==(int)(S[h+1][w]-'0')){\n            if(!flag[h+1][w][D.id(dow)]) que.emplace(h+1,w,D.id(dow)),flag[h+1][w][D.id(dow)]=true;\n        }\n        if(u[DOWN]==(int)(S[h-1][w]-'0')){\n            if(!flag[h-1][w][D.id(u)]) que.emplace(h-1,w,D.id(u)),flag[h-1][w][D.id(u)]=true;\n        }\n        \n    }\n    for(int i=0;i<24;i++){\n        if(flag[H][W][i]){\n            cout<<\"YES\"<<endl;\n            return 0;\n        }\n    }\n    cout<<\"NO\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=105,INF=1<<30;\n\nstruct data{\n    int h;\n    int w;\n    int d;\n    int f;\n    int r;\n};\n\nbool can[MAX][MAX][7][7][7];\nvector<data> G[MAX][MAX][7][7][7];\n\nint S[MAX][MAX];\nint H,W;\n\nvoid DFS(data u,data p){\n    for(data to:G[u.h][u.w][u.d][u.f][u.r]){\n        if(to.h==p.h&&to.w==p.w&&to.d==p.d&&to.f==p.f&&to.r==p.r) continue;\n        \n        if(to.h<0||to.h>=H||to.w<0||to.w>=W) continue;\n        \n        if(to.d!=S[to.h][to.w]) continue;\n        \n        if(can[to.h][to.w][to.d][to.f][to.r]) continue;\n        \n        can[to.h][to.w][to.d][to.f][to.r]=1;\n        DFS(to,u);\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    cin>>H>>W;\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            char c;cin>>c;\n            if(c=='#') S[i][j]=0;\n            else S[i][j]=c-'0';\n        }\n    }\n    \n    can[0][0][6][2][3]=1;\n    \n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            for(int d=1;d<=6;d++){\n                for(int f=1;f<=6;f++){\n                    for(int r=1;r<=6;r++){\n                        if(d==f) continue;\n                        if(d==r) continue;\n                        if(f==r) continue;\n                        \n                        G[i][j][d][f][r].push_back({i+1,j,f,7-d,r});\n                        G[i][j][d][f][r].push_back({i,j+1,r,f,7-d});\n                        G[i][j][d][f][r].push_back({i-1,j,7-f,d,r});\n                        G[i][j][d][f][r].push_back({i,j-1,7-r,f,d});\n                    }\n                }\n            }\n        }\n    }\n    \n    DFS({0,0,6,2,3},{-1,-1,-1,-1,-1});\n    \n    bool ok=false;\n    \n    for(int f=1;f<=6;f++){\n        for(int r=1;r<=6;r++){\n            if(can[H-1][W-1][S[H-1][W-1]][f][r]) ok=true;\n        }\n    }\n    \n    if(ok) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nsigned main(){\n\n  int h,w;\n  cin>>h>>w;\n  vector<string> s(h);\n  for(auto& si:s)cin>>si;\n\n  vector<vector<int>> a(h,vector<int>(w));\n  for(int i=0;i<h;++i)for(int j=0;j<w;++j){\n    if(s[i][j]=='#')continue;\n    a[i][j] = (s[i][j]-'0');\n  }\n\n  struct dice{\n    int sita,ue,migi,hidari,temae,oku;\n    dice(){}\n    dice order(int x){\n      if(x==1){\n        return to_migi();\n      }\n      if(x==4){\n        return to_oku();\n      }\n      if(x==3){\n        return to_hidari();\n      }\n      if(x==2){\n        return to_temae();\n      }\n      return *this;\n    }\n    dice to_migi(){\n      dice nxt = *this;\n      nxt.sita = migi;\n      nxt.ue = hidari;\n      nxt.migi = ue;\n      nxt.hidari = sita;\n      return nxt;\n    }\n    dice to_hidari(){\n      dice nxt = *this;\n      nxt.sita = hidari;\n      nxt.ue = migi;\n      nxt.hidari = ue;\n      nxt.migi = sita;\n      return nxt;\n    }\n    dice to_oku(){\n      dice nxt = *this;\n      nxt.sita = oku;\n      nxt.ue = temae;\n      nxt.temae = sita;\n      nxt.oku = ue;\n      return nxt;\n    }\n    dice to_temae(){\n      dice nxt = *this;\n      nxt.sita = temae;\n      nxt.ue = oku;\n      nxt.temae = ue;\n      nxt.oku = sita;\n      return nxt;\n    }\n    \n  };\n\n  dice d;\n  d.sita = 6;\n  d.ue = 1;\n  d.migi = 3;\n  d.hidari = 4;\n  d.temae = 2;\n  d.oku = 5;\n\n  using T = tuple<int,int,dice>;\n  queue<T> que;\n  que.emplace(0,0,d);\n  vector<vector<int>> visited(h,vector<int>(w,0));\n  constexpr int dx[]={1,0,-1,0,1,1,-1,-1};\n  constexpr int dy[]={0,1,0,-1,1,-1,1,-1};\n  constexpr int dd[]={1,2,3,4};\n  while(!que.empty()){\n    int y,x;\n    dice d;\n    tie(y,x,d) = que.front();\n    que.pop();\n    if(visited[y][x])continue;\n    visited[y][x] = 1;\n    for(int i=0;i<4;++i){\n      int ny = y+dy[i];\n      int nx = x+dx[i];\n      if(ny==h||nx==w||ny==-1||nx==-1)continue;\n      if(s[ny][nx]=='#')continue;\n      dice nxt = d.order(dd[i]);\n      if(nxt.sita==a[ny][nx])que.emplace(ny,nx,nxt);\n    }\n  }\n  cout<<(visited[h-1][w-1]?\"YES\":\"NO\")<<endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MOD 1000000007\n//#define MOD 998244353\n#define INF 1145141919810893364\n//#define INF 810114514\n//#define PI 3.141592653589\ntypedef pair<int,int> PP;\ntypedef long long ll;\n#define int ll\n#define setdouble setprecision\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define OREP(i,n) for(int i=1;i<=(n);++i)\n#define RREP(i,n) for(int i=(n)-1;i>=0;--i)\n#define GOODBYE do { cout << \"0\" << endl; return 0; } while (false)\n#define MM <<\" \"<<\n#define Endl endl\n\nsigned main(void){\n    int H,W;\n    string S[120];\n    cin >> H >> W;\n    REP(i,H){\n        cin >> S[i];\n    }\n    string T[4];\n    T[0]=\"6314\";\n    T[1]=\"2-2-\";\n    T[2]=\"1364\";\n    T[3]=\"5-5-\";\n    \n    int D[120][120]={};\n    REP(i,H){\n        REP(j,W){\n            D[i][j]=0;\n        }\n    }\n    REP(i,H){\n        REP(j,W){\n            if(S[i][j]==T[i%4][j%4]){\n                D[i][j]=1;\n            }\n        }\n    }\n    \n    /*REP(i,H){\n        REP(j,W){\n            cout << D[i][j] ;\n        }cout << endl;\n    }*/\n    \n    int visited[120][120]={};\n    int dx[4]={1,0,-1,0};\n    int dy[4]={0,1,0,-1};\n    queue<pair<int,int>> Q;\n    Q.push({0,0});\n    while(!Q.empty()){\n        pair<int,int> q;\n        q=Q.front();\n        Q.pop();\n        visited[q.first][q.second]=1;\n        if(q.first==W-1 && q.second==H-1){\n            cout << \"YES\" << endl;\n            return 0;\n        }\n        REP(k,4){\n            int x=q.first+dx[k];\n            int y=q.second+dy[k];\n            if(0<=x && x<W && 0<=y && y<H){\n                if(D[y][x]==1 && visited[x][y]==0){\n                    Q.push({x,y});\n                    visited[x][y]=1;\n                }\n            }\n        }\n        \n    }\n    cout << \"NO\" << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (ll i = 0; i < (n); ++i)\n#define rep1(i, n) for (ll i = 1; i <= (n); ++i)\n#define rrep(i, n) for (ll i = (n - 1); i >= 0; --i)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define pb push_back\n#define to_s to_string\n#define len(v) (ll)v.size()\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define print(x) cout << (x) << '\\n'\n#define debug(x) cout << #x << \": \" << (x) << '\\n'\nusing namespace std;\nusing ll = long long;\ntypedef pair<ll, ll> P;\nll MOD = 1e9 + 7;\nll devc(ll x, ll y) { return 1 + (x - 1) / y; }\n\nstruct dice{\n    ll x, y, z;\n};\n\ndice roll(dice d, ll dir){\n    ll x = d.x, y = d.y, z = d.z;\n    if(dir == 0) d.x = y, d.y = 7 - x;\n    if(dir == 1) d.x = z, d.z = 7 - x;\n    if(dir == 2) d.x = 7 - y, d.y = x;\n    if(dir == 3) d.x = 7 - z, d.z = x;\n    return d;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout << fixed << setprecision(20);\n\n    ll H, W;\n    cin >> H >> W;\n    int s[105][105];\n    rep(i, H + 2) rep(j, W + 2) if(i == 0 || j == 0 || i == H + 1 || j == W + 1) s[i][j] = -1;\n\n    rep1(i,H){\n        string S;\n        cin >> S;\n        rep1(j, len(S)){\n            if(S[j - 1] == '#') s[i][j] = -1;\n            else s[i][j] = S[j - 1] - '0';\n        }\n    }\n\n    stack<pair<P,dice>> sk;\n    sk.push({{1, 1},{6,2,3}});\n\n    while(!sk.empty()){\n        ll h = sk.top().first.first, w = sk.top().first.second;\n        dice d = sk.top().second;\n        sk.pop();\n        if(s[h][w] != d.x) continue;\n        if (h == H && w == W){\n            print(\"YES\");\n            return 0;\n        }\n\n        sk.push({{h + 1, w}, roll(d, 0)});\n        sk.push({{h, w + 1}, roll(d, 1)});\n        sk.push({{h - 1, w}, roll(d, 2)});\n        sk.push({{h, w - 1}, roll(d, 3)});\n\n        s[h][w] = -1;\n    }\n\n    print(\"NO\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define p_ary(ary,a,b) do { cout << \"[\"; for (int count = (a);count < (b);++count) cout << ary[count] << ((b)-1 == count ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\ntemplate<typename T1,typename T2>ostream& operator<<(ostream& os,const pair<T1,T2>& a) {os << \"(\" << a.first << \", \" << a.second << \")\";return os;}\n\nconst char newl = '\\n';\nstruct Dice\n{\n  // int x, y;\n  int l, r, f, b, d, u;\n\n  void RollS()\n  {\n    //  --y;\n    int buff = d;\n    d = f;\n    f = u;\n    u = b;\n    b = buff;\n  }\n\n  void RollN()\n  {\n    // ++y;\n    int buff = d;\n    d = b;\n    b = u;\n    u = f;\n    f = buff;\n  }\n\n  void RollL() // ----->\n  {\n    int buff = f;\n    f = l;\n    l = b;\n    b = r;\n    r = buff;\n  }\n\n  void RollR() // <------\n  {\n    int buff = f;\n    f = r;\n    r = b;\n    b = l;\n    l = buff;\n  }\n\n  void RollE() // .o -> o.\n  {\n    // --x;\n    int buff = d;\n    d = l;\n    l = u;\n    u = r;\n    r = buff;\n  }\n\n\n  void RollW() // o. -> .o\n  {\n    //  ++x;\n    int buff = d;\n    d = r;\n    r = u;\n    u = l;\n    l = buff;\n  }\n\n\n  vector< Dice > makeDice()\n  {\n    vector< Dice > ret;\n    for(int i = 0; i < 6; i++) {\n      Dice d(*this);\n      if(i == 1) d.RollN();\n      if(i == 2) d.RollS();\n      if(i == 3) d.RollS(), d.RollS();\n      if(i == 4) d.RollL();\n      if(i == 5) d.RollR();\n      for(int j = 0; j < 4; j++) {\n        ret.emplace_back(d);\n        d.RollE();\n      }\n    }\n    return (ret);\n  }\n};\n\nstruct tapi {\n    int x,y;\n    Dice d;\n    int get() {\n        return d.d+d.f*6+d.r*36;\n    }\n};\n\nint main() {\n    int h,w;\n    cin >> h >> w;\n    string s[100];\n    vector<vector<vector<bool>>> used(220,vector<vector<bool>>(h,vector<bool>(w,false)));\n    queue<tapi> que;\n    for (int i = 0;i < h;++i) cin >> s[i];\n    for (int i = 0;i < h;++i) for (int j = 0;j < w;++j) if (s[i][j] == '6') s[i][j] = '0';\n    que.push(tapi{0,0,Dice{4,3,2,5,0,1}});\n    used[que.front().get()][0][0] = true;\n    while (!que.empty()) {\n        tapi t = que.front();que.pop();\n        if (t.x > 0) {\n            t.d.RollN();\n            t.x--;\n            if (t.d.d == s[t.x][t.y]-'0' && !used[t.get()][t.x][t.y]) {\n                que.push(t);\n                used[t.get()][t.x][t.y] = true;\n            }\n            t.d.RollS();\n            t.x++;\n        }\n        if (t.x < h-1) {\n            t.d.RollS();\n            t.x++;\n            if (t.d.d == s[t.x][t.y]-'0' && !used[t.get()][t.x][t.y]) {\n                que.push(t);\n                used[t.get()][t.x][t.y] = true;\n            }\n            t.d.RollN();\n            t.x--;\n        }\n        if (t.y > 0) {\n            t.d.RollE();\n            t.y--;\n            if (t.d.d == s[t.x][t.y]-'0' && !used[t.get()][t.x][t.y]) {\n                que.push(t);\n                used[t.get()][t.x][t.y] = true;\n            }\n            t.d.RollW();\n            t.y++;\n        }\n        if (t.y < w-1) {\n            t.d.RollW();\n            t.y++;\n            if (t.d.d == s[t.x][t.y]-'0' && !used[t.get()][t.x][t.y]) {\n                que.push(t);\n                used[t.get()][t.x][t.y] = true;\n            }\n            t.d.RollE();\n            t.y--;\n        }\n    }\n    bool ans = false;\n    for (int i = 0;i < 220;++i) if (used[i][h-1][w-1]) ans = true;\n    cout << (ans ? \"YES\" : \"NO\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma warning(disable : 4996)\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<math.h>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<cstring>\n#include<cstdio>\n#include<functional>\n#include<bitset>\n#include<limits.h>\n#include<cassert>\n#include<iterator>\n#include<complex>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<time.h>\n#include<random>\n#include<array>\n\n\nusing namespace std;\n\n#define REP(i, n) for(int i = 0;i < n;++i)\n#define REPR(i, n) for(int i = n-1;i >= 0;--i)\n#define FOR(i, m, n) for(int i = m;i < n;++i)\n#define FORR(i, m, n) for(int i = m-1;i >= n;--i)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define REVERSE(v,n) reverse(v,v+n);\n#define VREVERSE(v) reverse(v.begin(), v.end())\n#define ll long long\n#define print(x) cout<<(x)<<'\\n'\n#define pe(x) cout<<(x)<<\" \"\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define lb(v,n) lower_bound(v.begin(), v.end(), (n))\n#define ub(v,n) upper_bound(v.begin(), v.end(), (n))\n#define int long long\n//#define double long double\n#define all(x) (x).begin(), (x).end()\n#define print_space(v) REP(i,v.size())cout << v[i] << ((i == v.size() - 1) ? \"\\n\" : \" \")\ntemplate<typename T1, typename T2> inline void chmin(T1 & a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1& a, T2 b) { if (a < b) a = b; }\ntypedef pair<int, int>P;\ntypedef array<int, 3> arr3;\nstd::random_device rd;\nstd::mt19937 mt(rd());\nconstexpr int MOD = 1e9 + 7; constexpr int MAX = 200020;\nconst double pi = acos(-1); constexpr double EPS = 1e-8;\nconstexpr ll INF = 1e18;\nbool can[101][101][7][7][7];\n\nchar A[101][101];\nint H, W;\n\nbool vis[101][101][7][7][7];\nvoid solve() {\n\tcin >> H >> W;\n\tREP(i, H) {\n\t\tREP(j, W) {\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\tqueue<array<int,5>>que;\n\tque.push({ 0,0,6,2,3 });\n\tvis[0][0][6][2][3] = true;\n\twhile (!que.empty()) {\n\t\tarray<int, 5>a = que.front();\n\t\tque.pop();\n\t\tint x = a[0];\n\t\tint y = a[1];\n\t\tint B = a[2];\n\t\tint D = a[3];\n\t\tint R = a[4];\n\t\tint T = 7 - B;\n\t\tint U = 7 - D;\n\t\tint L = 7 - R;\n\t\tvis[x][y][B][D][R] = true;\n\t\t//D\n\t\tif (x == H - 1 && y == W - 1) {\n\t\t\tprint(\"YES\"); exit(0);\n\t\t}\n\t\tif (x + 1 < H) {\n\t\t\tif (D == A[x + 1][y] - '0' && !vis[x + 1][y][D][T][R]) {\n\t\t\t\tvis[x + 1][y][D][T][R] = true;\n\t\t\t\tque.push({ x + 1,y,D,T,R });\n\t\t\t}\n\t\t}\n\t\tif (x - 1 >= 0) {\n\t\t\tif (U == A[x - 1][y] - '0' && !vis[x - 1][y][U][B][R]) {\n\t\t\t\tvis[x - 1][y][U][B][R] = true;\n\t\t\t\tque.push({ x - 1,y,U,B,R });\n\t\t\t}\n\t\t}\n\t\tif (y + 1 < W) {\n\t\t\tif (R == A[x][y + 1] - '0' && !vis[x][y + 1][R][D][T]) {\n\t\t\t\tvis[x][y + 1][R][D][T] = true;\n\t\t\t\tque.push({ x,y + 1,R,D,T });\n\t\t\t}\n\t\t}\n\t\tif (y - 1 >= 0) {\n\t\t\tif (L == A[x][y - 1] - '0' && !vis[x][y - 1][L][D][B]) {\n\t\t\t\tvis[x][y - 1][L][D][B] = true;\n\t\t\t\tque.push({ x,y - 1,L,D,B });\n\t\t\t}\n\t\t}\n\t}\n\tprint(\"NO\");\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t//int q; cin >> q;\n\t//while (q--)\n\tsolve();\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nbool debug = false;\nint main(){\n  int H, W;\n  cin >> H >> W;\n  vector<vector<char>> s(H, vector<char>(W));\n  for (int i = 0; i < H; i++){\n    for (int j = 0; j < W; j++){\n      cin >> s[i][j];\n    }\n  }\n  vector<vector<bool>> M(H + 2, vector<bool>(W + 2, 0));\n  for (int i = 0; i < H; i++){\n    for (int j = 0; j < W; j++){\n      if (i % 4 == 0 && j % 4 == 0 && s[i][j] == '6'){\n        M[i + 1][j + 1] = true;\n      }\n      if (i % 4 == 2 && j % 4 == 2 && s[i][j] == '6'){\n        M[i + 1][j + 1] = true;\n      }\n      if (i % 4 == 0 && j % 4 == 2 && s[i][j] == '1'){\n        M[i + 1][j + 1] = true;\n      }\n      if (i % 4 == 2 && j % 4 == 0 && s[i][j] == '1'){\n        M[i + 1][j + 1] = true;\n      }\n      if (i % 4 == 1 && j % 2 == 0 && s[i][j] == '2'){\n        M[i + 1][j + 1] = true;\n      }\n      if (i % 4 == 3 && j % 2 == 0 && s[i][j] == '5'){\n        M[i + 1][j + 1] = true;\n      }\n      if (i % 2 == 0 && j % 4 == 1 && s[i][j] == '3'){\n        M[i + 1][j + 1] = true;\n      }\n      if (i % 2 == 0 && j % 4 == 3 && s[i][j] == '4'){\n        M[i + 1][j + 1] = true;\n      }\n    }\n  }\n  if (debug){\n    for (int i = 0; i < H + 2; i++){\n      for (int j = 0; j < W + 2; j++){\n        cout << M[i][j];\n      }\n      cout << endl;\n    }\n  }\n  queue<pair<int, int>> Q;\n  Q.push(make_pair(1, 1));\n  vector<vector<bool>> U(H + 2, vector<bool>(W + 2, false));\n  U[1][1] = true;\n  while (!Q.empty()){\n    int y = Q.front().first;\n    int x = Q.front().second;\n    if (debug){\n      cout << \"y=\" << y <<\",x=\" << x << endl;\n    }\n    Q.pop();\n    if (M[y + 1][x] && !U[y + 1][x]){\n      Q.push(make_pair(y + 1, x));\n      U[y + 1][x] = true;\n    }\n    if (M[y - 1][x] && !U[y - 1][x]){\n      Q.push(make_pair(y - 1, x));\n      U[y - 1][x] = true;\n    }\n    if (M[y][x + 1] && !U[y][x + 1]){\n      Q.push(make_pair(y, x + 1));\n      U[y][x + 1] = true;\n    }\n    if (M[y][x - 1] && !U[y][x - 1]){\n      Q.push(make_pair(y, x - 1));\n      U[y][x - 1] = true;\n    }\n  }\n  if (U[H][W]){\n    cout << \"YES\" << endl;\n  } else {\n    cout << \"NO\" << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <numeric>\n#include <random>\n#include <algorithm>\n#include <functional>\n#include <cassert>\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\npair<int,int> operator+(const pair<int,int> &lhs, const pair<int,int> &rhs){\n  pair<int,int> p = { lhs.first + rhs.first, lhs.second + rhs.second };\n  return p;\n}\n\nbool operator==(const pair<int,int> &lhs, const pair<int,int> &rhs){\n  return (lhs.first == rhs.first) && (lhs.second == rhs.second);\n}\n\nconst int INF = (1 << 30) - 1;\nconst ll INFLL= (1LL << 61) - 1;\nconst int MOD = 1000000007;\n#define ALL(a) (a).begin(),(a).end()\n#define rALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nint main(){\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int h,w;\n  cin>>h>>w;\n  vector<vector<int>> field(h,vector<int>(w));\n  REP(i,h){\n    string str;\n    cin>>str;\n    REP(j,w){\n      int num=str[j]-'0';\n      if(i%2==0 && j%2==0){\n        if((i/2+j/2)%2==0){\n          if(num==6)field[i][j]=1;\n        }else{\n          if(num==1)field[i][j]=1;\n        }\n      }\n      if(i%2!=0 && j%2==0){\n        if(i%4==1){\n          if(num==2)field[i][j]=1;\n        }\n        if(i%4==3){\n          if(num==5)field[i][j]=1;\n        }\n      }\n      if(i%2==0 && j%2!=0){\n        if(j%4==1){\n          if(num==3)field[i][j]=1;\n        }\n        if(j%4==3){\n          if(num==4)field[i][j]=1;\n        }\n      }\n    }\n  }\n\n  queue<pair<int,int> > q;\n\n  q.push(make_pair(0,0));\n\n  const pair<int,int> moves[] = {\n    { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 },\n  };\n\n  vector<vector<int>> field2(h,vector<int>(w, -1));\n  field2[0][0]=0;\n\n  while( !q.empty() ) {\n    pair<int,int> cur = q.front(); q.pop();\n    for(auto &move : moves){\n      pair<int,int> next=cur+move;\n      if(next.first<0||next.first>=h||next.second<0||next.second>=w)continue;\n      if(field2[next.first][next.second]==-1 && field[next.first][next.second]==1){\n        field2[next.first][next.second]=field2[cur.first][cur.second]+1;\n        q.push(next);\n      }\n    }\n  }\n  if(field2[h-1][w-1]==-1){\n    cout<<\"NO\"<<endl;\n  }else{\n    cout<<\"YES\"<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nint main(){\n    using namespace std;\n    unsigned long H, W;\n    cin >> H >> W;\n    vector<vector<char>> kanou{{'6', '3', '1', '4'}, {'2', '0', '2', '0'}, {'1', '3', '6', '4'}, {'5', '0', '5', '0'}};\n    vector<vector<unsigned long>> moveable(H + 2, vector<unsigned long>(W + 2));\n    for(unsigned long i{0}; i < H; ++i){\n        string S;\n        cin >> S;\n        for(unsigned long j{0}; j < W; ++j)moveable[i + 1][j + 1] = static_cast<unsigned long>(S[j] == kanou[i & 3][j & 3]);\n    }\n    vector<pair<unsigned long, unsigned long>> tansaku, dist{{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n    tansaku.emplace_back(1, 1);\n    while(!tansaku.empty()){\n        auto t = tansaku.back();\n        tansaku.pop_back();\n        moveable[t.first][t.second] = 0;\n        if(t.first == H && t.second == W)return 0 & puts(\"YES\");\n        for(const auto& d : dist)if(moveable[t.first + d.first][t.second + d.second]){\n            tansaku.emplace_back(t.first + d.first, t.second + d.second);\n            moveable[t.first + d.first][t.second + d.second] = 0;\n        }\n    }\n    return 0 & puts(\"NO\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\n\ntemplate <class T> inline T chmax(T &a, const T b) {return a = (a < b) ? b : a;}\ntemplate <class T> inline T chmin(T &a, const T b) {return a = (a > b) ? b : a;}\n\nconstexpr int MOD = 1e9 + 7;\nconstexpr int inf = 1e9;\nconstexpr long long INF = 1e18;\n\n#define all(a) (a).begin(), (a).end()\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int h, w; cin>>h>>w;\n    vector<string> s(h);\n    for(int i=0; i<h; i++) cin>>s[i];\n\n    vector<vector<char>> base(h, vector<char>(w, '#'));\n    char v0[] = {'6', '3', '1', '4'};\n    char v2[] = {'1', '3', '6', '4'};\n    for(int i=0; i<h; i++){\n        for(int j=0; j<w; j++){\n            if(i % 4 == 0) base[i][j] = v0[j % 4];\n            if(i % 4 == 1) if(j % 2 == 0) base[i][j] = '2';\n            if(i % 4 == 2) base[i][j] = v2[j % 4];\n            if(i % 4 == 3) if(j % 2 == 0) base[i][j] = '5';\n        }\n    }\n\n    queue<P> que;\n    que.emplace(0, 0);\n    vector<vector<bool>> visited(h, vector<bool>(w, false));\n    visited[0][0] = true;\n    \n    while(que.size()){\n        int cy, cx; tie(cy, cx) = que.front(); que.pop();\n\n        if(cy == h - 1 && cx == w - 1){\n            cout << \"YES\" << endl;\n            return 0;\n        }\n\n        for(int i=0; i<4; i++){\n            int ny = cy + dy[i], nx = cx + dx[i];\n        \n            if(!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n            if(s[ny][nx] == '#') continue;\n            if(s[ny][nx] != base[ny][nx]) continue;\n            if(visited[ny][nx]) continue;\n\n            visited[ny][nx] = true;\n            que.emplace(ny, nx);\n        }\n    }\n\n    cout << \"NO\" << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\tint H = sc.nextInt();\n\t\tint W = sc.nextInt();\n\t\tint[][] field = new int[H][W];\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tchar[] row = sc.next().toCharArray();\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (row[j] == '#') {\n\t\t\t\t\tfield[i][j] = -1;\n\t\t\t\t} else {\n\t\t\t\t\tfield[i][j] = row[j] - '1';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tboolean[][][][] visited = new boolean[H][W][6][6];\n\t\tvisited[0][0][1][2] = true;\n\t\tArrayList<Integer> que = new ArrayList<>();\n\t\tque.add(encode(0, 0, 1, 2));\n\t\tfor (int i = 0; i < que.size(); i++) {\n\t\t\tint cur = que.get(i);\n\t\t\tint r = cur >> 24;\n\t\t\tint c = (cur >> 16) & 0xFF;\n\t\t\tint f = (cur >> 8) & 0xFF;\n\t\t\tint s = (cur >> 0) & 0xFF;\n\t\t\tif (r == H - 1 && c == W - 1) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// up\n\t\t\tif (r > 0 && field[r - 1][c] == 5 - f && !visited[r - 1][c][field[r][c]][s]) {\n\t\t\t\tvisited[r - 1][c][field[r][c]][s] = true;\n\t\t\t\tque.add(encode(r - 1, c, field[r][c], s));\n\t\t\t}\n\t\t\t// down\n\t\t\tif (r < H - 1 && field[r + 1][c] == f && !visited[r + 1][c][5 - field[r][c]][s]) {\n\t\t\t\tvisited[r + 1][c][5 - field[r][c]][s] = true;\n\t\t\t\tque.add(encode(r + 1, c, 5 - field[r][c], s));\n\t\t\t}\n\t\t\t// left\n\t\t\tif (c > 0 && field[r][c - 1] == 5 - s && !visited[r][c - 1][f][field[r][c]]) {\n\t\t\t\tvisited[r][c - 1][f][field[r][c]] = true;\n\t\t\t\tque.add(encode(r, c - 1, f, field[r][c]));\n\t\t\t}\n\t\t\t// right\n\t\t\tif (c < W - 1 && field[r][c + 1] == s && !visited[r][c + 1][f][5 - field[r][c]]) {\n\t\t\t\tvisited[r][c + 1][f][5 - field[r][c]] = true;\n\t\t\t\tque.add(encode(r, c + 1, f, 5 - field[r][c]));\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"NO\");\n\t}\n\n\tstatic int encode(int r, int c, int f, int s) {\n\t\treturn (r << 24) | (c << 16) | (f << 8) | s;\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.io.BufferedOutputStream;\nimport java.util.HashSet;\nimport java.nio.charset.Charset;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.io.OutputStreamWriter;\nimport java.io.OutputStream;\nimport java.util.EnumMap;\nimport java.util.Collection;\nimport java.util.Set;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.util.Objects;\nimport java.util.AbstractMap;\nimport java.io.Writer;\nimport java.util.Queue;\nimport java.io.BufferedReader;\nimport java.util.ArrayDeque;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author mikit\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        LightScanner in = new LightScanner(inputStream);\n        LightWriter out = new LightWriter(outputStream);\n        B solver = new B();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class B {\n        private static final Dice.Roll[] ROLLS = {Dice.Roll.FORWARD, Dice.Roll.BACKWARD, Dice.Roll.RIGHT, Dice.Roll.LEFT};\n        private static final int[] DC = {0, 0, 1, -1};\n        private static final int[] DR = {1, -1, 0, 0};\n\n        public void solve(int testNumber, LightScanner in, LightWriter out) {\n            out.setBoolLabel(LightWriter.BoolLabel.YES_NO_ALL_UP);\n            int h = in.ints() + 2, w = in.ints() + 2;\n            char[][] s = new char[h][];\n            s[0] = s[h - 1] = new char[w];\n            Arrays.fill(s[0], '#');\n            for (int i = 1; i < h - 1; i++) s[i] = (\"#\" + in.string() + \"#\").toCharArray();\n            if (h == 3 && w == 3) {\n                out.yesln();\n                return;\n            }\n\n            EnumMap<Dice.Face, Character> map = new EnumMap<>(Dice.Face.class);\n            map.put(Dice.Face.TOP, '1');\n            map.put(Dice.Face.FRONT, '2');\n            map.put(Dice.Face.RIGHT, '3');\n            map.put(Dice.Face.LEFT, '4');\n            map.put(Dice.Face.BACK, '5');\n            map.put(Dice.Face.BOTTOM, '6');\n\n\n            Set<B.State> visited = new HashSet<>();\n            Queue<B.State> q = new ArrayDeque<>();\n            q.offer(new B.State(1, 1, new Dice<>(map)));\n            while (!q.isEmpty()) {\n                B.State now = q.poll();\n                for (int i = 0; i < 4; i++) {\n                    int nr = now.r + DR[i], nc = now.c + DC[i];\n                    Dice<Character> roll = new Dice<>(now.roll);\n                    roll.apply(ROLLS[i]);\n                    if (s[nr][nc] != roll.get(Dice.Face.BOTTOM)) continue;\n                    if (nr == h - 2 && nc == w - 2) {\n                        out.yesln();\n                        return;\n                    }\n                    B.State next = new B.State(nr, nc, roll);\n                    if (!visited.contains(next)) {\n                        visited.add(next);\n                        q.offer(next);\n                    }\n                }\n            }\n            out.noln();\n        }\n\n        private static class State {\n            int r;\n            int c;\n            Dice<Character> roll;\n\n            State(int r, int c, Dice<Character> roll) {\n                this.r = r;\n                this.c = c;\n                this.roll = roll;\n            }\n\n            public boolean equals(Object o) {\n                if (this == o) return true;\n                if (o == null || getClass() != o.getClass()) return false;\n                B.State state = (B.State) o;\n                if (r != state.r) return false;\n                if (c != state.c) return false;\n                return Objects.equals(roll, state.roll);\n            }\n\n            public int hashCode() {\n                int result = r;\n                result = 31 * result + c;\n                result = 31 * result + (roll != null ? roll.hashCode() : 0);\n                return result;\n            }\n\n        }\n\n    }\n\n    static class LightScanner {\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public LightScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public String string() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int ints() {\n            return Integer.parseInt(string());\n        }\n\n    }\n\n    static class Dice<T> {\n        private final EnumMap<Dice.Face, T> map = new EnumMap<>(Dice.Face.class);\n\n        public Dice(Dice<T> init) {\n            map.putAll(init.map);\n        }\n\n        public Dice(Map<Dice.Face, T> init) {\n            map.putAll(init);\n        }\n\n        public T get(Dice.Face face) {\n            return map.get(face);\n        }\n\n        public void apply(Dice.Roll roll) {\n            T tmp = map.get(roll.rot[0]);\n            int n = roll.rot.length;\n            for (int i = 1; i < n; i++) {\n                map.put(roll.rot[i - 1], map.get(roll.rot[i]));\n            }\n            map.put(roll.rot[n - 1], tmp);\n        }\n\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Dice<?> dice = (Dice<?>) o;\n            return Objects.equals(map, dice.map);\n        }\n\n        public int hashCode() {\n            return Objects.hash(map);\n        }\n\n        public String toString() {\n            return map.toString();\n        }\n\n        public enum Face {\n            TOP,\n            BOTTOM,\n            LEFT,\n            RIGHT,\n            FRONT,\n            BACK,\n            ;\n        }\n\n        public enum Roll {\n            FORWARD(Dice.Face.TOP, Dice.Face.BACK, Dice.Face.BOTTOM, Dice.Face.FRONT),\n            BACKWARD(Dice.Face.FRONT, Dice.Face.BOTTOM, Dice.Face.BACK, Dice.Face.TOP),\n            LEFT(Dice.Face.TOP, Dice.Face.RIGHT, Dice.Face.BOTTOM, Dice.Face.LEFT),\n            RIGHT(Dice.Face.LEFT, Dice.Face.BOTTOM, Dice.Face.RIGHT, Dice.Face.TOP),\n            HORIZONTAL_LEFT(Dice.Face.FRONT, Dice.Face.RIGHT, Dice.Face.BACK, Dice.Face.LEFT),\n            HORIZONTAL_RIGHT(Dice.Face.LEFT, Dice.Face.BACK, Dice.Face.RIGHT, Dice.Face.FRONT),\n            ;\n            private final Dice.Face[] rot;\n\n            Roll(Dice.Face... rot) {\n                this.rot = rot;\n            }\n\n        }\n\n    }\n\n    static class LightWriter implements AutoCloseable {\n        private final Writer out;\n        private boolean autoflush = false;\n        private boolean breaked = true;\n        private LightWriter.BoolLabel boolLabel = LightWriter.BoolLabel.YES_NO_FIRST_UP;\n\n        public LightWriter(Writer out) {\n            this.out = out;\n        }\n\n        public LightWriter(OutputStream out) {\n            this(new OutputStreamWriter(new BufferedOutputStream(out), Charset.defaultCharset()));\n        }\n\n        public void setBoolLabel(LightWriter.BoolLabel label) {\n            this.boolLabel = Objects.requireNonNull(label);\n        }\n\n        public LightWriter print(char c) {\n            try {\n                out.write(c);\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter print(String s) {\n            try {\n                out.write(s, 0, s.length());\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter ans(String s) {\n            if (!breaked) {\n                print(' ');\n            }\n            return print(s);\n        }\n\n        public LightWriter ans(boolean b) {\n            return ans(boolLabel.transfer(b));\n        }\n\n        public LightWriter yesln() {\n            return ans(true).ln();\n        }\n\n        public LightWriter noln() {\n            return ans(false).ln();\n        }\n\n        public LightWriter ln() {\n            print(System.lineSeparator());\n            breaked = true;\n            if (autoflush) {\n                try {\n                    out.flush();\n                } catch (IOException ex) {\n                    throw new UncheckedIOException(ex);\n                }\n            }\n            return this;\n        }\n\n        public void close() {\n            try {\n                out.close();\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n        }\n\n        public enum BoolLabel {\n            YES_NO_FIRST_UP(\"Yes\", \"No\"),\n            YES_NO_ALL_UP(\"YES\", \"NO\"),\n            YES_NO_ALL_DOWN(\"yes\", \"no\"),\n            Y_N_ALL_UP(\"Y\", \"N\"),\n            POSSIBLE_IMPOSSIBLE_FIRST_UP(\"Possible\", \"Impossible\"),\n            POSSIBLE_IMPOSSIBLE_ALL_UP(\"POSSIBLE\", \"IMPOSSIBLE\"),\n            POSSIBLE_IMPOSSIBLE_ALL_DOWN(\"possible\", \"impossible\"),\n            FIRST_SECOND_FIRST_UP(\"First\", \"Second\"),\n            FIRST_SECOND_ALL_UP(\"FIRST\", \"SECOND\"),\n            FIRST_SECOND_ALL_DOWN(\"first\", \"second\"),\n            ALICE_BOB_FIRST_UP(\"Alice\", \"Bob\"),\n            ALICE_BOB_ALL_UP(\"ALICE\", \"BOB\"),\n            ALICE_BOB_ALL_DOWN(\"alice\", \"bob\"),\n            ;\n            private final String positive;\n            private final String negative;\n\n            BoolLabel(String positive, String negative) {\n                this.positive = positive;\n                this.negative = negative;\n            }\n\n            private String transfer(boolean f) {\n                return f ? positive : negative;\n            }\n\n        }\n\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Runtime.CompilerServices;\nusing System.Text;\nusing System.Diagnostics;\nusing System.Numerics;\nusing static System.Console;\nusing static System.Convert;\nusing static System.Math;\nusing static Template;\nusing Pi = Pair<int, int>;\n\n\nclass Solver\n{\n    int[] rev = new[] { 5, 4, 3, 2, 1, 0 };\n    public void Solve(Scanner sc)\n    {\n        int H, W;\n        sc.Make(out H, out W);\n        var G = sc.Grid(H);\n        var q = new Queue<P>();\n        var use = Create(H, () => new bool[W]);\n        use[0][0] = true;\n        q.Enqueue(new P(0, 0, 5, new[] { 2, 3, 1, 4 }));\n        while (q.Any())\n        {\n            var p = q.Dequeue();\n            for(int i = 0; i < 4; i++)\n            {\n               int h=gh[i]+p.h,w=gw[i]+p.w;\n                if (!Inside(h, w, H, W)) continue;\n                if (G[h][w] == '#' || p.nx[i] != G[h][w] - '1'||use[h][w]) continue;\n                use[h][w] = true;\n                var n = new int[4];\n                n[i ^ 1] = p.id;\n                n[i] = rev[p.id];\n                n[i ^ 3] = p.nx[i ^ 3];\n                n[i ^ 2] = p.nx[i ^ 2];\n                q.Enqueue(new P(h, w, p.nx[i], n));\n            }\n        }\n\n        WriteLine(use[H - 1][W - 1] ? \"YES\" : \"NO\");\n    }\n    struct P { public int h, w, id;public int[] nx; public P(int H,int W,int i,int[] nx) { h = H;w = W;id = i;this.nx = nx; } }\n    int[] gh = new[] { 0, 0, 1, -1 }, gw = new[] { 1, -1, 0, 0 };\n    public static bool Inside(int h, int w, int H, int W)\n        => 0 <= h && h < H && 0 <= w && w < W;\n}\n\n#region Template\npublic static class Template\n{\n    static void Main(string[] args)\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Solver().Solve(new Scanner());\n        Console.Out.Flush();\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) == 1) { a = b; return true; } return false; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) == -1) { a = b; return true; } return false; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void swap<T>(ref T a, ref T b) { var t = b; b = a; a = t; }\n    public static T[] Shuffle<T>(this IList<T> A) { T[] rt = A.ToArray(); Random rnd = new Random(); for (int i = rt.Length - 1; i >= 1; i--) swap(ref rt[i], ref rt[rnd.Next(i + 1)]); return rt; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static T[] Create<T>(int n, Func<T> f) { var rt = new T[n]; for (var i = 0; i < rt.Length; ++i) rt[i] = f(); return rt; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static T[] Create<T>(int n, Func<int, T> f) { var rt = new T[n]; for (var i = 0; i < rt.Length; ++i) rt[i] = f(i); return rt; }\n    public static void Fail<T>(T s) { Console.WriteLine(s); Console.Out.Close(); Environment.Exit(0); }\n}\npublic class Scanner\n{\n    public string Str => Console.ReadLine().Trim();\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public int[] ArrInt => Str.Split(' ').Select(int.Parse).ToArray();\n    public long[] ArrLong => Str.Split(' ').Select(long.Parse).ToArray();\n    public char[][] Grid(int n) => Create(n, () => Str.ToCharArray());\n    public int[] ArrInt1D(int n) => Create(n, () => Int);\n    public long[] ArrLong1D(int n) => Create(n, () => Long);\n    public int[][] ArrInt2D(int n) => Create(n, () => ArrInt);\n    public long[][] ArrLong2D(int n) => Create(n, () => ArrLong);\n    private Queue<string> q = new Queue<string>();\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public T Next<T>() { if (q.Count == 0) foreach (var item in Str.Split(' ')) q.Enqueue(item); return (T)Convert.ChangeType(q.Dequeue(), typeof(T)); }\n    public void Make<T1>(out T1 v1) => v1 = Next<T1>();\n    public void Make<T1, T2>(out T1 v1, out T2 v2) { v1 = Next<T1>(); v2 = Next<T2>(); }\n    public void Make<T1, T2, T3>(out T1 v1, out T2 v2, out T3 v3) { Make(out v1, out v2); v3 = Next<T3>(); }\n    public void Make<T1, T2, T3, T4>(out T1 v1, out T2 v2, out T3 v3, out T4 v4) { Make(out v1, out v2, out v3); v4 = Next<T4>(); }\n    public void Make<T1, T2, T3, T4, T5>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5) { Make(out v1, out v2, out v3, out v4); v5 = Next<T5>(); }\n    public void Make<T1, T2, T3, T4, T5, T6>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5, out T6 v6) { Make(out v1, out v2, out v3, out v4, out v5); v6 = Next<T6>(); }\n    //public (T1, T2) Make<T1, T2>() { Make(out T1 v1, out T2 v2); return (v1, v2); }\n    //public (T1, T2, T3) Make<T1, T2, T3>() { Make(out T1 v1, out T2 v2, out T3 v3); return (v1, v2, v3); }\n    //public (T1, T2, T3, T4) Make<T1, T2, T3, T4>() { Make(out T1 v1, out T2 v2, out T3 v3, out T4 v4); return (v1, v2, v3, v4); }\n}\npublic class Pair<T1, T2> : IComparable<Pair<T1, T2>>\n{\n    public T1 v1;\n    public T2 v2;\n    public Pair() { }\n    public Pair(T1 v1, T2 v2)\n    { this.v1 = v1; this.v2 = v2; }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public int CompareTo(Pair<T1, T2> p)\n    {\n        var c = Comparer<T1>.Default.Compare(v1, p.v1);\n        if (c == 0)\n            c = Comparer<T2>.Default.Compare(v2, p.v2);\n        return c;\n    }\n    public override string ToString() => $\"{v1.ToString()} {v2.ToString()}\";\n    public void Deconstruct(out T1 a, out T2 b) { a = v1; b = v2; }\n}\n\npublic class Pair<T1, T2, T3> : Pair<T1, T2>, IComparable<Pair<T1, T2, T3>>\n{\n    public T3 v3;\n    public Pair() : base() { }\n    public Pair(T1 v1, T2 v2, T3 v3) : base(v1, v2)\n    { this.v3 = v3; }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public int CompareTo(Pair<T1, T2, T3> p)\n    {\n        var c = base.CompareTo(p);\n        if (c == 0)\n            c = Comparer<T3>.Default.Compare(v3, p.v3);\n        return c;\n    }\n    public override string ToString() => $\"{base.ToString()} {v3.ToString()}\";\n    public void Deconstruct(out T1 a, out T2 b, out T3 c) { Deconstruct(out a, out b); c = v3; }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing static System.Math;\n\npublic static class P\n{\n    public static void Main()\n    {\n        var hw = Console.ReadLine().Split().Select(int.Parse).ToArray();\n        var map = Enumerable.Repeat(0, hw[0]).Select(_ => Console.ReadLine().Select(x => x - '0').ToArray()).ToArray();\n        HashSet<int>[][] arrivedStates = Enumerable.Range(0, hw[0]).Select(_ => Enumerable.Range(0, hw[1]).Select(__ => new HashSet<int>()).ToArray()).ToArray();\n        var initDice = new Dice(false);\n        Queue<Tuple<Dice, Tuple<int, int>>> dices = new Queue<Tuple<Dice, Tuple<int, int>>>();\n        dices.Enqueue(new Tuple<Dice, Tuple<int, int>>(initDice, new Tuple<int, int>(0, 0)));\n        arrivedStates[0][0].Add(initDice.Hash);\n        while (dices.Count > 0)\n        {\n            var elem = dices.Dequeue();\n            var dice = elem.Item1;\n            var y = elem.Item2.Item1;\n            var x = elem.Item2.Item2;\n            if (y != 0)\n            {\n                var newDice = dice;\n                newDice.Up();\n                if (!arrivedStates[y - 1][x].Contains(newDice.Hash) && newDice.bottom == map[y - 1][x])\n                {\n                    arrivedStates[y - 1][x].Add(newDice.Hash);\n                    dices.Enqueue(new Tuple<Dice, Tuple<int, int>>(newDice, new Tuple<int, int>(y - 1, x)));\n                }\n            }\n            if (y != hw[0] - 1)\n            {\n                var newDice = dice;\n                newDice.Down();\n                if (!arrivedStates[y + 1][x].Contains(newDice.Hash) && newDice.bottom == map[y + 1][x])\n                {\n                    arrivedStates[y + 1][x].Add(newDice.Hash);\n                    dices.Enqueue(new Tuple<Dice, Tuple<int, int>>(newDice, new Tuple<int, int>(y + 1, x)));\n                }\n            }\n            if (x != 0)\n            {\n                var newDice = dice;\n                newDice.Left();\n                if (!arrivedStates[y][x - 1].Contains(newDice.Hash) && newDice.bottom == map[y][x - 1])\n                {\n                    arrivedStates[y][x - 1].Add(newDice.Hash);\n                    dices.Enqueue(new Tuple<Dice, Tuple<int, int>>(newDice, new Tuple<int, int>(y, x - 1)));\n                }\n            }\n            if (x != hw[1] - 1)\n            {\n                var newDice = dice;\n                newDice.Right();\n                if (!arrivedStates[y][x + 1].Contains(newDice.Hash) && newDice.bottom == map[y][x + 1])\n                {\n                    arrivedStates[y][x + 1].Add(newDice.Hash);\n                    dices.Enqueue(new Tuple<Dice, Tuple<int, int>>(newDice, new Tuple<int, int>(y, x + 1)));\n                }\n            }\n        }\n\n        Console.WriteLine(arrivedStates[hw[0] - 1][hw[1] - 1].Count != 0 ? \"YES\" : \"NO\");\n    }\n}\n\nstruct Dice\n{\n    public int top;\n    public int oku;\n    public int right;\n    public int temae;\n    public int left;\n    public int bottom;\n    public int Hash => top * 100000 + oku * 10000 + right * 1000 + temae * 100 + left * 10 + bottom;\n    public Dice(bool b)\n    {\n        top = 1;\n        oku = 5;\n        right = 3;\n        temae = 2;\n        left = 4;\n        bottom = 6;\n    }\n    public void Up()\n    {\n        var temp = top;\n        top = temae;\n        temae = bottom;\n        bottom = oku;\n        oku = temp;\n    }\n    public void Left()\n    {\n        var temp = top;\n        top = right;\n        right = bottom;\n        bottom = left;\n        left = temp;\n    }\n    public void Right()\n    {\n        var temp = top;\n        top = left;\n        left = bottom;\n        bottom = right;\n        right = temp;\n    }\n    public void Down()\n    {\n        var temp = top;\n        top = oku;\n        oku = bottom;\n        bottom = temae;\n        temae = temp;\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Threading;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Diagnostics;\nusing static util;\nusing P = pair<int, int>;\n\nclass Program {\n    static void Main(string[] args) {\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        var solver = new Solver(sw);\n        // var t = new Thread(solver.solve, 1 << 26); // 64 MB\n        // t.Start();\n        // t.Join();\n        solver.solve();\n        sw.Flush();\n    }\n}\n\nclass Solver {\n    StreamWriter sw;\n    Scan sc;\n    void Prt(string a) => sw.WriteLine(a);\n    void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    void Prt(params object[] a) => Prt(string.Join(\" \", a));\n    public Solver(StreamWriter sw) {\n        this.sw = sw;\n        this.sc = new Scan();\n    }\n\n    public void solve() {\n        int h, w;\n        sc.Multi(out h, out w);\n        var s = new string[h];\n        for (int i = 0; i < h; i++)\n        {\n            s[i] = sc.Str;\n        }\n        var vis = new bool[h][];\n        for (int i = 0; i < h; i++)\n        {\n            vis[i] = new bool[w];\n        }\n        var q = new Queue<int[]>();\n        q.Enqueue(new int[]{ 0, 0, 1, 2, 3 });\n        vis[0][0] = true;\n        while (q.Any()) {\n            var p = q.Dequeue();\n            int pi = p[0], pj = p[1];\n            int a = p[2], b = p[3], c = p[4];\n            if (pi + 1 < h && !vis[pi + 1][pj] && s[pi + 1][pj] == b + '0') {\n                vis[pi + 1][pj] = true;\n                q.Enqueue(new int[]{ pi + 1, pj, 7 - b, a, c });\n            }\n            if (pi - 1 >= 0 && !vis[pi - 1][pj] && s[pi - 1][pj] == 7 - b + '0') {\n                vis[pi - 1][pj] = true;\n                q.Enqueue(new int[]{ pi - 1, pj, b, 7 - a, c });\n            }\n            if (pj + 1 < w && !vis[pi][pj + 1] && s[pi][pj + 1] == c + '0') {\n                vis[pi][pj + 1] = true;\n                q.Enqueue(new int[]{ pi, pj + 1, 7 - c, b, a });\n            }\n            if (pj - 1 >= 0 && !vis[pi][pj - 1] && s[pi][pj - 1] == 7 - c + '0') {\n                vis[pi][pj - 1] = true;\n                q.Enqueue(new int[]{ pi, pj - 1, c, b, 7 - a });\n            }\n        }\n        Prt(vis[h - 1][w - 1] ? \"YES\" : \"NO\");\n\n    }\n}\n\nclass pair<T, U> : IComparable<pair<T, U>> {\n    public T v1;\n    public U v2;\n    public pair() : this(default(T), default(U)) {}\n    public pair(T v1, U v2) { this.v1 = v1; this.v2 = v2; }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) { a = v1; b = v2; }\n}\nstatic class util {\n    public static readonly int M = 1000000007;\n    // public static readonly int M = 998244353;\n    public static readonly long LM = 1L << 60;\n    public static readonly double eps = 1e-11;\n    public static void DBG(string a) => Console.Error.WriteLine(a);\n    public static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    public static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    public static void Assert(params bool[] conds) {\n        foreach (var cond in conds) if (!cond) throw new Exception();\n    }\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static int CompareList<T>(IList<T> a, IList<T> b) where T : IComparable<T> {\n        for (int i = 0; i < a.Count && i < b.Count; i++)\n            if (a[i].CompareTo(b[i]) != 0) return a[i].CompareTo(b[i]);\n        return a.Count.CompareTo(b.Count);\n    }\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    static readonly int[] dd = { 0, 1, 0, -1 };\n    // static readonly string dstring = \"RDLU\";\n    public static P[] adjacents(int i, int j)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1])).ToArray();\n    public static P[] adjacents(int i, int j, int h, int w)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1]))\n                                         .Where(p => inside(p.v1, p.v2, h, w)).ToArray();\n    public static P[] adjacents(this P p) => adjacents(p.v1, p.v2);\n    public static P[] adjacents(this P p, int h, int w) => adjacents(p.v1, p.v2, h, w);\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static T[] inv<T>(this Dictionary<T, int> dic) {\n        var res = new T[dic.Count];\n        foreach (var item in dic) res[item.Value] = item.Key;\n        return res;\n    }\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a) {\n        a = v[0];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b) {\n        a = v[0]; b = v[1];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b, out T c) {\n        a = v[0]; b = v[1]; c = v[2];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b, out T c, out T d) {\n        a = v[0]; b = v[1]; c = v[2]; d = v[3];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b, out T c, out T d, out T e) {\n        a = v[0]; b = v[1]; c = v[2]; d = v[3]; e = v[4];\n    }\n}\n\nclass Scan {\n    StreamReader sr;\n    public Scan() { sr = new StreamReader(Console.OpenStandardInput()); }\n    public Scan(string path) { sr = new StreamReader(path); }\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => sr.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P => Pair<int, int>();\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]);\n    }\n    public void Multi<T, U, V>(out T a, out U b, out V c) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]);\n    }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]);\n    }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]);\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing static System.Math;\nusing Number = System.Int32;\n\nnamespace Program {\n\tpublic class Solver {\n\t\tRandom rnd = new Random();\n\t\tpublic void Solve() {\n\t\t\tvar n = ri;\n\t\t\tvar m = ri;\n\t\t\tvar mat = Enumerate(n, x => rs);\n\t\t\tvar go = Enumerate(4, x => new int[4]);\n\t\t\tgo[0] = new int[] { 6, 3, 1, 4 };\n\t\t\tgo[1] = new int[] { 2, -1, 2, -1 };\n\t\t\tgo[2] = new int[] { 1, 3, 6, 4 };\n\t\t\tgo[3] = new int[] { 5, -1, 5, -1 };\n\t\t\tvar q = new Queue<int>();\n\t\t\tq.Enqueue(0);\n\t\t\tvar ok = new bool[n, m];\n\t\t\tok[0, 0] = true;\n\t\t\twhile (q.Any()) {\n\t\t\t\tvar p = q.Dequeue();\n\t\t\t\tvar x = p / m;\n\t\t\t\tvar y = p % m;\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tvar nx = x + dx[k];\n\t\t\t\t\tvar ny = y + dy[k];\n\t\t\t\t\tif (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;\n\t\t\t\t\tif (mat[nx][ny] == '#') continue;\n\t\t\t\t\tif (mat[nx][ny] - '0' != go[nx % 4][ny % 4]) continue;\n\t\t\t\t\tif (ok[nx, ny]) continue;\n\t\t\t\t\tok[nx, ny] = true;\n\t\t\t\t\tq.Enqueue(nx * m + ny);\n\t\t\t\t\tDebug.WriteLine($\"{x} {y} ->{ nx} {ny}\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok[n - 1, m - 1]) Console.WriteLine(\"YES\");\n\t\t\telse Console.WriteLine(\"NO\");\n\t\t}\n\n\t\tconst long INF = 1L << 60;\n\t\tstatic int[] dx = { -1, 0, 1, 0 };\n\t\tstatic int[] dy = { 0, 1, 0, -1 };\n\t\tint ri { get { return sc.Integer(); } }\n\t\tlong rl { get { return sc.Long(); } }\n\t\tdouble rd { get { return sc.Double(); } }\n\t\tstring rs { get { return sc.Scan(); } }\n\t\tpublic IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n\t\tstatic T[] Enumerate<T>(int n, Func<int, T> f) {\n\t\t\tvar a = new T[n];\n\t\t\tfor (int i = 0; i < a.Length; ++i) a[i] = f(i);\n\t\t\treturn a;\n\t\t}\n\t\tstatic public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\t}\n}\n\n#region main\nstatic class Ex {\n\tstatic public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n\tstatic public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n\t\treturn string.Join(st, ie);\n\t}\n\tstatic public void Main() {\n\t\tConsole.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = true });\n\t\tvar solver = new Program.Solver();\n\t\t//* \n\t\tvar t = new System.Threading.Thread(solver.Solve, 50000000);\n\t\tt.Start();\n\t\tt.Join();\n\t\t//*/\n\t\t// solver.Solve();\n\t\tConsole.Out.Flush();\n\t}\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n\tusing System.IO;\n\tusing System.Text;\n\tusing System.Globalization;\n\n\tpublic class Printer : StreamWriter {\n\t\tpublic override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n\t\tpublic Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n\t}\n\n\tpublic class StreamScanner {\n\t\tpublic StreamScanner(Stream stream) { str = stream; }\n\n\t\tpublic readonly Stream str;\n\t\tprivate readonly byte[] buf = new byte[1024];\n\t\tprivate int len, ptr;\n\t\tpublic bool isEof = false;\n\t\tpublic bool IsEndOfStream { get { return isEof; } }\n\n\t\tprivate byte read() {\n\t\t\tif (isEof) return 0;\n\t\t\tif (ptr >= len) {\n\t\t\t\tptr = 0;\n\t\t\t\tif ((len = str.Read(buf, 0, 1024)) <= 0) {\n\t\t\t\t\tisEof = true;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[ptr++];\n\t\t}\n\n\t\tpublic char Char() {\n\t\t\tbyte b = 0;\n\t\t\tdo b = read(); while ((b < 33 || 126 < b) && !isEof);\n\t\t\treturn (char)b;\n\t\t}\n\t\tpublic string Scan() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic string ScanLine() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n\t\tpublic int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n\t\tpublic double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n\t}\n}\n\n#endregion\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class P\n{\n    public string d { get; set; }\n    public int x { get; set; }\n    public int y { get; set; }\n}\n\npublic class DICE\n{\n    private int[] data;\n    public DICE(string s = \"1,5,6,4,2,3\")\n    {\n        data = new int[6];\n        string[] line = s.Split(',');\n        for (int i = 0; i < 6; i++)\n            data[i] = int.Parse(line[i]);        // 0: ceilling 1: front 2: floor 3:right:4:back:5:left\n    }\n    public void roll(int c)\n    {\n        var w = new int[6];\n        Array.Copy(data, w, 6);\n        if (c == 3) { data[4] = w[0]; data[0] = w[1]; data[1] = w[2]; data[2] = w[4]; }\n        else if (c == 1) { data[1] = w[0]; data[2] = w[1]; data[4] = w[2]; data[0] = w[4]; }\n        else if (c == 0) { data[3] = w[0]; data[5] = w[2]; data[2] = w[3]; data[0] = w[5]; }\n        else { data[5] = w[0]; data[3] = w[2]; data[0] = w[3]; data[2] = w[5]; }\n    }\n    public int peek(int n) => data[n];\n    public string getDice() => string.Join(\",\", data);\n}\n\n\npublic class hello\n{\n    public static void Main()\n    {\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var h = int.Parse(line[0]);\n        var w = int.Parse(line[1]);\n        var map = new int[h, w];\n        for (int i = 0; i < h; i++)\n        {\n            var s = Console.ReadLine().Trim();\n            for (int j = 0; j < w; j++)\n                if (s[j] != '#') map[i, j] = s[j] - '0';\n        }\n        Console.WriteLine(getAns(h, w, map) ? \"YES\" : \"NO\");\n    }\n    static bool getAns(int h, int w, int[,] map)\n    {\n        var dx = new int[] { 0, 1, 0, -1 };\n        var dy = new int[] { 1, 0, -1, 0 };\n        var visited = new bool[h, w];\n        var q = new Queue<P>();\n        q.Enqueue(new P { d = \"1,2,6,3,5,4\", x = 0, y = 0 });\n        visited[0, 0] = true;\n        while (q.Count() > 0)\n        {\n            var t = q.Dequeue();\n            if (t.x == h - 1 && t.y == w - 1) return true;\n            for (int i = 0; i < 4; i++)\n            {\n                var nx = t.x + dx[i];\n                var ny = t.y + dy[i];\n                if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] != 0 && !visited[nx, ny])\n                {\n                    var dice = new DICE(t.d);\n                    dice.roll(i);\n                    if (dice.peek(2) == map[nx, ny])\n                    {\n                        visited[nx, ny] = true;\n                        q.Enqueue(new P { d = dice.getDice(), x = nx, y = ny });\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nvar h, w int\nvar maze [][]byte\n\nvar visited [][]bool\n\ntype dice struct {\n\ttop, bottom, right, left, up, down int\n}\n\nfunc move(d *dice, dir byte) {\n\tnow := d.top\n\tswitch dir {\n\tcase 'N':\n\t\td.top = d.down\n\t\td.down = d.bottom\n\t\td.bottom = d.up\n\t\td.up = now\n\tcase 'S':\n\t\td.top = d.up\n\t\td.up = d.bottom\n\t\td.bottom = d.down\n\t\td.down = now\n\tcase 'W':\n\t\td.top = d.right\n\t\td.right = d.bottom\n\t\td.bottom = d.left\n\t\td.left = now\n\tcase 'E':\n\t\td.top = d.left\n\t\td.left = d.bottom\n\t\td.bottom = d.right\n\t\td.right = now\n\t}\n}\n\nvar dx = [4]int{1, -1, 0, 0}\nvar dy = [4]int{0, 0, 1, -1}\n\nfunc dfs(x, y int, d *dice) bool {\n\t// fmt.Printf(\"dfs(%d,%d) en: dice.bottom=%d\\n\", x, y, d.bottom)\n\tvisited[y][x] = true // (x,y)に到達した\n\tif (y == h-1) && (x == w-1) {\n\t\treturn true\n\t}\n\t// 4方のマス目に進めるかどうかチェック\n\tfor i := 0; i < 4; i++ {\n\t\tnx := x + dx[i]\n\t\tny := y + dy[i]\n\t\tdir := []byte{'E', 'W', 'S', 'N'}\n\t\tdc := *d\n\t\tmove(&dc, dir[i]) // 動かしてみる\n\t\tif 0 <= nx && nx < w && 0 <= ny && ny < h && maze[ny][nx] != '#' && !visited[ny][nx] && dc.bottom == int(maze[ny][nx]-'0') {\n\t\t\t// fmt.Printf(\"move dir %c, new bottom=%d, move to (nx, ny)=(%d,%d)\\n\", dir[i], dc.bottom, nx, ny)\n\t\t\tif dfs(nx, ny, &dc) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t} else {\n\t\t\tcontinue\n\t\t}\n\t}\n\treturn false\n}\n\nfunc main() {\n\tfmt.Scan(&h, &w)\n\tmaze = make([][]byte, h)\n\tvisited = make([][]bool, h)\n\tfor i := 0; i < h; i++ {\n\t\tvisited[i] = make([]bool, w)\n\t\tmaze[i] = make([]byte, w)\n\t\tfmt.Scan(&maze[i])\n\t}\n\t// fmt.Println(\"h\", h, \"w\", w, \"maze\", maze)\n\t// visited[0][0] = true\n\tvar d dice\n\td.bottom = 6\n\td.top = 1\n\td.right = 3\n\td.left = 4\n\td.down = 2\n\td.up = 5\n\tif dfs(0, 0, &d) {\n\t\tfmt.Println(\"YES\")\n\t} else {\n\t\tfmt.Println(\"NO\")\n\t}\n}\n\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations, accumulate\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\nd = [(1,0),(-1,0),(0,1),(0,-1)]\ndef solve():\n    def rotate(dice,d):\n        d1,d2,d3,d4,d5,d6 = dice\n        if d == (0,1):\n            return (d4,d2,d1,d6,d5,d3)\n        elif d == (0,-1):\n            return (d3,d2,d6,d1,d5,d4)\n        elif d == (1,0):\n            return (d5,d1,d3,d4,d6,d2)\n        else:\n            return (d2,d6,d3,d4,d1,d5)\n    h,w = LI()\n    s = [input() for i in range(h)]\n    bfs = [[0 for i in range(w)] for j in range(h)]\n    bfs[0][0] = 1\n    q = deque([(0,0,(1,2,3,4,5,6))])\n    while q:\n        y,x,dice = q.popleft()\n        if y == h-1 and x == w-1:\n            print(\"YES\")\n            return\n        for dy,dx in d:\n            ny,nx = y+dy,x+dx\n            if 0 <= ny < h and 0 <= nx < w:\n                nd = rotate(dice,(dy,dx))\n                if not bfs[ny][nx] and str(nd[-1]) == s[ny][nx]:\n                    bfs[ny][nx] = 1\n                    q.append((ny,nx,nd))\n    print(\"NO\")\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    solve()\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**6)\nfrom collections import deque\n\nh, w = map(int, input().split())\nedge = [[] for _ in range(8 * w * h)]\nfield = []\nfor _ in range(h):\n    line = input().rstrip()\n    field.append(line)\nif field[h-1][w-1] == \"#\":\n    print(\"NO\")\n    exit()\n\ndef get_index(x, y, state):\n    return x * w * 8 + y * 8 + state \n\ndef get_place(index):\n    x = index // (w * 8)\n    index %= (w * 8)\n    y = index // 8\n    index %= 8\n    state = index\n    return x, y, state\n\nif h % 2 == 0 and w % 2 == 0:\n    print(\"NO\")\n    exit()\n# 1: (2,3), (3,5), (5,4), (4,2) \n# 6: (5,3), (3,2), (2,4), (4,5) \nfor x in range(h):\n    for y in range(w):\n        if field[x][y] in \"#16\":\n            continue\n        # Up - Down\n        if x % 2 == 1 and y % 2 == 0 and x + 1 < h:\n            if field[x-1][y] not in \"#2345\" and field[x+1][y] not in \"#2345\" and int(field[x-1][y]) + int(field[x+1][y]) == 7:\n                path = int(field[x][y])\n                # 0 -> 4, 6 -> 2\n                if path == 2:\n                    edge[get_index(x-1, y, 0)].append(get_index(x+1, y, 4))\n                    edge[get_index(x-1, y, 6)].append(get_index(x+1, y, 2))\n                    edge[get_index(x+1, y, 4)].append(get_index(x-1, y, 0))\n                    edge[get_index(x+1, y, 2)].append(get_index(x-1, y, 6))\n                # 1 -> 7, 5 -> 3\n                if path == 3:\n                    edge[get_index(x-1, y, 1)].append(get_index(x+1, y, 7))\n                    edge[get_index(x-1, y, 5)].append(get_index(x+1, y, 3))\n                    edge[get_index(x+1, y, 7)].append(get_index(x-1, y, 1))\n                    edge[get_index(x+1, y, 3)].append(get_index(x-1, y, 5))\n                # 3 -> 5, 7 -> 1\n                if path == 4:\n                    edge[get_index(x-1, y, 3)].append(get_index(x+1, y, 5))\n                    edge[get_index(x-1, y, 7)].append(get_index(x+1, y, 1))\n                    edge[get_index(x+1, y, 5)].append(get_index(x-1, y, 3))\n                    edge[get_index(x+1, y, 1)].append(get_index(x-1, y, 7))\n                # 2 -> 6, 4 -> 0\n                if path == 5:\n                    edge[get_index(x-1, y, 2)].append(get_index(x+1, y, 6))\n                    edge[get_index(x-1, y, 4)].append(get_index(x+1, y, 0))\n                    edge[get_index(x+1, y, 6)].append(get_index(x-1, y, 2))\n                    edge[get_index(x+1, y, 0)].append(get_index(x-1, y, 4))\n        # Right - Left\n        if x % 2 == 0 and y % 2 == 1 and y + 1 < w:\n            if field[x][y-1] not in \"#2345\" and field[x][y+1] not in \"#2345\" and int(field[x][y-1]) + int(field[x][y+1]) == 7:\n                path = int(field[x][y])\n                # 3 -> 7, 5 -> 1\n                if path == 2:\n                    edge[get_index(x, y-1, 3)].append(get_index(x, y+1, 7))\n                    edge[get_index(x, y-1, 5)].append(get_index(x, y+1, 1))\n                    edge[get_index(x, y+1, 7)].append(get_index(x, y-1, 3))\n                    edge[get_index(x, y+1, 1)].append(get_index(x, y-1, 5))\n                # 7 -> 3, 1 -> 5\n                if path == 5:\n                    edge[get_index(x, y-1, 7)].append(get_index(x, y+1, 3))\n                    edge[get_index(x, y-1, 1)].append(get_index(x, y+1, 5))\n                    edge[get_index(x, y+1, 3)].append(get_index(x, y-1, 7))\n                    edge[get_index(x, y+1, 5)].append(get_index(x, y-1, 1))\n                # 0 -> 6, 4 -> 2\n                if path == 3:\n                    edge[get_index(x, y-1, 0)].append(get_index(x, y+1, 6))\n                    edge[get_index(x, y-1, 4)].append(get_index(x, y+1, 2))\n                    edge[get_index(x, y+1, 6)].append(get_index(x, y-1, 0))\n                    edge[get_index(x, y+1, 2)].append(get_index(x, y-1, 4))\n                # 6 -> 0, 2 -> 4\n                if path == 4:\n                    edge[get_index(x, y-1, 6)].append(get_index(x, y+1, 0))\n                    edge[get_index(x, y-1, 2)].append(get_index(x, y+1, 4))\n                    edge[get_index(x, y+1, 0)].append(get_index(x, y-1, 6))\n                    edge[get_index(x, y+1, 4)].append(get_index(x, y-1, 2))\n\nvisited = [False] * (8 * w * h)\ndef dfs(start):\n    visited[start] = True\n    for nv in edge[start]:\n        if not visited[nv]:\n            dfs(nv)\ndfs(0)\n\nif h % 2 == 1 and w % 2 == 1:\n    ok = False\n    for i in range(8):\n        if visited[get_index(h-1, w-1, i)]:\n            ok = True\n    if ok:\n        print(\"YES\")\n        exit()\n    else:\n        print(\"NO\")\nelif h % 2 == 0:\n    if int(field[h-1][w-1]) == 2:\n        if visited[get_index(h-2, w-1, 0)] or visited[get_index(h-2, w-1, 6)]:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    elif int(field[h-1][w-1]) == 3:\n        if visited[get_index(h-2, w-1, 1)] or visited[get_index(h-2, w-1, 5)]:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    elif int(field[h-1][w-1]) == 4:\n        if visited[get_index(h-2, w-1, 3)] or visited[get_index(h-2, w-1, 7)]:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    elif int(field[h-1][w-1]) == 5:\n        if visited[get_index(h-2, w-1, 2)] or visited[get_index(h-2, w-1, 4)]:\n            print(\"YES\")\n        else:\n            print(\"NO\")\nelif w % 2 == 0:\n    if int(field[h-1][w-1]) == 2:\n        if visited[get_index(h-1, w-2, 3)] or visited[get_index(h-1, w-2, 5)]:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    elif int(field[h-1][w-1]) == 3:\n        if visited[get_index(h-1, w-2, 0)] or visited[get_index(h-1, w-2, 4)]:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    elif int(field[h-1][w-1]) == 4:\n        if visited[get_index(h-1, w-2, 2)] or visited[get_index(h-1, w-2, 6)]:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    elif int(field[h-1][w-1]) == 5:\n        if visited[get_index(h-1, w-2, 1)] or visited[get_index(h-1, w-2, 7)]:\n            print(\"YES\")\n        else:\n            print(\"NO\")\nelse:\n    print(\"NO\")\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nh,w = map(int,input().split())\ng = [list(map(int, list(input().replace('#', '0')))) for _ in range(h)]\nf = [[False]*w for _ in range(h)]\nq = deque()\nd = ((0,1), (1,0), (-1,0), (0,-1))\n\ndef chst(c,st,i):\n  if i == 1:\n    nc = st[1]\n    nst = (st[0], 7-c)\n  if i == 0:\n    nc = st[0]\n    nst = (7-c, st[1])\n  if i == 2:\n    nc = 7-st[1]\n    nst = (st[0], c)\n  if i == 3:\n    nc = 7 - st[0]\n    nst = (c, st[1])\n  return nc, nst\n\nq.append((0,0,(2,3)))\nwhile q:\n  y,x,st = q.popleft()\n  if f[y][x]: continue\n  f[y][x] = st\n  for i in range(4):\n    dx, dy = d[i]\n    nx = x + dx; ny = y + dy\n    if 0 <= nx < w and 0 <= ny < h:\n      nc, nst = chst(g[y][x], st, i)\n      if nc == g[ny][nx]:\n        q.append((ny,nx,nst))\nprint('YES' if f[h-1][w-1] else 'NO')\n# print(*f, sep = '\\n')\n"
  },
  {
    "language": "Python",
    "code": "H,W=map(int,input().split())\nMAP=[input() for i in range(H)]\n\nCANGO=[[0]*W for i in range(H)]\nCANGO[0][0]=1\n\nQ=[(0,0)]\n\nwhile Q:\n    x,y=Q.pop()\n\n    for tox,toy in [[x+1,y],[x-1,y],[x,y+1],[x,y-1]]:\n        if 0<=tox<H and 0<=toy<W and CANGO[tox][toy]==0:\n            if tox%4==0:\n                if toy%4==0 and MAP[tox][toy]==\"6\":\n                    CANGO[tox][toy]=1\n                    Q.append((tox,toy))\n                if toy%4==1 and MAP[tox][toy]==\"3\":\n                    CANGO[tox][toy]=1\n                    Q.append((tox,toy))\n                if toy%4==2 and MAP[tox][toy]==\"1\":\n                    CANGO[tox][toy]=1\n                    Q.append((tox,toy))\n                if toy%4==3 and MAP[tox][toy]==\"4\":\n                    CANGO[tox][toy]=1\n                    Q.append((tox,toy))\n            if tox%4==2:\n                if toy%4==0 and MAP[tox][toy]==\"1\":\n                    CANGO[tox][toy]=1\n                    Q.append((tox,toy))\n                if toy%4==1 and MAP[tox][toy]==\"3\":\n                    CANGO[tox][toy]=1\n                    Q.append((tox,toy))\n                if toy%4==2 and MAP[tox][toy]==\"6\":\n                    CANGO[tox][toy]=1\n                    Q.append((tox,toy))\n                if toy%4==3 and MAP[tox][toy]==\"4\":\n                    CANGO[tox][toy]=1\n                    Q.append((tox,toy))\n            if tox%4==1:\n                if toy%4==0 and MAP[tox][toy]==\"2\":\n                    CANGO[tox][toy]=1\n                    Q.append((tox,toy))\n\n                if toy%4==2 and MAP[tox][toy]==\"2\":\n                    CANGO[tox][toy]=1\n                    Q.append((tox,toy))\n            if tox%4==3:\n                if toy%4==0 and MAP[tox][toy]==\"5\":\n                    CANGO[tox][toy]=1\n                    Q.append((tox,toy))\n\n                if toy%4==2 and MAP[tox][toy]==\"5\":\n                    CANGO[tox][toy]=1\n                    Q.append((tox,toy))\n\nif CANGO[H-1][W-1]==1:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(pow(10, 8))\n\nS = [6, 3, 1, 4, 2, 5]\nH, W = map(int, input().split())\nX = []\nfor i in range(H):\n    X.append(input().strip())\n\ndef migi(S):\n    return [S[1], S[2], S[3], S[0], S[4], S[5]]\ndef hidari(S):\n    return [S[3], S[0], S[1], S[2], S[4], S[5]]\ndef sita(S):\n    return [S[4], S[1], S[5], S[3], S[2], S[0]]\ndef ue(S):\n    return [S[5], S[1], S[4], S[3], S[0], S[2]]\n\nvs = set()\n\ndef dfs(x, y, s):\n    if (x, y) == (H-1, W-1):\n        return True\n    vs.add((x, y))\n    f = False\n    if x+1 < H and (x+1, y) not in vs:\n        ns = sita(s)\n        if str(ns[0]) == X[x+1][y]:\n            f = f|dfs(x+1, y, ns)\n    if y+1 < W and (x, y+1) not in vs:\n        ns = migi(s)\n        if str(ns[0]) == X[x][y+1]:\n            f = f|dfs(x, y+1, ns)\n    if x-1 >= 0 and (x-1, y) not in vs:\n        ns = ue(s)\n        if str(ns[0]) == X[x-1][y]:\n            f = f|dfs(x-1, y, ns)\n    if y-1 >= 0 and (x, y-1) not in vs:\n        ns = hidari(s)\n        if str(ns[0]) == X[x][y-1]:\n            f = f|dfs(x, y-1, ns)\n    return f\nif dfs(0, 0, S):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**7)\n\ndice = [[6,3,1,4],\n        [2,0,2,0],\n        [1,3,6,4],\n        [5,0,5,0]]\nH,W = map(int,input().split())\ns = list(input() for _ in range(H))\nboard = [[0]*W for _ in range(H)]\n\ndef dfs(x,y):\n    board[x][y] = 1\n    for dx,dy in [[0,-1],[0,1],[1,0],[-1,0]]:\n        if not(0 <= dx+x < H and 0 <= dy+y < W):\n            continue\n        if(board[x+dx][y+dy] == 1):\n            continue\n\n        if s[x+dx][y+dy] == str(dice[(x+dx)%4][(y+dy)%4]):\n            dfs(dx+x,dy+y)\n\ndfs(0,0)\nprint([\"NO\",\"YES\"][board[-1][-1]])\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**6)\nH, W = map(int, input().split())\nS = [[c for c in input()] for _ in range(H)]\nB = [[False] * W for _ in range(H)]\n\nR = [['6', '3', '1', '4'], ['1', '3', '6', '4']]\nC = [['6', '2', '1', '5'], ['1', '2', '6', '5']]\nG = [['6', '3', '1', '4'], ['2', '-1', '2', '-1'],\n     ['1', '3', '6', '4'], ['5', '-1', '5', '-1']]\n\ndx = [1, -1, 0, 0]\ndy = [0, 0, 1, -1]\n\n\ndef dfs(y, x):\n    if y < 0 or H <= y or x < 0 or W <= x:\n        return\n    if S[y][x] == '#':\n        return\n    if B[y][x] == True:\n        return\n\n    m4y = y % 4\n    m4x = x % 4\n\n    if S[y][x] != G[m4y][m4x]:\n        return\n\n    # R\n    # if y % 2 == 0:\n    #    if not(y % 4 != 0 or y % 4 == 0 and S[y][x] == R[0][x % 4]):\n    #        return\n    #    if not(y % 4 != 2 or y % 4 == 2 and S[y][x] == R[1][x % 4]):\n    #        return\n    # C\n    # if y % 2 == 1:\n    #    if not(y % 4 != 1 or y % 4 == 1 and S[y][x] == '2'):\n    #        return\n    #    if not(y % 4 != 3 or y % 4 == 3 and S[y][x] == '5'):\n    #        return\n\n    B[y][x] = True\n\n    for i in range(4):\n        dfs(y+dy[i], x+dx[i])\n\n\ndfs(0, 0)\n#print(*B, sep='\\n')\nprint('YES' if B[H-1][W-1] else 'NO')\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import *\nfrom collections import deque\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\nclass Dice:\n    def __init__(self,top,bot,lef,rig,fro,bac):\n        self.top = top\n        self.bot = bot\n        self.lef = lef\n        self.rig = rig\n        self.fro = fro\n        self.bac = bac\n\n    def up(self):\n        top, bac, bot, fro = self.fro, self.top, self.bac, self.bot\n        return Dice(top,bot,self.lef,self.rig,fro,bac)\n\n    def down(self):\n        top, bac, bot, fro = self.bac, self.bot, self.fro, self.top\n        return Dice(top,bot,self.lef,self.rig,fro,bac)\n\n    def right(self):\n        top, rig, bot, lef = self.lef, self.top, self.rig, self.bot\n        return Dice(top,bot,lef,rig,self.fro,self.bac)\n\n    def left(self):\n        top, rig, bot, lef = self.rig, self.bot, self.lef, self.top\n        return Dice(top,bot,lef,rig,self.fro,self.bac)\n\n    def state(self):\n        return (self.top, self.rig, self.bot, self.lef, self.fro, self.bac)\n\ndef main():\n    h, w = MI()\n    ss = [[0 if c == \"#\" else int(c) for c in SI()] for _ in range(h)]\n    stack=[(0,0,Dice(1,6,4,3,2,5))]\n    fin=[[set() for _ in range(w)] for _ in range(h)]\n    fin[0][0].add(Dice(1,6,4,3,2,5).state())\n    while stack:\n        i,j,d=stack.pop()\n        if i==h-1 and j==w-1:\n            print(\"YES\")\n            exit()\n        ni,nj=i-1,j\n        if i-1>=0:\n            nd=d.up()\n            if nd.bot==ss[ni][nj] and nd.state() not in fin[ni][nj]:\n                fin[ni][nj].add(nd.state())\n                stack.append((i-1,j,nd))\n        ni,nj=i+1,j\n        if i+1<h:\n            nd=d.down()\n            if nd.bot==ss[ni][nj] and nd.state() not in fin[ni][nj]:\n                fin[ni][nj].add(nd.state())\n                stack.append((i+1,j,nd))\n        ni,nj=i,j-1\n        if j-1>=0:\n            nd=d.left()\n            if nd.bot==ss[ni][nj] and nd.state() not in fin[ni][nj]:\n                fin[ni][nj].add(nd.state())\n                stack.append((i,j-1,nd))\n        ni,nj=i,j+1\n        if j+1<w:\n            nd=d.right()\n            if nd.bot==ss[ni][nj] and nd.state() not in fin[ni][nj]:\n                fin[ni][nj].add(nd.state())\n                stack.append((i,j+1,nd))\n    print(\"NO\")\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "h, w = map(int, input().split())\n\np = list(range(h*w))\n\ndef find(x):\n    global p\n    if p[x] == x:return x\n    p[x] = find(p[x])\n    return p[x]\n\ndef unite(x, y):\n    global p\n    x = find(x)\n    y = find(y)\n    if x != y:p[x] =y\n\ndef real_number(i, j):\n    i += 1\n    j += 1\n    i %= 4\n    j %= 4\n    if i == 1 and j == 1:return 6\n    if i == 1 and j == 2:return 3\n    if i == 1 and j == 3:return 1\n    if i == 1 and j == 0:return 4\n    if i == 2 and j == 1:return 2\n    if i == 2 and j == 3:return 2\n    if i == 3 and j == 1:return 1\n    if i == 3 and j == 2:return 3\n    if i == 3 and j == 3:return 6\n    if i == 3 and j == 0:return 4\n    if i == 0 and j == 1:return 5\n    if i == 0 and j == 3:return 5\n    return -1\n    \nfield = [input() for i in range(h)]\nfor i in range(h):\n    for j in range(w):\n        if str(real_number(i,j)) != field[i][j]:continue\n        if i + 1 < h and str(real_number(i+1,j)) == field[i+1][j]:\n            unite(i*w+j, (i+1)*w+j)\n        if j + 1 < w and str(real_number(i,j+1)) == field[i][j+1]:\n            unite(i*w+j, i*w+j+1)\n\nif find(0) == find(h*w-1):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n    \n        \n"
  },
  {
    "language": "Python",
    "code": "def main():\n    H, W = map( int, input().split())\n    S = [ list( input()) for _ in range(H)]\n    T = [[6,3,1,4], [2,0,2,0],[1,3,6,4],[5,0,5,0]]\n    C = [[0]*W for _ in range(H)]\n    for i in range(H):\n        for j in range(W):\n            if S[i][j] == '#':\n                continue\n            if T[i%4][j%4] == int(S[i][j]):\n                C[i][j] = 1\n    d = [(0,0)]\n    P = [[False]*W for _ in range(H)]\n    P[0][0] = True\n    while d:\n        x, y = d.pop()\n        if x > 0:\n            if C[x-1][y] == 1 and not P[x-1][y]:\n                d.append((x-1,y))\n                P[x-1][y] = True\n        if x < H-1:\n            if C[x+1][y] == 1 and not P[x+1][y]:\n                d.append((x+1,y))\n                P[x+1][y] = True\n        if y > 0:\n            if C[x][y-1] == 1 and not P[x][y-1]:\n                d.append((x,y-1))\n                P[x][y-1] = True\n        if y < W-1:\n            if C[x][y+1] == 1 and not P[x][y+1]:\n                d.append((x,y+1))\n                P[x][y+1] = True\n    if P[H-1][W-1]:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "H,W = map(int,input().split())\nS = [list(input()) for i in range(H)]\n\nA = [[False]*W for i in range(H)]\n\nQ = [(0,0,(5,4,1,3,6,2))]\n\nwhile Q:\n    q = Q.pop()\n    h,w,s = q[0],q[1],q[2]\n    if min(h,w)<0 or h>=H or w>=W:continue\n    if S[h][w]==\"#\":continue\n    if A[h][w]:continue\n    if int(S[h][w])!=s[4]:continue\n    A[h][w] = True\n    Q.append((h-1,w,(s[2],s[1],s[5],s[3],s[0],s[4])))\n    Q.append((h+1,w,(s[4],s[1],s[0],s[3],s[5],s[2])))\n    Q.append((h,w-1,(s[0],s[2],s[3],s[4],s[1],s[5])))\n    Q.append((h,w+1,(s[0],s[4],s[1],s[2],s[3],s[5])))\nprint(\"YES\" if A[H-1][W-1] else \"NO\")\n"
  },
  {
    "language": "Python",
    "code": "H,W = map(int,input().split())\nS = [input() for i in range(H)]\n\ndef tor(x,y):\n    to = {'6':'3','3':'1','1':'4','4':'6'} if y%4==0 else {'6':'4','4':'1','1':'3','3':'6'}\n    return to[S[y][x]]\ndef tol(x,y):\n    to = {'6':'3','3':'1','1':'4','4':'6'} if y%4==2 else {'6':'4','4':'1','1':'3','3':'6'}\n    return to[S[y][x]]\ndef tod(x,y):\n    to = {'6':'2','2':'1','1':'5','5':'6'} if x%4==0 else {'6':'5','5':'1','1':'2','2':'6'}\n    return to[S[y][x]]\ndef tou(x,y):\n    to = {'6':'2','2':'1','1':'5','5':'6'} if x%4==2 else {'6':'5','5':'1','1':'2','2':'6'}\n    return to[S[y][x]]\ndxyto = [(0,1,tod),(1,0,tor),(0,-1,tou),(-1,0,tol)]\nstack = [(0,0)]\nvisited = [[0]*W for i in range(H)]\nwhile stack:\n    x,y = stack.pop()\n    visited[y][x] = 1\n    if (x,y) == (W-1,H-1):\n        print('YES')\n        exit()\n    c = S[y][x]\n    for dx,dy,to in dxyto:\n        nx,ny = x+dx,y+dy\n        if not 0 <= nx < W: continue\n        if not 0 <= ny < H: continue\n        if visited[ny][nx]: continue\n        if S[ny][nx] == '#': continue\n        if to(x,y) != S[ny][nx]: continue\n        stack.append((nx,ny))\nprint('NO')\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\nH, W = map(int, readline().split())\n\nGr = [list(map(lambda x: int(x) if x != '#' else 7, readline().strip())) for _ in range(H)]\n\nRi = []\nfor h in range(H):\n    if h % 4 == 0:\n        Ri.append([6, 3, 1, 4]*W)\n    elif h % 4 == 1:\n        Ri.append([2, 8, 2, 8]*W)\n    elif h % 4 == 2:\n        Ri.append([1, 3, 6, 4]*W)\n    else:\n        Ri.append([5, 8, 5, 8]*W)\n\nfor h in range(H):\n    for w in range(W):\n        if Gr[h][w] != Ri[h][w]:\n            Gr[h][w] = -1\n\nstack = [(0, 0)]\nused = set(stack)\ndim = [(0, -1), (0, 1), (1, 0), (-1, 0)]\nwhile stack:\n    nx, ny = stack.pop()\n    for dx, dy in dim:\n        fx, fy = nx+dx, ny+dy\n        if not 0 <= fx < W or not 0 <= fy < H:\n            continue\n        if Gr[fy][fx] == -1:\n            continue\n        if (fx, fy) in used:\n            continue\n        used.add((fx, fy))\n        stack.append((fx, fy))\nprint('YES' if (W-1, H-1) in used else 'NO')            \n"
  },
  {
    "language": "Rust",
    "code": "//---------- begin union_find ----------\n#[allow(dead_code)]\nmod union_find {\n    pub struct UF {\n        p: Vec<i32>,\n    }\n    impl UF {\n        pub fn new(n: usize) -> UF {\n            UF {p: vec![-1; n] }\n        }\n        pub fn init(&mut self) {\n            for p in self.p.iter_mut() {\n                *p = -1;\n            }\n        }\n        pub fn root(&self, mut x: usize) -> usize {\n            while self.p[x] >= 0 {\n                x = self.p[x] as usize;\n            }\n            x\n        }\n        pub fn same(&self, x: usize, y: usize) -> bool {\n            self.root(x) == self.root(y)\n        }\n        pub fn unite(&mut self, mut x: usize, mut y: usize) -> Option<(usize, usize)> {\n            x = self.root(x);\n            y = self.root(y);\n            if x == y {\n                return None;\n            }\n            if self.p[x] > self.p[y] {\n                let s = x;\n                x = y;\n                y = s;\n            }\n            self.p[x] += self.p[y];\n            self.p[y] = x as i32;\n            Some((x, y))\n        }\n        pub fn get_size(&self, x: usize) -> usize {\n            let r = self.root(x);\n            (-self.p[r]) as usize\n        }\n    }\n}\n//---------- end union_find ----------\n//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8 より\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n//\n\nfn run() {\n    input! {\n        h: usize,\n        w: usize,\n        s: [chars; h],\n    }\n    // 上下左右\n    // 651, 621, 641, 631\n    let mut u = union_find::UF::new(h * w);\n    let d = [\n        ('6', ['2', '5', '3', '4']),\n        ('1', ['2', '5', '4', '3']),\n        ('1', ['5', '2', '3', '4']),\n        ('6', ['5', '2', '4', '3']),\n    ];\n    for i in 0..h {\n        for j in 0..w {\n            if i & 1 == 1 || j & 1 == 1 {\n                continue;\n            }\n            let k = i / 2 % 2 * 2 + j / 2 % 2;\n            if s[i][j] == d[k].0 {\n                let (x, y) = (i, j);\n                for (&c, &(x, y)) in d[k].1.iter().zip([(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)].iter()) {\n                    if x < h && y < w && s[x][y] == c {\n                        u.unite(x * w + y, i * w + j);\n                    }\n                }\n            }\n        }\n    }\n    let ans = if u.same(0, h * w - 1) {\"YES\"} else {\"NO\"};\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n\n"
  }
]