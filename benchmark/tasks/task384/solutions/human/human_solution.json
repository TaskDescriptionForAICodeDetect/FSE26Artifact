[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport scala.collection.mutable\nobject Main extends App {\n  import scala.io.StdIn._\n  loop()\n  @tailrec def loop(): Unit = {\n    readLine.trim match {\n      case \"#\" ⇒ return\n      case Expression(e) ⇒ println(e.calculate.distinct.length)\n        loop()\n    }\n  }\n}\nobject Expression {\n  def unapply(arg: String): Option[Expression] = {\n    arg.toList match {\n      case e Expr Nil ⇒ Some(e)\n      case _ ⇒ ???\n    }\n  }\n\n  object Expr {\n    def unapply(arg: List[Char]): Option[(Expression, List[Char])] = {\n      arg match {\n        case t Term r ⇒\n          r match {\n            case o Operator (e Expr rest) ⇒ Some(Expression(o::e.operator, t::e.term), rest)\n            case _ ⇒ Some(Expression(Nil, List(t)), r)\n          }\n        case _ ⇒ None\n      }\n    }\n  }\n  object Operator{\n    def unapply(arg: List[Char]): Option[(Operator, List[Char])] = {\n      arg match {\n        case '+'::r ⇒ Some(Add, r)\n        case '-'::r ⇒ Some(Sub, r)\n        case '*'::r ⇒ Some(Mul, r)\n        case '/'::r ⇒ Some(Div, r)\n        case _ ⇒ None\n      }\n    }\n  }\n  object Number {\n    def unapply(arg: List[Char]): Option[(Int, List[Char])] = {\n      arg.span(_.isDigit) match {\n        case (Nil, _) ⇒ None\n        case (n, r) ⇒ Some(n.foldLeft(0){case (c, d) ⇒ c * 10 + d.asDigit}, r)\n      }\n    }\n  }\n  object Term{\n    def unapply(arg: List[Char]): Option[(Term, List[Char])] = {\n      arg match {\n        case '('::(e Expr ')'::r) ⇒ Some(Bracket(e), r)\n        case n Number r ⇒ Some(Num(n), r)\n        case _ ⇒ None\n      }\n    }\n  }\n}\nsealed trait Term {\n  def calculate: List[Int]\n}\ncase class Expression(operator: List[Operator], term: List[Term]) extends Term {\n  private def calculate(op: List[Operator], te: List[Term], priority: Int): (List[Operator], List[Term]) = {\n    (priority, op, te) match {\n      case (0, o::or, a::b::tr) ⇒(or, Calculated(o(a, b))::tr)\n      case (p, o::or, t::tr) ⇒ calculate(or, tr, p - 1) match {case (orr, brr) ⇒ (o::orr, t::brr)}\n      case _ ⇒ ???\n    }\n  }\n\n  override lazy val calculate: List[Int] = {\n    val memo = Array.tabulate(1 << operator.length){i ⇒ Array.fill(term.length - i.toBinaryString.count(_ == '1')){mutable.Set[Int]()}}\n    val op = operator.toArray\n    memo(0) = term.map{t ⇒ mutable.Set(t.calculate:_*)}.toArray\n    for (from ← memo.indices) {\n      val rest = op.indices.filter(i ⇒ (from & (1 << i)) == 0)\n      for (i ← rest.indices) {\n        val to = from | (1 << rest(i))\n        for (j ← 0 until i) {\n          memo(to)(j) ++= memo(from)(j)\n        }\n        memo(to)(i) ++= op(rest(i))(memo(from)(i), memo(from)(i + 1))\n        for (j ← i + 2 until memo(from).length) {\n          memo(to)(j - 1) ++= memo(from)(j)\n        }\n      }\n    }\n    memo.last.head.toList\n  }\n}\ncase class Bracket(term: Term) extends Term {\n  override def calculate :List[Int] = term.calculate\n}\ncase class Num(number: Int) extends Term {\n  override def calculate: List[Int] = List(number)\n}\ncase class Calculated(override val calculate: List[Int]) extends Term\nsealed trait Operator {\n  def apply(left: Term, right: Term): List[Int]\n  def apply(left: Iterable[Int], right: Iterable[Int]): Iterable[Int]\n}\nobject Add extends Operator {\n  override def apply(left: Term, right: Term): List[Int] = left.calculate.flatMap(l ⇒ right.calculate.map(r ⇒ l + r)).distinct\n\n  override def apply(left: Iterable[Int], right: Iterable[Int]): Iterable[Int] = left.flatMap(l ⇒ right.map(r ⇒ l + r))\n}\nobject Sub extends Operator {\n  override def apply(left: Term, right: Term): List[Int] = left.calculate.flatMap(l ⇒ right.calculate.map(r ⇒ l - r)).distinct\n\n  override def apply(left: Iterable[Int], right: Iterable[Int]): Iterable[Int] = left.flatMap(l ⇒ right.map(r ⇒ l - r))\n}\nobject Mul extends Operator {\n  override def apply(left: Term, right: Term): List[Int] = left.calculate.flatMap(l ⇒ right.calculate.map(r ⇒ l * r)).distinct\n\n  override def apply(left: Iterable[Int], right: Iterable[Int]): Iterable[Int] = left.flatMap(l ⇒ right.map(r ⇒ l * r))\n}\nobject Div extends Operator {\n  override def apply(left: Term, right: Term): List[Int] = left.calculate.flatMap(l ⇒ right.calculate.filterNot(_ == 0).map(r ⇒ l / r)).distinct\n\n  override def apply(left: Iterable[Int], right: Iterable[Int]): Iterable[Int] = left.flatMap(l ⇒ right.filterNot(_ == 0).map(r ⇒ l / r))\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<set>\n\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\nusing namespace std;\n\nset<int> solve(const string &str){\n  vector<set<int> > nums;\n  set<int> ret;\n  vector<char> ops;\n\n  int p = 0;\n\n  while(p < str.size()){\n    if(str[p] == '('){\n      int lev = 1;\n      int pp  = ++p;\n      for(; lev > 0; ++p){\n        if(str[p] == '(') ++lev;\n        else if(str[p] == ')') --lev;\n      }\n      nums.push_back(solve(str.substr(pp, p - pp)));\n    }else if(isdigit(str[p])){\n      set<int> num;\n      int tmp = 0;\n      for(; isdigit(str[p]); ++p){\n        tmp *= 10; tmp += str[p] - '0';\n      }\n      num.insert(tmp);\n      nums.push_back(num);\n    }else{\n      ops.push_back(str[p++]);\n    }\n  }\n\n  const int n = nums.size();\n  vector<vector<set<int> > > memo(n, vector<set<int> >(n));\n\n  for(int i = 0; i < n; i++)\n    memo[i][i] = nums[i];\n\n  for(int len = 1; len < n; len++){\n    for(int i = 0; i + len < n; i++){\n      for(int last = 0; last < len; last++){\n        FOR(it1, memo[i][i+last]){\n          FOR(it2, memo[i+last+1][i+len]){\n            switch(ops[i + last]){\n            case '+':\n              memo[i][i+len].insert(*it1 + *it2); break;\n            case '-':\n              memo[i][i+len].insert(*it1 - *it2); break;\n            case '/':\n              if(*it2 != 0) memo[i][i+len].insert(*it1 / *it2); break;\n            case '*':\n              memo[i][i+len].insert(*it1 * *it2); break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return memo[0][n-1];\n}\n\nint main(){\n  string str;\n  while(cin >> str, str[0] != '#')\n    cout << solve(str).size() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <sstream>\n \nusing namespace std;\n \nset<int> m1[201][201];\nbool m2[201][201];\n \nint stoi(string s) {\n    stringstream ss; ss << s;\n    int ret; ss >> ret;\n    return ret;\n}\n \nstring str;\nset<int> dp(int l, int r) {\n    if (m2[l][r]) return m1[l][r];\n    if (str[l] == '(' && str[r-1] == ')') return dp(l+1, r-1);\n \n    set<int> ret;\n    bool f = true;\n    for (int i = l; i < r; ++i) {\n        if (!isdigit(str[i])) f = false;\n    }\n    if (f) {\n        ret.insert( stoi(str.substr(l, r-l)) );\n        return m2[l][r] = true, m1[l][r] = ret;\n    }\n \n    int depth = 0;\n    for (int i = l; i < r; ++i) {\n        switch (str[i]) {\n            case '(':\n                ++depth;\n                break;\n \n            case ')':\n                --depth;\n                break;\n \n            case '+':\n            case '-':\n            case '*':\n            case '/':\n            if (depth == 0) {\n                set<int> L = dp(l, i), R = dp(i+1, r);\n                for (set<int>::iterator j = L.begin(); j != L.end(); ++j) {\n                    for (set<int>::iterator k = R.begin(); k != R.end(); ++k) {\n                        switch (str[i]) {\n                            case '+': ret.insert(*j+*k); break;\n                            case '-': ret.insert(*j-*k); break;\n                            case '*': ret.insert((*j)*(*k)); break;\n                            case '/': if (*k) ret.insert((*j)/(*k)); break;\n                        }\n                    }\n                }\n            }\n            break;\n        }\n    }\n    return m2[l][r] = true, m1[l][r] = ret;\n}\n \nint main() {\n    while (cin >> str, str != \"#\") {\n        fill(&m2[0][0], &m2[0][0]+201*201, false);\n        cout << dp(0, str.size()).size() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <sstream>\n \nusing namespace std;\n \nset<int> m1[201][201];\nbool m2[201][201];\n \nint stoi(string s) {\n\tstringstream ss; ss << s;\n\tint ret; ss >> ret;\n\treturn ret;\n}\n \nstring str;\nset<int> dp(int l, int r) {\n\tif (m2[l][r]) return m1[l][r];\n  if (m2[l][r]) return m1[l][r];\n  int cnt = 0; bool p = true; set<int> res;\n  for (int i = l; i < r; ++i) {\n    char c = str[i];\n    if (c == '(') ++cnt;\n    else if (c == ')') --cnt;\n    else if (cnt == 0 && !isdigit(c)) {\n      p = false;\n      set<int> s1 = dp(l, i), s2 = dp(i+1, r);\n      for (int j: s1) for (int k: s2) {\n        if (c == '+') res.insert(j + k);\n        if (c == '-') res.insert(j - k);\n        if (c == '*') res.insert(j * k);\n        if (k && str[i] == '/') res.insert(j / k);\n      }\n    }\n  }\n  if (p) {\n    if (str[l] == '(' && str[r-1] == ')') res = dp(l+1, r-1);\n    else res.insert(stoi(str.substr(l, r-l)));\n  }\n  m2[l][r] = true; return m1[l][r] = res;\n}\n \nint main() {\n\twhile (cin >> str, str != \"#\") {\n\t\tfill(&m2[0][0], &m2[0][0]+201*201, false);\n\t\tcout << dp(0, str.size()).size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s;\n\nint oper(int lhs,int rhs,char op){\n    if(op=='+'){\n        return lhs+rhs;\n    }\n    if(op=='-'){\n        return lhs-rhs;\n    }\n    if(op=='*'){\n        return lhs*rhs;\n    }\n    if(op=='/'){\n        if(rhs==0) throw \"0_devision\";\n        return lhs/rhs;\n    }\n    //assert(false);\n    return 0;\n}\n\nset<int> calc(vector<int> num,vector<char> op){\n    set<int> res;\n    if(num.size()==1){\n        res.insert(num[0]);\n        return res;\n    }\n    for(int i=0;i<num.size()-1;i++){\n        auto nexnum=num;\n        auto nexop=op;\n        int lhs=num[i];\n        int rhs=num[i+1];\n        char opc=op[i];\n        int val;\n        try{\n            val=oper(lhs,rhs,opc);\n        }catch(const char* ex){\n            continue;\n        }\n        nexnum.erase(nexnum.begin()+i,nexnum.begin()+i+2);\n        nexnum.insert(nexnum.begin()+i,val);\n        nexop.erase(nexop.begin()+i);\n        auto ret=calc(nexnum,nexop);\n        res.insert(ret.begin(),ret.end());\n    }\n    return res;\n}\n\nset<int> dfs(int inde,vector<set<int>> &nums,vector<char> &op,vector<int> &num){\n    if(inde==nums.size()){\n        return calc(num,op);\n    }\n    set<int> res;\n    for(auto &v:nums[inde]){\n        num.push_back(v);\n        auto ret=dfs(inde+1,nums,op,num);\n        res.insert(ret.begin(),ret.end());\n        num.pop_back();\n    }\n    return res;\n}\n\nset<int> expr(int &p){\n    vector<set<int>> nums;\n    vector<char> op;\n    while(true){\n        if(isdigit(s[p])){\n            set<int> st;\n            st.insert(s[p]-'0');\n            p++;\n            nums.push_back(st);\n        }\n        else{\n            //assert(s[p]=='(');\n            p++;\n            nums.push_back(expr(p));\n            //assert(s[p]==')');\n            p++;\n        }\n        if(p==s.size() || s[p]==')') break;\n        op.push_back(s[p]);\n        p++;\n    }\n    vector<int> num;\n    return dfs(0,nums,op,num);\n}\n\nint main(){\n    while(cin>>s,s!=\"#\"){\n        int p=0;\n        cout<<expr(p).size()<<endl;\n    }      \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\npii expr(const string& s,int i,int cp,const vi& pri)\n{\n\tif(cp==0){\n\t\tif(s[i]=='('){\n\t\t\tpii p=expr(s,i+1,10,pri);\n\t\t\tp.second++;\n\t\t\treturn p;\n\t\t}\n\t\telse{\n\t\t\tassert(isdigit(s[i]));\n\t\t\tint x=0;\n\t\t\tfor(;i<s.size() && isdigit(s[i]);i++)\n\t\t\t\tx=x*10+s[i]-'0';\n\t\t\treturn mp(x,i);\n\t\t}\n\t}\n\telse{\n\t\tpii p=expr(s,i,cp-1,pri);\n\t\twhile((i=p.second)<s.size() && pri[i]==cp){\n\t\t\tchar op=s[i++];\n\t\t\tpii q=expr(s,i,cp-1,pri);\n\t\t\tif(op=='*') p.first=p.first*q.first;\n\t\t\tif(op=='+') p.first=p.first+q.first;\n\t\t\tif(op=='-') p.first=p.first-q.first;\n\t\t\tif(op=='/'){\n\t\t\t\tif(q.first==0) throw \"zero division\";\n\t\t\t\telse           p.first=p.first/q.first;\n\t\t\t}\n\t\t\tp.second=q.second;\n\t\t}\n\t\treturn p;\n\t}\n}\n\nint main()\n{\n\tfor(string s;getline(cin,s),s!=\"#\";){\n\t\tvi ops;\n\t\trep(i,s.size()) if(strchr(\"*+-/\",s[i]))\n\t\t\tops.push_back(i);\n\t\tvi res;\n\t\tdo{\n\t\t\tvi pri(10);\n\t\t\trep(i,ops.size()) pri[ops[i]]=i+1;\n\t\t\ttry{\n\t\t\t\tint x=expr(s,0,10,pri).first;\n\t\t\t\tres.push_back(x);\n\t\t\t}\n\t\t\tcatch(...){\n\t\t\t\t// do nothing\n\t\t\t}\n\t\t}while(next_permutation(all(ops)));\n\t\t\n\t\tcout<<set<int>(all(res)).size()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <string>\nusing namespace std;\n\nbool isnum(char c){\n\treturn '0'<=c && c<='9';\n}\nbool isnum(string &s){\n\tif(s[0]!='-' && !isnum(s[0])) return false;\n\tfor(int i=1; i<(int)s.length(); i++){\n\t\tif(!isnum(s[i])) return false;\n\t}\n\treturn true;\n}\nbool isop(string &s){\n\treturn s==\"+\" || s==\"-\" || s==\"*\" || s==\"/\";\n}\n\nvector<string> parse(string &str){\n\tvector<string> ret;\n\tstring num = \"\";\n\tfor(int i=0; i<(int)str.length(); i++){\n\t\tif(isnum(str[i])){\n\t\t\tnum += str[i];\n\t\t\tif(i+1 == (int)str.length() || !isnum(str[i+1])){\n\t\t\t\tret.push_back(num);\n\t\t\t}\n\t\t}else{\n\t\t\tnum = \"\";\n\t\t\tret.push_back(string(1,str[i]));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid erasebrac(vector<string> &vs){\n\twhile(1){\n\t\tbool end = true;\n\t\tfor(int i=0; i<(int)vs.size()-2; i++){\n\t\t\tif(vs[i]==\"(\" && isnum(vs[i+1]) && vs[i+2]==\")\"){\n\t\t\t\tend = false;\n\t\t\t\tvs.erase(vs.begin() +i+2);\n\t\t\t\tvs.erase(vs.begin() +i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(end) break;\n\t}\n}\nint calc(int a, int b, string &op){\n\tif(op == \"+\"){\n\t\treturn a+b;\n\t}else if(op == \"-\"){\n\t\treturn a-b;\n\t}else if(op == \"*\"){\n\t\treturn a*b;\n\t}else if(op == \"/\"){\n\t\tif((long long int)a*b>=0) return abs(a)/abs(b);\n\t\telse return -(abs(a)/abs(b));\n\t}\n\treturn -1;\n}\n\nvoid solve(vector<string> vs, set<int> &ans){\n\terasebrac(vs);\n\tint n = vs.size();\n\tif(n==1){\n\t\tans.insert(stoi(vs[0]));\n\t}\n\tfor(int i=1; i<n-1; i++){\n\t\tif(isnum(vs[i-1]) && isop(vs[i]) && isnum(vs[i+1])){\n\t\t\tif(vs[i]==\"/\" && vs[i+1]==\"0\") continue;\n\t\t\tvector<string> next = vs;\n\t\t\tnext[i-1] = to_string(calc(stoi(vs[i-1]), stoi(vs[i+1]), vs[i]));\n\t\t\tnext.erase(next.begin()+i, next.begin()+i+2);\n\t\t\tsolve(next, ans);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tstring str;\n\t\tcin >> str;\n\t\tif(str==\"#\") break;\n\t\t\n\t\tvector<string> vs = parse(str);\n\t\tset<int> ans;\n\t\tsolve(vs, ans);\n\t\tcout << ans.size() << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\ntypedef long long int ll;\nusing ll = long long int;\nusing ull = long long unsigned int;\nusing Int = long long int;\nusing uInt = long long unsigned int;\nusing Double = long double;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//edit\nclass Solve {\npublic:\n    string s;\n\n    vector<vector<bool>> checked;\n    vector<vector<set<Int>>> dp;\n\n    Int op(Int l, Int r, char o) {\n        if (o == '+') {\n            return l + r;\n        } else if (o == '-') {\n            return l - r;\n        } else if (o == '*') {\n            return l * r;\n        } else {\n            assert(r != 0);\n            return l / r;\n        }\n    }\n\n    set<Int> rec(Int l, Int r) {\n        if (checked[l][r]) return dp[l][r];\n\n        // 数字が現れたか, カッコの対応, 演算子が現れるか\n        bool onlynum = true;\n        vector<Int> opeidx;\n        stack<char> st;\n\n        for (int i = l; i <= r; ++i) {\n            if (s[i] == '(') {\n                st.push('(');\n            } else if (s[i] == ')') {\n                if (st.top() == '(') st.pop();\n                else st.push(')');\n            } else if (!isdigit(s[i]) && st.empty()) {\n                opeidx.push_back(i);\n            }\n\n            if (!isdigit(s[i])) {\n                onlynum = false;\n            }\n        }\n\n        if (onlynum) {\n            Int tmp = 0;\n            for (int i = l; i <= r; ++i) {\n                tmp *= 10;\n                tmp += (s[i] - '0');\n            }\n            set<Int> ret;\n            ret.insert(tmp);\n            checked[l][r] = true;\n            return dp[l][r] = ret;\n        }\n\n        if (!st.empty()) {\n            dp[l][r] = set<Int>();\n            checked[l][r] = true;\n            return dp[l][r];\n        }\n\n        if (opeidx.empty()) {\n            checked[l][r] = true;\n            return dp[l][r] = rec(l + 1, r - 1);\n        }\n\n\n        set<Int> ret;\n        for (auto m : opeidx) {\n            set<Int> lefts = rec(l, m - 1);\n            set<Int> rights = rec(m + 1, r);\n            for (auto left : lefts) {\n                for (auto right : rights) {\n                    if (s[m] == '/' && right == 0) continue;\n                    Int val = op(left, right, s[m]);\n                    ret.insert(val);\n                }\n            }\n        }\n\n\n        checked[l][r] = true;\n        return dp[l][r] = ret;\n    }\n\n\n    bool solve() {\n        cin >> s;\n        if (s == \"#\") return false;\n        checked.resize(s.size(), vector<bool>(s.size()));\n        dp.resize(s.size(), vector<set<Int>>(s.size()));\n\n        set<Int> st = rec(0, s.size() - 1);\n\n//        cout << \"----b-----\" << endl;\n//        for (auto e : st) {\n//            cout << e << endl;\n//        }\n//        cout << \"----e-----\" << endl;\n\n        Int ans = st.size();\n        cout << ans << endl;\n\n\n        return true;\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n//    std::ifstream in(\"input.txt\");\n//    std::cin.rdbuf(in.rdbuf());\n\n    while (Solve().solve());\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype>\n#include <set>\n#include <numeric>\nusing namespace std;\n\nvector<int> order;\n\nstruct Term {\n    char op;\n    set<int> operand;\n    Term(char c, set<int> si) : op(c), operand(si) { }\n};\n\ntemplate<class T> struct Parser {\n    typedef string::const_iterator State;\n\n    T solve(const string &S) {\n        State begin = S.begin();\n        return expr(begin);\n    }\n\n    // expr ::= factor | factor + factor | factor - factor\n    //         | factor * factor | factor / factor\n    T expr(State &begin) {\n        vector<Term> terms;\n        terms.emplace_back('@', factor(begin));\n        for (;;) {\n            if (*begin == '+') {\n                terms.emplace_back('+', factor(++begin));\n            } else if (*begin == '-') {\n                terms.emplace_back('-', factor(++begin));\n            } else if (*begin == '*') {\n                terms.emplace_back('*', factor(++begin));\n            } else if (*begin == '/') {\n                terms.emplace_back('/', factor(++begin));\n            } else {\n                break;\n            }\n        }\n        return dp(terms, 0, terms.size());\n    }\n\n    T dp(vector<Term> &terms, int l, int r) {\n        if (l + 1 == r) {\n            return terms[l].operand;\n        } else {\n            T res1 = f(dp(terms, l, r - 1), terms[r - 1].op, terms[r - 1].operand);\n            T res2 = f(terms[l].operand, terms[l + 1].op, dp(terms, l + 1, r));\n            return merge(res1, res2);\n        }\n    }\n\n    T f(T left, char op, T right) {\n        T res;\n        for (int a : left) for (int b : right) {\n            if (op == '+') res.insert(a + b);\n            else if (op == '-') res.insert(a - b);\n            else if (op == '*') res.insert(a * b);\n            else if (op == '/' && b != 0) res.insert(a / b);\n        }\n        return res;\n    }\n\n    T merge(T left, T right) {\n        T res;\n        for (int e : left) res.insert(e);\n        for (int e : right) res.insert(e);\n        return res;\n    }\n\n    // expr ::= ( term ) | num\n    T factor(State &begin) {\n        if (*begin == '(') {\n            begin++; // skip '('\n            T ret = expr(begin);\n            begin++; // skip ')'\n            return ret;\n        } else {\n            return number(begin);\n        }\n    }\n\n    // num ::= digit | num digit\n    T number(State &begin) {\n        int ret = 0;\n        while (isdigit(*begin)) {\n            ret *= 10;\n            ret += *begin - '0';\n            begin++;\n        }\n        return {ret};\n    }\n};\n\nint main() {\n    string S;\n    while (cin >> S && S != \"#\") {\n        Parser<set<int>> ps;\n        cout << ps.solve(S).size() << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<set>\n\nusing namespace std;\n\n#define int long long\n\nvoid solve(string &s, vector<vector<pair<bool,set<int>>>>& ans, int b, int e){\n\t\n\tif(e - b <= 0) return;\n\t\n\n\tif(ans[b][e].first){\n\t\treturn;\n\t}\n\t\t\n\tans[b][e].first = true;\n\t\n\n\tbool flag = true;\n\tint num = 0, con = 0;\n\t\n\tfor(int i = b, depth = 0, index = 0; i < e; i++){\n\t\tif(s[i] == '(') {\n\t\t\tif(!depth) con++;\n\t\t\tdepth++;\n\t\t\tflag = false;\n\t\t} else if(s[i] == ')') {\n\t\t\tdepth--;\n\t\t\tflag = false;\n\t\t} else if(s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/') {\n\t\t\tif(depth) continue;\n\t\t\t\n\t\t\tsolve(s, ans, b, i);\n\t\t\t\n\t\t\tsolve(s, ans, i+1, e);\n\t\t\t\n\t\t\tif(s[i] == '+') {\n\t\t\t\tfor(int y : ans[b][i].second){\n\t\t\t\t\tfor(int z : ans[i+1][e].second){\n\t\t\t\t\t\tans[b][e].second.insert(y + z);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(s[i] == '-') {\n\t\t\t\tfor(int y : ans[b][i].second){\n\t\t\t\t\tfor(int z : ans[i+1][e].second){\n\t\t\t\t\t\tans[b][e].second.insert(y - z);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(s[i] == '*') {\n\t\t\t\tfor(int y : ans[b][i].second){\n\t\t\t\t\tfor(int z : ans[i+1][e].second){\n\t\t\t\t\t\tans[b][e].second.insert(y * z);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(s[i] == '/') {\n\t\t\t\tfor(int y : ans[b][i].second){\n\t\t\t\t\tfor(int z : ans[i+1][e].second){\n\t\t\t\t\t\tif(z) ans[b][e].second.insert(y / z);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tflag = false;\n\t\t} else {\n\t\t\tnum = num * 10 + s[i] - '0';\n\t\t}\n\t}\n\t\n\tif(flag) {\n\t\tans[b][e].second.insert(num);\n\t}\n\t\n\tif(s[b] == '(' && s[e-1] == ')' && con == 1) {\n\t\tsolve(s, ans, b+1, e-1);\n\t\t\n\t\tans[b][e] = ans[b+1][e-1];\n\t\t\n\t\treturn ;\n\t}\n\n}\n\nsigned main(){\n\t\n\twhile(true){\n\t\tvector<vector<pair<bool,set<int>>>> ans;\n\t\t\n\t\tint n;\n\t\tstring s;\n\t\t\n\t\tcin>>s;\n\t\t\n\t\tif(s == \"#\") break;\n\t\t\n\t\tn = s.size();\n\t\t\n\t\tans.resize(n, vector<pair<bool,set<int>>>(n+1));\n\n\t\tsolve(s, ans, 0, s.size());\n\t\t\n\t\tcout<<ans[0][s.size()].second.size()<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct ops{\n  int pos,num;\n  char op;\n  ops(int pos, int num, char op):pos(pos),num(num),op(op){}\n  bool operator < (const ops &p) const {\n    return pos < p.pos;\n  }\n};\n\nstring str;\n\nvoid erase_parenthesis(vector<ops> &v){\n for(int i=0;i<(int)v.size()-2;i++){\n    if(v[i].op == '(' && v[i+1].op == 0 && v[i+2].op == ')'){\n      v.erase(v.begin() + i + 2);\n      v.erase(v.begin() + i);\n      i--;\n      if(i >= 0) i--;\n    }      \n  }\n\n}\n\nint solve(){\n  set<int> st;\n  vector<ops> ov,initv;\n\n  for(int i=0;i<str.size();i++){\n    if(str[i] == '+' || str[i] == '-' || str[i] == '*' || str[i] == '/'){\n      initv.push_back(ops(i, 0, str[i]));\n      ov.push_back(ops(i, 0, str[i]));\n    } else if(str[i] >= '0' && str[i] <= '9'){\n      int num = 0;\n      while(str[i] >= '0' && str[i] <= '9'){\n        num += str[i] - '0';\n        i++;\n      }\n      i--;\n      initv.push_back(ops(i, num, 0));\n    } else {\n      initv.push_back(ops(i, 0, str[i]));\n    }\n  }\n\n  erase_parenthesis(initv);\n\n  do{\n    vector<ops> v = initv;\n    for(int i=0;i<ov.size();i++){\n      int pos = lower_bound(v.begin(), v.end(), ov[i]) - v.begin(), res;\n      if(pos == 0 || pos == v.size()-1 || v[pos-1].op != 0 || v[pos+1].op != 0) break;\n      if(v[pos].op == '/' && v[pos+1].num == 0) break;\n      if(v[pos].op == '+') res = v[pos-1].num + v[pos+1].num;\n      if(v[pos].op == '-') res = v[pos-1].num - v[pos+1].num;\n      if(v[pos].op == '*') res = v[pos-1].num * v[pos+1].num;\n      if(v[pos].op == '/') res = v[pos-1].num / v[pos+1].num;\n      for(int j=0;j<2;j++) v.erase(v.begin()+pos);\n      v[pos-1].num = res;\n\n      erase_parenthesis(v);      \n    }\n\n    if(v.size() == 1) st.insert(v[0].num);\n\n  } while(next_permutation(ov.begin(), ov.end()));\n\n  return max(1, (int)st.size());\n}\n\nint main(){\n  while(cin >> str && str != \"#\") cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<cstring>\n#define foreach(t,p) for(t::iterator it=p.begin();it!=p.end();++it)\n#define FOREACH(t,p,tit) for(t::iterator tit=p.begin();tit!=p.end();++tit)\n#define REP(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef set<int> pp;\nstring ss;\n\npp solve(int f,int l)\n{\n\tpp ans;\n\tans.clear();\n\tbool ope=false;\n\tfor(int i=f;i<l;i++)\n\t{\n\t\tif(\n\t\t\t\tss[i]=='+'||\n\t\t\t\tss[i]=='-'||\n\t\t\t\tss[i]=='*'||\n\t\t\t\tss[i]=='/')ope = true;\n\t}\n\tif(!ope)\n\t{\n\t\tstring s = ss.substr(f,(l-f+1));\n\t\t//cout << s << endl;\n\t\tint t = atoi(s.c_str() );\n\t\tans.insert(t);\n\t\t//foreach(pp,ans)cout << *it << endl;\n\t\t//cout << atoi( (ss.substr(f,l+1)).c_str()) << endl ;\n\t\t//cout <<ss.substr(f,(l-f+1))<<endl;\n\t\treturn ans;\n\t}\n\n\t//int ofs = 0;\n\tif(ss[f]=='('&& ss[l]==')'  )return solve(f+1,l-1);\n\tint bo =0;\n\tfor(int i=f;i<l;i++)\n\t{\n\t\n\t\tif(ss[i]=='(') bo++;\n\t\tif(ss[i]==')') bo--;\n\n\t\tif((ss[i]=='+'||ss[i]=='-'||ss[i]=='*'||ss[i]=='/')&&(bo==0))\n\t\t{\n\t\t\n\t\t\tpp ansl = solve(f,i-1);\n\t\t\tpp ansr = solve(i+1,l);\n\t\t\tFOREACH(pp,ansl,iit)FOREACH(pp,ansr,jit)\n\t\t\t{\n\t\t\t\tif(ss[i]=='+') ans.insert((*iit)+(*jit));\n\t\t\t\tif(ss[i]=='-') ans.insert((*iit)-(*jit));\n\t\t\t\tif(ss[i]=='*') ans.insert((*iit)*(*jit));\n\t\t\t\tif(ss[i]=='/')if((*jit)!=0)\tans.insert((*iit)/(*jit));\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\twhile(cin >> ss &&(ss!=\"#\"))\n\t{\n\t\tpp anss = solve(0,ss.size()-1);\n\t\tcout << anss.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nstring str;\n\nint number(const int begin,const int end){\n    int res=0,idx=begin;\n    while(idx!=end){\n        res*=10;\n        res+=str[idx]-'0';\n        ++idx;\n    }\n    return res;\n}\n\nset<int> dfs(const vector<set<int>> v,const vector<char> o){\n    if(v.size()==1) return set<int>{v[0]};\n    set<int> res;\n    rep(i,0,o.size()){\n        for(const auto &x:v[i]) for(const auto &y:v[i+1]){\n            if(o[i]=='/' and y==0) continue;\n            vector<set<int>> v_(v.begin(),v.begin()+i);\n            vector<char> o_(o.begin(),o.begin()+i);\n            if(o[i]=='+') v_.emplace_back(set<int>{x+y});\n            if(o[i]=='-') v_.emplace_back(set<int>{x-y});\n            if(o[i]=='*') v_.emplace_back(set<int>{x*y});\n            if(o[i]=='/') v_.emplace_back(set<int>{x/y});\n            v_.insert(v_.end(),v.begin()+i+2,v.end());\n            o_.insert(o_.end(),o.begin()+i+1,o.end());\n            set<int> tmp=dfs(v_,o_);\n            res.insert(tmp.begin(),tmp.end());\n        }\n    }\n    return res;\n};\n\nset<int> expression(const int begin,const int end){\n    vector<set<int>> vals;\n    vector<char> ops;\n    int idx=begin;\n    while(idx!=end){\n        if(isdigit(str[idx])){\n            int end_;\n            rep(i,idx,inf) if(!isdigit(str[i])){\n                end_=i;\n                break;\n            }\n            vals.emplace_back(set<int>{number(idx,end_)});\n            idx=end_;\n        }else if(str[idx]=='+' or str[idx]=='-' or str[idx]=='*' or str[idx]=='/'){\n            ops.emplace_back(str[idx]);\n            ++idx;\n        }else if(str[idx]=='('){\n            ++idx;\n            int cnt=1,end_;\n            rep(i,idx,end){\n                if(str[i]=='(') ++cnt;\n                else if(str[i]==')') --cnt;\n                if(!cnt){\n                    end_=i;\n                    break;\n                }\n            }\n            vals.emplace_back(expression(idx,end_));\n            idx=end_+1;\n        }else break;\n    }\n    return dfs(vals,ops);\n}\n\nvoid solve(){\n    while(true){\n        cin >> str;\n        if(str==\"#\") return;\n        cout << expression(0,str.size()).size() << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef string::const_iterator state;\n\nint expression(state&);\n\nint number(state &begin){\n    int res=0;\n    while(isdigit(*begin)){\n        res*=10;\n        res+=*begin-'0';\n        ++begin;\n    }\n    return res;\n}\n\nint factor(state &begin){\n    if(*begin=='(' or *begin=='['){\n        begin++;\n        const int res=expression(begin);\n        begin++;\n        return res;\n    }else return number(begin);\n}\n\nint expression(state &begin){\n    int res=factor(begin);\n    if(res==inf) return inf;\n    while(true){\n        if(*begin=='+'){\n            ++begin;\n            res+=expression(begin);\n        }else if(*begin=='-'){\n            ++begin;\n            res-=expression(begin);\n        }else if(*begin=='*'){\n            ++begin;\n            res*=expression(begin);\n        }else if(*begin=='/'){\n            ++begin;\n            const int tmp=expression(begin);\n            if(tmp==0) return inf;\n            res/=tmp;\n        }else break;\n    }\n    return res;\n}\n\nvoid solve(){\n    while(true){\n        string str;\n        cin >> str;\n        if(str==\"#\") return;\n\n        int cnt=0;\n        for(const auto ch:str) if(ch=='+' or ch=='-' or ch=='*' or ch=='/') ++cnt;\n\n        set<int> res;\n        function<void(const string,const int,const stack<char>,bool)> rec=[&](const string &s,const int idx,const stack<char> stk,bool f){\n            if(idx==s.size()){\n                if(!stk.size()){\n                    string s_=s;\n                    dump(s_);\n                    state begin=s_.begin();\n                    const int res_=expression(begin);\n                    if(res_!=inf) res.insert(res_);\n                    dump(res_);\n                }\n                return;\n            }\n            if(s[idx]=='('){\n                auto stk_=stk;\n                stk_.push('(');\n                rec(s,idx+1,stk_,f);\n                return;\n            }\n            if(s[idx]==')'){\n                if(!stk.size() or stk.top()!='(') return;\n                auto stk_=stk;\n                stk_.pop();\n                rec(s,idx+1,stk_,f);\n                return;\n            }\n            if(stk.size()<cnt and isdigit(s[idx]) and (!idx or !isdigit(s[idx-1]))){\n                auto stk_=stk;\n                stk_.push('[');\n                auto s_=s;\n                s_.insert(idx,\"[\");\n                rec(s_,idx,stk_,false);\n            }\n            if(f and (idx+1==s.size() or (isdigit(s[idx]) and !isdigit(s[idx+1])))){\n                if(!stk.size() or stk.top()!='['){\n                    rec(s,idx+1,stk,f);\n                    return;\n                }\n                auto stk_=stk;\n                auto s_=s;\n                stk_.pop();\n                if(idx+1==s.size()) s_+=\"]\";\n                else s_.insert(idx+1,\"]\");\n                rec(s_,idx+1,stk_,false);\n            }\n            if(s[idx]=='+' or s[idx]=='-' or s[idx]=='*' or s[idx]=='/') rec(s,idx+1,stk,true);\n            else rec(s,idx+1,stk,f);\n        };\n        rec(str,0,stack<char>(),false);\n        cout << res.size() << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <set>\nusing namespace std;\n\nchar memo[16][16];\nset<int> dp[16][16];\nvector<int> op, ol;\nconst char *exp;\n\nset<int> &dfs(int s, int e, int sp, int ep, int lv){\n\tset<int> &res = dp[s][e];\n\tif(memo[s][e]){\n\t\treturn res;\n\t}\n\tres.clear();\n\n\tmemo[s][e] = 1;\n\twhile(exp[sp] == '(' && exp[ep - 1] == ')'){\n\t\t++sp;\n\t\t--ep;\n\t\t++lv;\n\t}\n\t\n\tif(s + 1 == e){\n\t\tres.insert(strtol(exp + sp, 0, 10));\n\t}\n\telse{\n\t\tfor(int i = s + 1; i < e; ++i){\n\t\t\tif(ol[i] == lv){\n\t\t\t\tchar c = exp[op[i]];\n\t\t\t\tset<int> &t = dfs(s, i, sp, op[i], lv);\n\t\t\t\tset<int> &u = dfs(i, e, op[i] + 1, ep, lv);\n\t\t\t\tset<int>::iterator it1, it2;\n\t\t\t\tfor(it1 = t.begin(); it1 != t.end(); ++it1)\n\t\t\t\tfor(it2 = u.begin(); it2 != u.end(); ++it2){\n\t\t\t\t\tswitch(c){\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\tres.insert(*it1 + *it2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\tres.insert(*it1 - *it2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\tres.insert(*it1 * *it2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '/':\n\t\t\t\t\t\tif(*it2){\n\t\t\t\t\t\t\tres.insert(*it1 / *it2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main(){\n\tstring s;\n\twhile(getline(cin, s), s[0] != '#'){\n\t\tmemset(memo, 0, sizeof memo);\n\t\top.assign(1, -1);\n\t\tol.assign(1, 0);\n\t\tint lv = 1;\n\t\tint len = s.size();\n\t\t\n\t\texp = s.c_str();\n\t\tfor(int i = 0; i < len; ++i){\n\t\t\tif(s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/'){\n\t\t\t\top.push_back(i);\n\t\t\t\tol.push_back(lv);\n\t\t\t}\n\t\t\telse if(s[i] == '('){\n\t\t\t\t++lv;\n\t\t\t}\n\t\t\telse if(s[i] == ')'){\n\t\t\t\t--lv;\n\t\t\t}\n\t\t}\n\t\top.push_back(len);\n\t\tol.push_back(0);\n\t\tint ans = dfs(0, op.size() - 1, 0, len, 1).size();\n\t\tcout << ans << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <algorithm>\n#include <climits>\n#include <vector>\nusing namespace std;\n\nint pos;\nstring line;\nstring table = \"+/*-\";\n \nvoid view(set<int> a){\n\tfor(set<int>::iterator it = a.begin() ; it != a.end() ; ++it){\n\t\tcout << *it << \" \";\n\t}\n\tcout << endl;\n}\nint mcalc(int a,int b,char c){\n\tswitch(c){\n\t\tcase '+': return a+b;\n\t\tcase '-': return a-b;\n\t\tcase '*': return a*b;\n\t\tcase '/': return b?a/b:INT_MAX;\n\t}\n}\nset<int> real(vector<int> num,vector<char> &op2){\n\tvector<int> src = num;\n\tint o[] = {0,1,2,3,4,5,6,7,8,9} , n = op2.size();\n\tset<int> answer;\n\tdo{\n\t\tvector<int> posi(n+1);\n\t\tvector<pair<int,char> > op(n);\n\t\tfor(int i = 0 ; i < n ; i++) op[i] = make_pair(i,op2[i]);\n\t\t\n\t\tfor(int i = 0 ; i < posi.size() ; i++) posi[i] = i;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < op.size() ; j++){\t\t\t\n\t\t\t\tif( op[j].first == o[i]){\n\t\t\t\t\tint p = j;\n\t\t\t\t\tint r = mcalc(num[p],num[p+1],op[p].second);\n\t\t\t\t\tif(r == INT_MAX) goto fail;\n\t\t\t\t\tnum[p] = num[p+1] = r;\n\t\t\t\t\tnum.erase(num.begin()+p);\n\t\t\t\t\top.erase(op.begin()+p);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//or(int i = 0 ; i < num.size() ; i++) cout << o[i] << \" \";cout << endl;\n\t\t//for(int i = 0 ; i <= n ; i++) cout << num[i] << \" \";cout << \"=\" << num[o[n-1]] << endl;\n\t\tanswer.insert(num[0]);\n\t\tfail:;\n\t\tnum = src;\n\t}while(next_permutation(o,o+n));\n\t//for(int i = 0 ; i <= n ; i++) cout << num[i] << \" \";cout << endl;\n\t//cout << answer.size() << \" |\" ; view(answer);\n\treturn answer;\n}\n\nvector< vector<int> > var;\nvector<int> current;\nvoid func(vector<int> &cur,vector< set<int> > &num){\n\tif(cur.size() == num.size()){\n\t\tvar.push_back(cur);\n\t}else{\n\t\tint p = cur.size();\n\t\tfor(set<int>::iterator it = num[p].begin() ; it != num[p].end() ; ++it){\n\t\t\tcur.push_back(*it);\n\t\t\tfunc(cur,num);\n\t\t\tcur.pop_back();\n\t\t}\n\t}\n}\n\nset<int> calc(vector< set<int> > num,vector<char> op){\n\tvar.clear();\n\tcurrent.clear();\n\tfunc(current,num);\n\t\n\tset<int> answer;\n\tfor(int i = 0 ; i < var.size() ; i++){\n\t\tset<int> result = real(var[i],op);\n\t\tanswer.insert(result.begin(),result.end());\n\t}\n\treturn answer;\n}\nset<int> go(int depth){\n\tint cur = 0;\n\tvector< set<int> > num;\n\tvector<char> op;\n\twhile(1){\n\t\t//cout << depth << \":\" << pos << \" \" << line[pos] << \" \" << num.size() << endl;\n\t\tchar c = line[pos++];\n\t\tif( c== '('){\n\t\t\tnum.push_back(go(depth+1));\n\t\t}else if(c == ')'){\n\t\t\t//cout << \"[\" << depth << endl;\n\t\t\t//for(int i = 0 ; i < op.size() ; i++)\n\t\t\t//\tcout << op[i] << \" \" ; cout << endl;\n\t\t\t//\n\t\t\t//for(int i = 0 ; i < num.size() ; i++)\n\t\t\t//\tcout << num[i].size() << \" \" ; cout << endl;\n\t\t\tif(num.size() == 1) return num[0];\n\t\t\telse return calc(num,op);\n\t\t}else if(table.find(c) != -1){\n\t\t\top.push_back(c);\n\t\t}else{\n\t\t\tint number = c-'0';\n\t\t\t//cout << c << endl;\n\t\t\twhile(line[pos] >= '0' && line[pos] <= '9') number = number * 10 + line[pos] - '0' , pos++;\n\t\t\tset<int> add;\n\t\t\tadd.insert(number);\n\t\t\tnum.push_back(add);\n\t\t}\n\t}\n}\nint main(){\n\twhile(getline(cin,line) && line != \"#\"){\n\t\tpos = 0;\n\t\tline += \")\";\n\t\tcout << go(0).size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nstring s;\ntypedef long long ll;\nusing Iter = string::const_iterator;\nusing SIter= set<ll>::const_iterator;\n\nIter skip_par(Iter it) {\n  it++;\n  for(int cnt=1; cnt > 0; it++) cnt += (*it == '(') ? 1 : ((*it == ')') ? -1 : 0);\n  return it;\n}\n\nbool number(Iter st, Iter ed, ll& ret) {\n  ret = 0;\n  for(Iter curr=st; curr!=ed; curr++) {\n    if(isdigit(*curr)) {\n      ret *= 10;\n      ret += (*curr)-'0';\n    }\n    else { return false; }\n  }\n  return true;\n}\n\nset<char> opes={'+','-','*','/'};\n\nset<ll> exp(Iter st, Iter ed) {\n  if(*st == '(' && *(ed-1) == ')') { return exp(st+1, ed-1); }\n  {ll num; if(number(st, ed, num)) { return {num}; } }\n  set<ll> ret;\n  for(Iter curr=st; curr!=ed;curr++) {\n    if(*curr == '(') {\n      curr = skip_par(curr)-1;\n    }\n    else if(opes.count(*curr)) {\n      set<ll> l = exp(st, curr);\n      set<ll> r = exp(curr+1,ed);\n      for(SIter i=l.begin(); i!=l.end(); i++) {\n        for(SIter j=r.begin(); j!=r.end(); j++) {\n          switch(*curr) {\n            case '+': ret.insert(*i+*j); break;\n            case '-': ret.insert(*i-*j); break;\n            case '*': ret.insert(*i**j); break;\n            case '/': if(*j!=0) { ret.insert(*i/(*j)); } break;\n          }\n        }\n      }\n    }\n  }\n\n  return ret;\n}\n\nint main()\n{\n  for(;getline(cin, s);) {\n    if(s==\"#\") { break; }\n    Iter it = s.begin(), ed = s.end();\n    cout << exp(it, ed).size() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\n\nstring str;\n\nint calc(int a, int b, char c){\n\tif(c == '+') return a+b;\n\tif(c == '*') return a*b;\n\tif(c == '-') return a-b;\n\tif(b == 0){\n\t\treturn MOD;\n\t} else if(b > 0){\n\t\treturn a/b;\n\t}\n}\n\nvector<int> fu(vector<int> v, vector<char> c){\n\tvector<int> ret;\n\tif(c.size() == 0){\n\t\tret.push_back(v[0]);\n\t\treturn ret;\n\t}\n\tvector<int> V;\n\tvector<char> C;\n\trep(i,c.size()){\n\t\tV.clear();\n\t\tC.clear();\n\t\tbool ok = true;\n\t\trep(j,v.size()){\n\t\t\tif(i != j){\n\t\t\t\tV.push_back(v[j]);\n\t\t\t\tif(j != v.size()-1) C.push_back(c[j]);\n\t\t\t} else{\n\t\t\t\tint tmp = calc(v[j],v[j+1],c[j]);\n\t\t\t\tif(tmp == MOD){\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tV.push_back(tmp);\n\t\t\t\tif(j+1 != v.size()-1) C.push_back(c[j+1]);\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tif(!ok) continue;\n\t\tV = fu(V,C);\n\t\trep(j,V.size()) ret.push_back(V[j]);\n\t}\n\treturn ret;\n}\n\nvector<int> fun(vector<vector<int> > v, vector<char> c, vector<int> z, int cnt){\n\tvector<int> x;\n\tif(v[cnt].size() == 0){\n\t\treturn fu(z,c);\n\t}\n\tvector<int> tmp;\n\trep(i,v[cnt].size()){\n\t\tz.push_back(v[cnt][i]);\n\t\ttmp.clear();\n\t\ttmp = fun(v,c,z,cnt+1);\n\t\trep(j,tmp.size()) x.push_back(tmp[j]);\n\t\tz.pop_back();\n\t}\n\treturn x;\n}\n\nvector<int> func(string s){\n\tint cont = 0;\n\tvector<vector<int> > v;\n\tv.resize(12);\n\tvector<char> c;\n\trep(i,s.size()){\n\t\tif(s[i] == '('){\n\t\t\tint cnt = 0;\n\t\t\tstring tmp;\n\t\t\twhile(true){\n\t\t\t\ti++;\n\t\t\t\tif(s[i] == '(') cnt++;\n\t\t\t\tif(s[i] == ')' && cnt == 0) break;\n\t\t\t\tif(s[i] == ')') cnt--;\n\t\t\t\ttmp.push_back(s[i]);\n\t\t\t}\n\t\t\tv[cont] = func(tmp);\n\t\t} else if('0' <= s[i] && s[i] <= '9'){\n\t\t\tv[cont].push_back(s[i]-'0');\n\t\t} else{\n\t\t\tc.push_back(s[i]);\n\t\t\tcont++;\n\t\t}\n\t}\n\tvector<int> z;\n\treturn fun(v, c, z, 0);\n}\n\nvoid solve(){\n\tvector<int> v = func(str);\n\tsort(v.begin(),v.end());\n\tv.erase(unique(v.begin(),v.end()),v.end());\n\tcout << v.size() << endl;\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> str;\n\t\tif(str == \"#\") break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype>\n#include <set>\nusing namespace std;\n\ntemplate<class T> struct Parser {\n    typedef string::const_iterator State;\n\n    T solve(const string &S) {\n        State begin = S.begin();\n        return expr(begin);\n    }\n\n    struct Term {\n        char op;\n        set<int> operand;\n        Term(char c, set<int> si) : op(c), operand(si) { }\n    };\n\n    // expr ::= factor | factor + factor | factor - factor\n    //         | factor * factor | factor / factor\n    T expr(State &begin) {\n        vector<Term> terms;\n        terms.emplace_back('@', factor(begin));\n        for (;;) {\n            if (*begin == '+') {\n                terms.emplace_back('+', factor(++begin));\n            } else if (*begin == '-') {\n                terms.emplace_back('-', factor(++begin));\n            } else if (*begin == '*') {\n                terms.emplace_back('*', factor(++begin));\n            } else if (*begin == '/') {\n                terms.emplace_back('/', factor(++begin));\n            } else {\n                break;\n            }\n        }\n        return dp(terms);\n    }\n\n    T dp(vector<Term> &terms) {\n        int n = terms.size();\n        vector<vector<T>> dp(n, vector<T>(n + 1));\n        for (int i = 0; i < n; i++) {   // len = 1\n            dp[i][i + 1] = terms[i].operand;\n        }\n        for (int len = 2; len <= n; len++) {\n            for (int i = 0; i + len <= n; i++) {        // [i, i + len)\n                T &res = dp[i][i + len];\n                for (int j = i + 1; j < i + len; j++) { // [i, j) + [j, i + len)\n                    T tmp = calc(dp[i][j], terms[j].op, dp[j][i + len]);\n                    merge(res, tmp);\n                }\n            }\n        }\n        return dp[0][n];\n    }\n\n    T calc(T left, char op, T right) {\n        T res;\n        for (int a : left) for (int b : right) {\n            if (op == '+') res.insert(a + b);\n            else if (op == '-') res.insert(a - b);\n            else if (op == '*') res.insert(a * b);\n            else if (op == '/' && b != 0) res.insert(a / b);\n        }\n        return res;\n    }\n\n    void merge(T &res, T tmp) {\n        for (int e : tmp) res.insert(e);\n    }\n\n    // expr ::= ( term ) | number\n    T factor(State &begin) {\n        if (*begin == '(') {\n            begin++; // skip '('\n            T ret = expr(begin);\n            begin++; // skip ')'\n            return ret;\n        } else {\n            return number(begin);\n        }\n    }\n\n    // number ::= digit | number digit\n    T number(State &begin) {\n        int ret = 0;\n        while (isdigit(*begin)) {\n            ret *= 10;\n            ret += *begin - '0';\n            begin++;\n        }\n        return {ret};\n    }\n};\n\nint main() {\n    string S;\n    while (cin >> S && S != \"#\") {\n        Parser<set<int>> ps;\n        cout << ps.solve(S).size() << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <vector>\n#include <cstdlib>\n\nusing namespace std;\n\n\nset<int> rec2(string str){\n\t// ©Ç¤©\n\tbool f = false;\n\tfor(int i = 0; i < str.size(); i++){\n\t\tif(!(str[i] >= '0' && str[i] <= '9')){\n\t\t\tf = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!f){\n\t\tset<int> v;\n\t\tv.insert(atoi(str.c_str()));\n\t\treturn v;\n\t}\n\n\t// ©ªÌÊÅÍíêÄ¢éê\n\tif(str[0] == '('){\n\t\tbool ff = false;\n\t\tint cnt = 1;\n\t\tfor(int i = 1; i < str.size(); i++){\n\t\t\tif(str[i] == '('){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\telse if(str[i] == ')'){\n\t\t\t\tcnt--;\n\t\t\t\tif(cnt == 0 && i != str.size()-1)\n\t\t\t\t\tbreak;\n\t\t\t\tif(cnt == 0 && i == str.size()-1){\n\t\t\t\t\treturn rec2(str.substr(1,str.size()-2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tset<int> vec;\n\tfor(int i = 0; i < str.size(); i++){\n\t\tif(str[i] == '+'){\n\t\t\tset<int> v1 =  rec2(str.substr(0,i));\n\t\t\tset<int> v2 =  rec2(str.substr(i+1));\n\t\t\tfor(set<int>::iterator it = v1.begin(); v1.end() != it; it++){\n\t\t\t\tfor(set<int>::iterator iit = v2.begin(); v2.end() != iit; iit++){\n\t\t\t\t\tvec.insert((*it) + (*iit));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(str[i] == '*'){\n\t\t\tset<int> v1 =  rec2(str.substr(0,i));\n\t\t\tset<int> v2 =  rec2(str.substr(i+1));\n\t\t\tfor(set<int>::iterator it = v1.begin(); v1.end() != it; it++){\n\t\t\t\tfor(set<int>::iterator iit = v2.begin(); v2.end() != iit; iit++){\n\t\t\t\t\tvec.insert((*it) * (*iit));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(str[i] == '/'){\n\t\t\tset<int> v1 =  rec2(str.substr(0,i));\n\t\t\tset<int> v2 =  rec2(str.substr(i+1));\n\t\t\tfor(set<int>::iterator it = v1.begin(); v1.end() != it; it++){\n\t\t\t\tfor(set<int>::iterator iit = v2.begin(); v2.end() != iit; iit++){\n\t\t\t\t\tif((*iit) != 0)\n\t\t\t\t\t\tvec.insert((*it) / (*iit));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(str[i] == '-'){\n\t\t\tset<int> v1 =  rec2(str.substr(0,i));\n\t\t\tset<int> v2 =  rec2(str.substr(i+1));\n\t\t\tfor(set<int>::iterator it = v1.begin(); v1.end() != it; it++){\n\t\t\t\tfor(set<int>::iterator iit = v2.begin(); v2.end() != iit; iit++){\n\t\t\t\t\tvec.insert((*it) - (*iit));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn vec;\n}\n\nint main(){\n\n\tstring str;\n\twhile(cin >> str && str != \"#\"){\n\t\tset<int> ss = rec2(str);\n\t\tcout << ss.size() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(V) (V).begin(),(V).end()\nusing namespace std;\nusing ll = int64_t;\ntemplate <typename T> using V = vector<T>;\n\nll zero = 0;\n\nbool is_op(char c) {\n    return c == '+' ||\n           c == '-' ||\n           c == '*' ||\n           c == '/';\n}\n\nbool is_dig(char c) { return '0' <= c && c <= '9'; }\n\nll solve(string S) {\n    V<ll> op_idx;\n    for(ll i = 0; i < S.size(); i++) if(is_op(S[i])) op_idx.push_back(i);\n    const auto id_lis = op_idx;\n\n    auto get_op_id = [&](ll idx) {\n        return distance(id_lis.begin(),\n                        lower_bound(ALL(id_lis), idx));\n    };\n\n    V<ll> depth(op_idx.size());\n    \n    {\n        ll d = 0;\n        for(ll i = 0; i < S.size(); i++) {\n            if(S[i] == '(') d++;\n            else if(S[i] == ')') d--;\n            if(!is_op(S[i])) continue;\n            depth[get_op_id(i)] = d;\n        }\n    }\n\n    V<ll> op_idx_rev(op_idx.size());\n    bool suc = true;\n\n    function<ll(ll, ll)> calc_substr = [&](ll l, ll r) {\n        ll first_op = -1;\n        for(ll i = l; i < r; i++) {\n            if(!is_op(S[i])) continue;\n            if(first_op == -1) first_op = i;\n            else if(op_idx_rev[get_op_id(i)] <\n                    op_idx_rev[get_op_id(first_op)]) first_op = i;\n        }\n        if(first_op == -1) {\n            ll ret = 0;\n            for(ll i = l; i < r; i++) if(is_dig(S[i])) ret = ret * 10 + (S[i] - '0');\n            return ret;\n        }\n        ll lv = calc_substr(l, first_op);\n        ll rv = calc_substr(first_op + 1, r);\n        if(!suc) return zero;\n        switch(S[first_op]) {\n            case '+': return lv + rv;\n            case '-': return lv - rv;\n            case '*': return lv * rv;\n            case '/':\n                if(rv == 0) {\n                    suc = false;\n                    return zero;\n                } else {\n                    return lv / rv;\n                }\n                break;\n        }\n        suc = false;\n        return zero;\n    };\n\n    set<ll> results;\n    do {\n        suc = true;\n        for(ll i = 0; i < op_idx.size(); i++) op_idx_rev[get_op_id(op_idx[i])] = i;\n        for(ll i = 0; i < op_idx.size(); i++) {\n            ll id1 = get_op_id(op_idx[i]);\n            for(ll j = i; j < op_idx.size(); j++) {\n                ll id2 = get_op_id(op_idx[j]);\n                if(depth[id2] < depth[id1]) {\n                    suc = false;\n                    break;\n                }\n            }\n        }\n        ll ret = (suc ? calc_substr(0, S.size()) : 0);\n        if(suc) results.insert(ret);\n    } while(next_permutation(ALL(op_idx)));\n\n    return results.size();\n}\n\nint main() {\n    while(true) {\n        string S;\n        cin >> S;\n        if(S == \"#\") break;\n        cout << solve(S) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s;\n\nint oper(int lhs,int rhs,char op){\n    if(op=='+'){\n        return lhs+rhs;\n    }\n    if(op=='-'){\n        return lhs-rhs;\n    }\n    if(op=='*'){\n        return lhs*rhs;\n    }\n    if(op=='/'){\n        if(rhs==0) throw \"0_devision\";\n        return lhs/rhs;\n    }\n    assert(false);\n}\n\nset<int> calc(vector<int> num,vector<char> op){\n    set<int> res;\n    if(num.size()==1){\n        res.insert(num[0]);\n        return res;\n    }\n    for(int i=0;i<num.size()-1;i++){\n        auto nexnum=num;\n        auto nexop=op;\n        int lhs=num[i];\n        int rhs=num[i+1];\n        char opc=op[i];\n        int val;\n        try{\n            val=oper(lhs,rhs,opc);\n        }catch(const char* ex){\n            continue;\n        }\n        nexnum.erase(nexnum.begin()+i,nexnum.begin()+i+2);\n        nexnum.insert(nexnum.begin()+i,val);\n        nexop.erase(nexop.begin()+i);\n        auto ret=calc(nexnum,nexop);\n        res.insert(ret.begin(),ret.end());\n    }\n    return res;\n}\n\nset<int> dfs(int inde,vector<set<int>> &nums,vector<char> &op,vector<int> &num){\n    if(inde==nums.size()){\n        return calc(num,op);\n    }\n    set<int> res;\n    for(auto &v:nums[inde]){\n        num.push_back(v);\n        auto ret=dfs(inde+1,nums,op,num);\n        res.insert(ret.begin(),ret.end());\n        num.pop_back();\n    }\n    return res;\n}\n\nset<int> expr(int &p){\n    vector<set<int>> nums;\n    vector<char> op;\n    while(true){\n        if(isdigit(s[p])){\n            set<int> st;\n            st.insert(s[p]-'0');\n            p++;\n            nums.push_back(st);\n        }\n        else{\n            assert(s[p]=='(');\n            p++;\n            nums.push_back(expr(p));\n            assert(s[p]==')');\n            p++;\n        }\n        if(p==s.size() || s[p]==')') break;\n        op.push_back(s[p]);\n        p++;\n    }\n    vector<int> num;\n    return dfs(0,nums,op,num);\n}\n\nint main(){\n    while(cin>>s,s!=\"#\"){\n        int p=0;\n        cout<<expr(p).size()<<endl;\n    }      \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <iostream>\n#include <set>\n#include <vector>\n#include <string>\n\nclass Solver {\n  using set = std::set<int>;\n  public:\n    std::string line;\n    int solve() {\n      i_ = 0;\n      return expr().size();\n    }\n  private:\n    std::size_t i_;\n    set expr() {\n      std::vector<set> nums = {chunk()};\n      std::vector<char> ops;\n      while (i_ < line.length() and is_operator(line[i_])) {\n        ops.push_back(line[i_++]);\n        nums.push_back(chunk());\n      }\n      std::vector<std::vector<set>> t(nums.size(), std::vector<set>(nums.size() + 1));\n      for (std::size_t i = 0; i < nums.size(); ++i) t[i][i + 1] = nums[i];\n      for (std::size_t w = 2; w <= nums.size(); ++w) {\n        for (std::size_t begin = 0; begin + w <= nums.size(); ++begin) {\n          std::size_t end = begin + w;\n          for (std::size_t sep = begin + 1; sep < end; ++sep) {\n            char op = ops[sep - 1];\n            for (auto left : t[begin][sep]) {\n              for (auto right : t[sep][end]) {\n                auto &s = t[begin][end];\n                if (op == '+') s.insert(left + right);\n                if (op == '-') s.insert(left - right);\n                if (op == '*') s.insert(left * right);\n                if (op == '/' and right != 0) s.insert(left / right);\n              }\n            }\n          }\n        }\n      }\n      return t[0][nums.size()];\n    }\n    bool is_operator(char c) {\n      return c == '+' or c == '-' or c == '*' or c == '/';\n    }\n    set chunk() {\n      if (line[i_] == '(') {\n        ++i_;\n        set s = expr();\n        ++i_;\n        return s;\n      }\n      int x = 0;\n      while (i_ < line.length() and std::isdigit(line[i_])) x = 10 * x + (line[i_++] - '0');\n      return {x};\n    }\n};\n\nint main() {\n  Solver s;\n  while (true) {\n    std::cin >> s.line;\n    if (s.line == \"#\") return 0;\n    std::cout << s.solve() << std::endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nstring s;\n\nset<int> parse(int l, int r)\n{\n\tset<int> res;\n\tstring t = s.substr(l, r - l);\n\tbool f = true;\n\tREP(i, t.size())\n\t{\n\t\tif (!isdigit(t[i])) f = false;\n\t}\n\tif (f)\n\t{\n\t\tres.insert(stoi(t));\n\t\treturn res;\n\t}\n\t\n\tif (t[0] == '('&&t.back() == ')')\n\t{\n\t\tbool f = true;\n\t\tint cnt = 0;\n\t\tREP(i, t.size()-1)\n\t\t{\n\t\t\tif (t[i] == '(') cnt++;\n\t\t\telse if (t[i] == ')') cnt--;\n\t\t\tif (cnt == 0) f = false;\n\t\t}\n\t\tif (f) return parse(l + 1, r - 1);\n\t}\n\tint cnt = 0;\n\tFOR(i, l, r)\n\t{\n\t\tif (s[i] == '(') cnt++;\n\t\telse if (s[i] == ')') cnt--;\n\t\telse if (!isdigit(s[i]) && cnt == 0)\n\t\t{\n\t\t\tset<int> lhs = parse(l, i);\n\t\t\tset<int> rhs = parse(i + 1, r);\n\t\t\tfor (auto j : lhs)for (auto k : rhs)\n\t\t\t{\n\t\t\t\tif (s[i] == '+') res.insert(j + k);\n\t\t\t\tif (s[i] == '-') res.insert(j - k);\n\t\t\t\tif (s[i] == '*') res.insert(j * k);\n\t\t\t\tif (k != 0 && s[i] == '/') res.insert(j / k);\n\t\t\t}\n\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> s, s != \"#\")\n\t{\n\t\tcout << parse(0, s.size()).size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nnamespace SyntaxAnalysis{\n\ttypedef string::const_iterator Cursor;\n\n\n//\t\t\tl.erase(remove(l.begin(), l.end(), ' '), l.end());//空白除去\n\t\n\tclass ParseError{};\n\t// <四則演算の式> ::= <乗算除算の式> (+ or -) <乗算除算の式> (+ or -) ...\n\t// <乗算除算の式> ::= <括弧か数> (* or /) <括弧か数> (* or /) ...\n\t// <括弧か数>     ::= '(' <四則演算の式> ')' or <数>\n\t// <数>           ::= (0|1|2|3|4|5|6|7|8|9)+\n\n\tvector<int> expression(Cursor&);\n\tvector<int> factor(Cursor&);\n\tint number(Cursor&);\n \n\n\t// <四則演算の式> ::= <乗算除算の式> (+ or -) <乗算除算の式> (+ or -) ...\n\tvector<int> expression(Cursor &c){\n\t    vector<vector<int>> fs;fs.push_back(factor(c));\n\t    vector<char> ops;\n\t    while(*c == '+' || *c == '-' || *c =='*' || *c =='/'){\n\t        ops.push_back(*c);\n\t        c++;fs.push_back(factor(c));\n\t    }\n\t    int opc=ops.size();\n\n\t    vector<int> per(opc);REP(i,opc)per[i]=i;\n\t    vector<int> res;\n\t    do{\n\t    \tvector<vector<int>> tmp=fs;\n\t    \tREP(i,opc){\n\t    \t\tvector<int> rlt;\n\t    \t\tREP(j,tmp[per[i]].size())REP(k,tmp[per[i]+1].size()){\n\t    \t\t\tif(ops[per[i]]=='+') rlt.push_back(tmp[per[i]][j]+tmp[per[i]+1][k]);\n\t    \t\t\tif(ops[per[i]]=='-') rlt.push_back(tmp[per[i]][j]-tmp[per[i]+1][k]);\n\t    \t\t\tif(ops[per[i]]=='*') rlt.push_back(tmp[per[i]][j]*tmp[per[i]+1][k]);\n\t    \t\t\tif(ops[per[i]]=='/' && tmp[per[i]+1][k]!=0) rlt.push_back(tmp[per[i]][j]/tmp[per[i]+1][k]);\n\t    \t\t}\n\t    \t\tsort(ALL(rlt)); rlt.erase(unique(ALL(rlt)),rlt.end());\n\t    \t\ttmp[per[i]]=rlt;\n\t    \t}\n\t    \tREP(i,tmp[0].size())res.push_back(tmp[0][i]);\n\t    }while(next_permutation(ALL(per)));\n\n\t    sort(ALL(res)); res.erase(unique(ALL(res)),res.end());\n\t    return res;\n\t}\n\n\t// <括弧か数>     ::= '(' <四則演算の式> ')' or <数>\n\tvector<int> factor(Cursor &c){\n\t    if(*c == '('){\n\t        c++;\n\t        vector<int> ret = expression(c);\n\t        c++; // ')'\n\t        return ret;\n\t    }else{\n\t        return vector<int>(1,number(c));\n\t    }\n\t}\n\n\t// <数>           ::= (0|1|2|3|4|5|6|7|8|9)+\n\tint number(Cursor &c){\n\t    stringstream ss;\n\t    while(isdigit(*c)){\n\t        ss << *c;\n\t        c++;\n\t    }\n\t    int ret;\n\t    ss >> ret;\n\t    return ret;\n\t}\n}\nusing namespace SyntaxAnalysis;\n\nclass Main{\n\tpublic:\n\n\tvoid run(){\n\t\t// ifstream cin(\"D2\");\n//\t\tofstream cout( \"D2.out\" );\n\t\t\n\t\twhile(true){\n\t\t\tstring str;cin >> str;if(str==\"#\")break;\n\n\t\t\tCursor c=str.begin();\n\n\t\t\tcout << expression(c).size()<<endl;\n\t\t}\n\t}\n\n\n};\nint main(){\n\tcout <<fixed<<setprecision(15);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef string::const_iterator state;\n\nint expression(state&);\n\nint number(state &begin){\n    int res=0;\n    while(isdigit(*begin)){\n        res*=10;\n        res+=*begin-'0';\n        ++begin;\n    }\n    return res;\n}\n\nint factor(state &begin){\n    if(*begin=='(' or *begin=='['){\n        begin++;\n        const int res=expression(begin);\n        begin++;\n        return res;\n    }else return number(begin);\n}\n\nint expression(state &begin){\n    int res=factor(begin);\n    if(res==inf) return inf;\n    while(true){\n        if(*begin=='+'){\n            ++begin;\n            res+=expression(begin);\n        }else if(*begin=='-'){\n            ++begin;\n            res-=expression(begin);\n        }else if(*begin=='*'){\n            ++begin;\n            res*=expression(begin);\n        }else if(*begin=='/'){\n            ++begin;\n            const int tmp=expression(begin);\n            if(tmp==0) return inf;\n            res/=tmp;\n        }else break;\n    }\n    return res;\n}\n\nvoid solve(){\n    while(true){\n        string str;\n        cin >> str;\n        if(str==\"#\") return;\n\n        int cnt=0;\n        for(const auto ch:str) if(ch=='+' or ch=='-' or ch=='*' or ch=='/') ++cnt;\n\n        set<int> res;\n        function<void(const string,const int,const stack<char>,bool)> rec=[&](const string &s,const int idx,const stack<char> stk,bool f){\n            if(idx==s.size()){\n                if(!stk.size()){\n                    string s_=s;\n                    dump(s_);\n                    state begin=s_.begin();\n                    const int res_=expression(begin);\n                    if(res_!=inf) res.insert(res_);\n                    dump(res_);\n                }\n                return;\n            }\n            if(s[idx]=='('){\n                auto stk_=stk;\n                stk_.push('(');\n                rec(s,idx+1,stk_,f);\n                return;\n            }\n            if(s[idx]==')'){\n                if(!stk.size() or stk.top()!='(') return;\n                auto stk_=stk;\n                stk_.pop();\n                rec(s,idx+1,stk_,f);\n                return;\n            }\n            if(stk.size()<cnt and isdigit(s[idx]) and (!idx or (s[idx-1]!='(' and !isdigit(s[idx-1])))){\n                auto stk_=stk;\n                stk_.push('[');\n                auto s_=s;\n                s_.insert(idx,\"[\");\n                rec(s_,idx,stk_,false);\n            }\n            if(f and (idx+1==s.size() or (isdigit(s[idx]) and !isdigit(s[idx+1])))){\n                if(!stk.size() or stk.top()!='['){\n                    rec(s,idx+1,stk,f);\n                    return;\n                }\n                auto stk_=stk;\n                auto s_=s;\n                stk_.pop();\n                if(idx+1==s.size()) s_+=\"]\";\n                else s_.insert(idx+1,\"]\");\n                rec(s_,idx+1,stk_,false);\n            }\n            if(s[idx]=='+' or s[idx]=='-' or s[idx]=='*' or s[idx]=='/') rec(s,idx+1,stk,true);\n            else rec(s,idx+1,stk,f);\n        };\n        rec(str,0,stack<char>(),false);\n        cout << res.size() << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MP make_pair\n#define EACH(i, c) for(__typeof((c).begin()) i=(c).begin(); (i)!=(c).end(); i++)\n\ntypedef pair<int, int> PII;\n\nconst int SIZE = 50;\n\nchar line[SIZE], t[SIZE];\nset<int> memo[SIZE][SIZE];\nset<PII> used;\n \nvoid eval(int const l, int const r) {\n   \n  set<int>& ret = memo[l][r];\n  if(l == r) return;\n   \n  if(used.count(MP(l, r))) return;\n  used.insert(MP(l, r));\n   \n  // check is digits [l, r)\n  bool digits = true;\n  for(int i=l; i<r; i++) { digits = digits && isdigit(line[i]); }\n  strncpy(t, line+l, r-l); t[r-l] = 0;\n  if(digits) { ret.insert(atoi(t)); return; }\n   \n  int par = 0; bool check = true;\n  for(int i=l; i<r-1; i++) {\n    if(line[i] == '(') { par ++; }\n    if(line[i] == ')') { par --; }\n    if(par == 0) { check = false; }\n  }\n   \n  // \"(expr)\"\n  if(check) {\n    if(line[r-1] == ')') {\n      eval(l+1, r-1); ret = memo[l+1][r-1]; return;\n    }\n  }\n   \n  par = 0;\n  // parsing loop\n  for(int i=l; i<r; i++) {\n    if(line[i] == '(') { par ++; }\n    if(line[i] == ')') { par --; }\n    if(par != 0) continue;\n     \n    switch(line[i]) {\n    case '+': case '-': case '*': case '/':\n      eval(l, i); eval(i+1, r);\n      EACH(ia, memo[l][i]) EACH(ib, memo[i+1][r]) {\n        if(line[i] == '+') { ret.insert(*ia + *ib); }\n        if(line[i] == '-') { ret.insert(*ia - *ib); }\n        if(line[i] == '*') { ret.insert(*ia * *ib); }\n        if(line[i] == '/' && *ib!=0) { ret.insert(*ia / *ib); }\n      }\n      break;\n    }\n  } // for parsing loop\n}\n \nint main() {\n   \n  while(1) {\n    scanf(\"%s\\n\", line);\n    for(int i=0; i<SIZE; i++)\n      for(int j=0; j<SIZE; j++)\n        memo[i][j].clear();\n     \n    used.clear();\n     \n    if(0==strcmp(line, \"#\")) break;\n    eval(0, strlen(line));\n    cout << memo[0][strlen(line)].size() << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) loop(i,0,n)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nint dx[]={-1,-1,0,0,1,1};\nint dy[]={0,-1,1,-1,1,0};\nconst int inf=1000000010;\nstring s;\nint t;\nvi f(){\n\tvvi in;\n\tstring w=\"\";\n\twhile(t<s.size()){\n\t\tif(s[t]=='('){\n\t\t\tt++;\n\t\t\tin.pb(f());\n\t\t\tt++;\n\t\t}else{\n\t\t\tint a=0;\n\t\t\twhile(t<s.size()&&isdigit(s[t])){\n\t\t\t\ta*=10;\n\t\t\t\ta+=s[t]-'0';\n\t\t\t\tt++;\n\t\t\t}\n\t\t\tin.pb({a});\n\t\t}\n\t\tif(s.size()==t)break;\n\t\tif(s[t]==')')break;\n\t\tw+=s[t];\n\t\tt++;\n\t}\n\tvi out;\n\tvi per(w.size());\n\trep(i,w.size())per[i]=i;\n\tdo{\n\t\tvvi tmp=in;\n\t\tvi used(w.size()+1);\n\t\trep(i,w.size()){\n\t\t\tint l=per[i],r=per[i]+1;\n\t\t\twhile(used[l])l--;\n\t\t\twhile(used[r])r++;\n\t\t\tvi nt;\n\n\t\t\trep(j,tmp[l].size())rep(k,tmp[r].size()){\n\t\t\t\tif(w[per[i]]=='+')nt.pb(tmp[l][j]+tmp[r][k]);\n\t\t\t\tif(w[per[i]]=='-')nt.pb(tmp[l][j]-tmp[r][k]);\n\t\t\t\tif(w[per[i]]=='*')nt.pb(tmp[l][j]*tmp[r][k]);\n\t\t\t\tif(tmp[r][k]&&w[per[i]]=='/')nt.pb(tmp[l][j]/tmp[r][k]);\n\t\t\t}\n\t\t\tused[l]=true;\n\t\t\ttmp[l]=vi(0);\n\t\t\ttmp[r]=nt;\n\t\t}\n\t\trep(j,tmp.size()){rep(i,tmp[j].size())out.pb(tmp[j][i]);}\n\t}while(next_permutation(all(per)));\n\tsort(all(out));\n\tout.erase(unique(all(out)),out.end());\n\n\treturn out;\n}\nint main(){\n\twhile(cin>>s,s!=\"#\"){\n\t\tt=0;\n\t\tcout<<f().size()<<endl;\n\t}\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nset<string> S;\nmap<string,bool> memo;\n\n// a op b の計算結果を返す. (a と b は '0'-'9', c は '+' or '-' or '*' or '/' )\nstring operate(char a, char op, char b){\n\tstring result;\n\tif( op == '+' ){\n\t\tint c = (a - '0') + (b - '0');\n\t\tif( c >= 10 ) result.push_back('1');\n\t\tresult.push_back((c % 10) + '0');\n\t}else if( op == '-' ){\n\t\tint c = (a - '0') - (b - '0');\n\t\tif( c < 0 ){\n\t\t\tresult.push_back('-');\n\t\t\tc *= -1;\n\t\t}\n\t\tresult.push_back((c % 10) + '0');\n\t}else if( op == '*' ){\n\t\tint c = (a - '0') * (b - '0');\n\t\tif( c >= 10 ) result.push_back( (c/10) + '0' );\n\t\tresult.push_back((c % 10) + '0');\n\t}else if( op == '/' ){\n\t\tif( b != '0' ){\n\t\t\tint c = (a - '0') / (b - '0');\n\t\t\tresult.push_back((c % 10) + '0');\n\t\t}\n\t}\n\treturn result;\n}\n\nbool is_op(char op){\n\treturn  (op == '+' || op == '-' || op == '*' || op == '/');\n}\n\nbool is_digit(char a){\n\treturn ('0' <= a && a <= '9');\n}\n\nbool check(char a, char op, char b){\n\treturn (is_digit(a) && is_digit(b) && is_op(op) );\n}\n\nbool is_number(string s){\n\tif( s[0] == '-' ){\n\t\tfor(int i=1 ; i < s.size() ; i++ ){\n\t\t\tif( !is_digit(s[i]) ) return false;\n\t\t}\n\t}else{\n\t\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\t\tif( !is_digit(s[i]) ) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid solve(string ex){\n\tif( is_number(ex) ){\n\t\tif( ex == \"-0\" ) ex = \"0\";\n\t\tS.insert( ex );\n\t\treturn ;\n\t}\n\tmemo[ex] = true;\n\tfor(int i=2 ; i < ex.size() ; i++ ){\n\t\tif( check(ex[i-2], ex[i-1], ex[i]) ){\n\t\t\tif( ex[i-1] == '+' || ex[i-1] == '-' ){\n\t\t\t\tif( i-3 >= 0 && i+1 < ex.size() && ex[i-3] == '(' && ex[i+1] == ')' ){\n\t\t\t\t\tstring s = operate(ex[i-2], ex[i-1], ex[i]);\n\t\t\t\t\tif( s.empty() ) continue;\n\t\t\t\t\tstring next;\n\t\t\t\t\tfor(int j=0 ; j < i-3 ; j++ ){\n\t\t\t\t\t\tnext.push_back( ex[j] );\n\t\t\t\t\t}\n\t\t\t\t\tnext += s;\n\t\t\t\t\tfor(int j=i+2 ; j < ex.size() ; j++ ){\n\t\t\t\t\t\tnext.push_back( ex[j] );\n\t\t\t\t\t}\n\t\t\t\t\t// cout << \"ex : \" << next << endl;\n\t\t\t\t\tif( !memo.count(next) ) solve( next );\n\t\t\t\t}else{\n\t\t\t\t\tstring s = operate(ex[i-2], ex[i-1], ex[i]);\n\t\t\t\t\tif( s.empty() ) continue;\n\t\t\t\t\tstring next;\n\t\t\t\t\tfor(int j=0 ; j < i-2 ; j++ ){\n\t\t\t\t\t\tnext.push_back( ex[j] );\n\t\t\t\t\t}\n\t\t\t\t\tnext += s;\n\t\t\t\t\tfor(int j=i+1 ; j < ex.size() ; j++ ){\n\t\t\t\t\t\tnext.push_back( ex[j] );\n\t\t\t\t\t}\n\t\t\t\t\t// cout << \"ex : \" << next << endl;\n\t\t\t\t\tif( !memo.count(next) ) solve( next );\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tstring s = operate(ex[i-2], ex[i-1], ex[i]);\n\t\t\t\tif( s.empty() ) continue;\n\t\t\t\tstring next;\n\t\t\t\tfor(int j=0 ; j < i-2 ; j++ ){\n\t\t\t\t\tnext.push_back( ex[j] );\n\t\t\t\t}\n\t\t\t\tnext += s;\n\t\t\t\tfor(int j=i+1 ; j < ex.size() ; j++ ){\n\t\t\t\t\tnext.push_back( ex[j] );\n\t\t\t\t}\n\t\t\t\t// cout << \"ex : \" << next << endl;\n\t\t\t\tif( !memo.count(next) ) solve( next );\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstring ex;\n\twhile( cin >> ex ){\n\t\tif( ex == \"#\" ) break;\n\t\tS.clear();\n\t\tmemo.clear();\n\t\tsolve( ex );\n\t\tcout << S.size() << endl;\n\t\t/* for(set<string>::iterator it = S.begin() ; it != S.end() ; ++it ){\n\t\t\tcout << *it << endl;\n\t\t}*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nstring s;\nint p;\nset<int> number(){\n  int res = 0;\n  while(p < s.size() && isdigit(s[p])){\n    res = res * 10 + (s[p] - '0');\n    p += 1;\n  }\n  set<int> ret;\n  ret.insert(res);\n  return ret;\n}\nset<int> calc(set<int> n1, set<int> n2, char ope){\n  set<int> res;\n  FORIT(it1, n1)FORIT(it2, n2){\n    int x = *it1, y = *it2;\n    if(ope == '+') res.insert(x+y);\n    else if(ope == '-') res.insert(x-y);\n    else if(ope == '*') res.insert(x*y);\n    else if(ope == '/' && y != 0){\n      res.insert(abs(x)/abs(y) * ((x * y > 0)?1:-1));\n    }\n  }\n  return res;\n}\n\nset<int> expr(){\n  vector< set<int> > nums;\n  vector< char > opes;\n  while(p < s.size() && s[p] != ')'){\n    set<int> cal;\n    if(s[p] == '('){\n      p += 1;\n      cal = expr();\n      p += 1;\n    }else{\n      cal = number();\n    }\n    nums.push_back(cal);\n    if(p < s.size() && s[p] != ')'){\n      char ope = s[p++];\n      opes.push_back(ope);\n    }\n  }\n  assert(nums.size() == opes.size() + 1);\n  vector<int> per(opes.size());\n  REP(i, per.size()) per[i] = i;\n  set<int> res;\n  do{\n    bool used[11] = {};\n    vector< set<int> > tnums = nums;\n    REP(i, per.size()){\n      int t = per[i];\n      int cnt = 0;\n      REP(j, t) cnt += used[j];\n      cnt = t - cnt;\n      used[t] = true;\n      set<int> num1 = tnums[cnt], num2 = tnums[cnt+1];\n      vector< set<int> >::iterator it = tnums.begin() + cnt;\n      it = tnums.erase(it);\n      it = tnums.erase(it);\n      set<int> result = calc(num1, num2, opes[t]);\n      tnums.insert(it, result);\n    }\n    FORIT(it, tnums[0]) res.insert(*it);\n  }while(next_permutation(per.begin(), per.end()));\n  return res;\n}\nint main(){\n\twhile(cin>>s && s!=\"#\"){\n    p = 0;\n    set<int> ans = expr();\n    debug(ans.begin(), ans.end());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <set>\n#include <vector>\nusing namespace std;\n\nstring str;\n\nvoid calc(char op, const set<int> a, const set<int> b, set<int>& dest) {\n    for (const int v : a) {\n        for (const int w : b) {\n            if (op == '/' && w == 0) continue;\n            dest.insert(\n                op == '+' ? v + w :\n                op == '-' ? v - w :\n                op == '*' ? v * w :\n                            v / w\n            );\n        }\n    }\n}\n\nset<int> solve(int start, int end) {\n    vector<set<int>> nums;\n    vector<char> ops;\n    for (int idx = start; idx < end;) {\n        if (str[idx] == '(') {\n            int idx_ = idx+1;\n            while (str[idx_] != ')') ++idx_;\n            set<int> t = solve(idx+1, idx_);\n            nums.emplace_back(t);\n            idx = idx_ + 1;\n        } else if (isdigit(str[idx])) {\n            int acc = 0;\n            while (idx < end && isdigit(str[idx])) {\n                acc = 10 * acc + (str[idx] - '0');\n                ++idx;\n            }\n            nums.push_back(set<int>{acc});\n        } else {\n            ops.push_back(str[idx++]);\n        }\n    }\n\n    int L = nums.size();\n    vector<vector<set<int>>> vs(nums.size());\n    for (int j = 0; j < L; ++j) {\n        vs[j].resize(L+1);\n        vs[j][j+1] = nums[j];\n    }\n\n    for (int w = 2; w <= L; ++w) {\n        for (int j = 0; j+w <= L; ++j) {\n            set<int> res;\n            for (int k = j+1; k < j+w; ++k) {\n                calc(ops[k-1], vs[j][k], vs[k][j+w], res);\n            }\n            vs[j][j+w] = res;\n        }\n    }\n\n    return vs[0][L];\n}\n\n\nint main() {\n    while (true) {\n        cin >> str;\n        if (str == \"#\") break;\n        cout << solve(0, str.size()).size() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype>\n#include <set>\n#include <tuple>\nusing namespace std;\ntypedef string::const_iterator State;\nclass ParseError {};\n\n\nenum Operator { add, sub, mul, divi, fac, integer };\n\nstruct Node{\n    int num;\n    Operator op;\n    vector<Node> children;\n    Node(int n){\n        num=n;\n        op=integer;\n    }\n    Node(Operator o){\n        num=-1;\n        op=o;\n    }\n};\n\nint number(State &begin) {\n    int ret=0;\n    while(isdigit(*begin)) ret=ret*10+*begin++-'0';\n    // cout<<ret<<endl;\n    return ret;\n}\n\nNode expr(State &begin){\n    Node node(fac);\n    while(true){\n        if(*begin=='('){\n            begin++;\n            node.children.push_back(expr(begin));\n            begin++;\n        }else if(*begin==')'){\n            return node;\n        }else if(isdigit(*begin)){\n            int n = number(begin);\n            node.children.push_back(Node(n));\n        }else if(*begin=='+'){\n            node.children.push_back(Node(add));\n            begin++;\n        }else if(*begin=='-'){\n            node.children.push_back(Node(sub));\n            begin++;\n        }else if(*begin=='*'){\n            node.children.push_back(Node(mul));\n            begin++;\n        }else if(*begin=='/'){\n            node.children.push_back(Node(divi));\n            begin++;\n        }else{\n            break;\n        }\n    }\n    return node;\n}\n\nset<int> dfs(Node &node){\n    set<int> ret;\n    if(node.op==integer){\n        ret.insert(node.num);\n        return ret;\n    }\n    int n = (node.children.size()+1)/2;\n    vector<tuple<int,Operator,set<int>>> V,VV;\n    for(int i=0;i<n;i++){\n        if(!i) VV.emplace_back(i,integer,dfs(node.children[2*i]));\n        else VV.emplace_back(i,node.children[2*i-1].op, dfs(node.children[2*i]));\n    }\n    /*\n    for(auto v:VV){\n        int i;\n        Operator op;\n        tie(i,op,ignore)=v;\n        cout<<i<<' ';\n        switch(op){\n            case add:\n                cout<<\"add \";\n                break;\n            case sub:\n                cout<<\"sub \";\n                break;\n            case mul:\n                cout<<\"mul \";\n                break;\n            case divi:\n                cout<<\"divi \";\n                break;\n            case fac:\n                cout<<\"fac \";\n                break;\n            case integer:\n                cout<<\"integer \";\n        }\n    }\n    cout<<endl;\n    */\n    // return ret;\n    vector<int> I(n-1);\n    for(int i=0;i<n-1;i++) I[i]=i+1;\n\n    do{\n        V=VV;\n        for(int i=0;i<I.size();i++){\n            for(int v=0;v<V.size();v++){\n                if(get<0>(V[v])==I[i]){\n                    set<int> &S1=get<2>(V[v-1]);\n                    set<int> &S2=get<2>(V[v]);\n                    set<int> S3;\n                    Operator op = get<1>(V[v]);\n                    for(auto s1:S1){\n                        for(auto s2:S2){\n                            switch(op){\n                                case add:\n                                    S3.insert(s1+s2);\n                                    break;\n                                case sub:\n                                    S3.insert(s1-s2);\n                                    break;\n                                case mul:\n                                    S3.insert(s1*s2);\n                                    break;\n                                case divi:\n                                    if(s2) S3.insert(s1/s2);\n                                    break;\n                                default:\n                                    cout<<\"!\"<<endl;\n                                    exit(1);\n                            }\n                        }\n                    }\n                    S1.clear();\n                    for(auto s3:S3) S1.insert(s3);\n                    V.erase(V.begin()+v);\n                    break;\n                }\n            }\n        }\n        for(auto s:get<2>(V.front())) ret.insert(s);\n    }while(next_permutation(I.begin(),I.end()));\n\n    return ret;\n}\n\nvoid dfs2(Node &node, int depth = 0){\n    cout<<string(depth,' ')<<\"num: \"<<node.num<<\" op: \";\n    switch(node.op){\n        case add:\n            cout<<\"add\"<<endl;\n            break;\n        case sub:\n            cout<<\"sub\"<<endl;\n            break;\n        case mul:\n            cout<<\"mul\"<<endl;\n            break;\n        case divi:\n            cout<<\"divi\"<<endl;\n            break;\n        case fac:\n            cout<<\"fac\"<<endl;\n            break;\n        case integer:\n            cout<<\"integer\"<<endl;\n    }\n    for(auto &c:node.children) dfs2(c,depth+1);\n}\n\nint main(){\n    while(true){\n        string S;\n        getline(cin, S);\n        if(S[0]=='#') break;\n        // cout<<S<<endl;\n        State begin = S.begin();\n        Node root = expr(begin);\n        //dfs2(root);\n        set<int> ans = dfs(root);\n        cout<<ans.size()<<endl;\n        // for(auto a:ans) cout<<a<<' ';\n        // cout<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <cctype>\n#include <vector>\n\nusing namespace std;\n\nstring S;\n\nbool is_op(char c)\n{\n    return (c == '+' || c == '-' || c == '*' || c == '/');\n}\n\nbool is_num(int L, int R)\n{\n    for (int i = L; i <= R; i++) {\n        if (!isdigit(S[i])) return 0;\n    }\n    return 1;\n}\n\nint num(int L, int R)\n{\n    int res = 0;\n    for (int i = L; i <= R; i++) {\n        res *= 10;\n        res += (S[i] - '0');\n    }\n    return res;\n}\n\nint near(int L, int R)\n{\n    int p = 0;\n    for (int i = L; i <= R; i++) {\n        if (S[i] == '(') p++;\n        if (S[i] == ')') p--;\n        if (p == 0) return i;\n    }\n    return -1;\n}\n\nset<int> expr(int L, int R)\n{\n    set<int> res;\n    \n    if (is_num(L, R)) return {num(L, R)};\n    \n    int nR = near(L, R);\n    if (nR == R && S[L] == '(' && S[R] == ')') {\n        return expr(L + 1, R - 1);\n    }\n    \n    for (int i = L; i <= R - 1; i++) {\n        char c = S[i];\n        \n        if (!is_op(c)) continue;        \n        \n        auto l = expr(L, i - 1);\n        auto r = expr(i + 1, R);\n        \n        for (int lv : l) {\n            for (int rv : r) {\n                switch (c) {\n                    case '+':\n                        res.insert(lv + rv);\n                        break;\n                    case '-':\n                        res.insert(lv - rv);\n                        break;\n                    case '*':\n                        res.insert(lv * rv);\n                        break;\n                    case '/':\n                        if (rv != 0) {\n                            res.insert(lv / rv);                            \n                        }                            \n                        break;\n                }\n            }\n        }\n    } \n    return res;\n}\n\nvoid solve()\n{\n    int N = S.size();\n    cout << expr(0, N - 1).size() << endl;\n}\n\nint main()\n{\n    while (cin >> S, S != \"#\") {\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#include <cstdlib>\n\nusing namespace std;\nstring s;\ntypedef set<int>::iterator sit;\n\nbool is_ope(char c){\n    return c == '+' || c == '-' || c == '*' || c == '/';\n}\n\nset<int> solve(int l, int r){\n    int par = 0;\n    bool found = 0;\n    set<int> result;\n\n    for(int i=l; i<r; i++){\n        if(s[i] == '(') par++;\n        if(s[i] == ')') par--;\n        if(par == 0 && is_ope(s[i])){\n            found = 1;\n            set<int> lhs = solve(l,i-1) , rhs = solve(i+1, r);\n            for(sit it = lhs.begin(); it != lhs.end(); ++it){\n                for(sit jt = rhs.begin(); jt != rhs.end(); ++jt){\n                    int ii = *it;\n                    int jj = *jt;\n                    if(s[i] == '+') result.insert(ii+jj);\n                    else if(s[i] == '-') result.insert(ii-jj);\n                    else if(s[i] == '*') result.insert(ii*jj);\n                    else if(s[i] == '/') result.insert(ii/jj);\n                }\n            }\n        }\n    }\n    if(!found){\n        if(s[l] == '(') return solve(l+1,r-1);\n        result.insert(atoi(s.substr(l, r-l+1).c_str()));\n    }\n    return result;\n}\n\nint main(){\n    while (cin >> s, s != \"#\"){\n        cout << solve(0, s.size()-1).size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint cur,cur2,num[11],perm[10];\nchar op[10];\nstring s;\n\nint digit(){\n\tassert(isdigit(s[cur]));\n\tint n=s[cur++]-'0';\n\treturn n;\n}\n\nset<int> number(){\n\tint n=digit();\n\twhile(cur<s.size()&&isdigit(s[cur]))n=n*10+digit();\n\tset<int> res;\n\tres.insert(n);\n\treturn res;\n}\n\nset<int> calc2(set<int> a,set<int> b,char c){\n\tset<int> res;\n\tset<int>::iterator it1;\n\tset<int>::iterator it2;\n\tfor(it1=a.begin();it1!=a.end();it1++)for(it2=b.begin();it2!=b.end();it2++){\n\t\tint n;\n\t\tif((*it2)==0&&c=='/')continue;\n\t\tif(c=='+')n=*it1+(*it2);\n\t\tif(c=='-')n=*it1-(*it2);\n\t\tif(c=='*')n=*it1*(*it2);\n\t\tif(c=='/')n=*it1/(*it2);\n\t\tres.insert(n);\n\t}\n\treturn res;\n}\n\nset<int> expression(){\n\tset<int> num[11];\n\tchar op[10];\n\tint no=0;\n\tif(s[cur]=='('){\n\t\tcur++;\n\t\tnum[no]=expression();\n\t\tcur++;\n\t}\n\telse num[no]=number();\n\twhile(cur<s.size()&&(s[cur]=='+'||s[cur]=='-'||s[cur]=='*'||s[cur]=='/')){\n\t\top[no++]=s[cur++];\n\t\tif(s[cur]=='('){\n\t\t\tcur++;\n\t\t\tnum[no]=expression();\n\t\t\tcur++;\n\t\t}\n\t\telse num[no]=number();\n\t}\n\tset<int> dp[11][11];\n\trep(i,no+1)dp[i][i]=num[i];\n\tfor(int i=1;i<=no;i++)rep(j,no-i+1){\n\t\trep(k,i){\n\t\t\tset<int> temp=calc2(dp[j][j+k],dp[j+k+1][j+i],op[j+k]);\n\t\t\tset<int>::iterator it;\n\t\t\tfor(it=temp.begin();it!=temp.end();it++)dp[j][j+i].insert(*it);\n\t\t}\n\t}\n\treturn dp[0][no];\n\t/*rep(i,no)perm[i]=i;\n\tdo{\n\t\tint p[10],rest=no,flag=0;\n\t\tchar o[10];\n\t\tset<int> n[11];\n\t\trep(i,no+1)n[i]=num[i];\n\t\trep(i,no)o[i]=op[i];\n\t\trep(i,no)p[i]=perm[i];\n\t\trep(i,no){\n\t\t\tset<int> a=n[p[i]],b=n[p[i]+1];\n\t\t\tchar c=o[p[i]];\n\t\t\tn[p[i]]=calc2(a,b,c);\n\t\t\tfor(int j=p[i]+1;j<rest;j++)n[j]=n[j+1];\n\t\t\tfor(int j=p[i];j<rest-1;j++)o[j]=o[j+1];\n\t\t\tfor(int j=i+1;j<no;j++)if(p[j]>=p[i])p[j]--;\n\t\t\trest--;\n\t\t}\n\t\tset<int>::iterator it;\n\t\tfor(it=n[0].begin();it!=n[0].end();it++)res.insert(*it);\n\t}while(next_permutation(perm,perm+no));\n\treturn res;*/\n}\n\n\nint main(){\n\tofstream o(\"tempDout.txt\");\n\twhile(cin>>s&&s!=\"#\"){\n\t\tcur=0;\n\t\tset<int> a;\n\t\tset<int>::iterator it;\n\t\to<<(a=expression()).size()<<endl;\n\t\tcout<<a.size()<<endl;\n\t\t//for(it=a.begin();it!=a.end();it++)cout<<*it<<\" \";cout<<endl;\n\t}\n}\n\t\t/*cur2=0;\n\t\tfill(num,num+11,0);\n\t\tfill(op,op+10,0);\n\t\tint N=expression();\n\t\trep(i,N)perm[i]=i;\n\t\tset<int> ans;\n\t\tdo{\n\t\t\tint n[11],p[10],rest=N,flag=0;\n\t\t\tchar o[10];\n\t\t\trep(i,N+1)n[i]=num[i];\n\t\t\trep(i,N)o[i]=op[i];\n\t\t\trep(i,N)p[i]=perm[i];\n\t\t\trep(i,N){\n\t\t\t\tint a=n[p[i]],b=n[p[i]+1];\n\t\t\t\tchar c=o[p[i]];\n\t\t\t\tif(b==0&&c=='/'){flag=1;break;}\n\t\t\t\tn[p[i]]=calc2(a,b,c);\n\t\t\t\tfor(int j=p[i]+1;j<rest;j++)n[j]=n[j+1];\n\t\t\t\tfor(int j=p[i];j<rest-1;j++)o[j]=o[j+1];\n\t\t\t\tfor(int j=i+1;j<N;j++)if(p[j]>=p[i])p[j]--;\n\t\t\t\trest--;\n\t\t\t}\n\t\t\tif(!flag)ans.insert(n[0]);\n\t\t}while(next_permutation(perm,perm+N));\n\t\tcout<<ans.size()<<endl;\n\t\tset<int>::iterator it;\n\t\tfor(it=ans.begin();it!=ans.end();it++)cout<<*it<<\" \";cout<<endl;\n\t}\n}*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) loop(i,0,n)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nint dx[]={-1,-1,0,0,1,1};\nint dy[]={0,-1,1,-1,1,0};\nconst int inf=1000000010;\nstring s;\nint t;\nvi f(){\n\tvvi in;\n\tstring w=\"\";\n\twhile(t<s.size()){\n\t\tif(s[t]=='('){\n\t\t\tt++;\n\t\t\tin.pb(f());\n\t\t\tt++;\n\t\t}else{\n\t\t\tint a=0;\n\t\t\twhile(t<s.size()&&isdigit(s[t])){\n\t\t\t\ta*=10;\n\t\t\t\ta+=s[t]-'0';\n\t\t\t\tt++;\n\t\t\t}\n\t\t\tin.pb({a});\n\t\t}\n\t\tif(s.size()==t)break;\n\t\tif(s[t]==')')break;\n\t\tw+=s[t];\n\t\tt++;\n\t}\n\tvi out;\n\tvi per(w.size());\n\trep(i,w.size())per[i]=i;\n\tdo{\n\t\tvvi tmp=in;\n\t\trep(i,w.size()){\n\t\t\tint l=per[i],r=per[i]+1;\n\t\t\twhile(tmp[l].size()==0)l--;\n\t\t\twhile(tmp[r].size()==0)r++;\n\t\t\tvi nt;\n//\t\t\trep(j,per.size())cout<<\" \"<<per[j];cout<<endl;\n\n\t\t\trep(j,tmp[l].size())rep(k,tmp[r].size()){\n\t\t\t\tif(w[per[i]]=='+')nt.pb(tmp[l][j]+tmp[r][k]);\n\t\t\t\tif(w[per[i]]=='-')nt.pb(tmp[l][j]-tmp[r][k]);\n\t\t\t\tif(w[per[i]]=='*')nt.pb(tmp[l][j]*tmp[r][k]);\n\t\t\t\tif(tmp[r][k]&&w[per[i]]=='/')nt.pb(tmp[l][j]/tmp[r][k]);\n\t\t\t}\n\t\t\ttmp[l]=vi(0);\n\t\t\ttmp[r]=nt;\n\t\t}\n\t\trep(j,tmp.size()){rep(i,tmp[j].size())out.pb(tmp[j][i]);}\n\t}while(next_permutation(all(per)));\n\n\tsort(all(out));\n\tout.erase(unique(all(out)),out.end());\n\treturn out;\n}\nint main(){\n\twhile(cin>>s,s!=\"#\"){\n\t\tt=0;\n\t\tcout<<f().size()<<endl;\n\t}\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nset<int> dp[15][15];\nint num;\nbool used[15][15];\nvector<int> v;\nvoid dfs(string s,int l,int r){\n  //cout<<s<<\" \"<<l<<\"-\"<<r<<endl;\n  if(used[l][r]) return;\n  used[l][r]=1;\n  if(l+1==r){\n    dp[l][r].insert(v[l]);\n    return;\n  }\n  int op=0,cnt=0;\n  while(s.front()=='('&&s.back()==')'){\n    for(int i=1;i<(int)s.size()-1;i++){\n      if(s[i]=='(') op++;\n      if(s[i]==')') op--;\n      if(op<0) break;\n    }\n    if(op<0) break;\n    s.erase(s.begin());\n    s.pop_back();\n  }\n  op=0;\n  for(int i=0;i<(int)s.size();i++){\n    if(s[i]=='(') op++;\n    if(s[i]==')') op--;\n    if(isdigit(s[i])){\n      cnt++;\n      while(i<(int)s.size()&&isdigit(s[i])) i++;\n      i--;\n    }\n    if(op) continue;\n    if(s[i]=='+'||s[i]=='-'||s[i]=='*'||s[i]=='/'){\n      dfs(s.substr(0,i),l,l+cnt);\n      dfs(s.substr(i+1,s.length()-i-1),l+cnt,r);\n      for(int p:dp[l][l+cnt]){\n\tfor(int q:dp[l+cnt][r]){\n\t  if(s[i]=='+') dp[l][r].insert(p+q);\n\t  if(s[i]=='-') dp[l][r].insert(p-q);\n\t  if(s[i]=='*') dp[l][r].insert(p*q);\n\t  if(!q) continue;\n\t  if(s[i]=='/') dp[l][r].insert(p/q);\n\t}\n      }\n    }\n  }\n  //cout<<s<<\" \"<<l<<\"-\"<<r<<endl;\n  //for(auto i:dp[l][r]) cout<<i<<endl;\n}\nsigned main(){\n  string s;\n  while(cin>>s,s!=\"#\"){\n    //cout<<s<<\":\";\n    for(int i=0;i<15;i++)\n      for(int j=0;j<15;j++)\n\tdp[i][j].clear();\n    v.clear();\n    for(int i=0;i<(int)s.size();i++){\n      if(s[i]=='+') num++;\n      if(s[i]=='-') num++;\n      if(s[i]=='*') num++;\n      if(s[i]=='/') num++;\n      if(isdigit(s[i])){\n\tint tmp=0;\n\twhile(i<(int)s.size()&&isdigit(s[i])){\n\t  tmp=tmp*10+s[i]-'0';\n\t  i++;\n\t}\n\t//cout<<tmp<<endl;\n\tv.push_back(tmp);\n\ti--;\n      }\n    }\n    num=v.size();\n    memset(used,0,sizeof(used));\n    dfs(s,0,num);\n    //for(auto i:dp[0][num]) cout<<i<<endl;\n    cout<<dp[0][num].size()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\ntypedef pair<int,int> PI;\n#ifndef M_PI\nconst double M_PI=acos(-1);\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int(a.size()))\n#define F first\n#define S second\n\nint tx[]={1,0,-1,-1,0,1},ty[]={1,1,0,-1,-1,0};\n\nstring in;\nint pos;\n\nint number(){\n  int ret=0;\n  while(pos<SZ(in) && isdigit(in[pos]))ret=ret*10+in[pos++]-'0';\n  return ret;\n}\n\nset<int> expr(){\n  vector<pair<set<int>,int> >op;\n  set<int> ret;\n  if(in[pos]=='('){\n    ++pos;\n    ret=expr();\n  }else ret.insert(number());\n  \n  op.pb(mp(ret,0));\n  while(pos<in.size() && in[pos]!=')'){\n    op.pb(mp(set<int>(),in[pos++]));\n    set<int> tnum;\n    if(in[pos]=='('){\n      ++pos;\n      tnum=expr();\n    }else tnum.insert(number());\n    op.pb(mp(tnum,0));\n  }\n  ret.clear();\n  queue<vector<pair<set<int>,int> > >q;\n  q.push(op);\n  while(!q.empty()){\n    vector<pair<set<int>,int> > tnode=q.front();\n    q.pop();\n    if(SZ(tnode)==1){\n      FOR(iter,tnode[0].F)ret.insert(*iter);\n      continue;\n    }\n    int sz=SZ(tnode);\n    for(int i=1;i<sz;i+=2){\n      vector<pair<set<int>,int> >next;\n      for(int j=0;j<i-1;++j)next.pb(tnode[j]);\n      set<int> a=tnode[i-1].F,b=tnode[i+1].F;\n      set<int> nnum;\n      FOR(aiter,a){\n\tFOR(biter,b){\n\t  switch(tnode[i].S){\n\t  case '+':nnum.insert(*aiter+*biter);break;\n\t  case '-':nnum.insert(*aiter-*biter);break;\n\t  case '*':nnum.insert(*aiter*(*biter));break;\n\t  case '/':\n\t    if(*biter!=0){\n\t      if((ll)(*aiter)*(*biter)<0)nnum.insert(-(abs(*aiter)/(abs(*biter))));\n\t      else nnum.insert(*aiter/(*biter));\n\t    }\n\t    break;\n\t  }\n\t}\n      }\n      next.pb(mp(nnum,0));\n      for(int j=i+2;j<sz;j++)next.pb(tnode[j]);\n      q.push(next);\n    }\n  }\n  ++pos;\n  return ret;\n}\n\nmain(){\n  while(cin>>in,in!=\"#\"){\n    pos=0;\n    set<int> ans=expr();\n    cout<<ans.size()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <complex>\n#include <algorithm>\n//C\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n \n#define REP(i,x) for(int i = 0 ; i < (int)(x) ; i++)\n#define ALL(x) (x).begin(),(x).end()\n#define LL long long\n \nusing namespace std;\n\nstring str;\n\nvector<int> table;// ZqÌDæxðo¦Ä¨­zñ\nint N;// Zq\nint idx;// \\¶ðÍÌCfbNX\n// Zq»è\nbool isOp(char c){\n\treturn c=='+'||c=='-'||c=='*'||c=='/';\n}\n// ZqÉ¶ÄvZ\n// 0ÌÆ«ÉfalseðÔ·\npair<bool,int> calc(int a,int b,char op){\n\tif(op=='+')return make_pair(true,a+b);\n\tif(op=='-')return make_pair(true,a-b);\n\tif(op=='*')return make_pair(true,a*b);\n\tif(b==0)return make_pair(false,0);\n\treturn make_pair(true,a/b);\n}\n\npair<bool,int> expr(int depth){\n\tif(depth==N){\n\t\tif(str[idx]=='('){\n\t\t\tidx++;\n\t\t\tpair<bool,int> a=expr(0);\n\t\t\tidx++;\n\t\t\treturn a;\n\t\t}\n\t\telse{\n\t\t\tint num=0;\n\t\t\twhile(idx<str.size() && isdigit(str[idx])){\n\t\t\t\tnum=num*10+str[idx++]-'0';\n\t\t\t}\n\t\t\treturn make_pair(true,num);\n\t\t}\n\t}\n\telse{\n\t\tpair<bool,int> a=expr(depth+1);\n\t\tif(!a.first)\n\t\t\treturn a;\n\t\tif(idx<str.size() && isOp(str[idx]) && table[idx]==depth){\n\t\t\tchar op=str[idx++];\n\t\t\tpair<bool,int> b=expr(depth+1);\n\t\t\tif(!b.first) return b;\n\t\t\ta=calc(a.second,b.second,op);\n\t\t\tif(!a.first)return a;\n\t\t}\n\t\treturn a;\n\t}\n}\n\n\n\nint main()\n{\n\twhile(cin>>str && str!=\"#\"){\n\t\tvector<int> res;\n\t\t// ZqÌÊuðo¦Ä¨­\n\t\ttable.assign(str.size(),-1);\n\t\tvector<int> pos;\n\t\tREP(i,str.size())if(isOp(str[i]))pos.push_back(i);\n\t\tvector<int> perm;\n\t\tN = pos.size();\n\t\tREP(i,pos.size())perm.push_back(i);\n\t\t// next_permutationÅSTõ\n\t\tdo{\n\t\t\tREP(i,perm.size())table[pos[i]] = perm[i];\n\t\t\tidx=0;\n\t\t\tpair<bool,int> tmp = expr(0);\n\t\t\tif(tmp.first)res.push_back(tmp.second);\n\t\t}\n\t\twhile(next_permutation(ALL(perm)));\n\t\t// ¯¶Êðí\n\t\tsort(ALL(res));\n\t\tres.erase(unique(ALL(res)),res.end());\n\n\t\tcout << res.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <cctype>\n#include <map>\n#include <set>\n#include <sstream>\nusing namespace std;\n\nstring s;\n\n//typedef string::const_iterator State;\ntypedef vector<int>::iterator State;\n\nint expression(State&);\nint term(State&);\nint number(State&);\nint factor(State&);\n\nint expression(State &begin){\n  int ret = term(begin);\n  while(1){\n    if(*begin == -3){\n      begin++;\n      ret += term(begin);\n    }\n    else if(*begin == -4){\n      begin++;\n      ret -= term(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\n\nint term(State &begin){\n  int ret = factor(begin);\n  while(1){\n    if(*begin == -5){\n      begin++;\n      ret *= factor(begin);\n    }\n    else if(*begin == -6){\n      begin++;\n      int tmp = factor(begin);\n      if(tmp == 0) throw \"\";\n      ret /= tmp;\n    }\n    else break;\n  }\n  return ret;\n}\n\nint number(string::iterator &begin){\n  int ret = 0;\n  while(isdigit(*begin)){\n    ret *= 10;\n    ret += *begin-'0';\n    begin++;\n  }\n  return ret;\n}\n\nint factor(State &begin){\n  if(*begin == -1){\n    begin++;\n    int ret = expression(begin);\n    begin++;\n    return ret;\n  }\n  \n  else return *(begin++);\n}\n\nint main(){\n  map<char, char> conv;\n  map<char, int> conv2;\n  conv2['('] = -1;\n  conv2[')'] = -2;\n  conv2['+'] = -3;\n  conv2['-'] = -4;\n  conv2['*'] = -5;\n  conv2['/'] = -6;\n  \n  map<int, char> conv3;\n  conv3[-1] = '(';\n  conv3[-2] = ')';\n  conv3[-3] = '+';\n  conv3[-4] = '-';\n  conv3[-5] = '*';\n  conv3[-6] = '/';\n  \n  \n  while(cin >> s){\n    if(s == \"#\") break;\n    set<int> used;\n    vector<string> value;\n    int op_size=0;\n    vector<int> op; \n    vector<int> val;\n    for(string::iterator it = s.begin() ; it != s.end() ; it++){\n      if(isdigit(*it)){\n\tval.push_back(number(it));\n\tit--;\n      }\n      else if(*it == '+' || *it == '-' || *it == '*' || *it == '/'){\n\tint tt = -8-op_size;\n\top.push_back(tt);\n\tconv[tt] = conv2[*it];\n\tval.push_back(tt);\n\top_size++;\n      }\n      else val.push_back(conv2[*it]);\n      }\n            \n    sort(op.begin(), op.end());\n\n      do{\n\tvector<int> tmp = val;\n\tfor(int i = 0 ; i < op.size() ; i++){\n\t  int pos = find(tmp.begin(), tmp.end(), op[i])-tmp.begin();\n\t  int cnt = 0;\n\t  \n\t  for(int j = pos-1 ; j >= 0 ; j--){\n\t    if(tmp[j] == -2){\n\t      cnt++;\n\t    }\n\t    if(tmp[j] == -1){\n\t      if(cnt == 0){\n\t\ttmp.insert(tmp.begin()+j, -1);\n\t\tbreak;\n\t      }\n\t      else{\n\t\tcnt--;\n\t      }\n\t    }\n\t   \n\t    if(cnt == 0 && tmp[j] <= -8){\n\t      tmp.insert(tmp.begin()+j+1, -1);\n\t      break;\n\t    }\n\t    if(j == 0) tmp.insert(tmp.begin(), -1);\n\t  }\n\t  \n\t  for(int j = pos+2 ; j < tmp.size() ; j++){\n\t    if(tmp[j] == -1){\n\t      cnt++;\n\t    }\n\t    if(tmp[j] == -2){\n\t      if(cnt == 0){\n\t\ttmp.insert(tmp.begin()+j, -2);\n\t\tbreak;\n\t      }\n\t      else{\n\t\tcnt--;\n\t      }\n\t    }\n\t    if(cnt == 0 && tmp[j] <= -8){\n\t      tmp.insert(tmp.begin()+j, -2);\n\t      break;\n\t    }\n\t    if(j == tmp.size()-1){\n\t      tmp.insert(tmp.begin()+tmp.size(), -2);\n\t      break;\n\t    }\n\t  }\n\t}\n\t\n\tfor(int i = 0 ; i < tmp.size() ; i++){\n\t  if(tmp[i] <= -8) tmp[i] = conv[tmp[i]];\n\t}\n\t\n\tState Tbegin = tmp.begin();\n\tint t;\n\ttry{\n\t  t = expression(Tbegin);\n\t  \n\t  used.insert(t);\n\t}catch(const char* str){\n\t}\n      }while(next_permutation(op.begin(), op.end()));\n      \n      cout << used.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nconst int N = 200;\nbool ok[N][N];\nset<int> dp[N][N];\n\n\n\nstring s;\nset<int> calc(int l, int r){\n\tif (ok[l][r]) return dp[l][r];\n\tok[l][r] = 1;\n\tauto &res = dp[l][r];\n\n\tint nest = 0;\n\tbool ope = false;\n\tfor (int i = l; i < r; ++i){\n\t\tif (s[i] == '(') ++nest;\n\t\telse if (s[i] == ')') --nest;\n\t\telse if (!nest && s[i] < '0' || s[i] > '9'){\n\t\t\tope = true;\n\t\t\tauto L = calc(l, i), R = calc(i+1, r);\n\t\t\tfor (auto e1 : L){\n\t\t\t\tfor (auto e2 : R){\n\t\t\t\t\tif (s[i] == '+') res.insert(e1 + e2);\n\t\t\t\t\tif (s[i] == '-') res.insert(e1 - e2);\n\t\t\t\t\tif (s[i] == '*') res.insert(e1 * e2);\n\t\t\t\t\tif (s[i] == '/' && e2) res.insert(e1 / e2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ope){\n\t\tif (s[l] == '(' && s[r - 1] == ')') res = calc(l + 1, r - 1);\n\t\telse res.insert(stoi(s.substr(l, r - l)));\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile (cin >> s, s != \"#\"){\n\t\tint n = s.size();\n\t\tmemset(ok, 0, sizeof(ok));\n\t\tfor (int i = 0; i < N; ++i) for (int j = 0; j < N; ++j) dp[i][j].clear();\n\t\tcout << calc(0, n).size() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <set>\nusing namespace std;\n\nchar memo[16][16];\nset<int> dp[16][16];\nvector<int> op, ol;\nconst char *exp;\n\nset<int> &dfs(int s, int e, int sp, int ep, int lv){\n\tset<int> &res = dp[s][e];\n\tif(memo[s][e]){\n\t\treturn res;\n\t}\n\tres.clear();\n\n\tmemo[s][e] = 1;\n\n\tfor(bool need = true; need; ){\n\t\tneed = (exp[sp] == '(' && exp[ep - 1] == ')');\n\t\tfor(int i = s + 1; i < e; ++i){\n\t\t\tif(ol[i] == lv){\n\t\t\t\tneed = false;\n\t\t\t}\n\t\t}\n\t\tif(need){\n\t\t\t++sp;\n\t\t\t--ep;\n\t\t\t++lv;\n\t\t}\n\t}\n\n\tif(s + 1 == e){\n\t\tres.insert(strtol(exp + sp, 0, 10));\n\t}\n\telse{\n\t\tfor(int i = s + 1; i < e; ++i){\n\t\t\tif(ol[i] == lv){\n\t\t\t\tchar c = exp[op[i]];\n\t\t\t\tset<int> &t = dfs(s, i, sp, op[i], lv);\n\t\t\t\tset<int> &u = dfs(i, e, op[i] + 1, ep, lv);\n\t\t\t\tset<int>::iterator it1, it2;\n\t\t\t\tfor(it1 = t.begin(); it1 != t.end(); ++it1)\n\t\t\t\tfor(it2 = u.begin(); it2 != u.end(); ++it2){\n\t\t\t\t\tswitch(c){\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\tres.insert(*it1 + *it2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\tres.insert(*it1 - *it2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\tres.insert(*it1 * *it2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '/':\n\t\t\t\t\t\tif(*it2){\n\t\t\t\t\t\t\tres.insert(*it1 / *it2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main(){\n\tstring s;\n\twhile(getline(cin, s), s[0] != '#'){\n\t\tmemset(memo, 0, sizeof memo);\n\t\top.assign(1, -1);\n\t\tol.assign(1, 0);\n\t\tint lv = 1;\n\t\tint len = s.size();\n\t\t\n\t\texp = s.c_str();\n\t\tfor(int i = 0; i < len; ++i){\n\t\t\tif(s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/'){\n\t\t\t\top.push_back(i);\n\t\t\t\tol.push_back(lv);\n\t\t\t}\n\t\t\telse if(s[i] == '('){\n\t\t\t\t++lv;\n\t\t\t}\n\t\t\telse if(s[i] == ')'){\n\t\t\t\t--lv;\n\t\t\t}\n\t\t}\n\t\top.push_back(len);\n\t\tol.push_back(0);\n\t\tint ans = dfs(0, op.size() - 1, 0, len, 1).size();\n\t\tcout << ans << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nconst int INF = 1e9+100;\n\nbool isnum(char c){\n  return '0' <= c && c <= '9';\n}\n\nbool isop(char c){\n  const string op = \"+*-/\";\n  return op.find(c) != string::npos;\n}\n\nint find_paren(const string& s, int i){\n  int cnt = 0;\n  for(;i<SZ(s);++i){\n\tif(s[i] == '(') ++cnt;\n\telse if(s[i] == ')')\n\t  if(--cnt == 0) return i;\n  }\n  return -1;\n}\n\nset<int> eval(const string& s){\n  VS terms;\n  vector<char> ops;\n  string term;\n  for(int i=0;i<SZ(s);++i){\n\tif(isnum(s[i]))\n\t  term += string(1,s[i]);\n\telse if(s[i] == '('){\n\t  if(!term.empty()){\n\t\t//cout << term << endl;\n\t\tterms.PB(term);\n\t  }\n\t  int j = find_paren(s, i);\n\t  term = s.substr(i, j-i+1);\n\t  i = j;\n\t}\n\telse{\n\t  if(!term.empty()){\n\t\t//cout << term << endl;\n\t\tterms.PB(term);\n\t  }\n\t  term = \"\";\n\t  ops.PB(s[i]);\n\t}\n  }\n  if(!term.empty())\n\tterms.PB(term);\n\n  set<int> res;\n  if(ops.empty()){\n\tif(terms[0][0] == '(')\n\t  return eval(terms[0].substr(1, SZ(terms[0])-2));\n\telse\n\t  res.insert(atoi(terms[0].c_str()));\n  }\n  else{\n\tfor(int i=0;i<SZ(ops);++i){\n\t  string lhs;\n\t  for(int j=0;j<=i;++j){\n\t\tif(j != 0) lhs += ops[j-1];\n\t\tlhs += terms[j];\n\t  }\n\t  set<int> l = eval(lhs);\n\t  string rhs;\n\t  for(int j=i+1;j<SZ(terms);++j){\n\t\tif(j != i+1) rhs += ops[j-1];\n\t\trhs += terms[j];\n\t  }\n\t  set<int> r = eval(rhs);\n\t  for(int lx: l){\n\t\tfor(int rx: r){\n\t\t  int x;\n\t\t  switch(ops[i]){\n\t\t  case '+': x = lx+rx; break;\n\t\t  case '-': x = lx-rx; break;\n\t\t  case '*': x = lx*rx; break;\n\t\t  case '/': x = (rx != 0? lx/rx: INF); break;\n\t\t  }\n\t\t  if(x != INF) res.insert(x);\n\t\t}\n\t  }\n\t}\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  string expr;\n  while(cin>>expr,expr!=\"#\"){\n\t//\tcout<<expr<<endl;\n\tcout << SZ(eval(expr)) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar S[211];\n\nset<int> solve(int l,int r);\n\nvoid view( set<int> b ){\n  cout << \"view\" << endl;\n  for( set<int>::iterator it = b.begin(); it != b.end(); it++)\n    cout << *it << \" \";\n  cout << endl;\n}\n\nint check(int l,int r){\n  int k = 0;\n  for(int i=l;i<=r;i++){\n    if( !isdigit(S[i]) ) return -1;\n    k*=10;\n    k+=(S[i]-'0');\n  }\n  return k;\n}\n\nset<int> calc(set<int> a,set<int> b,char c){\n  set<int> ret;\n  for( set<int>::iterator it = a.begin(); it != a.end(); it++){\n    for( set<int>::iterator jt = b.begin(); jt != b.end(); jt++){\n      if( c == '+' ){\n\tret.insert( *it + *jt );\n      } else if( c== '-' ){\n\tret.insert( *it - *jt );\n      } else if( c== '*' ){\n\tret.insert( *it * *jt );\n      } else {\n\tif( *jt == 0 ) continue;\n\tret.insert( *it / *jt );\n      }\n    }\n  }\n  return ret;\n}\n\nset<int> check2(int l,int r){\n  int cnt = 0;\n  set<int> a,b;\n  int nc = -1;\n  for(int i=l;i<=r;i++){\n    if( S[i] == '(' ){\n      cnt++;\n    } else if (S[i] == ')' ){\n      cnt--;\n    }\n    else if( cnt == 0  && ( S[i] == '+' || S[i] == '-' || S[i] == '*' || S[i] == '/' )){\n      a = calc( solve(l,i-1), solve(i+1,r), S[i]);\n      nc = i;\n      break;\n    }\n  }\n  cnt = 0;  \n  for(int i=r;i>=l;i--){\n    if( S[i] == ')' ){\n      cnt++;\n    } else if (S[i] == '(' ){\n      cnt--;\n    }\n    else if( cnt == 0  && ( S[i] == '+' || S[i] == '-' || S[i] == '*' || S[i] == '/' )){\n      if( nc == i ) break;\n      b = calc( solve(l,i-1), solve(i+1,r), S[i]);\n      break;\n    }\n  }\n  //  cout << l << \" \"<< r << endl;\n  //view(a);\n  if( b.empty() ) return a;\n  // view(b);\n  for( set<int>::iterator it = b.begin(); it != b.end(); it++)\n    a.insert( *it );\n\n\n  return a;\n}\n\nset<int> solve(int l,int r){\n  if( S[l] == '(' && S[r] == ')' )\n    return solve(l+1,r-1);\n  \n  int tmp = check(l,r);\n  if( tmp>-1 ){\n    //cout << l << \" \"<< r << \" \" << tmp << endl;\n    set<int> s; s.insert(tmp);\n    return s;\n  }\n  \n  return check2(l,r);\n}\n\n\nint main(){\n  while( cin >> S ){\n    if( S[0] == '#' ) break;\n    set<int> res = solve(0,strlen(S)-1);\n    cout << res.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<vector<int>,vector<char> > P;\n\nstring str;\nmap<P, vector<int> > m;\n\nint calc(int a, int b, char c){\n\tif(c == '+') return a+b;\n\tif(c == '*') return a*b;\n\tif(c == '-') return a-b;\n\tif(b == 0){\n\t\treturn MOD;\n\t} else if(b > 0){\n\t\treturn a/b;\n\t}\n}\n\nvector<int> fu(vector<int> v, vector<char> c){\n\tif(m[P(v,c)].size() > 0) return m[P(v,c)];\n\tvector<int> ret;\n\tif(c.size() == 0){\n\t\tret.push_back(v[0]);\n\t\tm[P(v,c)] = ret;\n\t\treturn ret;\n\t}\n\tvector<int> V;\n\tvector<char> C;\n\trep(i,c.size()){\n\t\tV.clear();\n\t\tC.clear();\n\t\tbool ok = true;\n\t\trep(j,v.size()){\n\t\t\tif(i != j){\n\t\t\t\tV.push_back(v[j]);\n\t\t\t\tif(j != v.size()-1) C.push_back(c[j]);\n\t\t\t} else{\n\t\t\t\tint tmp = calc(v[j],v[j+1],c[j]);\n\t\t\t\tif(tmp == MOD){\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tV.push_back(tmp);\n\t\t\t\tif(j+1 != v.size()-1) C.push_back(c[j+1]);\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tif(!ok) continue;\n\t\tV = fu(V,C);\n\t\trep(j,V.size()) ret.push_back(V[j]);\n\t}\n\tm[P(v,c)] = ret;\n\treturn ret;\n}\n\nvector<int> fun(vector<vector<int> > v, vector<char> c, vector<int> z, int cnt){\n\tvector<int> x;\n\tif(v[cnt].size() == 0){\n\t\treturn fu(z,c);\n\t}\n\tvector<int> tmp;\n\trep(i,v[cnt].size()){\n\t\tz.push_back(v[cnt][i]);\n\t\ttmp.clear();\n\t\ttmp = fun(v,c,z,cnt+1);\n\t\trep(j,tmp.size()) x.push_back(tmp[j]);\n\t\tz.pop_back();\n\t}\n\treturn x;\n}\n\nvector<int> func(string s){\n\tint cont = 0;\n\tvector<vector<int> > v;\n\tv.resize(12);\n\tvector<char> c;\n\trep(i,s.size()){\n\t\tif(s[i] == '('){\n\t\t\tint cnt = 0;\n\t\t\tstring tmp;\n\t\t\twhile(true){\n\t\t\t\ti++;\n\t\t\t\tif(s[i] == '(') cnt++;\n\t\t\t\tif(s[i] == ')' && cnt == 0) break;\n\t\t\t\tif(s[i] == ')') cnt--;\n\t\t\t\ttmp.push_back(s[i]);\n\t\t\t}\n\t\t\tv[cont] = func(tmp);\n\t\t} else if('0' <= s[i] && s[i] <= '9'){\n\t\t\tv[cont].push_back(s[i]-'0');\n\t\t} else{\n\t\t\tc.push_back(s[i]);\n\t\t\tcont++;\n\t\t}\n\t}\n\tvector<int> z;\n\treturn fun(v, c, z, 0);\n}\n\nvoid solve(){\n\tm.clear();\n\tvector<int> v = func(str);\n\tsort(v.begin(),v.end());\n\tv.erase(unique(v.begin(),v.end()),v.end());\n\tcout << v.size() << endl;\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> str;\n\t\tif(str == \"#\") break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <cctype>\nusing namespace std;\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n\ntypedef string::const_iterator State;\nclass ParseError {};\nset<int> expression(State &begin);\n\n\nset<int> setunion(const set<int> &a, const set<int> &b){\n\tset<int> ret;\n\tFOR(it1, a) ret.insert(*it1);\n\tFOR(it2, b) ret.insert(*it2);\n\treturn ret;\n}\n\nset<int> calc(const set<int> &a, const set<int> &b, char op){\n\tset<int> ret;\n\tFOR(it1, a){\n\t\tFOR(it2, b){\n\t\t\tif(op == '+') ret.insert(*it1 + *it2);\n\t\t\tif(op == '-') ret.insert(*it1 - *it2);\n\t\t\tif(op == '*') ret.insert(*it1 * *it2);\n\t\t\tif(op == '/' && *it2) ret.insert(*it1 / *it2);\n\t\t}\n\t}\n\treturn ret;\n}\n\n// beginがexpectedを指していたらbeginを一つ進める。\nvoid consume(State &begin, char expected) {\n\tif (*begin == expected) {\n\t\tbegin++;\n\t} else {\n\t\tcerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n\t\tcerr << \"Rest string is '\";\n\t\twhile (*begin) {\n\t\t\tcerr << *begin++;\n\t\t}\n\t\tcerr << \"'\" << endl;\n\t\tthrow ParseError();\n\t}\n}\n\nint number(State &begin) {\n\tint ret = 0;\n\twhile (isdigit(*begin)) ret = ret*10 + *begin++ - '0';\n\treturn ret;\n}\n\nset<int> factor(State &begin) {\n\tset<int> ret;\n\tif (*begin == '(') {\n\t\tconsume(begin, '(');\n\t\tret = expression(begin);\n\t\tconsume(begin, ')');\n\t}else ret.insert(number(begin));\n\treturn ret;\n}\n\n\nset<int> expression(State &begin) {\n\tset<int> ret;\n\tset<int> tmp = factor(begin);\n\n\tfor (;;) {\n\t\tset<int> tmp2;\n\t\tif(*begin != '+' && *begin != '-' && *begin != '*' && *begin != '/') break;\n\t\tchar op = *begin++;\n\t\tState prev = begin;\n\t\tret = setunion(ret, calc(tmp, expression(begin), op));\n\t\tbegin = prev;\n\t\ttmp = calc(tmp, factor(begin), op);\n\t}\n\t\n\treturn setunion(ret, tmp);\n}\n\nint main(void) {\n\tint N;\n\tstring s;\n\twhile (getline(cin, s), s!=\"#\") {\n\t\tState begin = s.begin();\n\t\tcout << expression(begin).size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MP make_pair\n\ntypedef pair<int, int> PII;\n\nconst int SIZE = 210;\n\nchar line[SIZE], t[SIZE];\nset<int> memo[SIZE][SIZE];\nset<PII> used;\n \nvoid eval(int const l, int const r) {\n   \n  set<int>& ret = memo[l][r];\n  if(l == r) return;\n   \n  if(used.count(MP(l, r))) return;\n  used.insert(MP(l, r));\n   \n  // check is digits [l, r)\n  bool digits = true;\n  for(int i=l; i<r; i++) { digits = digits && isdigit(line[i]); }\n  strncpy(t, line+l, r-l); t[r-l+1] = 0;\n  if(digits) { ret.insert(atoi(t)); return; }\n   \n  int par = 0; bool check = true;\n  for(int i=l; i<r-1; i++) {\n    if(line[i] == '(') { par ++; }\n    if(line[i] == ')') { par --; }\n    if(par == 0) { check = false; }\n  }\n   \n  // \"(expr)\"\n  if(check) {\n    if(line[r-1] == ')') {\n      eval(l+1, r-1); ret = memo[l+1][r-1]; return;\n    }\n  }\n   \n  par = 0;\n  // parsing loop\n  for(int i=l; i<r; i++) {\n    if(line[i] == '(') { par ++; }\n    if(line[i] == ')') { par --; }\n    if(par != 0) continue;\n     \n    switch(line[i]) {\n    case '+': case '-': case '*': case '/': {\n      eval(l, i); eval(i+1, r);\n      set<int>::iterator iter_a, iter_b;\n      for(iter_a = memo[l][i].begin(); iter_a!=memo[l][i].end(); iter_a++) {\n        for(iter_b = memo[i+1][r].begin(); iter_b!=memo[i+1][r].end(); iter_b++) {\n          if(line[i] == '+') { ret.insert(*iter_a + *iter_b); }\n          if(line[i] == '-') { ret.insert(*iter_a - *iter_b); }\n          if(line[i] == '*') { ret.insert(*iter_a * *iter_b); }\n          if(line[i] == '/') {\n            if(*iter_b == 0) continue;\n            ret.insert(*iter_a / *iter_b);\n          }\n        }\n      }\n      break;\n    }\n    default:;\n    }\n  } // for parsing loop\n}\n \nint main() {\n   \n  while(1) {\n    scanf(\"%s\\n\", line);\n    for(int i=0; i<SIZE; i++)\n      for(int j=0; j<SIZE; j++)\n        memo[i][j].clear();\n     \n    used.clear();\n     \n    if(0==strcmp(line, \"#\")) break;\n    eval(0, strlen(line));\n    cout << memo[0][strlen(line)].size() << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RREP(i,x) for(int i=(x)-1;i>=0;i--)\n#define RFOR(i,c) for(auto i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(container) container.begin(), container.end()\n#define SZ(container) ((int)container.size())\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nstring s;\n\nvi calc(int p, int q){\n\tint bra = 0;\n\tif(s[p] == '('){\n\t\tint f = 1;\n\t\tfor(int i=p+1;i<q-1;i++){\n\t\t\tif(s[i] == '(') bra ++;\n\t\t\tif(s[i] == ')') bra --;\n\t\t\tif(bra < 0) f = 0;\n\t\t}\n\t\tif(f) return calc(p+1, q-1);\n\t}else{\n\t\tint f = 0;\n\t\tfor(int i=p;i<q;i++){\n\t\t\tif(!isalnum(s[i])){\n\t\t\t\tf = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf = f*10 + s[i] - '0';\n\t\t}\n\t\tif(f >= 0) return vi(1, f);\n\t}\n\tbra = 0;\n\tvi ret;\n\tfor(int i=p;i<q;i++){\n\t\tif(s[i] == '(') bra ++;\n\t\telse if(s[i] == ')') bra --;\n\t\telse if(!bra && !isalnum(s[i])){\n\t\t\tvi a = calc(p, i);\n\t\t\tvi b = calc(i+1, q);\n\t\t\tFOR(it, a)FOR(jt, b){\n\t\t\t\tif(s[i] == '+') ret.push_back(*it + *jt);\n\t\t\t\tif(s[i] == '-') ret.push_back(*it - *jt);\n\t\t\t\tif(s[i] == '*') ret.push_back(*it * *jt);\n\t\t\t\tif(s[i] == '/' && *jt) ret.push_back(*it / *jt);\n\t\t\t}\n\t\t}\n\t}\n\tsort(ALL(ret));\n\tret.erase( unique(ALL(ret)), ret.end() );\n\treturn ret;\n}\n\nmain(){\n\twhile(cin >> s, s!=\"#\"){\n\t\tcout << calc(0, s.size()).size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<cstdlib>\nusing namespace std;\n\nset<string> S;\n\nvoid cal(vector<string> V){\n  for(int i=1;i<V.size()-1;i++){\n    if(V[i-1]==\"(\" && V[i+1]==\")\"){\n      V.erase(V.begin()+i+1);\n      V.erase(V.begin()+i-1);\n    }\n  }\n  if(V.size()==1){\n    S.insert(V[0]);\n  }\n  else {\n    for(int i=0;i<V.size();i++){\n      if(V[i]==\"+\"){\n        if(V[i+1]==\"(\" || V[i-1]==\")\")continue;\n        int a=atoi(V[i-1].c_str())+atoi(V[i+1].c_str());\n\tstringstream ss;\n\tss << a;\n\tstring s=ss.str();\n        vector<string> v=V;\n        v.erase(v.begin()+i+1);\n        v.erase(v.begin()+i);\n\tv.erase(v.begin()+i-1);\n\tv.insert(v.begin()+i-1,s);\n\tcal(v);\n      }\n      if(V[i]==\"-\"){\n\tif(V[i+1]==\"(\" || V[i-1]==\")\")continue;\n        int a=atoi(V[i-1].c_str())-atoi(V[i+1].c_str());\n\tstringstream ss;\n\tss << a;\n\tstring s=ss.str();\n        vector<string> v=V;\n        v.erase(v.begin()+i+1);\n        v.erase(v.begin()+i);\n\tv.erase(v.begin()+i-1);\n\tv.insert(v.begin()+i-1,s);\n\tcal(v);\n      }\n      if(V[i]==\"*\"){\n\tif(V[i+1]==\"(\" || V[i-1]==\")\")continue;\n        int a=atoi(V[i-1].c_str())*atoi(V[i+1].c_str());\n\tstringstream ss;\n\tss << a;\n\tstring s=ss.str();\n        vector<string> v=V;\n        v.erase(v.begin()+i+1);\n        v.erase(v.begin()+i);\n\tv.erase(v.begin()+i-1);\n\tv.insert(v.begin()+i-1,s);\n\tcal(v);\n      }\n      if(V[i]==\"/\"){\n\tif(V[i+1]==\"(\" || V[i-1]==\")\")continue;\n\tif(V[i+1]==\"0\")return;\n        int a=atoi(V[i-1].c_str())/atoi(V[i+1].c_str());\n\tstringstream ss;\n\tss << a;\n\tstring s=ss.str();\n        vector<string> v=V;\n        v.erase(v.begin()+i+1);\n        v.erase(v.begin()+i);\n\tv.erase(v.begin()+i-1);\n\tv.insert(v.begin()+i-1,s);\n\tcal(v);\n      }\n    }\n  }\n}\n\nint main()\n{\n  string s;\n  while(1){\n    cin>>s;\n    if(s[0]=='#')break;\n    vector<string> V;\n    string samp;\n    for(int i=0;i<s.length();i++){\n      if('0'<=s[i] && s[i]<='9'){\n\tsamp+=s[i];\n\tif(i==s.length()-1)V.push_back(samp);\n      }\n      else {\n\tif(!samp.empty()){\n\t  V.push_back(samp);\n\t  samp=\"\";\n\t}\n\tsamp=s[i];\n\tV.push_back(samp);\n\tsamp=\"\";\n      }\n    }\n    S.clear();\n    cal(V);\n    cout<<S.size()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nset<int> SET;\n\nint calc(int a,int b,char op){\n\tswitch(op){\n\tcase '+':return a+b;\n\tcase '-':return a-b;\n\tcase '*':return a*b;\n\tcase '/':\n\t\tif(b == 0){\n\t\t\treturn BIG_NUM;\n\t\t}else{\n\t\t\treturn a/b;\n\t\t}\n\t}\n}\n\nbool is_op(char ch){\n\tif(ch == '+' || ch == '-' || ch == '*' || ch == '/'){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nbool is_num(char ch){\n\treturn ch >= '0' && ch <= '9';\n}\n\nvoid recursive(char equation[201],int length){\n\n\tstack<int> S;\n\n\t//演算可能な演算子を走査する(左右にカッコがあるものはSKIP)\n\tfor(int i = 0; i < length; i++){\n\t\tif(is_op(equation[i]) == true && equation[i+1] != '(' && equation[i-1] != ')'){\n\t\t\tS.push(i);\n\t\t}\n\t}\n\n\tif(S.empty()){ //計算できる演算子がない場合:SETに最終結果を突っ込む\n\t\tint number = 0;\n\t\tbool neg_FLG = false;\n\n\t\tfor(int i = 0; i < length; i++){\n\t\t\tif(equation[i] == '@'){ //マイナス\n\t\t\t\tneg_FLG = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnumber = 10*number+equation[i]-'0';\n\t\t}\n\t\tif(neg_FLG)number *= -1;\n\t\tSET.insert(number);\n\n\t\treturn;\n\t}\n\n\tint loc,left,right,left_num,start,right_num,new_num,index,num_length,index_2;\n\tbool left_neg_FLG,right_neg_FLG,new_num_neg_FLG;\n\n\tstack<int> WORK;\n\n\t//演算し、演算部を結果で置換する\n\twhile(!S.empty()){\n\t\tloc = S.top();\n\t\tS.pop();\n\n\t\tleft_neg_FLG = false;\n\t\t//左側の数字の開始位置を調べる\n\t\tfor(left = loc-1; left >= 0 && is_num(equation[left]) == true; left--);\n\t\tleft++;\n\t\tif(left > 0 && equation[left-1] == '@'){\n\t\t\tleft--; //演算部の左端をデクリメント\n\t\t\tleft_neg_FLG = true;\n\t\t}\n\n\t\tif(equation[loc+1] == '@'){\n\t\t\tright_neg_FLG = true;\n\t\t\tstart = loc+2;\n\t\t}else{\n\t\t\tright_neg_FLG = false;\n\t\t\tstart = loc+1;\n\t\t}\n\n\t\t//右側の数字の終了位置を調べる\n\t\tfor(right = start; right < length && is_num(equation[right]) == true; right++);\n\t\tright--;\n\n\t\t//左側の数字を計算する\n\t\tleft_num = 0;\n\t\tfor(int i = left; i < loc; i++){\n\t\t\tif(equation[i] == '@')continue;\n\t\t\tleft_num = 10*left_num+equation[i]-'0';\n\t\t}\n\t\tif(left_neg_FLG)left_num *= -1;\n\n\t\t//右側の数字を計算する\n\t\tright_num = 0;\n\t\tfor(int i = start; i <= right; i++){\n\t\t\tright_num = 10*right_num+equation[i]-'0';\n\t\t}\n\t\tif(right_neg_FLG)right_num *= -1;\n\n\t\t//演算\n\t\tnew_num = calc(left_num,right_num,equation[loc]);\n\n\t\tif(new_num == BIG_NUM)continue; //0割り発生\n\n\t\tif(new_num < 0){\n\t\t\tnew_num_neg_FLG = true;\n\t\t\tnew_num *= -1;\n\t\t}else{\n\t\t\tnew_num_neg_FLG = false;\n\t\t}\n\n\t\t//新しい数式を作る\n\t\tchar next_equation[201];\n\t\tindex = 0;\n\n\t\t//演算部の前まで\n\t\tfor(int i = 0; i < left; i++){\n\t\t\tnext_equation[index++] = equation[i];\n\t\t}\n\n\t\t//new_numを分解し、char型にする\n\t\tnum_length = 0;\n\n\t\tdo{\n\t\t\tWORK.push(new_num%10);\n\t\t\tnew_num /= 10;\n\t\t\tnum_length++;\n\n\t\t}while(new_num > 0);\n\n\t\tif(new_num_neg_FLG){ //結果が負の場合\n\t\t\tnext_equation[index++] = '@';\n\t\t\tnum_length++; //★★マイナスも数字長に含む★★\n\t\t}\n\n\t\twhile(!WORK.empty()){\n\t\t\tnext_equation[index++] = '0'+WORK.top();\n\t\t\tWORK.pop();\n\t\t}\n\n\t\t//演算部の右側\n\t\tfor(int i = right+1; i < length; i++){\n\t\t\tnext_equation[index++] = equation[i];\n\t\t}\n\t\tnext_equation[index] = '\\0';\n\n\t\t//★★今回の演算によって、演算子を含まない()ができれば、()を除去する\n\t\tif(next_equation[left-1] == '(' && next_equation[left+num_length] == ')'){\n\t\t\tindex_2 = 0;\n\t\t\tchar work_equation[201];\n\n\t\t\tfor(int i = 0; i < left-1; i++){\n\t\t\t\twork_equation[index_2++] = next_equation[i];\n\t\t\t}\n\t\t\tfor(int i = left; i < left+num_length; i++){\n\t\t\t\twork_equation[index_2++] = next_equation[i];\n\t\t\t}\n\t\t\tfor(int i = left+num_length+1; i < index; i++){\n\t\t\t\twork_equation[index_2++] = next_equation[i];\n\t\t\t}\n\n\n\t\t\tfor(int i = 0; i < index_2; i++){\n\t\t\t\tnext_equation[i] = work_equation[i];\n\t\t\t}\n\t\t\tindex = index_2;\n\t\t\tnext_equation[index] = '\\0';\n\t\t}\n\t\trecursive(next_equation,index);\n\t}\n}\n\n/*\n * 簡単のため、単項の-は@で表す\n * */\n\nint main(){\n\n\tint length,index;\n\tchar equation[201],work[201];\n\n\twhile(true){\n\t\tscanf(\"%s\",equation);\n\t\tif(equation[0] == '#')break;\n\n\t\tfor(length = 0; equation[length] != '\\0'; length++);\n\n\t\tbool op_FLG,other_FLG;;\n\t\t//演算子のないカッコを外す\n\t\tfor(int left = 0; left < length-1; left++){\n\t\t\tfor(int right = left+2; right < length; right++){\n\t\t\t\tif(equation[left] != '(' || equation[right] != ')')continue;\n\n\t\t\t\top_FLG = false;\n\t\t\t\tother_FLG = false;\n\t\t\t\tfor(int i = left+1; i < right; i++){ //left-right間に、他のカッコがあるか、演算子があるかを調べる\n\t\t\t\t\tif(is_op(equation[i])){\n\t\t\t\t\t\top_FLG = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(equation[i] == '(' || equation[i] == ')'){\n\t\t\t\t\t\tother_FLG = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(op_FLG)continue;\n\t\t\t\tif(other_FLG)continue;\n\n\t\t\t\t//()を消す\n\t\t\t\tequation[left] = '.';\n\t\t\t\tequation[right] = '.';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tindex = 0;\n\t\tfor(int i = 0; i < length; i++){\n\t\t\tif(equation[i] == '.')continue;\n\t\t\twork[index++] = equation[i];\n\t\t}\n\t\tfor(int i = 0; i < index; i++){\n\t\t\tequation[i] = work[i];\n\t\t}\n\t\tequation[index] = '\\0';\n\n\t\tlength = index;\n\n\t\tSET.clear();\n\t\trecursive(equation,length);\n\n\t\tprintf(\"%lld\\n\",SET.size());\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <tuple>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <string>\n#include <bitset>\n#include <set>\n\n#define FOR(i, a, b) for(int i = (int)a; i < (int)b; ++i)\n#define REP(i, n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\nusing ll = long long;\ntemplate <class T, class U> void CHMAX(T & a, const U & b) { if (a < b) a = b; }\ntemplate <class T, class U> void CHMIN(T& a, const U& b) { if (a > b) a = b; }\n\nconstexpr int INF = (1 << 30) - 1;\n\nusing State = std::string::iterator;\nstruct Node {\n\tstd::vector<Node> child;\n\tstd::vector<char> op;\n\tstd::vector<int> val;\n\n\tint num(State& it) {\n\t\tint res = 0;\n\t\twhile (std::isdigit(*it)) {\n\t\t\tres = res * 10 + (*it - '0');\n\t\t\t++it;\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid eval() {\n\t\tstd::vector<int> ps(child.size(), 0);\n\t\tstd::set<int> set;\n\n\t\twhile (true) {\n\t\t\tauto rec = [&](auto && f, std::vector<int> v, std::vector<char> c) -> void {\n\t\t\t\tif (c.empty()) {\n\t\t\t\t\tset.emplace(v[0]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tREP(i, c.size()) {\n\t\t\t\t\tif (c[i] == '/' && v[i + 1] == 0) continue;\n\t\t\t\t\tauto tv(v);\n\t\t\t\t\tauto tc(c);\n\t\t\t\t\tif (tc[i] == '+') tv[i] += tv[i + 1];\n\t\t\t\t\tif (tc[i] == '-') tv[i] -= tv[i + 1];\n\t\t\t\t\tif (tc[i] == '*') tv[i] *= tv[i + 1];\n\t\t\t\t\tif (tc[i] == '/') tv[i] /= tv[i + 1];\n\t\t\t\t\ttv.erase(tv.begin() + i + 1);\n\t\t\t\t\ttc.erase(tc.begin() + i);\n\t\t\t\t\tf(f, tv, tc);\n\t\t\t\t}\n\t\t\t};\n\t\t\tstd::vector<int> v(child.size());\n\t\t\tREP(i, child.size()) v[i] = child[i].val[ps[i]];\n\t\t\trec(rec, v, op);\n\n\t\t\tint p = ps.size() - 1;\n\t\t\twhile (p >= 0) {\n\t\t\t\t++ps[p];\n\t\t\t\tif (ps[p] == child[p].val.size()) {\n\t\t\t\t\tps[p] = 0;\n\t\t\t\t\t--p;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p < 0) break;\n\t\t}\n\t\tval.reserve(set.size());\n\t\tfor (auto& x : set) val.emplace_back(x);\n\t}\n\n\tNode(int n) {\n\t\tval.emplace_back(n);\n\t}\n\tNode(State& it) {\n\t\twhile (*it != '$' && *it != ')') {\n\t\t\tif (*it == '(') {\n\t\t\t\t++it;\n\t\t\t\tchild.emplace_back(it);\n\t\t\t}\n\t\t\telse if (std::isdigit(*it)) {\n\t\t\t\tchild.emplace_back(num(it));\n\t\t\t}\n\t\t\telse {\n\t\t\t\top.emplace_back(*it);\n\t\t\t\t++it;\n\t\t\t}\n\t\t}\n\t\t++it;\n\n\t\teval();\n\t}\n};\n\nsigned main() {\n\n\tstd::string s;\n\twhile (std::cin >> s, s != \"#\") {\n\t\ts += '$';\n\t\tauto it = s.begin();\n\t\tNode r(it);\n\t\tstd::cout << r.val.size() << std::endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef string::const_iterator state;\n\nint expression(state&);\n\nint number(state &begin){\n    int res=0;\n    while(isdigit(*begin)){\n        res*=10;\n        res+=*begin-'0';\n        ++begin;\n    }\n    return res;\n}\n\nint factor(state &begin){\n    if(*begin=='(' or *begin=='['){\n        begin++;\n        const int res=expression(begin);\n        begin++;\n        return res;\n    }else return number(begin);\n}\n\nint expression(state &begin){\n    int res=factor(begin);\n    if(res==inf) return inf;\n    while(true){\n        if(*begin=='+'){\n            ++begin;\n            res+=expression(begin);\n        }else if(*begin=='-'){\n            ++begin;\n            res-=expression(begin);\n        }else if(*begin=='*'){\n            ++begin;\n            res*=expression(begin);\n        }else if(*begin=='/'){\n            ++begin;\n            const int tmp=expression(begin);\n            if(tmp==0) return inf;\n            res/=tmp;\n        }else break;\n    }\n    return res;\n}\n\nvoid solve(){\n    while(true){\n        string str;\n        cin >> str;\n        if(str==\"#\") return;\n\n        set<int> res;\n        function<void(const string,const int,const int,const int)> rec=[&](const string s,const int idx,const int cnt1,const int cnt2){\n            if(cnt2<0) return;\n            if(idx==s.size()){\n                if(!cnt2){\n                    dump(s);\n                    auto begin=s.begin();\n                    const int res_=expression(begin);\n                    if(res_!=inf) res.insert(res_);\n                    dump(res_);\n                }\n                return;\n            }\n            if(s[idx]=='('){\n                rec(s,idx+1,cnt1+1,cnt2);\n                return;\n            }\n            if(s[idx]==')'){\n                if(cnt2) return;\n                rec(s,idx+1,cnt1-1,cnt2);\n                return;\n            }\n            if(cnt2<10 and isdigit(s[idx]) and (!idx or !isdigit(s[idx-1]))){\n                auto s_=s;\n                s_.insert(idx,\"[\");\n                rec(s_,idx,cnt1,cnt2+1);\n            }\n            if(!cnt1 and cnt2 and isdigit(s[idx]) and (idx+1==s.size() or !isdigit(s[idx+1]))){\n                bool ok=false;\n                for(int i=idx; s[i]!='[' ; --i){\n                    if(!isdigit(s[i])){\n                        ok=true;\n                        break;\n                    }\n                }\n                if(!ok){\n                    rec(s,idx+1,cnt1,cnt2);\n                    return;\n                }\n                auto s_=s;\n                if(idx+1==s.size()) s_+=\"]\";\n                else s_.insert(idx+1,\"]\");\n                rec(s_,idx+1,cnt1,cnt2-1);\n            }\n            rec(s,idx+1,cnt1,cnt2);\n        };\n        rec(str,0,0,0);\n        cout << res.size() << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nstring st;\nint getnum(int l) {\n\tint num = 0;\n\twhile (isdigit(st[l])) {\n\t\tnum = num * 10 + st[l] - '0';\n\t\tl++;\n\t}\n\treturn num;\n}\nint calc(const int a,const int b,const char type) {\n\tif (type == '+')return a + b;\n\telse if (type == '-')return a - b;\n\telse if (type == '*')return a*b;\n\telse return a / b;\n}\nset<int> getexpr(const int l,const int r) {\n\tset <int>aset;\n\tint depth = 0;\n\tbool flag = false;\n\tfor (int x = l; x <= r; ++x) {\n\t\tif (st[x] == '(') {\n\t\t\tdepth++;\n\t\t}\n\t\telse if (st[x] == ')') {\n\t\t\tdepth--;\n\t\t}\n\t\telse if (st[x] == '+' || st[x] == '-' || st[x] == '*' || st[x] == '/') {\n\t\t\tif (!depth) {\n\t\t\t\tflag = true;\n\t\t\t\tconst set<int> lset = getexpr(l, x - 1);\n\t\t\t\tconst set<int> rset = getexpr(x + 1, r);\n\t\t\t\tfor (auto a : lset) {\n\t\t\t\t\tfor (auto b : rset) {\n\t\t\t\t\t\tif (st[x] == '/'&&!b)continue;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\taset.emplace(calc(a, b, st[x]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!flag) {\n\t\tif (st[l] == '(')return getexpr(l + 1, r - 1);\n\t\taset.emplace(getnum(l));\n\t}\n\treturn aset;\n}\nint main() {\n\twhile (1) {\n\t\tcin >> st;\n\t\tif (st == \"#\")break;\n\t\tset<int>aset=getexpr(0,st.size()-1);\t\n\t\tcout << aset.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct ops{\n  int pos,num;\n  char op;\n  ops(int pos, int num, char op):pos(pos),num(num),op(op){}\n  bool operator < (const ops &p) const {\n    return pos < p.pos;\n  }\n};\n\nstring str;\n\nvoid print(const vector<ops> &v){\n  for(int i=0;i<v.size();i++){\n    if(v[i].op == 0) cout << v[i].num;\n    else cout << v[i].op;\n  }\n  cout << endl;\n}\n\nvoid erase_parenthesis(vector<ops> &v){\n for(int i=0;i<(int)v.size()-2;i++){\n    if(v[i].op == '(' && v[i+1].op == 0 && v[i+2].op == ')'){\n      v.erase(v.begin() + i + 2);\n      v.erase(v.begin() + i);\n      i--;\n      if(i >= 0) i--;\n    }      \n  }\n\n}\n\nint solve(){\n  set<int> st;\n  vector<ops> ov,initv;\n\n  for(int i=0;i<str.size();i++){\n    if(str[i] == '+' || str[i] == '-' || str[i] == '*' || str[i] == '/'){\n      initv.push_back(ops(i, 0, str[i]));\n      ov.push_back(ops(i, 0, str[i]));\n    } else if(str[i] >= '0' && str[i] <= '9'){\n      int num = 0;\n      while(str[i] >= '0' && str[i] <= '9'){\n        num += str[i] - '0';\n        i++;\n      }\n      i--;\n      initv.push_back(ops(i, num, 0));\n    } else {\n      initv.push_back(ops(i, 0, str[i]));\n    }\n  }\n\n  erase_parenthesis(initv);\n  if(initv.size() == 1 && initv[0].op == 0) return 1;\n\n  do{\n    vector<ops> v = initv;\n    for(int i=0;i<ov.size();i++){\n      int pos = lower_bound(v.begin(), v.end(), ov[i]) - v.begin(), res;\n      if(pos <= 0 || pos >= v.size()-1 || v[pos-1].op != 0 || v[pos+1].op != 0) break;\n      if(v[pos].op == '/' && v[pos+1].num == 0) break;\n      if(v[pos].op == '+') res = v[pos-1].num + v[pos+1].num;\n      if(v[pos].op == '-') res = v[pos-1].num - v[pos+1].num;\n      if(v[pos].op == '*') res = v[pos-1].num * v[pos+1].num;\n      if(v[pos].op == '/') res = v[pos-1].num / v[pos+1].num;\n      for(int j=0;j<2;j++) v.erase(v.begin()+pos);\n      v[pos-1].num = res;\n\n      erase_parenthesis(v);\n    }\n\n    if(v.size() == 1 && v[0].op == 0) st.insert(v[0].num);\n\n  } while(next_permutation(ov.begin(), ov.end()));\n\n  return max(1, (int)st.size());\n}\n\nint main(){\n  while(cin >> str && str != \"#\") cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nstring expr;\nstring oprs = \"+-*/\";\n\nint to_int(int s, int t){\n    int res = 0;\n    int x = 1;\n    for(int i=t-1; i>=s; i--){\n        if('0'<=expr[i] && expr[i]<'9')\n            res += x * (expr[i]-'0');\n        else\n            return -1;\n    }\n    \n    return res;\n}\n\nvector<int> dfs(int s, int t){\n    vector<int> res;\n    \n    int x = to_int(s, t);\n    if(x >= 0){\n        res.push_back(x);\n        return res;\n    }\n    \n    if(expr[s] == '(' && expr[t-1] == ')')\n        return dfs(s+1, t-1);\n        \n    int count = 0;\n    for(int i=s; i<t; i++){\n        char &c = expr[i];\n        if(c == '('){\n            count++;\n        }else if(c == ')'){\n            count--;\n        }else if(c == '+'){\n            if(count) continue;\n                \n            vector<int> v1 = dfs(s, i);\n            vector<int> v2 = dfs(i+1, t);\n            \n            for(auto x1: v1)\n                for(auto x2: v2)\n                    res.push_back(x1+x2);\n        \n        }else if(c == '-'){\n            if(count) continue;\n            \n            vector<int> v1 = dfs(s, i);\n            vector<int> v2 = dfs(i+1, t);\n            \n            for(auto x1: v1)\n                for(auto x2: v2)\n                    res.push_back(x1-x2);\n    \n        }else if(c == '*'){\n            if(count) continue;\n            \n            vector<int> v1 = dfs(s, i);\n            vector<int> v2 = dfs(i+1, t);\n            \n            for(auto x1: v1)\n                for(auto x2: v2)\n                    res.push_back(x1*x2);\n        \n        }else if(c == '/'){\n            if(count) continue;\n            \n            vector<int> v1 = dfs(s, i);\n            vector<int> v2 = dfs(i+1, t);\n            \n            for(auto x1: v1)\n                for(auto x2: v2) if(x2 != 0)\n                    res.push_back(x1/x2);\n        \n        }else{\n            //??°???\n        }\n            \n    }\n    sort(res.begin(), res.end());\n    res.erase(unique(res.begin(), res.end()), res.end());\n    \n    return res;\n}\n\nvoid solve(){\n    vector<int> res = dfs(0, expr.length());\n    \n    cout << res.size() << endl;\n}\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    \n    while(cin>>expr, expr!=\"#\")\n        solve();\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n\nusing namespace std;\n\n#define mod 1000000007\n\nstring s;\nint l;\nvector<vector<set<int> > > result;\nvector<vector<bool> > ischecked;\n\nset<int> solve(int i, int n)\n{\n\t// cout << i << \" \" << n << endl;\n\t// s???i????????????n????????¨??£????????????????¨???????????????????????????????\n\tif(ischecked[i][n]) return result[i][n];\n\tischecked[i][n] = true;\n\tstack<int> leftkakko;\n\tbool noopandkakko = true;\n\tint num = 0;\n\tfor(int j = 0; j < n; j++){\n\t\tif(s[i + j] == '('){\n\t\t\tleftkakko.push(i + j);\n\t\t\tnoopandkakko = false;\n\t\t} else if(s[i + j] == ')'){\n\t\t\tint tmp = leftkakko.top();\n\t\t\tleftkakko.pop();\n\t\t\tresult[tmp][i + j - tmp + 1] = solve(tmp + 1, i + j - tmp - 1);\n\t\t} else if(isdigit(s[i + j])){\n\t\t\tnum = 10 * num + (s[i + j] - '0');\n\t\t} else {\n\t\t\tif(!leftkakko.empty()) continue;\n\t\t\tnoopandkakko = false;\n\t\t\tset<int> left, right;\n\t\t\tleft = solve(i, j);\n\t\t\tright = solve(i + j + 1, n - j - 1);\n\t\t\tfor(auto p = left.begin(); p != left.end(); p++){\n\t\t\t\tfor(auto q = right.begin(); q != right.end(); q++){\n\t\t\t\t\tif(s[i + j] == '+'){\n\t\t\t\t\t\tresult[i][n].insert((*p) + (*q));\n\t\t\t\t\t} else if(s[i + j] == '*'){\n\t\t\t\t\t\tresult[i][n].insert((*p) * (*q));\n\t\t\t\t\t} else if(s[i + j] == '-'){\n\t\t\t\t\t\tresult[i][n].insert((*p) - (*q));\n\t\t\t\t\t} else if(s[i + j] == '/'){\n\t\t\t\t\t\tif((*q) != 0) result[i][n].insert((*p) / (*q));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(noopandkakko) result[i][n].insert(num);\n\t// cout << i << \" \" << n << \":\" << endl;\n\t// for(auto j = result[i][n].begin(); j != result[i][n].end(); j++){\n\t// \tcout << (*j) << endl;\n\t// }\n\treturn result[i][n];\n}\n\nint main()\n{\n\twhile(1){\n\t\tcin >> s;\n\t\tif(s == \"#\") break;\n\t\tl = s.length();\n\t\tresult = vector<vector<set<int> > >(l + 1, vector<set<int> >(l + 1));\n\t\tischecked = vector<vector<bool> >(l + 1, vector<bool>(l + 1, false));\n\t\tcout << solve(0, l).size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n\nstring STR;\nvector<string> S;\n\nset<int> calc(int b, int e){\n  //cout <<\"-------\" <<endl;\n  //cout <<\"begin = \" <<b <<\", end = \" <<e <<endl;\n  //FOR(i, b, e) cout <<S[i]; cout <<endl;\n  set<int> ret;\n  if(e - b == 1) ret.insert(atoi(S[b].c_str()));\n  else if(S[b] == \"(\" && S[e - 1] == \")\") ret = calc(b + 1, e - 1);\n  else {\n    int cnt = 0;\n    FOR(i, b, e){\n      if(S[i] == \"(\") ++cnt;\n      else if(S[i] == \")\") --cnt;\n      else if(cnt == 0 && (S[i] == \"+\" || S[i] == \"-\" || S[i] == \"*\" || S[i] == \"/\")){\n        set<int> left = calc(b, i), right = calc(i + 1, e);\n        for(set<int>::iterator it1 = left.begin(); it1 != left.end(); ++it1){\n          for(set<int>::iterator it2 = right.begin(); it2 != right.end(); ++it2){\n            if(S[i] == \"+\") ret.insert((*it1) + (*it2));\n            if(S[i] == \"-\") ret.insert((*it1) - (*it2));\n            if(S[i] == \"*\") ret.insert((*it1) * (*it2));\n            if(S[i] == \"/\" && (*it2) != 0) ret.insert((*it1) / (*it2));\n            //cout <<\"insert \";\n            //for(set<int>::iterator it = ret.begin(); it != ret.end(); ++it) cout <<(*it) <<\", \"; cout <<endl;\n          }\n        }\n      }\n    }\n  }\n  //cout <<\"ret = \";\n  //for(set<int>::iterator it = ret.begin(); it != ret.end(); ++it) cout <<(*it) <<\", \"; cout <<endl;\n  return ret;\n}\n\nint main() {\n  while(cin >>STR && STR != \"#\"){\n    S = vector<string>();\n    string tmp = \"\";\n    REP(i, STR.length()){\n      if(isdigit(STR[i])) tmp += STR[i];\n      else{\n        if(tmp != \"\") S.push_back(tmp);\n        tmp = STR[i];\n        S.push_back(tmp);\n        tmp = \"\";\n      }\n    }\n    if(tmp != \"\") S.push_back(tmp);\n    //REP(i, S.size()) cout <<S[i] <<\" | \"; cout <<endl;\n    set<int> ans = calc(0, S.size());\n    cout <<ans.size() <<endl;\n    //for(set<int>::iterator it = ans.begin(); it != ans.end(); ++it) cout <<(*it) <<\", \"; cout <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<sstream>\n\nusing namespace std;\n\ntypedef long long ll;\n\nbool isnum(string s){\n  for(int i = 0; i < s.length(); i++)\n    if(s[i] < '0' || '9' < s[i]) return false;\n\n  return true;\n}\nvector<ll> solve(string s){\n  \n  vector<ll> V;\n\n  if(isnum(s)){\n    stringstream ss(s);\n    ll n;\n    ss >> n;\n    V.push_back(n);\n    return V;\n  }else if(s[0] == '(' && s[s.length()-1] == ')'){\n    return solve(s.substr(1,s.length()-2));\n  }else{\n    int para = 0;\n\n    for(int i = 0; i < s.length(); i++){\n      vector<ll> v1,v2;\n      if(s[i] == '(') para++;\n      if(s[i] == ')') para--;\n      if(para == 0 && s[i] == '+'){\n\tv1 = solve(s.substr(0,i));\n\tv2 = solve(s.substr(i+1));\n\n\tfor(int j = 0; j < v1.size(); j++)\n\t  for(int k = 0; k < v2.size(); k++)\n\t    V.push_back(v1[j]+v2[k]);\n\t  \n      }\n\n      if(para == 0 && s[i] == '-'){\n\tvector<ll> v1,v2;\n\tv1 = solve(s.substr(0,i));\n\tv2 = solve(s.substr(i+1));\n\n\tfor(int j = 0; j < v1.size(); j++)\n\t  for(int k = 0; k < v2.size(); k++)\n\t    V.push_back(v1[j]-v2[k]);\n\n      }\n      if(para == 0 && s[i] == '*'){\n\tvector<ll> v1,v2;\n\tv1 = solve(s.substr(0,i));\n\tv2 = solve(s.substr(i+1));\n\n\tfor(int j = 0; j < v1.size(); j++)\n\t  for(int k = 0; k < v2.size(); k++)\n\t    V.push_back(v1[j]*v2[k]);\n      }\n      if(para == 0 && s[i] == '/'){\n\tvector<ll> v1,v2;\n\tv1 = solve(s.substr(0,i));\n\tv2 = solve(s.substr(i+1));\n\n\tfor(int j = 0; j < v1.size(); j++)\n\t  for(int k = 0; k < v2.size(); k++)\n\t    if(v2[k] != 0) V.push_back(v1[j]/v2[k]);\n\n      }\n    }\n  }\n  return V;\n}\n\nint main(){\n  \n  string in;\n  while(getline(cin,in) && in != \"#\"){\n    vector<ll> V = solve(in);\n    map<ll,int> M;\n    ll ans = 0;\n    for(int i = 0; i < V.size(); i++){\n      if(M[V[i]] == 0){\n\tM[V[i]] = 1;\n\tans++;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define var auto\n#define ll long long\n//#define APPLY(a, f) f(a.begin(), a.end())\n#define APPLY(a, f, ...) f(a.begin(), a.end(), __VA_ARGS__)\n#define FUN1(x, f) [&](auto& x){return f;}\n#define FUN2(x, y, f) [&](auto& x){return f;}\nusing namespace std;\n\nstring s;\n\nset<int> solve(int& ind){\n    vector<set<int>> num{};\n    vector<char> op{};\n    int curnum = -1;\n    while (true){\n        var c = s[ind];\n        if (c == '+' || c == '-' || c == '*' || c == '/'){\n            if (curnum != -1) { num.push_back(set<int>{curnum}); curnum = -1; }\n            op.push_back(c);\n            goto end;\n        }\n        if ('0' <= c && c <= '9'){\n            if (curnum == -1) curnum = 0;\n            curnum = curnum * 10 + (c - '0');\n            goto end;\n        }\n        if (c == '('){\n            ind++;\n            num.push_back(solve(ind));//かっこをよしなに\n            goto end;\n        }\n        if (c == ')'){\n            if (curnum != -1) { num.push_back(set<int>{curnum}); curnum = -1; }\n            //ここでマージ処理\n            vector<vector<set<int>>> dp(num.size(), vector<set<int>>(num.size(), set<int>{}));\n            for (int i = 0; i < num.size(); i++){\n                dp[i][i] = num[i];\n            }\n            for (int sz = 2; sz <= num.size(); sz++){\n                for (int i = 0; i <= num.size() - sz; i++){\n                    for (int j = i; j < i + sz - 1; j++){\n                        for (auto&& elem1 : dp[i][j]){\n                            for (auto&& elem2 : dp[j + 1][i + sz - 1]){\n                                bool flag = false;\n                                int opres;\n                                switch (op[j]){\n                                    case '+':\n                                        opres = elem1 + elem2;\n                                        break;\n                                    case '-':\n                                        opres = elem1 - elem2;\n                                        break;\n                                    case '*':\n                                        opres = elem1 * elem2;\n                                        break;\n                                    case '/':\n                                        if (elem2 == 0) { flag = true;\n                                            break; }\n                                        opres = elem1 / elem2;\n                                        break;\n                                }\n                                if (flag) continue;\n                                dp[i][i + sz - 1].insert(opres);\n                            }\n                        }\n                    }\n                }\n            }\n            return dp[0][num.size() - 1];\n        }\n        end:;\n        ind++;\n    }\n}\n\n\n\nint main() {\n    while (true){\n        cin >> s;\n        if (s == \"#\") return 0;\n        s = s + \")\";\n        int ind = 0;\n        cout << solve(ind).size() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype>\n#include <set>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\ntypedef string::const_iterator State;\nclass ParseError {};\n\n\nenum Operator { add, sub, mul, divi, fac, integer };\n\nstruct Node{\n    int num;\n    Operator op;\n    vector<Node> children;\n    Node(int n){\n        num=n;\n        op=integer;\n    }\n    Node(Operator o){\n        num=-1;\n        op=o;\n    }\n};\n\nint number(State &begin) {\n    int ret=0;\n    while(isdigit(*begin)) ret=ret*10+*begin++-'0';\n    // cout<<ret<<endl;\n    return ret;\n}\n\nNode expr(State &begin){\n    Node node(fac);\n    while(true){\n        if(*begin=='('){\n            begin++;\n            node.children.push_back(expr(begin));\n            begin++;\n        }else if(*begin==')'){\n            return node;\n        }else if(isdigit(*begin)){\n            int n = number(begin);\n            node.children.push_back(Node(n));\n        }else if(*begin=='+'){\n            node.children.push_back(Node(add));\n            begin++;\n        }else if(*begin=='-'){\n            node.children.push_back(Node(sub));\n            begin++;\n        }else if(*begin=='*'){\n            node.children.push_back(Node(mul));\n            begin++;\n        }else if(*begin=='/'){\n            node.children.push_back(Node(divi));\n            begin++;\n        }else{\n            break;\n        }\n    }\n    return node;\n}\n\nset<int> dfs(Node &node){\n    set<int> ret;\n    if(node.op==integer){\n        ret.insert(node.num);\n        return ret;\n    }\n    int n = (node.children.size()+1)/2;\n    vector<tuple<int,Operator,set<int>>> V,VV;\n    for(int i=0;i<n;i++){\n        if(!i) VV.emplace_back(i,integer,dfs(node.children[2*i]));\n        else VV.emplace_back(i,node.children[2*i-1].op, dfs(node.children[2*i]));\n    }\n    /*\n    for(auto v:VV){\n        int i;\n        Operator op;\n        tie(i,op,ignore)=v;\n        cout<<i<<' ';\n        switch(op){\n            case add:\n                cout<<\"add \";\n                break;\n            case sub:\n                cout<<\"sub \";\n                break;\n            case mul:\n                cout<<\"mul \";\n                break;\n            case divi:\n                cout<<\"divi \";\n                break;\n            case fac:\n                cout<<\"fac \";\n                break;\n            case integer:\n                cout<<\"integer \";\n        }\n    }\n    cout<<endl;\n    */\n    // return ret;\n    vector<int> I(n-1);\n    for(int i=0;i<n-1;i++) I[i]=i+1;\n\n    do{\n        V=VV;\n        for(int i=0;i<I.size();i++){\n            for(int v=0;v<V.size();v++){\n                if(get<0>(V[v])==I[i]){\n                    set<int> &S1=get<2>(V[v-1]);\n                    set<int> &S2=get<2>(V[v]);\n                    set<int> S3;\n                    Operator op = get<1>(V[v]);\n                    for(auto s1:S1){\n                        for(auto s2:S2){\n                            switch(op){\n                                case add:\n                                    S3.insert(s1+s2);\n                                    break;\n                                case sub:\n                                    S3.insert(s1-s2);\n                                    break;\n                                case mul:\n                                    S3.insert(s1*s2);\n                                    break;\n                                case divi:\n                                    if(s2) S3.insert(s1/s2);\n                                    break;\n                                default:\n                                    cout<<\"!\"<<endl;\n                                    exit(1);\n                            }\n                        }\n                    }\n                    S1.clear();\n                    for(auto s3:S3) S1.insert(s3);\n                    V.erase(V.begin()+v);\n                    break;\n                }\n            }\n        }\n        for(auto s:get<2>(V.front())) ret.insert(s);\n    }while(next_permutation(I.begin(),I.end()));\n\n    return ret;\n}\n\nvoid dfs2(Node &node, int depth = 0){\n    cout<<string(depth,' ')<<\"num: \"<<node.num<<\" op: \";\n    switch(node.op){\n        case add:\n            cout<<\"add\"<<endl;\n            break;\n        case sub:\n            cout<<\"sub\"<<endl;\n            break;\n        case mul:\n            cout<<\"mul\"<<endl;\n            break;\n        case divi:\n            cout<<\"divi\"<<endl;\n            break;\n        case fac:\n            cout<<\"fac\"<<endl;\n            break;\n        case integer:\n            cout<<\"integer\"<<endl;\n    }\n    for(auto &c:node.children) dfs2(c,depth+1);\n}\n\nint main(){\n    while(true){\n        string S;\n        getline(cin, S);\n        if(S[0]=='#') break;\n        // cout<<S<<endl;\n        State begin = S.begin();\n        Node root = expr(begin);\n        //dfs2(root);\n        set<int> ans = dfs(root);\n        cout<<ans.size()<<endl;\n        // for(auto a:ans) cout<<a<<' ';\n        // cout<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MP make_pair\n\ntypedef pair<int, int> PII;\n\nconst int SIZE = 200;\n\nchar line[SIZE], t[SIZE];\nset<int> memo[SIZE][SIZE];\nset<PII> used;\n \nvoid eval(int const l, int const r) {\n   \n  set<int>& ret = memo[l][r];\n  if(l == r) return;\n   \n  if(used.count(MP(l, r))) return;\n  used.insert(MP(l, r));\n   \n  // check is digits [l, r)\n  bool digits = true;\n  for(int i=l; i<r; i++) { digits = digits && isdigit(line[i]); }\n  strncpy(t, line+l, r-l); t[r-l+1] = 0;\n  if(digits) { ret.insert(atoi(t)); return; }\n   \n  int par = 0; bool check = true;\n  for(int i=l; i<r-1; i++) {\n    if(line[i] == '(') { par ++; }\n    if(line[i] == ')') { par --; }\n    if(par == 0) { check = false; }\n  }\n   \n  // \"(expr)\"\n  if(check) {\n    if(line[r-1] == ')') {\n      eval(l+1, r-1); ret = memo[l+1][r-1]; return;\n    }\n  }\n   \n  par = 0;\n  // parsing loop\n  for(int i=l; i<r; i++) {\n    if(line[i] == '(') { par ++; }\n    if(line[i] == ')') { par --; }\n    if(par != 0) continue;\n     \n    switch(line[i]) {\n    case '+': case '-': case '*': case '/': {\n      eval(l, i); eval(i+1, r);\n      set<int>::iterator iter_a, iter_b;\n      for(iter_a = memo[l][i].begin(); iter_a!=memo[l][i].end(); iter_a++) {\n        for(iter_b = memo[i+1][r].begin(); iter_b!=memo[i+1][r].end(); iter_b++) {\n          if(line[i] == '+') { ret.insert(*iter_a + *iter_b); }\n          if(line[i] == '-') { ret.insert(*iter_a - *iter_b); }\n          if(line[i] == '*') { ret.insert(*iter_a * *iter_b); }\n          if(line[i] == '/') {\n            if(*iter_b == 0) continue;\n            ret.insert(*iter_a / *iter_b);\n          }\n        }\n      }\n      break;\n    }\n    default:;\n    }\n  } // for parsing loop\n}\n \nint main() {\n   \n  while(1) {\n    scanf(\"%s\\n\", line);\n    for(int i=0; i<SIZE; i++)\n      for(int j=0; j<SIZE; j++)\n        memo[i][j].clear();\n     \n    used.clear();\n     \n    if(0==strcmp(line, \"#\")) break;\n    eval(0, strlen(line));\n    cout << memo[0][strlen(line)].size() << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MP make_pair\n#define EACH(i, c) for(__typeof((c).begin()) i=(c).begin(); (i)!=(c).end(); i++)\n\ntypedef pair<int, int> PII;\n\nconst int SIZE = 100;\n\nchar line[SIZE], t[SIZE];\nset<int> memo[SIZE][SIZE];\nset<PII> used;\n \nvoid eval(int const l, int const r) {\n   \n  set<int>& ret = memo[l][r];\n  if(l == r) return;\n   \n  if(used.count(MP(l, r))) return;\n  used.insert(MP(l, r));\n   \n  // check is digits [l, r)\n  bool digits = true;\n  for(int i=l; i<r; i++) { digits = digits && isdigit(line[i]); }\n  strncpy(t, line+l, r-l); t[r-l] = 0;\n  if(digits) { ret.insert(atoi(t)); return; }\n   \n  int par = 0; bool check = true;\n  for(int i=l; i<r-1; i++) {\n    if(line[i] == '(') { par ++; }\n    if(line[i] == ')') { par --; }\n    if(par == 0) { check = false; }\n  }\n   \n  // \"(expr)\"\n  if(check) {\n    if(line[r-1] == ')') {\n      eval(l+1, r-1); ret = memo[l+1][r-1]; return;\n    }\n  }\n   \n  par = 0;\n  // parsing loop\n  for(int i=l; i<r; i++) {\n    if(line[i] == '(') { par ++; }\n    if(line[i] == ')') { par --; }\n    if(par != 0) continue;\n     \n    switch(line[i]) {\n    case '+': case '-': case '*': case '/':\n      eval(l, i); eval(i+1, r);\n      EACH(ia, memo[l][i]) EACH(ib, memo[i+1][r]) {\n        if(line[i] == '+') { ret.insert(*ia + *ib); }\n        if(line[i] == '-') { ret.insert(*ia - *ib); }\n        if(line[i] == '*') { ret.insert(*ia * *ib); }\n        if(line[i] == '/' && *ib!=0) { ret.insert(*ia / *ib); }\n      }\n      break;\n    }\n  } // for parsing loop\n}\n \nint main() {\n   \n  while(1) {\n    scanf(\"%s\\n\", line);\n    for(int i=0; i<SIZE; i++)\n      for(int j=0; j<SIZE; j++)\n        memo[i][j].clear();\n     \n    used.clear();\n     \n    if(0==strcmp(line, \"#\")) break;\n    eval(0, strlen(line));\n    cout << memo[0][strlen(line)].size() << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nstring S;\nint N;\n\nenum Type {\n    Open,\n    Close,\n    Num,\n    Ope,\n    None\n};\n\nstruct Expr {\n    Expr() {\n        right = -1;\n        left = -1;\n        type = None;\n    }\n    Type type;\n\n    int num;\n    char ope;\n\n    int left;\n    int right;\n};\n\nvector<Expr> exprs;\nVI ope_idxes;\n\nPII parse_num(int pos) {\n    string num_s;\n    while (pos < N && isdigit(S[pos])) {\n        num_s += S[pos];\n        ++pos;\n    }\n    return MP(pos, fromString<int>(num_s));\n}\n\nvoid link(int a, int b) {\n    if (a != -1) {\n        exprs[a].right = b;\n    }\n    if (b != -1) {\n        exprs[b].left = a;\n    }\n}\n\nvoid link2(vector<Expr> &es, int a, int b) {\n    if (a != -1) {\n        es[a].right = b;\n    }\n    if (b != -1) {\n        es[b].left = a;\n    }\n}\n\nint make_expr(int before) {\n    Expr cur;\n    int idx = exprs.size();\n    exprs.PB(cur);\n    link(before, idx);\n    return idx;\n}\n\nvoid parse() {\n    exprs.resize(0);\n    ope_idxes.resize(0);\n\n    int before = -1;\n\n    for (int i = 0; i < N; i++) {\n        int cur = make_expr(before);\n        Expr &e = exprs[cur];\n        char c = S[i];\n\n        if (c == '(') {\n            e.type = Open;\n        } else if (c == ')') {\n            e.type = Close;\n        } else if (isdigit(c)) {\n            e.type = Num;\n            PII tmp = parse_num(i);\n            i = tmp.fst - 1; // ?????´\n            e.num = tmp.snd;\n        } else { // ope\n            e.type = Ope;\n            e.ope = c;\n            ope_idxes.PB(cur);\n        }\n\n        before = cur;\n    }\n}\n\nvoid remove_blocks(vector<Expr> &es, int i) {\n    while (true) {\n        int l = es[i].left;\n        int r = es[i].right;\n\n        if (l == -1 || r == -1) return;\n        if (es[l].type != Open || es[r].type != Close) return;\n\n        link2(es, es[l].left, i);\n        link2(es, i, es[r].right);\n    }\n}\n\npair<int, bool> calc(VI &idxes, vector<Expr> es) {\n    int val = es[(int)es.size() / 2].num;\n    \n    for (int i = 0; i < (int)idxes.size(); i++) {\n        int cur = idxes[i];\n        int left = es[cur].left;\n        int right = es[cur].right;\n\n        if (es[left].type == Close ||\n            es[right].type == Open ) {\n            return MP(1, false);\n        }\n\n        char ope = es[cur].ope;\n        int a = es[left].num;\n        int b = es[right].num;\n\n        // ?¨????\n        if (ope == '+') {\n            val = a + b;\n        } else if (ope == '-') {\n            val = a - b;\n        } else if (ope == '*') {\n            val = a * b;\n        } else if (ope == '/') {\n            if (b == 0) {\n                return MP(2, false);\n            }\n            val = a / b;\n        }\n\n        // ?????????\n        Expr new_expr;\n        new_expr.num = val;\n        new_expr.type = Num;\n        int new_idx = es.size();\n        es.PB(new_expr);\n        link2(es, es[left].left, new_idx);\n        link2(es, new_idx, es[right].right);\n\n        // ??¬??§??????????????????????????¬??§?????????\n        remove_blocks(es, new_idx);\n    }\n\n    return MP(val, true);\n}\n\nint solve() {\n    parse();\n\n    // (num) ??? num ???\n    for (int i = 0; i < (int)exprs.size(); i++) {\n        remove_blocks(exprs, i);\n    }\n\n    set<int> anses;\n\n    sort(ALL(ope_idxes));\n\n    do {\n        auto ans = calc(ope_idxes, exprs);\n        if (ans.snd) {\n            anses.insert(ans.fst);\n        }\n    } while (next_permutation(ALL(ope_idxes)));\n\n    return anses.size();\n}\n\nint main(void) {\n    while (cin >> S, S != \"#\") {\n        N = S.size();\n        cout << solve() << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <iostream>\n#include <set>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_from(i, m, n) for (int i = (m); (i) < int(n); ++(i))\nusing namespace std;\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\nstruct expr_t {\n    int immidiate;\n    vector<expr_t> value;\n    vector<char> op;\n};\nexpr_t parse_value(string::const_iterator & first, string::const_iterator last) {\n    assert (first != last);\n    assert (isdigit(*first));\n    int acc = 0;\n    while (first != last and isdigit(*first)) {\n        acc = acc * 10 + (*first - '0');\n        ++ first;\n    }\n    return (expr_t) { acc };\n}\nexpr_t parse_expr(string::const_iterator & first, string::const_iterator last);\nexpr_t parse_term(string::const_iterator & first, string::const_iterator last) {\n    assert (first != last);\n    if (*first == '(') {\n        ++ first;\n        expr_t expr = parse_expr(first, last);\n        assert (*first == ')');\n        ++ first;\n        return expr;\n    } else {\n        return parse_value(first, last);\n    }\n}\nexpr_t parse_expr(string::const_iterator & first, string::const_iterator last) {\n    assert (first != last);\n    expr_t expr = { -1 };\n    expr.value.push_back(parse_term(first, last));\n    while (first != last and *first != ')') {\n        assert (*first == '+' or *first == '-' or *first == '*' or *first == '/');\n        expr.op.push_back(*first);\n        ++ first;\n        expr.value.push_back(parse_term(first, last));\n    }\n    return expr;\n}\nexpr_t parse(string const & s) {\n    auto first = s.begin();\n    expr_t expr = parse_expr(first, s.end());\n    assert (first == s.end());\n    return expr;\n}\n\nset<int> solve(expr_t const & expr) {\n    if (expr.immidiate != -1) {\n        return set<int>({ expr.immidiate });\n    } else {\n        int n = expr.value.size();\n        auto dp = vectors(n, n + 1, set<int>());\n        repeat (i, n) {\n            dp[i][i + 1] = solve(expr.value[i]);\n        }\n        repeat_from (len, 2, n + 1) {\n            repeat_from (r, len, n + 1) {\n                int l = r - len;\n                repeat_from (m, l, r - 1) {\n                    set<int> & left  = dp[l][m + 1];\n                    set<int> & right = dp[m + 1][r];\n                    char op = expr.op[m];\n                    if (op == '+') {\n                        for (int a : left) for (int b : right) dp[l][r].insert(a + b);\n                    } else if (op == '-') {\n                        for (int a : left) for (int b : right) dp[l][r].insert(a - b);\n                    } else if (op == '*') {\n                        for (int a : left) for (int b : right) dp[l][r].insert(a * b);\n                    } else if (op == '/') {\n                        for (int b : right) if (b != 0) for (int a : left) dp[l][r].insert(a / b);\n                    }\n                }\n            }\n        }\n        return dp[0][n];\n    }\n}\n\nint main() {\n    while (true) {\n        string s; cin >> s;\n        if (s == \"#\") break;\n        expr_t expr = parse(s);\n        int result = solve(expr).size();\n        printf(\"%d\\n\", result);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint next_paren(string expr, int i) {\n    int level = 0;\n    for (; i < (int)expr.length(); i++) {\n        switch (expr[i]) {\n        case '(':\n            level++;\n            break;\n        case ')':\n            level--;\n            if (level == 0) return i;\n            break;\n        }\n    }\n    assert(0);\n}\n\nset<int> eval(string expr) {\n    vector<string> terms;\n    vector<char> ops;\n    REP(i, expr.length()) {\n        switch (expr[i]) {\n        case '(': {\n            int j = next_paren(expr, i);\n            terms.push_back(expr.substr(i, j+1));\n            i = j;\n            break;\n        }\n        case '+':\n        case '-':\n        case '*':\n        case '/':\n            ops.push_back(expr[i]);\n            break;\n        default: {\n            string num;\n            for (; i < (int)expr.length() && isdigit(expr[i]); i++) {\n                num += expr[i];\n            }\n            terms.push_back(num);\n            i--;\n        }\n        }\n    }\n\n    set<int> res;\n    if (ops.empty()) {\n        if (terms[0][0] == '(') {\n            return eval(terms[0].substr(1, terms[0].length()-2));\n        } else {\n            res.insert(stoi(terms[0]));\n        }\n    } else {\n        FOR(i, 1, terms.size()) {\n            string lexpr, rexpr;\n            REP(j, i) {\n                if (j != 0) lexpr += ops[j-1];\n                lexpr += terms[j];\n            }\n            FOR(j, i, terms.size()) {\n                if (j != i) rexpr += ops[j-1];\n                rexpr += terms[j];\n            }\n//            LOG(\"--> %s %c %s\\n\", lexpr.c_str(), ops[i-1], rexpr.c_str());\n            set<int> l = eval(lexpr);\n            set<int> r = eval(rexpr);\n//            LOG(\"# %d\\n\", l.size());\n//            LOG(\"# %d\\n\", r.size());\n            for (int a : l) for (int b : r) {\n//                LOG(\"-----> %d %c %d\\n\", a, ops[i-1], b);\n                int val;\n                switch (ops[i-1]) {\n                case '+':\n                    val = a + b;\n                    break;\n                case '-':\n                    val = a - b;\n                    break;\n                case '*':\n                    val = a * b;\n                    break;\n                case '/':\n                    if (b == 0) {\n                        goto NEXT;\n                    }\n                    val = a / b;\n                    break;\n                }\n                res.insert(val);\n                NEXT : {}\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    string expr;\n    while (cin  >> expr, expr != \"#\") {\n        cout << eval(expr).size() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <cctype>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <vector>\n\nstd::set<int> apply(\n    const std::set<int> &lhs, char op, const std::set<int> &rhs) {\n\n  std::set<int> res;\n  for (int lx: lhs)\n    for (int rx: rhs) {\n      if (op == '+') {\n        res.insert(lx+rx);\n      } else if (op == '-') {\n        res.insert(lx-rx);\n      } else if (op == '*') {\n        res.insert(lx*rx);\n      } else if (op == '/' && rx != 0) {\n        res.insert(lx/rx);\n      }\n    }\n\n  return res;\n}\n\nstd::set<int> parse(std::string &s, size_t &i, size_t preced=0) {\n  static const std::string ops=\"+-*/\";\n\n  if (preced == 1) {\n    if (s[i] == '(') {\n      auto res=parse(s, ++i);\n      assert(s[i] == ')');\n      ++i;\n      return res;\n    } else if (isdigit(s[i])) {\n      int res=s[i]-'0';\n      while (++i < s.length() && isdigit(s[i]))\n        res = res*10+s[i]-'0';\n\n      return {res};\n    }\n    assert(false);\n  }\n\n  std::set<int> res;\n  size_t starti=i;\n  // skip an expression\n  auto tmp=parse(s, i, 1);\n  if (i == s.length () || !std::count(ops.begin(), ops.end(), s[i]))\n    return tmp;\n\n  while (i < s.length()) {\n    char op=s[i];\n    if (!std::count(ops.begin(), ops.end(), op)) break;\n\n    s[i] = '$';\n    size_t li=starti;\n    auto lhs=parse(s, li);\n    s[i] = op;\n\n    size_t ri=++i;\n    auto rhs=parse(s, ri);\n\n    auto tmp=apply(lhs, op, rhs);\n    res.insert(tmp.begin(), tmp.end());\n\n    // skip an expression\n    parse(s, i, 1);\n  }\n  return res;\n}\n\nint testcase_ends() {\n  char buf[256];\n  scanf(\"%s\", buf);\n  std::string s=buf;\n  if (s == \"#\") return 1;\n\n  size_t i=0;\n  printf(\"%zu\\n\", parse(s, i).size());\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <sstream>\n\nusing namespace std;\n\nset<int> m1[201][201];\nbool m2[201][201];\n\nint stoi(string s) {\n\tstringstream ss; ss << s;\n\tint ret; ss >> ret;\n\treturn ret;\n}\n\nstring str;\nset<int> dp(int l, int r) {\n\tif (m2[l][r]) return m1[l][r];\n\tif (str[l] == '(' && str[r-1] == ')') return dp(l+1, r-1);\n\n\tset<int> ret;\n\tbool f = true;\n\tfor (int i = l; i < r; ++i) {\n\t\tif (!isdigit(str[i])) f = false;\n\t}\n\tif (f) {\n\t\tret.insert( stoi(str.substr(l, r-l)) );\n\t\treturn m2[l][r] = true, m1[l][r] = ret;\n\t}\n\n\tint depth = 0;\n\tfor (int i = l; i < r; ++i) {\n\t\tswitch (str[i]) {\n\t\t\tcase '(':\n\t\t\t\t++depth;\n\t\t\t\tbreak;\n\n\t\t\tcase ')':\n\t\t\t\t--depth;\n\t\t\t\tbreak;\n\n\t\t\tcase '+':\n\t\t\tcase '-':\n\t\t\tcase '*':\n\t\t\tcase '/':\n\t\t\tif (depth == 0) {\n\t\t\t\tset<int> L = dp(l, i), R = dp(i+1, r);\n\t\t\t\tfor (set<int>::iterator j = L.begin(); j != L.end(); ++j) {\n\t\t\t\t\tfor (set<int>::iterator k = R.begin(); k != R.end(); ++k) {\n\t\t\t\t\t\tswitch (str[i]) {\n\t\t\t\t\t\t\tcase '+': ret.insert(*j+*k); break;\n\t\t\t\t\t\t\tcase '-': ret.insert(*j-*k); break;\n\t\t\t\t\t\t\tcase '*': ret.insert((*j)*(*k)); break;\n\t\t\t\t\t\t\tcase '/': if (*k) ret.insert((*j)/(*k)); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn m2[l][r] = true, m1[l][r] = ret;\n}\n\nint main() {\n\twhile (cin >> str, str != \"#\") {\n\t\tfill(&m2[0][0], &m2[0][0]+201*201, false);\n\t\tcout << dp(0, str.size()).size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define S str[pos]\nusing namespace std;\nstring str;\nint pos;\nmap <string,int> M;\nset <int> ans;\nint num[1<<8],flg;\n\nint bnf(){\n  int res=0,a;\n  if('A'<=S&&S<='Z') res=num[str[pos++]];\n  while(1){\n    if(S=='(') pos++,res=bnf(),pos++;\n    else if(S=='+')pos++,res+=bnf();\n    else if(S=='-')pos++,res-=bnf();\n    else if(S=='*'){\n      pos++;\n      if(S=='(') pos++,res*=bnf(),pos++;   \n      else res*=num[str[pos++]];\n    }\n    else if(S=='/'){\n      pos++;\n      if(S=='('){\n\tpos++,a=bnf(),pos++;\n\tif(a)res/=a;\n\telse flg=0;\n      }\n      else {\n\ta=num[str[pos++]];\n\tif(a)res/=a;\n\telse flg=0;\n      }\n    }\n    else break;\n  }\n  return res;\n}\n\nint CNT=0;\nvoid dfs(string abc,int idx,int l,int r){\n  while(('A'<=str[idx]&&str[idx]<='Z')||str[idx]=='('||str[idx]==')')abc+=str[idx++];\n  CNT++;\n  if(!r&&(int)str.size()<idx){\n    //    cout <<abc<<endl;\n    swap(str,abc);\n    pos=0,flg=1;\n    int a=bnf();\n    if(flg)ans.insert(a);\n    swap(str,abc);\n    return;\n  }\n  if(str.size()<idx)return;\n  dfs(abc+str[idx],idx+1,l,r);\n\n  string a=abc;\n  if(r&&a[a.size()-2]!='('){\n    if(idx<str.size())dfs(a+')'+str[idx],idx+1,l,r-1);\n    else dfs(a+')',idx+1,l,r-1);\n  }\n\n  a=abc+str[idx++];\n  for(int i=0;i<l;i++){\n    a+='(';\n    dfs(a,idx,l-1-i,r+i+1);\n  }\n\n}\n\nint main(){\n\n  while(1){\n    cin>>str;\n    if(str==\"#\")break;\n    pos=0,memset(num,0,sizeof(num)),ans.clear();\n    string a;\n    int ch='A',cnt=0;\n    while(str[pos]){\n      cnt+=(S=='+'||S=='-'||S=='/'||S=='*');\n      cnt-=(S=='(');\n      int b=0;\n      while('0'<=S&&S<='9') b=b*10+str[pos++]-'0';\n      if(b)num[ch]=b,a+=ch++;\n      else a+=str[pos++];\n    }\n    pos=0,str=\"Z+\"+a;\n    dfs(\"\",0,cnt,0);\n    cout << ans.size()<<endl;\n    // cout <<CNT<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<string>\nusing namespace std;\n\nstring str;\n\nset<int> search(int s,int e){\n\tset<int> a,b,c;\n\tset<int>::iterator it1,it2;\n\tint level=0;\n\tfor(int i=s;i<=e;i++){\n\t\tif(str[i]=='(')level++;\n\t\telse if(str[i]==')')level--;\n\t\tif(level==0 && (str[i]=='+'||str[i]=='-'||str[i]=='*'||str[i]=='/')){\n\t\t\ta=search(s,i-1);\n\t\t\tb=search(i+1,e);\n\t\t\tfor(it1=a.begin();it1!=a.end();++it1){\n\t\t\t\tfor(it2=b.begin();it2!=b.end();++it2){\n\t\t\t\t\tif(str[i]=='+')c.insert(*it1 + *it2);\n\t\t\t\t\telse if(str[i]=='-')c.insert(*it1 - *it2);\n\t\t\t\t\telse if(str[i]=='*')c.insert(*it1 * *it2);\n\t\t\t\t\telse if(*it2 != 0)c.insert(*it1 / *it2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(c.empty()){\n\t\tif(str[s]=='('&&str[e]==')')return search(s+1,e-1);\n\t\tint num=0;\n\t\twhile(s<=e){\n\t\t\tnum=10*num+str[s++]-'0';\n\t\t}\n\t\tc.insert(num);\n\t}\n\treturn c;\n}\n\nint main(){\n\twhile(cin>>str,str[0]!='#'){\n\t\tcout<<search(0,str.length()-1).size()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <set>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nset<int> se[200][201];\nstring s;\n\nset<int> rec(int l, int r) {\n  if (se[l][r].size()) return se[l][r];\n  \n  int nest = 0;\n\n  set<int> res;\n  bool flag = 0;\n  for (int i=l; i<r; ++i) {\n    if (s[i]=='(') nest++;\n    else if (s[i]==')') nest--;\n    if (nest == 0 && (s[i]=='/'||s[i]=='+'||s[i]=='*'||s[i]=='-')) {\n      flag = 1;\n      set<int> leftset = rec(l, i);\n      set<int> rightset = rec(i+1, r);\n      FOR(it, leftset) {\n        FOR(jt, rightset) {\n          if (s[i]=='/') {\n            if (*jt!=0)\n              res.insert(*it / *jt);\n          }\n          else if (s[i]=='+')\n            res.insert(*it + *jt);\n          else if (s[i]=='-')\n            res.insert(*it - *jt);\n          else if (s[i]=='*')\n            res.insert(*it * *jt);\n        }\n      }\n    }\n  }\n  if (!flag) {                    // ツ可可算ツ子ツ鳴ウツつオ\n    if (s[l]=='('&& s[r-1]==')') return rec(l+1,r-1);\n    res.insert(atoi(s.substr(l,r-l).c_str()));\n  }\n  // cout << s.substr(l,r-l) << endl;\n  // cout << \"res : \";\n  // FOR(it, res)\n  //   cout << *it << \" \";\n  // cout << endl;\n  return se[l][r] = res;\n}\n\nint main() {\n  while(cin>>s, s!=\"#\"){\n    int n = s.size();\n    REP(i,n) REP(j,n+1)\n      se[i][j].clear();\n    cout << rec(0,s.size()).size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define rep2(i,a,b) for(ll i=(a);i<(b);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\nstring s;\n\nbool isop(char ch){\n    if(ch=='+' || ch=='-' || ch=='*' || ch=='/')return true;\n    else return false;\n}\n\nvoid mul(set<int> a, set<int> b, char op, set<int> &ret){\n    for(auto e1:a){\n        for(auto e2:b){\n            if(op=='+')ret.insert(e1+e2);\n            if(op=='-')ret.insert(e1-e2);\n            if(op=='*')ret.insert(e1*e2);\n            if(op=='/'){\n                if(e2==0)continue;\n                ret.insert(e1/e2);\n            }\n        }\n    }\n}\n\nset<int> dfs(int l, int r){\n    if(s[l]=='(' && s[r-1]==')'){\n        l++,r--;\n    }\n    set<int> ret;\n    int c = 0;\n    \n    bool ops=false;\n    for(int i=l;i<r;i++){\n        if(s[i]=='(')c++;\n        else if(s[i]==')')c--;\n        else if( isop(s[i]) && c==0 ){\n            ops = true;\n            mul( dfs(l,i) , dfs(i+1,r), s[i], ret);\n        }\n    }\n    if(!ops)return set<int>{stoi(s.substr(l,r-l))};\n    return ret;\n}\n\nint main(){\n    while(cin>>s && s!=\"#\"){\n        set<int> res = dfs(0,s.size());\n        cout<<res.size()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MP make_pair\n\ntypedef pair<int, int> PII;\n\ninline int toInt(string s) { return atoi(s.c_str()); }\n \nstring line;\nset<int> memo[200][200];\nset<PII> used;\n \nvoid eval(int const l, int const r) {\n   \n  set<int>& ret = memo[l][r];\n  if(l == r) return;\n   \n  if(used.count(MP(l, r))) return;\n  used.insert(MP(l, r));\n   \n  // check is digits [l, r)\n  bool digits = true;\n  for(int i=l; i<r; i++) { digits = digits && isdigit(line[i]); }\n  if(digits) { ret.insert(toInt(line.substr(l, r-l))); return; }\n   \n  int par = 0; bool check = true;\n  for(int i=l; i<r-1; i++) {\n    if(line[i] == '(') { par ++; }\n    if(line[i] == ')') { par --; }\n    if(par == 0) { check = false; }\n  }\n   \n  // \"(expr)\"\n  if(check) {\n    if(line[r-1] == ')') {\n      eval(l+1, r-1); ret = memo[l+1][r-1]; return;\n    }\n  }\n   \n  par = 0;\n  // parsing loop\n  for(int i=l; i<r; i++) {\n    if(line[i] == '(') { par ++; }\n    if(line[i] == ')') { par --; }\n    if(par != 0) continue;\n     \n    switch(line[i]) {\n    case '+': case '-': case '*': case '/': {\n      eval(l, i); eval(i+1, r);\n      set<int>::iterator iter_a, iter_b;\n      for(iter_a = memo[l][i].begin(); iter_a!=memo[l][i].end(); iter_a++) {\n        for(iter_b = memo[i+1][r].begin(); iter_b!=memo[i+1][r].end(); iter_b++) {\n          if(line[i] == '+') { ret.insert(*iter_a + *iter_b); }\n          if(line[i] == '-') { ret.insert(*iter_a - *iter_b); }\n          if(line[i] == '*') { ret.insert(*iter_a * *iter_b); }\n          if(line[i] == '/') {\n            if(*iter_b == 0) continue;\n            ret.insert(*iter_a / *iter_b);\n          }\n        }\n      }\n      break;\n    }\n    default:;\n    }\n  } // for parsing loop\n}\n \nint main() {\n   \n  while(cin >> line) {\n    for(int i=0; i<200; i++)\n      for(int j=0; j<200; j++)\n        memo[i][j].clear();\n     \n    used.clear();\n     \n    if(line == \"#\") break;\n    eval(0, line.size());\n    cout << memo[0][line.size()].size() << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 300\n\nset<int> calc(char *s){\n  int r, counter  = 0;\n  \n  for(r=0;;r++){\n    if(s[r] == '(') counter++;\n    if(s[r] == ')') counter--;\n    if(counter < 0) break;\n  }\n  \n  set<int> num[11];\n  char op[11];\n\n  int pos = 0, curnum = 0, f = 0;\n  \n  for(int i=0;i<r;i++){\n    if(s[i] == '('){\n      num[pos] = calc(s+i+1);\n      int counter = -1;\n      while(1){\n        counter += (s[i] == '(') - (s[i] == ')');\n        if(counter < 0) break;\n        i++;\n      }\n      f = true;\n      continue;\n    }\n\n    if('0' <= s[i] && s[i] <= '9'){\n      curnum = curnum * 10 + (s[i] - '0');\n      continue;\n    }\n\n    if(!f)\n      num[pos] = {curnum};\n\n    op[pos] = s[i];\n    pos++;\n    curnum = 0;\n    f = false;\n  }\n  \n   if(!f) num[pos] = {curnum};\n   \n   if(pos == 0) return num[0];\n   \n  int per[11];\n  for(int i=0;i<pos;i++) per[i] = i;\n  \n  set<int> res;\n\n  \n  do{\n    bool used[11] = {};\n\n    set<int> temp[11];\n    for(int i=0;i<=pos;i++) temp[i] = num[i];\n    \n    for(int i=0;i<pos;i++){\n      int lnum = per[i];\n      int rnum = per[i]+1;\n\n      while(used[lnum]) lnum--;\n      while(used[rnum]) rnum++;\n      \n      set<int> cur;\n\n      for(int a : temp[lnum]){\n        for(int b : temp[rnum]){\n          switch(op[per[i]]){\n          case '+':\n            cur.insert(a + b);\n            break;\n          case '-':\n            cur.insert(a - b);\n            break;\n          case '*':\n            cur.insert(a * b);\n            break;\n          case '/':\n            if(b != 0) cur.insert(a / b);\n            break;\n          }\n        }\n      }\n\n      temp[lnum] = cur;\n      used[rnum] = true;\n    }\n\n    for(int a: temp[0]){\n      res.insert(a);\n    }\n\n  }while(next_permutation(per, per+pos));\n\n  /*\n  for(int i=0;i<r;i++){\n    printf(\"%c\", s[i]);\n  }\n  puts(\"\");\n  for(int a: res){\n    printf(\" = %d\\n\", a);\n  }\n  */\n  \n  return res;\n}\n\nint solve(){\n  char formula[SIZE];\n\n  scanf(\"%s\", formula);\n  int n = strlen(formula);\n  formula[n] = ')';\n  n++;\n  \n  if(formula[0] == '#') return false;\n\n  printf(\"%d\\n\", (int)calc(formula).size());\n\n  return true;\n}\n\nint main(){\n  while(solve());\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nmap< string, set< int > > memo;\n\nint isalldigit(const string& str)\n{\n  for(int i = 0; i < str.size(); i++){\n    if(!isdigit(str[i])) return false;\n  }\n  return true;\n}\n\nbool dahara(const string& str){\n  int foo = 0;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == '(') foo++;\n    else if(str[i] == ')') foo--;\n    else if(foo == 0) return false;\n  }\n  return true;\n}\n\nset< int > expr(string str)\n{\n  if(memo.find(str) != memo.end()){\n    return memo[str];\n  }\n\n  set< int > ret;\n\n  int foo = 0 ;\n  if(isalldigit(str)){\n    ret.insert(atoi(str.c_str()));\n  } else if (dahara(str)){\n    return memo[str] = expr( str.substr( 1, str.size() - 2));\n  } else {\n    for(int i = 0; i < str.size(); i++){\n      if(str[i] == '('){ //開き括弧だなぁ\n        foo++;\n        continue;\n      } else if(str[i] == ')'){ //閉じ括弧だなぁ \n        foo--;\n        continue;\n      } else if(isdigit(str[i])){ //数字はどうでもいいなぁ\n        continue;\n      }\n      if(foo == 0){\n        set< int > hori = expr(str.substr( 0, i));\n        set< int > tkc = expr(str.substr( i + 1));\n        for(set< int >::iterator msy = hori.begin(); msy != hori.end(); msy++){\n          for(set< int >::iterator mtur = tkc.begin(); mtur != tkc.end(); mtur++){\n            if(str[i] == '+'){\n              ret.insert( *msy + *mtur);\n            } else if(str[i] == '-'){\n              ret.insert( *msy - *mtur);\n            } else if(str[i] == '*'){\n              ret.insert( *msy * *mtur);\n            } else {\n              if(*mtur == 0) continue;\n              ret.insert( *msy / *mtur);\n            }\n          }\n        }\n      }\n    }\n  }\n  return memo[str] = ret;\n}\n\n\nint main()\n{\n  string s;\n  while(cin >> s, s != \"#\"){\n    cout << expr(s).size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int INF = 1e9;\nint N, M;\nint opPos[10];\nint depth[10];\nint num[10];\nstring s;\nset<int> ans;\nint c;\n\nbool isOperator(char c) {\n\treturn c == '+' || c == '-' || c == '*' || c == '/';\n}\n\nvoid dfs(int d) {\n\twhile(c < N && s[c] != ')') {\n\t\tif(s[c] == '(') {\n\t\t\tc++;\n\t\t\tdfs(d + 1);\n\t\t\tassert(s[c] == ')');\n\t\t}\n\t\tif(isOperator(s[c])) {\n\t\t\tfor(int i = 0; i < M; i++) {\n\t\t\t\tif(opPos[i] == c) depth[i] = d;\n\t\t\t}\n\t\t}\n\t\tc++;\n\t}\n}\n\nint findMinPos(int l, int r) {\n\tint minId = -1;\n\tfor(int i = 0; i < M; i++) {\n\t\tif(l <= opPos[i] && opPos[i] <= r) {\n\t\t\tif(minId == -1 || num[minId] > num[i]) minId = i;\n\t\t}\n\t}\n\tif(minId == -1) return -1;\n\treturn opPos[minId];\n}\n\nint R(double n) {\n\tif(n > 0) return (int)floor(n);\n\treturn (int)ceil(n);\n\tdouble an = abs(n);\n\tint ret = round(an - 1e-9);\n\tif(n < 0) ret *= -1;\n\treturn ret;\n}\n\nint f(int l, int r) {\n\tint minPos = findMinPos(l, r);\n\tif(minPos == -1) {\n\t\tint ret = 0;\n\t\tif(s[l] == '(') l++;\n\t\tif(s[r] == ')') r--;\n\t\tfor(int i = l; i <= r; i++) {\n\t\t\tret = ret * 10 + s[i] - '0';\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint vl = f(l, minPos - 1), vr = f(minPos + 1, r);\n\tif(vl == INF || vr == INF) return INF;\n\tchar op = s[minPos];\n\tif(op == '+') return vl + vr;\n\tif(op == '-') return vl - vr;\n\tif(op == '*') return vl * vr;\n\tif(vr == 0) return INF;\n\tint ret = R((double)vl / vr);\n\treturn ret;\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> s, s != \"#\") {\n\t\tN = s.size();\n\t\tM = 0;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tif(isOperator(s[i])) {\n\t\t\t\topPos[M] = i;\n\t\t\t\tdepth[M] = 0;\n\t\t\t\tM++;\n\t\t\t}\n\t\t}\n\t\tc = 0;\n\t\tdfs(0);\n\n\t\tvector<int> p(M);\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tp[i] = i;\n\t\t}\n\n\t\tans.clear();\n\t\tdo {\n\t\t\tfor(int i = 0; i < M; i++) {\n\t\t\t\tnum[i] = p[i] + depth[i] * 100;\n\t\t\t}\n\t\t\tint res = f(0, N - 1);\n\t\t\tif(res != INF) ans.insert(res);\n\t\t} while(next_permutation(p.begin(), p.end()));\n\n\t\tcout << ans.size() << endl;\n\t\t/*for(auto a : ans) {\n\t\t\tcout << a << \" \";\n\t\t}\n\t\tcout << endl;*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// infty\n#define ULLINF (ULLONG_MAX)\n#define LLINF  (LLONG_MAX)\n#define IINF   (INT_MAX)\n#define INF    (1<<29)\n\n// math\n#define Sq(x) ((x)*(x))\n\n// container utility\n#define ALL(x) (x).begin(), (x).end()\n#define MP make_pair\n#define PB push_back\n\n// rep\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\n// typedef\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\n\ntypedef long long ll;\n\n// pair util\n#define FST first\n#define SND second\n\n// range validator\n#define CK(n,a,b) (a<=n && n<b)\n\n// conversion\ntemplate<class T> inline string toStr(T a) { ostringstream oss_; oss_ << a; return oss_.str(); }\ninline int toInt(string s) { return atoi(s.c_str()); }\n\n// prime\nbool isPrime(int a) { for(int i=2; i*i <=a; i++) if(a%i == 0) return false; return true; }\n\nint const dx[] = {-1,0,1,0,-1,1,1,-1};\nint const dy[] = {0,-1,0,1,-1,-1,1,1};\n\n//////////////////////////////////////////////////////////////\n\nstring line;\nset<int> memo[200][200];\nset<PII> used;\n\nset<int> eval(int const l, int const r) {\n  \n  /*\n  for(int i=l; i<r; i++) cout << line[i];\n  cout << endl;\n  */\n  set<int>& ret = memo[l][r];\n  if(l == r) return ret;\n  \n  if(used.count(MP(l, r))) return ret;\n  used.insert(MP(l, r));\n  \n  // check is digits [l, r)\n  bool digits = true;\n  for(int i=l; i<r; i++) { digits = digits && isdigit(line[i]); }\n  if(digits) { ret.insert(toInt(line.substr(l, r-l))); return ret; }\n  \n  int par = 0; bool check = true;\n  for(int i=l; i<r-1; i++) {\n    if(line[i] == '(') { par ++; }\n    if(line[i] == ')') { par --; }\n    if(par == 0) { check = false; }\n  }\n  \n  // \"(expr)\"\n  if(check) {\n    if(line[r-1] == ')') {\n      /*\n      for(int i=l; i<r; i++) cout << line[i];\n      cout << endl;\n      */\n      return ret = eval(l+1, r-1);\n    }\n  }\n  \n  par = 0;\n  // parsing loop\n  for(int i=l; i<r; i++) {\n    if(line[i] == '(') { par ++; }\n    if(line[i] == ')') { par --; }\n    if(par != 0) continue;\n    \n    switch(line[i]) {\n    case '+': case '-': case '*': case '/': {\n      set<int> st_a = eval(l, i), st_b = eval(i+1, r);\n      set<int>::iterator iter_a, iter_b;\n      for(iter_a = st_a.begin(); iter_a!=st_a.end(); iter_a++) {\n\tfor(iter_b = st_b.begin(); iter_b!=st_b.end(); iter_b++) {\n\t  if(line[i] == '+') { ret.insert(*iter_a + *iter_b); }\n\t  if(line[i] == '-') { ret.insert(*iter_a - *iter_b); }\n\t  if(line[i] == '*') { ret.insert(*iter_a * *iter_b); }\n\t  if(line[i] == '/') {\n\t    if(*iter_b == 0) continue;\n\t    ret.insert(*iter_a / *iter_b);\n\t  }\n\t}\n      }\n      break;\n    }\n    default:;\n    }\n  } // for parsing loop\n  \n  return ret;\n}\n\nint main() {\n  \n  while(cin >> line) {\n    for(int i=0; i<200; i++)\n      for(int j=0; j<200; j++)\n\tmemo[i][j].clear();\n    \n    used.clear();\n    \n    if(line == \"#\") break;\n    cout << eval(0, line.size()).size() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) rep(i, 0, n)\nusing namespace std;\n\nset<int> memo[20][20];\n\nset<int> rec(int l, int r, vector<set<int>>& vals, vector<char>& ops) {\n    if (!memo[l][r].empty()) return memo[l][r];\n    if (l + 1 == r) return memo[l][r] = vals[l];\n    vector<set<int>> L, R;\n    L.emplace_back(vals[l]);\n    for (int i = r - 1; i > l; --i) R.emplace_back(vals[i]);\n    set<int> res;\n    for (int i = l; i < r - 1; ++i) {\n        set<int> tmp1 = rec(l, i + 1, vals, ops);\n        set<int> tmp2 = rec(i + 1, r, vals, ops);\n        for (int v1 : tmp1) for (int v2 : tmp2) {\n            if (ops[i] == '+') res.emplace(v1 + v2);\n            else if (ops[i] == '-') res.emplace(v1 - v2);\n            else if (ops[i] == '*') res.emplace(v1 * v2);\n            else if (v2 != 0) res.emplace(v1 / v2);\n        }\n        L.emplace_back(vals[i + 1]);\n        R.pop_back();\n    }\n    return memo[l][r] = res;\n}\n\nset<int> num(const string& s, int& i) {\n    int tmp = (s[i++] - '0');\n    while (isdigit(s[i])) tmp = tmp * 10 + (s[i++] - '0');\n    set<int> res;\n    res.emplace(tmp);\n    return res;\n}\n\nset<int> expr(const string& s, int& i) {\n    int l = i;\n    vector<set<int>> vals;\n    vector<char> ops;\n    if (s[i] == '(') {\n        ++i;    // skip '('\n        vals.emplace_back(expr(s, i));\n        ++i;    // skip ')'\n    } else {\n        vals.emplace_back(num(s, i));\n    }\n    while (s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/') {\n        ops.emplace_back(s[i]);\n        ++i;    // skip op\n        if (s[i] == '(') {\n            ++i;    // skip '('\n            vals.emplace_back(expr(s, i));\n            ++i;    // skip ')'\n        } else {\n            vals.emplace_back(num(s, i));\n        }\n    }\n    REP(i, 20) REP(j, 20) memo[i][j].clear();\n    return rec(0, vals.size(), vals, ops);\n}\n\nsigned main() {\n    string s;\n    while (cin >> s, s != \"#\") {\n        int i = 0;\n        cout << expr(s, i).size() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<set>\n#include<vector>\nusing namespace std;\nchar str[210];\nint cur;\nset<int> expr();\nset<int> dig(){\n\tif(str[cur]=='('){\n\t\tcur++;\n\t\tset<int>R=expr();\n\t\tcur++;\n\t\treturn R;\n\t}\n\tint ret=0;\n\twhile('0'<=str[cur]&&str[cur]<='9'){\n\t\tret*=10;\n\t\tret+=str[cur]-'0';\n\t\tcur++;\n\t}\n\t//printf(\"%d\\n\",ret);\n\tset<int>r;r.insert(ret);\n\treturn r;\n}\nset<int> expr(){\n\tvector<set<int> > num;\n\tvector<char> op;\n\tnum.push_back(dig());\n\twhile(str[cur]=='+'||str[cur]=='-'||str[cur]=='/'||str[cur]=='*'){\n\t\top.push_back(str[cur]);\n\t\tcur++;\n\t\tnum.push_back(dig());\n\t}\n\tset<int>ret;\n\tint n=op.size();\n\tvector<int>perm(n);for(int i=0;i<n;i++)perm[i]=i;\n\tdo{\n\t\tvector<set<int> > tmp=num;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint L=perm[i];\n\t\t\tint R=perm[i]+1;\n\t\t\tchar opr=op[perm[i]];\n\t\t\twhile(!num[L].size()){\n\t\t\t\tL--;\n\t\t\t}\n\t\t\tset<int>to;\n\t\t\tfor(set<int>::iterator i1=tmp[L].begin();i1!=tmp[L].end();i1++){\n\t\t\t\tfor(set<int>::iterator i2=tmp[R].begin();i2!=tmp[R].end();i2++){\n\t\t\t\t\tif(opr=='+')to.insert((*i1)+(*i2));\n\t\t\t\t\tif(opr=='-')to.insert((*i1)-(*i2));\n\t\t\t\t\tif(opr=='*')to.insert((*i1)*(*i2));\n\t\t\t\t\tif(opr=='/'&&(*i2))to.insert((*i1)/(*i2));\n\t\t\t\t}\t\n\t\t\t}\n\t\t\ttmp[L]=to;\n\t\t\ttmp[R].clear();\n\t\t}\n\t\tfor(set<int>::iterator it=tmp[0].begin();it!=tmp[0].end();it++)\n\t\t\tret.insert(*it);\n\t}while(next_permutation(perm.begin(),perm.end()));\n\t//printf(\"%d \",ret.size());\n\treturn ret;\n}\nint main(){\n\twhile(1){\n\t\tscanf(\"%s\",str);\n\t\tif(str[0]=='#')break;\n\t\tcur=0;\n\t\tset<int>ret=expr();\n\t\tprintf(\"%d\\n\",ret.size());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct UnionFind {\n\tvector<int> parent;\n\tint size;\n\tUnionFind(int n) :parent(n, -1), size(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y)return false;\n\t\tif (size_of(x) < size_of(y))swap(x, y);\n\t\tparent[x] += parent[y]; parent[y] = x; size--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n\tint size_of(int x) { return -parent[root(x)]; }\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (string s; cin >> s&&s != \"#\";) {\n\t\tvector<int> a;\n\t\tvector<char> b;\n\t\tfor (auto it = s.begin(); it != s.end();) {\n\t\t\tif (!isdigit(*it)) {\n\t\t\t\tif (*it != '(' && *it != ')') {\n\t\t\t\t\tb.emplace_back(*it);\n\t\t\t\t}\n\t\t\t\tit++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint num = 0;\n\t\t\t\twhile (it != s.end() && isdigit(*it)) {\n\t\t\t\t\tnum *= 10;\n\t\t\t\t\tnum += *it - '0';\n\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t\ta.emplace_back(num);\n\t\t\t}\n\t\t}\n\t\tdump(a, b);\n\t\tint n = a.size(), m = b.size();\n\t\tassert(n - 1 == m);\n\t\tvector<int> d(m);\n\t\tint idx = 0;\n\t\tint depth = 0;\n\t\trep(i, 0, s.size()) {\n\t\t\tif (s[i] == '(')depth++;\n\t\t\telse if (s[i] == ')')depth--;\n\t\t\telse if (!isdigit(s[i])) {\n\t\t\t\td[idx] = depth;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\tdump(d);\n\t\tint maxd = *max_element(all(d));\n\t\tdump(maxd);\n\t\tvector<int> p(m);\n\t\tiota(all(p), 0);\n\t\tunordered_set<int> st;\n\t\tdo {\n\t\t\tbool invalid = false;\n\t\t\tint mind = INF;\n\t\t\trep(i, 0, m) {\n\t\t\t\tif (mind < d[p[i]])\n\t\t\t\t\tinvalid = true;\n\t\t\t\tchmin(mind, d[p[i]]);\n\t\t\t}\n\t\t\tif (invalid)\n\t\t\t\tcontinue;\n\t\t\tdump(p);\n\t\t\tvector<int> ta = a;\n\t\t\tUnionFind c(n);\n\t\t\trep(i, 0, m) {\n\t\t\t\tint idx = p[i];\n\t\t\t\tint xi = c.root(idx), yi = c.root(idx + 1);\n\t\t\t\tint x = ta[xi], y = ta[yi];\n\t\t\t\tdump(x, b[idx], y);\n\t\t\t\tif (b[idx] == '+')\n\t\t\t\t\tx += y;\n\t\t\t\telse if (b[idx] == '-')\n\t\t\t\t\tx -= y;\n\t\t\t\telse if (b[idx] == '*')\n\t\t\t\t\tx *= y;\n\t\t\t\telse {\n\t\t\t\t\tif (y == 0) {\n\t\t\t\t\t\tinvalid = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tx /= y;\n\t\t\t\t}\n\t\t\t\tta[xi] = ta[yi] = x;\n\t\t\t\tc.unite(xi, yi);\n\t\t\t\tdump(ta);\n\t\t\t}\n\t\t\tif (invalid)\n\t\t\t\tcontinue;\n\t\t\tst.emplace(ta[c.root(0)]);\n\t\t} while (next_permutation(all(p)));\n\t\tcout << st.size() << endl;\n\t\tdump(st);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint digit(string &s,int &p){\n\t//<digit> ::= \"0\" | \"1\" | \"2\" | \"3\" | \"4\"\n\t//          | \"5\" | \"6\" | \"7\" | \"8\" | \"9\"\n\treturn s[p++]-'0';\n}\n\nint num(string &s,int &p){\n\t//<num> ::= <digit> | <num> <digit>\n\tassert(isdigit(s[p]));\n\tint num=digit(s,p);\n\twhile(isdigit(s[p])){\n\t\tnum*=10;\n\t\tnum+=digit(s,p);\n\t}\n\treturn num;\n}\n\nbool isop(char c){\n\treturn c=='+'||c=='-'||c=='*'||c=='/';\n}\n\nint expr(string &s,int &p,vi &perm){\n\t//<expr> ::= <num>\n\t//        | \"(\" <expr> \")\"\n\t//        | <expr> \"+\" <expr>\n\t//        | <expr> \"-\" <expr>\n\t//        | <expr> \"*\" <expr>\n\t//        | <expr> \"/\" <expr>\n\tvi e;\n\tvector<pair<int,char> >ops;\n\n\tbool par=false;\n\tif(s[p]=='('){\n\t\tp++;\n\t\tpar=true;\n\t}else{\n\t\treturn num(s,p);\n\t}\n\te.push_back(expr(s,p,perm));\n\tif(e[e.size()-1]==INT_MAX){\n\t\treturn INT_MAX;\n\t}\n\twhile(isop(s[p])){\n\t\tops.push_back(make_pair(p,s[p]));\n\t\tp++;\n\t\te.push_back(expr(s,p,perm));\n\t\tif(e[e.size()-1]==INT_MAX){\n\t\t\treturn INT_MAX;\n\t\t}\n\t}\n\tif(par){\n\t\tassert(s[p]==')');\n\t\tp++;\n\t}\n\n\tREP(i,perm.size()){\n\t\tint opi=-1;\n\t\tREP(j,ops.size()){\n\t\t\tif(ops[j].first==perm[i]){\n\t\t\t\topi=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(opi==-1){\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch(ops[opi].second){\n\t\tcase '+':\n\t\t\t{\n\t\t\t\tint val=e[opi]+e[opi+1];\n\t\t\t\te.erase(e.begin()+opi);\n\t\t\t\te.erase(e.begin()+opi);\n\t\t\t\te.insert(e.begin()+opi,val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\t{\n\t\t\t\tint val=e[opi]-e[opi+1];\n\t\t\t\te.erase(e.begin()+opi);\n\t\t\t\te.erase(e.begin()+opi);\n\t\t\t\te.insert(e.begin()+opi,val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\t{\n\t\t\t\tint val=e[opi]*e[opi+1];\n\t\t\t\te.erase(e.begin()+opi);\n\t\t\t\te.erase(e.begin()+opi);\n\t\t\t\te.insert(e.begin()+opi,val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\t{\n\t\t\t\tif(e[opi+1]==0){\n\t\t\t\t\treturn INT_MAX;\n\t\t\t\t}\n\t\t\t\tdouble val=(double)e[opi]/e[opi+1];\n\t\t\t\tdouble intpart;\n\t\t\t\tmodf(val,&intpart);\n\t\t\t\te.erase(e.begin()+opi);\n\t\t\t\te.erase(e.begin()+opi);\n\t\t\t\te.insert(e.begin()+opi,(int)intpart);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t}\n\t\tops.erase(ops.begin()+opi);\n\t}\n\n\treturn e[0];\n}\n\n\nint main(){\n\tstring s;\n\twhile(cin>>s,s!=\"#\"){\n\t\ts=\"(\"+s;\n\t\ts+=\")\";\n\t\tvi perm;\n\t\tREP(i,s.size()){\n\t\t\tif(isop(s[i])){\n\t\t\t\tperm.push_back(i);\n\t\t\t}\n\t\t}\n\t\tset<int> ans;\n\t\tdo{\n\t\t\tvi permrev(s.size());\n\t\t\tREP(i,perm.size()){\n\t\t\t\tpermrev[perm[i]]=i;\n\t\t\t}\n\t\t\tint p=0;\n\t\t\tint e=expr(s,p,perm);\n\t\t\tif(e!=INT_MAX){\n\t\t\t\tans.insert(e);\n\t\t\t}\n\t\t}while(next_permutation(ALL(perm)));\n\t\tcout<<ans.size()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nstring s;\n\ntypedef string::const_iterator State;\n\nset<int> factor(State& begin);\nset<int> digit(State& begin);\n\nset<int> expr(State& begin) {\n  vector<char> op;\n  vector<set<int>> num;\n  while(begin != s.end() && *begin != ')') {\n    if(*begin == '+') {\n      op.PB('+'); begin++;\n    } else if(*begin == '-') {\n      op.PB('-'); begin++;\n    } else if(*begin == '*') {\n      op.PB('*'); begin++;\n    } else if(*begin == '/') {\n      op.PB('/'); begin++;\n    } else if(*begin == '(') {\n      num.PB(factor(begin));\n    } else {\n      num.PB(digit(begin));\n    }\n  }\n\n  // for(char i: op) cout << i << \" \"; cout << endl;\n  // for(auto i: num) {\n  //   for(auto j: i) cout << j << \" \"; cout << endl;\n  // }\n\n  set<int> ret;\n  VI per(op.size());\n  REP(i, op.size()) per[i] = i;\n  do {\n    VI p(per);\n    for(int i=per.size()-1; i>=0; --i) {\n      int tmp = 0;\n      REP(j, i) {\n        if(p[j] < p[i]) tmp++;\n      }\n      p[i] -= tmp;\n    }\n    // for(int i: per) cout << i << \" \"; cout << endl;\n    vector<set<int>> num2(num);\n    REP(i, per.size()) {\n      // cout << \"p[i]:\" << p[i] << endl;\n      // p[i] ??¨ p[i]+1??????????????????????????????\n      if(op[per[i]] == '+') {\n        set<int> tmp;\n        for(int j: num2[p[i]]) for(int k: num2[p[i]+1]) {\n          tmp.insert(j+k);\n          // cout << j+k << \" \";\n        }\n        // cout << endl;\n        num2[p[i]] = tmp;\n        num2.erase(num2.begin()+p[i]+1);\n      } else if(op[per[i]] == '-') {\n        set<int> tmp;\n        for(int j: num2[p[i]]) for(int k: num2[p[i]+1]) {\n          tmp.insert(j-k);\n        }\n        num2[p[i]] = tmp;\n        num2.erase(num2.begin()+p[i]+1);\n      } else if(op[per[i]] == '*') {\n        set<int> tmp;\n        for(int j: num2[p[i]]) for(int k: num2[p[i]+1]) {\n          tmp.insert(j*k);\n        }\n        num2[p[i]] = tmp;\n        num2.erase(num2.begin()+p[i]+1);\n      } else if(op[per[i]] == '/') {\n        set<int> tmp;\n        for(int j: num2[p[i]]) for(int k: num2[p[i]+1]) {\n          if(k == 0) continue;\n          tmp.insert(j/k);\n        }\n        num2[p[i]] = tmp;\n        num2.erase(num2.begin()+p[i]+1);\n      }\n      // for(auto j: num2) {\n      //   for(auto k: j) cout << k << \",\"; cout << \" \";\n      // }\n      // cout << endl;\n    }\n    // cout << endl;\n    for(int i: num2[0]) ret.insert(i);\n  } while(next_permutation(ALL(per)));\n  return ret;\n}\n\nset<int> factor(State& begin) {\n  begin++;\n  set<int> ret = expr(begin);\n  begin++;\n  return ret;\n}\n\nset<int> digit(State& begin) {\n  int ret = 0;\n  while(isdigit(*begin)) {\n    ret *= 10;\n    ret += *begin - '0';\n    begin++;\n  }\n  return {ret};\n}\n\nsigned main(void)\n{\n  while(true) {\n    cin >> s;\n    if(s == \"#\") break;\n    State begin = s.begin();\n    set<int> ret = expr(begin);\n    // for(int i: ret) cout << i << \" \"; cout << endl;\n    cout << ret.size() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint isalldigit(const string& str)\n{\n  for(int i = 0; i < str.size(); i++){\n    if(!isdigit(str[i])) return false;\n  }\n  return true;\n}\n\nbool dahara(const string& str){\n  int foo = 0;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == '(') foo++;\n    else if(str[i] == ')') foo--;\n    else if(foo == 0) return false;\n  }\n  return true;\n}\n\nset< int > expr(string str)\n{\n  set< int > ret;\n\n  int foo = 0 ;\n  if(isalldigit(str)){\n    ret.insert(atoi(str.c_str()));\n  } else if (dahara(str)){\n    return expr( str.substr( 1, str.size() - 2));\n  } else {\n    for(int i = 0; i < str.size(); i++){\n      if(str[i] == '('){ //開き括弧だなぁ\n        foo++;\n        continue;\n      } else if(str[i] == ')'){ //閉じ括弧だなぁ \n        foo--;\n        continue;\n      } else if(isdigit(str[i])){ //数字はどうでもいいなぁ\n        continue;\n      }\n      if(foo == 0){\n        set< int > hori = expr(str.substr( 0, i));\n        set< int > tkc = expr(str.substr( i + 1));\n        for(set< int >::iterator msy = hori.begin(); msy != hori.end(); msy++){\n          for(set< int >::iterator mtur = tkc.begin(); mtur != tkc.end(); mtur++){\n            if(str[i] == '+'){\n              ret.insert( *msy + *mtur);\n            } else if(str[i] == '-'){\n              ret.insert( *msy - *mtur);\n            } else if(str[i] == '*'){\n              ret.insert( *msy * *mtur);\n            } else {\n              if(*mtur == 0) continue;\n              ret.insert( *msy / *mtur);\n            }\n          }\n        }\n      }\n    }\n  }\n  return ret;\n}\n\n\nint main()\n{\n  string s;\n  while(cin >> s, s != \"#\"){\n    cout << expr(s).size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nvoid dfs(vector<set<int>>& nums, string ops, set<int>& ret){\n    int len = ops.size();\n\n    if(len == 0){\n        for(auto & e : nums[0]){\n            ret.insert(e);\n        }\n        return;\n    }\n\n    rep(i, len){\n        char op = ops[i];\n\n        set<int> next;\n        for(auto & l : nums[i]){\n            for(auto & r : nums[i + 1]){\n                switch(op){\n                    case '+': { next.insert(l + r); break; }\n                    case '-': { next.insert(l - r); break; }\n                    case '*': { next.insert(l * r); break; }\n                    case '/': { if(r == 0) break; next.insert(l / r); break; }\n                }\n            }\n        }\n\n        if(next.size() == 0){\n            continue;\n        }\n\n        vector<set<int>> nnums;\n        string nops = \"\";\n        rep(j, len + 1){\n            if(j == i){\n                nnums.push_back(next);\n                continue;\n            }\n\n            if(j < len) nops.push_back(ops[j]);\n            if(j != i + 1) nnums.push_back(nums[j]);\n        }\n\n        dfs(nnums, nops, ret);\n    }\n}\n\nset<int> parse(string& str, int& idx){\n    vector<set<int>> nums;\n    string ops;\n\n    int len = str.size();\n    while(true){\n        if(str[idx] == '('){\n            idx++;\n            nums.push_back(parse(str, idx));\n        }\n        else {\n            int cur = 0;\n            while(idx < len and '0' <= str[idx] and str[idx] <= '9'){\n                cur = 10 * cur + (str[idx] - '0');\n                idx++;\n            }\n            nums.push_back({cur});\n        }\n\n        if(idx == len){\n            break;\n        }\n        if(str[idx] == ')'){\n            idx++;\n            break;\n        }\n\n        ops.push_back(str[idx]);\n        idx++;\n    }\n\n    set<int> s;\n    dfs(nums, ops, s);\n\n    return s;\n}\n\nint main(void){\n    for(string in; cin >> in, in != \"#\";){\n        int idx = 0;\n        cout << parse(in, idx).size() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst int tx[] = {+0,+1,+0,-1};\nconst int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\nint main(){\n  string str;\n  while(cin >> str){\n    if(str == \"#\") break;\n    vector<string> elems;\n    string tmp = \"\";\n\n    vector<char> ope;\n    vector<int> nums;\n    vector<int> ope_depth;\n    int depth = 0; \n\n    for(int i = 0; i < str.size(); i++){\n      if(str[i] == '+' || str[i] == '-' || str[i] == '/' || str[i] == '*'){\n        if(tmp != \"\") nums.push_back(atoi(tmp.c_str()));\n        tmp = \"\";\n        ope.push_back(str[i]);\n        ope_depth.push_back(depth);\n      }\n      else if(str[i] == '('){\n        if(tmp != \"\") nums.push_back(atoi(tmp.c_str()));\n        tmp = \"\";\n        depth++;\n      }\n      else if(str[i] == ')'){\n        if(tmp != \"\") nums.push_back(atoi(tmp.c_str()));\n        tmp = \"\";\n        depth--;\n      }\n      else{\n        tmp += str[i];\n      }\n    }\n    if(tmp != \"\") nums.push_back(atoi(tmp.c_str()));\n\n    vector<int> order;\n    for(int i = 0; i < ope.size(); i++){\n      order.push_back(i);\n    }\n    \n    set<int> res;\n    vector<int> orig = nums;\n\n    do {\n      nums = orig;\n      int min_depth = INF;\n      bool is_valid = true;\n      bool used[12] = {};\n      for(int i = 0; i < order.size(); i++){\n        if(min_depth < ope_depth[order[i]]){\n          goto over;\n        }\n        min_depth = min(min_depth,ope_depth[order[i]]);\n      }\n\n      for(int i = 0; i < order.size(); i++){\n        int ans = 0;\n        if(ope[order[i]] == '+') ans = nums[order[i]] + nums[order[i]+1];\n        else if(ope[order[i]] == '-') ans = nums[order[i]] - nums[order[i]+1];\n        else if(ope[order[i]] == '*') ans = nums[order[i]] * nums[order[i]+1];\n\n        else if(ope[order[i]] == '/'){\n          if(nums[order[i]+1] == 0){\n            goto over;\n          }\n          ans = nums[order[i]] / nums[order[i]+1];\n        }\n\n        nums[order[i]] = nums[order[i]+1] = ans;\n        for(int offset = 0; order[i]+ offset < nums.size(); offset++){\n          if(used[order[i] + offset]){\n            nums[order[i] + offset] = ans;\n          }\n          else{\n            break;\n          }\n        }\n        for(int offset = 0; order[i] - offset >= 0; offset++){\n          if(used[order[i] - offset]){\n            nums[order[i] - offset] = ans;\n          }\n          else{\n            break;\n          }\n        }\n        used[order[i]] = used[order[i]+1] = true;\n      }\n\n      res.insert(nums[0]);\n    over:;\n    }while(next_permutation(order.begin(),order.end()));\n    cout << res.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return conj(P(imag(a),real(a)));}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n  return\n    min4(spdist(a,b.F),spdist(a,b.S),\n         spdist(b,a.F),spdist(b,a.S));\n}\n\nstring in;\nmap<PI,set<ll> > memo;\nset<ll> rec(int s,int e){\n  if(memo.count(mp(s,e)))\n    return memo[mp(s,e)];\n\n  set<ll> &ret=memo[mp(s,e)];\n  bool ok=0;\n  int u=0;\n  ll nu=0;\n  for(int idx=s;idx<e;++idx){\n    nu=nu*10+in[idx]-'0';\n    if(in[idx]=='(') ++u;\n    if(in[idx]==')') --u;\n    if(u || (in[idx]!='+' && in[idx]!='-' &&\n             in[idx]!='*' && in[idx]!='/')) continue;\n    ok=true;\n    set<ll> a=rec(s,idx);\n    set<ll> b=rec(idx+1,e);\n    switch(in[idx]){\n    case '+':FOR(ia,a)FOR(ib,b)ret.insert(*ia+*ib);break;\n    case '-':FOR(ia,a)FOR(ib,b)ret.insert(*ia-*ib);break;\n    case '*':FOR(ia,a)FOR(ib,b)ret.insert(*ia**ib);break;\n    case '/':\n      FOR(ia,a)FOR(ib,b)\n        if(*ib)ret.insert(*ia/ *ib);\n      break;\n    }\n  }\n\n  /*\n  cout << s << ' ' << e << endl;\n  cout << SZ(ret) << endl;\n  FOR(it,ret) cout << *it << endl;\n  */\n  if(ok) return ret;\n  if(in[s]=='(') return ret=rec(s+1,e-1);\n  ret.insert(nu);\n  return ret;\n}\n\nvoid solve(){\n  memo.clear();\n  cout << rec(0,SZ(in)).size() << endl;\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> in && in!=\"#\") solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nbool cyk[201][201][15];\n\nint main() {\n  while (true) {\n    string s;\n    cin>>s;\n    if (s == \"#\") break;\n    cout<<s<<endl;\n    int n = s.size();\n    vector<vector<vector<set<int>>>> dp(n+1, vector<vector<set<int>>>(n+1, vector<set<int>>(15)));\n    REP(i,n+1)REP(j,n+1)REP(k,15) cyk[i][j][k] = false;\n    REP(i,n+1) {\n      cyk[i][0][14] = true;\n    }\n    REP(i,n) {\n      if (isdigit(s[i])) {\n        cyk[i][1][2] = true;\n        dp[i][1][2].insert(s[i] - '0');\n      } else {\n        switch (s[i]) {\n          case '(':\n          cyk[i][1][8] = true;\n          break;\n          case ')':\n          cyk[i][1][9] = true;\n          break;\n          case '+':\n          cyk[i][1][10] = true;\n          break;\n          case '-':\n          cyk[i][1][11] = true;\n          break;\n          case '*':\n          cyk[i][1][12] = true;\n          break;\n          case '/':\n          cyk[i][1][13] = true;\n          break;\n        }\n      }\n    }\n    using T = tuple<int,int,int>;\n    vector<T> rule = {\n      T( 8, 3, 0),\n      T( 0, 4, 0),\n      T( 0, 5, 0),\n      T( 0, 6, 0),\n      T( 0, 7, 0),\n      T( 0, 9, 3),\n      T(10, 0, 4),\n      T(11, 0, 5),\n      T(12, 0, 6),\n      T(13, 0, 7),\n      T( 1, 2, 1),\n      T( 2,14, 1),\n      T( 1,14, 0)\n    };\n     \n    FOR(l,1,n+1)REP(i,n) {\n      FOR(k,1,l+1)REP(m,rule.size()) {\n        int first, second, result;\n        tie(first, second, result) = rule[m];\n        if (cyk[i][k][first] && cyk[i+k][l-k][second]) {\n          cyk[i][l][result] = true;\n          switch(m) {\n            case 0: // <(> + <3>\n            case 6: // <+> + <expr>\n            case 7: // <-> + <expr>\n            case 8: // <*> + <expr>\n            case 9: // </> + <expr>\n              dp[i][l][result] = dp[i+k][l-k][second];\n              break;\n            case 5: // <expr> + <)>\n            case 11: // <digit> + empty\n            case 12: // <num> + empty\n              dp[i][l][result] = dp[i][k][first];\n              break;\n            case 1: // <expr> + <4>\n              for (int x:dp[i][k][first]) {\n                for (int y:dp[i+k][l-k][second]) {\n                  dp[i][l][result].insert(x+y);\n                }\n              }\n              break;\n            case 2: // <expr> + <5>\n              for (int x:dp[i][k][first]) {\n                for (int y:dp[i+k][l-k][second]) {\n                  dp[i][l][result].insert(x-y);\n                }\n              }\n              break;\n            case 3: // <expr> + <6>\n              for (int x:dp[i][k][first]) {\n                for (int y:dp[i+k][l-k][second]) {\n                  dp[i][l][result].insert(x*y);\n                }\n              }\n              break;\n            case 4: // <expr> + <7>\n              for (int x:dp[i][k][first]) {\n                for (int y:dp[i+k][l-k][second]) {\n                  if (y != 0) {\n                    dp[i][l][result].insert(x/y);\n                  }\n                }\n              }\n              break;\n            case 10: // <num> + <digit>\n              dp[i][l][result].insert(\n                  *begin(dp[i][k][first]) * 10 + *begin(dp[i+k][l-k][second]));\n              break;\n          }\n        }\n      }\n    }\n    cout << dp[0][n][0].size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst int MAX_LENGTH = 201;\nstring s;\nset<int> dp[MAX_LENGTH][MAX_LENGTH];\n\nint stoi(string str) {\n\tistringstream is(str);\n\tint res;\n\tis >> res;\n\treturn res;\t\n}\n\nset<int> expr(int l, int r) {\n\tif(dp[l][r].size())\n\t\treturn dp[l][r];\n\n\tint depth = 0;\n\tbool found = false;\n\tfor(int i = l; i < r; ++i) {\n\t\tswitch(s[i]) {\n\t\tcase '(': ++depth; break;\n\t\tcase ')': --depth; break;\n\t\tcase '+':\n\t\tcase '-':\n\t\tcase '*':\n\t\tcase '/':\n\t\t\tif(depth == 0) {\n\t\t\t\tfound = true;\n\t\t\t\tset<int> left = expr(l, i);\n\t\t\t\tset<int> right = expr(i + 1, r);\n\t\t\t\tFOR(it, left) {\n\t\t\t\t\tFOR(it2, right) {\n\t\t\t\t\t\tswitch(s[i]) {\n\t\t\t\t\t\tcase '+': dp[l][r].insert(*it + *it2); break;\n\t\t\t\t\t\tcase '-': dp[l][r].insert(*it - *it2); break;\n\t\t\t\t\t\tcase '*': dp[l][r].insert(*it * *it2); break;\n\t\t\t\t\t\tcase '/': if(*it2) dp[l][r].insert(*it / *it2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(!found) {\n\t\tif(s[l] == '(')\n\t\t\tdp[l][r] = expr(l + 1, r - 1);\n\n\t\telse\n\t\t\tdp[l][r].insert(stoi(s.substr(l, r - l)));\n\t}\n\n\treturn dp[l][r];\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> s, s != \"#\") {\n\t\tfor(int i = 0; i < MAX_LENGTH; ++i)\n\t\t\tfor(int j = i + 1; j < MAX_LENGTH; ++j)\n\t\t\t\tdp[i][j].clear();\n\n\t\tcout << expr(0, s.size()).size() << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<sstream>\n\nusing namespace std;\n\nbool isnum(string s){\n  for(int i = 0; i < s.length(); i++)\n    if(s[i] < '0' || '9' < s[i]) return false;\n\n  return true;\n}\nvector<int> solve(string s){\n  \n  vector<int> V;\n\n  if(isnum(s)){\n    stringstream ss(s);\n    int n;\n    ss >> n;\n    V.push_back(n);\n    return V;\n  }else if(s[0] == '(' && s[s.length()-1] == ')'){\n    return solve(s.substr(1,s.length()-2));\n  }else{\n    int para = 0;\n\n    for(int i = 0; i < s.length(); i++){\n      vector<int> v1,v2;\n      if(s[i] == '(') para++;\n      if(s[i] == ')') para--;\n      if(para == 0 && s[i] == '+'){\n\tv1 = solve(s.substr(0,i));\n\tv2 = solve(s.substr(i+1));\n\n\tfor(int i = 0; i < v1.size(); i++)\n\t  for(int j = 0; j < v2.size(); j++)\n\t    V.push_back(v1[i]+v2[j]);\n\t  \n      }\n\n      if(para == 0 && s[i] == '-'){\n\tvector<int> v1,v2;\n\tv1 = solve(s.substr(0,i));\n\tv2 = solve(s.substr(i+1));\n\n\tfor(int i = 0; i < v1.size(); i++)\n\t  for(int j = 0; j < v2.size(); j++)\n\t    V.push_back(v1[i]-v2[j]);\n\n      }\n      if(para == 0 && s[i] == '*'){\n\tvector<int> v1,v2;\n\tv1 = solve(s.substr(0,i));\n\tv2 = solve(s.substr(i+1));\n\n\tfor(int i = 0; i < v1.size(); i++)\n\t  for(int j = 0; j < v2.size(); j++)\n\t    V.push_back(v1[i]*v2[j]);\n      }\n      if(para == 0 && s[i] == '/'){\n\tvector<int> v1,v2;\n\tv1 = solve(s.substr(0,i));\n\tv2 = solve(s.substr(i+1));\n\n\tfor(int i = 0; i < v1.size(); i++)\n\t  for(int j = 0; j < v2.size(); j++)\n\t    if(v2[j] != 0) V.push_back(v1[i]/v2[j]);\n\n      }\n    }\n  }\n  return V;\n}\n\nint main(){\n  \n  string in;\n  while(getline(cin,in) && in != \"#\"){\n    vector<int> V = solve(in);\n    map<int,int> M;\n    int ans = 0;\n    for(int i = 0; i < V.size(); i++){\n      if(M[V[i]] == 0){\n\tM[V[i]] = 1;\n\tans++;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef string::const_iterator state;\n\nint expression(state&);\n\nint number(state &begin){\n    int res=0;\n    while(isdigit(*begin)){\n        res*=10;\n        res+=*begin-'0';\n        ++begin;\n    }\n    return res;\n}\n\nint factor(state &begin){\n    if(*begin=='(' or *begin=='['){\n        begin++;\n        const int res=expression(begin);\n        begin++;\n        return res;\n    }else return number(begin);\n}\n\nint expression(state &begin){\n    int res=factor(begin);\n    if(res==inf) return inf;\n    while(true){\n        if(*begin=='+'){\n            ++begin;\n            res+=expression(begin);\n        }else if(*begin=='-'){\n            ++begin;\n            res-=expression(begin);\n        }else if(*begin=='*'){\n            ++begin;\n            res*=expression(begin);\n        }else if(*begin=='/'){\n            ++begin;\n            const int tmp=expression(begin);\n            if(tmp==0) return inf;\n            res/=tmp;\n        }else break;\n    }\n    return res;\n}\n\nvoid solve(){\n    while(true){\n        string str;\n        cin >> str;\n        if(str==\"#\") return;\n\n        set<int> res;\n        function<void(const string,const int,const stack<char>,bool)> rec=[&](const string s,const int idx,const stack<char> stk,bool f){\n            if(idx==s.size()){\n                if(!stk.size()){\n                    string s_=s;\n                    dump(s_);\n                    state begin=s_.begin();\n                    const int res_=expression(begin);\n                    if(res_!=inf) res.insert(res_);\n                    dump(res_);\n                }\n                return;\n            }\n            if(s[idx]=='('){\n                auto stk_=stk;\n                stk_.push('(');\n                rec(s,idx+1,stk_,f);\n                return;\n            }\n            if(s[idx]==')'){\n                if(!stk.size() or stk.top()!='(') return;\n                auto stk_=stk;\n                stk_.pop();\n                rec(s,idx+1,stk_,f);\n                return;\n            }\n            if(stk.size()<10 and isdigit(s[idx]) and (!idx or !isdigit(s[idx-1]))){\n                auto stk_=stk;\n                stk_.push('[');\n                auto s_=s;\n                s_.insert(idx,\"[\");\n                rec(s_,idx,stk_,false);\n            }\n            if(f and (idx+1==s.size() or (isdigit(s[idx]) and !isdigit(s[idx+1])))){\n                if(!stk.size() or stk.top()!='['){\n                    rec(s,idx+1,stk,f);\n                    return;\n                }\n                auto stk_=stk;\n                auto s_=s;\n                stk_.pop();\n                if(idx+1==s.size()) s_+=\"]\";\n                else s_.insert(idx+1,\"]\");\n                rec(s_,idx+1,stk_,false);\n            }\n            if(s[idx]=='+' or s[idx]=='-' or s[idx]=='*' or s[idx]=='/') rec(s,idx+1,stk,true);\n            else rec(s,idx+1,stk,f);\n        };\n        rec(str,0,stack<char>(),false);\n        cout << res.size() << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nbool NG ;\nstring s;\nint p,num[100009];\n\nint bnf1();\n\nint bnf(){\n\n  int r=0;\n  if(s[p]=='-')p++,r=bnf()*(-1);\n  else if(s[p]=='(')p++,r=bnf1(),p++;\n  else while(isdigit(s[p]))r=(r*10)+(s[p++]-'0');\n  //cout<<r<<endl;\n  return r;\n}\n\nint bnf10(){\n  int res=bnf();\n  while( num[p]==10 ){\n    int c=s[p++];\n    if(c=='+') res+= bnf();\n    if(c=='-') res-= bnf();\n    if(c=='*') res*= bnf();\n    if(c=='/'){\n      int X=bnf();\n      if(X)res /= X;\n      else NG=1;\n    }\n  }\n  return res;\n}\n\nint bnf9(){\n  int res=bnf10();\n  while( num[p]==9 ){\n    int c=s[p++];\n    if(c=='+') res+= bnf10();\n    if(c=='-') res-= bnf10();\n    if(c=='*') res*= bnf10();\n    if(c=='/'){\n      int X=bnf10();\n      if(X)res /= X;\n      else NG=1;\n    }\n  }\n  return res;\n}\n\nint bnf8(){\n  int res=bnf9();\n  while( num[p]==8 ){\n    int c=s[p++];\n    if(c=='+') res+= bnf9();\n    if(c=='-') res-= bnf9();\n    if(c=='*') res*= bnf9();\n    if(c=='/'){\n      int X=bnf9();\n      if(X)res /= X;\n      else NG=1;\n    }\n  }\n  return res;\n}\n\nint bnf7(){\n  int res=bnf8();\n  while( num[p]==7 ){\n    int c=s[p++];\n    if(c=='+') res+= bnf8();\n    if(c=='-') res-= bnf8();\n    if(c=='*') res*= bnf8();\n    if(c=='/'){\n      int X=bnf8();\n      if(X)res /= X;\n      else NG=1;\n    }\n  }\n  return res;\n}\n\nint bnf6(){\n  int res=bnf7();\n  while( num[p]==6 ){\n    int c=s[p++];\n    if(c=='+') res+= bnf7();\n    if(c=='-') res-= bnf7();\n    if(c=='*') res*= bnf7();\n    if(c=='/'){\n      int X=bnf7();\n      if(X)res /= X;\n      else NG=1;\n    }\n  }\n  return res;\n}\n\nint bnf5(){\n  int res=bnf6();\n  while( num[p]==5 ){\n    int c=s[p++];\n    if(c=='+') res+= bnf6();\n    if(c=='-') res-= bnf6();\n    if(c=='*') res*= bnf6();\n    if(c=='/'){\n      int X=bnf6();\n      if(X)res /= X;\n      else NG=1;\n    }\n  }\n  return res;\n}\n\nint bnf4(){\n  int res=bnf5();\n  while( num[p]==4 ){\n    int c=s[p++];\n    if(c=='+') res+= bnf5();\n    if(c=='-') res-= bnf5();\n    if(c=='*') res*= bnf5();\n    if(c=='/'){\n      int X=bnf5();\n      if(X)res /= X;\n      else NG=1;\n    }\n  }\n  return res;\n}\n\nint bnf3(){\n  int res=bnf4();\n  while( num[p]==3 ){\n    int c=s[p++];\n    if(c=='+') res+= bnf4();\n    if(c=='-') res-= bnf4();\n    if(c=='*') res*= bnf4();\n    if(c=='/'){\n      int X=bnf4();\n      if(X)res /= X;\n      else NG=1;\n    }\n  }\n  return res;\n}\n\nint bnf2(){\n  int res=bnf3();\n  while( num[p]==2 ){\n    int c=s[p++];\n    if(c=='+') res+= bnf3();\n    if(c=='-') res-= bnf3();\n    if(c=='*') res*= bnf3();\n    if(c=='/'){\n      int X=bnf3();\n      if(X)res /= X;\n      else NG=1;\n    }\n  }\n  return res;\n}\n\nint bnf1(){\n\n  int res=bnf2();\n  while( num[p]==1 ){\n    int c=s[p++];\n    if(c=='+') res+= bnf2();\n    if(c=='-') res-= bnf2();\n    if(c=='*') res*= bnf2();\n    if(c=='/'){\n      int X=bnf2();\n      if(X)res /= X;\n      else NG=1;\n    }\n  }\n  return res;\n}\n\nsigned main(){\n\n  vector<int>v;\n\n  while(cin>>s){\n    v.clear();\n    memset(num,0,sizeof(num));\n\n    if(s==\"#\")break;\n\n    r(i,s.size()){\n      if(s[i]=='+') v.push_back(i);\n      if(s[i]=='-') v.push_back(i);\n      if(s[i]=='*') v.push_back(i);\n      if(s[i]=='/') v.push_back(i);\n    }\n\n    set<int>sum;\n\n    do{\n      int T=1; p=0; NG=0;\n\n      r(i,v.size()){\n        num[v[i]]=T++;\n      }\n      //cout<<T<<endl;\n\n      int ans=bnf1();\n      //cout<<ans<<endl;\n      if(!NG)sum.insert(ans);\n\n      //cout<<T<<endl;\n\n    }while(next_permutation(v.begin(),v.end()));\n\n    cout<<sum.size()<<endl;\n    //exit(0);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cctype>\n#include <cassert>\n#include <algorithm>\n#include <stdexcept>\n#include <vector>\n#include <string>\n#include <set>\n\nconst std::string OPS=\"+-*/\";\n#define fprintf(...) void(0)\n\nint parse_int(const std::string &s, size_t &i) {\n  int res=s[i]-'0';\n  while (++i < s.length() && isdigit(s[i])) {\n    res = res*10+s[i]-'0';\n  }\n  return res;\n}\n\nint apply(int lhs, char op, int rhs) {\n  switch (op) {\n  case '+': return lhs+rhs;\n  case '-': return lhs-rhs;\n  case '*': return lhs*rhs;\n  case '/': return lhs/rhs;\n  }\n  assert(false);\n}\n\nvoid debug_set(const std::set<int> &s) {\n  fprintf(stderr, \"{\");\n  for (int x: s)\n    fprintf(stderr, \" %d\", x);\n  fprintf(stderr, \" }\\n\");\n}\n\nstd::set<int> apply(const std::set<int> &lhs, char op, const std::set<int> &rhs) {\n  std::set<int> res={};\n  for (int xl: lhs) {\n    for (int xr: rhs) {\n      if (op == '/' && xr == 0) continue;\n      res.emplace(apply(xl, op, xr));\n    }\n  }\n  return res;\n}\n\nstd::set<int> parse(std::string &s, size_t &i, int prec=0) {\n  fprintf(stderr, \"\\\"%s\\\"[%zu] p: %d\\n\", s.c_str(), i, prec);\n  if (prec == 1) {\n    if (s[i] == '(') {\n      std::set<int> res=parse(s, ++i, 0);\n      assert(s[i] == ')');\n      ++i;\n      return res;\n    } else if (isdigit(s[i])) {\n      return {parse_int(s, i)};\n    }\n    assert(false);\n  }\n\n  const size_t si=i;\n  std::set<int> res={};\n  {\n    std::set<int> lhs=parse(s, i, 1);\n    if (i == s.length() || s[i] == '$' || s[i] == ')')\n      return lhs;\n  }\n\n  while (i < s.length()) {\n    char op=s[i];\n    if (!std::count(OPS.begin(), OPS.end(), op)) break;\n    size_t ii=i;\n    s[ii] = '$';\n    size_t il=si, ir=++i;\n    std::set<int> lhs=parse(s, il, 0), rhs=parse(s, ir, 0);\n    std::set<int> cur=apply(lhs, op, rhs);\n    res.insert(cur.begin(), cur.end());\n    s[ii] = op;\n    (void)parse(s, i, 1);\n  }\n  debug_set(res);\n  return res;\n}\n\nint testcase_ends() {\n  char buf[256];\n  scanf(\"%s\", buf);\n  std::string s=buf;\n  if (s == \"#\")\n    return 1;\n\n  size_t i=0;\n  std::set<int> res=parse(s, i, 0);\n  for (int x: res)\n    fprintf(stderr, \" %d\", x);\n  fprintf(stderr, \"\\n\");\n  printf(\"%zu\\n\", res.size());\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <set>\n#include <vector>\n#include <cctype>\n#include <cassert>\n\nusing namespace std;\nstring str;\n\nstruct Tree {\n  int num;\n  vector<char> op;\n  vector<Tree> child;\n  Tree() :num(-1), op(), child() {}\n};\n\ntypedef pair<Tree ,int> P;\n\nP num(int idx) {\n  int num = 0;\n  while (isdigit(str[idx])) {\n    num = num * 10 + (str[idx] - '0');\n    idx++;\n  }\n  Tree t;\n  t.num = num;\n  // printf(\"%d\\n\", num);\n  return P(t, idx);\n}\n\nP expr(int idx) {\n  Tree e;\n   do {\n    if (str[idx] == '(') {\n      P t = expr(idx + 1);\n      e.child.push_back(t.first);\n      idx = t.second;\n      assert(str[idx] == ')');\n      idx++;\n    } else {\n      P t = num(idx);\n      // printf(\"%d\\n\", t.first.num);\n      e.child.push_back(t.first);\n      idx = t.second;\n    }\n    if (idx == str.size() || str[idx] == ')') {\n      return P(e, idx);\n    }\n    e.op.push_back(str[idx]);\n    idx++;\n  } while (idx < str.size());\n}\n\ntypedef pair<bool, int> Res;\n\nRes eval(int a, int b, char op) {\n  switch (op) {\n  case '+':\n    return Res(true, a+b);\n  case '-':\n    return Res(true, a-b);\n  case '*':\n    return Res(true, a*b);\n  case '/':\n    if (b == 0) {\n      return Res(false, 0);\n    } else {\n      return Res(true, a / b);\n    }\n  }\n}\n\nset<int> merge_res(set<int> l, set<int> r, char op) {\n  set<int> res;\n  for (set<int>::iterator lit = l.begin(); lit != l.end(); lit++) {\n    for (set<int>::iterator rit = r.begin(); rit != r.end(); rit++) {\n      Res t = eval(*lit, *rit, op);\n      if (t.first) {\n        res.insert(t.second);\n      }\n    } \n  }\n  return res;\n}\n\nset<int> evaluate(Tree e, int l, int r) {\n  // printf(\"%d, %d\\n\", l, r);\n  if (e.child.size() == 0) {\n    set<int> s;\n    s.insert(e.num);\n    return s;\n  }\n  if (r == l + 1) {\n    //printf(\"down\\n\");\n    set<int> s = evaluate(e.child[l], 0, e.child[l].child.size());\n    // printf(\"ret\\n\");\n    return s;\n  }\n\n  // printf(\"op = %d\\n\", e.op.size());\n  set<int> result;\n  for (int nextr = l + 1; nextr < r; nextr++) {\n    set<int> resl = evaluate(e, l, nextr);\n    set<int> resr = evaluate(e, nextr, r);\n    set<int> res = merge_res(resl, resr, e.op[nextr - 1]);\n    //printf(\"out\\n\");\n    result.insert(res.begin(), res.end());\n    // printf(\"safe\\n\");\n  }\n\n  return result;\n}\n\nvoid testTree(Tree e) {\n  if (e.child.size() == 0) {\n    printf(\"%d\", e.num);\n    return;\n  }\n  printf(\"(\");\n  testTree(e.child[0]);\n  for (int i = 0; i < e.op.size(); i++) {\n    printf(\"%c\", e.op[i]);\n    testTree(e.child[i + 1]);\n  }\n  printf(\")\");\n}\n\nvoid solve() {\n  P e1 = expr(0);\n  Tree e = e1.first;\n  //testTree(e);\n  //printf(\"\\n\");\n  set<int> res = evaluate(e, 0, e.child.size());\n  printf(\"%d\\n\", res.size());\n}\n\nint main() {\n  while (true) {\n    getline(cin, str);\n    if (str == \"#\") {\n      return 0;\n    }\n    //cout << str << endl;\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <iterator>\n#include <set>\n#include <sstream>\nusing namespace std;\n\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n\nconst int MAX_LENGTH = 201;\nstring s;\nset<int> dp[MAX_LENGTH][MAX_LENGTH];\n\nint stoi(string str) {\n\tistringstream is(str);\n\tint res;\n\tis >> res;\n\treturn res;\t\n}\n\nset<int> expr(int l, int r) {\n\tif(dp[l][r].size())\n\t\treturn dp[l][r];\n\n\tint depth = 0;\n\tbool found = false;\n\tfor(int i = l; i < r; ++i) {\n\t\tswitch(s[i]) {\n\t\tcase '(': ++depth; break;\n\t\tcase ')': --depth; break;\n\t\tcase '+':\n\t\tcase '-':\n\t\tcase '*':\n\t\tcase '/':\n\t\t\tif(depth == 0) {\n\t\t\t\tfound = true;\n\t\t\t\tset<int> left = expr(l, i);\n\t\t\t\tset<int> right = expr(i + 1, r);\n\t\t\t\tFOR(it, left) {\n\t\t\t\t\tFOR(it2, right) {\n\t\t\t\t\t\tswitch(s[i]) {\n\t\t\t\t\t\tcase '+': dp[l][r].insert(*it + *it2); break;\n\t\t\t\t\t\tcase '-': dp[l][r].insert(*it - *it2); break;\n\t\t\t\t\t\tcase '*': dp[l][r].insert(*it * *it2); break;\n\t\t\t\t\t\tcase '/': if(*it2) dp[l][r].insert(*it / *it2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(!found) {\n\t\tif(s[l] == '(')\n\t\t\tdp[l][r] = expr(l + 1, r - 1);\n\n\t\telse\n\t\t\tdp[l][r].insert(stoi(s.substr(l, r - l)));\n\t}\n\n\treturn dp[l][r];\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> s, s != \"#\") {\n\t\tfor(int i = 0; i < MAX_LENGTH; ++i)\n\t\t\tfor(int j = i + 1; j < MAX_LENGTH; ++j)\n\t\t\t\tdp[i][j].clear();\n\n\t\tcout << expr(0, s.size()).size() << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int INF = 1e9;\nint N, M;\nint opPos[10];\nint depth[10];\nint num[10];\nstring s;\nset<int> ans;\nint c;\n\nbool isOperator(char c) {\n\treturn c == '+' || c == '-' || c == '*' || c == '/';\n}\n\nvoid dfs(int d) {\n\twhile(c < N && s[c] != ')') {\n\t\tif(s[c] == '(') {\n\t\t\tc++;\n\t\t\tdfs(d + 1);\n\t\t\tassert(s[c] == ')');\n\t\t}\n\t\tif(isOperator(s[c])) {\n\t\t\tfor(int i = 0; i < M; i++) {\n\t\t\t\tif(opPos[i] == c) depth[i] = d;\n\t\t\t}\n\t\t}\n\t\tc++;\n\t}\n}\n\nint findMinPos(int l, int r) {\n\tint minId = -1;\n\tfor(int i = 0; i < M; i++) {\n\t\tif(l <= opPos[i] && opPos[i] <= r) {\n\t\t\tif(minId == -1 || num[minId] > num[i]) minId = i;\n\t\t}\n\t}\n\tif(minId == -1) return -1;\n\treturn opPos[minId];\n}\n\nint R(double n) {\n\tdouble an = abs(n);\n\tint ret = round(an - 1e-9);\n\tif(n < 0) ret *= -1;\n\treturn ret;\n}\n\nint f(int l, int r) {\n\tint minPos = findMinPos(l, r);\n\tif(minPos == -1) {\n\t\tint ret = 0;\n\t\tif(s[l] == '(') l++;\n\t\tif(s[r] == ')') r--;\n\t\tfor(int i = l; i <= r; i++) {\n\t\t\tret = ret * 10 + s[i] - '0';\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint vl = f(l, minPos - 1), vr = f(minPos + 1, r);\n\tif(vl == INF || vr == INF) return INF;\n\tchar op = s[minPos];\n\tif(op == '+') return vl + vr;\n\tif(op == '-') return vl - vr;\n\tif(op == '*') return vl * vr;\n\tif(vr == 0) return INF;\n\tint ret = R((double)vl / vr);\n\treturn ret;\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> s, s != \"#\") {\n\t\tN = s.size();\n\t\tM = 0;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tif(isOperator(s[i])) {\n\t\t\t\topPos[M] = i;\n\t\t\t\tdepth[M] = 0;\n\t\t\t\tM++;\n\t\t\t}\n\t\t}\n\t\tc = 0;\n\t\tdfs(0);\n\n\t\tvector<int> p(M);\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tp[i] = i;\n\t\t}\n\n\t\tans.clear();\n\t\tdo {\n\t\t\tfor(int i = 0; i < M; i++) {\n\t\t\t\tnum[i] = p[i] + depth[i] * 100;\n\t\t\t}\n\t\t\tint res = f(0, N - 1);\n\t\t\tif(res != INF) ans.insert(res);\n\t\t} while(next_permutation(p.begin(), p.end()));\n\n\t\tcout << ans.size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nmap<string, set<int> > memo;\n\nbool kakko(const string &str) {\n  int n = str.size();\n  int open = 0;\n  REP(i, n - 1) {\n    if (str[i] == '(') { open++; }\n    if (str[i] == ')') { open--; }\n    if (open == 0) { return false; }\n  }\n  return true;\n}\n\nset<int> calc(const string str) {\n  if (memo.count(str)) { return memo[str]; }\n  set<int> ret;\n  int n = str.size();\n  int open = 0;\n  bool onlyDigit = true;\n  REP(i, n) { if (!isdigit(str[i])) { onlyDigit = false; } }\n  if (onlyDigit) {\n    ret.insert(atoi(str.c_str()));\n  } else if (kakko(str)) {\n    ret = calc(str.substr(1, n - 2));\n  } else {\n    REP(i, n) {\n      if (str[i] == '(') { open++; }\n      else if (str[i] == ')') { open--; }\n      else if (isdigit(str[i])) {\n      } else if (open == 0) {\n        set<int> left = calc(str.substr(0, i));\n        set<int> right = calc(str.substr(i + 1, n - (i + 1)));\n        FORIT(it1, left) {\n          FORIT(it2, right) {\n            if (str[i] == '+') {\n              ret.insert(*it1 + *it2);\n            } else if (str[i] == '-') {\n              ret.insert(*it1 - *it2);\n            } else if (str[i] == '*') {\n              ret.insert(*it1 * *it2);\n            } else if (str[i] == '/') {\n              if (*it2 == 0) { continue; }\n              ret.insert(*it1 / *it2);\n            }\n          }\n        }\n      }\n    }\n  }\n  //cout << str << \" \" << endl;\n  //FORIT(it, ret) { cout << *it << \" \"; }\n  //puts(\"\");\n  return memo[str] = ret;\n}\n\nint main() {\n  string str;\n  while (getline(cin, str), str[0] != '#') {\n    memo.clear();\n    printf(\"%d\\n\", (int)calc(str).size());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2255&lang=jp\n// reference : http://rokugats-pc.hateblo.jp/entry/2015/06/20/163726\ntypedef long long ll;\n#define INF 1<<30\n\nmap<string, set<int>> memo;\nbool n_only(string& str) {\n\tfor (auto s : str) if (s < '0' || s > '9') return false;\n\treturn true;\n}\nstring::iterator p_end_pos(string::iterator s) {\n\tint p = 1;\n\tfor (auto it = s + 1;;it++) {\n\t\tif (*it == '(')p++; if (*it == ')')p--;\n\t\tif (p == 0)return it;\n\t}\n}\n\nset<int> rec(string str) {\n\tif (memo.count(str)) return memo[str];\n\tif (n_only(str))return memo[str] = set<int>{ stoi(str) };\n\tif (str[0] == '(' && p_end_pos(str.begin()) == str.end() - 1) {\n\t\treturn memo[str] = rec(string(str.begin() + 1, str.end() - 1));\n\t}\n\tset<int> ret;\n\tfor (auto it = str.begin(); it != str.end();it++) {\n\t\tif (*it == '(') it = p_end_pos(it);\n\t\tchar op = *it;\n\t\tif (op == '+') {\n\t\t\tset<int> L = rec(string(str.begin(), it));\n\t\t\tset<int> R = rec(string(it + 1, str.end()));\n\t\t\tfor (auto l : L)for (auto r : R) {\n\t\t\t\tret.insert(l + r);\n\t\t\t}\n\t\t}\n\t\telse if (op == '-') {\n\t\t\tset<int> L = rec(string(str.begin(), it));\n\t\t\tset<int> R = rec(string(it + 1, str.end()));\n\t\t\tfor (auto l : L)for (auto r : R) {\n\t\t\t\tret.insert(l - r);\n\t\t\t}\n\t\t}\n\t\telse if (op == '*') {\n\t\t\tset<int> L = rec(string(str.begin(), it));\n\t\t\tset<int> R = rec(string(it + 1, str.end()));\n\t\t\tfor (auto l : L)for (auto r : R) {\n\t\t\t\tret.insert(l * r);\n\t\t\t}\n\t\t}\n\t\telse if (op == '/') {\n\t\t\tset<int> L = rec(string(str.begin(), it));\n\t\t\tset<int> R = rec(string(it + 1, str.end()));\n\t\t\tfor (auto l : L)for (auto r : R) {\n\t\t\t\tif (r == 0)continue;\n\t\t\t\tret.insert(l / r);\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[str] = ret;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tstring str;\n\twhile (cin >> str) {\n\t\tif (str == \"#\")break;\n\t\tcout << rec(str).size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <cctype>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nstring S;\n\nbool is_op(char c)\n{\n    return (c == '+' || c == '-' || c == '*' || c == '/');\n}\n\nbool is_num(int L, int R)\n{\n    for (int i = L; i <= R; i++) {\n        if (!isdigit(S[i])) return 0;\n    }\n    return 1;\n}\n\nint num(int L, int R)\n{\n    int res = 0;\n    for (int i = L; i <= R; i++) {\n        res *= 10;\n        res += (S[i] - '0');\n    }\n    return res;\n}\n\nint near(int L, int R)\n{\n    int p = 0;\n    for (int i = L; i <= R; i++) {\n        if (S[i] == '(') p++;\n        if (S[i] == ')') p--;\n        if (p == 0) return i;\n    }\n    return -1;\n}\n\nset<int> expr(int L, int R)\n{\n    set<int> res;\n    \n    if (is_num(L, R)) return {num(L, R)};\n    \n    int nR = near(L, R);\n    if (nR == R && S[L] == '(' && S[R] == ')') {\n        return expr(L + 1, R - 1);\n    }\n    \n    for (int i = L; i <= R - 1; i++) {\n        char c = S[i];\n        \n        if (!is_op(c)) continue;        \n        \n        auto l = expr(L, i - 1);\n        auto r = expr(i + 1, R);\n        \n        for (int lv : l) {\n            for (int rv : r) {\n                switch (c) {\n                    case '+':\n                        res.insert(lv + rv);\n                        break;\n                    case '-':\n                        res.insert(lv - rv);\n                        break;\n                    case '*':\n                        res.insert(lv * rv);\n                        break;\n                    case '/':\n                        if (rv != 0) {\n                            res.insert(lv / rv);                            \n                        }                            \n                        break;\n                }\n            }\n        }\n    } \n    return res;\n}\n\nvoid solve()\n{\n    int N = S.size();\n    cout << expr(0, N - 1).size() << endl;\n}\n\nint main()\n{\n    while (cin >> S, S != \"#\") {\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n//#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstring str;\nmap<P,set<int> >M;\nset<int> rec(int L,int R){\n\tif(M.find(mp(L,R)) != M.end()) return M[mp(L,R)];\n\tint dep = 0;\n\tvector<int>cut;\n\tfor(int i=L;i<=R;i++){\n\t\tif(str[i] == '(') dep ++;\n\t\telse if(str[i] == ')') dep --;\n\t\telse if(dep == 0 && (str[i] == '+' || str[i] == '-' || str[i] == '*' || str[i] == '/')){\n\t\t\tcut.pb(i);\n\t\t}\n\t}\n\tif(cut.empty()){\n\t\t//<num> or (<expr>)\n\t\tif(str[L] == '('){\n\t\t\tassert(str[R] == ')');\n\t\t\treturn M[mp(L,R)] = rec(L+1,R-1);\n\t\t}\n\t\telse{\n\t\t\tint num = 0;\n\t\t\tfor(int i=L;i<=R;i++){\n\t\t\t\tnum = num * 10 + (str[i]-'0');\n\t\t\t}\n\t\t\tset<int>S; S.insert(num);\n\t\t\treturn M[mp(L,R)] = S;\n\t\t}\n\t}\n\telse{\n\t\tset<int>ans;\n\t\tfor(int i=0;i<cut.size();i++){\n\t\t\tset<int>x = rec(L,cut[i]-1);\n\t\t\tset<int>y = rec(cut[i]+1,R);\n\t\t\tfor(auto a:x){\n\t\t\t\tfor(auto b:y){\n\t\t\t\t\tif(str[cut[i]] == '+') ans.insert(a+b);\n\t\t\t\t\tif(str[cut[i]] == '-') ans.insert(a-b);\n\t\t\t\t\tif(str[cut[i]] == '*') ans.insert(a*b);\n\t\t\t\t\tif(str[cut[i]] == '/') if(b != 0) ans.insert(a/b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\nint main(){\n\twhile(1){\n\t\tcin>>str;\n\t\tif(str == \"#\") return 0;\n\t\tM.clear();\n\t\tset<int>hoge = rec(0,str.size()-1);\n\t\tcout<<hoge.size()<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <numeric>\n#include <set>\n#include <map>\n#include <sstream>\n\n#define rep(i, j) for(int i = 0; i < j; i++)\n#define all(i) i.begin(), i.end()\n#define int long long\n\nusing namespace std;\n\nint toint(string s) {\n\tstringstream ss(s);\n\tint ret;\n\tss >> ret;\n\treturn ret;\n}\n\nstring s;\nint c;\n\nstring num() {\n\tstring r;\n\tif (s[c] >= '0' && s[c] <= '9') {\n\t\tr += s[c];\n\t\tc++;\n\t\tr += num();\n\t\treturn r;\n\t}\n\telse {\n\t\treturn \"\";\n\t}\n}\n\nset<int> solve(vector<set<int>> &v, vector<char> &o) {\n\tint n = v.size();\n\tvector<bool> f(n, false);\n\n\tvector<int> t(n - 1);\n\trep(i, n - 1) {\n\t\tt[i] = i;\n\t}\n\n\tset<int> re;\n\tdo {\n\t\tauto tv = v;\n\t\tauto to = o;\n\t\tauto tt = t;\n\n\t\trep(i, n - 1) {\n\t\t\tset<int> se;\n\t\t\tfor (auto j : tv[tt[i]]) {\n\t\t\t\tfor (auto k : tv[tt[i]+1]) {\n\t\t\t\t\tif (to[tt[i]] == '+') {\n\t\t\t\t\t\tse.insert(j + k);\n\t\t\t\t\t}\n\t\t\t\t\tif (to[tt[i]] == '-') {\n\t\t\t\t\t\tse.insert(j - k);\n\t\t\t\t\t}\n\t\t\t\t\tif (to[tt[i]] == '*') {\n\t\t\t\t\t\tse.insert(j * k);\n\t\t\t\t\t}\n\t\t\t\t\tif (to[tt[i]] == '/') {\n\t\t\t\t\t\tif (k != 0) {\n\t\t\t\t\t\t\tse.insert(j / k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tto.erase(to.begin() + tt[i]);\n\t\t\ttv.erase(tv.begin() + tt[i] + 1);\n\t\t\ttv.erase(tv.begin() + tt[i]);\n\t\t\ttv.insert(tv.begin() + tt[i], se);\n\t\t\tfor (int j = 0; j < tt.size(); j++) {\n\t\t\t\tif (tt[i] < tt[j]) {\n\t\t\t\t\ttt[j]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (auto i : tv[0]) {\n\t\t\tre.insert(i);\n\t\t}\n\n\t} while (next_permutation(t.begin(), t.end()));\n\n\treturn re;\n}\n\n//exprテ」ツ?ョテァツオツづ、ツコツ?・ツ慊ーテァツつケテ」ツ?ィテァツオツ?」ツ?ソテ・ツ青暗」ツつ湘」ツ?崚」ツ?ョテヲツ閉ー\nset<int> fc() {\n\tif (s[c] == '(') {\n\t\tc += 1;\n\t\tvector<set<int>> v;\n\t\tv.push_back(fc());\n\t\tvector<char> o;\n\n\t\twhile (s[c] != ')') {\n\t\t\to.push_back(s[c]);\n\t\t\tif (s[c] == '+') {\n\t\t\t\tc++;\n\t\t\t\tv.push_back(fc());\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (s[c] == '-') {\n\t\t\t\tc++;\n\t\t\t\tv.push_back(fc());\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (s[c] == '*') {\n\t\t\t\tc++;\n\t\t\t\tv.push_back(fc());\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (s[c] == '/') {\n\t\t\t\tc++;\n\t\t\t\tv.push_back(fc());\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tc += 1;\n\t\treturn solve(v, o);\n\t}\n\tif (s[c] >= '0' && s[c] <= '9') {\n\t\tint t = toint(num());\n\t\tset<int> re;\n\t\tre.insert(t);\n\t\treturn re;\n\t}\n}\n\nsigned main(){\n\twhile (cin >> s && s != \"#\") {\n\t\tc = 0;\n\t\ts = \"(\" + s + \"))\";\n\t\tcout << fc().size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\nnamespace solver {\n\nstring s;\ntypedef string::const_iterator Iter;\nIter it, end;\n\ntypedef pair<set<int>, char> pic;\n\nvoid consume(char e) {\n  assert(e == *it);\n  it ++;\n}\n\nbool isconsume(char e) {\n  if(e == *it) {\n    consume(e);\n    return true;\n  }\n  return false;\n}\n\nint number() {\n  int ret = 0;\n  if(!isdigit(*it)) return -1;\n  while(isdigit(*it)) {\n    ret *= 10;\n    ret += *it - '0';\n    it ++;\n  }\n  return ret;\n}\n\nset<int> calc(set<int> const& n1, set<int> const& n2, char o) {\n  set<int> ret;\n  for(auto&& e: n1) for(auto&& u: n2) {\n    if(o == '+') ret.insert(e + u);\n    if(o == '-') ret.insert(e - u);\n    if(o == '*') ret.insert(e * u);\n    if(o == '/' && u != 0) ret.insert(e / u);\n  }\n  return ret;\n}\n\nvoid push_trans(queue<vector<pic>>& q, set<vector<pic>>& used, vector<pic> const& p, int i, set<int> const& n1, set<int> const& n2, char o, char nexto) {\n  set<int> r = calc(n1, n2, o);\n  auto nextp = p;\n  nextp.erase(nextp.begin() + i);\n  nextp.erase(nextp.begin() + i);\n  nextp.insert(nextp.begin() + i, {r, nexto});\n  if(used.count(nextp)) return;\n  used.insert(nextp);\n  q.push(nextp);\n}\n\nset<int> expr() {\n  vector<pic> v;\n  while(1) {\n    int num = number();\n    set<int> nums;\n    if(num == -1 && isconsume('(')) {\n      nums = expr();\n      consume(')');\n    }\n    else if(num == -1) {\n      assert(0);\n    }\n    else {\n      nums.insert(num);\n    }\n\n    if(isconsume('+')) v.push_back({nums, '+'});\n    else if(isconsume('-')) v.push_back({nums, '-'});\n    else if(isconsume('*')) v.push_back({nums, '*'});\n    else if(isconsume('/')) v.push_back({nums, '/'});\n    else {\n      v.push_back({nums, '0'});\n      break;\n    }\n  }\n\n  queue<vector<pic>> q; q.push(v);\n  set<vector<pic>> used;\n\n  set<int> ret;\n\n  for(;!q.empty(); q.pop()) {\n    auto const& p = q.front();\n    if(p.size() == 1) {\n      for(auto&& e: p[0].first)\n        ret.insert(e);\n      continue;\n    }\n    assert(p.size());\n    rep(i, p.size() - 1)\n      push_trans(q, used, p, i, p[i].first, p[i+1].first, p[i].second, p[i+1].second);\n  }\n\n  return ret;\n}\n\nint solve() {\n  it = s.begin(), end = s.end();\n  return expr().size();\n}\n\n}\n\nint main() {\n\n  while(cin >> solver::s) {\n    if(solver::s == \"#\") break;\n    cout << solver::solve() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nvector<vector<vector<ll>>> A(300,vector<vector<ll>>(300));\nvector<char> B;\n\nvector<ll> & dfs(ll l,ll r){\n    if(!A[l][r].empty()){return A[l][r];}\n    if(l==r){return A[l][r];}\n    ll sum=0;\n    ll cnt=0;\n    for(ll i=l;i<r;i++){\n        if(B[i]=='('){sum++;}\n        else if(B[i]==')'){sum--;}\n        if(sum<0){return A[l][r];}\n        if(sum==0){cnt++;}\n    }\n    if(sum!=0){return A[l][r];}\n    if(l+1<r && cnt==1){return A[l][r]=dfs(l+1,r-1);}\n    //cout<<l<<\" \"<<r<<endl;\n    for(ll i=l;i<r;i++){\n        vector<ll> &L=dfs(l,i);\n        vector<ll> &R=dfs(i+1,r);\n        if(B[i]=='*'){\n            for(auto &I:L){\n                for(auto &T:R){A[l][r].push_back(I*T);}\n            }\n        }\n        else if(B[i]=='/'){\n            for(auto &I:L){\n                for(auto &T:R){if(T!=0){A[l][r].push_back(I/T);}}\n            }\n        }\n        else if(B[i]=='+'){\n            for(auto &I:L){\n                for(auto &T:R){A[l][r].push_back(I+T);}\n            }\n        }\n        else if(B[i]=='-'){\n            for(auto &I:L){\n                for(auto &T:R){A[l][r].push_back(I-T);}\n            }\n        }\n    }\n    return A[l][r];\n}\n\nbool isNum(char c){return '0'<=c && c<='9';}\n\nint main(){\n    string s;\n    while(cin>>s){\n        if(s==\"#\"){break;}\n    for(auto &I:A){\n        for(auto &T:I){T.clear();}\n    }\n    ll k=0;\n    stack<ll> S;\n    B.clear();\n    for(int i=0;i<s.size();i++){\n        if(isNum(s[i])){k*=10; k+=s[i]-'0';}\n        else{\n            if(i>0 && isNum(s[i-1])){\n                A[B.size()][B.size()]={k};\n                k=0;\n            }\n            B.push_back(s[i]);\n        }\n    }\n    if(isNum(s.back())){A[B.size()][B.size()]={k}; k=0;}\n    dfs(0,B.size());\n    set<ll> st;\n    for(auto &I:A[0][B.size()]){st.insert(I);}\n    cout<<st.size()<<endl;\n    /*\n    for(int i=0;i<=B.size();i++){\n        for(int t=0;t<=B.size();t++){\n            cout<<i<<\" \"<<t<<endl;\n            for(auto &I:A[i][t]){cout<<I<<\" \";}\n            cout<<endl;\n        }\n        cout<<endl;\n    }\n    */\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef set <int> S;\n\nvoid skip(string &str,int &i){\n  if(str[i]!='(')return;\n  string res;\n  int cnt=1;i++;\n  while(1) {\n    if(str[i]=='(')cnt++;\n    if(str[i]==')')cnt--;\n    if(!cnt)break;\n    res+=str[i++];\n  }\n}\n\n\nint num[1<<8];\nvector <S> mem;\nmap <string,int> M;\nvoid calc(char ch,S a,S b, S &res){\n  S::iterator i,j;\n  for(i=a.begin();i!=a.end();i++)\n    for(j=b.begin();j!=b.end();j++){\n      int I=*i,J=*j,c=0;\n      if(ch=='+') c=I+J;\n      else if(ch=='-') c=I-J;\n      else if(ch=='*') c=I*J;\n      else if(ch=='/'){\n\tif(!J)continue;\n\tc=I/J;\n      }\n      res.insert(c);\n    }\n}\n\nS solve(string str){\n  S res;\n  if(str.size()==1){res.insert(num[str[0]]);return res;}\n  if(M.count(str))return mem[M[str]];\n  int a=0;skip(str,a);\n  if(a==str.size()-1)return solve(str.substr(1,str.size()-2));\n\n  string A,B;\n  for(int i=0;i<str.size()-1;i+=2){\n    skip(str,i);\n    if(i>=str.size()-1)break;\n    string A=str.substr(0,i+1),B=str.substr(i+2,str.size()-i-2);\n    calc(str[i+1],solve(A),solve(B),res);\n  }\n  M[str]=mem.size();\n  mem.push_back(res); \n  return mem[M[str]];\n}\n\nint main(){\n  while(1){\n    string str;\n    cin>>str;\n    if(str==\"#\")break;\n    mem.clear(),M.clear();\n    string siki;\n    char ch='A';\n    for(int i=0;i<(int)str.size();){\n      int b=0;\n      while('0'<=str[i]&&str[i]<='9') b=b*10+str[i++]-'0';\n      if(b) num[ch]=b,siki+=ch++;\n      else siki+=str[i++];\n    }\n    cout <<solve(siki).size()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nset<int> ans;\nstring line; \nint len;\n\nint apply(char opr, int a, int b) {\n    if (opr == '+') return a + b;\n    if (opr == '-') return a - b;\n    if (opr == '*') return a * b;\n    if (opr == '/') return a / b;\n}\n\nint reduce(stack<int>& N, stack<char>& O) {\n    char opr = O.top(); O.pop();\n    int v = N.top(); N.pop();\n    int w = N.top(); N.pop();\n    if (opr == '/' && !v) return 0;\n    N.push(apply(opr, w, v));\n    return 1;\n}\n\nvoid read(int i, stack<int> N, stack<char> O) {\n    if (i == len) {\n        while (O.size()) if (!reduce(N, O)) return;\n        ans.insert(N.top());\n        return;\n    }\n    if (line[i] >= '0') {\n        int v = 0;\n        while (i < len && line[i] >= '0') v *= 10, v += line[i++] - '0';\n\n        N.push(v);\n        read(i, N, O);\n        while (!O.empty() && O.top() != '(' && reduce(N, O)) read(i, N, O);\n        return;\n    }\n    if (line[i] == ')') {\n        while (O.top() != '(') if (!reduce(N, O)) return;\n        O.pop();\n        read(i+1, N, O);\n        while (!O.empty() && O.top() != '(' && reduce(N, O)) read(i+1, N, O);\n        return;\n    }\n    O.push(line[i]);\n    read(i+1, N, O);\n    return;\n}\n\nint main()\n{\n    while (1) {\n        ans.clear();\n        cin >> line;\n        len = line.length();\n        if (line == \"#\") break;\n        read(0, stack<int>(), stack<char>());\n        cout << ans.size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2255&lang=jp\n// http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2500257#1\n\ntypedef long long ll;\nusing namespace std;\n#define LINF 1LL<<63\nll solve(string expr, map<char, ll>& op,map<char,char>& op_rev, int op_cnt);\nll check(int& i, string& expr);\nll solve(string expr, map<char, ll>& op,map<char,char>& op_rev,int op_cnt) {\n\t/* <expr> <op> <expr> ??? ( <expr> <op> <expr> )*/\n\n\tfor (int p = 1; p <= op_cnt;p++) {\n\t\tfor (int i = 0; i < (int)expr.length();i++) {\n\t\t\tif (expr[i] >= '0' && expr[i] <= '9')continue;\n\t\t\tif (expr[i] == ')' || expr[i] == '(')continue;\n\t\t\tif (op[expr[i]] != p) continue;\n\n\t\t\tint parentheses = 0;\n\t\t\tfor (int left = i - 1; left >= 0; left--) {\n\t\t\t\tif (left == 0) { expr = \"(\" + expr; i++; break; }\n\t\t\t\tif (expr[left] >= '0' && expr[left] <= '9')continue;\n\t\t\t\tif (expr[left] == ')') { parentheses++; }\n\t\t\t\tif (expr[left] == '(') { parentheses--; }\n\t\t\t\tif (parentheses > 0) continue;\n\t\t\t\texpr.insert(expr.begin() + left + 1, '('); i++; break;\n\t\t\t}\n\t\t\tparentheses = 0;\n\t\t\tfor (int right = i + 1; right < expr.length();right++) {\n\t\t\t\tif (right == expr.length() - 1) { expr = expr + \")\"; break; }\n\t\t\t\tif (expr[right] >= '0' && expr[right] <= '9')continue;\n\t\t\t\tif (expr[right] == '(') { parentheses++; }\n\t\t\t\tif (expr[right] == ')') { parentheses--; }\n\t\t\t\tif (parentheses > 0) continue;\n\t\t\t\texpr.insert(expr.begin() + right, ')'); break;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < expr.length();i++) {\n\t\tif (expr[i] >= 'A' && expr[i] <= 'Z') {\n\t\t\texpr[i] = op_rev[expr[i]];\n\t\t}\n\t}\n\tint i = 0;\n\tll ret = check(i, expr);\n\treturn ret;\n}\n\nll check(int& i, string& expr) {\n\tll l_expr, r_expr;\n\tif (expr[i] == '(') {\n\t\t/* \"( ~ )\" op ~ */\n\t\ti++;\n\t\tl_expr = check(i, expr);\n\t\tif (l_expr == LINF) {\n\t\t\treturn LINF;\n\t\t}\n\t}\n\telse {\n\t\t/* \"number\" op ~ */\n\t\tl_expr = 0;\n\t\twhile (expr[i] >= '0' && expr[i] <= '9') {\n\t\t\tl_expr = l_expr * 10 + (expr[i] - '0');\n\t\t\ti++;\n\t\t}\n\t}\n\t/* (expr) or (number) */\n\tchar option;\n\tif (i == expr.length() || expr[i] == ')') { i++; return l_expr; }\n\telse {\n\t\toption = expr[i];\n\t\ti++;\n\t}\n\n\tif (expr[i] == '(') {\n\t\t/* ~ op \"( ~ )\"*/\n\t\ti++;\n\t\tr_expr = check(i, expr);\n\t\tif (r_expr == LINF)return LINF;\n\t}\n\telse {\n\t\t/* ~ op \"number\" */\n\t\tr_expr = 0;\n\t\twhile (expr[i] >= '0' && expr[i] <= '9') {\n\t\t\tr_expr = r_expr * 10 + (expr[i] - '0');\n\t\t\ti++;\n\t\t}\n\t}\n\tif (expr[i] == ')') {\n\t\ti++;\n\t\tif (option == '+') return l_expr + r_expr;\n\t\tif (option == '-') return l_expr - r_expr;\n\t\tif (option == '*') return l_expr * r_expr;\n\t\tif (option == '/') {\n\t\t\tif (r_expr == 0) {\n\t\t\t\treturn LINF;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn l_expr / r_expr;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tstring expr; \n\twhile (cin >> expr) {\n\t\tif (expr == \"#\")break;\n\t\tmap<char, ll> op; op['('] = op[')'] = 0;\n\t\tset<ll> ans;\n\t\tint op_cnt = 0;\n\t\tmap<int, int> op_loc;\n\t\tmap<char, char> op_rev;\n\t\tfor (int i = 0; i < expr.length();i++) {\n\t\t\tif (expr[i] >= '0' && expr[i] <= '9')continue;\n\t\t\tif (expr[i] == ')' || expr[i] == '(')continue;\n\t\t\top_cnt++;\n\t\t\top_loc[op_cnt] = i;\n\t\t}\n\t\tvector<int> v(op_cnt);\n\t\tiota(v.begin(), v.end(), 1);\n\t\tdo {\n\t\t\tstring temp = expr;\n\t\t\top_rev.clear();\n\t\t\tint vidx = 0;\n\t\t\tfor (int i = 1; i <= op_cnt;i++) {\n\t\t\t\top[i + 'A'] = v[vidx];\n\t\t\t\top_rev[i + 'A'] = temp[op_loc[i]];\n\t\t\t\ttemp[op_loc[i]] = i + 'A';\n\t\t\t\tvidx++;\n\t\t\t}\n\t\t\tll x = solve(temp, op, op_rev, op_cnt);\n\t\t\tif (x == LINF) continue;\n\t\t\tans.insert(x);\n\t\t} while (next_permutation(v.begin(), v.end()));\n\n\t\t/*for (int i = 1; i <= 3;i++) {\n\t\t\tfor (int j = 1; j <= 3;j++) {\n\t\t\t\tfor (int k = 1; k <= 3;k++) {\n\t\t\t\t\tfor (int l = 1; l <= 4;l++) {\n\t\t\t\t\t\tif (i != 1 && j != 1 && k != 1 && l != 1) continue;\n\t\t\t\t\t\top['+'] = i; op['-'] = j; op['*'] = k; op['/'] = l;\n\t\t\t\t\t\tll x = solve(expr, op);\n\t\t\t\t\t\tif (x == LINF) continue;\n\t\t\t\t\t\tans.insert(x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\tcout << ans.size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<char,char> cc;\nvector<cc> opr;\nint ep;\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n  bool error;\n \n  Parsing(string s){\n    parse = s;\n    pos = 0;\n    error = false;\n  }\n  int fact(){\n    if( error ) return 0;\n    if(parse[pos] == '('){\n      pos++;\n      int p = expression();\n      pos++;\n      return p;\n    }else{\n      int p=0;\n      while('0' <= parse[pos] && parse[pos] <= '9'){\n        p *= 10;\n        p += parse[pos]-'0';\n        pos++;\n      }\n      return p;\n    }\n  }\n \n  int term(int depth){\n\n    if( error ) return 0;\n    int p; \n    if( depth >= ep ) p = fact();\n    else              p = term(depth+1);\n\n    while( depth < ep &&  parse[pos] == opr[depth].second ){\n\n      char c = opr[depth].first;\n      if( c == '+' )      { pos++; p += term(depth+1); }\n      else if( c == '-' ) { pos++; p -= term(depth+1); } \n      else if( c == '*' ) { pos++; p *= term(depth+1); } \n      else if( c == '/' ) {\n        pos++; \n        int denom = term(depth+1); \n        if( denom == 0 ) error = true;\n        else p /= denom;\n      } \n    }\n    return p;\n  }\n \n  int expression(){\n    if( error ) return 0;\n    int p = term(1);\n    while(!opr.empty() && parse[pos] == opr[0].second ){\n      char c = opr[0].first;\n      if( c == '+' )      { pos++; p += term(1); }\n      else if( c == '-' ) { pos++; p -= term(1); } \n      else if( c == '*' ) { pos++; p *= term(1); } \n      else if( c == '/' ) {\n        pos++; \n        int denom = term(1); \n        if( denom == 0 ) error = true;\n        else p /= denom;\n      } \n    }\n    return p;\n  } \n \n};\n\nstring s;\nint main(){\n  while( getline(cin,s) ){\n    opr.clear();\n    if( s == \"#\" ) break;\n    int cnt = 0;\n    rep(i,s.size()) if( s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/' ) {\n      opr.push_back(cc(s[i],(char)('A'+cnt)));\n      s[i] = (char)('A'+cnt);\n      cnt++;\n    }\n    ep = opr.size();\n    sort(opr.begin(),opr.end());\n    unordered_set<int> ans;\n    do{\n      Parsing par(s);\n      int tmp = par.expression();\n      if( par.error ) continue;\n      ans.insert(tmp);\n    }while(next_permutation(opr.begin(),opr.end()));\n    cout << ans.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s;\n\nint oper(int lhs,int rhs,char op){\n    if(op=='+'){\n        return lhs+rhs;\n    }\n    if(op=='-'){\n        return lhs-rhs;\n    }\n    if(op=='*'){\n        return lhs*rhs;\n    }\n    if(op=='/'){\n        if(rhs==0) throw \"0_devision\";\n        return lhs/rhs;\n    }\n    assert(false);\n}\n\nset<int> calc(vector<int> num,vector<char> op){\n    set<int> res;\n    if(num.size()==1){\n        res.insert(num[0]);\n        return res;\n    }\n    for(int i=0;i<num.size()-1;i++){\n        auto nexnum=num;\n        auto nexop=op;\n        int lhs=num[i];\n        int rhs=num[i+1];\n        char opc=op[i];\n        int val;\n        try{\n            val=oper(lhs,rhs,opc);\n        }catch(const char* ex){\n            continue;\n        }\n        nexnum.erase(nexnum.begin()+i,nexnum.begin()+i+2);\n        nexnum.insert(nexnum.begin()+i,val);\n        nexop.erase(nexop.begin()+i);\n        auto ret=calc(nexnum,nexop);\n        res.insert(ret.begin(),ret.end());\n    }\n    return res;\n}\n\nset<int> dfs(int inde,vector<set<int>> &nums,vector<char> &op,vector<int> &num){\n    if(inde==nums.size()){\n        return calc(num,op);\n    }\n    set<int> res;\n    for(auto &v:nums[inde]){\n        num.push_back(v);\n        auto ret=dfs(inde+1,nums,op,num);\n        res.insert(ret.begin(),ret.end());\n        num.pop_back();\n    }\n    return res;\n}\n\nset<int> expr(int &p){\n    vector<set<int>> nums;\n    vector<char> op;\n    while(true){\n        if(isdigit(s[p])){\n            set<int> st;\n            st.insert(s[p]-'0');\n            p++;\n            nums.push_back(st);\n        }\n        else{\n            //assert(s[p]=='(');\n            p++;\n            nums.push_back(expr(p));\n            //assert(s[p]==')');\n            p++;\n        }\n        if(p==s.size() || s[p]==')') break;\n        op.push_back(s[p]);\n        p++;\n    }\n    vector<int> num;\n    return dfs(0,nums,op,num);\n}\n\nint main(){\n    while(cin>>s,s!=\"#\"){\n        int p=0;\n        cout<<expr(p).size()<<endl;\n    }      \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<cstring>\n#define foreach(t,p) for(t::iterator it=p.begin();it!=p.end();++it)\n#define FOREACH(t,p,tit) for(t::iterator tit=p.begin();tit!=p.end();++tit)\n#define REP(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef set<int> pp;\nstring ss;\n\npp solve(int f,int l)\n{\n\tpp ans;\n\tans.clear();\n\tbool ope=false;\n\tfor(int i=f;i<l;i++)\n\t{\n\t\tif(\n\t\t\t\tss[i]=='+'||\n\t\t\t\tss[i]=='-'||\n\t\t\t\tss[i]=='*'||\n\t\t\t\tss[i]=='/')ope = true;\n\t}\n\tif(!ope)\n\t{\n\t\tstring s = ss.substr(f,(l-f+1));\n\t\t//cout << s << endl;\n\t\tint t = atoi(s.c_str() );\n\t\tans.insert(t);\n\t\t//foreach(pp,ans)cout << *it << endl;\n\t\t//cout << atoi( (ss.substr(f,l+1)).c_str()) << endl ;\n\t\t//cout <<ss.substr(f,(l-f+1))<<endl;\n\t\treturn ans;\n\t}\n\n\tint ofs = 0;\n\tif(ss[f]=='('&& ss[l]==')'  ) ofs=1;\n\tint bo =0;\n\tfor(int i=f+ofs;i<l-ofs;i++)\n\t{\n\t\n\t\tif(ss[i]=='(') bo++;\n\t\tif(ss[i]==')') bo--;\n\n\t\tif((\tss[i]=='+'||ss[i]=='-'||ss[i]=='*'||ss[i]=='/')&&(bo==0))\n\t\t{\n\t\t\n\t\t\tpp ansl = solve(f+ofs,i-1);\n\t\t\tpp ansr = solve(i+1,l-ofs);\n\t\t\tif(ss[i]=='+')\n\t\t\t\tFOREACH(pp,ansl,iit)FOREACH(pp,ansr,jit)\n\t\t\t\t\tans.insert((*iit)+(*jit));\n\t\t\tif(ss[i]=='-')\n\t\t\t\tFOREACH(pp,ansl,iit)FOREACH(pp,ansr,jit)\n\t\t\t\t\tans.insert((*iit)-(*jit));\n\t\t\tif(ss[i]=='*')\n\t\t\t\tFOREACH(pp,ansl,iit)FOREACH(pp,ansr,jit)\n\t\t\t\t\tans.insert((*iit)*(*jit));\n\t\t\tif(ss[i]=='/')\n\t\t\t\tFOREACH(pp,ansl,iit)FOREACH(pp,ansr,jit)\n\t\t\t\t{\n\t\t\t\t\tif((*jit)!=0)\n\t\t\t\t\tans.insert((*iit)/(*jit));\n\t\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n\t\n}\n\nint main()\n{\n\twhile(cin >> ss &&(ss!=\"#\"))\n\t{\n\t\tpp anss = solve(0,ss.size()-1);\n\t\t//foreach(pp,anss)cout << *it << endl;\n\n\t\tcout << anss.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nstring S;\nstring op = \"+-*/\";\n\nset<int> parse(int l, int r) {\n  if (S[l] == '(' && S[r - 1] == ')') return parse(l + 1, r - 1);\n  set<int> res;\n  int depth = 0;\n  for (int i = l; i < r; i++) {\n    depth += (S[i] == '(') - (S[i] == ')');\n    if (depth) continue;\n    if (op.find(S[i]) == string::npos) continue;\n    set<int> a = parse(l, i), b = parse(i + 1, r);\n    for (auto &x : a)\n      for (auto &y : b) {\n        if (S[i] == '+') res.emplace(x + y);\n        if (S[i] == '-') res.emplace(x - y);\n        if (S[i] == '*') res.emplace(x * y);\n        if (S[i] == '/' && y) res.emplace(x / y);\n      }\n  }\n  if (res.size()) return res;\n  int x = 0;\n  while (l < r) x = x * 10 + S[l++] - '0';\n  return {x};\n}\n\nmain {\n  while (cin >> S, S != \"#\") cout << parse(0, S.size()).size() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nset<int> SET;\n\nint calc(int a,int b,char op){\n\tswitch(op){\n\tcase '+':return a+b;\n\tcase '-':return a-b;\n\tcase '*':return a*b;\n\tcase '/':\n\t\tif(b == 0){\n\t\t\treturn BIG_NUM;\n\t\t}else{\n\t\t\treturn a/b;\n\t\t}\n\t}\n}\n\nbool is_op(char ch){\n\tif(ch == '+' || ch == '-' || ch == '*' || ch == '/'){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nbool is_num(char ch){\n\treturn ch >= '0' && ch <= '9';\n}\n\nvoid recursive(char equation[201],int length){\n\n\tstack<int> S;\n\n\tfor(int i = 0; i < length; i++){\n\t\tif(is_op(equation[i]) == true && equation[i+1] != '(' && equation[i-1] != ')'){\n\t\t\tS.push(i);\n\t\t}\n\t}\n\n\tif(S.empty()){\n\t\tint number = 0;\n\t\tbool neg_FLG = false;\n\n\t\tfor(int i = 0; i < length; i++){\n\t\t\tif(equation[i] == '@'){\n\t\t\t\tneg_FLG = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnumber = 10*number+equation[i]-'0';\n\t\t}\n\t\tif(neg_FLG)number *= -1;\n\t\tSET.insert(number);\n\n\t\treturn;\n\t}\n\n\tint loc,left,right,left_num,start,right_num,new_num,index,num_length,index_2;\n\tbool left_neg_FLG,right_neg_FLG,new_num_neg_FLG;\n\n\tstack<int> WORK;\n\n\twhile(!S.empty()){\n\t\tloc = S.top();\n\t\tS.pop();\n\n\t\tleft_neg_FLG = false;\n\n\t\tfor(left = loc-1; left >= 0 && is_num(equation[left]) == true; left--);\n\t\tleft++;\n\t\tif(left > 0 && equation[left-1] == '@'){\n\t\t\tleft--;\n\t\t\tleft_neg_FLG = true;\n\t\t}\n\n\t\tif(equation[loc+1] == '@'){\n\t\t\tright_neg_FLG = true;\n\t\t\tstart = loc+2;\n\t\t}else{\n\t\t\tright_neg_FLG = false;\n\t\t\tstart = loc+1;\n\t\t}\n\n\t\tfor(right = start; right < length && is_num(equation[right]) == true; right++);\n\t\tright--;\n\n\t\tleft_num = 0;\n\t\tfor(int i = left; i < loc; i++){\n\t\t\tif(equation[i] == '@')continue;\n\t\t\tleft_num = 10*left_num+equation[i]-'0';\n\t\t}\n\t\tif(left_neg_FLG)left_num *= -1;\n\n\t\tright_num = 0;\n\t\tfor(int i = start; i <= right; i++){\n\t\t\tright_num = 10*right_num+equation[i]-'0';\n\t\t}\n\t\tif(right_neg_FLG)right_num *= -1;\n\n\t\tnew_num = calc(left_num,right_num,equation[loc]);\n\n\t\tif(new_num == BIG_NUM)continue;\n\n\t\tif(new_num < 0){\n\t\t\tnew_num_neg_FLG = true;\n\t\t\tnew_num *= -1;\n\t\t}else{\n\t\t\tnew_num_neg_FLG = false;\n\t\t}\n\n\t\tchar next_equation[201];\n\t\tindex = 0;\n\n\t\tfor(int i = 0; i < left; i++){\n\t\t\tnext_equation[index++] = equation[i];\n\t\t}\n\n\t\tnum_length = 0;\n\n\t\tdo{\n\t\t\tWORK.push(new_num%10);\n\t\t\tnew_num /= 10;\n\t\t\tnum_length++;\n\n\t\t}while(new_num > 0);\n\n\t\tif(new_num_neg_FLG){\n\t\t\tnext_equation[index++] = '@';\n\t\t\tnum_length++;\n\t\t}\n\n\t\twhile(!WORK.empty()){\n\t\t\tnext_equation[index++] = '0'+WORK.top();\n\t\t\tWORK.pop();\n\t\t}\n\n\t\tfor(int i = right+1; i < length; i++){\n\t\t\tnext_equation[index++] = equation[i];\n\t\t}\n\t\tnext_equation[index] = '\\0';\n\n\t\tif(next_equation[left-1] == '(' && next_equation[left+num_length] == ')'){\n\t\t\tindex_2 = 0;\n\t\t\tchar work_equation[201];\n\n\t\t\tfor(int i = 0; i < left-1; i++){\n\t\t\t\twork_equation[index_2++] = next_equation[i];\n\t\t\t}\n\t\t\tfor(int i = left; i < left+num_length; i++){\n\t\t\t\twork_equation[index_2++] = next_equation[i];\n\t\t\t}\n\t\t\tfor(int i = left+num_length+1; i < index; i++){\n\t\t\t\twork_equation[index_2++] = next_equation[i];\n\t\t\t}\n\n\n\t\t\tfor(int i = 0; i < index_2; i++){\n\t\t\t\tnext_equation[i] = work_equation[i];\n\t\t\t}\n\t\t\tindex = index_2;\n\t\t\tnext_equation[index] = '\\0';\n\t\t}\n\t\trecursive(next_equation,index);\n\t}\n}\n\nint main(){\n\n\tint length;\n\tchar equation[201];\n\n\twhile(true){\n\t\tscanf(\"%s\",equation);\n\t\tif(equation[0] == '#')break;\n\n\t\tfor(length = 0; equation[length] != '\\0'; length++);\n\n\t\tSET.clear();\n\t\trecursive(equation,length);\n\n\t\tprintf(\"%lld\\n\",SET.size());\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vec;\n\nclass UnionFind {\n  vector<int> a;\npublic:\n  UnionFind(int n) { REP(i, 0, n) a.push_back(i); }\n  int find(int i) { return a[i] == i ? i : (a[i] = find(a[i])); }\n  void unite(int i, int j) { a[find(i)] = find(j); }\n  bool same(int i, int j) { return find(i) == find(j); }\n};\n\nstring S;\nint p;\n\nll num() {\n  int val = 0;\n  while('0' <= S[p] && S[p] <= '9') val = val * 10 + (S[p++] - '0');\n  return val;\n}\n\nvec expr() {\n  vector<vec> n;\n  vector<char> op;\n  while(p < S.length() && S[p] != ')') {\n    if(S[p] == '+' || S[p] == '-' || S[p] == '*' || S[p] == '/') {\n      op.push_back(S[p++]);\n    } else if(S[p] == '(') {\n      p++;\n      n.push_back(expr());\n      p++;\n    } else {\n      vec u;\n      u.push_back(num());\n      n.push_back(u);\n    }\n  }\n\n  int idx[20];\n  REP(i, 0, op.size()) idx[i] = i;\n  vec ret;\n  do {\n    UnionFind uf(n.size());\n    vec d[20];\n    REP(i, 0, n.size()) REP(j, 0, n[i].size()) d[i].push_back(n[i][j]);\n    REP(i, 0, op.size()) {\n      vec n1 = d[uf.find(idx[i])];\n      vec n2 = d[uf.find(idx[i] + 1)];\n      vec res;\n      REP(j, 0, n1.size()) REP(k, 0, n2.size()) {\n        int val;\n        if(op[idx[i]] == '/' && n2[k] == 0) continue;\n        switch(op[idx[i]]) {\n          case '+': val = n1[j] + n2[k]; break;\n          case '-': val = n1[j] - n2[k]; break;\n          case '*': val = n1[j] * n2[k]; break;\n          case '/': val = n1[j] / n2[k]; break;\n        }\n        res.push_back(val);\n      }\n      sort(res.begin(), res.end());\n      res.erase(unique(res.begin(), res.end()), res.end());\n      uf.unite(idx[i], idx[i] + 1);\n      d[uf.find(idx[i])].clear();\n      REP(j, 0, res.size()) d[uf.find(idx[i])].push_back(res[j]);\n    }\n    REP(i, 0, d[uf.find(0)].size()) ret.push_back(d[uf.find(0)][i]);\n    sort(ret.begin(), ret.end());\n    ret.erase(unique(ret.begin(), ret.end()), ret.end());\n  } while(next_permutation(idx, idx + op.size()));\n\n  return ret;\n}\n\nint main(void) {\n  while(cin >> S, S != \"#\") {\n    p = 0;\n    cout << expr().size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nvector<char> op;\nset<ll> res;\n\ninline bool num(char c){return '0'<=c && c<='9';}\ninline bool alp(char c){return 'a'<=c && c<='z';}\ninline bool ope(char c){return c=='+' || c=='-' || c=='*' || c=='/';}\n\nbool valid(string s)\n{\n    int b=0,o=0;\n    rep(i,s.size())\n    {\n        if(s[i]=='(') ++b;\n        else if(s[i]==')') --b;\n        else if(alp(s[i])) ++o;\n    }\n    return b==0 && o==0;\n}\n\nll get_num(string s)\n{\n    int S = s.size();\n    int l = 0, r = S-1;\n    while(s[l]=='(') ++l;\n    while(s[r]==')') --r;\n    return atoll(s.substr(l,r-l+1).c_str());\n}\n\nstring rmbr(string s)\n{\n    string ret = \"\";\n    int S = s.size();\n    int idx = 0;\n    while(idx<S)\n    {\n        if(s[idx]=='(')\n        {\n            bool fail=false;\n            int st = idx;\n            ++idx;\n            while(s[idx]!=')')\n            {\n                if(idx+1<S && s[idx+1]=='(')\n                {\n                    fail = true;\n                    break;\n                }\n                ++idx;\n            }\n\n            string x = s.substr(st,idx-st+1);\n            if(!fail) fail = !valid(x);\n            if(fail) ret += x;\n            else ret += to_string(get_num(x));\n        }\n        else ret += s[idx];\n\n        ++idx;\n    }\n\n    return ret;\n}\n\nset<string> vis;\nvoid dfs(string s)\n{\n    s = rmbr(s);\n    if(vis.count(s)) return;\n    vis.insert(s);\n\n    int S = s.size();\n    vector<int> pos;\n    rep(i,S)if(alp(s[i])) pos.pb(i);\n\n    int P = pos.size();\n    if(P==0) res.insert(get_num(s));\n\n    rep(i,P)\n    {\n        int xl = 0;\n        if(i>0) xl = pos[i-1]+1;\n        int yr = S-1;\n        if(i<P-1) yr = pos[i+1]-1;\n\n        while(!num(s[xl])) ++xl;\n        while(!num(s[yr])) --yr;\n        string x = s.substr(xl,pos[i]-xl);\n        string y = s.substr(pos[i]+1,yr-pos[i]);\n\n        // cout << \"s= \"<<s<<\", i= \"<<i<<\": (x,y) = [\"<<x<<\",\"<<y<<\"]\"<<endl;\n\n        char o = op[s[pos[i]]-'a'];\n        if(valid(x) && valid(y))\n        {\n            ll X = get_num(x), Y = get_num(y);\n            if(o=='+') X+=Y;\n            else if(o=='-') X-=Y;\n            else if(o=='*') X*=Y;\n            else if(o=='/')\n            {\n                if(Y==0) continue;\n                X/=Y;\n            }\n\n            string t = s;\n            t.replace(xl, x.size()+y.size()+1, to_string(X));\n            dfs(t);\n        }\n    }\n}\n\nint main()\n{\n    string s;\n    while(cin >>s,(s!=\"#\"))\n    {\n        op.clear();\n        rep(i,s.size())if(ope(s[i]))\n        {\n            op.pb(s[i]);\n            s[i] = 'a'+op.size()-1;\n        }\n        vis.clear();\n        res.clear();\n        dfs(s);\n        cout << res.size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vec;\n\nclass UnionFind {\n  vector<int> a;\npublic:\n  UnionFind(int n) { REP(i, 0, n) a.push_back(i); }\n  int find(int i) { return a[i] == i ? i : (a[i] = find(a[i])); }\n  void unite(int i, int j) { a[find(i)] = find(j); }\n  bool same(int i, int j) { return find(i) == find(j); }\n};\n\nstring S;\nint p;\n\nll num() {\n  int val = 0;\n  while('0' <= S[p] && S[p] <= '9') val = val * 10 + (S[p++] - '0');\n  return val;\n}\n\nvec expr() {\n  vector<vec> n;\n  vector<char> op;\n  while(p < S.length() && S[p] != ')') {\n    if(S[p] == '+' || S[p] == '-' || S[p] == '*' || S[p] == '/') {\n      op.push_back(S[p++]);\n    } else if(S[p] == '(') {\n      p++;\n      n.push_back(expr());\n      p++;\n    } else {\n      vec u;\n      u.push_back(num());\n      n.push_back(u);\n    }\n  }\n\n  int idx[20];\n  REP(i, 0, op.size()) idx[i] = i;\n  vec ret;\n  do {\n    UnionFind uf(n.size());\n    vec d[20];\n    REP(i, 0, n.size()) d[i] = n[i];\n    REP(i, 0, op.size()) {\n      vec n1 = d[uf.find(idx[i])];\n      vec n2 = d[uf.find(idx[i] + 1)];\n      vec res;\n      REP(j, 0, n1.size()) REP(k, 0, n2.size()) {\n        int val;\n        if(op[idx[i]] == '/' && n2[k] == 0) continue;\n        switch(op[idx[i]]) {\n          case '+': val = n1[j] + n2[k]; break;\n          case '-': val = n1[j] - n2[k]; break;\n          case '*': val = n1[j] * n2[k]; break;\n          case '/': val = n1[j] / n2[k]; break;\n        }\n        res.push_back(val);\n      }\n      uf.unite(idx[i], idx[i] + 1);\n      d[uf.find(idx[i])] = res;\n    }\n    REP(i, 0, d[uf.find(0)].size()) ret.push_back(d[uf.find(0)][i]);\n  } while(next_permutation(idx, idx + op.size()));\n  sort(ret.begin(), ret.end());\n  ret.erase(unique(ret.begin(), ret.end()), ret.end());\n\n  return ret;\n}\n\nint main(void) {\n  while(cin >> S, S != \"#\") {\n    p = 0;\n    cout << expr().size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n\nusing namespace std;\nstring s;\ntypedef set<int>::iterator sit;\n\nbool is_ope(char c){\n    return c == '+' || c == '-' || c == '*' || c == '/';\n}\n\nset<int> solve(int l, int r){\n    int par = 0;\n    bool found = 0;\n    set<int> result;\n\n    for(int i=l; i<r; i++){\n        if(s[i] == '(') par++;\n        if(s[i] == ')') par--;\n        if(par == 0 && is_ope(s[i])){\n            found = 1;\n            set<int> lhs = solve(l,i-1) , rhs = solve(i+1, r);\n            for(sit it = lhs.begin(); it != lhs.end(); ++it){\n                for(sit jt = rhs.begin(); jt != rhs.end(); ++jt){\n                    int ii = *it;\n                    int jj = *jt;\n                    if(s[i] == '+') result.insert(ii+jj);\n                    else if(s[i] == '-') result.insert(ii-jj);\n                    else if(s[i] == '*') result.insert(ii*jj);\n                    else if(s[i] == '/') result.insert(ii/jj);\n                }\n            }\n        }\n    }\n    if(!found){\n        if(s[l] == '(') return solve(l+1,r-1);\n        result.insert(atoi(s.substr(l, r-l+1).c_str()));\n    }\n    return result;\n}\n\nint main(){\n    while (cin >> s, s != \"#\"){\n        cout << solve(0, s.size()-1).size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef set <int> S;\n\nint skip(string &str,int i){\n  if(str[i]!='(')return i;\n  string res;\n  int cnt=1;i++;\n  while(1) {\n    if(str[i]=='(')cnt++;\n    if(str[i]==')')cnt--;\n    if(!cnt)break;\n    res+=str[i++];\n  }\n  return i;\n}\n\n\nint num[1<<8];\nvector <S> mem;\nmap <string,int> M;\nvoid calc(char ch,S a,S b, S &res){\n  S::iterator i,j;\n  for(i=a.begin();i!=a.end();i++)\n    for(j=b.begin();j!=b.end();j++){\n      int I=*i,J=*j,c=0;\n      if(ch=='+') c=I+J;\n      else if(ch=='-') c=I-J;\n      else if(ch=='*') c=I*J;\n      else if(ch=='/'){\n\tif(!J)continue;\n\tc=I/J;\n      }\n      res.insert(c);\n    }\n}\n\nS solve(string str){\n  S res;\n  if(str.size()==1){res.insert(num[str[0]]);return res;}\n  if(M.count(str))return mem[M[str]];\n  if(skip(str,0)==str.size()-1)return solve(str.substr(1,str.size()-2));\n\n  string A,B;\n  for(int i=0;(i=skip(str,i))<str.size()-1;i+=2){\n    string A=str.substr(0,i+1),B=str.substr(i+2,str.size()-i-2);\n    calc(str[i+1],solve(A),solve(B),res);\n  }\n  M[str]=mem.size();\n  mem.push_back(res); \n  return mem[M[str]];\n}\n\nint main(){\n  while(1){\n    string str;\n    cin>>str;\n    if(str==\"#\")break;\n    mem.clear(),M.clear();\n    string siki;\n    char ch='A';\n    for(int i=0;i<(int)str.size();){\n      int b=0;\n      while('0'<=str[i]&&str[i]<='9') b=b*10+str[i++]-'0';\n      if(b) num[ch]=b,siki+=ch++;\n      else siki+=str[i++];\n    }\n    cout <<solve(siki).size()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nconst int INF = 1e9+100;\n\nbool isnum(char c){\n  return '0' <= c && c <= '9';\n}\n\nbool isop(char c){\n  const string op = \"+*-/\";\n  return op.find(c) != string::npos;\n}\n\nint find_paren(const string& s, int i){\n  int cnt = 0;\n  for(;i<SZ(s);++i){\n\tif(s[i] == '(') ++cnt;\n\telse if(s[i] == ')')\n\t  if(--cnt == 0) return i;\n  }\n  return -1;\n}\n\nset<int> eval(const string& s){\n  VS terms;\n  vector<char> ops;\n  string term;\n  for(int i=0;i<SZ(s);++i){\n\tif(isnum(s[i]))\n\t  term += string(1,s[i]);\n\telse if(s[i] == '('){\n\t  if(!term.empty()){\n\t\t//cout << term << endl;\n\t\tterms.PB(term);\n\t  }\n\t  int j = find_paren(s, i);\n\t  term = s.substr(i, j-i+1);\n\t  i = j;\n\t}\n\telse{\n\t  if(!term.empty()){\n\t\t//cout << term << endl;\n\t\tterms.PB(term);\n\t  }\n\t  term = \"\";\n\t  ops.PB(s[i]);\n\t}\n  }\n  if(!term.empty())\n\tterms.PB(term);\n\n  set<int> res;\n  if(ops.empty()){\n\tif(terms[0][0] == '(')\n\t  return eval(terms[0].substr(1, SZ(terms[0])-2));\n\telse\n\t  res.insert(atoi(terms[0].c_str()));\n  }\n  else{\n\tfor(int i=0;i<SZ(ops);++i){\n\t  string lhs;\n\t  for(int j=0;j<=i;++j){\n\t\tif(j != 0) lhs += ops[j];\n\t\tlhs += terms[j];\n\t  }\n\t  set<int> l = eval(lhs);\n\t  string rhs;\n\t  for(int j=i+1;j<SZ(terms);++j){\n\t\tif(j != i+1) rhs += ops[j-1];\n\t\trhs += terms[j];\n\t  }\n\t  set<int> r = eval(rhs);\n\t  for(int lx: l){\n\t\tfor(int rx: r){\n\t\t  int x;\n\t\t  switch(ops[i]){\n\t\t  case '+': x = lx+rx; break;\n\t\t  case '-': x = lx-rx; break;\n\t\t  case '*': x = lx*rx; break;\n\t\t  case '/': x = (rx != 0? lx/rx: INF); break;\n\t\t  }\n\t\t  if(x != INF) res.insert(x);\n\t\t}\n\t  }\n\t}\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  string expr;\n  while(cin>>expr,expr!=\"#\"){\n\t//\tcout<<expr<<endl;\n\tcout << SZ(eval(expr)) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nvector<vector<vector<ll>>> A(100,vector<vector<ll>>(100));\nvector<char> B;\n\nvector<ll> & dfs(ll l,ll r){\n    if(!A[l][r].empty()){return A[l][r];}\n    ll sum=0;\n    ll cnt=0;\n    for(ll i=l;i<r;i++){\n        if(B[i]=='('){sum++;}\n        else if(B[i]==')'){sum--;}\n        if(sum<0){return A[l][r];}\n        if(sum==0){cnt++;}\n    }\n    if(sum!=0){return A[l][r];}\n    if(l+1<r && cnt==1){return dfs(l+1,r-1);}\n    //cout<<l<<\" \"<<r<<endl;\n    for(ll i=l;i<r;i++){\n        vector<ll> &L=dfs(l,i);\n        vector<ll> &R=dfs(i+1,r);\n        if(B[i]=='*'){\n            for(auto &I:L){\n                for(auto &T:R){A[l][r].push_back(I*T);}\n            }\n        }\n        else if(B[i]=='/'){\n            for(auto &I:L){\n                for(auto &T:R){if(T!=0){A[l][r].push_back(I/T);}}\n            }\n        }\n        else if(B[i]=='+'){\n            for(auto &I:L){\n                for(auto &T:R){A[l][r].push_back(I+T);}\n            }\n        }\n        else if(B[i]=='-'){\n            for(auto &I:L){\n                for(auto &T:R){A[l][r].push_back(I-T);}\n            }\n        }\n    }\n    return A[l][r];\n}\n\nbool isNum(char c){return '0'<=c && c<='9';}\n\nint main(){\n    string s;\n    while(cin>>s){\n        if(s==\"#\"){break;}\n    for(auto &I:A){\n        for(auto &T:I){T.clear();}\n    }\n    ll k=0;\n    stack<ll> S;\n    B.clear();\n    for(int i=0;i<s.size();i++){\n        if(isNum(s[i])){k*=10; k+=s[i]-'0';}\n        else{\n            if(i>0 && isNum(s[i-1])){\n                A[B.size()][B.size()]={k};\n                k=0;\n            }\n            B.push_back(s[i]);\n        }\n    }\n    if(isNum(s.back())){A[B.size()][B.size()]={k}; k=0;}\n    dfs(0,B.size());\n    set<ll> st;\n    for(auto &I:A[0][B.size()]){st.insert(I);}\n    cout<<st.size()<<endl;\n    /*\n    for(int i=0;i<=B.size();i++){\n        for(int t=0;t<=B.size();t++){\n            cout<<i<<\" \"<<t<<endl;\n            for(auto &I:A[i][t]){cout<<I<<\" \";}\n            cout<<endl;\n        }\n        cout<<endl;\n    }\n    */\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<sstream>\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long ll;\n\nbool isnum(string s){\n  for(int i = 0; i < s.length(); i++)\n    if(s[i] < '0' || '9' < s[i]) return false;\n\n  return true;\n}\nvector<ll> solve(string s){\n  \n  vector<ll> V;\n\n  if(isnum(s)){\n    stringstream ss(s);\n    ll n;\n    ss >> n;\n    V.push_back(n);\n    return V;\n  }else if(s[0] == '(' && s[s.length()-1] == ')'){\n    return solve(s.substr(1,s.length()-2));\n  }else{\n    int para = 0;\n\n    for(int i = 0; i < s.length(); i++){\n      vector<ll> v1,v2;\n      if(s[i] == '(') para++;\n      if(s[i] == ')') para--;\n      if(para == 0 && s[i] == '+'){\n\tv1 = solve(s.substr(0,i));\n\tv2 = solve(s.substr(i+1));\n\n\tfor(int j = 0; j < v1.size(); j++)\n\t  for(int k = 0; k < v2.size(); k++)\n\t    V.push_back(v1[j]+v2[k]);\n\t  \n      }\n\n      if(para == 0 && s[i] == '-'){\n\tvector<ll> v1,v2;\n\tv1 = solve(s.substr(0,i));\n\tv2 = solve(s.substr(i+1));\n\n\tfor(int j = 0; j < v1.size(); j++)\n\t  for(int k = 0; k < v2.size(); k++)\n\t    V.push_back(v1[j]-v2[k]);\n\n      }\n      if(para == 0 && s[i] == '*'){\n\tvector<ll> v1,v2;\n\tv1 = solve(s.substr(0,i));\n\tv2 = solve(s.substr(i+1));\n\n\tfor(int j = 0; j < v1.size(); j++)\n\t  for(int k = 0; k < v2.size(); k++)\n\t    V.push_back(v1[j]*v2[k]);\n      }\n      if(para == 0 && s[i] == '/'){\n\tvector<ll> v1,v2;\n\tv1 = solve(s.substr(0,i));\n\tv2 = solve(s.substr(i+1));\n\n\tfor(int j = 0; j < v1.size(); j++)\n\t  for(int k = 0; k < v2.size(); k++)\n\t    if(v2[k] != 0) V.push_back(v1[j]/v2[k]);\n\n      }\n    }\n  }\n  return V;\n}\n\nint main(){\n  \n  string in;\n  while(getline(cin,in) && in != \"#\"){\n    vector<ll> V = solve(in);\n    map<ll,int> M;\n    ll ans = 0;\n    for(int i = 0; i < V.size(); i++){\n      if(M[V[i]] == 0){\n\tM[V[i]] = 1;\n\tans++;\n      }\n    }\n    assert(ans != 0);\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MP make_pair\n\ntypedef pair<int, int> PII;\n\nconst int SIZE = 30;\n\nchar line[SIZE], t[SIZE];\nset<int> memo[SIZE][SIZE];\nset<PII> used;\n \nvoid eval(int const l, int const r) {\n   \n  set<int>& ret = memo[l][r];\n  if(l == r) return;\n   \n  if(used.count(MP(l, r))) return;\n  used.insert(MP(l, r));\n   \n  // check is digits [l, r)\n  bool digits = true;\n  for(int i=l; i<r; i++) { digits = digits && isdigit(line[i]); }\n  strncpy(t, line+l, r-l); t[r-l] = 0;\n  if(digits) { ret.insert(atoi(t)); return; }\n   \n  int par = 0; bool check = true;\n  for(int i=l; i<r-1; i++) {\n    if(line[i] == '(') { par ++; }\n    if(line[i] == ')') { par --; }\n    if(par == 0) { check = false; }\n  }\n   \n  // \"(expr)\"\n  if(check) {\n    if(line[r-1] == ')') {\n      eval(l+1, r-1); ret = memo[l+1][r-1]; return;\n    }\n  }\n   \n  par = 0;\n  // parsing loop\n  for(int i=l; i<r; i++) {\n    if(line[i] == '(') { par ++; }\n    if(line[i] == ')') { par --; }\n    if(par != 0) continue;\n     \n    switch(line[i]) {\n    case '+': case '-': case '*': case '/': {\n      eval(l, i); eval(i+1, r);\n      set<int>::iterator iter_a, iter_b;\n      for(iter_a = memo[l][i].begin(); iter_a!=memo[l][i].end(); iter_a++) {\n        for(iter_b = memo[i+1][r].begin(); iter_b!=memo[i+1][r].end(); iter_b++) {\n          if(line[i] == '+') { ret.insert(*iter_a + *iter_b); }\n          if(line[i] == '-') { ret.insert(*iter_a - *iter_b); }\n          if(line[i] == '*') { ret.insert(*iter_a * *iter_b); }\n          if(line[i] == '/') {\n            if(*iter_b == 0) continue;\n            ret.insert(*iter_a / *iter_b);\n          }\n        }\n      }\n      break;\n    }\n    default:;\n    }\n  } // for parsing loop\n}\n \nint main() {\n   \n  while(1) {\n    scanf(\"%s\\n\", line);\n    for(int i=0; i<SIZE; i++)\n      for(int j=0; j<SIZE; j++)\n        memo[i][j].clear();\n     \n    used.clear();\n     \n    if(0==strcmp(line, \"#\")) break;\n    eval(0, strlen(line));\n    cout << memo[0][strlen(line)].size() << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<cstring>\n#define foreach(t,p) for(t::iterator it=p.begin();it!=p.end();++it)\n#define FOREACH(t,p,tit) for(t::iterator tit=p.begin();tit!=p.end();++tit)\n#define REP(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef set<int> pp;\nstring ss;\n\npp solve(int f,int l)\n{\n\tpp ans;\n\tans.clear();\n\tbool ope=false;\n\tfor(int i=f;i<l;i++)\n\t{\n\t\tif(\n\t\t\t\tss[i]=='+'||\n\t\t\t\tss[i]=='-'||\n\t\t\t\tss[i]=='*'||\n\t\t\t\tss[i]=='/')ope = true;\n\t}\n\tif(!ope)\n\t{\n\t\tstring s = ss.substr(f,(l-f+1));\n\t\t//cout << s << endl;\n\t\tint t = atoi(s.c_str() );\n\t\tans.insert(t);\n\t\t//foreach(pp,ans)cout << *it << endl;\n\t\t//cout << atoi( (ss.substr(f,l+1)).c_str()) << endl ;\n\t\t//cout <<ss.substr(f,(l-f+1))<<endl;\n\t\treturn ans;\n\t}\n\n\tint ofs = 0;\n\tif(ss[f]=='('&& ss[l]==')'  ) ofs=1;\n\tint bo =0;\n\tfor(int i=f+ofs;i<l-ofs+1;i++)\n\t{\n\t\n\t\tif(ss[i]=='(') bo++;\n\t\tif(ss[i]==')') bo--;\n\n\t\tif((ss[i]=='+'||ss[i]=='-'||ss[i]=='*'||ss[i]=='/')&&(bo==0))\n\t\t{\n\t\t\n\t\t\tpp ansl = solve(f+ofs,i-1);\n\t\t\tpp ansr = solve(i+1,l-ofs);\n\t\t\tif(ss[i]=='+')\n\t\t\t\tFOREACH(pp,ansl,iit)FOREACH(pp,ansr,jit)\n\t\t\t\t\tans.insert((*iit)+(*jit));\n\t\t\tif(ss[i]=='-')\n\t\t\t\tFOREACH(pp,ansl,iit)FOREACH(pp,ansr,jit)\n\t\t\t\t\tans.insert((*iit)-(*jit));\n\t\t\tif(ss[i]=='*')\n\t\t\t\tFOREACH(pp,ansl,iit)FOREACH(pp,ansr,jit)\n\t\t\t\t\tans.insert((*iit)*(*jit));\n\t\t\tif(ss[i]=='/')\n\t\t\t\tFOREACH(pp,ansl,iit)FOREACH(pp,ansr,jit)\n\t\t\t\t{\n\t\t\t\t\tif((*jit)!=0)\n\t\t\t\t\tans.insert((*iit)/(*jit));\n\t\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\twhile(cin >> ss &&(ss!=\"#\"))\n\t{\n\t\tpp anss = solve(0,ss.size()-1);\n\t\tcout << anss.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<sstream>\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long ll;\n\nbool isnum(string s){\n  for(int i = 0; i < s.length(); i++)\n    if(s[i] < '0' || '9' < s[i]) return false;\n\n  return true;\n}\n\nbool issep(string s){\n  int p = 1;\n  if(s[0] != '(') return false;\n  for(int i = 1; i < s.length()-1; i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n    if(p == 0) return false;\n  }\n  // cout << \" test \" << s[s.length()-1] << \" \" << p << endl;\n  return ((s[s.length()-1] == ')') && (p == 1));\n}\n\nvector<ll> solve(string s){\n\n  //  cout << \"s \" << s << endl;\n  \n  vector<ll> V;\n\n  if(isnum(s)){\n    stringstream ss(s);\n    ll n;\n    ss >> n;\n    V.push_back(n);\n    return V;\n  }else if(issep(s)){\n    return solve(s.substr(1,s.length()-2));\n  }else{\n    int para = 0;\n\n    for(int i = 0; i < s.length(); i++){\n      vector<ll> v1,v2;\n      if(s[i] == '(') para++;\n      if(s[i] == ')') para--;\n\n      if(para == 0 && s[i] == '+'){\n\tv1 = solve(s.substr(0,i));\n\tv2 = solve(s.substr(i+1));\n\n\tfor(int j = 0; j < v1.size(); j++)\n\t  for(int k = 0; k < v2.size(); k++)\n\t    V.push_back(v1[j]+v2[k]);\n\t  \n      }\n\n      if(para == 0 && s[i] == '-'){\n\tvector<ll> v1,v2;\n\tv1 = solve(s.substr(0,i));\n\tv2 = solve(s.substr(i+1));\n\n\tfor(int j = 0; j < v1.size(); j++)\n\t  for(int k = 0; k < v2.size(); k++)\n\t    V.push_back(v1[j]-v2[k]);\n      }\n\n      if(para == 0 && s[i] == '*'){\n\tvector<ll> v1,v2;\n\tv1 = solve(s.substr(0,i));\n\tv2 = solve(s.substr(i+1));\n\n\tfor(int j = 0; j < v1.size(); j++)\n\t  for(int k = 0; k < v2.size(); k++)\n\t    V.push_back(v1[j]*v2[k]);\n      }\n\n      if(para == 0 && s[i] == '/'){\n\tvector<ll> v1,v2;\n\tv1 = solve(s.substr(0,i));\n\tv2 = solve(s.substr(i+1));\n\n\tfor(int j = 0; j < v1.size(); j++)\n\t  for(int k = 0; k < v2.size(); k++)\n\t    if(v2[k] != 0) V.push_back(v1[j]/v2[k]);\n\n      }\n    }\n  }\n  return V;\n}\n\nint main(){\n  \n  string in;\n  while(getline(cin,in) && in != \"#\"){\n    vector<ll> V = solve(in);\n    map<ll,bool> M;\n    ll ans = 0;\n    for(int i = 0; i < V.size(); i++){\n      if(M[V[i]] == false){\n\tM[V[i]] = true;\n\tans++;\n      }\n    }\n    \n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nset<int> parse(string &S, int &p){\n  if (isdigit(S[p])){\n    set<int> st;\n    int tmp = 0;\n    while (isdigit(S[p])){\n      tmp = tmp * 10 + S[p] - '0';\n      p++;\n      if (p == S.size()){\n        break;\n      }\n    }\n    st.insert(tmp);\n    return st;\n  } else {\n    vector<set<int>> st;\n    vector<char> op;\n    p++;\n    while (1){\n      st.push_back(parse(S, p));\n      if (p == S.size()){\n        break;\n      }\n      if (S[p] == ')'){\n        p++;\n        break;\n      }\n      op.push_back(S[p]);\n      p++;\n    }\n    int N = st.size();\n    vector<vector<set<int>>> dp(N + 1, vector<set<int>>(N + 1));\n    for (int i = 0; i < N; i++){\n      dp[i][i + 1] = st[i];\n    }\n    for (int d = 2; d <= N; d++){\n      for (int i = 0; i <= N - d; i++){\n        int j = i + d;\n        for (int k = i + 1; k < j; k++){\n          for (int x : dp[i][k]){\n            for (int y : dp[k][j]){\n              if (op[k - 1] == '+'){\n                dp[i][j].insert(x + y);\n              }\n              if (op[k - 1] == '-'){\n                dp[i][j].insert(x - y);\n              }\n              if (op[k - 1] == '*'){\n                dp[i][j].insert(x * y);\n              }\n              if (op[k - 1] == '/' && y != 0){\n                if ((x < 0) ^ (y < 0)){\n                  dp[i][j].insert(abs(x) / abs(y) * -1);\n                } else {\n                  dp[i][j].insert(abs(x) / abs(y));\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return dp[0][N];\n  }\n}\nint main(){\n  while (1){\n    string S;\n    cin >> S;\n    if (S == \"#\"){\n      break;\n    }\n    S = '(' + S + ')';\n    int p = 0;\n    set<int> st = parse(S, p);\n    cout << st.size() << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MP make_pair\n\ntypedef pair<int, int> PII;\n\nconst int SIZE = 100;\n\nchar line[SIZE], t[SIZE];\nset<int> memo[SIZE][SIZE];\nset<PII> used;\n \nvoid eval(int const l, int const r) {\n   \n  set<int>& ret = memo[l][r];\n  if(l == r) return;\n   \n  if(used.count(MP(l, r))) return;\n  used.insert(MP(l, r));\n   \n  // check is digits [l, r)\n  bool digits = true;\n  for(int i=l; i<r; i++) { digits = digits && isdigit(line[i]); }\n  strncpy(t, line+l, r-l); t[r-l+1] = 0;\n  if(digits) { ret.insert(atoi(t)); return; }\n   \n  int par = 0; bool check = true;\n  for(int i=l; i<r-1; i++) {\n    if(line[i] == '(') { par ++; }\n    if(line[i] == ')') { par --; }\n    if(par == 0) { check = false; }\n  }\n   \n  // \"(expr)\"\n  if(check) {\n    if(line[r-1] == ')') {\n      eval(l+1, r-1); ret = memo[l+1][r-1]; return;\n    }\n  }\n   \n  par = 0;\n  // parsing loop\n  for(int i=l; i<r; i++) {\n    if(line[i] == '(') { par ++; }\n    if(line[i] == ')') { par --; }\n    if(par != 0) continue;\n     \n    switch(line[i]) {\n    case '+': case '-': case '*': case '/': {\n      eval(l, i); eval(i+1, r);\n      set<int>::iterator iter_a, iter_b;\n      for(iter_a = memo[l][i].begin(); iter_a!=memo[l][i].end(); iter_a++) {\n        for(iter_b = memo[i+1][r].begin(); iter_b!=memo[i+1][r].end(); iter_b++) {\n          if(line[i] == '+') { ret.insert(*iter_a + *iter_b); }\n          if(line[i] == '-') { ret.insert(*iter_a - *iter_b); }\n          if(line[i] == '*') { ret.insert(*iter_a * *iter_b); }\n          if(line[i] == '/') {\n            if(*iter_b == 0) continue;\n            ret.insert(*iter_a / *iter_b);\n          }\n        }\n      }\n      break;\n    }\n    default:;\n    }\n  } // for parsing loop\n}\n \nint main() {\n   \n  while(1) {\n    scanf(\"%s\\n\", line);\n    for(int i=0; i<SIZE; i++)\n      for(int j=0; j<SIZE; j++)\n        memo[i][j].clear();\n     \n    used.clear();\n     \n    if(0==strcmp(line, \"#\")) break;\n    eval(0, strlen(line));\n    cout << memo[0][strlen(line)].size() << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nstring st;\n\nint getnum( int l) {\n\tint num = 0;\n\twhile (isdigit(st[l])) {\n\t\tnum = num * 10 + st[l] - '0';\n\t\tl++;\n\t}\n\treturn num;\n\n}\nint calc(const int a,const int b,const char type) {\n\tif (type == '+')return a + b;\n\telse if (type == '-')return a - b;\n\telse if (type == '*')return a*b;\n\telse {\n\t\tif (b)return a / b;\n\t\telse {\n\t\t\tthrow(false);\n\t\t}\n\t}\n}\n\nset<int> getexpr(const int l,const int r) {\n\tset <int>aset;\n\tif (l > r)assert(false);\n\tif (st[l] == '('&&st[r] == ')')return getexpr(l + 1, r - 1);\n\tint depth = 0;\n\tbool flag = false;\n\tfor (int x = l; x <= r; ++x) {\n\t\tif (st[x] == '(') {\n\t\t\tdepth++;\n\t\t}\n\t\telse if (st[x] == ')') {\n\t\t\tdepth--;\n\t\t}\n\t\telse if (st[x] == '+' || st[x] == '-' || st[x] == '*' || st[x] == '/') {\n\t\t\tflag = true;\n\t\t\tif (!depth) {\n\t\t\t\tconst set<int> lset = getexpr(l, x - 1);\n\t\t\t\tconst set<int> rset = getexpr(x + 1, r);\n\t\t\t\tfor (auto a : lset) {\n\t\t\t\t\tfor (auto b : rset) {\n\t\t\t\t\t\tif (st[x] == '/'&&!b)continue;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\taset.emplace(calc(a, b, st[x]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!flag) {\n\t\taset.emplace(getnum(l));\n\t}\n\treturn aset;\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> st;\n\t\tif (st == \"#\")break;\n\t\tset<int>aset;\n\t\tbool ok = true;\n\t\ttry {\n\t\t\taset=getexpr(0,st.size()-1);\n\t\t}\n\t\tcatch (...) {\n\t\t\tok = false;\n\t\t}\n\t\t\n\t\tcout << aset.size() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef set <int> S;\nchar ch;\n\nstring get_str(string &str,int i){\n  int cnt=0,f=1;\n  if(str[i]==')') f=-1;\n  string res;\n  i+=f,cnt+=f;\n  while(1) {\n    if(str[i]=='(')cnt++;\n    if(str[i]==')')cnt--;\n    if(!cnt)break;\n    res+=str[i];\n    i+=f;\n  }\n  if(f==1&&i<(int)str.size()) str='$'+str.substr(i+1,str.size()-i);\n  else if(f==-1&&i) str=str.substr(0,i)+'$';\n  else str=\"\";\n  if(f==-1)reverse(res.begin(),res.end());\n  return res;\n}\n\n\nint num[1<<8];\nvector <S> mem;\nmap <string,int> M;\n\nvoid calc(char ch,S a,S b, S &res){\n  S::iterator i,j;\n  for(i=a.begin();i!=a.end();i++)\n    for(j=b.begin();j!=b.end();j++){\n      int I=*i,J=*j,c=0;\n      if(ch=='+') c=I+J;\n      else if(ch=='-') c=I-J;\n      else if(ch=='*') c=I*J;\n      else if(ch=='/'){\n\tif(!J)continue;\n\tc=I/J;\n      }\n      res.insert(c);\n    }\n}\n\nS solve(string str){\n  S a,b,res;\n  string stra,strb;\n  \n  if(str[0]=='(') a=solve((stra=get_str(str,0))),stra='('+stra+')';\n  else a.insert(num[str[0]]),stra+=str[0];\n  if(str[str.size()-1]==')') b=solve((strb=get_str(str,str.size()-1))),strb='('+strb+')';\n  else b.insert(num[str[str.size()-1]]),strb+=str[str.size()-1];\n  \n  if(str.size()==1){\n    res.insert(num[str[0]]);\n    return res;\n  }\n  if(M.count(str))return mem[M[str]];\n\n  calc(str[1],a,solve(str.substr(2,str.size()-3)+strb),res);\n  calc(str[str.size()-2],solve(stra+str.substr(1,str.size()-3)),b,res);\n\n  M[str]=mem.size();  \n  mem.push_back(res);\n  return res;\n}\n\nint main(){\n  while(1){\n    string str;\n    cin>>str;\n    if(str==\"#\")break;\n    mem.clear(),M.clear();\n    string siki;\n    ch='A';\n    for(int i=0;i<(int)str.size();){\n      int b=0;\n      while('0'<=str[i]&&str[i]<='9') b=b*10+str[i++]-'0';\n      if(b) num[ch]=b,siki+=ch++;\n      else siki+=str[i++];\n    }\n    cout <<solve(siki).size()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v, y, m; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint num(string& s, int l, int r) {\n\tint x = 0;\n\tfor (int i = l; i < r; i++)\n\t\tx = x * 10 + (s[i] - '0');\n\treturn x;\n}\n\nset<int> f(string& s, int l, int r) {\n\tset<int> Z;\n\tint lev = 0;\n\tbool flag = false;\n\tfor (int i = l; i < r; i++) {\n\t\tchar c = s[i];\n\t\tif (c == '(') lev++;\n\t\tif (c == ')') lev--;\n\t\tif (lev == 0 && (c == '+' || c == '-' || c == '*' || c == '/')) {\n\t\t\tset<int> X = f(s, l, i), Y = f(s, i + 1, r);\n\t\t\tfor (set<int>::iterator ix = X.begin(); ix != X.end(); ix++)\n\t\t\t\tfor (set<int>::iterator iy = Y.begin(); iy != Y.end(); iy++) {\n\t\t\t\t\tint x = *ix, y = *iy;\n\t\t\t\t\tif (c == '+') Z.insert(x + y);\n\t\t\t\t\tif (c == '-') Z.insert(x - y);\n\t\t\t\t\tif (c == '*') Z.insert(x * y);\n\t\t\t\t\tif (c == '/' && y != 0) Z.insert(x / y);\n\t\t\t\t}\n\t\t\tflag = true;\n\t\t}\n\t}\n\tif (flag) return Z;\n\telse if (s[l] == '(') return f(s, l + 1, r - 1);\n\tZ.insert(num(s, l, r));\n\treturn Z;\n}\n\nint main() {\n\tfor (;;) {\n\t\tstring s; cin >> s;\n\t\tif (s == \"#\") break;\n\t\tint l = 0, r = s.length();\n\t\tset<int> Z = f(s, l, r);\n\t\tcout << Z.size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nset<string> S;\n\n// a op b の計算結果を返す. (a と b は '0'-'9', c は '+' or '-' or '*' or '/' )\nstring operate(char a, char op, char b){\n\tstring result;\n\tif( op == '+' ){\n\t\tint c = (a - '0') + (b - '0');\n\t\tif( c >= 10 ) result.push_back('1');\n\t\tresult.push_back((c % 10) + '0');\n\t}else if( op == '-' ){\n\t\tint c = (a - '0') - (b - '0');\n\t\tif( c < 0 ){\n\t\t\tresult.push_back('-');\n\t\t\tc *= -1;\n\t\t}\n\t\tresult.push_back((c % 10) + '0');\n\t}else if( op == '*' ){\n\t\tint c = (a - '0') * (b - '0');\n\t\tif( c >= 10 ) result.push_back( (c/10) + '0' );\n\t\tresult.push_back((c % 10) + '0');\n\t}else if( op == '/' ){\n\t\tif( b != '0' ){\n\t\t\tint c = (a - '0') / (b - '0');\n\t\t\tresult.push_back((c % 10) + '0');\n\t\t}\n\t}\n\treturn result;\n}\n\nbool is_op(char op){\n\treturn  (op == '+' || op == '-' || op == '*' || op == '/');\n}\n\nbool is_digit(char a){\n\treturn ('0' <= a && a <= '9');\n}\n\nbool check(char a, char op, char b){\n\treturn (is_digit(a) && is_digit(b) && is_op(op) );\n}\n\nbool is_number(string s){\n\tif( s[0] == '-' ){\n\t\tfor(int i=1 ; i < s.size() ; i++ ){\n\t\t\tif( !is_digit(s[i]) ) return false;\n\t\t}\n\t}else{\n\t\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\t\tif( !is_digit(s[i]) ) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid solve(string ex){\n\tif( is_number(ex) ){\n\t\tif( ex == \"-0\" ) ex = \"0\";\n\t\tS.insert( ex );\n\t\treturn ;\n\t}\n\tfor(int i=2 ; i < ex.size() ; i++ ){\n\t\tif( check(ex[i-2], ex[i-1], ex[i]) ){\n\t\t\tif( ex[i-1] == '+' || ex[i-1] == '-' ){\n\t\t\t\tif( i-3 >= 0 && i+1 < ex.size() && ex[i-3] == '(' && ex[i+1] == ')' ){\n\t\t\t\t\tstring s = operate(ex[i-2], ex[i-1], ex[i]);\n\t\t\t\t\tif( s.empty() ) continue;\n\t\t\t\t\tstring next;\n\t\t\t\t\tfor(int j=0 ; j < i-3 ; j++ ){\n\t\t\t\t\t\tnext.push_back( ex[j] );\n\t\t\t\t\t}\n\t\t\t\t\tnext += s;\n\t\t\t\t\tfor(int j=i+2 ; j < ex.size() ; j++ ){\n\t\t\t\t\t\tnext.push_back( ex[j] );\n\t\t\t\t\t}\n\t\t\t\t\t// cout << \"ex : \" << next << endl;\n\t\t\t\t\tsolve( next );\n\t\t\t\t}else{\n\t\t\t\t\tstring s = operate(ex[i-2], ex[i-1], ex[i]);\n\t\t\t\t\tif( s.empty() ) continue;\n\t\t\t\t\tstring next;\n\t\t\t\t\tfor(int j=0 ; j < i-2 ; j++ ){\n\t\t\t\t\t\tnext.push_back( ex[j] );\n\t\t\t\t\t}\n\t\t\t\t\tnext += s;\n\t\t\t\t\tfor(int j=i+1 ; j < ex.size() ; j++ ){\n\t\t\t\t\t\tnext.push_back( ex[j] );\n\t\t\t\t\t}\n\t\t\t\t\t// cout << \"ex : \" << next << endl;\n\t\t\t\t\tsolve( next );\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tstring s = operate(ex[i-2], ex[i-1], ex[i]);\n\t\t\t\tif( s.empty() ) continue;\n\t\t\t\tstring next;\n\t\t\t\tfor(int j=0 ; j < i-2 ; j++ ){\n\t\t\t\t\tnext.push_back( ex[j] );\n\t\t\t\t}\n\t\t\t\tnext += s;\n\t\t\t\tfor(int j=i+1 ; j < ex.size() ; j++ ){\n\t\t\t\t\tnext.push_back( ex[j] );\n\t\t\t\t}\n\t\t\t\t// cout << \"ex : \" << next << endl;\n\t\t\t\tsolve( next );\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstring ex;\n\twhile( cin >> ex , ex != \"#\" ){\n\t\tS.clear();\n\t\tsolve( ex );\n\t\tcout << S.size() << endl;\n\t\t/* for(set<string>::iterator it = S.begin() ; it != S.end() ; ++it ){\n\t\t\tcout << *it << endl;\n\t\t}*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nstring s;\n\nvoid dfs(int& id,vi& vec)\n{\n    vvi val;\n    vector<char> enz;\n    while(id < len(s)){\n        if(isdigit(s[id])){\n            vi hoge;\n            hoge.pb((s[id]-'0'));\n            val.pb(hoge);\n            id++;\n        }else if(s[id] == '('){\n            id++;\n            vi vv;\n            dfs(id,vv);\n            zip(vv);\n            val.pb(vv);\n        }else if(s[id] == ')'){\n            id++;\n            break;\n        }else{\n            enz.pb(s[id]);\n            id++;\n        }\n    }\n    vi num(len(enz)),ord(len(val));\n    vvi temp = val;\n    iota(all(num),0);\n    do{\n        val = temp;\n        iota(all(ord),0);\n        for(int i : num){\n            vi res;\n            rep(j,len(val[ord[i]])){\n                rep(k,len(val[ord[i+1]])){\n                    if(enz[i] == '+'){\n                        res.pb(val[ord[i]][j]+val[ord[i+1]][k]);\n                    }else if(enz[i] == '-'){\n                        res.pb(val[ord[i]][j]-val[ord[i+1]][k]);\n                    }else if(enz[i] == '*'){\n                        res.pb(val[ord[i]][j]*val[ord[i+1]][k]);\n                    }else{\n                        if(val[i+1][k] != 0){\n                            res.pb(val[ord[i]][j]/val[ord[i+1]][k]);\n                        }\n                    }\n                }\n            }\n            val[ord[i]] = res;\n            // show(i);\n            ord[i+1] = ord[i];\n            // svec(ord);\n        }\n        // svec(num);\n        rep(i,len(val[ord[0]])){\n            vec.pb(val[ord[0]][i]);\n        }\n    }while(next_permutation(all(num)));\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        cin >> s;\n        if(s == \"#\"){\n            break;\n        }\n        int id = 0;\n        vi vec;\n        dfs(id,vec);\n        zip(vec);\n        cout << len(vec) << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef set<int> :: iterator setit;\n\nint f(int a,char ch,int b){\n  if(ch=='+')return a+b;\n  else if(ch=='-')return a-b;\n  else if(ch=='*')return a*b;\n  else return a/b;\n}\n\nbool visited[20][20];\nset<int> dp[20][20];\nset<int> rec( int l,int r,  vector< set<int> > &t,  vector< char > &u ){\n  if(visited[l][r])return dp[l][r];\n  visited[l][r]=true;\n  set<int> res;\n  for(int i=l;i+1<=r;i++){\n    set<int> A,B;\n    A=rec(l,i,t,u);\n    B=rec(i+1,r,t,u);\n    for(setit j=A.begin();j!=A.end();j++){\n      for(setit k=B.begin();k!=B.end();k++){\n        int J=*j,K=*k;\n        if(u[i]=='/'&&K==0)continue;\n        res.insert( f(J,u[i],K) );\n      }\n    }\n  }\n  return dp[l][r]=res;\n}\n\nset<int> solve(   vector< set<int> > &t,  vector< char > &u ){\n  for(int i=0;i<20;i++)\n    for(int j=0;j<20;j++)\n      dp[i][j].clear(),visited[i][j]=false;\n  for(int i=0;i<(int)t.size();i++){\n    dp[i][i]=t[i];\n    visited[i][i]=true;\n  }\n  return rec(0,t.size()-1,t,u);\n}\n\n\n\nstring s;\nint p;\n\nset<int> calc();\n\nset<int> getNum(){\n  if(s[p]=='('){\n    p++;\n    return calc();\n  }\n  int a=0;\n  while('0'<=s[p]&&s[p]<='9'){\n    a=a*10+s[p]-'0';\n    p++;\n  }\n  set<int> res;\n  res.insert(a);\n  return res;\n}\n\nset<int> calc(){\n  vector< set<int> > t;\n  vector< char > u;\n  t.push_back(getNum());\n  while(1){\n    if(s[p]=='='||s[p]==')'){\n      p++;\n      break;\n    }\n    u.push_back(s[p]);\n    p++;\n    t.push_back(getNum());\n  }\n  if(u.size()==0)return t[0];\n  else return solve(t,u);\n}\n\nint main(){\n  while(1){\n    cin>>s;\n    if(s==\"#\")break;\n    s.push_back('=');\n    p=0;\n    set<int> ans=calc();\n    cout<<ans.size()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int INF = 1 << 30;\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef vector<double> vd;\ntypedef pair<int,int> pii;\ntypedef pair<long,long> pll;\ntypedef long long ll;\ntypedef set<int> si;\n\nenum { T_NUM, T_OP, T_PR0, T_PR1 };\n\nstruct Elm {\n  int type, v;\n  Elm() {}\n  Elm(int _t, int _v): type(_t), v(_v) {}\n\n  void print() const {\n    if (type == T_NUM) printf(\"%d\", v);\n    else printf(\"%c\", v);\n  }\n};\n\ntypedef vector<Elm> ve;\n\n/* global variables */\n\nsi ans;\n\n/* subroutines */\n\nvoid parse(ve& expr, string str) {\n  expr.clear();\n  int len = str.length();\n\n  for (int i = 0; i < len; i++)\n    switch (str[i]) {\n    case '(': expr.push_back(Elm(T_PR0, '(')); break;\n    case ')': expr.push_back(Elm(T_PR1, ')')); break;\n    case '+': expr.push_back(Elm(T_OP, '+')); break;\n    case '-': expr.push_back(Elm(T_OP, '-')); break;\n    case '*': expr.push_back(Elm(T_OP, '*')); break;\n    case '/': expr.push_back(Elm(T_OP, '/')); break;\n    default:\n      int num = 0;\n      while (i < len && str[i] >= '0' && str[i] <= '9')\n\tnum = 10 * num + (str[i++] - '0');\n      i--;\n      expr.push_back(Elm(T_NUM, num));\n    }\n}\n\nint calc(const Elm& e0, const Elm& op, const Elm& e1) {\n  switch (op.v) {\n  case '+': return e0.v + e1.v;\n  case '-': return e0.v - e1.v;\n  case '*': return e0.v * e1.v;\n  case '/': return (e1.v) ? e0.v / e1.v : INF;\n  }\n  return INF;\n}\n\nvoid print_expr(ve expr) {\n  for (ve::iterator vit = expr.begin(); vit != expr.end(); vit++)\n    vit->print(), putchar(' ');\n  putchar('\\n');\n}\n\nvoid rec(ve expr) {\n  //print_expr(expr);\n  int elen = expr.size();\n  if (elen == 1) {\n    ans.insert(expr.front().v);\n    return;\n  }\n\n  for (int i = 0; i < elen - 2; i++) {\n    Elm e0 = expr[i], op = expr[i + 1], e1 = expr[i + 2];\n    if (e0.type == T_NUM && op.type == T_OP && e1.type == T_NUM) {\n      int num = calc(e0, op, e1);\n      if (num >= INF) continue;\n\n      int pos0 = i, pos1 = i + 3;\n      int npr = 0;\n\n      while (pos0 > 0 && pos1 < elen &&\n\t     expr[pos0 - 1].type == T_PR0 &&\n\t     expr[pos1].type == T_PR1) {\n\tnpr++;\n\tpos0--;\n\tpos1++;\n      }\n\n      expr.erase(expr.begin() + pos0, expr.begin() + pos1);\n      expr.insert(expr.begin() + pos0, Elm(T_NUM, num));\n\n      //cout << \"--> \"; print_expr(expr);\n      rec(expr);\n\n      expr.erase(expr.begin() + pos0);\n      for (int j = 0; j < npr; j++)\n\texpr.insert(expr.begin() + pos0++, Elm(T_PR0, '('));\n      expr.insert(expr.begin() + pos0++, e0);\n      expr.insert(expr.begin() + pos0++, op);\n      expr.insert(expr.begin() + pos0++, e1);\n      for (int j = 0; j < npr; j++)\n\texpr.insert(expr.begin() + pos0++, Elm(T_PR1, ')'));\n      //cout << \"<-- \"; print_expr(expr);\n    }\n  }\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    string str;\n    cin >> str;\n    if (str == \"#\") break;\n\n    ve expr;\n    parse(expr, str);\n    //cout << expr.size() << endl;\n\n    ans.clear();\n    rec(expr);\n    cout << ans.size() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype>\n#include <set>\n#include <numeric>\nusing namespace std;\n\nvector<int> order;\n\nstruct Term {\n    char op;\n    set<int> operand;\n    Term(char c, set<int> si) : op(c), operand(si) { }\n};\n\ntemplate<class T> struct Parser {\n    typedef string::const_iterator State;\n\n    T solve(const string &S) {\n        State begin = S.begin();\n        return expr(begin);\n    }\n\n    // expr ::= factor | factor + factor | factor - factor\n    //         | factor * factor | factor / factor\n    T expr(State &begin) {\n        vector<Term> terms;\n        terms.emplace_back('@', factor(begin));\n        for (;;) {\n            if (*begin == '+') {\n                terms.emplace_back('+', factor(++begin));\n            } else if (*begin == '-') {\n                terms.emplace_back('-', factor(++begin));\n            } else if (*begin == '*') {\n                terms.emplace_back('*', factor(++begin));\n            } else if (*begin == '/') {\n                terms.emplace_back('/', factor(++begin));\n            } else {\n                break;\n            }\n        }\n        return dp(terms, 0, terms.size());\n    }\n\n    T dp(vector<Term> &terms, int l, int r) {\n        if (l + 1 == r) {\n            return terms[l].operand;\n        } else {\n            T res1 = f(dp(terms, l, r - 1), terms[r - 1].op, terms[r - 1].operand);\n            T res2 = f(terms[l].operand, terms[l + 1].op, dp(terms, l + 1, r));\n            return merge(res1, res2);\n        }\n    }\n\n    T f(T left, char op, T right) {\n        T res;\n        for (int a : left) for (int b : right) {\n            if (op == '+') res.insert(a + b);\n            else if (op == '-') res.insert(a - b);\n            else if (op == '*') res.insert(a * b);\n            else if (op == '/') res.insert(a / b);\n        }\n        return res;\n    }\n\n    T merge(T left, T right) {\n        T res;\n        for (int e : left) res.insert(e);\n        for (int e : right) res.insert(e);\n        return res;\n    }\n\n    // expr ::= ( term ) | num\n    T factor(State &begin) {\n        if (*begin == '(') {\n            begin++; // skip '('\n            T ret = expr(begin);\n            begin++; // skip ')'\n            return ret;\n        } else {\n            return number(begin);\n        }\n    }\n\n    // num ::= digit | num digit\n    T number(State &begin) {\n        int ret = 0;\n        while (isdigit(*begin)) {\n            ret *= 10;\n            ret += *begin - '0';\n            begin++;\n        }\n        return {ret};\n    }\n};\n\nint main() {\n    string S;\n    while (cin >> S && S != \"#\") {\n        Parser<set<int>> ps;\n        cout << ps.solve(S).size() << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nconst int INF = 1e9+100;\n\nbool isnum(char c){\n  return '0' <= c && c <= '9';\n}\n\nbool isop(char c){\n  const string op = \"+*-/\";\n  return op.find(c) != string::npos;\n}\n\nint find_paren(const string& s, int i){\n  int cnt = 0;\n  for(;i<SZ(s);++i){\n\tif(s[i] == '(') ++cnt;\n\telse if(s[i] == ')')\n\t  if(--cnt == 0) return i;\n  }\n  return -1;\n}\n\nset<int> eval(const string& s){\n  VS terms;\n  vector<char> ops;\n  string term;\n  for(int i=0;i<SZ(s);++i){\n\tif(isnum(s[i]))\n\t  term += string(1,s[i]);\n\telse if(s[i] == '('){\n\t  if(!term.empty()){\n\t\t//cout << term << endl;\n\t\tterms.PB(term);\n\t  }\n\t  int j = find_paren(s, i);\n\t  term = s.substr(i+1, j-i-1);\n\t  i = j;\n\t}\n\telse{\n\t  if(!term.empty()){\n\t\t//cout << term << endl;\n\t\tterms.PB(term);\n\t  }\n\t  term = \"\";\n\t  ops.PB(s[i]);\n\t}\n  }\n  terms.PB(term);\n\n  set<int> res;\n  if(ops.empty()){\n\tif(terms[0][0] == '(')\n\t  return eval(terms[0].substr(1, SZ(terms[0])-2));\n\telse\n\t  res.insert(atoi(terms[0].c_str()));\n  }\n  else{\n\tfor(int i=0;i<SZ(ops);++i){\n\t  string lhs;\n\t  for(int j=0;j<=i;++j){\n\t\tif(j != 0) lhs += ops[j];\n\t\tlhs += terms[j];\n\t  }\n\t  set<int> l = eval(lhs);\n\t  string rhs;\n\t  for(int j=i+1;j<SZ(terms);++j){\n\t\tif(j != i+1) rhs += ops[j-1];\n\t\trhs += terms[j];\n\t  }\n\t  set<int> r = eval(rhs);\n\t  for(int lx: l){\n\t\tfor(int rx: r){\n\t\t  int x;\n\t\t  switch(ops[i]){\n\t\t  case '+': x = lx+rx; break;\n\t\t  case '-': x = lx-rx; break;\n\t\t  case '*': x = lx*rx; break;\n\t\t  case '/': x = (rx != 0? lx/rx: INF); break;\n\t\t  }\n\t\t  if(x != INF) res.insert(x);\n\t\t}\n\t  }\n\t}\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  string expr;\n  while(cin>>expr,expr!=\"#\"){\n\tcout << SZ(eval(expr)) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef string::const_iterator state;\n\nint expression(state&);\n\nint number(state &begin){\n    int res=0;\n    while(isdigit(*begin)){\n        res*=10;\n        res+=*begin-'0';\n        ++begin;\n    }\n    return res;\n}\n\nint factor(state &begin){\n    if(*begin=='(' or *begin=='['){\n        begin++;\n        const int res=expression(begin);\n        begin++;\n        return res;\n    }else return number(begin);\n}\n\nint expression(state &begin){\n    int res=factor(begin);\n    if(res==inf) return inf;\n    while(true){\n        if(*begin=='+'){\n            ++begin;\n            res+=expression(begin);\n        }else if(*begin=='-'){\n            ++begin;\n            res-=expression(begin);\n        }else if(*begin=='*'){\n            ++begin;\n            res*=expression(begin);\n        }else if(*begin=='/'){\n            ++begin;\n            const int tmp=expression(begin);\n            if(tmp==0) return inf;\n            res/=tmp;\n        }else break;\n    }\n    return res;\n}\n\nvoid solve(){\n    while(true){\n        string str;\n        cin >> str;\n        if(str==\"#\") return;\n\n        const int cnt=0;\n        for(const auto ch:str) if(ch=='+' or ch=='-' or ch=='*' or ch=='/') ++cnt;\n\n        set<int> res;\n        function<void(const string,const int,const stack<char>,bool)> rec=[&](const string s,const int idx,const stack<char> stk,bool f){\n            if(idx==s.size()){\n                if(!stk.size()){\n                    string s_=s;\n                    dump(s_);\n                    state begin=s_.begin();\n                    const int res_=expression(begin);\n                    if(res_!=inf) res.insert(res_);\n                    dump(res_);\n                }\n                return;\n            }\n            if(s[idx]=='('){\n                auto stk_=stk;\n                stk_.push('(');\n                rec(s,idx+1,stk_,f);\n                return;\n            }\n            if(s[idx]==')'){\n                if(!stk.size() or stk.top()!='(') return;\n                auto stk_=stk;\n                stk_.pop();\n                rec(s,idx+1,stk_,f);\n                return;\n            }\n            if(stk.size()<cnt and isdigit(s[idx]) and (!idx or !isdigit(s[idx-1]))){\n                auto stk_=stk;\n                stk_.push('[');\n                auto s_=s;\n                s_.insert(idx,\"[\");\n                rec(s_,idx,stk_,false);\n            }\n            if(f and (idx+1==s.size() or (isdigit(s[idx]) and !isdigit(s[idx+1])))){\n                if(!stk.size() or stk.top()!='['){\n                    rec(s,idx+1,stk,f);\n                    return;\n                }\n                auto stk_=stk;\n                auto s_=s;\n                stk_.pop();\n                if(idx+1==s.size()) s_+=\"]\";\n                else s_.insert(idx+1,\"]\");\n                rec(s_,idx+1,stk_,false);\n            }\n            if(s[idx]=='+' or s[idx]=='-' or s[idx]=='*' or s[idx]=='/') rec(s,idx+1,stk,true);\n            else rec(s,idx+1,stk,f);\n        };\n        rec(str,0,stack<char>(),false);\n        cout << res.size() << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1 << 30;\nint eval_exp(int x, int y, char op) {\n    if(op == '/' && y == 0) return INF;\n\n    if(op == '+') return x + y;\n    if(op == '-') return x - y;\n    if(op == '*') return x * y;\n    if(op == '/') return x / y;\n    return INF;\n}\n\nstring ops = \"+-/*\";\nset<int> parse(string s, int l, int r) {\n    int level = 0;\n    vector<int> op_idx;\n\n    for(int i=l; i<r; i++) {\n        if     (s[i] == '(') level++;\n        else if(s[i] == ')') level--;\n        else {\n            if(level == 0 && ops.find(s[i]) != string::npos) {\n                op_idx.push_back(i);\n            }\n        }\n    }\n\n    if(op_idx.size()) {\n        set<int> ret;\n        for(auto piv : op_idx) {\n            set<int> lhs = parse(s, l, piv);\n            set<int> rhs = parse(s, piv+1, r);\n\n            for(auto x : lhs) {\n                for(auto y : rhs) {\n                    int num = eval_exp(x, y, s[piv]);\n                    if(num == INF) continue;\n                    ret.insert(num);\n                }\n            }\n        }\n        return ret;\n    }\n    else {\n        if(s[l] == '(') return parse(s, l+1, r-1);\n        int value = 0;\n        for(int i=l; i<r; i++) {\n            value = (value * 10 + (s[i] - '0'));\n        }\n        return set<int>{value};\n    }\n}\n\nint main() {\n    string s;\n    while(cin >> s, s != \"#\") {\n        int len = s.length();\n        cout << parse(s, 0, len).size() << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef string::const_iterator state;\n\nint expression(state&);\n\nint number(state &begin){\n    int res=0;\n    while(isdigit(*begin)){\n        res*=10;\n        res+=*begin-'0';\n        ++begin;\n    }\n    return res;\n}\n\nint factor(state &begin){\n    if(*begin=='(' or *begin=='['){\n        begin++;\n        const int res=expression(begin);\n        begin++;\n        return res;\n    }else return number(begin);\n}\n\nint expression(state &begin){\n    int res=factor(begin);\n    if(res==inf) return inf;\n    while(true){\n        if(*begin=='+'){\n            ++begin;\n            res+=expression(begin);\n        }else if(*begin=='-'){\n            ++begin;\n            res-=expression(begin);\n        }else if(*begin=='*'){\n            ++begin;\n            res*=expression(begin);\n        }else if(*begin=='/'){\n            ++begin;\n            const int tmp=expression(begin);\n            if(tmp==0) return inf;\n            res/=tmp;\n        }else break;\n    }\n    return res;\n}\n\nvoid solve(){\n    while(true){\n        string str;\n        cin >> str;\n        if(str==\"#\") return;\n\n        set<int> res;\n        function<void(const string,const int,const stack<char>,bool)> rec=[&](const string s,const int idx,const stack<char> stk,bool f){\n            if(idx==s.size()){\n                if(!stk.size()){\n                    string s_=s;\n                    dump(s_);\n                    state begin=s_.begin();\n                    const int res_=expression(begin);\n                    if(res_!=inf) res.insert(res_);\n                    dump(res_);\n                }\n                return;\n            }\n            if(s[idx]=='('){\n                auto stk_=stk;\n                stk_.push('(');\n                rec(s,idx+1,stk_,f);\n                return;\n            }\n            if(s[idx]==')'){\n                if(!stk.size() or stk.top()!='(') return;\n                auto stk_=stk;\n                stk_.pop();\n                rec(s,idx+1,stk_,f);\n                return;\n            }\n            if(stk.size()<10 and isdigit(s[idx]) and (!idx or !isdigit(s[idx-1]))){\n                auto stk_=stk;\n                stk_.push('[');\n                auto s_=s;\n                s_.insert(idx,\"[\");\n                rec(s_,idx,stk_,false);\n            }\n            if(f and idx+1==s.size() or (isdigit(s[idx]) and !isdigit(s[idx+1]))){\n                if(!stk.size() or stk.top()!='['){\n                    rec(s,idx+1,stk,f);\n                    return;\n                }\n                auto stk_=stk;\n                auto s_=s;\n                stk_.pop();\n                if(idx+1==s.size()) s_+=\"]\";\n                else s_.insert(idx+1,\"]\");\n                rec(s_,idx+1,stk_,false);\n            }\n            if(s[idx]=='+' or s[idx]=='-' or s[idx]=='*' or s[idx]=='/') rec(s,idx+1,stk,true);\n            else rec(s,idx+1,stk,f);\n        };\n        rec(str,0,stack<char>(),false);\n        cout << res.size() << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n// Shrotening\n#define fst first\n#define snd second\n#define pb push_back\n\n// Loop\n#define FOR(i,a,b) for(auto i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(auto i=(a);i>=(b);--i)\n\n#define REP(i,a) for(long i=0;i<(a);++i)\n#define RREP(i,a) for(long i=(a);i>=0;--i)\n\n#define EACH(i,a) for(auto (i)=(a).begin(),_END=(a).end();i!=_END;++i)\n#define REACH(i,a) for(auto (i)=(a).rbegin(),_END=(a).rend();i!=_END;++i)\n\n//Algorithm\n#define ALL(a) (a).begin(), a.end()\n#define RALL(a) (a).rbegin(), a.rend()\n#define EXIST(a,x) ((a).find(x)!=(a).end())\n#define SORT(a) std::sort((a).begin(), (a).end())\n#define UNIQUE(a) std::sort((a).begin(), a.end()), a.erase(std::unique((a).begin(), a.end()), a.end());\n#define SUM(a) std::accumulate((a).begin(), (a).end(), 0);\n\n//Setting\n#define OPT std::cin.tie(0);std::ios::sync_with_stdio(false);\n\n//debug message\nbool debug = true;\n#define MSG(s)   if(debug){std::cout << s << std::endl;}\n#define DEBUG(x) if(debug){std::cout << \"debug(\" << #x << \"): \" << x << std::endl;}\n\n//alias\ntypedef long long LL;\ntypedef std::vector<char> VC;\ntypedef std::vector<int>  VI;\ntypedef std::vector<long> VL;\ntypedef std::vector<long long> VLL;\n\ntypedef std::vector< VC > VC2;\ntypedef std::vector< VI > VI2;\ntypedef std::vector< VL > VL2;\ntypedef std::vector< VLL > VLL2;\n\ntypedef std::pair<int,int> PII;\n\n\nstd::string str;\nint len;\n\nstd::map<int,int> bracketTable;\n\nint inline calc(char op, int l, int r) {\n    return   op == '+' ? l + r\n           : op == '-' ? l - r\n           : op == '*' ? l * r\n           :             l / r;\n}\n\nbool inline isOperator(char c) {\n    return (c == '+' || c == '-' || c == '*' || c == '/');\n}\n\nbool isOperatorContain(int l, int r) {\n    int d = 0;\n    for(int i=l; i<=r; ++i) {\n        if(str[i] == '(') {\n            ++d;\n        }\n        if(str[i] == ')') {\n            --d;\n        }\n        if(d > 0) {\n            continue;\n        }\n\n        if(isOperator(str[i])) {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool isCloseBracket(int l, int r) {\n    return (bracketTable.count(l) > 0 && bracketTable[l] == r);\n}\n\nstd::map< std::pair<int,int>, std::set<int> > memo;\n\nstd::set<int> eval(int l, int r) {\n    std::pair<int,int> p = std::make_pair(l, r);\n    if(memo.count(p) > 0) {\n        return memo[p];\n    }\n\n    std::set<int> ans;\n    if(isCloseBracket(l, r)) {\n        ans = eval(l+1, r-1);\n    } else if(isOperatorContain(l, r)) {\n        int i = l, d = 0; //depth\n        while(i <= r) {\n            if(str[i] == '(') {\n                ++d;\n            }\n            if(str[i] == ')') {\n                --d;\n            }\n            if(d > 0) {\n                ++i;\n                continue;\n            }\n\n            if(isOperator(str[i])) {\n                char op = str[i];\n                auto left  = eval(l, i-1);\n                auto right = eval(i+1, r);\n                for(auto x: left) {\n                    for(auto y: right) {\n                        if(op == '/' && y == 0) {\n                            continue;\n                        }\n                        ans.insert(calc(op, x, y));\n                    }\n                }\n            }\n            ++i;\n        }\n    } else {\n        int v = 0;\n        int i = l;\n        while(i <= r && str[i] != ')') {\n            assert(str[i] >= '0' && str[i] <= '9');\n            v *= 10;\n            v += (str[i] - '0');\n            ++i;\n        }\n        ans.insert(v);\n    }\n    memo.insert(std::make_pair(p, ans));\n    return ans;\n}\n\nint main() {\n    int i, j;\n    while(std::cin >> str, str != \"#\") {\n        memo.clear();\n        bracketTable.clear();\n        len = str.length();\n        for(i=0; i<len; ++i) {\n            if(str[i] != '(') continue;\n\n            int d = 1;\n            for(j=i+1; j < len; ++j) {\n                if(str[j] == '(') {\n                    ++d;\n                } else if(str[j] == ')') {\n                    --d;\n                    if(d == 0) {\n                        break;\n                    }\n                }\n            }\n            bracketTable.insert(std::make_pair(i, j));\n        }\n\n        auto pat = eval(0, len - 1);\n        std::cout << pat.size() << std::endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\nusing namespace std;\n#define rep(i,a,b) for(auto (i)=(a);(i)<(b);(i)++)\n#define rev(i,a,b) for(auto (i)=(b)-1;(i)>=(a);(i)--)\n#define num_check(x) '0'<=(x)&&(x)<='9'\n\n\nstruct Siki{\n\tint num;\n\tint depth;\n\tchar type;\n\tint left, right;\n\n};\n\nint pri[10];//各演算子の計算順序\nint min_pri[6];//各演算子のdepthごとの計算順序の最低値、これを破るとNG\nSiki siki[12];\nSiki temp[12];//作業用配列\nint s_size;\nstring input;\nmap<int, int> data;\n\nbool check_pri(){\n\trep(i, 0, s_size){\n\t\tif (min_pri[siki[pri[i]].depth] > i)\n\t\t\treturn(false);\n\t}\n\treturn(true);\n}\n\nvoid init(){\n\t//初期化\n\tdata.clear();\n\trep(i, 0, 12)siki[i].num = 0;\n\trep(i, 0, 6)min_pri[i] = 0;\n\tint d = 0; \n\ts_size = 0;\n\t\n\t//入力を作業用に変換\n\trep(i, 0u, input.length()){\n\t\tif (num_check(input[i])){\n\t\t\tsiki[s_size].num *= 10;\n\t\t\tsiki[s_size].num += input[i] - '0';\n\t\t}\n\t\telse if (input[i] == '(')d++;//()の中に入るので深さを増加\n\t\telse if (input[i] == ')')d--;//深さを減少\n\t\telse\n\t\t{\n\t\t\tsiki[s_size].type = input[i];\n\t\t\tsiki[s_size].depth = d;\n\t\t\tpri[s_size] = s_size;\n\t\t\trep(j, d + 1, 6)\n\t\t\t\tmin_pri[j]++;\n\t\t\ts_size++;\n\t\t}\n\t}\n\tsiki[s_size].type = '\\0';//終端記号\n\trep(i, 0, s_size){\n\t\t//連結リスト構造の作成\n\t\tsiki[i].right = i+1;\n\t\tsiki[i + 1].left = i;\n\t}\n\tsiki[0].left = siki[s_size].right = -1;//左端、右端の保護\n\t\n}\n\n//2項計算する関数\nint calc(int l, char op, int r){\n\tswitch (op){\n\tcase '+':return(l + r);\n\tcase '-':return(l - r);\n\tcase '*':return(l * r);\n\tcase '/':return(l / r);\n\t}\n\treturn(0);\n}\n\n\nvoid parse(){\n\tSiki *p,*r,*l;\n\trep(i, 0, s_size+1)temp[i] = siki[i];//作業用配列にコピー\n\trev(i, 0, s_size){\n\t\tp = &temp[pri[i]];\n\t\tl = &temp[p->left];\n\t\tr = &temp[p->right];\n\n\t\tif (r->num == 0 && p->type == '/')return;//0除算を省く\n\t\t//printf(\"%d%c%d=\", p->num, p->type, r->num);\n\t\tr->num = calc(p->num, p->type, r->num);\n\t\t//printf(\"%d\\n\", r->num);\n\t\tr->left = p->left;\n\t\tif (p->left >=0 )l->right = p->right;\n\n\t}\n\t//cout << temp[s_size].num << endl;\n\tdata[temp[s_size].num]++;\n}\n\n//順列を効率的に列挙するための関数\nvoid p(int d, int dm){\n\tif (d == dm){\n\t\tif (check_pri()){\n\t\t\tparse();\n\t\t}\n\t}\n\trep(i, d, dm){\n\t\tswap(pri[d], pri[i]);\n\t\tp(d + 1, dm);\n\t\tswap(pri[d], pri[i]);\n\t}\n}\n\nint main(void){\n\twhile (true){\n\t\tcin >> input;\n\t\tif (input[0] == '#')break;\n\t\tinit();\n\t\t/*\t\n\t\trep(i, 0, siki_size)if (siki[i].type == 'c')printf(\"%d\", siki[i].num); else printf(\"%c\", siki[i].type); cout << endl;\n\t\trep(i, 0, op_size)printf(\"%c\", siki[index[i]].type); cout << endl;\n\t\trep(i, 0, op_size)printf(\"%d\", min_pri[siki[index[i]].num]); cout << endl;\n\t\t*/\n\t\tp(0, s_size);\n\t\tcout << data.size() << endl;\n\t}\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef set <int> S;\n\nint skip(string str,int i){\n  int cnt=str[i++]=='(';\n  while(cnt) cnt+=(str[i]=='(')-(str[i++]==')');\n  return i-1;\n}\n\nvoid calc(char ch,S a,S b, S &res){\n  S::iterator i,j;\n  for(i=a.begin();i!=a.end();i++)\n    for(j=b.begin();j!=b.end();j++){\n      int I=*i,J=*j;\n      if(ch=='+') I+=J;\n      else if(ch=='-') I-=J;\n      else if(ch=='*') I*=J;\n      else if(ch=='/'&&J)I/=J;\n      else continue;\n      res.insert(I);\n    }\n}\n\nint num[1<<8];\nS solve(string str){\n  S res;\n  int len=str.size();\n  if(len==1){res.insert(num[str[0]]);return res;}\n  if(skip(str,0)==len-1)res=solve(str.substr(1,len-2));\n\n  for(int i=0;(i=skip(str,i))<len-1;i+=2)\n    calc(str[i+1],solve(str.substr(0,i+1)),solve(str.substr(i+2,len-i-2)),res);\n\n  return res;\n}\n\nint main(){\n  while(1){\n    string str;\n    cin>>str;\n    if(str==\"#\")break;\n\n    string siki;\n    char ch='A';\n    for(int i=0;i<str.size();){\n      int b=0;\n      while('0'<=str[i]&&str[i]<='9') b=b*10+str[i++]-'0';\n      if(b)num[ch]=b,siki+=ch++;\n      else siki+=str[i++];\n    }\n    cout <<solve(siki).size()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct ops{\n  int pos,num;\n  char op;\n  ops(int pos, int num, char op):pos(pos),num(num),op(op){}\n  bool operator < (const ops &p) const {\n    return pos < p.pos;\n  }\n};\n\nstring str;\n\nvoid print(const vector<ops> &v){\n  for(int i=0;i<v.size();i++){\n    if(v[i].op == 0) cout << v[i].num;\n    else cout << v[i].op;\n  }\n  cout << endl;\n}\n\nvoid erase_parenthesis(vector<ops> &v){\n for(int i=0;i<(int)v.size()-2;i++){\n    if(v[i].op == '(' && v[i+1].op == 0 && v[i+2].op == ')'){\n      v.erase(v.begin() + i + 2);\n      v.erase(v.begin() + i);\n      i--;\n      if(i >= 0) i--;\n    }      \n  }\n\n}\n\nint solve(){\n  set<int> st;\n  vector<ops> ov,initv;\n\n  for(int i=0;i<str.size();i++){\n    if(str[i] == '+' || str[i] == '-' || str[i] == '*' || str[i] == '/'){\n      initv.push_back(ops(i, 0, str[i]));\n      ov.push_back(ops(i, 0, str[i]));\n    } else if(str[i] >= '0' && str[i] <= '9'){\n      int num = 0;\n      while(str[i] >= '0' && str[i] <= '9'){\n        num *= 10;\n        num += str[i] - '0';\n        i++;\n      }\n      i--;\n      initv.push_back(ops(i, num, 0));\n    } else {\n      initv.push_back(ops(i, 0, str[i]));\n    }\n  }\n\n  erase_parenthesis(initv);\n  if(initv.size() == 1 && initv[0].op == 0) return 1;\n\n  do{\n    vector<ops> v = initv;\n    for(int i=0;i<ov.size();i++){\n      int pos = lower_bound(v.begin(), v.end(), ov[i]) - v.begin(), res;\n      if(pos <= 0 || pos >= v.size()-1 || v[pos-1].op != 0 || v[pos+1].op != 0) break;\n      if(v[pos].op == '/' && v[pos+1].num == 0) break;\n      if(v[pos].op == '+') res = v[pos-1].num + v[pos+1].num;\n      if(v[pos].op == '-') res = v[pos-1].num - v[pos+1].num;\n      if(v[pos].op == '*') res = v[pos-1].num * v[pos+1].num;\n      if(v[pos].op == '/') res = v[pos-1].num / v[pos+1].num;\n      for(int j=0;j<2;j++) v.erase(v.begin()+pos);\n      v[pos-1].num = res;\n\n      erase_parenthesis(v);\n    }\n\n    if(v.size() == 1 && v[0].op == 0) st.insert(v[0].num);\n\n  } while(next_permutation(ov.begin(), ov.end()));\n\n  return max(1, (int)st.size());\n}\n\nint main(){\n  while(cin >> str && str != \"#\") cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nset<int> dp[15][15];\nint num;\nbool used[15][15];\nvector<int> v;\nvoid dfs(string s,int l,int r){\n  //cout<<s<<\" \"<<l<<\"-\"<<r<<endl;\n  if(used[l][r]) return;\n  used[l][r]=1;\n  if(l+1==r){\n    dp[l][r].insert(v[l]);\n    return;\n  }\n  int op=0,cnt=0;\n  while(s.front()=='('&&s.back()==')'){\n    s.erase(s.begin());\n    s.pop_back();\n  }\n  for(int i=0;i<(int)s.size();i++){\n    if(s[i]=='(') op++;\n    if(s[i]==')') op--;\n    if(isdigit(s[i])) cnt++;\n    if(op) continue;\n    if(s[i]=='+'||s[i]=='-'||s[i]=='*'||s[i]=='/'){\n      dfs(s.substr(0,i),l,l+cnt);\n      dfs(s.substr(i+1,s.length()-i-1),l+cnt,r);\n      for(int p:dp[l][l+cnt]){\n\tfor(int q:dp[l+cnt][r]){\n\t  if(s[i]=='+') dp[l][r].insert(p+q);\n\t  if(s[i]=='-') dp[l][r].insert(p-q);\n\t  if(s[i]=='*') dp[l][r].insert(p*q);\n\t  if(!q) continue;\n\t  if(s[i]=='/') dp[l][r].insert(p/q);\n\t}\n      }\n    }\n  }\n  //cout<<s<<\" \"<<l<<\"-\"<<r<<endl;\n  //for(auto i:dp[l][r]) cout<<i<<endl;\n}\nsigned main(){\n  string s;\n  while(cin>>s,s!=\"#\"){\n    //cout<<s<<\":\";\n    for(int i=0;i<15;i++)\n      for(int j=0;j<15;j++)\n\tdp[i][j].clear();\n    num=1;\n    v.clear();\n    for(int i=0;i<(int)s.size();i++){\n      if(s[i]=='+') num++;\n      if(s[i]=='-') num++;\n      if(s[i]=='*') num++;\n      if(s[i]=='/') num++;\n      if(isdigit(s[i])) v.push_back(s[i]-'0');\n    }\n    memset(used,0,sizeof(used));\n    dfs(s,0,num);\n    //for(auto i:dp[0][num]) cout<<i<<endl;\n    cout<<dp[0][num].size()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nstring S;\n \nint digit(int cur){\n    return S[cur]-'0';\n}\n \nset<int> number(int cur){\n    int res=digit(cur++);\n    while(isdigit(S[cur])){\n        res=10*res+digit(cur++);\n    }\n    set<int> ans;\n    ans.insert(res);\n    return ans;\n}\n \nset<int> exp(int l,int r){\n\n    if(isdigit(S[l])){\n\t\tbool isall=true;\n\t\tfor(int i=l;i<r;i++)\n\t\t\tif(!isdigit(S[i])) isall=false;\n\t\tif(isall)\n\t\t\treturn number(l);\n\t}\n\t\n\tif(S[l]=='('){\n\t\tbool all=true;\n\t\tfor(int i=l,depth=0;i<r;i++){\n\t\t\tif(S[i]=='(') depth++;\n\t\t\telse if(S[i]==')') depth--;\n\t\t\tif(i<r-1&&depth==0) all=false;\n\t\t}\n\t\tif(all) return exp(l+1,r-1);\n\t}\n\n    int num=0;\n    set<int> res;\n \n    for(int i=l;i<r;i++){\n        if(isdigit(S[i])){\n            continue;\n        }else if(S[i]=='('){\n            num++;\n        }else if(S[i]==')'){\n            num--;\n        }else if(num==0){\n            char op=S[i];\n            set<int> a=exp(l,i);\n            set<int> b=exp(i+1,r);\n            set<int> res2;\n            switch(op){\n                case '+':\n                    each(j,a)each(k,b) res2.insert((*j)+(*k));\n                    break;\n                case '-':\n                    each(j,a)each(k,b) res2.insert((*j)-(*k));\n                    break;\n                case '*':\n                    each(j,a)each(k,b) res2.insert((*j)*(*k));\n                    break;\n                case '/':\n                    each(j,a)each(k,b)if((*k)!=0)res2.insert((*j)/(*k));\n                    break;\n \n            }\n            each(j,res2) res.insert(*j);\n        }\n    }\n\treturn res;\n}\n  \nint main(void){\n    while(cin >> S){\n        int n=S.size();\n        if(S==\"#\")\n            break;\n\t\tset<int> ans=exp(0,n);\n        cout << ans.size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\n\n#define all(c) ((c).begin()), ((c).end())\n#define debug(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define present(c, e) ((c).find((e)) != (c).end())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, a, b) for (int i = (int)(a); i <= (int)(b); i++)\n\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\n\nconst double EPS = 1e-10;\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef complex<double> P;\n\n\nset<int> solve(int l, int r, string s) {\n\tint depth = 0;\n\tset<int> res;\n\tbool noop = true;\n\tREP(i, l, r - 1) {\n\t\tif (s[i] == '(') depth++;\n\t\telse if (s[i] == ')') depth--;\n\t\telse if (depth == 0) if (!isdigit(s[i])) {\n\t\t\tnoop = false;\n\t\t\tset<int> ls = solve(l, i, s);\n\t\t\tset<int> rs = solve(i + 1, r, s);\n\t\t\tif (s[i] == '+') tr(j, ls) tr(k, rs) res.insert(*j + *k);\n\t\t\tif (s[i] == '-') tr(j, ls) tr(k, rs) res.insert(*j - *k);\n\t\t\tif (s[i] == '*') tr(j, ls) tr(k, rs) res.insert(*j * *k);\n\t\t\tif (s[i] == '/') tr(j, ls) tr(k, rs) if (*k != 0) res.insert(*j / *k);\n\t\t}\n\t}\n\tif (noop) {\n\t\tif (s[l] == '(') {\n\t\t\tres = solve(l + 1, r - 1, s);\n\t\t}\n\t\tif (isdigit(s[l])) {\n\t\t\tint num = 0;\n\t\t\tREP(i, l, r - 1) num = num * 10 + s[i] - '0';\n\t\t\tres.insert(num);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tfor (string s; cin >> s, s != \"#\"; ) {\n\t\tcout << solve(0, s.size(), s).size() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <char,char> P;\ntypedef pair <int,P > PP;\n \nconst int tx[] = {+0,+1,+0,-1};\nconst int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\nstruct ParseResult{\n  int pos;\n  int num;\n  ParseResult(int pos,int num) : \n    pos(pos),num(num) {}\n  ParseResult();\n};\n\nclass Strategy {\npublic:\n  virtual void calc(int& lhs,int rhs) = 0;\n};\n\nclass AddStrategy : public Strategy{\npublic:\n  void calc(int& lhs,int rhs){\n    lhs += rhs;\n  }\n};\n\nclass SubStrategy : public Strategy{\npublic:\n  void calc(int& lhs,int rhs){\n    lhs -= rhs;\n  }\n};\n\nclass DivStrategy : public Strategy{\npublic:\n  void calc(int& lhs,int rhs){\n    lhs /= rhs;\n  }\n};\n\nclass MulStrategy : public Strategy{\npublic:\n  void calc(int& lhs,int rhs){\n    lhs *= rhs;\n  }\n};\n\nclass Processor {\nprivate:\n  Strategy* _strategy;\npublic:\n  void setStrategy(char ope){\n    if(ope == '+'){\n      _strategy = new AddStrategy();\n    }\n    else if(ope == '-'){\n      _strategy = new SubStrategy();\n    }\n    else if(ope == '*'){\n      _strategy = new MulStrategy();\n    }\n    else if(ope == '/'){\n      _strategy = new DivStrategy();\n    }\n  }\n  void calc(int& lhs,int rhs){\n    _strategy->calc(lhs,rhs);\n  }\n};\n\nParseResult expr(int pos,const string& str);\nParseResult expr(int pos,const string& str,char ope1);\nParseResult expr(int pos,const string& str,char ope1,char ope2);\nParseResult expr(int pos,const string& str,char ope1,char ope2,char ope3);\nParseResult factor(int pos,const string& str,char ope1);\nParseResult factor(int pos,const string& str,char ope1,char ope2);\nParseResult factor(int pos,const string& str,char ope1,char ope2,char ope3);\nParseResult term(int pos,const string& str);\nParseResult term(int pos,const string& str,char ope1);\nParseResult term(int pos,const string& str,char ope1,char ope2);\nParseResult term(int pos,const string& str,char ope1,char ope2,char ope3);\nParseResult num(int pos,const string& str);\n\nvector<char> infer_ope(char ope1){\n  bool used[256] = {};\n  used[ope1] = true;\n  vector<char> res;\n  if(!used['+']) res.push_back('+');\n  if(!used['-']) res.push_back('-');\n  if(!used['*']) res.push_back('*');\n  if(!used['/']) res.push_back('/');\n  return res;\n}\n\nvector<char> infer_ope(char ope1,char ope2){\n  bool used[256] = {};\n  used[ope1] = true;\n  used[ope2] = true;\n  vector<char> res;\n  if(!used['+']) res.push_back('+');\n  if(!used['-']) res.push_back('-');\n  if(!used['*']) res.push_back('*');\n  if(!used['/']) res.push_back('/');\n  return res;\n}\n\nvector<char> infer_ope(char ope1,char ope2,char ope3){\n  bool used[256] = {};\n  used[ope1] = true;\n  used[ope2] = true;\n  used[ope3] = true;\n  vector<char> res;\n  if(!used['+']) res.push_back('+');\n  if(!used['-']) res.push_back('-');\n  if(!used['*']) res.push_back('*');\n  if(!used['/']) res.push_back('/');\n  return res;\n}\n\nParseResult expr(int pos,const string& str){\n  ParseResult r = term(pos,str);\n  while(r.pos < str.size()\n        && (str[r.pos] == '+' || str[r.pos] == '-' || str[r.pos] == '*' || str[r.pos] == '/')){\n    ParseResult tmp = term(r.pos+1,str);\n    if(str[r.pos] == '+'){\n      Processor pr;\n      pr.setStrategy('+');\n      pr.calc(r.num,tmp.num);\n    }\n    if(str[r.pos] == '-'){\n      Processor pr;\n      pr.setStrategy('-');\n      pr.calc(r.num,tmp.num);\n    }\n    if(str[r.pos] == '/'){\n      Processor pr;\n      pr.setStrategy('/');\n      pr.calc(r.num,tmp.num);\n    }\n    if(str[r.pos] == '*'){\n      Processor pr;\n      pr.setStrategy('*');\n      pr.calc(r.num,tmp.num);\n    }\n    r.pos = tmp.pos;\n  }\n  return r;\n}\n\nParseResult expr(int pos,const string& str,char ope1){\n  vector<char> rem = infer_ope(ope1);\n  ParseResult r = factor(pos,str,rem[0],rem[1],rem[2]);\n  while(r.pos < str.size()\n        && (str[r.pos] == ope1)){\n    ParseResult tmp = factor(r.pos+1,str,rem[0],rem[1],rem[2]);\n    if(str[r.pos] == ope1){\n      Processor pr;\n      pr.setStrategy(ope1);\n      pr.calc(r.num,tmp.num);\n    }\n    r.pos = tmp.pos;\n  }\n  return r;\n}\n\nParseResult expr(int pos,const string& str,char ope1,char ope2){\n  vector<char> rem = infer_ope(ope1,ope2);\n  ParseResult r = factor(pos,str,rem[0],rem[1]);\n  while(r.pos < str.size()\n        && (str[r.pos] == ope1 || str[r.pos] == ope2)){\n    ParseResult tmp = factor(r.pos+1,str,rem[0],rem[1]);\n    if(str[r.pos] == ope1){\n      Processor pr;\n      pr.setStrategy(ope1);\n      pr.calc(r.num,tmp.num);\n    }\n    if(str[r.pos] == ope2){\n      Processor pr;\n      pr.setStrategy(ope2);\n      pr.calc(r.num,tmp.num);\n    }\n    r.pos = tmp.pos;\n  }\n  return r;\n}\n\nParseResult expr(int pos,const string& str,char ope1,char ope2,char ope3){\n  vector<char> rem = infer_ope(ope1,ope2,ope3);\n  ParseResult r = factor(pos,str,rem[0]);\n  while(r.pos < str.size()\n        && (str[r.pos] == ope1 || str[r.pos] == ope2 || str[r.pos] == ope3)){\n    ParseResult tmp = factor(r.pos+1,str,rem[0]);\n    if(str[r.pos] == ope1){\n      Processor pr;\n      pr.setStrategy(ope1);\n      pr.calc(r.num,tmp.num);\n    }\n    if(str[r.pos] == ope2){\n      Processor pr;\n      pr.setStrategy(ope2);\n      pr.calc(r.num,tmp.num);\n    }\n    if(str[r.pos] == ope3){\n      Processor pr;\n      pr.setStrategy(ope3);\n      pr.calc(r.num,tmp.num);\n    }\n    r.pos = tmp.pos;\n  }\n  return r;\n}\n\nParseResult factor(int pos, const string& str,char ope1){\n  vector<char> rem = infer_ope(ope1);\n  ParseResult r = term(pos,str,rem[0],rem[1],rem[2]);\n  while(r.pos < str.size()\n        && (str[r.pos] == ope1)){\n    ParseResult tmp = term(r.pos+1,str,rem[0],rem[1],rem[2]);\n    if(str[r.pos] == ope1){\n      Processor pr;\n      pr.setStrategy(ope1);\n      pr.calc(r.num,tmp.num);\n    }\n    r.pos = tmp.pos;\n  }\n  return r;\n}\n\nParseResult factor(int pos, const string& str,char ope1,char ope2){\n  vector<char> rem = infer_ope(ope1,ope2);\n  ParseResult r = term(pos,str,rem[0],rem[1]);\n  while(r.pos < str.size()\n        && (str[r.pos] == ope1 || str[r.pos] == ope2)){\n    ParseResult tmp = term(r.pos+1,str,rem[0],rem[1]);\n    if(str[r.pos] == ope1){\n      Processor pr;\n      pr.setStrategy(ope1);\n      pr.calc(r.num,tmp.num);\n    }\n    if(str[r.pos] == ope2){\n      Processor pr;\n      pr.setStrategy(ope2);\n      pr.calc(r.num,tmp.num);\n    }\n    r.pos = tmp.pos;\n  }\n  return r;\n}\n\nParseResult factor(int pos, const string& str,char ope1,char ope2,char ope3){\n  vector<char> rem = infer_ope(ope1,ope2,ope3);\n  ParseResult r = term(pos,str,rem[0]);\n  while(r.pos < str.size()\n        && (str[r.pos] == ope1 || str[r.pos] == ope2 || str[r.pos] == ope3)){\n    ParseResult tmp = term(r.pos+1,str,rem[0]);\n    if(str[r.pos] == ope1){\n      Processor pr;\n      pr.setStrategy(ope1);\n      pr.calc(r.num,tmp.num);\n    }\n    if(str[r.pos] == ope2){\n      Processor pr;\n      pr.setStrategy(ope2);\n      pr.calc(r.num,tmp.num);\n    }\n    if(str[r.pos] == ope3){\n      Processor pr;\n      pr.setStrategy(ope3);\n      pr.calc(r.num,tmp.num);\n    }\n    r.pos = tmp.pos;\n  }\n  return r;\n}\n\nParseResult term(int pos, const string& str,char ope1,char ope2,char ope3){\n  if(str[pos] == '('){\n    ParseResult r = expr(pos+1,str,ope1,ope2,ope3);\n    r.pos++; // for ')'\n    return r;\n  }\n  else {\n    return num(pos,str);\n  }\n}\n\nParseResult term(int pos, const string& str,char ope1,char ope2){\n  if(str[pos] == '('){\n    ParseResult r = expr(pos+1,str,ope1,ope2);\n    r.pos++; // for ')'\n    return r;\n  }\n  else {\n    return num(pos,str);\n  }\n}\n\nParseResult term(int pos, const string& str,char ope1){\n  if(str[pos] == '('){\n    ParseResult r = expr(pos+1,str,ope1);\n    r.pos++; // for ')'\n    return r;\n  }\n  else {\n    return num(pos,str);\n  }\n}\n\nParseResult term(int pos, const string& str){\n  if(str[pos] == '('){\n    ParseResult r = expr(pos+1,str);\n    r.pos++; // for ')'\n    return r;\n  }\n  else {\n    return num(pos,str);\n  }\n}\n\nParseResult num(int pos,const string& str){\n  int sum = 0;\n  while(pos < str.size() && isdigit(str[pos])){\n    sum *= 10;\n    sum += str[pos] - '0';\n    pos++;\n  }\n  return ParseResult(pos,sum);\n}\n\nint main(){\n  string str;\n  char patterns[4] = {'-','+','*','/'};\n  while(cin >> str){\n    if(str == \"#\") break;\n\n    for(int str_i = 0; str_i < str.size(); str_i++){\n      if(str[str_i] == '-'){\n        string pre = str.substr(0,str_i);\n        string suf = str.substr(str_i+1,str.size() - (str_i + 1));\n        string tmp = pre + \"-1*\" + suf;\n        str = tmp;\n      }\n    }\n    set<int> ans;\n    for(int i = 0; i < 4; i++){\n      for(int j = i+1; j < 4; j++){\n        ParseResult r = expr(0,str,patterns[i],patterns[j]);\n        ans.insert(r.num);\n      }\n    }\n    for(int i = 0; i < 4; i++){\n      ParseResult r = expr(0,str,patterns[i]);\n      ans.insert(r.num);\n\n    }\n    for(int i = 0; i < 4; i++){\n      vector<char> tmp;\n      for(int j = 0; j < 4; j++){\n        if(i != j) tmp.push_back(patterns[j]);\n      }\n      ParseResult r = expr(0,str,tmp[0],tmp[1],tmp[2]);\n      ans.insert(r.num);\n    }\n    ParseResult r2 = expr(0,str);\n    ans.insert(r2.num);\n    cout << ans.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\n\nstruct Edge{int to,from,cost;};\n\n#define debug cout\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define SS stringstream\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nset <int> add(string l,string r);\nset <int> sub(string l,string r);\nset <int> mul(string l,string r);\nset <int> div(string l,string r);\n\nset<int> addAll(set<int> a,set<int> b){\n\tset<int> res;\n\tfor(set<int>::iterator it=a.begin();it!=a.end();++it)res.insert(*it);\n\tfor(set<int>::iterator it=b.begin();it!=b.end();++it)res.insert(*it);\n\treturn res;\n}\n\nset<int> expr(string s){\n//debug<<s<<endl;\n\tbool in=true;\n\tint n=0;\n\trep(i,sz(s)){\n\t\tif(s[i]=='(')++n;\n\t\tif(s[i]==')')--n;\n\t\tif(n==0){\n\t\t\tif(s[i]==')'&&i==sz(s)-1)break;\n\t\t\tin=false;\n\t\t\tbreak;\n\t\t}\n\t}\n//debug<<in<<endl;\n\tif(in)return expr(s.substr(1,sz(s)-2));\n\tset<int> res;\n\tbool dig=true;\n\tn=0;\n\trep(i,sz(s)){\n\t\tif(!isdigit(s[i])){\n\t\t\tdig=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(dig){\n\t\tSS ss;\n\t\tss<<s;\n\t\tint num;\n\t\tss>>num;\n\t\tres.insert(num);\n\t\treturn res;\n\t}\n\tn=0;\n\trep(i,sz(s)){\n\t\tif(s[i]=='(')++n;\n\t\tif(s[i]==')')--n;\n\t\tif(n==0&&s[i]=='+')res=addAll(res,add(s.substr(0,i),s.substr(i+1,sz(s)-i-1)));\n\t\tif(n==0&&s[i]=='-')res=addAll(res,sub(s.substr(0,i),s.substr(i+1,sz(s)-i-1)));\n\t\tif(n==0&&s[i]=='*')res=addAll(res,mul(s.substr(0,i),s.substr(i+1,sz(s)-i-1)));\n\t\tif(n==0&&s[i]=='/')res=addAll(res,div(s.substr(0,i),s.substr(i+1,sz(s)-i-1)));\n\t}\n\treturn res;\n}\n\nset<int> add(string l,string r){\n\tset<int> left=expr(l);\n\tset<int> right=expr(r);\n\tset<int> res;\n\tfor(set<int>::iterator itl=left.begin();itl!=left.end();++itl){\n\t\tfor(set<int>::iterator itr=right.begin();itr!=right.end();++itr){\n\t\t\tres.insert(*itl+*itr);\n\t\t}\n\t}\n\treturn res;\n}\n\nset<int> sub(string l,string r){\n\tset<int> left=expr(l);\n\tset<int> right=expr(r);\n\tset<int> res;\n\tfor(set<int>::iterator itl=left.begin();itl!=left.end();++itl){\n\t\tfor(set<int>::iterator itr=right.begin();itr!=right.end();++itr){\n\t\t\tres.insert(*itl-*itr);\n\t\t}\n\t}\n\treturn res;\n}\n\nset<int> mul(string l,string r){\n\tset<int> left=expr(l);\n\tset<int> right=expr(r);\n\tset<int> res;\n\tfor(set<int>::iterator itl=left.begin();itl!=left.end();++itl){\n\t\tfor(set<int>::iterator itr=right.begin();itr!=right.end();++itr){\n\t\t\tres.insert(*itl**itr);\n\t\t}\n\t}\n\treturn res;\n}\n\nset<int> div(string l,string r){\n\tset<int> left=expr(l);\n\tset<int> right=expr(r);\n\tset<int> res;\n\tfor(set<int>::iterator itl=left.begin();itl!=left.end();++itl){\n\t\tfor(set<int>::iterator itr=right.begin();itr!=right.end();++itr){\n\t\t\tif(*itr==0)continue;\n\t\t\tres.insert(*itl/ *itr);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tstring s;\n\tIL{\n\t\tcin>>s;\n\t\tif(s==\"#\")break;\n\t\tcout<<sz(expr(s))<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define INFS (1LL<<28)\n#define DEKAI 1000000007\n//#define MOD 1000000007\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,n) for(int i=1;i<=n;i++)\n#define all(c) begin(c), end(c)\n\n//#define int long long \n\nnamespace {\n\t#define __DECLARE__(C)    \\\n\t    template <typename T> \\\n\tstd::ostream &operator<<(std::ostream &, const C<T> &);\n\n\t#define __DECLAREM__(C)               \\\n\t    template <typename T, typename U> \\\n\tstd::ostream &operator<<(std::ostream &, const C<T, U> &);\n\n\t__DECLARE__(std::vector)\n\t__DECLARE__(std::deque)\n\t__DECLARE__(std::set)\n\t__DECLARE__(std::stack)\n\t__DECLARE__(std::queue)\n\t__DECLARE__(std::priority_queue)\n\t__DECLARE__(std::unordered_set)\n\t__DECLAREM__(std::map)\n\t__DECLAREM__(std::unordered_map)\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &, const std::pair<T, U> &);\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &, const std::tuple<T...> &);\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &, const std::array<T, N> &);\n\n\ttemplate <typename Tuple, std::size_t N>\n\tstruct __TuplePrinter__ {\n\t\tstatic void print(std::ostream &os, const Tuple &t) {\n\t\t\t__TuplePrinter__<Tuple, N - 1>::print(os, t);\n\t\t\tos << \", \" << std::get<N - 1>(t);\n\t\t}\n\t};\n\n\ttemplate <typename Tuple>\n\tstruct __TuplePrinter__<Tuple, 1> {\n\t\tstatic void print(std::ostream &os, const Tuple &t) { os << std::get<0>(t); }\n\t};\n\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &os, const std::tuple<T...> &t) {\n\t\tos << '(';\n\t\t__TuplePrinter__<decltype(t), sizeof...(T)>::print(os, t);\n\t\tos << ')';\n\t\treturn os;\n\t}\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &v) {\n\t\treturn os << '(' << v.first << \", \" << v.second << ')';\n\t}\n\n\t#define __INNER__                             \\\n\tos << '[';                                \\\n\tfor (auto it = begin(c); it != end(c);) { \\\n\t\tos << *it;                            \\\n\t\tos << (++it != end(c) ? \", \" : \"\");   \\\n\t}                                         \\\n\treturn os << ']';\n\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &os, const std::array<T, N> &c) {\n\t\t__INNER__\n\t}\n\n\t#define __DEFINE__(C)                                           \\\n\t    template <typename T>                                       \\\n\tstd::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t\t__INNER__                                               \\\n\t}\n\n\t#define __DEFINEM__(C)                                             \\\n\t    template <typename T, typename U>                              \\\n\tstd::ostream &operator<<(std::ostream &os, const C<T, U> &c) { \\\n\t\t__INNER__                                                  \\\n\t}\n\n\t#define __DEFINEW__(C, M1, M2)                                  \\\n\t    template <typename T>                                       \\\n\tstd::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t\tstd::deque<T> v;                                        \\\n\t\tfor (auto d = c; !d.empty(); d.pop()) v.M1(d.M2());     \\\n\t\t\treturn os << v;                                         \\\n\t}\n\n\t__DEFINE__(std::vector)\n\t__DEFINE__(std::deque)\n\t__DEFINE__(std::set)\n\t__DEFINEW__(std::stack, push_front, top)\n\t__DEFINEW__(std::queue, push_back, front)\n\t__DEFINEW__(std::priority_queue, push_front, top)\n\t__DEFINE__(std::unordered_set)\n\t__DEFINEM__(std::map)\n\t__DEFINEM__(std::unordered_map)\n}\n\n#define pii pair<int,int>\n#define ll long long\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\n// modint \ntemplate <signed M, unsigned T>\nstruct mod_int {\n\tconstexpr static signed MODULO = M;\n\tconstexpr static unsigned TABLE_SIZE = T;\n\n\tsigned x;\n\n\tmod_int() : x(0) {}\n\n\tmod_int(long long y) : x(static_cast<signed>(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO)) {}\n\n\tmod_int(int y) : x(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO) {}\n\n\tmod_int &operator+=(const mod_int &rhs) {\n\t\tif ((x += rhs.x) >= MODULO) x -= MODULO;\n\t\treturn *this;\n\t}\n\n\tmod_int &operator-=(const mod_int &rhs) {\n\t\tif ((x += MODULO - rhs.x) >= MODULO) x -= MODULO;\n\t\treturn *this;\n\t}\n\n\tmod_int &operator*=(const mod_int &rhs) {\n\t\tx = static_cast<signed>(1LL * x * rhs.x % MODULO);\n\t\treturn *this;\n\t}\n\n\tmod_int &operator/=(const mod_int &rhs) {\n\t\tx = static_cast<signed>((1LL * x * rhs.inv().x) % MODULO);\n\t\treturn *this;\n\t}\n\n\tmod_int operator-() const { return mod_int(-x); }\n\n\tmod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n\n\tmod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n\n\tmod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n\n\tmod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n\n\tbool operator<(const mod_int &rhs) const { return x < rhs.x; }\n\n\tmod_int inv() const {\n\t\tassert(x != 0);\n\t\tif (x <= static_cast<signed>(TABLE_SIZE)) {\n\t\t\tif (_inv[1].x == 0) prepare();\n\t\t\treturn _inv[x];\n\t\t} else {\n\t\t\tsigned a = x, b = MODULO, u = 1, v = 0, t;\n\t\t\twhile (b) {\n\t\t\t\tt = a / b;\n\t\t\t\ta -= t * b;\n\t\t\t\tstd::swap(a, b);\n\t\t\t\tu -= t * v;\n\t\t\t\tstd::swap(u, v);\n\t\t\t}\n\t\t\treturn mod_int(u);\n\t\t}\n\t}\n\n\tmod_int pow(long long t) const {\n\t\tassert(!(x == 0 && t == 0));\n\t\tmod_int e = *this, res = mod_int(1);\n\t\tfor (; t; e *= e, t >>= 1)\n\t\t\tif (t & 1) res *= e;\n\t\treturn res;\n\t}\n\n\tmod_int fact() {\n\t\tif (_fact[0].x == 0) prepare();\n\t\treturn _fact[x];\n\t}\n\n\tmod_int inv_fact() {\n\t\tif (_fact[0].x == 0) prepare();\n\t\treturn _inv_fact[x];\n\t}\n\n\tmod_int choose(mod_int y) {\n\t\tassert(y.x <= x);\n\t\treturn this->fact() * y.inv_fact() * mod_int(x - y.x).inv_fact();\n\t}\n\n\tstatic mod_int _inv[TABLE_SIZE + 1];\n\n\tstatic mod_int _fact[TABLE_SIZE + 1];\n\n\tstatic mod_int _inv_fact[TABLE_SIZE + 1];\n\n\tstatic void prepare() {\n\t\t_inv[1] = 1;\n\t\tfor (int i = 2; i <= (int)TABLE_SIZE; ++i) {\n\t\t\t_inv[i] = 1LL * _inv[MODULO % i].x * (MODULO - MODULO / i) % MODULO;\n\t\t}\n\t\t_fact[0] = 1;\n\t\tfor (unsigned i = 1; i <= TABLE_SIZE; ++i) {\n\t\t\t_fact[i] = _fact[i - 1] * int(i);\n\t\t}\n\t\t_inv_fact[TABLE_SIZE] = _fact[TABLE_SIZE].inv();\n\t\tfor (int i = (int)TABLE_SIZE - 1; i >= 0; --i) {\n\t\t\t_inv_fact[i] = _inv_fact[i + 1] * (i + 1);\n\t\t}\n\t}\n};\n\ntemplate <int M, unsigned F>\nstd::ostream &operator<<(std::ostream &os, const mod_int<M, F> &rhs) {\n\treturn os << rhs.x;\n}\n\ntemplate <int M, unsigned F>\nstd::istream &operator>>(std::istream &is, mod_int<M, F> &rhs) {\n\tlong long s;\n\tis >> s;\n\trhs = mod_int<M, F>(s);\n\treturn is;\n}\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nbool operator==(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n\treturn lhs.x == rhs.x;\n}\n\ntemplate <int M, unsigned F>\nbool operator!=(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n\treturn !(lhs == rhs);\n}\n\nconst int MF = 1000010;\nconst int MOD = 1000000007;\n\nusing mint = mod_int<MOD, MF>;\n\nmint binom(int n, int r) { return (r < 0 || r > n || n < 0) ? 0 : mint(n).choose(r); }\n\nmint fact(int n) { return mint(n).fact(); }\n\nmint inv_fact(int n) { return mint(n).inv_fact(); }\nconst ll mod = 1000000007;\nconst int MAX_N = 10000;  // 400MB\n// const int MAX_N = 1024; // 4MB\n// nCr % mod\n\n#define int long long\n#define double long double \n#define RK 20000000000\n#define LK 30000000000\n\ninline ll gcds(ll a, ll b) { return b ? gcds(b, a % b) : a; }\n\nvoid remk(vector<int> &v){\n\tint doed=1;\n\twhile(1){\n\t\tdoed=1;\n\t\tlp(i,v.size()){\n\t\t\tif(v.size()-i>=3){\n\t\t\t\tif(v[i]==RK&&v[i+1]<10000000000&&v[i+2]==LK){\n\t\t\t\t\tv.erase(v.begin()+i+2);\n\t\t\t\t\tv.erase(v.begin()+i);\n\t\t\t\t\tdoed=2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(doed==1)return;\n\t}\n}\n\nbool solve(vector<int> &v, char c, int target){\n\tlp(i,v.size()){\n\t\tif(v[i]==target){\n\t\t\tif(v[i-1]>=10000000000||v[i+1]>=10000000000)return false;\n\t\t\tif(c=='+'){\n\t\t\t\tv[i-1]=v[i-1]+v[i+1];\n\t\t\t}\n\t\t\tif(c=='-'){\n\t\t\t\tv[i-1]=v[i-1]-v[i+1];\n\t\t\t}\n\t\t\tif(c=='*'){\n\t\t\t\tv[i-1]=v[i-1]*v[i+1];\n\t\t\t}\n\t\t\tif(c=='/'){\n\t\t\t\tif(v[i+1]==0)return false;\n\t\t\t\tv[i-1]=v[i-1]/v[i+1];\n\t\t\t}\n\t\t\tv.erase(v.begin()+i+1);\n\t\t\tv.erase(v.begin()+i);\n\t\t\treturn true;\n\t\t}\n\t}\n\tassert(false);\n\treturn false;\n}\n\nsigned main(){\n\twhile(1){\n\t\tstring s;\n\t\tcin>>s;\n\t\tif(s==\"#\")break;\n\t\tchar mark[10];\n\t\tint marknum[10];\n\t\tint mt=0;\n\t\tint num=-10000000000;\n\t\tint tn=10000000000;\n\t\tvector<int> v;\n\t\tlp(i,s.size()){\n\t\t\tif('0'<=s[i]&&s[i]<='9'){\n\t\t\t\tif(num==-10000000000)num=0;\n\t\t\t\tnum*=10;\n\t\t\t\tnum+=s[i]-'0';\n\t\t\t\tif(i==s.size()-1)v.push_back(num);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(num!=-10000000000)v.push_back(num);\n\t\t\t\tnum=-10000000000;\n\t\t\t\tif(s[i]=='('){\n\t\t\t\t\tv.push_back(RK);\n\t\t\t\t}\n\t\t\t\telse if(s[i]==')'){\n\t\t\t\t\tv.push_back(LK);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmark[mt]=s[i];\n\t\t\t\t\tv.push_back(tn);\n\t\t\t\t\tmarknum[mt]=tn;\n\t\t\t\t\tmt++;\n\t\t\t\t\ttn++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> ju;\n\t\tlp(i,mt){\n\t\t\tju.push_back(i);\n\t\t}\n\t\tremk(v);\n\t\tvector<int> base=v;\n\t\tset<int> m;\n\t\tdo{\n\t\t\tv=base;\n\t\t\tbool res=true;\n\t\t\tlp(i,mt){\n\t\t\t\tint tg=ju[i];\n\t\t\t\t//cout<<v<<\" \"<<tg<<\" \"<<mark[tg]<<\" \"<<marknum[tg]<<endl;\n\t\t\t\tres=solve(v, mark[tg],marknum[tg]);\n\t\t\t\tif(res==false)break;\n\t\t\t\tremk(v);\n\t\t\t}\n\t\t\tif(res==true&&v.size()==1){\n\t\t\t\tm.insert(v[0]);\n\t\t\t}\n\t\t}\n\t\twhile(next_permutation(ju.begin(),ju.end()));\n\t\tcout<<m.size()<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef set <int> S;\n\nint skip(string str,int i){\n  int cnt=str[i++]=='(';\n  while(cnt) cnt+=(str[i]=='(')-(str[i++]==')');\n  return i-1;\n}\n\nvoid calc(char ch,S a,S b, S &res){\n  S::iterator i,j;\n  for(i=a.begin();i!=a.end();i++)\n    for(j=b.begin();j!=b.end();j++){\n      int I=*i,J=*j;\n      if(ch=='+') I+=J;\n      else if(ch=='-') I-=J;\n      else if(ch=='*') I*=J;\n      else if(ch=='/'&&J)I/=J;\n      else continue;\n      res.insert(I);\n    }\n}\n\nint num[1<<8];\nS solve(string str){\n  S res;\n  int len=str.size();\n  if(len==1){res.insert(num[str[0]]);return res;}\n  if(skip(str,0)==len-1)res=solve(str.substr(1,len-2));\n\n  for(int i=0;(i=skip(str,i))<len-1;i+=2)\n    calc(str[i+1],solve(str.substr(0,i+1)),solve(str.substr(i+2,len-i-2)),res);\n\n  return res;\n}\n\nint main(){\n  while(1){\n    string str;\n    cin>>str;\n    if(str==\"#\")break;\n    string siki;\n    char ch='A';\n    for(int i=0;i<str.size();){\n      int b=0;\n      while('0'<=str[i]&&str[i]<='9') b=b*10+str[i++]-'0';\n      if(b)num[ch]=b,siki+=ch++;\n      else siki+=str[i++];\n    }\n    cout <<solve(siki).size()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// infty\n#define ULLINF (ULLONG_MAX)\n#define LLINF  (LLONG_MAX)\n#define IINF   (INT_MAX)\n#define INF    (1<<29)\n\n// math\n#define Sq(x) ((x)*(x))\n\n// container utility\n#define ALL(x) (x).begin(), (x).end()\n#define MP make_pair\n#define PB push_back\n\n// rep\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\n// typedef\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\n\ntypedef long long ll;\n\n// pair util\n#define FST first\n#define SND second\n\n// range validator\n#define CK(n,a,b) (a<=n && n<b)\n\n// conversion\ntemplate<class T> inline string toStr(T a) { ostringstream oss_; oss_ << a; return oss_.str(); }\ninline int toInt(string s) { return atoi(s.c_str()); }\n\n// prime\nbool isPrime(int a) { for(int i=2; i*i <=a; i++) if(a%i == 0) return false; return true; }\n\nint const dx[] = {-1,0,1,0,-1,1,1,-1};\nint const dy[] = {0,-1,0,1,-1,-1,1,1};\n\n//////////////////////////////////////////////////////////////\n\nstring line;\nset<int> memo[200][200];\nset<PII> used;\n\nset<int> eval(int const l, int const r) {\n  \n  /*\n  for(int i=l; i<r; i++) cout << line[i];\n  cout << endl;\n  */\n  set<int>& ret = memo[l][r];\n  if(l == r) return ret;\n  \n  if(used.count(MP(l, r))) return ret;\n  used.insert(MP(l, r));\n  \n  // check is digits [l, r)\n  bool digits = true;\n  for(int i=l; i<r; i++) { digits = digits && isdigit(line[i]); }\n  if(digits) { ret.insert(toInt(line.substr(l, r-l))); return ret; }\n  \n  int par = 0; bool check = true;\n  for(int i=l; i<r-1; i++) {\n    if(line[i] == '(') { par ++; }\n    if(line[i] == ')') { par --; }\n    if(par == 0) { check = false; }\n  }\n  \n  // \"(expr)\"\n  if(check) {\n    if(line[r-1] == ')') {\n      /*\n      for(int i=l; i<r; i++) cout << line[i];\n      cout << endl;\n      */\n      return ret = eval(l+1, r-1);\n    }\n  }\n  \n  par = 0;\n  // parsing loop\n  for(int i=l; i<r; i++) {\n    if(line[i] == '(') { par ++; }\n    if(line[i] == ')') { par --; }\n    if(par != 0) continue;\n    \n    switch(line[i]) {\n    case '+': case '-': case '*': case '/': {\n      set<int> st_a = eval(l, i), st_b = eval(i+1, r);\n      set<int>::iterator iter_a, iter_b;\n      for(iter_a = st_a.begin(); iter_a!=st_a.end(); iter_a++) {\n\tfor(iter_b = st_b.begin(); iter_b!=st_b.end(); iter_b++) {\n\t  if(line[i] == '+') { ret.insert(*iter_a + *iter_b); }\n\t  if(line[i] == '-') { ret.insert(*iter_a - *iter_b); }\n\t  if(line[i] == '*') { ret.insert(*iter_a * *iter_b); }\n\t  if(line[i] == '/') {\n\t    if(*iter_b == 0) continue;\n\t    ret.insert(*iter_a / *iter_b);\n\t  }\n\t}\n      }\n      break;\n    }\n    default:;\n    }\n  } // for parsing loop\n  \n  return ret;\n}\n\nint main() {\n  \n  while(cin >> line) {\n    for(int i=0; i<200; i++)\n      for(int j=0; j<200; j++)\n\tmemo[i][j].clear();\n    \n    used.clear();\n    \n    if(line == \"#\") break;\n    cout << eval(0, line.size()).size() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<set>\n#include<vector>\nusing namespace std;\nchar str[210];\nint cur;\nset<int> expr();\nset<int> dig(){\n\tif(str[cur]=='('){\n\t\tcur++;\n\t\tset<int>R=expr();\n\t\tcur++;\n\t\treturn R;\n\t}\n\tint ret=0;\n\twhile('0'<=str[cur]&&str[cur]<='9'){\n\t\tret*=10;\n\t\tret+=str[cur]-'0';\n\t\tcur++;\n\t}\n\tset<int>r;r.insert(ret);\n\treturn r;\n}\nset<int> expr(){\n\tvector<set<int> > num;\n\tvector<char> op;\n\tnum.push_back(dig());\n\twhile(str[cur]=='+'||str[cur]=='-'||str[cur]=='/'||str[cur]=='*'){\n\t\top.push_back(str[cur]);\n\t\tcur++;\n\t\tnum.push_back(dig());\n\t}\n\tset<int>ret;\n\tint n=op.size();\n\tvector<int>perm(n);for(int i=0;i<n;i++)perm[i]=i;\n\tdo{\n\t\tvector<set<int> > tmp=num;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint L=perm[i];\n\t\t\tint R=perm[i]+1;\n\t\t\tchar opr=op[perm[i]];\n\t\t\twhile(!tmp[L].size()){\n\t\t\t\tL--;\n\t\t\t}\n\t\t\t\n\t\t\tset<int>to;\n\t\t\tfor(set<int>::iterator i1=tmp[L].begin();i1!=tmp[L].end();i1++){\n\t\t\t\tfor(set<int>::iterator i2=tmp[R].begin();i2!=tmp[R].end();i2++){\n\t\t\t\t\tif(opr=='+')to.insert((*i1)+(*i2));\n\t\t\t\t\tif(opr=='-')to.insert((*i1)-(*i2));\n\t\t\t\t\tif(opr=='*')to.insert((*i1)*(*i2));\n\t\t\t\t\tif(opr=='/'&&(*i2))to.insert((*i1)/(*i2));\n\t\t\t\t}\t\n\t\t\t}\n\t\t\ttmp[L]=to;\n\t\t\ttmp[R].clear();\n\t\t}\n\t\tfor(set<int>::iterator it=tmp[0].begin();it!=tmp[0].end();it++)\n\t\t\tret.insert(*it);\n\t}while(next_permutation(perm.begin(),perm.end()));\n\t//printf(\"%d \",ret.size());\n\treturn ret;\n}\nint main(){\n\twhile(1){\n\t\tscanf(\"%s\",str);\n\t\tif(str[0]=='#')break;\n\t\tcur=0;\n\t\tset<int>ret=expr();\n\t//\tfor(set<int>::iterator it=ret.begin();it!=ret.end();it++)\n\t\t//\tprintf(\"%d \",*it);\n\t\tprintf(\"%d\\n\",ret.size());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<int>Tashi(vector<int>f1, vector<int>f2) {\n\tvector<int>f3; for (int i = 0; i < f1.size(); i++) { for (int j = 0; j < f2.size(); j++)f3.push_back(f1[i] + f2[j]); }\n\treturn f3;\n}\nvector<int>Hiki(vector<int>f1, vector<int>f2) {\n\tvector<int>f3; for (int i = 0; i < f1.size(); i++) { for (int j = 0; j < f2.size(); j++)f3.push_back(f1[i] - f2[j]); }\n\treturn f3;\n}\nvector<int>Kake(vector<int>f1, vector<int>f2) {\n\tvector<int>f3; for (int i = 0; i < f1.size(); i++) { for (int j = 0; j < f2.size(); j++)f3.push_back(f1[i] * f2[j]); }\n\treturn f3;\n}\nvector<int>Wari(vector<int>f1, vector<int>f2) {\n\tvector<int>f3;\n\tfor (int i = 0; i < f1.size(); i++) {\n\t\tfor (int j = 0; j < f2.size(); j++) { if (f2[j] != 0)f3.push_back(f1[i] / f2[j]); }\n\t}\n\treturn f3;\n}\nvector<int> solve(string S) {\n\twhile (S.size() >= 2 && S[0] == '(' && S[S.size() - 1] == ')') S = S.substr(1, S.size() - 2);\n\tbool OK = false;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tif (S[i] < '0' || S[i] > '9')OK = true;\n\t}\n\tif (OK == false) { return{ stoi(S) }; }\n\n\tint depth = 0; vector<int>K;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tif (S[i] == '(')depth++; if (S[i] == ')')depth--;\n\t\tif (depth == 0) {\n\t\t\tif (S[i] == '+') {\n\t\t\t\tvector<int>J = Tashi(solve(S.substr(0, i)), solve(S.substr(i + 1, S.size() - i - 1)));\n\t\t\t\tfor (int j = 0; j < J.size(); j++)K.push_back(J[j]);\n\t\t\t}\n\t\t\tif (S[i] == '-') {\n\t\t\t\tvector<int>J = Hiki(solve(S.substr(0, i)), solve(S.substr(i + 1, S.size() - i - 1)));\n\t\t\t\tfor (int j = 0; j < J.size(); j++)K.push_back(J[j]);\n\t\t\t}\n\t\t\tif (S[i] == '*') {\n\t\t\t\tvector<int>J = Kake(solve(S.substr(0, i)), solve(S.substr(i + 1, S.size() - i - 1)));\n\t\t\t\tfor (int j = 0; j < J.size(); j++)K.push_back(J[j]);\n\t\t\t}\n\t\t\tif (S[i] == '/') {\n\t\t\t\tvector<int>J = Wari(solve(S.substr(0, i)), solve(S.substr(i + 1, S.size() - i - 1)));\n\t\t\t\tfor (int j = 0; j < J.size(); j++)K.push_back(J[j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn K;\n}\nint main() {\n\twhile (true) {\n\t\tstring U; cin >> U; if (U == \"#\")break;\n\t\tvector<int>ans = solve(U);\n\t\tsort(ans.begin(), ans.end()); ans.erase(unique(ans.begin(), ans.end()), ans.end());\n\t\tcout << ans.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <string>\nusing namespace std;\n\nbool isnum(char c){\n\treturn '0'<=c && c<='9';\n}\nbool isnum(string &s){\n\tfor(int i=0; i<(int)s.length(); i++){\n\t\tif(!isnum(s[i])) return false;\n\t}\n\treturn true;\n}\nbool isop(string &s){\n\treturn s==\"+\" || s==\"-\" || s==\"*\" || s==\"/\";\n}\n\nvector<string> parse(string &str){\n\tvector<string> ret;\n\tstring num = \"\";\n\tfor(int i=0; i<(int)str.length(); i++){\n\t\tif(isnum(str[i])){\n\t\t\tnum += str[i];\n\t\t\tif(i+1 == (int)str.length() || !isnum(str[i+1])){\n\t\t\t\tret.push_back(num);\n\t\t\t}\n\t\t}else{\n\t\t\tnum = \"\";\n\t\t\tret.push_back(string(1,str[i]));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid erasebrac(vector<string> &vs){\n\twhile(1){\n\t\tbool end = true;\n\t\tfor(int i=0; i<(int)vs.size()-2; i++){\n\t\t\tif(vs[i]==\"(\" && isnum(vs[i+1]) && vs[i+2]==\")\"){\n\t\t\t\tend = false;\n\t\t\t\tvs.erase(vs.begin() +i+2);\n\t\t\t\tvs.erase(vs.begin() +i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(end) break;\n\t}\n}\nint calc(int a, int b, string &op){\n\tif(op == \"+\"){\n\t\treturn a+b;\n\t}else if(op == \"-\"){\n\t\treturn a-b;\n\t}else if(op == \"*\"){\n\t\treturn a*b;\n\t}else if(op == \"/\"){\n\t\tif(a*b>=0) return abs(a)/abs(b);\n\t\telse return -(abs(a)/abs(b));\n\t}\n\treturn -1;\n}\n\nvoid solve(vector<string> vs, set<int> &ans){\n\terasebrac(vs);\n\tint n = vs.size();\n\tif(n==1){\n\t\tans.insert(stoi(vs[0]));\n\t}\n\tfor(int i=1; i<n-1; i++){\n\t\tif(isnum(vs[i-1]) && isop(vs[i]) && isnum(vs[i+1])){\n\t\t\tif(vs[i]==\"/\" && vs[i+1]==\"0\") return;\n\t\t\tvector<string> next = vs;\n\t\t\tnext[i-1] = to_string(calc(stoi(vs[i-1]), stoi(vs[i+1]), vs[i]));\n\t\t\tnext.erase(next.begin()+i, next.begin()+i+2);\n\t\t\tsolve(next, ans);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tstring str;\n\t\tcin >> str;\n\t\tif(str==\"#\") break;\n\t\t\n\t\tvector<string> vs = parse(str);\n\t\tset<int> ans;\n\t\tsolve(vs, ans);\n\t\tcout << ans.size() << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool digit(char c){\n  if( c - '0'< 0 || c-'0' > 9)return false;\n  return true;\n}\n\nint stoi(string s){\n  int res,tmp;\n\n  res = 0;\n  tmp = 1;\n  for(int i=s.size()-1;i>=0;i--){\n    res += (s[i]-'0') * tmp;\n    tmp *= 10;\n  }\n  return res;\n}  \n\nset<int> cal(set<int> a,set<int> b,char o){\n  set<int> res;\n  set<int>::iterator i,j;\n  res.clear();\n  if(a.empty() || b.empty)return res;\n\n  if(o=='+'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tres.insert((*i) + (*j));\n      }\n    }\n  }else if(o=='-'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tres.insert((*i) - (*j));\n      }\n    }\n  }else if(o=='*'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tres.insert((*i) * (*j));\n      }\n    }\n  }else if(o=='/'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tif(!(*j))res.insert((*i) / (*j));\n      }\n    }\n  }\n  return res;\n}\n\nset<int> parse(string s){\n  string tmp;\n  set<int> ans[20],store[20],res;\n  char op[20];\n  int pos,cnt;\n  vector<int> order;\n\n  res.clear();\n  pos = 0;\n  cnt = 0;\n\n  while(pos < (int)s.size()){\n    if(s[pos] == '('){\n      tmp.clear();\n      pos++;\n      while(s[pos] != ')'){\n\ttmp.push_back(s[pos]);\n\tpos++;\n      }\n      ans[cnt].clear();\n      ans[cnt] = parse(tmp);\n      pos++;\n    }else if(digit(s[pos])){\n      tmp.clear();\n      while(digit(s[pos])){\n\ttmp.push_back(s[pos]);\n\tpos++;\n      }\n      ans[cnt].clear();\n      ans[cnt].insert(stoi(tmp));\n    }\n    if(pos==(int)s.size())break;\n\n    op[cnt] = s[pos];\n    cnt++;\n    pos++;\n  }\n\n  order.clear();\n  for(int i=0;i<cnt;i++)order.push_back(i);\n  res.clear();\n\n  do{\n    for(int i=0;i<=cnt;i++)store[i] = ans[i];\n    int use[20],num;\n    set<int> hoge;\n    for(int i=0;i<=cnt;i++)use[i] = i;\n    hoge.clear();\n    \n    for(int i=0;i<cnt;i++){\n      hoge = cal(store[order[i]],store[order[i]+1],op[order[i]]);\n      \n      num = use[order[i]+1];\n      for(int j=0;j<=cnt;j++){\n\tif(use[j] == num)use[j] = use[order[i]];\n      }\n      for(int j=0;j<=cnt;j++){\n\tif(use[j] == use[order[i]])store[j] = hoge;\n      }\n    }\n    \n    set<int>::iterator i;\n    for(i=store[0].begin();i!=store[0].end();i++)res.insert(*i);\n\n  }while(next_permutation(order.begin(),order.end()));\n  \n\n  return res;\n}\n\n\nint main(){\n  string str;\n  set<int> s;\n\n  while(1){\n    cin >> str;\n    if(str == \"#\")break;\n\n    s = parse(str);\n\n    cout << s.size() << endl;    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\nvi f(string s){\n    int n = s.size();\n    vp v;\n    int t = 0;\n    vector<vi> num;\n    rep(i,n){\n        if(isdigit(s[i])){\n            t *= 10;\n            t += s[i]-'0';\n        }else{\n            if(i && isdigit(s[i-1]))num.push_back(vi(1,t));\n            t = 0;\n            if(s[i] == '+' || s[i] == '*' || s[i] == '-' || s[i] == '/')v.push_back(pii(i,v.size()));\n            else if(s[i] == '('){\n                int cnt = 0;\n                loop(j,i+1,n){\n                    if(s[j] == '(')cnt++;\n                    if(s[j] == ')'){\n                        if(cnt)cnt--;\n                        else{\n                            num.push_back(f(s.substr(i+1,j-i-1)));\n                            i = j;\n                            j = n;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(isdigit(s.back()))num.push_back(vi(1,t));\n    vi ret;\n    if(v.size()){\n        do{\n            vector<vi> tnum = num;\n            rep(i,v.size()){\n                int op = v[i].first;\n                int l = v[i].second, r = v[i].second+1;\n                while(l && tnum[l].empty())l--;\n                while(r < tnum.size() && tnum[r].empty())r++;\n                if(l < 0 || r >= tnum.size()){\n                    i = v.size();\n                    tnum.resize(0);\n                    break;\n                }\n                // num[l]とnum[r]をopで結合する\n                vi tmp;\n                for(auto x: tnum[l])for(auto y: tnum[r]){\n                    if(s[op] == '+')tmp.push_back(x+y);\n                    if(s[op] == '-')tmp.push_back(x-y);\n                    if(s[op] == '*')tmp.push_back(x*y);\n                    if(y && s[op] == '/')tmp.push_back(x/y);\n                }\n                tnum[l] = tmp;\n                tnum[r].resize(0);\n            }\n            rep(i,tnum.size())if(tnum[i].size()){\n                rep(j,tnum[i].size())ret.push_back(tnum[i][j]);\n            }\n        }while(next_permutation(all(v)));\n    }else{\n        rep(i,num.size())if(num[i].size()){\n            rep(j,num[i].size())ret.push_back(num[i][j]);\n        }\n    }\n    sort(all(ret));\n    ret.erase(unique(all(ret)),ret.end());\n    return ret;\n}\nsigned main(void) {\n    string s;\n    while(cin >> s, s != \"#\"){\n        vi ans = f(s);\n        cout << ans.size() << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <set>\nusing namespace std;\nstring s;\n\nset<int> number(int left,int right){\n\tset<int>st;\n\tint tmp=0;\n\tfor(int i=left;i<=right;i++){\n\t\ttmp *= 10;\n\t\ttmp += s[i]-'0';\n\t}\n\tst.insert(tmp);\n\treturn st;\n}\n\nset<int> expr(int left,int right){\n\tset<int>st;\n\tvector<int> v;\n\tint depth = 0;\n\t//cout << left << \" \" << right << endl;\n\tfor(int i=left;i<=right;i++){\n\t\tif(s[i]=='('){\n\t\t\tdepth++;\n\t\t}\n\t\tif(s[i]==')'){\n\t\t\tdepth--;\n\t\t}\n\t\tif(depth==0&&s[i]=='+'){\n\t\t\tv.push_back(i);\n\t\t}\n\t\tif(depth==0&&s[i]=='-'){\n\t\t\tv.push_back(i);\n\t\t}\n\t\tif(depth==0&&s[i]=='*'){\n\t\t\tv.push_back(i);\n\t\t}\n\t\tif(depth==0&&s[i]=='/'){\n\t\t\tv.push_back(i);\n\t\t}\n\t}\n\tif(v.size()==0&&s[left]=='('){\n\t\treturn expr(left+1,right-1);\n\t}\n\tif(v.size()==0){\n\t\treturn number(left,right);\n\t}\n\tfor(int i=0;i<v.size();i++){\n\t\tif(s[v[i]]=='+'){\n\t\t\tset<int>tmp,tmp2;\n\t\t\ttmp = expr(left,v[i]-1);\n\t\t\ttmp2 = expr(v[i]+1,right);\n\t\t\tfor(int x:tmp){\n\t\t\t\tfor(int y:tmp2){\n\t\t\t\t\tst.insert(x+y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(s[v[i]]=='-'){\n\t\t\tset<int>tmp,tmp2;\n\t\t\ttmp = expr(left,v[i]-1);\n\t\t\ttmp2 = expr(v[i]+1,right);\n\t\t\tfor(int x:tmp){\n\t\t\t\tfor(int y:tmp2){\n\t\t\t\t\tst.insert(x-y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(s[v[i]]=='*'){\n\t\t\tset<int>tmp,tmp2;\n\t\t\ttmp = expr(left,v[i]-1);\n\t\t\ttmp2 = expr(v[i]+1,right);\n\t\t\tfor(int x:tmp){\n\t\t\t\tfor(int y:tmp2){\n\t\t\t\t\tst.insert(x*y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(s[v[i]]=='/'){\n\t\t\tset<int>tmp,tmp2;\n\t\t\ttmp = expr(left,v[i]-1);\n\t\t\ttmp2 = expr(v[i]+1,right);\n\t\t\tfor(int x:tmp){\n\t\t\t\tfor(int y:tmp2){\n\t\t\t\t\tif(y!=0){\n\t\t\t\t\t\tst.insert(x/y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn st;\n}\n\n\n\n\n\nint main(){\n\twhile(cin >> s &&s!=\"#\"){\n\t\tset<int>st;\n\t\tst = expr(0,s.size()-1);\n\t\tcout << st.size() << endl;\n\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < int(n); ++i)\n#define all(a) (a).begin(),(a).end()\n#define debug(x) cerr<<(#x)<<\": \"<<(x)<<endl;\ntypedef long long ll;\n#define print(v) {cerr<<#v<<\": [\"; for(auto x : v){cerr<<x<<\", \"; } cerr<<\"]\"<<endl;}\n\n\nbool is_op(char c){\n    return c=='+' || c=='-' || c=='*' || c=='/';\n}\n\nint operate(int &e1,int &e2,char &op){\n    if(op == '+') return e1+e2;\n    if(op == '-') return e1-e2;\n    if(op == '*') return e1*e2;\n    if(op == '/') return e1/e2;\n    assert(false);\n}\n\nset<int> calc(vector<set<int>> Es, vector<char> &ops, vector<int> &perm){\n    int n = perm.size();\n    if(n == 0){\n        return Es[0];\n    }\n    vector<bool> done(n);\n    rep(i,n){\n        int p = perm[i];\n        set<int> E;\n        char op = ops[p];\n        for(int e1 : Es[p]){\n            for(int e2 : Es[p+1]){\n                if(op == '/' && e2 == 0) continue;\n                E.insert(operate(e1,e2,op));\n            }\n        }\n        done[p] = true;\n        // debug(p);\n        Es[p] = E;\n        Es[p+1] = E;\n        int l = p-1, r = p+1;\n        while(l>=0 && done[l]){\n            Es[l] = E;\n            l--;\n        }\n        while(r<=n && done[r]){\n            Es[r] = E;\n            r++;\n        }\n        // cerr<<\"----------\"<<endl;\n        // rep(k,n){\n        //     // print(Es[k]);\n        //     cerr<<ops[k]<<endl;\n        // }\n        // print(Es[n]);\n        if(p == n-1){\n            return E;\n        }\n    }\n    assert(false);\n}\n\nset<int> all_check(vector<set<int>> &Es, vector<char> &ops){\n    int n = ops.size();\n    vector<int> perm(n);\n    rep(i,n){\n        perm[i] = i;\n    }\n\n    set<int> res;\n    do{\n        set<int> tmp = calc(Es,ops,perm);\n        for(int t : tmp){\n            res.insert(t);\n        }\n    }while(next_permutation(all(perm)));\n    return res;\n}\n\n\nset<int> eval(string &s, int &i){\n\n    vector<set<int>> Es;\n    vector<char> ops;\n    while(1){\n        // debug(i);\n        if(isdigit(s[i])){\n            set<int> res;\n            int num = 0;\n            while(isdigit(s[i])){\n                num = num*10 + s[i]-'0';\n                i++;\n            }\n            res.insert(num);\n            Es.push_back(res);\n        }else if(s[i] == '('){\n            i++; // (\n            Es.push_back(eval(s,i));\n            i++; // )\n        }else{\n            assert(false);\n            Es.push_back(eval(s,i));\n        }\n\n        if(i == (int)s.size()) break;\n        if(is_op(s[i])){\n            ops.push_back(s[i]);\n            i++;\n        }else{\n            break;\n        }\n    }\n    set<int> res = all_check(Es,ops);\n    // print(Es);\n    // print(ops);\n    // print(res);\n    return res;\n\n}\n\nint main(){\n    string s;\n    while(cin>>s, s!=\"#\"){\n        // debug(s);\n        int index = 0;\n        set<int> st = eval(s, index);\n        cout<<st.size()<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nstring st;\nint getnum( int l) {\n\tint num = 0;\n\twhile (isdigit(st[l])) {\n\t\tnum = num * 10 + st[l] - '0';\n\t\tl++;\n\t}\n\treturn num;\n}\nint calc(const int a,const int b,const char type) {\n\tif (type == '+')return a + b;\n\telse if (type == '-')return a - b;\n\telse if (type == '*')return a*b;\n\telse {\n\t\tif (b)return a / b;\n\t\telse {\n\t\t\tthrow(false);\n\t\t}\n\t}\n}\nset<int> getexpr(const int l,const int r) {\n\tset <int>aset;\n\tint depth = 0;\n\tbool flag = false;\n\tfor (int x = l; x <= r; ++x) {\n\t\tif (st[x] == '(') {\n\t\t\tdepth++;\n\t\t}\n\t\telse if (st[x] == ')') {\n\t\t\tdepth--;\n\t\t}\n\t\telse if (st[x] == '+' || st[x] == '-' || st[x] == '*' || st[x] == '/') {\n\t\t\tif (!depth) {\n\t\t\t\tflag = true;\n\t\t\t\tconst set<int> lset = getexpr(l, x - 1);\n\t\t\t\tconst set<int> rset = getexpr(x + 1, r);\n\t\t\t\tfor (auto a : lset) {\n\t\t\t\t\tfor (auto b : rset) {\n\t\t\t\t\t\tif (st[x] == '/'&&!b)continue;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\taset.emplace(calc(a, b, st[x]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!flag) {\n\t\tif (st[l] == '(')return getexpr(l + 1, r - 1);\n\t\taset.emplace(getnum(l));\n\t}\n\treturn aset;\n}\nint main() {\n\twhile (1) {\n\t\tcin >> st;\n\t\tif (st == \"#\")break;\n\t\tset<int>aset=getexpr(0,st.size()-1);\t\n\t\tcout << aset.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <sstream>\n#include <cstdio>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reps(i,s,n) for(int i=s; i<n; i++)\n#define all(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n\nll calc( string in, int index, bool& invalid ) {\n\tll res = -1, a=0, b=0;\n\tchar c = in[index];\n\tif( c == '+' ) {\n\t\tsscanf( in.c_str(), \"%lld+%lld\", &a, &b );\n\t\tres = a + b;\n\t} else if( c == '-' ) {\n\t\tsscanf( in.c_str(), \"%lld-%lld\", &a, &b );\n\t\tres = a - b;\n\t} else if( c == '*' ) {\n\t\tsscanf( in.c_str(), \"%lld*%lld\", &a, &b );\n\t\tres = a * b;\n\t} else if( c == '/' ) {\n\t\tsscanf( in.c_str(), \"%lld/%lld\", &a, &b );\n\t\tif( b != 0 ) {\n\t\t\tres = a / b;\n\t\t} else {\n\t\t\tinvalid = true;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid solve( string e, vector<int>& v ) {\n\tbool br = false;\n\tint brBeg = 0;\n\trep(i, e.length()) {\n\t\tif( e[i] == '(' ) {\n\t\t\tbr = true;\n\t\t\tbrBeg = i;\n\t\t}\n\t}\n\tif( br ) {\n\t\tint cnt = 0;\n\t\tint brEnd = 0;\n\t\tfor(int i=brBeg+1; i<e.length(); i++) {\n\t\t\tif( e[i]==')' ) {\n\t\t\t\tif( cnt==0 ) {\n\t\t\t\t\tbrEnd = i;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tcnt--;\n\t\t\t\t}\n\t\t\t} else if( e[i]=='('){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tstring ne = e.substr(brBeg+1, brEnd-brBeg-1);\n\t\tvector<int> vi;\n\t\tsolve( ne, vi );\n\t\trep(i, vi.size()) {\n\t\t\tstring out = e;\n\t\t\tstringstream ss;\n\t\t\tss << vi[i];\n\t\t\tstring rep;\n\t\t\tss >> rep;\n\t\t\tout.replace( brBeg, brEnd-brBeg+1, rep.c_str(), rep.length() );\n\t\t\tsolve( out, v );\n\t\t}\n\t} else {\n\t\tint pos[10], cnt=0;\n\t\trep(i, e.length()) {\n\t\t\tif( e[i]=='+' || e[i]=='-' || e[i]=='*' || e[i]=='/' ) {\n\t\t\t\tpos[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\trep(i, cnt) {\n\t\t\tint ps=pos[i]-1, pe=pos[i]+1;\n\t\t\twhile( 0<=ps && '0'<=pos[ps] && pos[ps]<='9' ) ps--;\n//\t\t\tps++;\n\t\t\twhile( pe<e.length() && '0'<=pos[pe] && pos[pe]<='9' ) pe++;\n//\t\t\tpe--;\n\t\t\tbool invalid = false;\n\t\t\tll res = calc( e.substr( ps, pe-ps+1 ), pos[i]-ps, invalid );\n\t\t\tif( invalid ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstringstream ss;\n\t\t\tss << res;\n\t\t\tstring o;\n\t\t\tss >> o;\n\t\t\tstring out = e;\n\t\t\tout.replace( ps, ps-pe+1, o.c_str(), o.length() );\n\t\t\tsolve( out, v );\n\t\t}\n\t\tif( cnt == 0 ) {\n\t\t\tstringstream ss;\n\t\t\tss << e;\n\t\t\tll ans;\n\t\t\tss >> ans;\n\t\t\tv.push_back(ans);\n\t\t}\n\t}\n}\n\nint main() {\n\tstring expr;\n\twhile( cin >> expr, expr[0]!='#' ) {\n\t\tvector<int> vi;\n\t\tsolve(expr, vi);\n\t\tsort( vi.begin(), vi.end() );\n\t\tvi.erase( unique( vi.begin(), vi.end()), vi.end() );\n\t\tcout << vi.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n//#define debug(x) cerr << #x << \" : \" << x << endl\n#define debug(...)\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << \" ! \" << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\nstruct Expr {\n    vector<char> op;\n    vector<string> expr;\n};\n\n\nclass Solver {\n  public:\n    string S;\n    int N;\n    vector<int> apply(vector<int> &A, vector<int> &B, char op) {\n        debug(A); debug(B); debug(op);\n        vector<int> res;\n        for(int a : A) for(int b : B) {\n                if(op == '+') res.push_back(a + b);\n                else if(op == '-') res.push_back(a - b);\n                else if(op == '*') res.push_back(a * b);\n                else if(op == '/' and b != 0) res.push_back(a / b);\n                else assert(0);\n            }\n        sort(all(res));\n        res.erase(unique(all(res)), res.end());\n        return res;\n    }\n    vector<int> calc3(vector<vector<int>> nums, const vector<char> &ops, const vector<int> &perm) {\n        map<int, int> ref;\n        for(int i : perm) {\n            int ii = i;\n            int j = i + 1;\n            while(ref.count(i)) i = ref[i];\n            while(ref.count(j)) j = ref[j];\n            nums[i] = apply(nums[i], nums[j], ops[ii]);\n            ref[j] = i;\n        }\n        assert(ref.size() == nums.size() - 1);\n        return nums[0];\n    }\n    vector<int> calc2(vector<vector<int>> &nums, vector<char> ops) {\n        assert(nums.size() == ops.size() + 1);\n        vector<int> perm; rep(i, ops.size()) perm.push_back(i);\n        vector<int> res;\n        do {\n            debug(perm);\n            auto tmp = calc3(nums, ops, perm);\n            for(int i : tmp) res.push_back(i);\n        } while(next_permutation(all(perm)));\n        sort(all(res));\n        res.erase(unique(all(res)), res.end());\n        return res;\n    }\n    vector<int> calc(int &i) {\n        debug(i); debug(S[i]);\n        int s = i;\n        if(isdigit(S[s])) {\n            while(i < N and isdigit(S[i])) i++;\n            return { stoi(S.substr(s, i - s)) };\n        }\n        assert(S[s] == '(');\n        i++;\n        vector<vector<int>> nums;\n        vector<char> ops;\n        bool started = false;\n        while(S[i] != ')') {\n            if(started) {\n                ops.push_back(S[i++]);\n            }\n            nums.push_back(calc(i));\n            started = true;\n        }\n        i++;\n        debug(nums);\n        debug(ops);\n        auto res = calc2(nums, ops);\n        // cerr << \"@ \" << s << \" \" << res;\n        return res;\n    }\n\n    \n    bool solve() {\n        cin >> S;\n        if(S == \"#\") return 0;\n        S = \"(\" + S + \")\";\n        N = S.size();\n        debug(S);\n        int i = 0;\n        auto res = calc(i);\n        debug(res);\n        cout << res.size() << endl;\n        return 1;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(Solver().solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <sstream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n \nset<int> m1[201][201];\nbool m2[201][201];\n \nint stoi(string s) {\n\tstringstream ss; ss << s;\n\tint ret; ss >> ret;\n\treturn ret;\n}\n \nstring str;\nset<int> dp(int l, int r) {\n\tif (m2[l][r]) return m1[l][r];\n\n\tset<int> ret;\n\tbool f = true;\n\tfor (int i = l; i < r; ++i) {\n\t\tif (!isdigit(str[i])) f = false;\n\t}\n\tif (f) {\n\t\tret.insert( stoi(str.substr(l, r-l)) );\n\t}\n\telse {\n\t\tint depth = 0;\n\t\tfor (int i = l; i < r; ++i) {\n\t\t\tswitch (str[i]) {\n\t\t\t\tcase '(':\n\t\t\t\t\t++depth;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ')':\n\t\t\t\t\t--depth;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '+':\n\t\t\t\tcase '-':\n\t\t\t\tcase '*':\n\t\t\t\tcase '/':\n\t\t\t\tif (depth == 0) {\n\t\t\t\t\tset<int> L = dp(l, i), R = dp(i+1, r);\n\t\t\t\t\tfor (set<int>::iterator j = L.begin(); j != L.end(); ++j) {\n\t\t\t\t\t\tfor (set<int>::iterator k = R.begin(); k != R.end(); ++k) {\n\t\t\t\t\t\t\tswitch (str[i]) {\n\t\t\t\t\t\t\t\tcase '+': ret.insert(*j+*k); break;\n\t\t\t\t\t\t\t\tcase '-': ret.insert(*j-*k); break;\n\t\t\t\t\t\t\t\tcase '*': ret.insert((*j)*(*k)); break;\n\t\t\t\t\t\t\t\tcase '/': if (*k) ret.insert((*j)/(*k)); break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ret.size() && str[l] == '(' && str[r-1] == ')') ret = dp(l+1, r-1);\n\t}\n\treturn m2[l][r] = true, m1[l][r] = ret;\n}\n \nint main() {\n\twhile (cin >> str, str != \"#\") {\n\t\tfill(&m2[0][0], &m2[0][0]+201*201, false);\n\t\tcout << dp(0, str.size()).size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_DEPRECATE\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <iterator>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> Pii;\ntypedef pair<ll, ll> Pll;\n\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)(c).size())\n#define ten(x) ((int)1e##x)\n#define tenll(x) ((ll)1e##x)\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstruct Node {\n\tNode *l, *r;\n\tchar op;\n\tint val;\n};\n\nchar s[500];\n\nint num(char* &p){\n\tint ret = 0;\n\twhile (true) {\n\t\tif ('0' <= *p && *p <= '9') {\n\t\t\tret = ret * 10 + *p - '0';\n\t\t\tp++;\n\t\t} else break;\n\t}\n\treturn ret;\n}\n\nset<int> expr(char* &p){\n\tvector<set<int>> val;\n\tvector<char> op;\n\twhile (*p) {\n\t\tif (*p == ')') break;\n\t\tif (*p == '(') {\n\t\t\tp++;\n\t\t\tval.push_back(expr(p));\n\t\t\tp++;\n\t\t} else {\n\t\t\tint a = num(p);\n\t\t\tset<int> s;\n\t\t\ts.insert(a);\n\t\t\tval.push_back(s);\n\t\t}\n\t\tif (*p && *p != ')') op.push_back(*(p++));\n\t}\n\tset<int> dp[20][20];\n\tFOR(i, sz(val)) dp[i][i + 1] = val[i];\n\tfor (int l = 2; l <= sz(val); l++) {\n\t\tfor (int left = 0; left + l <= sz(val); left++) {\n\t\t\tint right = left + l;\n\t\t\tFOR(o, l - 1){\n\t\t\t\tint a = o + left + 1;\n\t\t\t\tchar uop = op[a - 1];\n\t\t\t\tfor (auto x : dp[left][a]) for (auto y : dp[a][right]) {\n\t\t\t\t\tif (uop == '*') dp[left][right].insert(x*y);\n\t\t\t\t\tif (uop == '/' && y != 0) dp[left][right].insert(x / y);\n\t\t\t\t\tif (uop == '+') dp[left][right].insert(x + y);\n\t\t\t\t\tif (uop == '-') dp[left][right].insert(x - y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][sz(val)];\n}\n\nint solve(){\n\tchar* p = s;\n\tauto a = expr(p);\n\treturn sz(a);\n}\n\nint main(){\n\twhile (cin >> s, strcmp(s,\"#\")!= 0) {\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nstring st;\n\nint getnum( int l) {\n\tint num = 0;\n\twhile (isdigit(st[l])) {\n\t\tnum = num * 10 + st[l] - '0';\n\t\tl++;\n\t}\n\treturn num;\n\n}\nint calc(const int a,const int b,const char type) {\n\tif (type == '+')return a + b;\n\telse if (type == '-')return a - b;\n\telse if (type == '*')return a*b;\n\telse {\n\t\tif (b)return a / b;\n\t\telse {\n\t\t\tthrow(false);\n\t\t}\n\t}\n}\n\nset<int> getexpr(const int l,const int r) {\n\tset <int>aset;\n\tif (l > r)assert(false);\n\tif (st[l] == '('&&st[r] == ')') {\n\t\tint depth = 0;\n\t\tbool kakko = true;\n\t\tfor (int x = l; x <= r; ++x) {\n\t\t\tif (st[x] == '(') {\n\t\t\t\tdepth++;\n\t\t\t}\n\t\t\telse if (st[x] == ')') {\n\t\t\t\tdepth--;\n\t\t\t}\n\t\t\tif (!depth&&x != r)kakko = false;\n\t\t}\n\t\tif (kakko) {\n\n\t\t\treturn getexpr(l + 1, r - 1);\n\t\t}\n\t}\n\tint depth = 0;\n\tbool flag = false;\n\tfor (int x = l; x <= r; ++x) {\n\t\tif (st[x] == '(') {\n\t\t\tdepth++;\n\t\t}\n\t\telse if (st[x] == ')') {\n\t\t\tdepth--;\n\t\t}\n\t\telse if (st[x] == '+' || st[x] == '-' || st[x] == '*' || st[x] == '/') {\n\t\t\tflag = true;\n\t\t\tif (!depth) {\n\t\t\t\tconst set<int> lset = getexpr(l, x - 1);\n\t\t\t\tconst set<int> rset = getexpr(x + 1, r);\n\t\t\t\tfor (auto a : lset) {\n\t\t\t\t\tfor (auto b : rset) {\n\t\t\t\t\t\tif (st[x] == '/'&&!b)continue;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\taset.emplace(calc(a, b, st[x]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!flag) {\n\t\taset.emplace(getnum(l));\n\t}\n\treturn aset;\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> st;\n\t\tif (st == \"#\")break;\n\t\tset<int>aset;\n\t\tbool ok = true;\n\t\ttry {\n\t\t\taset=getexpr(0,st.size()-1);\n\t\t}\n\t\tcatch (...) {\n\t\t\tassert(false);\n\t\t\tok = false;\n\t\t}\n\t\t\n\t\tcout << aset.size() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint digit(string &s,int &p){\n\t//<digit> ::= \"0\" | \"1\" | \"2\" | \"3\" | \"4\"\n\t//          | \"5\" | \"6\" | \"7\" | \"8\" | \"9\"\n\treturn s[p++]-'0';\n}\n\nint num(string &s,int &p){\n\t//<num> ::= <digit> | <num> <digit>\n\tassert(isdigit(s[p]));\n\tint num=digit(s,p);\n\twhile(isdigit(s[p])){\n\t\tnum*=10;\n\t\tnum+=digit(s,p);\n\t}\n\treturn num;\n}\n\nbool isop(char c){\n\treturn c=='+'||c=='-'||c=='*'||c=='/';\n}\n\nint expr(string &s,int &p,vi &perm){\n\t//<expr> ::= <num>\n\t//        | \"(\" <expr> \")\"\n\t//        | <expr> \"+\" <expr>\n\t//        | <expr> \"-\" <expr>\n\t//        | <expr> \"*\" <expr>\n\t//        | <expr> \"/\" <expr>\n\tvi e;\n\tvector<pair<int,char> >ops;\n\n\tbool par=false;\n\tif(s[p]=='('){\n\t\tp++;\n\t\tpar=true;\n\t}else{\n\t\treturn num(s,p);\n\t}\n\te.push_back(expr(s,p,perm));\n\tif(e[e.size()-1]==INT_MAX){\n\t\treturn INT_MAX;\n\t}\n\twhile(isop(s[p])){\n\t\tops.push_back(make_pair(p,s[p]));\n\t\tp++;\n\t\te.push_back(expr(s,p,perm));\n\t\tif(e[e.size()-1]==INT_MAX){\n\t\t\treturn INT_MAX;\n\t\t}\n\t}\n\tif(par){\n\t\tassert(s[p]==')');\n\t\tp++;\n\t}\n\n\tREP(i,perm.size()){\n\t\tint opi=-1;\n\t\tREP(j,ops.size()){\n\t\t\tif(ops[j].first==perm[i]){\n\t\t\t\topi=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(opi==-1){\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch(ops[opi].second){\n\t\tcase '+':\n\t\t\t{\n\t\t\t\tint val=e[opi]+e[opi+1];\n\t\t\t\te.erase(e.begin()+opi);\n\t\t\t\te.erase(e.begin()+opi);\n\t\t\t\te.insert(e.begin()+opi,val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\t{\n\t\t\t\tint val=e[opi]-e[opi+1];\n\t\t\t\te.erase(e.begin()+opi);\n\t\t\t\te.erase(e.begin()+opi);\n\t\t\t\te.insert(e.begin()+opi,val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\t{\n\t\t\t\tint val=e[opi]*e[opi+1];\n\t\t\t\te.erase(e.begin()+opi);\n\t\t\t\te.erase(e.begin()+opi);\n\t\t\t\te.insert(e.begin()+opi,val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\t{\n\t\t\t\tif(e[opi+1]==0){\n\t\t\t\t\treturn INT_MAX;\n\t\t\t\t}\n\t\t\t\tdouble val=(double)e[opi]/e[opi+1];\n\t\t\t\tdouble intpart;\n\t\t\t\tmodf(val,&intpart);\n\t\t\t\te.erase(e.begin()+opi);\n\t\t\t\te.erase(e.begin()+opi);\n\t\t\t\te.insert(e.begin()+opi,(int)intpart);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t}\n\t\tops.erase(ops.begin()+opi);\n\t}\n\n\treturn e[0];\n}\n\nint cntop(string &s){\n\tint ret=0;\n\tREP(i,s.size()){\n\t\tswitch(s[i]){\n\t\tcase '+':\n\t\tcase '-':\n\t\tcase '*':\n\t\tcase '/':\n\t\t\tret++;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tstring s;\n\twhile(cin>>s,s!=\"#\"){\n\t\ts=\"(\"+s;\n\t\ts+=\")\";\n\t\tvi perm(cntop(s));\n\t\tREP(i,s.size()){\n\t\t\tif(isop(s[i])){\n\t\t\t\tperm.push_back(i);\n\t\t\t}\n\t\t}\n\t\tset<int> ans;\n\t\tdo{\n\t\t\tvi permrev(s.size());\n\t\t\tREP(i,perm.size()){\n\t\t\t\tpermrev[perm[i]]=i;\n\t\t\t}\n\t\t\tint p=0;\n\t\t\tint e=expr(s,p,perm);\n\t\t\tif(e!=INT_MAX){\n\t\t\t\tans.insert(e);\n\t\t\t}\n\t\t}while(next_permutation(ALL(perm)));\n\t\tcout<<ans.size()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nmap<string, set<int>> memo;\n\nint toNum(string str){\n\tint num = 0;\n\trep(i,str.size()){\n\t\tnum *= 10;\n\t\tnum += str[i] - '0';\n\t}\n\treturn num;\n}\n\nbool numCheck(string s){\n\tfor(auto i : s){\n\t\tif(not isdigit(i)) return false;\n\t}\n\treturn true;\n}\n\nauto close(string::iterator it){\n\tint c = 0;\n\twhile(true){\n\t\tif(*it == '(') c++;\n\t\telse if(*it == ')') c--;\n\n\t\tif(c == 0) return it;\n\t\tit++;\n\t}\n\tassert(false);\n\treturn it;\n}\n\nset<int> expr(string s){\n\tif(memo.count(s)) return memo[s];\n\tif(numCheck(s)) return memo[s] = {toNum(s)};\n\tif(s.front() == '(' && close(s.begin()) == --s.end()){\n\t\treturn memo[s] = expr(string(++s.begin(), --s.end()));\n\t}\n\n\tset<int> res;\n\tfor(auto it = s.begin(); it != s.end(); it++){\n\t\tif(*it == '(') it = close(it);\n\n\t\tif(not isdigit(*it) && *it != ')'){\n\t\t\t//cout << string(s.begin(), it) << ' ' << string(it + 1, s.end()) << endl;\n\t\t\tset<int> a = expr(string(s.begin(), it));\n\t\t\tset<int> b = expr(string(it + 1, s.end()));\n\n\t\t\tfor(auto i : a){\n\t\t\t\tfor(auto j : b){\n\t\t\t\t\tif(j == 0 && *it == '/') continue;\n\t\t\t\t\tswitch (*it) {\n\t\t\t\t\t\tcase '+':\n\t\t\t\t\t\t\tres.emplace(i + j);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '-':\n\t\t\t\t\t\t\tres.emplace(i - j);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\tres.emplace(i * j);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '/':\n\t\t\t\t\t\t\tres.emplace(i / j);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tstring s;\n\twhile(cin >> s, s[0] != '#'){\n\t\tcout << expr(s).size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v, y, m; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nset<int> f(string& s, int l, int r) {\n\tif (r - l == 1) {\n\t\tset<int> Z;\n\t\tZ.insert(s[l] - '0');\n\t\treturn Z;\n\t}\n\tset<int> Z;\n\tint lev = 0;\n\tbool flag = false;\n\tfor (int i = l; i < r; i++) {\n\t\tchar c = s[i];\n\t\tif (c == '(') lev++;\n\t\tif (c == ')') lev--;\n\t\tif (lev == 0 && (c == '+' || c == '-' || c == '*' || c == '/')) {\n\t\t\tset<int> X = f(s, l, i), Y = f(s, i + 1, r);\n\t\t\tfor (set<int>::iterator ix = X.begin(); ix != X.end(); ix++)\n\t\t\t\tfor (set<int>::iterator iy = Y.begin(); iy != Y.end(); iy++) {\n\t\t\t\t\tint x = *ix, y = *iy;\n\t\t\t\t\tif (c == '+') Z.insert(x + y);\n\t\t\t\t\tif (c == '-') Z.insert(x - y);\n\t\t\t\t\tif (c == '*') Z.insert(x * y);\n\t\t\t\t\tif (c == '/' && y != 0) Z.insert(x / y);\n\t\t\t\t}\n\t\t\tflag = true;\n\t\t}\n\t}\n\treturn flag ? Z : f(s, l + 1, r - 1);\n}\n\nint main() {\n\tfor (;;) {\n\t\tstring s; cin >> s;\n\t\tif (s == \"#\") break;\n\t\tint l = 0, r = s.length();\n\t\tset<int> Z = f(s, l, r);\n\t\tcout << Z.size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nnamespace SyntaxAnalysis{\n\ttypedef string::const_iterator Cursor;\n\n\n//\t\t\tl.erase(remove(l.begin(), l.end(), ' '), l.end());//空白除去\n\t\n\tclass ParseError{};\n\t// <四則演算の式> ::= <乗算除算の式> (+ or -) <乗算除算の式> (+ or -) ...\n\t// <乗算除算の式> ::= <括弧か数> (* or /) <括弧か数> (* or /) ...\n\t// <括弧か数>     ::= '(' <四則演算の式> ')' or <数>\n\t// <数>           ::= (0|1|2|3|4|5|6|7|8|9)+\n\n\tvector<int> expression(Cursor&);\n\tvector<int> factor(Cursor&);\n\tint number(Cursor&);\n \n\n\t// <四則演算の式> ::= <乗算除算の式> (+ or -) <乗算除算の式> (+ or -) ...\n\tvector<int> expression(Cursor &c){\n\t    vector<vector<int>> fs;fs.push_back(factor(c));\n\t    vector<char> ops;\n\t    while(*c == '+' || *c == '-' || *c =='*' || *c =='/'){\n\t        ops.push_back(*c);\n\t        c++;fs.push_back(factor(c));\n\t    }\n\t    int opc=ops.size();\n\n\t    vector<int> per(opc);REP(i,opc)per[i]=i;\n\t    vector<int> res;\n\t    do{\n\t    \tvector<vector<int>> tmp=fs;\n\t    \tvector<bool> used(fs.size(),false);\n\t    \tREP(i,opc){\n\t    \t\tvector<int> rlt;\n\t    \t\tint l=per[i];while(used[l])l--;\n\t    \t\tint r=per[i]+1;while(used[r])r++;\n\t    \t\tREP(j,tmp[l].size())REP(k,tmp[r].size()){\n\t    \t\t\tif(ops[per[i]]=='+') rlt.push_back(tmp[l][j]+tmp[r][k]);\n\t    \t\t\tif(ops[per[i]]=='-') rlt.push_back(tmp[l][j]-tmp[r][k]);\n\t    \t\t\tif(ops[per[i]]=='*') rlt.push_back(tmp[l][j]*tmp[r][k]);\n\t    \t\t\tif(ops[per[i]]=='/' && tmp[r][k]!=0) rlt.push_back(tmp[l][j]/tmp[r][k]);\n\t    \t\t}\n\t    \t\tused[r]=true;\n\t    \t\tsort(ALL(rlt)); rlt.erase(unique(ALL(rlt)),rlt.end());\n\t    \t\ttmp[l]=rlt;\n\t    \t}\n\t    \tREP(i,tmp[0].size())res.push_back(tmp[0][i]);\n\t    }while(next_permutation(ALL(per)));\n\n\t    sort(ALL(res)); res.erase(unique(ALL(res)),res.end());\n\t    return res;\n\t}\n\n\t// <括弧か数>     ::= '(' <四則演算の式> ')' or <数>\n\tvector<int> factor(Cursor &c){\n\t    if(*c == '('){\n\t        c++;\n\t        vector<int> ret = expression(c);\n\t        c++; // ')'\n\t        return ret;\n\t    }else{\n\t        return vector<int>(1,number(c));\n\t    }\n\t}\n\n\t// <数>           ::= (0|1|2|3|4|5|6|7|8|9)+\n\tint number(Cursor &c){\n\t    stringstream ss;\n\t    while(isdigit(*c)){\n\t        ss << *c;\n\t        c++;\n\t    }\n\t    int ret;\n\t    ss >> ret;\n\t    return ret;\n\t}\n}\nusing namespace SyntaxAnalysis;\n\nclass Main{\n\tpublic:\n\n\tvoid run(){\n\t\t// ifstream cin(\"D2\");\n//\t\tofstream cout( \"D2.out\" );\n\t\t\n\t\twhile(true){\n\t\t\tstring str;cin >> str;if(str==\"#\")break;\n\n\t\t\tCursor c=str.begin();\n\n\t\t\tcout << expression(c).size()<<endl;\n\t\t}\n\t}\n\n\n};\nint main(){\n\tcout <<fixed<<setprecision(15);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint to_int(string s){\n  int res;\n  stringstream ss;\n  ss << s;\n  ss >> res;\n  return res;\n}\n\nbool is_op(char c){\n  return\n    c == '+' ||\n    c == '-' ||\n    c == '*' ||\n    c == '/';\n}\n\nset<int> calc_op(char op, set<int> set1, set<int> set2){\n  set<int> res;\n  for(auto itr1 = set1.begin(); itr1 != set1.end();++itr1){\n    for(auto itr2 = set2.begin(); itr2 != set2.end();++itr2){\n      if(op == '+'){\n\tres.insert((*itr1) + (*itr2));\n      }else if(op == '-'){\n\tres.insert((*itr1) - (*itr2));\n      }else if(op == '*'){\n\tres.insert((*itr1) * (*itr2));\n      }else if(op == '/'){\n\tif((*itr2) != 0){\n\t  res.insert((*itr1) / (*itr2));\n\t}\n      }\t\n    }\n  }\n  return res;\n}\n\nset<int> solve(string s){\n  vector< vector<set<int>>> dp;\n  vector< char > op;\n  dp.resize(20);\n  for(int i = 0;i < 20;++i){\n    dp[i].resize(20);       \n  }\n  int len = (int)s.size(),size = 0,p = 0;\n  while(p < len){\n    if(s[p] == '('){\n      int q = p+1;\n      int balance = 1;\n      while(1){\n\tif(s[q] == '('){\n\t  ++balance;\n\t}else if(s[q] == ')'){\n\t  --balance;\n\t  if(balance == 0)break;\n\t}\n\t++q;\n      }\n      string elem = s.substr(p+1,q-p-1);\n      dp[size][size] = solve(elem);\n      ++size;\n      p = q;\n    }else if(is_op(s[p])){\n      op.push_back(s[p]);\n    }else{\n      int q = p+1;\n      while(q < len && '0' <= s[q] && s[q] <= '9')++q;\n      string elem = s.substr(p,q-p);\n      int num = to_int(elem);\n      dp[size][size].clear();\n      dp[size][size].insert(num);\n      ++size;\n      p = q-1;\n    }\n    ++p;\n  }\n  for(int step = 1;step < size;++step){\n    for(int i = 0;i + step < size;++i){\n      int j = i + step;\n      for(int k = i;k < j;++k){\n\tset<int> calc = calc_op(op[k],dp[i][k],dp[k+1][j]);\n\tfor(auto elem : calc)dp[i][j].insert(elem);\n      }\n    }\n  }\n  return dp[0][size-1];\n}\n\nint main(){\n  string s;\n  while(cin >> s,s != \"#\"){\n    set<int> res = solve(s);\n    /*\n    for(auto elem : res){\n      cout << elem << \" \";\n    }\n    cout << endl;\n    */\n    cout << (int)res.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\nusing Int = long long;\nconst char newl = '\\n';\n\n//INSERT ABOVE HERE\nset<string> ans;\n\n// use ~ as anary minus at end\n// 1~ as -1\nstring conv(int val){\n  string res=to_string(abs(val));\n  if(val<0) res+='~';\n  //cout<<val<<':'<<res<<endl;\n  return res;\n}\n\nint calc(int a,int b,char c){\n  if(c=='+') return a+b;\n  if(c=='-') return a-b;\n  if(c=='*') return a*b;\n  if(c=='/') return a/b;\n  abort();\n}\n\nvoid dfs2(vector<int> vs,vector<char> cs,vector<int> &res){\n  if(cs.empty()){\n    res.emplace_back(vs[0]);\n    return;\n  }\n  for(int i=0;i<(int)cs.size();i++){\n    auto nv=vs;\n    auto nc=cs;\n    if(vs[i+1]==0 and cs[i]=='/') continue;\n    int tmp=calc(vs[i],vs[i+1],cs[i]);\n    nv.erase(nv.begin()+i);\n    nc.erase(nc.begin()+i);\n    nv[i]=tmp;\n    dfs2(nv,nc,res);\n  }\n}\n\nvector<string> solve2(vector<int> vs,vector<char> cs){\n  vector<int> res;\n  dfs2(vs,cs,res);\n  vector<string> tmp;\n  for(int val:res) tmp.emplace_back(conv(val));\n  return tmp;\n}\n\nvoid dfs(string s){\n  // cout<<s<<endl;\n\n  if(s[0]!='('){\n    ans.emplace(s);\n    return;\n  }\n\n  int op=0,ma=0;\n  for(char c:s){\n    if(c=='(') op++;\n    if(c==')') op--;\n    chmax(ma,op);\n  }\n\n  int n=s.size();\n  int l=0,r=0;\n  for(int i=0;i<n;i++){\n    if(op==ma and s[i]==')') r=i;\n\n    if(s[i]=='(') op++;\n    if(s[i]==')') op--;\n\n    if(op==ma and s[i]=='(') l=i;\n  }\n\n  vector<int> vs;\n  vector<char> cs;\n  vs.emplace_back(0);\n  for(int i=l+1;i<r;i++){\n    if(s[i]=='~') vs.back()*=-1;\n    else if(s[i]=='+' or s[i]=='-' or s[i]=='*' or s[i]=='/')\n      cs.emplace_back(s[i]),vs.emplace_back(0);\n    else\n      vs.back()=vs.back()*10+(s[i]-'0');\n  }\n\n  auto res=solve2(vs,cs);\n  for(string t:res)\n    dfs(s.substr(0,l)+t+s.substr(r+1));\n}\n\nint solve(string s){\n  ans.clear();\n  dfs(s);\n  cout<<ans.size()<<newl;\n  return 0;\n}\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  string s;\n  while(cin>>s,s!=\"#\") solve(\"(\"+s+\")\");\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n// Shrotening\n#define fst first\n#define snd second\n#define pb push_back\n\n// Loop\n#define FOR(i,a,b) for(auto i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(auto i=(a);i>=(b);--i)\n\n#define REP(i,a) for(long i=0;i<(a);++i)\n#define RREP(i,a) for(long i=(a);i>=0;--i)\n\n#define EACH(i,a) for(auto (i)=(a).begin(),_END=(a).end();i!=_END;++i)\n#define REACH(i,a) for(auto (i)=(a).rbegin(),_END=(a).rend();i!=_END;++i)\n\n//Algorithm\n#define ALL(a) (a).begin(), a.end()\n#define RALL(a) (a).rbegin(), a.rend()\n#define EXIST(a,x) ((a).find(x)!=(a).end())\n#define SORT(a) std::sort((a).begin(), (a).end())\n#define UNIQUE(a) std::sort((a).begin(), a.end()), a.erase(std::unique((a).begin(), a.end()), a.end());\n#define SUM(a) std::accumulate((a).begin(), (a).end(), 0);\n\n//Setting\n#define OPT std::cin.tie(0);std::ios::sync_with_stdio(false);\n\n//debug message\nbool debug = true;\n#define MSG(s)   if(debug){std::cout << s << std::endl;}\n#define DEBUG(x) if(debug){std::cout << \"debug(\" << #x << \"): \" << x << std::endl;}\n\n//alias\ntypedef long long LL;\ntypedef std::vector<char> VC;\ntypedef std::vector<int>  VI;\ntypedef std::vector<long> VL;\ntypedef std::vector<long long> VLL;\n\ntypedef std::vector< VC > VC2;\ntypedef std::vector< VI > VI2;\ntypedef std::vector< VL > VL2;\ntypedef std::vector< VLL > VLL2;\n\ntypedef std::pair<int,int> PII;\n\n\nstd::string str;\nint len;\n\nint inline calc(char op, int l, int r) {\n    return   op == '+' ? l + r\n           : op == '-' ? l - r\n           : op == '*' ? l * r\n           :             l / r;\n}\n\nbool inline isOperator(char c) {\n    return (c == '+' || c == '-' || c == '*' || c == '/');\n}\n\nbool isOperatorContain(int l, int r) {\n    int d = 0;\n    for(int i=l; i<=r; ++i) {\n        if(str[i] == '(') {\n            ++d;\n        }\n        if(str[i] == ')') {\n            --d;\n        }\n        if(d > 0) {\n            continue;\n        }\n\n        if(isOperator(str[i])) {\n            return true;\n        }\n    }\n    return false;\n}\n\nstd::map< std::pair<int,int>, std::set<int> > memo;\n\nstd::set<int> eval(int l, int r) {\n    std::pair<int,int> p = std::make_pair(l, r);\n    if(memo.count(p) > 0) {\n        return memo[p];\n    }\n\n    std::set<int> ans;\n    if(str[l] == '(' && str[r] == ')') {\n        ans = eval(l+1, r-1);\n    } else if(isOperatorContain(l, r)) {\n        int i = l, d = 0; //depth\n        while(i <= r) {\n            if(str[i] == '(') {\n                ++d;\n            }\n            if(str[i] == ')') {\n                --d;\n            }\n            if(d > 0) {\n                ++i;\n                continue;\n            }\n\n            if(isOperator(str[i])) {\n                char op = str[i];\n                auto left  = eval(l, i-1);\n                auto right = eval(i+1, r);\n                for(auto x: left) {\n                    for(auto y: right) {\n                        ans.insert(calc(op, x, y));\n                    }\n                }\n            }\n            ++i;\n        }\n    } else {\n        int v = 0;\n        int i = l;\n        while(i <= r && str[i] != ')') {\n            v *= 10;\n            v += (str[i] - '0');\n            ++i;\n        }\n        ans.insert(v);\n    }\n    memo.insert(std::make_pair(p, ans));\n    return ans;\n}\n\nint main() {\n    while(std::cin >> str, str != \"#\") {\n        memo.clear();\n        len = str.length();\n        auto pat = eval(0, len - 1);\n        std::cout << pat.size() << std::endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nstring s;\nint N;\nint pos[15], id[105], lv[15], lvnum[105];\nint perm[15];\n\nint parseNumber(int &p)\n{\n  int ret = 0;\n  while(s[p] >= '0' && s[p] <= '9'){\n    ret *= 10, ret += s[p]-'0';\n    p++;\n  }\n  return ret;\n}\n\nbool error;\nint parse(int &p, int depth)\n{\n  //cout << p << \" \" << depth << endl;\n  if(depth == -1){\n    if(s[p] == '('){\n      p++;\n      int ret = parse(p, N-1);\n      p++;\n      return ret;\n    }\n    if(s[p] >= '0' && s[p] <= '9'){\n      return parseNumber(p);\n    }\n  }\n  int ret = parse(p, depth-1);\n  if(perm[id[p]] == depth){\n    if(s[p] == '+'){\n      p++;\n      ret += parse(p, depth-1);\n    }\n    else if(s[p] == '-'){\n      p++;\n      ret -= parse(p, depth-1);\n    }\n    else if(s[p] == '*'){\n      p++;\n      ret *= parse(p, depth-1);\n    }\n    else if(s[p] == '/'){\n      p++;\n      int res = parse(p, depth-1);\n      if(res == 0){\n        error = true;\n        return -1;\n      }\n      ret /= res;\n    }\n  }\n  return ret;\n}\n\nint main(void)\n{\n  while(1){\n    cin >> s;\n    if(s == \"#\") break;\n    s += \"=\";\n    int nest = 1, cnt = 0;\n    for(int i = 0; i < s.size(); i++){\n      if(s[i] == '(') nest++;\n      if(s[i] == ')') nest--;\n      if(s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/'){\n        pos[cnt] = i;\n        id[i] = cnt;\n        lv[cnt] = nest;\n        cnt++;\n      }\n    }\n    N = cnt;\n    for(int i = 0; i < 105; i++) lvnum[i] = 0;\n    for(int i = 0; i < N; i++) lvnum[lv[i]]++;\n    for(int i = 1; i < 105; i++) lvnum[i] += lvnum[i-1];\n\n    //for(int i = 0; i < 5; i++) cout << lvnum[i] << \" \"; cout<< endl;\n    //for(int i = 0; i < cnt; i++) cout << lv[i] << \" \"; cout << endl;\n\n    set<int> S;\n    for(int i = 0; i < N; i++) perm[i] = i;\n    do{\n      bool flag = true;\n      for(int i = 0; i < N; i++){\n        if(perm[i] < lvnum[lv[i]-1] || perm[i] >= lvnum[lv[i]]) flag = false;\n      }\n      if(!flag) continue;\n\n      error = false;\n      int p = 0;\n      int res = parse(p, N-1);\n      if(!error) S.insert(res);\n    }while(next_permutation(perm, perm+cnt));\n\n    cout << (int)S.size() << endl;\n    //for(auto it = S.begin(); it != S.end(); it++) cout << *it << \" \"; cout << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v, y, m; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nset<int> f(string& s, int l, int r) {\n\tif (r - l == 1) {\n\t\tset<int> Z;\n\t\tZ.insert(s[l] - '0');\n\t\treturn Z;\n\t}\n\tif (s[l] == '(' && s[r - 1] == ')')\n\t\treturn f(s, l + 1, r - 1);\n\tset<int> Z;\n\tint lev = 0;\n\tfor (int i = l; i < r; i++) {\n\t\tchar c = s[i];\n\t\tif (c == '(') lev++;\n\t\tif (c == ')') lev--;\n\t\tif (lev == 0 && (c == '+' || c == '-' || c == '*' || c == '/')) {\n\t\t\tset<int> X = f(s, l, i), Y = f(s, i + 1, r);\n\t\t\tfor (set<int>::iterator ix = X.begin(); ix != X.end(); ix++)\n\t\t\t\tfor (set<int>::iterator iy = Y.begin(); iy != Y.end(); iy++) {\n\t\t\t\t\tint x = *ix, y = *iy;\n\t\t\t\t\tif (c == '+') Z.insert(x + y);\n\t\t\t\t\tif (c == '-') Z.insert(x - y);\n\t\t\t\t\tif (c == '*') Z.insert(x * y);\n\t\t\t\t\tif (c == '/' && y != 0) Z.insert(x / y);\n\t\t\t\t}\n\t\t}\n\t}\n\treturn Z;\n}\n\nint main() {\n\tfor (;;) {\n\t\tstring s; cin >> s;\n\t\tif (s == \"#\") break;\n\t\tint l = 0, r = s.length();\n\t\tset<int> Z = f(s, l, r);\n\t\tcout << Z.size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cctype>\n#include <set>\n#include <iostream>\nusing namespace std;\ntypedef string::const_iterator State;\n\nset<int> number(State &begin);\nset<int> factor(State &begin);\nset<int> expression(State &begin);\n\nset<int> number(State &begin){\n\tint ret=0;\n\twhile(isdigit(*begin)){\n\t\tret*=10;\n\t\tret+=*begin-'0';\n\t\tbegin++;\n\t}\n\tset<int> s;\n\ts.insert(ret);\n\treturn s;\n}\n\nset<int> factor(State &begin){\n\tif(*begin=='('){\n\t\tbegin++;\n\t\tset<int> ret=expression(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint perm[10]={0,1,2,3,4,5,6,7,8,9};\nset<int> dp[11][11];\n\nset<int> expression(State &begin){\n\tset<int> ret;\n\tvector<string> ex;\n\tvector<set<int> >  s;\n\ts.push_back(factor(begin));\n\twhile(1){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tex.push_back(\"+\");\n\t\t\ts.push_back(factor(begin));\n\t\t}else if(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tex.push_back(\"-\");\n\t\t\ts.push_back(factor(begin));\n\t\t}else if(*begin=='*'){\n\t\t\tbegin++;\n\t\t\tex.push_back(\"*\");\n\t\t\ts.push_back(factor(begin));\n\t\t}else if(*begin=='/'){\n\t\t\tbegin++;\n\t\t\tex.push_back(\"/\");\n\t\t\ts.push_back(factor(begin));\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\tint n=s.size();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tdp[i][j].clear();\n\t\t}\n\t\tdp[i][i]=s[i];\n\t}\n\tfor(int l=1;l<n;l++){\n\t\tfor(int i=0;i<=n-l;i++){\n\t\t\tfor(int j=i;j<i+l;j++){\n\t\t\t\tfor(set<int>::iterator a=dp[i][j].begin();a!=dp[i][j].end();a++){\n\t\t\t\t\tfor(set<int>::iterator b=dp[j+1][i+l].begin();b!=dp[j+1][i+l].end();b++){\n\t\t\t\t\t\tif(ex[j]==\"+\"){\n\t\t\t\t\t\t\tdp[i][i+l].insert(*a+*b);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ex[j]==\"-\"){\n\t\t\t\t\t\t\tdp[i][i+l].insert(*a-*b);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ex[j]==\"*\"){\n\t\t\t\t\t\t\tdp[i][i+l].insert((*a)*(*b));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ex[j]==\"/\"){\n\t\t\t\t\t\t\tif(*b==0)continue;\n\t\t\t\t\t\t\tdp[i][i+l].insert((*a)/(*b));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][n-1];\n }\n\nint main(void){\n\tstring str;\n\twhile(1){\n\t\tcin >> str;\n\t\tif(str==\"#\")break;\n\t\tState begin=str.begin();\n\t\tprintf(\"%d\\n\",expression(begin).size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <set>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nset<int> se[200][201];\nstring s;\n\nset<int> rec(int l, int r) {\n  if (se[l][r].size()) return se[l][r];\n  if (s[l]=='('&& s[r-1]==')') return rec(l+1,r-1);\n  \n  int nest = 0;\n\n  set<int> res;\n  bool flag = 0;\n  for (int i=l; i<r; ++i) {\n    if (s[i]=='(') nest++;\n    else if (s[i]==')') nest--;\n    if (nest == 0 && (s[i]=='/'||s[i]=='+'||s[i]=='*'||s[i]=='-')) {\n      flag = 1;\n      set<int> leftset = rec(l, i);\n      set<int> rightset = rec(i+1, r);\n      FOR(it, leftset) {\n        FOR(jt, rightset) {\n          if (s[i]=='/')\n            res.insert(*it / *jt);\n          else if (s[i]=='+')\n            res.insert(*it + *jt);\n          else if (s[i]=='-')\n            res.insert(*it - *jt);\n          else if (s[i]=='*')\n            res.insert(*it * *jt);\n        }\n      }\n    }\n  }\n  if (!flag) {                    // ツ可可算ツ子ツ鳴ウツつオ\n    res.insert(atoi(s.substr(l,r-l).c_str()));\n  }\n  // cout << s.substr(l,r-l) << endl;\n  // cout << \"res : \";\n  // FOR(it, res)\n  //   cout << *it << \" \";\n  // cout << endl;\n  return se[l][r] = res;\n}\n\nint main() {\n  while(cin>>s, s!=\"#\"){\n    int n = s.size();\n    REP(i,n) REP(j,n+1)\n      se[i][j].clear();\n    cout << rec(0,s.size()).size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <numeric>\n#include <set>\n#include <map>\n#include <sstream>\n\n#define rep(i, j) for(int i = 0; i < j; i++)\n#define all(i) i.begin(), i.end()\n\nusing namespace std;\n\nint toint(string s) {\n\tstringstream ss(s);\n\tint ret;\n\tss >> ret;\n\treturn ret;\n}\n\nstring s;\nint c;\n\nstring num() {\n\tstring r;\n\tif (s[c] >= '0' && s[c] <= '9') {\n\t\tr += s[c];\n\t\tc++;\n\t\tr += num();\n\t\treturn r;\n\t}\n\telse {\n\t\treturn \"\";\n\t}\n}\n\nset<int> solve(vector<set<int>> &v, vector<char> &o) {\n\tint n = v.size();\n\tvector<bool> f(n, false);\n\n\tvector<int> t(n - 1);\n\trep(i, n - 1) {\n\t\tt[i] = i;\n\t}\n\n\tset<int> re;\n\tdo {\n\t\tauto tv = v;\n\t\tauto to = o;\n\t\tauto tt = t;\n\n\t\trep(i, n - 1) {\n\t\t\tset<int> se;\n\t\t\tfor (auto j : tv[tt[i]]) {\n\t\t\t\tfor (auto k : tv[tt[i]+1]) {\n\t\t\t\t\tif (to[tt[i]] == '+') {\n\t\t\t\t\t\tse.insert(j + k);\n\t\t\t\t\t}\n\t\t\t\t\tif (to[tt[i]] == '-') {\n\t\t\t\t\t\tse.insert(j - k);\n\t\t\t\t\t}\n\t\t\t\t\tif (to[tt[i]] == '*') {\n\t\t\t\t\t\tse.insert(j * k);\n\t\t\t\t\t}\n\t\t\t\t\tif (to[tt[i]] == '/') {\n\t\t\t\t\t\tif (k != 0) {\n\t\t\t\t\t\t\tse.insert(j / k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tto.erase(to.begin() + tt[i]);\n\t\t\ttv.erase(tv.begin() + tt[i] + 1);\n\t\t\ttv.erase(tv.begin() + tt[i]);\n\t\t\ttv.insert(tv.begin() + tt[i], se);\n\t\t\tfor (int j = 0; j < tt.size(); j++) {\n\t\t\t\tif (tt[i] < tt[j]) {\n\t\t\t\t\ttt[j]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (auto i : tv[0]) {\n\t\t\tre.insert(i);\n\t\t}\n\n\t} while (next_permutation(t.begin(), t.end()));\n\n\treturn re;\n}\n\n//exprテ」ツ?ョテァツオツづ、ツコツ?・ツ慊ーテァツつケテ」ツ?ィテァツオツ?」ツ?ソテ・ツ青暗」ツつ湘」ツ?崚」ツ?ョテヲツ閉ー\nset<int> fc() {\n\tif (s[c] == '(') {\n\t\tc += 1;\n\t\tvector<set<int>> v;\n\t\tv.push_back(fc());\n\t\tvector<char> o;\n\n\t\twhile (s[c] != ')') {\n\t\t\to.push_back(s[c]);\n\t\t\tif (s[c] == '+') {\n\t\t\t\tc++;\n\t\t\t\tv.push_back(fc());\n\t\t\t}\n\t\t\tif (s[c] == '-') {\n\t\t\t\tc++;\n\t\t\t\tv.push_back(fc());\n\t\t\t}\n\t\t\tif (s[c] == '*') {\n\t\t\t\tc++;\n\t\t\t\tv.push_back(fc());\n\t\t\t}\n\t\t\tif (s[c] == '/') {\n\t\t\t\tc++;\n\t\t\t\tv.push_back(fc());\n\t\t\t}\n\t\t}\n\t\tc += 1;\n\t\treturn solve(v, o);\n\t}\n\tif (s[c] >= '0' && s[c] <= '9') {\n\t\tint t = toint(num());\n\t\tset<int> re;\n\t\tre.insert(t);\n\t\treturn re;\n\t}\n}\n\nint main(){\n\twhile (cin >> s && s != \"#\") {\n\t\tc = 0;\n\t\ts = \"(\" + s + \")\";\n\t\tcout << fc().size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\nusing namespace std;\n#define rep(i,a,b) for(auto (i)=(a);(i)<(b);(i)++)\n#define rev(i,a,b) for(auto (i)=(b)-1;(i)>=(a);(i)--)\n#define num_check(x) '0'<=(x)&&(x)<='9'\n\n\nstruct Siki{\n\tint num;\n\tint depth;\n\tchar type;\n\tint left, right;\n\n};\n\nint pri[10];//各演算子の計算順序\nint min_pri[6];//各演算子のdepthごとの計算順序の最低値、これを破るとNG\nSiki siki[12];\nSiki temp[12];//作業用配列\nint s_size;\nstring input;\nmap<int, int> data;\n\nbool check_pri(){\n\trep(i, 0, s_size){\n\t\tif (min_pri[siki[pri[i]].depth] > i)\n\t\t\treturn(false);\n\t}\n\treturn(true);\n}\n\nvoid init(){\n\t//初期化\n\tdata.clear();\n\trep(i, 0, 12)siki[i].num = 0;\n\trep(i, 0, 6)min_pri[i] = 0;\n\tint d = 0; \n\ts_size = 0;\n\t\n\t//入力を作業用に変換\n\trep(i, 0u, input.length()){\n\t\tif (num_check(input[i])){\n\t\t\tsiki[s_size].num *= 10;\n\t\t\tsiki[s_size].num += input[i] - '0';\n\t\t}\n\t\telse if (input[i] == '(')d++;//()の中に入るので深さを増加\n\t\telse if (input[i] == ')')d--;//深さを減少\n\t\telse\n\t\t{\n\t\t\tsiki[s_size].type = input[i];\n\t\t\tsiki[s_size].depth = d;\n\t\t\tpri[s_size] = s_size;\n\t\t\trep(j, d + 1, 6)\n\t\t\t\tmin_pri[j]++;\n\t\t\ts_size++;\n\t\t}\n\t}\n\tsiki[s_size].type = '\\0';//終端記号\n\trep(i, 0, s_size){\n\t\t//連結リスト構造の作成\n\t\tsiki[i].right = i+1;\n\t\tsiki[i + 1].left = i;\n\t}\n\tsiki[0].left = siki[s_size].right = -1;//左端、右端の保護\n\t\n}\n\n//2項計算する関数\nint calc(int l, char op, int r){\n\tswitch (op){\n\tcase '+':return(l + r);\n\tcase '-':return(l - r);\n\tcase '*':return(l * r);\n\tcase '/':return(l / r);\n\t}\n\treturn(0);\n}\n\n\nvoid parse(){\n\tSiki *p,*r,*l;\n\trep(i, 0, s_size+1)temp[i] = siki[i];//作業用配列にコピー\n\trev(i, 0, s_size){\n\t\tp = &temp[pri[i]];\n\t\tl = &temp[p->left];\n\t\tr = &temp[p->right];\n\n\t\tif (r->num == 0 && p->type == '/')return;//0除算を省く\n\t\t//printf(\"%d%c%d=\", p->num, p->type, r->num);\n\t\tr->num = calc(p->num, p->type, r->num);\n\t\t//printf(\"%d\\n\", r->num);\n\t\tr->left = p->left;\n\t\tif (l->left >=0 )l->right = p->right;\n\n\t}\n\t//cout << temp[s_size].num << endl;\n\tdata[temp[s_size].num]++;\n}\n\n//順列を効率的に列挙するための関数\nvoid p(int d, int dm){\n\tif (d == dm){\n\t\tif (check_pri()){\n\t\t\tparse();\n\t\t}\n\t}\n\trep(i, d, dm){\n\t\tswap(pri[d], pri[i]);\n\t\tp(d + 1, dm);\n\t\tswap(pri[d], pri[i]);\n\t}\n}\n\nint main(void){\n\twhile (true){\n\t\tcin >> input;\n\t\tif (input[0] == '#')break;\n\t\tinit();\n\t\t/*\t\n\t\trep(i, 0, siki_size)if (siki[i].type == 'c')printf(\"%d\", siki[i].num); else printf(\"%c\", siki[i].type); cout << endl;\n\t\trep(i, 0, op_size)printf(\"%c\", siki[index[i]].type); cout << endl;\n\t\trep(i, 0, op_size)printf(\"%d\", min_pri[siki[index[i]].num]); cout << endl;\n\t\t*/\n\t\tp(0, s_size);\n\t\tcout << data.size() << endl;\n\t}\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <tuple>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nint Div(int a, int b){\n\tint sign=1;\n\tif(a<0){\n\t\ta=-a;\n\t\tsign=-1;\n\t}\n\tif(b<0){\n\t\tb=-b;\n\t\tsign=-sign;\n\t}\n\treturn sign*(a/b);\n}\nvoid f(string str, vector<int>& vals)\n{\n\tif(str[0]=='('&&str[str.size()-1]==')')\n\t{\n\t\tf(str.substr(1,str.size()-2),vals);\n\t\treturn;\n\t}\n\tint level=0;\n\tint dsize=0;\n\tfor(int i=0;i<str.size();i++){\n\t\tswitch(str[i]){\n\t\t\tcase '(':\n\t\t\t\tlevel++;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tlevel--;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\tcase '-':\n\t\t\tcase '*':\n\t\t\tcase '/':\n\t\t\t\tif(level==0){\n\t\t\t\t\tvector<int> v1;\n\t\t\t\t\tvector<int> v2;\n\t\t\t\t\tf(str.substr(0,i),v1);\n\t\t\t\t\tf(str.substr(i+1,str.size()-(i+1)),v2);\n\t\t\t\t\tfor(auto a:v1){\n\t\t\t\t\t\tfor(auto b:v2){\n\t\t\t\t\t\t\tswitch(str[i]){\n\t\t\t\t\t\t\t\tcase '+':vals.push_back(a+b);break;\n\t\t\t\t\t\t\t\tcase '*':vals.push_back(a*b);break;\n\t\t\t\t\t\t\t\tcase '-':vals.push_back(a-b);break;\n\t\t\t\t\t\t\t\tcase '/':\n\t\t\t\t\t\t\t\t\tif(b!=0){\n\t\t\t\t\t\t\t\t\t\tvals.push_back(Div(a,b));break;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdsize++;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif(vals.size()){\n\t\tsort(vals.begin(),vals.end());\n\t\tauto it=unique(vals.begin(),vals.end());\n\t\tvals.resize(it-vals.begin());\n\t}\n\telse if (dsize==str.size()){\n\t\tistringstream istr(str);\n\t\tint v;\n\t\tistr >> v;\n\t\tvals.push_back(v);\n\t}\n}\nint main() {\n\tstring str;\n\twhile(cin >> str){\n\t\tif(str==\"#\"){\n\t\t\treturn 0;\n\t\t}\n\t\tvector<int> v;\n\t\tf(str,v);\n\t\tcout << v.size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<cstring>\n#define foreach(t,p) for(t::iterator it=p.begin();it!=p.end();++it)\n#define FOREACH(t,p,tit) for(t::iterator tit=p.begin();tit!=p.end();++tit)\n#define REP(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef set<int> pp;\nstring ss;\n\npp solve(int f,int l)\n{\n\n\tpp ans;\n\t//ans.clear();\n\tbool ope=false;\n/*\tfor(int i=f;i<l;i++)\n\t{\n\t\tif(\n\t\t\t\tss[i]=='+'||\n\t\t\t\tss[i]=='-'||\n\t\t\t\tss[i]=='*'||\n\t\t\t\tss[i]=='/')ope = true;\n\t}*/\n\n\t//int ofs = 0;\n\tint bo =0;\n\tfor(int i=f;i<l;i++)\n\t{\n\t\n\t\tif(ss[i]=='(') bo++;\n\t\tif(ss[i]==')') bo--;\n\n\t\tif((ss[i]=='+'||ss[i]=='-'||ss[i]=='*'||ss[i]=='/')&&(bo==0))\n\t\t{\n\t\t\tope = true;\n\t\t\n\t\t\tpp ansl = solve(f,i-1);\n\t\t\tpp ansr = solve(i+1,l);\n\t\t\tFOREACH(pp,ansl,iit)FOREACH(pp,ansr,jit)\n\t\t\t{\n\t\t\t\tif(ss[i]=='+') ans.insert((*iit)+(*jit));\n\t\t\t\tif(ss[i]=='-') ans.insert((*iit)-(*jit));\n\t\t\t\tif(ss[i]=='*') ans.insert((*iit)*(*jit));\n\t\t\t\tif(ss[i]=='/')if((*jit)!=0)\tans.insert((*iit)/(*jit));\n\t\t\t}\n\t\t}\n\t}\n\tif(!ope)\n\t{\n\t\tif(ss[f]=='('&& ss[l]==')'  ){return solve(f+1,l-1);}\n\t\telse\n\t\t{\n\t\t\tstring s = ss.substr(f,(l-f+1));\n\t\t\t//cout << s << endl;\n\t\t\tint t = atoi(s.c_str() );\n\t\t\tans.insert(t);\n\t\t\t//foreach(pp,ans)cout << *it << endl;\n\t\t\t//cout << atoi( (ss.substr(f,l+1)).c_str()) << endl ;\n\t\t\t//cout <<ss.substr(f,(l-f+1))<<endl;\n\t\t\treturn ans;\n\t\t}\n\t}\n\t\treturn ans;\n}\n\nint main()\n{\n\twhile(cin >> ss &&(ss!=\"#\"))\n\t{\n\t\tpp anss = solve(0,ss.size()-1);\n\t\t//foreach(pp,anss)cout << *it << endl;\n\t\tcout << anss.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nstring s;\ntypedef long long ll;\ntypedef string::const_iterator Iter;\ntypedef set<ll>::const_iterator SIter;\n\nIter skip_par(Iter it) {\n  it++;\n  for(int cnt=1;; it++) {\n    if(*it == '(') cnt ++;\n    if(*it == ')') cnt --;\n    if(cnt == 0) break;\n  }\n  return it;\n}\n\nbool number(Iter st, Iter ed, ll& ret) {\n  ret = 0;\n  for(Iter curr=st; curr!=ed; curr++) {\n    if(isdigit(*curr)) {\n      ret *= 10;\n      ret += (*curr)-'0';\n    }\n    else { return false; }\n  }\n  return true;\n}\n\nset<char> opes={'+','-','*','/'};\n\nset<ll> exp(Iter st, Iter ed) {\n  bool ok=false; if(*st=='('){Iter ii = st; ii = skip_par(ii);if(ii==ed-1) ok=true;}\n  if(ok && *st == '(' && *(ed-1) == ')') { return exp(st+1, ed-1); }\n  {ll num; if(number(st, ed, num)) { return {num}; } }\n  set<ll> ret;\n  for(Iter curr=st; curr!=ed;curr++) {\n    if(*curr == '(') {\n      curr = skip_par(curr);\n    }\n    else if(opes.count(*curr)) {\n      set<ll> l = exp(st, curr);\n      set<ll> r = exp(curr+1,ed);\n      for(SIter i=l.begin(); i!=l.end(); i++) {\n        for(SIter j=r.begin(); j!=r.end(); j++) {\n          switch(*curr) {\n            case '+': ret.insert(*i+*j); break;\n            case '-': ret.insert(*i-*j); break;\n            case '*': ret.insert(*i**j); break;\n            case '/': if(*j!=0) { ret.insert(*i/(*j)); } break;\n          }\n        }\n      }\n    }\n  }\n\n  return ret;\n}\n\nint main()\n{\n  for(int i=0;i++,getline(cin, s);) {\n    if(s==\"#\") { break; }\n    Iter it = s.begin(), ed = s.end();\n    cout << exp(it, ed).size() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nset<int> solve(string&s, int& i){\n    vector<set<int> > num;\n    vector<char> ope;\n    ++ i;\n    for(;;){\n        if(s[i] == '('){\n            num.push_back(solve(s, i));\n        }else{\n            int a = 0;\n            while('0' <= s[i] && s[i] <= '9'){\n                a *= 10;\n                a += s[i] - '0';\n                ++ i;\n            }\n            num.resize(num.size() + 1);\n            num.back().insert(a);\n        }\n        if(s[i] == ')'){\n            ++ i;\n            break;\n        }\n        ope.push_back(s[i]);\n        ++ i;\n    }\n\n    int n = num.size();\n    vector<vector<set<int> > > dp(n, vector<set<int> >(n));\n    for(int i=0; i<n; ++i)\n        dp[i][i] = num[i];\n\n    for(int i=1; i<=n; ++i){\n        for(int j=0; j+i<n; ++j){\n            for(int k=j; k<j+i; ++k){\n                set<int>& a = dp[j][k];\n                set<int>& b = dp[k+1][j+i];\n                set<int>& c = dp[j][j+i];\n                set<int>::iterator it1;\n                for(it1=a.begin(); it1!=a.end(); ++it1){\n                    set<int>::iterator it2;\n                    for(it2=b.begin(); it2!=b.end(); ++it2){\n                        if(ope[k] == '+')\n                            c.insert((*it1) + (*it2));\n                        else if(ope[k] == '-')\n                            c.insert((*it1) - (*it2));\n                        else if(ope[k] == '*')\n                            c.insert((*it1) * (*it2));\n                        else if((*it2) != 0){\n                            int x = abs(*it1) / abs(*it2);\n                            if(((*it1) < 0) != ((*it2) < 0))\n                                x *= -1;\n                            c.insert((*it1) / (*it2));\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return dp[0][n-1];\n}\n\nint main()\n{\n    for(;;){\n        string s;\n        cin >> s;\n        if(s == \"#\")\n            return 0;\n\n        s = '(' + s + ')';\n        int i = 0;\n        cout << solve(s, i).size() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define rep2(i,a,b) for(ll i=(a);i<(b);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\nstring s;\n\nbool isop(char ch){\n    if(ch=='+' || ch=='-' || ch=='*' || ch=='/')return true;\n    else return false;\n}\n\nvoid mul(const set<int> &a, const set<int> &b, char op, set<int> &ret){\n    for(auto e1:a){\n        for(auto e2:b){\n            if(op=='+')ret.insert(e1+e2);\n            if(op=='-')ret.insert(e1-e2);\n            if(op=='*')ret.insert(e1*e2);\n            if(op=='/'){\n                if(e2==0)continue;\n                ret.insert(e1/e2);\n            }\n        }\n    }\n}\n\nset<int> dfs(int l, int r){\n    vector<int> br(300,-1);\n    stack<int> stk;\n    for(int i=l;i<r;i++){\n        if(s[i]=='(')stk.push(i);\n        else if(s[i]==')'){\n            assert(stk.size());\n            br[stk.top()] = i;\n            stk.pop();\n        }\n    }\n    int count = 0;\n    for(int i=l;i<r;i++){\n        if(br[i]==r-1-count*2){\n            l++,r--;\n            count++;\n        }else break;\n    }\n    \n    set<int> ret;\n    int c = 0;\n    \n    bool ops=false;\n    for(int i=l;i<r;i++){\n        if(s[i]=='(')c++;\n        else if(s[i]==')')c--;\n        else if( isop(s[i]) && c==0 ){\n            ops = true;\n            mul( dfs(l,i) , dfs(i+1,r), s[i], ret);\n        }\n    }\n    \n    \n    \n    if(!ops)ret = set<int>{stoi(s.substr(l,r-l))};\n    \n    return ret;\n}\n\nint main(){\n    while(cin>>s && s!=\"#\"){\n        set<int> res = dfs(0,s.size());\n        cout<<res.size()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nset<int> memo[201][201];\nvector<int> par_pos;\n\nint number(string const& s, int p) {\n    int res = 0;\n    while(p < s.size() && isdigit(s[p])) {\n        res *= 10;\n        res += s[p++] - '0';\n    }\n    return res;\n}\n\nset<int> solve(string const& s, int l, int r) {\n    auto& res = memo[l][r];\n    if(res.size() != 0) {\n        return res;\n    }\n    bool f = true;\n    for(int i=l; i<=r; ++i) {\n        f &= isdigit(s[i]);\n    }\n    if(f) {\n        res.insert(number(s, l));\n        return res;\n    }\n    if(par_pos[l] == r) {\n        return res = solve(s, l+1, r-1);\n    }\n    vector<int> pare(s.size());\n    for(int i=l; i<=r; ++i) {\n        if(s[i] == '(') {\n            pare[i] = 1;\n        }\n        if(s[i] == ')') {\n            pare[i] = -1;\n        }\n        if(i != l) {\n            pare[i] += pare[i-1];\n        }\n    }\n    for(int i=l+1; i<r; ++i) {\n        char c = s[i];\n        if(pare[i] != 0) {\n            continue;\n        }\n        if(c == '+' || c == '-' || c == '*' || c == '/') {\n            set<int> s1 = solve(s, l, i-1);\n            set<int> s2 = solve(s, i+1, r);\n            for(auto x : s1) {\n                for(auto y : s2) {\n                    if(c == '+') {\n                        res.insert(x + y);\n                    } else if(c == '-') {\n                        res.insert(x - y);\n                    } else if(c == '*') {\n                        res.insert(x * y);\n                    } else {\n                        if(y == 0) {\n                            continue;\n                        }\n                        res.insert(x / y);\n                    }\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    string s;\n    while(cin >> s, s != \"#\") {\n        for(int i=0; i<201; ++i) {\n            for(int j=0; j<201; ++j) {\n                memo[i][j].clear();\n            }\n        }\n        par_pos.assign(s.size(), -1);\n        stack<int> p;\n        for(int i=0; i<s.size(); ++i) {\n            if(s[i] == '(') {\n                p.push(i);\n            }\n            if(s[i] == ')') {\n                par_pos[p.top()] = i;\n                p.pop();\n            }\n        }\n        cout << solve(s, 0, s.size()-1).size() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Solve {\nprivate:\n\tstd::string input;\n\tusing Set = std::set<int>;\n\tusing vs = std::vector<Set>;\n\tusing vvs = std::vector<vs>;\n\n\tSet calcFormula(int& s_i)\n\t{\n\t\tvs expressions;\n\t\tstd::vector<char> operators;\n\t\texpressions.push_back(calcExpression(s_i));\n\t\twhile (s_i < (int)input.size() && input[s_i] != ')')\n\t\t{\n\t\t\toperators.push_back(input[s_i]);\n\t\t\ts_i++;\n\t\t\texpressions.push_back(calcExpression(s_i));\n\t\t}\n\n\t\tvvs dp(expressions.size(), vs(expressions.size() + 1));\n\t\tfor (int i{}; i < (int)expressions.size(); i++)\n\t\t\tdp[i][i + 1] = std::move(expressions[i]);\n\t\tfor (int width{2}; width <= (int)expressions.size(); width++)\n\t\t\tfor (int left{}; left + width <= (int)expressions.size(); left++)\n\t\t\t{\n\t\t\t\tint right{left + width};\n\t\t\t\tfor (int mid{left + 1}; mid < right; mid++)\n\t\t\t\t\tfor (auto& lhs: dp[left][mid])\n\t\t\t\t\t\tfor (auto& rhs: dp[mid][right])\n\t\t\t\t\t\t\tif (operators[mid - 1] != '/' || rhs != 0)\n\t\t\t\t\t\t\t\tdp[left][right].insert(calcOperation(lhs, rhs, operators[mid - 1]));\n\t\t\t}\n\t\treturn std::move(dp[0][expressions.size()]);\n\t}\n\n\tSet calcExpression(int& s_i)\n\t{\n\t\tSet ret;\n\t\tif (input[s_i] == '(')\n\t\t{\n\t\t\ts_i++;\n\t\t\tret = calcFormula(s_i);\n\t\t\ts_i++;\n\t\t}\n\t\telse\n\t\t\tret.insert(calcNum(s_i));\n\t\treturn std::move(ret);\n\t}\n\n\tint calcNum(int& s_i)\n\t{\n\t\tint ret{};\n\t\twhile (s_i < (int)input.size() && isdigit(input[s_i]))\n\t\t{\n\t\t\tret = 10 * ret + input[s_i] - '0';\n\t\t\ts_i++;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint calcOperation(int a, int b, char ope)\n\t{\n\t\tif (ope == '+') return a + b;\n\t\tif (ope == '-') return a - b;\n\t\tif (ope == '*') return a * b;\n\t\tif (ope == '/') return a / b;\n\t}\n\npublic:\n\tbool is_last_query{};\n\tSolve()\n\t{\n\t\tstd::cin >> input;\n\t\tif (input == \"#\")\n\t\t{\n\t\t\tis_last_query = true;\n\t\t\treturn;\n\t\t}\n\t\tint s_i{};\n\t\tprintf(\"%d\\n\", calcFormula(s_i).size());\n\t}\n};\n\nint main()\n{\n\twhile (!Solve().is_last_query);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<char,char> cc;\nvector<cc> opr;\nint ep;\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n  bool error;\n \n  Parsing(string s){\n    parse = s;\n    pos = 0;\n    error = false;\n  }\n  int fact(){\n    if( error ) return 0;\n    if(parse[pos] == '('){\n      pos++;\n      int p = expression();\n      pos++;\n      return p;\n    }else{\n      int p=0;\n      while('0' <= parse[pos] && parse[pos] <= '9'){\n        p *= 10;\n        p += parse[pos]-'0';\n        pos++;\n      }\n      return p;\n    }\n  }\n \n  int term(int depth){\n\n    if( error ) return 0;\n    int p; \n    if( depth >= ep ) p = fact();\n    else              p = term(depth+1);\n\n    while( depth < ep &&  parse[pos] == opr[depth].second ){\n\n      char c = opr[depth].first;\n      if( c == '+' )      { pos++; p += term(depth+1); }\n      else if( c == '-' ) { pos++; p -= term(depth+1); } \n      else if( c == '*' ) { pos++; p *= term(depth+1); } \n      else if( c == '/' ) {\n        pos++; \n        int denom = term(depth+1); \n        if( denom == 0 ) error = true;\n        else p /= denom;\n      } \n    }\n    return p;\n  }\n \n  int expression(){\n    if( error ) return 0;\n    int p = term(1);\n    while(!opr.empty() && parse[pos] == opr[0].second ){\n      char c = opr[0].first;\n      if( c == '+' )      { pos++; p += term(1); }\n      else if( c == '-' ) { pos++; p -= term(1); } \n      else if( c == '*' ) { pos++; p *= term(1); } \n      else if( c == '/' ) {\n        pos++; \n        int denom = term(1); \n        if( denom == 0 ) error = true;\n        else p /= denom;\n      } \n    }\n    return p;\n  } \n \n};\n\nstring s;\nint main(){\n  while( getline(cin,s) ){\n    if( s == \"#\" ) break;\n    int cnt = 0;\n    rep(i,s.size()) if( s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/' ) {\n      opr.push_back(cc(s[i],(char)('A'+cnt)));\n      s[i] = (char)('A'+cnt);\n      cnt++;\n    }\n    ep = opr.size();\n    sort(opr.begin(),opr.end());\n    set<int> ans;\n    do{\n      Parsing par(s);\n      int tmp = par.expression();\n      if( par.error ) continue;\n      ans.insert(tmp);\n    }while(next_permutation(opr.begin(),opr.end()));\n    cout << ans.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef string::const_iterator state;\n\nint expression(state&);\n\nint number(state &begin){\n    int res=0;\n    while(isdigit(*begin)){\n        res*=10;\n        res+=*begin-'0';\n        ++begin;\n    }\n    return res;\n}\n\nint factor(state &begin){\n    if(*begin=='(' or *begin=='['){\n        begin++;\n        const int res=expression(begin);\n        begin++;\n        return res;\n    }else return number(begin);\n}\n\nint expression(state &begin){\n    int res=factor(begin);\n    if(res==inf) return inf;\n    while(true){\n        if(*begin=='+'){\n            ++begin;\n            res+=expression(begin);\n        }else if(*begin=='-'){\n            ++begin;\n            res-=expression(begin);\n        }else if(*begin=='*'){\n            ++begin;\n            res*=expression(begin);\n        }else if(*begin=='/'){\n            ++begin;\n            const int tmp=expression(begin);\n            if(tmp==0) return inf;\n            res/=tmp;\n        }else break;\n    }\n    return res;\n}\n\nvoid solve(){\n    while(true){\n        string str;\n        cin >> str;\n        if(str==\"#\") return;\n\n        set<int> res;\n        function<void(const string,const int,const stack<char>)> rec=[&](const string s,const int idx,const stack<char> stk){\n            if(idx==s.size()){\n                if(!stk.size()){\n                    string s_=s;\n                    dump(s_);\n                    state begin=s_.begin();\n                    const int res_=expression(begin);\n                    if(res_!=inf) res.insert(res_);\n                    dump(res_);\n                }\n                return;\n            }\n            if(s[idx]=='('){\n                auto stk_=stk;\n                stk_.push('(');\n                rec(s,idx+1,stk_);\n                return;\n            }\n            if(s[idx]==')'){\n                if(!stk.size() or stk.top()!='(') return;\n                auto stk_=stk;\n                stk_.pop();\n                rec(s,idx+1,stk_);\n                return;\n            }\n            if(stk.size()<12 and isdigit(s[idx]) and (!idx or !isdigit(s[idx-1]))){\n                auto stk_=stk;\n                stk_.push('[');\n                auto s_=s;\n                s_.insert(idx,\"[\");\n                rec(s_,idx,stk_);\n            }\n            if(idx+1==s.size() or (isdigit(s[idx]) and !isdigit(s[idx+1]))){\n                if(!stk.size() or stk.top()!='['){\n                    rec(s,idx+1,stk);\n                    return;\n                }\n                bool ok=false;\n                for(int i=idx; s[i]!='[' ; --i){\n                    if(!isdigit(s[i])){\n                        ok=true;\n                        break;\n                    }\n                }\n                if(!ok){\n                    rec(s,idx+1,stk);\n                    return;\n                }\n                auto stk_=stk;\n                auto s_=s;\n                stk_.pop();\n                if(idx+1==s.size()) s_+=\"]\";\n                else s_.insert(idx+1,\"]\");\n                rec(s_,idx+1,stk_);\n            }\n            rec(s,idx+1,stk);\n        };\n        rec(str,0,stack<char>());\n        cout << res.size() << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool digit(char c){\n  if( c - '0'< 0 || c-'0' > 9)return false;\n  return true;\n}\n\nint stoi(string s){\n  int res,tmp;\n\n  res = 0;\n  tmp = 1;\n  for(int i=s.size()-1;i>=0;i--){\n    res += (s[i]-'0') * tmp;\n    tmp *= 10;\n  }\n  return res;\n}  \n\nset<int> cal(set<int> a,set<int> b,char o){\n  set<int> res;\n  set<int>::iterator i,j;\n  res.clear();\n\n  if(a.empty() || b.empty())return res;\n\n  if(o=='+'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tres.insert((*i) + (*j));\n      }\n    }\n  }else if(o=='-'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tres.insert((*i) - (*j));\n      }\n    }\n  }else if(o=='*'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tres.insert((*i) * (*j));\n      }\n    }\n  }else if(o=='/'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tif((*j))res.insert((*i) / (*j));\n      }\n    }\n  }\n  return res;\n}\n\nset<int> parse(string s){\n  string tmp;\n  set<int> ans[20],store[20],res;\n  char op[20];\n  int pos,cnt;\n  vector<int> order;\n\n  res.clear();\n  pos = 0;\n  cnt = 0;\n\n  while(pos < (int)s.size()){\n    if(s[pos] == '('){\n      tmp.clear();\n      pos++;\n      while(s[pos] != ')'){\n\ttmp.push_back(s[pos]);\n\tpos++;\n      }\n      ans[cnt].clear();\n      ans[cnt] = parse(tmp);\n      pos++;\n    }else if(digit(s[pos])){\n      tmp.clear();\n      while(digit(s[pos])){\n\ttmp.push_back(s[pos]);\n\tpos++;\n      }\n      ans[cnt].clear();\n      ans[cnt].insert(stoi(tmp));\n    }\n    if(pos==(int)s.size())break;\n\n    op[cnt] = s[pos];\n    cnt++;\n    pos++;\n  }\n\n  order.clear();\n  for(int i=0;i<cnt;i++)order.push_back(i);\n  res.clear();\n\n  do{\n    for(int i=0;i<=cnt;i++)store[i] = ans[i];\n    int use[20],num;\n    set<int> hoge;\n    for(int i=0;i<=cnt;i++)use[i] = i;\n    \n    for(int i=0;i<cnt;i++){\n      hoge = cal(store[order[i]],store[order[i]+1],op[order[i]]);\n      /*\n      set<int>::iterator k;\n      if(hoge.empty()){\n\tcout << \"{\";\n\tfor(k=store[order[i]].begin();k!=store[order[i]].end();k++)cout << *k << \" \";\n\tcout << \"} \";\n\tcout << op[order[i]];\n\tcout<< \" {\";\n\tfor(k=store[order[i]+1].begin();k!=store[order[i]+1].end();k++)cout << *k << \" \";\n\tcout << \"}\";\n\tcout << endl;\n      }\n      */\n\n      num = use[order[i]+1];\n      for(int j=0;j<=cnt;j++){\n\tif(use[j] == num)use[j] = use[order[i]];\n      }\n      for(int j=0;j<=cnt;j++){\n\tif(use[j] == use[order[i]])store[j] = hoge;\n      }\n    }\n    \n    set<int>::iterator i;\n    for(i=store[0].begin();i!=store[0].end();i++)res.insert(*i);\n\n  }while(next_permutation(order.begin(),order.end()));\n  \n\n  return res;\n}\n\n\nint main(){\n  string str;\n  set<int> s;\n\n  while(1){\n    cin >> str;\n    if(str == \"#\")break;\n\n    s = parse(str);\n    cout << s.size() << endl;    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\ntypedef pair<int,set<int> > pii;\n#define r second\n#define value first\n\n#define isdigit(n) ('0'<= n && n <= '9')\n\nint calc2(int a,int b,char c){\n\tswitch(c){\n\tcase '+':return a+b;\n\tcase '-':return a-b;\n\tcase '*':return a*b;\n\tcase '/':return a/b;\n\t}\n}\nset<int> calc(set<int> &a,set<int> &b,char c){\n\tset<int> ans;\n\tfor(set<int>::iterator it = a.begin() ; it != a.end() ; ++it){\n\t\tfor(set<int>::iterator it2 = b.begin() ; it2 != b.end() ; ++it2){\n\t\t\tans.insert( calc2( (*it) , (*it2) , c ) );\n\t\t}\n\t}\n\treturn ans;\n}\n\nset<int> expr(string s){\n\t\n\tint i = 0 ; \n\tvector< set<int> > d;\n\tvector< pair<int,char> > op;\n\twhile(s[i]){\n\t\tif(isdigit(s[i])){\n\t\t\tstring v;\n\t\t\twhile(isdigit(s[i]))v += s[i++];\n\t\t\tset<int> ss;\n\t\t\tss.insert(atoi(v.c_str()));\n\t\t\td.push_back(ss);\n\t\t}else if(s[i] == '('){\n\t\t\ti++;\n\t\t\tint j = 0 , st = 0;\n\t\t\twhile(s[i+j] != ')' || st){\n\t\t\t\tif(s[i+j] == '(')st++;\n\t\t\t\telse if(s[i+j] == ')')st--;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\td.push_back(expr(s.substr(i,j)));\n\t\t\ti = i+j+1;\n\t\t}else{\n\t\t\top.push_back(make_pair(op.size(),s[i++]));\n\t\t}\n\t}\n\tset<int> ans;\n\tsort(op.begin(),op.end());\n\tdo{ // 1 + 5 + 4\n\t\tvector< pair<int,char> > w = op;\n\t\tvector< set<int> > c = d;\n\t\tfor(int i = 0 ; i < w.size() ; i++){\n\t\t\tint p = w[i].first;\n\t\t\tset<int> res = calc(c[p],c[p+1],w[i].second);\n\t\t\tc.erase(c.begin()+p);\n\t\t\tc[p] = res;\n\t\t\tfor(int j = i+1 ; j < w.size() ; j++){\n\t\t\t\tif(w[i].first < w[j].first)w[j].first--;\n\t\t\t}\n\t\t}\n\t\tans.insert(c[0].begin(),c[0].end());\n\t}while(next_permutation(op.begin(),op.end()));\n\t\n\treturn ans;\n}\nint main(){\n\tstring s;\n\twhile(cin >> s , s != \"#\"){\n\t\tcout << expr(s).size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nvector<int> perm(15);\n\nvector<ll> dfs(string s) {\n    vector<vector<ll>> num;\n    vector<char> op;\n\n    int i = 0;\n    while(i < s.length()) {\n        if ('0' <= s[i] && s[i] <= '9') {\n            int tmp = 0;\n            while('0' <= s[i] && s[i] <= '9') {\n                tmp = tmp * 10 + (s[i] - '0');\n                i++;\n            }\n            num.pb(vector<ll>(1, tmp));\n            i--;\n        } else if (s[i] == '(') {\n            int j = i + 1;\n            while(s[j] != ')') j++;\n            num.pb(dfs(s.substr(i + 1, j - i - 1)));\n            i = j;\n        } else {\n            op.pb(s[i]);\n        }\n        i++;\n    }\n\n    iota(all(perm), 0);\n    vector<ll> ans;\n    do {\n        vector<vector<ll>> v(num);\n\n        bool ok = true;\n        rep(i, op.size()) {\n            vector<ll> tmp;\n            int l = perm[i];\n            while(v[l].empty()) l--;\n            rep(j, v[l].size()) {\n                rep(k, v[perm[i] + 1].size()) {\n                    switch(op[perm[i]]) {\n                        case '+':\n                        tmp.pb(v[l][j] + v[perm[i] + 1][k]); break;\n                        case '-':\n                        tmp.pb(v[l][j] - v[perm[i] + 1][k]); break;\n                        case '*':\n                        tmp.pb(v[l][j] * v[perm[i] + 1][k]); break;\n                        case '/':\n                        if (v[perm[i] + 1][k] != 0) tmp.pb(v[l][j] / v[perm[i] + 1][k]); break;\n                    }\n                }\n            }\n\n            if (tmp.size() == 0) {\n                ok = false;\n                break;\n            }\n            uni(tmp);\n            v[l] = tmp;\n            v[perm[i] + 1].clear();\n        }\n        if (ok) rep(i, v[0].size()) ans.pb(v[0][i]);\n    } while(next_permutation(perm.begin(), perm.begin() + op.size()));\n\n    uni(ans);\n    return ans;\n}\n\nint main(){\n    cin.sync_with_stdio(false);\n    string s;\n    while(cin >> s, s[0] != '#') {\n        cout << dfs(s).size() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\nstruct expr{\n\tset<int> num;\n\tchar ope;\n\tvector<expr> exp;\n\texpr(){\n\t\tope = 0;\n\t}\n};\n\nvoid print(expr e, int deep){\n//\tcout << \"info: \" << e.num.size() << \" \" << e.ope << \" \" << e.exp.size() << endl;\n\tif( e.num.empty() ){\n\t\tfor(int i=0; i<e.exp.size(); i++){\n\t\t\tprint( e.exp[i], deep+1 );\n\t\t}\n\t}\n\tfor(int i=0; i<deep; i++)\n\t\tcout << \"  \";\n\tif( !e.num.empty() ){\n\t\tcout << *( e.num.begin() );\n\t}\n\tcout << e.ope << endl;\n}\n\nset<int> calc(expr e){\n//\tcout << \"calc\" << endl;\n//\tprint(e,0);\n\tset<int> result;\n\tif( e.exp.size() == 0 ){\n\t\tresult = e.num;\n\t}else if( e.exp.size() == 1 ){\n\t\tresult = calc( e.exp[0] );\n\t}else if( e.exp.size() == 2 ){\n\t\tset<int> t[2];\n\t\tt[0] = calc( e.exp[0] );\n\t\tt[1] = calc( e.exp[1] );\n\t\tfor(set<int>::iterator it0 = t[0].begin(); it0 != t[0].end(); it0++){\n\t\t\tfor(set<int>::iterator it1 = t[1].begin(); it1 != t[1].end(); it1++){\n\t\t\t\tswitch( e.exp[0].ope ){\n\t\t\t\tcase '+':\n\t\t\t\t\tresult.insert( *it0 + *it1 );\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tresult.insert( *it0 - *it1 );\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\tresult.insert( *it0 * *it1 );\n\t\t\t\t\tbreak;\n\t\t\t\tcase '/':\n\t\t\t\t\tif( *it1 != 0 )\n\t\t\t\t\t\tresult.insert( *it0 / *it1 );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else{\n\t\tchar b_ope = 0;\n\t\texpr tmp, t;\n\t\ttmp.exp.push_back(t);\n\t\ttmp.exp.push_back(t);\n\t\ttmp.exp[1].ope = 'e';\n\t\ttmp.exp[1].exp = e.exp;\n\t\tfor(int i=0; i<e.exp.size()-1; i++){\n\t\t\tif( !tmp.exp[0].exp.empty() )\n\t\t\t\ttmp.exp[0].exp.back().ope = b_ope;\n\t\t\ttmp.exp[0].exp.push_back( e.exp[i] );\n\t\t\tb_ope = tmp.exp[0].exp.back().ope;\n\t\t\ttmp.exp[0].exp.back().ope = 'e';\n\t\t\ttmp.exp[0].ope = e.exp[i].ope;\n\t\t\ttmp.exp[1].exp.erase( tmp.exp[1].exp.begin() );\n\t\t\tset<int> rt = calc( tmp );\n\t\t\tfor(set<int>::iterator it = rt.begin(); it != rt.end(); it++){\n\t\t\t\tresult.insert( *it );\n\t\t\t}\n\t\t}\n\t}\n//\tcout << \"result : \" << result.size() << endl;\n\treturn result;\n}\n\nexpr *getexpr(expr *root, int deep){\n\texpr *pe = root;\n\tfor(int k=0; k<=deep; k++){\n\t\tif( pe->exp.empty() || pe->exp.back().ope != 0 ){\n\t\t\texpr ex;\n\t\t\tpe->exp.push_back( ex );\n\t\t}\n\t\tpe = &( pe->exp.back() );\n\t}\n\treturn pe;\n}\n\nvoid solve(char str[205]){\n\tstruct expr exp;\n\tint tmp=0, deep=0;\n\tbool num_f=false;\n\t\n\tstr[ strlen(str)+1 ] = '\\0';\n\tstr[ strlen(str) ] = 'e';\n\tfor(int i=0; str[i] != '\\0'; i++){\n\t\tif( str[i] >= '0' && str[i] <= '9' ){\n\t\t\ttmp = tmp * 10 + ( str[i]-'0' );\n\t\t\tnum_f = true;\n\t\t\tcontinue;\n\t\t}\n\t\tif( num_f ){\n\t\t\tgetexpr(&exp,deep)->num.insert( tmp );\n\t\t\ttmp = 0;\n\t\t\tnum_f = false;\n\t\t}\n\t\tif( str[i] == '(' ){\n\t\t\tdeep++;\n\t\t}else if( str[i] == ')' ){\n\t\t\tgetexpr(&exp,deep)->ope = 'e';\n\t\t\tdeep--;\n\t\t}else{\n\t\t\t// 演算子登録\n\t\t\tgetexpr(&exp,deep)->ope = str[i];\n\t\t}\n\t}\n\n//\tprint( exp, 0 );\n\n\tset<int> ans = calc( exp );\n//\tfor(set<int>::iterator it = ans.begin(); it != ans.end(); it++){\n//\t\tcout << *it << \" \";\n//\t}\n\n\tcout << ans.size() << endl;\n}\n\nint main(){\n\tchar str[205];\n\twhile(1){\n\t\tcin >> str;\n\t\tif( str[0] == '#' )\n\t\t\tbreak;\n\t\tsolve(str);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <complex>\n#include <queue>\n#include <stack>\n#include <string>\n#include <cmath>\n#include <bitset>\n\n#define rep(i,a) for(int i = 0;i < (a); i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nstruct ev\n{\n    virtual set<int> eval() = 0;\n};\n\nstruct num : public ev\n{\n    int n;\n    set<int> ed;\n\n    num(int n) : n(n), ed() {\n        ed.insert(n);\n    }\n\n    set<int> eval() {\n        return ed;\n    }\n};\n\nstruct expr : public ev\n{\n    vector<char> op;\n    vector<ev*> inner;\n    vector<set<int> > ed;\n\n    expr() : op(), inner(), ed() {}\n\n    ~expr() {\n        rep(i,(int)inner.size())\n            delete inner[i];\n    }\n\n    set<int> eval() {\n        rep(i,(int)inner.size())\n            ed.pb(inner[i]->eval());\n\n        return recur(0, inner.size());\n    }\n\n    set<int> recur(int a, int b) {\n        if (a + 1 == b)\n            return ed[a];\n\n        set<int> ret;\n        for (int i = a + 1; i < b; ++i) {\n            set<int> lhs = recur(a, i);\n            set<int> rhs = recur(i, b);\n            repit(it1,lhs) {\n                repit(it2,rhs) {\n                    switch (op[i - 1]) {\n                    case '+':\n                        ret.insert(*it1 + *it2);\n                        break;\n                    case '-':\n                        ret.insert(*it1 - *it2);\n                        break;\n                    case '*':\n                        ret.insert(*it1 * *it2);\n                        break;\n                    case '/':\n                        if (*it2 != 0)\n                            ret.insert(*it1 / *it2);\n                        break;\n                    }\n                }\n            }\n        }\n        return ret;\n    }\n};\n\nev *parseTerm(const string &s, int pos, int &next);\n\nexpr *parseExpr(const string &s, int pos, int &next)\n{\n    expr *ret = new expr();\n    while (pos < (int) s.length()) {\n        ev *term = parseTerm(s, pos, pos);\n        ret->inner.pb(term);\n        char op = s[pos];\n        if (op == ')')\n            break;\n        ret->op.pb(op);\n        ++pos;\n    }\n    next = pos;\n    return ret;\n}\n\nev *parseTerm(const string &s, int pos, int &next)\n{\n    if (s[pos] == '(') {\n        ev *inner = parseExpr(s, pos + 1, next);\n        ++next;\n        return inner;\n    }\n\n    int ret = 0;\n    while (pos < (int) s.length() && '0' <= s[pos] && s[pos] <= '9') {\n        ret *= 10;\n        ret += s[pos] & 15;\n        ++pos;\n    }\n    next = pos;\n    return new num(ret);\n}\n\nint main()\n{\n    string line;\n    while (cin >> line && line[0] != '#') {\n        int dummy;\n        expr *expr = parseExpr(line, 0, dummy);\n\n        cout << expr->eval().size() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\nvector<char> op;\nvector<int> num;\nconst int INF=1e+9+1;\nint pri[20];\n\nint main(){ _;\n  string str;\n  while(cin>>str,str[0]!='#'){\n    op.clear();\n    num.clear();\n    fill_n(pri,20,0);\n    for(char c:str){\n      if(c=='+'||c=='-'||c=='*'||c=='/'){\n\top.push_back(c);\n\tpri[op.size()]=pri[op.size()-1];\n      }else if(c=='('){\n\tpri[op.size()]+=100;\n      }else if(c==')'){\n\tpri[op.size()]-=100;\n      }else{\n\tif(num.size()==op.size())num.push_back(0);\n\tnum[op.size()]=num[op.size()]*10+(c-'0');\n      }\n    }\n    int perm[20];\n    set<int> result;\n    int n=op.size();\n    REP(i,n)perm[i]=i;\n    do{\n      priority_queue<pair<int,int> > que;\n      vector<int> nm(num);\n      REP(j,n) que.push(make_pair(perm[j]+pri[j],j));\n      REP(j,n){\n\tchar o=op[que.top().second];\n\tauto lhs=next(nm.begin(),que.top().second);\n\twhile(*lhs==INF)lhs=prev(lhs);\n\tauto rhs=next(nm.begin(),que.top().second+1);\n\twhile(*rhs==INF)rhs=next(rhs);\n\tif(o=='+')\n\t  *lhs+=*rhs;\n\telse if(o=='-')\n\t  *lhs-=*rhs;\n\telse if(o=='*')\n\t  *lhs*=*rhs;\n\telse if(o=='/'){\n\t  if(*rhs==0)break;\n\t  *lhs/=*rhs;\n\t}\n\t*rhs=INF;\n\tque.pop();\n      }\n      result.insert(nm[0]);\n    }while(next_permutation(perm,perm+n));\n    cout<<result.size()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nstring expr;\nstring oprs = \"+-*/\";\n\nint to_int(int s, int t){\n    int res = 0;\n    int x = 1;\n    for(int i=t-1; i>=s; i--){\n        if('0'<=expr[i] && expr[i]<='9')\n            res += x * (expr[i]-'0');\n        else\n            return -1;\n        x *= 10;\n    }\n    \n    return res;\n}\n\nvector<int> dfs(int s, int t){\n    vector<int> res;\n    \n    int x = to_int(s, t);\n    if(x >= 0){\n        res.push_back(x);\n        return res;\n    }\n    \n    if(expr[s] == '(' && expr[t-1] == ')'){\n        int i;\n        int count = 0;\n        for(i=s; i<t; i++){\n            if(expr[i] == '(')\n                count++;\n            else if(expr[i] == ')')\n                count--;\n            if(count == 0)\n                break;\n        }\n        if(i == t-1)\n            return dfs(s+1, t-1);\n    }\n    \n    int count = 0;\n    for(int i=s; i<t; i++){\n        char &c = expr[i];\n        if(c == '('){\n            count++;\n        }else if(c == ')'){\n            count--;\n        }else if(c == '+'){\n            if(count) continue;\n                \n            vector<int> v1 = dfs(s, i);\n            vector<int> v2 = dfs(i+1, t);\n            \n            for(auto x1: v1)\n                for(auto x2: v2)\n                    res.push_back(x1+x2);\n        \n        }else if(c == '-'){\n            if(count) continue;\n            \n            vector<int> v1 = dfs(s, i);\n            vector<int> v2 = dfs(i+1, t);\n            \n            for(auto x1: v1)\n                for(auto x2: v2)\n                    res.push_back(x1-x2);\n    \n        }else if(c == '*'){\n            if(count) continue;\n            \n            vector<int> v1 = dfs(s, i);\n            vector<int> v2 = dfs(i+1, t);\n            \n            for(auto x1: v1)\n                for(auto x2: v2)\n                    res.push_back(x1*x2);\n        \n        }else if(c == '/'){\n            if(count) continue;\n            \n            vector<int> v1 = dfs(s, i);\n            vector<int> v2 = dfs(i+1, t);\n            \n            for(auto x1: v1)\n                for(auto x2: v2) if(x2 != 0)\n                    res.push_back(x1/x2);\n        \n        }else{\n            //??°???\n        }\n            \n    }\n    sort(res.begin(), res.end());\n    res.erase(unique(res.begin(), res.end()), res.end());\n    \n    return res;\n}\n\nvoid solve(){\n    vector<int> res = dfs(0, expr.length());\n    \n    cout << res.size() << endl;\n}\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    \n    while(cin>>expr, expr!=\"#\")\n        solve();\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <queue>\n#include <map>\n#include <ctime>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define pb push_back\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int inf=1<<29;\n\nstring S;\n\nint digit(int cur){\n\treturn S[cur]-'0';\n}\n\nset<int> number(int cur){\n\tint res=digit(cur++);\n\twhile(isdigit(S[cur])){\n\t\tres=10*res+digit(cur++);\n\t}\n\tset<int> ans;\n\tans.insert(res);\n\treturn ans;\n}\n\nset<int> exp2(int l,int r){\n\tif(S[l]=='('&&S[r-1]==')') l++,r--;\n\tint i=l;\n\tbool iscall=false;\n\tint num=0;\n\tset<int> res;\n\n\twhile(i<r){\n\t\tif(isdigit(S[i]))\n\t\t\tcontinue;\n\t\telse if(S[i]=='(')\n\t\t\tnum++;\n\t\telse if(S[i]==')')\n\t\t\tnum--;\n\t\telse if(num==0){\n\t\t\tiscall=true;\n\t\t\tchar op=S[i];\n\t\t\tset<int> a=exp2(0,i);\n\t\t\tset<int> b=exp2(i+1,r);\n\t\t\tset<int> res2;\n\t\t\tswitch(op){\n\t\t\t\tcase '+':\n\t\t\t\t\tfor(auto j:a)for(auto k:b) res2.insert(j+k);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tfor(auto j:a)for(auto k:b) res2.insert(j-k);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\tfor(auto j:a)for(auto k:b) res2.insert(j*k);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '/':\n\t\t\t\t\tfor(auto j:a)for(auto k:b)if(k!=0)res2.insert(j/k);\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t\tfor(auto j:res2) res.insert(j);\n\t\t}\n\t}\n\t\n\tif(iscall) \n\t\treturn res;\n\telse\n\t\treturn number(l);\n}\n\n\nint exp(int l,int r){\n\tset<int> res;\n\tbool iscall=false;\n\tint num=0;\n\trep(i,r){\n\t\tif(isdigit(S[i]))\n\t\t\tcontinue;\n\t\telse if(S[i]=='(')\n\t\t\tnum++;\n\t\telse if(S[i]==')')\n\t\t\tnum--;\n\t\telse if(num==0){\n\t\t\tiscall=true;\n\t\t\tchar op=S[i];\n\t\t\tset<int> a=exp2(0,i);\n\t\t\tset<int> b=exp2(i+1,r);\n\t\t\tset<int> res2;\n\t\t\tswitch(op){\n\t\t\t\tcase '+':\n\t\t\t\t\tfor(auto j:a)for(auto k:b) res2.insert(j+k);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tfor(auto j:a)for(auto k:b) res2.insert(j-k);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\tfor(auto j:a)for(auto k:b) res2.insert(j*k);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '/':\n\t\t\t\t\tfor(auto j:a)for(auto k:b)if(k!=0)res2.insert(j/k);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(auto j:res2) res.insert(j);\n\t\t}\n\t}\n\tif(iscall)\n\t\treturn res.size();\n\telse\n\t\treturn 1;\n}\n\nint main(void){\n\twhile(cin >> S){\n\t\tint n=S.size();\n\t\tif(S==\"#\")\n\t\t\tbreak;\n\t\tcout << exp(0,n) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\n\nset<int> rec2(string str){\n\t// ©Ç¤©\n\tbool f = false;\n\tfor(int i = 0; i < str.size(); i++){\n\t\tif(!(str[i] >= '0' && str[i] <= '9')){\n\t\t\tf = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!f){\n\t\tset<int> v;\n\t\tv.insert(atoi(str.c_str()));\n\t\treturn v;\n\t}\n\n\t// ©ªÌÊÅÍíêÄ¢éê\n\tif(str[0] == '('){\n\t\tbool ff = false;\n\t\tint cnt = 1;\n\t\tfor(int i = 1; i < str.size(); i++){\n\t\t\tif(str[i] == '('){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\telse if(str[i] == ')'){\n\t\t\t\tcnt--;\n\t\t\t\tif(cnt == 0 && i != str.size()-1)\n\t\t\t\t\tbreak;\n\t\t\t\tif(cnt == 0 && i == str.size()-1){\n\t\t\t\t\treturn rec2(str.substr(1,str.size()-2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tset<int> vec;\n\tfor(int i = 0; i < str.size(); i++){\n\t\tif(str[i] == '+'){\n\t\t\tset<int> v1 =  rec2(str.substr(0,i));\n\t\t\tset<int> v2 =  rec2(str.substr(i+1));\n\t\t\tfor(set<int>::iterator it = v1.begin(); v1.end() != it; it++){\n\t\t\t\tfor(set<int>::iterator iit = v2.begin(); v2.end() != iit; iit++){\n\t\t\t\t\tvec.insert((*it) + (*iit));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(str[i] == '*'){\n\t\t\tset<int> v1 =  rec2(str.substr(0,i));\n\t\t\tset<int> v2 =  rec2(str.substr(i+1));\n\t\t\tfor(set<int>::iterator it = v1.begin(); v1.end() != it; it++){\n\t\t\t\tfor(set<int>::iterator iit = v2.begin(); v2.end() != iit; iit++){\n\t\t\t\t\tvec.insert((*it) * (*iit));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(str[i] == '/'){\n\t\t\tset<int> v1 =  rec2(str.substr(0,i));\n\t\t\tset<int> v2 =  rec2(str.substr(i+1));\n\t\t\tfor(set<int>::iterator it = v1.begin(); v1.end() != it; it++){\n\t\t\t\tfor(set<int>::iterator iit = v2.begin(); v2.end() != iit; iit++){\n\t\t\t\t\tif((*iit) != 0)\n\t\t\t\t\t\tvec.insert((*it) / (*iit));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(str[i] == '-'){\n\t\t\tset<int> v1 =  rec2(str.substr(0,i));\n\t\t\tset<int> v2 =  rec2(str.substr(i+1));\n\t\t\tfor(set<int>::iterator it = v1.begin(); v1.end() != it; it++){\n\t\t\t\tfor(set<int>::iterator iit = v2.begin(); v2.end() != iit; iit++){\n\t\t\t\t\tvec.insert((*it) - (*iit));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn vec;\n}\n\nint main(){\n\n\tstring str;\n\twhile(cin >> str && str != \"#\"){\n\t\tset<int> ss = rec2(str);\n\t\tcout << ss.size() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<int>Tashi(vector<int>f1, vector<int>f2) {\n\tvector<int>f3; for (int i = 0; i < f1.size(); i++) { for (int j = 0; j < f2.size(); j++)f3.push_back(f1[i] + f2[j]); }\n\treturn f3;\n}\nvector<int>Hiki(vector<int>f1, vector<int>f2) {\n\tvector<int>f3; for (int i = 0; i < f1.size(); i++) { for (int j = 0; j < f2.size(); j++)f3.push_back(f1[i] - f2[j]); }\n\treturn f3;\n}\nvector<int>Kake(vector<int>f1, vector<int>f2) {\n\tvector<int>f3; for (int i = 0; i < f1.size(); i++) { for (int j = 0; j < f2.size(); j++)f3.push_back(f1[i] * f2[j]); }\n\treturn f3;\n}\nvector<int>Wari(vector<int>f1, vector<int>f2) {\n\tvector<int>f3;\n\tfor (int i = 0; i < f1.size(); i++) {\n\t\tfor (int j = 0; j < f2.size(); j++) { if (f2[j] != 0)f3.push_back(f1[i] / f2[j]); }\n\t}\n\treturn f3;\n}\nvector<int> solve(string S) {\n\twhile (true) {\n\t\tif (S[0] != '(' || S[S.size() - 1] != ')')break;\n\t\tint depth = 0; string S2 = S.substr(1, S.size() - 2); bool OK = true;\n\t\tfor (int i = 0; i < S2.size(); i++) {\n\t\t\tif (S2[i] == '(')depth++;\n\t\t\tif (S2[i] == ')')depth--;\n\t\t\tif (depth == -1)OK = false;\n\t\t}\n\t\tif (OK == false)break;\n\t\tS = S.substr(1, S.size() - 2);\n\t\tif (S.size() <= 1)break;\n\t}\n\tbool OK = false;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tif (S[i] < '0' || S[i] > '9')OK = true;\n\t}\n\tif (S.size() == 0) { return{}; }\n\tif (OK == false) { return{ stoi(S) }; }\n\n\tint depth = 0; vector<int>K;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tif (S[i] == '(')depth++; if (S[i] == ')')depth--;\n\t\tif (depth == 0) {\n\t\t\tif (S[i] == '+') {\n\t\t\t\tvector<int>J = Tashi(solve(S.substr(0, i)), solve(S.substr(i + 1, S.size() - i - 1)));\n\t\t\t\tfor (int j = 0; j < J.size(); j++)K.push_back(J[j]);\n\t\t\t}\n\t\t\tif (S[i] == '-') {\n\t\t\t\tvector<int>J = Hiki(solve(S.substr(0, i)), solve(S.substr(i + 1, S.size() - i - 1)));\n\t\t\t\tfor (int j = 0; j < J.size(); j++)K.push_back(J[j]);\n\t\t\t}\n\t\t\tif (S[i] == '*') {\n\t\t\t\tvector<int>J = Kake(solve(S.substr(0, i)), solve(S.substr(i + 1, S.size() - i - 1)));\n\t\t\t\tfor (int j = 0; j < J.size(); j++)K.push_back(J[j]);\n\t\t\t}\n\t\t\tif (S[i] == '/') {\n\t\t\t\tvector<int>J = Wari(solve(S.substr(0, i)), solve(S.substr(i + 1, S.size() - i - 1)));\n\t\t\t\tfor (int j = 0; j < J.size(); j++)K.push_back(J[j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn K;\n}\nint main() {\n\twhile (true) {\n\t\tstring U; cin >> U; if (U == \"#\")break;\n\t\tvector<int>ans = solve(U);\n\t\tsort(ans.begin(), ans.end()); ans.erase(unique(ans.begin(), ans.end()), ans.end());\n\t\tcout << ans.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <cctype>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cassert>\n#include <fstream>\nusing namespace std;\n\nset<int> add(const set<int> &s1, const set<int> &s2){\n  set<int> res;\n  for(set<int>::iterator it1 = s1.begin(); it1 != s1.end(); it1++){\n    for(set<int>::iterator it2 = s2.begin(); it2 != s2.end(); it2++){\n      int num = *it1 + *it2;\n      if(!res.count(num)) res.insert(num);\n    }\n  }\n\n  return res;\n}\n\nset<int> sub(const set<int> &s1, const set<int> &s2){\n  set<int> res;\n  for(set<int>::iterator it1 = s1.begin(); it1 != s1.end(); it1++){\n    for(set<int>::iterator it2 = s2.begin(); it2 != s2.end(); it2++){\n      int num = *it1 - *it2;\n      if(!res.count(num)) res.insert(num);\n    }\n  }\n  return res;\n}\n\nset<int> mul(const set<int> &s1, const set<int> &s2){\n  set<int> res;\n  for(set<int>::iterator it1 = s1.begin(); it1 != s1.end(); it1++){\n    for(set<int>::iterator it2 = s2.begin(); it2 != s2.end(); it2++){\n      int num = (*it1) * (*it2);\n      if(!res.count(num)) res.insert(num);\n    }\n  }\n  return res;\n}\n\nset<int> div(const set<int> &s1, const set<int> &s2){\n  set<int> res;\n  for(set<int>::iterator it1 = s1.begin(); it1 != s1.end(); it1++){\n    for(set<int>::iterator it2 = s2.begin(); it2 != s2.end(); it2++){\n      if(*it2 != 0){\n\tint num = *it1 / *it2;\n\t  if(!res.count(num))res.insert(num);\n      }\n    }\n  }\n  return res;\n}\n\nvoid putset(set<int> &s1, const set<int> &s2){\n  for(set<int>::iterator iter = s2.begin(); iter != s2.end();iter++){\n    if(!s1.count(*iter)){\n      s1.insert(*iter);\n    }\n  }\n}\n\nsize_t cur;\nstring s;\n\nint number(){\n  int res = 0;\n  while(cur < s.size() && isdigit(s[cur])){\n    res = res * 10 + s[cur++] - '0';\n  }\n  return res;\n}\n\nset<int> expr(){\n  vector<set<int> > vs;\n  vector<char> op;\n\n  while(cur < s.size() && s[cur] != ')'){\n    if(s[cur] == '('){\n      cur++;\n      vs.push_back(expr());\n      assert(s[cur] == ')');\n      cur++;\n    }else if(isdigit(s[cur])){\n      int num = number();\n      set<int> s;\n      s.insert(num);\n      vs.push_back(s);\n    }else{\n      op.push_back(s[cur]);\n      cur++;\n    }\n  }\n  \n  set<int> dp[12][12];\n  int n = vs.size();\n  //  cout << \"sz \"<< n << endl;\n  for(int i = 0; i < n; i++){\n    dp[i][1] = vs[i];\n    //    cout << dp[i][1].size() << endl;\n  }\n  /*  for(int i = 0; i < n; i++){\n    for(set<int>::iterator iter = vs[i].begin(); iter != vs[i].end(); iter++){\n      cout << *iter << \" \";\n    }\n    cout << endl;\n    }*/\n  for(int w = 2; w <= n; w++){\n    for(int i = 0; i < n - w + 1; i++){\n      for(int j = i + 1; j < i + w; j++){\n\t\n\tswitch(op[j-1]){\n\tcase '+': \n\t  putset(dp[i][w], add(dp[i][j-i], dp[j][i+w-j]));\n\t  break;\n\tcase '-':\n\t  putset(dp[i][w], sub(dp[i][j-i], dp[j][i+w-j]));\n\t  break;\n\tcase '*':\n\t  putset(dp[i][w], mul(dp[i][j-i], dp[j][i+w-j]));\n\t  break;\n\tcase '/':\n\t  putset(dp[i][w], div(dp[i][j-i], dp[j][i+w-j]));\n\t  break;\n\tdefault : \n\t  cout << \"NG\" << endl;\n\t}\n      }\n    }\n  }\n  \n  return dp[0][n];\n}\n\nint main(){\n  //  ofstream cout(\"D.txt\");\n  while(cin >> s && s != \"#\"){\n    cur = 0;\n    cout << expr().size() << endl;\n  }\n \n  //  cout.close();\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s;\n\nint oper(int lhs,int rhs,char op){\n    if(op=='+'){\n        return lhs+rhs;\n    }\n    if(op=='-'){\n        return lhs-rhs;\n    }\n    if(op=='*'){\n        return lhs*rhs;\n    }\n    if(op=='/'){\n        if(rhs==0) throw \"0_devision\";\n        return lhs/rhs;\n    }\n    assert(false);\n    return 0;\n}\n\nset<int> calc(vector<int> num,vector<char> op){\n    set<int> res;\n    if(num.size()==1){\n        res.insert(num[0]);\n        return res;\n    }\n    for(int i=0;i<num.size()-1;i++){\n        auto nexnum=num;\n        auto nexop=op;\n        int lhs=num[i];\n        int rhs=num[i+1];\n        char opc=op[i];\n        int val;\n        try{\n            val=oper(lhs,rhs,opc);\n        }catch(const char* ex){\n            continue;\n        }\n        nexnum.erase(nexnum.begin()+i,nexnum.begin()+i+2);\n        nexnum.insert(nexnum.begin()+i,val);\n        nexop.erase(nexop.begin()+i);\n        auto ret=calc(nexnum,nexop);\n        res.insert(ret.begin(),ret.end());\n    }\n    return res;\n}\n\nset<int> dfs(int inde,vector<set<int>> &nums,vector<char> &op,vector<int> &num){\n    if(inde==nums.size()){\n        return calc(num,op);\n    }\n    set<int> res;\n    for(auto &v:nums[inde]){\n        num.push_back(v);\n        auto ret=dfs(inde+1,nums,op,num);\n        res.insert(ret.begin(),ret.end());\n        num.pop_back();\n    }\n    return res;\n}\n\nint val(int &p){\n    int res=0;\n    while(isdigit(s[p])){\n        res*=10;\n        res+=s[p]-'0';\n        p++;\n    }\n    return res;\n}\n\nset<int> expr(int &p){\n    vector<set<int>> nums;\n    vector<char> op;\n    while(true){\n        if(isdigit(s[p])){\n            set<int> st;\n            int v=val(p);\n            st.insert(v);\n            nums.push_back(st);\n        }\n        else{\n            assert(s[p]=='(');\n            p++;\n            nums.push_back(expr(p));\n            assert(s[p]==')');\n            p++;\n        }\n        if(p==s.size() || s[p]==')') break;\n        op.push_back(s[p]);\n        p++;\n    }\n    vector<int> num;\n    return dfs(0,nums,op,num);\n}\n\nint main(){\n    while(cin>>s,s!=\"#\"){\n        int p=0;\n        cout<<expr(p).size()<<endl;\n    }      \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <sstream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n \nset<int> m1[201][201];\nbool m2[201][201];\n \nint stoi(string s) {\n\tstringstream ss; ss << s;\n\tint ret; ss >> ret;\n\treturn ret;\n}\n \nstring str;\nset<int> dp(int l, int r) {\n\tif (m2[l][r]) return m1[l][r];\n\tif (str[l] == '(' && str[r-1] == ')') return dp(l+1, r-1);\n\n\tset<int> ret;\n\tbool f = true;\n\tfor (int i = l; i < r; ++i) {\n\t\tif (!isdigit(str[i])) f = false;\n\t}\n\tif (f) {\n\t\tret.insert( stoi(str.substr(l, r-l)) );\n\t}\n\telse {\n\t\tint depth = 0;\n\t\tfor (int i = l; i < r; ++i) {\n\t\t\tswitch (str[i]) {\n\t\t\t\tcase '(':\n\t\t\t\t\t++depth;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ')':\n\t\t\t\t\t--depth;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '+':\n\t\t\t\tcase '-':\n\t\t\t\tcase '*':\n\t\t\t\tcase '/':\n\t\t\t\tif (depth == 0) {\n\t\t\t\t\tset<int> L = dp(l, i), R = dp(i+1, r);\n\t\t\t\t\tfor (set<int>::iterator j = L.begin(); j != L.end(); ++j) {\n\t\t\t\t\t\tfor (set<int>::iterator k = R.begin(); k != R.end(); ++k) {\n\t\t\t\t\t\t\tswitch (str[i]) {\n\t\t\t\t\t\t\t\tcase '+': ret.insert(*j+*k); break;\n\t\t\t\t\t\t\t\tcase '-': ret.insert(*j-*k); break;\n\t\t\t\t\t\t\t\tcase '*': ret.insert((*j)*(*k)); break;\n\t\t\t\t\t\t\t\tcase '/': if (*k) ret.insert((*j)/(*k)); break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn m2[l][r] = true, m1[l][r] = ret;\n}\n \nint main() {\n\twhile (cin >> str, str != \"#\") {\n\t\tfill(&m2[0][0], &m2[0][0]+201*201, false);\n\t\tcout << dp(0, str.size()).size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s;\nint a[200],p,f;\nchar b[11];\nint bns1();\nint g_A(){\n  int r=0;\n  if(s[p]=='(')p++,r=bns1(),p++;\n  else while(isdigit(s[p]))r=r*10+(s[p++]-'0');\n  return r;\n}\nint bns10(){\n  int res=g_A();\n  while(a[s[p]]==10){\n    int t=p++;\n    if(b[s[t]]=='+')res+=g_A();\n    if(b[s[t]]=='-')res-=g_A();\n    if(b[s[t]]=='*')res+=g_A();\n    if(b[s[t]]=='/'){\n      int tt=g_A();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nint bns9(){\n  int res=bns10();\n  while(a[s[p]]==9){\n    int t=p++;\n    if(b[s[t]]=='+')res+=bns10();\n    if(b[s[t]]=='-')res-=bns10();\n    if(b[s[t]]=='*')res+=bns10();\n    if(b[s[t]]=='/'){\n      int tt=bns10();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nint bns8(){\n  int res=bns9();\n  while(a[s[p]]==8){\n    int t=p++;\n    if(b[s[t]]=='+')res+=bns9();\n    if(b[s[t]]=='-')res-=bns9();\n    if(b[s[t]]=='*')res+=bns9();\n    if(b[s[t]]=='/'){\n      int tt=bns9();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nint bns7(){\n  int res=bns8();\n  while(a[s[p]]==7){\n    int t=p++;\n    if(b[s[t]]=='+')res+=bns8();\n    if(b[s[t]]=='-')res-=bns8();\n    if(b[s[t]]=='*')res+=bns8();\n    if(b[s[t]]=='/'){\n      int tt=bns8();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nint bns6(){\n  int res=bns7();\n  while(a[s[p]]==6){\n    int t=p++;\n    if(b[s[t]]=='+')res+=bns7();\n    if(b[s[t]]=='-')res-=bns7();\n    if(b[s[t]]=='*')res+=bns7();\n    if(b[s[t]]=='/'){\n      int tt=bns7();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nint bns5(){\n  int res=bns6();\n  while(a[s[p]]==5){\n    int t=p++;\n    if(b[s[t]]=='+')res+=bns6();\n    if(b[s[t]]=='-')res-=bns6();\n    if(b[s[t]]=='*')res+=bns6();\n    if(b[s[t]]=='/'){\n      int tt=bns6();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nint bns4(){\n  int res=bns5();\n  while(a[s[p]]==4){\n    int t=p++;\n    if(b[s[t]]=='+')res+=bns5();\n    if(b[s[t]]=='-')res-=bns5();\n    if(b[s[t]]=='*')res+=bns5();\n    if(b[s[t]]=='/'){\n      int tt=bns5();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nint bns3(){\n  int res=bns4();\n  while(a[s[p]]==3){\n    int t=p++;\n    if(b[s[t]]=='+')res+=bns4();\n    if(b[s[t]]=='-')res-=bns4();\n    if(b[s[t]]=='*')res+=bns4();\n    if(b[s[t]]=='/'){\n      int tt=bns4();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nint bns2(){\n  int res=bns3();\n  while(a[s[p]]==2){\n    int t=p++;\n    if(b[s[t]]=='+')res+=bns3();\n    if(b[s[t]]=='-')res-=bns3();\n    if(b[s[t]]=='*')res+=bns3();\n    if(b[s[t]]=='/'){\n      int tt=bns3();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nint bns1(){\n  int res=bns2();\n  while(a[s[p]]==1){\n    int t=p++;\n    if(b[s[t]]=='+')res+=bns2();\n    if(b[s[t]]=='-')res-=bns2();\n    if(b[s[t]]=='*')res+=bns2();\n    if(b[s[t]]=='/'){\n      int tt=bns2();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nmain(){\n  while(cin>>s,s!=\"#\"){\n    int cnt=0,lx[10];\n    set<int>se;\n    r(i,s.size())if(!isdigit(s[i])&&s[i]!='('&&s[i]!=')')b[cnt+'a']=s[i],s[i]='a'+cnt++;\n    r(i,cnt)lx[i]=i;\n    do{\n      f=p=0;\n      r(i,cnt)a[lx[i]+'a']=i+1;\n      int ppp=bns1();\n      if(!f)se.insert(ppp);\n    }while(next_permutation(lx,lx+cnt));\n    cout<<se.size()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\nusing namespace std;\n\nset<int> dp[12][12];\n\nbool digit(char c){\n  if( c - '0'< 0 || c-'0' > 9)return false;\n  return true;\n}\n\nint stoi(string s){\n  int res,tmp;\n\n  res = 0;\n  tmp = 1;\n  for(int i=s.size()-1;i>=0;i--){\n    res += (s[i]-'0') * tmp;\n    tmp *= 10;\n  }\n  return res;\n}  \n\nset<int> cal(set<int> a,set<int> b,char o){\n  set<int> res;\n  set<int>::iterator i,j;\n  res.clear();\n\n  if(a.empty() || b.empty())return res;\n\n  if(o=='+'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tres.insert((*i) + (*j));\n      }\n    }\n  }else if(o=='-'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tres.insert((*i) - (*j));\n      }\n    }\n  }else if(o=='*'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tres.insert((*i) * (*j));\n      }\n    }\n  }else if(o=='/'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tif((*j))res.insert((*i) / (*j));\n      }\n    }\n  }\n  return res;\n}\n\nset<int> parse(string s){\n  string tmp;\n  set<int> ans[12];\n  char op[12];\n  int pos,cnt;\n\n  pos = 0;\n  cnt = 0;\n\n  while(1){\n    if(s[pos] == '('){\n      tmp.clear();\n      pos++;\n      while(s[pos] != ')'){\n\ttmp.push_back(s[pos]);\n\tpos++;\n      }\n      ans[cnt].clear();\n      ans[cnt] = parse(tmp);\n      pos++;\n    }else if(digit(s[pos])){\n      tmp.clear();\n      while(pos<(int)s.size() && digit(s[pos])){\n\ttmp.push_back(s[pos]);\n\tpos++;\n      }\n      ans[cnt].clear();\n      ans[cnt].insert(stoi(tmp));\n    }\n    if(pos==(int)s.size())break;\n\n    op[cnt] = s[pos];\n    cnt++;\n    pos++;\n  }\n\n  for(int i=0;i<=cnt;i++)dp[i][i] = ans[i];\n      \n  for(int i=1;i<=cnt;i++){\n    for(int j=0;j+i<=cnt;j++){\n      dp[j][j+i].clear();\n      for(int k=j;k<j+i;k++){\n\tset<int> hoge;\n\thoge = cal(dp[j][k],dp[k+1][j+i],op[k]);\n\tset<int>::iterator ite;\n\tfor(ite=hoge.begin();ite!=hoge.end();ite++)dp[j][j+i].insert(*ite);\n      }\n    }\n  }\n\n  return dp[0][cnt];\n}\n\n\nint main(){\n  string str;\n  set<int> s;\n\n  while(1){\n    cin >> str;\n    if(str == \"#\")break;\n\n    s = parse(str);\n    cout << s.size() << endl;    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef set<int> :: iterator setit;\n\nint f(int a,char ch,int b){\n  if(ch=='+')return a+b;\n  else if(ch=='-')return a-b;\n  else if(ch=='*')return a*b;\n  else return a/b;\n}\n\nbool visited[20][20];\nset<int> dp[20][20];\nset<int> rec( int l,int r,  vector< set<int> > &t,  vector< char > &u ){\n  if(visited[l][r])return dp[l][r];\n  visited[l][r]=true;\n  set<int> res;\n  for(int i=l;i+1<=r;i++){\n    set<int> A,B;\n    A=rec(l,i,t,u);\n    B=rec(i+1,r,t,u);\n    for(setit j=A.begin();j!=A.end();j++){\n      for(setit k=B.begin();k!=B.end();k++){\n        int J=*j,K=*k;\n        if(u[i]=='/'&&K==0)continue;\n        res.insert( f(J,u[i],K) );\n      }\n    }\n  }\n  return res;\n}\n\nset<int> solve(   vector< set<int> > &t,  vector< char > &u ){\n  for(int i=0;i<20;i++)\n    for(int j=0;j<20;j++)\n      dp[i][j].clear(),visited[i][j]=false;\n  for(int i=0;i<(int)t.size();i++){\n    dp[i][i]=t[i];\n    visited[i][i]=true;\n  }\n  return rec(0,t.size()-1,t,u);\n}\n\n\n\nstring s;\nint p;\n\nset<int> calc();\n\nset<int> getNum(){\n  if(s[p]=='('){\n    p++;\n    return calc();\n  }\n  int a=0;\n  while('0'<=s[p]&&s[p]<='9'){\n    a=a*10+s[p]-'0';\n    p++;\n  }\n  set<int> res;\n  res.insert(a);\n  return res;\n}\n\nset<int> calc(){\n  vector< set<int> > t;\n  vector< char > u;\n  t.push_back(getNum());\n  while(1){\n    if(s[p]=='='||s[p]==')'){\n      p++;\n      break;\n    }\n    u.push_back(s[p]);\n    p++;\n    t.push_back(getNum());\n  }\n  if(u.size()==0)return t[0];\n  else return solve(t,u);\n}\n\nint main(){\n  while(1){\n    cin>>s;\n    if(s==\"#\")break;\n    s.push_back('=');\n    p=0;\n    set<int> ans=calc();\n    cout<<ans.size()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<set>\nusing namespace std;\nset<int> log;\nint solve(string s);\nstring calc(string a, string b, int mode);\nint num(string a);\nint main(){\n  string s;\n  while(cin >>s,s!=\"#\"){\n    log.clear();\n    cout <<solve(s+'=')<<endl;\n  }\n  return 0;\n}\nint solve(string s){\n  int ans = 0,a = -1,b = -1,c = -1,m = 0;\n  bool flag = true;\n  for(int i=0; i<s.size(); i++){\n    if(s[i]>='0' && s[i]<='9'){\n      if(a == -1) a = i;\n      else if(b!=-1 && c == -1) c = i;\n    }\n    else if(s[i] == '(' || s[i] == ')'){\n      if(s[i] == ')'){\n\tif(m!=0 && c!=-1){\n\t  string sc = calc(s.substr(a,b-a),s.substr(c,i-c),m);\n\t  string ns = s.substr(0,a)+sc+s.substr(i);\n\t  if(sc == \"Error\") return 0;\n\t  ans+=solve(ns);\n\t  flag = false;\n\t  a = c;b = i;c = -1;\n\t}\n\tif(m == 0){\n\t  string xs = s.substr(0,a-1)+s.substr(a,i-a)+s.substr(i+1);\n\t  ans+=solve(xs);\n\t}\n      }\n      a = b = c = -1;m = 0;\n    }\n    else if(s[i] == '+' || s[i] == '-' || s[i] == '/' || s[i] == '*' || s[i] == '='){\n      if(m!=0 && c!=-1){\n\tstring sc = calc(s.substr(a,b-a),s.substr(c,i-c),m);\n\tstring ns = s.substr(0,a)+sc+s.substr(i);\n\tif(sc == \"Error\") return 0;\n\tans+=solve(ns);\n\tflag = false;\n\ta = c;b = i;c = -1;\n      }\n      else if(flag && s[i] == '='){\n\tint as = num(s.substr(0,i));\n\tif(log.find(as) == log.end()){\n\t  log.insert(as);\n\t  return 1;\n\t}\n\treturn 0;\n      }\n      if(a == -1 && s[i] == '-') a = i;\n      else{\n\tif(m == 0) b = i;\n\tif(s[i] == '+') m = 1;\n\tif(s[i] == '-') m = 2;\n\tif(s[i] == '*') m = 3;\n\tif(s[i] == '/') m = 4;\n      }\n    }\n  }\n  return ans;\n}\nstring calc(string a, string b, int mode){\n  int A = num(a),B = num(b),C,f = 0;\n  string s,ans;\n  if(mode == 1) C = A+B;\n  if(mode == 2) C = A-B;\n  if(mode == 3) C = A*B;\n  if(mode == 4){\n    if(B == 0) return \"Error\";\n    C = A/B;\n  }\n  if(C == 0) s = \"0\";\n  if(C<0){f = 1;C*=-1;}\n  while(C!=0){\n    s+=C%10+'0';\n    C/=10;\n  }\n  if(f == 1) s+='-';\n  for(int i=0; i<s.size(); i++) ans+=s[s.size()-i-1];\n  return ans;\n}\nint num(string a){\n  int A = 0;\n  for(int i=0; i<a.size(); i++) if(a[i]>='0' && a[i]<='9') A = A*10+a[i]-'0';\n  if(a[0] == '-') A*=-1;\n  return A;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define si(x) int(x.size())\n#define double long double\nconst int mod=1000000007,MAX=205,INF=1<<28;\nstring S;\nint N;\nset<int> dp[MAX][MAX];\nbool seen[MAX][MAX];\n\nbool num(int i){\n    if('0'<=S[i]&&S[i]<='9') return 1;\n    else return 0;\n}\n\nvoid merge(int l1,int r1,int l2,int r2,char c){\n    for(auto a:dp[l1][r1]){\n        for(auto b:dp[l2][r2]){\n            if(c=='/'&&b==0) continue;\n            \n            if(c=='+') dp[l1][r2].insert(a+b);\n            if(c=='-') dp[l1][r2].insert(a-b);\n            if(c=='*') dp[l1][r2].insert(a*b);\n            if(c=='/') dp[l1][r2].insert(a/b);\n        }\n    }\n}\n\nvoid solve(int l,int r){\n    if(seen[l][r]) return;\n    seen[l][r]=1;\n    \n    bool numcheck=true;\n    if(l&&num(l-1)) return;\n    if(r<N&&num(r)) return;\n    for(int i=l;i<r;i++) if(!num(i)) numcheck=false;\n    \n    if(numcheck){\n        int ret=0;\n        for(int i=l;i<r;i++){\n            ret*=10;\n            ret+=S[i]-'0';\n        }\n        dp[l][r].insert(ret);\n    }\n    \n    if(S[l]=='('){\n        if(S[r-1]==')'){\n            solve(l+1,r-1);\n            dp[l][r]=dp[l+1][r-1];\n        }\n    }\n    \n    for(int i=l+1;i<r-1;i++){\n        if(S[i]=='+'||S[i]=='-'||S[i]=='*'||S[i]=='/'){\n            solve(l,i);\n            solve(i+1,r);\n            merge(l,i,i+1,r,S[i]);\n        }\n    }\n    \n    return;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        cin>>S;\n        if(S==\"#\") break;\n        \n        N=si(S);\n        for(int i=0;i<=N;i++) for(int j=0;j<=N;j++) dp[i][j].clear();\n        memset(seen,0,sizeof(seen));\n        \n        solve(0,N);\n        \n        cout<<si(dp[0][N])<<endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n// Shrotening\n#define fst first\n#define snd second\n#define pb push_back\n\n// Loop\n#define FOR(i,a,b) for(auto i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(auto i=(a);i>=(b);--i)\n\n#define REP(i,a) for(long i=0;i<(a);++i)\n#define RREP(i,a) for(long i=(a);i>=0;--i)\n\n#define EACH(i,a) for(auto (i)=(a).begin(),_END=(a).end();i!=_END;++i)\n#define REACH(i,a) for(auto (i)=(a).rbegin(),_END=(a).rend();i!=_END;++i)\n\n//Algorithm\n#define ALL(a) (a).begin(), a.end()\n#define RALL(a) (a).rbegin(), a.rend()\n#define EXIST(a,x) ((a).find(x)!=(a).end())\n#define SORT(a) std::sort((a).begin(), (a).end())\n#define UNIQUE(a) std::sort((a).begin(), a.end()), a.erase(std::unique((a).begin(), a.end()), a.end());\n#define SUM(a) std::accumulate((a).begin(), (a).end(), 0);\n\n//Setting\n#define OPT std::cin.tie(0);std::ios::sync_with_stdio(false);\n\n//debug message\nbool debug = true;\n#define MSG(s)   if(debug){std::cout << s << std::endl;}\n#define DEBUG(x) if(debug){std::cout << \"debug(\" << #x << \"): \" << x << std::endl;}\n\n//alias\ntypedef long long LL;\ntypedef std::vector<char> VC;\ntypedef std::vector<int>  VI;\ntypedef std::vector<long> VL;\ntypedef std::vector<long long> VLL;\n\ntypedef std::vector< VC > VC2;\ntypedef std::vector< VI > VI2;\ntypedef std::vector< VL > VL2;\ntypedef std::vector< VLL > VLL2;\n\ntypedef std::pair<int,int> PII;\n\n\nstd::string str;\nint len;\n\nint inline calc(char op, int l, int r) {\n    return   op == '+' ? l + r\n           : op == '-' ? l - r\n           : op == '*' ? l * r\n           :             l / r;\n}\n\nbool inline isOperator(char c) {\n    return (c == '+' || c == '-' || c == '*' || c == '/');\n}\n\nbool isOperatorContain(int l, int r) {\n    int d = 0;\n    for(int i=l; i<=r; ++i) {\n        if(str[i] == '(') {\n            ++d;\n        }\n        if(str[i] == ')') {\n            --d;\n        }\n        if(d > 0) {\n            continue;\n        }\n\n        if(isOperator(str[i])) {\n            return true;\n        }\n    }\n    return false;\n}\n\nstd::map< std::pair<int,int>, std::set<int> > memo;\n\nstd::set<int> eval(int l, int r) {\n    std::pair<int,int> p = std::make_pair(l, r);\n    if(memo.count(p) > 0) {\n        return memo[p];\n    }\n\n    std::set<int> ans;\n    if(str[l] == '(' && str[r] == ')') {\n        ans = eval(l+1, r-1);\n    } else if(isOperatorContain(l, r)) {\n        int i = l, d = 0; //depth\n        while(i <= r) {\n            if(str[i] == '(') {\n                ++d;\n            }\n            if(str[i] == ')') {\n                --d;\n            }\n            if(d > 0) {\n                ++i;\n                continue;\n            }\n\n            if(isOperator(str[i])) {\n                char op = str[i];\n                auto left  = eval(l, i-1);\n                auto right = eval(i+1, r);\n                for(auto x: left) {\n                    for(auto y: right) {\n                        ans.insert(calc(op, x, y));\n                    }\n                }\n            }\n            ++i;\n        }\n    } else {\n        int v = 0;\n        int i = l;\n        while(i <= r && str[i] != ')') {\n            v *= 10;\n            v += (str[i] - '0');\n            ++i;\n        }\n        ans.insert(v);\n    }\n    memo.insert(std::make_pair(p, ans));\n    return ans;\n}\n\nint main() {\n    while(std::cin >> str, str != \"#\") {\n        memo.clear();\n        len = str.length();\n        auto pat = eval(0, len - 1);\n        std::cout << pat.size() << std::endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint isalldigit(const string& str)\n{\n  for(int i = 0; i < str.size(); i++){\n    if(!isdigit(str[i])) return false;\n  }\n  return true;\n}\n\nset< int > expr(string str)\n{\n  set< int > ret;\n\n  int foo = 0 ;\n  if(str[0] == '(' && str[str.size() - 1] == ')'){\n    return expr( str.substr( 1, str.size() - 2));\n  }else if(isalldigit(str)){\n    ret.insert(atoi(str.c_str()));\n  } else {\n    for(int i = 0; i < str.size(); i++){\n      if(str[i] == '('){ //開き括弧だなぁ\n        foo++;\n        continue;\n      } else if(str[i] == ')'){ //閉じ括弧だなぁ \n        foo--;\n        continue;\n      } else if(isdigit(str[i])){ //数字はどうでもいいなぁ\n        continue;\n      }\n      if(foo == 0){\n        set< int > hori = expr(str.substr( 0, i));\n        set< int > tkc = expr(str.substr( i + 1));\n        for(set< int >::iterator msy = hori.begin(); msy != hori.end(); msy++){\n          for(set< int >::iterator mtur = tkc.begin(); mtur != tkc.end(); mtur++){\n            if(str[i] == '+'){\n              ret.insert( *msy + *mtur);\n            } else if(str[i] == '-'){\n              ret.insert( *msy - *mtur);\n            } else if(str[i] == '*'){\n              ret.insert( *msy * *mtur);\n            } else {\n              if(*mtur == 0) continue;\n              ret.insert( *msy / *mtur);\n            }\n          }\n        }\n      }\n    }\n  }\n  return ret;\n}\n\n\nint main()\n{\n  string s;\n  while(cin >> s, s != \"#\"){\n    cout << expr(s).size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nstring S;\nint N;\n\nenum Type {\n    Open,\n    Close,\n    Num,\n    Ope,\n    None\n};\n\nstruct Expr {\n    Expr() {\n        right = -1;\n        left = -1;\n        type = None;\n    }\n    Type type;\n\n    int num;\n    char ope;\n\n    int left;\n    int right;\n};\n\nvector<Expr> exprs;\nVI ope_idxes;\n\nPII parse_num(int pos) {\n    string num_s;\n    while (pos < N && isdigit(S[pos])) {\n        num_s += S[pos];\n        ++pos;\n    }\n    return MP(pos, fromString<int>(num_s));\n}\n\nvoid link(int a, int b) {\n    if (a != -1) {\n        exprs[a].right = b;\n    }\n    if (b != -1) {\n        exprs[b].left = a;\n    }\n}\n\nvoid link2(vector<Expr> &es, int a, int b) {\n    if (a != -1) {\n        es[a].right = b;\n    }\n    if (b != -1) {\n        es[b].left = a;\n    }\n}\n\nint make_expr(int before) {\n    Expr cur;\n    int idx = exprs.size();\n    exprs.PB(cur);\n    link(before, idx);\n    return idx;\n}\n\nvoid parse() {\n    exprs.resize(0);\n    ope_idxes.resize(0);\n\n    int before = -1;\n\n    for (int i = 0; i < N; i++) {\n        int cur = make_expr(before);\n        Expr &e = exprs[cur];\n        char c = S[i];\n\n        if (c == '(') {\n            e.type = Open;\n        } else if (c == ')') {\n            e.type = Close;\n        } else if (isdigit(c)) {\n            e.type = Num;\n            PII tmp = parse_num(i);\n            i = tmp.fst - 1; // ?????´\n            e.num = tmp.snd;\n        } else { // ope\n            e.type = Ope;\n            e.ope = c;\n            ope_idxes.PB(cur);\n        }\n\n        before = cur;\n    }\n}\n\nvoid remove_blocks(vector<Expr> &es, int i) {\n    while (true) {\n        int l = es[i].left;\n        int r = es[i].right;\n\n        if (l == -1 || r == -1) return;\n        if (es[l].type != Open || es[r].type != Close) return;\n\n        link2(es, es[l].left, i);\n        link2(es, i, es[r].right);\n    }\n}\n\npair<int, bool> calc(VI &idxes, vector<Expr> es) {\n    int val = es[(int)es.size() / 2].num;\n    \n    for (int i = 0; i < (int)idxes.size(); i++) {\n        int cur = idxes[i];\n        int left = es[cur].left;\n        int right = es[cur].right;\n\n        if (es[left].type == Close ||\n            es[right].type == Open ) {\n            return MP(1, false);\n        }\n\n        char ope = es[cur].ope;\n        int a = es[left].num;\n        int b = es[right].num;\n\n        // ?¨????\n        if (ope == '+') {\n            val = a + b;\n        } else if (ope == '-') {\n            val = a - b;\n        } else if (ope == '*') {\n            val = a * b;\n        } else if (ope == '/') {\n            if (b == 0) {\n                return MP(2, false);\n            }\n            val = a / b;\n        }\n\n        // ?????????\n        Expr new_expr;\n        int new_idx = es.size();\n        es.PB(new_expr);\n        link2(es, es[left].left, new_idx);\n        link2(es, new_idx, es[right].right);\n\n        // ??¬??§??????????????????????????¬??§?????????\n        remove_blocks(es, new_idx);\n    }\n\n    return MP(val, true);\n}\n\nint solve() {\n    parse();\n\n    set<int> anses;\n\n    sort(ALL(ope_idxes));\n\n    do {\n        auto ans = calc(ope_idxes, exprs);\n        if (ans.snd) {\n            anses.insert(ans.fst);\n        }\n    } while (next_permutation(ALL(ope_idxes)));\n\n    return anses.size();\n}\n\nint main(void) {\n    while (cin >> S, S != \"#\") {\n        N = S.size();\n        cout << solve() << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <set>\n#include <vector>\nusing namespace std;\n\nstring str;\n\nvoid calc(char op, const set<int> a, const set<int> b, set<int>& dest) {\n    for (const int v : a) {\n        for (const int w : b) {\n            if (op == '/' && w == 0) continue;\n            dest.insert(\n                op == '+' ? v + w :\n                op == '-' ? v - w :\n                op == '*' ? v * w :\n                            v / w\n            );\n        }\n    }\n}\n\nset<int> solve(int start, int end) {\n    vector<set<int>> nums;\n    vector<char> ops;\n    for (int idx = start; idx < end;) {\n        if (str[idx] == '(') {\n            int idx_ = idx+1;\n            for (int count = 1; ; ++idx_) {\n                if (str[idx_] == '(') count++;\n                if (str[idx_] == ')') {\n                    count--;\n                    if (count == 0) break;\n                }\n            }\n            set<int> t = solve(idx+1, idx_);\n            nums.push_back(t);\n            idx = idx_ + 1;\n        } else if (isdigit(str[idx])) {\n            int acc = 0;\n            while (idx < end && isdigit(str[idx]))\n                acc = 10 * acc + (str[idx++] - '0');\n            nums.push_back(set<int>{acc});\n        } else {\n            ops.push_back(str[idx++]);\n        }\n    }\n\n    int L = nums.size();\n    vector<vector<set<int>>> vs(nums.size());\n    for (int j = 0; j < L; ++j) {\n        vs[j].resize(L+1);\n        vs[j][j+1] = nums[j];\n    }\n\n    for (int w = 2; w <= L; ++w) {\n        for (int j = 0; j+w <= L; ++j) {\n            set<int> res;\n            for (int k = j+1; k < j+w; ++k) {\n                calc(ops[k-1], vs[j][k], vs[k][j+w], res);\n            }\n            vs[j][j+w] = res;\n        }\n    }\n\n    return vs[0][L];\n}\n\n\nint main() {\n    while (true) {\n        getline(cin, str);\n        if (str == \"#\") break;\n        cout << solve(0, str.size()).size() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n// Shrotening\n#define fst first\n#define snd second\n#define pb push_back\n\n// Loop\n#define FOR(i,a,b) for(auto i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(auto i=(a);i>=(b);--i)\n\n#define REP(i,a) for(long i=0;i<(a);++i)\n#define RREP(i,a) for(long i=(a);i>=0;--i)\n\n#define EACH(i,a) for(auto (i)=(a).begin(),_END=(a).end();i!=_END;++i)\n#define REACH(i,a) for(auto (i)=(a).rbegin(),_END=(a).rend();i!=_END;++i)\n\n//Algorithm\n#define ALL(a) (a).begin(), a.end()\n#define RALL(a) (a).rbegin(), a.rend()\n#define EXIST(a,x) ((a).find(x)!=(a).end())\n#define SORT(a) std::sort((a).begin(), (a).end())\n#define UNIQUE(a) std::sort((a).begin(), a.end()), a.erase(std::unique((a).begin(), a.end()), a.end());\n#define SUM(a) std::accumulate((a).begin(), (a).end(), 0);\n\n//Setting\n#define OPT std::cin.tie(0);std::ios::sync_with_stdio(false);\n\n//debug message\nbool debug = true;\n#define MSG(s)   if(debug){std::cout << s << std::endl;}\n#define DEBUG(x) if(debug){std::cout << \"debug(\" << #x << \"): \" << x << std::endl;}\n\n//alias\ntypedef long long LL;\ntypedef std::vector<char> VC;\ntypedef std::vector<int>  VI;\ntypedef std::vector<long> VL;\ntypedef std::vector<long long> VLL;\n\ntypedef std::vector< VC > VC2;\ntypedef std::vector< VI > VI2;\ntypedef std::vector< VL > VL2;\ntypedef std::vector< VLL > VLL2;\n\ntypedef std::pair<int,int> PII;\n\n\nstd::string str;\nint len;\n\nint inline calc(char op, int l, int r) {\n    return   op == '+' ? l + r\n           : op == '-' ? l - r\n           : op == '*' ? l * r\n           :             l / r;\n}\n\nbool inline isOperator(char c) {\n    return (c == '+' || c == '-' || c == '*' || c == '/');\n}\n\nbool isOperatorContain(int l, int r) {\n    int d = 0;\n    for(int i=l; i<=r; ++i) {\n        if(str[i] == '(') {\n            ++d;\n        }\n        if(str[i] == ')') {\n            --d;\n        }\n        if(d > 0) {\n            continue;\n        }\n\n        if(isOperator(str[i])) {\n            return true;\n        }\n    }\n    return false;\n}\n\nstd::map< std::pair<int,int>, std::set<int> > memo;\n\nstd::set<int> eval(int l, int r) {\n    std::pair<int,int> p = std::make_pair(l, r);\n    if(memo.count(p) > 0) {\n        return memo[p];\n    }\n\n    std::set<int> ans;\n    if(str[l] == '(' && str[r] == ')') {\n        ans = eval(l+1, r-1);\n    } else if(isOperatorContain(l, r)) {\n        int i = l, d = 0; //depth\n        while(i <= r) {\n            if(str[i] == '(') {\n                ++d;\n            }\n            if(str[i] == ')') {\n                --d;\n            }\n            if(d > 0) {\n                ++i;\n                continue;\n            }\n\n            if(isOperator(str[i])) {\n                char op = str[i];\n                auto left  = eval(l, i-1);\n                auto right = eval(i+1, r);\n                for(auto x: left) {\n                    for(auto y: right) {\n                        if(op == '/' && y == 0) {\n                            continue;\n                        }\n                        ans.insert(calc(op, x, y));\n                    }\n                }\n            }\n            ++i;\n        }\n    } else {\n        int v = 0;\n        int i = l;\n        while(i <= r && str[i] != ')') {\n            v *= 10;\n            v += (str[i] - '0');\n            ++i;\n        }\n        ans.insert(v);\n    }\n    memo.insert(std::make_pair(p, ans));\n    return ans;\n}\n\nint main() {\n    while(std::cin >> str, str != \"#\") {\n        memo.clear();\n        len = str.length();\n        auto pat = eval(0, len - 1);\n        std::cout << pat.size() << std::endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n\nstring s;\n\nbool isbalanced(int l, int r){\n    int p = 0;\n    for(int i=l;i<r;i++){\n        if(s[i]=='('){\n            p++;\n        }else if(s[i]==')'){\n            p--;\n            if(p<0)return false;\n        }\n    }\n    if(p==0)return true;\n    else return false;\n}\n\n\nbool isoperation(char ch){\n    if(ch=='+' || ch=='-' || ch=='*' || ch=='/')return true;\n    else return false;\n}\n\nvoid merge(set<int> &t, set<int> a, set<int> b, char op){\n    for(auto elma: a){\n        for(auto elmb: b){\n            if(op=='+'){\n                t.insert(elma+elmb);\n            }else if(op=='-'){\n                t.insert(elma-elmb);\n            }else if(op=='*'){\n                t.insert(elma*elmb);\n            }else{\n                assert(op=='/');\n                if(elmb==0)continue;\n                t.insert(elma/elmb);\n            }\n        }\n    }\n}\n\npii remove_bracket(int l, int r){\n    int lc = 0, rc = 0;\n    while(s[l+lc]=='(' && s[r-rc-1]==')'&&r-rc-1-l-lc>=2){\n        lc++, rc++;\n    }\n    \n    int p = 0;\n    for(int i=l+lc;i<r-rc;i++){\n        if(s[i]=='('){\n            p++;\n        }else if(s[i]==')'){\n            p--;\n            if(p<0){\n                p++;\n                lc--;\n            }\n        }\n    }\n    rc -= p;\n    \n    int v = min(lc,rc);\n    return pii(l+v, r-v);\n}\n\nbool used[201][201]={};\nset<int> dp[201][201];\nset<int> dfs(int l, int r){\n    if(used[l][r])return dp[l][r];\n    used[l][r] = true;\n    \n    if( not isbalanced(l,r) ){\n        return dp[l][r] = set<int>();\n    }\n    \n    int ld, rd;\n    tie(ld, rd) = remove_bracket(l,r);\n    \n    int num_of_op = 0;\n    for(int i=ld;i<rd;i++){\n        if( isoperation(s[i]) )num_of_op++;\n    }\n    if(num_of_op==0){\n        return dp[l][r] = set<int>{stoi(s.substr(ld,rd-ld))};\n    }\n\n    for(int i=ld;i<rd;i++){\n        if( isoperation(s[i]) ){\n            merge(dp[l][r], dfs(ld,i), dfs(i+1,rd), s[i]);\n        }\n    }\n    \n    return dp[l][r];\n}\n\n\nsigned main(){\n    while(cin>>s&&s!=\"#\"){\n        rep(i,201)rep(j,201){\n            used[i][j] = false;\n            dp[i][j].clear();\n        }\n        cout<<dfs(0,s.size()).size()<<endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <sstream>\n\nusing namespace std;\n\nset<int> m1[201][201];\nbool m2[201][201];\n\nint stoi(string s) {\n\tstringstream ss; ss << s;\n\tint ret; ss >> ret;\n\treturn ret;\n}\n\nstring str;\nset<int> dp(int l, int r) {\n\tif (m2[l][r]) return m1[l][r];\n\tif (str[l] == '(' && str[r-1] == ')') return dp(l+1, r-1);\n\n\tset<int> ret;\n\tbool f = true;\n\tfor (int i = l; i < r; ++i) {\n\t\tif (!isdigit(str[i])) f = false;\n\t}\n\tif (f) {\n\t\tret.insert( stoi(str.substr(l, r-l)) );\n\t\treturn m2[l][r] = true, m1[l][r] = ret;\n\t}\n\n\tint depth = 0;\n\tfor (int i = l; i < r; ++i) {\n\t\tswitch (str[i]) {\n\t\t\tcase '(':\n\t\t\t\t++depth;\n\t\t\t\tbreak;\n\n\t\t\tcase ')':\n\t\t\t\t--depth;\n\t\t\t\tbreak;\n\n\t\t\tcase '+':\n\t\t\tcase '-':\n\t\t\tcase '*':\n\t\t\tcase '/':\n\t\t\tif (depth == 0) {\n\t\t\t\tset<int> L = dp(l, i), R = dp(i+1, r);\n\t\t\t\tfor (set<int>::iterator j = L.begin(); j != L.end(); ++j) {\n\t\t\t\t\tfor (set<int>::iterator k = R.begin(); k != R.end(); ++k) {\n\t\t\t\t\t\tswitch (str[i]) {\n\t\t\t\t\t\t\tcase '+': ret.insert(*j+*k); break;\n\t\t\t\t\t\t\tcase '-': ret.insert(*j-*k); break;\n\t\t\t\t\t\t\tcase '*': ret.insert((*j)*(*k)); break;\n\t\t\t\t\t\t\tcase '/': if (*k) ret.insert((*j)/(*k)); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn m2[l][r] = true, m1[l][r] = ret;\n}\n\nint main() {\n\twhile (cin >> str, str != \"#\") {\n\t\tfill(&m2[0][0], &m2[0][0]+201*201, false);\n\t\tcout << dp(0, str.size()).size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 300\n\nset<int> calc(char *s){\n  int r, counter  = 0;\n  \n  for(r=0;;r++){\n    if(s[r] == '(') counter++;\n    if(s[r] == ')') counter--;\n    if(counter < 0) break;\n  }\n\n  set<int> num[11];\n  char op[11];\n\n  int pos = 0, curnum = 0, f = 0;\n  \n  for(int i=0;i<r;i++){\n    if(s[i] == '('){\n      num[pos] = calc(s+i+1);\n      int counter = 0;\n      while(1){\n        counter += (s[i] == '(') - (s[i] == ')');\n        if(counter < 0) break;\n        i++;\n      }\n      f = true;\n      continue;\n    }\n\n    if('0' <= s[i] && s[i] <= '9'){\n      curnum = curnum * 10 + (s[i] - '0');\n      continue;\n    }\n\n    if(!f)\n      num[pos] = {curnum};\n\n    op[pos] = s[i];\n    pos++;\n    curnum = 0;\n    f = false;\n  }\n  \n   if(!f) num[pos] = {curnum};\n   \n   if(pos == 0) return num[0];\n   \n  int per[11];\n  for(int i=0;i<pos;i++) per[i] = i;\n  \n  set<int> res;\n\n  \n  do{\n    bool used[11] = {};\n\n    set<int> temp[11];\n    for(int i=0;i<=pos;i++) temp[i] = num[i];\n    \n    for(int i=0;i<pos;i++){\n      int lnum = per[i];\n      int rnum = per[i]+1;\n\n      while(used[lnum]) lnum--;\n      while(used[rnum]) rnum++;\n      \n      set<int> cur;\n\n      for(int a : temp[lnum]){\n        for(int b : temp[rnum]){\n          switch(op[per[i]]){\n          case '+':\n            cur.insert(a + b);\n            break;\n          case '-':\n            cur.insert(a - b);\n            break;\n          case '*':\n            cur.insert(a * b);\n            break;\n          case '/':\n            cur.insert(a / b);\n            break;\n          }\n        }\n      }\n\n      temp[lnum] = cur;\n      used[rnum] = true;\n    }\n\n    for(int a: temp[0]){\n      res.insert(a);\n    }\n    \n  }while(next_permutation(per, per+pos));\n  \n  return res;\n}\n\nint solve(){\n  char formula[SIZE];\n\n  scanf(\"%s\", formula);\n  int n = strlen(formula);\n  formula[n] = ')';\n  n++;\n  \n  if(formula[0] == '#') return false;\n\n  printf(\"%d\\n\", (int)calc(formula).size());\n\n  return true;\n}\n\nint main(){\n  while(solve());\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nvector<int> perm(15);\n\nvector<ll> dfs(string s) {\n    vector<vector<ll>> num;\n    vector<char> op;\n\n    int i = 0;\n    while(i < s.length()) {\n        if ('0' <= s[i] && s[i] <= '9') {\n            int tmp = 0;\n            while(i < s.length() && '0' <= s[i] && s[i] <= '9') {\n                tmp = tmp * 10 + (s[i] - '0');\n                i++;\n            }\n            num.pb(vector<ll>(1, tmp));\n            i--;\n        } else if (s[i] == '(') {\n            int j = i + 1;\n            while(s[j] != ')') j++;\n            num.pb(dfs(s.substr(i + 1, j - i - 1)));\n            i = j;\n        } else {\n            op.pb(s[i]);\n        }\n        i++;\n    }\n\n    iota(all(perm), 0);\n    vector<ll> ans;\n    do {\n        vector<vector<ll>> v(num);\n\n        bool ok = true;\n        rep(i, op.size()) {\n            vector<ll> tmp;\n            int l = perm[i];\n            while(l >= 0 && v[l].empty()) l--;\n            if (l < 0) {\n                ok = false;\n                break;\n            }\n            rep(j, v[l].size()) {\n                rep(k, v[perm[i] + 1].size()) {\n                    switch(op[perm[i]]) {\n                        case '+':\n                        tmp.pb(v[l][j] + v[perm[i] + 1][k]); break;\n                        case '-':\n                        tmp.pb(v[l][j] - v[perm[i] + 1][k]); break;\n                        case '*':\n                        tmp.pb(v[l][j] * v[perm[i] + 1][k]); break;\n                        case '/':\n                        if (v[perm[i] + 1][k] != 0) tmp.pb(v[l][j] / v[perm[i] + 1][k]); break;\n                    }\n                }\n            }\n\n            if (tmp.size() == 0) {\n                ok = false;\n                break;\n            }\n            uni(tmp);\n            v[l] = tmp;\n            v[perm[i] + 1].clear();\n        }\n        if (ok) rep(i, v[0].size()) ans.pb(v[0][i]);\n    } while(next_permutation(perm.begin(), perm.begin() + op.size()));\n\n    uni(ans);\n    return ans;\n}\n\nint main(){\n    cin.sync_with_stdio(false);\n    string s;\n    while(cin >> s, s[0] != '#') {\n        cout << dfs(s).size() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\nusing namespace std;\n#define rep(i,a,b) for(auto (i)=(a);(i)<(b);(i)++)\n#define rev(i,a,b) for(auto (i)=(b)-1;(i)>=(a);(i)--)\n#define num_check(x) '0'<=(x)&&(x)<='9'\n\n\nstruct Siki{\n\tint num;\n\tchar type;\n\tint left, right;\n};\n\nint index[10];//各演算子のインデックス\nint pri[10];//各演算子の計算順序\nint min_pri[6];//各演算子のdepthごとの計算順序の最低値、これを破るとNG\nint op_size;\nSiki siki[30];\nSiki temp[30];\nint siki_size;\nstring input;\n\n\nbool check_pri(){\n\trep(i, 0, op_size){\n\t\tif (min_pri[siki[index[pri[i]]].num] > i)\n\t\t\treturn(false);\n\t}\n\treturn(true);\n}\n\nmap<int, int> data;\nvoid init(){\n\tdata.clear();\n\trep(i, 0, 30)siki[i].num = 0;\n\tint d=0;siki_size =op_size= 0;\n\trep(i, 0, 6)min_pri[i] = 0;\n\t//(3)+(1+(2*3-3)+5)+2*3\n\trep(i, 0u, input.length()){\n\t\tif (num_check(input[i])){\n\t\t\tsiki[siki_size].num *= 10, siki[siki_size].type = 'c', siki[siki_size].num += input[i] - '0';\n\t\t\tif (i + 1 == input.length() || !(num_check(input[i+1])))\n\t\t\t\tsiki_size++;\n\t\t}\n\t\telse if (input[i] == '(')d++;\n\t\telse if (input[i] == ')')d--;\n\t\telse\n\t\t{\n\t\t\tsiki[siki_size].type = input[i];\n\t\t\tsiki[siki_size].num = d;\n\t\t\tpri[op_size] = op_size;\n\t\t\trep(j, d + 1, 6)min_pri[j]++;\n\t\t\tindex[op_size++] = siki_size++;\n\t\t}\n\t}\n\trep(i, 0, op_size){\n\t\tsiki[index[i] - 1].right = siki[index[i] + 1].left = index[i];\n\t\tsiki[index[i]].left = index[i] - 1;\n\t\tsiki[index[i]].right = index[i] + 1;\n\t}\n\tsiki[0].left = -1;siki[siki_size - 1].right = -1;\n\t\n}\n\n\n\nint calc(int l, char op, int r){\n\tswitch (op){\n\tcase '+':return(l + r);\n\tcase '-':return(l - r);\n\tcase '*':return(l * r);\n\tcase '/':return(l / r);\n\t}\n\treturn(0);\n}\n\nvoid parse(){\n\tint result; Siki *p,*r,*l;\n\trep(i, 0, siki_size)temp[i] = siki[i];\n\trev(i, 0, op_size){\n\t\tp = &temp[index[pri[i]]];\n\t\tl = &temp[p->left];\n\t\tr = &temp[p->right];\n\n//\t\tcout << l->num << p->type << r->num << \"=\";\n\t\tif (r->num == 0 && p->type == '/')return;\n\t\tresult=p->num = calc(l->num, p->type, r->num);\n//\t\tcout << p->num << endl;\n\t\tif(r->right>=0)temp[r->right].left = index[pri[i]];\n\t\tif (r->left >=0 )temp[l->left].right = index[pri[i]];\n\t\tp->left =l->left;\n\t\tp->right = r->right;\n\t}\n//\tcout << result << endl;\n\tdata[result]++;\n}\n\n\nvoid p(int d, int dm){\n\tif (d == dm){\n\t\tif (check_pri()){\n\t\t\tparse();\n\t\t}\n\t}\n\trep(i, d, dm){\n\t\tswap(pri[d], pri[i]);\n\t\tp(d + 1, dm);\n\t\tswap(pri[d], pri[i]);\n\t}\n}\n\n\n\nint main(void){\n\twhile (true){\n\t\tcin >> input;\n\t\tif (input[0] == '#')break;\n\t\tinit();\n\t\t/*\t\n\t\trep(i, 0, siki_size)if (siki[i].type == 'c')printf(\"%d\", siki[i].num); else printf(\"%c\", siki[i].type); cout << endl;\n\t\trep(i, 0, op_size)printf(\"%c\", siki[index[i]].type); cout << endl;\n\t\trep(i, 0, op_size)printf(\"%d\", min_pri[siki[index[i]].num]); cout << endl;\n\t\t*/\n\t\tp(0, op_size);\n\t\tcout << data.size() << endl;\n\t}\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring s, op;\nvector<long long> memo, dep, v;\nstack<long long> st;\nset<long long> answers;\n\nlong long solve();\n\nint main() {\n  while(1) {\n    cin >> s;\n    if(s == \"#\") break;\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nlong long solve() {\n  long long height = 0, n = s.size();\n  op = \"\";\n  memo.clear();\n  v.clear();\n  dep.clear();\n  answers.clear();\n  for(int i = 0; i < n;) {\n    if(s[i] == '(')\n      ++height, ++i;\n    else if(s[i] == ')')\n      --height, ++i;\n    else if(isdigit(s[i])) {\n      long long now = 0;\n      while(i < n && isdigit(s[i])) {\n        now *= 10;\n        now += s[i] - '0';\n        ++i;\n      }\n      memo.push_back(now);\n    }\n    else {\n      op += s[i];\n      dep.push_back(height);\n      v.push_back(v.size());\n      ++i;\n    }\n  }\n  n = v.size();\n  if(n == 0) return 1;\n  do {\n    bool ch = 1;\n    height = dep[v[0]];\n    for(int i = 0; i < n; ++i)\n      if(dep[v[i]] <= height)\n        height = dep[v[i]];\n      else\n        ch = 0;\n    if(!ch) continue;\n    st.push(memo[n]);\n    for(int i = n - 1; i >= 0; --i) {\n      st.push(i);\n      st.push(memo[i]);\n    }\n    ch = 1;\n    for(int t = 0; t < n; ++t) {\n      stack<long long> tmp;\n      while(1) {\n        tmp.push(st.top());\n        st.pop();\n        if(st.top() == v[t]) break;\n        tmp.push(st.top());\n        st.pop();\n      }\n      st.pop();\n      char nowop = op[v[t]];\n      long long x = tmp.top(), y = st.top();\n      st.pop();\n      tmp.pop();\n      if(nowop == '+')\n        st.push(x + y);\n      else if(nowop == '-')\n        st.push(x - y);\n      else if(nowop == '*')\n        st.push(x * y);\n      else {\n        if(y == 0) {\n          ch = 0;\n          while(!st.empty()) st.pop();\n          break;\n        }\n        st.push(x / y);\n      }\n      while(!tmp.empty()) {\n        st.push(tmp.top());\n        tmp.pop();\n      }\n    }\n    if(!ch) continue;\n    answers.insert(st.top());\n    st.pop();\n    assert(st.empty());\n  } while(next_permutation(v.begin(), v.end()));\n  return answers.size();\n}\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\n\n//// algorithm ////\n\n// 文字列の置換\nvoid inplaceReplace(string &target, const string &from, const string &to, bool global = false)\n{\n\tdo\n\t{\n\t\tstring::size_type pos = target.find(from);\n\t\tif (pos == target.npos) { break; }\n\t\ttarget.replace(pos, from.length(), to);\n\t} while (true);\n}\n\n// 文字列の分割\nvector<string> split(const string &str, const string &s, bool removeEmpty = false)\n{\n\tvector<string> ret;\n\tsize_t p = 0, sl = s.size();\n\twhile (true)\n\t{\n\t\tsize_t q = str.find(s, p);\n\t\tif (q == str.npos) break;\n\t\tret.push_back(str.substr(p, q - p));\n\t\tp = q + sl;\n\t}\n\tret.push_back(str.substr(p));\n\tif (removeEmpty) ret.erase(remove(allof(ret), string()), ret.end());\n\treturn ret;\n}\n\n// 対応する括弧のインデクス\nint findbrace(const string &str, int l)\n{\n\tstack<char> stack;\n\tFOR(i, l, str.size())\n\t{\n\t\tswitch (str[i])\n\t\t{\n#define CASE(x,y) case x: stack.push(str[i]); break; case y: if(stack.top() != x) return -2; stack.pop(); break\n\t\t\tCASE('(', ')');\n\t\t\tCASE('[', ']');\n\t\t\tCASE('<', '>');\n\t\t\tCASE('{', '}');\n#undef  CASE\n\t\t}\n\t\tif (stack.size() == 0) return i;\n\t}\n\treturn -1;\n}\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nset<int> eval(const string &str, int l, int r)\n{\n\tvector<set<int>> operands;\n\tvector<char> operators(1);\n\n\t// 式を読む\n\tint val = 0;\n\tFOR(p, l, r)\n\t{\n\t\tif (isdigit(str[p]))\n\t\t{\n\t\t\tval = val * 10 + str[p] - '0';\n\t\t}\n\t\telse if (str[p] == '(')\n\t\t{\n\t\t\toperands.push_back(eval(str, p + 1, findbrace(str, p)));\n\t\t\tp = findbrace(str, p);\n\t\t\tval = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (val >= 0)\n\t\t\t{\n\t\t\t\toperands.push_back(set<int>({ val }));\n\t\t\t}\n\t\t\tval = 0;\n\t\t\toperators.push_back(str[p]);\n\t\t}\n\t}\n\t\n\tif (val >= 0)\n\t{\n\t\toperands.push_back(set<int>({ val }));\n\t\tval = 0;\n\t}\n\n\tset<int> result;\n\n\t// よんだ\n\tint n = operands.size();\n\tvector<vector<set<int> > > dp(n + 1, vector<set<int>>(n + 1)); // [l][r] 範囲[l,r)のオペランドを計算して出てくる整数セット\n\t\n\tREP(i, n) dp[i][i + 1] = operands[i];\n\tFOR(i, 2, n + 1) // 統合幅\n\t{\n\t\tREP(j, n - i + 1) // 始点 j から i 文字\n\t\t{\n\t\t\tFOR(k, 1, i) // jからk文字と j+kからi-k文字\n\t\t\t{\n\t\t\t\tint s = j;\n\t\t\t\tint m = j + k;\n\t\t\t\tint e = j + i;\n\t\t\t\t// WRITE(\"sme\", s, m, e);\n\t\t\n\t\t\t\t// 演算\n\t\t\t\tfor (int x : dp[s][m]) for (int y : dp[m][e])\n\t\t\t\t{\n\t\t\t\t\tswitch (operators[m])\n\t\t\t\t\t{\n\t\t\t\t\tcase '+': dp[s][e].insert(x + y); break;\n\t\t\t\t\tcase '-': dp[s][e].insert(x - y); break;\n\t\t\t\t\tcase '*': dp[s][e].insert(x * y); break;\n\t\t\t\t\tcase '/': if (y) dp[s][e].insert(x / y); break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][n];\n}\n\nvoid solve()\n{\n\tint testcases = INF;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(string, expr);\n\t\tif (expr == \"#\") { break; }\n\t\tWRITE(eval(expr, 0, expr.size()).size());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\nset<int> dp[200][200];\t//closed\nstring s;\nvoid num(int &x){\n\tint ret=0,y=x;\n\twhile(isdigit(s[y])){\n\t\tret*=10;\n\t\tret+=s[y]-'0';\n\t\ty++;\n\t}\n\tdp[x][y-1].insert(ret);\n\tx=y;\n}\nint main(){\n\twhile(true){\n\t\tcin>>s;\n\t\tif(s[0]=='#') break;\n\t\tint N=s.size();\n\t\trep(i,N) rep(j,N) dp[i][j].clear();\n\t\tfor(int x=0;x<N;x++){\n\t\t\tif(isdigit(s[x])) num(x);\n\t\t}\n\t\trep(d,N) rep(x,N-d){\n\t\t\tint y=x+d;\n\t\t\tif(s[x]=='('&&s[y]==')'){\n\t\t\t\tdp[x][y]=dp[x+1][y-1];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int m=x+1;m<=y-1;m++){\n\t\t\t\tif(s[m]=='+'){\n\t\t\t\t\tfor(int a:dp[x][m-1]) for(int b:dp[m+1][y]) dp[x][y].insert(a+b);\n\t\t\t\t}\n\t\t\t\tif(s[m]=='-'){\n\t\t\t\t\tfor(int a:dp[x][m-1]) for(int b:dp[m+1][y]) dp[x][y].insert(a-b);\n\t\t\t\t}\n\t\t\t\tif(s[m]=='*'){\n\t\t\t\t\tfor(int a:dp[x][m-1]) for(int b:dp[m+1][y]) dp[x][y].insert(a*b);\n\t\t\t\t}\n\t\t\t\tif(s[m]=='/'){\n\t\t\t\t\tfor(int a:dp[x][m-1]) for(int b:dp[m+1][y]) if(b!=0) dp[x][y].insert(a/b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dp[0][s.size()-1].size()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nstruct State {\n    int pos;\n    string str;\n    State(string s) : pos(0), str(move(s)) {}\n    char get() { return str[pos]; }\n    char next() { return str[pos++]; }\n    char prev() { return str[pos--]; }\n    bool is_end() { return pos == str.size(); }\n};\n\nenum ElemType {\n    INT,\n    OP_ADD,\n    OP_SUB,\n    OP_MUL,\n    OP_DIV,\n    L_PAR,\n    R_PAR,\n    NIL,\n};\n\nstruct Elem {\n    ElemType type;\n    int value;\n    Elem() {}\n    Elem(ElemType type) : type(type) {}\n};\n\nlist<Elem> lexer(State &state) {\n    if (state.is_end()) {\n        Elem e;\n        e.type = NIL;\n        return {e};\n    }\n\n    Elem e;\n    e.value = -100;\n    switch (state.get()) {\n    case '(': e.type = L_PAR; break;\n    case ')': e.type = R_PAR; break;\n    case '+': e.type = OP_ADD; break;\n    case '-': e.type = OP_SUB; break;\n    case '*': e.type = OP_MUL; break;\n    case '/': e.type = OP_DIV; break;\n    default:\n        e.type = INT;\n        int value = 0;\n        while ('0' <= state.get() && state.get() <= '9') {\n            value *= 10;\n            value += state.get() - '0';\n            state.next();\n        }\n        e.value = value;\n        state.prev();\n        break;\n    }\n    state.next();\n\n    auto ret = lexer(state);\n    ret.push_front(e);\n    return ret;\n}\n\nvoid print(list<Elem>::iterator left, list<Elem>::iterator right) {\n    if (left == right) {\n        cout << endl;\n        return;\n    }\n\n    switch (left->type) {\n    case INT:\n        cout << \"INT: \" << left->value << \", \";\n        break;\n    case OP_ADD:\n        cout << \"OP_ADD, \";\n        break;\n    case OP_SUB:\n        cout << \"OP_SUB, \";\n        break;\n    case OP_MUL:\n        cout << \"OP_MUL, \";\n        break;\n    case OP_DIV:\n        cout << \"OP_DIV, \";\n        break;\n    case L_PAR:\n        cout << \"L_PAR, \";\n        break;\n    case R_PAR:\n        cout << \"R_PAR, \";\n        break;\n    case NIL:\n        cout << \"NIL, \";\n        break;\n    }\n\n    print(next(left), right);\n}\n\nvoid simplify(list<Elem> &elems, list<Elem>::iterator itr) {\n    while (prev(itr)->type == L_PAR && next(itr)->type == R_PAR) {\n        elems.erase(prev(itr));\n        elems.erase(next(itr));\n    }\n}\n\nbool check_bothside(list<Elem>::iterator itr) {\n    return (prev(itr)->type != R_PAR && next(itr)->type != L_PAR);\n}\n\nsigned main() {\n    while (1) {\n        string s;\n        cin >> s;\n        if (s == \"#\") break;\n\n        State state(s);\n        auto elems = lexer(state);\n        elems.emplace_front(NIL);\n\n\n        int op_num = 0;\n        for (auto itr = next(elems.begin()); itr != prev(elems.end()); itr++) {\n            if (itr->type == OP_ADD || itr->type == OP_SUB || itr->type == OP_MUL || itr->type == OP_DIV) {\n                op_num++;\n            }\n            simplify(elems, itr);\n        }\n        vector<int> ord(op_num);\n        for (int i = 0; i < ord.size(); i++) ord[i] = i;\n\n        set<int> values;\n        do {\n            if (op_num == 0) break;\n\n            auto tmp = elems;\n            vector<list<Elem>::iterator> ops;\n            for (auto itr = tmp.begin(); itr != tmp.end(); itr++) {\n                if (itr->type == OP_ADD || itr->type == OP_SUB || itr->type == OP_MUL || itr->type == OP_DIV) {\n                    ops.push_back(itr);\n                }\n            }\n\n            bool invalid = false;\n            for (int i = 0; i < ord.size(); i++) {\n                int idx = ord[i];\n                if (!check_bothside(ops[idx])) {\n                    invalid = true;\n                    break;\n                }\n\n                int a = prev(ops[idx])->value;\n                int b = next(ops[idx])->value;\n                switch (ops[idx]->type) {\n                case OP_ADD:\n                    ops[idx]->value = a + b;\n                    break;\n                case OP_SUB:\n                    ops[idx]->value = a - b;\n                    break;\n                case OP_MUL:\n                    ops[idx]->value = a * b;\n                    break;\n                case OP_DIV:\n                    if (b == 0) {\n                        invalid = true;\n                        break;\n                    }\n                    ops[idx]->value = a / b;\n                    break;\n                default:\n                    assert(false);\n                }\n                if (invalid) break;\n                \n                ops[idx]->type = INT;\n                tmp.erase(next(ops[idx]));\n                tmp.erase(prev(ops[idx]));\n                simplify(tmp, ops[idx]);\n            }\n            if (invalid) continue;\n            values.insert(next(tmp.begin())->value);\n        } while (next_permutation(ord.begin(), ord.end()));\n\n        if (op_num == 0) {\n            values.insert(next(elems.begin())->value);\n        }\n        cout << values.size() << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cctype>\n#include <set>\n#include <iostream>\nusing namespace std;\ntypedef string::const_iterator State;\n\nset<int> number(State &begin);\nset<int> factor(State &begin);\nset<int> expression(State &begin);\n\nset<int> number(State &begin){\n\tint ret=0;\n\twhile(isdigit(*begin)){\n\t\tret*=10;\n\t\tret+=*begin-'0';\n\t\tbegin++;\n\t}\n\tset<int> s;\n\ts.insert(ret);\n\treturn s;\n}\n\nset<int> factor(State &begin){\n\tif(*begin=='('){\n\t\tbegin++;\n\t\tset<int> ret=expression(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nset<int> dp[11][11];\n\nset<int> expression(State &begin){\n\tset<int> ret;\n\tvector<string> ex;\n\tvector<set<int> >  s;\n\ts.push_back(factor(begin));\n\twhile(1){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tex.push_back(\"+\");\n\t\t\ts.push_back(factor(begin));\n\t\t}else if(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tex.push_back(\"-\");\n\t\t\ts.push_back(factor(begin));\n\t\t}else if(*begin=='*'){\n\t\t\tbegin++;\n\t\t\tex.push_back(\"*\");\n\t\t\ts.push_back(factor(begin));\n\t\t}else if(*begin=='/'){\n\t\t\tbegin++;\n\t\t\tex.push_back(\"/\");\n\t\t\ts.push_back(factor(begin));\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\tint n=s.size();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tdp[i][j].clear();\n\t\t}\n\t\tdp[i][i]=s[i];\n\t}\n\tfor(int l=1;l<n;l++){\n\t\tfor(int i=0;i<n-l;i++){\n\t\t\tfor(int j=i;j<i+l;j++){\n\t\t\t\tfor(set<int>::iterator a=dp[i][j].begin();a!=dp[i][j].end();a++){\n\t\t\t\t\tfor(set<int>::iterator b=dp[j+1][i+l].begin();b!=dp[j+1][i+l].end();b++){\n\t\t\t\t\t\tif(ex[j]==\"+\"){\n\t\t\t\t\t\t\tdp[i][i+l].insert(*a+*b);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ex[j]==\"-\"){\n\t\t\t\t\t\t\tdp[i][i+l].insert(*a-*b);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ex[j]==\"*\"){\n\t\t\t\t\t\t\tdp[i][i+l].insert((*a)*(*b));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ex[j]==\"/\"){\n\t\t\t\t\t\t\tif(*b==0)continue;\n\t\t\t\t\t\t\tdp[i][i+l].insert((*a)/(*b));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][n-1];\n }\n\nint main(void){\n\tstring str;\n\twhile(1){\n\t\tcin >> str;\n\t\tif(str==\"#\")break;\n\t\tState begin=str.begin();\n\t\tprintf(\"%d\\n\",expression(begin).size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<cstring>\n#define foreach(t,p) for(t::iterator it=p.begin();it!=p.end();++it)\n#define FOREACH(t,p,tit) for(t::iterator tit=p.begin();tit!=p.end();++tit)\n#define REP(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef set<int> pp;\nstring ss;\n\npp solve(int f,int l)\n{\n\tpp ans;\n\tans.clear();\n\tbool ope=false;\n\tfor(int i=f;i<l;i++)\n\t{\n\t\tif(\n\t\t\t\tss[i]=='+'||\n\t\t\t\tss[i]=='-'||\n\t\t\t\tss[i]=='*'||\n\t\t\t\tss[i]=='/')ope = true;\n\t}\n\tif(!ope)\n\t{\n\t\tstring s = ss.substr(f,(l-f+1));\n\t\t//cout << s << endl;\n\t\tint t = atoi(s.c_str() );\n\t\tans.insert(t);\n\t\t//foreach(pp,ans)cout << *it << endl;\n\t\t//cout << atoi( (ss.substr(f,l+1)).c_str()) << endl ;\n\t\t//cout <<ss.substr(f,(l-f+1))<<endl;\n\t\treturn ans;\n\t}\n\n\tint ofs = 0;\n\tif(ss[f]=='('&& ss[l]==')'  ) ofs=1;\n\tint bo =0;\n\tfor(int i=f+ofs;i<l-ofs;i++)\n\t{\n\t\n\t\tif(ss[i]=='(') bo++;\n\t\tif(ss[i]==')') bo--;\n\n\t\tif((\tss[i]=='+'||ss[i]=='-'||ss[i]=='*'||ss[i]=='/')&&(bo==0))\n\t\t{\n\t\t\n\t\t\tpp ansl = solve(f+ofs,i-1);\n\t\t\tpp ansr = solve(i+1,l-ofs);\n\t\t\tif(ss[i]=='+')\n\t\t\t\tFOREACH(pp,ansl,iit)FOREACH(pp,ansr,jit)\n\t\t\t\t\tans.insert((*iit)+(*jit));\n\t\t\tif(ss[i]=='-')\n\t\t\t\tFOREACH(pp,ansl,iit)FOREACH(pp,ansr,jit)\n\t\t\t\t\tans.insert((*iit)-(*jit));\n\t\t\tif(ss[i]=='*')\n\t\t\t\tFOREACH(pp,ansl,iit)FOREACH(pp,ansr,jit)\n\t\t\t\t\tans.insert((*iit)*(*jit));\n\t\t\tif(ss[i]=='/')\n\t\t\t\tFOREACH(pp,ansl,iit)FOREACH(pp,ansr,jit)\n\t\t\t\t{\n\t\t\t\t\tif((*jit)!=0)\n\t\t\t\t\tans.insert((*iit)/(*jit));\n\t\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n\t\n}\n\nint main()\n{\n\twhile(cin >> ss &&(ss!=\"#\"))\n\t{\n\t\tpp anss = solve(0,ss.size()-1);\n\t\t//foreach(pp,anss)cout << *it << endl;\n\n\t\tcout << anss.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n//#define debug(x) cerr << #x << \" : \" << x << endl\n#define debug(...)\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << \" ! \" << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\nstruct Expr {\n    vector<char> op;\n    vector<string> expr;\n};\n\n\nclass Solver {\n  public:\n    string S;\n    int N;\n    vector<int> apply(vector<int> &A, vector<int> &B, char op) {\n        debug(A); debug(B); debug(op);\n        vector<int> res;\n        for(int a : A) for(int b : B) {\n                if(op == '+') res.push_back(a + b);\n                else if(op == '-') res.push_back(a - b);\n                else if(op == '*') res.push_back(a * b);\n                else if(op == '/' and b != 0) res.push_back(a / b);\n                else assert(0);\n            }\n        sort(all(res));\n        res.erase(unique(all(res)), res.end());\n        return res;\n    }\n    vector<int> calc2(vector<vector<int>> &nums, vector<char> ops) {\n        assert(nums.size() == ops.size() + 1);\n        vector<int> perm; rep(i, ops.size()) perm.push_back(i);\n        vector<int> res;\n        do {\n            debug(perm);\n            vector<vector<int>> nums2 = nums;\n            map<int, int> ref;\n            for(int i : perm) {\n                int ii = i;\n                int j = i + 1;\n                while(ref.count(i)) i = ref[i];\n                while(ref.count(j)) j = ref[j];\n                nums2[i] = apply(nums2[i], nums2[j], ops[ii]);\n                ref[j] = i;\n            }\n            assert(ref.size() == nums2.size() or ref.size() + 1 == nums2.size());\n            for(int n : nums2[0]) res.push_back(n);\n        } while(next_permutation(all(perm)));\n        sort(all(res));\n        res.erase(unique(all(res)), res.end());\n        return res;\n    }\n    vector<int> calc(int &i) {\n        debug(i); debug(S[i]);\n        int s = i;\n        if(isdigit(S[s])) {\n            while(i < N and isdigit(S[i])) i++;\n            return { stoi(S.substr(s, i - s)) };\n        }\n        assert(S[s] == '(');\n        i++;\n        vector<vector<int>> nums;\n        vector<char> ops;\n        bool started = false;\n        while(S[i] != ')') {\n            if(started) {\n                ops.push_back(S[i++]);\n            }\n            nums.push_back(calc(i));\n            started = true;\n        }\n        i++;\n        debug(nums);\n        debug(ops);\n        auto res = calc2(nums, ops);\n        cerr << \"@ \" << s << \" \" << res;\n        return res;\n    }\n\n    \n    bool solve() {\n        cin >> S;\n        if(S == \"#\") return 0;\n        S = \"(\" + S + \")\";\n        N = S.size();\n        debug(S);\n        int i = 0;\n        auto res = calc(i);\n        debug(res);\n        cout << res.size() << endl;\n        return 1;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(Solver().solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nset<int> ans;\nstring line; \nint len;\n\nint apply(char opr, int a, int b) {\n    if (opr == '+') return a + b;\n    if (opr == '-') return a - b;\n    if (opr == '*') return a * b;\n    if (opr == '/') return a / b;\n}\n\nvoid reduce(stack<int>& N, stack<char>& O) {\n    char opr = O.top(); O.pop();\n    int v = N.top(); N.pop();\n    int w = N.top(); N.pop();\n    if (opr == '/' && !v) return;\n    N.push(apply(opr, w, v));\n}\n\nvoid read(int i, stack<int> N, stack<char> O) {\n    if (i == len) {\n        while (O.size()) reduce(N, O);\n        ans.insert(N.top());\n        return;\n    }\n    if (line[i] >= '0') {\n        int v = 0;\n        while (i < len && line[i] >= '0') v *= 10, v += line[i++] - '0';\n\n        stack<int> dup = N;\n        dup.push(v);\n        read(i, dup, O);\n\n        if (N.empty() || O.empty() || O.top() == '(') return;\n        int w = N.top(); N.pop();\n        char opr = O.top(); O.pop();\n        if (opr == '/' && !v) return;\n        N.push(apply(opr, w, v));\n        read(i, N, O);\n        return;\n    }\n    if (line[i] == ')') {\n        while (O.top() != '(') reduce(N, O);\n        O.pop();\n        read(i+1, N, O);\n        return;\n    }\n    O.push(line[i]);\n    read(i+1, N, O);\n    return;\n}\n\nint main()\n{\n    while (1) {\n        ans.clear();\n        cin >> line;\n        len = line.length();\n        if (line == \"#\") break;\n        read(0, stack<int>(), stack<char>());\n        cout << ans.size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n// Shrotening\n#define fst first\n#define snd second\n#define pb push_back\n\n// Loop\n#define FOR(i,a,b) for(auto i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(auto i=(a);i>=(b);--i)\n\n#define REP(i,a) for(long i=0;i<(a);++i)\n#define RREP(i,a) for(long i=(a);i>=0;--i)\n\n#define EACH(i,a) for(auto (i)=(a).begin(),_END=(a).end();i!=_END;++i)\n#define REACH(i,a) for(auto (i)=(a).rbegin(),_END=(a).rend();i!=_END;++i)\n\n//Algorithm\n#define ALL(a) (a).begin(), a.end()\n#define RALL(a) (a).rbegin(), a.rend()\n#define EXIST(a,x) ((a).find(x)!=(a).end())\n#define SORT(a) std::sort((a).begin(), (a).end())\n#define UNIQUE(a) std::sort((a).begin(), a.end()), a.erase(std::unique((a).begin(), a.end()), a.end());\n#define SUM(a) std::accumulate((a).begin(), (a).end(), 0);\n\n//Setting\n#define OPT std::cin.tie(0);std::ios::sync_with_stdio(false);\n\n//debug message\nbool debug = true;\n#define MSG(s)   if(debug){std::cout << s << std::endl;}\n#define DEBUG(x) if(debug){std::cout << \"debug(\" << #x << \"): \" << x << std::endl;}\n\n//alias\ntypedef long long LL;\ntypedef std::vector<char> VC;\ntypedef std::vector<int>  VI;\ntypedef std::vector<long> VL;\ntypedef std::vector<long long> VLL;\n\ntypedef std::vector< VC > VC2;\ntypedef std::vector< VI > VI2;\ntypedef std::vector< VL > VL2;\ntypedef std::vector< VLL > VLL2;\n\ntypedef std::pair<int,int> PII;\n\n\nstd::string str;\nint len;\n\nint inline calc(char op, int l, int r) {\n    return   op == '+' ? l + r\n           : op == '-' ? l - r\n           : op == '*' ? l * r\n           :             l / r;\n}\n\nbool inline isOperator(char c) {\n    return (c == '+' || c == '-' || c == '*' || c == '/');\n}\n\nbool isOperatorContain(int l, int r) {\n    int d = 0;\n    for(int i=l; i<=r; ++i) {\n        if(str[i] == '(') {\n            ++d;\n        }\n        if(str[i] == ')') {\n            --d;\n        }\n        if(d > 0) {\n            continue;\n        }\n\n        if(isOperator(str[i])) {\n            return true;\n        }\n    }\n    return false;\n}\n\nstd::map< std::pair<int,int>, std::set<int> > memo;\n\nstd::set<int> eval(int l, int r) {\n    std::pair<int,int> p = std::make_pair(l, r);\n    if(memo.count(p) > 0) {\n        return memo[p];\n    }\n\n    std::set<int> ans;\n    if(str[l] == '(' && str[r] == ')') {\n        ans = eval(l+1, r-1);\n    } else if(isOperatorContain(l, r)) {\n        int i = l, d = 0; //depth\n        while(i <= r) {\n            if(str[i] == '(') {\n                ++d;\n            }\n            if(str[i] == ')') {\n                --d;\n            }\n            if(d > 0) {\n                ++i;\n                continue;\n            }\n\n            if(isOperator(str[i])) {\n                char op = str[i];\n                auto left  = eval(l, i-1);\n                auto right = eval(i+1, r);\n                for(auto x: left) {\n                    for(auto y: right) {\n                        if(op == '/' && y == 0) {\n                            continue;\n                        }\n                        ans.insert(calc(op, x, y));\n                    }\n                }\n            }\n            ++i;\n        }\n    } else {\n        int v = 0;\n        int i = l;\n        while(i <= r && str[i] != ')') {\n            v *= 10;\n            v += (str[i] - '0');\n            ++i;\n        }\n        ans.insert(v);\n    }\n    memo.insert(std::make_pair(p, ans));\n    return ans;\n}\n\nint main() {\n    while(std::cin >> str, str != \"#\") {\n        memo.clear();\n        len = str.length();\n        auto pat = eval(0, len - 1);\n        std::cout << pat.size() << std::endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <string>\n\nusing namespace std;\n\n#define whole(xs) (xs).begin(),(xs).end()\n#define uniq(xs) ((xs).erase(unique((xs).begin(), (xs).end()), (xs).end()))\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T> xs) {\n    if (xs.empty()) return os << \"[]\";\n    os << \"[\" << xs[0];\n    for (int i = 1; i < xs.size(); i++) os << \" \" << xs[i];\n    return os << \"]\";\n}\n\nstring s;\nbool input() {\n    getline(cin, s);\n    if (s == \"#\") return false;\n    return true;\n}\n\nbool check_op(char x) {\n    const string ops = \"+-*/(\";\n    if (ops.find(x) == string::npos) return false;\n    return true;\n}\n\nint calc(char op, int l, int r) {\n    switch (op) {\n        case '+': return l + r;\n        case '-': return l - r;\n        case '*': return l * r;\n        case '/': return l / r;\n        default: assert(0);\n    }\n}\n\nint number(const string& s, int& i) {\n    int x = 0;\n    while (i < s.size() && isdigit(s[i])) {\n        x = x * 10 + (s[i] - '0');\n        i++;\n    }\n    return x;\n}\n\nvector<int> dfs(const vector< vector<int> >& values, const vector<char>& ops);\nvector<int> expr(const string& s,int& i) {\n    vector<int> L;\n    if (s[i] == '(') {\n        i++;\n        L = expr(s, i);\n        assert(s[i] == ')');\n        i++;\n    } else {\n        L.push_back(number(s, i));\n    }\n    vector<char> ops;\n    vector< vector<int> > values;\n    values.push_back(L);\n    while (true) {\n        if (i == s.size() || s[i] == ')') break;\n        assert(check_op(s[i]));\n        ops.push_back(s[i]); i++;\n        vector<int> value;\n        if (s[i] == '(') {\n            i++;\n            value = expr(s, i);\n            assert(s[i] == ')');\n            i++;\n        } else {\n            value.push_back(number(s, i));\n        }\n        values.push_back(value);\n    }\n    assert(ops.size() + 1 == values.size());\n    return dfs(values, ops);\n}\n\nvector<int> dfs(const vector< vector<int> >& values, const vector<char>& ops) {\n    int N = ops.size();\n    if (N == 0) {\n        assert(values.size() == 1);\n        return values[0];\n    }\n    vector<int> ret;\n    for (int i = 0; i < N; i++) {\n        char op = ops[i];\n        vector< vector<int> > lvalues; for (int j = 0; j <= i; j++) lvalues.push_back(values[j]);\n        vector<char> lops; for (int j = 0; j < i; j++) lops.push_back(ops[j]);\n        vector< vector<int> > rvalues; for (int j = i + 1; j <= N; j++) rvalues.push_back(values[j]);\n        vector<char> rops; for (int j = i + 1; j < N; j++) rops.push_back(ops[j]);\n        vector<int> L = dfs(lvalues, lops);\n        vector<int> R = dfs(rvalues, rops);\n        assert(L.size() > 0);\n        assert(R.size() > 0);\n        for (int j = 0; j < L.size(); j++) {\n            for (int k = 0; k < R.size(); k++) {\n                if (op == '/' && R[k] == 0) continue;\n                ret.push_back(calc(op, L[j], R[k]));\n            }\n        }\n    }\n    sort(whole(ret));\n    uniq(ret);\n    if (false) {\n        cout << \"values: \" << values << endl;\n        cout << \"ops: \" << ops << endl;\n        cout << ret << endl;\n    }\n    return ret;\n}\n\nvoid solve() {\n    int i = 0;\n    cout << expr(s, i).size() << endl;\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<vector<int>,vector<char> > P;\n\nstring str;\nmap<P, vector<int> > m;\n\nint calc(int a, int b, char c){\n\tif(c == '+') return a+b;\n\tif(c == '*') return a*b;\n\tif(c == '-') return a-b;\n\tif(b == 0){\n\t\treturn MOD;\n\t} else{\n\t\treturn a/b;\n\t}\n}\n\nvector<int> fu(vector<int> v, vector<char> c){\n\tif(m[P(v,c)].size() > 0) return m[P(v,c)];\n\tvector<int> ret;\n\tif(c.size() == 0){\n\t\tret.push_back(v[0]);\n\t\tm[P(v,c)] = ret;\n\t\treturn ret;\n\t}\n\tvector<int> V;\n\tvector<char> C;\n\trep(i,c.size()){\n\t\tV.clear();\n\t\tC.clear();\n\t\tbool ok = true;\n\t\trep(j,v.size()){\n\t\t\tif(i != j){\n\t\t\t\tV.push_back(v[j]);\n\t\t\t\tif(j != v.size()-1) C.push_back(c[j]);\n\t\t\t} else{\n\t\t\t\tint tmp = calc(v[j],v[j+1],c[j]);\n\t\t\t\tif(tmp == MOD){\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tV.push_back(tmp);\n\t\t\t\tif(j+1 != v.size()-1) C.push_back(c[j+1]);\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tif(!ok) continue;\n\t\tV = fu(V,C);\n\t\trep(j,V.size()) ret.push_back(V[j]);\n\t}\n\tm[P(v,c)] = ret;\n\treturn ret;\n}\n\nvector<int> fun(vector<vector<int> > v, vector<char> c, vector<int> z, int cnt){\n\tvector<int> x;\n\tif(v[cnt].size() == 0){\n\t\treturn fu(z,c);\n\t}\n\tvector<int> tmp;\n\trep(i,v[cnt].size()){\n\t\tz.push_back(v[cnt][i]);\n\t\ttmp.clear();\n\t\ttmp = fun(v,c,z,cnt+1);\n\t\trep(j,tmp.size()) x.push_back(tmp[j]);\n\t\tz.pop_back();\n\t}\n\treturn x;\n}\n\nvector<int> func(string s){\n\tint cont = 0;\n\tvector<vector<int> > v;\n\tv.resize(12);\n\tvector<char> c;\n\trep(i,s.size()){\n\t\tif(s[i] == '('){\n\t\t\tint cnt = 0;\n\t\t\tstring tmp;\n\t\t\twhile(true){\n\t\t\t\ti++;\n\t\t\t\tif(s[i] == '(') cnt++;\n\t\t\t\tif(s[i] == ')' && cnt == 0) break;\n\t\t\t\tif(s[i] == ')') cnt--;\n\t\t\t\ttmp.push_back(s[i]);\n\t\t\t}\n\t\t\tv[cont] = func(tmp);\n\t\t} else if('0' <= s[i] && s[i] <= '9'){\n\t\t\tint num = s[i]-'0';\n\t\t\twhile(true){\n\t\t\t\tif(i == s.size()-1) break;\n\t\t\t\tif('0'<=s[i+1]&&s[i+1]<='9'){\n\t\t\t\t\ti++;\n\t\t\t\t\tnum *= 10;\n\t\t\t\t\tnum += s[i]-'0';\n\t\t\t\t} else break;\n\t\t\t}\n\t\t\tv[cont].push_back(num);\n\t\t} else{\n\t\t\tc.push_back(s[i]);\n\t\t\tcont++;\n\t\t}\n\t}\n\tvector<int> z;\n\treturn fun(v, c, z, 0);\n}\n\nvoid solve(){\n\tm.clear();\n\tvector<int> v = func(str);\n\tsort(v.begin(),v.end());\n\tv.erase(unique(v.begin(),v.end()),v.end());\n\tcout << v.size() << endl;\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> str;\n\t\tif(str == \"#\") break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <tuple>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nint Div(int a, int b){\n\tint sign=1;\n\tif(a<0){\n\t\ta=-a;\n\t\tsign=-1;\n\t}\n\tif(b<0){\n\t\tb=-b;\n\t\tsign=-sign;\n\t}\n\treturn sign*(a/b);\n}\nvoid f(string str, vector<int>& vals)\n{\n\t//cout << str << endl;\n\tint level=0;\n\tint dsize=0;\n\tbool level0=false;\n\tfor(int i=0;i<str.size();i++){\n\t\tswitch(str[i]){\n\t\t\tcase '(':\n\t\t\t\tlevel++;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tlevel--;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\tcase '-':\n\t\t\tcase '*':\n\t\t\tcase '/':\n\t\t\t\tif(level==0){\n\t\t\t\t\tlevel0=true;\n\t\t\t\t\tvector<int> v1;\n\t\t\t\t\tvector<int> v2;\n\t\t\t\t\tf(str.substr(0,i),v1);\n\t\t\t\t\tf(str.substr(i+1,str.size()-(i+1)),v2);\n\t\t\t\t\tfor(auto a:v1){\n\t\t\t\t\t\tfor(auto b:v2){\n\t\t\t\t\t\t\tswitch(str[i]){\n\t\t\t\t\t\t\t\tcase '+':vals.push_back(a+b);break;\n\t\t\t\t\t\t\t\tcase '*':vals.push_back(a*b);break;\n\t\t\t\t\t\t\t\tcase '-':\n\t\t\t\t\t\t\t\t\t\t vals.push_back(a-b);\n\t\t\t\t\t\t\t\t\t\t break;\n\t\t\t\t\t\t\t\tcase '/':\n\t\t\t\t\t\t\t\t\tif(b!=0){\n\t\t\t\t\t\t\t\t\t\tvals.push_back(Div(a,b));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdsize++;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif(vals.size()){\n\t\tsort(vals.begin(),vals.end());\n\t\tauto it=unique(vals.begin(),vals.end());\n\t\tvals.resize(it-vals.begin());\n\t}\n\telse if (dsize==str.size()){\n\t\tistringstream istr(str);\n\t\tint v;\n\t\tistr >> v;\n\t\tvals.push_back(v);\n\t}\n\telse if (!level0)\n\t{\n\t\tf(str.substr(1,str.size()-2),vals);\n\t}\n\t//cout << str << \", \" << level0 << \", \" << dsize << \", \" << str.size() << \": \" << vals.size() << endl;\n}\nint main() {\n\tstring str;\n\twhile(cin >> str){\n\t\tif(str==\"#\"){\n\t\t\treturn 0;\n\t\t}\n\t\tvector<int> v;\n\t\tf(str,v);\n\t\tcout << v.size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 205\nusing namespace std;\ntypedef pair<int,int> P;\nvector<int> memo[N][N];\nint p,d[N],dlen;\nstring s;\n \nint getNum(){\n  int res=0;\n  while('0'<=s[p]&&s[p]<='9')\n    res=res*10+s[p++]-'0';\n  return res;\n}\n \nvoid comp(){\n  int slen=s.size(),idx=0;\n  while(s[p]!='x'){\n    if('0'<=s[p]&&s[p]<='9')\n      d[idx++]=getNum(),p--;\n    if(s[p]=='(')d[idx++]=-1;\n    if(s[p]==')')d[idx++]=-2;\n    if(s[p]=='+')d[idx++]=-3;\n    if(s[p]=='-')d[idx++]=-4;\n    if(s[p]=='*')d[idx++]=-5;\n    if(s[p]=='/')d[idx++]=-6;\n    p++;\n  }\n  d[idx++]=-7;\n  dlen=idx;\n}\n \nvoid dfs(){\n  vector<int> v2;\n  vector<P> v;\n  int S=max(0,p-1);\n  while(d[p]!=-2&&d[p]!=-7){\n    if(d[p]>=0)v.push_back(P(p,p)),p++;\n    else if(d[p]==-1){\n      int b=p++;\n      dfs();\n      v.push_back(P(b,p));\n      p++;\n    }\n    else if(d[p]==-3)p++,v2.push_back(-3);\n    else if(d[p]==-4)p++,v2.push_back(-4);\n    else if(d[p]==-5)p++,v2.push_back(-5);\n    else if(d[p]==-6)p++,v2.push_back(-6);\n  }\n  int E=p;\n  if(d[S+1]==-1&&d[E-1]==-2)\n    for(int i=0;i<memo[S+1][E-1].size();i++)\n      memo[S][E].push_back(memo[S+1][E-1][i]);\n  if(S+1==E-1)memo[S][E].push_back(memo[S+1][E-1][0]);\n  for(int l=2;l<=v.size();l++){\n    for(int i=0;i<=v.size()-l;i++){\n      int j=i+l-1;\n      for(int k=i;k<j;k++){\n\tint A=v[i].first,B=v[k].second;\n\tint C=v[k+1].first,D=v[j].second;\n\tfor(int n=0;n<memo[A][B].size();n++){\n\t  int num1=memo[A][B][n];\n\t  for(int m=0;m<memo[C][D].size();m++){\n\t    int num2=memo[C][D][m];\n\t    if(v2[k]==-6&&!num2)continue;\n\t    if(l!=v.size()){\n\t      if(v2[k]==-3)memo[A][D].push_back(num1+num2);\n\t      if(v2[k]==-4)memo[A][D].push_back(num1-num2);\n\t      if(v2[k]==-5)memo[A][D].push_back(num1*num2);\n\t      if(v2[k]==-6)memo[A][D].push_back(num1/num2);\n\t    }else{\n\t      if(v2[k]==-3)memo[S][E].push_back(num1+num2);\n\t      if(v2[k]==-4)memo[S][E].push_back(num1-num2);\n\t      if(v2[k]==-5)memo[S][E].push_back(num1*num2);\n\t      if(v2[k]==-6)memo[S][E].push_back(num1/num2);\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n}\n \nint main(){\n  while(true){\n    cin>>s;\n    if(s==\"#\")break;\n    s='('+s+')'+'x';\n    p=0; comp();\n    for(int i=0;i<dlen;i++)\n      if(d[i]>=0)\n\tmemo[i][i].push_back(d[i]);\n    p=0; dfs();\n    set<int> ans;\n    for(int i=0;i<memo[0][dlen-2].size();i++)\n      ans.insert(memo[0][dlen-2][i]);\n    cout<<ans.size()<<endl;\n    ans.clear();\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n\tmemo[i][j].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring s;\nvector<vector<bool>> visited;\nvector<vector<set<int>>> dp;\n\nvoid init() {\n\tvisited = vector<vector<bool>>(210, vector<bool>(210, false));\n\tdp = vector<vector<set<int>>>(210, vector<set<int>>(210));\n}\n\nbool number(int l, int r) {\n\tif(r <= l) return false;\n\tint ret = 0;\n\tfor(int i = l; i < r; ++i) {\n\t\tret *= 10;\n\t\tif(s[i] < '0' or '9' < s[i]) return false;\n\t\tret += (s[i] - '0');\n\t}\n\t// fprintf(stderr, \"[%d, %d) : %d\\n\", l, r, ret);\n\tthrow ret;\n}\n\nset<int> dfs(int l, int r) {\n\tif(r <= l) return {};\n\tif(visited[l][r]) return dp[l][r];\n\tif(s[l] == '(') {\n\t\tint depth = 0;\n\t\tbool flg = 1;\n\t\tfor(int i = l; i < r; ++i) {\n\t\t\tif(s[i] == '(') {\n\t\t\t\tdepth++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(s[i] == ')') {\n\t\t\t\tdepth--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(depth == 0) {\n\t\t\t\tflg = 0;\n\t\t\t}\n\t\t}\n\t\tif(flg and s[r - 1] == ')') return dfs(l + 1, r - 1);\n\t}\n\t// fprintf(stderr, \"[%d, %d)\\n\", l, r);\n\ttry {\n\t\tnumber(l, r);\n\t}\n\tcatch(int num) {\n\t\tdp[l][r].insert(num);\n\t\tvisited[l][r] = true;\n\t\treturn dp[l][r];\n\t}\n\tset<int> ret;\n\tint depth = 0;\n\tfor(int i = l; i < r; ++i) {\n\t\tif(s[i] == '(') {\n\t\t\tdepth++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(s[i] == ')') {\n\t\t\tdepth--;\n\t\t\tcontinue;\n\t\t}\n\t\tif(depth > 0) continue;\n\t\tif('0' <= s[i] and s[i] <= '9') continue;\n\t\tint lid = l, ldepth = 0;\n\t\tfor(int j = i - 1; j >= l; --j) {\n\t\t\tif(s[j] == ')') {\n\t\t\t\tldepth++;\n\t\t\t}\n\t\t\tif(s[j] == '(') {\n\t\t\t\tlid = j;\n\t\t\t\tldepth--;\n\t\t\t}\n\t\t\tif(ldepth < 0) break;\n\t\t\tlid = l;\n\t\t}\n\t\tset<int> left = dfs(lid, i);\n\t\tint rid = r, rdepth = 0;\n\t\tfor(int j = i + 1; j < r; ++j) {\n\t\t\tif(s[j] == '(') {\n\t\t\t\trdepth++;\n\t\t\t}\n\t\t\tif(s[j] == ')') {\n\t\t\t\trid = j + 1;\n\t\t\t\trdepth--;\n\t\t\t}\n\t\t\tif(rdepth < 0) break;\n\t\t\trid = r;\n\t\t}\n\t\tset<int> right = dfs(i + 1, rid);\n\t\tif(s[i] == '+') {\n\t\t\tfor(int ll : left) {\n\t\t\t\tfor(int rr : right) {\n\t\t\t\t\tret.insert(ll + rr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(s[i] == '-') {\n\t\t\tfor(int ll : left) {\n\t\t\t\tfor(int rr : right) {\n\t\t\t\t\tret.insert(ll - rr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(s[i] == '*') {\n\t\t\tfor(int ll : left) {\n\t\t\t\tfor(int rr : right) {\n\t\t\t\t\tret.insert(ll * rr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(s[i] == '/') {\n\t\t\tfor(int ll : left) {\n\t\t\t\tfor(int rr : right) {\n\t\t\t\t\tif(rr == 0) continue;\n\t\t\t\t\tret.insert(ll / rr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[l][r] = ret;\n\tvisited[l][r] = true;\n\t// fprintf(stderr, \"[%d, %d)\\n\", l, r);\n\t// for(int i : dp[l][r]) {\n\t// \tcerr << i <<endl;\n\t// }\n\treturn dp[l][r];\n}\n\nint main() {\n\twhile(cin >> s and s != \"#\") {\n\t\tinit();\n\t\tint n = s.size();\n\t\tset<int> ans = dfs(0, n);\n\t\t// for(int i : ans) {\n\t\t// \tcerr << i <<endl;\n\t\t// }\n\t\tcout << ans.size() << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\n#define ll long long\n#define lld long double\n#ifdef DEBUG\n#define line() cout << \"[\" << __LINE__ << \"] \";\n#define dump(i) cout << #i \": \" << i << \" \";\n#define dumpl(i) cout << #i \": \" << i << endl;\n#else\n#define line(i)\n#define dump(i)\n#define dumpl(i)\n#endif\nusing namespace std;\n\ntypedef string::const_iterator State;\nint num(State &begin);\nvoid consume(State &begin, char expected);\nset<int> expr(State &begin);\nint operate(int r, int l, char op);\nset<int> gen_pattern(vector<set<int>> &v, vector<char> op);\n\nclass ParseError\n{\n};\n\nint num(State &begin)\n{\n    int ret = 0;\n    while (isdigit(*begin))\n    {\n        ret = 10 * ret + (*begin) - '0';\n        begin++;\n    }\n    return ret;\n}\nvoid consume(State &begin, char expected)\n{\n    if (*begin == expected)\n    {\n        begin++;\n    }\n    else\n    {\n        cerr << \"expected:\" << expected << \", but got\" << *begin << endl;\n        cerr << \"rest string is\";\n        while (*begin)\n        {\n            cerr << *begin;\n            begin++;\n        }\n        cerr << endl;\n        throw ParseError();\n    }\n}\n\nset<int> term(State &begin)\n{\n    if (isdigit(*begin))\n    {\n\n        return set<int>{num(begin)};\n    }\n    if (*begin == '(')\n    {\n        begin++;\n        set<int> ret = expr(begin);\n        consume(begin, ')');\n        return ret;\n    }\n}\n\nset<int> expr(State &begin)\n{\n    vector<set<int>> v;\n    vector<char> op;\n    while (*begin != ')' && *begin)\n    {\n        set<int> val = term(begin);\n        v.push_back(val);\n        char c = *begin;\n        if (c == ')' || c == '\\0')\n            break;\n        assert(c == '+' || c == '-' || c == '*' || c == '/');\n        op.push_back(c);\n        begin++;\n    }\n    return gen_pattern(v, op);\n}\n\nint operate(int r, int l, char op)\n{\n    if (op == '+')\n    {\n        return r + l;\n    }\n    if (op == '*')\n    {\n        return r * l;\n    }\n    if (op == '-')\n    {\n        return r - l;\n    }\n    if (op == '/')\n    {\n        return r / l;\n    }\n}\n\nset<int> gen_pattern(vector<set<int>> &v, vector<char> op)\n{\n    if (op.empty())\n    {\n        assert(v.size() == 1);\n        return v[0];\n    }\n    set<int> ret;\n    rep(i, op.size())\n    {\n        auto _v = v;\n        auto _op = op;\n        set<int> tmp;\n        for (auto j : _v[i])\n        {\n            for (auto k : _v[i + 1])\n            {\n                if (_op[i] != '/' || k != 0)\n                    tmp.insert(operate(j, k, _op[i]));\n                else\n                    continue;\n            }\n        }\n\n        _v[i] = tmp;\n\n        _v.erase(_v.begin() + i + 1);\n\n        _op.erase(_op.begin() + i);\n\n        set<int> rec = gen_pattern(_v, _op);\n        ret.insert(rec.begin(), rec.end());\n    }\n    return ret;\n}\n\nint main(int argc, char const *argv[])\n{\n\n    while (true)\n    {\n        string s;\n        cin >> s;\n        if (s == \"#\")\n            break;\n        State begin = s.begin();\n        auto ret = expr(begin);\n        cout << ret.size() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef string::const_iterator state;\n\nint expression(state&);\n\nint number(state &begin){\n    int res=0;\n    while(isdigit(*begin)){\n        res*=10;\n        res+=*begin-'0';\n        ++begin;\n    }\n    return res;\n}\n\nint factor(state &begin){\n    if(*begin=='(' or *begin=='['){\n        begin++;\n        const int res=expression(begin);\n        begin++;\n        return res;\n    }else return number(begin);\n}\n\nint expression(state &begin){\n    int res=factor(begin);\n    if(res==inf) return inf;\n    while(true){\n        if(*begin=='+'){\n            ++begin;\n            res+=expression(begin);\n        }else if(*begin=='-'){\n            ++begin;\n            res-=expression(begin);\n        }else if(*begin=='*'){\n            ++begin;\n            res*=expression(begin);\n        }else if(*begin=='/'){\n            ++begin;\n            const int tmp=expression(begin);\n            if(tmp==0) return inf;\n            res/=tmp;\n        }else break;\n    }\n    return res;\n}\n\nvoid solve(){\n    while(true){\n        string str;\n        cin >> str;\n        if(str==\"#\") return;\n\n        set<int> res;\n        function<void(const string,const int,const int,const int)> rec=[&](const string s,const int idx,const int cnt1,const int cnt2){\n            if(cnt2<0) return;\n            if(idx==s.size()){\n                if(!cnt2){\n                    auto begin=s.begin();\n                    const int res_=expression(begin);\n                    if(res_!=inf) res.insert(res_);\n                }\n                return;\n            }\n            if(s[idx]=='('){\n                rec(s,idx+1,cnt1+1,cnt2);\n                return;\n            }\n            if(s[idx]==')'){\n                if(cnt2) return;\n                rec(s,idx+1,cnt1-1,cnt2);\n                return;\n            }\n            if(cnt2<10 and isdigit(s[idx]) and (!idx or !isdigit(s[idx-1]))){\n                auto s_=s;\n                s_.insert(idx,\"[\");\n                rec(s_,idx,cnt1,cnt2+1);\n            }\n            if(!cnt1 and cnt2 and isdigit(s[idx]) and (idx+1==s.size() or !isdigit(s[idx+1]))){\n                auto s_=s;\n                if(idx+1==s.size()) s_+=\"]\";\n                else s_.insert(idx+1,\"]\");\n                rec(s_,idx+1,cnt1,cnt2-1);\n            }\n            rec(s,idx+1,cnt1,cnt2);\n        };\n        rec(str,0,0,0);\n        cout << res.size() << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nvector<int> perm(15);\n\nvector<ll> dfs(string s) {\n    vector<vector<ll>> num;\n    vector<char> op;\n\n    int i = 0;\n    while(i < s.length()) {\n        if ('0' <= s[i] && s[i] <= '9') {\n            int tmp = 0;\n            while('0' <= s[i] && s[i] <= '9') {\n                tmp = tmp * 10 + (s[i] - '0');\n                i++;\n            }\n            num.pb(vector<ll>(1, tmp));\n            i--;\n        } else if (s[i] == '(') {\n            int j = i + 1;\n            while(s[j] != ')') j++;\n            num.pb(dfs(s.substr(i + 1, j - i - 1)));\n            i = j;\n        } else {\n            op.pb(s[i]);\n        }\n        i++;\n    }\n\n    iota(all(perm), 0);\n    vector<ll> ans;\n    do {\n        vector<vector<ll>> v(num);\n\n        bool ok = true;\n        rep(i, op.size()) {\n            vector<ll> tmp;\n            int l = perm[i];\n            while(l >= 0 && v[l].empty()) l--;\n            if (l < 0) {\n                ok = false;\n                break;\n            }\n            rep(j, v[l].size()) {\n                rep(k, v[perm[i] + 1].size()) {\n                    switch(op[perm[i]]) {\n                        case '+':\n                        tmp.pb(v[l][j] + v[perm[i] + 1][k]); break;\n                        case '-':\n                        tmp.pb(v[l][j] - v[perm[i] + 1][k]); break;\n                        case '*':\n                        tmp.pb(v[l][j] * v[perm[i] + 1][k]); break;\n                        case '/':\n                        if (v[perm[i] + 1][k] != 0) tmp.pb(v[l][j] / v[perm[i] + 1][k]); break;\n                    }\n                }\n            }\n\n            if (tmp.size() == 0) {\n                ok = false;\n                break;\n            }\n            uni(tmp);\n            v[l] = tmp;\n            v[perm[i] + 1].clear();\n        }\n        if (ok) rep(i, v[0].size()) ans.pb(v[0][i]);\n    } while(next_permutation(perm.begin(), perm.begin() + op.size()));\n\n    uni(ans);\n    return ans;\n}\n\nint main(){\n    cin.sync_with_stdio(false);\n    string s;\n    while(cin >> s, s[0] != '#') {\n        cout << dfs(s).size() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\nusing namespace std;\n\nset<int> dp[12][12];\n\nbool digit(char c){\n  if( c - '0'< 0 || c-'0' > 9)return false;\n  return true;\n}\n\nint stoi(string s){\n  int res,tmp;\n\n  res = 0;\n  tmp = 1;\n  for(int i=s.size()-1;i>=0;i--){\n    res += (s[i]-'0') * tmp;\n    tmp *= 10;\n  }\n  return res;\n}  \n\nset<int> cal(set<int> a,set<int> b,char o){\n  set<int> res;\n  set<int>::iterator i,j;\n  res.clear();\n\n  if(a.empty() || b.empty())return res;\n\n  if(o=='+'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tres.insert((*i) + (*j));\n      }\n    }\n  }else if(o=='-'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tres.insert((*i) - (*j));\n      }\n    }\n  }else if(o=='*'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tres.insert((*i) * (*j));\n      }\n    }\n  }else if(o=='/'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tif((*j))res.insert((*i) / (*j));\n      }\n    }\n  }\n  return res;\n}\n\nset<int> parse(string s){\n  string tmp;\n  set<int> ans[12];\n  char op[12];\n  int pos,cnt,check;\n\n  pos = 0;\n  cnt = 0;\n\n  while(1){\n    if(s[pos] == '('){\n      tmp.clear();\n      pos++;\n      check = 1;\n      while(1){\n\tif(s[pos] == '(')check++;\n\tif(s[pos] == ')')check--;\n\tif(!check)break;\n\ttmp.push_back(s[pos]);\n\tpos++;\n      }\n      ans[cnt].clear();\n      ans[cnt] = parse(tmp);\n      pos++;\n    }else if(digit(s[pos])){\n      tmp.clear();\n      while(pos<(int)s.size() && digit(s[pos])){\n\ttmp.push_back(s[pos]);\n\tpos++;\n      }\n      ans[cnt].clear();\n      ans[cnt].insert(stoi(tmp));\n    }\n    if(pos==(int)s.size())break;\n\n    op[cnt] = s[pos];\n    cnt++;\n    pos++;\n  }\n\n  for(int i=0;i<=cnt;i++)dp[i][i] = ans[i];\n      \n  for(int i=1;i<=cnt;i++){\n    for(int j=0;j+i<=cnt;j++){\n      dp[j][j+i].clear();\n      for(int k=j;k<j+i;k++){\n\tset<int> hoge;\n\thoge = cal(dp[j][k],dp[k+1][j+i],op[k]);\n\tset<int>::iterator ite;\n\tfor(ite=hoge.begin();ite!=hoge.end();ite++)dp[j][j+i].insert(*ite);\n      }\n    }\n  }\n\n  return dp[0][cnt];\n}\n\n\nint main(){\n  string str;\n  set<int> s;\n\n  while(1){\n    cin >> str;\n    if(str == \"#\")break;\n\n    s = parse(str);\n    cout << s.size() << endl;    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nset<int> dp[20][20];\n\nbool digit(char c){\n  if( c - '0'< 0 || c-'0' > 9)return false;\n  return true;\n}\n\nint stoi(string s){\n  int res,tmp;\n\n  res = 0;\n  tmp = 1;\n  for(int i=s.size()-1;i>=0;i--){\n    res += (s[i]-'0') * tmp;\n    tmp *= 10;\n  }\n  return res;\n}  \n\nset<int> cal(set<int> a,set<int> b,char o){\n  set<int> res;\n  set<int>::iterator i,j;\n  res.clear();\n\n  if(a.empty() || b.empty())return res;\n\n  if(o=='+'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tres.insert((*i) + (*j));\n      }\n    }\n  }else if(o=='-'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tres.insert((*i) - (*j));\n      }\n    }\n  }else if(o=='*'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tres.insert((*i) * (*j));\n      }\n    }\n  }else if(o=='/'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tif((*j))res.insert((*i) / (*j));\n      }\n    }\n  }\n  return res;\n}\n\nset<int> parse(string s){\n  string tmp;\n  set<int> ans[20];\n  char op[20];\n  int pos,cnt;\n\n  pos = 0;\n  cnt = 0;\n\n  while(pos < (int)s.size()){\n    if(s[pos] == '('){\n      tmp.clear();\n      pos++;\n      while(s[pos] != ')'){\n\ttmp.push_back(s[pos]);\n\tpos++;\n      }\n      ans[cnt].clear();\n      ans[cnt] = parse(tmp);\n      pos++;\n    }else if(digit(s[pos])){\n      tmp.clear();\n      while(digit(s[pos])){\n\ttmp.push_back(s[pos]);\n\tpos++;\n      }\n      ans[cnt].clear();\n      ans[cnt].insert(stoi(tmp));\n    }\n    if(pos==(int)s.size())break;\n\n    op[cnt] = s[pos];\n    cnt++;\n    pos++;\n  }\n\n  for(int i=0;i<=cnt;i++)dp[i][i] = ans[i];\n      \n  for(int i=1;i<=cnt;i++){\n    for(int j=0;j+i<=cnt;j++){\n      dp[j][j+i].clear();\n      for(int k=j;k<j+i;k++){\n\tset<int> hoge;\n\thoge = cal(dp[j][k],dp[k+1][j+i],op[k]);\n\tset<int>::iterator ite;\n\tfor(ite=hoge.begin();ite!=hoge.end();ite++)dp[j][j+i].insert(*ite);\n      }\n    }\n  }\n\n  return dp[0][cnt];\n}\n\n\nint main(){\n  string str;\n  set<int> s;\n\n  while(1){\n    cin >> str;\n    if(str == \"#\")break;\n\n    s = parse(str);\n    cout << s.size() << endl;    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\n#define int ll\n\nint num(State& now) {\n    int ans = 0;\n    while (*now >= '0' && *now <= '9') {\n        ans *= 10;\n        ans += *now - '0';\n        now++;\n    }\n    return ans;\n}\n\nvector<int> sol(State& now) {\n    vector<vector<int>> inputs;\n    vector<int> calc;\n    while (*now != ')') {\n        if (*now == '(') {\n            now++;\n            inputs.push_back(sol(now));\n        }\n        else if(*now >= '0'&&*now <= '9'){\n            inputs.push_back(vector<int>{num(now)});\n        }\n        else {\n            if (*now == '+') {\n                calc.push_back(0);\n            }\n            else if (*now == '-') {\n                calc.push_back(1);\n            }\n            else if (*now == '/') {\n                calc.push_back(2);\n            }\n            else if (*now == '*') {\n                calc.push_back(3);\n            }\n            now++;\n        }\n    }\n    assert(calc.size() == inputs.size() - 1);\n    set<int> gogo;\n    vector<int> geko;\n    REP(i, calc.size()) {\n        geko.push_back(i);\n    }\n    do {\n        vector<vector<int>> now = inputs;\n        REP(i, geko.size()) {\n            int target = geko[i];\n            REP(q, i) {\n                if (geko[q] < geko[i])target--;\n            }\n            set<int> tmp;\n            REP(q, now[target].size()) {\n                REP(j, now[target + 1].size()) {\n                    if (calc[geko[i]] == 0) {\n                        tmp.insert(now[target][q] + now[target + 1][j]);\n                    }\n                    else if (calc[geko[i]] == 1) {\n                        tmp.insert(now[target][q] - now[target + 1][j]);\n                    }\n                    else if (calc[geko[i]] == 2) {\n                        if (now[target + 1][j] == 0) continue;\n                        tmp.insert(now[target][q] / now[target + 1][j]);\n                    }\n                    else {\n                        tmp.insert(now[target][q] * now[target + 1][j]);\n                    }\n                }\n            }\n            REP(t, 2) {\n                now.erase(now.begin() + target);\n            }\n            vector<int> hogea;\n            for (auto i : tmp) {\n                hogea.push_back(i);\n            }\n            now.insert(now.begin() + target, hogea);\n        }\n        if (now.size() != 1) continue;\n        REP(q, now[0].size()) {\n            gogo.insert(now[0][q]);\n        }\n    } while (next_permutation(ALL(geko)));\n    vector<int> ans;\n    for (auto i : gogo) {\n        ans.push_back(i);\n    }\n    now++;\n    return ans;\n}\n\nvoid solve(){\n    while (true) {\n        string s;\n        cin >> s;\n        if (s == \"#\") return;\n        s.push_back(')');\n        State start = s.begin();\n        cout << sol(start).size() << endl;\n    }\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n//#define debug(x) cerr << #x << \" : \" << x << endl\n#define debug(...)\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << \" ! \" << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\nstruct Expr {\n    vector<char> op;\n    vector<string> expr;\n};\n\n\nclass Solver {\n  public:\n    string S;\n    int N;\n    vector<int> apply(vector<int> &A, vector<int> &B, char op) {\n        debug(A); debug(B); debug(op);\n        vector<int> res;\n        for(int a : A) for(int b : B) {\n                if(op == '+') res.push_back(a + b);\n                else if(op == '-') res.push_back(a - b);\n                else if(op == '*') res.push_back(a * b);\n                else if(op == '/') {\n                    if(b != 0) res.push_back(a / b);\n                }\n                else assert(0);\n            }\n        sort(all(res));\n        res.erase(unique(all(res)), res.end());\n        return res;\n    }\n    vector<int> calc3(vector<vector<int>> nums, const vector<char> &ops, const vector<int> &perm) {\n        map<int, int> ref;\n        for(int i : perm) {\n            int ii = i;\n            int j = i + 1;\n            while(ref.count(i)) i = ref[i];\n            while(ref.count(j)) j = ref[j];\n            nums[i] = apply(nums[i], nums[j], ops[ii]);\n            ref[j] = i;\n        }\n        assert(ref.size() == nums.size() - 1);\n        return nums[0];\n    }\n    vector<int> calc2(vector<vector<int>> &nums, vector<char> ops) {\n        assert(nums.size() == ops.size() + 1);\n        vector<int> perm; rep(i, ops.size()) perm.push_back(i);\n        vector<int> res;\n        do {\n            debug(perm);\n            auto tmp = calc3(nums, ops, perm);\n            for(int i : tmp) res.push_back(i);\n        } while(next_permutation(all(perm)));\n        sort(all(res));\n        res.erase(unique(all(res)), res.end());\n        return res;\n    }\n    vector<int> calc(int &i) {\n        debug(i); debug(S[i]);\n        int s = i;\n        if(isdigit(S[s])) {\n            while(i < N and isdigit(S[i])) i++;\n            return { stoi(S.substr(s, i - s)) };\n        }\n        assert(S[s] == '(');\n        i++;\n        vector<vector<int>> nums;\n        vector<char> ops;\n        bool started = false;\n        while(S[i] != ')') {\n            if(started) {\n                ops.push_back(S[i++]);\n            }\n            nums.push_back(calc(i));\n            started = true;\n        }\n        i++;\n        debug(nums);\n        debug(ops);\n        auto res = calc2(nums, ops);\n        // cerr << \"@ \" << s << \" \" << res;\n        return res;\n    }\n\n    \n    bool solve() {\n        cin >> S;\n        if(S == \"#\") return 0;\n        S = \"(\" + S + \")\";\n        N = S.size();\n        debug(S);\n        int i = 0;\n        auto res = calc(i);\n        debug(res);\n        cout << res.size() << endl;\n        return 1;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(Solver().solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int INF = 1e9;\nint N, M;\nint opPos[10];\nint depth[10];\nint num[10];\nstring s;\nset<int> ans;\nint c;\n\nbool isOperator(char c) {\n\treturn c == '+' || c == '-' || c == '*' || c == '/';\n}\n\nvoid dfs(int d) {\n\twhile(c < N && s[c] != ')') {\n\t\tif(s[c] == '(') {\n\t\t\tc++;\n\t\t\tdfs(d + 1);\n\t\t\tassert(s[c] == ')');\n\t\t}\n\t\tif(isOperator(s[c])) {\n\t\t\tfor(int i = 0; i < M; i++) {\n\t\t\t\tif(opPos[i] == c) depth[i] = d;\n\t\t\t}\n\t\t}\n\t\tc++;\n\t}\n}\n\nint findMinPos(int l, int r) {\n\tint minId = -1;\n\tfor(int i = 0; i < M; i++) {\n\t\tif(l <= opPos[i] && opPos[i] <= r) {\n\t\t\tif(minId == -1 || num[minId] > num[i]) minId = i;\n\t\t}\n\t}\n\tif(minId == -1) return -1;\n\treturn opPos[minId];\n}\n\nint R(double n) {\n\tif(n > 0) return (int)floor(n);\n\treturn (int)ceil(n);\n\tdouble an = abs(n);\n\tint ret = round(an - 1e-9);\n\tif(n < 0) ret *= -1;\n\treturn ret;\n}\n\nint f(int l, int r) {\n\tint minPos = findMinPos(l, r);\n\tif(minPos == -1) {\n\t\tint ret = 0;\n\t\tif(s[l] == '(') l++;\n\t\tif(s[r] == ')') r--;\n\t\tfor(int i = l; i <= r; i++) {\n\t\t\tassert(isdigit(s[i]));\n\t\t\tret = ret * 10 + s[i] - '0';\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint vl = f(l, minPos - 1), vr = f(minPos + 1, r);\n\tif(vl == INF || vr == INF) return INF;\n\tchar op = s[minPos];\n\tif(op == '+') return vl + vr;\n\tif(op == '-') return vl - vr;\n\tif(op == '*') return vl * vr;\n\tif(vr == 0) return INF;\n\tint ret = R((double)vl / vr);\n\treturn ret;\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> s, s != \"#\") {\n\t\tN = s.size();\n\t\tM = 0;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tif(isOperator(s[i])) {\n\t\t\t\topPos[M] = i;\n\t\t\t\tdepth[M] = 0;\n\t\t\t\tM++;\n\t\t\t}\n\t\t}\n\t\tc = 0;\n\t\tdfs(0);\n\n\t\tvector<int> p(M);\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tp[i] = i;\n\t\t}\n\n\t\tans.clear();\n\t\tdo {\n\t\t\tfor(int i = 0; i < M; i++) {\n\t\t\t\tnum[i] = p[i] + depth[i] * 100;\n\t\t\t}\n\t\t\tint res = f(0, N - 1);\n\t\t\tif(res != INF) ans.insert(res);\n\t\t} while(next_permutation(p.begin(), p.end()));\n\n\t\tcout << ans.size() << endl;\n\t\t/*for(auto a : ans) {\n\t\t\tcout << a << \" \";\n\t\t}\n\t\tcout << endl;*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nset<int> ans;\nstring line; \nint len;\n\nint apply(char opr, int a, int b) {\n    if (opr == '+') return a + b;\n    if (opr == '-') return a - b;\n    if (opr == '*') return a * b;\n    if (opr == '/') return a / b;\n}\n\nint reduce(stack<int>& N, stack<char>& O) {\n    char opr = O.top(); O.pop();\n    int v = N.top(); N.pop();\n    int w = N.top(); N.pop();\n    if (opr == '/' && !v) return 0;\n    N.push(apply(opr, w, v));\n    return 1;\n}\n\nvoid debug(stack<int> N, stack<char> O) {\n    while (N.size()) { cout << N.top() << endl; N.pop(); }\n    while (O.size()) { cout << O.top() << endl; O.pop(); }\n}\n\nvoid read(int i, stack<int> N, stack<char> O) {\n    if (i == len) {\n        while (O.size()) if (!reduce(N, O)) return;\n        ans.insert(N.top());\n        return;\n    }\n    if (line[i] >= '0') {\n        int v = 0;\n        while (i < len && line[i] >= '0') v *= 10, v += line[i++] - '0';\n\n        N.push(v);\n        read(i, N, O);\n\n        while (!O.empty() && O.top() != '(' && reduce(N, O)) read(i, N, O);\n        // if (O.empty() || O.top() == '(' || !reduce(N, O)) return;\n        // read(i, N, O);\n        return;\n    }\n    if (line[i] == ')') {\n        while (O.top() != '(') if (!reduce(N, O)) return;\n        O.pop();\n        read(i+1, N, O);\n        while (!O.empty() && O.top() != '(' && reduce(N, O)) read(i+1, N, O);\n        // if (O.empty() || O.top() == '(' || !reduce(N, O)) return;\n        // read(i+1, N, O);\n        return;\n    }\n    O.push(line[i]);\n    read(i+1, N, O);\n    return;\n}\n\nvector<string> inn = {\n\"6/2*(1+2)\",\n\"1-1-1\",\n\"(1-1-1)/2\",\n\"9369/589/182446-1\",\n\"166/(6679+817)\",\n\"3+5536\",\n\"(6*(525483)+(3656+(4432)+318))\",\n\"(1)*15473/1-(823/68)-2-168-565\",\n\"911509/(7803)/276*4\",\n\"116/7232/351+544*443169/693/5513/2/20024+2/62\",\n\"(946730/((667/(6)))-51)\",\n\"3874+(358)*1+25897\",\n\"135229-5506/7/222827/7+3-396\",\n\"2174+3278-4138/1317982*267+8/523297\",\n\"1*15625*3+39325\",\n\"(3)*68287\",\n\"326965/982552-3+4871854/4873-354467-3+477259+3\",\n\"(40510)+(8/60+2214*1)\",\n\"5+7-828*4\",\n\"49969+86987-(6460)+956302+957509+7765\",\n\"6+25/98487+31545/8\",\n\"471+9+483763\",\n\"467669+(23*9-3561154-4047+8750330-728)-8939\",\n\"(((37450)/5960))\",\n\"8982/1/18859\",\n\"8*7+8213/78857/398-5-254\",\n\"68086-7/796615\",\n\"(2/60+3)-53127\",\n\"((42778)*(9077))\",\n\"5-53743+(51*787)\",\n\"92*7350\",\n\"(271)/67\",\n\"211797/464581/6-1+68981-58667/9808592/5208414+1\",\n\"682/(5)\",\n\"(((15+986)+532)+1)*37\",\n\"((296852)+(12887))\",\n\"(3)*7\",\n\"77*1190359/8585*294-25536\",\n\"87*2-47621\",\n\"315536-(407778*3*(4))-6+61755\",\n\"4/7\",\n\"47290+1/(395)/40631/6619+840839/656+7870421-202\",\n\"15980+(4822382)\",\n\"4345701*4-3\",\n\"754508+1-2\",\n\"(219890)/6\",\n\"6378/3*694\",\n\"3/(2270301)*46\",\n\"(7300-4)+900/7098+54\",\n\"3/166999\",\n\"4+980067/613828*82/26874-9+4\",\n\"(4-3914)\",\n\"21490/83921+(42706)\",\n\"(1*491920+6*2)\",\n\"98+299-620717/95328*28*2/86\",\n\"86530+24456/9*98-1693/83603\",\n\"2802732/(3)-(9-4-9+22294)\",\n\"7/82/8017*4+3624+83823\",\n\"(6597383)-(2467)/(797)\",\n\"1699-894/47400+8327+3231219*7\",\n\"(6+70)\",\n\"(5763+(7)+75890-(6)+53989-74)\",\n\"3867426-9/3815340+7/46-405635+561986*131/939\",\n\"210103+71496+8*88\",\n\"(6669+((7))-49)\",\n\"9949/9691+81+156\",\n\"3709/(1+2)+(61*471-6820744+7)/257+589523*78\",\n\"6*(433674/(8+1)-6462)\",\n\"86-7+1331*727\",\n\"(48)/(99)+7-5/563834/1116438/8464629+7854*6\",\n\"932+61735/53\",\n\"916/2*471\",\n\"1547312+1164764\",\n\"106-20869+63359*9-3*9+2-1153\",\n\"6-71+8127+86*4/13-6*8009\",\n\"53423+314/7\",\n\"(7903*5)-(4)\",\n\"4/935/58-7406244/615\",\n\"352/949877-707156+391869+3+(52)-84\",\n\"6+1484+1/6583331-24364/(9/6)/5030597\",\n\"1903/9312+1668376/5-448-411508/90229\",\n\"702954+(690)/398178-6\",\n\"6222+4/7/7/5426\",\n\"9*5962441/505\",\n\"21270-4+688669/11+9+543*4\",\n\"4+627-88709+((7398*(81782/827262*3)/5019257)+7849)/1013372\",\n\"4*(628945/(6-22350)+991+9142107)+237037\",\n\"((56)*(478-63037)/90906)\",\n\"13376-(8+27*2)\",\n\"413-6059581/397+6/141/49/23291-57-1+1402\",\n\"89+49*8*(4+(92)/703947)\",\n\"(91163/15506)/3256248+379194/168482/((6))*8-4\",\n\"9*8897/7547785-5-9\"\n};\n\nint main()\n{\n    //for (string v : inn) {\n    while (1) {\n        ans.clear();\n        cin >> line;\n        //line = v;\n        len = line.length();\n        if (line == \"#\") break;\n        read(0, stack<int>(), stack<char>());\n        cout << ans.size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n\nstring STR;\nvector<string> S;\n\nbool bye_bye_paren(int b, int e){\n  int cnt = 0;\n  FOR(i, b, e){\n    if(S[i] == \"(\") ++cnt;\n    if(S[i] == \")\") --cnt;\n    if(cnt < 0) return false;\n  }\n  return (cnt == 0);\n}\n\nset<int> calc(int b, int e){\n  //cout <<\"-------\" <<endl;\n  //cout <<\"begin = \" <<b <<\", end = \" <<e <<endl;\n  //FOR(i, b, e) cout <<S[i]; cout <<endl;\n  set<int> ret;\n  if(e - b == 1) ret.insert(atoi(S[b].c_str()));\n  else if(S[b] == \"(\" && S[e - 1] == \")\" && bye_bye_paren(b + 1, e - 1)) ret = calc(b + 1, e - 1);\n  else {\n    int cnt = 0;\n    FOR(i, b, e){\n      if(S[i] == \"(\") ++cnt;\n      else if(S[i] == \")\") --cnt;\n      else if(cnt == 0 && (S[i] == \"+\" || S[i] == \"-\" || S[i] == \"*\" || S[i] == \"/\")){\n        set<int> left = calc(b, i), right = calc(i + 1, e);\n        for(set<int>::iterator it1 = left.begin(); it1 != left.end(); ++it1){\n          for(set<int>::iterator it2 = right.begin(); it2 != right.end(); ++it2){\n            if(S[i] == \"+\") ret.insert((*it1) + (*it2));\n            if(S[i] == \"-\") ret.insert((*it1) - (*it2));\n            if(S[i] == \"*\") ret.insert((*it1) * (*it2));\n            if(S[i] == \"/\" && (*it2) != 0) ret.insert((*it1) / (*it2));\n            //if(b == 1 && e == 14){\n            //  cout <<\"insert \" <<endl;\n            //  for(set<int>::iterator it = left.begin(); it != left.end(); ++it) cout <<(*it) <<\", \"; cout <<endl;\n            //  for(set<int>::iterator it = right.begin(); it != right.end(); ++it) cout <<(*it) <<\", \"; cout <<endl;\n            //  cout <<S[i] <<\", \" <<ret.size() <<endl;\n            //  for(set<int>::iterator it = ret.begin(); it != ret.end(); ++it) cout <<(*it) <<\", \"; cout <<endl;\n            //}\n          }\n        }\n      }\n    }\n  }\n  //cout <<\"ret = \";\n  //for(set<int>::iterator it = ret.begin(); it != ret.end(); ++it) cout <<(*it) <<\", \"; cout <<endl;\n  return ret;\n}\n\nint main() {\n  while(cin >>STR && STR != \"#\"){\n    S = vector<string>();\n    string tmp = \"\";\n    REP(i, STR.length()){\n      if(isdigit(STR[i])) tmp += STR[i];\n      else{\n        if(tmp != \"\") S.push_back(tmp);\n        tmp = STR[i];\n        S.push_back(tmp);\n        tmp = \"\";\n      }\n    }\n    if(tmp != \"\") S.push_back(tmp);\n    //REP(i, S.size()) cout <<S[i] <<\" | \"; cout <<endl;\n    set<int> ans = calc(0, S.size());\n    cout <<ans.size() <<endl;\n    //for(set<int>::iterator it = ans.begin(); it != ans.end(); ++it) cout <<(*it) <<\", \"; cout <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<set>\n#include<cctype>\n#include<algorithm>\nusing namespace std;\ntypedef string::const_iterator State;\n\nstring s;\nint yuusenn[10], mx;\nint expr(State& begin, int& now, int num);\nbool zero = false;\n\nint number(State& begin, int& now) {\n  if (zero) return 0;\n  int ans = 0;\n  if (*begin == '(') {\n    begin++;\n    ans = expr(begin, now, 0);\n    begin++;\n    return ans;\n  }\n  while (isdigit(*begin)) ans *= 10, ans += *begin - '0', begin++;\n  return ans;\n}\n\nint expr(State& begin, int& now, int num) {\n  if (num == mx) return number(begin, now);\n  int ans = expr(begin, now, num+1);\n  while (1) {\n    if (zero) return 0;\n    if (*begin == '+' && yuusenn[now] == num) begin++, now++, ans += expr(begin, now, num+1);\n    else if (*begin == '*' && yuusenn[now] == num) begin++, now++, ans *= expr(begin, now, num+1);\n    else if (*begin == '/' && yuusenn[now] == num) {\n      begin++, now++;\n      int temp = expr(begin, now, num+1);\n      if (temp == 0) {\n        zero = true;\n        return 0;\n      }\n      ans /= temp;\n    } else if (*begin == '-' && yuusenn[now] == num) begin++, now++, ans -= expr(begin, now, num+1);\n    else return ans;\n  }\n}\n\nint main() {\n  while (cin >> s, s != \"#\") {\n    mx = 0;\n    int ans = 0;\n    set<int> st;\n    for (int i = 0; i < s.length(); i++) if (s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/') mx++;\n    for (int i = 0; i < mx; i++) yuusenn[i] = i;\n    do {\n      State state = s.begin();\n      int now = 0;\n      zero = false;\n      int temp = expr(state, now, 0);\n      if (zero) continue;\n      if (st.count(temp) == 0) st.insert(temp), ans++;\n    } while (next_permutation(yuusenn, yuusenn + mx));\n    printf(\"%d\\n\", ans);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\n#include<cassert>\n\nstring s;\nint ls;\nint nps[205]={};\n\nbool isnum(char c){\n\treturn ('0'<=c && c<='9');\n}\n\t\n\nlli getnum(int& p){\n\tlli res=0;\n\tfor(;;){\n\t\tif(p>=ls)break;\n\t\tchar c=s[p];\n\t\tif(isnum(c)){\n\t\t\tres*=10;\n\t\t\tres+=(c-'0');\n\t\t\tp++;\n\t\t}\n\t\telse break;\n\t}\n\treturn res;\n}\n\nchar ops[5]=\"+-*/\";\nbool isope(char c){\n\trep(i,4){\n\t\tif(c==ops[i])return true;\n\t}\n\treturn false;\n}\n\t\t\t\n\nint npt[15]; //yuusenndo\n\nbool ok;\n\nlli expr(int& p,int pr){\n\t//printf(\"expr %d %d\\n\",p,pr);\n\t\n\tif(pr>11){\n\t\treturn getnum(p);\n\t}\n\telse if(pr==10){\n\t\tif(s[p]=='('){\n\t\t\tp++;\n\t\t\tlli res=expr(p,0);\n\t\t\tassert(s[p]==')');\n\t\t\tp++;\n\t\t\treturn res;\n\t\t}\n\t}\n\t//assert(isnum(s[p]));\n\tlli a1=expr(p,pr+1);\n\tif(p>=ls || s[p]==')')return a1;\n\tif(!isope(s[p])){\n\t\tprintf(\"%dgyo %d %c\",__LINE__,p,s[p]);\n\t\tassert(false);\n\t}\n\t//printf(\"nps_npt %d\\n\",npt[nps[p]]);\n\tif(npt[nps[p]]==pr){\n\t\tchar c=s[p]; p++;\n\t\tlli a2=expr(p,pr+1);\n\t\tif(c=='+')return (a1+a2);\n\t\telse if(c=='-')return (a1-a2);\n\t\telse if(c=='*')return (a1*a2);\n\t\telse if(c=='/'){\n\t\t\t//printf(\"%lld %lld\\n\",a1,a2);\n\t\t\tif(a2==0){\n\t\t\t\tok=false;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse return (a1/a2);\n\t\t}\n\t\telse assert(false);\n\t}\n\telse{\n\t\treturn a1;\n\t}\n}\n\nint main(void){\n\tfor(;;){\n\t\tcin >> s;\n\t\tls=s.size();\n\t\tif(s[0]=='#')break;\n\t\t\n\t\tmemset(nps,-1,sizeof(nps));\n\t\tint ct=0;\n\t\trep(i,ls){\n\t\t\tif(isope(s[i])){\n\t\t\t\tnps[i]=ct;\n\t\t\t\tct++;\n\t\t\t}\n\t\t}\n\n\t\trep(i,ct)npt[i]=i;\n\t\t\n\t\tvector<lli> anss;\n\t\tdo{\n\t\t\tint p=0;\n\t\t\tok = true;\n\t\t\tlli na=expr(p,0);\n\t\t\t//printf(\"kekka .. %s %lld\\n\",ok?\"ok\":\"ng\",na);\n\t\t\tif(ok)anss.push_back(na);\n\t\t}while(next_permutation(npt,npt+ct));\n\t\t\n\t\tsort(anss.begin(),anss.end());\n\t\tanss.erase(unique(anss.begin(),anss.end()),anss.end());\n\t\t\n\t\t\t\n\t\tprintf(\"%d\\n\",anss.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nstring s;\n\nset<int> parse(int l, int r)\n{\n\tset<int> res;\n\tstring t = s.substr(l, r - l);\n\tbool f = true;\n\tREP(i, t.size())\n\t{\n\t\tif (!isdigit(t[i])) f = false;\n\t}\n\tif (f)\n\t{\n\t\tres.insert(stoi(t));\n\t\treturn res;\n\t}\n\tif (t[0] == '('&&t.back() == ')') return parse(l + 1, r - 1);\n\tint cnt = 0;\n\tFOR(i, l, r)\n\t{\n\t\tif (s[i] == '(') cnt++;\n\t\telse if (s[i] == ')') cnt--;\n\t\telse if (!isdigit(s[i]) && cnt == 0)\n\t\t{\n\t\t\tset<int> lhs = parse(l, i);\n\t\t\tset<int> rhs = parse(i + 1, r);\n\t\t\tfor (auto j : lhs)for (auto k : rhs)\n\t\t\t{\n\t\t\t\tif (s[i] == '+') res.insert(j + k);\n\t\t\t\tif (s[i] == '-') res.insert(j - k);\n\t\t\t\tif (s[i] == '*') res.insert(j * k);\n\t\t\t\tif (k != 0 && s[i] == '/') res.insert(j / k);\n\t\t\t}\n\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> s, s != \"#\")\n\t{\n\t\tcout << parse(0, s.size()).size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nset<int> dp[12][12];\n\nbool digit(char c){\n  if( c - '0'< 0 || c-'0' > 9)return false;\n  return true;\n}\n\nint stoi(string s){\n  int res,tmp;\n\n  res = 0;\n  tmp = 1;\n  for(int i=s.size()-1;i>=0;i--){\n    res += (s[i]-'0') * tmp;\n    tmp *= 10;\n  }\n  return res;\n}  \n\nset<int> cal(set<int> a,set<int> b,char o){\n  set<int> res;\n  set<int>::iterator i,j;\n  res.clear();\n\n  if(a.empty() || b.empty())return res;\n\n  if(o=='+'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tres.insert((*i) + (*j));\n      }\n    }\n  }else if(o=='-'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tres.insert((*i) - (*j));\n      }\n    }\n  }else if(o=='*'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tres.insert((*i) * (*j));\n      }\n    }\n  }else if(o=='/'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tif((*j))res.insert((*i) / (*j));\n      }\n    }\n  }\n  return res;\n}\n\nset<int> parse(string s){\n  string tmp;\n  set<int> ans[12];\n  char op[12];\n  int pos,cnt;\n\n  pos = 0;\n  cnt = 0;\n\n  while(pos < (int)s.size()){\n    if(s[pos] == '('){\n      tmp.clear();\n      pos++;\n      while(s[pos] != ')'){\n\ttmp.push_back(s[pos]);\n\tpos++;\n      }\n      ans[cnt].clear();\n      ans[cnt] = parse(tmp);\n      pos++;\n    }else if(digit(s[pos])){\n      tmp.clear();\n      while(digit(s[pos])){\n\ttmp.push_back(s[pos]);\n\tpos++;\n      }\n      ans[cnt].clear();\n      ans[cnt].insert(stoi(tmp));\n    }\n    if(pos==(int)s.size())break;\n\n    op[cnt] = s[pos];\n    cnt++;\n    pos++;\n  }\n\n  for(int i=0;i<=cnt;i++)dp[i][i] = ans[i];\n      \n  for(int i=1;i<=cnt;i++){\n    for(int j=0;j+i<=cnt;j++){\n      dp[j][j+i].clear();\n      for(int k=j;k<j+i;k++){\n\tset<int> hoge;\n\thoge = cal(dp[j][k],dp[k+1][j+i],op[k]);\n\tset<int>::iterator ite;\n\tfor(ite=hoge.begin();ite!=hoge.end();ite++)dp[j][j+i].insert(*ite);\n      }\n    }\n  }\n\n  return dp[0][cnt];\n}\n\n\nint main(){\n  string str;\n  set<int> s;\n\n  while(1){\n    cin >> str;\n    if(str == \"#\")break;\n\n    s = parse(str);\n    cout << s.size() << endl;    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nvector<char> ops{'+', '-', '*', '/'};\n\n\nauto is_op(char c) -> bool {\n  auto&& it = find(ops.begin(), ops.end(), c);\n  return it != ops.end();\n}\n\nauto eval(int a, char op, int b) -> int {\n  // cout << a << \" \" << op << \" \" << b << endl;\n  if(op == '+') return a + b;\n  else if(op == '*') return a * b;\n  else if(op == '-') return a - b;\n  else if(op == '/') return a / b;\n}\n\nauto expr(set<int> a, set<int> b, char op) -> set<int> {\n  set<int> res;\n  for(auto it = a.begin(); it != a.end(); ++it) {\n    for(auto b_it = b.begin(); b_it != b.end(); ++b_it) {\n      if(*b_it == 0 && op == '/') continue;\n      res.insert(eval(*it, op, *b_it));\n      // cout << eval(*it, op, *b_it) << endl;\n    }\n  }\n  return res;\n}\n\nauto calc(string s) -> set<int> {\n  set<int> result[11][11];\n  vector<int> op_pos;\n  vector<char> expr_ops;\n  set<int> nums[256];\n\n  string num = \"\";\n  // cout << \"s => \" << s << endl;\n\n  int idx = 0;\n  for(int i=0; i<s.size(); ++i) {\n    // cout << \"s[i] \" << s[i] << endl;\n    if(s[i] == '(') {\n      int cnt = 1;\n      for(int j=i+1;j<s.size(); ++j) {\n        if(s[j]=='(') cnt++;\n        if(s[j]==')') cnt--;\n        if(s[j]==')' && cnt==0) {\n          nums[idx++] = calc(s.substr(i+1, j-i-1));\n          i = j;\n          break;\n        }\n      }\n    }\n    else if(is_op(s[i])) {\n      op_pos.push_back(i);\n      expr_ops.push_back(s[i]);\n      // cout << \"num \" << num << endl;\n      if(num != \"\")\n        nums[idx++].insert(stoll(num));\n      num = \"\";\n    } else num += s[i];\n  }\n      // cout << \"num \" << num << endl;\n  if(num != \"\") nums[idx++].insert(stoll(num));\n\n  for(int i = 0; i<idx; ++i){\n    result[i][i] = nums[i];\n  }\n  for(int j=1; j<idx; ++j) {\n    for(int i=0; i<idx; ++i) {\n      if(i+j >= idx)break;\n      for(int k=0; k<j; ++k) {\n        //cout << \"i\" << i << \" i+k\" << i+k << \"     i+k+1\" << i+k+1 << \" i+j: \" << i+j << \" k \" << k << endl;\n        //cout << result[i][i+k].size()<< \" , \" << result[i+k+1][i+j].size() << endl;\n        auto&& tmp = expr(result[i][i+k], result[i+k+1][i+j], expr_ops[i+k]);\n        for(auto e : tmp) result[i][i+j].insert(e);\n        //cout << \"result: \" << result[i][i+j].size() << endl;\n      }\n    }\n  }\n\n  // for(int i= 0; i < idx; ++i){\n  //   cout << \"i: \" << i << endl;\n  //   for(int j = i; j < idx; ++j){\n  //     cout << result[i][j].size() << endl;\n  //   }\n  // }\n\n  return result[0][idx-1];\n}\n\nauto rec(string target) -> void {\n}\n\nauto main() -> signed {\n  string s;\n  while(cin>>s, s!=\"#\") {\n    cout << calc(s).size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) loop(i,0,n)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nint dx[]={-1,-1,0,0,1,1};\nint dy[]={0,-1,1,-1,1,0};\nconst int inf=1000000010;\nstring s;\nint t;\nvi f(){\n\tvvi in;\n\tstring w=\"\";\n\twhile(t<s.size()){\n\t\tif(s[t]=='('){\n\t\t\tt++;\n\t\t\tin.pb(f());\n\t\t\tt++;\n\t\t}else{\n\t\t\tint a=0;\n\t\t\twhile(t<s.size()&&isdigit(s[t])){\n\t\t\t\ta*=10;\n\t\t\t\ta+=s[t]-'0';\n\t\t\t\tt++;\n\t\t\t}\n\t\t\tin.pb({a});\n\t\t}\n\t\tif(s.size()==t)break;\n\t\tif(s[t]==')')break;\n\t\tw+=s[t];\n\t\tt++;\n\t}\n\tvi out;\n\tvi per(w.size());\n\trep(i,w.size())per[i]=i;\n\tdo{\n\t\tvvi tmp=in;\n\t\trep(i,w.size()){\n\t\t\tint l=per[i],r=per[i]+1;\n\t\t\twhile(tmp[l].size()==0)l--;\n\t\t\twhile(tmp[r].size()==0)r++;\n\t\t\tvi nt;\n//\t\t\trep(j,per.size())cout<<\" \"<<per[j];cout<<endl;\n\n\t\t\trep(j,tmp[l].size())rep(k,tmp[r].size()){\n\t\t\t\tif(w[per[i]]=='+')nt.pb(tmp[l][j]+tmp[r][k]);\n\t\t\t\tif(w[per[i]]=='-')nt.pb(tmp[l][j]-tmp[r][k]);\n\t\t\t\tif(w[per[i]]=='*')nt.pb(tmp[l][j]*tmp[r][k]);\n\t\t\t\tif(w[per[i]]=='/')nt.pb(tmp[l][j]/tmp[r][k]);\n\t\t\t}\n\t\t\ttmp[l]=vi(0);\n\t\t\ttmp[r]=nt;\n\t\t}\n\t\trep(j,tmp.size()){rep(i,tmp[j].size())out.pb(tmp[j][i]);}\n\t}while(next_permutation(all(per)));\n\n\tsort(all(out));\n\tout.erase(unique(all(out)),out.end());\n\treturn out;\n}\nint main(){\n\twhile(cin>>s,s!=\"#\"){\n\t\tt=0;\n\t\tcout<<f().size()<<endl;\n\t}\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <string>\n\nusing namespace std;\n\n#define whole(xs) (xs).begin(),(xs).end()\n#define uniq(xs) ((xs).erase(unique((xs).begin(), (xs).end()), (xs).end()))\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T> xs) {\n    if (xs.empty()) return os << \"[]\";\n    os << \"[\" << xs[0];\n    for (int i = 1; i < xs.size(); i++) os << \" \" << xs[i];\n    return os << \"]\";\n}\n\nstring s;\nbool input() {\n    getline(cin, s);\n    if (s == \"#\") return false;\n    return true;\n}\n\nbool check_op(char x) {\n    const string ops = \"+-*/(\";\n    if (ops.find(x) == string::npos) return false;\n    return true;\n}\n\nint calc(char op, int l, int r) {\n    switch (op) {\n        case '+': return l + r;\n        case '-': return l - r;\n        case '*': return l * r;\n        case '/': return l / r;\n        default: assert(0);\n    }\n}\n\nint number(const string& s, int& i) {\n    int x = 0;\n    while (i < s.size() && isdigit(s[i])) {\n        x = x * 10 + (s[i] - '0');\n        i++;\n    }\n    return x;\n}\n\nvector<int> dfs(const vector< vector<int> >& values, const vector<char>& ops);\nvector<int> expr(const string& s,int& i) {\n    vector<int> L;\n    if (s[i] == '(') {\n        i++;\n        L = expr(s, i);\n        assert(s[i] == ')');\n        i++;\n    } else {\n        L.push_back(number(s, i));\n    }\n    vector<char> ops;\n    vector< vector<int> > values;\n    values.push_back(L);\n    while (true) {\n        if (i == s.size() || s[i] == ')') break;\n        assert(check_op(s[i]));\n        ops.push_back(s[i]); i++;\n        vector<int> value;\n        if (s[i] == '(') {\n            i++;\n            value = expr(s, i);\n            assert(s[i] == ')');\n            i++;\n        } else {\n            value.push_back(number(s, i));\n        }\n        values.push_back(value);\n    }\n    assert(ops.size() + 1 == values.size());\n    return dfs(values, ops);\n}\n\nvector<int> dfs(const vector< vector<int> >& values, const vector<char>& ops) {\n    int N = ops.size();\n    if (N == 0) {\n        assert(values.size() == 1);\n        return values[0];\n    }\n    vector<int> ret;\n    for (int i = 0; i < N; i++) {\n        char op = ops[i];\n        vector< vector<int> > lvalues; for (int j = 0; j <= i; j++) lvalues.push_back(values[j]);\n        vector<char> lops; for (int j = 0; j < i; j++) lops.push_back(ops[j]);\n        vector< vector<int> > rvalues; for (int j = i + 1; j <= N; j++) rvalues.push_back(values[j]);\n        vector<char> rops; for (int j = i + 1; j < N; j++) rops.push_back(ops[j]);\n        vector<int> L = dfs(lvalues, lops);\n        vector<int> R = dfs(rvalues, rops);\n        assert(L.size() > 0);\n        assert(R.size() > 0);\n        for (int j = 0; j < L.size(); j++) {\n            for (int k = 0; k < R.size(); k++) {\n                ret.push_back(calc(op, L[j], R[k]));\n            }\n        }\n    }\n    sort(whole(ret));\n    uniq(ret);\n    if (false) {\n        cout << \"values: \" << values << endl;\n        cout << \"ops: \" << ops << endl;\n        cout << ret << endl;\n    }\n    return ret;\n}\n\nvoid solve() {\n    int i = 0;\n    cout << expr(s, i).size() << endl;\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nset<int> solve(string exp) {\n    vector<int> idx;\n    map<int, int> rev;\n    for (int i = 0, c = 0; i < exp.size(); i++) {\n        if (exp[i] == '(')\n            c++;\n        if (exp[i] == ')')\n            c--;\n        if (c == 0 && (exp[i]=='*' || exp[i]=='/' || exp[i]=='+' || exp[i]=='-')) {\n            rev[i] = idx.size();\n            idx.push_back(i);\n        }\n    }\n \n    if(idx.size() == 0) {\n        if (exp[0] == '(') return solve(string(exp.begin()+1, exp.end()-1));\n        stringstream ss;\n        ss << exp;\n        int num;\n        ss >> num;\n        set<int> ans;\n        ans.insert(num);\n        return ans;\n    }\n \n    vector<set<int> > res(idx.size() + 1);\n    for (int i = 0; i < idx.size() + 1; i++) {\n        int l = i == 0 ? 0 : idx[i - 1] + 1;\n        int r = i == idx.size() ? exp.size() : idx[i];\n        res[i] = solve(string(exp.begin() + l, exp.begin() + r));\n    }\n \n \n    set<int> ans;\n    do {\n        vector<set<int> > ret = res;\n        vector<int> ridx(idx.size());\n        for (int i = 0; i < idx.size(); i++) {\n            ridx[rev[idx[i]]] = i;\n        }\n        for (int i = 0; i < idx.size(); i++) {\n            int l = -1;\n            int r = rev[idx[i]] + 1;\n            set<int> num;\n            for (int j = rev[idx[i]]-1, ml = -1; j >= 0 && i > ridx[j]; j--)\n                if (ml < ridx[j]) {ml = ridx[j], l = j;}\n            if (l == -1) l = rev[idx[i]];\n            for (int j = r, mr = -1; j < idx.size() && i > ridx[j]; j++)\n                if (mr < ridx[j]) {mr = ridx[j], r = j;}\n             for (auto lhs : ret[l]) {\n                for (auto rhs : ret[r]) {\n                    if (exp[idx[i]] == '+')\n                        num.insert(lhs + rhs);\n                    if (exp[idx[i]] == '-')\n                        num.insert(lhs - rhs);\n                    if (exp[idx[i]] == '*')\n                        num.insert(lhs * rhs);\n                    if (exp[idx[i]] == '/') {\n                        if (rhs == 0)\n                            continue;\n                        num.insert(lhs / rhs);\n                    }\n                }\n            }\n \n            ret[rev[idx[i]]] = num;\n        }\n \n        for (auto i : ret[rev[idx[idx.size()-1]]]) ans.insert(i);\n    } while (next_permutation(idx.begin(), idx.end()));\n \n    return ans;\n}\n \nint main() {\n    string str;\n    while (cin >> str, str != \"#\")\n        cout << solve(str).size() << endl;\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nset<int> SET;\n\nint calc(int a,int b,char op){\n\tswitch(op){\n\tcase '+':return a+b;\n\tcase '-':return a-b;\n\tcase '*':return a*b;\n\tcase '/':\n\t\tif(b == 0){\n\t\t\treturn BIG_NUM;\n\t\t}else{\n\t\t\treturn a/b;\n\t\t}\n\t}\n}\n\nbool is_op(char ch){\n\tif(ch == '+' || ch == '-' || ch == '*' || ch == '/'){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nbool is_num(char ch){\n\treturn ch >= '0' && ch <= '9';\n}\n\nvoid remove_brackets(char equation[201],int length){\n\n\tchar work[201];\n\tbool op_FLG;\n\n\tstack<int> S;\n\tint left,right;\n\n\tfor(int i = 0; i < length; i++){\n\t\tif(equation[i] == '('){\n\t\t\tS.push(i);\n\t\t}else if(equation[i] == ')'){\n\t\t\top_FLG = false;\n\t\t\t//対応する開きカッコから自分までの間に、演算子があるか調べる\n\t\t\tleft = S.top();\n\t\t\tS.pop();\n\t\t\tright = i;\n\t\t\tfor(int k = left+1; k < right; k++){\n\t\t\t\tif(is_op(equation[k])){\n\t\t\t\t\top_FLG = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!op_FLG){ //対応する区間に演算子がない場合:削除する\n\t\t\t\tequation[left] = '.';\n\t\t\t\tequation[right] = '.';\n\t\t\t}\n\t\t}\n\t}\n\n\tint index = 0;\n\tfor(int i = 0; i < length; i++){\n\t\tif(equation[i] == '.')continue;\n\t\twork[index++] = equation[i];\n\t}\n\tfor(int i = 0; i < index; i++){\n\t\tequation[i] = work[i];\n\t}\n\tequation[index] = '\\0';\n}\n\nvoid recursive(char equation[201],int length){\n\n\tstack<int> S;\n\n\t//演算可能な演算子を走査する(左右にカッコがあるものはSKIP)\n\tfor(int i = 0; i < length; i++){\n\t\tif(is_op(equation[i]) == true && equation[i+1] != '(' && equation[i-1] != ')'){\n\t\t\tS.push(i);\n\t\t}\n\t}\n\n\tif(S.empty()){ //計算できる演算子がない場合:SETに最終結果を突っ込む\n\t\tint number = 0;\n\t\tbool neg_FLG = false;\n\n\t\tfor(int i = 0; i < length; i++){\n\t\t\tif(equation[i] == '@'){ //マイナス\n\t\t\t\tneg_FLG = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnumber = 10*number+equation[i]-'0';\n\t\t}\n\t\tif(neg_FLG)number *= -1;\n\t\tSET.insert(number);\n\n\t\treturn;\n\t}\n\n\tint loc,left,right,left_num,start,right_num,new_num,index,num_length,next_length;\n\tbool left_neg_FLG,right_neg_FLG,new_num_neg_FLG;\n\n\tstack<int> WORK;\n\n\t//演算し、演算部を結果で置換する\n\twhile(!S.empty()){\n\t\tloc = S.top();\n\t\tS.pop();\n\n\t\tleft_neg_FLG = false;\n\t\t//左側の数字の開始位置を調べる\n\t\tfor(left = loc-1; left >= 0 && is_num(equation[left]) == true; left--);\n\t\tleft++;\n\t\tif(left > 0 && equation[left-1] == '@'){\n\t\t\tleft--; //演算部の左端をデクリメント\n\t\t\tleft_neg_FLG = true;\n\t\t}\n\n\t\tif(equation[loc+1] == '@'){\n\t\t\tright_neg_FLG = true;\n\t\t\tstart = loc+2;\n\t\t}else{\n\t\t\tright_neg_FLG = false;\n\t\t\tstart = loc+1;\n\t\t}\n\n\t\t//右側の数字の終了位置を調べる\n\t\tfor(right = start; right < length && is_num(equation[right]) == true; right++);\n\t\tright--;\n\n\t\t//左側の数字を計算する\n\t\tleft_num = 0;\n\t\tfor(int i = left; i < loc; i++){\n\t\t\tif(equation[i] == '@')continue;\n\t\t\tleft_num = 10*left_num+equation[i]-'0';\n\t\t}\n\t\tif(left_neg_FLG)left_num *= -1;\n\n\t\t//右側の数字を計算する\n\t\tright_num = 0;\n\t\tfor(int i = start; i <= right; i++){\n\t\t\tright_num = 10*right_num+equation[i]-'0';\n\t\t}\n\t\tif(right_neg_FLG)right_num *= -1;\n\n\t\t//演算\n\t\tnew_num = calc(left_num,right_num,equation[loc]);\n\n\t\tif(new_num == BIG_NUM)continue; //0割り発生\n\n\t\tif(new_num < 0){\n\t\t\tnew_num_neg_FLG = true;\n\t\t\tnew_num *= -1;\n\t\t}else{\n\t\t\tnew_num_neg_FLG = false;\n\t\t}\n\n\t\t//新しい数式を作る\n\t\tchar next_equation[201];\n\t\tindex = 0;\n\n\t\t//演算部の前まで\n\t\tfor(int i = 0; i < left; i++){\n\t\t\tnext_equation[index++] = equation[i];\n\t\t}\n\n\t\t//new_numを分解し、char型にする\n\t\tnum_length = 0;\n\n\t\tdo{\n\t\t\tWORK.push(new_num%10);\n\t\t\tnew_num /= 10;\n\t\t\tnum_length++;\n\n\t\t}while(new_num > 0);\n\n\t\tif(new_num_neg_FLG){ //結果が負の場合\n\t\t\tnext_equation[index++] = '@';\n\t\t\tnum_length++; //★★マイナスも数字長に含む★★\n\t\t}\n\n\t\twhile(!WORK.empty()){\n\t\t\tnext_equation[index++] = '0'+WORK.top();\n\t\t\tWORK.pop();\n\t\t}\n\n\t\t//演算部の右側\n\t\tfor(int i = right+1; i < length; i++){\n\t\t\tnext_equation[index++] = equation[i];\n\t\t}\n\t\tnext_equation[index] = '\\0';\n\n\t\t//★★今回の演算によって、演算子を含まない()ができれば、()を除去する\n\t\tremove_brackets(next_equation,index);\n\t\tfor(next_length = 0; next_equation[next_length] != '\\0'; next_length++);\n\n\t\trecursive(next_equation,next_length);\n\t}\n}\n\n/*\n * 簡単のため、単項の-は@で表す\n * */\n\nint main(){\n\n\tint length;\n\tchar equation[201],work[201];\n\n\twhile(true){\n\t\tscanf(\"%s\",equation);\n\t\tif(equation[0] == '#')break;\n\n\t\tfor(length = 0; equation[length] != '\\0'; length++);\n\t\tremove_brackets(equation,length); //カッコを取り除く\n\n\t\tfor(length = 0; equation[length] != '\\0'; length++);\n\n\t\tSET.clear();\n\t\trecursive(equation,length);\n\n\t\tprintf(\"%lld\\n\",SET.size());\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<int>Tashi(vector<int>f1, vector<int>f2) {\n\tvector<int>f3; for (int i = 0; i < f1.size(); i++) { for (int j = 0; j < f2.size(); j++)f3.push_back(f1[i] + f2[j]); }\n\treturn f3;\n}\nvector<int>Hiki(vector<int>f1, vector<int>f2) {\n\tvector<int>f3; for (int i = 0; i < f1.size(); i++) { for (int j = 0; j < f2.size(); j++)f3.push_back(f1[i] - f2[j]); }\n\treturn f3;\n}\nvector<int>Kake(vector<int>f1, vector<int>f2) {\n\tvector<int>f3; for (int i = 0; i < f1.size(); i++) { for (int j = 0; j < f2.size(); j++)f3.push_back(f1[i] * f2[j]); }\n\treturn f3;\n}\nvector<int>Wari(vector<int>f1, vector<int>f2) {\n\tvector<int>f3;\n\tfor (int i = 0; i < f1.size(); i++) {\n\t\tfor (int j = 0; j < f2.size(); j++) { if (f2[j] != 0)f3.push_back(f1[i] / f2[j]); }\n\t}\n\treturn f3;\n}\nvector<int> solve(string S) {\n\twhile (S.size() >= 2 && S[0] == '(' && S[S.size() - 1] == ')') S = S.substr(1, S.size() - 2);\n\tbool OK = false;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tif (S[i] < '0' || S[i] > '9')OK = true;\n\t}\n\tif (OK == false) { return{ stoi(S) }; }\n\n\tint depth = 0; vector<int>K;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tif (S[i] == '(')depth++; if (S[i] == ')')depth--;\n\t\tif (depth == 0) {\n\t\t\tif (S[i] == '+') {\n\t\t\t\tvector<int>J = Tashi(solve(S.substr(0, i)), solve(S.substr(i + 1, S.size() - i - 1)));\n\t\t\t\tfor (int j = 0; j < J.size(); j++)K.push_back(J[j]);\n\t\t\t}\n\t\t\tif (S[i] == '-') {\n\t\t\t\tvector<int>J = Hiki(solve(S.substr(0, i)), solve(S.substr(i + 1, S.size() - i - 1)));\n\t\t\t\tfor (int j = 0; j < J.size(); j++)K.push_back(J[j]);\n\t\t\t}\n\t\t\tif (S[i] == '*') {\n\t\t\t\tvector<int>J = Kake(solve(S.substr(0, i)), solve(S.substr(i + 1, S.size() - i - 1)));\n\t\t\t\tfor (int j = 0; j < J.size(); j++)K.push_back(J[j]);\n\t\t\t}\n\t\t\tif (S[i] == '/') {\n\t\t\t\tvector<int>J = Wari(solve(S.substr(0, i)), solve(S.substr(i + 1, S.size() - i - 1)));\n\t\t\t\tfor (int j = 0; j < J.size(); j++)K.push_back(J[j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn K;\n}\nint main() {\n\twhile (true) {\n\t\tstring U; cin >> U; if (U == \"#\")break;\n\t\tvector<int>ans = solve(U);\n\t\tsort(ans.begin(), ans.end());\n\t\tcout << ans.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nstring s;\ntypedef long long ll;\ntypedef string::const_iterator Iter;\ntypedef set<ll>::const_iterator SIter;\n\nIter skip_par(Iter it) {\n  it++;\n  for(int cnt=1;; it++) {\n    if(*it == '(') cnt ++;\n    if(*it == ')') cnt --;\n    if(cnt == 0) break;\n  }\n  return it;\n}\n\nbool number(Iter st, Iter ed, ll& ret) {\n  ret = 0;\n  for(Iter curr=st; curr!=ed; curr++) {\n    if(isdigit(*curr)) {\n      ret *= 10;\n      ret += (*curr)-'0';\n    }\n    else { return false; }\n  }\n  return true;\n}\n\nset<char> opes={'+','-','*','/'};\n\nset<ll> exp(Iter st, Iter ed) {\n  int pcnt=0; for(auto it=st;it!=ed;it++) if(*it=='(') pcnt++;\n  if(pcnt == 1 && *st == '(' && *(ed-1) == ')') { return exp(st+1, ed-1); }\n  {ll num; if(number(st, ed, num)) { return {num}; } }\n  set<ll> ret;\n  for(Iter curr=st; curr!=ed;curr++) {\n    if(*curr == '(') {\n      curr = skip_par(curr);\n    }\n    else if(opes.count(*curr)) {\n      set<ll> l = exp(st, curr);\n      set<ll> r = exp(curr+1,ed);\n      for(SIter i=l.begin(); i!=l.end(); i++) {\n        for(SIter j=r.begin(); j!=r.end(); j++) {\n          switch(*curr) {\n            case '+': ret.insert(*i+*j); break;\n            case '-': ret.insert(*i-*j); break;\n            case '*': ret.insert(*i**j); break;\n            case '/': if(*j!=0) { ret.insert(*i/(*j)); } break;\n          }\n        }\n      }\n    }\n  }\n\n  return ret;\n}\n\nint main()\n{\n  for(int i=0;i++,getline(cin, s);) {\n    if(s==\"#\") { break; }\n    Iter it = s.begin(), ed = s.end();\n    cout << exp(it, ed).size() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <algorithm>\n#include <climits>\n#include <vector>\nusing namespace std;\n\nint pos;\nstring line;\nstring table = \"+/*-\";\n \nvoid view(set<int> a){\n\tfor(set<int>::iterator it = a.begin() ; it != a.end() ; ++it){\n\t\tcout << *it << \" \";\n\t}\n\tcout << endl;\n}\nint mcalc(int a,int b,char c){\n\tswitch(c){\n\t\tcase '+': return a+b;\n\t\tcase '-': return a-b;\n\t\tcase '*': return a*b;\n\t\tcase '/': return b?a/b:INT_MAX;\n\t}\n}\nset<int> real(vector<int> num,vector<char> &op){\n\tvector<int> src = num;\n\tint o[] = {0,1,2,3,4,5,6,7,8,9} , n = op.size();\n\tset<int> answer;\n\tdo{\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint p = o[i];\n\t\t\tint r = mcalc(num[p],num[p+1],op[p]);\n\t\t\tif(r == INT_MAX) goto fail;\n\t\t\tnum[p] = num[p+1] = r;\n\t\t}\n\t\tanswer.insert(num[o[n-1]]);\n\t\tfail:;\n\t\tnum = src;\n\t}while(next_permutation(o,o+n));\n\t//for(int i = 0 ; i <= n ; i++) cout << num[i] << \" \";cout << endl;\n\t//cout << answer.size() << \" |\" ; view(answer);\n\treturn answer;\n}\n\nvector< vector<int> > var;\nvector<int> current;\nvoid func(vector<int> &cur,vector< set<int> > &num){\n\tif(cur.size() == num.size()){\n\t\tvar.push_back(cur);\n\t}else{\n\t\tint p = cur.size();\n\t\tfor(set<int>::iterator it = num[p].begin() ; it != num[p].end() ; ++it){\n\t\t\tcur.push_back(*it);\n\t\t\tfunc(cur,num);\n\t\t\tcur.pop_back();\n\t\t}\n\t}\n}\n\nset<int> calc(vector< set<int> > num,vector<char> op){\n\tvar.clear();\n\tcurrent.clear();\n\tfunc(current,num);\n\t\n\tset<int> answer;\n\tfor(int i = 0 ; i < var.size() ; i++){\n\t\tset<int> result = real(var[i],op);\n\t\tanswer.insert(result.begin(),result.end());\n\t}\n\treturn answer;\n}\nset<int> go(int depth){\n\tint cur = 0;\n\tvector< set<int> > num;\n\tvector<char> op;\n\twhile(1){\n\t\t//cout << depth << \":\" << pos << \" \" << line[pos] << \" \" << num.size() << endl;\n\t\tchar c = line[pos++];\n\t\tif( c== '('){\n\t\t\tnum.push_back(go(depth+1));\n\t\t}else if(c == ')'){\n\t\t\t//cout << \"[\" << depth << endl;\n\t\t\t//for(int i = 0 ; i < op.size() ; i++)\n\t\t\t//\tcout << op[i] << \" \" ; cout << endl;\n\t\t\t//for(int i = 0 ; i < num.size() ; i++)\n\t\t\t//\tcout << num[i].size() << \" \" ; cout << endl;\n\t\t\treturn calc(num,op);\n\t\t}else if(table.find(c) != -1){\n\t\t\top.push_back(c);\n\t\t}else{\n\t\t\tint number = c-'0';\n\t\t\t//cout << c << endl;\n\t\t\twhile(line[pos] >= '0' && line[pos] <= '9') number = number * 10 + line[pos] - '0' , pos++;\n\t\t\tset<int> add;\n\t\t\tadd.insert(number);\n\t\t\tnum.push_back(add);\n\t\t}\n\t}\n}\nint main(){\n\twhile(getline(cin,line) && line != \"#\"){\n\t\tpos = 0;\n\t\tline += \")\";\n\t\tcout << go(0).size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nchar S[211];\n\nset<ll> solve(int l,int r);\n\nvoid view( set<ll> b ){\n  cout << \"view\" << endl;\n  for( set<ll>::iterator it = b.begin(); it != b.end(); it++)\n    cout << *it << \" \";\n  cout << endl;\n}\n\nint check(int l,int r){\n  ll k = 0;\n  for(int i=l;i<=r;i++){\n    if( !isdigit(S[i]) ) return -1;\n    k*=10LL;\n    k+=(ll)(S[i]-'0');\n  }\n  return k;\n}\n\nset<ll> calc(set<ll> a,set<ll> b,char c){\n  set<ll> ret;\n  for( set<ll>::iterator it = a.begin(); it != a.end(); it++){\n    for( set<ll>::iterator jt = b.begin(); jt != b.end(); jt++){\n      if( c == '+' ){\n\tret.insert( *it + *jt );\n      } else if( c== '-' ){\n\tret.insert( *it - *jt );\n      } else if( c== '*' ){\n\tret.insert( (*it) * (*jt) );\n      } else {\n\tif( *jt == 0 ) continue;\n\tret.insert( *it / *jt );\n      }\n    }\n  }\n  return ret;\n}\n\nset<ll> check2(int l,int r){\n  int cnt = 0;\n  set<ll> a,b;\n  int nc = -1;\n  for(int i=l;i<=r;i++){\n    if( S[i] == '(' ){\n      cnt++;\n    } else if (S[i] == ')' ){\n      cnt--;\n    }\n    else if( cnt == 0  && ( S[i] == '+' || S[i] == '-' || S[i] == '*' || S[i] == '/' )){\n      a = calc( solve(l,i-1), solve(i+1,r), S[i]);\n      nc = i;\n      break;\n    }\n  }\n  cnt = 0;  \n  for(int i=r;i>=l;i--){\n    if( S[i] == ')' ){\n      cnt++;\n    } else if (S[i] == '(' ){\n      cnt--;\n    }\n    else if( cnt == 0  && ( S[i] == '+' || S[i] == '-' || S[i] == '*' || S[i] == '/' )){\n      if( nc == i ) break;\n      b = calc( solve(l,i-1), solve(i+1,r), S[i]);\n      break;\n    }\n  }\n  //  cout << l << \" \"<< r << endl;\n  //view(a);\n  if( b.empty() ) return a;\n  // view(b);\n  for( set<ll>::iterator it = b.begin(); it != b.end(); it++)\n    a.insert( *it );\n\n\n  return a;\n}\n\nbool check3(int l,int r){\n  int cnt = 0;\n  if( S[l] != '(' ) return false;\n  for(int i=l;i<=r;i++){\n    if( S[i] == '(' ) cnt++;\n    else if( S[i] == ')' ){\n      cnt--;\n      if( cnt == 0 && i == r ) return true;       \n      return false;\n    }\n  }\n  return false;\n}\n\nset<ll> solve(int l,int r){\n  if( check3(l,r) )\n    return solve(l+1,r-1);\n  \n  int tmp = check(l,r);\n  if( tmp>-1 ){\n    //cout << l << \" \"<< r << \" \" << tmp << endl;\n    set<ll> s; s.insert(tmp);\n    return s;\n  }\n  \n  return check2(l,r);\n}\n\n\nint main(){\n  while( cin >> S ){\n    if( S[0] == '#' ) break;\n    set<ll> res = solve(0,strlen(S)-1);\n    cout << res.size() << endl;\n    //    view(res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int DUMMY = 1e13;\nint op(int l, int r, char c) {\n    if (l == DUMMY || r == DUMMY) return DUMMY;\n    if (c == '+') return l + r;\n    if (c == '-') return l - r;\n    if (c == '*') return l * r;\n    if (c == '/') return r == 0 ? DUMMY : l / r;\n    assert(0);\n}\nbool is_op(char c) {\n    return c == '+' || c =='-' || c == '*' || c == '/';\n}\n\nstruct expr_t {\n    int imd = -1;\n    vector<expr_t> vals;\n    vector<char> ops;\n};\nint number(string& s, int& i) {\n    int acc = 0;\n    while (isdigit(s[i])) {\n        acc = acc * 10 + (s[i++] - '0');\n    }\n    return acc;\n}\nexpr_t expr1(string& s, int& i);\nexpr_t expr2(string& s, int& i);\n\nexpr_t expr1(string& s, int& i) {\n    expr_t ret;\n    while (i < s.size() && s[i] != ')') {\n        if (is_op(s[i])) {\n            ret.ops.push_back(s[i++]);\n        } else if (s[i] == '(') {\n            ret.vals.push_back(expr1(s, ++i));\n            i++;\n        } else if (s[i] == ')') {\n            i++;\n            break;\n        } else {\n            ret.vals.push_back(expr2(s, i));\n        }\n    }\n    return ret;\n}\nexpr_t expr2(string& s, int& i) {\n    return expr_t({number(s, i)});\n}\nset<int> calc(expr_t e) {\n    if (e.imd != -1) {\n        set<int> ret;\n        ret.insert(e.imd);\n        return ret;\n    }\n    assert(e.vals.size() == e.ops.size() + 1);\n    int n = e.vals.size();\n    vector<vector<set<int>>> dp(n, vector<set<int>>(n));\n    function<set<int>(int, int)> dfs = [&](int i, int j) {\n        set<int>& ret = dp[i][j];\n        if (ret.size() != 0) return ret;\n        if (i == j) return ret = calc(e.vals[i]);\n        for (int k = i; k < j; k++) {\n            set<int> ls = dfs(i, k);\n            set<int> rs = dfs(k + 1, j);\n            for (int l : ls) {\n                for (int r : rs) {\n                    ret.insert(op(l, r, e.ops[k]));\n                }\n            }\n        }\n        return ret;\n    };\n    return dfs(0, n - 1);\n}\nvoid solve() {\n    string s; cin >> s;\n    if (s == \"#\") exit(0);\n    int i = 0;\n    expr_t res = expr1(s, i);\n    set<int> ret = calc(res);\n    if (ret.count(DUMMY)) ret.erase(DUMMY);\n    cout << ret.size() << endl;\n}\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while (1) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<set>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nusing namespace std;\nconst int inf=1000000010;\n\nset<int> dp[200][200];\nstring in;\n\nset<int> rec(int s,int t){\n\tif(dp[s][t].count(inf))return dp[s][t];\n\t\n\tdp[s][t].insert(inf);\n\tint i=s,d=0,found=0;\n\t\n\tfor(;i<t;i++){\n\t\tif(in[i]=='(')d++;\n\t\tif(in[i]==')')d--;\n\t\t\n\t\tif(d==0&&(in[i]=='+'||in[i]=='-'||in[i]=='*'||in[i]=='/')){\n\t\t\tfound=1;\n\t\t\t\n\t\t\tset<int> l=rec(s,i-1), r=rec(i+1,t);\n\t\t\tfr(ii,l)fr(jj,r){\n\t\t\t\tif(*ii==inf||*jj==inf)continue;\n\t\t\t\t\n\t\t\t\tif(in[i]=='+')dp[s][t].insert(*ii + *jj);\n\t\t\t\tif(in[i]=='-')dp[s][t].insert(*ii - *jj);\n\t\t\t\tif(in[i]=='*')dp[s][t].insert(*ii * *jj);\n\t\t\t\tif(in[i]=='/'&&*jj!=0)dp[s][t].insert(*ii / *jj);\n\t\t\t}\n\t\t}\n\t}\n\tif(!found){\n\t\tif(in[s]=='(')return dp[s][t]=rec(s+1,t-1);\n\t\t\n\t\tstringstream ss(in.substr(s,t-s+1));\n\t\tint n; ss>>n;\n\t\tdp[s][t].insert(n);\n\t}\n\treturn dp[s][t];\n}\nint main()\n{\n\twhile(cin>>in,in!=\"#\"){\n\t\trep(i,200)rep(j,200)dp[i][j].clear();\n\t\t\n\t\trec(0,in.size()-1);\n\t\tcout<<dp[0][in.size()-1].size()-1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nconst int N = 200;\nbool ok[N][N];\nset<int> dp[N][N];\n\nstring s;\nset<int> calc(int l, int r){\n\tif (ok[l][r]) return dp[l][r];\n\tok[l][r] = 1;\n\tauto &res = dp[l][r];\n\n\tint nest = 0;\n\tbool ope = false;\n\tfor (int i = l; i < r; ++i){\n\t\tif (s[i] == '(') ++nest;\n\t\telse if (s[i] == ')') --nest;\n\t\telse if (!nest && s[i] < '0' || s[i] > '9'){\n\t\t\tope = true;\n\t\t\tauto L = calc(l, i), R = calc(i+1, r);\n\t\t\tfor (auto e1 : L){\n\t\t\t\tfor (auto e2 : R){\n\t\t\t\t\tif (s[i] == '+') res.insert(e1 + e2);\n\t\t\t\t\tif (s[i] == '-') res.insert(e1 - e2);\n\t\t\t\t\tif (s[i] == '*') res.insert(e1 * e2);\n\t\t\t\t\tif (s[i] == '/' && e2) res.insert(e1 / e2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ope){\n\t\tif (s[l] == '(' && s[r - 1] == ')') res = calc(l + 1, r - 1);\n\t\telse res.insert(stoi(s.substr(l, r - l)));\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile (cin >> s, s != \"#\"){\n\t\tint n = s.size();\n\t\tfor (int i = 0; i < N; ++i) for (int j = 0; j < N; ++j){\n\t\t\tok[i][j] = 0;\n\t\t\tdp[i][j].clear();\n\t\t}\n\t\tcout << calc(0, n).size() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <climits>\nusing namespace std;\n\n#define DEB 0\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n\nstring in;\nset<int> dp[200][200];\n\nbool isope(char c){\n  return (c=='+'||c=='-'||c=='*'||c=='/');\n}\nset<int> parse(int s, int t){\n  int i;\n  int x = 0;\n  bool f = false;\n\n  if( dp[s][t].size()>0 ) return dp[s][t];\n\n  for(i=s; i<t; i++){\n    if( in[i]=='(' )x++;\n    if( in[i]==')' )x--;\n    if( x==0 && isope(in[i]) ){\n      f = true;\n      set<int> left = parse(s,i-1);\n      set<int> right = parse(i+1,t);\n      set<int>::iterator j,k;\n      for(j=left.begin(); j!=left.end(); j++){\n        for(k=right.begin(); k!=right.end(); k++){\n          if( in[i]=='+' ) dp[s][t].insert(*j + *k);\n          if( in[i]=='-' ) dp[s][t].insert(*j - *k);\n          if( in[i]=='*' ) dp[s][t].insert(*j * *k);\n          if( in[i]=='/' && *k!=0 ) dp[s][t].insert(*j / *k);\n#if DEB\n          printf(\"s:%d, t:%d  i:%d  %d-%d\\n\",s,t,i,*j,*k);\n#endif\n        }\n      }\n    }\n  }\n  if( !f ){\n    if( in[s]=='(' ) return dp[s][t]=parse(s+1, t-1);\n    int d = atoi(in.substr(s,t-s+1).c_str());\n    dp[s][t].insert(d);\n  }\n  return dp[s][t];\n}\n\nint main(){\n  while(cin>>in,in!=\"#\"){\n    rep(i,200)rep(j,200)dp[i][j].clear();\n    parse(0,in.size()-1);\n    printf(\"%d\\n\",dp[0][in.size()-1].size());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\nconst double EPS = 1e-9;\n\ntemplate<class T>\nostream& operator<<(ostream& os,const vector<T>& vec){\n    for(int i=0;i<vec.size();i++){\n        os << vec[i];\n        if(i != vec.size()-1) os << \" \";\n    }\n    return os;\n}\n\nint to_int(string s){\n    stringstream ss;\n    ss << s;\n    int ret;\n    ss >> ret;\n    return ret;\n}\n\nset<int> eval(const string& str){\n    vector<string> terms;\n    vector<char> ops;\n    for(int i=0;i<str.size();i++){\n        if(isdigit(str[i])){\n            string num = \"\";\n            for(;i<str.size() and isdigit(str[i]);i++){\n                num += str[i];\n            }\n            i--;\n            terms.push_back(num);\n        }else if(str[i] == '('){\n            int p = 0;\n            int  from = i,to = -1;\n            for(;i<str.size();i++){\n                if(str[i] == '('){\n                    p++;\n                }else if(str[i] == ')'){\n                    if(p == 1){\n                        to = i;\n                        break;\n                    }\n                    p--;\n                }\n            }\n            terms.push_back(str.substr(from,to-from+1));\n        }else{\n            ops.push_back(str[i]);\n        }\n    }\n    //cerr << \"terms:\" << terms << endl;\n    //cerr << \"ops:\" << ops << endl;\n    set<int> ret;\n    if(terms.size() == 1){\n        string now = terms[0];\n        if(now[0] == '('){\n            ret = eval(now.substr(1,now.size()-2));\n        }else{\n            ret.insert(to_int(now));\n        }\n        return ret;\n    }else{\n        // look\n        for(int i=0;i<ops.size();i++){\n            string lhs,rhs;\n            for(int j=0;j<ops.size();j++){\n                if(i >= j){\n                    lhs += terms[j];\n                    if(i != j){\n                        lhs += ops[j];\n                    }\n                }else{\n                    rhs += terms[j];\n                    rhs += ops[j];\n                }\n            }\n            rhs += terms.back();\n            //cerr << \"lhs:\" << lhs << endl;\n            //cerr << \"rhs:\" << rhs << endl;\n            set<int> le = eval(lhs);\n            set<int> re = eval(rhs);\n            for(set<int>::iterator lit=le.begin();lit!=le.end();++lit){\n                for(set<int>::iterator rit=re.begin();rit!=re.end();++rit){\n                    if(ops[i] == '+'){\n                        ret.insert(*lit + *rit);\n                    }else if(ops[i] == '-'){\n                        ret.insert(*lit - *rit);\n                    }else if(ops[i] == '*'){\n                        ret.insert(*lit * *rit);\n                    }else if(ops[i] == '/'){\n                        if(*rit == 0) continue;\n                        // tokusyu?\n                        ret.insert(*lit / *rit);\n                    }\n                }\n            }\n        }\n        return ret;\n    }\n}\n\nint main(){\n    while(true){\n        string s;\n        cin >> s;\n        if(s == \"#\") break;\n        set<int> ret = eval(s);\n        cout << ret.size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nvector<char> op;\nvector<int> perm;\nbool ok;\n\nint pr(string s)\n{\n    if('0'<=s[0] && s[0]<='9') return -1;\n    if(s[0]=='(' || s[0]==')') return 1919;\n    return perm[s[0]-'a'];\n}\n\nll E(string s)\n{\n    int S = s.size();\n\n    vector<string> p;\n    stack<string> st;\n    int idx = 0;\n    while(idx<S)\n    {\n        if(s[idx]=='(')\n        {\n            st.push(\"(\");\n            ++idx;\n        }\n        else if(s[idx]==')')\n        {\n            while(1)\n            {\n                string now = st.top(); st.pop();\n                if(now==\"(\") break;\n                p.pb(now);\n            }\n            ++idx;\n        }\n        else\n        {\n            string x;\n            if('a'<=s[idx] && s[idx]<='z')\n            {\n                x = s.substr(idx,1);\n                ++idx;\n            }\n            else\n            {\n                int start = idx;\n                while(idx<S && '0'<=s[idx] && s[idx]<='9') ++idx;\n                x = s.substr(start,idx-start);\n            }\n\n            bool pushed=false;\n            while(!st.empty())\n            {\n                string now = st.top(); st.pop();\n                if(pr(now)<=pr(x)) p.pb(now);\n                else\n                {\n                    st.push(now);\n                    st.push(x);\n                    pushed = true;\n                    break;\n                }\n            }\n            if(!pushed) st.push(x);\n        }\n    }\n    while(!st.empty())\n    {\n        p.pb(st.top());\n        st.pop();\n    }\n\n    stack<ll> val;\n    for(const auto &x:p)\n    {\n        if('a'<=x[0] && x[0]<='z')\n        {\n            ll Y = val.top(); val.pop();\n            ll X = val.top(); val.pop();\n\n            char OP = op[x[0]-'a'];\n            if(OP=='+') val.push(X+Y);\n            if(OP=='-') val.push(X-Y);\n            if(OP=='*') val.push(X*Y);\n            if(OP=='/')\n            {\n                if(Y==0)\n                {\n                    ok = false;\n                    val.push(0);\n                }\n                else val.push(X/Y);\n            }\n        }\n        else val.push(atoll(x.c_str()));\n    }\n\n    return val.top();\n}\n\nint main()\n{\n    string s;\n    while(cin >>s,(s!=\"#\"))\n    {\n        op.clear();\n        int OP = 0;\n\n        rep(i,s.size())if(s[i]=='+' || s[i]=='-' || s[i]=='*' || s[i]=='/')\n        {\n            op.pb(s[i]);\n            s[i] = 'a'+OP;\n            ++OP;\n        }\n\n        perm.resize(OP);\n        iota(all(perm),0);\n\n        set<ll> res;\n        do {\n            ok = true;\n            ll val = E(s);\n            if(ok) res.insert(val);\n        } while(next_permutation(all(perm)));\n\n        cout << res.size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nvector<int> perm(10);\n\nvector<ll> dfs(string s) {\n    vector<vector<ll>> num;\n    vector<char> op;\n\n    int i = 0;\n    while(i < s.length()) {\n        if ('0' <= s[i] && s[i] <= '9') {\n            int tmp = 0;\n            while('0' <= s[i] && s[i] <= '9') {\n                tmp = tmp * 10 + (s[i] - '0');\n                i++;\n            }\n            num.pb(vector<ll>(1, tmp));\n            i--;\n        } else if (s[i] == '(') {\n            int j = i + 1;\n            while(s[j] != ')') j++;\n            num.pb(dfs(s.substr(i + 1, j - i - 1)));\n            i = j;\n        } else {\n            op.pb(s[i]);\n        }\n        i++;\n    }\n\n    iota(all(perm), 0);\n    vector<ll> ans;\n    do {\n        vector<vector<ll>> v(num);\n\n        bool ok = true;\n        rep(i, op.size()) {\n            vector<ll> tmp;\n            int l = perm[i];\n            while(v[l].empty()) l--;\n            rep(j, v[l].size()) {\n                rep(k, v[perm[i] + 1].size()) {\n                    switch(op[perm[i]]) {\n                        case '+':\n                        tmp.pb(v[l][j] + v[perm[i] + 1][k]); break;\n                        case '-':\n                        tmp.pb(v[l][j] - v[perm[i] + 1][k]); break;\n                        case '*':\n                        tmp.pb(v[l][j] * v[perm[i] + 1][k]); break;\n                        case '/':\n                        if (v[perm[i] + 1][k] != 0) tmp.pb(v[l][j] / v[perm[i] + 1][k]); break;\n                    }\n                }\n            }\n\n            if (tmp.size() == 0) {\n                ok = false;\n                break;\n            }\n            uni(tmp);\n            v[l] = tmp;\n            v[perm[i] + 1].clear();\n        }\n        if (ok) rep(i, v[0].size()) ans.pb(v[0][i]);\n    } while(next_permutation(perm.begin(), perm.begin() + op.size()));\n\n    uni(ans);\n    return ans;\n}\n\nint main(){\n    cin.sync_with_stdio(false);\n    string s;\n    while(cin >> s, s[0] != '#') {\n        cout << dfs(s).size() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint to_int(string s){\n  int res;\n  stringstream ss;\n  ss << s;\n  ss >> res;\n  return res;\n}\n\nbool is_op(char c){\n  return\n    c == '+' ||\n    c == '-' ||\n    c == '*' ||\n    c == '/';\n}\n\nset<int> calc_op(char op, set<int> set1, set<int> set2){\n  set<int> res;\n  for(auto itr1 = set1.begin(); itr1 != set1.end();++itr1){\n    for(auto itr2 = set2.begin(); itr2 != set2.end();++itr2){\n      if(op == '+'){\n\tres.insert((*itr1) + (*itr2));\n      }else if(op == '-'){\n\tres.insert((*itr1) - (*itr2));\n      }else if(op == '*'){\n\tres.insert((*itr1) * (*itr2));\n      }else if(op == '/'){\n\tif((*itr2) != 0){\n\t  res.insert((*itr1) / (*itr2));\n\t}\n      }\t\n    }\n  }\n  return res;\n}\n\nset<int> solve(string s){\n  vector< vector<set<int>>> dp;\n  vector< char > op;\n  dp.resize(20);\n  for(int i = 0;i < 20;++i){\n    dp[i].resize(20);       \n  }\n  int len = (int)s.size(),size = 0,p = 0;\n  while(p < len){\n    if(s[p] == '('){\n      int q = p+1;\n      int balance = 1;\n      while(1){\n\tif(s[q] == '('){\n\t  ++balance;\n\t}else if(s[q] == ')'){\n\t  --balance;\n\t  if(balance == 0)break;\n\t}\n\t++q;\n      }\n      string elem = s.substr(p+1,q-p-1);\n      dp[size][size] = solve(elem);\n      ++size;\n      p = q;\n    }else if(is_op(s[p])){\n      op.push_back(s[p]);\n    }else{\n      int q = p+1;\n      while(q < len && '0' <= s[q] && s[q] <= '9')++q;\n      string elem = s.substr(p,q-p);\n      int num = to_int(elem);\n      dp[size][size].clear();\n      dp[size][size].insert(num);\n      ++size;\n      p = q-1;\n    }\n    ++p;\n  }\n  for(int step = 1;step < size;++step){\n    for(int i = 0;i + step < size;++i){\n      int j = i + step;\n      for(int k = i;k < j;++k){\n\tset<int> calc = calc_op(op[k],dp[i][k],dp[k+1][j]);\n\tfor(auto elem : calc)dp[i][j].insert(elem);\n      }\n    }\n  }\n  return dp[0][size-1];\n}\n\nint main(){\n  string s;\n  while(cin >> s,s != \"#\"){\n    set<int> res = solve(s);\n    /*\n    for(auto elem : res){\n      cout << elem << \" \";\n    }\n    cout << endl;\n    */\n    cout << (int)res.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nstruct State {\n    int pos;\n    string str;\n    State(string s) : pos(0), str(move(s)) {}\n    char get() { return str[pos]; }\n    char next() { return str[pos++]; }\n    char prev() { return str[pos--]; }\n    bool is_end() { return pos == str.size(); }\n};\n\nenum ElemType {\n    INT,\n    OP_ADD,\n    OP_SUB,\n    OP_MUL,\n    OP_DIV,\n    L_PAR,\n    R_PAR,\n    NIL,\n};\n\nstruct Elem {\n    ElemType type;\n    int value;\n    Elem() {}\n    Elem(ElemType type) : type(type) {}\n};\n\nlist<Elem> lexer(State &state) {\n    if (state.is_end()) {\n        Elem e;\n        e.type = NIL;\n        return {e};\n    }\n\n    Elem e;\n    e.value = -100;\n    switch (state.get()) {\n    case '(': e.type = L_PAR; break;\n    case ')': e.type = R_PAR; break;\n    case '+': e.type = OP_ADD; break;\n    case '-': e.type = OP_SUB; break;\n    case '*': e.type = OP_MUL; break;\n    case '/': e.type = OP_DIV; break;\n    default:\n        e.type = INT;\n        int value = 0;\n        while ('0' <= state.get() && state.get() <= '9') {\n            value *= 10;\n            value += state.get() - '0';\n            state.next();\n        }\n        e.value = value;\n        state.prev();\n        break;\n    }\n    state.next();\n\n    auto ret = lexer(state);\n    ret.push_front(e);\n    return ret;\n}\n\nvoid print(list<Elem>::iterator left, list<Elem>::iterator right) {\n    if (left == right) {\n        cout << endl;\n        return;\n    }\n\n    switch (left->type) {\n    case INT:\n        cout << \"INT: \" << left->value << \", \";\n        break;\n    case OP_ADD:\n        cout << \"OP_ADD, \";\n        break;\n    case OP_SUB:\n        cout << \"OP_SUB, \";\n        break;\n    case OP_MUL:\n        cout << \"OP_MUL, \";\n        break;\n    case OP_DIV:\n        cout << \"OP_DIV, \";\n        break;\n    case L_PAR:\n        cout << \"L_PAR, \";\n        break;\n    case R_PAR:\n        cout << \"R_PAR, \";\n        break;\n    case NIL:\n        cout << \"NIL, \";\n        break;\n    }\n\n    print(next(left), right);\n}\n\nvoid simplify(list<Elem> &elems, list<Elem>::iterator itr) {\n    while (prev(itr)->type == L_PAR && next(itr)->type == R_PAR) {\n        elems.erase(prev(itr));\n        elems.erase(next(itr));\n    }\n}\n\nbool check_bothside(list<Elem>::iterator itr) {\n    return (prev(itr)->type != R_PAR && next(itr)->type != L_PAR);\n}\n\nsigned main() {\n    while (1) {\n        string s;\n        cin >> s;\n        if (s == \"#\") break;\n\n        State state(s);\n        auto elems = lexer(state);\n        elems.emplace_front(NIL);\n\n\n        int op_num = 0;\n        for (auto itr = next(elems.begin()); itr != prev(elems.end()); itr++) {\n            if (itr->type == OP_ADD || itr->type == OP_SUB || itr->type == OP_MUL || itr->type == OP_DIV) {\n                op_num++;\n            }\n            simplify(elems, itr);\n        }\n        vector<int> ord(op_num);\n        for (int i = 0; i < ord.size(); i++) ord[i] = i;\n\n        set<int> values;\n        do {\n            if (op_num == 0) break;\n\n            auto tmp = elems;\n            vector<list<Elem>::iterator> ops;\n            for (auto itr = tmp.begin(); itr != tmp.end(); itr++) {\n                if (itr->type == OP_ADD || itr->type == OP_SUB || itr->type == OP_MUL || itr->type == OP_DIV) {\n                    ops.push_back(itr);\n                }\n            }\n\n            bool invalid = false;\n            for (int i = 0; i < ord.size(); i++) {\n                int idx = ord[i];\n                if (!check_bothside(ops[idx])) {\n                    invalid = true;\n                    break;\n                }\n\n                switch (ops[idx]->type) {\n                case OP_ADD:\n                    ops[idx]->value = prev(ops[idx])->value + next(ops[idx])->value;\n                    break;\n                case OP_SUB:\n                    ops[idx]->value = prev(ops[idx])->value - next(ops[idx])->value;\n                    break;\n                case OP_MUL:\n                    ops[idx]->value = prev(ops[idx])->value * next(ops[idx])->value;\n                    break;\n                case OP_DIV:\n                    ops[idx]->value = prev(ops[idx])->value / next(ops[idx])->value;\n                    break;\n                default:\n                    assert(false);\n                }\n                \n                ops[idx]->type = INT;\n                tmp.erase(next(ops[idx]));\n                tmp.erase(prev(ops[idx]));\n                simplify(tmp, ops[idx]);\n            }\n            if (invalid) continue;\n            values.insert(next(tmp.begin())->value);\n        } while (next_permutation(ord.begin(), ord.end()));\n\n        if (op_num == 0) {\n            values.insert(next(elems.begin())->value);\n        }\n        cout << values.size() << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\nset<int> dp[200][200];\t//closed\nstring s;\nvoid num(int &x){\n\tint ret=0,y=x;\n\twhile(isdigit(s[y])){\n\t\tret*=10;\n\t\tret+=s[y]-'0';\n\t\ty++;\n\t}\n\tdp[x][y-1].insert(ret);\n\tx=y;\n}\nint main(){\n\twhile(true){\n\t\tcin>>s;\n\t\tif(s[0]=='#') break;\n\t\tint N=s.size();\n\t\trep(i,N) rep(j,N) dp[i][j].clear();\n\t\tfor(int x=0;x<N;x++){\n\t\t\tif(isdigit(s[x])) num(x);\n\t\t}\n\t\trep(d,N) rep(x,N-d){\n\t\t\tint y=x+d;\n\t\t\tif(s[x]=='('&&s[y]==')'&&!dp[x+1][y-1].empty()){\n\t\t\t\tdp[x][y]=dp[x+1][y-1];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int m=x+1;m<=y-1;m++){\n\t\t\t\tif(s[m]=='+'){\n\t\t\t\t\tfor(int a:dp[x][m-1]) for(int b:dp[m+1][y]) dp[x][y].insert(a+b);\n\t\t\t\t}\n\t\t\t\tif(s[m]=='-'){\n\t\t\t\t\tfor(int a:dp[x][m-1]) for(int b:dp[m+1][y]) dp[x][y].insert(a-b);\n\t\t\t\t}\n\t\t\t\tif(s[m]=='*'){\n\t\t\t\t\tfor(int a:dp[x][m-1]) for(int b:dp[m+1][y]) dp[x][y].insert(a*b);\n\t\t\t\t}\n\t\t\t\tif(s[m]=='/'){\n\t\t\t\t\tfor(int a:dp[x][m-1]) for(int b:dp[m+1][y]) if(b!=0) dp[x][y].insert(a/b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dp[0][s.size()-1].size()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\n#define fs first\n#define sc second\n\nconst LL MOD = 1e9+7;\nconst double EPS = 1e-10;\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>bool chmin(T &a, const T &b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename... Ts>\nauto make_vector(size_t a, size_t b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a,make_vector<T>(b,ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) {\n        is >> e;\n    }\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n\n    operator int() const { return to; }\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\ntemplate<typename T>\nusing Edges = vector<edge<T>>;\ntemplate<typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate<typename T>\nusing MatrixGraph = vector<vector<T>>;\n\nusing State = string::const_iterator;\nclass ParseError {};\n\nset<int> num(State &begin) {\n    int n = 0;\n    while ('0' <= *begin && *begin <= '9') {\n        n *= 10;\n        n += (*begin - '0');\n        begin++;\n    }\n    return set<int>{n};\n}\n\nset<int> expression(State &begin);\n\nset<int> factor(State &begin) {\n    if (*begin == '(') {\n        begin++;\n        auto ret = expression(begin);\n        assert(*begin == ')');\n        begin++;\n        return ret;\n    } else {\n        return num(begin);\n    }\n}\n\nset<int> expression(State &begin) {\n    vector<set<int>> facts{factor(begin)};\n    vector<char> ops;\n    while (true) {\n        if (*begin == '+' || *begin == '-' ||\n            *begin == '*' || *begin == '/') {\n            ops.push_back(*begin);\n            begin++;\n            facts.push_back(factor(begin));\n        } else {\n            break;\n        }\n    }\n\n    int m = ops.size();\n    vector<int> ord(m);\n    iota(ord.begin(), ord.end(), 0);\n\n    set<int> ret;\n    do {\n        vector<set<int>> buff = facts;\n        bool invalid = false;\n        for (auto i : ord) {\n            int l = i, r = i+1;\n            while (l >= 0 && buff[l].size() == 0) --l;\n            if (l < 0) {\n                invalid = true;\n                break;\n            }\n\n            set<int> tmp;\n            for (auto a : buff[l]) {\n                for (auto b : buff[r]) {\n                    if (ops[i] == '+') {\n                        tmp.insert(a+b);\n                    } else if (ops[i] == '-') {\n                        tmp.insert(a-b);\n                    } else if (ops[i] == '*') {\n                        tmp.insert(a*b);\n                    } else if (b != 0) {\n                        tmp.insert(a/b);\n                    }\n                }\n            }\n\n            buff[l] = tmp;\n            buff[r].clear();\n        }\n\n        if (invalid) continue;\n\n        for (auto val : buff[0]) {\n            ret.insert(val);\n        }\n\n    } while (next_permutation(ord.begin(), ord.end()));\n\n    return ret;\n}\n\n\nint main()\n{\n    while (true) {\n        string s; cin >> s;\n        if (s[0] == '#') {\n            break;\n        }\n\n        State begin = s.begin();\n        auto ans = expression(begin);\n        cout << ans.size() << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <stack>\n#include <exception>\n#include <algorithm>\n#include <utility>\n#include <cctype>\n#include <cmath>\n\nusing namespace std;\ntypedef pair<string, int> psi;\n\nstring OPERATORS[10];\nint BRACE_PRIORITY = 10;\n\nstring infix2rpn(const string &expression){\n\tstringstream ss(expression);\n\tvector<psi> tokens;\n\twhile(ss.tellg() < ss.str().size()){\n\t\tchar c = ss.peek();\n\t\tif(isdigit(c)){\n\t\t\tstring s;\n\t\t\twhile(isdigit(ss.peek())){ s += ss.get(); }\n\t\t\ttokens.push_back(psi(s, -1));\n\t\t}else if(c == '('){\n\t\t\tss.get();\n\t\t\tint depth = 0;\n\t\t\tstring sub;\n\t\t\twhile(depth >= 0){\n\t\t\t\tc = ss.get();\n\t\t\t\tif(c == ')' && depth == 0){ break; }\n\t\t\t\tsub += c;\n\t\t\t\tif(c == '('){ ++depth; }\n\t\t\t\tif(c == ')'){ --depth; }\n\t\t\t}\n\t\t\ttokens.push_back(psi(infix2rpn(sub), -1));\n\t\t}else{\n\t\t\tss.get();\n\t\t\tint priority = 0;\n\t\t\tfor(; priority < BRACE_PRIORITY; ++priority){\n\t\t\t\tif(OPERATORS[priority].find_first_of(c) != string::npos){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttokens.push_back(psi(string(1, c), priority));\n\t\t}\n\t}\n\twhile(tokens.size() > 1){\n\t\tint target = 0;\n\t\tfor(int i = 1; i < tokens.size(); ++i){\n\t\t\tif(tokens[target].second < tokens[i].second){ target = i; }\n\t\t}\n\t\ttokens[target - 1].first =\n\t\t\ttokens[target - 1].first + \" \" +\n\t\t\ttokens[target + 1].first + \" \" +\n\t\t\ttokens[target].first;\n\t\ttokens[target - 1].second = -1;\n\t\ttokens.erase(tokens.begin() + target, tokens.begin() + target + 2);\n\t}\n\treturn tokens[0].first;\n}\n\nint solve(const string &expression){\n\tstack<int> stk;\n\tstringstream ss(expression);\n\twhile(ss.tellg() < ss.str().size()){\n\t\twhile(ss.peek() == ' '){ ss.get(); }\n\t\tif(isdigit(ss.peek())){\n\t\t\tint value;\n\t\t\tss >> value;\n\t\t\tstk.push(value);\n\t\t}else{\n\t\t\tstring op;\n\t\t\tss >> op;\n\t\t\tint left, right;\n\t\t\tright = stk.top(); stk.pop();\n\t\t\tleft = stk.top(); stk.pop();\n\t\t\tif('A' <= op[0] && op[0] < 'A' + 13){\n\t\t\t\tstk.push(left + right);\n\t\t\t}else if('A' + 13 <= op[0] && op[0] < 'A' + 26){\n\t\t\t\tstk.push(left - right);\n\t\t\t}else if('a' <= op[0] && op[0] < 'a' + 13){\n\t\t\t\tstk.push(left * right);\n\t\t\t}else if('a' + 13 <= op[0] && op[0] < 'a' + 26){\n\t\t\t\tif(right == 0){ throw exception(); }\n\t\t\t\tstk.push(abs(left) / abs(right) * ((left < 0) ^ (right < 0) ? -1 : 1));\n\t\t\t}\n\t\t}\n\t}\n\treturn stk.top();\n}\n\nint main(){\n\twhile(true){\n\t\tstring expression;\n\t\tcin >> expression;\n\t\tif(expression == \"#\"){ break; }\n\t\tvector<int> operators;\n\t\tfor(int i = 0; i < expression.size(); ++i){\n\t\t\tif(!isdigit(expression[i])){\n\t\t\t\tif(expression[i] == '+'){\n\t\t\t\t\texpression[i] = 'A';\n\t\t\t\t}else if(expression[i] == '-'){\n\t\t\t\t\texpression[i] = 'A' + 13;\n\t\t\t\t}else if(expression[i] == '*'){\n\t\t\t\t\texpression[i] = 'a';\n\t\t\t\t}else if(expression[i] == '/'){\n\t\t\t\t\texpression[i] = 'a' + 13;\n\t\t\t\t}\n\t\t\t\toperators.push_back(i);\n\t\t\t}\n\t\t}\n\t\tBRACE_PRIORITY = operators.size();\n\t\tset<int> answers;\n\t\tdo {\n\t\t\tfor(int i = 0; i < operators.size(); ++i){\n\t\t\t\tchar &op = expression[operators[i]];\n\t\t\t\tif('A' <= op && op < 'A' + 13){\n\t\t\t\t\top = 'A' + i;\n\t\t\t\t}else if('A' + 13 <= op && op < 'A' + 26){\n\t\t\t\t\top = 'A' + 13 + i;\n\t\t\t\t}else if('a' <= op && op < 'a' + 13){\n\t\t\t\t\top = 'a' + i;\n\t\t\t\t}else if('a' + 13 <= op && op < 'a' + 26){\n\t\t\t\t\top = 'a' + 13 + i;\n\t\t\t\t}\n\t\t\t\tOPERATORS[i] = string(1, op);\n\t\t\t}\n\t\t\tstring rpn = infix2rpn(expression);\n\t\t\ttry {\n\t\t\t\tint answer = solve(rpn);\n\t\t\t\tanswers.insert(answer);\n\t\t\t}catch(exception){\n\t\t\t}\n\t\t} while(next_permutation(operators.begin(), operators.end()));\n\t\tcout << answers.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint next_paren(string expr, int i) {\n    int level = 0;\n    for (; i < (int)expr.length(); i++) {\n        switch (expr[i]) {\n        case '(':\n            level++;\n            break;\n        case ')':\n            level--;\n            if (level == 0) return i;\n            break;\n        }\n    }\n    assert(0);\n}\n\nset<int> eval(string expr) {\n    vector<string> terms;\n    vector<char> ops;\n    REP(i, expr.length()) {\n        switch (expr[i]) {\n        case '(': {\n            int j = next_paren(expr, i);\n            terms.push_back(expr.substr(i, j-i+1));\n            i = j;\n            break;\n        }\n        case '+':\n        case '-':\n        case '*':\n        case '/':\n            ops.push_back(expr[i]);\n            break;\n        default: {\n            string num;\n            for (; i < (int)expr.length() && isdigit(expr[i]); i++) {\n                num += expr[i];\n            }\n            terms.push_back(num);\n            i--;\n        }\n        }\n    }\n\n    set<int> res;\n    if (ops.empty()) {\n        if (terms[0][0] == '(') {\n            return eval(terms[0].substr(1, terms[0].length()-2));\n        } else {\n            res.insert(stoi(terms[0]));\n        }\n    } else {\n        FOR(i, 1, terms.size()) {\n            string lexpr, rexpr;\n            REP(j, i) {\n                if (j != 0) lexpr += ops[j-1];\n                lexpr += terms[j];\n            }\n            FOR(j, i, terms.size()) {\n                if (j != i) rexpr += ops[j-1];\n                rexpr += terms[j];\n            }\n//            LOG(\"--> %s %c %s\\n\", lexpr.c_str(), ops[i-1], rexpr.c_str());\n            set<int> l = eval(lexpr);\n            set<int> r = eval(rexpr);\n//            LOG(\"# %d\\n\", l.size());\n//            LOG(\"# %d\\n\", r.size());\n            for (int a : l) for (int b : r) {\n//                LOG(\"-----> %d %c %d\\n\", a, ops[i-1], b);\n                int val;\n                switch (ops[i-1]) {\n                case '+':\n                    val = a + b;\n                    break;\n                case '-':\n                    val = a - b;\n                    break;\n                case '*':\n                    val = a * b;\n                    break;\n                case '/':\n                    if (b == 0) {\n                        goto NEXT;\n                    }\n                    val = a / b;\n                    break;\n                }\n                res.insert(val);\n                NEXT : {}\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    string expr;\n    while (cin  >> expr, expr != \"#\") {\n        cout << eval(expr).size() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) loop(i,0,n)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nint dx[]={-1,-1,0,0,1,1};\nint dy[]={0,-1,1,-1,1,0};\nconst int inf=1000000010;\nstring s;\nint t;\nvi f(){\n\tvvi in;\n\tstring w=\"\";\n\twhile(t<s.size()){\n\t\tif(s[t]=='('){\n\t\t\tt++;\n\t\t\tin.pb(f());\n\t\t\tt++;\n\t\t}else{\n\t\t\tint a=0;\n\t\t\twhile(t<s.size()&&isdigit(s[t])){\n\t\t\t\ta*=10;\n\t\t\t\ta+=s[t]-'0';\n\t\t\t\tt++;\n\t\t\t}\n\t\t\tin.pb({a});\n\t\t}\n\t\tif(s.size()==t)break;\n\t\tif(s[t]==')')break;\n\t\tw+=s[t];\n\t\tt++;\n\t}\n\tvi out;\n\tvi per(w.size());\n\trep(i,w.size())per[i]=i;\n\tdo{\n\t\tvvi tmp=in;\n\t\trep(i,w.size()){\n\t\t\tint l=per[i],r=per[i]+1;\n\t\t\twhile(tmp[l].size()==0)l--;\n\t\t\twhile(tmp[r].size()==0)r++;\n\t\t\tvi nt;\n//\t\t\trep(j,per.size())cout<<\" \"<<per[j];cout<<endl;\n\n\t\t\trep(j,tmp[l].size())rep(k,tmp[r].size()){\n\t\t\t\tif(w[per[i]]=='+')nt.pb(tmp[l][j]+tmp[r][k]);\n\t\t\t\tif(w[per[i]]=='-')nt.pb(tmp[l][j]-tmp[r][k]);\n\t\t\t\tif(w[per[i]]=='*')nt.pb(tmp[l][j]*tmp[r][k]);\n\t\t\t\tif(tmp[r][k]&&w[per[i]]=='/')nt.pb(tmp[l][j]/tmp[r][k]);\n\t\t\t}\n\t\t\ttmp[l]=vi(0);\n\t\t\ttmp[r]=nt;\n\t\t}\n\t\trep(j,tmp.size()){rep(i,tmp[j].size())out.pb(tmp[j][i]);}\n\t\tsort(all(out));\n\t\tout.erase(unique(all(out)),out.end());\n\t}while(next_permutation(all(per)));\n\n\treturn out;\n}\nint main(){\n\twhile(cin>>s,s!=\"#\"){\n\t\tt=0;\n\t\tcout<<f().size()<<endl;\n\t}\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nstring line;\nint len;\nset<int> dp[201][201];\n\nvoid num(int s, int t) {\n    int v = 0;\n    for (int i = s; i < t; i++) {\n        if (line[i] < '0') return;\n        v *= 10;\n        v += line[i] - '0';\n    }\n    dp[s][t].insert(v);\n}\n\nvoid brace(int s, int t) {\n    if (line[s] == '(' && line[t - 1] == ')') dp[s][t] = dp[s + 1][t - 1];\n}\n\nint isOpr(char c) {\n    return c == '+' || c == '-' || c == '*' || c == '/';\n}\n\nint apply(char opr, int a, int b, int& ret) {\n    if (!b && opr == '/') return 0;\n    if (opr == '+') ret = a + b;\n    if (opr == '-') ret = a - b;\n    if (opr == '*') ret = a * b;\n    if (opr == '/') ret = a / b;\n    return 1;\n}\n\nint main()\n{\n    while (1) {\n        cin >> line;\n        if (line == \"#\") break;\n        len = line.length();\n        loop (len + 1, i) loop (len + 1, j) dp[i][j].clear();\n        loop (len, d) loop (len, s) {\n            int t = s + d + 1;\n            if (t > len) continue;\n            num(s, t);\n            brace(s, t);\n            for (int u = s + 1; u < t; u++) {\n                if (!isOpr(line[u])) continue;\n                for (int a : dp[s][u]) for (int b : dp[u + 1][t]) {\n                    int ret;\n                    if (apply(line[u], a, b, ret)) dp[s][t].insert(ret);\n                }\n            }\n        }\n        cout << dp[0][len].size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<set>\n#include<cstring>\n#include<algorithm>\n#include<stdlib.h>\n#define foreach(t,p) for(t::iterator it=p.begin();it!=p.end();++it)\n#define FOREACH(t,p,tit) for(t::iterator tit=p.begin();tit!=p.end();++tit)\n\nusing namespace std;\nstring ss;\ntypedef set<int> pp;\n\n\npp solve(int f,int l)\n{\n    pp ans;\n    bool ope=false;\n    int bo=0;\n    for(int i=f;i<l+1;i++)\n    {\n        if(ss[i]=='(') bo++;\n        if(ss[i]==')') bo--;\n\n        if((ss[i]=='+'||ss[i]=='-'||ss[i]=='*'||ss[i]=='/')&&(bo==0))\n        {\n            ope = true;\n            pp ansl = solve(f,i-1);\n            pp ansr = solve(i+1,l);\n            FOREACH(pp,ansl,lit)FOREACH(pp,ansr,rit)\n            {\n                if(ss[i]=='+') ans.insert((*lit)+(*rit));\n                if(ss[i]=='-') ans.insert((*lit)-(*rit));\n                if(ss[i]=='*') ans.insert((*lit)*(*rit));\n                if(ss[i]=='/') if((*rit)!=0)\n                    ans.insert((*lit)/(*rit));\n            }\n        \n\n        }\n\n    }\n    if(ope)return ans;\n    if(ss[f]=='(')return solve(f+1,l-1);\n    int p= atoi((ss.substr(f,l-f+1)).c_str());\n    ans.insert(p);\n    return ans;\n}\n\nint main()\n{\n    while(cin >> ss &&(ss!=\"#\"))\n    {\n        pp tans = solve(0,ss.size());\n        cout << tans.size() << endl;\n        //foreach(pp,tans) cout << *it << endl;\n        \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nstruct Expr {\n  int kind = -1;\n  int val = 0;\n};\nset<int> st;\nstring str = \"#+-*/()\";\nvoid calc(vector<Expr> exp) {\n  if((int)(exp.size()) == 1) {\n    assert(exp[0].kind == 0);\n    st.insert(exp[0].val);\n    return;\n  }\n  for(int i=0;i<(int)(exp.size());++i) {\n    if(i < (int)(exp.size())-2 && exp[i].kind == 5 && exp[i+2].kind == 6) {\n      exp.erase(exp.begin() + i);\n      exp.erase(exp.begin() + (i+1));\n      calc(exp);\n      return;\n    }\n  }\n  for(int i=1;i<(int)(exp.size())-1;++i) {\n    if(!(exp[i-1].kind == 0 && exp[i+1].kind == 0)) continue;\n    if(exp[i].kind == 1) {\n      int v1 = exp[i-1].val, v2 = exp[i+1].val;\n      exp.erase(exp.begin() + (i-1));\n      exp.erase(exp.begin() + (i-1));\n      exp.erase(exp.begin() + (i-1));\n      exp.insert(exp.begin() + (i-1), {0, v1 + v2});\n      calc(exp);\n      exp.erase(exp.begin() + (i-1));\n      exp.insert(exp.begin() + (i-1), {0, v2});\n      exp.insert(exp.begin() + (i-1), {1, -1});\n      exp.insert(exp.begin() + (i-1), {0, v1});\n    } else if(exp[i].kind == 2) {\n      int v1 = exp[i-1].val, v2 = exp[i+1].val;\n      exp.erase(exp.begin() + (i-1));\n      exp.erase(exp.begin() + (i-1));\n      exp.erase(exp.begin() + (i-1));\n      exp.insert(exp.begin() + (i-1), {0, v1 - v2});\n      calc(exp);\n      exp.erase(exp.begin() + (i-1));\n      exp.insert(exp.begin() + (i-1), {0, v2});\n      exp.insert(exp.begin() + (i-1), {2, -1});\n      exp.insert(exp.begin() + (i-1), {0, v1});\n    } else if(exp[i].kind == 3) {\n      int v1 = exp[i-1].val, v2 = exp[i+1].val;\n      exp.erase(exp.begin() + (i-1));\n      exp.erase(exp.begin() + (i-1));\n      exp.erase(exp.begin() + (i-1));\n      exp.insert(exp.begin() + (i-1), {0, v1 * v2});\n      calc(exp);\n      exp.erase(exp.begin() + (i-1));\n      exp.insert(exp.begin() + (i-1), {0, v2});\n      exp.insert(exp.begin() + (i-1), {3, -1});\n      exp.insert(exp.begin() + (i-1), {0, v1});\n    } else if(exp[i].kind == 4) {\n      int v1 = exp[i-1].val, v2 = exp[i+1].val;\n      if(v2 == 0) continue;\n      exp.erase(exp.begin() + (i-1));\n      exp.erase(exp.begin() + (i-1));\n      exp.erase(exp.begin() + (i-1));\n      exp.insert(exp.begin() + (i-1), {0, v1 / v2});\n      calc(exp);\n      exp.erase(exp.begin() + (i-1));\n      exp.insert(exp.begin() + (i-1), {0, v2});\n      exp.insert(exp.begin() + (i-1), {4, -1});\n      exp.insert(exp.begin() + (i-1), {0, v1});\n    }\n  }\n}\nvoid solve(string &s) {\n  vector<Expr> exp;\n  int n = (int)(s.size());\n  int now = 0;\n  for(int i=0;i<n;++i) {\n    if('0' <= s[i] && s[i] <= '9') {\n      now *= 10;\n      now += s[i] - '0';\n    } else if(now > 0) {\n      exp.push_back({0, now});\n      now = 0;\n    }\n    if(s[i] == '+') {\n      exp.push_back({1, -1});\n    } else if(s[i] == '-') {\n      exp.push_back({2, -1});\n    } else if(s[i] == '*') {\n      exp.push_back({3, -1});\n    } else if(s[i] == '/') {\n      exp.push_back({4, -1});\n    } else if(s[i] == '(') {\n      exp.push_back({5, -1});\n    } else if(s[i] == ')') {\n      exp.push_back({6, -1});\n    }\n  }\n  if(now > 0) {\n    exp.push_back({0, now});\n  }\n  calc(exp);\n  cout << (int)(st.size()) << endl;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    string s; cin >> s;\n    if(s == \"#\") break;\n    st.clear();\n    solve(s);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef set<int> :: iterator setit;\n\nint f(int a,char ch,int b){\n  if(ch=='+')return a+b;\n  else if(ch=='-')return a-b;\n  else if(ch=='*')return a*b;\n  else return a/b;\n}\n\nbool visited[20][20];\nset<int> dp[20][20];\nset<int> rec( int l,int r,  vector< set<int> > &t,  vector< char > &u ){\n  if(visited[l][r])return dp[l][r];\n  visited[l][r]=true;\n  set<int> res;\n  for(int i=l;i+1<=r;i++){\n    set<int> A,B;\n    A=rec(l,i,t,u);\n    B=rec(i+1,r,t,u);\n    for(setit j=A.begin();j!=A.end();j++){\n      for(setit k=B.begin();k!=B.end();k++){\n        int J=*j,K=*k;\n        if(u[i]=='/'&&K==0)continue;\n        res.insert( f(J,u[i],K) );\n      }\n    }\n  }\n  return res;\n}\n\nset<int> solve(   vector< set<int> > &t,  vector< char > &u ){\n  for(int i=0;i<20;i++)\n    for(int j=0;j<20;j++)\n      dp[i][j].clear(),visited[i][j]=false;\n  for(int i=0;i<(int)t.size();i++){\n    dp[i][i]=t[i];\n    visited[i][i]=true;\n  }\n  return rec(0,t.size()-1,t,u);\n}\n\n\n\nstring s;\nint p;\n\nset<int> calc();\n\nset<int> getNum(){\n  if(s[p]=='('){\n    p++;\n    return calc();\n  }\n  int a=0;\n  while('0'<=s[p]&&s[p]<='9'){\n    a=a*10+s[p]-'0';\n    p++;\n  }\n  set<int> res;\n  res.insert(a);\n  return res;\n}\n\nset<int> calc(){\n  vector< set<int> > t;\n  vector< char > u;\n  t.push_back(getNum());\n  while(1){\n    if(s[p]=='='||s[p]==')'){\n      p++;\n      break;\n    }\n    u.push_back(s[p]);\n    p++;\n    t.push_back(getNum());\n  }\n  return solve(t,u);\n}\n\nint main(){\n  while(1){\n    cin>>s;\n    if(s==\"#\")break;\n    s.push_back('=');\n    p=0;\n    set<int> ans=calc();\n    cout<<ans.size()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<cstdlib>\nusing namespace std;\n\nset<int> S;\n\nvoid cal(vector<string> V){\n  for(int i=1;i<V.size()-1;i++){\n    if(V[i-1]==\"(\" && V[i+1]==\")\"){\n      V.erase(V.begin()+i+1);\n      V.erase(V.begin()+i-1);\n    }\n  }\n  if(V.size()==1){\n    S.insert(atoi(V[0].c_str()));\n  }\n  else {\n    for(int i=0;i<V.size();i++){\n      if(V[i]==\"+\"){\n        if(V[i+1]==\"(\" || V[i-1]==\")\")continue;\n        int a=atoi(V[i-1].c_str())+atoi(V[i+1].c_str());\n\tstringstream ss;\n\tss << a;\n\tstring s=ss.str();\n        vector<string> v=V;\n        v.erase(v.begin()+i+1);\n        v.erase(v.begin()+i);\n\tv.erase(v.begin()+i-1);\n\tv.insert(v.begin()+i-1,s);\n\tcal(v);\n      }\n      if(V[i]==\"-\"){\n\tif(V[i+1]==\"(\" || V[i-1]==\")\")continue;\n        int a=atoi(V[i-1].c_str())-atoi(V[i+1].c_str());\n\tstringstream ss;\n\tss << a;\n\tstring s=ss.str();\n        vector<string> v=V;\n        v.erase(v.begin()+i+1);\n        v.erase(v.begin()+i);\n\tv.erase(v.begin()+i-1);\n\tv.insert(v.begin()+i-1,s);\n\tcal(v);\n      }\n      if(V[i]==\"*\"){\n\tif(V[i+1]==\"(\" || V[i-1]==\")\")continue;\n        int a=atoi(V[i-1].c_str())*atoi(V[i+1].c_str());\n\tstringstream ss;\n\tss << a;\n\tstring s=ss.str();\n        vector<string> v=V;\n        v.erase(v.begin()+i+1);\n        v.erase(v.begin()+i);\n\tv.erase(v.begin()+i-1);\n\tv.insert(v.begin()+i-1,s);\n\tcal(v);\n      }\n      if(V[i]==\"/\"){\n\tif(V[i+1]==\"(\" || V[i-1]==\")\")continue;\n\tif(V[i+1]==\"0\")continue;\n        int a=atoi(V[i-1].c_str())/atoi(V[i+1].c_str());\n\tstringstream ss;\n\tss << a;\n\tstring s=ss.str();\n        vector<string> v=V;\n        v.erase(v.begin()+i+1);\n        v.erase(v.begin()+i);\n\tv.erase(v.begin()+i-1);\n\tv.insert(v.begin()+i-1,s);\n\tcal(v);\n      }\n    }\n  }\n}\n\nint main()\n{\n  string s;\n  while(1){\n    cin>>s;\n    if(s[0]=='#')break;\n    vector<string> V;\n    string samp;\n    for(int i=0;i<s.length();i++){\n      if('0'<=s[i] && s[i]<='9'){\n\tsamp+=s[i];\n\tif(i==s.length()-1)V.push_back(samp);\n      }\n      else {\n\tif(!samp.empty()){\n\t  V.push_back(samp);\n\t  samp=\"\";\n\t}\n\tsamp=s[i];\n\tV.push_back(samp);\n\tsamp=\"\";\n      }\n    }\n    S.clear();\n    cal(V);\n    cout<<S.size()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <sstream>\n#include <set>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\ntypedef string::const_iterator Iterator;\n\nIterator matching_paren(Iterator it, const Iterator& last)\n{\n  for (int d = 1; it != last; ++it) {\n    if (*it == ')') {\n      --d;\n      if (d == 0) {\n        return it;\n      }\n    } else if (*it == '(') {\n      ++d;\n    }\n  }\n  throw \"paren mismatch\";\n}\n\nset<int> eval(const string& str)\n{\n  vector<string> terms;\n  vector<char> ops;\n  string term;\n  for (string::const_iterator it(str.begin()), end = str.end(); it != end; ++it) {\n    if ('0' <= *it && *it <= '9') {\n      term += *it;\n    } else if (*it == '(') {\n      if (!term.empty()) {\n        terms.push_back(term);\n      }\n      term = \"\";\n      Iterator l = matching_paren(it+1, end);\n      term = string(it, l+1);\n      it = l;\n    } else {\n      if (!term.empty()) {\n        terms.push_back(term);\n      }\n      term = \"\";\n      assert(*it == '+' || *it == '-' || *it == '*' || *it == '/');\n      ops.push_back(*it);\n    }\n  }\n  terms.push_back(term);\n  assert(ops.size()+1 == terms.size());\n\n  if (ops.empty()) {\n    if (terms[0][0] == '(') {\n      return eval(terms[0].substr(1, terms[0].size()-2));\n    } else {\n      set<int> s;\n      istringstream iss(terms[0]);\n      int x;\n      iss >> x;\n      s.insert(x);\n      return s;\n    }\n  } else {\n    set<int> s;\n    for (vector<char>::size_type i = 0; i < ops.size(); i++) {\n      string lhs;\n      for (vector<string>::size_type j = 0; j <= i; j++) {\n        if (j != 0) {\n          lhs += ops[j-1];\n        }\n        lhs += terms[j];\n      }\n      const set<int> l = eval(lhs);\n      string rhs;\n      for (vector<string>::size_type j = i+1; j < terms.size(); j++) {\n        if (j != i+1) {\n          rhs += ops[j-1];\n        }\n        rhs += terms[j];\n      }\n      const set<int> r = eval(rhs);\n      for (set<int>::const_iterator jt(l.begin()); jt != l.end(); ++jt) {\n        for (set<int>::const_iterator kt(r.begin()); kt != r.end(); ++kt) {\n          switch (ops[i]) {\n            case '+': s.insert(*jt + *kt);  break;\n            case '-': s.insert(*jt - *kt);  break;\n            case '*': s.insert(*jt * *kt);  break;\n            case '/': if (*kt != 0) { s.insert(*jt / *kt); }  break;\n          }\n        }\n      }\n    }\n    return s;\n  }\n}\n\nint main()\n{\n  for (string s; cin >> s && s != \"#\";) {\n    cout << eval(s).size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype>\n#include <set>\n#include <numeric>\nusing namespace std;\n\nstruct Term {\n    char op;\n    set<int> operand;\n    Term(char c, set<int> si) : op(c), operand(si) { }\n};\n\ntemplate<class T> struct Parser {\n    typedef string::const_iterator State;\n\n    T solve(const string &S) {\n        State begin = S.begin();\n        return expr(begin);\n    }\n\n    // expr ::= factor | factor + factor | factor - factor\n    //         | factor * factor | factor / factor\n    T expr(State &begin) {\n        vector<Term> terms;\n        terms.emplace_back('@', factor(begin));\n        for (;;) {\n            if (*begin == '+') {\n                ++begin;\n                terms.emplace_back('+', factor(begin));\n            } else if (*begin == '-') {\n                ++begin;\n                terms.emplace_back('-', factor(begin));\n            } else if (*begin == '*') {\n                ++begin;\n                terms.emplace_back('*', factor(begin));\n            } else if (*begin == '/') {\n                ++begin;\n                terms.emplace_back('/', factor(begin));\n            } else {\n                break;\n            }\n        }\n        return dp(terms);\n    }\n\n    T dp(vector<Term> &terms) {\n        int n = terms.size();\n        vector<vector<T>> dp(n, vector<T>(n));\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = terms[i].operand;\n        }\n        for (int len = 1; len < n; len++) {\n            for (int i = 0; i + len < n; i++) {     // [i, i + len]\n                T &res = dp[i][len];\n                for (int j = i + 1; j <= i + len; j++) {   // [i, j - 1] + [j, i + len]\n                    T tmp = f(dp[i][j - i - 1], terms[j].op, dp[j][len + i - j]);\n                    merge(res, tmp);\n                }\n            }\n        }\n        return dp[0][n - 1];\n    }\n\n    T f(T left, char op, T right) {\n        T res;\n        for (int a : left) for (int b : right) {\n            if (op == '+') res.insert(a + b);\n            else if (op == '-') res.insert(a - b);\n            else if (op == '*') res.insert(a * b);\n            else if (op == '/' && b != 0) res.insert(a / b);\n        }\n        return res;\n    }\n\n    T merge(T &res, T tmp) {\n        for (int e : tmp) res.insert(e);\n        return res;\n    }\n\n    // expr ::= ( term ) | num\n    T factor(State &begin) {\n        if (*begin == '(') {\n            begin++; // skip '('\n            T ret = expr(begin);\n            begin++; // skip ')'\n            return ret;\n        } else {\n            return number(begin);\n        }\n    }\n\n    // num ::= digit | num digit\n    T number(State &begin) {\n        int ret = 0;\n        while (isdigit(*begin)) {\n            ret *= 10;\n            ret += *begin - '0';\n            begin++;\n        }\n        return {ret};\n    }\n};\n\nint main() {\n    string S;\n    while (cin >> S && S != \"#\") {\n        Parser<set<int>> ps;\n        cout << ps.solve(S).size() << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<cstring>\n#define foreach(t,p) for(t::iterator it=p.begin();it!=p.end();++it)\n#define FOREACH(t,p,tit) for(t::iterator tit=p.begin();tit!=p.end();++tit)\n#define REP(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef set<int> pp;\nstring ss;\n\npp solve(int f,int l)\n{\n\tif(ss[f]=='('&& ss[l]==')'  )return solve(f+1,l-1);\n\n\tpp ans;\n\t//ans.clear();\n\tbool ope=false;\n/*\tfor(int i=f;i<l;i++)\n\t{\n\t\tif(\n\t\t\t\tss[i]=='+'||\n\t\t\t\tss[i]=='-'||\n\t\t\t\tss[i]=='*'||\n\t\t\t\tss[i]=='/')ope = true;\n\t}*/\n\n\t//int ofs = 0;\n\tint bo =0;\n\tfor(int i=f;i<l;i++)\n\t{\n\t\n\t\tif(ss[i]=='(') bo++;\n\t\tif(ss[i]==')') bo--;\n\n\t\tif((ss[i]=='+'||ss[i]=='-'||ss[i]=='*'||ss[i]=='/')&&(bo==0))\n\t\t{\n\t\t\tope = true;\n\t\t\n\t\t\tpp ansl = solve(f,i-1);\n\t\t\tpp ansr = solve(i+1,l);\n\t\t\tFOREACH(pp,ansl,iit)FOREACH(pp,ansr,jit)\n\t\t\t{\n\t\t\t\tif(ss[i]=='+') ans.insert((*iit)+(*jit));\n\t\t\t\tif(ss[i]=='-') ans.insert((*iit)-(*jit));\n\t\t\t\tif(ss[i]=='*') ans.insert((*iit)*(*jit));\n\t\t\t\tif(ss[i]=='/')if((*jit)!=0)\tans.insert((*iit)/(*jit));\n\t\t\t}\n\t\t}\n\t}\n\tif(!ope)\n\t{\n\t\tstring s = ss.substr(f,(l-f+1));\n\t\t//cout << s << endl;\n\t\tint t = atoi(s.c_str() );\n\t\tans.insert(t);\n\t\t//foreach(pp,ans)cout << *it << endl;\n\t\t//cout << atoi( (ss.substr(f,l+1)).c_str()) << endl ;\n\t\t//cout <<ss.substr(f,(l-f+1))<<endl;\n\t\treturn ans;\n\t}\n\n\treturn ans;\n}\n\nint main()\n{\n\twhile(cin >> ss &&(ss!=\"#\"))\n\t{\n\t\tpp anss = solve(0,ss.size()-1);\n\t\tcout << anss.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 300\n\nset<int> calc(char *s){\n  int r, counter  = 0;\n  \n  for(r=0;;r++){\n    if(s[r] == '(') counter++;\n    if(s[r] == ')') counter--;\n    if(counter < 0) break;\n  }\n\n  set<int> num[11];\n  char op[11];\n\n  int pos = 0, curnum = 0, f = 0;\n  \n  for(int i=0;i<r;i++){\n    if(s[i] == '('){\n      num[pos] = calc(s+i+1);\n      while(s[i] != ')') i++;\n      f = true;\n      continue;\n    }\n\n    if('0' <= s[i] && s[i] <= '9'){\n      curnum = curnum * 10 + (s[i] - '0');\n      continue;\n    }\n\n    if(!f)\n      num[pos] = {curnum};\n\n    op[pos] = s[i];\n    pos++;\n    curnum = 0;\n    f = false;\n  }\n  \n   if(!f) num[pos] = {curnum};\n\n  int per[11];\n  for(int i=0;i<pos;i++) per[i] = i;\n  \n  set<int> res;\n  \n  do{\n    bool used[11] = {};\n\n    set<int> temp[11];\n    for(int i=0;i<=pos;i++) temp[i] = num[i];\n    \n    for(int i=0;i<pos;i++){\n      int lnum = per[i];\n      int rnum = per[i]+1;\n\n      while(used[lnum]) lnum--;\n      while(used[rnum]) rnum++;\n      \n      set<int> cur;\n\n      for(int a : temp[lnum]){\n        for(int b : temp[rnum]){\n          switch(op[per[i]]){\n          case '+':\n            cur.insert(a + b);\n            break;\n          case '-':\n            cur.insert(a - b);\n            break;\n          case '*':\n            cur.insert(a * b);\n            break;\n          case '/':\n            cur.insert(a / b);\n            break;\n          }\n        }\n      }\n\n      temp[lnum] = cur;\n      used[rnum] = true;\n    }\n\n    for(int a: temp[0]){\n      res.insert(a);\n    }\n    \n  }while(next_permutation(per, per+pos));\n  \n  return res;\n}\n\nint solve(){\n  char formula[SIZE];\n\n  scanf(\"%s\", formula);\n  int n = strlen(formula);\n  formula[n] = ')';\n  n++;\n  \n  if(formula[0] == '#') return false;\n\n  printf(\"%d\\n\", (int)calc(formula).size());\n\n  return true;\n}\n\nint main(){\n  while(solve());\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef string::const_iterator state;\n\nint expression(state&);\n\nint number(state &begin){\n    int res=0;\n    while(isdigit(*begin)){\n        res*=10;\n        res+=*begin-'0';\n        ++begin;\n    }\n    return res;\n}\n\nint factor(state &begin){\n    if(*begin=='(' or *begin=='['){\n        begin++;\n        const int res=expression(begin);\n        begin++;\n        return res;\n    }else return number(begin);\n}\n\nint expression(state &begin){\n    int res=factor(begin);\n    if(res==inf) return inf;\n    while(true){\n        if(*begin=='+'){\n            ++begin;\n            res+=expression(begin);\n        }else if(*begin=='-'){\n            ++begin;\n            res-=expression(begin);\n        }else if(*begin=='*'){\n            ++begin;\n            res*=expression(begin);\n        }else if(*begin=='/'){\n            ++begin;\n            const int tmp=expression(begin);\n            if(tmp==0) return inf;\n            res/=tmp;\n        }else break;\n    }\n    return res;\n}\n\nvoid solve(){\n    while(true){\n        string str;\n        cin >> str;\n        if(str==\"#\") return;\n\n        set<int> res;\n        function<void(const string,const int,const int,const int)> rec=[&](const string s,const int idx,const int cnt1,const int cnt2){\n            if(cnt2<0) return;\n            if(idx==s.size()){\n                if(!cnt2){\n                    dump(s);\n                    auto begin=s.begin();\n                    const int res_=expression(begin);\n                    if(res_!=inf) res.insert(res_);\n                    dump(res_);\n                }\n                return;\n            }\n            if(s[idx]=='('){\n                rec(s,idx+1,cnt1+1,cnt2);\n                return;\n            }\n            if(s[idx]==')'){\n                if(cnt2) return;\n                rec(s,idx+1,cnt1-1,cnt2);\n                return;\n            }\n            if(cnt2<10 and isdigit(s[idx]) and (!idx or !isdigit(s[idx-1]))){\n                auto s_=s;\n                s_.insert(idx,\"[\");\n                rec(s_,idx,cnt1,cnt2+1);\n            }\n            if(!cnt1 and cnt2 and idx+1==s.size() or (isdigit(s[idx]) and !isdigit(s[idx+1]))){\n                bool ok=false;\n                for(int i=idx; s[i]!='[' ; --i){\n                    if(!isdigit(s[i])){\n                        ok=true;\n                        break;\n                    }\n                }\n                if(!ok){\n                    rec(s,idx+1,cnt1,cnt2);\n                    return;\n                }\n                auto s_=s;\n                if(idx+1==s.size()) s_+=\"]\";\n                else s_.insert(idx+1,\"]\");\n                rec(s_,idx+1,cnt1,cnt2-1);\n            }\n            rec(s,idx+1,cnt1,cnt2);\n        };\n        rec(str,0,0,0);\n        cout << res.size() << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct ops{\n  int pos,num;\n  char op;\n  ops(int pos, int num, char op):pos(pos),num(num),op(op){}\n  bool operator < (const ops &p) const {\n    return pos < p.pos;\n  }\n};\n\nstring str;\n\nvoid erase_parenthesis(vector<ops> &v){\n for(int i=0;i<(int)v.size()-2;i++){\n    if(v[i].op == '(' && v[i+1].op == 0 && v[i+2].op == ')'){\n      v.erase(v.begin() + i + 2);\n      v.erase(v.begin() + i);\n      i--;\n      if(i >= 0) i--;\n    }      \n  }\n\n}\n\nint solve(){\n  set<int> st;\n  vector<ops> ov,initv;\n\n  for(int i=0;i<str.size();i++){\n    if(str[i] == '+' || str[i] == '-' || str[i] == '*' || str[i] == '/'){\n      initv.push_back(ops(i, 0, str[i]));\n      ov.push_back(ops(i, 0, str[i]));\n    } else if(str[i] >= '0' && str[i] <= '9'){\n      int num = 0;\n      while(str[i] >= '0' && str[i] <= '9'){\n        num += str[i] - '0';\n        i++;\n      }\n      i--;\n      initv.push_back(ops(i, num, 0));\n    } else {\n      initv.push_back(ops(i, 0, str[i]));\n    }\n  }\n\n  erase_parenthesis(initv);\n\n  do{\n    vector<ops> v = initv;\n    for(int i=0;i<ov.size();i++){\n      int pos = lower_bound(v.begin(), v.end(), ov[i]) - v.begin(), res;\n      if(pos == 0 || pos == v.size()-1 || v[pos-1].op != 0 || v[pos+1].op != 0) break;\n      if(v[pos].op == '/' && v[pos+1].num == 0) break;\n      if(v[pos].op == '+') res = v[pos-1].num + v[pos+1].num;\n      if(v[pos].op == '-') res = v[pos-1].num - v[pos+1].num;\n      if(v[pos].op == '*') res = v[pos-1].num * v[pos+1].num;\n      if(v[pos].op == '/') res = v[pos-1].num / v[pos+1].num;\n      for(int j=0;j<2;j++) v.erase(v.begin()+pos);\n      v[pos-1].num = res;\n\n      erase_parenthesis(v);\n    }\n\n    if(v.size() == 1) st.insert(v[0].num);\n\n  } while(next_permutation(ov.begin(), ov.end()));\n\n  return st.size();\n}\n\nint main(){\n  while(cin >> str && str != \"#\") cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nstring s;\ntypedef long long ll;\nusing Iter = string::const_iterator;\nusing SIter= set<ll>::const_iterator;\n\nIter skip_par(Iter it) {\n  it++;\n  for(int cnt=1; cnt > 0; it++) cnt += (*it == '(') ? 1 : ((*it == ')') ? -1 : 0);\n  return it;\n}\n\nbool number(Iter st, Iter ed, ll& ret) {\n  ret = 0;\n  for(Iter curr=st; curr!=ed; curr++) {\n    if(isdigit(*curr)) {\n      ret *= 10;\n      ret += (*curr)-'0';\n    }\n    else { return false; }\n  }\n  return true;\n}\n\nset<char> opes={'+','-','*','/'};\n\nset<ll> exp(Iter st, Iter ed) {\n  if(*st == '(' && *(ed-1) == ')') { return exp(st+1, ed-1); }\n  {ll num; if(number(st, ed, num)) { return {num}; } }\n  set<ll> ret;\n  for(Iter curr=st; curr!=ed;curr++) {\n    if(*curr == '(') {\n      curr = skip_par(curr)-1;\n    }\n    else if(opes.count(*curr)) {\n      set<ll> l = exp(st, curr);\n      set<ll> r = exp(curr+1,ed);\n      for(SIter i=l.begin(); i!=l.end(); i++) {\n        for(SIter j=r.begin(); j!=r.end(); j++) {\n          switch(*curr) {\n            case '+': ret.insert(*i+*j); break;\n            case '-': ret.insert(*i-*j); break;\n            case '*': ret.insert(*i**j); break;\n            case '/': if(*j!=0) { ret.insert(*i/(*j)); } break;\n          }\n        }\n      }\n    }\n  }\n\n  return ret;\n}\n\nint main()\n{\n  for(;getline(cin, s);) {\n    if(s==\"#\") { break; }\n    Iter it = s.begin(), ed = s.end();\n    cout << exp(it, ed).size() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n\nstring s;\nvoid mul(const set<int> &a, const set<int> &b, char op, set<int> &ret){\n    for(auto e1:a){\n        for(auto e2:b){\n            if(op=='+')ret.insert(e1+e2);\n            if(op=='-')ret.insert(e1-e2);\n            if(op=='*')ret.insert(e1*e2);\n            if(op=='/'){\n                if(e2==0)continue;\n                ret.insert(e1/e2);\n            }\n        }\n    }\n}\n\n\nset<int> dfs(int l, int r){\n    vector<int> br(300,-1);\n    stack<int> stk;\n    for(int i=l;i<r;i++){\n        if(s[i]=='(')stk.push(i);\n        else if(s[i]==')'){\n            br[stk.top()] = i;\n            stk.pop();\n        }\n    }\n    while(1){\n        if( s[l]=='(' && br[l]==r-1 )l++,r--;\n        else break;\n    }\n    \n    set<int> ret;\n    int c = 0;\n    \n    bool ops=true;\n    for(int i=l;i<r;i++){\n        if(s[i]=='(')c++;\n        else if(s[i]==')')c--;\n        else if( (s[i]=='+' || s[i]=='-' || s[i]=='*' || s[i]=='/') && c==0 ){\n            ops = false;\n            mul( dfs(l,i) , dfs(i+1,r), s[i], ret);\n        }\n    }\n    \n    if(ops)return set<int>{stoi(s.substr(l,r-l))};\n    else return ret;\n}\n\n\nint main(){\n    while(cin>>s && s!=\"#\"){\n        set<int> res = dfs(0,s.size());\n        cout<<res.size()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint isalldigit(const string& str)\n{\n  for(int i = 0; i < str.size(); i++){\n    if(!isdigit(str[i])) return false;\n  }\n  return true;\n}\n\nbool dahara(const string& str){\n  int foo = 0;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == '(') foo++;\n    else if(str[i] == ')') foo--;\n    if(foo == 0) return false;\n  }\n  return true;\n}\n\nset< int > expr(string str)\n{\n  set< int > ret;\n\n  int foo = 0 ;\n  if(isalldigit(str)){\n    ret.insert(atoi(str.c_str()));\n  } else if (dahara(str)){\n    return expr( str.substr( 1, str.size() - 2));\n  } else {\n    for(int i = 0; i < str.size(); i++){\n      if(str[i] == '('){ //開き括弧だなぁ\n        foo++;\n        continue;\n      } else if(str[i] == ')'){ //閉じ括弧だなぁ \n        foo--;\n        continue;\n      } else if(isdigit(str[i])){ //数字はどうでもいいなぁ\n        continue;\n      }\n      if(foo == 0){\n        set< int > hori = expr(str.substr( 0, i));\n        set< int > tkc = expr(str.substr( i + 1));\n        for(set< int >::iterator msy = hori.begin(); msy != hori.end(); msy++){\n          for(set< int >::iterator mtur = tkc.begin(); mtur != tkc.end(); mtur++){\n            if(str[i] == '+'){\n              ret.insert( *msy + *mtur);\n            } else if(str[i] == '-'){\n              ret.insert( *msy - *mtur);\n            } else if(str[i] == '*'){\n              ret.insert( *msy * *mtur);\n            } else {\n              if(*mtur == 0) continue;\n              ret.insert( *msy / *mtur);\n            }\n          }\n        }\n      }\n    }\n  }\n  return ret;\n}\n\n\nint main()\n{\n  string s;\n  while(cin >> s, s != \"#\"){\n    cout << expr(s).size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<sstream>\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long ll;\n\nbool isnum(string s){\n  for(int i = 0; i < s.length(); i++)\n    if(s[i] < '0' || '9' < s[i]) return false;\n\n  return true;\n}\n\nbool issep(string s){\n  int p = 1;\n  if(s[0] != '(') return false;\n  for(int i = 1; i < s.length()-1; i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n    if(p == 0) return false;\n  }\n  // cout << \" test \" << s[s.length()-1] << \" \" << p << endl;\n  return ((s[s.length()-1] == ')') && (p == 1));\n}\n\nvector<ll> solve(string s){\n\n  //  cout << \"s \" << s << endl;\n  \n  vector<ll> V;\n\n  if(isnum(s)){\n    stringstream ss(s);\n    ll n;\n    ss >> n;\n    V.push_back(n);\n    return V;\n  }else if(issep(s)){\n    return solve(s.substr(1,s.length()-2));\n  }else{\n    int para = 0;\n\n    for(int i = 0; i < s.length(); i++){\n      vector<ll> v1,v2;\n      if(s[i] == '(') para++;\n      if(s[i] == ')') para--;\n\n      if(para == 0 && s[i] == '+'){\n\tv1 = solve(s.substr(0,i));\n\tv2 = solve(s.substr(i+1));\n\n\tfor(int j = 0; j < v1.size(); j++)\n\t  for(int k = 0; k < v2.size(); k++)\n\t    V.push_back(v1[j]+v2[k]);\n\t  \n      }\n\n      if(para == 0 && s[i] == '-'){\n\tvector<ll> v1,v2;\n\tv1 = solve(s.substr(0,i));\n\tv2 = solve(s.substr(i+1));\n\n\tfor(int j = 0; j < v1.size(); j++)\n\t  for(int k = 0; k < v2.size(); k++)\n\t    V.push_back(v1[j]-v2[k]);\n      }\n\n      if(para == 0 && s[i] == '*'){\n\tvector<ll> v1,v2;\n\tv1 = solve(s.substr(0,i));\n\tv2 = solve(s.substr(i+1));\n\n\tfor(int j = 0; j < v1.size(); j++)\n\t  for(int k = 0; k < v2.size(); k++)\n\t    V.push_back(v1[j]*v2[k]);\n      }\n\n      if(para == 0 && s[i] == '/'){\n\tvector<ll> v1,v2;\n\tv1 = solve(s.substr(0,i));\n\tv2 = solve(s.substr(i+1));\n\n\tfor(int j = 0; j < v1.size(); j++)\n\t  for(int k = 0; k < v2.size(); k++)\n\t    if(v2[k] != 0) V.push_back(v1[j]/v2[k]);\n\n      }\n    }\n  }\n  return V;\n}\n\nint main(){\n  \n  string in;\n  while(getline(cin,in) && in != \"#\"){\n    vector<ll> V = solve(in);\n    map<ll,bool> M;\n    ll ans = 0;\n    for(int i = 0; i < V.size(); i++){\n      if(M[V[i]] == false){\n\tM[V[i]] = true;\n\tans++;\n      }\n    }\n    \n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MP make_pair\n\ntypedef pair<int, int> PII;\n\nconst int SIZE = 100;\n\nchar line[SIZE], t[SIZE];\nset<int> memo[SIZE][SIZE];\nset<PII> used;\n \nvoid eval(int const l, int const r) {\n   \n  set<int>& ret = memo[l][r];\n  if(l == r) return;\n   \n  if(used.count(MP(l, r))) return;\n  used.insert(MP(l, r));\n   \n  // check is digits [l, r)\n  bool digits = true;\n  for(int i=l; i<r; i++) { digits = digits && isdigit(line[i]); }\n  strncpy(t, line+l, r-l); t[r-l] = 0;\n  if(digits) { ret.insert(atoi(t)); return; }\n   \n  int par = 0; bool check = true;\n  for(int i=l; i<r-1; i++) {\n    if(line[i] == '(') { par ++; }\n    if(line[i] == ')') { par --; }\n    if(par == 0) { check = false; }\n  }\n   \n  // \"(expr)\"\n  if(check) {\n    if(line[r-1] == ')') {\n      eval(l+1, r-1); ret = memo[l+1][r-1]; return;\n    }\n  }\n   \n  par = 0;\n  // parsing loop\n  for(int i=l; i<r; i++) {\n    if(line[i] == '(') { par ++; }\n    if(line[i] == ')') { par --; }\n    if(par != 0) continue;\n     \n    switch(line[i]) {\n    case '+': case '-': case '*': case '/': {\n      eval(l, i); eval(i+1, r);\n      set<int>::iterator iter_a, iter_b;\n      for(iter_a = memo[l][i].begin(); iter_a!=memo[l][i].end(); iter_a++) {\n        for(iter_b = memo[i+1][r].begin(); iter_b!=memo[i+1][r].end(); iter_b++) {\n          if(line[i] == '+') { ret.insert(*iter_a + *iter_b); }\n          if(line[i] == '-') { ret.insert(*iter_a - *iter_b); }\n          if(line[i] == '*') { ret.insert(*iter_a * *iter_b); }\n          if(line[i] == '/') {\n            if(*iter_b == 0) continue;\n            ret.insert(*iter_a / *iter_b);\n          }\n        }\n      }\n      break;\n    }\n    default:;\n    }\n  } // for parsing loop\n}\n \nint main() {\n   \n  while(1) {\n    scanf(\"%s\\n\", line);\n    for(int i=0; i<SIZE; i++)\n      for(int j=0; j<SIZE; j++)\n        memo[i][j].clear();\n     \n    used.clear();\n     \n    if(0==strcmp(line, \"#\")) break;\n    eval(0, strlen(line));\n    cout << memo[0][strlen(line)].size() << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nset<int> solve(string exp) {\n    vector<int> idx;\n    map<int, int> rev;\n    for (int i = 0, c = 0; i < exp.size(); i++) {\n        if (exp[i] == '(')\n            c++;\n        if (exp[i] == ')')\n            c--;\n        if (c == 0 && (exp[i]=='*' || exp[i]=='/' || exp[i]=='+' || exp[i]=='-')) {\n            rev[i] = idx.size();\n            idx.push_back(i);\n        }\n    }\n\n    if(idx.size() == 0) {\n        if (exp[0] == '(') return solve(string(exp.begin()+1, exp.end()-1));\n        stringstream ss;\n        ss << exp;\n        int num;\n        ss >> num;\n        set<int> ans;\n        ans.insert(num);\n        return ans;\n    }\n\n    vector<set<int> > res(idx.size() + 1);\n    for (int i = 0; i < idx.size() + 1; i++) {\n        int l = i == 0 ? 0 : idx[i - 1] + 1;\n        int r = i == idx.size() ? exp.size() : idx[i];\n        res[i] = solve(string(exp.begin() + l, exp.begin() + r));\n    }\n\n    set<int> ans;\n    do {\n        vector<set<int> > ret = res;\n        vector<int> ridx(idx.size());\n        for (int i = 0; i < idx.size(); i++) {\n            ridx[rev[idx[i]]] = i;\n        }\n        for (int i = 0; i < idx.size(); i++) {\n            int l = rev[idx[i]];\n            int r = rev[idx[i]] + 1;\n            set<int> num;\n            for (int j = l; j > 0 && i > ridx[j]; j--)\n                l = max(l, ridx[j]);\n            for (int j = r; j < idx.size() && i > ridx[j]; j++)\n                r = max(r, ridx[j]);\n            for (auto lhs : ret[l]) {\n                for (auto rhs : ret[r]) {\n                    if (exp[idx[i]] == '+')\n                        num.insert(lhs + rhs);\n                    if (exp[idx[i]] == '-')\n                        num.insert(lhs - rhs);\n                    if (exp[idx[i]] == '*')\n                        num.insert(lhs * rhs);\n                    if (exp[idx[i]] == '/') {\n                        if (rhs == 0)\n                            continue;\n                        num.insert(lhs / rhs);\n                    }\n                }\n            }\n            ret[rev[idx[i]]] = num;\n        }\n\n        for (auto i : ret[rev[idx[idx.size()-1]]]) ans.insert(i);\n    } while (next_permutation(idx.begin(), idx.end()));\n\n    return ans;\n}\n\nint main() {\n    string str;\n    while (cin >> str, str != \"#\")\n        cout << solve(str).size() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<ll> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nvector<int> perm(15);\n\nvector<ll> dfs(string s) {\n    vector<vector<ll>> num;\n    vector<char> op;\n\n    int i = 0;\n    while(i < s.length()) {\n        if ('0' <= s[i] && s[i] <= '9') {\n            int tmp = 0;\n            while(i < s.length() && '0' <= s[i] && s[i] <= '9') {\n                tmp = tmp * 10 + (s[i] - '0');\n                i++;\n            }\n            num.pb(vector<ll>(1, tmp));\n            i--;\n        } else if (s[i] == '(') {\n            int j = i + 1, flag = 1;\n            while(flag > 0) {\n                if (s[j] == '(') flag++;\n                if (s[j] == ')') flag--;\n                j++;\n            }\n            j--;\n            num.pb(dfs(s.substr(i + 1, j - i - 1)));\n            i = j;\n        } else {\n            op.pb(s[i]);\n        }\n        i++;\n    }\n\n    if (op.size() > 0) {\n        S st;\n        vector<ll> ans;\n        iota(all(perm), 0);\n        do {\n            vector<vector<ll>> v(num);\n\n            bool ok = true;\n            rep(i, op.size()) {\n                vector<ll> tmp;\n                int l = perm[i];\n                while(l >= 0 && v[l].empty()) l--;\n                if (l < 0) {\n                    ok = false;\n                    break;\n                }\n                rep(j, v[l].size()) {\n                    rep(k, v[perm[i] + 1].size()) {\n                        switch(op[perm[i]]) {\n                            case '+':\n                            tmp.pb(v[l][j] + v[perm[i] + 1][k]); break;\n                            case '-':\n                            tmp.pb(v[l][j] - v[perm[i] + 1][k]); break;\n                            case '*':\n                            tmp.pb(v[l][j] * v[perm[i] + 1][k]); break;\n                            case '/':\n                            if (v[perm[i] + 1][k] != 0) tmp.pb(v[l][j] / v[perm[i] + 1][k]); break;\n                        }\n                    }\n                }\n                if (tmp.size() == 0) {\n                    ok = false;\n                    break;\n                }\n                uni(tmp);\n                v[l] = tmp;\n                v[perm[i] + 1].clear();\n            }\n            if (ok) rep(i, v[0].size()) st.insert(v[0][i]);\n        } while(next_permutation(perm.begin(), perm.begin() + op.size()));\n        each(itr, st) ans.pb(itr);\n        return ans;\n    } else {\n        return num[0];\n    }\n}\n\nint main(){\n    cin.sync_with_stdio(false);\n    string s;\n    while(cin >> s, s[0] != '#') {\n        cout << dfs(s).size() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n// Shrotening\n#define fst first\n#define snd second\n#define pb push_back\n\n// Loop\n#define FOR(i,a,b) for(auto i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(auto i=(a);i>=(b);--i)\n\n#define REP(i,a) for(long i=0;i<(a);++i)\n#define RREP(i,a) for(long i=(a);i>=0;--i)\n\n#define EACH(i,a) for(auto (i)=(a).begin(),_END=(a).end();i!=_END;++i)\n#define REACH(i,a) for(auto (i)=(a).rbegin(),_END=(a).rend();i!=_END;++i)\n\n//Algorithm\n#define ALL(a) (a).begin(), a.end()\n#define RALL(a) (a).rbegin(), a.rend()\n#define EXIST(a,x) ((a).find(x)!=(a).end())\n#define SORT(a) std::sort((a).begin(), (a).end())\n#define UNIQUE(a) std::sort((a).begin(), a.end()), a.erase(std::unique((a).begin(), a.end()), a.end());\n#define SUM(a) std::accumulate((a).begin(), (a).end(), 0);\n\n//Setting\n#define OPT std::cin.tie(0);std::ios::sync_with_stdio(false);\n\n//debug message\nbool debug = true;\n#define MSG(s)   if(debug){std::cout << s << std::endl;}\n#define DEBUG(x) if(debug){std::cout << \"debug(\" << #x << \"): \" << x << std::endl;}\n\n//alias\ntypedef long long LL;\ntypedef std::vector<char> VC;\ntypedef std::vector<int>  VI;\ntypedef std::vector<long> VL;\ntypedef std::vector<long long> VLL;\n\ntypedef std::vector< VC > VC2;\ntypedef std::vector< VI > VI2;\ntypedef std::vector< VL > VL2;\ntypedef std::vector< VLL > VLL2;\n\ntypedef std::pair<int,int> PII;\n\n\nstd::string str;\nint len;\n\nstd::map<int,int> bracketTable;\n\nint inline calc(char op, int l, int r) {\n    return   op == '+' ? l + r\n           : op == '-' ? l - r\n           : op == '*' ? l * r\n           :             l / r;\n}\n\nbool inline isOperator(char c) {\n    return (c == '+' || c == '-' || c == '*' || c == '/');\n}\n\nbool isOperatorContain(int l, int r) {\n    int d = 0;\n    for(int i=l; i<=r; ++i) {\n        if(str[i] == '(') {\n            ++d;\n        }\n        if(str[i] == ')') {\n            --d;\n        }\n        if(d > 0) {\n            continue;\n        }\n\n        if(isOperator(str[i])) {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool isCloseBracket(int l, int r) {\n    return (bracketTable.count(l) > 0 && bracketTable[l] == r);\n}\n\nstd::map< std::pair<int,int>, std::set<int> > memo;\n\nstd::set<int> eval(int l, int r) {\n    std::pair<int,int> p = std::make_pair(l, r);\n    if(memo.count(p) > 0) {\n        return memo[p];\n    }\n\n    std::set<int> ans;\n    if(isCloseBracket(l, r)) {\n        ans = eval(l+1, r-1);\n    } else if(isOperatorContain(l, r)) {\n        int i = l, d = 0; //depth\n        while(i <= r) {\n            if(str[i] == '(') {\n                ++d;\n            }\n            if(str[i] == ')') {\n                --d;\n            }\n            if(d > 0) {\n                ++i;\n                continue;\n            }\n\n            if(isOperator(str[i])) {\n                char op = str[i];\n                auto left  = eval(l, i-1);\n                auto right = eval(i+1, r);\n                for(auto x: left) {\n                    for(auto y: right) {\n                        if(op == '/' && y == 0) {\n                            continue;\n                        }\n                        ans.insert(calc(op, x, y));\n                    }\n                }\n            }\n            ++i;\n        }\n    } else {\n        int v = 0;\n        int i = l;\n        while(i <= r && str[i] != ')') {\n            assert(str[i] >= '0' && str[i] <= '9');\n            v *= 10;\n            v += (str[i] - '0');\n            ++i;\n        }\n        ans.insert(v);\n    }\n    memo.insert(std::make_pair(p, ans));\n    return ans;\n}\n\nint main() {\n    int i, j;\n    while(std::cin >> str, str != \"#\") {\n        memo.clear();\n        bracketTable.clear();\n        len = str.length();\n        for(i=0; i<len; ++i) {\n            if(str[i] != '(') continue;\n\n            int d = 1;\n            for(j=i+1; j < len; ++j) {\n                if(str[j] == '(') {\n                    ++d;\n                } else if(str[j] == ')') {\n                    --d;\n                    if(d == 0) {\n                        break;\n                    }\n                }\n            }\n            bracketTable.insert(std::make_pair(i, j));\n        }\n\n        auto pat = eval(0, len - 1);\n        std::cout << pat.size() << std::endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < int(n); ++i)\n#define all(a) (a).begin(),(a).end()\n#define debug(x) cerr<<(#x)<<\": \"<<(x)<<endl;\ntypedef long long ll;\n#define print(v) {cerr<<#v<<\": [\"; for(auto x : v){cerr<<x<<\", \"; } cerr<<\"]\"<<endl;}\n\n\nbool is_op(char c){\n    return c=='+' || c=='-' || c=='*' || c=='/';\n}\n\nint operate(int &e1,int &e2,char &op){\n    if(op == '+') return e1+e2;\n    if(op == '-') return e1-e2;\n    if(op == '*') return e1*e2;\n    if(op == '/') return e1/e2;\n    assert(false);\n}\n\nset<int> calc(vector<set<int>> Es, vector<char> &ops, vector<int> &perm){\n    int n = perm.size();\n    if(n == 0){\n        return Es[0];\n    }\n    vector<bool> done(n);\n    rep(i,n){\n        int p = perm[i];\n        set<int> E;\n        char op = ops[p];\n        for(int e1 : Es[p]){\n            for(int e2 : Es[p+1]){\n                if(op == '/' && e2 == 0) continue;\n                E.insert(operate(e1,e2,op));\n            }\n        }\n        done[p] = true;\n        // debug(p);\n        Es[p] = E;\n        Es[p+1] = E;\n        int l = p-1, r = p+1;\n        while(l>=0 && done[l]){\n            Es[l] = E;\n            l--;\n        }\n        while(r<n && done[r]){\n            Es[r+1] = E;\n            r++;\n        }\n        // cerr<<\"----------\"<<endl;\n        // rep(k,n){\n        //     // print(Es[k]);\n        //     cerr<<ops[k]<<endl;\n        // }\n        // print(Es[n]);\n        if(i == n-1){\n            return E;\n        }\n    }\n    assert(false);\n}\n\nset<int> all_check(vector<set<int>> &Es, vector<char> &ops){\n    int n = ops.size();\n    vector<int> perm(n);\n    rep(i,n){\n        perm[i] = i;\n    }\n\n    set<int> res;\n    do{\n        set<int> tmp = calc(Es,ops,perm);\n        for(int t : tmp){\n            res.insert(t);\n        }\n    }while(next_permutation(all(perm)));\n    return res;\n}\n\n\nset<int> eval(string &s, int &i){\n\n    vector<set<int>> Es;\n    vector<char> ops;\n    while(1){\n        if(isdigit(s[i])){\n            set<int> res;\n            int num = 0;\n            while(isdigit(s[i])){\n                num = num*10 + s[i]-'0';\n                i++;\n            }\n            res.insert(num);\n            Es.push_back(res);\n        }else if(s[i] == '('){\n            i++; // (\n            Es.push_back(eval(s,i));\n            i++; // )\n        }else{\n            assert(false);\n            Es.push_back(eval(s,i));\n        }\n\n        if(i == (int)s.size()) break;\n        if(is_op(s[i])){\n            ops.push_back(s[i]);\n            i++;\n        }else{\n            break;\n        }\n    }\n    set<int> res = all_check(Es,ops);\n    // print(Es);\n    // print(ops);\n    // print(res);\n    return res;\n\n}\n\nint main(){\n    string s;\n    while(cin>>s, s!=\"#\"){\n        // debug(s);\n        int index = 0;\n        set<int> st = eval(s, index);\n        cout<<st.size()<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < int(n); ++i)\n#define all(a) (a).begin(),(a).end()\n\nbool is_op(char c){\n    return c=='+' || c=='-' || c=='*' || c=='/';\n}\n\nint operate(int &e1,int &e2,char &op){\n    if(op == '+') return e1+e2;\n    if(op == '-') return e1-e2;\n    if(op == '*') return e1*e2;\n    if(op == '/') return e1/e2;\n    assert(false);\n}\n\nset<int> calc(vector<set<int>> Es, vector<char> &ops, vector<int> &perm){\n    int n = perm.size();\n    if(n == 0){\n        return Es[0];\n    }\n    vector<bool> done(n);\n    rep(i,n){\n        int p = perm[i];\n        set<int> E;\n        char op = ops[p];\n        for(int e1 : Es[p]){\n            for(int e2 : Es[p+1]){\n                if(op == '/' && e2 == 0) continue;\n                E.insert(operate(e1,e2,op));\n            }\n        }\n        done[p] = true;\n        Es[p] = E;\n        Es[p+1] = E;\n        int l = p-1, r = p+1;\n        while(l>=0 && done[l]){\n            Es[l] = E;\n            l--;\n        }\n        while(r<n && done[r]){\n            Es[r+1] = E;\n            r++;\n        }\n        if(i == n-1){\n            return E;\n        }\n    }\n    return Es[0];\n}\n\nset<int> all_check(vector<set<int>> &Es, vector<char> &ops){\n    int n = ops.size();\n    vector<int> perm(n);\n    rep(i,n){\n        perm[i] = i;\n    }\n\n    set<int> res;\n    do{\n        set<int> tmp = calc(Es,ops,perm);\n        for(int t : tmp){\n            res.insert(t);\n        }\n    }while(next_permutation(all(perm)));\n    return res;\n}\n\n\nset<int> eval(string &s, int &i){\n    vector<set<int>> Es;\n    vector<char> ops;\n    while(1){\n        if(isdigit(s[i])){\n            set<int> res;\n            int num = 0;\n            while(isdigit(s[i])){\n                num = num*10 + s[i]-'0';\n                i++;\n            }\n            res.insert(num);\n            Es.push_back(res);\n        }else if(s[i] == '('){\n            i++; // (\n            Es.push_back(eval(s,i));\n            i++; // )\n        }\n\n        if(i == (int)s.size()) break;\n        if(is_op(s[i])){\n            ops.push_back(s[i]);\n            i++;\n        }else{\n            break;\n        }\n    }\n    return all_check(Es,ops);\n\n}\n\nint main(){\n    string s;\n    while(cin>>s, s!=\"#\"){\n        int index = 0;\n        cout<<eval(s, index).size()<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <set>\nusing namespace std;\n\nstring s;\n\nset<int> solve(int l, int r)\n{\n\tint par = 0;\n\tbool found = false;\n\tset<int> result;\n\n\tfor (int i = l; i < r; ++i) {\n\t\tif (s[i] == '(')\n\t\t\t++par;\n\t\tif (s[i] == ')')\n\t\t\t--par;\n\n\t\tif (par == 0 && (s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/')) {\n\t\t\tfound = true;\n\n\t\t\tset<int> lhs = solve(l, i-1), rhs = solve(i+1, r);\n\t\t\tfor (set<int>::iterator it = lhs.begin(); it != lhs.end(); ++it) {\n\t\t\t\tfor (set<int>::iterator jt = rhs.begin(); jt != rhs.end(); ++jt) {\n\t\t\t\t\tif (s[i] == '+')\n\t\t\t\t\t\tresult.insert((*it) + (*jt));\n\t\t\t\t\telse if (s[i] == '-')\n\t\t\t\t\t\tresult.insert((*it) - (*jt));\n\t\t\t\t\telse if (s[i] == '*')\n\t\t\t\t\t\tresult.insert((*it) * (*jt));\n\t\t\t\t\telse if ((*jt) != 0)\n\t\t\t\t\t\tresult.insert((*it) / (*jt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tif (s[l] == '(')\n\t\t\treturn solve(l+1, r-1);\n\t\tresult.insert(atoi(s.substr(l, r-l+1).c_str()));\n\t}\n\treturn result;\n}\n\nint main()\n{\n\twhile (cin >> s) {\n\t\tif (s == \"#\")\n\t\t\tbreak;\n\t\tcout << solve(0, s.size()-1).size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s;\nint a[200],p,f;\nchar b[11];\nint bns1();\nint g_A(){\n  int r=0;\n  if(s[p]=='(')p++,r=bns1(),p++;\n  else while(isdigit(s[p]))r=r*10+(s[p++]-'0');\n  return r;\n}\nint bns10(){\n  int res=g_A();\n  while(a[s[p]]==10){\n    int t=p++;\n    if(b[s[t]]=='+')res+=g_A();\n    if(b[s[t]]=='-')res-=g_A();\n    if(b[s[t]]=='*')res+=g_A();\n    if(b[s[t]]=='/'){\n      int tt=g_A();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nint bns9(){\n  int res=bns10();\n  while(a[s[p]]==9){\n    int t=p++;\n    if(b[s[t]]=='+')res+=bns10();\n    if(b[s[t]]=='-')res-=bns10();\n    if(b[s[t]]=='*')res+=bns10();\n    if(b[s[t]]=='/'){\n      int tt=bns10();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nint bns8(){\n  int res=bns9();\n  while(a[s[p]]==8){\n    int t=p++;\n    if(b[s[t]]=='+')res+=bns9();\n    if(b[s[t]]=='-')res-=bns9();\n    if(b[s[t]]=='*')res+=bns9();\n    if(b[s[t]]=='/'){\n      int tt=bns9();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nint bns7(){\n  int res=bns8();\n  while(a[s[p]]==7){\n    int t=p++;\n    if(b[s[t]]=='+')res+=bns8();\n    if(b[s[t]]=='-')res-=bns8();\n    if(b[s[t]]=='*')res+=bns8();\n    if(b[s[t]]=='/'){\n      int tt=bns8();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nint bns6(){\n  int res=bns7();\n  while(a[s[p]]==6){\n    int t=p++;\n    if(b[s[t]]=='+')res+=bns7();\n    if(b[s[t]]=='-')res-=bns7();\n    if(b[s[t]]=='*')res+=bns7();\n    if(b[s[t]]=='/'){\n      int tt=bns7();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nint bns5(){\n  int res=bns6();\n  while(a[s[p]]==5){\n    int t=p++;\n    if(b[s[t]]=='+')res+=bns6();\n    if(b[s[t]]=='-')res-=bns6();\n    if(b[s[t]]=='*')res+=bns6();\n    if(b[s[t]]=='/'){\n      int tt=bns6();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nint bns4(){\n  int res=bns5();\n  while(a[s[p]]==4){\n    int t=p++;\n    if(b[s[t]]=='+')res+=bns5();\n    if(b[s[t]]=='-')res-=bns5();\n    if(b[s[t]]=='*')res+=bns5();\n    if(b[s[t]]=='/'){\n      int tt=bns5();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nint bns3(){\n  int res=bns4();\n  while(a[s[p]]==3){\n    int t=p++;\n    if(b[s[t]]=='+')res+=bns4();\n    if(b[s[t]]=='-')res-=bns4();\n    if(b[s[t]]=='*')res+=bns4();\n    if(b[s[t]]=='/'){\n      int tt=bns4();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nint bns2(){\n  int res=bns3();\n  while(a[s[p]]==2){\n    int t=p++;\n    if(b[s[t]]=='+')res+=bns3();\n    if(b[s[t]]=='-')res-=bns3();\n    if(b[s[t]]=='*')res+=bns3();\n    if(b[s[t]]=='/'){\n      int tt=bns3();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nint bns1(){\n  int res=bns2();\n  while(a[s[p]]==1){\n    int t=p++;\n    if(b[s[t]]=='+')res+=bns2();\n    if(b[s[t]]=='-')res-=bns2();\n    if(b[s[t]]=='*')res+=bns2();\n    if(b[s[t]]=='/'){\n      int tt=bns2();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nmain(){\n  while(cin>>s,s!=\"#\"){\n    int cnt=0,lx[10];\n    set<int>se;\n    r(i,s.size())if(!isdigit(s[i])&&s[i]!='('&&s[i]!=')')b[cnt+'a']=s[i],s[i]='a'+cnt++;\n    r(i,cnt)lx[i]=i;\n    do{\n      f=p=0;\n      r(i,cnt)a[lx[i]+'a']=i+1;\n      int ppp=bns1();\n      if(!f)se.insert(ppp);\n    }while(next_permutation(lx,lx+cnt));\n    cout<<se.size()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<set>\n#include<vector>\nusing namespace std;\nchar str[210];\nint cur;\nset<int> expr();\nset<int> dig(){\n\tif(str[cur]=='('){\n\t\tcur++;\n\t\tset<int>R=expr();\n\t\tcur++;\n\t\treturn R;\n\t}\n\tint ret=0;\n\twhile('0'<=str[cur]&&str[cur]<='9'){\n\t\tret*=10;\n\t\tret+=str[cur]-'0';\n\t\tcur++;\n\t}\n\tset<int>r;r.insert(ret);\n\treturn r;\n}\nset<int> expr(){\n\tvector<set<int> > num;\n\tvector<char> op;\n\tnum.push_back(dig());\n\twhile(str[cur]=='+'||str[cur]=='-'||str[cur]=='/'||str[cur]=='*'){\n\t\top.push_back(str[cur]);\n\t\tcur++;\n\t\tnum.push_back(dig());\n\t}\n\tset<int>ret;\n\tint n=op.size();\n\tvector<int>perm(n);for(int i=0;i<n;i++)perm[i]=i;\n\tdo{\n\t\tvector<set<int> > tmp=num;\n\t\tbool dame=false;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint L=perm[i];\n\t\t\tint R=perm[i]+1;\n\t\t\tchar opr=op[perm[i]];\n\t\t\twhile(L>=0&&!tmp[L].size()){\n\t\t\t\tL--;\n\t\t\t}\n\t\t\tif(L<0){\n\t\t\t\tdame=true;break;\n\t\t\t}\n\t\t\tset<int>to;\n\t\t\tfor(set<int>::iterator i1=tmp[L].begin();i1!=tmp[L].end();i1++){\n\t\t\t\tfor(set<int>::iterator i2=tmp[R].begin();i2!=tmp[R].end();i2++){\n\t\t\t\t\tif(opr=='+')to.insert((*i1)+(*i2));\n\t\t\t\t\tif(opr=='-')to.insert((*i1)-(*i2));\n\t\t\t\t\tif(opr=='*')to.insert((*i1)*(*i2));\n\t\t\t\t\tif(opr=='/'&&(*i2))to.insert((*i1)/(*i2));\n\t\t\t\t}\t\n\t\t\t}\n\t\t\ttmp[L]=to;\n\t\t\ttmp[R].clear();\n\t\t}\n\t\tif(!dame){\n\t\t\tfor(set<int>::iterator it=tmp[0].begin();it!=tmp[0].end();it++)\n\t\t\t\tret.insert(*it);\n\t\t}\n\t}while(next_permutation(perm.begin(),perm.end()));\n\t//printf(\"%d \",ret.size());\n\treturn ret;\n}\nint main(){\n\twhile(1){\n\t\tscanf(\"%s\",str);\n\t\tif(str[0]=='#')break;\n\t\tcur=0;\n\t\tset<int>ret=expr();\n\t//\tfor(set<int>::iterator it=ret.begin();it!=ret.end();it++)\n\t\t//\tprintf(\"%d \",*it);\n\t\tprintf(\"%d\\n\",ret.size());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst int tx[] = {+0,+1,+0,-1};\nconst int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\nint main(){\n  string str;\n  while(cin >> str){\n    if(str == \"#\") break;\n    vector<string> elems;\n\n    vector<char> ope;\n    vector<int> nums;\n    vector<int> ope_depth;\n\n    int depth = 0; \n    for(int i = 0; i < str.size(); i++){\n      if(str[i] == '+' || str[i] == '-' || str[i] == '/' || str[i] == '*'){\n        ope.push_back(str[i]);\n        ope_depth.push_back(depth);\n      }\n      else if(str[i] == '('){\n        depth++;\n      }\n      else if(str[i] == ')'){\n        depth--;\n      }\n      else if(isdigit(str[i])){\n        int sum = 0;\n        while(i < str.size() && isdigit(str[i])){\n          sum *= 10;\n          sum += str[i] - '0';\n          i++;\n        }\n        nums.push_back(sum);\n        i--;\n      }\n    }\n\n    vector<int> order;\n    for(int i = 0; i < ope.size(); i++){\n      order.push_back(i);\n    }\n    \n    set<int> res;\n    vector<int> orig = nums;\n\n    do {\n      nums = orig;\n      int min_depth = INF;\n      bool used[12];\n      memset(used,false,sizeof(used));\n      for(int i = 0; i < order.size(); i++){\n        if(min_depth < ope_depth[order[i]]){\n          goto over;\n        }\n        min_depth = min(min_depth,ope_depth[order[i]]);\n      }\n\n      for(int i = 0; i < order.size(); i++){\n        int ans = 0;\n        if(ope[order[i]] == '+') ans = nums[order[i]] + nums[order[i]+1];\n        else if(ope[order[i]] == '-') ans = nums[order[i]] - nums[order[i]+1];\n        else if(ope[order[i]] == '*') ans = nums[order[i]] * nums[order[i]+1];\n\n        else if(ope[order[i]] == '/'){\n          if(nums[order[i]+1] == 0){\n            goto over;\n          }\n          ans = nums[order[i]] / nums[order[i]+1];\n        }\n\n        for(int j = order[i] + 1; j <= order.size() ; j++){\n          nums[j] = ans;\n          if(!used[j]) break;\n        }\n        for(int j = order[i]; j >= 0; j--){\n          nums[j] = ans;\n          if(j == 0 || !used[j-1]) break;\n        }\n        used[order[i]] = true;\n      }\n\n      res.insert(nums[0]);\n    over:;\n    }while(next_permutation(order.begin(),order.end()));\n    cout << res.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <sstream>\n#include <cstdio>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reps(i,s,n) for(int i=s; i<n; i++)\n#define all(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n\nll calc( string in, int index, bool& invalid ) {\n\tll res = -1, a=0, b=0;\n\trep(i, in.length()) if(in[i]=='_') in[i]='-';\n\tchar c = in[index];\n\tif( c == '+' ) {\n\t\tsscanf( in.c_str(), \"%lld+%lld\", &a, &b );\n\t\tres = a + b;\n\t} else if( c == '-' ) {\n\t\tsscanf( in.c_str(), \"%lld-%lld\", &a, &b );\n\t\tres = a - b;\n\t} else if( c == '*' ) {\n\t\tsscanf( in.c_str(), \"%lld*%lld\", &a, &b );\n\t\tres = a * b;\n\t} else if( c == '/' ) {\n\t\tsscanf( in.c_str(), \"%lld/%lld\", &a, &b );\n\t\tif( b != 0 ) {\n\t\t\tres = a / b;\n\t\t} else {\n\t\t\tinvalid = true;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid solve( string e, vector<ll>& v ) {\n//\tcout << e << endl;\n\tbool br = false;\n\tint brBeg = 0;\n\trep(i, e.length()) {\n\t\tif( e[i] == '(' ) {\n\t\t\tbr = true;\n\t\t\tbrBeg = i;\n\t\t}\n\t}\n\tif( br ) {\n\t\tint cnt = 0;\n\t\tint brEnd = 0;\n\t\tfor(int i=brBeg+1; i<e.length(); i++) {\n\t\t\tif( e[i]==')' ) {\n\t\t\t\tif( cnt==0 ) {\n\t\t\t\t\tbrEnd = i;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tcnt--;\n\t\t\t\t}\n\t\t\t} else if( e[i]=='('){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tstring ne = e.substr(brBeg+1, brEnd-brBeg-1);\n\t\tvector<ll> vi;\n\t\tsolve( ne, vi );\n\t\trep(i, vi.size()) {\n\t\t\tstring out = e;\n\t\t\tstringstream ss;\n\t\t\tss << vi[i];\n\t\t\tstring rep;\n\t\t\tss >> rep;\n\t\t\tif(rep[0] == '-') rep[0] = '_';\n\t\t\tout.replace( brBeg, brEnd-brBeg+1, rep.c_str(), rep.length() );\n\t\t\tsolve( out, v );\n\t\t}\n\t} else {\n\t\tint pos[10], cnt=0;\n\t\trep(i, e.length()) {\n\t\t\tif( e[i]=='+' || e[i]=='-' || e[i]=='*' || e[i]=='/' ) {\n\t\t\t\tpos[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\trep(i, cnt) {\n\t\t\tint ps=pos[i]-1, pe=pos[i]+1;\n\t\t\twhile( 0<=ps && (('0'<=e[ps] && e[ps]<='9') || e[ps]=='_') ) ps--;\n\t\t\tps++;\n\t\t\twhile( pe<e.length() && (('0'<=e[pe] && e[pe]<='9') || e[pe]=='_') ) pe++;\n\t\t\tpe--;\n\t\t\tbool invalid = false;\n\t\t\tll res = calc( e.substr( ps, pe-ps+1 ), pos[i]-ps, invalid );\n\t\t\tif( invalid ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstringstream ss;\n\t\t\tss << res;\n\t\t\tstring o;\n\t\t\tss >> o;\n\t\t\tif(o[0]=='-') o[0] = '_';\n//\t\t\tcout << \"start : \" << ps << endl;\n//\t\t\tcout << \"end : \" << pe-ps+1 << endl;\n\t\t\tstring out = e;\n//\t\t\tcout << \"o : \" << o << endl;\n//\t\t\tcout << \"out : \" << out << \" -> \";\n\t\t\tout.replace( ps, pe-ps+1, o.c_str(), o.length() );\n//\t\t\tcout << out << endl;\n\t\t\tsolve( out, v );\n\t\t}\n\t\tif( cnt == 0 ) {\n\t\t\tstringstream ss;\n\t\t\tif(e[0]=='_') e[0]='-';\n\t\t\tss << e;\n\t\t\tll ans;\n\t\t\tss >> ans;\n\t\t\tv.push_back(ans);\n\t\t}\n\t}\n}\n\nint main() {\n\tstring expr;\n\twhile( cin >> expr, expr[0]!='#' ) {\n\t\tvector<ll> vi;\n\t\tsolve(expr, vi);\n//\t\tcout << \"---answers---\" << endl;\n//\t\trep(i, vi.size()) {\n//\t\t\tcout << vi[i] << endl;\n//\t\t}\n\t\tsort( vi.begin(), vi.end() );\n\t\tvi.erase( unique( vi.begin(), vi.end()), vi.end() );\n\t\tcout << vi.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<char, int> P;\ntypedef set<ll> st;\ntypedef vector<st> sv;\ntypedef vector<char> cv;\n\n#define INF 1e16\n\nstring form;\n\nbool is_op(char c){ return c=='+'||c=='-'||c=='*'||c=='/'; }\n\nll calc(ll a,ll b,char c){\n  if(c=='+') return a+b;\n  else if(c=='-') return a-b;\n  else if(c=='*') return a*b;\n  else if(c=='/'&&b!=0) return a/b;\n  else return -INF;\n}\n\nst merge(sv ns,cv op){\n  if(op.size()==0)return ns[0];\n  st res;\n  rep(i,op.size()){\n    sv tmp=ns;\n    cv nop=op;\n    st add;\n    each(o1,tmp[i])each(o2,tmp[i+1]){\n      ll cal=calc(o1,o2,nop[i]);\n      if(cal==-INF)continue;\n      add.insert(cal);\n    }\n    tmp[i]=add;\n    tmp.erase(tmp.begin()+i+1);\n    nop.erase(nop.begin()+i);\n    st e=merge(tmp,nop);\n    each(o,e){\n      res.insert(o);\n    }\n  }\n  return res;\n}\n\nst num(int l,int r){\n  st res;\n  res.insert(stoll(form.substr(l,r-l)));\n  return res;\n}\n\nst expr(int l,int r){\n  int level=0,nl=l;\n  sv tmp;\n  cv op;\n  repl(i,l,r){\n    if(form[i]=='(')level++;\n    else if(form[i]==')')level--;\n    else if(level==0&&(is_op(form[i]))){\n      tmp.pb(expr(nl,i));\n      op.pb(form[i]);\n      nl=i+1;\n    }\n  }\n  if(op.size()==0&&form[l]=='(')return expr(l+1,r-1);\n  else if(op.size()==0)return num(l,r);\n  else{\n    tmp.pb(expr(nl,r));\n    st res=merge(tmp,op);\n    return res;\n  }\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>form;\n    if(form==\"#\")break;\n    int n=form.length();\n    st res=expr(0,n);\n    cout<<res.size()<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\nusing namespace std;\n#define rep(i,a,b) for(auto (i)=(a);(i)<(b);(i)++)\n#define rev(i,a,b) for(auto (i)=(b)-1;(i)>=(a);(i)--)\n#define num_check(x) '0'<=(x)&&(x)<='9'\n\n\nstruct Siki{\n\tint num;\n\tchar type;\n\tint left, right;\n};\n\nint index[10];//各演算子のインデックス\nint pri[10];//各演算子の計算順序\nint min_pri[6];//各演算子のdepthごとの計算順序の最低値、これを破るとNG\nint op_size;\nSiki siki[30];\nSiki temp[30];\nint siki_size;\nstring input;\n\n\nbool check_pri(){\n\trep(i, 0, op_size){\n\t\tif (min_pri[siki[index[pri[i]]].num] > i)\n\t\t\treturn(false);\n\t}\n\treturn(true);\n}\n\nmap<int, int> data;\nvoid init(){\n\tdata.clear();\n\trep(i, 0, 30)siki[i].num = 0;\n\tint d=0;siki_size =op_size= 0;\n\trep(i, 0, 6)min_pri[i] = 0;\n\t//(3)+(1+(2*3-3)+5)+2*3\n\trep(i, 0u, input.length()){\n\t\tif (num_check(input[i])){\n\t\t\tsiki[siki_size].num *= 10, siki[siki_size].type = 'c', siki[siki_size].num += input[i] - '0';\n\t\t\tif (i + 1 == input.length() || !(num_check(input[i+1])))\n\t\t\t\tsiki_size++;\n\t\t}\n\t\telse if (input[i] == '(')d++;\n\t\telse if (input[i] == ')')d--;\n\t\telse\n\t\t{\n\t\t\tsiki[siki_size].type = input[i];\n\t\t\tsiki[siki_size].num = d;\n\t\t\tpri[op_size] = op_size;\n\t\t\trep(j, d + 1, 6)min_pri[j]++;\n\t\t\tindex[op_size++] = siki_size++;\n\t\t}\n\t}\n\trep(i, 0, op_size){\n\t\tsiki[index[i] - 1].right = siki[index[i] + 1].left = index[i];\n\t\tsiki[index[i]].left = index[i] - 1;\n\t\tsiki[index[i]].right = index[i] + 1;\n\t}\n\tsiki[0].left = -1;siki[siki_size - 1].right = -1;\n\t\n}\n\n\n\nint calc(int l, char op, int r){\n\tswitch (op){\n\tcase '+':return(l + r);\n\tcase '-':return(l - r);\n\tcase '*':return(l * r);\n\tcase '/':return(l / r);\n\t}\n\treturn(0);\n}\n\nvoid parse(){\n\tint result; Siki *p,*r,*l;\n\trep(i, 0, siki_size)temp[i] = siki[i];\n\trev(i, 0, op_size){\n\t\tp = &temp[index[pri[i]]];\n\t\tl = &temp[p->left];\n\t\tr = &temp[p->right];\n\n//\t\tcout << l->num << p->type << r->num << \"=\";\n\t\tresult=p->num = calc(l->num, p->type, r->num);\n//\t\tcout << p->num << endl;\n\t\tif(r->right>=0)temp[r->right].left = index[pri[i]];\n\t\tif (r->left >=0 )temp[l->left].right = index[pri[i]];\n\t\tp->left =l->left;\n\t\tp->right = r->right;\n\t}\n//\tcout << result << endl;\n\tdata[result]++;\n}\n\n\nvoid p(int d, int dm){\n\tif (d == dm){\n\t\tif (check_pri()){\n\t\t\tparse();\n\t\t}\n\t}\n\trep(i, d, dm){\n\t\tswap(pri[d], pri[i]);\n\t\tp(d + 1, dm);\n\t\tswap(pri[d], pri[i]);\n\t}\n}\n\n\n\nint main(void){\n\twhile (true){\n\t\tcin >> input;\n\t\tif (input == \"#\")break;\n\t\tinit();\n\t\t/*\t\n\t\trep(i, 0, siki_size)if (siki[i].type == 'c')printf(\"%d\", siki[i].num); else printf(\"%c\", siki[i].type); cout << endl;\n\t\trep(i, 0, op_size)printf(\"%c\", siki[index[i]].type); cout << endl;\n\t\trep(i, 0, op_size)printf(\"%d\", min_pri[siki[index[i]].num]); cout << endl;\n\t\t*/\n\t\tp(0, op_size);\n\t\tcout << data.size() << endl;\n\t}\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Result{\n  set<int> value;\n  int p;\n  Result(set<int> v, int p) : value(v), p(p) {}\n};\nbool is_operator(char c){\n  string operators = \"+-*/\";\n  REP(i, operators.size()) if(c == operators[i]) return true;\n  return false;\n}\nResult expr(const string& s, int p);\nResult factor(const string& s, int p){\n  if(s[p] == '('){\n    Result r = expr(s, p + 1);\n    assert(s[r.p] == ')');\n    r.p ++;\n    return r;\n  }else{\n    int v = 0;\n    while(isdigit(s[p])){\n      v = v * 10 + s[p++] - '0';\n    }\n    set<int> res;\n    res.insert(v);\n    return Result(res, p);\n  }\n}\nResult expr(const string& s, int p){\n  Result r = factor(s, p);\n  vector<char> operators;\n  vector< set<int> > operands;\n  operands.push_back(r.value);\n  while(is_operator(s[r.p])){\n    Result r_ = factor(s, r.p + 1);\n    operators.push_back(s[r.p]);\n    operands.push_back(r_.value);\n    r.p = r_.p;\n  }\n  set<int> dp[20][20];\n  int N = operands.size();\n  REP(i, N) dp[i][i + 1] = operands[i];\n  for(int len = 2; len <= N; len++){\n    for(int left = 0; left + len <= N; left++){\n      int right = left + len;\n      for(int ope = left + 1; ope < right; ope++){\n        FORIT(it1, dp[left][ope])FORIT(it2, dp[ope][right]){\n          if(operators[ope - 1] == '+'){\n            dp[left][right].insert(*it1 + *it2);\n          }else if(operators[ope - 1] == '-'){\n            dp[left][right].insert(*it1 - *it2);\n          }else if(operators[ope - 1] == '*'){\n            dp[left][right].insert(*it1 * *it2);\n          }else if(operators[ope - 1] == '/' && *it2 != 0){\n            dp[left][right].insert(*it1 / *it2);\n          }\n        }\n      }\n    }\n  }\n  r.value = dp[0][N];\n  return r;\n}\nint main(){\n  string s;\n  while(cin>>s && s != \"#\"){\n    set<int> res = expr(s, 0).value;\n    cout << res.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <sstream>\n#include <cstdio>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reps(i,s,n) for(int i=s; i<n; i++)\n#define all(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n\nll calc( string in, int index, bool& invalid ) {\n\tll res = -1, a=0, b=0;\n\trep(i, in.length()) if(in[i]=='_') in[i]='-';\n\tchar c = in[index];\n\tif( c == '+' ) {\n\t\tsscanf( in.c_str(), \"%lld+%lld\", &a, &b );\n\t\tres = a + b;\n\t} else if( c == '-' ) {\n\t\tsscanf( in.c_str(), \"%lld-%lld\", &a, &b );\n\t\tres = a - b;\n\t} else if( c == '*' ) {\n\t\tsscanf( in.c_str(), \"%lld*%lld\", &a, &b );\n\t\tres = a * b;\n\t} else if( c == '/' ) {\n\t\tsscanf( in.c_str(), \"%lld/%lld\", &a, &b );\n\t\tif( b != 0 ) {\n\t\t\tres = a / b;\n\t\t} else {\n\t\t\tinvalid = true;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid solve( string e, vector<ll>& v ) {\n//\tcout << e << endl;\n\tbool br = false;\n\tint brBeg = 0;\n\trep(i, e.length()) {\n\t\tif( e[i] == '(' ) {\n\t\t\tbr = true;\n\t\t\tbrBeg = i;\n\t\t}\n\t}\n\tif( br ) {\n\t\tint cnt = 0;\n\t\tint brEnd = 0;\n\t\tfor(int i=brBeg+1; i<e.length(); i++) {\n\t\t\tif( e[i]==')' ) {\n\t\t\t\tif( cnt==0 ) {\n\t\t\t\t\tbrEnd = i;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tcnt--;\n\t\t\t\t}\n\t\t\t} else if( e[i]=='('){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tstring ne = e.substr(brBeg+1, brEnd-brBeg-1);\n\t\tvector<ll> vi;\n\t\tsolve( ne, vi );\n\t\trep(i, vi.size()) {\n\t\t\tstring out = e;\n\t\t\tstringstream ss;\n\t\t\tss << vi[i];\n\t\t\tstring rep;\n\t\t\tss >> rep;\n\t\t\tif(rep[0] == '-') rep[0] = '_';\n\t\t\tout.replace( brBeg, brEnd-brBeg+1, rep.c_str(), rep.length() );\n\t\t\tsolve( out, v );\n\t\t}\n\t} else {\n\t\tint pos[10], cnt=0;\n\t\trep(i, e.length()) {\n\t\t\tif( e[i]=='+' || e[i]=='-' || e[i]=='*' || e[i]=='/' ) {\n\t\t\t\tpos[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\trep(i, cnt) {\n\t\t\tint ps=pos[i]-1, pe=pos[i]+1;\n\t\t\twhile( 0<=ps && (('0'<=e[ps] && e[ps]<='9') || e[ps]=='_') ) ps--;\n\t\t\tps++;\n\t\t\twhile( pe<e.length() && (('0'<=e[pe] && e[pe]<='9') || e[pe]=='_') ) pe++;\n\t\t\tpe--;\n\t\t\tbool invalid = false;\n\t\t\tll res = calc( e.substr( ps, pe-ps+1 ), pos[i]-ps, invalid );\n\t\t\tif( invalid ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstringstream ss;\n\t\t\tss << res;\n\t\t\tstring o;\n\t\t\tss >> o;\n\t\t\tif(o[0]=='-') o[0] = '_';\n//\t\t\tcout << \"start : \" << ps << endl;\n//\t\t\tcout << \"end : \" << pe-ps+1 << endl;\n\t\t\tstring out = e;\n//\t\t\tcout << \"o : \" << o << endl;\n//\t\t\tcout << \"out : \" << out << \" -> \";\n\t\t\tout.replace( ps, pe-ps+1, o.c_str(), o.length() );\n//\t\t\tcout << out << endl;\n\t\t\tsolve( out, v );\n\t\t}\n\t\tif( cnt == 0 ) {\n\t\t\tstringstream ss;\n\t\t\tss << e;\n\t\t\tif(e[0]=='_') e[0]='-';\n\t\t\tll ans;\n\t\t\tss >> ans;\n\t\t\tv.push_back(ans);\n\t\t}\n\t}\n}\n\nint main() {\n\tstring expr;\n\twhile( cin >> expr, expr[0]!='#' ) {\n\t\tvector<ll> vi;\n\t\tsolve(expr, vi);\n\t\tsort( vi.begin(), vi.end() );\n\t\tvi.erase( unique( vi.begin(), vi.end()), vi.end() );\n\t\tcout << vi.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n \nstring line;\n \ninline bool isOp(char c) {\n  return c == '+' || c == '-' || c == '*' || c == '/';\n}\n \nset<int> rec(int l, int r) {\n  vector<int> v;\n  for(int i = l, j = 0; i < r; ++i) {\n    if(line[i] == '(') ++j;\n    if(line[i] == ')') --j;\n    if(j == 0 && isOp(line[i])) v.push_back(i);\n  }\n \n  if(v.size() == 0) {\n    if(line[l] == '(') return rec(l+1, r-1);\n    set<int> res;\n    res.insert(atoi(line.substr(l,r-l).c_str()));\n    return res;\n  }\n \n  set<int> res;\n  for(int i = 0; i < v.size(); ++i) {\n    set<int> a, b;\n    a = rec(l, v[i]);\n    b = rec(v[i]+1, r);\n    for(set<int>::iterator p = a.begin();\n        p != a.end(); ++p) {\n      for(set<int>::iterator q = b.begin();\n          q != b.end(); ++q) {\n        if(line[v[i]] == '+') {\n          res.insert(*p + *q);\n        } else if(line[v[i]] == '-') {\n          res.insert(*p - *q);\n        } else if(line[v[i]] == '*') {\n          res.insert(*p * *q);\n        } else if(line[v[i]] == '/') {\n          if(*q != 0) res.insert(*p / *q);\n        }\n      }\n    }\n  }\n  return res;\n}\n \nint main() {\n  while(getline(cin, line) && line != \"#\") {\n    cout << rec(0, line.size()).size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\nusing namespace std;\n#define rep(i,a,b) for(auto (i)=(a);(i)<(b);(i)++)\n#define rev(i,a,b) for(auto (i)=(b)-1;(i)>=(a);(i)--)\n#define num_check(x) '0'<=(x)&&(x)<='9'\n\n\nstruct Siki{\n\tint num;\n\tint depth;\n\tchar type;\n\tint left, right;\n\n};\n\nint pri[10];//各演算子の計算順序\nint min_pri[6];//各演算子のdepthごとの計算順序の最低値、これを破るとNG\nSiki siki[12];\nSiki temp[12];//作業用配列\nint s_size;\nstring input;\nmap<int, int> data;\n\nbool check_pri(){\n\trep(i, 0, s_size){\n\t\tif (min_pri[siki[pri[i]].depth] > i)\n\t\t\treturn(false);\n\t}\n\treturn(true);\n}\n\nvoid init(){\n\t//初期化\n\tdata.clear();\n\trep(i, 0, 12)siki[i].num = 0;\n\trep(i, 0, 6)min_pri[i] = 0;\n\tint d = 0; \n\ts_size = 0;\n\t\n\t//入力を作業用に変換\n\trep(i, 0u, input.length()){\n\t\tif (num_check(input[i])){\n\t\t\tsiki[s_size].num *= 10;\n\t\t\tsiki[s_size].num += input[i] - '0';\n\t\t}\n\t\telse if (input[i] == '(')d++;//()の中に入るので深さを増加\n\t\telse if (input[i] == ')')d--;//深さを減少\n\t\telse\n\t\t{\n\t\t\tsiki[s_size].type = input[i];\n\t\t\tsiki[s_size].depth = d;\n\t\t\tpri[s_size] = s_size;\n\t\t\trep(j, d + 1, 6)\n\t\t\t\tmin_pri[j]++;\n\t\t\ts_size++;\n\t\t}\n\t}\n\tsiki[s_size].type = '\\0';//終端記号\n\trep(i, 0, s_size){\n\t\t//連結リスト構造の作成\n\t\tsiki[i].right = i+1;\n\t\tsiki[i + 1].left = i;\n\t}\n\tsiki[0].left = siki[s_size].right = -1;//左端、右端の保護\n\t\n}\n\n//2項計算する関数\nint calc(int l, char op, int r){\n\tswitch (op){\n\tcase '+':return(l + r);\n\tcase '-':return(l - r);\n\tcase '*':return(l * r);\n\tcase '/':return(l / r);\n\t}\n\treturn(0);\n}\n\n\nvoid parse(){\n\tSiki *p,*r,*l;\n\trep(i, 0, s_size+1)temp[i] = siki[i];//作業用配列にコピー\n\trev(i, 0, s_size){\n\t\tp = &temp[pri[i]];\n\t\tl = &temp[p->left];\n\t\tr = &temp[p->right];\n\n\t\tif (r->num == 0 && p->type == '/')return;//0除算を省く\n\t\t//printf(\"%d%c%d=\", p->num, p->type, r->num);\n\t\tr->num = calc(p->num, p->type, r->num);\n\t\t//printf(\"%d\\n\", r->num);\n\t\tr->left = p->left;\n\t\tif (l->left >=0 )l->right = p->right;\n\n\t}\n\tcout << temp[s_size].num << endl;\n\tdata[temp[s_size].num]++;\n}\n\n//順列を効率的に列挙するための関数\nvoid p(int d, int dm){\n\tif (d == dm){\n\t\tif (check_pri()){\n\t\t\tparse();\n\t\t}\n\t}\n\trep(i, d, dm){\n\t\tswap(pri[d], pri[i]);\n\t\tp(d + 1, dm);\n\t\tswap(pri[d], pri[i]);\n\t}\n}\n\nint main(void){\n\twhile (true){\n\t\tcin >> input;\n\t\tif (input[0] == '#')break;\n\t\tinit();\n\t\t/*\t\n\t\trep(i, 0, siki_size)if (siki[i].type == 'c')printf(\"%d\", siki[i].num); else printf(\"%c\", siki[i].type); cout << endl;\n\t\trep(i, 0, op_size)printf(\"%c\", siki[index[i]].type); cout << endl;\n\t\trep(i, 0, op_size)printf(\"%d\", min_pri[siki[index[i]].num]); cout << endl;\n\t\t*/\n\t\tp(0, s_size);\n\t\tcout << data.size() << endl;\n\t}\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int DUMMY = 1e13;\nint op(int l, int r, char c) {\n    if (l == DUMMY || r == DUMMY) return DUMMY;\n    if (c == '+') return l + r;\n    if (c == '-') return l - r;\n    if (c == '*') return l * r;\n    if (c == '/') return r == 0 ? DUMMY : l / r;\n    assert(0);\n}\nbool is_op(char c) {\n    return c == '+' || c =='-' || c == '*' || c == '/';\n}\nstring s;\nset<int> exp1(int& i);\nset<int> exp2(int& i);\nint number(int& i);\n\nset<int> rec(vector<set<int>>& ss, vector<int>& ops) {\n    assert(ss.size() ==  ops.size() + 1);\n    if (ops.size() == 0) return ss[0];\n    set<int> ret;\n    for (int i = 0; i < ops.size(); i++) {\n        vector<set<int>> lss, rss;\n        vector<int> lops, rops;\n        for (int k = 0; k < i + 1; k++) {\n            lss.push_back(ss[k]);\n        }\n        for (int k = 0; k < i; k++) {\n            lops.push_back(ops[k]);\n        }\n        for (int k = i + 1; k < ss.size(); k++) {\n            rss.push_back(ss[k]);\n        }\n        for (int k = i + 1; k < ops.size(); k++) {\n            rops.push_back(ops[k]);\n        }\n\n        set<int> ls = rec(lss, lops);\n        set<int> rs = rec(rss, rops);\n        for (int x : ls) {\n            for (int y : rs) {\n                ret.insert(op(x, y, ops[i]));\n            }\n        }\n    }\n    // for (int x : ret) cerr << x << endl;\n    return ret;\n}\nset<int> exp1(int& i) {\n    vector<set<int>> ss;\n    vector<int> ops;\n    ss.push_back(exp2(i));\n    while (i < s.size() && s[i] != ')') {\n        assert(is_op(s[i]));\n        ops.push_back(s[i]);\n        i++;\n        ss.push_back(exp2(i));\n    }\n    if (i < s.size()) {\n        assert(s[i] == ')');\n        i++;\n    }\n    return rec(ss, ops);\n}\nset<int> exp2(int& i) {\n    if (s[i] == '(') {\n        set<int> ret = exp1(++i);\n        // assert(s[i] == ')');\n        // i++;\n        return ret;\n    }\n    set<int> ret;\n    ret.insert(number(i));\n    return ret;\n}\nint number(int& i) {\n    int acc = 0;\n    while (isdigit(s[i])){\n        acc = acc * 10 + (s[i++] - '0');\n    }\n    return acc;\n}\n\nvoid solve() {\n    cin >> s;\n    if (s == \"#\") exit(0);\n    int i = 0;\n    set<int> ret = exp1(i);\n    // for (int x : ret) cerr << x << endl;\n    if (ret.count(DUMMY)) ret.erase(DUMMY);\n    cout << ret.size() << endl;\n}\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while (1) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\nusing namespace std;\n\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define absd(x) (x<0?-(x):x)\n#define pow2(x) ((x)*(x))\n#define rep(i,n) for(int i=0; i<n; ++i)\n#define repr(i,n) for(int i=n-1; i>=0; --i)\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define replr(i,s,n) for(int i=n; i>=s; --i)\n#define repf(i,s,n,j) for(int i=s; i<=n; i+=j)\n#define repe(e,obj) for(auto e : obj)\n\n#define SP << \" \" <<\n#define COL << \" : \" <<\n#define COM << \", \" <<\n#define ARR << \" -> \" <<\n#define PNT(STR) cout << STR << endl\n#define POS(X,Y) \"(\" << X << \", \" << Y << \")\"\n#define DEB(A) \" (\" << #A << \") \" << A\n#define DEBREP(i,n,val) for(int i=0; i<n; ++i) cout << val << \" \"; cout << endl\n#define ALL(V) (V).begin(), (V).end()\n#define INF 1000000007\n#define INFLL 10000000000000000007LL\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\n//typedef pair<ll, ll> P;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\ntypedef pair<P, P> PP;\ntypedef priority_queue<P, vector<P>, greater<P> > pvqueue;\n\ntypedef set<int> seti;\n\n#define N 105\n\nint cur;\nstring s;\nseti parse() {\n  seti dp[N][N];\n  int idx = 0;\n  char op[N];\n  int num = 0;\n  while(cur < s.length()) {\n    char c = s[cur];\n    if('0' <= c && c <= '9') {\n      if(num == -1) {\n        num = c - '0';\n      } else {\n        num = 10*num + (c - '0');\n      }\n    } else if(c == '(') {\n      ++cur;\n      dp[idx][idx] = parse();\n      //cout << idx SP num << endl;\n      num = -1;\n    } else if(c == ')') {\n      break;\n    } else {\n      // \"+\", \"-\", \"/\", \"*\"\n      if(num != -1) {\n        dp[idx][idx].insert(num);\n        //cout << idx SP num << endl;\n      }\n      op[idx] = c;\n      num = -1;\n      ++idx;\n    }\n    ++cur;\n  }\n\n  if(num != -1) {\n    dp[idx][idx].insert(num);\n    //cout << idx SP num << endl;\n  }\n\n  //cout << \"solve \" << idx << endl;\n\n  int sz = idx;\n  repl(l, 1, sz) {\n    rep(i, sz-l+1) {\n      int j = i+l;\n      repl(k, i, j-1) {\n        //cout << \"s\" SP l SP i SP j SP k << endl;\n        // dp[i][k] + dp[k][j]\n        seti ss;\n        seti &s1 = dp[i][k], &s2 = dp[k+1][j];\n        //cout << \"op \" << op[k] << endl;\n        //cout << \"sz \" << s1.size() SP s2.size() << endl;\n        switch(op[k]) {\n          case '+': {\n                      repe(v1, s1) {\n                        repe(v2, s2) {\n                          ss.insert(v1+v2);\n                        }\n                      }\n                      break;\n                    }\n          case '-':\n                    {\n                      repe(v1, s1) {\n                        repe(v2, s2) {\n                          ss.insert(v1-v2);\n                        }\n                      }\n                      break;\n                    }\n          case '*':\n                    {\n                      repe(v1, s1) {\n                        repe(v2, s2) {\n                          ss.insert(v1*v2);\n                        }\n                      }\n                      break;\n                    }\n          case '/':\n                    {\n                      repe(v1, s1) {\n                        repe(v2, s2) {\n                          if(v2 != 0) ss.insert(v1/v2);\n                        }\n                      }\n                      break;\n                    }\n        }\n        dp[i][j].insert(ss.begin(), ss.end());\n      }\n      //cout << \"w\" SP i SP j SP dp[i][j].size() << endl;\n    }\n  }\n  /*\n  cout << \"return \" SP dp[0][sz].size() << endl;\n  cout << \"{\";\n  repe(v, dp[0][sz]) cout << \" \" << v;\n  cout << \" }\" << endl;\n  */\n  return dp[0][sz];\n}\n\nint main() {\n  while(cin >> s && s[0] != '#') {\n    cur = 0;\n    set<int> res = parse();\n    cout << res.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//56\n#include<iostream>\n#include<set>\n#include<algorithm>\n#include<cstdio>\n#include<cctype>\n#include<vector>\n#include<cstdlib>\n\nusing namespace std;\n\nset<int> cs(vector<set<int> > n,vector<char> o){\n  if(o.empty()){\n    return n[0];\n  }else{\n    set<int> st;\n    for(int i=0;i<o.size();i++){\n      set<int> l=cs(vector<set<int> > (n.begin(),n.begin()+i+1),vector<char> (o.begin(),o.begin()+i));\n      set<int> r=cs(vector<set<int> > (n.begin()+i+1,n.end()),vector<char> (o.begin()+i+1,o.end()));\n      for(set<int>::iterator k=l.begin();k!=l.end();k++){\n\tfor(set<int>::iterator j=r.begin();j!=r.end();j++){\n\t  if(o[i]=='+'){\n\t    st.insert(*k+*j);\n\t  }else if(o[i]=='-'){\n\t    st.insert(*k-*j);\n\t  }else if(o[i]=='*'){\n\t    st.insert(*k**j);\n\t  }else if(*j){\n\t    int r=abs(*k)/abs(*j);\n\t    st.insert((*k**j<0)?-r:r);\n\t  }\n\t}\n      }\n    }\n    return st;\n  }\n}\n\nset<int> exp(char *s){\n  vector<set<int> > n;\n  vector<char> o;\n  for(int i=0;s[i];){\n    if(isdigit(s[i])){\n      int d,r;\n      sscanf(s+i,\"%d%n\",&d,&r);\n      i+=r;\n      set<int> ss;\n      ss.insert(d);\n      n.push_back(ss);\n    }else if(s[i]!='('){\n      o.push_back(s[i]);\n      i++;\n    }else{\n      int b;\n      sscanf(s+i,\"(%*[^)])%n\",&b);\n      char ns[201]={};\n      copy(s+i+1,s+i+b-1,ns);\n      n.push_back(exp(ns));\n      i+=b;\n    }\n  }\n  return cs(n,o);\n}\n \nint main(){\n  char s[201];\n  while(cin>>s,s[0]!='#'){\n    cout<<exp(s).size()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nbool cyk[201][201][15];\n\nint main() {\n  while (true) {\n    string s;\n    cin>>s;\n    if (s == \"#\") break;\n    cout<<s<<endl;\n    int n = s.size();\n    vector<vector<vector<set<int>>>> dp(n+1, vector<vector<set<int>>>(n+1, vector<set<int>>(15)));\n    REP(i,n+1)REP(j,n+1)REP(k,15) cyk[i][j][k] = false;\n    REP(i,n+1) {\n      cyk[i][0][14] = true;\n    }\n    REP(i,n) {\n      if (isdigit(s[i])) {\n        cyk[i][1][2] = true;\n        dp[i][1][2].insert(s[i] - '0');\n      } else {\n        switch (s[i]) {\n          case '(':\n          cyk[i][1][8] = true;\n          break;\n          case ')':\n          cyk[i][1][9] = true;\n          break;\n          case '+':\n          cyk[i][1][10] = true;\n          break;\n          case '-':\n          cyk[i][1][11] = true;\n          break;\n          case '*':\n          cyk[i][1][12] = true;\n          break;\n          case '/':\n          cyk[i][1][13] = true;\n          break;\n        }\n      }\n    }\n    using T = tuple<int,int,int>;\n    vector<T> rule = {\n      { 8, 3, 0},\n      { 0, 4, 0},\n      { 0, 5, 0},\n      { 0, 6, 0},\n      { 0, 7, 0},\n      { 0, 9, 3},\n      {10, 0, 4},\n      {11, 0, 5},\n      {12, 0, 6},\n      {13, 0, 7},\n      { 1, 2, 1},\n      { 2,14, 1},\n      { 1,14, 0}\n    };\n     \n    FOR(l,1,n+1)REP(i,n) {\n      FOR(k,1,l+1)REP(m,rule.size()) {\n        int first, second, result;\n        tie(first, second, result) = rule[m];\n        if (cyk[i][k][first] && cyk[i+k][l-k][second]) {\n          cyk[i][l][result] = true;\n          switch(m) {\n            case 0: // <(> + <3>\n            case 6: // <+> + <expr>\n            case 7: // <-> + <expr>\n            case 8: // <*> + <expr>\n            case 9: // </> + <expr>\n              dp[i][l][result] = dp[i+k][l-k][second];\n              break;\n            case 5: // <expr> + <)>\n            case 11: // <digit> + empty\n            case 12: // <num> + empty\n              dp[i][l][result] = dp[i][k][first];\n              break;\n            case 1: // <expr> + <4>\n              for (int x:dp[i][k][first]) {\n                for (int y:dp[i+k][l-k][second]) {\n                  dp[i][l][result].insert(x+y);\n                }\n              }\n              break;\n            case 2: // <expr> + <5>\n              for (int x:dp[i][k][first]) {\n                for (int y:dp[i+k][l-k][second]) {\n                  dp[i][l][result].insert(x-y);\n                }\n              }\n              break;\n            case 3: // <expr> + <6>\n              for (int x:dp[i][k][first]) {\n                for (int y:dp[i+k][l-k][second]) {\n                  dp[i][l][result].insert(x*y);\n                }\n              }\n              break;\n            case 4: // <expr> + <7>\n              for (int x:dp[i][k][first]) {\n                for (int y:dp[i+k][l-k][second]) {\n                  if (y != 0) {\n                    dp[i][l][result].insert(x/y);\n                  }\n                }\n              }\n              break;\n            case 10: // <num> + <digit>\n              dp[i][l][result].insert(\n                  *begin(dp[i][k][first]) * 10 + *begin(dp[i+k][l-k][second]));\n              break;\n          }\n        }\n      }\n    }\n    cout << dp[0][n][0].size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nchar S[211];\n \nset<ll> solve(int l,int r);\n \nvoid view( set<ll> b ){\n  cout << \"view\" << endl;\n  for( set<ll>::iterator it = b.begin(); it != b.end(); it++)\n    cout << *it << \" \";\n  cout << endl;\n}\n \nint check(int l,int r){\n  ll k = 0;\n  for(int i=l;i<=r;i++){\n    if( !isdigit(S[i]) ) return -1;\n    k*=10LL;\n    k+=(ll)(S[i]-'0');\n  }\n  return k;\n}\n \nset<ll> calc(set<ll> a,set<ll> b,char c){\n  set<ll> ret;\n  for( set<ll>::iterator it = a.begin(); it != a.end(); it++){\n    for( set<ll>::iterator jt = b.begin(); jt != b.end(); jt++){\n      if( c == '+' ){\n    ret.insert( *it + *jt );\n      } else if( c== '-' ){\n    ret.insert( *it - *jt );\n      } else if( c== '*' ){\n    ret.insert( (*it) * (*jt) );\n      } else {\n    if( *jt == 0 ) continue;\n    ret.insert( *it / *jt );\n      }\n    }\n  }\n  return ret;\n}\n \nset<ll> check2(int l,int r){\n  int cnt = 0;\n  set<ll> a,b;\n  int nc = -1;\n  for(int i=l;i<=r;i++){\n    if( S[i] == '(' ){\n      cnt++;\n    } else if (S[i] == ')' ){\n      cnt--;\n    }\n    else if( cnt == 0  && ( S[i] == '+' || S[i] == '-' || S[i] == '*' || S[i] == '/' )){\n      a = calc( solve(l,i-1), solve(i+1,r), S[i]);\n      nc = i;\n      break;\n    }\n  }\n  cnt = 0; \n  for(int i=r;i>=l;i--){\n    if( S[i] == ')' ){\n      cnt++;\n    } else if (S[i] == '(' ){\n      cnt--;\n    }\n    else if( cnt == 0  && ( S[i] == '+' || S[i] == '-' || S[i] == '*' || S[i] == '/' )){\n      if( nc == i ) break;\n      b = calc( solve(l,i-1), solve(i+1,r), S[i]);\n      break;\n    }\n  }\n  //  cout << l << \" \"<< r << endl;\n  //view(a);\n  if( b.empty() ) return a;\n  // view(b);\n  for( set<ll>::iterator it = b.begin(); it != b.end(); it++)\n    a.insert( *it );\n \n \n  return a;\n}\n \nbool check3(int l,int r){\n  int cnt = 0;\n  if( S[l] != '(' ) return false;\n  for(int i=l;i<=r;i++){\n    if( S[i] == '(' ) cnt++;\n    else if( S[i] == ')' ){\n      cnt--;\n      if( cnt == 0 && i == r ) return true;      \n      return false;\n    }\n  }\n  return false;\n}\n \nset<ll> solve(int l,int r){\n  if( check3(l,r) )\n    return solve(l+1,r-1);\n   \n  int tmp = check(l,r);\n  if( tmp>-1 ){\n    //cout << l << \" \"<< r << \" \" << tmp << endl;\n    set<ll> s; s.insert(tmp);\n    return s;\n  }\n   \n  return check2(l,r);\n}\n \n \nint main(){\n  while( cin >> S ){\n    if( S[0] == '#' ) break;\n    set<ll> res = solve(0,strlen(S)-1);\n    cout << res.size() << endl;\n    //    view(res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <sstream>\n \nusing namespace std;\n \nset<int> m1[250][250];\nbool m2[250][250];\n \nint stoi(string s) {\n\tstringstream ss; ss << s;\n\tint ret; ss >> ret;\n\treturn ret;\n}\n \nstring str;\nset<int> dp(int l, int r) {\n\tif (m2[l][r]) return m1[l][r];\n\tif (str[l] == '(' && str[r-1] == ')') return dp(l+1, r-1);\n\n\tset<int> ret;\n\tbool f = true;\n\tfor (int i = l; i < r; ++i) {\n\t\tif (!isdigit(str[i])) f = false;\n\t}\n\tif (f) {\n\t\tret.insert( stoi(str.substr(l, r-l)) );\n\t}\n\telse {\n\t\tint depth = 0;\n\t\tfor (int i = l; i < r; ++i) {\n\t\t\tswitch (str[i]) {\n\t\t\t\tcase '(':\n\t\t\t\t\t++depth;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ')':\n\t\t\t\t\t--depth;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '+':\n\t\t\t\tcase '-':\n\t\t\t\tcase '*':\n\t\t\t\tcase '/':\n\t\t\t\tif (depth == 0) {\n\t\t\t\t\tset<int> L = dp(l, i), R = dp(i+1, r);\n\t\t\t\t\tfor (set<int>::iterator j = L.begin(); j != L.end(); ++j) {\n\t\t\t\t\t\tfor (set<int>::iterator k = R.begin(); k != R.end(); ++k) {\n\t\t\t\t\t\t\tswitch (str[i]) {\n\t\t\t\t\t\t\t\tcase '+': ret.insert(*j+*k); break;\n\t\t\t\t\t\t\t\tcase '-': ret.insert(*j-*k); break;\n\t\t\t\t\t\t\t\tcase '*': ret.insert((*j)*(*k)); break;\n\t\t\t\t\t\t\t\tcase '/': if (*k) ret.insert((*j)/(*k)); break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn m2[l][r] = true, m1[l][r] = ret;\n}\n \nint main() {\n\twhile (cin >> str, str != \"#\") {\n\t\tfill(&m2[0][0], &m2[0][0]+201*201, false);\n\t\tcout << dp(0, str.size()).size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nvector<char> op;\nset<ll> res;\n\ninline bool num(char c){return '0'<=c && c<='9';}\ninline bool alp(char c){return 'a'<=c && c<='z';}\ninline bool ope(char c){return c=='+' || c=='-' || c=='*' || c=='/';}\n\nbool valid(string s)\n{\n    int b=0,o=0;\n    rep(i,s.size())\n    {\n        if(s[i]=='(') ++b;\n        else if(s[i]==')') --b;\n        else if(alp(s[i])) ++o;\n    }\n    return b==0 && o==0;\n}\n\nll get_num(string s)\n{\n    int S = s.size();\n    int l = 0, r = S-1;\n    while(s[l]=='(') ++l;\n    while(s[r]==')') --r;\n    return atoll(s.substr(l,r-l+1).c_str());\n}\n\nstring rmbr(string s)\n{\n    bool update = true;\n    while(update)\n    {\n        update = false;\n        int S = s.size();\n        int idx = 0;\n\n        string ret=\"\";\n        while(idx<S)\n        {\n            if(s[idx]=='(')\n            {\n                bool fail=false;\n                int st = idx;\n                ++idx;\n                while(s[idx]!=')')\n                {\n                    if(s[idx]=='(')\n                    {\n                        fail = true;\n                        break;\n                    }\n                    ++idx;\n                }\n\n                string x = s.substr(st,idx-st+1);\n                if(fail)\n                {\n                    x = s.substr(st,idx-st);\n                    ret += x;\n                    continue;\n                }\n\n                if(!fail) fail = !valid(x);\n                if(fail) ret += x;\n                else\n                {\n                    update = true;\n                    ret += to_string(get_num(x));\n                }\n            }\n            else ret += s[idx];\n\n            ++idx;\n        }\n        s = ret;\n    }\n    return s;\n}\n\nset<string> vis;\nvoid dfs(string s)\n{\n    s = rmbr(s);\n    if(vis.count(s)) return;\n    vis.insert(s);\n\n    int S = s.size();\n    vector<int> pos;\n    rep(i,S)if(alp(s[i])) pos.pb(i);\n\n    int P = pos.size();\n    if(P==0) res.insert(get_num(s));\n\n    rep(i,P)\n    {\n        int xl = 0;\n        if(i>0) xl = pos[i-1]+1;\n        int yr = S-1;\n        if(i<P-1) yr = pos[i+1]-1;\n\n        while(s[xl]=='(') ++xl;\n        while(s[yr]==')') --yr;\n        string x = s.substr(xl,pos[i]-xl);\n        string y = s.substr(pos[i]+1,yr-pos[i]);\n\n        char o = op[s[pos[i]]-'a'];\n        if(valid(x) && valid(y))\n        {\n            ll X = get_num(x), Y = get_num(y);\n            if(o=='+') X+=Y;\n            else if(o=='-') X-=Y;\n            else if(o=='*') X*=Y;\n            else if(o=='/')\n            {\n                if(Y==0) continue;\n                X/=Y;\n            }\n\n            string t = s;\n            t.replace(xl, x.size()+y.size()+1, to_string(X));\n            dfs(t);\n        }\n    }\n}\n\nint main()\n{\n    string s;\n    while(cin >>s,(s!=\"#\"))\n    {\n        op.clear();\n        rep(i,s.size())if(ope(s[i]))\n        {\n            op.pb(s[i]);\n            s[i] = 'a'+op.size()-1;\n        }\n\n        vis.clear();\n        res.clear();\n        dfs(s);\n        cout << res.size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int INF = 1e9;\nint N, M;\nint opPos[10];\nint depth[10];\nint num[10];\nstring s;\nset<int> ans;\nint c;\n\nbool isOperator(char c) {\n\treturn c == '+' || c == '-' || c == '*' || c == '/';\n}\n\nvoid dfs(int d) {\n\twhile(c < N && s[c] != ')') {\n\t\tif(s[c] == '(') {\n\t\t\tc++;\n\t\t\tdfs(d + 1);\n\t\t\tassert(s[c] == ')');\n\t\t}\n\t\tif(isOperator(s[c])) {\n\t\t\tfor(int i = 0; i < M; i++) {\n\t\t\t\tif(opPos[i] == c) depth[i] = d;\n\t\t\t}\n\t\t}\n\t\tc++;\n\t}\n}\n\nint findMinPos(int l, int r) {\n\tint minId = -1;\n\tfor(int i = 0; i < M; i++) {\n\t\tif(l <= opPos[i] && opPos[i] <= r) {\n\t\t\tif(minId == -1 || num[minId] > num[i]) minId = i;\n\t\t}\n\t}\n\tif(minId == -1) return -1;\n\treturn opPos[minId];\n}\n\nint R(double n) {\n\tif(n > 0) return (int)floor(n);\n\treturn (int)ceil(n);\n\tdouble an = abs(n);\n\tint ret = round(an - 1e-9);\n\tif(n < 0) ret *= -1;\n\treturn ret;\n}\n\nint f(int l, int r) {\n\tint minPos = findMinPos(l, r);\n\tif(minPos == -1) {\n\t\tint ret = 0;\n\t\twhile(s[l] == '(') l++;\n\t\twhile(s[r] == ')') r--;\n\t\tfor(int i = l; i <= r; i++) {\n\t\t\tassert(isdigit(s[i]));\n\t\t\tret = ret * 10 + s[i] - '0';\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint vl = f(l, minPos - 1), vr = f(minPos + 1, r);\n\tif(vl == INF || vr == INF) return INF;\n\tchar op = s[minPos];\n\tif(op == '+') return vl + vr;\n\tif(op == '-') return vl - vr;\n\tif(op == '*') return vl * vr;\n\tif(vr == 0) return INF;\n\tint ret = R((double)vl / vr);\n\treturn ret;\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> s, s != \"#\") {\n\t\tN = s.size();\n\t\tM = 0;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tif(isOperator(s[i])) {\n\t\t\t\topPos[M] = i;\n\t\t\t\tdepth[M] = 0;\n\t\t\t\tM++;\n\t\t\t}\n\t\t}\n\t\tc = 0;\n\t\tdfs(0);\n\n\t\tvector<int> p(M);\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tp[i] = i;\n\t\t}\n\n\t\tans.clear();\n\t\tdo {\n\t\t\tfor(int i = 0; i < M; i++) {\n\t\t\t\tnum[i] = p[i] + depth[i] * 100;\n\t\t\t}\n\t\t\tint res = f(0, N - 1);\n\t\t\tif(res != INF) ans.insert(res);\n\t\t} while(next_permutation(p.begin(), p.end()));\n\n\t\tcout << ans.size() << endl;\n\t\t/*for(auto a : ans) {\n\t\t\tcout << a << \" \";\n\t\t}\n\t\tcout << endl;*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\n#define MP make_pair\n\ntypedef pair<int, int> PII;\n\nconst int SIZE = 15;\n\nchar line[SIZE], t[SIZE];\nset<int> memo[SIZE][SIZE];\nset<PII> used;\n \nvoid eval(int const l, int const r) {\n   \n  set<int>& ret = memo[l][r];\n  if(l == r) return;\n   \n  if(used.count(MP(l, r))) return;\n  used.insert(MP(l, r));\n   \n  // check is digits [l, r)\n  bool digits = true;\n  for(int i=l; i<r; i++) { digits = digits && isdigit(line[i]); }\n  strncpy(t, line+l, r-l); t[r-l+1] = 0;\n  if(digits) { ret.insert(atoi(t)); return; }\n   \n  int par = 0; bool check = true;\n  for(int i=l; i<r-1; i++) {\n    if(line[i] == '(') { par ++; }\n    if(line[i] == ')') { par --; }\n    if(par == 0) { check = false; }\n  }\n   \n  // \"(expr)\"\n  if(check) {\n    if(line[r-1] == ')') {\n      eval(l+1, r-1); ret = memo[l+1][r-1]; return;\n    }\n  }\n   \n  par = 0;\n  // parsing loop\n  for(int i=l; i<r; i++) {\n    if(line[i] == '(') { par ++; }\n    if(line[i] == ')') { par --; }\n    if(par != 0) continue;\n     \n    switch(line[i]) {\n    case '+': case '-': case '*': case '/': {\n      eval(l, i); eval(i+1, r);\n      set<int>::iterator iter_a, iter_b;\n      for(iter_a = memo[l][i].begin(); iter_a!=memo[l][i].end(); iter_a++) {\n        for(iter_b = memo[i+1][r].begin(); iter_b!=memo[i+1][r].end(); iter_b++) {\n          if(line[i] == '+') { ret.insert(*iter_a + *iter_b); }\n          if(line[i] == '-') { ret.insert(*iter_a - *iter_b); }\n          if(line[i] == '*') { ret.insert(*iter_a * *iter_b); }\n          if(line[i] == '/') {\n            if(*iter_b == 0) continue;\n            ret.insert(*iter_a / *iter_b);\n          }\n        }\n      }\n      break;\n    }\n    default:;\n    }\n  } // for parsing loop\n}\n \nint main() {\n   \n  while(1) {\n    scanf(\"%s\\n\", line);\n    for(int i=0; i<SIZE; i++)\n      for(int j=0; j<SIZE; j++)\n        memo[i][j].clear();\n     \n    used.clear();\n     \n    if(0==strcmp(line, \"#\")) break;\n    eval(0, strlen(line));\n    cout << memo[0][strlen(line)].size() << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s;\nint a[200],p,f;\nchar b[11];\nint bns1();\nint g_A(){\n  int r=0;\n  if(s[p]=='(')p++,r=bns1(),p++;\n  else while(isdigit(s[p]))r=r*10+(s[p++]-'0');\n  return r;\n}\nint bns10(){\n  int res=g_A();\n  while(a[s[p]]==10){\n    int t=p++;\n    if(b[s[t]]=='+')res+=g_A();\n    if(b[s[t]]=='-')res-=g_A();\n    if(b[s[t]]=='*')res*=g_A();\n    if(b[s[t]]=='/'){\n      int tt=g_A();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nint bns9(){\n  int res=bns10();\n  while(a[s[p]]==9){\n    int t=p++;\n    if(b[s[t]]=='+')res+=bns10();\n    if(b[s[t]]=='-')res-=bns10();\n    if(b[s[t]]=='*')res*=bns10();\n    if(b[s[t]]=='/'){\n      int tt=bns10();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nint bns8(){\n  int res=bns9();\n  while(a[s[p]]==8){\n    int t=p++;\n    if(b[s[t]]=='+')res+=bns9();\n    if(b[s[t]]=='-')res-=bns9();\n    if(b[s[t]]=='*')res*=bns9();\n    if(b[s[t]]=='/'){\n      int tt=bns9();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nint bns7(){\n  int res=bns8();\n  while(a[s[p]]==7){\n    int t=p++;\n    if(b[s[t]]=='+')res+=bns8();\n    if(b[s[t]]=='-')res-=bns8();\n    if(b[s[t]]=='*')res*=bns8();\n    if(b[s[t]]=='/'){\n      int tt=bns8();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nint bns6(){\n  int res=bns7();\n  while(a[s[p]]==6){\n    int t=p++;\n    if(b[s[t]]=='+')res+=bns7();\n    if(b[s[t]]=='-')res-=bns7();\n    if(b[s[t]]=='*')res*=bns7();\n    if(b[s[t]]=='/'){\n      int tt=bns7();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nint bns5(){\n  int res=bns6();\n  while(a[s[p]]==5){\n    int t=p++;\n    if(b[s[t]]=='+')res+=bns6();\n    if(b[s[t]]=='-')res-=bns6();\n    if(b[s[t]]=='*')res*=bns6();\n    if(b[s[t]]=='/'){\n      int tt=bns6();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nint bns4(){\n  int res=bns5();\n  while(a[s[p]]==4){\n    int t=p++;\n    if(b[s[t]]=='+')res+=bns5();\n    if(b[s[t]]=='-')res-=bns5();\n    if(b[s[t]]=='*')res*=bns5();\n    if(b[s[t]]=='/'){\n      int tt=bns5();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nint bns3(){\n  int res=bns4();\n  while(a[s[p]]==3){\n    int t=p++;\n    if(b[s[t]]=='+')res+=bns4();\n    if(b[s[t]]=='-')res-=bns4();\n    if(b[s[t]]=='*')res*=bns4();\n    if(b[s[t]]=='/'){\n      int tt=bns4();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nint bns2(){\n  int res=bns3();\n  while(a[s[p]]==2){\n    int t=p++;\n    if(b[s[t]]=='+')res+=bns3();\n    if(b[s[t]]=='-')res-=bns3();\n    if(b[s[t]]=='*')res*=bns3();\n    if(b[s[t]]=='/'){\n      int tt=bns3();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nint bns1(){\n  int res=bns2();\n  while(a[s[p]]==1){\n    int t=p++;\n    if(b[s[t]]=='+')res+=bns2();\n    if(b[s[t]]=='-')res-=bns2();\n    if(b[s[t]]=='*')res*=bns2();\n    if(b[s[t]]=='/'){\n      int tt=bns2();\n      if(!tt)f++,tt=1;\n      else res/=tt;\n    }\n  }\n  return res;\n}\nmain(){\n  while(cin>>s,s!=\"#\"){\n    memset(a,0,sizeof(a));\n    memset(b,0,sizeof(b));\n    int cnt=0,lx[10];\n    set<int>se;\n    r(i,s.size())if(!isdigit(s[i])&&s[i]!='('&&s[i]!=')')b[cnt+'a']=s[i],s[i]='a'+cnt++;\n    r(i,cnt)lx[i]=i;\n    do{\n      f=p=0;\n      r(i,cnt)a[lx[i]+'a']=i+1;\n      int ppp=bns1();\n      if(!f)se.insert(ppp);\n    }while(next_permutation(lx,lx+cnt));\n    cout<<se.size()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <stack>\n#include <exception>\n#include <algorithm>\n#include <utility>\n#include <cctype>\n#include <cmath>\n\nusing namespace std;\ntypedef pair<string, int> psi;\n\nstring OPERATORS[10];\nint BRACE_PRIORITY = 10;\n\nstring infix2rpn(const string &expression){\n\tstringstream ss(expression);\n\tvector<psi> tokens;\n\twhile(ss.tellg() < ss.str().size()){\n\t\tchar c = ss.peek();\n\t\tif(isdigit(c)){\n\t\t\tstring s;\n\t\t\twhile(isdigit(ss.peek())){ s += ss.get(); }\n\t\t\ttokens.push_back(psi(s, -1));\n\t\t}else if(c == '('){\n\t\t\tss.get();\n\t\t\tint depth = 0;\n\t\t\tstring sub;\n\t\t\twhile(depth >= 0){\n\t\t\t\tc = ss.get();\n\t\t\t\tif(c == ')' && depth == 0){ break; }\n\t\t\t\tsub += c;\n\t\t\t\tif(c == '('){ ++depth; }\n\t\t\t\tif(c == ')'){ --depth; }\n\t\t\t}\n\t\t\ttokens.push_back(psi(infix2rpn(sub), -1));\n\t\t}else{\n\t\t\tss.get();\n\t\t\tint priority = 0;\n\t\t\tfor(; priority < BRACE_PRIORITY; ++priority){\n\t\t\t\tif(OPERATORS[priority].find_first_of(c) != string::npos){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttokens.push_back(psi(string(1, c), priority));\n\t\t}\n\t}\n\twhile(tokens.size() > 1){\n\t\tint target = 0;\n\t\tfor(int i = 1; i < tokens.size(); ++i){\n\t\t\tif(tokens[target].second < tokens[i].second){ target = i; }\n\t\t}\n\t\ttokens[target - 1].first =\n\t\t\ttokens[target - 1].first + \" \" +\n\t\t\ttokens[target + 1].first + \" \" +\n\t\t\ttokens[target].first;\n\t\ttokens[target - 1].second = -1;\n\t\ttokens.erase(tokens.begin() + target, tokens.begin() + target + 2);\n\t}\n\treturn tokens[0].first;\n}\n\nint solve(const string &expression){\n\tstack<int> stk;\n\tstringstream ss(expression);\n\twhile(ss.tellg() < ss.str().size()){\n\t\twhile(ss.peek() == ' '){ ss.get(); }\n\t\tif(isdigit(ss.peek())){\n\t\t\tint value;\n\t\t\tss >> value;\n\t\t\tstk.push(value);\n\t\t}else{\n\t\t\tstring op;\n\t\t\tss >> op;\n\t\t\tint left, right;\n\t\t\tright = stk.top(); stk.pop();\n\t\t\tleft = stk.top(); stk.pop();\n\t\t\tif('A' <= op[0] && op[0] < 'A' + 13){\n\t\t\t\tstk.push(left + right);\n\t\t\t}else if('A' + 13 <= op[0] && op[0] < 'A' + 26){\n\t\t\t\tstk.push(left - right);\n\t\t\t}else if('a' <= op[0] && op[0] < 'a' + 13){\n\t\t\t\tstk.push(left * right);\n\t\t\t}else if('a' + 13 <= op[0] && op[0] < 'a' + 26){\n\t\t\t\tif(right == 0){ throw exception(); }\n\t\t\t\tstk.push(abs(left) / abs(right) * ((left < 0) ^ (right < 0) ? -1 : 1));\n\t\t\t}\n\t\t}\n\t}\n\treturn stk.top();\n}\n\nint main(){\n\twhile(true){\n\t\tstring expression;\n\t\tcin >> expression;\n\t\tif(expression == \"#\"){ break; }\n\t\tvector<int> operators;\n\t\tfor(int i = 0; i < expression.size(); ++i){\n\t\t\tif(!isdigit(expression[i]) && expression[i] != '(' && expression[i] != ')'){\n\t\t\t\tif(expression[i] == '+'){\n\t\t\t\t\texpression[i] = 'A';\n\t\t\t\t}else if(expression[i] == '-'){\n\t\t\t\t\texpression[i] = 'A' + 13;\n\t\t\t\t}else if(expression[i] == '*'){\n\t\t\t\t\texpression[i] = 'a';\n\t\t\t\t}else if(expression[i] == '/'){\n\t\t\t\t\texpression[i] = 'a' + 13;\n\t\t\t\t}\n\t\t\t\toperators.push_back(i);\n\t\t\t}\n\t\t}\n\t\tBRACE_PRIORITY = operators.size();\n\t\tset<int> answers;\n\t\tdo {\n\t\t\tfor(int i = 0; i < operators.size(); ++i){\n\t\t\t\tchar &op = expression[operators[i]];\n\t\t\t\tif('A' <= op && op < 'A' + 13){\n\t\t\t\t\top = 'A' + i;\n\t\t\t\t}else if('A' + 13 <= op && op < 'A' + 26){\n\t\t\t\t\top = 'A' + 13 + i;\n\t\t\t\t}else if('a' <= op && op < 'a' + 13){\n\t\t\t\t\top = 'a' + i;\n\t\t\t\t}else if('a' + 13 <= op && op < 'a' + 26){\n\t\t\t\t\top = 'a' + 13 + i;\n\t\t\t\t}\n\t\t\t\tOPERATORS[i] = string(1, op);\n\t\t\t}\n\t\t\tstring rpn = infix2rpn(expression);\n\t\t\ttry {\n\t\t\t\tint answer = solve(rpn);\n\t\t\t\tanswers.insert(answer);\n\t\t\t}catch(exception){\n\t\t\t}\n\t\t} while(next_permutation(operators.begin(), operators.end()));\n\t\tcout << answers.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<char,char> cc;\nvector<cc> opr;\nint ep;\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n  bool error;\n \n  Parsing(string s){\n    parse = s;\n    pos = 0;\n    error = false;\n  }\n  int fact(){\n    if( error ) return 0;\n    if(parse[pos] == '('){\n      pos++;\n      int p = expression();\n      pos++;\n      return p;\n    }else{\n      int p=0;\n      while('0' <= parse[pos] && parse[pos] <= '9'){\n        p *= 10;\n        p += parse[pos]-'0';\n        pos++;\n      }\n      return p;\n    }\n  }\n \n  int term(int depth){\n\n    if( error ) return 0;\n    int p; \n    if( depth >= ep ) p = fact();\n    else              p = term(depth+1);\n\n    while( depth < ep &&  parse[pos] == opr[depth].second ){\n\n      char c = opr[depth].first;\n      if( c == '+' )      { pos++; p += term(depth+1); }\n      else if( c == '-' ) { pos++; p -= term(depth+1); } \n      else if( c == '*' ) { pos++; p *= term(depth+1); } \n      else if( c == '/' ) {\n        pos++; \n        int denom = term(depth+1); \n        if( denom == 0 ) error = true;\n        else p /= denom;\n      } \n    }\n    return p;\n  }\n \n  int expression(){\n    if( error ) return 0;\n    int p = term(1);\n    while(!opr.empty() && parse[pos] == opr[0].second ){\n      char c = opr[0].first;\n      if( c == '+' )      { pos++; p += term(1); }\n      else if( c == '-' ) { pos++; p -= term(1); } \n      else if( c == '*' ) { pos++; p *= term(1); } \n      else if( c == '/' ) {\n        pos++; \n        int denom = term(1); \n        if( denom == 0 ) error = true;\n        else p /= denom;\n      } \n    }\n    return p;\n  } \n \n};\n\nstring s;\nint main(){\n  while( getline(cin,s) ){\n    if( s == \"#\" ) break;\n    int cnt = 0;\n    rep(i,s.size()) if( s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/' ) {\n      opr.push_back(cc(s[i],(char)('A'+cnt)));\n      s[i] = (char)('A'+cnt);\n      cnt++;\n    }\n    ep = opr.size();\n    sort(opr.begin(),opr.end());\n    unordered_set<int> ans;\n    do{\n      Parsing par(s);\n      int tmp = par.expression();\n      if( par.error ) continue;\n      ans.insert(tmp);\n    }while(next_permutation(opr.begin(),opr.end()));\n    cout << ans.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar S[211];\n\nset<int> solve(int l,int r);\n\nvoid view( set<int> b ){\n  cout << \"view\" << endl;\n  for( set<int>::iterator it = b.begin(); it != b.end(); it++)\n    cout << *it << \" \";\n  cout << endl;\n}\n\nint check(int l,int r){\n  int k = 0;\n  for(int i=l;i<=r;i++){\n    if( !isdigit(S[i]) ) return -1;\n    k*=10;\n    k+=(S[i]-'0');\n  }\n  return k;\n}\n\nset<int> calc(set<int> a,set<int> b,char c){\n  set<int> ret;\n  for( set<int>::iterator it = a.begin(); it != a.end(); it++){\n    for( set<int>::iterator jt = b.begin(); jt != b.end(); jt++){\n      if( c == '+' ){\n\tret.insert( *it + *jt );\n      } else if( c== '-' ){\n\tret.insert( *it - *jt );\n      } else if( c== '*' ){\n\tret.insert( (*it) * (*jt) );\n      } else {\n\tif( *jt == 0 ) continue;\n\tret.insert( *it / *jt );\n      }\n    }\n  }\n  return ret;\n}\n\nset<int> check2(int l,int r){\n  int cnt = 0;\n  set<int> a,b;\n  int nc = -1;\n  for(int i=l;i<=r;i++){\n    if( S[i] == '(' ){\n      cnt++;\n    } else if (S[i] == ')' ){\n      cnt--;\n    }\n    else if( cnt == 0  && ( S[i] == '+' || S[i] == '-' || S[i] == '*' || S[i] == '/' )){\n      a = calc( solve(l,i-1), solve(i+1,r), S[i]);\n      nc = i;\n      break;\n    }\n  }\n  cnt = 0;  \n  for(int i=r;i>=l;i--){\n    if( S[i] == ')' ){\n      cnt++;\n    } else if (S[i] == '(' ){\n      cnt--;\n    }\n    else if( cnt == 0  && ( S[i] == '+' || S[i] == '-' || S[i] == '*' || S[i] == '/' )){\n      if( nc == i ) break;\n      b = calc( solve(l,i-1), solve(i+1,r), S[i]);\n      break;\n    }\n  }\n  //  cout << l << \" \"<< r << endl;\n  //view(a);\n  if( b.empty() ) return a;\n  // view(b);\n  for( set<int>::iterator it = b.begin(); it != b.end(); it++)\n    a.insert( *it );\n\n\n  return a;\n}\n\nbool check3(int l,int r){\n  int cnt = 0;\n  if( S[l] != '(' ) return false;\n  for(int i=l;i<=r;i++){\n    if( S[i] == '(' ) cnt++;\n    else if( S[i] == ')' ){\n      cnt--;\n      if( cnt == 0 && i == r ) return true;       \n      return false;\n    }\n  }\n  return false;\n}\n\nset<int> solve(int l,int r){\n  if( check3(l,r) )\n    return solve(l+1,r-1);\n  \n  int tmp = check(l,r);\n  if( tmp>-1 ){\n    //cout << l << \" \"<< r << \" \" << tmp << endl;\n    set<int> s; s.insert(tmp);\n    return s;\n  }\n  \n  return check2(l,r);\n}\n\n\nint main(){\n  while( cin >> S ){\n    if( S[0] == '#' ) break;\n    set<int> res = solve(0,strlen(S)-1);\n    cout << res.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <complex>\n#include <queue>\n#include <stack>\n#include <string>\n#include <cmath>\n#include <bitset>\n\n#define rep(i,a) for(int i = 0;i < (a); i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nint t, n;\nint dx[] = {0, 1, 1, 0, -1, -1};\nint dy[] = {1, 1, 0, -1, -1, 0};\nstruct node{\n    int x;\n    int y;\n    int step;\n};\nbool inrange(int x, int y){\n    return x >= 0 && y >= 0 && x <= 200 && y <= 200;\n}\nbool jam[201][201];\nint main(){\n    while(cin >> t >> n, t||n){\n        memset(jam, 0, sizeof(jam));\n        rep(i, n){\n            int bx, by;\n            cin >> bx >> by;\n            bx += 100;\n            by += 100;\n            jam[bx][by] = true;\n        }\n        int sx, sy;\n        cin >> sx >> sy;\n        sx += 100;\n        sy += 100;\n        queue<node> q;\n        set<pair<int, int> > st;\n        q.push((node){sx, sy, 0});\n        while(!q.empty()){\n            int x = q.front().x;\n            int y = q.front().y;\n            int step = q.front().step;\n            q.pop();\n            //      cout << x << \" \" << y << \" \" << step << endl;\n            if(st.find(mp(x, y)) != st.end()) continue;\n            if(step >= t+1) break;\n            st.insert(mp(x, y));\n            rep(i, 6){\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if(inrange(nx, ny) && !jam[nx][ny]){\n                    q.push((node){nx, ny, step+1});\n                }\n            }\n            \n        }\n        cout << st.size() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nchar S[211];\n \nset<ll> solve(int l,int r);\n \nvoid view( set<ll> b ){\n  cout << \"view\" << endl;\n  for( set<ll>::iterator it = b.begin(); it != b.end(); it++)\n    cout << *it << \" \";\n  cout << endl;\n}\n \nint check(int l,int r){\n  ll k = 0;\n  for(int i=l;i<=r;i++){\n    if( !isdigit(S[i]) ) return -1;\n    k*=10LL;\n    k+=(ll)(S[i]-'0');\n  }\n  return k;\n}\n \nset<ll> calc(set<ll> a,set<ll> b,char c){\n  set<ll> ret;\n  for( set<ll>::iterator it = a.begin(); it != a.end(); it++){\n    for( set<ll>::iterator jt = b.begin(); jt != b.end(); jt++){\n      if( c == '+' ){\n    ret.insert( *it + *jt );\n      } else if( c== '-' ){\n    ret.insert( *it - *jt );\n      } else if( c== '*' ){\n    ret.insert( (*it) * (*jt) );\n      } else {\n    if( *jt == 0 ) continue;\n    ret.insert( *it / *jt );\n      }\n    }\n  }\n  return ret;\n}\n \nset<ll> check2(int l,int r){\n  int cnt = 0;\n  set<ll> a,b;\n  for(int i=l;i<=r;i++){\n    if( S[i] == '(' ){\n      cnt++;\n    } else if (S[i] == ')' ){\n      cnt--;\n    }\n    else if( cnt == 0  && ( S[i] == '+' || S[i] == '-' || S[i] == '*' || S[i] == '/' )){\n\n      b = calc( solve(l,i-1), solve(i+1,r), S[i]);\n      for( set<ll>::iterator it = b.begin(); it != b.end(); it++)\n\ta.insert( *it );\n\n    }\n  }\n  //  cout << l << \" \"<< r << endl;\n  // view(a);\n  \n  return a;\n}\n \nbool check3(int l,int r){\n  int cnt = 0;\n  if( S[l] != '(' ) return false;\n  for(int i=l;i<=r;i++){\n    if( S[i] == '(' ) cnt++;\n    else if( S[i] == ')' ){\n      cnt--;\n      if( cnt == 0 && i == r ) return true;      \n      else if( cnt == 0 ) \n\treturn false;\n    }\n  }\n  return false;\n}\n \nset<ll> solve(int l,int r){\n  if( check3(l,r) ){\n    //cout << l << \" \"<< r << \" \" << \" in check3\" << endl;\n    return solve(l+1,r-1);\n  }   \n  int tmp = check(l,r);\n  if( tmp>-1 ){\n    //cout << l << \" \"<< r << \" \" << tmp << endl;\n    set<ll> s; s.insert(tmp);\n    return s;\n  }\n   \n  return check2(l,r);\n}\n \n \nint main(){\n  while( cin >> S ){\n    if( S[0] == '#' ) break;\n    \n    set<ll> res = solve(0,strlen(S)-1);\n    cout << res.size() << endl;\n    // view(res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\nvector<char> op;\nvector<int> num;\nconst int INF=1e+9+1;\nint paren[20];\nint pri[20];\nint perm[20];\n\nint dfs(int s,int t){\n  int i=distance(pri,min_element(pri+s,pri+t));\n  int a=i-s==0?num[s]:dfs(s,i);\n  int b=t-i==1?num[t]:dfs(i+1,t);\n  if(op[i]=='/'){\n    if(b==0)throw 0;\n    return a/b;\n  }\n  if(op[i]=='+')return a+b;\n  if(op[i]=='-')return a-b;\n  return a*b;\n}\n\nint main(){ _;\n  string str;\n  while(cin>>str,str[0]!='#'){\n    op.clear();\n    num.clear();\n    fill_n(paren,20,0);\n    int prn=0;\n    for(char c:str){\n      if(c=='+'||c=='-'||c=='*'||c=='/'){\n\tparen[op.size()]=prn;\n\top.push_back(c);\n      }else if(c=='('){\n\tprn+=100;\n      }else if(c==')'){\n\tprn-=100;\n      }else{\n\tif(num.size()==op.size())num.push_back(0);\n\tnum[op.size()]=num[op.size()]*10+(c-'0');\n      }\n    }\n    int n=op.size();\n    set<int>result;\n    REP(i,n)perm[i]=i;\n    do{\n      REP(i,n)pri[i]=perm[i]+paren[i];\n      try{\n\tresult.insert(dfs(0,n));\n      }catch(int j){}\n    }while(next_permutation(perm,perm+n));\n    cout<<result.size()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstring>\nusing namespace std;\nstruct C{\n  char s;\n  set<int> p;\n};\nset<int> fj(list<C> a){\n  int i;\n  set<int> mx;\n  int sz=a.size()/2;\n  if(sz){\n    for(i=0;i<sz;++i){\n      list<C> b(a);\n      list<C>::iterator it=b.begin(),jt,kt;\n      advance(it,i*2);\n      jt=it;\n      ++jt;\n      kt=jt;\n      ++kt;\n      C c;\n      c.s='\\0';\n      set<int>::iterator lt,mt;\n      if(0){\n      }else if((*jt).s=='+'){\n\tfor(lt=(*it).p.begin();lt!=(*it).p.end();++lt)\n\t  for(mt=(*kt).p.begin();mt!=(*kt).p.end();++mt)\n\t    c.p.insert(*lt+*mt);\n      }else if((*jt).s=='-'){\n\tfor(lt=(*it).p.begin();lt!=(*it).p.end();++lt)\n\t  for(mt=(*kt).p.begin();mt!=(*kt).p.end();++mt)\n\t    c.p.insert(*lt-*mt);\n      }else if((*jt).s=='*'){\n\tfor(lt=(*it).p.begin();lt!=(*it).p.end();++lt)\n\t  for(mt=(*kt).p.begin();mt!=(*kt).p.end();++mt)\n\t    c.p.insert(*lt**mt);\n      }else if((*jt).s=='/'){\n\tfor(lt=(*it).p.begin();lt!=(*it).p.end();++lt){\n\t  for(mt=(*kt).p.begin();mt!=(*kt).p.end();++mt){\n\t    if(*mt)\n\t      c.p.insert((*lt)/(*mt));\n\t  }\n\t}\n      }\n      ++kt;\n      b.insert(b.erase(it,kt),c);\n      set<int> sm=fj(b);\n      for(lt=sm.begin();lt!=sm.end();++lt)\n\tmx.insert(*lt);\n    }\n  }else{\n    return (*a.begin()).p;\n  }\n  return mx;\n}\nset<int> fi(list<C> a){\n  int i;  \n  list<C>::iterator it,jt;\n  for(it=a.begin();it!=a.end();++it){\n    if((*it).s=='('){\n      jt=it;\n      for(i=1;i;){\n\t++jt;\n\tif(0){\n\t}else if((*jt).s=='('){\n\t  ++i;\n\t}else if((*jt).s==')'){\n\t  --i;\n\t}\n      }\n      ++it;\n      list<C> b(it,jt);\n      C c;\n      c.s='\\0';\n      c.p=fi(b);\n      --it;\n      ++jt;\n      it=a.insert(a.erase(it,jt),c);\n    }\n  }\n  return fj(a);\n}\nint main(){\n  int i,j;\n  string s;\n  while(cin>>s,s[0]!='#'){\n    int ln=s.length();\n    list<C> a;\n    for(i=0;i<ln;){\n      if('0'<=s[i]&&s[i]<='9'){\n\tfor(j=i+1;j<ln&&'0'<=s[j]&&s[j]<='9';++j);\n\tC c;\n\tc.s='\\0';\n\tc.p.insert(atoi(s.substr(i,j-i).c_str()));\n\ta.push_back(c);\n\ti=j;\n      }else{\n\tC c;\n\tc.s=s[i];\n\ta.push_back(c);\n\t++i;\n      }\n    }\n    cout<<fi(a).size()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nset<int> solve(string exp) {\n    vector<int> idx;\n    map<int, int> rev;\n    for (int i = 0, c = 0; i < exp.size(); i++) {\n        if (exp[i] == '(')\n            c++;\n        if (exp[i] == ')')\n            c--;\n        if (c == 0 && (exp[i]=='*' || exp[i]=='/' || exp[i]=='+' || exp[i]=='-')) {\n            rev[i] = idx.size();\n            idx.push_back(i);\n        }\n    }\n\n    if(idx.size() == 0) {\n        if (exp[0] == '(') return solve(string(exp.begin()+1, exp.end()-1));\n        stringstream ss;\n        ss << exp;\n        int num;\n        ss >> num;\n        set<int> ans;\n        ans.insert(num);\n        return ans;\n    }\n\n    vector<set<int> > res(idx.size() + 1);\n    for (int i = 0; i < idx.size() + 1; i++) {\n        int l = i == 0 ? 0 : idx[i - 1] + 1;\n        int r = i == idx.size() ? exp.size() : idx[i];\n        res[i] = solve(string(exp.begin() + l, exp.begin() + r));\n    }\n\n\n    set<int> ans;\n    do {\n        vector<set<int> > ret = res;\n        vector<int> ridx(idx.size());\n        for (int i = 0; i < idx.size(); i++) {\n            ridx[rev[idx[i]]] = i;\n        }\n        for (int i = 0; i < idx.size(); i++) {\n            int l = -1;\n            int r = rev[idx[i]] + 1;\n            set<int> num;\n            for (int j = rev[idx[i]]-1, ml = -1; j >= 0 && i > ridx[j]; j--)\n                if (ml < ridx[j]) {ml = ridx[j], l = j;}\n            if (l == -1) l = rev[idx[i]];\n            for (int j = r, mr = -1; j < idx.size() && i > ridx[j]; j++)\n                if (mr < ridx[j]) {mr = ridx[j], r = j;}\n             for (auto lhs : ret[l]) {\n                for (auto rhs : ret[r]) {\n                    if (exp[idx[i]] == '+')\n                        num.insert(lhs + rhs);\n                    if (exp[idx[i]] == '-')\n                        num.insert(lhs - rhs);\n                    if (exp[idx[i]] == '*')\n                        num.insert(lhs * rhs);\n                    if (exp[idx[i]] == '/') {\n                        if (rhs == 0)\n                            continue;\n                        num.insert(lhs / rhs);\n                    }\n                }\n            }\n\n            ret[rev[idx[i]]] = num;\n        }\n\n        for (auto i : ret[rev[idx[idx.size()-1]]]) ans.insert(i);\n    } while (next_permutation(idx.begin(), idx.end()));\n\n    return ans;\n}\n\nint main() {\n    string str;\n    while (cin >> str, str != \"#\")\n        cout << solve(str).size() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const set<T>& a){\n\tos<<'{';\n\tforeach(i,a) os<<(i!=begin(a)?\" \":\"\")<<*i;\n\treturn os<<'}';\n}\n\nset<int> calc(const set<int>& a,const set<int>& b,char op)\n{\n\tset<int> res;\n\tfor(int x:a) for(int y:b){\n\t\tif(op=='*') res.insert(x*y);\n\t\tif(op=='+') res.insert(x+y);\n\t\tif(op=='-') res.insert(x-y);\n\t\tif(op=='/' && y) res.insert(x/y);\n\t}\n\treturn res;\n}\n\nset<int> expr(const string& s,int l,int r)\n{\n\tvector<set<int>> vals;\n\tstring ops;\n\tfor(int i=l;i<r;i++){\n\t\tif(s[i]=='('){\n\t\t\tint cnt=0,j=i++;\n\t\t\tfor(;j<r;j++){\n\t\t\t\tif(s[j]=='(') cnt++;\n\t\t\t\tif(s[j]==')') cnt--;\n\t\t\t\tif(cnt==0) break;\n\t\t\t}\n\t\t\tvals.push_back(expr(s,i,j));\n\t\t\ti=j;\n\t\t}\n\t\telse if(strchr(\"*+-/\",s[i]))\n\t\t\tops.push_back(s[i]);\n\t\telse{\n\t\t\tint x=0;\n\t\t\tfor(;i<r && isdigit(s[i]);i++)\n\t\t\t\tx=x*10+s[i]-'0';\n\t\t\tvals.push_back(set<int>({x}));\n\t\t\ti--;\n\t\t}\n\t}\n\tint n=vals.size();\n\tvector<vector<set<int>>> dp(n,vector<set<int>>(n));\n\trep(i,n) dp[i][i]=vals[i];\n\tper(i,n) repi(j,i+1,n) repi(k,i,j){\n\t\tset<int> t=calc(dp[i][k],dp[k+1][j],ops[k]);\n\t\tdp[i][j].insert(all(t));\n\t}\n\treturn dp[0][n-1];\n}\n\nint main()\n{\n\tfor(string s;getline(cin,s),s!=\"#\";)\n\t\tcout<<expr(s,0,s.size()).size()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef string::const_iterator state;\n\nint expression(state&);\n\nint number(state &begin){\n    int res=0;\n    while(isdigit(*begin)){\n        res*=10;\n        res+=*begin-'0';\n        ++begin;\n    }\n    return res;\n}\n\nint factor(state &begin){\n    if(*begin=='(' or *begin=='['){\n        begin++;\n        const int res=expression(begin);\n        begin++;\n        return res;\n    }else return number(begin);\n}\n\nint expression(state &begin){\n    int res=factor(begin);\n    if(res==inf) return inf;\n    while(true){\n        if(*begin=='+'){\n            ++begin;\n            res+=expression(begin);\n        }else if(*begin=='-'){\n            ++begin;\n            res-=expression(begin);\n        }else if(*begin=='*'){\n            ++begin;\n            res*=expression(begin);\n        }else if(*begin=='/'){\n            ++begin;\n            const int tmp=expression(begin);\n            if(tmp==0) return inf;\n            res/=tmp;\n        }else break;\n    }\n    return res;\n}\n\nvoid solve(){\n    while(true){\n        string str;\n        cin >> str;\n        if(str==\"#\") return;\n\n        set<int> res;\n        function<void(const string,const int,const stack<char>)> rec=[&](const string s,const int idx,const stack<char> stk){\n            if(idx==s.size()){\n                if(!stk.size()){\n                    string s_=s;\n                    dump(s_);\n                    state begin=s_.begin();\n                    const int res_=expression(begin);\n                    if(res_!=inf) res.insert(res_);\n                    dump(res_);\n                }\n                return;\n            }\n            if(s[idx]=='('){\n                auto stk_=stk;\n                stk_.push('(');\n                rec(s,idx+1,stk_);\n                return;\n            }\n            if(s[idx]==')'){\n                if(!stk.size() or stk.top()!='(') return;\n                auto stk_=stk;\n                stk_.pop();\n                rec(s,idx+1,stk_);\n                return;\n            }\n            if(stk.size()<10 and isdigit(s[idx]) and (!idx or !isdigit(s[idx-1]))){\n                auto stk_=stk;\n                stk_.push('[');\n                auto s_=s;\n                s_.insert(idx,\"[\");\n                rec(s_,idx,stk_);\n            }\n            if(idx+1==s.size() or (isdigit(s[idx]) and !isdigit(s[idx+1]))){\n                if(!stk.size() or stk.top()!='['){\n                    rec(s,idx+1,stk);\n                    return;\n                }\n                bool ok=false;\n                for(int i=idx; s[i]!='[' ; --i){\n                    if(!isdigit(s[i])){\n                        ok=true;\n                        break;\n                    }\n                }\n                if(!ok){\n                    rec(s,idx+1,stk);\n                    return;\n                }\n                auto stk_=stk;\n                auto s_=s;\n                stk_.pop();\n                if(idx+1==s.size()) s_+=\"]\";\n                else s_.insert(idx+1,\"]\");\n                rec(s_,idx+1,stk_);\n            }\n            rec(s,idx+1,stk);\n        };\n        rec(str,0,stack<char>());\n        cout << res.size() << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <cctype>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nstring S;\n\nbool is_op(char c)\n{\n    return (c == '+' || c == '-' || c == '*' || c == '/');\n}\n\nbool is_num(int L, int R)\n{\n    for (int i = L; i <= R; i++) {\n        if (!isdigit(S[i])) return 0;\n    }\n    return 1;\n}\n\nint num(int L, int R)\n{\n    int res = 0;\n    for (int i = L; i <= R; i++) {\n        res *= 10;\n        res += (S[i] - '0');\n    }\n    return res;\n}\n\nint next(int L, int R)\n{\n    int p = 0;\n    for (int i = L; i <= R; i++) {\n        if (S[i] == '(') p++;\n        if (S[i] == ')') p--;\n        if (p == 0) return i;\n    }\n    return -1;\n}\n\nset<int> expr(int L, int R)\n{\n    set<int> res;\n    \n    if (is_num(L, R)) return (res = {num(L, R)});\n\n    if (S[L] == '(' && S[R] == ')') {\n        return (res = expr(L + 1, R - 1));\n    }\n    \n    for (int i = L + 1; i <= R - 1; i++) {\n        char c = S[i];\n        \n        if (!is_op(c)) continue;\n        \n        auto l = expr(L, i - 1);\n        auto r = expr(i + 1, R);\n        \n        for (int lv : l) {\n            for (int rv : r) {\n                switch (c) {\n                    case '+':\n                        res.insert(lv + rv);\n                        break;\n                    case '-':\n                        res.insert(lv - rv);\n                        break;\n                    case '*':\n                        res.insert(lv * rv);\n                        break;\n                    case '/':\n                        if (rv != 0) {\n                            res.insert(lv / rv);                            \n                        }                            \n                        break;\n                }\n            }\n        }\n    } \n    return res;\n}\n\nvoid solve()\n{\n    int N = S.size();\n    cout << expr(0, N - 1).size() << endl;\n}\n\nint main()\n{\n    while (cin >> S, S != \"#\") {\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing vp = vector<Pii>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nbool isOperator(char c) {\n    return c == '/' || c == '*' || c == '+' || c == '-';\n}\n\nvector<vector<bool>> trclOp(string s) {\n    vi op_pos;\n    rep(i, s.size()) {\n        if (isOperator(s[i])) {\n            op_pos.emplace_back(i);\n        }\n    }\n    int num_op = op_pos.size();\n\n    vp ranges;\n    ranges.emplace_back(-inf, inf);\n    rep(i, s.size()) {\n        if (s[i] == '(') {\n            int depth = 1;\n            int j = i + 1;\n            while (depth > 0) {\n                if (s[j] == '(') depth++;\n                else if (s[j] == ')') depth--;\n                j++;\n            }\n            ranges.emplace_back(i, j);\n        }\n    }\n    int num_range = ranges.size();\n    sort(all(ranges));\n\n    vi op_range(num_op);\n    rep(i, num_range) {\n        rep(j, num_op) {\n            if (ranges[i].first <= op_pos[j] && op_pos[j] < ranges[i].second) {\n                op_range[j] = i;\n            }\n        }\n    }\n\n    vector<vector<bool>> trcl_range(num_range, vector<bool>(num_range));\n    rep(i, num_range) {\n        rep(j, num_range) {\n            if (ranges[i].first < ranges[j].first && ranges[j].second < ranges[i].second) {\n                trcl_range[i][j] = true;\n            }\n        }\n    }\n\n    // printVV(trcl_range);\n\n    vector<vector<bool>> trcl_op(num_op, vector<bool>(num_op));\n    rep(i, num_op) {\n        rep(j, num_op) {\n            trcl_op[j][i] = trcl_range[op_range[i]][op_range[j]];\n        }\n    }\n\n    return trcl_op;\n}\n\nbool valid(const vi& perm, const vector<vector<bool>>& trcl_op) {\n    rep(i, perm.size()) {\n        rep2(j, i + 1, perm.size()) {\n            if (trcl_op[perm[j]][perm[i]]) return false;\n        }\n    }\n    return true;\n}\n\nint op(int a, int b, char c) {\n    if (a == inf || b == inf) return inf;\n    if (c == '+') return a + b;\n    if (c == '-') return a - b;\n    if (c == '*') return a * b;\n    if (c == '/') {\n        if (b == 0) return inf;\n        int x = ceil(1. * a / b);\n        int y = floor(1. * a / b);\n        if (abs(x) < abs(y)) return x;\n        else return y;\n    }\n}\n\nint eval(vi numbers, vector<char> operators, vi perm) {\n    while(!perm.empty()) {\n        int p = perm[0];\n        int a = numbers[p];\n        int b = numbers[p + 1];\n        int x = op(a, b, operators[p]);\n        if (x == inf) return inf;\n        numbers.erase(numbers.begin() + p, numbers.begin() + p + 2);\n        numbers.insert(numbers.begin() + p, x);\n        operators.erase(operators.begin() + p);\n        perm.erase(perm.begin());\n        for (auto& q : perm) {\n            if (q > p) q--;\n        }\n    }\n    return numbers[0];\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    string s;\n    int testcase = 0;\n    while (cin >> s, s != \"#\") {\n        // output(\"testcase = \", testcase++);\n        auto trcl_op = trclOp(s);\n        // printVV(trcl_op);\n\n        // parse\n        vi numbers;\n        vector<char> operators;\n        {\n            string t;\n            rep(i, s.size()) {\n                if (isdigit(s[i])) {\n                    t += s[i];\n                }\n                else {\n                    if (t != \"\") {\n                        numbers.emplace_back(stoi(t));\n                        t = \"\";\n                    }\n                    if (isOperator(s[i])) {\n                        operators.emplace_back(s[i]);\n                    }\n                }\n            }\n            if (t != \"\") {\n                numbers.emplace_back(stoi(t));\n            }\n        }\n\n        // printV(numbers);\n        // printV(operators);\n\n        if (operators.empty()) {\n            cout << 1 << endl;\n            continue;\n        }\n\n        vi perm(operators.size());\n        rep(i, operators.size()) perm[i] = i;\n        sort(all(perm));\n        set<int> st;\n        do {\n            if (!valid(perm, trcl_op)) continue;\n            // printV(perm);\n            int x = eval(numbers, operators, perm);\n            if (x != inf) st.insert(x);\n        } while (next_permutation(all(perm)));\n\n        cout << st.size() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nstring s;\ntypedef long long ll;\ntypedef string::const_iterator Iter;\ntypedef set<ll>::const_iterator SIter;\n\nIter skip_par(Iter it) {\n  it++;\n  for(int cnt=1; cnt > 0; it++) cnt += (*it == '(') ? 1 : ((*it == ')') ? -1 : 0);\n  return it;\n}\n\nbool number(Iter st, Iter ed, ll& ret) {\n  ret = 0;\n  for(Iter curr=st; curr!=ed; curr++) {\n    if(isdigit(*curr)) {\n      ret *= 10;\n      ret += (*curr)-'0';\n    }\n    else { return false; }\n  }\n  return true;\n}\n\nset<char> opes={'+','-','*','/'};\n\nset<ll> exp(Iter st, Iter ed) {\n  if(*st == '(' && *(ed-1) == ')') { return exp(st+1, ed-1); }\n  {ll num; if(number(st, ed, num)) { return {num}; } }\n  set<ll> ret;\n  for(Iter curr=st; curr!=ed;curr++) {\n    if(*curr == '(') {\n      curr = skip_par(curr)-1;\n    }\n    else if(opes.count(*curr)) {\n      set<ll> l = exp(st, curr);\n      set<ll> r = exp(curr+1,ed);\n      for(SIter i=l.begin(); i!=l.end(); i++) {\n        for(SIter j=r.begin(); j!=r.end(); j++) {\n          switch(*curr) {\n            case '+': ret.insert(*i+*j); break;\n            case '-': ret.insert(*i-*j); break;\n            case '*': ret.insert(*i**j); break;\n            case '/': if(*j!=0) { ret.insert(*i/(*j)); } break;\n          }\n        }\n      }\n    }\n  }\n\n  return ret;\n}\n\nint main()\n{\n  for(;getline(cin, s);) {\n    if(s==\"#\") { break; }\n    Iter it = s.begin(), ed = s.end();\n    cout << exp(it, ed).size() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MP make_pair\n\ntypedef pair<int, int> PII;\n\nconst int SIZE = 15;\n\nchar line[SIZE], t[SIZE];\nset<int> memo[SIZE][SIZE];\nset<PII> used;\n \nvoid eval(int const l, int const r) {\n   \n  set<int>& ret = memo[l][r];\n  if(l == r) return;\n   \n  if(used.count(MP(l, r))) return;\n  used.insert(MP(l, r));\n   \n  // check is digits [l, r)\n  bool digits = true;\n  for(int i=l; i<r; i++) { digits = digits && isdigit(line[i]); }\n  strncpy(t, line+l, r-l); t[r-l+1] = 0;\n  if(digits) { ret.insert(atoi(t)); return; }\n   \n  int par = 0; bool check = true;\n  for(int i=l; i<r-1; i++) {\n    if(line[i] == '(') { par ++; }\n    if(line[i] == ')') { par --; }\n    if(par == 0) { check = false; }\n  }\n   \n  // \"(expr)\"\n  if(check) {\n    if(line[r-1] == ')') {\n      eval(l+1, r-1); ret = memo[l+1][r-1]; return;\n    }\n  }\n   \n  par = 0;\n  // parsing loop\n  for(int i=l; i<r; i++) {\n    if(line[i] == '(') { par ++; }\n    if(line[i] == ')') { par --; }\n    if(par != 0) continue;\n     \n    switch(line[i]) {\n    case '+': case '-': case '*': case '/': {\n      eval(l, i); eval(i+1, r);\n      set<int>::iterator iter_a, iter_b;\n      for(iter_a = memo[l][i].begin(); iter_a!=memo[l][i].end(); iter_a++) {\n        for(iter_b = memo[i+1][r].begin(); iter_b!=memo[i+1][r].end(); iter_b++) {\n          if(line[i] == '+') { ret.insert(*iter_a + *iter_b); }\n          if(line[i] == '-') { ret.insert(*iter_a - *iter_b); }\n          if(line[i] == '*') { ret.insert(*iter_a * *iter_b); }\n          if(line[i] == '/') {\n            if(*iter_b == 0) continue;\n            ret.insert(*iter_a / *iter_b);\n          }\n        }\n      }\n      break;\n    }\n    default:;\n    }\n  } // for parsing loop\n}\n \nint main() {\n   \n  while(1) {\n    scanf(\"%s\\n\", line);\n    for(int i=0; i<SIZE; i++)\n      for(int j=0; j<SIZE; j++)\n        memo[i][j].clear();\n     \n    used.clear();\n     \n    if(0==strcmp(line, \"#\")) break;\n    eval(0, strlen(line));\n    cout << memo[0][strlen(line)].size() << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<cstdlib>\nusing namespace std;\n\nset<int> S;\n\nvoid cal(vector<string> V){\n  \n  for(int i=1;i<V.size()-1;i++){\n    if(V[i-1]==\"(\" && V[i+1]==\")\"){\n      V.erase(V.begin()+i+1);\n      V.erase(V.begin()+i-1);\n      i=max(0,i-2);\n    }\n    }\n  if(V.size()==1){\n    S.insert(atoi(V[0].c_str()));\n  }\n  else {\n    for(int i=0;i<V.size();i++){\n      if(V[i]==\"+\"){\n        if(V[i+1]==\"(\" || V[i-1]==\")\")continue;\n        int a=atoi(V[i-1].c_str())+atoi(V[i+1].c_str());\n\tstringstream ss;\n\tss << a;\n\tstring s=ss.str();\n        vector<string> v=V;\n        v.erase(v.begin()+i+1);\n        v.erase(v.begin()+i);\n\tv.erase(v.begin()+i-1);\n\tv.insert(v.begin()+i-1,s);\n\tcal(v);\n      }\n      if(V[i]==\"-\"){\n\tif(V[i+1]==\"(\" || V[i-1]==\")\")continue;\n        int a=atoi(V[i-1].c_str())-atoi(V[i+1].c_str());\n\tstringstream ss;\n\tss << a;\n\tstring s=ss.str();\n        vector<string> v=V;\n        v.erase(v.begin()+i+1);\n        v.erase(v.begin()+i);\n\tv.erase(v.begin()+i-1);\n\tv.insert(v.begin()+i-1,s);\n\tcal(v);\n      }\n      if(V[i]==\"*\"){\n\tif(V[i+1]==\"(\" || V[i-1]==\")\")continue;\n        int a=atoi(V[i-1].c_str())*atoi(V[i+1].c_str());\n\tstringstream ss;\n\tss << a;\n\tstring s=ss.str();\n        vector<string> v=V;\n        v.erase(v.begin()+i+1);\n        v.erase(v.begin()+i);\n\tv.erase(v.begin()+i-1);\n\tv.insert(v.begin()+i-1,s);\n\tcal(v);\n      }\n      if(V[i]==\"/\"){\n\tif(V[i+1]==\"(\" || V[i-1]==\")\")continue;\n\tif(V[i+1]==\"0\")continue;\n        int a=atoi(V[i-1].c_str())/atoi(V[i+1].c_str());\n\tstringstream ss;\n\tss << a;\n\tstring s=ss.str();\n        vector<string> v=V;\n        v.erase(v.begin()+i+1);\n        v.erase(v.begin()+i);\n\tv.erase(v.begin()+i-1);\n\tv.insert(v.begin()+i-1,s);\n\tcal(v);\n      }\n    }\n  }\n}\n\nint main()\n{\n  string s;\n  while(1){\n    cin>>s;\n    if(s[0]=='#')break;\n    vector<string> V;\n    string samp;\n    for(int i=0;i<s.length();i++){\n      if('0'<=s[i] && s[i]<='9'){\n\tsamp+=s[i];\n\tif(i==s.length()-1)V.push_back(samp);\n      }\n      else {\n\tif(!samp.empty()){\n\t  V.push_back(samp);\n\t  samp=\"\";\n\t}\n\tsamp=s[i];\n\tV.push_back(samp);\n\tsamp=\"\";\n      }\n    }\n    S.clear();\n    cal(V);\n    cout<<S.size()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool digit(char c){\n  if( c - '0'< 0 || c-'0' > 9)return false;\n  return true;\n}\n\nint stoi(string s){\n  int res,tmp;\n\n  res = 0;\n  tmp = 1;\n  for(int i=s.size()-1;i>=0;i--){\n    res += (s[i]-'0') * tmp;\n    tmp *= 10;\n  }\n  return res;\n}  \n\nset<int> cal(set<int> a,set<int> b,char o){\n  set<int> res;\n  set<int>::iterator i,j;\n  res.clear();\n  if(o=='+'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tres.insert((*i) + (*j));\n      }\n    }\n  }else if(o=='-'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tres.insert((*i) - (*j));\n      }\n    }\n  }else if(o=='*'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tres.insert((*i) * (*j));\n      }\n    }\n  }else if(o=='/'){\n    for(i=a.begin();i!=a.end();i++){\n      for(j=b.begin();j!=b.end();j++){\n\tres.insert((*i) / (*j));\n      }\n    }\n  }\n  return res;\n}\n\nset<int> parse(string s){\n  string tmp;\n  set<int> ans[20],store[20],res;\n  char op[20];\n  int pos,cnt;\n  vector<int> order;\n\n  res.clear();\n  pos = 0;\n  cnt = 0;\n\n  while(pos < (int)s.size()){\n    if(s[pos] == '('){\n      tmp.clear();\n      pos++;\n      while(s[pos] != ')'){\n\ttmp.push_back(s[pos]);\n\tpos++;\n      }\n      ans[cnt].clear();\n      ans[cnt] = parse(tmp);\n      pos++;\n    }else if(digit(s[pos])){\n      tmp.clear();\n      while(digit(s[pos])){\n\ttmp.push_back(s[pos]);\n\tpos++;\n      }\n      ans[cnt].clear();\n      ans[cnt].insert(stoi(tmp));\n    }\n    if(pos==(int)s.size())break;\n\n    op[cnt] = s[pos];\n    cnt++;\n    pos++;\n  }\n\n  order.clear();\n  for(int i=0;i<cnt;i++)order.push_back(i);\n  res.clear();\n\n  do{\n    for(int i=0;i<=cnt;i++)store[i] = ans[i];\n    int use[20],num;\n    set<int> hoge;\n    for(int i=0;i<=cnt;i++)use[i] = i;\n    hoge.clear();\n    \n    for(int i=0;i<cnt;i++){\n      hoge = cal(store[order[i]],store[order[i]+1],op[order[i]]);\n      \n      num = use[order[i]+1];\n      for(int j=0;j<=cnt;j++){\n\tif(use[j] == num)use[j] = use[order[i]];\n      }\n      for(int j=0;j<=cnt;j++){\n\tif(use[j] == use[order[i]])store[j] = hoge;\n      }\n    }\n    \n    set<int>::iterator i;\n    for(i=store[0].begin();i!=store[0].end();i++)res.insert(*i);\n\n  }while(next_permutation(order.begin(),order.end()));\n  \n\n  return res;\n}\n\n\nint main(){\n  string str;\n  set<int> s;\n\n  while(1){\n    cin >> str;\n    if(str == \"#\")break;\n\n    s = parse(str);\n\n    cout << s.size() << endl;    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint expression(string,int&);\nint term(string,int&);\nint factor(string,int&);\nint number(string,int&);\n\nbool f;\n\nint expression(string s,int& p){\n  int res=term(s,p);\n  while(p<(int)s.size()){\n    if(s[p]=='+'){\n      p++;\n      res+=term(s,p);\n      continue;\n    }\n    if(s[p]=='-'){\n      p++;\n      res-=term(s,p);\n      continue;\n    }\n    break;\n  }\n  return res;\n}\n\nint term(string s,int& p){\n  int res=factor(s,p);\n  while(p<(int)s.size()){\n    if(s[p]=='*'){\n      p++;\n      res*=factor(s,p);\n      continue;\n    }\n    if(s[p]=='/'){\n      p++;\n      int tmp=factor(s,p);\n      if(tmp==0){\n\tf=1;\n\tbreak;\n      }\n      res/=tmp;\n      continue;\n    }\n    break;\n  }\n  return res;\n}\n\nint factor(string s,int& p){\n  int res;\n  if(s[p]=='('){\n    p++;\n    res=expression(s,p);\n    p++;\n  }else{\n    res=number(s,p);\n  }\n  return res;\n}\n\nint number(string s,int& p){\n  int res=0;\n  while(p<(int)s.size()&&isdigit(s[p]))\n    res=res*10+s[p++]-'0';\n  return res;\n}\n\nsigned main(){\n  string s;\n  while(cin>>s,s!=\"#\"){\n    vector<int> v;\n    for(int i=0,k=0;i<(int)s.size();i++)\n      if(s[i]=='+'||s[i]=='-'||s[i]=='*'||s[i]=='/') v.push_back(k++);\n    set<int> si;\n    do{\n      string t=s;\n      int p=0;\n      for(int i=0;i<(int)v.size();i++){\n\t//cout<<t<<endl;\n\tfor(int j=0,k=0;j<(int)t.size();j++){\n\t  if(t[j]=='+'||t[j]=='-'||t[j]=='*'||t[j]=='/'){\n\t    if(k==v[i]){\n\t      {\n\t\tint pos=j-1,op=0;\n\t\twhile(pos>0){\n\t\t  if(t[pos]=='(') op++;\n\t\t  if(t[pos]==')') op--;\n\t\t  if(t[pos-1]=='+'||t[pos-1]=='-'||\n\t\t     t[pos-1]=='*'||t[pos-1]=='/'||\n\t\t     t[pos-1]=='('){\n\t\t    if(op==0) break;\n\t\t  }\n\t\t  pos--;\n\t\t}\n\t\tt.insert(pos,\"(\");\n\t      }\n\t      {\n\t\tint pos=j+2,op=0;\n\t\twhile(pos<(int)t.size()-1){\n\t\t  if(t[pos]=='(') op++;\n\t\t  if(t[pos]==')') op--;\n\t\t  if(t[pos+1]=='+'||t[pos+1]=='-'||\n\t\t     t[pos+1]=='*'||t[pos+1]=='/'||\n\t\t     t[pos+1]==')'){\n\t\t    if(op==0) break;\n\t\t  }\n\t\t  pos++;\n\t\t}\n\t\tt.insert(pos+1,\")\");\n\t      }\n\t    }\n\t    k++;\n\t  }\n\t}\n      }\n      f=0;\n      int tmp=expression(t,p);\n      if(!f&&p==(int)t.size()) si.insert(tmp);\n      //cout<<t<<\":\"<<f<<\" \"<<tmp<<endl;\n    }while(next_permutation(v.begin(),v.end()));\n    cout<<si.size()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <set>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\ntypedef pair<int,set<int> > pii;\n#define r second\n#define value first\n\n#define isdigit(n) ('0'<= n && n <= '9')\n\nint calc2(int a,int b,char c){\n\tif(a == INT_MAX || b == INT_MAX) return INT_MAX;\n\tswitch(c){\n\tcase '+':return a+b;\n\tcase '-':return a-b;\n\tcase '*':return a*b;\n\tcase '/':return a/b;\n\t}\n}\nset<int> calc(set<int> &a,set<int> &b,char c){\n\tset<int> ans;\n\tfor(set<int>::iterator it = a.begin() ; it != a.end() ; ++it){\n\t\tfor(set<int>::iterator it2 = b.begin() ; it2 != b.end() ; ++it2){\n\t\t\tif( !((c == '/') && (*it2) == 0) )ans.insert( calc2( (*it) , (*it2) , c ) );\n\t\t\telse ans.insert(INT_MAX);\n\t\t}\n\t}\n\treturn ans;\n}\n\nset<int> expr(string s){\n\t\n\tint i = 0 ; \n\tvector< set<int> > d;\n\tvector< pair<int,char> > op;\n\twhile(s[i]){\n\t\tif(isdigit(s[i])){\n\t\t\tstring v;\n\t\t\twhile(isdigit(s[i]))v += s[i++];\n\t\t\tset<int> ss;\n\t\t\tss.insert(atoi(v.c_str()));\n\t\t\td.push_back(ss);\n\t\t}else if(s[i] == '('){\n\t\t\ti++;\n\t\t\tint j = 0 , st = 0;\n\t\t\twhile(s[i+j] != ')' || st){\n\t\t\t\tif(s[i+j] == '(')st++;\n\t\t\t\telse if(s[i+j] == ')')st--;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\td.push_back(expr(s.substr(i,j)));\n\t\t\ti = i+j+1;\n\t\t}else{\n\t\t\top.push_back(make_pair(op.size(),s[i++]));\n\t\t}\n\t}\n\tset<int> ans;\n\tsort(op.begin(),op.end());\n\tdo{ // 1 + 5 + 4\n\t\tvector< pair<int,char> > w = op;\n\t\tvector< set<int> > c = d;\n\t\tfor(int i = 0 ; i < w.size() ; i++){\n\t\t\tint p = w[i].first;\n\t\t\tset<int> res = calc(c[p],c[p+1],w[i].second);\n\t\t\tc.erase(c.begin()+p);\n\t\t\tc[p] = res;\n\t\t\tfor(int j = i+1 ; j < w.size() ; j++){\n\t\t\t\tif(w[i].first < w[j].first)w[j].first--;\n\t\t\t}\n\t\t}\n\t\tc[0].erase(INT_MAX);\n\t\tans.insert(c[0].begin(),c[0].end());\n\t}while(next_permutation(op.begin(),op.end()));\n\t\n\treturn ans;\n}\nint main(){\n\tstring s;\n\twhile(cin >> s , s != \"#\"){\n\t\tcout << expr(s).size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\nvector<char> op;\nvector<int> num;\nconst int INF=1e+9+1;\nint paren[20];\nint pri[20];\nint perm[20];\n\nint dfs(int s,int t){\n  int i=distance(pri,min_element(pri+s,pri+t));\n  int a=i-s==0?num[s]:dfs(s,i);\n  int b=t-i==1?num[t]:dfs(i+1,t);\n  if(op[i]=='+')return a+b;\n  if(op[i]=='-')return a-b;\n  if(op[i]=='*')return a*b;\n  return a/b;\n}\n\nint main(){ _;\n  string str;\n  while(cin>>str,str[0]!='#'){\n    op.clear();\n    num.clear();\n    fill_n(paren,20,0);\n    int prn=0;\n    for(char c:str){\n      if(c=='+'||c=='-'||c=='*'||c=='/'){\n\tparen[op.size()]=prn;\n\top.push_back(c);\n      }else if(c=='('){\n\tprn+=100;\n      }else if(c==')'){\n\tprn-=100;\n      }else{\n\tif(num.size()==op.size())num.push_back(0);\n\tnum[op.size()]=num[op.size()]*10+(c-'0');\n      }\n    }\n    int n=op.size();\n    set<int>result;\n    REP(i,n)perm[i]=i;\n    do{\n      REP(i,n)pri[i]=perm[i]+paren[i];\n      try{\n\tresult.insert(dfs(0,n));\n      }catch(int j){}\n    }while(next_permutation(perm,perm+n));\n    cout<<result.size()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nstring str;\n\nint number(const int begin,const int end){\n    int res=0,idx=begin;\n    while(idx!=end){\n        res*=10;\n        res+=str[idx]-'0';\n        ++idx;\n    }\n    return res;\n}\n\nset<int> dfs(vector<set<int>> v,vector<char> o){\n    if(v.size()==1) return set<int>{v[0]};\n    set<int> res;\n    rep(i,0,o.size()){\n        for(const auto &x:v[i]) for(const auto &y:v[i+1]){\n            if(o[i]=='/' and y==0) continue;\n            vector<set<int>> v_(v.begin(),v.begin()+i);\n            vector<char> o_(o.begin()+1,o.end());\n            if(o[i]=='+') v_.emplace_back(set<int>{x+y});\n            if(o[i]=='-') v_.emplace_back(set<int>{x-y});\n            if(o[i]=='*') v_.emplace_back(set<int>{x*y});\n            if(o[i]=='/') v_.emplace_back(set<int>{x/y});\n            v_.insert(v_.end(),v.begin()+i+2,v.end());\n            set<int> tmp=dfs(v_,o_);\n            res.insert(tmp.begin(),tmp.end());\n        }\n    }\n    return res;\n};\n\nset<int> expression(const int begin,const int end){\n    vector<set<int>> vals;\n    vector<char> ops;\n    int idx=begin;\n    while(idx!=end){\n        if(isdigit(str[idx])){\n            int end_;\n            rep(i,idx,inf) if(!isdigit(str[i])){\n                end_=i;\n                break;\n            }\n            vals.emplace_back(set<int>{number(idx,end_)});\n            idx=end_;\n        }else if(str[idx]=='+' or str[idx]=='-' or str[idx]=='*' or str[idx]=='/'){\n            ops.emplace_back(str[idx]);\n            ++idx;\n        }else if(str[idx]=='('){\n            ++idx;\n            int cnt=1,end_;\n            rep(i,idx,end){\n                if(str[i]=='(') ++cnt;\n                else if(str[i]==')') --cnt;\n                if(!cnt){\n                    end_=i;\n                    break;\n                }\n            }\n            vals.emplace_back(expression(idx,end_));\n            idx=end_+1;\n        }else break;\n    }\n    return dfs(vals,ops);\n}\n\nvoid solve(){\n    while(true){\n        cin >> str;\n        if(str==\"#\") return;\n        cout << expression(0,str.size()).size() << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <queue>\n#include <stack>\n#include <map>\nusing namespace std;\n \n#define REP(i, s, e) for (int i = (s); i < (e); i++)\n#define REPI(i, s, e) for (int i = (s); i <= (e); i++)\n#define rep(i, n) REP(i, 0, n)\n#define repi(i, n) REPI(i, 0, n)\n#define ALL(v) (v).begin(), (v).end()\n \n#define dump(x) (cout << #x << \" = \" << x << endl)\n#define dump2(x, y) (cout << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl)\n#define dump3(x, y, z) (cout << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \"<< z << \")\" << endl)\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define INF (1<<10)\n\nstring str;\n\nint strpos;\nvoid init() { strpos = 0; }\nchar get() { return str[strpos++]; }\nvoid unget() { strpos--; }\n\nvector<int> nums;\nvector<char> ops;\nvector<int> priorities;\n\nint num();\nvoid expr();\n\nvoid initialize()\n{\n\tnums.clear();\n\tops.clear();\n\tpriorities.clear();\n\tinit();\n\texpr();\n}\n\nint num()\n{\n\tint n = 0;\n\tfor (;;) {\n\t\tchar ch = get();\n\t\tif (!isdigit(ch))\n\t\t\tbreak;\n\t\tn = (10*n) + (ch-'0');\n\t}\n\tunget();\n\treturn n;\n}\n\nvoid expr()\n{\n\tint depth = 0;\n\twhile (strpos < str.size()) {\n\t\tchar ch = get();\n\t\tif (ch == '(') {\n\t\t\tdepth++;\n\t\t} else if (ch == ')') {\n\t\t\tdepth--;\n\t\t} else if (isdigit(ch)) {\n\t\t\tunget();\n\t\t\tint n = num();\n\t\t\tnums.push_back(n);\n\t\t} else {\n\t\t\tchar op = ch;\n\t\t\tops.push_back(op);\n\t\t\tpriorities.push_back(depth);\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (cin >> str, str != \"#\") {\n\t\tinitialize();\n/*\n\t\trep(i, ops.size())\n\t\t\tcout << ops[i] << (i==ops.size()-1?\"\\n\":\", \");\n\t\trep(i, priorities.size())\n\t\t\tcout << priorities[i] << (i==priorities.size()-1?\"\\n\":\", \");\n\t\trep(i, nums.size())\n\t\t\tcout << nums[i] << (i==nums.size()-1?\"\\n\":\", \");\n\t\tcout << \"----\" << endl;\n*/\n\n\t\tset<int> ans;\n\t\tint sz = priorities.size();\n\t\tvector<int> pri;\n\t\trep(i, sz) pri.push_back(i);\n\t\tdo {\n\t\t\tvector<int> buf(nums);\n\t\t\tint mi = INF;\n\t\t\tbool used[11] = {};\n\n\t\t\trep(i, sz) {\n\t\t\t\tif (mi < priorities[pri[i]])\n\t\t\t\t\tgoto NEXT;\n\t\t\t\tmi = min(mi, priorities[pri[i]]);\n\t\t\t}\n\n\t\t\trep(i, sz) {\n\t\t\t\tint idx = pri[i];\n\t\t\t\tchar op = ops[idx];\n\t\t\t\tint a = buf[idx];\n\t\t\t\tint b = buf[idx+1];\n\t\t\t\tint ret;\n\t\t\t\tswitch(op) {\n\t\t\t\tcase '+': ret = a+b; break;\n\t\t\t\tcase '-': ret = a-b; break;\n\t\t\t\tcase '*': ret = a*b; break;\n\t\t\t\tcase '/':\n\t\t\t\t\t{\n\t\t\t\t\t\tif (b == 0)\n\t\t\t\t\t\t\tgoto NEXT;\n\t\t\t\t\t\tret = a/b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = idx+1;; j++) {\n\t\t\t\t\tbuf[j] = ret;\n\t\t\t\t\tif (j == sz || !used[j]) break;\n\t\t\t\t}\n\t\t\t\tfor (int j = idx;; j--) {\n\t\t\t\t\tbuf[j] = ret;\n\t\t\t\t\tif (j == 0 || !used[j-1]) break;\n\t\t\t\t}\n\t\t\t\tused[idx] = true;\n\t\t\t}\n\t\t\t/*\n\t\t\trep(i, pri.size())\n\t\t\t\tcout << pri[i] << (i==pri.size()-1?\"\\n\":\", \");\n\t\t\trep(i, buf.size())\n\t\t\t\tcout << buf[i] << (i==buf.size()-1?\"\\n\":\", \");\n\t\t\tcout << \"----\" << endl;\n\t\t\t*/\n\t\t\tans.insert(buf[0]);\nNEXT:;\n\t\t} while(next_permutation(ALL(pri)));\n\t\tcout << ans.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <map> \n#include <set>\nusing namespace std;\n \nconst int MAX= 10000100;\n\n#define loop(i,a,b) for(int i = a ; i < b ; i ++)\n#define rep(i,a) loop(i,0,a)\n#define all(a) (a).begin(),(a).end()\n#define ll long long int\n#define gcd(a,b) __gcd(a,b)\n\nint GCD(int a, int b) {if(!b) return a; return gcd(b, a%b);}\nint lcm(int a, int b) {return a*b / gcd(a, b);}\n\nstring line;\n\ninline bool is0p(char c){\n  return c == '+' || c == '-' || c == '/' || c == '*';\n}\n\nset<int> rec(int l,int r){\n  vector<int> v;\n  for(int i = l , j = 0 ; i < r ; i ++){\n    if(line[i] == '(') j ++;\n    if(line[i] == ')') j --;\n    if(j == 0 && is0p(line[i]))v.push_back(i);\n  }\n  if(v.size() == 0){\n    if(line[l] == '(')return rec(l+1,r-1);\n    set<int> res;\n    res.insert(atoi(line.substr(l,r-l).c_str()));\n    return res;\n  }\n\n  set<int> res;\n  for(int i = 0 ; i < v.size() ; i ++){\n    set<int> a,b;\n    a = rec(l,v[i]);\n    b = rec(v[i]+1,r);\n    for(set<int>::iterator p=a.begin();p!=a.end();p++){\n      for(set<int>::iterator q=b.begin();q!=b.end();q++){\n\tif(line[v[i]]=='+'){\n\t  res.insert(*p + *q);\n\t}else if(line[v[i]]=='-'){\n\t  res.insert(*p - *q);\n\t}else if(line[v[i]]=='*'){\n\t  res.insert(*p * *q);\n\t}else if(line[v[i]]=='/'){\n\t  if(*q != 0)res.insert(*p / *q);\n\t}\n      }\n    }\n  }\n  return res;\n}\n\nint main(void){\n  while(getline(cin,line)&&line !=\"#\"){\n    cout<<rec(0,line.size()).size()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nstring st;\n\nint getnum( int l) {\n\tint num = 0;\n\twhile (isdigit(st[l])) {\n\t\tnum = num * 10 + st[l] - '0';\n\t\tl++;\n\t}\n\treturn num;\n\n}\nint calc(const int a,const int b,const char type) {\n\tif (type == '+')return a + b;\n\telse if (type == '-')return a - b;\n\telse if (type == '*')return a*b;\n\telse {\n\t\tif (b)return a / b;\n\t\telse {\n\t\t\tthrow(false);\n\t\t}\n\t}\n}\n\nset<int> getexpr(const int l,const int r) {\n\tset <int>aset;\n\tif (l > r)assert(false);\n\t\n\tint depth = 0;\n\tbool flag = false;\n\tfor (int x = l; x <= r; ++x) {\n\t\tif (st[x] == '(') {\n\t\t\tdepth++;\n\t\t}\n\t\telse if (st[x] == ')') {\n\t\t\tdepth--;\n\t\t}\n\t\telse if (st[x] == '+' || st[x] == '-' || st[x] == '*' || st[x] == '/') {\n\t\t\tif (!depth) {\n\t\t\t\tflag = true;\n\t\t\t\tconst set<int> lset = getexpr(l, x - 1);\n\t\t\t\tconst set<int> rset = getexpr(x + 1, r);\n\t\t\t\tfor (auto a : lset) {\n\t\t\t\t\tfor (auto b : rset) {\n\t\t\t\t\t\tif (st[x] == '/'&&!b)continue;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\taset.emplace(calc(a, b, st[x]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!flag) {\n\t\tif (st[l] == '(')return getexpr(l + 1, r - 1);\n\t\taset.emplace(getnum(l));\n\t}\n\treturn aset;\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> st;\n\t\tif (st == \"#\")break;\n\t\tset<int>aset;\n\t\tbool ok = true;\n\t\ttry {\n\t\t\taset=getexpr(0,st.size()-1);\n\t\t}\n\t\tcatch (...) {\n\t\t\tassert(false);\n\t\t\tok = false;\n\t\t}\n\t\t\n\t\tcout << aset.size() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef string::const_iterator state;\n\nint expression(state&);\n\nint number(state &begin){\n    int res=0;\n    while(isdigit(*begin)){\n        res*=10;\n        res+=*begin-'0';\n        ++begin;\n    }\n    return res;\n}\n\nint factor(state &begin){\n    if(*begin=='(' or *begin=='['){\n        begin++;\n        const int res=expression(begin);\n        begin++;\n        return res;\n    }else return number(begin);\n}\n\nint expression(state &begin){\n    int res=factor(begin);\n    if(res==inf) return inf;\n    while(true){\n        if(*begin=='+'){\n            ++begin;\n            res+=expression(begin);\n        }else if(*begin=='-'){\n            ++begin;\n            res-=expression(begin);\n        }else if(*begin=='*'){\n            ++begin;\n            res*=expression(begin);\n        }else if(*begin=='/'){\n            ++begin;\n            const int tmp=expression(begin);\n            if(tmp==0) return inf;\n            res/=tmp;\n        }else break;\n    }\n    return res;\n}\n\nvoid solve(){\n    while(true){\n        string str;\n        cin >> str;\n        if(str==\"#\") return;\n\n        int cnt=0;\n        for(const auto ch:str) if(ch=='+' or ch=='-' or ch=='*' or ch=='/') ++cnt;\n\n        set<int> res;\n        function<void(const string,const int,const stack<char>,bool)> rec=[&](const string s,const int idx,const stack<char> stk,bool f){\n            if(idx==s.size()){\n                if(!stk.size()){\n                    string s_=s;\n                    dump(s_);\n                    state begin=s_.begin();\n                    const int res_=expression(begin);\n                    if(res_!=inf) res.insert(res_);\n                    dump(res_);\n                }\n                return;\n            }\n            if(s[idx]=='('){\n                auto stk_=stk;\n                stk_.push('(');\n                rec(s,idx+1,stk_,f);\n                return;\n            }\n            if(s[idx]==')'){\n                if(!stk.size() or stk.top()!='(') return;\n                auto stk_=stk;\n                stk_.pop();\n                rec(s,idx+1,stk_,f);\n                return;\n            }\n            if(stk.size()<cnt and isdigit(s[idx]) and (!idx or !isdigit(s[idx-1]))){\n                auto stk_=stk;\n                stk_.push('[');\n                auto s_=s;\n                s_.insert(idx,\"[\");\n                rec(s_,idx,stk_,false);\n            }\n            if(f and (idx+1==s.size() or (isdigit(s[idx]) and !isdigit(s[idx+1])))){\n                if(!stk.size() or stk.top()!='['){\n                    rec(s,idx+1,stk,f);\n                    return;\n                }\n                auto stk_=stk;\n                auto s_=s;\n                stk_.pop();\n                if(idx+1==s.size()) s_+=\"]\";\n                else s_.insert(idx+1,\"]\");\n                rec(s_,idx+1,stk_,false);\n            }\n            if(s[idx]=='+' or s[idx]=='-' or s[idx]=='*' or s[idx]=='/') rec(s,idx+1,stk,true);\n            else rec(s,idx+1,stk,f);\n        };\n        rec(str,0,stack<char>(),false);\n        cout << res.size() << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//56\n#include<iostream>\n#include<set>\n#include<algorithm>\n#include<cstdio>\n#include<cctype>\n#include<vector>\n#include<cstdlib>\n\nusing namespace std;\n\nset<int> cs(vector<set<int> > n,vector<char> o){\n  if(o.empty()){\n    return n[0];\n  }else{\n    set<int> st;\n    for(int i=0;i<o.size();i++){\n      set<int> l=cs(vector<set<int> > (n.begin(),n.begin()+i+1),vector<char> (o.begin(),o.begin()+i));\n      set<int> r=cs(vector<set<int> > (n.begin()+i+1,n.end()),vector<char> (o.begin()+i+1,o.end()));\n      for(set<int>::iterator k=l.begin();k!=l.end();k++){\n\tfor(set<int>::iterator j=r.begin();j!=r.end();j++){\n\t  if(o[i]=='+'){\n\t    st.insert(*k+*j);\n\t  }else if(o[i]=='-'){\n\t    st.insert(*k-*j);\n\t  }else if(o[i]=='*'){\n\t    st.insert(*k**j);\n\t  }else if(*j){\n\t    int r=abs(*k)/abs(*j);\n\t    st.insert(((*k<0)^(*j<0))?-r:r);\n\t  }\n\t}\n      }\n    }\n    return st;\n  }\n}\n\nset<int> exp(char *s){\n  vector<set<int> > n;\n  vector<char> o;\n  for(int i=0;s[i];){\n    if(isdigit(s[i])){\n      int d,r;\n      sscanf(s+i,\"%d%n\",&d,&r);\n      i+=r;\n      set<int> ss;\n      ss.insert(d);\n      n.push_back(ss);\n    }else if(s[i]!='('){\n      o.push_back(s[i]);\n      i++;\n    }else{\n      int bc=1;\n      int j;\n      for(j=i+1;bc;j++){\n\tbc+=(s[j]=='(')-(s[j]==')');\n      }\n      char ns[201]={};\n      copy(s+i+1,s+j-1,ns);\n      n.push_back(exp(ns));\n      i=j;\n    }\n  }\n  return cs(n,o);\n}\n \nint main(){\n  char s[201];\n  while(cin>>s,s[0]!='#'){\n    cout<<exp(s).size()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nvector<char> ops{'+', '-', '*', '/'};\n\n\nauto is_op(char c) -> bool {\n  auto&& it = find(ops.begin(), ops.end(), c);\n  return it != ops.end();\n}\n\nauto eval(int a, char op, int b) -> int {\n  // cout << a << \" \" << op << \" \" << b << endl;\n  if(op == '+') return a + b;\n  else if(op == '*') return a * b;\n  else if(op == '-') return a - b;\n  else if(op == '/') return a / b;\n}\n\nauto expr(set<int> a, set<int> b, char op) -> set<int> {\n  set<int> res;\n  for(auto it = a.begin(); it != a.end(); ++it) {\n    for(auto b_it = b.begin(); b_it != b.end(); ++b_it) {\n      if(*b_it == 0 && op == '/') continue;\n      res.insert(eval(*it, op, *b_it));\n      // cout << eval(*it, op, *b_it) << endl;\n    }\n  }\n  return res;\n}\n\nauto calc(string s) -> set<int> {\n  set<int> result[11][11];\n  vector<int> op_pos;\n  vector<char> expr_ops;\n  set<int> nums[256];\n\n  string num = \"\";\n  // cout << \"s => \" << s << endl;\n\n  int idx = 0;\n  for(int i=0; i<s.size(); ++i) {\n    if(s[i] == '(') {\n      int cnt = 1;\n      for(int j=i+1;j<s.size(); ++j) {\n        if(s[j]=='(') cnt++;\n        if(s[j]==')') cnt--;\n        if(s[j]==')' && cnt==0) {\n          nums[idx++] = calc(s.substr(i+1, j-i-1));\n          i = j;\n        }\n      }\n    }\n    else if(is_op(s[i])) {\n      op_pos.push_back(i);\n      expr_ops.push_back(s[i]);\n      // cout << \"num \" << num << endl;\n      if(num != \"\")\n        nums[idx++].insert(stoi(num));\n      num = \"\";\n    } else num += s[i];\n  }\n      // cout << \"num \" << num << endl;\n  if(num != \"\") nums[idx++].insert(stoi(num));\n\n  for(int i = 0; i<idx; ++i){\n    result[i][i] = nums[i];\n  }\n  for(int j=1; j<idx; ++j) {\n    for(int i=0; i<idx; ++i) {\n      if(i+j >= idx)break;\n      for(int k=0; k<j; ++k) {\n        //cout << \"i\" << i << \" i+k\" << i+k << \"     i+k+1\" << i+k+1 << \" i+j: \" << i+j << \" k \" << k << endl;\n        //cout << result[i][i+k].size()<< \" , \" << result[i+k+1][i+j].size() << endl;\n        auto&& tmp = expr(result[i][i+k], result[i+k+1][i+j], expr_ops[i+k]);\n        for(auto e : tmp) result[i][i+j].insert(e);\n        //cout << \"result: \" << result[i][i+j].size() << endl;\n      }\n    }\n  }\n\n  // for(int i= 0; i < idx; ++i){\n  //   cout << \"i: \" << i << endl;\n  //   for(int j = i; j < idx; ++j){\n  //     cout << result[i][j].size() << endl;\n  //   }\n  // }\n\n  return result[0][idx-1];\n}\n\nauto rec(string target) -> void {\n}\n\nauto main() -> signed {\n  string s;\n  while(cin>>s, s!=\"#\") {\n    cout << calc(s).size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nclass UF {\nprivate:\n    int sz; vector<int> par,nrank;\npublic:\n    UF(){}\n    UF(int node_size){ sz = node_size; par.resize(sz),nrank.resize(sz); rep(i,sz){ par[i] = i; nrank[i] = 0; } }\n    int find(int x){ if(par[x] == x){ return x; }else{ return par[x] = find(par[x]); } }\n    void unite(int x,int y)\n    { x = find(x),y = find(y); if(x == y) return;\n    \tif(nrank[x] < nrank[y]){ par[x] = y; }else{ par[y] = x; if(nrank[x] == nrank[y]) nrank[x]++; } }\n    bool same(int x,int y){ return find(x) == find(y); }\n};\n\nstring s;\n\nvoid dfs(int& id,vi& vec)\n{\n    vvi val;\n    vector<char> enz;\n    while(id < len(s)){\n        if(isdigit(s[id])){\n            string t;\n            vi hoge;\n            while(isdigit(s[id])){\n                t += s[id];\n                id++;\n            }\n            hoge.pb(stoi(t));\n            val.pb(hoge);\n        }else if(s[id] == '('){\n            id++;\n            vi vv;\n            dfs(id,vv);\n            zip(vv);\n            val.pb(vv);\n        }else if(s[id] == ')'){\n            id++;\n            break;\n        }else{\n            enz.pb(s[id]);\n            id++;\n        }\n    }\n    // svec(enz);\n    // rep(i,len(val)){\n    //     svec(val[i]);\n    // }\n    vi num(len(enz));\n    vvi temp = val;\n    iota(all(num),0);\n    do{\n        UF uf(len(val));\n        val = temp;\n        for(int i:num){\n            vi res;\n            int a = uf.find(i),b = uf.find(i+1);\n            rep(j,len(val[a])){\n                rep(k,len(val[b])){\n                    if(enz[i] == '+'){\n                        res.pb(val[a][j]+val[b][k]);\n                    }else if(enz[i] == '-'){\n                        res.pb(val[a][j]-val[b][k]);\n                    }else if(enz[i] == '*'){\n                        res.pb(val[a][j]*val[b][k]);\n                    }else{\n                        if(val[b][k] != 0){\n                            res.pb(val[a][j]/val[b][k]);\n                        }\n                    }\n                }\n            }\n            uf.unite(a,b);\n            val[uf.find(a)] = res;\n        }\n        int hoge = uf.find(0);\n        rep(i,len(val[hoge])){\n            vec.pb(val[hoge][i]);\n        }\n    }while(next_permutation(all(num)));\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        cin >> s;\n        if(s == \"#\"){\n            break;\n        }\n        int id = 0;\n        vi vec;\n        dfs(id,vec);\n        zip(vec);\n        // svec(vec);\n        cout << len(vec) << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int INF = 1 << 30;\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef vector<double> vd;\ntypedef pair<int,int> pii;\ntypedef pair<long,long> pll;\ntypedef long long ll;\ntypedef set<int> si;\n\nenum { T_NUM, T_OP, T_PR0, T_PR1 };\n\nstruct Elm {\n  int type, v;\n  Elm() {}\n  Elm(int _t, int _v): type(_t), v(_v) {}\n\n  void print() const {\n    if (type == T_NUM) printf(\"%d\", v);\n    else printf(\"%c\", v);\n  }\n};\n\ntypedef vector<Elm> ve;\n\n/* global variables */\n\nsi ans;\n\n/* subroutines */\n\nvoid parse(ve& expr, string str) {\n  expr.clear();\n  int len = str.length();\n\n  for (int i = 0; i < len; i++)\n    switch (str[i]) {\n    case '(': expr.push_back(Elm(T_PR0, '(')); break;\n    case ')': expr.push_back(Elm(T_PR1, ')')); break;\n    case '+': expr.push_back(Elm(T_OP, '+')); break;\n    case '-': expr.push_back(Elm(T_OP, '-')); break;\n    case '*': expr.push_back(Elm(T_OP, '*')); break;\n    case '/': expr.push_back(Elm(T_OP, '/')); break;\n    default:\n      int num = 0;\n      while (i < len && str[i] >= '0' && str[i] <= '9')\n\tnum = 10 * num + (str[i++] - '0');\n      i--;\n      expr.push_back(Elm(T_NUM, num));\n    }\n}\n\nint calc(const Elm& e0, const Elm& op, const Elm& e1) {\n  switch (op.v) {\n  case '+': return e0.v + e1.v;\n  case '-': return e0.v - e1.v;\n  case '*': return e0.v * e1.v;\n  case '/': return (e1.v) ? e0.v / e1.v : INF;\n  }\n  return INF;\n}\n\nvoid print_expr(ve expr) {\n  for (ve::iterator vit = expr.begin(); vit != expr.end(); vit++)\n    vit->print(), putchar(' ');\n  putchar('\\n');\n}\n\nvoid rec(ve expr) {\n  //print_expr(expr);\n  int elen = expr.size();\n  if (elen == 1) {\n    ans.insert(expr.front().v);\n    return;\n  }\n\n  for (int i = 0; i < elen - 2; i++) {\n    Elm e0 = expr[i], e1 = expr[i + 1], e2 = expr[i + 2];\n    if (e0.type == T_NUM && e1.type == T_OP && e2.type == T_NUM) {\n      int num = calc(e0, e1, e2);\n      if (num >= INF) continue;\n\n      int pos0 = i, pos1 = i + 3;\n      int npr = 0;\n\n      while (pos0 > 0 && pos1 < elen &&\n\t     expr[pos0 - 1].type == T_PR0 &&\n\t     expr[pos1].type == T_PR1) {\n\tnpr++;\n\tpos0--;\n\tpos1++;\n      }\n\n      expr.erase(expr.begin() + pos0, expr.begin() + pos1);\n      expr.insert(expr.begin() + pos0, Elm(T_NUM, num));\n\n      //cout << \"--> \"; print_expr(expr);\n      rec(expr);\n\n      expr.erase(expr.begin() + pos0);\n      for (int j = 0; j < npr; j++)\n\texpr.insert(expr.begin() + pos0++, Elm(T_PR0, '('));\n      expr.insert(expr.begin() + pos0++, e0);\n      expr.insert(expr.begin() + pos0++, e1);\n      expr.insert(expr.begin() + pos0++, e2);\n      for (int j = 0; j < npr; j++)\n\texpr.insert(expr.begin() + pos0++, Elm(T_PR1, ')'));\n      //cout << \"<-- \"; print_expr(expr);\n    }\n    else if (e0.type == T_PR0 && e1.type == T_NUM && e2.type == T_PR1) {\n      int pos0 = i, pos1 = i + 3;\n      int npr = 0;\n\n      while (pos0 > 0 && pos1 < elen &&\n\t     expr[pos0 - 1].type == T_PR0 &&\n\t     expr[pos1].type == T_PR1) {\n\tnpr++;\n\tpos0--;\n\tpos1++;\n      }\n\n      expr.erase(expr.begin() + pos0, expr.begin() + pos1);\n      expr.insert(expr.begin() + pos0, e1);\n\n      //cout << \"--> \"; print_expr(expr);\n      rec(expr);\n\n      expr.erase(expr.begin() + pos0);\n      for (int j = 0; j < npr; j++)\n\texpr.insert(expr.begin() + pos0++, Elm(T_PR0, '('));\n      expr.insert(expr.begin() + pos0++, e0);\n      expr.insert(expr.begin() + pos0++, e1);\n      expr.insert(expr.begin() + pos0++, e2);\n      for (int j = 0; j < npr; j++)\n\texpr.insert(expr.begin() + pos0++, Elm(T_PR1, ')'));\n      //cout << \"<-- \"; print_expr(expr);\n    }\n  }\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    string str;\n    cin >> str;\n    if (str == \"#\") break;\n\n    ve expr;\n    parse(expr, str);\n\n    ans.clear();\n    rec(expr);\n    cout << ans.size() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint isalldigit(const string& str)\n{\n  for(int i = 0; i < str.size(); i++){\n    if(!isdigit(str[i])) return false;\n  }\n  return true;\n}\n\nbool foo(const string& str){\n  int foo = 0;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == '(') foo++;\n    else if(str[i] == ')') foo--;\n    if(foo == 0) return false;\n  }\n  return true;\n}\n\nset< int > expr(string str)\n{\n  set< int > ret;\n\n  int foo = 0 ;\n  if(isalldigit(str)){\n    ret.insert(atoi(str.c_str()));\n  } else if (str[0] == '(' && str[str.size() - 1] == ')'){\n    return expr( str.substr( 1, str.size() - 2));\n  } else {\n    for(int i = 0; i < str.size(); i++){\n      if(str[i] == '('){ //開き括弧だなぁ\n        foo++;\n        continue;\n      } else if(str[i] == ')'){ //閉じ括弧だなぁ \n        foo--;\n        continue;\n      } else if(isdigit(str[i])){ //数字はどうでもいいなぁ\n        continue;\n      }\n      if(foo == 0){\n        set< int > hori = expr(str.substr( 0, i));\n        set< int > tkc = expr(str.substr( i + 1));\n        for(set< int >::iterator msy = hori.begin(); msy != hori.end(); msy++){\n          for(set< int >::iterator mtur = tkc.begin(); mtur != tkc.end(); mtur++){\n            if(str[i] == '+'){\n              ret.insert( *msy + *mtur);\n            } else if(str[i] == '-'){\n              ret.insert( *msy - *mtur);\n            } else if(str[i] == '*'){\n              ret.insert( *msy * *mtur);\n            } else {\n              if(*mtur == 0) continue;\n              ret.insert( *msy / *mtur);\n            }\n          }\n        }\n      }\n    }\n  }\n  return ret;\n}\n\n\nint main()\n{\n  string s;\n  while(cin >> s, s != \"#\"){\n    cout << expr(s).size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\nusing namespace std;\nstring s;\nint opn[222],stz[222];\nvector<int>pr;\nbool flag;\nint f(int L,int R,int st)\n{\n\tint mi=-1;\n\tfor(int i=L;i<R;i++)\n\t{\n\t\tif(opn[i]<0||stz[i]!=st)continue;\n\t\tif(mi<0)mi=i;\n\t\telse if(pr[opn[i]]<pr[opn[mi]])mi=i;\n\t}\n\tif(mi>=0)\n\t{\n\t\tint A=f(L,mi,st),B=f(mi+1,R,st);\n\t\tif(s[mi]=='+')return A+B;\n\t\telse if(s[mi]=='-')return A-B;\n\t\telse if(s[mi]=='*')return A*B;\n\t\telse if(s[mi]=='/')\n\t\t{\n\t\t\tif(B)return A/B;\n\t\t\telse\n\t\t\t{\n\t\t\t\tflag=false;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tif(s[L]=='('&&s[R-1]==')')return f(L+1,R-1,st+1);\n\telse\n\t{\n\t\tint now=0;\n\t\tfor(int i=L;i<R;i++)now=now*10+s[i]-'0';\n\t\treturn now;\n\t}\n}\nmain()\n{\n\twhile(cin>>s,s!=\"#\")\n\t{\n\t\tint sz=0,c=0;\n\t\tpr.clear();\n\t\tfor(int i=0;i<s.size();i++)\n\t\t{\n\t\t\topn[i]=stz[i]=-1;\n\t\t\tif(s[i]=='+'||s[i]=='-'||s[i]=='*'||s[i]=='/')\n\t\t\t{\n\t\t\t\topn[i]=sz++;\n\t\t\t\tstz[i]=c;\n\t\t\t\tpr.push_back(pr.size());\n\t\t\t}\n\t\t\tif(s[i]=='(')c++;\n\t\t\tif(s[i]==')')c--;\n\t\t}\n\t\tset<int>S;\n\t\tdo{\n\t\t\tflag=true;\n\t\t\tint ans=f(0,s.size(),0);\n\t\t\tif(flag)S.insert(ans);\n\t\t}while(next_permutation(pr.begin(),pr.end()));\n\t\tcout<<S.size()<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <queue>\n#include <stack>\n#include <map>\nusing namespace std;\n \n#define REP(i, s, e) for (int i = (s); i < (e); i++)\n#define REPI(i, s, e) for (int i = (s); i <= (e); i++)\n#define rep(i, n) REP(i, 0, n)\n#define repi(i, n) REPI(i, 0, n)\n#define ALL(v) (v).begin(), (v).end()\n \n#define dump(x) (cout << #x << \" = \" << x << endl)\n#define dump2(x, y) (cout << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl)\n#define dump3(x, y, z) (cout << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \"<< z << \")\" << endl)\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define INF (1<<10)\n\nstring str;\n\nint strpos;\nvoid init() { strpos = 0; }\nchar get() { return str[strpos++]; }\nvoid unget() { strpos--; }\n\nvector<int> nums;\nvector<char> ops;\nvector<int> priorities;\n\nint num();\nvoid expr();\n\nvoid initialize()\n{\n\tnums.clear();\n\tops.clear();\n\tpriorities.clear();\n\tinit();\n\texpr();\n}\n\nint num()\n{\n\tint n = 0;\n\tfor (;;) {\n\t\tchar ch = get();\n\t\tif (!isdigit(ch))\n\t\t\tbreak;\n\t\tn = (10*n) + (ch-'0');\n\t}\n\tunget();\n\treturn n;\n}\n\nvoid expr()\n{\n\tint depth = 0;\n\twhile (strpos < str.size()) {\n\t\tchar ch = get();\n\t\tif (ch == '(') {\n\t\t\tdepth++;\n\t\t} else if (ch == ')') {\n\t\t\tdepth--;\n\t\t} else if (isdigit(ch)) {\n\t\t\tunget();\n\t\t\tint n = num();\n\t\t\tnums.push_back(n);\n\t\t} else {\n\t\t\tchar op = ch;\n\t\t\tops.push_back(op);\n\t\t\tpriorities.push_back(depth);\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (cin >> str, str != \"#\") {\n\t\tinitialize();\n\t\t/*\n\t\trep(i, ops.size())\n\t\t\tcout << ops[i] << (i==ops.size()-1?\"\\n\":\", \");\n\t\trep(i, priorities.size())\n\t\t\tcout << priorities[i] << (i==priorities.size()-1?\"\\n\":\", \");\n\t\trep(i, nums.size())\n\t\t\tcout << nums[i] << (i==nums.size()-1?\"\\n\":\", \");\n\t\tcout << \"----\" << endl;\n\t\t*/\n\n\t\tset<int> ans;\n\t\tint sz = priorities.size();\n\t\tvector<int> pri;\n\t\trep(i, sz) pri.push_back(i);\n\t\tdo {\n\t\t\tvector<int> buf(nums);\n\t\t\tint mi = INF;\n\t\t\trep(i, sz) {\n\t\t\t\tif (mi < priorities[pri[i]])\n\t\t\t\t\tgoto NEXT;\n\t\t\t\tmi = min(mi, priorities[pri[i]]);\n\t\t\t}\n\n\t\t\trep(i, sz) {\n\t\t\t\tint idx = pri[i];\n\t\t\t\tchar op = ops[idx];\n\t\t\t\tint a = buf[idx];\n\t\t\t\tint b = buf[idx+1];\n\t\t\t\tint ret;\n\t\t\t\tswitch(op) {\n\t\t\t\tcase '+': ret = a+b; break;\n\t\t\t\tcase '-': ret = a-b; break;\n\t\t\t\tcase '*': ret = a*b; break;\n\t\t\t\tcase '/':\n\t\t\t\t\t{\n\t\t\t\t\t\tif (b == 0)\n\t\t\t\t\t\t\tgoto NEXT;\n\t\t\t\t\t\tret = a/b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbuf[idx] = ret;\n\t\t\t\tbuf[idx+1] = ret;\n\t\t\t}\n\t\t\tans.insert(buf[pri[pri.size()-1]]);\nNEXT:;\n\t\t} while(next_permutation(ALL(pri)));\n\t\tcout << ans.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\n\n//// algorithm ////\n\n// 文字列の置換\nvoid inplaceReplace(string &target, const string &from, const string &to, bool global = false)\n{\n\tdo\n\t{\n\t\tstring::size_type pos = target.find(from);\n\t\tif (pos == target.npos) { break; }\n\t\ttarget.replace(pos, from.length(), to);\n\t} while (true);\n}\n\n// 文字列の分割\nvector<string> split(const string &str, const string &s, bool removeEmpty = false)\n{\n\tvector<string> ret;\n\tsize_t p = 0, sl = s.size();\n\twhile (true)\n\t{\n\t\tsize_t q = str.find(s, p);\n\t\tif (q == str.npos) break;\n\t\tret.push_back(str.substr(p, q - p));\n\t\tp = q + sl;\n\t}\n\tret.push_back(str.substr(p));\n\tif (removeEmpty) ret.erase(remove(allof(ret), string()), ret.end());\n\treturn ret;\n}\n\n// 対応する括弧のインデクス\nint findbrace(const string &str, int l)\n{\n\tstack<char> stack;\n\tFOR(i, l, str.size())\n\t{\n\t\tswitch (str[i])\n\t\t{\n#define CASE(x,y) case x: stack.push(str[i]); break; case y: if(stack.top() != x) return -2; stack.pop(); break\n\t\t\tCASE('(', ')');\n\t\t\tCASE('[', ']');\n\t\t\tCASE('<', '>');\n\t\t\tCASE('{', '}');\n#undef  CASE\n\t\t}\n\t\tif (stack.size() == 0) return i;\n\t}\n\treturn -1;\n}\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nset<int> eval(const string &str, int l, int r)\n{\n\tvector<set<int>> operands;\n\tvector<char> operators(1);\n\n\t// 式を読む\n\tint val = 0;\n\tFOR(p, l, r)\n\t{\n\t\tif (isdigit(str[p]))\n\t\t{\n\t\t\tval = val * 10 + str[p] - '0';\n\t\t}\n\t\telse if (str[p] == '(')\n\t\t{\n\t\t\toperands.push_back(eval(str, p + 1, findbrace(str, p)));\n\t\t\tp = findbrace(str, p);\n\t\t\tval = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (val >= 0)\n\t\t\t{\n\t\t\t\toperands.push_back(set<int>({ val }));\n\t\t\t}\n\t\t\tval = 0;\n\t\t\toperators.push_back(str[p]);\n\t\t}\n\t}\n\t\n\tif (val >= 0)\n\t{\n\t\toperands.push_back(set<int>({ val }));\n\t\tval = 0;\n\t}\n\n\tset<int> result;\n\n\t// よんだ\n\tint n = operands.size();\n\tvector<vector<set<int> > > dp(n + 1, vector<set<int>>(n + 1)); // [l][r] 範囲[l,r)のオペランドを計算して出てくる整数セット\n\t\n\tREP(i, n) dp[i][i + 1] = operands[i];\n\tFOR(i, 2, n + 1) // 統合幅\n\t{\n\t\tREP(j, n - i + 1) // 始点 j から i 文字\n\t\t{\n\t\t\tFOR(k, 1, i) // jからk文字と j+kからi-k文字\n\t\t\t{\n\t\t\t\tint s = j;\n\t\t\t\tint m = j + k;\n\t\t\t\tint e = j + i;\n\t\t\t\t// WRITE(\"sme\", s, m, e);\n\t\t\n\t\t\t\t// 演算\n\t\t\t\tfor (int x : dp[s][m]) for (int y : dp[m][e])\n\t\t\t\t{\n\t\t\t\t\tswitch (operators[m])\n\t\t\t\t\t{\n\t\t\t\t\tcase '+': dp[s][e].insert(x + y); break;\n\t\t\t\t\tcase '-': dp[s][e].insert(x - y); break;\n\t\t\t\t\tcase '*': dp[s][e].insert(x * y); break;\n\t\t\t\t\tcase '/': if (y) dp[s][e].insert(x / y); break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[0][n];\n}\n\nvoid solve()\n{\n\tint testcases = INF;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(string, expr);\n\t\tif (expr == \"#\") { break; }\n\t\tWRITE(eval(expr, 0, expr.size()).size());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <sstream>\n \nusing namespace std;\n \nset<int> m1[201][201];\nbool m2[201][201];\n \nint stoi(string s) {\n\tstringstream ss; ss << s;\n\tint ret; ss >> ret;\n\treturn ret;\n}\n \nstring str;\nset<int> dp(int l, int r) {\n\tif (m2[l][r]) return m1[l][r];\n  if (m2[l][r]) return m1[l][r];\n  int cnt = 0; bool p = true; set<int> res;\n  for (int i = l; i < r; ++i) {\n    char c = str[i];\n    if (c == '(') ++cnt;\n    else if (c == ')') --cnt;\n    else if (cnt == 0 && !isdigit(c)) {\n      p = false;\n      set<int> s1 = dp(l, i), s2 = dp(i+1, r);\n      for (int j: s1) for (int k: s2) {\n        if (c == '+') res.insert(j + k);\n        if (c == '-') res.insert(j - k);\n        if (c == '*') res.insert(j * k);\n        if (k && str[i] == '/') res.insert(j / k);\n      }\n    }\n  }\n  if (p) {\n    if (str[l] == '(' && str[r-1] == ')') res = dp(l+1, r-1);\n    else res.insert(stoi(str.substr(l, r-l)));\n  }\n  m2[l][r] = true; return m1[l][r] = res;\n}\n \nint main() {\n\twhile (cin >> str, str != \"#\") {\n\t\tfill(&m2[0][0], &m2[0][0]+201*201, false);\n\t\tcout << dp(0, str.size()).size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef set <int> S;\nchar ch;\n\nstring get_str(string &str,int &i){\n  string res;\n  if(str[i]!='(')return \"\"+str[i];\n  \n  int cnt=1;\n  i++;\n  while(1) {\n    if(str[i]=='(')cnt++;\n    if(str[i]==')')cnt--;\n    if(!cnt)break;\n    res+=str[i++];\n  }\n  return res;\n}\n\n\nint num[1<<8];\nvector <S> mem;\nmap <string,int> M;\nvoid calc(char ch,S a,S b, S &res){\n  S::iterator i,j;\n  for(i=a.begin();i!=a.end();i++)\n    for(j=b.begin();j!=b.end();j++){\n      int I=*i,J=*j,c=0;\n      if(ch=='+') c=I+J;\n      else if(ch=='-') c=I-J;\n      else if(ch=='*') c=I*J;\n      else if(ch=='/'){\n\tif(!J)continue;\n\tc=I/J;\n      }\n      res.insert(c);\n    }\n}\n\nS solve(string str){\n  S res;\n  if(str.size()==1){res.insert(num[str[0]]);return res;}\n  if(M.count(str))return mem[M[str]];\n  if(str[0]=='('&&str[str.size()-1]==')')return solve(str.substr(1,str.size()-2));\n\n  string A,B;\n  for(int i=0;i<str.size()-1;i+=2){\n    get_str(str,i);\n    if(i>=str.size()-1)break;\n    string A=str.substr(0,i+1),B=str.substr(i+2,str.size()-i-2);\n    calc(str[i+1],solve(A),solve(B),res);\n  }\n  M[str]=mem.size();\n  mem.push_back(res); \n  return mem[M[str]];\n}\n\nint main(){\n  while(1){\n    string str;\n    cin>>str;\n    if(str==\"#\")break;\n    mem.clear(),M.clear();\n    string siki;\n    ch='A';\n    for(int i=0;i<(int)str.size();){\n      int b=0;\n      while('0'<=str[i]&&str[i]<='9') b=b*10+str[i++]-'0';\n      if(b) num[ch]=b,siki+=ch++;\n      else siki+=str[i++];\n    }\n    cout <<solve(siki).size()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif\n\n#include<string>\n#include<cmath>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<utility>\n#include<tuple>\n#include<set>\nusing namespace std;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ITR(x,v) for(auto &x:v)\ntypedef pair<int, int> P;\ntypedef vector<int> V;\ntypedef vector<V > VV;\nconst int B = 1e9;\nstring s;\nint parse_num(int &id) {\n\tint res = 0;\n\twhile (id < s.size() && isdigit(s[id])) {\n\t\tres = res * 10 + s[id] - '0';\n\t\tid++;\n\t}\n\treturn res;\n}\nconst int O = B+5;\nconst int C = B+6;\nvoid nobu(V &v,V &l,V& r,int id) {\n\twhile (l[id]!=-1&&r[id]!=-1&&v[l[id]] == O&&v[r[id]] == C) {\n\t\tint left = l[id];\n\t\tint right = r[id];\n\t\tl[id] = l[left];\n\t\tr[id] = r[right];\n\t\tv[left] = B + 10;\n\t\tv[right] = B + 10;\n\t\tif (l[left] != -1)r[l[left]] = id;\n\t\tif (r[right] != -1)l[r[right]] = id;\n\t}\n}\nbool myadd(V &v, V &l, V& r, int id) {\n\tint left = l[id];\n\tint right = r[id];\n\tif (v[l[id]] <= B&&v[r[id]] <= B);\n\telse {\n\t\treturn false;\n\t}\n\tv[id] = v[left] + v[right];\n\tl[id] = l[left];\n\tr[id] = r[right];\n\tv[left] = B + 10;\n\tv[right] = B + 10;\n\tif (l[left] != -1)r[l[left]] = id;\n\tif (r[right] != -1)l[r[right]] = id;\n\tnobu(v, l, r, id);\n\treturn true;\n}\nbool mysub(V &v, V &l, V& r, int id) {\n\tint left = l[id];\n\tint right = r[id];\n\tif (v[l[id]] <= B&&v[r[id]] <= B);\n\telse {\n\t\treturn false;\n\t}\n\tv[id] = v[left] - v[right];\n\tl[id] = l[left];\n\tr[id] = r[right];\n\tv[left] = B + 10;\n\tv[right] = B + 10;\n\tif (l[left] != -1)r[l[left]] = id;\n\tif (r[right] != -1)l[r[right]] = id;\n\tnobu(v, l, r, id);\n\treturn true;\n}\nbool mymul(V &v, V &l, V& r, int id) {\n\tint left = l[id];\n\tint right = r[id];\n\tif (v[l[id]] <= B&&v[r[id]] <= B);\n\telse {\n\t\treturn false;\n\t}\n\tv[id] = v[left] * v[right];\n\tl[id] = l[left];\n\tr[id] = r[right];\n\tv[left] = B + 10;\n\tv[right] = B + 10;\n\tif (l[left] != -1)r[l[left]] = id;\n\tif (r[right] != -1)l[r[right]] = id;\n\tnobu(v, l, r, id);\n\treturn true;\n}\nbool mydiv(V &v, V &l, V& r, int id) {\n\tint left = l[id];\n\tint right = r[id];\n\tif (v[l[id]] <= B&&v[r[id]] <= B);\n\telse {\n\t\treturn false;\n\t}\n\tif (v[right] == 0)return false;\n\tv[id] = v[left] / v[right];\n\tl[id] = l[left];\n\tr[id] = r[right];\n\tv[left] = B + 10;\n\tv[right] = B + 10;\n\n\tif (l[left] != -1)r[l[left]] = id;\n\tif (r[right] != -1)l[r[right]] = id;\n\tnobu(v, l, r, id);\n\treturn true;\n}\n\nint main() {\n\n\twhile (cin >> s, s != \"#\") {\n\t\tint id = 0;\n\t\tvector<int> v,op;\n\t\tset<int> ss;\n\t\twhile (id < s.size()) {\n\t\t\tswitch (s[id]) {\n\t\t\tcase '+':v.push_back(B + 1); id++; break;\n\t\t\tcase '-':v.push_back(B + 2); id++; break;\n\t\t\tcase '*':v.push_back(B + 3); id++; break;\n\t\t\tcase '/':v.push_back(B + 4); id++; break;\n\t\t\tcase '(':v.push_back(B + 5); id++; break;\n\t\t\tcase ')':v.push_back(B + 6); id++; break;\n\t\t\tdefault: v.push_back(parse_num(id)); break;\n\t\t\t}\n\t\t}\n\t\tint m = v.size();\n\t\tREP(i, m)if (B<v[i]&&v[i]<B+5)op.push_back(i);\n\t\tint k = op.size();\n\t\tdo {\n\t\t\tbool flag = true;\n\t\t\tvector<int> l(m, -1);\n\t\t\tvector<int> r(m, -1);\n\t\t\tauto u = v;\n\t\t\tREP(i, m - 1)l[i + 1] = i;\n\t\t\tREP(i, m - 1)r[i] = i+1;\n\t\t\tREP(i, m)if (v[i] <= B)nobu(u, l, r,i);\n\t\t\tREP(i, k) {\n\t\t\t\tint id = op[i];\n\t\t\t\tif (l[id] <= B&&r[id] <= B) {\n\t\t\t\t\tswitch (u[id]){\n\t\t\t\t\tcase B + 1:flag&=myadd(u, l, r, id); break;\n\t\t\t\t\tcase B + 2:flag&=mysub(u, l, r, id); break; \n\t\t\t\t\tcase B + 3:flag&=mymul(u, l, r, id); break; \n\t\t\t\t\tcase B + 4: \n\t\t\t\t\t\tflag&=mydiv(u, l, r, id); \n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\n\t\t\t\t\tdefault:flag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t\tif (flag == false)break;\n\t\t\t}\n\n\t\t\tif (flag) {\n\t\t\t\tint res;\n\t\t\t\tREP(i, m)if (u[i] != B + 10)res = u[i];\n\t\t\t\tss.insert(res);\n\n\n\n\t\t\t}\n\t\t}while(next_permutation(op.begin(), op.end()));\n\t\tcout << ss.size() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "  #include <bits/stdc++.h>\n\n  using namespace std;\n\n  typedef long long ll;\n  typedef vector<ll> vl;\n\n  vl mem[205][205];\n  ll visit[205][205];\n\n  int num(string& s, ll l, ll r){\n    ll ret = 0;\n    for(ll i = l;i < r;i++){\n      ret *= 10;\n      ret += s[i]-'0';\n    }\n    return ret;\n  }\n\n  bool is_op(char c){\n    return c == '+' || c == '-' || c == '*' || c == '/';\n  }\n\n  vl eval(string& s, ll l, ll r){\n    if(visit[l][r]) return mem[l][r];\n    visit[l][r] = 1;\n    // cerr << l << \" \" << r << endl;\n    vl ret = vl();\n    ll cnt = 0;\n    bool flag = false;\n    for(ll i = l;i < r;i++){\n      if(cnt == 0 && is_op(s[i])){\n        vl left_vec = eval(s, l, i);\n        vl right_vec = eval(s, i+1, r);\n        flag = true;\n        for(ll x : left_vec){\n          for(ll y : right_vec){\n\n            if(s[i] == '+') ret.push_back(x+y);\n            if(s[i] == '-') ret.push_back(x-y);\n            if(s[i] == '*') ret.push_back(x*y);\n            if(s[i] == '/' && y != 0) ret.push_back(abs(x)/abs(y)*(x*y >= 0 ? 1 : -1));\n\n          }\n        }\n      }\n      if(s[i] == '(') cnt++;\n      if(s[i] == ')') cnt--;\n    }\n    if(flag == false){\n      if(s[l] == '(' && s[r-1] == ')') return mem[l][r] = eval(s, l+1, r-1);\n      else return mem[l][r] = vl({num(s,l,r)});\n    }\n    if(ret.size() > 0){\n      sort(ret.begin(),ret.end());\n      ret.erase(unique(ret.begin(),ret.end()), ret.end());\n    }\n    return mem[l][r] = ret;\n  }\n\n\n  int main(){\n\n    string s;\n    while(cin >> s){\n      if(s == \"#\") return 0;\n      for(ll i = 0;i < 205;i++){\n        for(ll j = 0;j < 205;j++){\n          mem[i][j] = vl();\n          visit[i][j] = 0;\n        }\n      }\n      // vl res = eval(s,0,s.size());\n      // for(ll x : res){\n      //   cerr << x << \" \";\n      // }\n      // cerr << endl;\n      cout << eval(s,0,s.size()).size() << endl;\n    }\n  }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint to_int(string s){\n  int res;\n  stringstream ss;\n  ss << s;\n  ss >> res;\n  return res;\n}\n\nbool is_op(char c){\n  return\n    c == '+' ||\n    c == '-' ||\n    c == '*' ||\n    c == '/';\n}\n\nset<int> calc_op(char op, set<int> set1, set<int> set2){\n  set<int> res;\n  for(auto itr1 = set1.begin(); itr1 != set1.end();++itr1){\n    for(auto itr2 = set2.begin(); itr2 != set2.end();++itr2){\n      if(op == '+'){\n\tres.insert((*itr1) + (*itr2));\n      }else if(op == '-'){\n\tres.insert((*itr1) - (*itr2));\n      }else if(op == '*'){\n\tres.insert((*itr1) * (*itr2));\n      }else if(op == '/'){\n\tif((*itr2) != 0){\n\t  res.insert((*itr1) / (*itr2));\n\t}\n      }\t\n    }\n  }\n  return res;\n}\n\nset<int> solve(string s){\n  vector< vector<set<int>>> dp;\n  vector< char > op;\n  dp.resize(20);\n  for(int i = 0;i < 20;++i){\n    dp[i].resize(20);       \n  }\n  int len = (int)s.size(),size = 0,p = 0;\n  while(p < len){\n    if(s[p] == '('){\n      int q = p+1;\n      while(s[q] != ')')++q;\n      string elem = s.substr(p+1,q-p-1);\n      dp[size][size] = solve(elem);\n      ++size;\n      p = q;\n    }else if(is_op(s[p])){\n      op.push_back(s[p]);\n    }else{\n      int q = p+1;\n      while(q < len && '0' <= s[q] && s[q] <= '9')++q;\n      string elem = s.substr(p,q-p);\n      int num = to_int(elem);\n      dp[size][size].insert(num);\n      ++size;\n      p = q-1;\n    }\n    ++p;\n  }\n  for(int step = 1;step < size;++step){\n    for(int i = 0;i + step < size;++i){\n      int j = i + step;\n      set<int> set1 = calc_op(op[j-1],dp[i][j-1],dp[j][j]);\n      set<int> set2 = calc_op(op[i],dp[i][i],dp[i+1][j]);\n      if(step != 1){\n\tfor(auto itr = set2.begin();itr != set2.end();++itr){\n\t  set1.insert(*itr);\n\t}\n      }\n      dp[i][j] = set1;\n    }\n  }\n  set<int> ans = dp[0][size-1];\n  return dp[0][size-1];\n}\n\nint main(){\n  string s;\n  while(cin >> s,s != \"#\"){\n    set<int> res = solve(s);\n    cout << (int)res.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n// Created by 拓真 on 2018/07/05.\n//\n\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef string::const_iterator State;\nclass ParseError{};\n\nvoid consume(State &begin,char expected){\n    if(*begin==expected){\n        begin++;\n    }else{\n        cerr<<\"Expected \"<<expected<<\"but got\"<<*begin<<endl;\n        cerr<<\"Rest String is\";\n        while(*begin){\n            cerr<<*begin;\n        }\n        cerr<<endl;\n        throw ParseError();\n    }\n}\n\n\n\nset<int> expression(State &begin){\n\n    set<int> ret;\n    set<int> par;\n\n\n    if(isdigit(*begin)){\n        int num0=*begin;\n        begin++;\n        if(*begin=='+'){\n            begin++;\n            if(*begin=='('){\n                consume(begin,'(');\n                par=expression(begin);\n                consume(begin,')');\n            }else {\n                if(isdigit(*begin)) {\n                    par.insert(*begin);\n                }\n            }\n\n        }else if(*begin=='-'){\n            begin++;\n            if(*begin=='('){\n                consume(begin,'(');\n                par=expression(begin);\n                consume(begin,')');\n            }else {\n                if(isdigit(*begin)) {\n                    par.insert(*begin);\n                }\n            }\n\n\n        }else if(*begin=='*'){\n            begin++;\n            if(*begin=='('){\n                consume(begin,'(');\n                par=expression(begin);\n                consume(begin,')');\n            }else {\n                if(isdigit(*begin)) {\n                    par.insert(*begin);\n                }\n            }\n\n        }else if(*begin =='/'){\n            begin++;\n            if(*begin=='('){\n                consume(begin,'(');\n                par=expression(begin);\n                consume(begin,')');\n            }else {\n                if(isdigit(*begin)) {\n                    par.insert(*begin);\n                }else{\n                    throw ParseError();\n\n                }\n            }\n\n\n\n        }\n\n    }else{\n        throw ParseError();\n    }\n\n\n    vector<int> vec;\n    for(int i=0;i<par.size();i++){\n        vec.push_back(i);\n    }\n\n    do{\n\n        par[vec]\n\n    }while(vec.begin(),vec.end());\n\n\n\n    return ret;\n\n}\n\n\nint main(){\n\n\n    string s;\n    while(cin>>s){\n        if(s[0]=='#')break;\n        State begin=s.begin();\n\n        set<int>ans=expression(begin);\n        cout<<ans.size()<<endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define rep2(i,a,b) for(ll i=(a);i<(b);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\nstring s;\n\nbool isop(char ch){\n    if(ch=='+' || ch=='-' || ch=='*' || ch=='/')return true;\n    else return false;\n}\n\nvoid mul(const set<int> &a, const set<int> &b, char op, set<int> &ret){\n    for(auto e1:a){\n        for(auto e2:b){\n            if(op=='+')ret.insert(e1+e2);\n            if(op=='-')ret.insert(e1-e2);\n            if(op=='*')ret.insert(e1*e2);\n            if(op=='/'){\n                if(e2==0)continue;\n                ret.insert(e1/e2);\n            }\n        }\n    }\n}\n\nset<int> dfs(int l, int r){\n    vector<int> br(300,-1);\n    stack<int> stk;\n    for(int i=l;i<r;i++){\n        if(s[i]=='(')stk.push(i);\n        else if(s[i]==')'){\n            assert(stk.size());\n            br[stk.top()] = i;\n            stk.pop();\n        }\n    }\n    for(int i=l;i<r;i++){\n        if( br[i]!=-1 && br[i]==r-1){\n            l++,r--;\n        }else break;\n    }\n    \n    set<int> ret;\n    int c = 0;\n    \n    bool ops=false;\n    for(int i=l;i<r;i++){\n        if(s[i]=='(')c++;\n        else if(s[i]==')')c--;\n        else if( isop(s[i]) && c==0 ){\n            ops = true;\n            mul( dfs(l,i) , dfs(i+1,r), s[i], ret);\n        }\n    }\n    \n    if(!ops)ret = set<int>{stoi(s.substr(l,r-l))};\n    \n    return ret;\n}\n\nint main(){\n    while(cin>>s && s!=\"#\"){\n        set<int> res = dfs(0,s.size());\n        cout<<res.size()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\nstring line;\n\ninline bool isOp(char c) {\n  return c == '+' || c == '-' || c == '*' || c == '/';\n}\n\nset<int> rec(int l, int r) {\n  vector<int> v;\n  for(int i = l, j = 0; i < r; ++i) {\n    if(line[i] == '(') ++j;\n    if(line[i] == ')') --j;\n    if(j == 0 && isOp(line[i])) v.push_back(i);\n  }\n\n  if(v.size() == 0) {\n    if(line[l] == '(') return rec(l+1, r-1);\n    set<int> res;\n    res.insert(atoi(line.substr(l,r-l).c_str()));\n    return res;\n  }\n\n  set<int> res;\n  for(int i = 0; i < v.size(); ++i) {\n    set<int> a, b;\n    a = rec(l, v[i]);\n    b = rec(v[i]+1, r);\n    for(set<int>::iterator p = a.begin();\n        p != a.end(); ++p) {\n      for(set<int>::iterator q = b.begin();\n          q != b.end(); ++q) {\n        if(line[v[i]] == '+') {\n          res.insert(*p + *q);\n        } else if(line[v[i]] == '-') {\n          res.insert(*p - *q);\n        } else if(line[v[i]] == '*') {\n          res.insert(*p * *q);\n        } else if(line[v[i]] == '/') {\n          if(*q != 0) res.insert(*p / *q);\n        }\n      }\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(getline(cin, line) && line != \"#\") {\n    cout << rec(0, line.size()).size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nstring st;\n\nint getnum( int l) {\n\tint num = 0;\n\twhile (isdigit(st[l])) {\n\t\tnum = num * 10 + st[l] - '0';\n\t\tl++;\n\t}\n\treturn num;\n\n}\nint calc(const int a,const int b,const char type) {\n\tif (type == '+')return a + b;\n\telse if (type == '-')return a - b;\n\telse if (type == '*')return a*b;\n\telse {\n\t\tif (b)return a / b;\n\t\telse {\n\t\t\tthrow(false);\n\t\t}\n\t}\n}\n\nset<int> getexpr(const int l,const int r) {\n\tset <int>aset;\n\tif (l > r)assert(false);\n\tif (st[l] == '('&&st[r] == ')') {\n\t\tint depth = 0;\n\t\tbool kakko = true;\n\t\tfor (int x = l; x <= r; ++x) {\n\t\t\tif (st[x] == '(') {\n\t\t\t\tdepth++;\n\t\t\t}\n\t\t\telse if (st[x] == ')') {\n\t\t\t\tdepth--;\n\t\t\t}\n\t\t\tif (!depth&&x != r)kakko = false;\n\t\t}\n\t\tif (kakko) {\n\n\t\t\treturn getexpr(l + 1, r - 1);\n\t\t}\n\t}\n\tint depth = 0;\n\tbool flag = false;\n\tfor (int x = l; x <= r; ++x) {\n\t\tif (st[x] == '(') {\n\t\t\tdepth++;\n\t\t}\n\t\telse if (st[x] == ')') {\n\t\t\tdepth--;\n\t\t}\n\t\telse if (st[x] == '+' || st[x] == '-' || st[x] == '*' || st[x] == '/') {\n\t\t\tif (!depth) {\n\t\t\t\tflag = true;\n\t\t\t\tconst set<int> lset = getexpr(l, x - 1);\n\t\t\t\tconst set<int> rset = getexpr(x + 1, r);\n\t\t\t\tfor (auto a : lset) {\n\t\t\t\t\tfor (auto b : rset) {\n\t\t\t\t\t\tif (st[x] == '/'&&!b)continue;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\taset.emplace(calc(a, b, st[x]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!flag) {\n\t\tif (st[l] == '(')return getexpr(l + 1, r - 1);\n\t\taset.emplace(getnum(l));\n\t}\n\treturn aset;\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> st;\n\t\tif (st == \"#\")break;\n\t\tset<int>aset;\n\t\tbool ok = true;\n\t\ttry {\n\t\t\taset=getexpr(0,st.size()-1);\n\t\t}\n\t\tcatch (...) {\n\t\t\tassert(false);\n\t\t\tok = false;\n\t\t}\n\t\t\n\t\tcout << aset.size() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<string>\n#include<iostream>\n\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nset<int> operator+(const set<int> &S,const set<int> &T){\n\tset<int> U;\n\tset<int>::iterator it1,it2;\n\tfor(it1=S.begin();it1!=S.end();++it1) for(it2=T.begin();it2!=T.end();++it2)\n\t\tU.insert(*it1 + *it2);\n\treturn U;\n}\n\nset<int> operator-(const set<int> &S,const set<int> &T){\n\tset<int> U;\n\tset<int>::iterator it1,it2;\n\tfor(it1=S.begin();it1!=S.end();++it1) for(it2=T.begin();it2!=T.end();++it2)\n\t\tU.insert(*it1 - *it2);\n\treturn U;\n}\n\nset<int> operator*(const set<int> &S,const set<int> &T){\n\tset<int> U;\n\tset<int>::iterator it1,it2;\n\tfor(it1=S.begin();it1!=S.end();++it1) for(it2=T.begin();it2!=T.end();++it2)\n\t\tU.insert(*it1 * *it2);\n\treturn U;\n}\n\nset<int> operator/(const set<int> &S,const set<int> &T){\n\tset<int> U;\n\tset<int>::iterator it1,it2;\n\tfor(it1=S.begin();it1!=S.end();++it1) for(it2=T.begin();it2!=T.end();++it2)\n\t\tif(*it2!=0) U.insert(*it1 / *it2);\n\treturn U;\n}\n\nstring expr;\n\nset<int> solve(int il,int ir){\n\tset<int> ans;\n\n\t// ツつキツづ猟づ青板篠堋づ個湘ェツ債、ツつサツづ個青板篠堋つセツつッツつゥツづァツづ按づゥツ集ツ債づーツ陛板つキ\n\tbool alldgt=true;\n\tfor(int i=il;i<ir;i++) if(!isdigit(expr[i])) { alldgt=false; break; }\n\tif(alldgt){\n\t\tint num=0;\n\t\tfor(int i=il;i<ir;i++) num=10*num+(expr[i]-'0');\n\t\tans.insert(num);\n\t\treturn ans;\n\t}\n\n\t// (expression) ツづつ「ツつ、ツ形ツづ個湘ェツ債、( ) ツづーツづ債つクツつキ\n\tif(expr[il]=='('){\n\t\tbool allprn=true;\n\t\tfor(int i=il,depth=0;i<ir;i++){\n\t\t\tif     (expr[i]=='(') depth++;\n\t\t\telse if(expr[i]==')') depth--;\n\t\t\tif(i<ir-1 && depth==0){ allprn=false; break; }\n\t\t}\n\t\tif(allprn) return solve(il+1,ir-1);\n\t}\n\t\n\tint depth=0;\n\tfor(int i=il;i<ir;i++){\n\t\tif     (expr[i]=='(') depth++;\n\t\telse if(expr[i]==')') depth--;\n\t\tif(depth!=0) continue;\n\n\t\tset<int> tmp;\n\t\tswitch(expr[i]){\n\t\t\tcase '+': tmp=solve(il,i)+solve(i+1,ir); break;\n\t\t\tcase '-': tmp=solve(il,i)-solve(i+1,ir); break;\n\t\t\tcase '*': tmp=solve(il,i)*solve(i+1,ir); break;\n\t\t\tcase '/': tmp=solve(il,i)/solve(i+1,ir); break;\n\t\t}\n\t\tif(tmp.size()>0) ans.insert(all(tmp));\n\t}\n\treturn ans;\n}\n\nint main(){\n\tfor(;cin>>expr,expr!=\"#\";) cout<<solve(0,expr.length()).size()<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nstring S;\nstring op = \"+-*/\";\n\nset<int> parse(int l, int r) { // [l, r)\n  set<int> res;\n  int depth = 0;\n  for (int i = l; i < r; i++) {\n    depth += (S[i] == '(') - (S[i] == ')');\n    if (depth) continue;\n    if (op.find(S[i]) == string::npos) continue;\n    set<int> a = parse(l, i), b = parse(i + 1, r);\n    for (auto &x : a)\n      for (auto &y : b) {\n        if (S[i] == '+') res.emplace(x + y);\n        if (S[i] == '-') res.emplace(x - y);\n        if (S[i] == '*') res.emplace(x * y);\n        if (S[i] == '/' && y) res.emplace(x / y);\n      }\n  }\n  if (res.size()) return res;\n  if (S[l] == '(' && S[r - 1] == ')') return parse(l + 1, r - 1);\n  int x = 0;\n  while (l < r) x = x * 10 + S[l++] - '0';\n  return {x};\n}\n\nmain {\n  while (cin >> S, S != \"#\") cout << parse(0, S.size()).size() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//56\n#include<iostream>\n#include<set>\n#include<algorithm>\n#include<cstdio>\n#include<cctype>\n#include<vector>\n#include<cstdlib>\n\nusing namespace std;\n\nset<int> cs(vector<set<int> > n,vector<char> o){\n  if(o.empty()){\n    return n[0];\n  }else{\n    set<int> st;\n    for(int i=0;i<o.size();i++){\n      set<int> l=cs(vector<set<int> > (n.begin(),n.begin()+i+1),vector<char> (o.begin(),o.begin()+i));\n      set<int> r=cs(vector<set<int> > (n.begin()+i+1,n.end()),vector<char> (o.begin()+i+1,o.end()));\n      for(set<int>::iterator k=l.begin();k!=l.end();k++){\n\tfor(set<int>::iterator j=r.begin();j!=r.end();j++){\n\t  if(o[i]=='+'){\n\t    st.insert(*k+*j);\n\t  }else if(o[i]=='-'){\n\t    st.insert(*k-*j);\n\t  }else if(o[i]=='*'){\n\t    st.insert(*k**j);\n\t  }else if(*j){\n\t    int r=abs(*k)/abs(*j);\n\t    st.insert((*k**j<0)?-r:r);\n\t  }\n\t}\n      }\n    }\n    return st;\n  }\n}\n\nset<int> exp(char *s){\n  vector<set<int> > n;\n  vector<char> o;\n  for(int i=0;s[i];){\n    if(isdigit(s[i])){\n      int d,r;\n      sscanf(s+i,\"%d%n\",&d,&r);\n      i+=r;\n      set<int> ss;\n      ss.insert(d);\n      n.push_back(ss);\n    }else if(s[i]!='('){\n      o.push_back(s[i]);\n      i++;\n    }else{\n      int bc=1;\n      int j;\n      for(j=i+1;bc;j++){\n\tbc+=(s[j]=='(')-(s[j]==')');\n      }\n      char ns[201]={};\n      copy(s+i+1,s+j-1,ns);\n      n.push_back(exp(ns));\n      i=j;\n    }\n  }\n  return cs(n,o);\n}\n \nint main(){\n  char s[201];\n  while(cin>>s,s[0]!='#'){\n    cout<<exp(s).size()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <algorithm>\n#include <climits>\n#include <vector>\nusing namespace std;\n\nint pos;\nstring line;\nstring table = \"+/*-\";\n \nvoid view(set<int> a){\n\tfor(set<int>::iterator it = a.begin() ; it != a.end() ; ++it){\n\t\tcout << *it << \" \";\n\t}\n\tcout << endl;\n}\nint mcalc(int a,int b,char c){\n\tswitch(c){\n\t\tcase '+': return a+b;\n\t\tcase '-': return a-b;\n\t\tcase '*': return a*b;\n\t\tcase '/': return b?a/b:INT_MAX;\n\t}\n}\nset<int> real(vector<int> num,vector<char> &op){\n\tvector<int> src = num;\n\tint o[] = {0,1,2,3,4,5,6,7,8,9} , n = op.size();\n\tset<int> answer;\n\tdo{\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint p = o[i];\n\t\t\tint r = mcalc(num[p],num[p+1],op[p]);\n\t\t\tif(r == INT_MAX) goto fail;\n\t\t\tnum[p] = num[p+1] = r;\n\t\t}\n\t\tanswer.insert(num[o[n-1]]);\n\t\tfail:;\n\t\tnum = src;\n\t}while(next_permutation(o,o+n));\n\t//cout << answer.size() << \" |\" ; view(answer);\n\treturn answer;\n}\n\nvector< vector<int> > var;\nvector<int> current;\nvoid func(vector<int> &cur,vector< set<int> > &num){\n\tif(cur.size() == num.size()){\n\t\tvar.push_back(cur);\n\t}else{\n\t\tint p = cur.size();\n\t\tfor(set<int>::iterator it = num[p].begin() ; it != num[p].end() ; ++it){\n\t\t\tcur.push_back(*it);\n\t\t\tfunc(cur,num);\n\t\t\tcur.pop_back();\n\t\t}\n\t}\n}\n\nset<int> calc(vector< set<int> > num,vector<char> op){\n\tvar.clear();\n\tcurrent.clear();\n\tfunc(current,num);\n\tset<int> answer;\n\tfor(int i = 0 ; i < var.size() ; i++){\n\t\tset<int> result = real(var[i],op);\n\t\tanswer.insert(result.begin(),result.end());\n\t}\n\treturn answer;\n}\nset<int> go(){\n\tint cur = 0;\n\tvector< set<int> > num;\n\tvector<char> op;\n\twhile(1){\n\t\tchar c = line[pos++];\n\t\tif( c== '('){\n\t\t\tnum.push_back(go());\n\t\t}if(c == ')'){\n\t\t\treturn calc(num,op);\n\t\t}else if(table.find(c) != -1){\n\t\t\top.push_back(c);\n\t\t}else{\n\t\t\tint number = c-'0';\n\t\t\twhile(line[pos] >= '0' && line[pos] <= '9') number = number * 10 + line[pos] - '0' , pos++;\n\t\t\tset<int> add;\n\t\t\tadd.insert(number);\n\t\t\tnum.push_back(add);\n\t\t}\n\t}\n}\nint main(){\n\twhile(getline(cin,line) && line != \"#\"){\n\t\tpos = 0;\n\t\tline += \")\";\n\t\tcout << go().size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < int(n); ++i)\n#define all(a) (a).begin(),(a).end()\n\nbool is_op(char c){\n    return c=='+' || c=='-' || c=='*' || c=='/';\n}\n\nint operate(int &e1,int &e2,char &op){\n    if(op == '+') return e1+e2;\n    if(op == '-') return e1-e2;\n    if(op == '*') return e1*e2;\n    if(op == '/') return e1/e2;\n    assert(false);\n}\n\nset<int> calc(vector<set<int>> Es, vector<char> &ops, vector<int> &perm){\n    int n = perm.size();\n    if(n == 0){\n        return Es[0];\n    }\n    vector<bool> done(n);\n    rep(i,n){\n        int p = perm[i];\n        set<int> E;\n        char op = ops[p];\n        for(int e1 : Es[p]){\n            for(int e2 : Es[p+1]){\n                if(op == '/' && e2 == 0) continue;\n                E.insert(operate(e1,e2,op));\n            }\n        }\n        done[p] = true;\n        Es[p] = E;\n        Es[p+1] = E;\n        int l = p-1, r = p+1;\n        while(l>=0 && done[l]){\n            Es[l] = E;\n            l--;\n        }\n        while(r<n && done[r]){\n            Es[r+1] = E;\n            r++;\n        }\n    }\n    return Es[0];\n}\n\nset<int> all_check(vector<set<int>> &Es, vector<char> &ops){\n    int n = ops.size();\n    vector<int> perm(n);\n    rep(i,n){\n        perm[i] = i;\n    }\n\n    set<int> res;\n    do{\n        set<int> tmp = calc(Es,ops,perm);\n        for(int t : tmp){\n            res.insert(t);\n        }\n    }while(next_permutation(all(perm)));\n    return res;\n}\n\n\nset<int> eval(string &s, int &i){\n    vector<set<int>> Es;\n    vector<char> ops;\n    while(1){\n        if(isdigit(s[i])){\n            set<int> res;\n            int num = 0;\n            while(isdigit(s[i])){\n                num = num*10 + s[i]-'0';\n                i++;\n            }\n            res.insert(num);\n            Es.push_back(res);\n        }else if(s[i] == '('){\n            i++; // (\n            Es.push_back(eval(s,i));\n            i++; // )\n        }\n\n        if(i == (int)s.size()) break;\n        if(is_op(s[i])){\n            ops.push_back(s[i]);\n            i++;\n        }else{\n            break;\n        }\n    }\n    return all_check(Es,ops);\n\n}\n\nint main(){\n    string s;\n    while(cin>>s, s!=\"#\"){\n        int index = 0;\n        cout<<eval(s, index).size()<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <algorithm>\n#include <climits>\n#include <vector>\nusing namespace std;\n\nint pos;\nstring line;\nstring table = \"+/*-\";\n \nvoid view(set<int> a){\n\tfor(set<int>::iterator it = a.begin() ; it != a.end() ; ++it){\n\t\tcout << *it << \" \";\n\t}\n\tcout << endl;\n}\nint mcalc(int a,int b,char c){\n\tswitch(c){\n\t\tcase '+': return a+b;\n\t\tcase '-': return a-b;\n\t\tcase '*': return a*b;\n\t\tcase '/': return b?a/b:INT_MAX;\n\t}\n}\nset<int> real(vector<int> num,vector<char> &op){\n\tvector<int> src = num;\n\tint o[] = {0,1,2,3,4,5,6,7,8,9} , n = op.size();\n\tset<int> answer;\n\tdo{\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint p = o[i];\n\t\t\tint r = mcalc(num[p],num[p+1],op[p]);\n\t\t\tif(r == INT_MAX) goto fail;\n\t\t\tnum[p] = num[p+1] = r;\n\t\t}\n\t\tanswer.insert(num[o[n-1]]);\n\t\tfail:;\n\t\tnum = src;\n\t}while(next_permutation(o,o+n));\n\t//for(int i = 0 ; i <= n ; i++) cout << num[i] << \" \";cout << endl;\n\t//cout << answer.size() << \" |\" ; view(answer);\n\treturn answer;\n}\n\nvector< vector<int> > var;\nvector<int> current;\nvoid func(vector<int> &cur,vector< set<int> > &num){\n\tif(cur.size() == num.size()){\n\t\tvar.push_back(cur);\n\t}else{\n\t\tint p = cur.size();\n\t\tfor(set<int>::iterator it = num[p].begin() ; it != num[p].end() ; ++it){\n\t\t\tcur.push_back(*it);\n\t\t\tfunc(cur,num);\n\t\t\tcur.pop_back();\n\t\t}\n\t}\n}\n\nset<int> calc(vector< set<int> > num,vector<char> op){\n\tvar.clear();\n\tcurrent.clear();\n\tfunc(current,num);\n\t\n\tset<int> answer;\n\tfor(int i = 0 ; i < var.size() ; i++){\n\t\tset<int> result = real(var[i],op);\n\t\tanswer.insert(result.begin(),result.end());\n\t}\n\treturn answer;\n}\nset<int> go(int depth){\n\tint cur = 0;\n\tvector< set<int> > num;\n\tvector<char> op;\n\twhile(1){\n\t\t//cout << depth << \":\" << pos << \" \" << line[pos] << \" \" << num.size() << endl;\n\t\tchar c = line[pos++];\n\t\tif( c== '('){\n\t\t\tnum.push_back(go(depth+1));\n\t\t}else if(c == ')'){\n\t\t\t//cout << \"[\" << depth << endl;\n\t\t\t//for(int i = 0 ; i < op.size() ; i++)\n\t\t\t//\tcout << op[i] << \" \" ; cout << endl;\n\t\t\t//for(int i = 0 ; i < num.size() ; i++)\n\t\t\t//\tcout << num[i].size() << \" \" ; cout << endl;\n\t\t\tif(num.size() == 1) return num[0];\n\t\t\telse return calc(num,op);\n\t\t}else if(table.find(c) != -1){\n\t\t\top.push_back(c);\n\t\t}else{\n\t\t\tint number = c-'0';\n\t\t\t//cout << c << endl;\n\t\t\twhile(line[pos] >= '0' && line[pos] <= '9') number = number * 10 + line[pos] - '0' , pos++;\n\t\t\tset<int> add;\n\t\t\tadd.insert(number);\n\t\t\tnum.push_back(add);\n\t\t}\n\t}\n}\nint main(){\n\twhile(getline(cin,line) && line != \"#\"){\n\t\tpos = 0;\n\t\tline += \")\";\n\t\tcout << go(0).size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <string>\n#include <iostream>\nusing namespace std;\nstring s;\nset<int> expr(int l, int r) {\n\tint cnt = 0;\n\tfor (int i = l; i < r; i++) {\n\t\tif (s[i] < 48 || 57 < s[i]) cnt++;\n\t}\n\tif (cnt == 0) return set<int>({ stoi(s.substr(l, r - l)) });\n\tset<int> ret;\n\tint depth = 0, cnt2 = 0;\n\tfor (int i = l; i < r; i++) {\n\t\tif (s[i] == '(') depth++;\n\t\tif (s[i] == ')') depth--;\n\t\tif (depth == 0) cnt2++;\n\t\tif (depth == 0 && (s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/')) {\n\t\t\tset<int> r1 = expr(l, i);\n\t\t\tset<int> r2 = expr(i + 1, r);\n\t\t\tif (s[i] == '+') {\n\t\t\t\tfor (int j : r1) {\n\t\t\t\t\tfor (int k : r2) {\n\t\t\t\t\t\tret.insert(j + k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[i] == '-') {\n\t\t\t\tfor (int j : r1) {\n\t\t\t\t\tfor (int k : r2) {\n\t\t\t\t\t\tret.insert(j - k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[i] == '*') {\n\t\t\t\tfor (int j : r1) {\n\t\t\t\t\tfor (int k : r2) {\n\t\t\t\t\t\tret.insert(j * k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[i] == '/') {\n\t\t\t\tfor (int j : r1) {\n\t\t\t\t\tfor (int k : r2) {\n\t\t\t\t\t\tif (k == 0) continue;\n\t\t\t\t\t\tif (j > 0) ret.insert(j / k);\n\t\t\t\t\t\telse ret.insert(-((-j) / k));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (cnt2 == 1) return expr(l + 1, r - 1);\n\treturn ret;\n}\nint main() {\n\twhile (cin >> s, s != \"#\") {\n\t\tset<int> ret = expr(0, s.size());\n\t\tcout << ret.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint to_int(string s){\n  int res;\n  stringstream ss;\n  ss << s;\n  ss >> res;\n  return res;\n}\n\nbool is_op(char c){\n  return\n    c == '+' ||\n    c == '-' ||\n    c == '*' ||\n    c == '/';\n}\n\nset<int> calc_op(char op, set<int> set1, set<int> set2){\n  set<int> res;\n  for(auto itr1 = set1.begin(); itr1 != set1.end();++itr1){\n    for(auto itr2 = set2.begin(); itr2 != set2.end();++itr2){\n      if(op == '+'){\n\tres.insert((*itr1) + (*itr2));\n      }else if(op == '-'){\n\tres.insert((*itr1) - (*itr2));\n      }else if(op == '*'){\n\tres.insert((*itr1) * (*itr2));\n      }else if(op == '/'){\n\tif((*itr2) != 0){\n\t  res.insert((*itr1) / (*itr2));\n\t}\n      }\t\n    }\n  }\n  return res;\n}\n\nset<int> solve(string s){\n  vector< vector<set<int>>> dp;\n  vector< char > op;\n  dp.resize(20);\n  for(int i = 0;i < 20;++i){\n    dp[i].resize(20);       \n  }\n  int len = (int)s.size(),size = 0,p = 0;\n  while(p < len){\n    if(s[p] == '('){\n      int q = p+1;\n      int balance = 1;\n      while(1){\n\tif(s[q] == '('){\n\t  ++balance;\n\t}else if(s[q] == ')'){\n\t  --balance;\n\t  if(balance == 0)break;\n\t}\n\t++q;\n      }\n      string elem = s.substr(p+1,q-p-1);\n      dp[size][size] = solve(elem);\n      ++size;\n      p = q;\n    }else if(is_op(s[p])){\n      op.push_back(s[p]);\n    }else{\n      int q = p+1;\n      while(q < len && '0' <= s[q] && s[q] <= '9')++q;\n      string elem = s.substr(p,q-p);\n      int num = to_int(elem);\n      dp[size][size].insert(num);\n      ++size;\n      p = q-1;\n    }\n    ++p;\n  }\n  for(int step = 1;step < size;++step){\n    for(int i = 0;i + step < size;++i){\n      int j = i + step;\n      set<int> set1 = calc_op(op[j-1],dp[i][j-1],dp[j][j]);\n      set<int> set2 = calc_op(op[i],dp[i][i],dp[i+1][j]);\n      if(step != 1){\n\tfor(auto itr = set2.begin();itr != set2.end();++itr){\n\t  set1.insert(*itr);\n\t}\n      }\n      dp[i][j] = set1;\n    }\n  }\n  set<int> ans = dp[0][size-1];\n  return dp[0][size-1];\n}\n\nint main(){\n  string s;\n  while(cin >> s,s != \"#\"){\n    set<int> res = solve(s);\n    cout << (int)res.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int INF = 1e9;\nint N, M;\nint opPos[10];\nint depth[10];\nint num[10];\nstring s;\nset<int> ans;\nint c;\n\nbool isOperator(char c) {\n\treturn c == '+' || c == '-' || c == '*' || c == '/';\n}\n\nvoid dfs(int d) {\n\twhile(c < N && s[c] != ')') {\n\t\tif(s[c] == '(') {\n\t\t\tc++;\n\t\t\tdfs(d + 1);\n\t\t\tassert(s[c] == ')');\n\t\t}\n\t\tif(isOperator(s[c])) {\n\t\t\tfor(int i = 0; i < M; i++) {\n\t\t\t\tif(opPos[i] == c) depth[i] = d;\n\t\t\t}\n\t\t}\n\t\tc++;\n\t}\n}\n\nint findMinPos(int l, int r) {\n\tint minId = -1;\n\tfor(int i = 0; i < M; i++) {\n\t\tif(l <= opPos[i] && opPos[i] <= r) {\n\t\t\tif(minId == -1 || num[minId] > num[i]) minId = i;\n\t\t}\n\t}\n\tif(minId == -1) return -1;\n\treturn opPos[minId];\n}\n\nint R(double n) {\n\tdouble an = abs(n);\n\tint ret = round(an - 1e-9);\n\tif(n < 0) ret *= -1;\n\treturn ret;\n}\n\nint f(int l, int r) {\n\tint minPos = findMinPos(l, r);\n\tif(minPos == -1) {\n\t\tint ret = 0;\n\t\tif(s[l] == '(') l++;\n\t\tif(s[r] == ')') r--;\n\t\tfor(int i = l; i <= r; i++) {\n\t\t\tret = ret * 10 + s[i] - '0';\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint vl = f(l, minPos - 1), vr = f(minPos + 1, r);\n\tif(vl == INF || vr == INF) return INF;\n\tchar op = s[minPos];\n\tif(op == '+') return vl + vr;\n\tif(op == '-') return vl - vr;\n\tif(op == '*') return vl * vr;\n\tif(vr == 0) return INF;\n\tint ret = R((double)vl / vr);\n\treturn ret;\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> s, s != \"#\") {\n\t\tN = s.size();\n\t\tM = 0;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tif(isOperator(s[i])) {\n\t\t\t\topPos[M] = i;\n\t\t\t\tdepth[M] = 0;\n\t\t\t\tM++;\n\t\t\t}\n\t\t}\n\t\tc = 0;\n\t\tdfs(0);\n\n\t\tvector<int> p(M);\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tp[i] = i;\n\t\t}\n\n\t\tans.clear();\n\t\tdo {\n\t\t\tfor(int i = 0; i < M; i++) {\n\t\t\t\tnum[i] = p[i] + depth[i] * 100;\n\t\t\t}\n\t\t\tint res = f(0, N - 1);\n\t\t\tif(res != INF) ans.insert(res);\n\t\t} while(next_permutation(p.begin(), p.end()));\n\n\t\tcout << ans.size() << endl;\n\t\tfor(auto a : ans) {\n\t\t\tcout << a << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nstring S;\nstring op = \"+-*/\";\n\nset<int> parse(int l, int r) {\n  set<int> res;\n  int depth = 0;\n  for (int i = l; i < r; i++) {\n    depth += (S[i] == '(') - (S[i] == ')');\n    if (depth) continue;\n    if (op.find(S[i]) == string::npos) continue;\n    set<int> a = parse(l, i), b = parse(i + 1, r);\n    for (auto &x : a)\n      for (auto &y : b) {\n        if (S[i] == '+') res.emplace(x + y);\n        if (S[i] == '-') res.emplace(x - y);\n        if (S[i] == '*') res.emplace(x * y);\n        if (S[i] == '/' && y) res.emplace(x / y);\n      }\n  }\n  if (res.size()) return res;\n  int x = 0;\n  while (l < r) x = x * 10 + S[l++] - '0';\n  return {x};\n}\n\nmain {\n  while (cin >> S, S != \"#\") cout << parse(0, S.size()).size() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define rep2(i,a,b) for(ll i=(a);i<(b);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\nstring s;\n\nbool isop(char ch){\n    if(ch=='+' || ch=='-' || ch=='*' || ch=='/')return true;\n    else return false;\n}\n\nvoid mul(const set<int> &a, const set<int> &b, char op, set<int> &ret){\n    for(auto e1:a){\n        for(auto e2:b){\n            if(op=='+')ret.insert(e1+e2);\n            if(op=='-')ret.insert(e1-e2);\n            if(op=='*')ret.insert(e1*e2);\n            if(op=='/'){\n                if(e2==0)continue;\n                ret.insert(e1/e2);\n            }\n        }\n    }\n}\n\nset<int> dfs(int l, int r){\n    while(s[l]=='(' && s[r-1]==')'){\n        l++,r--;\n    }\n    set<int> ret;\n    int c = 0;\n    \n    bool ops=false;\n    for(int i=l;i<r;i++){\n        if(s[i]=='(')c++;\n        else if(s[i]==')')c--;\n        else if( isop(s[i]) && c==0 ){\n            ops = true;\n            mul( dfs(l,i) , dfs(i+1,r), s[i], ret);\n        }\n    }\n    if(!ops)return set<int>{stoi(s.substr(l,r-l))};\n    return ret;\n}\n\nint main(){\n    while(cin>>s && s!=\"#\"){\n        set<int> res = dfs(0,s.size());\n        cout<<res.size()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nset<int> ans;\nstring line; \nint len;\n\nint apply(char opr, int a, int b) {\n    if (opr == '+') return a + b;\n    if (opr == '-') return a - b;\n    if (opr == '*') return a * b;\n    if (opr == '/') return a / b;\n}\n\nint reduce(stack<int>& N, stack<char>& O) {\n    char opr = O.top(); O.pop();\n    int v = N.top(); N.pop();\n    int w = N.top(); N.pop();\n    if (opr == '/' && !v) return 0;\n    N.push(apply(opr, w, v));\n    return 1;\n}\n\nvoid read(int i, stack<int> N, stack<char> O) {\n    if (i == len) {\n        while (O.size()) if (!reduce(N, O)) return;\n        ans.insert(N.top());\n        return;\n    }\n    if (line[i] >= '0') {\n        int v = 0;\n        while (i < len && line[i] >= '0') v *= 10, v += line[i++] - '0';\n\n        N.push(v);\n        read(i, N, O);\n        while (!O.empty() && O.top() != '(' && reduce(N, O)) read(i, N, O);\n        return;\n    }\n    if (line[i] == ')') {\n        while (O.top() != '(') if (!reduce(N, O)) return;\n        O.pop();\n        read(i+1, N, O);\n        while (!O.empty() && O.top() != '(' && reduce(N, O)) read(i+1, N, O);\n        return;\n    }\n    O.push(line[i]);\n    read(i+1, N, O);\n    return;\n}\n\nint main()\n{\n    while (1) {\n        ans.clear();\n        cin >> line;\n        len = line.length();\n        if (line == \"#\") break;\n        read(0, stack<int>(), stack<char>());\n        cout << ans.size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nstring S;\nint N;\n\nenum Type {\n    Open,\n    Close,\n    Num,\n    Ope,\n    None\n};\n\nstruct Expr {\n    Expr() {\n        right = -1;\n        left = -1;\n        type = None;\n    }\n    Type type;\n\n    int num;\n    char ope;\n\n    int left;\n    int right;\n};\n\nvector<Expr> exprs;\nVI ope_idxes;\n\nPII parse_num(int pos) {\n    string num_s;\n    while (pos < N && isdigit(S[pos])) {\n        num_s += S[pos];\n        ++pos;\n    }\n    return MP(pos, fromString<int>(num_s));\n}\n\nvoid link(int a, int b) {\n    if (a != -1) {\n        exprs[a].right = b;\n    }\n    if (b != -1) {\n        exprs[b].left = a;\n    }\n}\n\nvoid link2(vector<Expr> &es, int a, int b) {\n    if (a != -1) {\n        es[a].right = b;\n    }\n    if (b != -1) {\n        es[b].left = a;\n    }\n}\n\nint make_expr(int before) {\n    Expr cur;\n    int idx = exprs.size();\n    exprs.PB(cur);\n    link(before, idx);\n    return idx;\n}\n\nvoid parse() {\n    exprs.resize(0);\n    ope_idxes.resize(0);\n\n    int before = -1;\n\n    for (int i = 0; i < N; i++) {\n        int cur = make_expr(before);\n        Expr &e = exprs[cur];\n        char c = S[i];\n\n        if (c == '(') {\n            e.type = Open;\n        } else if (c == ')') {\n            e.type = Close;\n        } else if (isdigit(c)) {\n            e.type = Num;\n            PII tmp = parse_num(i);\n            i = tmp.fst - 1; // ?????´\n            e.num = tmp.snd;\n        } else { // ope\n            e.type = Ope;\n            e.ope = c;\n            ope_idxes.PB(cur);\n        }\n\n        before = cur;\n    }\n}\n\nvoid remove_blocks(vector<Expr> &es, int i) {\n    while (true) {\n        int l = es[i].left;\n        int r = es[i].right;\n\n        if (l == -1 || r == -1) return;\n        if (es[l].type != Open || es[r].type != Close) return;\n\n        link2(es, es[l].left, i);\n        link2(es, i, es[r].right);\n    }\n}\n\npair<int, bool> calc(VI &idxes, vector<Expr> es) {\n    int val = es[(int)es.size() / 2].num;\n    \n    for (int i = 0; i < (int)idxes.size(); i++) {\n        int cur = idxes[i];\n        int left = es[cur].left;\n        int right = es[cur].right;\n\n        // ??¬??§??????????????????????????¬??§?????????\n        remove_blocks(es, cur);\n\n        if (es[left].type == Close ||\n            es[right].type == Open ) {\n            return MP(1, false);\n        }\n\n        char ope = es[cur].ope;\n        int a = es[left].num;\n        int b = es[right].num;\n\n        // ?¨????\n        if (ope == '+') {\n            val = a + b;\n        } else if (ope == '-') {\n            val = a - b;\n        } else if (ope == '*') {\n            val = a * b;\n        } else if (ope == '/') {\n            if (b == 0) {\n                return MP(2, false);\n            }\n            val = a / b;\n        }\n\n        // ?????????\n        Expr new_expr;\n        new_expr.num = val;\n        new_expr.type = Num;\n        int new_idx = es.size();\n        es.PB(new_expr);\n        link2(es, es[left].left, new_idx);\n        link2(es, new_idx, es[right].right);\n\n        // ??¬??§??????????????????????????¬??§?????????\n        remove_blocks(es, new_idx);\n    }\n\n    return MP(val, true);\n}\n\nint solve() {\n    parse();\n\n    set<int> anses;\n\n    sort(ALL(ope_idxes));\n\n    do {\n        auto ans = calc(ope_idxes, exprs);\n        if (ans.snd) {\n            anses.insert(ans.fst);\n        }\n    } while (next_permutation(ALL(ope_idxes)));\n\n    return anses.size();\n}\n\nint main(void) {\n    while (cin >> S, S != \"#\") {\n        N = S.size();\n        cout << solve() << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <cctype>\nusing namespace std;\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n\ntypedef string::const_iterator State;\nclass ParseError {};\nset<int> expression(State &begin);\n\n\nset<int> setunion(const set<int> a, const set<int> b){\n\tset<int> ret;\n\tFOR(it1, a) ret.insert(*it1);\n\tFOR(it2, b) ret.insert(*it2);\n\treturn ret;\n}\n\nset<int> calc(const set<int> a, const set<int> b, char op){\n\tset<int> ret;\n\tFOR(it1, a){\n\t\tFOR(it2, b){\n\t\t\tif(op == '+') ret.insert(*it1 + *it2);\n\t\t\tif(op == '-') ret.insert(*it1 - *it2);\n\t\t\tif(op == '*') ret.insert(*it1 * *it2);\n\t\t\tif(op == '/' && *it2) ret.insert(*it1 / *it2);\n\t\t}\n\t}\n\treturn ret;\n}\n\n// beginがexpectedを指していたらbeginを一つ進める。\nvoid consume(State &begin, char expected) {\n\tif (*begin == expected) {\n\t\tbegin++;\n\t} else {\n\t\tcerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n\t\tcerr << \"Rest string is '\";\n\t\twhile (*begin) {\n\t\t\tcerr << *begin++;\n\t\t}\n\t\tcerr << \"'\" << endl;\n\t\tthrow ParseError();\n\t}\n}\n\nint number(State &begin) {\n\tint ret = 0;\n\twhile (isdigit(*begin)) ret = ret*10 + *begin++ - '0';\n\treturn ret;\n}\n\nset<int> factor(State &begin) {\n\tset<int> ret;\n\tif (*begin == '(') {\n\t\tconsume(begin, '(');\n\t\tret = expression(begin);\n\t\tconsume(begin, ')');\n\t}else ret.insert(number(begin));\n\treturn ret;\n}\n\n\nset<int> expression(State &begin) {\n\tset<int> ret;\n\tset<int> tmp = factor(begin);\n\n\tfor (;;) {\n\t\tif(*begin != '+' && *begin != '-' && *begin != '*' && *begin != '/') break;\n\t\tchar op = *begin++;\n\t\tState prev = begin;\n\t\tret = setunion(ret, calc(tmp, expression(begin), op));\n\t\tbegin = prev;\n\t\ttmp = calc(tmp, factor(begin), op);\n\t}\n\t\n\treturn setunion(ret, tmp);\n}\n\nint main(void) {\n\tint N;\n\tstring s;\n\twhile (getline(cin, s), s!=\"#\") {\n\t\tState begin = s.begin();\n\t\tcout << expression(begin).size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000009;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\ntypedef unsigned long long ul;\n\nstring s;\n//j番目の前にi番目\nbool valid[11][10];\nvector<int> num;\nvector<char> ord;\nbool ope(char t) {\n\tif (t == '+' || t == '*' || t == '-' || t == '/')return true;\n\telse return false;\n}\nvoid init() {\n\trep(i, 10) {\n\t\trep(j, 10) {\n\t\t\tvalid[i][j] = true;\n\t\t}\n\t}\n\tnum.clear(); ord.clear();\n\tint n = s.length();\n\trep(i, n) {\n\t\tif (s[i] == '(') {\n\t\t\tint c = ord.size(); int ori = c - 1;\n\t\t\tint j = i + 1;\n\t\t\tint z = 1;\n\t\t\twhile (z) {\n\t\t\t\tif (ope(s[j])) {\n\t\t\t\t\tif (ori >= 0) {\n\t\t\t\t\t\tvalid[c][ori] = false;\n\t\t\t\t\t\t//cout << c << \" \" << ori << endl;\n\t\t\t\t\t}\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\telse if (s[j] == '(')z++;\n\t\t\t\telse if (s[j] == ')')z--;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tRep(k, ord.size(), c) {\n\t\t\t\tvalid[k][c] = false;\n\t\t\t\t//cout << c << \" \" << k << endl;\n\t\t\t}\n\t\t}\n\t\telse if (ope(s[i])) {\n\t\t\tord.push_back(s[i]);\n\t\t}\n\t\telse if ('0' <= s[i] && s[i] <= '9') {\n\t\t\tint memo = i;\n\t\t\twhile (i + 1 < n&&'0' <= s[i + 1] && s[i + 1] <= '9') {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tnum.push_back(stoi(s.substr(memo, i - memo + 1)));\n\t\t}\n\t}\n}\nint m;\nint u[10];\nbool ok() {\n\trep(i, m) {\n\t\tRep(j, i + 1, m) {\n\t\t\tif (!valid[u[j]][u[i]])return false;\n\t\t}\n\t}\n\treturn true;\n}\nbool zerodivi;\nint calc(int a, int b, char t) {\n\tif (t == '+')return a + b;\n\telse if (t == '*')return a * b;\n\telse if (t == '-')return a - b;\n\telse if (t == '/') {\n\t\tif (b == 0) {\n\t\t\tzerodivi = true; return 0;\n\t\t}\n\t\telse {\n\t\t\treturn a / b;\n\t\t}\n\t}\n}\nint ans() {\n\tzerodivi = false;\n\tint cu[10];\n\tvector<int> cnum = num;\n\tvector<char> cord = ord;\n\trep(i, m) {\n\t\tcu[i] = u[i];\n\t}\n\trep(i, m) {\n\t\trep(j, m) {\n\t\t\tif (cu[i] < cu[j])cu[j]--;\n\t\t}\n\t\tint alter = calc(cnum[cu[i]], cnum[cu[i]+1], cord[cu[i]]);\n\t//\tcout << alter << endl;\n\t\tcord.erase(cord.begin() + cu[i]);\n\t\tcnum.erase(cnum.begin() + cu[i]);\n\t\tcnum[cu[i]] = alter;\n\t}\n\treturn cnum[0];\n}\nint main() {\n\twhile (cin >> s) {\n\t\tif (s == \"#\")break; init();\n\t\t//cout << num.size() << \" \" << ord.size() << endl;\n\t\tm = ord.size();\n\t\trep(i, m) {\n\t\t\tu[i] = i;\n\t\t}\n\t\tvector<int> pos;\n\t\twhile (true) {\n\t\t\tif (ok()) {\n\t\t\t//\tcout << \"hello\" << endl;\n\t\t\t\tint z = ans();\n\t\t\t\tif (!zerodivi)pos.push_back(z);\n\t\t\t}\n\t\t\tif (!next_permutation(u, u + m))break;\n\t\t}\n\t\tsort(pos.begin(), pos.end());\n\t\t/*rep(i, pos.size())cout << pos[i] << endl;\n\t\tcout << endl;\n\t\trep(i, num.size())cout << num[i] << endl;\n\t\trep(i, ord.size())cout << ord[i] << endl;*/\n\t\tcout << unique(pos.begin(), pos.end()) - pos.begin() << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nbool cyk[201][201][15];\n\nint main() {\n  while (true) {\n    string s;\n    cin>>s;\n    if (s == \"#\") break;\n    int n = s.size();\n    vector<vector<vector<set<int>>>> dp(n+1, vector<vector<set<int>>>(n+1, vector<set<int>>(15)));\n    REP(i,n+1)REP(j,n+1)REP(k,15) cyk[i][j][k] = false;\n    REP(i,n+1) {\n      cyk[i][0][14] = true;\n    }\n    REP(i,n) {\n      if (isdigit(s[i])) {\n        cyk[i][1][2] = true;\n        dp[i][1][2].insert(s[i] - '0');\n      } else {\n        switch (s[i]) {\n          case '(':\n          cyk[i][1][8] = true;\n          break;\n          case ')':\n          cyk[i][1][9] = true;\n          break;\n          case '+':\n          cyk[i][1][10] = true;\n          break;\n          case '-':\n          cyk[i][1][11] = true;\n          break;\n          case '*':\n          cyk[i][1][12] = true;\n          break;\n          case '/':\n          cyk[i][1][13] = true;\n          break;\n        }\n      }\n    }\n    using T = tuple<int,int,int>;\n    vector<T> rule = {\n      T( 8, 3, 0),\n      T( 0, 4, 0),\n      T( 0, 5, 0),\n      T( 0, 6, 0),\n      T( 0, 7, 0),\n      T( 0, 9, 3),\n      T(10, 0, 4),\n      T(11, 0, 5),\n      T(12, 0, 6),\n      T(13, 0, 7),\n      T( 1, 2, 1),\n      T( 2,14, 1),\n      T( 1,14, 0)\n    };\n     \n    FOR(l,1,n+1)REP(i,n) {\n      FOR(k,1,l+1)REP(m,rule.size()) {\n        int first, second, result;\n        tie(first, second, result) = rule[m];\n        if (cyk[i][k][first] && cyk[i+k][l-k][second]) {\n          cyk[i][l][result] = true;\n          switch(m) {\n            case 0: // <(> + <3>\n            case 6: // <+> + <expr>\n            case 7: // <-> + <expr>\n            case 8: // <*> + <expr>\n            case 9: // </> + <expr>\n              dp[i][l][result] = dp[i+k][l-k][second];\n              break;\n            case 5: // <expr> + <)>\n            case 11: // <digit> + empty\n            case 12: // <num> + empty\n              dp[i][l][result] = dp[i][k][first];\n              break;\n            case 1: // <expr> + <4>\n              for (int x:dp[i][k][first]) {\n                for (int y:dp[i+k][l-k][second]) {\n                  dp[i][l][result].insert(x+y);\n                }\n              }\n              break;\n            case 2: // <expr> + <5>\n              for (int x:dp[i][k][first]) {\n                for (int y:dp[i+k][l-k][second]) {\n                  dp[i][l][result].insert(x-y);\n                }\n              }\n              break;\n            case 3: // <expr> + <6>\n              for (int x:dp[i][k][first]) {\n                for (int y:dp[i+k][l-k][second]) {\n                  dp[i][l][result].insert(x*y);\n                }\n              }\n              break;\n            case 4: // <expr> + <7>\n              for (int x:dp[i][k][first]) {\n                for (int y:dp[i+k][l-k][second]) {\n                  if (y != 0) {\n                    dp[i][l][result].insert(x/y);\n                  }\n                }\n              }\n              break;\n            case 10: // <num> + <digit>\n              dp[i][l][result].insert(\n                  *begin(dp[i][k][first]) * 10 + *begin(dp[i+k][l-k][second]));\n              break;\n          }\n        }\n      }\n    }\n    cout << dp[0][n][0].size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//repetition\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i, n) for(ll i = 0; i < (ll)(n); i++)\n\n//container util\n#define all(x) (x).begin(),(x).end()\n\n//typedef\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\n\n//const value\n//const ll MOD = 1e9 + 7;\n//const int dx[] = {0,1,0,-1};//{0,0,1,1,1,-1,-1,-1};\n//const int dy[] = {1,0,-1,0};//{1,-1,0,1,-1,0,1,-1};\n\n//conversion\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline ll toLL(string s) {ll v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\ntypedef string::const_iterator State;\n\nset<int> expression(State &);\nset<int> number(State&);\nset<int> factor(State&);\n\n\nset<int> number(State &begin){\n  int ret = 0;\n  while(isdigit(*begin)){\n    ret *= 10;\n    ret += *begin - '0';\n    begin++;\n  }\n  set<int> res;\n  res.insert(ret);\n  return res;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nset<int> factor(State &begin) {\n    if (*begin == '(') {\n        begin++;\n        auto ret = expression(begin);\n        begin++;\n        return ret;\n    } else {\n        return number(begin);\n    }\n}\n\n\nset<int> expression(State &begin){\n  vector<set<int>> nums;\n  vector<char> ops;\n  nums.push_back(factor(begin));\n  while( *begin == '+' || *begin == '-' ||\n         *begin == '*' || *begin == '/' ) {\n\n    ops.push_back(*begin);\n    begin++;\n    nums.push_back(factor(begin));\n  }\n\n  int n = ops.size();\n  vector<int> perm(n);\n  //next perm で回すためのvector配列\n  rep(i,n) perm[i] = i;\n  set<int> ret;\n  do{\n    vector<set<int>> buff = nums;\n    bool ng = false;\n    rep(i,n){\n      int L = perm[i];\n      int R = L+1;\n      char op = ops[perm[i]];\n      while(L >= 0 && buff[L].size() == 0){\n        L--;\n      }\n      if(L < 0){\n        ng = true;\n        break;\n      }\n      set<int> to;\n      for(auto el1: buff[L]){\n        for(auto el2: buff[R]){\n          if(op == '+') to.insert(el1 + el2);\n          if(op == '-') to.insert(el1 - el2);\n          if(op == '*') to.insert(el1 * el2);\n          if(op == '/' && el2 != 0) to.insert(el1 / el2);\n        }\n      }\n      buff[L] = to;\n      buff[R].clear();\n    }\n    if( !ng ){\n      for(int el: buff[0]){\n        ret.insert(el);\n      }\n    }\n  } while (next_permutation(all(perm)));\n  return ret;\n}\n\nvoid solve(const string & s){\n  State begin = s.begin();\n  auto ans = expression(begin);\n  cout << ans.size() << endl;\n}\n\nint main(){\n  string s;\n  while(cin >> s){\n    if( s==\"#\") break;\n    solve(s);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\nbool match(char c, string s)\n{\n\trep(i, 0, s.length()) if (s[i] == c) return true;\n\treturn false;\n}\n\nmap< pair<int, int>, set<int> > memo;\n\nset<int> parse(string s, int left, int right)\n{\n\tauto p = make_pair(left, right);\n\tif (memo.find(p) != memo.end()) return memo[p];\n\n\t{\n\t\tbool ok = true;\n\t\trep(i, left, right + 1) if (!match(s[i], \"0123456789\")) ok = false;\n\t\tif (ok)\n\t\t{\n\t\t\tint ret = 0;\n\t\t\trep(i, left, right + 1) ret = ret * 10 + s[i] - '0';\n\t\t\tset<int> ans;\n\t\t\tans.insert(ret);\n\t\t\treturn (memo[p] = ans);\n\t\t}\n\t}\n\n\t// ??¨?????¬??§??§????????°??????\n\tif (s[left] == '(')\n\t{\n\t\tint cnt = 1;\n\t\tbool ok = true;\n\t\trep(i, left + 1, right)\n\t\t{\n\t\t\tif (s[i] == '(')\n\t\t\t\tcnt++;\n\t\t\telse if (s[i] == ')')\n\t\t\t\tcnt--;\n\n\t\t\tif (cnt == 0) ok = false;\n\t\t}\n\n\t\tif (ok)\n\t\t{\n\t\t\tset<int> ans = parse(s, left + 1, right - 1);\n\t\t\treturn (memo[p] = ans);\n\t\t}\n\t}\n\n\tint cnt = 0;\n\tset<int> ans;\n\trep(i, left, right+1)\n\t{\n\t\tif (s[i] == '(')\n\t\t\tcnt++;\n\t\telse if (s[i] == ')')\n\t\t\tcnt--;\n\t\telse if (match(s[i], \"+-*/\") && cnt == 0)\n\t\t{\n\t\t\tset<int> l = parse(s, left, i - 1);\n\t\t\tset<int> r = parse(s, i + 1, right);\n\n\t\t\tfor (int ll : l) for (int rr : r)\n\t\t\t{\n\t\t\t\tswitch (s[i])\n\t\t\t\t{\n\t\t\t\tcase '+': ans.insert(ll + rr); break;\n\t\t\t\tcase '-': ans.insert(ll - rr); break;\n\t\t\t\tcase '*': ans.insert(ll * rr); break;\n\t\t\t\tcase '/': if(rr != 0) ans.insert(ll / rr); break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (memo[p] = ans);\n}\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tmemo.clear();\n\t\tstring s; cin >> s;\n\t\tif (s[0] == '#') return 0;\n\n\t\tauto ans = parse(s, 0, s.length() - 1);\n\t\tcout << ans.size() << endl;\n\n\t\t//for (int i : ans) cout << i << endl;\n\t\t//cout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef complex<double> C;\n\ntypedef string::const_iterator State;\n\nset<int> expression(State& begin);\nset<int> factor(State& begin);\n\nset<int> factor(State& begin) {\n    if (*begin == '(') {\n        begin++;\n        auto ret = expression(begin);\n        begin++;\n        return ret;\n    } else {\n        set<int> ret;\n        int tmp = 0;\n        while (isdigit(*begin)) {\n            tmp = 10*tmp + (*begin-'0');\n            begin++;\n        }\n        ret.insert(tmp);\n        return ret;\n    }\n}\n\nset<int> expression(State& begin) {\n    vector<set<int> > nums;\n    vector<char> ops;\n    nums.push_back(factor(begin));\n    while (*begin == '+' || *begin == '-' || *begin == '*' || *begin == '/') {\n        ops.push_back(*begin);\n        begin++;\n        nums.push_back(factor(begin));\n    }\n    int n = ops.size();\n    vector<int> perm(n);\n    for (int i = 0; i < n; i++) perm[i] = i;\n    set<int> ret;\n    do {\n        vector<set<int> > buff = nums;\n        bool ng = false;\n        for (int i = 0; i < n; i++) {\n            int L = perm[i], R = L+1;\n            char op = ops[perm[i]];\n            while (L >= 0 && buff[L].size() == 0) {\n                L--;\n            }\n            if (L < 0) {\n                ng = true;\n                break;\n            }\n            set<int> to;\n            for (auto el1 : buff[L]) {\n                for (auto el2 : buff[R]) {\n                    if (op == '+') to.insert(el1+el2);\n                    if (op == '-') to.insert(el1-el2);\n                    if (op == '*') to.insert(el1*el2);\n                    if (op == '/' && el2 != 0) to.insert(el1/el2);\n                }\n            }\n            buff[L] = to;\n            buff[R].clear();\n        }\n        if (!ng) {\n            for (int el : buff[0]) {\n                ret.insert(el);\n            }\n        }\n    } while (next_permutation(perm.begin(), perm.end()));\n    return ret;\n}\n\nvoid solve(const string& s) {\n    State begin = s.begin();\n    auto ans = expression(begin);\n    cout << ans.size() << endl;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    while (cin >> s) {\n        if (s == \"#\") break;\n        solve(s);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nset<Int> ss;\nInt check(char c){\n  if(isdigit(c)) return true;\n  if(c=='!') return true;\n  return false;\n}\nInt calc(string s){\n  Int n=s.size(); \n  Int neg=s[0]=='!';\n  return (neg?-1:1)*stoll(s.substr(neg,n-neg));\n}\nstring conv(Int x){\n  if(x<0) return \"!\"+to_string(-x);\n  return to_string(x);\n}\nvoid dfs(string s){\n  // cout<<\":::::\"<<s<<endl;\n  Int n=s.size(); \n  {    \n    Int flg=1;\n    for(Int k=0;k<n;k++)\n      flg&=check(s[k]);\n    if(flg){\n      ss.emplace(calc(s));\n      return;\n    }\n  }\n  Int op=0,num=0;\n  for(Int i=0;i<n;i++){\n    if(s[i]=='(') op++;\n    if(s[i]==')') op--;\n    chmax(num,op);\n    if(s[i]!='(') continue;\n    Int j=i;\n    while(s[j]!=')') j++;\n    Int flg=1;\n    for(Int k=i+1;k<j;k++)\n      flg&=check(s[k]);\n    if(flg){\n      string t=s.substr(0,i)+s.substr(i+1,j-(i+1))+s.substr(j+1,n-(j+1));\n      dfs(t);\n      return;\n    }\n  }\n  for(Int i=0;i<n;i++){\n    if(s[i]=='(') op++;\n    if(s[i]==')') op--;\n    if(op!=num) continue;\n    if(s[i]=='(') continue;\n    if(s[i]==')') continue;\n    if(check(s[i])) continue;\n    \n    Int j=i-1,k=i+1;\n    while(j-1>=0&&check(s[j-1])) j--;\n    while(k-1< n&&check(s[k+1])) k++;\n    // [j, i), (i, k]\n    string a=s.substr(j,i-j);\n    string b=s.substr(i+1,k-i);\n    Int x=calc(a),y=calc(b);\n\n    string p=s.substr(0,j);\n    string q=s.substr(k+1,n-(k+1));\n    //cout<<s<<endl;\n    //cout<<p<<\" \"<<x<<\" \"<<s[i]<<\" \"<<y<<\" \"<<q<<endl;\n    if(s[i]=='+'){\n      dfs(p+conv(x+y)+q);\n    }\n    if(s[i]=='-'){     \n      dfs(p+conv(x-y)+q);\n    }\n    if(s[i]=='*'){\n      dfs(p+conv(x*y)+q);      \n    }\n    if(s[i]=='/'&&y!=0){\n      dfs(p+conv(x/y)+q);      \n    }    \n  }  \n}\nsigned main(){\n  string s;\n  while(cin>>s,s!=\"#\"){\n    ss.clear();\n    dfs(s);\n    cout<<ss.size()<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef set <int> S;\n \nint skip(string &str,int i){\n  if(str[i]!='(')return i;\n  string res;\n  int cnt=1;i++;\n  while(1) {\n    if(str[i]=='(')cnt++;\n    if(str[i]==')')cnt--;\n    if(!cnt)break;\n    res+=str[i++];\n  }\n  return i;\n}\n \n \nint num[1<<8];\nvector <S> mem;\nmap <string,int> M;\nvoid calc(char ch,S a,S b, S &res){\n  S::iterator i,j;\n  for(i=a.begin();i!=a.end();i++)\n    for(j=b.begin();j!=b.end();j++){\n      int I=*i,J=*j,c=0;\n      if(ch=='+') c=I+J;\n      else if(ch=='-') c=I-J;\n      else if(ch=='*') c=I*J;\n      else if(ch=='/'){\n    if(!J)continue;\n    c=I/J;\n      }\n      res.insert(c);\n    }\n}\n \nS solve(string str){\n  S res;\n  if(str.size()==1){res.insert(num[str[0]]);return res;}\n  if(M.count(str))return mem[M[str]];\n  if(skip(str,0)==str.size()-1)return solve(str.substr(1,str.size()-2));\n \n  string A,B;\n  for(int i=0;(i=skip(str,i))<str.size()-1;i+=2){\n    string A=str.substr(0,i+1),B=str.substr(i+2,str.size()-i-2);\n    calc(str[i+1],solve(A),solve(B),res);\n  }\n  M[str]=mem.size();\n  mem.push_back(res); \n  return mem[M[str]];\n}\n \nint main(){\n  while(1){\n    string str;\n    cin>>str;\n    if(str==\"#\")break;\n    mem.clear(),M.clear();\n    string siki;\n    char ch='A';\n    for(int i=0;i<(int)str.size();){\n      int b=0;\n      while('0'<=str[i]&&str[i]<='9') b=b*10+str[i++]-'0';\n      if(b) num[ch]=b,siki+=ch++;\n      else siki+=str[i++];\n    }\n    cout <<solve(siki).size()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n// #define int long long\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000               // 2e9\n#define LLINF 2000000000000000000ll  // 2e18 (llmax:9e18)\n#define fi first\n#define sec second\n#define all(x) (x).begin(), (x).end()\n#define sq(x) ((x) * (x))\n#define dmp(x) cerr << #x << \": \" << x << endl;\n\ntemplate <class T>\nvoid chmin(T &a, const T &b) {\n  if (a > b) a = b;\n}\ntemplate <class T>\nvoid chmax(T &a, const T &b) {\n  if (a < b) a = b;\n}\n\ntemplate <class T>\nusing MaxHeap = priority_queue<T>;\ntemplate <class T>\nusing MinHeap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T>\nvector<T> vect(int len, T elem) {\n  return vector<T>(len, elem);\n}\n\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  os << p.fi << ',' << p.sec;\n  return os;\n}\ntemplate <class T, class U>\nistream &operator>>(istream &is, pair<T, U> &p) {\n  is >> p.fi >> p.sec;\n  return is;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n  for (int i = 0; i < vec.size(); i++) {\n    os << vec[i];\n    if (i + 1 < vec.size()) os << ' ';\n  }\n  return os;\n}\ntemplate <class T>\nistream &operator>>(istream &is, vector<T> &vec) {\n  for (int i = 0; i < vec.size(); i++) is >> vec[i];\n  return is;\n}\nvoid fastio() {\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  cout << fixed << setprecision(20);\n}\n\n#define endl \"\\n\"\n\nusing Pos = string::const_iterator;\n\nbool is_op(char c) {\n  if (c == '+' || c == '-' || c == '/' || c == '*')\n    return true;\n  else\n    return false;\n}\n\nset<int> expr(Pos l, Pos r) {\n  int d = 0;\n  set<int> res;\n  bool op_found = false;\n  for (auto it = l; it != r; it++) {\n    if (*it == '(') {\n      d++;\n    } else if (*it == ')') {\n      d--;\n    } else {\n      if (is_op(*it) && d == 0) {\n        op_found = true;\n        set<int> ls = expr(l, it);\n        set<int> rs = expr(++it, r);\n        it--;\n        if (*it == '+') {\n          for (auto lval : ls) {\n            for (auto rval : rs) { res.insert(lval + rval); }\n          }\n        }\n        if (*it == '-') {\n          for (auto lval : ls) {\n            for (auto rval : rs) { res.insert(lval - rval); }\n          }\n        }\n        if (*it == '*') {\n          for (auto lval : ls) {\n            for (auto rval : rs) { res.insert(lval * rval); }\n          }\n        }\n        if (*it == '/') {\n          for (auto lval : ls) {\n            for (auto rval : rs) {\n              if (rval != 0) res.insert(lval / rval);\n            }\n          }\n        }\n      }\n    }\n  }\n  if (op_found) return res;\n  if (*l == '(') {\n    l++;\n    r--;\n    return expr(l, r);\n  }\n  int val = 0;\n  for (auto it = l; it != r; it++) {\n    assert(isdigit(*it));\n    val = val * 10 + (*it - '0');\n  }\n  res.insert(val);\n  return res;\n}\n\nbool solve() {\n  string s;\n  cin >> s;\n  if (s == \"#\") return false;\n  set<int> ans = expr(s.begin(), s.end());\n  cout << ans.size() << endl;\n  return true;\n}\n\nsigned main() {\n  fastio();\n  // solve();\n  // int t; cin >> t; while(t--)solve();\n  while (solve()) {}\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<cstring>\n#define foreach(t,p) for(t::iterator it=p.begin();it!=p.end();++it)\n#define FOREACH(t,p,tit) for(t::iterator tit=p.begin();tit!=p.end();++tit)\n#define REP(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef set<int> pp;\nstring ss;\n\npp solve(int f,int l)\n{\n\n\tpp ans;\n\t//ans.clear();\n\tbool ope=false;\n/*\tfor(int i=f;i<l;i++)\n\t{\n\t\tif(\n\t\t\t\tss[i]=='+'||\n\t\t\t\tss[i]=='-'||\n\t\t\t\tss[i]=='*'||\n\t\t\t\tss[i]=='/')ope = true;\n\t}*/\n\n\t//int ofs = 0;\n\tint bo =0;\n\tfor(int i=f;i<l;i++)\n\t{\n\t\n\t\tif(ss[i]=='(') bo++;\n\t\tif(ss[i]==')') bo--;\n\n\t\tif((ss[i]=='+'||ss[i]=='-'||ss[i]=='*'||ss[i]=='/')&&(bo==0))\n\t\t{\n\t\t\tope = true;\n\t\t\n\t\t\tpp ansl = solve(f,i-1);\n\t\t\tpp ansr = solve(i+1,l);\n\t\t\tFOREACH(pp,ansl,iit)FOREACH(pp,ansr,jit)\n\t\t\t{\n\t\t\t\tif(ss[i]=='+') ans.insert((*iit)+(*jit));\n\t\t\t\tif(ss[i]=='-') ans.insert((*iit)-(*jit));\n\t\t\t\tif(ss[i]=='*') ans.insert((*iit)*(*jit));\n\t\t\t\tif(ss[i]=='/')if((*jit)!=0)\tans.insert((*iit)/(*jit));\n\t\t\t}\n\t\t}\n\t}\n\tif(!ope)\n\t{\n\t\tif(ss[f]=='('&& ss[l]==')'  ){return solve(f+1,l-1);}\n\n\n\t\tstring s = ss.substr(f,(l-f+1));\n\t\t//cout << s << endl;\n\t\tint t = atoi(s.c_str() );\n\t\tans.insert(t);\n\t\t//foreach(pp,ans)cout << *it << endl;\n\t\t//cout << atoi( (ss.substr(f,l+1)).c_str()) << endl ;\n\t\t//cout <<ss.substr(f,(l-f+1))<<endl;\n\t\treturn ans;\n\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\twhile(cin >> ss &&(ss!=\"#\"))\n\t{\n\t\tpp anss = solve(0,ss.size()-1);\n\t\t//foreach(pp,anss)cout << *it << endl;\n\t\tcout << anss.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 205\nusing namespace std;\ntypedef pair<int,int> P;\nvector<int> memo[N][N];\nint p,d[N],dlen;\nstring s;\n\nint getNum(){\n  int res=0;\n  while('0'<=s[p]&&s[p]<='9')\n    res=res*10+s[p++]-'0';\n  return res;\n}\n\nvoid comp(){\n  int slen=s.size(),idx=0;\n  while(s[p]!='x'){\n    if('0'<=s[p]&&s[p]<='9')\n      d[idx++]=getNum(),p--;\n    if(s[p]=='(')d[idx++]=-1;\n    if(s[p]==')')d[idx++]=-2;\n    if(s[p]=='+')d[idx++]=-3;\n    if(s[p]=='-')d[idx++]=-4;\n    if(s[p]=='*')d[idx++]=-5;\n    if(s[p]=='/')d[idx++]=-6;\n    p++;\n  }\n  d[idx++]=-7;\n  dlen=idx;\n}\n\nvoid dfs(){\n  vector<int> v2;\n  vector<P> v;\n  int S=p-1;\n  while(d[p]!=-2&&d[p]!=-7){\n    if(d[p]>=0)v.push_back(P(p,p)),p++;\n    else if(d[p]==-1){\n      int b=p++;\n      dfs();\n      v.push_back(P(b,p));\n      p++;\n    }\n    else if(d[p]==-3)p++,v2.push_back(-3);\n    else if(d[p]==-4)p++,v2.push_back(-4);\n    else if(d[p]==-5)p++,v2.push_back(-5);\n    else if(d[p]==-6)p++,v2.push_back(-6);\n  }\n  int E=p;\n  for(int l=2;l<=v.size();l++){\n    for(int i=0;i<=v.size()-l;i++){\n      int j=i+l-1;\n      for(int k=i;k<j;k++){\n\tint A=v[i].first,B=v[k].second;\n\tint C=v[k+1].first,D=v[j].second;\n\tfor(int n=0;n<memo[A][B].size();n++){\n\t  int num1=memo[A][B][n];\n\t  for(int m=0;m<memo[C][D].size();m++){\n\t    int num2=memo[C][D][m];\n\t    if(v2[k]==-6&&!num2)continue;\n\t    if(l!=v.size()){\n\t      if(v2[k]==-3)memo[A][D].push_back(num1+num2);\n\t      if(v2[k]==-4)memo[A][D].push_back(num1-num2);\n\t      if(v2[k]==-5)memo[A][D].push_back(num1*num2);\n\t      if(v2[k]==-6)memo[A][D].push_back(num1/num2);\n\t    }else{\n\t      if(v2[k]==-3)memo[S][E].push_back(num1+num2);\n\t      if(v2[k]==-4)memo[S][E].push_back(num1-num2);\n\t      if(v2[k]==-5)memo[S][E].push_back(num1*num2);\n\t      if(v2[k]==-6)memo[S][E].push_back(num1/num2);\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nint main(){\n  while(true){\n    cin>>s;\n    if(s==\"#\")break;\n    s='('+s+')'+'x';\n    p=0; comp();\n    for(int i=0;i<dlen;i++)\n      if(d[i]>=0)\n\tmemo[i][i].push_back(d[i]);\n    p=0; dfs();\n    set<int> ans;\n    for(int i=0;i<memo[0][dlen-2].size();i++)\n      ans.insert(memo[0][dlen-2][i]);\n    cout<<ans.size()<<endl;\n    ans.clear();\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n\tmemo[i][j].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <cctype>\n#include <map>\n#include <set>\n#include <sstream>\nusing namespace std;\n\nstring s;\n\ntypedef string::const_iterator State;\nint expression(State&);\nint term(State&);\nint number(State&);\nint factor(State&);\n\nint expression(State &begin){\n  int ret = term(begin);\n  while(1){\n    if(*begin == '+'){\n      begin++;\n      ret += term(begin);\n    }\n    else if(*begin == '-'){\n      begin++;\n      ret -= term(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\n\nint term(State &begin){\n  int ret = factor(begin);\n  while(1){\n    if(*begin == '*'){\n      begin++;\n      ret *= factor(begin);\n    }\n    else if(*begin == '/'){\n      begin++;\n      int tmp = factor(begin);\n      if(tmp == 0) throw \"\";\n      ret /= tmp;\n    }\n    else break;\n  }\n  return ret;\n}\n\nint number(State &begin){\n  int ret = 0;\n  while(isdigit(*begin)){\n    ret *= 10;\n    ret += *begin-'0';\n    begin++;\n  }\n  return ret;\n}\n\nint factor(State &begin){\n  if(*begin == '('){\n    begin++;\n    int ret = expression(begin);\n    begin++;\n    return ret;\n  }\n  else return number(begin);\n}\n\nstring toString(int n){\n  ostringstream os;\n  os << n;\n  return os.str();\n}\n\nint main(){\n  \n  map<char, char> conv;\n  \n  while(cin >> s){\n    if(s == \"#\") break;\n    set<int> used;\n    vector<string> value;\n    int op_size=0;\n    vector<char> op;\n    for(int i = 0 ; i <s.size() ; i++){\n      if(!isdigit(s[i]) && s[i] != '(' && s[i] != ')'){\n\top.push_back('a'+op_size);\n\tconv['a'+op_size] = s[i];\n\ts[i] = 'a'+op_size;\n\top_size++;\n      }\n    }\n    \n    \n    \n    do{\n      string tmp = s;\n      for(int i = 0 ; i < op.size() ; i++){\n\tint pos = tmp.find(op[i]);\n\tint cnt = 0;\n\tfor(int j = pos-1 ; j >= 0 ; j--){\n\t  if(tmp[j] == ')'){\n\t    cnt++;\n\t  }\n\t  if(tmp[j] == '('){\n\t    if(cnt == 0){\n\t      tmp.insert(j, \"(\");\n\t      break;\n\t    }\n\t    else{\n\t      cnt--;\n\t    }\n\t  }\n\t  if(cnt == 0 && isalpha(tmp[j])){\n\t    tmp.insert(j+1, \"(\");\n\t    break;\n\t  }\n\t  if(j == 0) tmp.insert(0, \"(\");\n\t}\n\t\n      \tfor(int j = pos+2 ; j < tmp.size() ; j++){\n\t  if(tmp[j] == '('){\n\t    cnt++;\n\t  }\n\t  if(tmp[j] == ')'){\n\t    if(cnt == 0){\n\t      tmp.insert(j, \")\");\n\t      break;\n\t    }\n\t    else{\n\t      cnt--;\n\t    }\n\t  }\n\t  if(cnt == 0 && isalpha(tmp[j])){\n\t    tmp.insert(j, \")\");\n\t    break;\n\t  }\n\t  if(j == tmp.size()-1){\n\t    tmp.insert(tmp.size(), \")\");\n\t    break;\n\t  }\n\t}\n\n      }\n      for(int i = 0 ; i < tmp.size() ; i++){\n\tif(isalpha(tmp[i])) tmp[i] = conv[tmp[i]];\n      }\n      // cout << tmp << endl;\n      State begin = tmp.begin();\n      int t;\n      try{\n\tt = expression(begin);\n\t//\tcout << t << endl;\n\tused.insert(t);\n      }catch(const char* str){\n      }\t\n    }while(next_permutation(op.begin(), op.end()));\n    \n    cout << used.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vec;\n\nclass UnionFind {\n  vector<int> a;\npublic:\n  UnionFind(int n) { REP(i, 0, n) a.push_back(i); }\n  int find(int i) { return a[i] == i ? i : (a[i] = find(a[i])); }\n  void unite(int i, int j) { a[find(i)] = find(j); }\n  bool same(int i, int j) { return find(i) == find(j); }\n};\n\nstring S;\nint p;\n\nll num() {\n  int val = 0;\n  while('0' <= S[p] && S[p] <= '9') val = val * 10 + (S[p++] - '0');\n  return val;\n}\n\nvec expr() {\n  vector<vec> n;\n  vector<char> op;\n  while(p < S.length() && S[p] != ')') {\n    if(S[p] == '+' || S[p] == '-' || S[p] == '*' || S[p] == '/') {\n      op.push_back(S[p++]);\n    } else if(S[p] == '(') {\n      p++;\n      n.push_back(expr());\n      p++;\n    } else {\n      vec u;\n      u.push_back(num());\n      n.push_back(u);\n    }\n  }\n\n  int idx[10];\n  REP(i, 0, op.size()) idx[i] = i;\n  vec ret;\n  do {\n    UnionFind uf(n.size());\n    vec d[10];\n    REP(i, 0, n.size()) REP(j, 0, n[i].size()) d[i].push_back(n[i][j]);\n    REP(i, 0, op.size()) {\n      vec n1 = d[uf.find(idx[i])];\n      vec n2 = d[uf.find(idx[i] + 1)];\n      vec res;\n      REP(j, 0, n1.size()) REP(k, 0, n2.size()) {\n        int val;\n        switch(op[idx[i]]) {\n          case '+': val = n1[j] + n2[k]; break;\n          case '-': val = n1[j] - n2[k]; break;\n          case '*': val = n1[j] * n2[k]; break;\n          case '/': val = n1[j] / n2[k]; break;\n        }\n        res.push_back(val);\n      }\n      res.erase(unique(res.begin(), res.end()), res.end());\n      uf.unite(idx[i], idx[i] + 1);\n      d[uf.find(idx[i])].clear();\n      REP(j, 0, res.size()) d[uf.find(idx[i])].push_back(res[j]);\n    }\n    REP(i, 0, d[uf.find(0)].size()) ret.push_back(d[uf.find(0)][i]);\n  } while(next_permutation(idx, idx + op.size()));\n  ret.erase(unique(ret.begin(), ret.end()), ret.end());\n\n  return ret;\n}\n\nint main(void) {\n  while(cin >> S, S != \"#\") {\n    p = 0;\n    cout << expr().size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) loop(i,0,n)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nint dx[]={-1,-1,0,0,1,1};\nint dy[]={0,-1,1,-1,1,0};\nconst int inf=1000000010;\nstring s;\nint t;\nvi f(){\n\tvvi in;\n\tstring w=\"\";\n\twhile(t<s.size()){\n\t\tif(s[t]=='('){\n\t\t\tt++;\n\t\t\tin.pb(f());\n\t\t\tt++;\n\t\t}else{\n\t\t\tint a=0;\n\t\t\twhile(t<s.size()&&isdigit(s[t])){\n\t\t\t\ta*=10;\n\t\t\t\ta+=s[t]-'0';\n\t\t\t\tt++;\n\t\t\t}\n\t\t\tin.pb({a});\n\t\t}\n\t\tif(s.size()==t)break;\n\t\tif(s[t]==')')break;\n\t\tw+=s[t];\n\t\tt++;\n\t}\n\tvi out;\n\tvi per(w.size());\n\trep(i,w.size())per[i]=i;\n\tdo{\n\t\tvvi tmp=in;\n\t\tvi used(w.size()+1);\n\t\trep(i,w.size()){\n\t\t\tint l=per[i],r=per[i]+1;\n\t\t\twhile(used[l])l--;\n\t\t\twhile(used[r])r++;\n\t\t\tvi nt;\n\n\t\t\trep(j,tmp[l].size())rep(k,tmp[r].size()){\n\t\t\t\tif(w[per[i]]=='+')nt.pb(tmp[l][j]+tmp[r][k]);\n\t\t\t\tif(w[per[i]]=='-')nt.pb(tmp[l][j]-tmp[r][k]);\n\t\t\t\tif(w[per[i]]=='*')nt.pb(tmp[l][j]*tmp[r][k]);\n\t\t\t\tif(tmp[r][k]&&w[per[i]]=='/')nt.pb(tmp[l][j]/tmp[r][k]);\n\t\t\t}\n\t\t\tused[l]=true;\n\t\t\ttmp[l]=vi(0);\n\t\t\ttmp[r]=nt;\n\t\t}\n\t\trep(j,tmp.size()){rep(i,tmp[j].size())out.pb(tmp[j][i]);}\n\t\tsort(all(out));\n\t\tout.erase(unique(all(out)),out.end());\n\t}while(next_permutation(all(per)));\n\n\treturn out;\n}\nint main(){\n\twhile(cin>>s,s!=\"#\"){\n\t\tt=0;\n\t\tcout<<f().size()<<endl;\n\t}\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef long long int ll;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define SP << \" \" <<\n\nLL mod = 1000000007;\n\nstruct token{\n  char c;\n  int num;\n  token(char c,int num):c(c),num(num){}\n};\n\nconst char TOKEN_NUM = 'N';\n\nvector<token> tokenize(string s){\n  vector<token> tokenlist;\n  int idx = 0;\n  while (idx<s.size())\n  {\n    if('0'<=s[idx]&&s[idx]<='9'){\n      int val = 0;\n      while('0'<=s[idx]&&s[idx]<='9'){\n        val *= 10;\n        val += s[idx] - '0';\n        idx++;\n      }\n      tokenlist.push_back(token(TOKEN_NUM, val));\n    }\n    else\n    {\n      tokenlist.push_back(token(s[idx], 0));\n      idx++;\n    }\n  }\n  return tokenlist;\n}\n\nvoid simplify(vector<token>& tokenlist,int idx){\n  if(0==idx||idx==tokenlist.size()-1){\n    return;\n  }\n  if(tokenlist[idx].c!=TOKEN_NUM){\n    return;\n  }\n  while(tokenlist[idx-1].c=='('&&tokenlist[idx+1].c==')'){\n    tokenlist.erase(tokenlist.begin() + idx + 1);\n    tokenlist.erase(tokenlist.begin() + idx - 1);\n    idx--;\n  }\n}\n\nbool is_op(char c){\n  return c == '+' || c == '-' || c == '*' || c == '/';\n}\n\nvector<token> f(vector<token> tokenlist,int num){\n  int cnt = -1;\n  int idx = 0;\n  for (; idx < tokenlist.size();++idx)\n  {\n    if(is_op(tokenlist[idx].c)){\n      cnt++;\n    }\n    if(cnt==num){\n      break;\n    }\n  }\n\n  if(cnt!=num){\n    return {};\n  }\n\n  if(tokenlist[idx-1].c==TOKEN_NUM&&tokenlist[idx+1].c==TOKEN_NUM){\n    int l = tokenlist[idx - 1].num;\n    int r = tokenlist[idx + 1].num;\n    int val;\n    if (tokenlist[idx].c == '+')\n    {\n      val = l + r;\n    }\n    else if (tokenlist[idx].c == '-')\n    {\n      val = l - r;\n    }\n    else if (tokenlist[idx].c == '*')\n    {\n      val = l * r;\n    }\n    else if (tokenlist[idx].c == '/')\n    {\n      if(r==0){\n        return {};\n      }\n      val = l / r;\n    }\n    tokenlist.erase(tokenlist.begin() + idx + 1);\n    tokenlist.erase(tokenlist.begin() + idx);\n    tokenlist[idx - 1].num = val;\n    simplify(tokenlist, idx - 1);\n    return tokenlist;\n  }\n  else\n  {\n    return {};\n  }\n}\n\nset<int> st;\n\nvoid calc(vector<token> tokenlist,int bound){\n  REP(i,bound){\n    auto list = f(tokenlist, i);\n    if(list.size()==0){\n      continue;\n    }\n    if(list.size()==3){\n      st.insert(list[1].num);\n      continue;\n    }\n    calc(list, bound - 1);\n  }\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  \n  while(true){\n    string s;\n    cin >> s;\n    if(s[0]=='#'){\n      break;\n    }\n\n    s = \"$\"+s+\"#\";\n\n    vector<token> tokenlist = tokenize(s);\n    \n    REP(i, tokenlist.size())\n    {\n      simplify(tokenlist,i);\n    }\n    \n    st = {};\n\n    int bound = 0;\n    \n    \n\n    REP(i,tokenlist.size()){\n      if (is_op(tokenlist[i].c))\n      {\n        bound++;\n      }\n    }\n\n    calc(tokenlist, bound);\n    cout << st.size() << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <cctype>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cassert>\n#include <fstream>\nusing namespace std;\n\nset<int> add(const set<int> &s1, const set<int> &s2){\n  set<int> res;\n  for(set<int>::iterator it1 = s1.begin(); it1 != s1.end(); it1++){\n    for(set<int>::iterator it2 = s2.begin(); it2 != s2.end(); it2++){\n      int num = *it1 + *it2;\n      if(!res.count(num)) res.insert(num);\n    }\n  }\n\n  return res;\n}\n\nset<int> sub(const set<int> &s1, const set<int> &s2){\n  set<int> res;\n  for(set<int>::iterator it1 = s1.begin(); it1 != s1.end(); it1++){\n    for(set<int>::iterator it2 = s2.begin(); it2 != s2.end(); it2++){\n      int num = *it1 - *it2;\n      if(!res.count(num)) res.insert(num);\n    }\n  }\n  return res;\n}\n\nset<int> mul(const set<int> &s1, const set<int> &s2){\n  set<int> res;\n  for(set<int>::iterator it1 = s1.begin(); it1 != s1.end(); it1++){\n    for(set<int>::iterator it2 = s2.begin(); it2 != s2.end(); it2++){\n      int num = (*it1) * (*it2);\n      if(!res.count(num)) res.insert(num);\n    }\n  }\n  return res;\n}\n\nset<int> div(const set<int> &s1, const set<int> &s2){\n  set<int> res;\n  for(set<int>::iterator it1 = s1.begin(); it1 != s1.end(); it1++){\n    for(set<int>::iterator it2 = s2.begin(); it2 != s2.end(); it2++){\n      if(*it2 != 0){\n\tint num = *it1 / *it2;\n\t  if(!res.count(num))res.insert(num);\n      }\n    }\n  }\n  return res;\n}\n\nvoid putset(set<int> &s1, const set<int> &s2){\n  for(set<int>::iterator iter = s2.begin(); iter != s2.end();iter++){\n    if(!s1.count(*iter)){\n      s1.insert(*iter);\n    }\n  }\n}\n\nsize_t cur;\nstring s;\n\nint number(){\n  int res = 0;\n  while(cur < s.size() && isdigit(s[cur])){\n    res = res * 10 + s[cur++] - '0';\n  }\n  return res;\n}\n\nset<int> expr(){\n  vector<set<int> > vs;\n  vector<char> op;\n\n  while(cur < s.size() && s[cur] != ')'){\n    if(s[cur] == '('){\n      cur++;\n      vs.push_back(expr());\n      assert(s[cur] == ')');\n      cur++;\n    }else if(isdigit(s[cur])){\n      int num = number();\n      set<int> s;\n      s.insert(num);\n      vs.push_back(s);\n    }else{\n      op.push_back(s[cur]);\n      cur++;\n    }\n  }\n  \n  set<int> dp[12][12];\n  int n = vs.size();\n  //  cout << \"sz \"<< n << endl;\n  for(int i = 0; i < n; i++){\n    dp[i][1] = vs[i];\n    //    cout << dp[i][1].size() << endl;\n  }\n  /*  for(int i = 0; i < n; i++){\n    for(set<int>::iterator iter = vs[i].begin(); iter != vs[i].end(); iter++){\n      cout << *iter << \" \";\n    }\n    cout << endl;\n    }*/\n  for(int w = 2; w <= n; w++){\n    for(int i = 0; i < n - w + 1; i++){\n      for(int j = i + 1; j < i + w; j++){\n\t\n\tswitch(op[j-1]){\n\tcase '+': \n\t  putset(dp[i][w], add(dp[i][j-i], dp[j][i+w-j]));\n\t  break;\n\tcase '-':\n\t  putset(dp[i][w], sub(dp[i][j-i], dp[j][i+w-j]));\n\t  break;\n\tcase '*':\n\t  putset(dp[i][w], mul(dp[i][j-i], dp[j][i+w-j]));\n\t  break;\n\tcase '/':\n\t  putset(dp[i][w], div(dp[i][j-i], dp[j][i+w-j]));\n\t  break;\n\tdefault : \n\t  cout << \"NG\" << endl;\n\t}\n      }\n    }\n  }\n  \n  return dp[0][n];\n}\n\nint main(){\n  ofstream cout(\"D.txt\");\n  while(cin >> s && s != \"#\"){\n    cur = 0;\n    cout << expr().size() << endl;\n  }\n \n  cout.close();\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <queue>\n#include <map>\n#include <ctime>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define pb push_back\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i) \n\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int inf=1<<29;\n\nstring S;\n\nint digit(int cur){\n\treturn S[cur]-'0';\n}\n\nset<int> number(int cur){\n\tint res=digit(cur++);\n\twhile(isdigit(S[cur])){\n\t\tres=10*res+digit(cur++);\n\t}\n\tset<int> ans;\n\tans.insert(res);\n\treturn ans;\n}\n\nset<int> exp2(int l,int r){\n\tif(S[l]=='('&&S[r-1]==')'){\n\t\t l++,r--;\n\t}\n\n\tint i=l;\n\tbool iscall=false;\n\tint num=0;\n\tset<int> res;\n\n\tfor(;i<r;i++){\n\t\tif(isdigit(S[i])){\n\t\t\tcontinue;\n\t\t}else if(S[i]=='('){\n\t\t\tnum++;\n\t\t}else if(S[i]==')'){\n\t\t\tnum--;\n\t\t}else if(num==0){\n\t\t\tiscall=true;\n\t\t\tchar op=S[i];\n\t\t\tset<int> a=exp2(l,i);\n\t\t\tset<int> b=exp2(i+1,r);\n\t\t\tset<int> res2;\n\t\t\tswitch(op){\n\t\t\t\tcase '+':\n\t\t\t\t\teach(j,a)each(k,b) res2.insert((*j)+(*k));\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\teach(j,a)each(k,b) res2.insert((*j)-(*k));\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\teach(j,a)each(k,b) res2.insert((*j)*(*k));\n\t\t\t\t\tbreak;\n\t\t\t\tcase '/':\n\t\t\t\t\teach(j,a)each(k,b)if((*k)!=0)res2.insert((*j)/(*k));\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t\teach(j,res2) res.insert(*j);\n\t\t}\n\t}\n\t\n\tif(iscall) \n\t\treturn res;\n\telse\n\t\treturn number(l);\n}\n\n\nint exp(int l,int r){\n\tset<int> res;\n\tbool iscall=false;\n\tint num=0;\n\trep(i,r){\n\t\tif(isdigit(S[i]))\n\t\t\tcontinue;\n\t\telse if(S[i]=='(')\n\t\t\tnum++;\n\t\telse if(S[i]==')')\n\t\t\tnum--;\n\t\telse if(num==0){\n\t\t\tiscall=true;\n\t\t\tchar op=S[i];\n\t\t\tset<int> a=exp2(l,i);\n\t\t\tset<int> b=exp2(i+1,r);\n\t\t\tset<int> res2;\n\t\t\tswitch(op){\n\t\t\t\tcase '+':\n\t\t\t\t\teach(j,a)each(k,b) res2.insert((*j)+(*k));\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\teach(j,a)each(k,b) res2.insert((*j)-(*k));\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\teach(j,a)each(k,b) res2.insert((*j)*(*k));\n\t\t\t\t\tbreak;\n\t\t\t\tcase '/':\n\t\t\t\t\teach(j,a)each(k,b)if((*k)!=0)res2.insert((*j)/(*k));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\teach(j,res2) res.insert(*j);\n\t\t}\n\t}\n\t//each(it,res) cout << *it << endl;\n\tif(iscall)\n\t\treturn res.size();\n\telse\n\t\treturn 1;\n}\n\nint main(void){\n\twhile(cin >> S){\n\t\tint n=S.size();\n\t\tif(S==\"#\")\n\t\t\tbreak;\n\t\tcout << exp(0,n) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) loop(i,0,n)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nint dx[]={-1,-1,0,0,1,1};\nint dy[]={0,-1,1,-1,1,0};\nconst int inf=1000000010;\nstring s;\nint t;\nvi f(){\n\tvvi in;\n\tstring w=\"\";\n\twhile(t<s.size()){\n\t\tif(s[t]=='('){\n\t\t\tt++;\n\t\t\tin.pb(f());\n\t\t\tt++;\n\t\t}else{\n\t\t\tint a=0;\n\t\t\twhile(t<s.size()&&isdigit(s[t])){\n\t\t\t\ta*=10;\n\t\t\t\ta+=s[t]-'0';\n\t\t\t\tt++;\n\t\t\t}\n\t\t\tin.pb({a});\n\t\t}\n\t\tif(s.size()==t)break;\n\t\tif(s[t]==')')break;\n\t\tw+=s[t];\n\t\tt++;\n\t}\n\tvi out;\n\tvi per(w.size());\n\trep(i,w.size())per[i]=i;\n\tdo{\n\t\tvvi tmp=in;\n\t\tvi used(w.size()+1);\n\t\trep(i,w.size()){\n\t\t\tint l=per[i],r=per[i]+1;\n\t\t\twhile(used[l])l--;\n\t\t\twhile(used[r])r++;\n\t\t\tvi nt;\n\n\t\t\trep(j,tmp[l].size())rep(k,tmp[r].size()){\n\t\t\t\tif(w[per[i]]=='+')nt.pb(tmp[l][j]+tmp[r][k]);\n\t\t\t\tif(w[per[i]]=='-')nt.pb(tmp[l][j]-tmp[r][k]);\n\t\t\t\tif(w[per[i]]=='*')nt.pb(tmp[l][j]*tmp[r][k]);\n\t\t\t\tif(tmp[r][k]&&w[per[i]]=='/')nt.pb(tmp[l][j]/tmp[r][k]);\n\t\t\t}\n\t\t\tused[l]=true;\n\t\t\ttmp[l]=vi(0);\n\t\t\ttmp[r]=nt;\n\t\t}\n\t\trep(j,tmp.size()){rep(i,tmp[j].size())out.pb(tmp[j][i]);}\n\t}while(next_permutation(all(per)));\n\tsort(all(out));\n\tout.erase(unique(all(out)),out.end());\n\n\treturn out;\n}\nint main(){\n\twhile(cin>>s,s!=\"#\"){\n\t\tt=0;\n\t\tcout<<f().size()<<endl;\n\t}\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\nusing namespace std;\n#define rep(i,a,b) for(auto (i)=(a);(i)<(b);(i)++)\n#define rev(i,a,b) for(auto (i)=(b)-1;(i)>=(a);(i)--)\n#define num_check(x) '0'<=(x)&&(x)<='9'\n\n\nstruct Siki{\n\tint num;\n\tint depth;\n\tchar type;\n\tint left, right;\n\n};\n\nint pri[10];//各演算子の計算順序\nint min_pri[6];//各演算子のdepthごとの計算順序の最低値、これを破るとNG\nSiki siki[12];\nSiki temp[12];//作業用配列\nint s_size;\nstring input;\nmap<int, int> data;\n\nbool check_pri(){\n\trep(i, 0, s_size){\n\t\tif (min_pri[siki[pri[i]].depth] > i)\n\t\t\treturn(false);\n\t}\n\treturn(true);\n}\n\nvoid init(){\n\t//初期化\n\tdata.clear();\n\trep(i, 0, 12)siki[i].num = 0;\n\trep(i, 0, 6)min_pri[i] = 0;\n\tint d = 0; \n\ts_size = 0;\n\t\n\t//入力を作業用に変換\n\trep(i, 0u, input.length()){\n\t\tif (num_check(input[i])){\n\t\t\tsiki[s_size].num *= 10;\n\t\t\tsiki[s_size].num += input[i] - '0';\n\t\t}\n\t\telse if (input[i] == '(')d++;//()の中に入るので深さを増加\n\t\telse if (input[i] == ')')d--;//深さを減少\n\t\telse\n\t\t{\n\t\t\tsiki[s_size].type = input[i];\n\t\t\tsiki[s_size].depth = d;\n\t\t\tpri[s_size] = s_size;\n\t\t\trep(j, d + 1, 6)\n\t\t\t\tmin_pri[j]++;\n\t\t\ts_size++;\n\t\t}\n\t}\n\tsiki[s_size].type = '\\0';//終端記号\n\trep(i, 0, s_size){\n\t\t//連結リスト構造の作成\n\t\tsiki[i].right = i+1;\n\t\tsiki[i + 1].left = i;\n\t}\n\tsiki[0].left = siki[s_size].right = -1;//左端、右端の保護\n\t\n}\n\n//2項計算する関数\nint calc(int l, char op, int r){\n\tswitch (op){\n\tcase '+':return(l + r);\n\tcase '-':return(l - r);\n\tcase '*':return(l * r);\n\tcase '/':return(l / r);\n\t}\n\treturn(0);\n}\n\n\nvoid parse(){\n\tSiki *p,*r,*l;\n\trep(i, 0, s_size+1)temp[i] = siki[i];//作業用配列にコピー\n\trev(i, 0, s_size){\n\t\tp = &temp[pri[i]];\n\t\tl = &temp[p->left];\n\t\tr = &temp[p->right];\n\n\t\tif (r->num == 0 && p->type == '/')return;//0除算を省く\n\t\tprintf(\"%d%c%d=\", p->num, p->type, r->num);\n\t\tr->num = calc(p->num, p->type, r->num);\n\t\tprintf(\"%d\\n\", r->num);\n\t\tr->left = p->left;\n\t\tif (l->left >=0 )l->right = p->right;\n\n\t}\n\tcout << temp[s_size].num << endl;\n\tdata[temp[s_size].num]++;\n}\n\n//順列を効率的に列挙するための関数\nvoid p(int d, int dm){\n\tif (d == dm){\n\t\tif (check_pri()){\n\t\t\tparse();\n\t\t}\n\t}\n\trep(i, d, dm){\n\t\tswap(pri[d], pri[i]);\n\t\tp(d + 1, dm);\n\t\tswap(pri[d], pri[i]);\n\t}\n}\n\nint main(void){\n\twhile (true){\n\t\tcin >> input;\n\t\tif (input[0] == '#')break;\n\t\tinit();\n\t\t/*\t\n\t\trep(i, 0, siki_size)if (siki[i].type == 'c')printf(\"%d\", siki[i].num); else printf(\"%c\", siki[i].type); cout << endl;\n\t\trep(i, 0, op_size)printf(\"%c\", siki[index[i]].type); cout << endl;\n\t\trep(i, 0, op_size)printf(\"%d\", min_pri[siki[index[i]].num]); cout << endl;\n\t\t*/\n\t\tp(0, s_size);\n\t\tcout << data.size() << endl;\n\t}\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\n\nstring str;\n\nint calc(int a, int b, char c){\n\tif(c == '+') return a+b;\n\tif(c == '*') return a*b;\n\tif(c == '-') return a-b;\n\tif(b == 0){\n\t\treturn MOD;\n\t} else if(b > 0){\n\t\treturn a/b;\n\t}\n}\n\nvector<int> fu(vector<int> v, vector<char> c){\n\tvector<int> ret;\n\tif(c.size() == 0){\n\t\tret.push_back(v[0]);\n\t\treturn ret;\n\t}\n\trep(i,c.size()){\n\t\tvector<int> V;\n\t\tvector<char> C;\n\t\tbool ok = true;\n\t\trep(j,v.size()){\n\t\t\tif(i != j){\n\t\t\t\tV.push_back(v[j]);\n\t\t\t\tif(j != v.size()-1) C.push_back(c[j]);\n\t\t\t} else{\n\t\t\t\tint tmp = calc(v[j],v[j+1],c[j]);\n\t\t\t\tif(tmp == MOD){\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tV.push_back(tmp);\n\t\t\t\tif(j+1 != v.size()-1) C.push_back(c[j+1]);\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tif(!ok) continue;\n\t\tV = fu(V,C);\n\t\trep(j,V.size()) ret.push_back(V[j]);\n\t}\n\treturn ret;\n}\n\nvector<int> fun(vector<vector<int> > v, vector<char> c, vector<int> z, int cnt){\n\tvector<int> x;\n\tif(v[cnt].size() == 0){\n\t\treturn fu(z,c);\n\t}\n\trep(i,v[cnt].size()){\n\t\tz.push_back(v[cnt][i]);\n\t\tvector<int> tmp = fun(v,c,z,cnt+1);\n\t\trep(j,tmp.size()) x.push_back(tmp[j]);\n\t\tz.pop_back();\n\t}\n\treturn x;\n}\n\nvector<int> func(string s){\n\tint cont = 0;\n\tvector<vector<int> > v;\n\tv.resize(12);\n\tvector<char> c;\n\trep(i,s.size()){\n\t\tif(s[i] == '('){\n\t\t\tint cnt = 0;\n\t\t\tstring tmp;\n\t\t\twhile(true){\n\t\t\t\ti++;\n\t\t\t\tif(s[i] == '(') cnt++;\n\t\t\t\tif(s[i] == ')' && cnt == 0) break;\n\t\t\t\tif(s[i] == ')') cnt--;\n\t\t\t\ttmp.push_back(s[i]);\n\t\t\t}\n\t\t\tv[cont] = func(tmp);\n\t\t} else if('0' <= s[i] && s[i] <= '9'){\n\t\t\tv[cont].push_back(s[i]-'0');\n\t\t} else{\n\t\t\tc.push_back(s[i]);\n\t\t\tcont++;\n\t\t}\n\t}\n\tvector<int> z;\n\treturn fun(v, c, z, 0);\n}\n\nvoid solve(){\n\tvector<int> v = func(str);\n\tsort(v.begin(),v.end());\n\tv.erase(unique(v.begin(),v.end()),v.end());\n\tcout << v.size() << endl;\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> str;\n\t\tif(str == \"#\") break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint qsort_comp(const void* x,const void* y) {\n\tint a=*((const int*)x);\n\tint b=*((const int*)y);\n\tif(a>b)return 1;\n\tif(a<b)return -1;\n\treturn 0;\n}\n\n#define OP_NULL (0)\n#define OP_KAKKO (-1)\n#define OP_PLUS (-2)\n#define OP_MINUS (-3)\n#define OP_MUL (-4)\n#define OP_DIV (-5)\n\n#define CALC_ERROR 0x7fffffff\n\nchar siki_str[204];\n\nint stack_num;\nint stack[200];\nint siki_num;\nint siki[200];\n\nint result_num;\nint result_list[10*9*8*7*6*5*4*3*2*1];\n\nvoid compile_rp(int puttern[]) {\n\tint i;\n\tint op_count=0;\n\tint nowop;\n\tstack_num=siki_num=0;\n\tfor(i=0;siki_str[i];i++) {\n\t\tnowop=OP_NULL;\n\t\tif(siki_str[i]=='+') {\n\t\t\tnowop=OP_PLUS;\n\t\t} else if(siki_str[i]=='-') {\n\t\t\tnowop=OP_MINUS;\n\t\t} else if(siki_str[i]=='*') {\n\t\t\tnowop=OP_MUL;\n\t\t} else if(siki_str[i]=='/') {\n\t\t\tnowop=OP_DIV;\n\t\t} else if(siki_str[i]=='(') {\n\t\t\tstack[stack_num++]=OP_KAKKO;\n\t\t} else if(siki_str[i]==')') {\n\t\t\twhile(stack_num>0 && stack[stack_num-1]!=OP_KAKKO) {\n\t\t\t\tsiki[siki_num++]=stack[--stack_num];\n\t\t\t}\n\t\t\tif(stack_num>0)stack_num--;\n\t\t} else if(isdigit(siki_str[i])) {\n\t\t\tint nownumber=0;\n\t\t\twhile(siki_str[i]!=0 && isdigit(siki_str[i])) {\n\t\t\t\tnownumber=nownumber*10+siki_str[i]-'0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tsiki[siki_num++]=nownumber;\n\t\t\ti--;\n\t\t}\n\t\tif(nowop!=OP_NULL) {\n\t\t\tnowop-=puttern[op_count]*10;\n\t\t\top_count++;\n\t\t\twhile(stack_num>0 && stack[stack_num-1]<nowop) {\n\t\t\t\tsiki[siki_num++]=stack[--stack_num];\n\t\t\t}\n\t\t\tstack[stack_num++]=nowop;\n\t\t}\n\t}\n\twhile(stack_num>0)siki[siki_num++]=stack[--stack_num];\n\tfor(i=0;i<siki_num;i++) {\n\t\tif(siki[i]<0) {\n\t\t\tsiki[i]%=10;\n\t\t\tif(siki[i]>0)siki[i]-=10;\n\t\t}\n\t}\n}\n\nint calc_rp(void) {\n\tint i;\n\tstack_num=0;\n\tfor(i=0;i<siki_num;i++) {\n\t\tif(siki[i]==OP_PLUS) {\n\t\t\tif(stack_num<2)return CALC_ERROR;\n\t\t\tstack[stack_num-2]+=stack[stack_num-1];\n\t\t\tstack_num--;\n\t\t} else if(siki[i]==OP_MINUS) {\n\t\t\tif(stack_num<2)return CALC_ERROR;\n\t\t\tstack[stack_num-2]-=stack[stack_num-1];\n\t\t\tstack_num--;\n\t\t} else if(siki[i]==OP_MUL) {\n\t\t\tif(stack_num<2)return CALC_ERROR;\n\t\t\tstack[stack_num-2]*=stack[stack_num-1];\n\t\t\tstack_num--;\n\t\t} else if(siki[i]==OP_DIV) {\n\t\t\tif(stack_num<2 || stack[stack_num-1]==0)return CALC_ERROR;\n\t\t\tstack[stack_num-2]/=stack[stack_num-1];\n\t\t\tstack_num--;\n\t\t} else {\n\t\t\tstack[stack_num++]=siki[i];\n\t\t}\n\t}\n\tif(stack_num!=1)return CALC_ERROR;\n\treturn stack[0];\n}\n\nvoid next_permutation(int arr[],int n) {\n\tint i,j;\n\tint pos;\n\tfor(pos=n-2;pos>=0;pos--) {\n\t\tif(arr[pos]<arr[pos+1])break;\n\t}\n\tif(pos<0)return;\n\tfor(i=pos+1;i<n;i++) {\n\t\tif(arr[i]>arr[pos]) {\n\t\t\tint t;\n\t\t\tt=arr[i];arr[i]=arr[pos];arr[pos]=t;\n\t\t}\n\t}\n\tfor(j=n-1;j>pos+1;j--) {\n\t\tfor(i=pos+1;i<j;i++) {\n\t\t\tif(arr[i]>arr[i+1]) {\n\t\t\t\tint t;\n\t\t\t\tt=arr[i];arr[i]=arr[i+1];arr[i+1]=t;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\twhile(scanf(\"%s\",siki_str)==1 && siki_str[0]!='#') {\n\t\tint i;\n\t\tint tansaku_max;\n\t\tint op_count;\n\t\tint answer;\n\t\tint puttern[10];\n\t\ttansaku_max=1;\n\t\top_count=0;\n\t\tfor(i=0;siki_str[i];i++) {\n\t\t\tif(siki_str[i]=='+' || siki_str[i]=='-' ||\n\t\t\t\t\tsiki_str[i]=='*' || siki_str[i]=='/') {\n\t\t\t\top_count++;\n\t\t\t\ttansaku_max*=op_count;\n\t\t\t}\n\t\t}\n\t\tresult_num=0;\n\t\tfor(i=0;i<op_count;i++)puttern[i]=i;\n\t\tfor(i=0;i<tansaku_max;i++) {\n\t\t\tcompile_rp(puttern);\n\t\t\tresult_list[result_num]=calc_rp();\n\t\t\tif(result_list[result_num]!=CALC_ERROR)result_num++;\n\t\t\tnext_permutation(puttern,op_count);\n\t\t}\n\t\tqsort(result_list,result_num,sizeof(int),qsort_comp);\n\t\tanswer=result_num;\n\t\tfor(i=1;i<result_num;i++) {\n\t\t\tif(result_list[i]==result_list[i-1])answer--;\n\t\t}\n\t\tprintf(\"%d\\n\",answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint qsort_comp(const void* x,const void* y) {\n\tint a=*((const int*)x);\n\tint b=*((const int*)y);\n\tif(a>b)return 1;\n\tif(a<b)return -1;\n\treturn 0;\n}\n\n#define OP_NULL (0)\n#define OP_KAKKO (-1)\n#define OP_PLUS (-2)\n#define OP_MINUS (-3)\n#define OP_MUL (-4)\n#define OP_DIV (-5)\n\n#define CALC_ERROR 0x7fffffff\n\nchar siki_str[204];\n\nint stack_num;\nint stack[200];\nint siki_num;\nint siki[200];\n\nint result_num;\nint result_list[10*9*8*7*6*5*4*3*2*1];\n\nvoid compile_rp(int puttern[]) {\n\tint i;\n\tint op_count=0;\n\tint nowop;\n\tstack_num=siki_num=0;\n\tfor(i=0;siki_str[i];i++) {\n\t\tnowop=OP_NULL;\n\t\tif(siki_str[i]=='+') {\n\t\t\tnowop=OP_PLUS;\n\t\t} else if(siki_str[i]=='-') {\n\t\t\tnowop=OP_MINUS;\n\t\t} else if(siki_str[i]=='*') {\n\t\t\tnowop=OP_MUL;\n\t\t} else if(siki_str[i]=='/') {\n\t\t\tnowop=OP_DIV;\n\t\t} else if(siki_str[i]=='(') {\n\t\t\tstack[stack_num++]=OP_KAKKO;\n\t\t} else if(siki_str[i]==')') {\n\t\t\twhile(stack_num>0 && stack[stack_num-1]!=OP_KAKKO) {\n\t\t\t\tsiki[siki_num++]=stack[--stack_num];\n\t\t\t}\n\t\t\tif(stack_num>0)stack_num--;\n\t\t} else if(isdigit(siki_str[i])) {\n\t\t\tint nownumber=0;\n\t\t\twhile(siki_str[i]!=0 && isdigit(siki_str[i])) {\n\t\t\t\tnownumber=nownumber*10+siki_str[i]-'0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tsiki[siki_num++]=nownumber;\n\t\t\ti--;\n\t\t}\n\t\tif(nowop!=OP_NULL) {\n\t\t\tnowop-=puttern[op_count]*10;\n\t\t\top_count++;\n\t\t\twhile(stack_num>0 && stack[stack_num-1]<nowop) {\n\t\t\t\tsiki[siki_num++]=stack[--stack_num];\n\t\t\t}\n\t\t\tstack[stack_num++]=nowop;\n\t\t}\n\t}\n\twhile(stack_num>0)siki[siki_num++]=stack[--stack_num];\n\tfor(i=0;i<siki_num;i++) {\n\t\tif(siki[i]<0) {\n\t\t\tsiki[i]%=10;\n\t\t\tif(siki[i]>0)siki[i]-=10;\n\t\t}\n\t}\n}\n\nint calc_rp(void) {\n\tint i;\n\tstack_num=0;\n\tfor(i=0;i<siki_num;i++) {\n\t\tif(siki[i]==OP_PLUS) {\n\t\t\tif(stack_num<2)return CALC_ERROR;\n\t\t\tstack[stack_num-2]+=stack[stack_num-1];\n\t\t\tstack_num--;\n\t\t} else if(siki[i]==OP_MINUS) {\n\t\t\tif(stack_num<2)return CALC_ERROR;\n\t\t\tstack[stack_num-2]-=stack[stack_num-1];\n\t\t\tstack_num--;\n\t\t} else if(siki[i]==OP_MUL) {\n\t\t\tif(stack_num<2)return CALC_ERROR;\n\t\t\tstack[stack_num-2]*=stack[stack_num-1];\n\t\t\tstack_num--;\n\t\t} else if(siki[i]==OP_DIV) {\n\t\t\tif(stack_num<2 || stack[stack_num-1]==0)return CALC_ERROR;\n\t\t\tstack[stack_num-2]/=stack[stack_num-1];\n\t\t\tstack_num--;\n\t\t} else {\n\t\t\tstack[stack_num++]=siki[i];\n\t\t}\n\t}\n\tif(stack_num!=1)return CALC_ERROR;\n\treturn stack[0];\n}\n\nvoid next_permutation(int arr[],int n) {\n\tint i,j;\n\tint pos;\n\tint min,minpos;\n\tfor(pos=n-2;pos>=0;pos--) {\n\t\tif(arr[pos]<arr[pos+1])break;\n\t}\n\tif(pos<0)return;\n\tmin=n;minpos=pos;\n\tfor(i=pos+1;i<n;i++) {\n\t\tif(arr[i]>arr[pos] && arr[i]<min) {\n\t\t\tmin=arr[i];\n\t\t\tminpos=i;\n\t\t}\n\t}\n\t{\n\t\tint t;\n\t\tt=arr[pos];arr[pos]=arr[minpos];arr[minpos]=t;\n\t}\n\tfor(j=n-1;j>pos+1;j--) {\n\t\tfor(i=pos+1;i<j;i++) {\n\t\t\tif(arr[i]>arr[i+1]) {\n\t\t\t\tint t;\n\t\t\t\tt=arr[i];arr[i]=arr[i+1];arr[i+1]=t;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\twhile(scanf(\"%s\",siki_str)==1 && siki_str[0]!='#') {\n\t\tint i;\n\t\tint tansaku_max;\n\t\tint op_count;\n\t\tint answer;\n\t\tint puttern[10];\n\t\ttansaku_max=1;\n\t\top_count=0;\n\t\tfor(i=0;siki_str[i];i++) {\n\t\t\tif(siki_str[i]=='+' || siki_str[i]=='-' ||\n\t\t\t\t\tsiki_str[i]=='*' || siki_str[i]=='/') {\n\t\t\t\top_count++;\n\t\t\t\ttansaku_max*=op_count;\n\t\t\t}\n\t\t}\n\t\tresult_num=0;\n\t\tfor(i=0;i<op_count;i++)puttern[i]=i;\n\t\tfor(i=0;i<tansaku_max;i++) {\n\t\t\tint j;\n\t\t\tcompile_rp(puttern);\n\t\t\tresult_list[result_num]=calc_rp();\n\t\t\tif(result_list[result_num]!=CALC_ERROR)result_num++;\n\t\t\tnext_permutation(puttern,op_count);\n\t\t}\n\t\tqsort(result_list,result_num,sizeof(int),qsort_comp);\n\t\tanswer=result_num;\n\t\tfor(i=1;i<result_num;i++) {\n\t\t\tif(result_list[i]==result_list[i-1])answer--;\n\t\t}\n\t\tprintf(\"%d\\n\",answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2255 6/2(1+2)\n// 2018.3.18 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX 2500\nint ans[MAX];\nchar buf[210];\nchar op[128];\n\nint cmp(const void *a, const void *b) { return *(int *)a - *(int *)b; }\n\nint update(int *ans, int pos, int val)\n{\n\tint i;\n\tfor (i = 0; i < pos; i++) if (ans[i] == val) return pos;\n\tans[pos++] = val;\n\treturn pos;\n}\n\nint calc(int *ans, int xs, int *x, int ys, int *y, int op)\n{\n\tint i, j, pos;\n\n\tpos = 0;\n\tfor (i = 0; i < xs; i++) for (j = 0; j < ys; j++) {\n\t\tswitch (op) {\n\t\tcase '+': pos = update(ans, pos, x[i] + y[j]); break;\n\t\tcase '-': pos = update(ans, pos, x[i] - y[j]); break;\n\t\tcase '*': pos = update(ans, pos, x[i] * y[j]); break;\n\t\tcase '/': if (y[j] != 0) pos = update(ans, pos, x[i] / y[j]); break;\n\t\t}\n\t}\n\treturn pos;\n}\n\nint closing(int pos)\n{\n\tint n = 1;\n\twhile (n > 0) {\n\t\tif (buf[pos] == '(') n++;\n\t\telse if (buf[pos] == ')') n--;\n\t\tpos++;\n\t}\n\treturn pos-1;\n}\n\nint expr(int *ans, int fr, int to);\n\nint num(int *ans, int fr, int to)\n{\n\tif (buf[fr] == '(') return expr(ans, fr+1, to-1);\n\t*ans = 0;\n\twhile (isdigit(buf[fr])) *ans = 10 * *ans + (buf[fr++] & 0xf);\n\treturn 1;\n}\n\nint expr(int *ans, int fr, int to)\n{\n\n\tint i, f, sz;\n\tint a[MAX], b[MAX], as, bs;\n\n\tsz = 0, f = 0;\n\tfor (i = fr; i < to; i++) if (op[buf[i]]) {\n\t\tif (buf[i] == '(') i = closing(i+1);\n\t\telse {\n\t\t\tas = expr(a, fr, i);\n\t\t\tbs = expr(b, i + 1, to);\n\t\t\tsz += calc(ans + sz, as, a, bs, b, buf[i]);\n\t\t\tf = 1;\n\t\t}\n\t}\n\tif (!f) sz = num(ans, fr, to);\n\treturn sz;\n}\n\nint main()\n{\n\tint i, sz, cnt;\n\n\top['+'] = 1, op['-'] = 2, op['*'] = 3, op['/'] = 4;\n\top['('] = 10, op[')'] = 11;\n\twhile (scanf(\"%s\", buf) && *buf != '#') {\n\t\tsz = expr(ans, 0, strlen(buf));\n\t\tqsort(ans, sz, sizeof(int), cmp);\n#if 0\nprintf(\"ans: n=%d: \", sz);\nfor (i = 0; i < sz; i++) printf(\"%d \", ans[i]); printf(\"\\n\");\n#endif\n\t\tcnt = 1; for (i = 1; i < sz; i++) {\n\t\t\tif (ans[i] != ans[i - 1]) cnt++;\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint qsort_comp(const void* x,const void* y) {\n\tint a=*((const int*)x);\n\tint b=*((const int*)y);\n\tif(a>b)return 1;\n\tif(a<b)return -1;\n\treturn 0;\n}\n\n#define OP_NULL (0)\n#define OP_PLUS (-1)\n#define OP_MINUS (-2)\n#define OP_MUL (-3)\n#define OP_DIV (-4)\n#define OP_KAKKO (-5)\n\n#define CALC_ERROR 0x7fffffff\n\nchar siki_str[204];\n\nint stack_num;\nint stack[200];\nint siki_num;\nint siki[200];\n\nint result_num;\nint result_list[1024];\n\nvoid compile_rp(int puttern) {\n\tint i;\n\tint op_count=0;\n\tint nowop;\n\tstack_num=siki_num=0;\n\tfor(i=0;siki_str[i];i++) {\n\t\tnowop=OP_NULL;\n\t\tif(siki_str[i]=='+') {\n\t\t\tnowop=OP_PLUS;\n\t\t} else if(siki_str[i]=='-') {\n\t\t\tnowop=OP_MINUS;\n\t\t} else if(siki_str[i]=='*') {\n\t\t\tnowop=OP_MUL;\n\t\t} else if(siki_str[i]=='/') {\n\t\t\tnowop=OP_DIV;\n\t\t} else if(siki_str[i]=='(') {\n\t\t\tstack[stack_num++]=OP_KAKKO;\n\t\t} else if(siki_str[i]==')') {\n\t\t\twhile(stack_num>0 && stack[stack_num-1]!=OP_KAKKO) {\n\t\t\t\tsiki[siki_num++]=stack[--stack_num];\n\t\t\t}\n\t\t\tif(stack_num>0)stack_num--;\n\t\t} else if(isdigit(siki_str[i])) {\n\t\t\tint nownumber=0;\n\t\t\twhile(siki_str[i]!=0 && isdigit(siki_str[i])) {\n\t\t\t\tnownumber=nownumber*10+siki_str[i]-'0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tsiki[siki_num++]=nownumber;\n\t\t\ti--;\n\t\t}\n\t\tif(nowop!=OP_NULL) {\n\t\t\tif(puttern & (1<<op_count))nowop*=10;\n\t\t\top_count++;\n\t\t\tif(nowop>-10) {\n\t\t\t\twhile(stack_num>0 && stack[stack_num-1]<=-10) {\n\t\t\t\t\tsiki[siki_num++]=stack[--stack_num];\n\t\t\t\t}\n\t\t\t}\n\t\t\tstack[stack_num++]=nowop;\n\t\t}\n\t}\n\twhile(stack_num>0)siki[siki_num++]=stack[--stack_num];\n\tfor(i=0;i<siki_num;i++) {\n\t\tif(siki[i]<=-10)siki[i]/=10;\n\t}\n}\n\nint calc_rp(void) {\n\tint i;\n\tstack_num=0;\n\tfor(i=0;i<siki_num;i++) {\n\t\tif(siki[i]==OP_PLUS) {\n\t\t\tif(stack_num<2)return CALC_ERROR;\n\t\t\tstack[stack_num-2]+=stack[stack_num-1];\n\t\t\tstack_num--;\n\t\t} else if(siki[i]==OP_MINUS) {\n\t\t\tif(stack_num<2)return CALC_ERROR;\n\t\t\tstack[stack_num-2]-=stack[stack_num-1];\n\t\t\tstack_num--;\n\t\t} else if(siki[i]==OP_MUL) {\n\t\t\tif(stack_num<2)return CALC_ERROR;\n\t\t\tstack[stack_num-2]*=stack[stack_num-1];\n\t\t\tstack_num--;\n\t\t} else if(siki[i]==OP_DIV) {\n\t\t\tif(stack_num<2 || stack[stack_num-1]==0)return CALC_ERROR;\n\t\t\tstack[stack_num-2]/=stack[stack_num-1];\n\t\t\tstack_num--;\n\t\t} else {\n\t\t\tstack[stack_num++]=siki[i];\n\t\t}\n\t}\n\tif(stack_num!=1)return CALC_ERROR;\n\treturn stack[0];\n}\n\nint main(void) {\n\twhile(scanf(\"%s\",siki_str)==1 && siki_str[0]!='#') {\n\t\tint i;\n\t\tint tansaku_max;\n\t\tint answer;\n\t\ttansaku_max=1;\n\t\tfor(i=0;siki_str[i];i++) {\n\t\t\tif(siki_str[i]=='+' || siki_str[i]=='-' ||\n\t\t\t\tsiki_str[i]=='*' || siki_str[i]=='/')tansaku_max<<=1;\n\t\t}\n\t\tresult_num=0;\n\t\tfor(i=0;i<tansaku_max;i++) {\n\t\t\tcompile_rp(i);\n\t\t\tresult_list[result_num]=calc_rp();\n\t\t\tif(result_list[result_num]!=CALC_ERROR)result_num++;\n\t\t}\n\t\tqsort(result_list,result_num,sizeof(int),qsort_comp);\n\t\tanswer=result_num;\n\t\tfor(i=1;i<result_num;i++) {\n\t\t\tif(result_list[i]==result_list[i-1])answer--;\n\t\t}\n\t\tprintf(\"%d\\n\",answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint qsort_comp(const void* x,const void* y) {\n\tint a=*((const int*)x);\n\tint b=*((const int*)y);\n\tif(a>b)return 1;\n\tif(a<b)return -1;\n\treturn 0;\n}\n\n#define OP_NULL (0)\n#define OP_PLUS (-1)\n#define OP_MINUS (-2)\n#define OP_MUL (-3)\n#define OP_DIV (-4)\n#define OP_KAKKO (-5)\n\n#define CALC_ERROR 0x7fffffff\n\nchar siki_str[204];\n\nint stack_num;\nint stack[200];\nint siki_num;\nint siki[200];\n\nint result_num;\nint result_list[1024];\n\nvoid compile_rp(int puttern) {\n\tint i;\n\tint op_count=0;\n\tint nowop;\n\tstack_num=siki_num=0;\n\tfor(i=0;siki_str[i];i++) {\n\t\tnowop=OP_NULL;\n\t\tif(siki_str[i]=='+') {\n\t\t\tnowop=OP_PLUS;\n\t\t} else if(siki_str[i]=='-') {\n\t\t\tnowop=OP_MINUS;\n\t\t} else if(siki_str[i]=='*') {\n\t\t\tnowop=OP_MUL;\n\t\t} else if(siki_str[i]=='/') {\n\t\t\tnowop=OP_DIV;\n\t\t} else if(siki_str[i]=='(') {\n\t\t\tstack[stack_num++]=OP_KAKKO;\n\t\t} else if(siki_str[i]==')') {\n\t\t\twhile(stack_num>0 && stack[stack_num-1]!=OP_KAKKO) {\n\t\t\t\tsiki[siki_num++]=stack[--stack_num];\n\t\t\t}\n\t\t\tif(stack_num>0)stack_num--;\n\t\t} else if(isdigit(siki_str[i])) {\n\t\t\tint nownumber=0;\n\t\t\twhile(siki_str[i]!=0 && isdigit(siki_str[i])) {\n\t\t\t\tnownumber=nownumber*10+siki_str[i]-'0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tsiki[siki_num++]=nownumber;\n\t\t\ti--;\n\t\t}\n\t\tif(nowop!=OP_NULL) {\n\t\t\tif(puttern & (1<<op_count))nowop*=10;\n\t\t\top_count++;\n\t\t\tif(nowop>-10) {\n\t\t\t\twhile(stack_num>0 && stack[stack_num-1]<=-10) {\n\t\t\t\t\tsiki[siki_num++]=stack[--stack_num];\n\t\t\t\t}\n\t\t\t}\n\t\t\tstack[stack_num++]=nowop;\n\t\t}\n\t}\n\twhile(stack_num>0)siki[siki_num++]=stack[--stack_num];\n\tfor(i=0;i<siki_num;i++) {\n\t\tif(siki[i]<=-10)siki[i]/=10;\n\t}\n}\n\nint calc_rp(void) {\n\tint i;\n\tstack_num=0;\n\tfor(i=0;i<siki_num;i++) {\n\t\tif(siki[i]==OP_PLUS) {\n\t\t\tif(stack_num<2)return CALC_ERROR;\n\t\t\tstack[stack_num-2]+=stack[stack_num-1];\n\t\t\tstack_num--;\n\t\t} else if(siki[i]==OP_MINUS) {\n\t\t\tif(stack_num<2)return CALC_ERROR;\n\t\t\tstack[stack_num-2]-=stack[stack_num-1];\n\t\t\tstack_num--;\n\t\t} else if(siki[i]==OP_MUL) {\n\t\t\tif(stack_num<2)return CALC_ERROR;\n\t\t\tstack[stack_num-2]*=stack[stack_num-1];\n\t\t\tstack_num--;\n\t\t} else if(siki[i]==OP_DIV) {\n\t\t\tif(stack_num<2 || stack[stack_num-1]==0)return CALC_ERROR;\n\t\t\tstack[stack_num-2]/=stack[stack_num-1];\n\t\t\tstack_num--;\n\t\t} else {\n\t\t\tstack[stack_num++]=siki[i];\n\t\t}\n\t}\n\tif(stack_num!=1)return CALC_ERROR;\n\treturn stack[0];\n}\n\nint main(void) {\n\twhile(scanf(\"%s\",siki_str)==1 && siki_str[0]!='#') {\n\t\tint i;\n\t\tint tansaku_max;\n\t\tint answer;\n\t\ttansaku_max=1;\n\t\tfor(i=0;siki_str[i];i++) {\n\t\t\tif(siki_str[i]=='+' || siki_str[i]=='-' ||\n\t\t\t\tsiki_str[i]=='*' || siki_str[i]=='/')tansaku_max<<=1;\n\t\t}\n\t\tif(tansaku_max>1024)return 1;\n\t\tresult_num=0;\n\t\tfor(i=0;i<tansaku_max;i++) {\n\t\t\tcompile_rp(i);\n\t\t\tresult_list[result_num]=calc_rp();\n\t\t\tif(result_list[result_num]!=CALC_ERROR)result_num++;\n\t\t}\n\t\tqsort(result_list,result_num,sizeof(int),qsort_comp);\n\t\tanswer=result_num;\n\t\tfor(i=1;i<result_num;i++) {\n\t\t\tif(result_list[i]==result_list[i-1])answer--;\n\t\t}\n\t\tprintf(\"%d\\n\",answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main{\n\n\tpublic static String s;\n\tpublic static int id;\n\n\tpublic static List<String> list;\n\tpublic static Set<Integer> set;\n\n\tpublic static int exp(){\n\t\tint ans = 0;\n\t\tif(s.charAt(id)=='('){\n\t\t\tid++;\n\t\t\tans = kakko();\n\t\t}\n\t\telse ans = num();\n\t\twhile(id < s.length()){\n//\t\t\tSystem.out.println(\"CH: \" + s.charAt(id) + \" STR:\" + s);\n\t\t\tchar ch = s.charAt(id);\n\t\t\tif(ch=='+'){\n\t\t\t\tid++;\n\t\t\t\tif(s.charAt(id)=='('){\n\t\t\t\t\tid++;\n\t\t\t\t\tans += kakko();\n\t\t\t\t}\n\t\t\t\telse ans += num();\n\t\t\t}\n\t\t\telse if(ch=='-'){\n\t\t\t\tid++;\n\t\t\t\tif(s.charAt(id)=='('){\n\t\t\t\t\tid++;\n\t\t\t\t\tans -= kakko();\n\t\t\t\t}\n\t\t\t\telse ans -= num();\n\t\t\t}\n\t\t\telse if(ch=='*'){\n\t\t\t\tid++;\n\t\t\t\tif(s.charAt(id)=='('){\n\t\t\t\t\tid++;\n\t\t\t\t\tans *= kakko();\n\t\t\t\t}\n\t\t\t\telse ans *= num();\n\t\t\t}\n\t\t\telse if(ch=='/'){\n\t\t\t\tid++;\n\t\t\t\tif(s.charAt(id)=='('){\n\t\t\t\t\tid++;\n\t\t\t\t\tint a = kakko();\n\t\t\t\t\tif(a==0)return Integer.MAX_VALUE;\n\t\t\t\t\tans /= a;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint a = num();\n\t\t\t\t\tif(a==0)return Integer.MAX_VALUE;\n\t\t\t\t\tans /= a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic static int kakko(){\n\t\tint ans = 0;\n\t\tif(s.charAt(id)=='('){\n\t\t\tid++;\n\t\t\tans = kakko();\n\t\t}\n\t\telse ans = num();\n\t\twhile(s.charAt(id)!=')'){\n//\t\t\tSystem.out.println(\"CHCH: \" + s.charAt(id));\n\t\t\tchar ch = s.charAt(id);\n\t\t\tif(ch=='+'){\n\t\t\t\tid++;\n\t\t\t\tif(s.charAt(id)=='('){\n\t\t\t\t\tid++;\n\t\t\t\t\tans += kakko();\n\t\t\t\t}\n\t\t\t\telse ans += num();\n\t\t\t}\n\t\t\telse if(ch=='-'){\n\t\t\t\tid++;\n\t\t\t\tif(s.charAt(id)=='('){\n\t\t\t\t\tid++;\n\t\t\t\t\tans -= kakko();\n\t\t\t\t}\n\t\t\t\telse ans -= num();\n\t\t\t}\n\t\t\telse if(ch=='*'){\n\t\t\t\tid++;\n\t\t\t\tif(s.charAt(id)=='('){\n\t\t\t\t\tid++;\n\t\t\t\t\tans *= kakko();\n\t\t\t\t}\n\t\t\t\telse ans *= num();\n\t\t\t}\n\t\t\telse if(ch=='/'){\n\t\t\t\tid++;\n\t\t\t\tif(s.charAt(id)=='('){\n\t\t\t\t\tid++;\n\t\t\t\t\tint a = kakko();\n\t\t\t\t\tif(a==0)return Integer.MAX_VALUE;\n\t\t\t\t\tans /= a;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint a = num();\n\t\t\t\t\tif(a==0)return Integer.MAX_VALUE;\n\t\t\t\t\tans /= a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tid++;\n\t\treturn ans;\n\t}\n\n\tpublic static int num(){\n\t\tint x = (int)(s.charAt(id)-'0');\n\t\tid++;\n\t\twhile(id < s.length() && Character.isDigit(s.charAt(id))){\n\t\t\tx *= 10;\n\t\t\tx += (int)(s.charAt(id)-'0');\n\t\t\tid++;\n\t\t}\n\t\treturn x;\n\t}\n\n\tpublic static void dfs(int k, String str){\n\t\tif(k==str.length()){\n\t\t\tlist.add(str);\n\t\t\treturn;\n\t\t}\n\t\tchar ch = str.charAt(k);\n\t\tif(ch=='+'||ch=='-'||ch=='*'||ch=='/'){\n\t\t\tdfs(k+1, new String(str));\n\t\t\tint index = k;\n\t\t\twhile(index < str.length() && str.charAt(index)!=')')index++;\n\t\t\tdfs(k+1, str.substring(0, k+1) + \"(\" + str.substring(k+1, index) + \")\" + str.substring(index));\n\t\t}\n\t\telse dfs(k+1, new String(str));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tboolean debug = true;\n\t\tif(!debug){\n\t\t\ttry {\n\t\t\t\tSystem.setOut(new PrintStream(new File(\"./src/mogi2011/D.txt\")));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ツ篠ゥツ督ョツ青カツ青ャツつウツづェツつス catch ツブツδ債ッツク\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\tScanner sc = new Scanner(System.in);\n//\t\tid = 0;\n//\t\ts = \"(4+(8-7)))\";\n//\t\tSystem.out.println(kakko());\n\t\twhile(true){\n\t\t\ts = sc.next();\n\t\t\tif(s.equals(\"#\"))break;\n\t\t\tlist = new ArrayList<String>();\n\t\t\tdfs(0, new String(s));\n\t\t\tset = new HashSet<Integer>();\n\t\t\tid = 0;\n\t\t\tfor(String st : list){\n//\t\t\t\tst = st+'$';\n\t\t\t\ts = st;\n\t\t\t\tid = 0;\n\t\t\t\tint ans = exp();\n//\t\t\t\tSystem.out.println(\"S:\" + s + \" \" + ans);\n\t\t\t\tset.add(ans);\n\t\t\t}\n//\t\t\tfor(int a:set)System.out.println(a);\n\t\t\tset.add(Integer.MAX_VALUE);\n\t\t\tSystem.out.println(set.size()-1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node {\n    int index;\n    Set<Integer> set;\n  }\n\n  int func(int left, int right, char cmd) {\n    switch (cmd) {\n      case '+':\n        return left + right;\n      case '-':\n        return left - right;\n      case '*':\n        return left * right;\n      case '/':\n        if (right == 0) {\n          return Integer.MIN_VALUE;\n        }\n        return left / right;\n      default:\n        assert false;\n    }\n    assert false;\n    return Integer.MIN_VALUE;\n  }\n\n  Set<Integer> dfs(int t, boolean[] done, List<Character> enzansi, List<Set<Integer>> nums) {\n    if (t == done.length) {\n      return new TreeSet<>(nums.get(0));\n    }\n    Set<Integer> set = new TreeSet<>();\n    for (int i = 0; i < done.length; ++i) {\n      if (done[i]) {\n        continue;\n      }\n      int mouhitotu = -1;\n      for (int j = i + 1; j <= done.length; ++j) {\n        if (!done[j - 1]) {\n          mouhitotu = j;\n          break;\n        }\n      }\n      if (mouhitotu == -1) {\n        continue;\n      }\n      Set<Integer> left = nums.get(i);\n      Set<Integer> right = nums.get(mouhitotu);\n      char cmd = enzansi.get(mouhitotu - 1);\n      Set<Integer> next = new TreeSet<>();\n      for (int l : left) {\n        for (int r : right) {\n          int v = func(l, r, cmd);\n          if (v == Integer.MIN_VALUE) {\n            continue;\n          }\n          next.add(v);\n        }\n      }\n      Set<Integer> tmp = nums.get(mouhitotu);\n      nums.set(i, next);\n      done[mouhitotu - 1] = true;\n      Set<Integer> ret = dfs(t + 1, done, enzansi, nums);\n      done[mouhitotu - 1] = false;\n      nums.set(i, tmp);\n      set.addAll(ret);\n    }\n    return set;\n  }\n\n  Node cal(String str, int index) {\n    List<Character> enzansi = new LinkedList<>();\n    List<Set<Integer>> nums = new LinkedList<>();\n    while (index < str.length() && str.charAt(index) != ')') {\n      if (str.charAt(index) == '(') {\n        Node node = cal(str, index + 1);\n        nums.add(node.set);\n        index = node.index;\n        assert str.charAt(index) == ')';\n        ++index;\n        continue;\n      }\n      char c = str.charAt(index);\n      if (Character.isDigit(c)) {\n        int num = 0;\n        while (index < str.length() && Character.isDigit(str.charAt(index))) {\n          char d = str.charAt(index);\n          num *= 10;\n          num += d - '0';\n          ++index;\n        }\n        TreeSet<Integer> set = new TreeSet<>();\n        set.add(num);\n        nums.add(set);\n      } else {\n        enzansi.add(c);\n        ++index;\n      }\n    }\n    Node ret = new Node();\n    ret.index = index;\n    boolean[] done = new boolean[enzansi.size()];\n    ret.set = dfs(0, done, enzansi, nums);\n    return ret;\n  }\n\n  void run() {\n    for (; ; ) {\n      String str = sc.next();\n      if (str.charAt(0) == '#') {\n        break;\n      }\n      Node ans = cal(str, 0);\n      assert ans.index == str.length();\n      System.out.println(ans.set.size());\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node {\n    int index;\n    Set<Integer> set;\n  }\n\n  int func(int left, int right, char cmd) {\n    switch (cmd) {\n      case '+':\n        return left + right;\n      case '-':\n        return left - right;\n      case '*':\n        return left * right;\n      case '/':\n        if (right == 0) {\n          return Integer.MIN_VALUE;\n        }\n        return left / right;\n      default:\n        assert false;\n    }\n    assert false;\n    return Integer.MIN_VALUE;\n  }\n\n  Set<Integer> dfs(int t, boolean[] done, List<Character> enzansi, List<Set<Integer>> nums) {\n    if (t == done.length) {\n      return nums.get(0);\n    }\n    Set<Integer> set = new TreeSet<>();\n    for (int i = 0; i < done.length; ++i) {\n      int mouhitotu = -1;\n      for (int j = i + 1; j <= done.length; ++j) {\n        if (!done[j - 1]) {\n          mouhitotu = j;\n          break;\n        }\n      }\n      if (mouhitotu == -1) {\n        continue;\n      }\n      Set<Integer> left = nums.get(i);\n      Set<Integer> right = nums.get(mouhitotu);\n      char cmd = enzansi.get(mouhitotu - 1);\n      Set<Integer> next = new TreeSet<>();\n      for (int l : left) {\n        for (int r : right) {\n          int v = func(l, r, cmd);\n          if (v == Integer.MIN_VALUE) {\n            continue;\n          }\n          next.add(v);\n        }\n      }\n      Set<Integer> tmp = nums.get(mouhitotu);\n      nums.set(i, next);\n      done[mouhitotu - 1] = true;\n      Set<Integer> ret = dfs(t + 1, done, enzansi, nums);\n      done[mouhitotu - 1] = false;\n      nums.set(i, tmp);\n      set.addAll(ret);\n      next = null;\n    }\n    return set;\n  }\n\n  Node cal(String str, int index) {\n    List<Character> enzansi = new ArrayList<>();\n    List<Set<Integer>> nums = new ArrayList<>();\n    while (index < str.length() && str.charAt(index) != ')') {\n      if (str.charAt(index) == '(') {\n        Node node = cal(str, index + 1);\n        nums.add(node.set);\n        index = node.index;\n        assert str.charAt(index) == ')';\n        ++index;\n        continue;\n      }\n      char c = str.charAt(index);\n      if (Character.isDigit(c)) {\n        int num = 0;\n        while (index < str.length() && Character.isDigit(str.charAt(index))) {\n          char d = str.charAt(index);\n          num *= 10;\n          num += d - '0';\n          ++index;\n        }\n        TreeSet<Integer> set = new TreeSet<>();\n        set.add(num);\n        nums.add(set);\n      } else {\n        enzansi.add(c);\n        ++index;\n      }\n    }\n    Node ret = new Node();\n    ret.index = index;\n    boolean[] done = new boolean[enzansi.size()];\n    ret.set = dfs(0, done, enzansi, nums);\n    done = null;\n    enzansi = null;\n    nums = null;\n    return ret;\n  }\n\n  void run() {\n    for (; ; ) {\n      String str = sc.next();\n      if (str.charAt(0) == '#') {\n        break;\n      }\n      Node ans = cal(str, 0);\n      assert ans.index == str.length();\n      System.out.println(ans.set.size());\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tHashSet<Integer> hash = new HashSet<Integer>();\n\tHashSet<String> used = new HashSet<String>();\n\t\n\tStack<String> stack = new Stack<String>();\n\t\n\tint add(String s1, String s2) {\n\t\tint a1 = Integer.valueOf(s1), a2 = Integer.valueOf(s2);\n\t\treturn a1 + a2;\n\t}\n\t\n\tint sub(String s1, String s2) {\n//\t\tSystem.out.println(\"sub : \" + s1 + \" \" + s2);\n\t\tint a1 = Integer.valueOf(s1), a2 = Integer.valueOf(s2);\n\t\treturn a1 - a2;\n\t}\n\t\n\tint mul(String s1, String s2) {\n\t\tint a1 = Integer.valueOf(s1), a2 = Integer.valueOf(s2);\n\t\treturn a1 * a2;\n\t}\n\t\n\tint div(String s1, String s2) {\n\t\tint a1 = Integer.valueOf(s1), a2 = Integer.valueOf(s2);\n\t\tif (a2 == 0) return INF;\n\t\treturn a1 / a2;\n\t}\n\t\n\tint INF = 1500000000;\n\tString[] parseString(String s) {\n\t\tArrayList<String> res = new ArrayList<String>();\n\t\tArrayList<Integer> expIdx = new ArrayList<Integer>();\n\t\tfor (int i = 1; i < s.length(); i++) {\n\t\t\tchar c = s.charAt(i);\n\t\t\tif (c >= '0' && c <= '9') continue;\n\t\t\tchar c2 = s.charAt(i-1);\n\t\t\tif (c == '-' && (c2 < '0' || c2 > '9')) continue;\n\t\t\texpIdx.add(i);\n\t\t}\n\t\t\n\t\tif (expIdx.size() == 0) res.add(s);\n\t\telse {\n\t\t\tfor (int i = 0; i < expIdx.size(); i++) {\n\t\t\t\tint idx = expIdx.get(i);\n\t\t\t\tString s1 = \"\";\n\t\t\t\tint ii = idx;\n\t\t\t\twhile (true) {\n\t\t\t\t\tii--;\n\t\t\t\t\tif (ii < 0) break;\n\t\t\t\t\tchar c = s.charAt(ii);\n\t\t\t\t\tif ((c >= '0' && c <= '9') || (ii == 0 || (s.charAt(ii-1) < '0' || s.charAt(ii-1) > '9') && c == '-')) {\n\t\t\t\t\t\ts1 = c + s1;\n\t\t\t\t\t} else break;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tString s2 = \"\";\n\t\t\t\tii = idx;\n\t\t\t\twhile (true) {\n\t\t\t\t\tii++;\n\t\t\t\t\tif (ii >= s.length()) break;\n\t\t\t\t\tchar c = s.charAt(ii);\n\t\t\t\t\tif ((c >= '0' && c <= '9') || (ii == idx + 1 && c == '-')) {\n\t\t\t\t\t\ts2 += c;\n\t\t\t\t\t} else break;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tchar exp = s.charAt(idx);\n\t\t\t\tint cul = 0;\n\t\t\t\tswitch (exp) {\n\t\t\t\tcase '+':\n\t\t\t\t\tcul = add(s1, s2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tcul = sub(s1, s2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\tcul = mul(s1, s2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '/':\n\t\t\t\t\tcul = div(s1, s2);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (cul == INF) continue;\n\t\t\t\tint start = (i == 0) ? -1 : expIdx.get(i-1);\n\t\t\t\tint end = (i == expIdx.size() - 1) ? s.length() : expIdx.get(i+1);\n\t\t\t\tString r = s.substring(0, start+1) + cul + s.substring(end);\n\t\t\t\tres.add(r);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res.toArray(new String[0]);\n\t}\n\t\n\tvoid doit(String s) {\n//\t\tSystem.out.println(\"doit : \\\"\" + s + \"\\\"\");\n\t\tint start = 0, end = 0;\n\t\tString[] parsed = null;\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tchar c = s.charAt(i);\n\t\t\tif (c == '(') start = i + 1;\n\t\t\telse if (c == ')') {\n\t\t\t\tend = i;\n\t\t\t\tparsed = parseString(s.substring(start, end));\n\t\t\t\tbreak;\n\t\t\t}\t\n\t\t}\n\t\tif (start == end) {\n\t\t\tfor (String next : parseString(s)) {\n\t\t\t\tif (!used.contains(next)) {\t\n\t\t\t\t\tused.add(next);\n\t\t\t\t\tstack.push(next);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\thash.add(Integer.valueOf(next));\n\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\t//System.out.println(\"number format exception\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (String p : parsed) {\n\t\t\t\tString temp = \"\";\n\t\t\t\ttry {\n\t\t\t\t\tint x = Integer.valueOf(p);\n\t\t\t\t\ttemp = s.substring(0, start-1) + p + s.substring(end+1);\n\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\ttemp = s.substring(0, start) + p + s.substring(end);\n\t\t\t\t}\n\t\t\t\tused.add(temp);\n\t\t\t\tstack.push(temp);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tString s = in.next();\n\t\t\tif (s.matches(\"#\")) break;\n\t\t\t\n\t\t\thash.clear();\n\t\t\tused.clear();\n\t\t\tused.add(s);\n\t\t\tstack.push(s);\n\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\tString next = stack.pop();\n\t\t\t\tdoit(next);\n\t\t\t}\n//\t\t\tfor (Integer i : hash) System.out.print(i + \" \");\n//\t\t\tSystem.out.println();\n\t\t\tSystem.out.println(hash.size());\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static char[] op = new char[10];\n\tpublic static String[] val = new String[11];\n\tpublic static int[] nest = new int[10];\n\tpublic static int numOfOp = 0;\n\tpublic static int maxNest = 0;\n\tpublic static TreeSet<Integer> tree = null;\n\tpublic static int[] order = new int[10];\n\tpublic static boolean[] used = new boolean[10];\n\tpublic static String last = null;\n\tpublic static int len = 0;\n\tpublic static int point = 0;\n\tpublic static boolean nan = false;\n\tpublic static void main(String[] args) {\n\t\tdoIt();\n\n\t}\n\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tString input = sc.next();\n\t\twhile(input.equals(\"#\") == false){\n\t\t\tanalyze(input);\n\t\t\t//printVal();\n\t\t\tArrays.fill(used, false);\n\t\t\ttree = new TreeSet<Integer>();\n\t\t\tsetOrder(0,maxNest);\n\t\t\tSystem.out.println(tree.size());\n\t\t\t//printVal();\n\t\t\tinput = sc.next();\n\t\t}\n\t}\n\t\n\tpublic static int getNext(){\n\t\tint ret = 0, left = 0, right = 0;\n\t\tchar c = last.charAt(point);\n\t\twhile(c == ' '){\n\t\t\tpoint--;\n\t\t\tc = last.charAt(point);\n\t\t}\n\t\t\n\t\tif(c == '+'){\n\t\t\tpoint--;\n\t\t\tright = getNext();\n\t\t\t//point--;\n\t\t\tleft = getNext();\n\t\t\t//point--;\n\t\t\tret = left + right;\n\t\t}\n\t\telse if(c == '-'){\n\t\t\tpoint--;\n\t\t\tright = getNext();\n\t\t\t//point--;\n\t\t\tleft = getNext();\n\t\t\t//point--;\n\t\t\tret = left - right;\n\t\t}\n\t\telse if(c == '*'){\n\t\t\tpoint--;\n\t\t\tright = getNext();\n\t\t\t//point--;\n\t\t\tleft = getNext();\n\t\t\t//point--;\n\t\t\tret = left * right;\n\t\t}\n\t\telse if(c == '/'){\n\t\t\tpoint--;\n\t\t\tright = getNext();\n\t\t\t//point--;\n\t\t\tleft = getNext();\n\t\t\t//point--;\n\t\t\tif(right == 0){\n\t\t\t\tnan = true;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tret = left / right;\n\t\t\t}\n\t\t}\n//\t\telse if(c == '('){\n//\t\t\tpoint++;\n//\t\t\tret = getNext();\n//\t\t\t//)の分跳ばす\n//\t\t\tpoint++;\n//\t\t}\n\t\telse{\n\t\t\t//数字のはず\n\t\t\tString ss = \"\";\n\t\t\twhile('0' <= c && c <= '9'){\n\t\t\t\tss = String.valueOf(c) + ss;\n\t\t\t\tpoint--;\n\t\t\t\tif(point < 0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tc = last.charAt(point);\n\t\t\t}\n\t\t\t//point++;\n\t\t\tret = Integer.parseInt(ss);\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\t//文字列lastを数字に変換\n\tpublic static void calc(){\n\t\tnan = false;\n\t\tlen = last.length();\n\t\tpoint = len - 1;\n\t\t//System.out.println(\"last = \" + last);\n\t\tint res = getNext();\n\t\t//System.out.println(\"res = \" + res);\n\t\tif(nan == false && tree.contains(res) == false){\n\t\t\ttree.add(res);\n\t\t}\n\t}\n\t\n\tpublic static void printVal(){\n\t\tfor(String a : val){\n\t\t\tSystem.out.print(a + \", \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\t//ネストnの大きな順に後置記法のストリングを作って結合していく\n\tpublic static void setOrder(int depth, int nLevel){\n\t\tif(depth == numOfOp){\n\t\t\tcalc();\n\t\t}\n\t\tboolean bOK = false;\n\t\tfor(int i = 0; i < numOfOp; i++){\n\t\t\tif(nest[i] == nLevel){\n\t\t\t\tif(used[i] == false){\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\t//System.out.println(\"val[i] = \" + val[i] + \", val[i+1] = \" + val[i+1]);\n\t\t\t\t\tlast = val[i] + ' ' + val[i + 1] + ' ' + op[i];\n\t\t\t\t\t//System.out.println(\"ONE : depth = \" + depth + \", nLevel = \" + nLevel);\n\t\t\t\t\t//printVal();\n\t\t\t\t\t//左を見る\n\t\t\t\t\tint left = -1;\n\t\t\t\t\tString lValue = null;\n\t\t\t\t\tfor(int j = i - 1; j >= 0; j--){\n\t\t\t\t\t\tif(used[j] == false){\n\t\t\t\t\t\t\tleft = j;\n\t\t\t\t\t\t\tlValue = val[j + 1];\n\t\t\t\t\t\t\tval[j + 1] = last;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//右を見る\n\t\t\t\t\tint right = -1;\n\t\t\t\t\tString rValue = null;\n\t\t\t\t\tfor(int j = i + 1; j < numOfOp; j++){\n\t\t\t\t\t\tif(used[j] == false){\n\t\t\t\t\t\t\tright = j;\n\t\t\t\t\t\t\trValue = val[j];\n\t\t\t\t\t\t\tval[j] = last;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsetOrder(depth + 1, nLevel);\n\t\t\t\t\t\n\t\t\t\t\t//修復作業\n\t\t\t\t\tif(left != -1){\n\t\t\t\t\t\tval[left + 1] = lValue;\n\t\t\t\t\t}\n\t\t\t\t\tif(right != -1){\n\t\t\t\t\t\tval[right] = rValue;\n\t\t\t\t\t}\n\t\t\t\t\t//System.out.println(\"TWO : depth = \" + depth + \", nLevel = \" + nLevel);\n\t\t\t\t\t//printVal();\n\t\t\t\t\tused[i] = false;\n\t\t\t\t\tbOK = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(bOK == false){\n\t\t\tif(nLevel != 0){\n\t\t\t\tsetOrder(depth, nLevel - 1);\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\tpublic static void analyze(String input){\n\t\tnumOfOp = 0;\n\t\tmaxNest = 0;\n\t\tint nestLevel = 0;\n\t\tint v = 0;\n\t\tint len = input.length(); \n\t\tfor(int i = 0; i < len; i++){\n\t\t\tchar c = input.charAt(i);\n\t\t\tswitch(c){\n\t\t\tcase '(':\n\t\t\t\tnestLevel++;\n\t\t\t\tmaxNest = Math.max(nestLevel, maxNest);\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tnestLevel--;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\tcase '-':\n\t\t\tcase '*':\n\t\t\tcase '/':\n\t\t\t\top[numOfOp] = c;\n\t\t\t\tnest[numOfOp] = nestLevel;\n\t\t\t\tnumOfOp++;\n\t\t\t\tbreak;\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '4':\n\t\t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\t\t\tcase '8':\n\t\t\tcase '9':\n\t\t\t\tString ss = \"\";\n\t\t\t\twhile('0' <= c && c <= '9'){\n\t\t\t\t\tss += String.valueOf(c);\n\t\t\t\t\ti++;\n\t\t\t\t\tif(len <= i){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tc = input.charAt(i);\n\t\t\t\t}\n\t\t\t\ti--;\n\t\t\t\tval[v++] = ss;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n@SuppressWarnings(\"unchecked\")\nclass Main{\n\n    char[] in;\n    boolean[][] checked;\n    HashSet[][] memo;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            String s = sc.next();\n            if(s.equals(\"#\")) break;\n\n            in = s.toCharArray();\n            int n = in.length+1;\n            checked = new boolean[n][n];\n            memo = new HashSet[n][n];\n            System.out.println(expr(0, in.length).size());\n        }\n    }\n\n    HashSet<Integer> expr(int l, int r){\n        if(checked[l][r]) return memo[l][r];\n        int depth = 0;\n        HashSet<Integer> res = new HashSet<Integer>();\n\n        for(int i=l; i<r; i++){\n            if(in[i]=='(') depth++;\n            if(in[i]==')') depth--;\n            if((in[i]=='*' || in[i]=='/' || in[i]=='+' || in[i]=='-') && depth==0){\n                HashSet<Integer> left = expr(l, i);\n                HashSet<Integer> right = expr(i+1, r);\n\n                for(Iterator j=left.iterator(); j.hasNext();){\n                    int a = (int)(Integer)j.next();\n                    for(Iterator k=right.iterator(); k.hasNext();){\n                        int b = (int)(Integer)k.next();\n                        if(in[i]=='*') res.add(new Integer(a * b));\n                        if(in[i]=='/' && b!=0) res.add(new Integer(a / b));\n                        if(in[i]=='+') res.add(new Integer(a + b));\n                        if(in[i]=='-') res.add(new Integer(a - b));\n                    }\n                }\n            }\n        }\n\n        if(res.size()==0){\n            if(Character.isDigit(in[l])) res.add(new Integer(digit(l, r)));\n            else res = expr(l+1, r-1);\n        }\n\n        checked[l][r] = true;\n        return memo[l][r] = res;\n    }\n\n    int digit(int l, int r){\n        int res = 0;\n        int ten = r-l;\n        for(int i=l; i<r; i++){\n            res += (in[i]-'0') * ten--;\n            //System.out.print(in[i]);\n        }\n        //System.out.println(\"\\nres \"+res+\" l \"+l+\" r \"+r);\n        return res;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node {\n    int index;\n    Set<Integer> set;\n  }\n\n  int func(int left, int right, char cmd) {\n    switch (cmd) {\n      case '+':\n        return left + right;\n      case '-':\n        return left - right;\n      case '*':\n        return left * right;\n      case '/':\n        if (right == 0) {\n          return Integer.MIN_VALUE;\n        }\n        return left / right;\n      default:\n        assert false;\n    }\n    assert false;\n    return Integer.MIN_VALUE;\n  }\n\n  Set<Integer> dfs(int t, boolean[] done, List<Character> enzansi, List<Set<Integer>> nums) {\n    if (t == done.length) {\n      return nums.get(0);\n    }\n    Set<Integer> set = new TreeSet<>();\n    for (int i = 0; i < done.length; ++i) {\n      int mouhitotu = -1;\n      for (int j = i + 1; j <= done.length; ++j) {\n        if (!done[j - 1]) {\n          mouhitotu = j;\n          break;\n        }\n      }\n      if (mouhitotu == -1) {\n        continue;\n      }\n      Set<Integer> left = nums.get(i);\n      Set<Integer> right = nums.get(mouhitotu);\n      char cmd = enzansi.get(mouhitotu - 1);\n      Set<Integer> next = new TreeSet<>();\n      for (int l : left) {\n        for (int r : right) {\n          int v = func(l, r, cmd);\n          if (v == Integer.MIN_VALUE) {\n            continue;\n          }\n          next.add(v);\n        }\n      }\n      Set<Integer> tmp = nums.get(mouhitotu);\n      nums.set(i, next);\n      done[mouhitotu - 1] = true;\n      Set<Integer> ret = dfs(t + 1, done, enzansi, nums);\n      done[mouhitotu - 1] = false;\n      nums.set(i, tmp);\n      set.addAll(ret);\n    }\n    return set;\n  }\n\n  Node cal(String str, int index) {\n    List<Character> enzansi = new LinkedList<>();\n    List<Set<Integer>> nums = new LinkedList<>();\n    while (index < str.length() && str.charAt(index) != ')') {\n      if (str.charAt(index) == '(') {\n        Node node = cal(str, index + 1);\n        nums.add(node.set);\n        index = node.index;\n        assert str.charAt(index) == ')';\n        ++index;\n        continue;\n      }\n      char c = str.charAt(index);\n      if (Character.isDigit(c)) {\n        int num = 0;\n        while (index < str.length() && Character.isDigit(str.charAt(index))) {\n          char d = str.charAt(index);\n          num *= 10;\n          num += d - '0';\n          ++index;\n        }\n        TreeSet<Integer> set = new TreeSet<>();\n        set.add(num);\n        nums.add(set);\n      } else {\n        enzansi.add(c);\n        ++index;\n      }\n    }\n    Node ret = new Node();\n    ret.index = index;\n    boolean[] done = new boolean[enzansi.size()];\n    ret.set = dfs(0, done, enzansi, nums);\n    return ret;\n  }\n\n  void run() {\n    for (; ; ) {\n      String str = sc.next();\n      if (str.charAt(0) == '#') {\n        break;\n      }\n      Node ans = cal(str, 0);\n      assert ans.index == str.length();\n      System.out.println(ans.set.size());\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n@SuppressWarnings(\"unchecked\")\nclass Main{\n\n    char[] in;\n    boolean[][] checked;\n    HashSet[][] memo;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            String s = sc.next();\n            if(s.equals(\"#\")) break;\n\n            in = s.toCharArray();\n            int n = in.length+1;\n            checked = new boolean[n][n];\n            memo = new HashSet[n][n];\n            System.out.println(expr(0, in.length).size());\n        }\n    }\n\n    HashSet<Integer> expr(int l, int r){\n        if(checked[l][r]) return memo[l][r];\n        int depth = 0;\n        HashSet<Integer> res = new HashSet<Integer>();\n\n        for(int i=l; i<r; i++){\n            if(in[i]=='(') depth++;\n            if(in[i]==')') depth--;\n            if((in[i]=='*' || in[i]=='/' || in[i]=='+' || in[i]=='-') && depth==0){\n                HashSet<Integer> left = expr(l, i);\n                HashSet<Integer> right = expr(i+1, r);\n\n                for(Iterator j=left.iterator(); j.hasNext();){\n                    int a = (int)j.next();\n                    for(Iterator k=right.iterator(); k.hasNext();){\n                        int b = (int)k.next();\n                        if(in[i]=='*') res.add(a * b);\n                        if(in[i]=='/' && b!=0) res.add(a / b);\n                        if(in[i]=='+') res.add(a + b);\n                        if(in[i]=='-') res.add(a - b);\n                    }\n                }\n            }\n        }\n        if(res.size()==0) res.add(digit(l, r));\n\n        checked[l][r] = true;\n        return memo[l][r] = res;\n    }\n\n    int digit(int l, int r){\n        int res = 0;\n        int ten = r-l;\n        for(int i=l; i<r; i++){\n            res += (in[i]-'0') * ten--;\n        }\n        return res;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node {\n    int index;\n    Set<Integer> set;\n  }\n\n  int func(int left, int right, char cmd) {\n    switch (cmd) {\n      case '+':\n        return left + right;\n      case '-':\n        return left - right;\n      case '*':\n        return left * right;\n      case '/':\n        if (right == 0) {\n          return Integer.MIN_VALUE;\n        }\n        return left / right;\n      default:\n        assert false;\n    }\n    assert false;\n    return Integer.MIN_VALUE;\n  }\n\n  Set<Integer> arimasu;\n\n  void dfs(int t, int done, List<Character> enzansi, List<Set<Integer>> nums) {\n    if (t == enzansi.size()) {\n      arimasu.addAll(nums.get(0));\n      return;\n    }\n    for (int i = 0; i < nums.size(); ++i) {\n      if (((done >> i) & 1) == 1) {\n        continue;\n      }\n      int mouhitotu = -1;\n      for (int j = i + 1; j < nums.size(); ++j) {\n        if (((done >> j) & 1) == 0) {\n          mouhitotu = j;\n          break;\n        }\n      }\n      if (mouhitotu == -1) {\n        continue;\n      }\n      Set<Integer> left = nums.get(i);\n      Set<Integer> right = nums.get(mouhitotu);\n      char cmd = enzansi.get(mouhitotu - 1);\n      Set<Integer> next = new TreeSet<>();\n      for (int l : left) {\n        for (int r : right) {\n          int v = func(l, r, cmd);\n          if (v == Integer.MIN_VALUE) {\n            continue;\n          }\n          next.add(v);\n        }\n      }\n      Set<Integer> tmp = nums.get(i);\n      nums.set(i, next);\n      dfs(t + 1, done | 1 << mouhitotu, enzansi, nums);\n      nums.set(i, tmp);\n    }\n  }\n\n  Node cal(String str, int index) {\n    List<Character> enzansi = new ArrayList<>();\n    List<Set<Integer>> nums = new ArrayList<>();\n    while (index < str.length() && str.charAt(index) != ')') {\n      if (str.charAt(index) == '(') {\n        Node node = cal(str, index + 1);\n        nums.add(node.set);\n        index = node.index;\n        assert str.charAt(index) == ')';\n        ++index;\n        continue;\n      }\n      char c = str.charAt(index);\n      if (Character.isDigit(c)) {\n        int num = 0;\n        while (index < str.length() && Character.isDigit(str.charAt(index))) {\n          char d = str.charAt(index);\n          num *= 10;\n          num += d - '0';\n          ++index;\n        }\n        TreeSet<Integer> set = new TreeSet<>();\n        set.add(num);\n        nums.add(set);\n      } else {\n        enzansi.add(c);\n        ++index;\n      }\n    }\n    Node ret = new Node();\n    ret.index = index;\n    arimasu = new TreeSet<>();\n    dfs(0, 0, enzansi, nums);\n    ret.set = arimasu;\n    return ret;\n  }\n\n  void run() {\n    for (; ; ) {\n      String str = sc.next();\n      if (str.charAt(0) == '#') {\n        break;\n      }\n      Node ans = cal(str, 0);\n      assert ans.index == str.length();\n      System.out.println(ans.set.size());\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main{\n\n\tString input;\n\tint p;\n\n\tvoid run(){\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tinput = in.nextLine();\n\t\t\tif(input.equals(\"#\")) return ;\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tint solve(){\n\t\tp = 0;\n\t\treturn expr().size();\n\t}\n\n\tSet<Integer> rec(ArrayList<Set<Integer>> nums, ArrayList<Character> ops, ArrayList< ArrayList<Set<Integer> > > memo, int from, int to){\n\t\tif(memo.get(from).get(to) != null){\n\t\t\treturn memo.get(from).get(to);\n\t\t}\n\t\tif(from == to){\n\t\t\tmemo.get(from).set(to, nums.get(from));\n\t\t\treturn memo.get(from).get(to);\n\t\t}\n\t\tSet<Integer> ret = new HashSet<Integer>();\n\t\tfor(int i=from; i<to; i++){\n\t\t\tInteger[] x = rec(nums, ops, memo, from, i).toArray(new Integer[0]),\n\t\t\t\t\ty = rec(nums, ops, memo, i+1, to).toArray(new Integer[0]);\n\t\t\tfor(int j=0; j<x.length; j++){\n\t\t\t\tfor(int k=0; k<y.length; k++){\n\t\t\t\t\tif(ops.get(i) == '+'){\n\t\t\t\t\t\tret.add(x[j].intValue() + y[k].intValue());\n\t\t\t\t\t}\n\t\t\t\t\telse if(ops.get(i) == '-'){\n\t\t\t\t\t\tret.add(x[j].intValue() - y[k].intValue());\n\t\t\t\t\t}\n\t\t\t\t\telse if(ops.get(i) == '*'){\n\t\t\t\t\t\tret.add(x[j].intValue() * y[k].intValue());\n\t\t\t\t\t}\n\t\t\t\t\telse if(ops.get(i) == '/' && y[k].intValue() != 0){\n\t\t\t\t\t\tret.add(x[j].intValue() / y[k].intValue());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemo.get(from).set(to, ret);\n\t\treturn ret;\n\t}\n\n\tSet<Integer> expr(){\n\t\tArrayList<Set<Integer>> nums = new ArrayList<Set<Integer>>();\n\t\tArrayList<Character> ops = new ArrayList<Character>();\n\t\twhile(p < input.length()){\n\t\t\tif(input.charAt(p) == '('){\n\t\t\t\tp++;\n\t\t\t\tnums.add(expr());\n\t\t\t\tp++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnums.add(num());\n\t\t\t}\n\t\t\tif(p < input.length() && (input.charAt(p)=='+' || input.charAt(p)=='-' || input.charAt(p)=='*' || input.charAt(p)=='/')){\n\t\t\t\tops.add(input.charAt(p++));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tArrayList< ArrayList<Set<Integer> > > memo = new ArrayList< ArrayList<Set<Integer> > >();\n\t\tfor(int i=0; i<nums.size(); i++){\n\t\t\tmemo.add(new ArrayList<Set<Integer> >());\n\t\t\tfor(int j=0; j<nums.size(); j++){\n\t\t\t\tmemo.get(i).add(null);\n\t\t\t}\n\t\t}\n\t\tSet<Integer> ret = rec(nums, ops, memo, 0, nums.size()-1);\n\t\treturn ret;\n\t}\n\n\tSet<Integer> num(){\n\t\tint ret = input.charAt(p++) - '0';\n\t\twhile(p < input.length() && Character.isDigit(input.charAt(p))){\n\t\t\tret = ret*10 + input.charAt(p++) - '0';\n\t\t}\n\t\tSet<Integer> s = new HashSet<Integer>();\n\t\ts.add(ret);\n\t\treturn s;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node {\n    int index;\n    Set<Integer> set;\n  }\n\n  int func(int left, int right, char cmd) {\n    switch (cmd) {\n      case '+':\n        return left + right;\n      case '-':\n        return left - right;\n      case '*':\n        return left * right;\n      case '/':\n        if (right == 0) {\n          return Integer.MIN_VALUE;\n        }\n        return left / right;\n      default:\n        assert false;\n    }\n    assert false;\n    return Integer.MIN_VALUE;\n  }\n\n  Set<Integer> dfs(List<Character> enzansi, List<Set<Integer>> nums) {\n    assert enzansi.size() + 1 == nums.size();\n    if (enzansi.size() == 0) {\n      return new TreeSet<>(nums.get(0));\n    }\n    Set<Integer> set = new TreeSet<>();\n    for (int i = 0; i < enzansi.size(); ++i) {\n      Set<Integer> left = nums.get(i);\n      Set<Integer> right = nums.get(i + 1);\n      char cmd = enzansi.get(i);\n      Set<Integer> next = new TreeSet<>();\n      for (int l : left) {\n        for (int r : right) {\n          int v = func(l, r, cmd);\n          if (v == Integer.MIN_VALUE) {\n            continue;\n          }\n          next.add(v);\n        }\n      }\n      List<Character> ne = new ArrayList<>();\n      for (int j = 0; j < enzansi.size(); ++j) {\n        if (j == i) {\n          continue;\n        }\n        ne.add(enzansi.get(j));\n      }\n      List<Set<Integer>> nn = new ArrayList<>();\n      for (int j = 0; j < nums.size(); ++j) {\n        if (j == i) {\n          nn.add(next);\n          continue;\n        }\n        if (j == i + 1) {\n          continue;\n        }\n        nn.add(nums.get(j));\n      }\n      Set<Integer> ret = dfs(ne, nn);\n      set.addAll(ret);\n    }\n    return set;\n  }\n\n  Node cal(String str, int index) {\n    List<Character> enzansi = new ArrayList<>();\n    List<Set<Integer>> nums = new ArrayList<>();\n    while (index < str.length() && str.charAt(index) != ')') {\n      if (str.charAt(index) == '(') {\n        Node node = cal(str, index + 1);\n        nums.add(node.set);\n        index = node.index;\n        assert str.charAt(index) == ')';\n        ++index;\n        continue;\n      }\n      char c = str.charAt(index);\n      if (Character.isDigit(c)) {\n        int num = 0;\n        while (index < str.length() && Character.isDigit(str.charAt(index))) {\n          char d = str.charAt(index);\n          num *= 10;\n          num += d - '0';\n          ++index;\n        }\n        TreeSet<Integer> set = new TreeSet<>();\n        set.add(num);\n        nums.add(set);\n      } else {\n        enzansi.add(c);\n        ++index;\n      }\n    }\n    Node ret = new Node();\n    ret.index = index;\n    ret.set = dfs(enzansi, nums);\n    return ret;\n  }\n\n  void run() {\n    for (; ; ) {\n      String str = sc.next();\n      if (str.charAt(0) == '#') {\n        break;\n      }\n      Node ans = cal(str, 0);\n      assert ans.index == str.length();\n      System.out.println(ans.set.size());\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\t\n\tclass P {\n\t\tint a, b;\n\t\tP(int a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t\t\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif(obj instanceof P){\n\t\t\t\tP p=(P)obj;\n\t\t\t\treturn this.a == p.a && this.b == p.b;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tScanner sc = new Scanner(in);\n\t\n\tchar[] eq;\n\tint len;\n\t\n\tMap<P, Set<Integer>> memo = new HashMap<P, Set<Integer>>();\n\t\n\tSet<Integer> calc(int a, int b) {\n\t\tP p = new P(a, b);\n\t\tif (!memo.containsKey(p)) {\n\t\t\tSet<Integer> set = new HashSet<Integer>();\n\t\t\tif (eq[a] == '(' && eq[b] ==')')\n\t\t\t\treturn calc(a+1, b-1);\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tfor (int i = a; i <= b; i++) {\n\t\t\t\tswitch(eq[i]) {\n\t\t\t\tcase '+':\n\t\t\t\t\tif (count == 0)\n\t\t\t\t\t\tfor (int k : calc(a, i-1))\n\t\t\t\t\t\t\tfor (int l : calc(i+1, b))\n\t\t\t\t\t\t\t\tset.add(k+l);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tif (count == 0)\n\t\t\t\t\t\tfor (int k : calc(a, i-1))\n\t\t\t\t\t\t\tfor (int l : calc(i+1, b))\n\t\t\t\t\t\t\t\tset.add(k-l);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\tif (count == 0)\n\t\t\t\t\t\tfor (int k : calc(a, i-1))\n\t\t\t\t\t\t\tfor (int l : calc(i+1, b))\n\t\t\t\t\t\t\t\tset.add(k*l);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '/':\n\t\t\t\t\tif (count == 0)\n\t\t\t\t\t\tfor (int k : calc(a, i-1))\n\t\t\t\t\t\t\tfor (int l : calc(i+1, b))\n\t\t\t\t\t\t\t\tif (l != 0)\n\t\t\t\t\t\t\t\t\tset.add(k/l);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '(':\n\t\t\t\t\tcount++; break;\n\t\t\t\tcase ')':\n\t\t\t\t\tcount--; break;\n\t\t\t\t}\n\t\n\t\t\t}\n\t\t\t\n\t\t\tif (set.isEmpty()) {\n\t\t\t\tint value = 0;\n\t\t\t\tfor (int i = a; i <= b; i++) {\n\t\t\t\t\tvalue = 10*value + Character.getNumericValue(eq[i]);\n\t\t\t\t}\n\t\t\t\tset.add(value);\n\t\t\t}\n\t\t\t\n\t\t\tmemo.put(p, set);\n\t\t}\n\t\t\n\t\treturn memo.get(p);\n\t}\n\t\n\tvoid run() {\n\t\tString s;\n\t\twhile (true) {\n\t\t\ts = sc.nextLine();\n\t\t\tif (s.equals(\"#\")) break;\n\t\t\teq = s.toCharArray();\n\t\t\tlen = eq.length;\n\t\t\tmemo.clear();\n\t\t\tout.println(calc(0, len-1).size());\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static char[] op = new char[10];\n\tpublic static String[] val = new String[11];\n\tpublic static int[] nest = new int[10];\n\tpublic static int numOfOp = 0;\n\tpublic static int maxNest = 0;\n\tpublic static TreeSet<Integer> tree = null;\n\tpublic static int[] order = new int[10];\n\tpublic static boolean[] used = new boolean[10];\n\tpublic static String last = null;\n\tpublic static int len = 0;\n\tpublic static int point = 0;\n\tpublic static boolean nan = false;\n\tpublic static void main(String[] args) {\n\t\tdoIt();\n\n\t}\n\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tString input = sc.next();\n\t\twhile(input.equals(\"#\") == false){\n\t\t\tanalyze(input);\n\t\t\t//printVal();\n\t\t\tArrays.fill(used, false);\n\t\t\ttree = new TreeSet();\n\t\t\tsetOrder(0,maxNest);\n\t\t\tSystem.out.println(tree.size());\n\t\t\t//printVal();\n\t\t\tinput = sc.next();\n\t\t}\n\t}\n\t\n\tpublic static int getNext(){\n\t\tint ret = 0, left = 0, right = 0;\n\t\tchar c = last.charAt(point);\n\t\twhile(c == ' '){\n\t\t\tpoint--;\n\t\t\tc = last.charAt(point);\n\t\t}\n\t\t\n\t\tif(c == '+'){\n\t\t\tpoint--;\n\t\t\tright = getNext();\n\t\t\t//point--;\n\t\t\tleft = getNext();\n\t\t\t//point--;\n\t\t\tret = left + right;\n\t\t}\n\t\telse if(c == '-'){\n\t\t\tpoint--;\n\t\t\tright = getNext();\n\t\t\t//point--;\n\t\t\tleft = getNext();\n\t\t\t//point--;\n\t\t\tret = left - right;\n\t\t}\n\t\telse if(c == '*'){\n\t\t\tpoint--;\n\t\t\tright = getNext();\n\t\t\t//point--;\n\t\t\tleft = getNext();\n\t\t\t//point--;\n\t\t\tret = left * right;\n\t\t}\n\t\telse if(c == '/'){\n\t\t\tpoint--;\n\t\t\tright = getNext();\n\t\t\t//point--;\n\t\t\tleft = getNext();\n\t\t\t//point--;\n\t\t\tif(right == 0){\n\t\t\t\tnan = true;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tret = left / right;\n\t\t\t}\n\t\t}\n//\t\telse if(c == '('){\n//\t\t\tpoint++;\n//\t\t\tret = getNext();\n//\t\t\t//)の分跳ばす\n//\t\t\tpoint++;\n//\t\t}\n\t\telse{\n\t\t\t//数字のはず\n\t\t\tString ss = \"\";\n\t\t\twhile('0' <= c && c <= '9'){\n\t\t\t\tss = String.valueOf(c) + ss;\n\t\t\t\tpoint--;\n\t\t\t\tif(point < 0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tc = last.charAt(point);\n\t\t\t}\n\t\t\t//point++;\n\t\t\tret = Integer.parseInt(ss);\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\t//文字列lastを数字に変換\n\tpublic static void calc(){\n\t\tnan = false;\n\t\tlen = last.length();\n\t\tpoint = len - 1;\n\t\t//System.out.println(\"last = \" + last);\n\t\tint res = getNext();\n\t\t//System.out.println(\"res = \" + res);\n\t\tif(nan == false && tree.contains(res) == false){\n\t\t\ttree.add(res);\n\t\t}\n\t}\n\t\n\tpublic static void printVal(){\n\t\tfor(String a : val){\n\t\t\tSystem.out.print(a + \", \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\t//ネストnの大きな順に後置記法のストリングを作って結合していく\n\tpublic static void setOrder(int depth, int nLevel){\n\t\tif(depth == numOfOp){\n\t\t\tcalc();\n\t\t}\n\t\tboolean bOK = false;\n\t\tfor(int i = 0; i < numOfOp; i++){\n\t\t\tif(nest[i] == nLevel){\n\t\t\t\tif(used[i] == false){\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\t//System.out.println(\"val[i] = \" + val[i] + \", val[i+1] = \" + val[i+1]);\n\t\t\t\t\tlast = val[i] + ' ' + val[i + 1] + ' ' + op[i];\n\t\t\t\t\t//System.out.println(\"ONE : depth = \" + depth + \", nLevel = \" + nLevel);\n\t\t\t\t\t//printVal();\n\t\t\t\t\t//左を見る\n\t\t\t\t\tint left = -1;\n\t\t\t\t\tString lValue = null;\n\t\t\t\t\tfor(int j = i - 1; j >= 0; j--){\n\t\t\t\t\t\tif(used[j] == false){\n\t\t\t\t\t\t\tleft = j;\n\t\t\t\t\t\t\tlValue = val[j + 1];\n\t\t\t\t\t\t\tval[j + 1] = last;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//右を見る\n\t\t\t\t\tint right = -1;\n\t\t\t\t\tString rValue = null;\n\t\t\t\t\tfor(int j = i + 1; j < numOfOp; j++){\n\t\t\t\t\t\tif(used[j] == false){\n\t\t\t\t\t\t\tright = j;\n\t\t\t\t\t\t\trValue = val[j];\n\t\t\t\t\t\t\tval[j] = last;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsetOrder(depth + 1, nLevel);\n\t\t\t\t\t\n\t\t\t\t\t//修復作業\n\t\t\t\t\tif(left != -1){\n\t\t\t\t\t\tval[left + 1] = lValue;\n\t\t\t\t\t}\n\t\t\t\t\tif(right != -1){\n\t\t\t\t\t\tval[right] = rValue;\n\t\t\t\t\t}\n\t\t\t\t\t//System.out.println(\"TWO : depth = \" + depth + \", nLevel = \" + nLevel);\n\t\t\t\t\t//printVal();\n\t\t\t\t\tused[i] = false;\n\t\t\t\t\tbOK = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(bOK == false){\n\t\t\tif(nLevel != 0){\n\t\t\t\tsetOrder(depth, nLevel - 1);\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\tpublic static void analyze(String input){\n\t\tnumOfOp = 0;\n\t\tmaxNest = 0;\n\t\tint nestLevel = 0;\n\t\tint v = 0;\n\t\tint len = input.length(); \n\t\tfor(int i = 0; i < len; i++){\n\t\t\tchar c = input.charAt(i);\n\t\t\tswitch(c){\n\t\t\tcase '(':\n\t\t\t\tnestLevel++;\n\t\t\t\tmaxNest = Math.max(nestLevel, maxNest);\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tnestLevel--;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\tcase '-':\n\t\t\tcase '*':\n\t\t\tcase '/':\n\t\t\t\top[numOfOp] = c;\n\t\t\t\tnest[numOfOp] = nestLevel;\n\t\t\t\tnumOfOp++;\n\t\t\t\tbreak;\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '4':\n\t\t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\t\t\tcase '8':\n\t\t\tcase '9':\n\t\t\t\tString ss = \"\";\n\t\t\t\twhile('0' <= c && c <= '9'){\n\t\t\t\t\tss += String.valueOf(c);\n\t\t\t\t\ti++;\n\t\t\t\t\tif(len <= i){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tc = input.charAt(i);\n\t\t\t\t}\n\t\t\t\ti--;\n\t\t\t\tval[v++] = ss;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tHashSet<Integer> hash = new HashSet<Integer>();\n\tHashSet<String> used = new HashSet<String>();\n\t\n\tStack<String> stack = new Stack<String>();\n\t\n\tint add(String s1, String s2) {\n\t\tint a1 = Integer.valueOf(s1), a2 = Integer.valueOf(s2);\n\t\treturn a1 + a2;\n\t}\n\t\n\tint sub(String s1, String s2) {\n//\t\tSystem.out.println(\"sub : \" + s1 + \" \" + s2);\n\t\tint a1 = Integer.valueOf(s1), a2 = Integer.valueOf(s2);\n\t\treturn a1 - a2;\n\t}\n\t\n\tint mul(String s1, String s2) {\n\t\tint a1 = Integer.valueOf(s1), a2 = Integer.valueOf(s2);\n\t\treturn a1 * a2;\n\t}\n\t\n\tint div(String s1, String s2) {\n\t\tint a1 = Integer.valueOf(s1), a2 = Integer.valueOf(s2);\n\t\tif (a2 == 0) return INF;\n\t\treturn a1 / a2;\n\t}\n\t\n\tint INF = 1_500_000_000;\n\tString[] parseString(String s) {\n\t\tArrayList<String> res = new ArrayList<String>();\n\t\tArrayList<Integer> expIdx = new ArrayList<Integer>();\n\t\tfor (int i = 1; i < s.length(); i++) {\n\t\t\tchar c = s.charAt(i);\n\t\t\tif (c >= '0' && c <= '9') continue;\n\t\t\tchar c2 = s.charAt(i-1);\n\t\t\tif (c == '-' && (c2 < '0' || c2 > '9')) continue;\n\t\t\texpIdx.add(i);\n\t\t}\n\t\t\n\t\tif (expIdx.size() == 0) res.add(s);\n\t\telse {\n\t\t\tfor (int i = 0; i < expIdx.size(); i++) {\n\t\t\t\tint idx = expIdx.get(i);\n\t\t\t\tString s1 = \"\";\n\t\t\t\tint ii = idx;\n\t\t\t\twhile (true) {\n\t\t\t\t\tii--;\n\t\t\t\t\tif (ii < 0) break;\n\t\t\t\t\tchar c = s.charAt(ii);\n\t\t\t\t\tif ((c >= '0' && c <= '9') || (ii == 0 || (s.charAt(ii-1) < '0' || s.charAt(ii-1) > '9') && c == '-')) {\n\t\t\t\t\t\ts1 = c + s1;\n\t\t\t\t\t} else break;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tString s2 = \"\";\n\t\t\t\tii = idx;\n\t\t\t\twhile (true) {\n\t\t\t\t\tii++;\n\t\t\t\t\tif (ii >= s.length()) break;\n\t\t\t\t\tchar c = s.charAt(ii);\n\t\t\t\t\tif ((c >= '0' && c <= '9') || (ii == idx + 1 && c == '-')) {\n\t\t\t\t\t\ts2 += c;\n\t\t\t\t\t} else break;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tchar exp = s.charAt(idx);\n\t\t\t\tint cul = 0;\n\t\t\t\tswitch (exp) {\n\t\t\t\tcase '+':\n\t\t\t\t\tcul = add(s1, s2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tcul = sub(s1, s2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\tcul = mul(s1, s2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '/':\n\t\t\t\t\tcul = div(s1, s2);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (cul == INF) continue;\n\t\t\t\tint start = (i == 0) ? -1 : expIdx.get(i-1);\n\t\t\t\tint end = (i == expIdx.size() - 1) ? s.length() : expIdx.get(i+1);\n\t\t\t\tString r = s.substring(0, start+1) + cul + s.substring(end);\n\t\t\t\tres.add(r);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res.toArray(new String[0]);\n\t}\n\t\n\tvoid doit(String s) {\n//\t\tSystem.out.println(\"doit : \\\"\" + s + \"\\\"\");\n\t\tint start = 0, end = 0;\n\t\tString[] parsed = null;\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tchar c = s.charAt(i);\n\t\t\tif (c == '(') start = i + 1;\n\t\t\telse if (c == ')') {\n\t\t\t\tend = i;\n\t\t\t\tparsed = parseString(s.substring(start, end));\n\t\t\t\tbreak;\n\t\t\t}\t\n\t\t}\n\t\tif (start == end) {\n\t\t\tfor (String next : parseString(s)) {\n\t\t\t\tif (used.contains(next)) continue;\n\t\t\t\telse {\n\t\t\t\t\tused.add(next);\n\t\t\t\t\tstack.push(next);\n\t\t\t\t\ttry {\n\t\t\t\t\t\thash.add(Integer.valueOf(next));\n\t\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (String p : parsed) {\n\t\t\t\tString temp = \"\";\n\t\t\t\ttry {\n\t\t\t\t\tint x = Integer.valueOf(p);\n\t\t\t\t\ttemp = s.substring(0, start-1) + p + s.substring(end+1);\n\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\ttemp = s.substring(0, start) + p + s.substring(end);\n\t\t\t\t}\n\t\t\t\tused.add(temp);\n\t\t\t\tstack.push(temp);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tString s = in.next();\n\t\t\tif (s.matches(\"#\")) break;\n\t\t\t\n\t\t\thash.clear();\n\t\t\tused.clear();\n\t\t\tused.add(s);\n\t\t\tstack.push(s);\n\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\tString next = stack.pop();\n\t\t\t\tdoit(next);\n\t\t\t}\n//\t\t\tfor (Integer i : hash) System.out.print(i + \" \");\n//\t\t\tSystem.out.println();\n\t\t\tSystem.out.println(hash.size());\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n@SuppressWarnings(\"unchecked\")\nclass Main{\n\n    char[] in;\n    boolean[][] checked;\n    HashSet[][] memo;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            String s = sc.next();\n            if(s.equals(\"#\")) break;\n\n            in = s.toCharArray();\n            int n = in.length+1;\n            checked = new boolean[n][n];\n            memo = new HashSet[n][n];\n            System.out.println(expr(0, in.length).size());\n        }\n    }\n\n    HashSet<Integer> expr(int l, int r){\n        if(checked[l][r]) return memo[l][r];\n\n        boolean kakko_num = true;\n        int depth = 0;\n        HashSet<Integer> res = new HashSet<Integer>();\n        for(int i=l; i<r; i++){\n            if(in[i]=='(') depth++;\n            if(in[i]==')') depth--;\n            if((in[i]=='*' || in[i]=='/' || in[i]=='+' || in[i]=='-') && depth==0){\n                kakko_num = false;\n                HashSet<Integer> left = expr(l, i);\n                HashSet<Integer> right = expr(i+1, r);\n\n                for(Iterator j=left.iterator(); j.hasNext();){\n                    int a = (int)(Integer)j.next();\n                    for(Iterator k=right.iterator(); k.hasNext();){\n                        int b = (int)(Integer)k.next();\n                        if(in[i]=='*') res.add(new Integer(a * b));\n                        if(in[i]=='/' && b!=0) res.add(new Integer(a / b));\n                        if(in[i]=='+') res.add(new Integer(a + b));\n                        if(in[i]=='-') res.add(new Integer(a - b));\n                    }\n                }\n            }\n        }\n\n        if(kakko_num){\n            if(Character.isDigit(in[l])) res.add(new Integer(digit(l, r)));\n            else res = expr(l+1, r-1);\n        }\n\n        checked[l][r] = true;\n        return memo[l][r] = res;\n    }\n\n    int digit(int l, int r){\n        int res = 0;\n        int ten = r-l-1;\n        for(int i=l; i<r; i++){\n            if(i>l) res *= 10; \n            res += in[i]-'0';\n        }\n        return res;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n@SuppressWarnings(\"unchecked\")\nclass Main{\n\n    char[] in;\n    boolean[][] checked;\n    HashSet[][] memo;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            String s = sc.next();\n            if(s.equals(\"#\")) break;\n\n            in = s.toCharArray();\n            int n = in.length+1;\n            checked = new boolean[n][n];\n            memo = new HashSet[n][n];\n            System.out.println(expr(0, in.length).size());\n        }\n    }\n\n    HashSet<Integer> expr(int l, int r){\n        if(checked[l][r]) return memo[l][r];\n\n        int depth = 0;\n        HashSet<Integer> res = new HashSet<Integer>();\n        for(int i=l; i<r; i++){\n            if(in[i]=='(') depth++;\n            if(in[i]==')') depth--;\n            if((in[i]=='*' || in[i]=='/' || in[i]=='+' || in[i]=='-') && depth==0){\n                HashSet<Integer> left = expr(l, i);\n                HashSet<Integer> right = expr(i+1, r);\n\n                for(Iterator j=left.iterator(); j.hasNext();){\n                    int a = (int)(Integer)j.next();\n                    for(Iterator k=right.iterator(); k.hasNext();){\n                        int b = (int)(Integer)k.next();\n                        if(in[i]=='*') res.add(new Integer(a * b));\n                        if(in[i]=='/' && b!=0) res.add(new Integer(a / b));\n                        if(in[i]=='+') res.add(new Integer(a + b));\n                        if(in[i]=='-') res.add(new Integer(a - b));\n                    }\n                }\n            }\n        }\n\n        boolean num = true;\n        for(int i=l; i<r; i++) if(!Character.isDigit(in[i])) num = false;\n        if(num) res.add(new Integer(digit(l, r)));\n        if(res.size()==0 && in[l]=='(') res = expr(l+1, r-1);\n\n        checked[l][r] = true;\n        return memo[l][r] = res;\n    }\n\n    int digit(int l, int r){\n        int res = 0;\n        int ten = r-l;\n        for(int i=l; i<r; i++){\n            res += (in[i]-'0') * ten--;\n        }\n        return res;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\t\n//\tclass P {\n//\t\tint a, b;\n//\t\tP(int a, int b) {\n//\t\t\tthis.a = a;\n//\t\t\tthis.b = b;\n//\t\t}\n//\t\t\n//\t\tpublic boolean equals(Object obj) {\n//\t\t\tif(obj instanceof P){\n//\t\t\t\tP p=(P)obj;\n//\t\t\t\treturn this.a == p.a && this.b == p.b;\n//\t\t\t}\n//\t\t\treturn false;\n//\t\t}\n//\t}\n\t\n\tScanner sc = new Scanner(in);\n\t\n\tchar[] eq;\n\tint len;\n\t\n//\tMap<P, Set<Integer>> memo = new HashMap<P, Set<Integer>>();\n\t\n\tSet<Integer> calc(int a, int b) {\n//\t\tP p = new P(a, b);\n//\t\tif (!memo.containsKey(p)) {\n\t\tboolean flag = true;\n\t\t\tSet<Integer> set = new HashSet<Integer>();\n\t\t\tif (eq[a] == '(' && eq[b] ==')')\n\t\t\t\treturn calc(a+1, b-1);\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tfor (int i = a; i <= b; i++) {\n\t\t\t\tswitch(eq[i]) {\n\t\t\t\tcase '+':\n\t\t\t\t\tif (count == 0) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tfor (int k : calc(a, i-1))\n\t\t\t\t\t\t\tfor (int l : calc(i+1, b))\n\t\t\t\t\t\t\t\tset.add(k+l);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tif (count == 0) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tfor (int k : calc(a, i-1))\n\t\t\t\t\t\t\tfor (int l : calc(i+1, b))\n\t\t\t\t\t\t\t\tset.add(k-l);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\tif (count == 0) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tfor (int k : calc(a, i-1))\n\t\t\t\t\t\t\tfor (int l : calc(i+1, b))\n\t\t\t\t\t\t\t\tset.add(k*l);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '/':\n\t\t\t\t\tif (count == 0) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tfor (int k : calc(a, i-1))\n\t\t\t\t\t\t\tfor (int l : calc(i+1, b))\n\t\t\t\t\t\t\t\tif (l != 0)\n\t\t\t\t\t\t\t\t\tset.add(k/l);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '(':\n\t\t\t\t\tcount++; break;\n\t\t\t\tcase ')':\n\t\t\t\t\tcount--; break;\n\t\t\t\t}\n\t\n\t\t\t}\n\t\t\t\n\t\t\tif (flag) {\n\t\t\t\tint value = 0;\n\t\t\t\tfor (int i = a; i <= b; i++) {\n\t\t\t\t\tvalue = 10*value + Character.getNumericValue(eq[i]);\n\t\t\t\t}\n\t\t\t\tset.add(value);\n\t\t\t}\n\t\t\t\n//\t\t\tmemo.put(p, set);\n//\t\t}\n\t\t\n//\t\treturn memo.get(p);\n\t\t\treturn set;\n\t}\n\t\n\tvoid run() {\n\t\tString s;\n\t\twhile (true) {\n\t\t\ts = sc.nextLine();\n\t\t\tif (s.equals(\"#\")) break;\n\t\t\teq = s.toCharArray();\n\t\t\tlen = eq.length;\n//\t\t\tmemo.clear();\n\t\t\tout.println(calc(0, len-1).size());\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n@SuppressWarnings(\"unchecked\")\nclass Main{\n\n    char[] in;\n    boolean[][] checked;\n    HashSet[][] memo;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            String s = sc.next();\n            if(s.equals(\"#\")) break;\n\n            in = s.toCharArray();\n            int n = in.length+1;\n            checked = new boolean[n][n];\n            memo = new HashSet[n][n];\n            System.out.println(expr(0, in.length).size());\n        }\n    }\n\n    HashSet<Integer> expr(int l, int r){\n        if(checked[l][r]) return memo[l][r];\n\n        boolean kakko_num = true;\n        int depth = 0;\n        HashSet<Integer> res = new HashSet<Integer>();\n        for(int i=l; i<r; i++){\n            if(in[i]=='(') depth++;\n            if(in[i]==')') depth--;\n            if((in[i]=='*' || in[i]=='/' || in[i]=='+' || in[i]=='-') && depth==0){\n                kakko_num = false;\n                HashSet<Integer> left = expr(l, i);\n                HashSet<Integer> right = expr(i+1, r);\n\n                for(Iterator j=left.iterator(); j.hasNext();){\n                    int a = (int)(Integer)j.next();\n                    for(Iterator k=right.iterator(); k.hasNext();){\n                        int b = (int)(Integer)k.next();\n                        if(in[i]=='*') res.add(new Integer(a * b));\n                        if(in[i]=='/' && b!=0) res.add(new Integer(a / b));\n                        if(in[i]=='+') res.add(new Integer(a + b));\n                        if(in[i]=='-') res.add(new Integer(a - b));\n                    }\n                }\n            }\n        }\n\n        if(kakko_num){\n            //digit?\n            boolean num = true;\n            for(int i=l; i<r; i++) if(!Character.isDigit(in[i])) num = false;\n            if(num) res.add(new Integer(digit(l, r)));\n            //(gonyo)?\n            int depth2 = 0;\n            for(int i=l+1; i<r-1; i++){\n                if(in[i]=='(') depth2++;\n                if(in[i]==')') depth2--;\n            }\n            if(depth2==0 && in[l]=='(' && in[r-1]==')') res = expr(l+1, r-1);\n        }\n\n        checked[l][r] = true;\n        return memo[l][r] = res;\n    }\n\n    int digit(int l, int r){\n        int res = 0;\n        int ten = r-l;\n        for(int i=l; i<r; i++){\n            res += (in[i]-'0') * (int)Math.pow(10, ten--);\n        }\n        return res;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\t\n//\tclass P {\n//\t\tint a, b;\n//\t\tP(int a, int b) {\n//\t\t\tthis.a = a;\n//\t\t\tthis.b = b;\n//\t\t}\n//\t\t\n//\t\tpublic boolean equals(Object obj) {\n//\t\t\tif(obj instanceof P){\n//\t\t\t\tP p=(P)obj;\n//\t\t\t\treturn this.a == p.a && this.b == p.b;\n//\t\t\t}\n//\t\t\treturn false;\n//\t\t}\n//\t}\n\t\n\tScanner sc = new Scanner(in);\n\t\n\tchar[] eq;\n\tint len;\n\t\n//\tMap<P, Set<Integer>> memo = new HashMap<P, Set<Integer>>();\n\t\n\tSet<Integer> calc(int a, int b) {\n//\t\tP p = new P(a, b);\n//\t\tif (!memo.containsKey(p)) {\n\t\t\tSet<Integer> set = new HashSet<Integer>();\n\t\t\tif (eq[a] == '(' && eq[b] ==')')\n\t\t\t\treturn calc(a+1, b-1);\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tfor (int i = a; i <= b; i++) {\n\t\t\t\tswitch(eq[i]) {\n\t\t\t\tcase '+':\n\t\t\t\t\tif (count == 0)\n\t\t\t\t\t\tfor (int k : calc(a, i-1))\n\t\t\t\t\t\t\tfor (int l : calc(i+1, b))\n\t\t\t\t\t\t\t\tset.add(k+l);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tif (count == 0)\n\t\t\t\t\t\tfor (int k : calc(a, i-1))\n\t\t\t\t\t\t\tfor (int l : calc(i+1, b))\n\t\t\t\t\t\t\t\tset.add(k-l);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\tif (count == 0)\n\t\t\t\t\t\tfor (int k : calc(a, i-1))\n\t\t\t\t\t\t\tfor (int l : calc(i+1, b))\n\t\t\t\t\t\t\t\tset.add(k*l);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '/':\n\t\t\t\t\tif (count == 0)\n\t\t\t\t\t\tfor (int k : calc(a, i-1))\n\t\t\t\t\t\t\tfor (int l : calc(i+1, b))\n\t\t\t\t\t\t\t\tif (l != 0)\n\t\t\t\t\t\t\t\t\tset.add(k/l);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '(':\n\t\t\t\t\tcount++; break;\n\t\t\t\tcase ')':\n\t\t\t\t\tcount--; break;\n\t\t\t\t}\n\t\n\t\t\t}\n\t\t\t\n\t\t\tif (set.isEmpty()) {\n\t\t\t\tint value = 0;\n\t\t\t\tfor (int i = a; i <= b; i++) {\n\t\t\t\t\tvalue = 10*value + Character.getNumericValue(eq[i]);\n\t\t\t\t}\n\t\t\t\tset.add(value);\n\t\t\t}\n\t\t\t\n//\t\t\tmemo.put(p, set);\n//\t\t}\n\t\t\n//\t\treturn memo.get(p);\n\t\t\treturn set;\n\t}\n\t\n\tvoid run() {\n\t\tString s;\n\t\twhile (true) {\n\t\t\ts = sc.nextLine();\n\t\t\tif (s.equals(\"#\")) break;\n\t\t\teq = s.toCharArray();\n\t\t\tlen = eq.length;\n//\t\t\tmemo.clear();\n\t\t\tout.println(calc(0, len-1).size());\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node {\n    int index;\n    Set<Integer> set;\n  }\n\n  int func(int left, int right, char cmd) {\n    switch (cmd) {\n      case '+':\n        return left + right;\n      case '-':\n        return left - right;\n      case '*':\n        return left * right;\n      case '/':\n        if (right == 0) {\n          return Integer.MIN_VALUE;\n        }\n        return left / right;\n      default:\n        assert false;\n    }\n    assert false;\n    return Integer.MIN_VALUE;\n  }\n\n  Set<Integer> dfs(int t, boolean[] done, List<Character> enzansi, List<Set<Integer>> nums) {\n    if (t == done.length) {\n      return new TreeSet<>(nums.get(0));\n    }\n    Set<Integer> set = new TreeSet<>();\n    for (int i = 0; i < done.length; ++i) {\n      if (done[i]) {\n        continue;\n      }\n      int mouhitotu = -1;\n      for (int j = i + 1; j <= done.length; ++j) {\n        if (!done[j - 1]) {\n          mouhitotu = j;\n          break;\n        }\n      }\n      if (mouhitotu == -1) {\n        continue;\n      }\n      Set<Integer> left = nums.get(i);\n      Set<Integer> right = nums.get(mouhitotu);\n      char cmd = enzansi.get(mouhitotu - 1);\n      Set<Integer> next = new TreeSet<>();\n      for (int l : left) {\n        for (int r : right) {\n          int v = func(l, r, cmd);\n          if (v == Integer.MIN_VALUE) {\n            continue;\n          }\n          next.add(v);\n        }\n      }\n      Set<Integer> tmp = nums.get(i);\n      nums.set(i, next);\n      done[mouhitotu - 1] = true;\n      Set<Integer> ret = dfs(t + 1, done, enzansi, nums);\n      done[mouhitotu - 1] = false;\n      nums.set(i, tmp);\n      set.addAll(ret);\n    }\n    return set;\n  }\n\n  Node cal(String str, int index) {\n    List<Character> enzansi = new ArrayList<>();\n    List<Set<Integer>> nums = new ArrayList<>();\n    while (index < str.length() && str.charAt(index) != ')') {\n      if (str.charAt(index) == '(') {\n        Node node = cal(str, index + 1);\n        nums.add(node.set);\n        index = node.index;\n        assert str.charAt(index) == ')';\n        ++index;\n        continue;\n      }\n      char c = str.charAt(index);\n      if (Character.isDigit(c)) {\n        int num = 0;\n        while (index < str.length() && Character.isDigit(str.charAt(index))) {\n          char d = str.charAt(index);\n          num *= 10;\n          num += d - '0';\n          ++index;\n        }\n        TreeSet<Integer> set = new TreeSet<>();\n        set.add(num);\n        nums.add(set);\n      } else {\n        enzansi.add(c);\n        ++index;\n      }\n    }\n    Node ret = new Node();\n    ret.index = index;\n    boolean[] done = new boolean[enzansi.size()];\n    ret.set = dfs(0, done, enzansi, nums);\n    return ret;\n  }\n\n  void run() {\n    for (; ; ) {\n      String str = sc.next();\n      if (str.charAt(0) == '#') {\n        break;\n      }\n      Node ans = cal(str, 0);\n      assert ans.index == str.length();\n      System.out.println(ans.set.size());\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node {\n    int index;\n    Set<Integer> set;\n  }\n\n  int func(int left, int right, char cmd) {\n    switch (cmd) {\n      case '+':\n        return left + right;\n      case '-':\n        return left - right;\n      case '*':\n        return left * right;\n      case '/':\n        if (right == 0) {\n          return Integer.MIN_VALUE;\n        }\n        return left / right;\n      default:\n        assert false;\n    }\n    assert false;\n    return Integer.MIN_VALUE;\n  }\n\n  Set<Integer> dfs(int t, boolean[] done, List<Character> enzansi, List<Set<Integer>> nums) {\n    if (t == done.length - 1) {\n      return new TreeSet<>(nums.get(0));\n    }\n    Set<Integer> set = new TreeSet<>();\n    for (int i = 0; i < done.length; ++i) {\n      if (done[i]) {\n        continue;\n      }\n      int mouhitotu = -1;\n      for (int j = i + 1; j < done.length; ++j) {\n        if (!done[j]) {\n          mouhitotu = j;\n          break;\n        }\n      }\n      if (mouhitotu == -1) {\n        continue;\n      }\n      Set<Integer> left = nums.get(i);\n      Set<Integer> right = nums.get(mouhitotu);\n      char cmd = enzansi.get(mouhitotu - 1);\n      Set<Integer> next = new TreeSet<>();\n      for (int l : left) {\n        for (int r : right) {\n          int v = func(l, r, cmd);\n          if (v == Integer.MIN_VALUE) {\n            continue;\n          }\n          next.add(v);\n        }\n      }\n      Set<Integer> tmp = nums.get(i);\n      nums.set(i, next);\n      done[mouhitotu] = true;\n      Set<Integer> ret = dfs(t + 1, done, enzansi, nums);\n      done[mouhitotu] = false;\n      nums.set(i, tmp);\n      set.addAll(ret);\n    }\n    return set;\n  }\n\n  Node cal(String str, int index) {\n    List<Character> enzansi = new ArrayList<>();\n    List<Set<Integer>> nums = new ArrayList<>();\n    while (index < str.length() && str.charAt(index) != ')') {\n      if (str.charAt(index) == '(') {\n        Node node = cal(str, index + 1);\n        nums.add(node.set);\n        index = node.index;\n        assert str.charAt(index) == ')';\n        ++index;\n        continue;\n      }\n      char c = str.charAt(index);\n      if (Character.isDigit(c)) {\n        int num = 0;\n        while (index < str.length() && Character.isDigit(str.charAt(index))) {\n          char d = str.charAt(index);\n          num *= 10;\n          num += d - '0';\n          ++index;\n        }\n        TreeSet<Integer> set = new TreeSet<>();\n        set.add(num);\n        nums.add(set);\n      } else {\n        enzansi.add(c);\n        ++index;\n      }\n    }\n    Node ret = new Node();\n    ret.index = index;\n    boolean[] done = new boolean[nums.size()];\n    ret.set = dfs(0, done, enzansi, nums);\n    return ret;\n  }\n\n  void run() {\n    for (; ; ) {\n      String str = sc.next();\n      if (str.charAt(0) == '#') {\n        break;\n      }\n      Node ans = cal(str, 0);\n      assert ans.index == str.length();\n      System.out.println(ans.set.size());\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node {\n    int index;\n    Set<Integer> set;\n  }\n\n  int func(int left, int right, char cmd) {\n    switch (cmd) {\n      case '+':\n        return left + right;\n      case '-':\n        return left - right;\n      case '*':\n        return left * right;\n      case '/':\n        if (right == 0) {\n          return Integer.MIN_VALUE;\n        }\n        return left / right;\n      default:\n        assert false;\n    }\n    assert false;\n    return Integer.MIN_VALUE;\n  }\n\n  Set<Integer> dfs(int t, int done, List<Character> enzansi, List<Set<Integer>> nums) {\n    if (t == enzansi.size()) {\n      return new HashSet<>(nums.get(0));\n    }\n    Set<Integer> set = new HashSet<>();\n    for (int i = 0; i < nums.size(); ++i) {\n      if (((done >> i) & 1) == 1) {\n        continue;\n      }\n      int mouhitotu = -1;\n      for (int j = i + 1; j < nums.size(); ++j) {\n        if (((done >> j) & 1) == 0) {\n          mouhitotu = j;\n          break;\n        }\n      }\n      if (mouhitotu == -1) {\n        continue;\n      }\n      Set<Integer> left = nums.get(i);\n      Set<Integer> right = nums.get(mouhitotu);\n      char cmd = enzansi.get(mouhitotu - 1);\n      Set<Integer> next = new TreeSet<>();\n      for (int l : left) {\n        for (int r : right) {\n          int v = func(l, r, cmd);\n          if (v == Integer.MIN_VALUE) {\n            continue;\n          }\n          next.add(v);\n        }\n      }\n      Set<Integer> tmp = nums.get(i);\n      nums.set(i, next);\n      Set<Integer> ret = dfs(t + 1, done | 1 << mouhitotu, enzansi, nums);\n      nums.set(i, tmp);\n      set.addAll(ret);\n    }\n    return set;\n  }\n\n  Node cal(String str, int index) {\n    List<Character> enzansi = new ArrayList<>();\n    List<Set<Integer>> nums = new ArrayList<>();\n    while (index < str.length() && str.charAt(index) != ')') {\n      if (str.charAt(index) == '(') {\n        Node node = cal(str, index + 1);\n        nums.add(node.set);\n        index = node.index;\n        assert str.charAt(index) == ')';\n        ++index;\n        continue;\n      }\n      char c = str.charAt(index);\n      if (Character.isDigit(c)) {\n        int num = 0;\n        while (index < str.length() && Character.isDigit(str.charAt(index))) {\n          char d = str.charAt(index);\n          num *= 10;\n          num += d - '0';\n          ++index;\n        }\n        Set<Integer> set = new HashSet<>();\n        set.add(num);\n        nums.add(set);\n      } else {\n        enzansi.add(c);\n        ++index;\n      }\n    }\n    Node ret = new Node();\n    ret.index = index;\n    ret.set = dfs(0, 0, enzansi, nums);\n    return ret;\n  }\n\n  void run() {\n    for (; ; ) {\n      String str = sc.next();\n      if (str.charAt(0) == '#') {\n        break;\n      }\n      Node ans = cal(str, 0);\n      assert ans.index == str.length();\n      System.out.println(ans.set.size());\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node {\n    int index;\n    Set<Integer> set;\n  }\n\n  int func(int left, int right, char cmd) {\n    switch (cmd) {\n      case '+':\n        return left + right;\n      case '-':\n        return left - right;\n      case '*':\n        return left * right;\n      case '/':\n        return left / right;\n      default:\n        assert false;\n    }\n    assert false;\n    return Integer.MIN_VALUE;\n  }\n\n  Set<Integer> dfs(List<Character> enzansi, List<Set<Integer>> nums) {\n    assert enzansi.size() + 1 == nums.size();\n    if (enzansi.size() == 0) {\n      return new TreeSet<>(nums.get(0));\n    }\n    Set<Integer> set = new TreeSet<>();\n    for (int i = 0; i < enzansi.size(); ++i) {\n      Set<Integer> left = nums.get(i);\n      Set<Integer> right = nums.get(i + 1);\n      char cmd = enzansi.get(i);\n      Set<Integer> next = new TreeSet<>();\n      for (int l : left) {\n        for (int r : right) {\n          int v = func(l, r, cmd);\n          next.add(v);\n        }\n      }\n      List<Character> ne = new ArrayList<>();\n      for (int j = 0; j < enzansi.size(); ++j) {\n        if (j == i) {\n          continue;\n        }\n        ne.add(enzansi.get(j));\n      }\n      List<Set<Integer>> nn = new ArrayList<>();\n      for (int j = 0; j < nums.size(); ++j) {\n        if (j == i) {\n          nn.add(next);\n          continue;\n        }\n        if (j == i + 1) {\n          continue;\n        }\n        nn.add(nums.get(j));\n      }\n      Set<Integer> ret = dfs(ne, nn);\n      set.addAll(ret);\n    }\n    return set;\n  }\n\n  Node cal(String str, int index) {\n    List<Character> enzansi = new ArrayList<>();\n    List<Set<Integer>> nums = new ArrayList<>();\n    while (index < str.length() && str.charAt(index) != ')') {\n      if (str.charAt(index) == '(') {\n        Node node = cal(str, index + 1);\n        nums.add(node.set);\n        index = node.index;\n        assert str.charAt(index) == ')';\n        ++index;\n        continue;\n      }\n      char c = str.charAt(index);\n      if (Character.isDigit(c)) {\n        int num = 0;\n        while (index < str.length() && Character.isDigit(str.charAt(index))) {\n          char d = str.charAt(index);\n          num *= 10;\n          num += d - '0';\n          ++index;\n        }\n        TreeSet<Integer> set = new TreeSet<>();\n        set.add(num);\n        nums.add(set);\n      } else {\n        enzansi.add(c);\n        ++index;\n      }\n    }\n    Node ret = new Node();\n    ret.index = index;\n    ret.set = dfs(enzansi, nums);\n    return ret;\n  }\n\n  void run() {\n    for (; ; ) {\n      String str = sc.next();\n      if (str.charAt(0) == '#') {\n        break;\n      }\n      Node ans = cal(str, 0);\n      assert ans.index == str.length();\n      System.out.println(ans.set.size());\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main{\n\n\tpublic static String s;\n\tpublic static int index;\n\t\n\tpublic static char c(){\n\t\treturn s.charAt(index++);\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static Set<Integer> calc(List<Set<Integer>> list, List<Character> ope){\n\t\tint n = list.size();\n\t\tSet<Integer>[][] dp = new Set[n][n];\n\t\tfor(int i=0;i<n;i++)dp[i][i]=list.get(i);\n\t\tfor(int w=1;w<n;w++){\n\t\t\tfor(int i=0;i+w<n;i++){\n\t\t\t\tSet<Integer> res = new HashSet<Integer>();\n\t\t\t\tfor(int k=i;k<i+w;k++){\n\t\t\t\t\tfor(int x : dp[i][k]){\n\t\t\t\t\t\tchar ch = ope.get(k);\n\t\t\t\t\t\tfor(int y : dp[k+1][i+w]){\n\t\t\t\t\t\t\tswitch(ch){\n\t\t\t\t\t\t\tcase '+': res.add(x+y);break;\n\t\t\t\t\t\t\tcase '-': res.add(x-y);break;\n\t\t\t\t\t\t\tcase '*': res.add(x*y);break;\n\t\t\t\t\t\t\tcase '/': if(y==0)break;else res.add(x/y);break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[i][i+w] = res;\n\t\t\t}\n\t\t}\n\t\treturn dp[0][n-1];\n\t}\n\t\n\tpublic static Set<Integer> exp(){\n\t\tList<Set<Integer>> list = new ArrayList<Set<Integer>>();\n\t\tList<Character> ope = new ArrayList<Character>();\n\t\twhile(true){\n\t\t\tchar ch = c();\n\t\t\tif(Character.isDigit(ch)){\n\t\t\t\tindex--;\n\t\t\t\tSet<Integer> a = new HashSet<Integer>();\n\t\t\t\ta.add(num());\n\t\t\t\tlist.add(a);\n\t\t\t}\n\t\t\telse if(ch=='('){\n\t\t\t\tlist.add(kakko());\n\t\t\t}\n\t\t\telse if(ch=='$')break;\n\t\t\telse {\n\t\t\t\tope.add(ch);\n\t\t\t}\n\t\t}\n\t\treturn calc(list, ope);\n\t}\n\t\n\tpublic static Set<Integer> kakko(){\n\t\tList<Set<Integer>> list = new ArrayList<Set<Integer>>();\n\t\tList<Character> ope = new ArrayList<Character>();\n\t\twhile(true){\n\t\t\tchar ch = c();\n\t\t\tif(ch=='('){\n\t\t\t\tlist.add(kakko());\n\t\t\t}\n\t\t\telse if(Character.isDigit(ch)){\n\t\t\t\tindex--;\n\t\t\t\tSet<Integer> a = new HashSet<Integer>();\n\t\t\t\ta.add(num());\n\t\t\t\tlist.add(a);\n\t\t\t}\n\t\t\telse if(ch==')'||ch=='$') break;\n\t\t\telse {\n\t\t\t\tope.add(ch);\n\t\t\t}\n\t\t}\n\t\treturn calc(list, ope);\n\t}\n\t\n\tpublic static int num(){\n\t\tchar ch = c();\n\t\tint ans = ch-'0';\n\t\twhile(Character.isDigit(ch)){\n\t\t\tch = c();\n\t\t\tif(!Character.isDigit(ch))break;\n\t\t\tans *= 10;\n\t\t\tans += ch-'0';\n\t\t}\n\t\tindex--;\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tboolean debug = true;\n\t\tif(!debug){\n\t\t\ttry {\n\t\t\t\tSystem.setOut(new PrintStream(new File(\"./src/icpc/D.txt\")));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\ts = sc.next();\n\t\t\tif(s.equals(\"#\"))break;\n\t\t\ts = s+\"$\";\n\t\t\tindex = 0;\n\t\t\tSystem.out.println(exp().size());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n@SuppressWarnings(\"unchecked\")\nclass Main{\n\n    char[] in;\n    boolean[][] checked;\n    HashSet[][] memo;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            String s = sc.next();\n            if(s.equals(\"#\")) break;\n\n            in = s.toCharArray();\n            int n = in.length+1;\n            checked = new boolean[n][n];\n            memo = new HashSet[n][n];\n            System.out.println(expr(0, in.length).size());\n        }\n    }\n\n    HashSet<Integer> expr(int l, int r){\n        if(checked[l][r]) return memo[l][r];\n\n        int depth = 0;\n        HashSet<Integer> res = new HashSet<Integer>();\n        for(int i=l; i<r; i++){\n            if(in[i]=='(') depth++;\n            if(in[i]==')') depth--;\n            if((in[i]=='*' || in[i]=='/' || in[i]=='+' || in[i]=='-') && depth==0){\n                HashSet<Integer> left = expr(l, i);\n                HashSet<Integer> right = expr(i+1, r);\n\n                for(Iterator j=left.iterator(); j.hasNext();){\n                    int a = (int)(Integer)j.next();\n                    for(Iterator k=right.iterator(); k.hasNext();){\n                        int b = (int)(Integer)k.next();\n                        if(in[i]=='*') res.add(new Integer(a * b));\n                        if(in[i]=='/' && b!=0) res.add(new Integer(a / b));\n                        if(in[i]=='+') res.add(new Integer(a + b));\n                        if(in[i]=='-') res.add(new Integer(a - b));\n                    }\n                }\n            }\n        }\n\n        boolean num = true;\n        for(int i=l; i<r; i++) if(!Character.isDigit(in[i])) num = false;\n        if(num) res.add(new Integer(digit(l, r)));\n        int depth2 = 0;\n        for(int i=l+1; i<r-1; i++){\n            if(in[i]=='(') depth2++;\n            if(in[i]==')') depth2--;\n        }\n        if(depth2==0 && in[l]=='(' && in[r-1]==')') res = expr(l+1, r-1);\n\n        checked[l][r] = true;\n        return memo[l][r] = res;\n    }\n\n    int digit(int l, int r){\n        int res = 0;\n        int ten = r-l;\n        for(int i=l; i<r; i++){\n            res += (in[i]-'0') * ten--;\n        }\n        return res;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n@SuppressWarnings(\"unchecked\")\nclass Main{\n\n    char[] in;\n    boolean[][] checked;\n    HashSet[][] memo;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            String s = sc.next();\n            if(s.equals(\"#\")) break;\n\n            in = s.toCharArray();\n            int n = in.length+1;\n            checked = new boolean[n][n];\n            memo = new HashSet[n][n];\n            System.out.println(expr(0, in.length).size());\n        }\n    }\n\n    HashSet<Integer> expr(int l, int r){\n        if(checked[l][r]) return memo[l][r];\n\n        boolean kakko_num = true;\n        int depth = 0;\n        HashSet<Integer> res = new HashSet<Integer>();\n        for(int i=l; i<r; i++){\n            if(in[i]=='(') depth++;\n            if(in[i]==')') depth--;\n            if((in[i]=='*' || in[i]=='/' || in[i]=='+' || in[i]=='-') && depth==0){\n                kakko_num = false;\n                HashSet<Integer> left = expr(l, i);\n                HashSet<Integer> right = expr(i+1, r);\n\n                for(Iterator j=left.iterator(); j.hasNext();){\n                    int a = (int)(Integer)j.next();\n                    for(Iterator k=right.iterator(); k.hasNext();){\n                        int b = (int)(Integer)k.next();\n                        if(in[i]=='*') res.add(new Integer(a * b));\n                        if(in[i]=='/' && b!=0) res.add(new Integer(a / b));\n                        if(in[i]=='+') res.add(new Integer(a + b));\n                        if(in[i]=='-') res.add(new Integer(a - b));\n                    }\n                }\n            }\n        }\n\n        if(kakko_num){\n            //digit?\n            boolean num = true;\n            for(int i=l; i<r; i++) if(!Character.isDigit(in[i])) num = false;\n            if(num) res.add(new Integer(digit(l, r)));\n            //(gonyo)?\n            int depth2 = 0;\n            for(int i=l+1; i<r-1; i++){\n                if(in[i]=='(') depth2++;\n                if(in[i]==')') depth2--;\n            }\n            if(depth2==0 && in[l]=='(' && in[r-1]==')') res = expr(l+1, r-1);\n        }\n\n        checked[l][r] = true;\n        return memo[l][r] = res;\n    }\n\n    int digit(int l, int r){\n        int res = 0;\n        int ten = r-l;\n        for(int i=l; i<r; i++){\n            res += (in[i]-'0') * ten--;\n        }\n        return res;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.EnumMap;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeSet;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\twhile (true) {\n\t\t\ts = br.readLine();\n\t\t\tif (s.equals(\"#\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti = 0;\n\t\t\t\n\t\t\tSystem.out.println(buildExprTree().getResults().size());\n\t\t\t\n//\t\t\tPermutation p = new Permutation(4);\n//\t\t\tdo {\n//\t\t\t\tSystem.out.println(Arrays.toString(p.data));\n//\t\t\t} while(p.nextPermutaion());\n\t\t\t\n\t\t}\n\t}\n\t\n\tstatic enum State {\n\t\tNONE, NUM, OPER\n\t}\n\t\n\tstatic int i = 0;\n\tstatic String s;\n\t\n\tstatic Expr buildExprTree() {\n\t\tint numTemp = 0;\n\t\tState state = State.NONE;\n\t\tList<Expr> exprs = new ArrayList<Expr>();\n\t\tList<Operator> opers = new ArrayList<Operator>();\n\t\t\n\t\tfor (; i < s.length(); i++) {\n\t\t\tchar c = s.charAt(i);\n\t\t\tif(Character.isDigit(c)) {\n\t\t\t\tif(state != State.NUM) {\n\t\t\t\t\tstate = State.NUM;\n\t\t\t\t\tnumTemp = c - '0';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnumTemp *= 10;\n\t\t\t\t\tnumTemp += c - '0';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(state == State.NUM) {\n\t\t\t\t\texprs.add(new Num(numTemp));\n\t\t\t\t\t//System.out.println(\"detected:\" + numTemp);\n\t\t\t\t\tstate = State.OPER;\n\t\t\t\t}\n\t\t\t\tif(c == '(') {\n\t\t\t\t\ti++;\n\t\t\t\t\texprs.add(buildExprTree());\n\t\t\t\t}\n\t\t\t\telse if(c == ')') {\n\t\t\t\t\treturn new BraceExpr(exprs, opers);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\topers.add(Operator.operatorMap.get(c));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(state == State.NUM) {\n\t\t\texprs.add(new Num(numTemp));\n\t\t}\n\t\treturn new BraceExpr(exprs, opers);\n\t\t\n\t}\n\t\n\tstatic abstract class Expr {\n\t\tSet<Integer> results;\n\t\t\n\t\tSet<Integer> getResults() {\n\t\t\tif(results == null)\n\t\t\t\treturn results = computeResults();\n\t\t\treturn results;\n\t\t}\n\t\t\n\t\tabstract Set<Integer> computeResults();\n\t}\n\t\n\tstatic class BraceExpr extends Expr {\n\n\t\tfinal List<Expr> exprs;\n\t\tfinal List<Operator> opers;\n\t\t\n\t\tpublic BraceExpr(List<Expr> exprs, List<Operator> opers) {\n\t\t\tsuper();\n\t\t\tthis.exprs = exprs;\n\t\t\tthis.opers = opers;\n\t\t}\n\n\t\t@Override\n\t\tSet<Integer> computeResults() {\n\t\t\tint size = exprs.size();\n\t\t\t\n\t\t\tif(size == 0)\n\t\t\t\treturn Collections.emptySet();\n\t\t\tif(size == 1)\n\t\t\t\treturn exprs.get(0).computeResults();\n\t\t\t\n\n\t\t\tSet<Integer> mergeResults = new HashSet<Integer>();\n\t\t\t\n\t\t\tPermutation p = new Permutation(opers.size());\n\t\t\tdo {\n\t\t\t\tSet<Integer>[] resultList = new Set[size]; \n\t\t\t\tfor (int i = 0; i < resultList.length; i++) {\n\t\t\t\t\tresultList[i] = exprs.get(i).getResults();\n\t\t\t\t}\n\t\t\t\tUnionFind uf = new UnionFind(size);\n\t\t\t\t\n\t\t\t\tfor (int i = 0; i < opers.size(); i++) {\n\t\t\t\t\tint left = uf.find(p.data[i]);\n\t\t\t\t\tint right = uf.find(p.data[i] + 1);\n\t\t\t\t\tOperator op = opers.get(p.data[i]);\n\t\t\t\t\tuf.unite(left, right);\n\n\t\t\t\t\tSet<Integer> leftResults = resultList[left];\n\t\t\t\t\tSet<Integer> rightResults = resultList[right];\n\t\t\t\t\tSet<Integer> results = new HashSet<Integer>();\n\t\t\t\t\t\n\t\t\t\t\tfor (int a : leftResults) {\n\t\t\t\t\t\tfor (int b : rightResults) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tresults.add(op.operate(a, b));\n\t\t\t\t\t\t\t} catch (ArithmeticException e) {\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tresultList[left] = resultList[right] = results;\n\t\t\t\t}\n\t\t\t\tfor (Integer n : resultList[uf.find(0)]) {\n\t\t\t\t\tmergeResults.add(n);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t} while(p.nextPermutaion());\n\t\t\t\n\t\t\t\n\t\t\treturn mergeResults;\n\t\t}\n\t\t\n\t}\n\t\n\tstatic class Num extends Expr {\n\n\t\tfinal int n;\n\t\t\n\t\tpublic Num(int n) {\n\t\t\tsuper();\n\t\t\tthis.n = n;\n\t\t}\n\n\t\t@Override\n\t\tSet<Integer> computeResults() {\n\t\t\treturn Collections.singleton(n);\n\t\t}\n\t}\n\t\n\tstatic class UnionFind {\n\t\tfinal int[] data;\n\n\t\tpublic UnionFind(int size) {\n\t\t\tdata = new int[size];\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tdata[i] = i;\n\t\t\t}\n\t\t}\n\n\t\tint find(int x) {\n\t\t\tif(data[x] == x)\n\t\t\t\treturn x;\n\t\t\telse\n\t\t\t\treturn data[x] = find(data[x]);\n\t\t}\n\n\t\tvoid unite(int x, int y) {\n\t\t\tdata[x] = data[y];\n\t\t}\n\t}\n\t\n\tstatic class Permutation {\n\t\tfinal int[] data;\n\t\tfinal TreeSet<Integer> temp = new TreeSet<Integer>();\n\n\t\tpublic Permutation(int size) {\n\t\t\tdata = new int[size];\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tdata[i] = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean nextPermutaion() {\n\t\t\tint i = data.length - 1;\n\t\t\ttemp.clear();\n\t\t\ttemp.add(data[i--]);\n\t\t\twhile (i >= 0) {\n\t\t\t\tInteger minGreater = temp.higher(data[i]);\n\t\t\t\tif(minGreater == null) {\n\t\t\t\t\ttemp.add(data[i--]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttemp.add(data[i]);\n\t\t\t\t\ttemp.remove(minGreater);\n\t\t\t\t\tdata[i++] = minGreater;\n\t\t\t\t\tfor (; i < data.length; i++) {\n\t\t\t\t\t\tdata[i] = temp.pollFirst();\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tstatic enum Operator {\n\t\tPLUS('+') {\n\t\t\t@Override\n\t\t\tint operate(int a, int b) {\n\t\t\t\treturn a+b;\n\t\t\t}\n\t\t},\n\t\tSUB('-') {\n\t\t\t@Override\n\t\t\tint operate(int a, int b) {\n\t\t\t\treturn a-b;\n\t\t\t}\n\t\t},\n\t\tMULTI('*') {\n\t\t\t@Override\n\t\t\tint operate(int a, int b) {\n\t\t\t\treturn a*b;\n\t\t\t}\n\t\t},\n\t\tDIV('/') {\n\t\t\t@Override\n\t\t\tint operate(int a, int b) {\n\t\t\t\treturn a/b;\n\t\t\t}\n\t\t};\n\t\tfinal char operator;\n\t\t\n\t\tprivate Operator(char o) {\n\t\t\toperator = o;\n\t\t}\n\t\t\n\t\t/**\n\t\t * @throws ArithmeticException\n\t\t */\n\t\tabstract int operate(int a, int b);\n\t\t\n\t\tstatic final Map<Character, Operator> operatorMap = new HashMap<Character, Operator>() {\n\t\t\t{\n\t\t\t\tfor (Operator operator : Operator.values()) {\n\t\t\t\t\tput(operator.operator, operator);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static char[] op = new char[10];\n\tpublic static String[] val2 = new String[11];\n\tpublic static int[] val = new int[11];\n\tpublic static int[] nest = new int[10];\n\tpublic static int numOfOp = 0;\n\tpublic static int maxNest = 0;\n\tpublic static TreeSet<Integer> tree = null;\n\tpublic static int[] order = new int[10];\n\tpublic static boolean[] used = new boolean[10];\n\tpublic static String last = null;\n\tpublic static int len = 0;\n\tpublic static int point = 0;\n\tpublic static boolean nan = false;\n\tpublic static void main(String[] args) {\n\t\tdoIt();\n\n\t}\n\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tString input = sc.next();\n\t\twhile(input.equals(\"#\") == false){\n\t\t\tanalyze(input);\n\t\t\t//printVal();\n\t\t\tArrays.fill(used, false);\n\t\t\ttree = new TreeSet<Integer>();\n\t\t\tsetOrder(0,maxNest);\n\t\t\tSystem.out.println(tree.size());\n\t\t\t//printVal();\n\t\t\tinput = sc.next();\n\t\t}\n\t}\n\t\n\tpublic static int getNext(){\n\t\tint ret = 0, left = 0, right = 0;\n\t\tchar c = last.charAt(point);\n\t\twhile(c == ' '){\n\t\t\tpoint--;\n\t\t\tc = last.charAt(point);\n\t\t}\n\t\t\n\t\tif(c == '+'){\n\t\t\tpoint--;\n\t\t\tright = getNext();\n\t\t\t//point--;\n\t\t\tleft = getNext();\n\t\t\t//point--;\n\t\t\tret = left + right;\n\t\t}\n\t\telse if(c == '-'){\n\t\t\tpoint--;\n\t\t\tright = getNext();\n\t\t\t//point--;\n\t\t\tleft = getNext();\n\t\t\t//point--;\n\t\t\tret = left - right;\n\t\t}\n\t\telse if(c == '*'){\n\t\t\tpoint--;\n\t\t\tright = getNext();\n\t\t\t//point--;\n\t\t\tleft = getNext();\n\t\t\t//point--;\n\t\t\tret = left * right;\n\t\t}\n\t\telse if(c == '/'){\n\t\t\tpoint--;\n\t\t\tright = getNext();\n\t\t\t//point--;\n\t\t\tleft = getNext();\n\t\t\t//point--;\n\t\t\tif(right == 0){\n\t\t\t\tnan = true;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tret = left / right;\n\t\t\t}\n\t\t}\n//\t\telse if(c == '('){\n//\t\t\tpoint++;\n//\t\t\tret = getNext();\n//\t\t\t//)の分跳ばす\n//\t\t\tpoint++;\n//\t\t}\n\t\telse{\n\t\t\t//数字のはず\n\t\t\tif(c == 'a'){\n\t\t\t\tret = val[10];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tret = val[Character.getNumericValue(c)];\n\t\t\t}\n\t\t\tpoint--;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\t//文字列lastを数字に変換\n\tpublic static void calc(){\n\t\tnan = false;\n\t\tlen = last.length();\n\t\tpoint = len - 1;\n\t\t//System.out.println(\"last = \" + last);\n\t\t//printVal();\n\t\tint res = getNext();\n\t\t//System.out.println(\"res = \" + res);\n\t\tif(nan == false && tree.contains(res) == false){\n\t\t\ttree.add(res);\n\t\t}\n\t}\n\t\n\tpublic static void printVal(){\n\t\tfor(String a : val2){\n\t\t\tSystem.out.print(a + \", \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\t//ネストnの大きな順に後置記法のストリングを作って結合していく\n\tpublic static void setOrder(int depth, int nLevel){\n\t\tif(depth == numOfOp){\n\t\t\tcalc();\n\t\t}\n\t\tboolean bOK = false;\n\t\tfor(int i = 0; i < numOfOp; i++){\n\t\t\tif(nest[i] == nLevel){\n\t\t\t\tif(used[i] == false){\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\t//System.out.println(\"val[i] = \" + val[i] + \", val[i+1] = \" + val[i+1]);\n\t\t\t\t\tlast = val2[i] + ' ' + val2[i+1] + ' ' + op[i];\n\t\t\t\t\t//System.out.println(\"ONE : depth = \" + depth + \", nLevel = \" + nLevel);\n\t\t\t\t\t//printVal();\n\t\t\t\t\t//左を見る\n\t\t\t\t\tint left = -1;\n\t\t\t\t\tString lValue = null;\n\t\t\t\t\tfor(int j = i - 1; j >= 0; j--){\n\t\t\t\t\t\tif(used[j] == false){\n\t\t\t\t\t\t\tleft = j;\n\t\t\t\t\t\t\tlValue = val2[j + 1];\n\t\t\t\t\t\t\tval2[j + 1] = last;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//右を見る\n\t\t\t\t\tint right = -1;\n\t\t\t\t\tString rValue = null;\n\t\t\t\t\tfor(int j = i + 1; j < numOfOp; j++){\n\t\t\t\t\t\tif(used[j] == false){\n\t\t\t\t\t\t\tright = j;\n\t\t\t\t\t\t\trValue = val2[j];\n\t\t\t\t\t\t\tval2[j] = last;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsetOrder(depth + 1, nLevel);\n\t\t\t\t\t\n\t\t\t\t\t//修復作業\n\t\t\t\t\tif(left != -1){\n\t\t\t\t\t\tval2[left + 1] = lValue;\n\t\t\t\t\t}\n\t\t\t\t\tif(right != -1){\n\t\t\t\t\t\tval2[right] = rValue;\n\t\t\t\t\t}\n\t\t\t\t\t//System.out.println(\"TWO : depth = \" + depth + \", nLevel = \" + nLevel);\n\t\t\t\t\t//printVal();\n\t\t\t\t\tused[i] = false;\n\t\t\t\t\tbOK = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(bOK == false){\n\t\t\tif(nLevel != 0){\n\t\t\t\tsetOrder(depth, nLevel - 1);\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\tpublic static void analyze(String input){\n\t\tnumOfOp = 0;\n\t\tmaxNest = 0;\n\t\tint nestLevel = 0;\n\t\tint v = 0;\n\t\tint len = input.length(); \n\t\tfor(int i = 0; i < len; i++){\n\t\t\tchar c = input.charAt(i);\n\t\t\tswitch(c){\n\t\t\tcase '(':\n\t\t\t\tnestLevel++;\n\t\t\t\tmaxNest = Math.max(nestLevel, maxNest);\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tnestLevel--;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\tcase '-':\n\t\t\tcase '*':\n\t\t\tcase '/':\n\t\t\t\top[numOfOp] = c;\n\t\t\t\tnest[numOfOp] = nestLevel;\n\t\t\t\tnumOfOp++;\n\t\t\t\tbreak;\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '4':\n\t\t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\t\t\tcase '8':\n\t\t\tcase '9':\n\t\t\t\tString ss = \"\";\n\t\t\t\twhile('0' <= c && c <= '9'){\n\t\t\t\t\tss += String.valueOf(c);\n\t\t\t\t\ti++;\n\t\t\t\t\tif(len <= i){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tc = input.charAt(i);\n\t\t\t\t}\n\t\t\t\ti--;\n\t\t\t\tval[v] = Integer.parseInt(ss);\n\t\t\t\tif(v == 10){\n\t\t\t\t\tval2[v] = \"a\";\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tval2[v] = String.valueOf(v);\n\t\t\t\t}\n\t\t\t\tv++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n@SuppressWarnings(\"unchecked\")\nclass Main{\n\n    char[] in;\n    boolean[][] checked;\n    HashSet[][] memo;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            String s = sc.next();\n            if(s.equals(\"#\")) break;\n\n            in = s.toCharArray();\n            int n = in.length+1;\n            checked = new boolean[n][n];\n            memo = new HashSet[n][n];\n            System.out.println(expr(0, in.length).size());\n        }\n    }\n\n    HashSet<Integer> expr(int l, int r){\n        if(checked[l][r]) return memo[l][r];\n\n        boolean kakko_num = true;\n        int depth = 0;\n        HashSet<Integer> res = new HashSet<Integer>();\n        for(int i=l; i<r; i++){\n            if(in[i]=='(') depth++;\n            if(in[i]==')') depth--;\n            if((in[i]=='*' || in[i]=='/' || in[i]=='+' || in[i]=='-') && depth==0){\n                kakko_num = false;\n                HashSet<Integer> left = expr(l, i);\n                HashSet<Integer> right = expr(i+1, r);\n\n                for(Iterator j=left.iterator(); j.hasNext();){\n                    int a = (int)(Integer)j.next();\n                    for(Iterator k=right.iterator(); k.hasNext();){\n                        int b = (int)(Integer)k.next();\n                        if(in[i]=='*') res.add(new Integer(a * b));\n                        if(in[i]=='/' && b!=0) res.add(new Integer(a / b));\n                        if(in[i]=='+') res.add(new Integer(a + b));\n                        if(in[i]=='-') res.add(new Integer(a - b));\n                    }\n                }\n            }\n        }\n\n        if(kakko_num){\n            //digit?\n            boolean num = true;\n            for(int i=l; i<r; i++) if(!Character.isDigit(in[i])) num = false;\n            if(num) res.add(new Integer(digit(l, r)));\n            //(gonyo)?\n            int depth2 = 0;\n            for(int i=l+1; i<r-1; i++){\n                if(in[i]=='(') depth2++;\n                if(in[i]==')') depth2--;\n            }\n            if(depth2==0 && in[l]=='(' && in[r-1]==')') res = expr(l+1, r-1);\n        }\n\n        checked[l][r] = true;\n        return memo[l][r] = res;\n    }\n\n    int digit(int l, int r){\n        int res = 0;\n        int ten = r-l-1;\n        for(int i=l; i<r; i++){\n            res += (in[i]-'0') * (int)Math.pow(10, ten--);\n        }\n        return res;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//D: 6/2(1+2)\npublic class Main{\n\n\tpublic static String s;\n\tpublic static int index;\n\t\n\tpublic static char c(){\n\t\treturn s.charAt(index++);\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static Set<Integer> calc(List<Set<Integer>> list, List<Character> ope){\n\t\tint n = list.size();\n\t\tSet<Integer>[][] dp = new Set[n][n];\n\t\tfor(int i=0;i<n;i++)dp[i][i]=list.get(i);\n\t\tfor(int w=1;w<n;w++){\n\t\t\tfor(int i=0;i+w<n;i++){\n\t\t\t\tSet<Integer> res = new HashSet<Integer>();\n\t\t\t\tfor(int k=i;k<i+w;k++){\n\t\t\t\t\tfor(int x : dp[i][k]){\n\t\t\t\t\t\tchar ch = ope.get(k);\n\t\t\t\t\t\tfor(int y : dp[k+1][i+w]){\n\t\t\t\t\t\t\tswitch(ch){\n\t\t\t\t\t\t\tcase '+': res.add(x+y);break;\n\t\t\t\t\t\t\tcase '-': res.add(x-y);break;\n\t\t\t\t\t\t\tcase '*': res.add(x*y);break;\n\t\t\t\t\t\t\tcase '/': if(y==0)break;else res.add(x/y);break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[i][i+w] = res;\n\t\t\t}\n\t\t}\n\t\treturn dp[0][n-1];\n\t}\n\t\n\tpublic static Set<Integer> exp(){\n\t\tList<Set<Integer>> list = new ArrayList<Set<Integer>>();\n\t\tList<Character> ope = new ArrayList<Character>();\n\t\twhile(true){\n\t\t\tchar ch = c();\n\t\t\tif(Character.isDigit(ch)){\n\t\t\t\tindex--;\n\t\t\t\tSet<Integer> a = new HashSet<Integer>();\n\t\t\t\ta.add(num());\n\t\t\t\tlist.add(a);\n\t\t\t}\n\t\t\telse if(ch=='('){\n\t\t\t\tlist.add(kakko());\n\t\t\t}\n\t\t\telse if(ch=='$')break;\n\t\t\telse {\n\t\t\t\tope.add(ch);\n\t\t\t}\n\t\t}\n\t\treturn calc(list, ope);\n\t}\n\t\n\tpublic static Set<Integer> kakko(){\n\t\tList<Set<Integer>> list = new ArrayList<Set<Integer>>();\n\t\tList<Character> ope = new ArrayList<Character>();\n\t\twhile(true){\n\t\t\tchar ch = c();\n\t\t\tif(ch=='('){\n\t\t\t\tlist.add(kakko());\n\t\t\t}\n\t\t\telse if(Character.isDigit(ch)){\n\t\t\t\tindex--;\n\t\t\t\tSet<Integer> a = new HashSet<Integer>();\n\t\t\t\ta.add(num());\n\t\t\t\tlist.add(a);\n\t\t\t}\n\t\t\telse if(ch==')'||ch=='$') break;\n\t\t\telse {\n\t\t\t\tope.add(ch);\n\t\t\t}\n\t\t}\n\t\treturn calc(list, ope);\n\t}\n\t\n\tpublic static int num(){\n\t\tchar ch = c();\n\t\tint ans = ch-'0';\n\t\twhile(Character.isDigit(ch)){\n\t\t\tch = c();\n\t\t\tif(!Character.isDigit(ch))break;\n\t\t\tans *= 10;\n\t\t\tans += ch-'0';\n\t\t}\n\t\tindex--;\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tboolean debug = true;\n\t\tif(!debug){\n\t\t\ttry {\n\t\t\t\tSystem.setOut(new PrintStream(new File(\"./src/icpc/D.txt\")));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\ts = sc.next();\n\t\t\tif(s.equals(\"#\"))break;\n\t\t\ts = s+\"$\";\n\t\t\tindex = 0;\n\t\t\tSystem.out.println(exp().size());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n@SuppressWarnings(\"unchecked\")\nclass Main{\n\n    char[] in;\n    boolean[][] checked;\n    HashSet[][] memo;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            String s = sc.next();\n            if(s.equals(\"#\")) break;\n\n            in = s.toCharArray();\n            int n = in.length+1;\n            checked = new boolean[n][n];\n            memo = new HashSet[n][n];\n            System.out.println(expr(0, in.length).size());\n        }\n    }\n\n    HashSet<Integer> expr(int l, int r){\n        if(checked[l][r]) return memo[l][r];\n        int depth = 0;\n        HashSet<Integer> res = new HashSet<Integer>();\n\n        for(int i=l; i<r; i++){\n            if(in[i]=='(') depth++;\n            if(in[i]==')') depth--;\n            if((in[i]=='*' || in[i]=='/' || in[i]=='+' || in[i]=='-') && depth==0){\n                HashSet<Integer> left = expr(l, i);\n                HashSet<Integer> right = expr(i+1, r);\n\n                for(Iterator j=left.iterator(); j.hasNext();){\n                    int a = (int)(Integer)j.next();\n                    for(Iterator k=right.iterator(); k.hasNext();){\n                        int b = (int)(Integer)k.next();\n                        if(in[i]=='*') res.add(new Integer(a * b));\n                        if(in[i]=='/' && b!=0) res.add(new Integer(a / b));\n                        if(in[i]=='+') res.add(new Integer(a + b));\n                        if(in[i]=='-') res.add(new Integer(a - b));\n                    }\n                }\n            }\n        }\n        if(res.size()==0) res.add(new Integer(digit(l, r)));\n\n        checked[l][r] = true;\n        return memo[l][r] = res;\n    }\n\n    int digit(int l, int r){\n        int res = 0;\n        int ten = r-l;\n        for(int i=l; i<r; i++){\n            res += (in[i]-'0') * ten--;\n        }\n        return res;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tString str;\n\tint pos;\n\t\n\tprivate TreeSet<Integer> solve(List<TreeSet<Integer>> list , List<Character> oplist){\n\t\tTreeSet<Integer> res = new TreeSet<Integer>();\n\t\tint len = list.size();\n\t\tif( len <= 1){\n\t\t\treturn list.get(0);\n\t\t}\n\t\tfor(int i = 1; i < len; i++){\n\t\t\t//(list) 0 to i , i to len \n\t\t\t\n\t\t\tTreeSet<Integer> left = solve(list.subList(0, i), oplist.subList(0, i-1));\n\t\t\tTreeSet<Integer> right = solve(list.subList(i, len), oplist.subList(i, len-1));\n\t\t\tchar nowOp = oplist.get(i-1);\n\t\t\tfor(int l: left){\n\t\t\t\tfor(int r: right){\n\t\t\t\t\tswitch(nowOp){\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\tres.add(l + r);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\tres.add(l - r);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\tres.add(l * r);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '/':\n\t\t\t\t\t\tif(r != 0) {\n\t\t\t\t\t\t\tres.add(l / r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault :\n\t\t\t\t\t\t//error\n\t\t\t\t\t\tint temp = 1/0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\t\n\t\n\tprivate TreeSet<Integer> exp() {\n\t\t//System.out.println(str);\n\t\t//char first = str.charAt(0);\n\t\t//int len = str.length();\n//\t\tif(first == '('){\n//\t\t\tString temp = str.substring(1,len-1);\n//\t\t\treturn exp(temp);\n//\t\t}\n\t\tArrayList<TreeSet<Integer>> al = new ArrayList<TreeSet<Integer>>();\n\t\tArrayList<Character> oplist = new ArrayList<Character>();\n\t\tTreeSet<Integer> res = fact();\n\t\tal.add(res);\n\t\twhile(true){\n\t\t\tchar op = str.charAt(pos);\n\t\t\tif(op == '+'|| op == '-' ||op == '*'|| op == '/'){\n\t\t\t\tTreeSet<Integer> old = res;\n\t\t\t\tpos++;\n\t\t\t\tres = fact();\n\t\t\t\tal.add(res);\n\t\t\t\toplist.add(op);\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\t//calc\n\n\t\treturn solve(al, oplist);\n\t}\n\t\n\tprivate TreeSet<Integer> fact() {\n\t\tTreeSet<Integer> res = new TreeSet<Integer>();\n\t\tif(Character.isDigit(str.charAt(pos))){\n\t\t\tint t = str.charAt(pos) - '0';\n\t\t\tpos++;\n\t\t\twhile(Character.isDigit(str.charAt(pos))){\n\t\t\t\tt = t * 10 + (str.charAt(pos) - '0');\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\t\n\t\t\tres.add(t);\n\t\t\treturn res;\n\t\t}\n\t\telse if(str.charAt(pos) =='('){\n\t\t\tpos++;\n\t\t\tres = exp();\n\t\t\tpos++;\n\t\t\treturn res;\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate void doit() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tstr = sc.next() + \"#\";\n\t\t\tif(str.equals(\"##\")) break;\n\t\t\tpos = 0;\n\t\t\tTreeSet<Integer> res = exp();\n\t\t\t//System.out.println(res);\n\t\t\tSystem.out.println(res.size());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node {\n    int index;\n    Set<Integer> set;\n  }\n\n  int func(int left, int right, char cmd) {\n    switch (cmd) {\n      case '+':\n        return left + right;\n      case '-':\n        return left - right;\n      case '*':\n        return left * right;\n      case '/':\n        if (right == 0) {\n          return Integer.MIN_VALUE;\n        }\n        return left / right;\n      default:\n        assert false;\n    }\n    assert false;\n    return Integer.MIN_VALUE;\n  }\n\n  Set<Integer> dfs(int t, boolean[] done, List<Character> enzansi, List<Set<Integer>> nums) {\n    if (t == done.length) {\n      return nums.get(0);\n    }\n    Set<Integer> set = new TreeSet<>();\n    for (int i = 0; i < done.length; ++i) {\n      int mouhitotu = -1;\n      for (int j = i + 1; j <= done.length; ++j) {\n        if (!done[j - 1]) {\n          mouhitotu = j;\n          break;\n        }\n      }\n      if (mouhitotu == -1) {\n        continue;\n      }\n      Set<Integer> left = nums.get(i);\n      Set<Integer> right = nums.get(mouhitotu);\n      char cmd = enzansi.get(mouhitotu - 1);\n      Set<Integer> next = new TreeSet<>();\n      for (int l : left) {\n        for (int r : right) {\n          int v = func(l, r, cmd);\n          if (v == Integer.MIN_VALUE) {\n            continue;\n          }\n          next.add(v);\n        }\n      }\n      Set<Integer> tmp = nums.get(mouhitotu);\n      nums.set(i, next);\n      done[mouhitotu - 1] = true;\n      Set<Integer> ret = dfs(t + 1, done, enzansi, nums);\n      done[mouhitotu - 1] = false;\n      nums.set(i, tmp);\n      set.addAll(ret);\n    }\n    return set;\n  }\n\n  Node cal(String str, int index) {\n    List<Character> enzansi = new ArrayList<>();\n    List<Set<Integer>> nums = new ArrayList<>();\n    while (index < str.length() && str.charAt(index) != ')') {\n      if (str.charAt(index) == '(') {\n        Node node = cal(str, index + 1);\n        nums.add(node.set);\n        index = node.index;\n        assert str.charAt(index) == ')';\n        ++index;\n        continue;\n      }\n      char c = str.charAt(index);\n      if (Character.isDigit(c)) {\n        int num = 0;\n        while (index < str.length() && Character.isDigit(str.charAt(index))) {\n          char d = str.charAt(index);\n          num *= 10;\n          num += d - '0';\n          ++index;\n        }\n        TreeSet<Integer> set = new TreeSet<>();\n        set.add(num);\n        nums.add(set);\n      } else {\n        enzansi.add(c);\n        ++index;\n      }\n    }\n    Node ret = new Node();\n    ret.index = index;\n    boolean[] done = new boolean[enzansi.size()];\n    ret.set = dfs(0, done, enzansi, nums);\n    return ret;\n  }\n\n  void run() {\n    for (; ; ) {\n      String str = sc.next();\n      if (str.charAt(0) == '#') {\n        break;\n      }\n      Node ans = cal(str, 0);\n      assert ans.index == str.length();\n      System.out.println(ans.set.size());\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n@SuppressWarnings(\"unchecked\")\nclass Main{\n\n    char[] in;\n    boolean[][] checked;\n    HashSet[][] memo;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            String s = sc.next();\n            if(s.equals(\"#\")) break;\n\n            in = s.toCharArray();\n            int n = in.length+1;\n            checked = new boolean[n][n];\n            memo = new HashSet[n][n];\n            System.out.println(expr(0, in.length).size());\n        }\n    }\n\n    HashSet<Integer> expr(int l, int r){\n        if(checked[l][r]) return memo[l][r];\n        int depth = 0;\n        HashSet<Integer> res = new HashSet<Integer>();\n\n        for(int i=l; i<r; i++){\n            if(in[i]=='(') depth++;\n            if(in[i]==')') depth--;\n            if((in[i]=='*' || in[i]=='/' || in[i]=='+' || in[i]=='-') && depth==0){\n                HashSet<Integer> left = expr(l, i);\n                HashSet<Integer> right = expr(i+1, r);\n\n                for(Iterator j=left.iterator(); j.hasNext();){\n                    int a = (int)j.next();\n                    for(Iterator k=right.iterator(); k.hasNext();){\n                        int b = (int)k.next();\n                        if(in[i]=='*') res.add(a * b);\n                        if(in[i]=='/' && b!=0) res.add(a / b);\n                        if(in[i]=='+') res.add(a + b);\n                        if(in[i]=='-') res.add(a - b);\n                    }\n                }\n            }\n        }\n        if(res.size()==0) res.add(digit(l, r));\n\n        checked[l][r] = true;\n        return memo[l][r] = res;\n    }\n\n    int digit(int l, int r){\n        int res = 0;\n        int ten = r-l;\n        for(int i=l; i<r; i++){\n            res += (in[i]-'0') * ten--;\n        }\n        return res;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tHashSet<Integer> hash = new HashSet<Integer>();\n\tHashSet<String> used = new HashSet<String>();\n\t\n\tStack<String> stack = new Stack<String>();\n\t\n\tint add(String s1, String s2) {\n\t\tint a1 = Integer.valueOf(s1), a2 = Integer.valueOf(s2);\n\t\treturn a1 + a2;\n\t}\n\t\n\tint sub(String s1, String s2) {\n//\t\tSystem.out.println(\"sub : \" + s1 + \" \" + s2);\n\t\tint a1 = Integer.valueOf(s1), a2 = Integer.valueOf(s2);\n\t\treturn a1 - a2;\n\t}\n\t\n\tint mul(String s1, String s2) {\n\t\tint a1 = Integer.valueOf(s1), a2 = Integer.valueOf(s2);\n\t\treturn a1 * a2;\n\t}\n\t\n\tint div(String s1, String s2) {\n\t\tint a1 = Integer.valueOf(s1), a2 = Integer.valueOf(s2);\n\t\tif (a2 == 0) return INF;\n\t\treturn a1 / a2;\n\t}\n\t\n\tint INF = 1500000000;\n\tString[] parseString(String s) {\n\t\tArrayList<String> res = new ArrayList<String>();\n\t\tArrayList<Integer> expIdx = new ArrayList<Integer>();\n\t\tfor (int i = 1; i < s.length(); i++) {\n\t\t\tchar c = s.charAt(i);\n\t\t\tif (c >= '0' && c <= '9') continue;\n\t\t\tchar c2 = s.charAt(i-1);\n\t\t\tif (c == '-' && (c2 < '0' || c2 > '9')) continue;\n\t\t\texpIdx.add(i);\n\t\t}\n\t\t\n\t\tif (expIdx.size() == 0) res.add(s);\n\t\telse {\n\t\t\tfor (int i = 0; i < expIdx.size(); i++) {\n\t\t\t\tint idx = expIdx.get(i);\n\t\t\t\tString s1 = \"\";\n\t\t\t\tint ii = idx;\n\t\t\t\twhile (true) {\n\t\t\t\t\tii--;\n\t\t\t\t\tif (ii < 0) break;\n\t\t\t\t\tchar c = s.charAt(ii);\n\t\t\t\t\tif ((c >= '0' && c <= '9') || (ii == 0 || (s.charAt(ii-1) < '0' || s.charAt(ii-1) > '9') && c == '-')) {\n\t\t\t\t\t\ts1 = c + s1;\n\t\t\t\t\t} else break;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tString s2 = \"\";\n\t\t\t\tii = idx;\n\t\t\t\twhile (true) {\n\t\t\t\t\tii++;\n\t\t\t\t\tif (ii >= s.length()) break;\n\t\t\t\t\tchar c = s.charAt(ii);\n\t\t\t\t\tif ((c >= '0' && c <= '9') || (ii == idx + 1 && c == '-')) {\n\t\t\t\t\t\ts2 += c;\n\t\t\t\t\t} else break;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tchar exp = s.charAt(idx);\n\t\t\t\tint cul = 0;\n\t\t\t\tswitch (exp) {\n\t\t\t\tcase '+':\n\t\t\t\t\tcul = add(s1, s2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tcul = sub(s1, s2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\tcul = mul(s1, s2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '/':\n\t\t\t\t\tcul = div(s1, s2);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (cul == INF) continue;\n\t\t\t\tint start = (i == 0) ? -1 : expIdx.get(i-1);\n\t\t\t\tint end = (i == expIdx.size() - 1) ? s.length() : expIdx.get(i+1);\n\t\t\t\tString r = s.substring(0, start+1) + cul + s.substring(end);\n\t\t\t\tres.add(r);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res.toArray(new String[0]);\n\t}\n\t\n\tvoid doit(String s) {\n\t\t//System.out.println(\"doit : \\\"\" + s + \"\\\"\");\n\t\tint start = 0, end = 0;\n\t\tString[] parsed = null;\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tchar c = s.charAt(i);\n\t\t\tif (c == '(') start = i + 1;\n\t\t\telse if (c == ')') {\n\t\t\t\tend = i;\n\t\t\t\tparsed = parseString(s.substring(start, end));\n\t\t\t\tbreak;\n\t\t\t}\t\n\t\t}\n\t\tif (start == end) {\n\t\t\tfor (String next : parseString(s)) {\n\t\t\t\tif (used.contains(next)) continue;\n\t\t\t\telse {\n\t\t\t\t\tused.add(next);\n\t\t\t\t\tstack.push(next);\n\t\t\t\t\ttry {\n\t\t\t\t\t\thash.add(Integer.valueOf(next));\n\t\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (String p : parsed) {\n\t\t\t\tString temp = \"\";\n\t\t\t\ttry {\n\t\t\t\t\tint x = Integer.valueOf(p);\n\t\t\t\t\ttemp = s.substring(0, start-1) + p + s.substring(end+1);\n\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\ttemp = s.substring(0, start) + p + s.substring(end);\n\t\t\t\t}\n\t\t\t\tused.add(temp);\n\t\t\t\tstack.push(temp);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tString s = in.next();\n\t\t\tif (s.matches(\"#\")) break;\n\t\t\t\n\t\t\thash.clear();\n\t\t\tused.clear();\n\t\t\tused.add(s);\n\t\t\tstack.push(s);\n\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\tString next = stack.pop();\n\t\t\t\tdoit(next);\n\t\t\t}\n//\t\t\tfor (Integer i : hash) System.out.print(i + \" \");\n//\t\t\tSystem.out.println();\n\t\t\tSystem.out.println(hash.size());\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node {\n    int index;\n    Set<Integer> set;\n  }\n\n  int func(int left, int right, char cmd) {\n    switch (cmd) {\n      case '+':\n        return left + right;\n      case '-':\n        return left - right;\n      case '*':\n        return left * right;\n      case '/':\n        if (right == 0) {\n          return Integer.MIN_VALUE;\n        }\n        return left / right;\n      default:\n        assert false;\n    }\n    assert false;\n    return Integer.MIN_VALUE;\n  }\n\n  Set<Integer> dfs(int t, int done, List<Character> enzansi, List<Set<Integer>> nums) {\n    if (t == enzansi.size()) {\n      return new TreeSet<>(nums.get(0));\n    }\n    Set<Integer> set = new TreeSet<>();\n    for (int i = 0; i < nums.size(); ++i) {\n      if (((done >> i)&1) == 1) {\n        continue;\n      }\n      int mouhitotu = -1;\n      for (int j = i + 1; j < nums.size(); ++j) {\n        if (((done >> j)&1) == 0) {\n          mouhitotu = j;\n          break;\n        }\n      }\n      if (mouhitotu == -1) {\n        continue;\n      }\n      Set<Integer> left = nums.get(i);\n      Set<Integer> right = nums.get(mouhitotu);\n      char cmd = enzansi.get(mouhitotu - 1);\n      Set<Integer> next = new TreeSet<>();\n      for (int l : left) {\n        for (int r : right) {\n          int v = func(l, r, cmd);\n          if (v == Integer.MIN_VALUE) {\n            continue;\n          }\n          next.add(v);\n        }\n      }\n      Set<Integer> tmp = nums.get(i);\n      nums.set(i, next);\n      Set<Integer> ret = dfs(t + 1, done | 1 << mouhitotu, enzansi, nums);\n      nums.set(i, tmp);\n      set.addAll(ret);\n    }\n    return set;\n  }\n\n  Node cal(String str, int index) {\n    List<Character> enzansi = new ArrayList<>();\n    List<Set<Integer>> nums = new ArrayList<>();\n    while (index < str.length() && str.charAt(index) != ')') {\n      if (str.charAt(index) == '(') {\n        Node node = cal(str, index + 1);\n        nums.add(node.set);\n        index = node.index;\n        assert str.charAt(index) == ')';\n        ++index;\n        continue;\n      }\n      char c = str.charAt(index);\n      if (Character.isDigit(c)) {\n        int num = 0;\n        while (index < str.length() && Character.isDigit(str.charAt(index))) {\n          char d = str.charAt(index);\n          num *= 10;\n          num += d - '0';\n          ++index;\n        }\n        TreeSet<Integer> set = new TreeSet<>();\n        set.add(num);\n        nums.add(set);\n      } else {\n        enzansi.add(c);\n        ++index;\n      }\n    }\n    Node ret = new Node();\n    ret.index = index;\n    ret.set = dfs(0, 0, enzansi, nums);\n    return ret;\n  }\n\n  void run() {\n    for (; ; ) {\n      String str = sc.next();\n      if (str.charAt(0) == '#') {\n        break;\n      }\n      Node ans = cal(str, 0);\n      assert ans.index == str.length();\n      System.out.println(ans.set.size());\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n  static final char MINUS = 'M';\n  static HashSet<Integer> set;\n\n  static boolean isdigit(char ch){\n    return '0' <= ch && ch <= '9' || ch == MINUS;\n  }\n\n  static String replace(String s){\n    int before = s.length();\n\n    while(true){\n      for(int i=0;i<s.length();i++){\n        if(s.charAt(i) == '('){\n          int j = i+1;\n          while(isdigit(s.charAt(j)))j++;\n          if(s.charAt(j) == ')'){\n            s = s.substring(0,i) + s.substring(i+1,j) + s.substring(j+1);\n            break;\n          }\n        }\n      }\n\n      if(before == s.length()) return s;\n      before = s.length();\n    }\n  }\n\n  static boolean check(String s){\n    for(int i=0;i<s.length();i++){\n      if(!isdigit(s.charAt(i))){\n        return false;\n      }\n    }\n    return true;\n  }\n\n  static int toInt(String s){\n    if(s.charAt(0) == MINUS){\n      return -1 * Integer.parseInt(s.substring(1));\n    }\n    else{\n      return Integer.parseInt(s);\n    }\n  }\n\n  static void solve(String s){\n    if(check(s)){\n      set.add(toInt(s));\n      return;\n    }\n\n    for(int i=0;i<s.length();i++){\n      char op = s.charAt(i);\n      if(op != '+' && op != '-' && op != '*' && op != '/') continue;\n      if(!isdigit(s.charAt(i-1)) || !isdigit(s.charAt(i+1))) continue;\n\n      int l = i-1;\n      int r = i+1;\n      while(l>=0 && isdigit(s.charAt(l))) l--;\n      while(r<s.length() && isdigit(s.charAt(r))) r++;\n\n      int left = toInt(s.substring(l+1,i));\n      int right = toInt(s.substring(i+1,r));\n      int cal = 0;\n\n      switch(op){\n      case '+': cal = left + right; break;\n      case '-': cal = left - right; break;\n      case '*': cal = left * right; break;\n      case '/':\n        if(right == 0) continue;\n        cal = left / right;\n      }\n\n      String next = \"\" + Math.abs(cal);\n      if(cal < 0) next = MINUS + next;\n\n      solve(replace( s.substring(0,l+1) + next + s.substring(r) ));\n    }\n  }\n\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n\n    while(true){\n      String s = sc.next();\n      if(s.equals(\"#\")) break;\n      set = new HashSet<Integer>();\n      solve(replace(s));\n      System.out.println(set.size());\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\t\n//\tclass P {\n//\t\tint a, b;\n//\t\tP(int a, int b) {\n//\t\t\tthis.a = a;\n//\t\t\tthis.b = b;\n//\t\t}\n//\t\t\n//\t\tpublic boolean equals(Object obj) {\n//\t\t\tif(obj instanceof P){\n//\t\t\t\tP p=(P)obj;\n//\t\t\t\treturn this.a == p.a && this.b == p.b;\n//\t\t\t}\n//\t\t\treturn false;\n//\t\t}\n//\t}\n\t\n\tScanner sc = new Scanner(in);\n\t\n\tchar[] eq;\n\tint len;\n\t\n//\tMap<P, Set<Integer>> memo = new HashMap<P, Set<Integer>>();\n\t\n\tSet<Integer> calc(int a, int b) {\n//\t\tP p = new P(a, b);\n//\t\tif (!memo.containsKey(p)) {\n\t\tboolean flag = true;\n\t\t\tSet<Integer> set = new HashSet<Integer>();\n\t\t\tif (eq[a] == '(' && eq[b] ==')') {\n\t\t\t\tint k = 1;\n\t\t\t\tboolean f = true;;\n\t\t\t\tfor (int i = a+1; i <= b-1; i++) {\n\t\t\t\t\tif (eq[i] == '(') k++;\n\t\t\t\t\telse if (eq[i] == ')') k--;\n\t\t\t\t\t\n\t\t\t\t\tif (k == 0) {\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f)\n\t\t\t\t\treturn calc(a+1, b-1);\n\t\t\t}\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tfor (int i = a; i <= b; i++) {\n\t\t\t\tswitch(eq[i]) {\n\t\t\t\tcase '+':\n\t\t\t\t\tif (count == 0) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tfor (int k : calc(a, i-1))\n\t\t\t\t\t\t\tfor (int l : calc(i+1, b))\n\t\t\t\t\t\t\t\tset.add(k+l);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tif (count == 0) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tfor (int k : calc(a, i-1))\n\t\t\t\t\t\t\tfor (int l : calc(i+1, b))\n\t\t\t\t\t\t\t\tset.add(k-l);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\tif (count == 0) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tfor (int k : calc(a, i-1))\n\t\t\t\t\t\t\tfor (int l : calc(i+1, b))\n\t\t\t\t\t\t\t\tset.add(k*l);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '/':\n\t\t\t\t\tif (count == 0) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tfor (int k : calc(a, i-1))\n\t\t\t\t\t\t\tfor (int l : calc(i+1, b))\n\t\t\t\t\t\t\t\tif (l != 0)\n\t\t\t\t\t\t\t\t\tset.add(k/l);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '(':\n\t\t\t\t\tcount++; break;\n\t\t\t\tcase ')':\n\t\t\t\t\tcount--; break;\n\t\t\t\t}\n\t\n\t\t\t}\n\t\t\t\n\t\t\tif (flag) {\n\t\t\t\tint value = 0;\n\t\t\t\tfor (int i = a; i <= b; i++) {\n\t\t\t\t\tvalue = 10*value + Character.getNumericValue(eq[i]);\n\t\t\t\t}\n\t\t\t\tset.add(value);\n\t\t\t}\n\t\t\t\n//\t\t\tmemo.put(p, set);\n//\t\t}\n\t\t\n//\t\treturn memo.get(p);\n\t\t\treturn set;\n\t}\n\t\n\tvoid run() {\n\t\tString s;\n\t\twhile (true) {\n\t\t\ts = sc.nextLine();\n\t\t\tif (s.equals(\"#\")) break;\n\t\t\teq = s.toCharArray();\n\t\t\tlen = eq.length;\n//\t\t\tmemo.clear();\n\t\t\tout.println(calc(0, len-1).size());\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tHashSet<Integer> hash = new HashSet<Integer>();\n\tHashSet<String> used = new HashSet<String>();\n\t\n\tStack<String> stack = new Stack<String>();\n\t\n\tint add(String s1, String s2) {\n\t\tint a1 = Integer.valueOf(s1), a2 = Integer.valueOf(s2);\n\t\treturn a1 + a2;\n\t}\n\t\n\tint sub(String s1, String s2) {\n//\t\tSystem.out.println(\"sub : \" + s1 + \" \" + s2);\n\t\tint a1 = Integer.valueOf(s1), a2 = Integer.valueOf(s2);\n\t\treturn a1 - a2;\n\t}\n\t\n\tint mul(String s1, String s2) {\n\t\tint a1 = Integer.valueOf(s1), a2 = Integer.valueOf(s2);\n\t\treturn a1 * a2;\n\t}\n\t\n\tint div(String s1, String s2) {\n\t\tint a1 = Integer.valueOf(s1), a2 = Integer.valueOf(s2);\n\t\tif (a2 == 0) return INF;\n\t\treturn a1 / a2;\n\t}\n\t\n\tint INF = 1500000000;\n\tString[] parseString(String s) {\n\t\tArrayList<String> res = new ArrayList<String>();\n\t\tArrayList<Integer> expIdx = new ArrayList<Integer>();\n\t\tfor (int i = 1; i < s.length(); i++) {\n\t\t\tchar c = s.charAt(i);\n\t\t\tif (c >= '0' && c <= '9') continue;\n\t\t\tchar c2 = s.charAt(i-1);\n\t\t\tif (c == '-' && (c2 < '0' || c2 > '9')) continue;\n\t\t\texpIdx.add(i);\n\t\t}\n\t\t\n\t\tif (expIdx.size() == 0) res.add(s);\n\t\telse {\n\t\t\tfor (int i = 0; i < expIdx.size(); i++) {\n\t\t\t\tint idx = expIdx.get(i);\n\t\t\t\tString s1 = \"\";\n\t\t\t\tint ii = idx;\n\t\t\t\twhile (true) {\n\t\t\t\t\tii--;\n\t\t\t\t\tif (ii < 0) break;\n\t\t\t\t\tchar c = s.charAt(ii);\n\t\t\t\t\tif ((c >= '0' && c <= '9') || (ii == 0 || (s.charAt(ii-1) < '0' || s.charAt(ii-1) > '9') && c == '-')) {\n\t\t\t\t\t\ts1 = c + s1;\n\t\t\t\t\t} else break;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tString s2 = \"\";\n\t\t\t\tii = idx;\n\t\t\t\twhile (true) {\n\t\t\t\t\tii++;\n\t\t\t\t\tif (ii >= s.length()) break;\n\t\t\t\t\tchar c = s.charAt(ii);\n\t\t\t\t\tif ((c >= '0' && c <= '9') || (ii == idx + 1 && c == '-')) {\n\t\t\t\t\t\ts2 += c;\n\t\t\t\t\t} else break;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tchar exp = s.charAt(idx);\n\t\t\t\tint cul = 0;\n\t\t\t\tswitch (exp) {\n\t\t\t\tcase '+':\n\t\t\t\t\tcul = add(s1, s2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tcul = sub(s1, s2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\tcul = mul(s1, s2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '/':\n\t\t\t\t\tcul = div(s1, s2);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (cul == INF) continue;\n\t\t\t\tint start = (i == 0) ? -1 : expIdx.get(i-1);\n\t\t\t\tint end = (i == expIdx.size() - 1) ? s.length() : expIdx.get(i+1);\n\t\t\t\tString r = s.substring(0, start+1) + cul + s.substring(end);\n\t\t\t\tres.add(r);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res.toArray(new String[0]);\n\t}\n\t\n\tvoid doit(String s) {\n//\t\tSystem.out.println(\"doit : \\\"\" + s + \"\\\"\");\n\t\tint start = 0, end = 0;\n\t\tString[] parsed = null;\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tchar c = s.charAt(i);\n\t\t\tif (c == '(') start = i + 1;\n\t\t\telse if (c == ')') {\n\t\t\t\tend = i;\n\t\t\t\tparsed = parseString(s.substring(start, end));\n\t\t\t\tbreak;\n\t\t\t}\t\n\t\t}\n\t\tif (start == end) {\n\t\t\tfor (String next : parseString(s)) {\n\t\t\t\tif (used.contains(next)) continue;\n\t\t\t\telse {\n\t\t\t\t\tused.add(next);\n\t\t\t\t\tstack.push(next);\n\t\t\t\t\ttry {\n\t\t\t\t\t\thash.add(Integer.valueOf(next));\n\t\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (String p : parsed) {\n\t\t\t\tString temp = \"\";\n\t\t\t\ttry {\n\t\t\t\t\tint x = Integer.valueOf(p);\n\t\t\t\t\ttemp = s.substring(0, start-1) + p + s.substring(end+1);\n\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\ttemp = s.substring(0, start) + p + s.substring(end);\n\t\t\t\t}\n\t\t\t\tused.add(temp);\n\t\t\t\tstack.push(temp);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tString s = in.next();\n\t\t\tif (s.matches(\"#\")) break;\n\t\t\t\n\t\t\thash.clear();\n\t\t\tused.clear();\n\t\t\tused.add(s);\n\t\t\tstack.push(s);\n\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\tString next = stack.pop();\n\t\t\t\tdoit(next);\n\t\t\t}\n//\t\t\tfor (Integer i : hash) System.out.print(i + \" \");\n//\t\t\tSystem.out.println();\n\t\t\tSystem.out.println(hash.size());\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\n//using System.Numerics;\n//using static System.Math;\nnamespace Program {\n    public class Solver {\n        //Random rnd = new Random();\n        public void Solve() {\n            for (; ; )\n            {\n                var s = rs + '#';\n                if (s[0] == '#') return;\n                var parser = new parser();\n                var ptr = 0;\n                var ans = parser.Solve(ref ptr, s);\n                Console.WriteLine(ans.Count);\n            }\n\n        }\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    /*\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }*/\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\nstruct parser {\n    HashSet<long> number(ref int ptr, string s) {\n        var ret = 0L;\n        while (char.IsDigit(s[ptr]))\n            ret = ret * 10 + s[ptr++] - '0';\n        return new HashSet<long>() { ret };\n    }\n    HashSet<long> subsolve(int l, int r, List<HashSet<long>> S, List<char> OP) {\n        if (r - l == 1) return S[l];\n        var ret = new HashSet<long>();\n        for (int i = l; i < r - 1; i++)\n        {\n            var A = subsolve(l, i + 1, S, OP);\n            var B = subsolve(i + 1, r, S, OP);\n            foreach (var x in A)\n                foreach (var y in B)\n                {\n                    if (OP[i] == '+') ret.Add(x + y);\n                    else if (OP[i] == '-') ret.Add(x - y);\n                    else if (OP[i] == '*') ret.Add(x * y);\n                    else if (y != 0) ret.Add(x / y);\n                }\n        }\n        return ret;\n    }\n    public HashSet<long> term(ref int ptr, string s) {\n        if (s[ptr] == '(')\n        {\n            ptr++;\n            var ret = Solve(ref ptr, s);\n            ptr++;\n            return ret;\n        }\n        else return number(ref ptr, s);\n    }\n    public HashSet<long> Solve(ref int ptr, string s) {\n        var S = new List<HashSet<long>>();\n        var OP = new List<char>();\n        for (; ; )\n        {\n            S.Add(term(ref ptr, s));\n            if (s[ptr] == '#' || s[ptr] == ')') break;\n            OP.Add(s[ptr++]);\n        }\n        return subsolve(0, S.Count, S, OP);\n    }\n}\n\n\n"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef f(s)\n\t0 while s.gsub!(/\\(\\((-?\\d+)\\)\\)/, '(\\1)')\n\t0 while s.gsub!(/\\((\\d+)\\)/, '\\1')\n\treturn if $checked[s]\n\t$checked[s] = 0\n\n\top_hash = {}\n\tnum_hash = {}\n\tif s.scan(/\\d+/).size == 1\n\t\t$set << eval(s)\n\t\treturn\n\tend\n\n\ts.gsub!(/\\((-?\\d+)\\)/) do\n\t\tc = ((?A.ord) + num_hash.size).chr\n\t\tnum_hash[c] = $1.to_i\n\t\tc\n\tend\n\n\ts.gsub!(/\\d+/) do |x|\n\t\tc = ((?A.ord) + num_hash.size).chr\n\t\tnum_hash[c] = x.to_i\n\t\tc\n\tend\n\n\t\n\ts.gsub!(/(?<=[A-Z]|\\([A-Z]\\))[-+*\\/](?=[A-Z]|\\([A-Z]\\))/) do |x|\n\t\tc = ((?a.ord) + op_hash.size).chr\n\t\top_hash[c] = x\n\t\tc\n\tend\n\t\n\top_hash.each do |c, op|\n\t\td = s.dup\n\t\tbegin\n\t\t\tif d.sub!(/([A-Z]|\\([A-Z]\\))#{c}([A-Z]|\\([A-Z]\\))/){|x|\n\t\t\t\tx = num_hash[$1[0] == ?( ? $1[1..-2] : $1]\n\t\t\t\ty = num_hash[$2[0] == ?( ? $2[1..-2] : $2]\n\t\t\t\traise if op == ?/ && y == 0\n\n\t\t\t\tz = if x * y < 0 && op == ?/\n\t\t\t\t\t\t-(x.abs.send(op, y.abs))\n\t\t\t\t\telse\n\t\t\t\t\t\tx.send(op, y)\n\t\t\t\t\tend\n\n\t\t\t\tif z < 0\n\t\t\t\t\t\"(#{z})\"\n\t\t\t\telse\n\t\t\t\t\tz.to_s\n\t\t\t\tend\n\t\t\t}\n\t\t\t\tnext_s = d.gsub(/[a-z]/){|l| op_hash[l]}.gsub(/[A-Z]/){|l| ?( + num_hash[l].to_s + ?)}\n\t\t\t\tf(next_s)\n\t\t\tend\n\t\trescue\n\t\tend\n\tend\nend\n\nloop do\n\ts = gets.chomp\n\tbreak if s == ?#\n\t$set = Set.new\n\t$checked = {}\n\tf(s)\n\tp $set.size\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef f(s)\n\t$checked[s] = 0\n\top_hash = {}\n\tnum_hash = {}\n\tif s.scan(/\\d+/).size == 1\n\t\t$set << eval(s)\n\t\treturn\n\tend\n\n\ts.gsub!(/\\((-?\\d+)\\)/) do\n\t\tc = ((?A.ord) + num_hash.size).chr\n\t\tnum_hash[c] = $1.to_i\n\t\tc\n\tend\n\n\ts.gsub!(/\\d+/) do |x|\n\t\tc = ((?A.ord) + num_hash.size).chr\n\t\tnum_hash[c] = x.to_i\n\t\tc\n\tend\n\t\n\ts.gsub!(/[-+*\\/]/) do |x|\n\t\tc = ((?a.ord) + op_hash.size).chr\n\t\top_hash[c] = x\n\t\tc\n\tend\n\n\t0 while s.gsub!(/\\(\\((.)\\)\\)/, '(\\1)')\n\t\n\top_hash.each do |c, op|\n\t\td = s.dup\n\t\tbegin\n\t\t\tif d.sub!(/([A-Z]|\\([A-Z]\\))#{c}([A-Z]|\\([A-Z]\\))/){|x|\n\t\t\t\tx = num_hash[$1[0] == ?( ? $1[1..-2] : $1]\n\t\t\t\ty = num_hash[$2[0] == ?( ? $2[1..-2] : $2]\n\t\t\t\traise if op == ?/ && y == 0\n\n\t\t\t\tz = if x < 0 && op == ?/\n\t\t\t\t\t\t(-(-x).send(op, y))\n\t\t\t\t\telse\n\t\t\t\t\t\tx.send(op, y)\n\t\t\t\t\tend\n\n\t\t\t\tif z < 0\n\t\t\t\t\t\"(#{z})\"\n\t\t\t\telse\n\t\t\t\t\tz.to_s\n\t\t\t\tend\n\t\t\t}\n\t\t\t\tnext_s = d.gsub(/[a-z]/){|l| op_hash[l]}.gsub(/[A-Z]/){|l| num_hash[l].to_s}\n\t\t\t\tnext if $checked[next_s]\n\t\t\t\tf(next_s)\n\t\t\tend\n\t\trescue\n\t\tend\n\tend\nend\n\nloop do\n\ts = gets.chomp\n\tbreak if s == ?#\n\t$set = Set.new\n\t$checked = {}\n\tf(s)\n\tp $set.size\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef f(s)\n\t0 while s.gsub!(/\\((\\d+)\\)/, '\\1')\n\t0 while s.gsub!(/\\(\\(([^\\(\\)]+)\\)\\)/, '(\\1)')\n\treturn if $checked[s]\n\t$checked[s] = 0\n\n\tif s.scan(/\\d+/).size == 1\n\t\t$set << eval(s)\n\t\treturn\n\tend\n\n\top_hash = {}\n\tnum_hash = {}\n\n\ts.gsub!(/\\((-\\d+)\\)/) do\n\t\tc = ((?A.ord) + num_hash.size).chr\n\t\tnum_hash[c] = $1.to_i\n\t\tc\n\tend\n\n\ts.gsub!(/\\d+/) do |x|\n\t\tc = ((?A.ord) + num_hash.size).chr\n\t\tnum_hash[c] = x.to_i\n\t\tc\n\tend\n\t\n\ts.gsub!(/(?<=[A-Z])[-+*\\/](?=[A-Z])/) do |x|\n\t\tc = ((?a.ord) + op_hash.size).chr\n\t\top_hash[c] = x\n\t\tc\n\tend\n\t\n\top_hash.each do |c, op|\n\t\td = s.dup\n\t\tbegin\n\t\t\td.sub!(/(\\w)#{c}(\\w)/){\n\t\t\t\tx, y = num_hash[$1], num_hash[$2]\n\t\t\t\traise if op == ?/ && y == 0\n\n\t\t\t\tz = if x * y < 0 && op == ?/\n\t\t\t\t\t\t-(x.abs.send(op, y.abs))\n\t\t\t\t\telse\n\t\t\t\t\t\tx.send(op, y)\n\t\t\t\t\tend\n\n\t\t\t\tif z < 0\n\t\t\t\t\t\"(#{z})\"\n\t\t\t\telse\n\t\t\t\t\tz.to_s\n\t\t\t\tend\n\t\t\t}\n\t\t\tnext_s = d.gsub(/[a-z]/){|l| op_hash[l]}.gsub(/[A-Z]/){|l| ?( + num_hash[l].to_s + ?)}\n\t\t\tf(next_s)\n\t\trescue\n\t\tend\n\tend\nend\n\nloop do\n\ts = gets.chomp\n\tbreak if s == ?#\n\t$set = Set.new\n\t$checked = {}\n\tf(s)\n\tp $set.size\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef f(s)\n\t0 while s.gsub!(/\\((\\d+)\\)/o, '\\1')\n\t0 while s.gsub!(/\\(\\(([^\\(\\)]+)\\)\\)/o, '(\\1)')\n\treturn if $checked[s]\n\t$checked[s] = 0\n\n\tif s.scan(/\\d+/).size == 1\n\t\t$set << eval(s)\n\t\treturn\n\tend\n\n\top_hash = {}\n\tnum_hash = {}\n\n\ts.gsub!(/\\((-\\d+)\\)/o) do\n\t\tc = ((?A.ord) + num_hash.size).chr\n\t\tnum_hash[c] = $1.to_i\n\t\tc\n\tend\n\n\ts.gsub!(/\\d+/o){|x| ((?A.ord) + num_hash.size).chr.tap{|c| num_hash[c] = x.to_i} }\n\ts.gsub!(/(?<=[A-Z])[-+*\\/](?=[A-Z])/o){|x| ((?a.ord) + op_hash.size).chr.tap{|c| op_hash[c] = x} }\n\t\n\top_hash.each do |c, op|\n\t\td = s.dup\n\t\tbegin\n\t\t\td.sub!(/(\\w)#{c}(\\w)/) do\n\t\t\t\tx, y = num_hash[$1], num_hash[$2]\n\t\t\t\traise if op == ?/ && y == 0\n\n\t\t\t\tz = if x * y < 0 && op == ?/\n\t\t\t\t\t\t-(x.abs.send(op, y.abs))\n\t\t\t\t\telse\n\t\t\t\t\t\tx.send(op, y)\n\t\t\t\t\tend\n\n\t\t\t\tz < 0 ? \"(#{z})\" : z.to_s\n\t\t\tend\n\t\t\tf(d.gsub(/[a-z]/o){|l| op_hash[l]}.gsub(/[A-Z]/o){|l| \"(#{num_hash[l]})\"})\n\t\trescue\n\t\tend\n\tend\nend\n\nloop do\n\ts = gets.chomp\n\tbreak if s == ?#\n\t$set = Set.new\n\t$checked = {}\n\tf(s)\n\tp $set.size\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nU_ALPH = (?A..?Z).to_a\nL_ALPH = (?a..?z).to_a\n\ndef f(s)\n\t0 while s.gsub!(/\\((\\d+)\\)/o, '\\1')\n\t0 while s.gsub!(/\\(\\((.+?)\\)\\)/o, '(\\1)')\n\treturn if $checked[s]\n\t$checked[s] = 0\n\n\tif s.scan(/\\d+/).size == 1\n\t\t$set << eval(s)\n\t\treturn\n\tend\n\n\top_hash = {}\n\tnum_hash = {}\n\n\ts.gsub!(/\\((-\\d+)\\)/o){ U_ALPH[num_hash.size].tap{|c| num_hash[c] = $1.to_i} }\n\ts.gsub!(/\\d+/o){|x| U_ALPH[num_hash.size].tap{|c| num_hash[c] = x.to_i} }\n\ts.gsub!(/(?<=[A-Z])[-+*\\/](?=[A-Z])/o){|x| L_ALPH[op_hash.size].tap{|c| op_hash[c] = x} }\n\t\n\top_hash.each do |c, op|\n\t\td = s.dup\n\t\tbegin\n\t\t\td.sub!(/(\\w)#{c}(\\w)/) do\n\t\t\t\tx, y = num_hash[$1], num_hash[$2]\n\t\t\t\traise if op == ?/ && y == 0\n\n\t\t\t\tz = if x * y < 0 && op == ?/\n\t\t\t\t\t\t-(x.abs.send(op, y.abs))\n\t\t\t\t\telse\n\t\t\t\t\t\tx.send(op, y)\n\t\t\t\t\tend\n\n\t\t\t\tz < 0 ? \"(#{z})\" : z.to_s\n\t\t\tend\n\t\t\tf(d.gsub(/[a-z]/o){|l| op_hash[l]}.gsub(/[A-Z]/o){|l| x = num_hash[l]; x < 0 ? \"(#{x})\" : \"#{x}\"})\n\t\trescue\n\t\tend\n\tend\nend\n\nloop do\n\ts = gets.chomp\n\tbreak if s == ?#\n\t$set = Set.new\n\t$checked = {}\n\tf(s)\n\tp $set.size\nend"
  },
  {
    "language": "PHP",
    "code": "<?php\n$arr=[];\n\nfunction solve($S) {\n        global $arr;\n\n        if(is_numeric($S))return [$S=>true];\n        if($S[0]==='$'&&is_numeric(substr($S, 1)))return $arr[substr($S,1)];\n        for($i = 0; $i < strlen($S); $i++) {\n                if($S[$i] === '(') {\n                        $count = 1;\n                        for($j = $i+1; $j < strlen($S); $j++){\n                                if($S[$j] === '(')$count++;\n                                if($S[$j] === ')')$count--;\n                                if($count===0){\n                                        $arr[]=solve(substr($S, $i + 1 , $j - $i - 1));\n                                        $S = substr_replace($S, '$'.(sizeof($arr)-1), $i, $j - $i+1);\n                                        break;\n                                }\n                        }\n                }\n        }\n        $f = false;\n        $ans=[];\n        for($i = 0; $i < strlen($S); $i++){\n                if($S[$i] === '+' || $S[$i] === '-' || $S[$i] === '*' || $S[$i] === '/') {\n                        $f = true;\n                        $right = solve(substr($S, $i+1, strlen($S) - $i));\n                        $left = solve(substr($S, 0, $i));\n                        foreach($left as $lk => $lv){\n                                foreach($right as $rk => $rv){\n                                        if($S[$i]==='+'){\n                                                $ans[$lk+$rk]=true;\n                                        }\n                                        if($S[$i]==='-'){\n                                                $ans[$lk-$rk]=true;\n                                        }\n                                        if($S[$i]==='*'){\n                                                $ans[$lk*$rk]=true;\n                                        }\n                                        if($S[$i]==='/'&& $rk != 0){\n                                                $ans[(int)($lk*1.0/$rk)]=true;\n                                        }\n                                }\n                        }\n                }\n        }\n        if(!$f)return solve($S);\n        return $ans;\n}\n\n\nwhile(true){\n        $S = trim(fgets(STDIN));\n        if($S === \"#\") break;\n        echo count(solve($S)).PHP_EOL;\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n$arr=[];\n\nfunction solve($S) {\n        //echo $S.PHP_EOL;\n        global $arr;\n        if(is_numeric($S))return [$S=>true];\n        if($S[0]==='$'&&is_numeric(substr($S, 1)))return $arr[substr($S,1)];\n        for($i = 0; $i < strlen($S); $i++) {\n                if($S[$i] === '(') {\n                        $count = 1;\n                        for($j = $i+1; $j < strlen($S); $j++){\n                                if($S[$j] === '(')$count++;\n                                if($S[$j] === ')')$count--;\n                                if($count===0){\n                                        $arr[]=solve(substr($S, $i + 1 , $j - $i - 1));\n                                        $S = substr_replace($S, '$'.(sizeof($arr)-1), $i, $j - $i+1);\n                                }\n                        }\n                }\n        }\n        $ans=[];\n        for($i = 0; $i < strlen($S); $i++){\n                if($S[$i] === '+' || $S[$i] === '-' || $S[$i] === '*' || $S[$i] === '/') {\n                        //echo substr($S, 0, $i ).\" \".substr($S, $i+1, strlen($S) - $i).PHP_EOL;\n                        $left = solve(substr($S, 0, $i));\n                        $right = solve(substr($S, $i+1, strlen($S) - $i));\n                        //var_dump($left);\n                        //var_dump($right);\n                        foreach($left as $lk => $lv){\n                                foreach($right as $rk => $rv){\n                                        if($S[$i]==='+'){\n                                                $ans[$lk+$rk]=true;\n                                        }\n                                        if($S[$i]==='-'){\n                                                $ans[$lk-$rk]=true;\n                                        }\n                                        if($S[$i]==='*'){\n                                                $ans[$lk*$rk]=true;\n                                        }\n                                        if($S[$i]==='/'){\n                                                $ans[(int)($lk/$rk)]=true;\n                                        }\n                                }\n                        }\n                        //var_dump($ans);\n                }\n        }\n        return $ans;\n}\n\n\nwhile(true){\n        $S = trim(fgets(STDIN));\n        if($S === \"#\") break;\n        echo count(solve($S)).PHP_EOL;\n}"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nsys.setrecursionlimit(10000000)\n\n# calculator with \"1234567890()+-*/\"\n\n# evaluate operation\ndef operate(term1, term2, op):\n    ret = []\n    if op == '+':\n        for p in it.product(term1, term2):\n            ret += [p[0] + p[1]]\n    if op == '-':\n        for p in it.product(term1, term2):\n            ret += [p[0] - p[1]]\n    if op == '*':\n        for p in it.product(term1, term2):\n            ret += [p[0] * p[1]]\n    if op == '/':\n        for p in it.product(term1, term2):\n            if p[1] == 0:\n                continue\n            if p[0] * p[1] < 0 and p[0] % p[1] != 0:\n                ret += [p[0] / p[1] + 1]\n            else:\n                ret += [p[0] / p[1]]\n    return ret\n\n# evaluate expression without bracket\ndef calc(S):\n    if len(S) == 1:\n        if type(S[0]) == type(\"\"):\n            return [int(S[0])]\n        else:\n            return S[0]\n    ret = []\n    for i in range(len(S)):\n        if S[i] in ['+', '-', '*', '/']:\n            ret += operate(calc(S[:i]), calc(S[i + 1:]), S[i])\n    return ret\n\n# evaluate expression\ndef br(S):\n    index = 0\n    lst = []\n    while True:\n        if index >= len(S) or S[index] == ')':\n            return index, calc(lst)\n        elif S[index] == '(':\n            ret, value = br(S[index + 1:])\n            index += ret + 1\n            lst.append(value)\n        else:\n            lst.append(S[index])\n        index += 1\n\n# \"(11+22)\" -> ['(', '11', '+', '22', ')']\ndef split(S):\n    ret = ['?']\n    c_num = \"1234567890\"\n    for c in S:\n        if c in c_num and ret[-1][-1] in c_num:\n            ret[-1] += c\n        else:\n            ret.append(c)\n    return ret[1:]\n\nwhile True:\n    S = raw_input()\n    if S == '#':\n        break\n    S = split(S)\n    ret = br(S)[1]\n    print len(set(ret))\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    def f(s):\n        a = []\n        for c in s:\n            if '0' <= c <= '9':\n                if len(a) > 0 and isinstance(a[-1], int):\n                    a[-1] *= 10\n                    a[-1] += int(c)\n                else:\n                    a.append(int(c))\n            else:\n                a.append(c)\n\n        for i in range(len(a)):\n            c = a[i]\n            if isinstance(c, int):\n                a[i] = set([c])\n\n        def _f(a):\n            li = None\n            l = len(a)\n            if l == 1:\n                return a\n\n            for i in range(l):\n                if a[i] == '(':\n                    li = i\n            if not li is None:\n                ri = None\n                for i in range(li+1,l):\n                    if a[i] == ')':\n                        ri = i\n                        break\n                t = _f(a[li+1:ri])\n                return _f(a[:li] + t + a[ri+1:])\n\n            ts = set()\n            for i in range(l):\n                c = a[i]\n                if isinstance(c, set) or c not in '+-*/':\n                    continue\n                ls = _f(a[:i])[0]\n                rs = _f(a[i+1:])[0]\n                for lc in ls:\n                    for rc in rs:\n                        if c == '+':\n                            ts.add(lc+rc)\n                        elif c == '-':\n                            ts.add(lc-rc)\n                        elif c == '*':\n                            ts.add(lc*rc)\n                        elif c == '/' and rc != 0:\n                            if lc * rc < 0:\n                                ts.add(-(abs(lc)//abs(rc)))\n                            else:\n                                ts.add(lc//rc)\n\n            return [ts]\n\n        return len(_f(a)[0])\n\n    while 1:\n        s = S()\n        if s == '#':\n            break\n        rr.append(f(s))\n        # print('rr', rr[-1])\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\n\n\ndef set_calc(left, right, ope):\n    return set(ope(l, r) for l in left for r in right)\n\n\ndef div(left, right):\n    res = set()\n    for l in left:\n        for r in right:\n            if r == 0:\n                continue\n            if l == 0:\n                res.add(0)\n                continue\n            res.add(abs(l) // abs(r) * ((l * r) // abs(l * r)))\n    return res\n\n\nO = {'+': lambda l, r: set_calc(l, r, lambda l, r: l + r),\n     '-': lambda l, r: set_calc(l, r, lambda l, r: l - r),\n     '*': lambda l, r: set_calc(l, r, lambda l, r: l * r),\n     '/': lambda l, r: div(l, r)}\n\n\nclass Source():\n    def __init__(self, S, i=0):\n        self.S = S\n        self.pos = i\n\n\ndef peek(S):\n    return S.S[S.pos] if S.pos < len(S.S) else 'a'\n\n\ndef next(S):\n    S.pos += 1\n\n\ndef concreate(left, m, right, i, j):\n    return set(Source(l.S[:i] + m + r.S[j:]) for l in left for r in right)\n\nmemo = dict()\n\ndef expr(S):\n    if S.S in memo:\n        return memo[S.S]\n    # print(S.S)\n    i = S.pos\n    left = factor(S)\n    res = set()\n\n    if not peek(S) in O:\n        return left\n\n    while peek(S) in O:\n        ope = peek(S)\n        next(S)\n        next_i = S.pos\n        right = factor(S)\n        j = S.pos\n        for m in O[ope](left, right):\n            res |= expr(Source(S.S[:i] + str(m) + S.S[j:]))\n        left = right\n        i = next_i\n\n    # print('res:', res, S.S)\n    memo[S.S] = res\n    return res\n\n\ndef factor(S):\n    if peek(S) == '(':\n        cnt = 1\n        next(S)\n        res = expr(Source(S.S[S.pos:]))\n        while cnt > 0:\n            if peek(S) == '(':\n                cnt += 1\n            elif peek(S) == ')':\n                cnt -= 1\n            next(S)\n    else:\n        res = num(S)\n    return res\n\n\ndef num(S):\n    sign = 1\n    if peek(S) == '-':\n        sign = -1\n        next(S)\n    res = 0\n    while '0' <= peek(S) <= '9':\n        res = res * 10 + int(peek(S))\n        next(S)\n\n    return {sign * res}\n\n\nwhile True:\n    S = input()\n    if S == '#':\n        break\n    memo = dict()\n    print(len(expr(Source(S))))\n\n"
  }
]