[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 10\n#define MAX_OPS (MAX_N - 1)\n\ntypedef struct {\n    int size;\n    int data[MAX_N];\n} Stack;\n\nvoid push(Stack *s, int val) {\n    s->data[s->size++] = val;\n}\n\nint pop(Stack *s) {\n    return s->data[--s->size];\n}\n\nint used[MAX_OPS];\nint ops[MAX_OPS];\nchar op_chars[MAX_OPS];\nint num_count;\nint nums[MAX_N];\nint res_count;\nint results[100000]; // Adjust size as needed\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid permute(int pos, int n) {\n    if (pos == n) {\n        Stack s;\n        s.size = 0;\n        push(&s, nums[0]);\n        int num_idx = 1;\n        for (int i = 0; i < n; i++) {\n            int op = ops[i];\n            int b = pop(&s);\n            int a = pop(&s);\n            int res;\n            switch (op_chars[op]) {\n                case '+': res = a + b; break;\n                case '-': res = a - b; break;\n                case '*': res = a * b; break;\n                case '/': res = a / b; break;\n                default: res = 0; break;\n            }\n            push(&s, res);\n            if (num_idx < num_count) {\n                push(&s, nums[num_idx++]);\n            }\n        }\n        int result = pop(&s);\n        int found = 0;\n        for (int i = 0; i < res_count; i++) {\n            if (results[i] == result) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            results[res_count++] = result;\n        }\n        return;\n    }\n    for (int i = 0; i < n; i++) {\n        if (!used[i]) {\n            used[i] = 1;\n            ops[pos] = i;\n            permute(pos + 1, n);\n            used[i] = 0;\n        }\n    }\n}\n\nint main() {\n    char expr[100];\n    fgets(expr, sizeof(expr), stdin);\n    expr[strcspn(expr, \"\\n\")] = 0;\n\n    num_count = 0;\n    int op_count = 0;\n    char *token = strtok(expr, \" \");\n    while (token != NULL) {\n        if (*token >= '0' && *token <= '9' || (*token == '-' && strlen(token) > 1)) {\n            nums[num_count++] = atoi(token);\n        } else {\n            op_chars[op_count++] = *token;\n        }\n        token = strtok(NULL, \" \");\n    }\n\n    res_count = 0;\n    memset(used, 0, sizeof(used));\n    permute(0, op_count);\n\n    printf(\"%d\\n\", res_count);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:20:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <string>\n#include <stack>\n#include <cctype>\n#include <algorithm>\n\nusing namespace std;\n\nint precedence(char op) {\n    if (op == '+' || op == '-') return 1;\n    if (op == '*' || op == '/') return 2;\n    return 0;\n}\n\nvector<string> infixToPostfix(const string& expr) {\n    vector<string> output;\n    stack<char> ops;\n    string num;\n    for (char c : expr) {\n        if (isdigit(c)) {\n            num += c;\n        } else {\n            if (!num.empty()) {\n                output.push_back(num);\n                num.clear();\n            }\n            if (c == '(') {\n                ops.push(c);\n            } else if (c == ')') {\n                while (!ops.empty() && ops.top() != '(') {\n                    output.push_back(string(1, ops.top()));\n                    ops.pop();\n                }\n                ops.pop();\n            } else {\n                while (!ops.empty() && precedence(ops.top()) >= precedence(c)) {\n                    output.push_back(string(1, ops.top()));\n                    ops.pop();\n                }\n                ops.push(c);\n            }\n        }\n    }\n    if (!num.empty()) {\n        output.push_back(num);\n    }\n    while (!ops.empty()) {\n        output.push_back(string(1, ops.top()));\n        ops.pop();\n    }\n    return output;\n}\n\nset<int> evaluateAll(const vector<string>& postfix) {\n    vector<set<int>> stack;\n    for (const string& token : postfix) {\n        if (isdigit(token[0])) {\n            stack.push_back({stoi(token)});\n        } else {\n            set<int> right = stack.back(); stack.pop_back();\n            set<int> left = stack.back(); stack.pop_back();\n            set<int> result;\n            for (int l : left) {\n                for (int r : right) {\n                    if (token == \"+\") result.insert(l + r);\n                    else if (token == \"-\") result.insert(l - r);\n                    else if (token == \"*\") result.insert(l * r);\n                    else if (token == \"/\" && r != 0) result.insert(l / r);\n                }\n            }\n            stack.push_back(result);\n        }\n    }\n    return stack.back();\n}\n\nint main() {\n    string expr;\n    getline(cin, expr);\n    vector<string> postfix = infixToPostfix(expr);\n    set<int> results = evaluateAll(postfix);\n    cout << results.size() << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:20:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class KitamasaCalculator {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String expr = scanner.nextLine();\n        System.out.println(calculateDistinctResults(expr));\n    }\n\n    public static int calculateDistinctResults(String expr) {\n        List<String> tokens = tokenize(expr);\n        List<Integer> nums = new ArrayList<>();\n        List<Character> ops = new ArrayList<>();\n\n        for (String token : tokens) {\n            if (token.length() == 1 && \"+-*/\".indexOf(token.charAt(0)) != -1) {\n                ops.add(token.charAt(0));\n            } else {\n                nums.add(Integer.parseInt(token));\n            }\n        }\n\n        Set<Integer> results = new HashSet<>();\n        computeAll(nums, ops, results);\n        return results.size();\n    }\n\n    private static void computeAll(List<Integer> nums, List<Character> ops, Set<Integer> results) {\n        if (ops.isEmpty()) {\n            results.add(nums.get(0));\n            return;\n        }\n\n        for (int i = 0; i < ops.size(); i++) {\n            char op = ops.get(i);\n            int a = nums.get(i);\n            int b = nums.get(i + 1);\n            int res = compute(a, b, op);\n\n            List<Integer> newNums = new ArrayList<>(nums);\n            List<Character> newOps = new ArrayList<>(ops);\n\n            newNums.remove(i);\n            newNums.remove(i);\n            newNums.add(i, res);\n            newOps.remove(i);\n\n            computeAll(newNums, newOps, results);\n        }\n    }\n\n    private static int compute(int a, int b, char op) {\n        switch (op) {\n            case '+': return a + b;\n            case '-': return a - b;\n            case '*': return a * b;\n            case '/': return a / b;\n            default: throw new IllegalArgumentException(\"Unknown operator: \" + op);\n        }\n    }\n\n    private static List<String> tokenize(String expr) {\n        List<String> tokens = new ArrayList<>();\n        StringBuilder current = new StringBuilder();\n\n        for (int i = 0; i < expr.length(); i++) {\n            char c = expr.charAt(i);\n            if (Character.isDigit(c)) {\n                current.append(c);\n            } else {\n                if (current.length() > 0) {\n                    tokens.add(current.toString());\n                    current.setLength(0);\n                }\n                tokens.add(String.valueOf(c));\n            }\n        }\n\n        if (current.length() > 0) {\n            tokens.add(current.toString());\n        }\n\n        return tokens;\n    }\n}",
    "timestamp": "2025-08-05 21:20:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] nums = new int[n];\n        for (int i = 0; i < n; i++) {\n            nums[i] = scanner.nextInt();\n        }\n        String[] ops = new String[n - 1];\n        for (int i = 0; i < n - 1; i++) {\n            ops[i] = scanner.next();\n        }\n        \n        Set<Long> results = calculateAllOutcomes(nums, ops);\n        System.out.println(results.size());\n    }\n    \n    private static Set<Long> calculateAllOutcomes(int[] nums, String[] ops) {\n        Set<Long> results = new HashSet<>();\n        List<Integer> numList = new ArrayList<>();\n        for (int num : nums) {\n            numList.add(num);\n        }\n        \n        generatePermutations(numList, ops, new ArrayList<>(), results);\n        return results;\n    }\n    \n    private static void generatePermutations(List<Integer> nums, String[] ops, \n                                             List<String> currentOps, \n                                             Set<Long> results) {\n        if (nums.size() == 1) {\n            results.add((long) nums.get(0));\n            return;\n        }\n        \n        for (int i = 0; i < nums.size() - 1; i++) {\n            for (String op : ops) {\n                if (currentOps.contains(op)) continue;\n                \n                List<Integer> newNums = new ArrayList<>(nums);\n                int a = newNums.get(i);\n                int b = newNums.remove(i + 1);\n                \n                long result;\n                switch(op) {\n                    case \"+\":\n                        result = (long) a + b;\n                        break;\n                    case \"-\":\n                        result = (long) a - b;\n                        break;\n                    case \"*\":\n                        result = (long) a * b;\n                        break;\n                    default:\n                        if (b == 0) continue;\n                        result = (long) a / b;\n                }\n                \n                newNums.set(i, (int) result);\n                \n                List<String> newOps = new ArrayList<>(currentOps);\n                newOps.add(op);\n                \n                generatePermutations(newNums, ops, newOps, results);\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:21:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_EXPR 20\n#define MAX_RESULTS 1000\n\ntypedef struct {\n    long long value;\n    int used[MAX_EXPR];\n} Calculation;\n\nlong long calculate(long long a, long long b, char op) {\n    switch (op) {\n        case '+': return a + b;\n        case '-': return a - b;\n        case '*': return a * b;\n        case '/': return a / b;\n        default: return 0;\n    }\n}\n\nvoid generatePermutations(char *ops, int n, Calculation *initial, Calculation *results, int *resultCount) {\n    if (n == 0) {\n        int exists = 0;\n        for (int i = 0; i < *resultCount; i++) {\n            if (results[i].value == initial->value) {\n                exists = 1;\n                break;\n            }\n        }\n        \n        if (!exists) {\n            results[*resultCount] = *initial;\n            (*resultCount)++;\n        }\n        return;\n    }\n\n    for (int i = 0; i < n; i++) {\n        Calculation current = *initial;\n        int pos1 = -1, pos2 = -1;\n\n        for (int j = 0; j < n + 1; j++) {\n            if (current.used[j] == 0 && pos1 == -1) pos1 = j;\n            else if (current.used[j] == 0 && pos1 != -1) {\n                pos2 = j;\n                break;\n            }\n        }\n\n        if (pos1 == -1 || pos2 == -1) return;\n\n        if (ops[i] == '/' && current.value % current.value != 0) continue;\n\n        current.value = calculate(current.value, current.value, ops[i]);\n        current.used[pos2] = 1;\n\n        char remainingOps[MAX_EXPR];\n        int remainingOpCount = 0;\n        for (int j = 0; j < n; j++) {\n            if (j != i) {\n                remainingOps[remainingOpCount++] = ops[j];\n            }\n        }\n        remainingOps[remainingOpCount] = '\\0';\n\n        generatePermutations(remainingOps, n - 1, &current, results, resultCount);\n    }\n}\n\nint main() {\n    int n;\n    long long nums[MAX_EXPR];\n    char ops[MAX_EXPR];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n + 1; i++) {\n        scanf(\"%lld\", &nums[i]);\n    }\n    for (int i = 0; i < n; i++) {\n        scanf(\" %c\", &ops[i]);\n    }\n\n    Calculation results[MAX_RESULTS];\n    int resultCount = 0;\n\n    Calculation initial = {nums[0], {0}};\n    initial.used[0] = 1;\n\n    generatePermutations(ops, n, &initial, results, &resultCount);\n\n    printf(\"%d\\n\", resultCount);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:21:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <string>\n#include <stack>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nlong long calculate(long long a, long long b, char op) {\n    switch (op) {\n        case '+': return a + b;\n        case '-': return a - b;\n        case '*': return a * b;\n        case '/': return a / b;\n        default: return 0;\n    }\n}\n\nlong long evaluateExpression(vector<long long>& nums, vector<char>& ops) {\n    stack<long long> values;\n    stack<char> operators;\n\n    for (int i = 0; i < nums.size(); i++) {\n        values.push(nums[i]);\n\n        if (i < ops.size()) {\n            while (!operators.empty() && \n                   ((ops[i] == '*' || ops[i] == '/') && \n                    (operators.top() == '+' || operators.top() == '-'))) {\n                long long b = values.top();\n                values.pop();\n                long long a = values.top();\n                values.pop();\n                char op = operators.top();\n                operators.pop();\n\n                long long result = calculate(a, b, op);\n                values.push(result);\n            }\n            operators.push(ops[i]);\n        }\n    }\n\n    while (!operators.empty()) {\n        long long b = values.top();\n        values.pop();\n        long long a = values.top();\n        values.pop();\n        char op = operators.top();\n        operators.pop();\n\n        long long result = calculate(a, b, op);\n        values.push(result);\n    }\n\n    return values.top();\n}\n\nint main() {\n    string line;\n    getline(cin, line);\n    \n    vector<long long> nums;\n    vector<char> ops;\n    \n    stringstream ss(line);\n    long long num;\n    char op;\n    \n    ss >> num;\n    nums.push_back(num);\n    \n    while (ss >> op >> num) {\n        ops.push_back(op);\n        nums.push_back(num);\n    }\n\n    set<long long> results;\n    \n    do {\n        try {\n            long long result = evaluateExpression(nums, ops);\n            results.insert(result);\n        } catch (...) {}\n    } while (next_permutation(ops.begin(), ops.end()));\n\n    cout << results.size() << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:21:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import permutations\n\ndef calculate_expression(operands, operations):\n    temp_operands = operands[:]\n    temp_operations = operations[:]\n    while len(temp_operations) > 0:\n        result = temp_operands[0]\n        for i, op in enumerate(temp_operations):\n            if op == '+':\n                result += temp_operands[i + 1]\n            elif op == '-':\n                result -= temp_operands[i + 1]\n            elif op == '*':\n                result *= temp_operands[i + 1]\n            elif op == '/':\n                result = int(result / temp_operands[i + 1])  # integer division\n        return result\n\ndef distinct_results(expression):\n    numbers = []\n    operators = []\n    num = \"\"\n    for char in expression:\n        if char.isdigit():\n            num += char\n        else:\n            if num != \"\":\n                numbers.append(int(num))\n                num = \"\"\n            operators.append(char)\n    if num != \"\":\n        numbers.append(int(num))\n\n    unique_results = set()\n    operator_count = len(operators)\n    permutations_of_operators = permutations(operators)\n\n    for perm in permutations_of_operators:\n        result = calculate_expression(numbers, perm)\n        unique_results.add(result)\n\n    return len(unique_results)\n\n# Example usage:\n# expression = \"2*3-4/6\"\n# print(distinct_results(expression))",
    "timestamp": "2025-08-13 05:57:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.HashSet;\nimport java.util.Set;\nimport java.util.Stack;\n\npublic class DistinctOutcomes {\n\n    public static int distinctOutcomes(String expression) {\n        Set<Integer> results = new HashSet<>();\n        evaluate(expression, results);\n        return results.size();\n    }\n\n    private static void evaluate(String expression, Set<Integer> results) {\n        if (!expression.contains(\"+\") && \n            !expression.contains(\"-\") && \n            !expression.contains(\"*\") && \n            !expression.contains(\"/\")) {\n            results.add(Integer.parseInt(expression));\n            return;\n        }\n\n        for (int i = 0; i < expression.length(); i++) {\n            char c = expression.charAt(i);\n            if (c == '+' || c == '-' || c == '*' || c == '/') {\n                String left = expression.substring(0, i);\n                String right = expression.substring(i + 1);\n\n                Set<Integer> leftResults = new HashSet<>();\n                Set<Integer> rightResults = new HashSet<>();\n\n                evaluate(left, leftResults);\n                evaluate(right, rightResults);\n\n                for (int leftValue : leftResults) {\n                    for (int rightValue : rightResults) {\n                        if (c == '+') {\n                            results.add(leftValue + rightValue);\n                        } else if (c == '-') {\n                            results.add(leftValue - rightValue);\n                        } else if (c == '*') {\n                            results.add(leftValue * rightValue);\n                        } else if (c == '/' && rightValue != 0) {\n                            results.add(leftValue / rightValue);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        String expression = \"2*3-4/2+1\";\n        System.out.println(distinctOutcomes(expression)); // Example output\n    }\n}",
    "timestamp": "2025-08-13 05:57:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nint numDistinctOutcomes(char* expression);\nint evaluateExpression(char* expression, int l, int r, int dp[r][r]);\n\nint main() {\n    char expression[101];\n    scanf(\"%s\", expression);\n    printf(\"%d\\n\", numDistinctOutcomes(expression));\n    return 0;\n}\n\nint numDistinctOutcomes(char* expression) {\n    int len = strlen(expression);\n    int dp[len][len];\n    bool visited[len][len];\n    memset(dp, 0, sizeof(dp));\n    memset(visited, false, sizeof(visited));\n    return evaluateExpression(expression, 0, len - 1, dp);\n}\n\nint evaluateExpression(char* expression, int l, int r, int dp[r][r]) {\n    if (l == r) {\n        return expression[l] - '0'; // convert single digit to int\n    }\n    if (dp[l][r] != 0) {\n        return dp[l][r];\n    }\n\n    int distinctResults[20001];\n    memset(distinctResults, 0, sizeof(distinctResults));\n    int count = 0;\n    \n    for (int i = l + 1; i < r; i += 2) { // i is operator position\n        char op = expression[i];\n        int left[10001], right[10001];\n        int leftSize = evaluateExpression(expression, l, i - 1, dp);\n        for (int li = 0; li < leftSize; ++li) {\n            left[li] = expression[l + li * 2] - '0'; // convert operand\n        }\n        int leftOutcomeCount = distinctResults[l];\n\n        int rightSize = evaluateExpression(expression, i + 1, r, dp);\n        for (int ri = 0; ri < rightSize; ++ri) {\n            right[ri] = expression[i + 1 + ri * 2] - '0'; // convert operand\n        }\n        int rightOutcomeCount = distinctResults[i + 1];\n\n        for (int li = 0; li < leftOutcomeCount; ++li) {\n            for (int ri = 0; ri < rightOutcomeCount; ++ri) {\n                int result;\n                switch (op) {\n                    case '+':\n                        result = left[li] + right[ri];\n                        break;\n                    case '-':\n                        result = left[li] - right[ri];\n                        break;\n                    case '*':\n                        result = left[li] * right[ri];\n                        break;\n                    default:\n                        continue;\n                }\n\n                bool exists = false;\n                for (int k = 0; k < count; ++k) {\n                    if (distinctResults[k] == result) {\n                        exists = true;\n                        break;\n                    }\n                }\n                if (!exists) {\n                    distinctResults[count] = result;\n                    count++;\n                }\n            }\n        }\n    }\n    dp[l][r] = count;\n    return count;\n}",
    "timestamp": "2025-08-13 05:58:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import permutations\n\ndef calculate(nums, ops):\n    def solve(expression):\n        stack = []\n        for token in expression:\n            if isinstance(token, int):\n                stack.append(token)\n            else:\n                b = stack.pop()\n                a = stack.pop()\n                if token == '+':\n                    stack.append(a + b)\n                elif token == '-':\n                    stack.append(a - b)\n                elif token == '*':\n                    stack.append(a * b)\n                elif token == '/':\n                    if b == 0:\n                        return None\n                    stack.append(a / b)\n        return stack[0]\n\n    unique_results = set()\n    for perm in permutations(list(range(len(nums))) + list(range(len(nums), len(nums) + len(ops)))):\n        expression = []\n        for p in perm:\n            if p < len(nums):\n                expression.append(nums[p])\n            else:\n                expression.append(ops[p - len(nums)])\n        \n        result = solve(expression)\n        if result is not None:\n            unique_results.add(round(result, 6))\n    \n    return len(unique_results)\n\ndef main():\n    n = int(input())\n    nums = list(map(int, input().split()))\n    ops = input().split()\n    \n    print(calculate(nums, ops))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 05:58:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import itertools\n\ndef count_distinct_outcomes(expr):\n    tokens = []\n    i = 0\n    while i < len(expr):\n        if expr[i] in '+-*/':\n            tokens.append(expr[i])\n            i += 1\n        else:\n            j = i\n            while j < len(expr) and expr[j].isdigit():\n                j += 1\n            tokens.append(int(expr[i:j]))\n            i = j\n    \n    nums = []\n    ops = []\n    for token in tokens:\n        if isinstance(token, int):\n            nums.append(token)\n        else:\n            ops.append(token)\n    \n    if not ops:\n        return 1\n    \n    unique = set()\n    for perm in itertools.permutations(ops):\n        stack_nums = nums.copy()\n        stack_ops = list(perm)\n        temp_nums = [stack_nums.pop(0)]\n        for op in stack_ops:\n            temp_nums.append(stack_nums.pop(0))\n            b = temp_nums.pop()\n            a = temp_nums.pop()\n            if op == '+':\n                temp_nums.append(a + b)\n            elif op == '-':\n                temp_nums.append(a - b)\n            elif op == '*':\n                temp_nums.append(a * b)\n            elif op == '/':\n                temp_nums.append(a // b)\n        unique.add(temp_nums[0])\n    return len(unique)\n\nif __name__ == \"__main__\":\n    import sys\n    expr = sys.stdin.readline().strip()\n    print(count_distinct_outcomes(expr))",
    "timestamp": "2025-08-13 05:58:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nunordered_set<long long> resultSet;\nvector<long long> nums;\nvector<char> ops;\n\nvoid calculate(int l, int r) {\n    if (l == r) {\n        resultSet.insert(nums[l]);\n        return;\n    }\n    for (int i = l; i < r; ++i) {\n        vector<long long> left_results;\n        vector<long long> right_results;\n        \n        calculate(l, i);\n        for (long long left_result : resultSet) left_results.push_back(left_result);\n        resultSet.clear();\n        \n        calculate(i + 1, r);\n        for (long long right_result : resultSet) right_results.push_back(right_result);\n        resultSet.clear();\n        \n        for (long long left_result : left_results) {\n            for (long long right_result : right_results) {\n                if (ops[i] == '+') {\n                    resultSet.insert(left_result + right_result);\n                } else if (ops[i] == '-') {\n                    resultSet.insert(left_result - right_result);\n                } else if (ops[i] == '*') {\n                    resultSet.insert(left_result * right_result);\n                } else if (ops[i] == '/') {\n                    if (right_result != 0) {\n                        resultSet.insert(left_result / right_result);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    string expression;\n    cin >> expression;\n    \n    string num = \"\";\n    for (char c : expression) {\n        if (isdigit(c)) {\n            num.push_back(c);\n        } else {\n            nums.push_back(stoll(num));\n            ops.push_back(c);\n            num.clear();\n        }\n    }\n    nums.push_back(stoll(num));\n    \n    calculate(0, nums.size() - 1);\n    cout << resultSet.size() << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:29:17"
  }
]