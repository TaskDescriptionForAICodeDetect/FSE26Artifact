[
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-9;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nint main() {\n\twhile (1) {\n\t\tint n; ll i, j;\n\t\tscanf(\"%d%lld%lld\", &n, &i, &j);\n\t\tif (n == 0 && i == 0 && j == 0) break;\n\t\tvector <int> f;\n\t\tll mi = i;\n\t\tfor (int m = n; m; m--) {\n\t\t\tif (mi <= 1LL << (m - 1)) f.push_back(1), mi = (1LL << (m - 1)) + 1 - mi;\n\t\t\telse f.push_back(0), mi = mi - (1LL << (m - 1));\n\t\t}\n\t\treverse(all(f));\n\t\tint m = n;\n\t\tfor (int e : f) {\n\t\t\tif (e == 1) {\n\t\t\t\tif (j <= 1LL << (m - 1)) putchar('L'), j = (1LL << (m - 1)) + 1 - j;\n\t\t\t\telse putchar('R'), j = (1LL << m) + 1 - j;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (j <= 1LL << (m - 1)) putchar('R');\n\t\t\t\telse putchar('L'), j = j - (1LL << (m - 1));\n\t\t\t}\n\t\t\t--m;\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\npair<ll, ll> track(int n, string op, ll j) {\n\tll x = j;\n\tll y = 1;\n\tfor (int i = 0; i < op.length(); i++) {\n\t\tchar c = op[i];\n\t\tll x_, y_;\n\t\tif (x <= (ll)pow(2, n - i - 1)) {\n\t\t\tif (c == 'R') {\n\t\t\t\tx_ = x;\n\t\t\t\ty_ = y;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx_ = (ll)pow(2, n - i - 1) - x + 1;\n\t\t\t\ty_ = (ll)pow(2, i + 1) - y + 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (c == 'L') {\n\t\t\t\tx_ = x - (ll)pow(2, n - i - 1);\n\t\t\t\ty_ = y;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx_ = (ll)pow(2, n - i) - x + 1;\n\t\t\t\ty_ = (ll)pow(2, i + 1) - y + 1;\n\t\t\t}\n\t\t}\n\t\tx = x_;\n\t\ty = y_;\n\t}\n\tpair<ll, ll> p;\n\tp.first = x;\n\tp.second = y;\n\treturn p;\n}\n\nstring ans(int n, ll i, ll j) {\n\tif (n == 1) {\n\t\tif (i == 1 && j == 1) return \"L\";\n\t\tif (i == 1 && j == 2) return \"R\";\n\t\tif (i == 2 && j == 1) return \"R\";\n\t\tif (i == 2 && j == 2) return \"L\";\n\t}\n\tstring temp;\n\tif (i <= (ll)pow(2, n - 1)) {\n\t\ttemp = ans(n - 1, (ll)pow(2, n - 1) - i + 1, (j + 1) / 2);\n\t\tpair<ll, ll> p = track(n, temp, j);\n\t\tif (p.first == 1) {\n\t\t\ttemp += 'L';\n\t\t\treturn temp;\n\t\t}\n\t\treturn temp + 'R';\n\t}\n\ttemp = ans(n - 1, i - (ll)pow(2, n - 1), (j + 1) / 2);\n\tpair<ll, ll> p = track(n, temp, j);\n\tif (p.first == 1) {\n\t\ttemp += 'R';\n\t\treturn temp;\n\t}\n\treturn temp + 'L';\n}\n\nint main() {\n\tint n;\n\tll i, j;\n\tcin >> n >> i >> j;\n\twhile (true){\n\t\tif (n == 0 && i == 0 && j == 0) break;\n\t\tcout << ans(n, i, j) << endl;\n\t\tcin >> n >> i >> j;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=998244353;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n//  10:00-\n//A 10:05 AC\n//B 10:15 AC\n//C 10:21 AC\n\n\n/*\n3\n2\n1\n*/\nint solve(void){\n\tllint n,st,j,i,h,x;\n\tllint bas[61]={};\n\tbool fold[61]={};\n\tcin>>n;\n\tcin>>bas[n]>>x;\n\tif(n==0){return 0;}\n\tfor(h=n;h>0;h--){\n\t\tif(bas[h]<=(1LL<<(h-1))){fold[h]=1;bas[h-1]=(1LL<<(h-1))+1-bas[h];}\n\t\telse{fold[h]=0;bas[h-1]=bas[h]-(1LL<<(h-1));}\n\t\t//cerr<<\"bas[\"<<h-1<<\"]=\"<<bas[h-1]<<endl;\n\t}\n\tfor(h=1;h<=n;h++){\n\t\tif(x<=(1LL<<(n-h))){\n\t\t\tif(fold[h]){x=(1LL<<(n-h))+1-x;cout<<'L';}\n\t\t\telse{cout<<'R';}\n\t\t}else{\n\t\t\tif(fold[h]){x=(1LL<<(n-h+1))+1-x;cout<<'R';}\n\t\t\telse{x-=(1LL<<(n-h));cout<<'L';}\n\t\t}\n\t}\n\tcout<<endl;\n\treturn 1;\n}\nint main(void){\n\twhile(solve()){}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll p(ll a,ll n){ll s=(1LL<<n)-1,t=s/2;return t<a?a-t-1:t-a;}\nchar f(ll a,ll b,ll n){ll s = (1LL<<n)-1;return ((a*2>s)^(p(a, n)&1)^(b&1)?'L':'R');}\nint main(){\n\tll n, a, b;\n\twhile(cin>>n>>a>>b,n+a+b) {\n\t\ta--;b--;\n\t\tstring s;\n\t\twhile(n>1){s+=f(a, b, n);a = p(a, n);n--;b /= 2;}\n\t\ts+=(a^b?'R':'L');\n\t\treverse(s.begin(),s.end());\n\t\tcout<<s<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma once\n#include <stdio.h>\n#include <string>\n#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <numeric>\n#include<bitset>\n#include <iomanip>\n\nusing namespace std;\n#define modd 1000000007\n\n\ntypedef pair<long long, long long> pl;\n\n\n\n#define ll long long\n\n\n\n\n/*\nclass UnionFind {\npublic:\n\tvector <ll> par;\n\tvector <ll> siz;\n\tvector <ll> gr;\n\n\t// Constructor\n\tUnionFind(ll sz_) : par(sz_), siz(sz_, 1LL) ,gr(sz_){\n\t\tfor (ll i = 0; i < sz_; ++i) par[i] = i;\n\t}\n\tvoid init(ll sz_) {\n\t\tpar.resize(sz_);\n\t\tsiz.assign(sz_, 1LL);  // resize だとなぜか初期化されなかった\n\t\tfor (ll i = 0; i < sz_; ++i) par[i] = i; // 初期では親は自分自身\n\t}\n\n\t// Member Function\n\t// Find\n\tll root(ll x) { // 根の検索\n\t\twhile (par[x] != x) {\n\t\t\tx = par[x] = par[par[x]]; // x の親の親を x の親とする\n\t\t}\n\t\treturn x;\n\t}\n\n\t// Union(Unite, Merge)\n\tbool merge(ll x, ll y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) return false;\n\n\t\t// merge technique（データ構造をマージするテク．小を大にくっつける）\n\t\tif (siz[x] < siz[y]) swap(x, y);\n\t\tsiz[x] += siz[y];\n\t\tpar[y] = x;\n\t\treturn true;\n\t}\n\n\n\n\tbool issame(ll x, ll y) { // 連結判定\n\t\treturn root(x) == root(y);\n\t}\n\n\tll size(ll x) { // 素集合のサイズ\n\t\treturn siz[root(x)];\n\t}\n\n\n};*/\n\n\nlong long N, M, K, a, b, c, d, e, H, W, L;\nlong long A[200005] = {};\nlong long B[5005][5] = {};\nlong long C[205][205] = {};\nlong long D[200005] = {};\nlong long E[200005] = {};\nbool f, ff;\nstring S[2];\nset <long long>sll;\npl bufpl;\nvector <long long>vl[3];\nvector <pl>vpl;\nvector <string> vs;\nset<ll> llset;\n\n/*struct ST\n{\n\tlong long Kati;\n\tint bangou;\n\n\tbool operator<(const ST& another) const\n\t{\n\t\treturn Kati < another.Kati;//比較\n\t};\n\n};\n\n\n\nvector <ST> vst;\nST st[200005];\nST bufst;\nbitset<5000> bits;*/\n\n\nlong long modinv(long long aa, long long mm) {\n\tlong long bb = mm, uu = 1, vv = 0;\n\twhile (bb) {\n\t\tlong long tt = aa / bb;\n\t\taa -= tt * bb; swap(aa, bb);\n\t\tuu -= tt * vv; swap(uu, vv);\n\t}\n\tuu %= mm;\n\tif (uu < 0) uu += mm;\n\treturn uu;\n}\n\n\nbool otta[2005] = {};\nbool ri[2005] = {};\n\nll nijou[65] = {};\nll high,width;\n\nint main() {\n\n\tnijou[0] = 1;\n\tfor (int i = 1; i < 65; i++) {\n\t\tnijou[i] = nijou[i - 1] * 2;\n\t}\n\n\twhile (true) {\n\n\t\tcin >> N >> a >> b;\n\n\t\tif (N == 0 && a == 0 && b == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\t\n\n\t\tM = nijou[N];\n\t\thigh = nijou[N]-a+1;\n\n\t\td = N;\n\n\t\twhile (M > 1) {\n\t\t\tif (high > M / 2) {\n\t\t\t\totta[d] = true;\n\t\t\t\tc = high - (M / 2);\n\t\t\t\thigh = (M / 2) - c + 1;//\n\t\t\t}\n\t\t\telse {\n\t\t\t\totta[d] = false;\n\t\t\t}\n\n\t\t\td--;\n\t\t\tM /= 2;\n\n\t\t}\n\n\n\t\tM = nijou[N];\n\t\twidth = b;\n\n\t\td = 1;\n\n\t\twhile (M > 1) {\n\n\t\t\tif (otta[d] == true) {\n\t\t\t\tif (width <= M / 2) {\n\t\t\t\t\tri[d] = false;\n\t\t\t\t\tc = (M / 2) - width;\n\t\t\t\t\twidth = c + 1;//\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tri[d] = true;\n\t\t\t\t\tc = M - width;\n\t\t\t\t\twidth = c + 1;\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t\tif (otta[d] == false) {\n\t\t\t\tif (width <= M / 2) {\n\t\t\t\t\tri[d] = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tri[d] = false;\n\t\t\t\t\twidth = width - (M / 2);\n\t\t\t\t}\n\n\n\t\t\t}\n\n\n\n\t\t\td++;\n\t\t\tM /= 2;\n\n\t\t}\n\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tif (ri[i]) {\n\t\t\t\tcout << 'R';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << 'L';\n\t\t\t}\n\t\t}\n\n\t\tcout << endl;\n\n\n\t}\n\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll n,a,b;\n\nll dfs(ll d,ll h){\n  if(d==n)return b;\n  ll H=(1LL<<(n-1-d));\n  ll W=(1LL<<d);\n  if(h<H){\n    ll f=dfs(d+1,H-1-h);\n    if( f < W ){\n      printf(\"L\");\n      return W-1-f;\n    }else{\n      printf(\"R\");\n      return W+W-f-1;\n    }\n  }else{\n    ll f=dfs(d+1,h-H);\n    if( f < W ){\n      printf(\"R\");\n      return f;\n    }else{\n      printf(\"L\");\n      return f-W;\n    }\n  }\n}\n\nint main(){\n  while(1){\n    scanf(\"%lld %lld %lld\",&n,&a,&b);\n    if(n==0&&a==0&&b==0)break;\n    a--;\n    b--;\n    dfs(0,a);\n    printf(\"\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nsigned main(){\n  int n,ii,jj;\n  while(cin>>n>>ii>>jj,n){\n    int k=n;\n    ii--;jj--;\n    vector<int> v;\n    for(int i=0;i<n;i++){\n      k--;\n      //cout<<i<<\":\"<<(1LL<<k)<<\" \"<<ii<<endl;\n      if(ii<(1LL<<k)){\n\tii=(1LL<<k)-1LL-ii;\n\tv.push_back(1LL);\n      }else{\n\tii=ii-(1LL<<k);\n\tv.push_back(0);\n      }\n      //cout<<v[i]<<\" \"<<ii<<endl;;\n    }\n    //cout<<endl;\n    reverse(v.begin(),v.end());\n    k=n;\n    string ans;\n    for(int i=0;i<n;i++){\n      k--;\n      //cout<<i<<\":\"<<(1LL<<k)<<\" \"<<jj<<endl;\n      if(jj<(1LL<<k)){\n\tif(v[i]){\n\t  jj=(1LL<<k)-1LL-jj;\n\t  ans+=\"L\";\n\t}else{\n\t  ans+=\"R\";\n\t}\n      }else{\n\tif(v[i]){\n\t  jj-=(1LL<<k);\n\t  jj=(1LL<<k)-1LL-jj;\n\t  ans+=\"R\";\n\t}else{\n\t  jj-=(1LL<<k);\n\t  ans+=\"L\";\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30)\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n//ここから編集する\n\nvoid solve(int n,ll I,ll J){\n\n    ll maxL = 1;\n    ll maxH = (1LL << n);\n    ll curL = 1;\n    ll curH = I;\n    vector<int> cmd(n,1);//0がL,1がR\n//    ll cmd = (1 << n) - 1;//\n    while(maxH != 1){\n        maxL *= 2LL;\n        maxH /= 2LL;\n        if(curH > maxH){\n            curH -= maxH;\n        }else{\n            curL = maxL - curL + 1;\n            curH = maxH - curH + 1;\n        }\n    }\n    ll range = (1LL << n);\n    ll targetL = J;\n    ll nowL = curL;\n//    for(int i = n - 1; i >= 0; i--){\n    for(int i = 0; i < n; i++){\n        range >>= 1;\n//        if((targetL <= range) ^ (nowL <= range)){\n//            cmd[i] = 0;\n//        }\n        if(range == 0){\n//            cout << \"err\" << endl;\n        }\n        if(targetL <= range){\n            if(nowL <= range){\n            }else{\n                nowL -= range;\n                cmd[i] = 0;\n            }\n        }else{\n            if(nowL <= range){\n                targetL -= range;\n                cmd[i] = 0;\n            }else{\n                nowL -= range;\n                targetL -= range;\n            }\n        }\n    }\n    rep(i,0,n){\n//        cout << (cmd[i]) ? \"R\" : \"L\";\n        if(cmd[i] == 1){\n            cout << \"R\";\n        }else{\n            cout << \"L\";\n        }\n    }\n    cout << endl;\n    return;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(true){\n        int n;\n        ll I,J;\n        cin >> n >> I >> J;\n        if(n == 0) break;\n        solve(n,I,J);\n\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n\nint solve(){\n    int n;\n    ll pi,pj;\n    cin>>n>>pi>>pj;\n    pi--,pj--;\n    if(n==0) return 1;\n    swap(pi,pj);\n    vector<int> isUp(n);\n    ll tar=pj;\n    for(int i=n-1;i>=0;i--){\n        bool b=(tar<(1LL<<i));\n        if(b) tar=(1LL<<i)-tar-1;\n        else tar-=(1LL<<i);\n        isUp[i]=b;\n    }\n    string res;\n    for(int i=0;i<n;i++){\n        ll len=(1LL<<(n-i));\n        bool isToLeft=!((pi<len/2)^(isUp[i]));\n        if(isToLeft) res+=\"L\";\n        else res+=\"R\";\n        if(isToLeft && pi<len/2){\n            pi=len/2-pi-1;\n        }\n        else if(!isToLeft && len/2<=pi){\n            pi=len/2-(pi-len/2)-1;\n        }\n        else if(isToLeft && len/2<=pi){\n            pi=pi-len/2;\n        }\n    }\n    cout<<res<<endl;\n    return 0;\n}\n\nint main(){\n    while(!solve()) ;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nLL solve(LL P, int N) {\n\tLL res = 0;\n\tfor (LL i = 0; i < N; ++i) {\n\t\tif (((P & (1LL << (N - 1 - i))) > 0) ^ (res % 2 > 0)) {\n\t\t\tres = (1LL << (i + 1)) - 1 - res;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tLL N, A, B;\n\twhile (cin >> N >> A >> B, N) {\n\t\tLL P = solve((1LL << N) - A , N);\n\t\tLL Q = B - 1;\n\t\tLL R = P ^ Q;\n\t\tstring str;\n\t\tfor (LL i = 0; i < N; ++i) {\n\t\t\tif (R & (1LL << i)) {\n\t\t\t\tstr.push_back('L');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstr.push_back('R');\n\t\t\t}\n\t\t}\n\t\treverse(str.begin(), str.end());\n\t\tcout << str << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64=long long;\n\nmain()\n{\n    i64 n,a,b;\n    while(1)\n    {\n        cin>>n>>a>>b;\n        if(!n) break;\n        a--;\n        string op;\n        i64 c=1ll<<n;\n        for(int i=0;i<n;i++,(++b)/=2)\n        {\n            if((a&1)==(b&1)) op+='R';\n            else op+='L';\n            c>>=1;\n            // cerr<<\"\\t\"<<a<<\" \"<<b<<endl;\n            if(a<c) a=c-a-1;\n            else a-=c;\n        }\n        reverse(begin(op), end(op));\n        cout<<op<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#include<time.h>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<m; ++i)\n#define FOR(i,n,m) for(long long i=n; i<m; ++i)\n#define DUMP(n,a) for(long long dump=0; dump<n; ++dump) { cout<<a[dump]; if(dump!=n-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\n/*\n ????¬?\n ????±?????????? ???????§£???????????????(???????????????????????§??????)?????????????±????????????? ??????????????¬???B\n ?????????????????? ??????????§£????????????????????¨???????§£????????????????????????????????????????±????????????? ???????????±?????\\???????????°??¨???\n ??¢\n */\n\n/*\n DP\n ???DP??????????¨?????±?????????????????????????(?§£?????°?´????????§??????§???????????????)\n */\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tll n,i,j;\n\t\tcin>>n>>i>>j;\n\t\tif(n==0&&i==0&&j==0) break;\n\t\ti--;\n\t\tj--;\n\t\tstring ret=\"\";\n\t\tREP(roop,n) {\n\t\t\tif(i%(1ll<<(n-roop-1))==i%(1ll<<(n-roop))) {\n\t\t\t\tif(i%2==0) {\n\t\t\t\t\tif(j%2==0) {\n\t\t\t\t\t\tret+='L';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret+='R';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif(j%2==0) {\n\t\t\t\t\t\tret+='R';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret+='L';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti=((1ll<<(n-roop-1))-1)-i;\n\t\t\t} else {\n\t\t\t\tif(i%2==0) {\n\t\t\t\t\tif(j%2==0) {\n\t\t\t\t\t\tret+='R';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret+='L';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif(j%2==0) {\n\t\t\t\t\t\tret+='L';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret+='R';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti=i%(1ll<<(n-roop-1));\n\t\t\t}\n\t\t\tj/=2;\n\t\t}\n\t\tREP(roop,n) {\n\t\t\tcout<<ret[n-1-roop];\n\t\t}\n\t\tcout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nint n;\nlong mark_fold;\nlong mark_open;\n\nbool input() {\n\tstd::cin >> n;\n\tstd::cin >> mark_fold;\n\tstd::cin >> mark_open;\n\tif (n | mark_fold | mark_open) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid solve_print() {\n\tbool ud_list[n]; //true : 上, false : 下\n\tlong pow2 = 1l << (n-1);\n\n\t//各段階での印が半分より上か下かを求める\n\tfor (int i = 0; i < n; i++) {\n\t\tif ((ud_list[i] = (mark_fold <= pow2))) {\n\t\t\tmark_fold = pow2 - mark_fold + 1;\n\t\t\t//std::cout << \"true \";\n\t\t} else {\n\t\t\t//std::cout << \"false \";\n\t\t}\n\n\t\tpow2 = pow2 >> 1;\n\t}\n\n\t//上下の情報を元に折り方を復元\n\tpow2 = 1l << (n-1);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (ud_list[i]) {\n\t\t\tif (mark_open <= pow2) {\n\t\t\t\tstd::cout << \"L\";\n\t\t\t\tmark_open = pow2 - mark_open + 1;\n\t\t\t} else {\n\t\t\t\tstd::cout << \"R\";\n\t\t\t\tmark_open = pow2*2 - mark_open + 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (mark_open <= pow2) {\n\t\t\t\tstd::cout << \"R\";\n\n\t\t\t} else {\n\t\t\t\tstd::cout << \"L\";\n\t\t\t\tmark_open = mark_open - pow2;\n\t\t\t}\n\t\t}\n\n\t\tpow2 = pow2 >> 1;\n\t}\n\tstd::cout << std::endl;\n}\n\nint main(int argc, char const *argv[])\n{\n\t/* code */\n\n\twhile (input()) {\n\tsolve_print();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nunsigned int n;\nunsigned long i;\nunsigned long j;\n\nstd::vector<short> ub;\n\nint main(int argc, char const *argv[]) {\n\n\t//最初の問題を読み取る\n    std::cin >> n;\n    std::cin >> i;\n    std::cin >> j;\n\n    //問題が正規の間続ける\n    while (n > 0) {\n        ub.resize(n);\n        unsigned long length = 1ul << n;\n        for (int k = 0; k < n; k++) {\n            length >>= 1;\n            if (i <= length) {\n                ub[k] = 0;\n                i = length - i + 1;\n            } else {\n                ub[k] = 1;\n                i -= length;     \n            }\n        }\n\n        length = 1ul << n;\n        for (int k = 0; k < n; k++) {\n            length >>= 1;\n            if (j <= length) {\n                if (ub[n-k-1] == 0) {\n                    j = length - j + 1;\n                    std::cout << \"L\";\n                } else {\n                    std::cout << \"R\";\n                }\n            } else {\n                if (ub[n-k-1] == 0) {\n                    j = length - j + length + 1;\n                    std::cout << \"R\";\n                } else {\n                    j -= length;\n                    std::cout << \"L\";\n                }\n            }\n        }\n        std::endl(std::cout);\n\n\n\t    //次の問題を読み取る\n\t    std::cin >> n;\n        std::cin >> i;\n    \tstd::cin >> j;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nll x,y;\nll max_y[63];\nll target_y[63];\nint main(void){\n\tmax_y[0]=1;\n\tfor(int i=1;i<=62;i++){\n\t\tmax_y[i]=max_y[i-1]*2LL;\n\t}\n\twhile(1){\n\t\tscanf(\"%d%lld%lld\",&n,&y,&x);\n\t\tif(n==0 && y==0LL && x==0LL)break;\n\t\ty=(1LL<<n)-y+1LL;\n\t\ttarget_y[n]=y;\n\t\tfor(int i=n-1;i>=0;i--){\n\t\t\tif(target_y[i+1]>max_y[i]){\n\t\t\t\ttarget_y[i]=max_y[i]*2LL-target_y[i+1]+1LL;\n\t\t\t}else{\n\t\t\t\ttarget_y[i]=target_y[i+1];\n\t\t\t}\n\t\t}\n\t\tll nowy=1;\n\t\tll nowx=x;\n\t\tll len=(1LL<<n);\n\t\tstring res=\"\";\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(nowy==target_y[i+1]){\n\t\t\t\tif(nowx<=len/2LL){\n\t\t\t\t\tres+='R';\n\t\t\t\t}else{\n\t\t\t\t\tres+='L';\n\t\t\t\t\tnowx-=(len/2LL);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(nowx<=len/2LL){\n\t\t\t\t\tres+='L';\n\t\t\t\t\tnowx=len/2LL-nowx+1LL;\n\t\t\t\t}else{\n\t\t\t\t\tres+='R';\n\t\t\t\t\tnowx=len-nowx+1LL;\n\t\t\t\t}\n\t\t\t\tnowy=target_y[i+1];\n\t\t\t}\n\t\t\tlen/=2LL;\n\t\t}\n\t\tcout << res << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#include<time.h>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<m; ++i)\n#define FOR(i,n,m) for(long long i=n; i<m; ++i)\n#define DUMP(n,a) for(long long dump=0; dump<n; ++dump) { cout<<a[dump]; if(dump!=n-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\n/*\n ????¬?\n ????±?????????? ???????§£???????????????(???????????????????????§??????)?????????????±????????????? ??????????????¬???B\n ?????????????????? ??????????§£????????????????????¨???????§£????????????????????????????????????????±????????????? ???????????±?????\\???????????°??¨???\n ??¢\n */\n\n/*\n DP\n ???DP??????????¨?????±?????????????????????????(?§£?????°?´????????§??????§???????????????)\n */\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tll n,i,j;\n\t\tcin>>n>>i>>j;\n\t\tif(n==0&&i==0&&j==0) break;\n\t\ti--;\n\t\tj--;\n\t\tstring ret=\"\";\n\t\tREP(roop,n) {\n\t\t\tll _n=n-roop;\n\t\t\tif(i%(1ll<<(_n-1))==i%(1ll<<(_n))) {\n\t\t\t\tif(i%2==0) {\n\t\t\t\t\tif(j%2==0) {\n\t\t\t\t\t\tret+='L';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret+='R';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif(j%2==0) {\n\t\t\t\t\t\tret+='R';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret+='L';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti=((1ll<<(_n-1))-1)-i;\n\t\t\t} else {\n\t\t\t\tif(i%2==0) {\n\t\t\t\t\tif(j%2==0) {\n\t\t\t\t\t\tret+='L';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret+='R';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif(j%2==0) {\n\t\t\t\t\t\tret+='R';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret+='L';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti=i%(1ll<<(_n-1));\n\t\t\t}\n\t\t\tj/=2;\n\t\t}\n\t\tREP(roop,n) {\n\t\t\tcout<<ret[n-1-roop];\n\t\t}\n\t\tcout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll beki(ll a, ll b) {\n    if(b == 0) return 1;\n    ll ret = beki(a, b / 2);\n    ret *= ret;\n    if(b % 2 == 1) ret *= a;\n    return ret;\n}\n\nint main() {\n    while(true) {\n        ll n, a, b;\n        cin >> n >> a >> b;\n        if(n == 0 && a == 0 && b == 0) break;\n        ll SIZE = beki(2, n);\n        a = SIZE - a + 1;\n        //cerr << a << endl;\n        string ans = \"\";\n        for(int time = 1; time <= n; time++) {\n            //cerr << time << \" \" << SIZE << \" \" << b << \" \";\n            bool upper = false;\n            ll copy = a + beki(2, time + 1) - beki(2, time - 1) - 1;\n            if((copy % beki(2, time + 1)) < beki(2, time)) upper = true;\n            if(upper) {\n                if(b <= SIZE / 2) {\n                    ans += \"L\";\n                    SIZE /= 2;\n                    b = SIZE - b + 1;\n                    //cerr << \"one\" << endl;\n                } else {\n                    ans += \"R\";\n                    b = SIZE - b + 1;\n                    SIZE /= 2;\n                    //cerr << \"two\" << endl;\n                }\n            } else {\n                if(b <= SIZE / 2) {\n                    ans += \"R\";\n                    SIZE /= 2;\n                    //cerr << \"three\" << endl;\n                } else {\n                    ans += \"L\";\n                    SIZE /= 2;\n                    b -= SIZE;\n                    //cerr << \"four\" << endl;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repq(i,a,n) for(int i=a; i<=n; i++)\ntypedef long long int ll;\ntypedef pair<int, int> pii;\n\nint main() {\n  long long int N, I, J;\n  while(cin >> N >> I >> J, N){\n    vector<ll> height;\n    --I;\n    --J;\n    ll t = I;\n    for(int i = 0; i < N; ++i){\n      height.push_back(t);\n      t = (1LL<<(N-i-1))-t;\n      if(t > 0) --t;\n      else t = -t;\n    }\n    height.push_back(t);\n    reverse(height.begin(),height.end());\n    //for(int i = 0; i < N+1; ++i)\n    //cout << height[i] << endl;\n    string ans = \"\";\n    for(int i = 0; i < N; ++i){\n      if((height[i+1] == height[i] + (1LL<<(i))) ^ (J >= (1LL<<(N-i-1)))){\n\tans += \"R\";\n\tif(J >= 1LL<<(N-i-1)) \n\t  J = (1LL<<(N-i))-J-1;\n      }else{\n\tans += \"L\";\n\tif(J >= (1LL<<(N-i-1))) J = -(1LL<<(N-i-1))+J;\n\telse J = (1LL<<(N-i-1))-J-1;\n      }\n      //printf(\"J = %lld\\n\", J);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <string>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nusing namespace std;\n\n// using ll = long long;\n// using P = pair<int, int>;\n// using minpq = priority_queue<int, vector<int>, greater<int> >;\n\nint main() {\n    while (true) {\n        long n, i, j;\n        cin >> n >> i >> j;\n        if (n == 0) break;\n        long pow = 1;\n        for (int id=0; id<n; id++) pow *= 2;\n        bool up[n];\n        for (int id=n-1; id>=0; id--) {\n            up[id] = (i <= pow/2); \n            if (i > pow / 2) \n                i -= pow/2;\n            else \n                i = pow/2 - i + 1;\n            pow /= 2;\n        }\n        pow = 1;\n        for (int id = 0; id < n; id++) pow *= 2;\n        for (int id=0; id<n; id++) {\n            if (j > pow / 2 && up[id]) {\n                cout << 'R';\n                j = pow - j + 1;\n            } else if (j > pow / 2 && !up[id]) {\n                cout << 'L';\n                j = j - pow/2;\n            } else if (up[id]) {\n                cout << 'L';\n                j = pow / 2 - j + 1;\n            } else {\n                cout << 'R';\n            }\n            pow /= 2;\n        }\n        cout << '\\n';\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1 ; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1 ; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst ll INF = 1e9+100;\nconst bool debug = 0;\n/***************************************/\n\nint main() {\n  ll N, y, x;\n  while (cin >> N >> y >> x, N || y || x) {\n    if (debug) putchar('@');\n\n    int ope[61] = {}; // 0:no 1:plus\n    ll h = 1ll<<N;\n    REP(i, N) {\n      if (y <= h / 2) {\n        ope[N - i - 1] = 1;\n        y = h / 2 - y + 1;\n      }\n      else y -= h / 2;\n      h /= 2;\n    }\n\n    string ans = \"\";\n    h = 1ll<<N;\n    REP(i, N) {\n      if (x <= h / 2 && ope[i]) {\n        ans += \"L\";\n        x = h / 2 - x + 1;\n      }\n      else if (x <= h / 2 && !ope[i]) {\n        ans += \"R\";\n      }\n      else if (x > h / 2 && ope[i]) {\n        x -= h / 2;\n        x = h / 2 - x + 1;\n        ans += \"R\";\n      }\n      else {\n        x -= h / 2;\n        ans += \"L\";\n      }\n\n      h /= 2;\n    }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n\nbool istop[100];\nint position[100];\nvoid init() {}\n\nbool solve() {\n    int N;\n    cin >> N;\n    int i, j;\n    cin >> i >> j;\n    if (N == 0) return false;\n    // i--, j--;\n    int m = N;\n    int pos = i;\n    while (m) {\n        if (i <= (1LL << (m - 1))) {\n            position[m - 1] = (1LL << (m - 1)) - i + 1;\n            istop[m - 1] = true;\n        } else {\n            position[m - 1] = i - (1LL << (m - 1));\n            istop[m - 1] = false;\n        }\n        i = position[m - 1];\n        m--;\n    }\n    string ans;\n    REP(i, N) {\n        int sum = 1LL << (N - i);\n        if (istop[i]) {\n            if (j <= sum / 2) {\n                ans += 'L';\n                j = sum / 2 - j + 1;\n            } else {\n                ans += 'R';\n                j = sum - j + 1;\n            }\n        } else {\n            if (j <= sum / 2) {\n                ans += 'R';\n                // j = sum / 2 - j + 1;\n            } else {\n                ans += 'L';\n                j = j - sum / 2;\n            }\n        }\n    }\n    cout << ans << endl;\n    return true;\n}\nsigned main() {\n    init();\n    while (solve())\n        ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\nint n;\nlint i, j;\n\nvoid solve(){\n    --i; --j;\n    int rev[n + 1], bottom[n + 1];\n    memset(rev, 0, sizeof(rev));\n    memset(bottom, 0, sizeof(bottom));\n    for(int k = n; k >= 1; --k){\n        if(i < (1LL << (k - 1))){\n            i = (1LL << (k - 1)) - i - 1;\n            rev[k] = 1;\n        }\n        else{\n            i -= (1LL << (k - 1));\n            bottom[k] = 1;\n        }\n    }\n    rep(k, n) rev[k + 1] ^= rev[k];\n    string ans;\n    for(int k = n; k >= 1; --k){\n        if(rev[k - 1] ^ (j >> (n - k) & 1) ^ bottom[k]) ans += 'R';\n        else ans += 'L';\n    }\n    reverse(ans.begin(), ans.end());\n    cout << ans << \"\\n\";\n}\n\nint main(){\n    while(scanf(\"%d%lld%lld\", &n, &i, &j) && n){\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\nint dy[]={0, 0, 1, -1, 1, 1, -1, -1};\nint dx[]={1, -1, 0, 0, 1, -1, -1, 1};\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define mp make_pair\n#define fi first\n#define sc second\nll n,i,j;\nint main(){\n\twhile(1) {\n\t\tcin >> n >> i >> j;\n\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\ti--;j--;\n\t\tchar ans[1000];\n\t\tans[n] = '\\0';\n\n\t\tRREP(k,n) {\n\t\t\t//cout << i << \" \" << j << endl;\n\t\t\tif((i ^ j) & 1) {\n\t\t\t\tans[k] = 'R';\n\t\t\t}else {\n\t\t\t\tans[k] = 'L';\n\t\t\t}\n\n\t\t\tif(i < (1ll << k)) {\n\t\t\t\ti = (1ll << k) - i - 1;\n\t\t\t}else{\n\t\t\t\ti -= (1ll << k);\n\t\t\t}\n\t\t\tj /= 2;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-4;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\ntypedef vector<string> svec;\n\nint n; ll g, s;\nvoid solve() {\n\tg--; s--;\n\tstring ans;\n\twhile (n > 0) {\n\t\tll k = (ll)1 << (n-1);\n\t\tif (g % 4 == 0 || g % 4 == 3) {\n\t\t\tif (s < k) {\n\t\t\t\tans.push_back('R');\n\t\t\t\t\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans.push_back('L');\n\t\t\t\ts -= k;\n\t\t\t}\n\t\t\tll d = g / 4; d *= 2;\n\t\t\tif (g % 4)d++;\n\t\t\tg = d; n--;\n\t\t}\n\t\telse {\n\t\t\tif (s < k) {\n\t\t\t\tans.push_back('L');\n\t\t\t\ts = k - 1 - s;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans.push_back('R');\n\t\t\t\ts -= k; s = k - 1 - s;\n\t\t\t}\n\t\t\tll d = g / 4; d *= 2;\n\t\t\tif (g % 4 == 2)d++;\n\t\t\tg = d; n--;\n\t\t}\n\t}\n\tif (ans.back() == 'R')ans.back() = 'L';\n\telse ans.back() = 'R';\n\tcout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(11);\n\twhile (cin >> n>>g>>s, n) {\n\t\tsolve();\n\t}\n\t//solve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nll n,i,j;\n\nint main(){\n  while(1){\n    cin>>n>>i>>j;\n    if(n==0)break;\n    i--; j--;\n    string res=\"\";\n    while(n>0){\n      if(i%2==j%2) res+=\"L\";\n      else res+=\"R\";\n      if(i<(1LL<<(n-1)))i=(1LL<<(n-1))-1LL-i;\n      else i-=(1LL<<(n-1));\n      j/=2;\n      n--;\n    }\n    reverse(all(res));\n    cout<<res<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll dfs(ll d,ll h,ll n,ll a,ll b,string& ans){\n  \n  if(d==n){\n    return b;\n  }\n  \n\n  ll H=(1LL<<(n-1-d));\n  ll W=(1LL<<d);\n  \n  if(h<H){\n    ll f=dfs(d+1,H-1-h,n,a,b,ans);\n    if( f < W ){\n      ans+='L';\n      return W-1-f;\n    }else{\n      ans+='R';\n      return W+W-f-1;\n    }\n    \n  }else{\n    ll f=dfs(d+1,h-H,n,a,b,ans);\n    if( f < W ){\n      ans+='R';\n      return f;\n    }else{\n      ans+='L';\n      return f-W;\n    }\n  }\n}\n\nint main(){\n  while(1){\n    ll n,a,b;\n    cin>>n>>a>>b;\n    if(n==0&&a==0&&b==0)break;\n    a--;\n    b--;\n    string ans=\"\";\n    dfs(0,a,n,a,b,ans);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\n#define int long long\n\nusing namespace std;\n\n\nclass Solver {\n};\n\nsigned main() {\n\twhile (true) {\n\t\tint n, i, j;\n\t\tcin >> n >> i >> j;\n\t\tif (n == 0)break;\n\n\t\tint up = i - 1;\n\t\tint down = n - up - 1;\n\t\tvector<bool> ups(n, false);\n\t\tint val = pow(2, n - 1);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tif (val <= up) {\n\t\t\t\tup -= val;\n\t\t\t\tups[i] = true;\n\t\t\t}\n\t\t\telse down -= val;\n\n\t\t\tval /= 2;\n\t\t}\n\n\t\tint now = j - 1;\n\t\tint len = pow(2, n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tbool left = now < len / 2;\n\t\t\tbool toLeft = false;\n\t\t\tif (i + 1 < n) {\n\t\t\t\tif (ups[i] == ups[i + 1]) {\n\t\t\t\t\tif (left)toLeft = true;\n\t\t\t\t\telse toLeft = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (left)toLeft = false;\n\t\t\t\t\telse toLeft = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (ups[i]) {\n\t\t\t\t\tif (left)toLeft = true;\n\t\t\t\t\telse toLeft = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (left)toLeft = false;\n\t\t\t\t\telse toLeft = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlen /= 2;\n\t\t\tif (toLeft) {\n\t\t\t\tcout << 'R';\n\t\t\t\tif (!left) {\n\t\t\t\t\tnow = len - now % len - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << 'L';\n\t\t\t\tif (left) {\n\t\t\t\t\tnow = len - now - 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnow %= len;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60)+1e9; // ~ 1.15 * 1e18\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\n\nvector<Int> getNum(Int n, Int b){\n  vector<Int> res;\n  Int x = 1LL<<(n - 1);\n  Int num = (b - 1) - ((1LL<<n) - b);\n  while(x){\n    if(abs(num + x) < abs(num - x)) num += x, res.push_back(-x);\n    else num -= x, res.push_back(x);\n    x /= 2;\n  }\n  reverse(res.begin(), res.end());\n  return res;\n}\n\nstring rev(string s){\n  for(char &ch:s) ch = ch == 'L'? 'R':'L';\n  return s;\n}\n\nstring solve(Int n,Int a, Int b){\n  a = (1LL<<n) - a + 1;\n  Int height = (1LL<<n);\n  string res;\n  auto dir = getNum(n, b);\n  for(Int x:dir){\n    Int openL = -1;\n    if(height / 2 >= a){ //lower\n      if(x > 0) openL = 1;\n      if(x < 0) openL = 0;\n    }\n    else{                //upper\n      if(x > 0) openL = 0, a = height - a + 1, res = rev(res);\n      if(x < 0) openL = 1, a = height - a + 1, res = rev(res);\n    }\n    assert(x != 0);\n    res += openL? 'L':'R';\n    height /= 2;\n  }\n  reverse(res.begin(), res.end());\n  return res;\n}\n\nsigned main(){\n  srand((unsigned)time(NULL));\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(1){\n    Int n, a, b;\n    cin>>n>>a>>b;\n    if(n == 0 && a == 0 && b == 0) return 0;\n    string ans = solve(n, a, b);\n    cout<<ans<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a) {\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'[';\n    for(const T &i: a) out<<i<<',';\n    out<<']';\n    return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out, const set<T>& a) {\n    out<<'{';\n    for(const T &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\ntemplate<class T, class S>\nostream &operator <<(ostream& out, const map<T,S>& a) {\n    out<<'{';\n    for(auto &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(1) {\n        ll n, y, x;\n        cin >> n >> y >> x;\n        if(!n) break;\n        y--, x--;\n\n        // ほどいていったときの印がついている位置のyの遷移\n        ll h = 1LL<<n;\n        vector<ll> transy(1, y);\n        REP(i, n) {\n            if(y < h/2) {\n                y = h/2 - y - 1;\n            } else {\n                y -= h/2;\n            }\n            transy.push_back(y);\n            h /= 2;\n        }\n\n        string ans = \"\";\n        for(ll i=n-1, h=2, w=1LL<<n; i>=0; --i, h*=2, w/=2) {\n            // transy[i] で LR どちらを選ぶか決められる\n            if(transy[i] < h/2) {\n                if(x < w/2) {\n                    ans += \"L\";\n                    x = w/2-1 - x;\n                } else {\n                    ans += \"R\";\n                    x = w-1 - x;\n                }\n            } else {\n                if(x < w/2) {\n                    ans += \"R\";\n                } else {\n                    ans += \"L\";\n                    x = x - w/2;\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n\tll n,a,b;\n\twhile(cin>>n>>a>>b,n){\n\t\ta--;b--;\n\t\tvi q(n);\n\t\tll T=a;\n\t\trep(i,n){\n\t\t\tll t=1ll<<(n-1-i);\n\t\t\tq[i]=T<t;\n\t\t\tT=max(t-T-1,T-t);\n//\t\t\tcout<<q[i]<<\" \"<<T<<endl;\n\t\t}\n\t\trep(i,n){\n\t\t\tll t=1ll<<(n-1-i);\n\t\t\tif(b<t&&q[n-1-i]){\n\t\t\t\tcout<<\"L\";\n\t\t\t\tb=t-b-1;\n\t\t\t}else if(t<=b&&q[n-1-i]==0){\n\t\t\t\tcout<<\"L\";\n\t\t\t\tb=b-t;\n\t\t\t}else if(b<t&&q[n-1-i]==0){\n\t\t\t\tcout<<\"R\";\n\t\t\t\tb=b;\n\t\t\t}else if(t<=b&&q[n-1-i]){\n\t\t\t\tcout<<\"R\";\n\t\t\t\tb=2*t-b-1;\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<pa,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                    \t\treturn x != p.x ? x<p.x: y<p.y;\n                                    \t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\nint n,V,W,K,N,L,R;\nvector<int>ve;\n\n//int dp[2][10001]={0};\nint a[1010] ;\nint s;\n           signed main(){\n            int n,i,j;\n           \twhile(cin>>n>>i>>j){\n           \t\tif(n==0) return 0;\n           \t\ti--;\n           \t\tj--;\n           \t\tstring ans=\"\";\n           \t\twhile(n){\n           \t\t\tif((i+j)%2) ans=\"R\"+ans;\n           \t\t\telse ans=\"L\"+ans;\n           \t\t\t\n           \t\t\tif(i<(1ll<<(n-1))) i=(1ll<<(n-1))-i-1;\n           \t\t\telse i -= (1ll<<(n-1));\n           \t\t\tj/=2;\n           \t\t\t\n           \t\t\tn--;\n           \t\t}\n           \t\tcout<<ans<<endl;\n           \t}\n           \t\n           \t\n           \t\n           \t\n           \t\n           }\n             "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long n, x, y;\n\nstring solve();\n\nint main() {\n  while(1) {\n    cin >> n >> x >> y;\n    if(n + x + y == 0) break;\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nstring solve() {\n  string res;\n  --y;\n  --x;\n  for(int i = 0; i < n; ++i) {\n    if((y % 2) ^ (x % 2))\n      res += 'R';\n    else\n      res += 'L';\n    if((1LL << (n - i - 1)) > x)\n      x = (1LL << (n - i)) - x - 1;\n    y >>= 1;\n    x %= 1LL << (n - i - 1);\n  }\n  reverse(res.begin(), res.end());\n  return res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll n,a,b;\n\nll dfs(ll d,ll h){\n  if(d==n)return b;\n  ll H=(1LL<<(n-1-d));\n  ll W=(1LL<<d);\n  if(h<H){\n    ll f=dfs(d+1,H-1-h);\n    printf( f<W ? \"L\" : \"R\" );\n    return W-(f%W)-1;\n  }else{\n    ll f=dfs(d+1,h-H);\n    if( f < W ){\n      printf(\"R\");\n      return f;\n    }else{\n      printf(\"L\");\n      return f-W;\n    }\n  }\n}\n\nint main(){\n  while(1){\n    scanf(\"%lld %lld %lld\",&n,&a,&b);\n    if(n==0&&a==0&&b==0)break;\n    a--;\n    b--;\n    dfs(0,a);\n    printf(\"\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; ++i)\n#define rep2(i, a, b) for(int i = (a); i <= (b); ++i)\n#define ll long long\n\nmain() {\n    while(1) {\n        ll n, x, y;\n        cin >> n >> x >> y;\n        if(!n) return 0;\n        string s = \"LR\";\n        x--, y--;\n        vector<int> v(n);\n        rep(i, n) {\n            v[i] = (x < (1LL << (n - 1 - i)));\n            if(v[i])\n                x = x ^ ((1LL << (n - 1 - i)) - 1);\n            else\n                x -= 1LL << (n - 1 - i);\n        }\n        for(int i = n - 1; i + 1; --i) {\n            int t = (y < (1LL << i) ^ v[i]) > 0;\n            if(y >= (1LL << i)) {\n                y ^= 1LL << i;\n                if(t) y ^= (1LL << i) - 1;\n            } else if(!t)\n                y ^= (1LL << i) - 1;\n            cout << s[t];\n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n/* ---------------------------------------------------------------------------------------------------- */\n\nint n,i,j;\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  while (cin >> n >> i >> j, n) {\n    i--; j--;\n    string ans;\n    while (n > 0) {\n      if ((i % 2 == 0) ^ (j % 2 == 0)) {\n        ans = \"R\" + ans;\n      } else {\n        ans = \"L\" + ans;\n      }\n      if (i < POW(n-1)) {\n        i = POW(n-1)-1-i;\n      } else {\n        i = i - POW(n-1);\n      }\n      j >>= 1;\n      n--;\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\n#define int long long\n\nusing namespace std;\n\n\nclass Solver {\n};\n\nsigned main() {\n\twhile (true) {\n\t\tint n, i, j;\n\t\tcin >> n >> i >> j;\n\t\tif (n == 0)break;\n\n\t\tint up = i - 1;\n\t\tint down = n - up - 1;\n\t\tvector<bool> ups(n, false);\n\t\tint val = pow(2, n - 1);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tif (val <= up) {\n\t\t\t\tup -= val;\n\t\t\t\tups[i] = true;\n\t\t\t}\n\t\t\telse down -= val;\n\n\t\t\tval /= 2;\n\t\t}\n\n\t\tint now = j - 1;\n\t\tint len = pow(2, n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tbool left = now < len / 2;\n\t\t\tbool toLeft = false;\n\t\t\tif (i + 1 < n) {\n\t\t\t\tif (ups[i] == ups[i + 1]) {\n\t\t\t\t\tif (left)toLeft = true;\n\t\t\t\t\telse toLeft = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (left)toLeft = false;\n\t\t\t\t\telse toLeft = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (ups[i]) {\n\t\t\t\t\tif (left)toLeft = true;\n\t\t\t\t\telse toLeft = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (left)toLeft = false;\n\t\t\t\t\telse toLeft = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlen /= 2;\n\t\t\tif (toLeft) {\n\t\t\t\tcout << 'R';\n\t\t\t\tif (!left) {\n\t\t\t\t\tnow = len - now % len - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << 'L';\n\t\t\t\tif (left) {\n\t\t\t\t\tnow = len - now - 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnow %= len;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1 ; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1 ; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst ll INF = 1e9+100;\nconst bool debug = 0;\n/***************************************/\n\nint main() {\n  puts(\"K\");\n  ll N, y, x;\n  while (cin >> N >> y >> x, N || y || x) {\n    if (debug) putchar('@');\n\n    int ope[61] = {}; // 0:no 1:plus\n    ll h = 1ll<<N;\n    REP(i, N) {\n      if (y <= h / 2) {\n        ope[N - i - 1] = 1;\n        y = h / 2 - y + 1;\n      }\n      else y -= h / 2;\n      h /= 2;\n    }\n\n    string ans = \"\";\n    h = 1ll<<N;\n    REP(i, N) {\n      if (x <= h / 2 && ope[i]) {\n        ans += \"L\";\n        x = h / 2 - x + 1;\n      }\n      else if (x <= h / 2 && !ope[i]) {\n        ans += \"R\";\n      }\n      else if (x > h / 2 && ope[i]) {\n        x -= h / 2;\n        x = h / 2 - x + 1;\n        ans += \"R\";\n      }\n      else {\n        x -= h / 2;\n        ans += \"L\";\n      }\n\n      h /= 2;\n    }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing Vec = vector<ll>;\n#define REP(i, m, n) for(ll i = (m); i < (n); ++i)\n#define rep(i, n) REP(i, 0, n)\ntemplate <typename T>\nbool chmax(T &a, const T b){if(a < b){a = b; return true;} return false;}\ntemplate <typename T>\nbool chmin(T &a, const T b){if(a > b){a = b; return true;} return false;}\nconstexpr ll LINF = 1e18+1;\nconstexpr ll MOD = 1e9+7;\n\nint main(void) {\n\tll n, m, l;\n\twhile(true){\n\t\tcin >> n >> m >> l;\n\t\tif(n == 0 && m == 0 && l == 0) break;\n\t\tm = (1LL << n) - m;\n\t\t--l;\n\t\t\n\t\tbool cnt = false;\n\t\tvector<bool> up(n);\n\t\tfor(int i = n - 1; i >= 0; --i){\n\t\t\tif(((m >> i) & 1) ^ cnt){\n\t\t\t\tup[i] = true;\n\t\t\t\tcnt = !cnt;\n\t\t\t}\n\t\t}\n\n\t\tstring ans;\n\t\trep(i, n){\n\t\t\tll b = 1LL << (n - 1 - i);\n\t\t\tif(up[i]){\n\t\t\t\tif(l < b){\n\t\t\t\t\tans += 'L';\n\t\t\t\t\tl = b - 1 - l;\n\t\t\t\t}else{\n\t\t\t\t\tans += 'R';\n\t\t\t\t\tl = 2 * b - 1 - l;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(l < b){\n\t\t\t\t\tans += 'R';\n\t\t\t\t}else{\n\t\t\t\t\tans += 'L';\n\t\t\t\t\tl -= b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define len(v) (int)(v).size()\n#define ll long long\n\nusing namespace std;\n\nvoid dfs(ll n,ll i,ll j,string& s)\n{\n    ll l,r;\n    if(j % 2){\n        l = i, r = (1LL << n)+1LL-i;\n    }else{\n        l = (1LL << n)+1-i, r = i;\n    }\n    ll mn = min(i,(1LL << n)+1LL-i);\n    ll up = (1LL << (n-1))-mn+1LL;\n    if(n == 1){\n        if(l < r){\n            s.push_back('L');\n        }else{\n            s.push_back('R');\n        }\n        return;\n    }\n    if(up%2){\n        if(l < r){\n            s.push_back('R');\n        }else{\n            s.push_back('L');\n        }\n    }else{\n        if(l < r){\n            s.push_back('L');\n        }else{\n            s.push_back('R');\n        }\n    }\n    dfs(n-1,up,(j+1)/2,s);\n}\n\nint main()\n{\n    while(1){\n        ll n,i,j;\n        cin >> n >> i >> j;\n        if(n == 0){\n            break;\n        }\n        string s;\n        dfs(n,i,j,s);\n        reverse(s.begin(),s.end());\n        cout << s << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\nusing pii=pair<int, int>;\n\n#define int long long\n\nsigned main(void) {\n\tvector<int> pow2 = { 1 };\n\trep(i, 0, 61) {\n\t\tpow2.push_back(pow2.back() * 2);\n\t}\n\tfor (int n, I, J; cin >> n >> I >> J && n;) {\n\t\tI--, J--;\n\t\tstring AB = \"\";\n\t\tfor(int i = n - 1; i >= 0; i--){\n\t\t\tint AI = pow2[i] - 1 - I;\n\t\t\tint BI = I - pow2[i];\n\t\t\tif (AI >= 0) {\n\t\t\t\tAB.push_back('A');\n\t\t\t\tI = AI;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tAB.push_back('B');\n\t\t\t\tI = BI;\n\t\t\t}\n\t\t}\n\t\treverse(AB.begin(), AB.end());\n\t\t//cout << AB << endl;\n\t\tstring LR = \"\";\n\t\trep(i, 0, n) {\n\t\t\tif (J < pow2[n - i - 1]) {\n\t\t\t\tif(AB[i] == 'A'){\n\t\t\t\t\tLR.push_back('L');\n\t\t\t\t\tJ = pow2[n - i - 1] - J - 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLR.push_back('R');\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (AB[i] == 'A') {\n\t\t\t\t\tLR.push_back('R');\n\t\t\t\t\tJ = pow2[n - i] - J - 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLR.push_back('L');\n\t\t\t\t\tJ = J - pow2[n - i - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << LR << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n\nint main(){\n    int n;\n    \n    long long a,b;\n    while(cin >> n >> a >> b&&n!=0){\n        a--;b--;\n        string s;   \n        rep(i,n){\n            if(a%2!=b%2){\n                s.push_back('R');\n            }else{\n                s.push_back('L');\n            }\n            if(a >= (1LL<<(n-i-1))){\n                a -= (1LL<<(n-i-1));\n            }else{\n                a = (1LL<<(n-i-1))-1- a;\n            }\n            b/=2;\n        }\n        reverse(s.begin(),s.end());\n        cout << s << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nint n;\nlong mark_fold;\nlong mark_open;\n\nbool input() {\n\tstd::cin >> n;\n\tstd::cin >> mark_fold;\n\tstd::cin >> mark_open;\n\tif (n == 0 && mark_fold == 0 && mark_open == 0) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid solve_print() {\n\tbool ud_list[n]; //true : 上, false : 下\n\tlong pow2 = 1l << (n-1);\n\n\t//各段階での印が半分より上か下かを求める\n\tfor (int i = n-1; 0 <= i; i--) {\n\t\tif (mark_fold <= pow2) {\n\t\t\tud_list[i] = true;\n\t\t\tmark_fold = pow2 - mark_fold + 1;\n\t\t\t//std::cout << \"u \";\n\t\t} else {\n\t\t\tud_list[i] = false;\n\t\t\tmark_fold = mark_fold - pow2;\n\t\t\t//std::cout << \"d \";\n\t\t}\n\n\t\tpow2 = pow2 >> 1;\n\t}\n\t//std::cout << std::endl;\n\n\n\t//上下の情報を元に折り方を復元\n\tpow2 = 1l << (n-1);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (ud_list[i]) {\n\t\t\tif (mark_open <= pow2) {\n\t\t\t\tstd::cout << \"L\";\n\t\t\t\tmark_open = pow2 - mark_open + 1;\n\t\t\t} else {\n\t\t\t\tstd::cout << \"R\";\n\t\t\t\tmark_open = pow2*2 - mark_open + 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (mark_open <= pow2) {\n\t\t\t\tstd::cout << \"R\";\n\n\t\t\t} else {\n\t\t\t\tstd::cout << \"L\";\n\t\t\t\tmark_open = mark_open - pow2;\n\t\t\t}\n\t\t}\n\n\t\tpow2 = pow2 >> 1;\n\t}\n\tstd::cout << std::endl;\n}\n\nint main(int argc, char const *argv[])\n{\n\t/* code */\n\n\twhile (input()) {\n\tsolve_print();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define int long long\nusing namespace std;\n\nint n, i, j;\n\nsigned main() {\n\twhile (cin >> n >> i >> j) {\n\t\tif (!n) { break; }\n\t\ti--; j--;\n\t\t\n\t\tstring ans;\n\t\twhile (n > 0) {\n\t\t\tif (i % 2 == j % 2) ans += 'L';\n\t\t\telse ans += 'R';\n\t\t\tif (i < (1LL << (n - 1))) i = (1LL << (n - 1)) - 1 - i;\n\t\t\telse i -= (1LL << (n - 1));\n\t\t\tn--;\n\t\t\tj /= 2;\n\t\t}\n\t\tfor (int k = ans.length() - 1; k >= 0; k--) {\n\t\t\tcout << ans[k];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long int lli;\n\nint main(){\n\twhile(1){\n\t\tlli n,pn,q0;\n\t\tcin >> n >> pn >> q0;\n\t\tpn--; q0--;\n\t\tif(n == 0) break;\n\n\t\tvector<lli> p(n+1);\n\t\tp[n] = pn;\n\t\tstring op = \"\";\n\t\tfor(int i=n; i>0; i--){\n\t\t\tlli half = 1LL<<(i-1);\n\t\t\tif(p[i] < half){\n\t\t\t\top += \"U\";\n\t\t\t\tp[i-1] = half-1 -p[i];\n\t\t\t}else{\n\t\t\t\top += \"D\";\n\t\t\t\tp[i-1] = p[i] -half;\n\t\t\t}\n\t\t}\n\t\treverse(op.begin(), op.end());\n\n\t\tvector<lli> q(n+1);\n\t\tq[0] = q0;\n\t\tstring ans = \"\";\n\t\tfor(int i=0; i<n; i++){\n\t\t\tlli half = 1LL<<(n-i-1);\n\t\t\tif(q[i] < half){\n\t\t\t\tif(op[i] == 'U'){\n\t\t\t\t\tq[i+1] = half-1 -q[i];\n\t\t\t\t\tans += \"L\";\n\t\t\t\t}else{\n\t\t\t\t\tq[i+1] = q[i];\n\t\t\t\t\tans += \"R\";\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(op[i] == 'U'){\n\t\t\t\t\tq[i+1] = 2*half-1 -q[i];\n\t\t\t\t\tans += \"R\";\n\t\t\t\t}else{\n\t\t\t\t\tq[i+1] = q[i] -half;\n\t\t\t\t\tans += \"L\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#define LL long long int\nusing namespace std;\n\nbool unfold(LL& x, LL m)\n{\n    bool tmp = x > m / 2;\n    if(tmp)\n        x = m + 1 - x;\n    return tmp;\n}\n\nbool fold(LL& x, LL m, bool dir)\n{\n    bool tmp = x > m / 2;\n    if(tmp)\n    {\n        if(dir)\n        {\n            x = m + 1 - x;\n            return 1;\n        }\n        else\n        {\n            x -= m / 2;\n            return 0;\n        }\n    }\n    else\n    {\n        if(dir)\n        {\n            x = m / 2 + 1 - x;\n            return 0;\n        }\n        else\n            return 1;\n    }\n}\n\nLL pow_int(LL n, LL e)\n{\n    if(e == 1)\n        return n;\n    if(e % 2)\n        return pow_int(n, e - 1) * n;\n    else\n        return pow_int(n * n, e / 2);\n}\n\nint main()\n{\n    LL n, i, j;\n    while(cin >> n >> i >> j && n != 0)\n    {\n        i = pow_int(2, n) + 1 - i;\n        cout << i << endl;\n        vector<bool> unf;\n        LL x = i, y = j;\n        LL m = pow_int(2, n);\n        while(m != 1)\n        {\n            unf.push_back(unfold(x, m));\n            m /= 2;\n        }\n        m = pow_int(2, n);\n        int cnt = unf.size() - 1;\n        while(m != 1)\n        {\n            //cout << unf[cnt] << \" \" << y << \" \" << m << endl;\n            cout << (fold(y, m, unf[cnt]) ? 'R' : 'L');\n            //out << y << endl;;\n            m /= 2;\n            cnt -= 1;\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nll POW[61],height[62];\n\nll N,I,J;\n\nvoid func(){\n\n\tll tmp_h = POW[N]-I+1;\n\n\theight[1] = 1;\n\n\tfor(ll i = N; i >= 1; i--){\n\t\theight[i+1] = tmp_h;\n\t\tif(tmp_h > POW[i]/2){\n\t\t\ttmp_h = POW[i]-tmp_h+1;\n\t\t}\n\t}\n\n\tqueue<char> Q;\n\n\tll width,mid,loc = J;\n\n\tll k,R_height,L_height,thick;\n\n\tfor(ll i = N; i >= 1; i--){\n\n\t\tk = N-i+1;\n\n\t\twidth = POW[i];\n\t\tmid = width/2;\n\n\t\tthick = POW[k-1];\n\t\ttmp_h = height[k];\n\n\t\tif(loc <= mid){\n\n\t\t\tL_height = thick+(thick-tmp_h)+1;\n\n\t\t\tR_height = tmp_h;\n\n\t\t\tif(L_height == height[k+1]){\n\n\t\t\t\tloc = mid-(loc-1);\n\t\t\t\tQ.push('L');\n\n\t\t\t}else{\n\t\t\t\tQ.push('R');\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tL_height = tmp_h;\n\n\t\t\tR_height = thick+(thick-tmp_h)+1;\n\n\t\t\tif(R_height == height[k+1]){\n\n\t\t\t\tloc = width-loc+1;\n\n\t\t\t\tQ.push('R');\n\t\t\t}else{\n\n\t\t\t\tloc -= mid;\n\t\t\t\tQ.push('L');\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(!Q.empty()){\n\t\tprintf(\"%c\",Q.front());\n\t\tQ.pop();\n\t}\n\tprintf(\"\\n\");\n}\n\nint main(){\n\n\tPOW[0] = 1;\n\tfor(int i = 1; i < 61; i++)POW[i] = 2*POW[i-1];\n\n\twhile(true){\n\t\tscanf(\"%lld %lld %lld\",&N,&I,&J);\n\t\tif(N == 0 && I == 0 && J == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tint n;\n\tll from, to;\n\twhile(cin >> n >> from >> to, n){\n\t\tfrom--; to--;\n\t\t\n\t\tvi upper;\n\t\tstring ans;\n\t\trep(i, n) if(from >> (n - i - 1) & 1) upper.pb(0);\n\t\telse{\n\t\t\tupper.pb(1);\n\t\t\tfrom = ~from;\n\t\t}\n\t\treverse(all(upper));\n\t\t//dbg(upper);\n\t\trep(i, n){\n\t\t\tans.pb((to >> n - i - 1 & 1) == upper[i] ? 'R' : 'L');\n\t\t\tif(upper[i]) to = ~to;\n\t\t\tto &= (1ll << (n - i)) - 1;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nll POW[61],height[62];\n\nll N,I,J;\n\nvoid func(){\n\n\tll tmp_h = POW[N]-I+1;\n\n\theight[1] = 1;\n\n\tfor(ll i = N; i >= 1; i--){\n\t\theight[i+1] = tmp_h;\n\t\tif(tmp_h > POW[i]/2){\n\t\t\ttmp_h = POW[i]-tmp_h+1;\n\t\t}\n\t}\n\n\tqueue<char> Q;\n\n\tll width,mid,loc = J;\n\n\tll k,R_height,L_height,thick;\n\n\tfor(ll i = N; i >= 1; i--){\n\n\t\tk = N-i+1;\n\n\t\twidth = POW[i];\n\t\tmid = width/2;\n\n\t\tthick = POW[k-1];\n\t\ttmp_h = height[k];\n\n\t\tif(loc <= mid){\n\n\t\t\tL_height = thick+(thick-tmp_h)+1;\n\n\t\t\tR_height = tmp_h;\n\n\t\t\tif(L_height == height[k+1]){\n\n\t\t\t\tloc = mid-(loc-1);\n\t\t\t\tQ.push('L');\n\n\t\t\t}else{\n\t\t\t\tQ.push('R');\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tL_height = tmp_h;\n\n\t\t\tR_height = thick+(thick-tmp_h)+1;\n\n\t\t\tif(R_height == height[k+1]){\n\n\t\t\t\tloc = width-loc+1;\n\n\t\t\t\tQ.push('R');\n\t\t\t}else{\n\n\t\t\t\tloc -= mid;\n\t\t\t\tQ.push('L');\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(!Q.empty()){\n\t\tprintf(\"%c\",Q.front());\n\t\tQ.pop();\n\t}\n\tprintf(\"%\\n\");\n}\n\nint main(){\n\n\tPOW[0] = 1;\n\tfor(int i = 1; i < 61; i++)POW[i] = 2*POW[i-1];\n\n\twhile(true){\n\t\tscanf(\"%lld %lld %lld\",&N,&I,&J);\n\t\tif(N == 0 && I == 0 && J == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll n,a,b;\n\nll dfs(ll d,ll h){\n  if(d==n)return b;\n  ll H=(1LL<<(n-1-d));\n  ll W=(1LL<<d);\n  if(h<H){\n    ll f=dfs(d+1,H-1-h);\n    printf( f<W ? \"L\" : \"R\" );\n    return W-f%W-1;\n  }else{\n    ll f=dfs(d+1,h-H);\n    printf( f<W ? \"R\" : \"L\" );\n    return f%W;\n  }\n}\n\nint main(){\n  while(1){\n    scanf(\"%lld %lld %lld\",&n,&a,&b);\n    if(n==0&&a==0&&b==0)break;\n    a--;\n    b--;\n    dfs(0,a);\n    printf(\"\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\nll prvNum(ll now, ll n) {\n\tll sum = (1LL << n) -1;\n\tll sum2 = sum / 2;\n\tif(sum2 < now) return now - sum2 - 1;\n\treturn sum2 - now;\n}\nchar lastOpe(ll now, ll idx, ll n) {\n\tll sum = (1LL << n) - 1LL;\n\tll nxt = sum - now, prv = prvNum(now, n);\n\tbool f = now > nxt;\n\treturn (f^(prv&1LL)^(idx&1LL) ? 'L' : 'R');\n}\n\nint main(){\n\tll n, now, idx;\n\twhile(cin >> n >> now >> idx) {\n\t\tif(n == 0 && now == 0 && idx == 0) break;\n\t\tnow--; idx--;\n\t\tstring s;\n\t\twhile(n > 1) {\n\t\t\ts += lastOpe(now, idx, n);\n\t\t\tnow = prvNum(now, n);\n\t\t\tn--;\n\t\t\tidx /= 2;\n\t\t}\n\t\ts += (now^idx ? 'R':'L');\n\t\treverse(all(s));\n\t\tcout << s << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\n#define fs first\n#define sc second\n\nconst LL MOD = 1e9+7;\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>bool chmin(T &a, const T &b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n// std::vector Initialization\ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) { arr = v; }\ntemplate<typename T, typename U>\nvoid fill_all(T& arr, const U& v) { for (auto& i : arr) fill_all(i, v); }\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\ntemplate<typename T>\nusing Edges = vector<edge<T>>;\ntemplate<typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate<typename T>\nusing MatrixGraph = vector<vector<T>>;\n\nint main()\n{\n    while (true) {\n        LL n, i, j;\n        cin >> n >> i >> j;\n        if (n == 0 && i == 0 && j == 0) {\n            break;\n        }\n        --i; --j;\n\n        stack<char> st;\n\n        while (n) {\n            if ((i % 2) == (j % 2)) {\n                st.push('L');\n            } else {\n                st.push('R');\n            }\n            if (i >= (1LL<<(n-1))) {\n                i -= (1LL<<(n-1));\n            } else {\n                i = (1LL<<(n-1))-1 - i;\n            }\n            j /= 2;\n            --n;\n        }\n\n        while (!st.empty()) {\n            printf(\"%c\", st.top());\n            st.pop();\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nconst pair<int, int> END(0, 0);\n\nint move_pos(int pos, int half, char dir) {\n    if(pos < half and dir == 'R') return pos;\n    if(pos >= half and dir == 'L') return pos - half;\n\n    if(pos < half) return half - pos - 1;\n    else return half - 1 - (pos - half);\n}\n\nstring solve(int N, int A, int B) {\n    // 最終状態 (自分の上・下に何枚ある？)\n    pair<int, int> state(A - 1, (1LL << N) - A);\n\n    int sub = (1LL << (N-1));\n    vector<int> ops;\n    while(state != END) {\n        int p, q, r = -1; tie(p, q) = state;\n        if(p - sub >= 0) {\n            ops.push_back(0);\n            r = 0;\n            state = make_pair(p - sub, q);\n        }\n        else if(q - sub >= 0) {\n            ops.push_back(1);\n            r = 1;\n            state = make_pair(q - sub, p);\n        }\n        sub >>= 1;\n    }\n\n    reverse(ops.begin(), ops.end());\n    string res = \"\";\n    int pos = B - 1, half = (1LL << (N-1));\n    for(auto e : ops) {\n        char c = '$';\n        if(pos < half) {\n            if(e == 1) c = 'L';\n            if(e == 0) c = 'R';\n        }\n        else {\n            if(e == 1) c = 'R';\n            if(e == 0) c = 'L';\n        }\n        res += c;\n        pos = move_pos(pos, half, c);\n        half >>= 1;\n    }\n    return res;\n}\n \nsigned main() {\n    int N, A, B;\n    while(cin >> N >> A >> B, N || A || B) {\n        cout << solve(N, A, B) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nint main() {\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  while(1) {\n    ll n, i, j; cin >> n >> j >> i;\n    i--; j--;\n    if(n == 0) break;\n    vector<ll> v(n);\n    ll tmp = 1;\n    for(int i=0;i<n;++i) {\n      v[i] = tmp;\n      tmp *= 2;\n    }\n    reverse(v.begin(), v.end());\n    string ans = \"\";\n    for(ll k=0;k<n;++k) {\n      if(i%2 == j%2) {\n        ans.push_back('L');\n      } else {\n        ans.push_back('R');\n      }\n      i = i / 2;\n      if(j - v[k] >= 0) {\n        j = j - v[k];\n      } else {\n        j = v[k] - j - 1;\n      }\n    }\n    reverse(ans.begin(), ans.end());\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nvoid solve(int n, long i, long j){\n  assert(i<(1L<<n) && j<(1L<<n));\n  if(n==1){\n    if(i!=j) cout << \"R\" << endl;\n    else cout << \"L\" << endl;\n    return;\n  }\n\n  bool bi = i >= (1L<<(n-1));\n  bool bj = j >= (1L<<(n-1));\n\n  bool ans;\n  if(bj) ans = i%4==1 || i%4==2;\n  else ans = i%4==0 || i%4==3;\n\n  if(ans) cout << \"R\";\n  else cout << \"L\";\n\n  i /= 2;\n\n  if(ans){ // R\n    if(bj) j = (1L<<n) - j - 1;\n  }\n  else { // L\n    if(bj) j = j - (1L<<(n-1));\n    else j = (1L<<(n-1)) - j - 1;\n  }\n\n  solve(n-1, i, j);\n}\n\nint main(){\n  long n,i,j;\n  while(cin>>n>>i>>j, n|i|j){\n    solve(n, i-1,j-1);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    while (true) {\n        int n;\n        long long a, b;\n        cin >> n >> a >> b;\n        if (!n) return 0;\n        --a; --b;\n        vector<bool> up(n);\n        for (int i = n - 1; i >= 0; --i) {\n            if (a < (1L << i)) {\n                up[i] = true;\n                a = (1L << i) - a - 1;\n            }\n            else {\n                up[i] = false;\n                a -= 1L << i;\n            }\n        }\n        string ans = \"\";\n        for (int i = 0; i < n; ++i) {\n            if (up[i]) {\n                if (b < (1L << (n - i - 1))) {\n                    ans += 'L';\n                    b = (1L << (n - i - 1)) - b - 1;\n                }\n                else {\n                    ans += 'R';\n                    b = (1L << (n - i)) - b - 1;\n                }\n            }\n            else {\n                if (b < (1L << (n - i - 1)))\n                    ans += 'R';\n                else {\n                    ans += 'L';\n                    b -= (1L << (n - i - 1));\n                }\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n\nusing namespace std;\n\nllint n, x, y;\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n >> x >> y;\n\t\tif(n == 0 && x == 0 && y == 0) break;\n\t\tx--, y--;\n\t\t\n\t\tllint flip = 0;\n\t\tfor(llint i = 0; i < n; i++){\n\t\t\tllint rem = (x / (1LL <<(n-1-i))) & 3;\n\t\t\tif(rem == 1 || rem == 2) flip |= (1LL << i);\n\t\t}\n\t\tflip ^= 1;\n\t\t\n\t\tllint ans = y;\n\t\tfor(llint i = 0; i < n; i++){\n\t\t\tif(flip & (1LL<<i)){\n\t\t\t\tans ^= (1LL<<(i+1)) - 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(llint i = n-1; i >= 0; i--){\n\t\t\tif(ans & (1LL<<i)) cout << \"L\";\n\t\t\telse cout << \"R\";\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repq(i,a,n) for(int i=a; i<=n; i++)\ntypedef long long int ll;\ntypedef pair<int, int> pii;\n\nint main() {\n  long long int N, I, J;\n  while(cin >> N >> I >> J, N){\n    vector<ll> height;\n    --I;\n    --J;\n    ll t = I;\n    for(int i = 0; i < N; ++i){\n      height.push_back(t);\n      t = (1LL<<(N-i-1))-t;\n      if(t > 0) --t;\n      else t = -t;\n    }\n    height.push_back(t);\n    reverse(height.begin(),height.end());\n    //for(int i = 0; i < N+1; ++i)\n    //cout << height[i] << endl;\n    string ans = \"\";\n    for(int i = 0; i < N; ++i){\n      if((height[i+1] == height[i] + (1LL<<(i))) ^ (J >= (1LL<<(N-i-1)))){\n\tans += \"R\";\n\tif(J >= 1LL<<(N-i-1)) \n\t  J = (1LL<<(N-i))-J-1;\n      }else{\n\tans += \"L\";\n\tif(J >= (1LL<<(N-i-1))) J = -(1LL<<(N-i-1))+J;\n\telse J = (1LL<<(N-i-1))-J-1;\n      }\n      //printf(\"J = %lld\\n\", J);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\nconstexpr int INF = numeric_limits<int>::max()/2;\nconstexpr long long LINF = numeric_limits<long long>::max()/3;\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os, const map<T,U>& mp){ os << \"{\"; for(auto& p : mp){ os << p << \",\"; } os << \"}\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const set<T>& st){ os<<\"{\"; for(T v:st) os<<v<<\",\"; os <<\"}\"; return os; }\ntemplate<typename T,typename U> inline void chmax(T &x,U y){ if(y>x) x = y; }\ntemplate<typename T,typename U> inline void chmin(T &x,U y){ if(y<x) x = y; }\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = std::pair<int,int>;\nusing vi = std::vector<int>;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nll n,t,p;\n\nvoid solve(){\n    vector<ll> rnk(n+1); // rnk[i] := i回おった後\n    rnk[n] = t-1;\n    ll th = (1LL << n);\n    for(int i=n-1;i>=0;i--){\n        if(rnk[i+1] <  th/2){\n            rnk[i] = th/2 - 1 - rnk[i+1];\n        }else{\n            rnk[i] = rnk[i+1] - th/2;\n        }\n        th >>= 1;\n    }\n\n    ll pos = p-1;\n    th = 1;\n    ll len = (1LL<<n);\n    string ans = \"\";\n    for(int i=0;i<n;i++){ // rnk[i] -> rnk[i+1]\n        if(pos < len/2){ // left\n            // L : rnk[i] -> th - rnk[i] - 1\n            if(rnk[i+1] == th - rnk[i] - 1 ){\n                ans.push_back('L');\n                pos = (len/2) - pos - 1;\n            }else if(rnk[i+1] == rnk[i] + th){\n                ans.push_back('R');\n            }else{\n                assert(false);\n            }\n        }else{\n            // R : rnk[i] -> th - rnk[i] - 1\n            if(rnk[i+1] == th-rnk[i]-1){\n                ans.push_back('R');\n                pos = len - 1 - pos;\n            }else if(rnk[i+1] == rnk[i] + th){\n                ans.push_back('L');\n                pos -= len / 2;\n            }else{\n                assert(false);\n            }\n        }\n        len >>= 1;\n        th <<= 1;\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    while(cin >> n >> t >> p)\n    {\n        if(!n and !t and !p){\n            break;\n        }\n        solve();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#define FOR(i, a, b) for (int i = a; i < b; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define RFOR(i, a, b) for (int i = b - 1; i >= a; i--)\n#define RREP(i, n) RFOR(i, 0, n)\n#define rep(i, a, b) for (auto i = a; i < b; i++)\n#define rrep(i, a, b) for (auto i = a; i > b; i--)\n#define range(i, a, b) (a <= i && i < b)\n#define int long long\n#define fi first\n#define fs first\n#define se second\n#define sc second\nusing namespace std;\nusing vec = vector<int>;\nusing mat = vector<vec>;\ntypedef pair<int, int> P;\n\nint n, x, y;\n\nvoid solve(){\n\tvec step(n);\n\tint cur = 1;\n\tREP(i, n - 1) cur *= 2;\n\tint mid = cur;\n\tREP(i, n) {\n\t\tif (x <= cur) {\n\t\t\tstep[i] = 1; //ue\n\t\t\tx = cur - x + 1;\n\t\t}\n\t\telse {\n\t\t\tstep[i] = 0; //sita\n\t\t\tx = x - cur;\n\t\t}\n\t\tcur /= 2;\n\t}\n\n\t//REP(i, n) cout << step[i] << endl;\n\t//return;\n\n\treverse(step.begin(), step.end());\n\n\tREP(i, n) {\n\t\tif (y <= mid) {\n\t\t\tif (step[i]) {\n\t\t\t\tcout << 'L';\n\t\t\t\ty = mid - y + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << 'R';\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (step[i]) {\n\t\t\t\tcout << 'R';\n\t\t\t\ty = 2 * mid - y + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << 'L';\n\t\t\t\ty -= mid;\n\t\t\t}\n\t\t}\n\t\tmid /= 2;\n\t}\n\tcout << endl;\n}\n\nsigned main() {\n\twhile (cin >> n >> x >> y, n) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\n#define REP(i, n) FOR(i, 0, n)\n#define FOR(i, a, b) for(int i = (int)a; i < (int)b; ++i)\n#define SORT(v) std::sort(v.begin(), v.end())\n#define ALL(v) v.begin(), v.end()\n#define cosnt const\nusing ll = long long;\nusing std::cin;\nusing std::cout;\nconstexpr char endl = '\\n';\n\nint main(){\n  ll n, i, j;\n  while(cin >> n >> i >> j, n || i || j) {\n    std::string ans;\n    --i; --j;\n    for(int p = n-1; p >= 0; --p) {\n      ans += ((i & 1) == (j & 1)) ? 'L' : 'R';\n      if(1ll << p > i) i = (1ll << (p + 1)) - 1 - i;\n      i -= 1ll << p;\n      j >>= 1;\n    }\n    std::reverse(ALL(ans));\n    std::cout << ans << std::endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing lint = long long;\n\nbool solve() {\n    int n;\n    lint m, k;\n    std::cin >> n >> m >> k;\n    --m, --k;\n\n    if (n == 0) return false;\n\n    std::vector<int> ans(n, 0);\n    for (int i = 0; i < n; ++i) {\n        int j = n - i - 1;\n        if ((m >> j) & 1) {\n            ans[i] = 1 - ((k >> i) & 1);\n            m = m & ((1LL << j) - 1);\n        } else {\n            for (auto& a : ans) a = 1 - a;\n            ans[i] = ((k >> i) & 1);\n            m = ~m & ((1LL << j) - 1);\n        }\n    }\n\n    std::reverse(ans.begin(), ans.end());\n    for (auto x : ans) std::cout << \"LR\"[x];\n    std::cout << std::endl;\n\n    return true;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    while (solve()) {}\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\n#define endl '\\n'\n#define ALL(V) begin(V), end(V)\n#define ALLR(V) rbegin(V), rend(V)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing PLL = std::pair<ll, ll>;\nusing TLL = std::tuple<ll, ll, ll>;\ntemplate <typename T> using V = std::vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return V<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\nusing namespace std;\n\n#ifdef DEBUGGING\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n    \nll N, I, J;\n\nll rec(ll rest, ll aim, V<char> &ans) {\n    if (rest == 0) return J;\n    ll all = (1ll << rest);\n    ll size = (1ll << (N - rest + 1));\n    bool op;\n    ll idx;\n    if (aim < all / 2) {\n        idx = rec(rest - 1, (1ll << (rest - 1)) - 1 - aim, ans);\n        op = (idx < size / 2);\n    } else {\n        idx = rec(rest - 1, aim ^ (1ll << (rest - 1)), ans);\n        op = !(idx < size / 2);\n    }\n    bool left = idx < size / 2;\n    ans.push_back(op ? 'L' : 'R');\n    if (left) {\n        if (op) return (size / 2 - 1) - idx;\n        else return idx;\n    } else {\n        idx -= size / 2;\n        if (op) return idx;\n        else return (size / 2 - 1) - idx;\n    }\n}\n\nbool solve() {\n    cin >> N >> I >> J;\n    if (!(N + I + J)) return false;\n    I--; J--;\n    V<char> ans;\n    rec(N, I, ans);\n    for (char c : ans) cout << c;\n    cout << endl;\n    return true;\n}\n\nint main() {\n    while (solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll pow2[100];\nll x[200];\nll n,idx,looknum;\nll i;\n\nvoid pow_init(){\n\n\tpow2[0] = 1;\n\tfor(int i=1;i<=60;i++){\n\t\tpow2[i] = pow2[i - 1] * 2;\n\t}\n\t\n\treturn;\n}\n\nll allL(ll n,ll looknum){\n\n\tll mannaka = pow2[n-1];\n\tll pos = looknum;\n\tll up = 0,down = 0;\n\twhile(1){\n\t\tif(mannaka == 0)break;\n\t\tif(pos <= mannaka){\n\t\t\tll tmp = down;\n\t\t\tdown = (up + down + 1) + up;\n\t\t\tup = tmp;\n\t\t\tpos = mannaka + 1 - pos;\n\t\t}else{\n\t\t\tup += (up + down + 1);\n\t\t\tpos -= mannaka;\n\t\t}\n\t\tif(mannaka == 1)break;\n\t\tmannaka /= 2;\n\n\t}\n\treturn up + 1;\n}\n\nvoid encode(ll n,ll idx_simple,ll idx_aim){\n\tll mannaka = pow2[n-1];\n\tll cnt = 0;\n\twhile(1){\n\n\t\tif(idx_simple <= mannaka && idx_aim <= mannaka){\n\t\t\t//cout << 0 << endl;\n\t\t}else if(idx_simple > mannaka && idx_aim > mannaka){\n\t\t\t//cout << 0 << endl;\n\t\t\tidx_simple -= mannaka;\n\t\t\tidx_aim -= mannaka;\n\t\t}else{\n\t\t\tx[cnt] = 1;\n\t\t\t//cout << 1 << endl;\n\t\t\tidx_simple = mannaka * 2 + 1 - idx_simple;\n\t\t\tif(idx_simple > mannaka){\n\t\t\t\tidx_simple -= mannaka;\n\t\t\t\tidx_aim -= mannaka;\n\t\t\t}\n\t\t}\n\t\tif(mannaka == 1)break;\n\t\tmannaka /= 2;\n\t\tcnt++;\n\t}\n\treturn ;\n}\n\nvoid decode(ll n){\n\tll tmp = 0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tif((x[i] + tmp) % 2 == 1){\n\t\t\tcout << \"R\";\n\t\t}else{\n\t\t\tcout << \"L\";\n\t\t}\n\t\tif(x[i])tmp++;\n\t}\n\tcout << endl;\n\treturn ;\n\n}\n\nbool solve(){\n\tcin >> n >> idx >> looknum;\n\tif(n == 0 && looknum == 0){\n\t\treturn false;\n\t}\n\tfor(i=0;i<=2*n + 10;i++){\n\t\tx[i] = 0;\n\t}\n\tll idx_simple = allL(n,looknum);\n\t//cout << idx_simple << endl;\n\tencode(n,idx_simple,idx);\n\tdecode(n);\n\treturn true;\n}\n\n\nint main(){\n\tpow_init();\n\twhile(solve()){};\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60)+1e9; // ~ 1.15 * 1e18\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\n\nvector<Int> getNum(Int n, Int b){\n  vector<Int> res;\n  Int x = 1LL<<(n - 1);\n  Int num = (b - 1) - ((1LL<<n) - b);\n  while(x){\n    if(abs(num + x) < abs(num - x)) num += x, res.push_back(-x);\n    else num -= x, res.push_back(x);\n    x /= 2;\n  }\n  reverse(res.begin(), res.end());\n  return res;\n}\n\nstring rev(string s){\n  for(char &ch:s) ch = ch == 'L'? 'R':'L';\n  return s;\n}\n\nstring solve(Int n,Int a, Int b){\n  a = (1LL<<n) - a + 1;\n  Int height = (1LL<<n);\n  string res;\n  auto dir = getNum(n, b);\n  for(Int x:dir){\n    Int openL = -1;\n    if(height / 2 >= a){ //lower\n      if(x > 0) openL = 1;\n      if(x < 0) openL = 0;\n    }\n    else{                //upper\n      if(x > 0) openL = 0, a = height - a + 1, res = rev(res);\n      if(x < 0) openL = 1, a = height - a + 1, res = rev(res);\n    }\n    assert(x != 0);\n    res += openL? 'L':'R';\n    height /= 2;\n  }\n  reverse(res.begin(), res.end());\n  return res;\n}\n\nsigned main(){\n  srand((unsigned)time(NULL));\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(1){\n    Int n, a, b;\n    cin>>n>>a>>b;\n    if(n == 0 && a == 0 && b == 0) return 0;\n    string ans = solve(n, a, b);\n    cout<<ans<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "59 471605241352156968 431565444592236940\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <numeric>\n#include <bitset>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long ll;\n#define FOR(i,a,b)   for(ll i = (a); i < (b); i++ )\n#define REP(i, n)    FOR(i,0,n)\ntypedef pair< ll, ll >   cp2;\ntypedef pair< ll, cp2 >   cp3;\n#define fi first\n#define se second\n#define sec  se.fi\n#define thr  se.se\nconst ll mod = 1000000007;\n//              123456789\n\n \n///////////////////////////////////////////////\n//\n//\n///////////////////////////////////////////////\n\n////////////////////////////////////////////////\n////////////////////////////////////////////////\n\nll N, X, Y;\nll S;\nbool f[100];\nstring ans;\n\nint main(){\n\t\n\twhile( 1 ){\n\t\tcin>>N>>Y>>X;\n\t\tif( !( X | Y | N ) ) break;\n\t\tans = \"\";\n\t\tll i = N;\n\t\tS = 1ll<<N;\n\t\twhile( i-- ){\n\t\t\t//cout<<\"-\"<<Y<<endl;\n\t\t\tif( Y <= S/2 ){\n\t\t\t\tf[i] = true;\n\t\t\t\tY = S/2-Y+1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tf[i] = false;\n\t\t\t\tY = Y - S/2;\n\t\t\t}\n\t\t\tS>>=1;\n\t\t}\n\t\tS = 1ll<<N;\n\t\n\t\tREP( i, N ){\n\t\t\t//cout<<\"*\"<<X<<endl;\n\t\t\tif( X <= S/2 ){//左半分にあったら\n\t\t\t\tif( f[i] ){\n\t\t\t\t\tans += \"L\";\n\t\t\t\t\tX = S/2 - X + 1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\tans += \"R\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{//右半分にあったら\n\t\t\t\tif( f[i] ){\n\t\t\t\t\tans += \"R\";\n\t\t\t\t\tX = S - X + 1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tans += \"L\";\n\t\t\t\t\tX = X - S/2;\n\t\t\t\t}\n\t\t\t}\n\t\tS>>=1;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\t\t\t\n\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nint n;\nlong mark_fold;\nlong mark_open;\n\nbool input() {\n\tstd::cin >> n;\n\tstd::cin >> mark_fold;\n\tstd::cin >> mark_open;\n\tif (n | mark_fold | mark_open) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid solve_print() {\n\tbool ud_list[n]; //true : 上, false : 下\n\tlong pow2 = 1l << (n-1);\n\n\t//各段階での印が半分より上か下かを求める\n\tfor (int i = n-1; 0 <= i; i--) {\n\t\tif ((ud_list[i] = (mark_fold <= pow2))) {\n\t\t\tmark_fold = pow2 - mark_fold + 1;\n\t\t\t//std::cout << \"true \";\n\t\t} else {\n\t\t\t//std::cout << \"false \";\n\t\t}\n\n\t\tpow2 = pow2 >> 1;\n\t}\n\n\t//上下の情報を元に折り方を復元\n\tpow2 = 1l << (n-1);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (ud_list[i]) {\n\t\t\tif (mark_open <= pow2) {\n\t\t\t\tstd::cout << \"L\";\n\t\t\t\tmark_open = pow2 - mark_open + 1;\n\t\t\t} else {\n\t\t\t\tstd::cout << \"R\";\n\t\t\t\tmark_open = pow2*2 - mark_open + 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (mark_open <= pow2) {\n\t\t\t\tstd::cout << \"R\";\n\n\t\t\t} else {\n\t\t\t\tstd::cout << \"L\";\n\t\t\t\tmark_open = mark_open - pow2;\n\t\t\t}\n\t\t}\n\n\t\tpow2 = pow2 >> 1;\n\t}\n\tstd::cout << std::endl;\n}\n\nint main(int argc, char const *argv[])\n{\n\t/* code */\n\n\twhile (input()) {\n\tsolve_print();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n long long n,a,b;\n char s[100];\n while(scanf(\"%lld %lld %lld\",&n,&a,&b),n){\n  a--;\n  b--;\n  s[n]=0;\n  while(n--){\n   s[n]=(a%2==b%2)?'L':'R';\n   a=(a<(1LL<<n))?(1LL<<n)-a-1:a-(1LL<<n);\n   b/=2;\n  }\n  printf(\"%s\\n\",s);\n }\n return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n long long n,a,b;\n char s[100];\n while(scanf(\"%lld %lld %lld\",&n,&a,&b),n){\n a--;\n b--;\n s[n]=0;\n while(n--){\n  s[n]=(a%2==b%2)?'L':'R';\n  a=(a<(1<<n))?(1<<n)-a-1:a-(1<<n);\n  b/=2;\n }\n printf(\"%s\\n\",s);\n }\n return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1621: Folding a Ribbon\n// 2017.12.30 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nchar ans[62];\nchar low[62];\n\nint main()\n{\n\tint n, k;\n\tlong long i, j;\n\n\twhile (scanf(\"%d%lld%lld\", &n, &i, &j) && n > 0) {\n\t\ti--, j--;\n\t\tfor (k = 1; k <= n; k++) {\n\t\t\tlow[n-k] = (i >> (n-k)) & 1;\n\t\t\tif (!low[n-k]) i = ~i;\n\t\t}\n\t\tfor (k = 1; k <= n; k++) {\n\t\t\tans[k] = (((j >> (n-k)) & 1) == low[k-1])? 'L': 'R';\n\t\t\tif (!low[k-1]) j = ~j;\n\t\t}\n\t\tans[n+1] = 0;\n\t\tputs(ans+1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n\tstatic long y=1;\n\tstatic long l=1;\n\tstatic Scanner cs=new Scanner(System.in);\n\tpublic static void main(String args[]){\n\t\twhile(true){\n\t\t\tint n=cs.nextInt();\n\t\t\tif (n==0)break;\n\t\t\tlong x=cs.nextLong();\n\t\t\ty=cs.nextLong();\n\t\t\tl=1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tl=l*2;\n\t\t\t}\n\t\t\tx=l-x+1;\n\t\t\tSystem.out.println(solve(l,x));\n\t\t\t}\n\t}\n\tstatic String solve(long h,long x){\n\t\tString res=\"\";\n\t\tif (h==1)return(\"\");\n\t\tif (x<=h/2) {\n\t\t\tres=solve(h/2,x);\n\t\t\tif (y<=l/2){\n\t\t\t\tres=res+\"R\";\n\t\t\t\tl=l/2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres=res+\"L\";\n\t\t\t\ty=y-l/2;\n\t\t\t\tl=l/2;\n\t\t\t}\n\t\t}else{\n\t\t\tres=solve(h/2,h-x+1);\n\t\t\tif (y<=l/2){\n\t\t\t\tres=res+\"L\";\n\t\t\t\ty=l/2-y+1;\n\t\t\t\tl=l/2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres=res+\"R\";\n\t\t\t\ty=l-y+1;\n\t\t\t\tl=l/2;\n\t\t\t}\n\t\t}\n\t\treturn(res);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main{\n    public static void main(String[] args){\n        PrintWriter out=new PrintWriter(System.out);\n        Scanner ir=new Scanner(System.in);\n        for(;;){\n            int n=ir.nextInt();\n            long m=ir.nextLong();\n            long k=ir.nextLong();\n            if(n==0&&m==0&&k==0){\n                break;\n            }\n            long[] pos=new long[n+1];\n            pos[n]=m;\n            for(int i=n-1;i>=0;i--){\n                if(pos[i+1]<=1L<<i){\n                    pos[i]=(1L<<i)+1-pos[i+1];\n                }\n                else{\n                    pos[i]=pos[i+1]-(1L<<i);\n                }\n            }\n            StringBuilder sb=new StringBuilder();\n            long cur=k;\n            for(int i=0;i<n;i++){\n                if(cur<=1L<<(n-i-1)){\n                    if(pos[i+1]<=1L<<i){\n                        cur=calcleft(cur, i+1, n);\n                        sb.append(\"L\");\n                    }\n                    else{\n                        cur=calcright(cur, i+1, n);\n                        sb.append(\"R\");\n                    }\n                }\n                else{\n                    if(pos[i+1]<=1L<<i){\n                        cur=calcright(cur, i+1, n);\n                        sb.append(\"R\");\n                    }\n                    else{\n                        cur=calcleft(cur, i+1, n);\n                        sb.append(\"L\");\n                    }\n                }\n                //out.println(cur+\" \"+i+\" \"+pos[i]);\n            }\n            out.println(sb);\n        }\n        out.flush();\n    }\n\n    static long calcleft(long cur, int t,int n){\n        if(cur>1L<<(n-t)){\n            return cur-(1L<<(n-t));\n        }\n        return (1L<<(n-t))+1-cur;\n    }\n\n    static long calcright(long cur, int t,int n){\n        if(cur<=1L<<(n-t)){\n            return cur;\n        }\n        return (1L<<(n-t+1))-cur+1;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Threading;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Diagnostics;\nusing static util;\nusing P = pair<int, int>;\n\nclass Program {\n    static void Main(string[] args) {\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        var solver = new Solver(sw);\n        // var t = new Thread(solver.solve, 1 << 28); // 256 MB\n        // t.Start();\n        // t.Join();\n        solver.solve();\n        sw.Flush();\n    }\n}\n\nclass Solver {\n    StreamWriter sw;\n    Scan sc;\n    void Prt(string a) => sw.WriteLine(a);\n    void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    void Prt(params object[] a) => Prt(string.Join(\" \", a));\n    public Solver(StreamWriter sw) {\n        this.sw = sw;\n        this.sc = new Scan();\n    }\n\n    public void solve() {\n        while (true) {\n            int n;\n            long h, w;\n            sc.Multi(out n, out h, out w);\n            if (n == 0) return;\n            h = (1L << n) - h;\n            --w;\n            var a = new long[n];\n            for (int i = n - 1; i >= 0 ; i--)\n            {\n                a[i] = h;\n                if (h >= 1L << i) {\n                    h = (1L << (i + 1)) - h - 1;\n                }\n            }\n            Assert(h == 0);\n            // DBG(a);\n            var ans = new char[n];\n            for (int i = 0; i < n; i++)\n            {\n                if (a[i] == h) {\n                    if (w < (1L << (n - i - 1))) {\n                        ans[i] = 'R';\n                    }\n                    else {\n                        ans[i] = 'L';\n                        w = w - (1L << (n - i - 1));\n                    }\n                }\n                else {\n                    if (w < (1L << (n - i - 1))) {\n                        ans[i] = 'L';\n                        w = (1L << (n - i - 1)) - w - 1;\n                    }\n                    else {\n                        ans[i] = 'R';\n                        w = (1L << (n - i)) - w - 1;\n                    }\n                    h = (1L << (i + 1)) - h - 1;\n                }\n            }\n            Prt(new string(ans));\n        }\n\n    }\n}\n\nclass pair<T, U> : IComparable<pair<T, U>> {\n    public T v1;\n    public U v2;\n    public pair() : this(default(T), default(U)) {}\n    public pair(T v1, U v2) { this.v1 = v1; this.v2 = v2; }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) { a = v1; b = v2; }\n}\nstatic class util {\n    public static readonly int M = 1000000007;\n    // public static readonly int M = 998244353;\n    public static readonly long LM = 1L << 60;\n    public static readonly double eps = 1e-11;\n    public static void DBG(string a) => Console.Error.WriteLine(a);\n    public static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    public static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    public static void Assert(params bool[] conds) {\n        if (conds.Any(x => !x)) throw new Exception();\n    }\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static int CompareList<T>(IList<T> a, IList<T> b) where T : IComparable<T> {\n        for (int i = 0; i < a.Count && i < b.Count; i++)\n            if (a[i].CompareTo(b[i]) != 0) return a[i].CompareTo(b[i]);\n        return a.Count.CompareTo(b.Count);\n    }\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    public static readonly int[] dd = { 0, 1, 0, -1 };\n    // static readonly string dstring = \"RDLU\";\n    public static IEnumerable<P> adjacents(int i, int j)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1]));\n    public static IEnumerable<P> adjacents(int i, int j, int h, int w)\n        => adjacents(i, j).Where(p => inside(p.v1, p.v2, h, w));\n    public static IEnumerable<P> adjacents(this P p) => adjacents(p.v1, p.v2);\n    public static IEnumerable<P> adjacents(this P p, int h, int w) => adjacents(p.v1, p.v2, h, w);\n    public static IEnumerable<int> all_subset(this int p) {\n        for (int i = 0; ; i = i - p & p) {\n            yield return i;\n            if (i == p) break;\n        }\n    }\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.SelectMany(x => x));\n    public static T[] inv<T>(this Dictionary<T, int> dic) {\n        var res = new T[dic.Count];\n        foreach (var item in dic) res[item.Value] = item.Key;\n        return res;\n    }\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\n\nclass Scan {\n    StreamReader sr;\n    public Scan() { sr = new StreamReader(Console.OpenStandardInput()); }\n    public Scan(string path) { sr = new StreamReader(path); }\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => sr.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P => Pair<int, int>();\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]);\n    }\n    public void Multi<T, U, V>(out T a, out U b, out V c) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]);\n    }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]);\n    }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]);\n    }\n}\n\n"
  },
  {
    "language": "Python",
    "code": "while 1:\n    n, i, j = map(int, input().split())\n    if n+i+j == 0:\n        break\n    i = 2**n - i\n    up = [0]*n\n    for k in range(n):\n        if 2**(n-1-k) <= i:\n            up[k] = 1\n            i = 2**(n-k)-1 - i\n    up.reverse()\n    ans = \"\"\n    j -= 1\n    for k in range(n):\n        if up[k]:\n            if j < 2**(n-1-k):\n                j = 2**(n-1-k)-1 - j\n                ans += \"L\"\n            else:\n                j = 2**(n-k)-1 - j\n                ans += \"R\"\n        else:\n            if j < 2**(n-1-k):\n                ans += \"R\"\n            else:\n                j -= 2**(n-1-k)\n                ans += \"L\"\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as ite\nimport sys\nimport math\n\nsys.setrecursionlimit(1000000)\n\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nwhile True:\n    n, y, x = map(int, raw_input().split())\n    if n == 0:\n        break\n    ys = [y]\n    for i in range(1, n)[::-1]:\n        if y <= 2 ** i:\n            y = 2 ** i - y + 1\n        else:\n            y -= 2 ** i\n        ys = [y] + ys\n    ans = \"\"\n    y = 1\n    for i in range(n):\n        sz = 2 ** (n - i)\n        c = \"R\" if (x > sz / 2) ^ (y + 2 ** i == ys[i]) else \"L\"\n        if c == \"L\" and x <= sz / 2:\n            x = sz / 2 - x + 1\n        elif c == \"L\":\n            x -= sz / 2\n        elif c == \"R\" and x > sz / 2:\n            x = sz - x + 1\n        ans += c\n        y = ys[i]\n    print ans\n"
  },
  {
    "language": "Python",
    "code": "while 1:\n    n, i, j = map(int, input().split())\n    if n+i+j == 0:\n        break\n    i = 2**n - i\n    up = [0]*n\n    for k in range(n):\n        if 2**(n-1-k) <= i:\n            up[k] = 1\n            i = 2**(n-k)-1 - i\n    up.reverse()\n    ans = \"\"\n    j -= 1\n    for k in range(n):\n        if up[k]==0 and j < 2**(n-1-k):\n            j = j\n            ans += \"R\"\n        elif up[k] == 0 and 2**(n-1-k) <= j:\n            j = j - 2**(n-1-k)\n            ans += \"L\"\n        elif up[k] == 1 and j < 2**(n-1-k):\n            j = 2**(n-1-k)-1 - j\n            ans += \"L\"\n        elif up[k] == 1 and 2**(n-1-k) <= j:\n            j = 2**(n-k)-1 - j\n            ans += \"R\"\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "while 1:\n    s = input()\n    n, i, j = map(int, s.split())\n\n    if n==0:\n        break\n\n    updown = [None for _ in range(n+1)];\n\n    whole = 2**n\n    fold = n\n    from_top = i\n    while 1:\n        if whole == 1:\n            assert fold == 0\n            break\n\n        half = whole // 2\n        if from_top <= half:\n            updown[fold] = 0\n        else:\n            updown[fold] = 1\n        \n        fold -= 1\n        whole = half\n\n        if half >= from_top:\n            from_top = half - from_top + 1\n        else:\n            from_top = from_top - half\n\n    whole = 2**n\n    from_left = j\n    output = \"\"\n    for i in range(1, n+1):\n        half = whole // 2\n\n        if from_left <= half:\n            is_right = 0\n        else:\n            is_right = 1\n\n        if (updown[i] + is_right) % 2 == 0:\n            output += \"L\"\n            if half >= from_left:\n                from_left = half - from_left + 1\n            else:\n                from_left = from_left - half\n        else:\n            output += \"R\"\n            if half < from_left:\n                from_left = whole - from_left + 1\n\n        whole = half\n\n    print(output)\n\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\ndef rdp_trace(n: int, i: int) -> list:\n    def loop(n: int, i: int) -> list:\n        if n == 1:\n            return []\n        if i <= n // 2:\n            rval = loop(n // 2, (n // 2) - i + 1)\n            rval.append(i)\n            return rval\n        else:\n            rval = loop(n // 2, i - (n // 2))\n            rval.append(i)\n            return rval\n    return loop(2 ** n, i)\n\ndef rdp_connect() -> bool:\n    global n, i, j\n    n, i, j = map(int, input().split())\n    if n == i == j == 0:\n        return False\n    return True\n\nif __name__ == '__main__':\n    while rdp_connect():\n        rval = []\n        for k, lv in zip(range(n), rdp_trace(n, i)):\n            if (lv <= (2 ** (k + 1)) // 2):\n                if (j <= (2 ** (n - k)) // 2):\n                    rval.append('L')\n                    j = (2 ** (n - k)) // 2 - j + 1\n                else:\n                    rval.append('R')\n                    j = (2 ** (n - k)) - j + 1\n            else:\n                if (j <= (2 ** (n - k)) // 2):\n                    rval.append('R')\n                else:\n                    rval.append('L')\n                    j = j - (2 ** (n - k)) // 2\n        print(''.join(rval))"
  },
  {
    "language": "Python",
    "code": "# AOJ 1621: Folding a Ribbon\n# Python3 2018.7.13 bal4u\n\nans, low = [0]*62, [0]*62\nwhile True:\n\tn, i, j = map(int, input().split())\n\tif n == 0: break\n\ti -= 1; j -= 1\n\tfor k in range(1, n+1):\n\t\tlow[n-k] = (i >> (n-k)) & 1\n\t\tif low[n-k] == 0: i = ~i\n\tfor k in range(1, n+1):\n\t\tans[k] = 'L' if ((j >> (n-k)) & 1) == low[k-1] else 'R'\n\t\tif low[k-1] == 0: j = ~j\n\tprint(''.join(ans[1:n+1]))\n\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    N,I,J = map(int,input().split())\n    if N == 0:\n        break\n    L = [I]*N\n    for i in range(N-2,-1,-1):\n        if L[i+1]<=2**(i+1):\n            L[i] = 2**(i+1) - L[i+1] + 1\n        else:\n            L[i] = L[i+1] - 2**(i+1)\n    ans = \"\"\n    for i in range(N):\n        if L[i] > 2**i:\n            if J <= 2**(N-i-1):\n                ans = ans+\"R\"\n            else:\n                ans = ans+\"L\"\n                J -= 2**(N-i-1)\n        else:\n            if J <= 2**(N-i-1):\n                J = 2**(N-1-i)-J+1\n                ans = ans + \"L\"\n            else:\n                J -= 2**(N-i-1)\n                J = 2**(N-1-i)-J+1\n                ans = ans + \"R\"\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "while 1:\n    n,a,b=map(int,input().split())\n    if n==0:\n        break\n    h_pos=[a]\n    all=2**n\n    for i in range(n):\n        if 1<=h_pos[-1]<=all//4:\n            h_pos.append(all//4+all//4-h_pos[-1]+1)\n        elif all//4+1<=h_pos[-1]<=all//2:\n            h_pos.append(all//2-h_pos[-1]+1)\n        elif all//2+1<=h_pos[-1]<=3*all//4:\n            h_pos.append(h_pos[-1]-all//2)\n        else:\n            h_pos.append(h_pos[-1]-3*all//4+all//4)\n        all//=2\n    h_pos=h_pos[::-1]\n    all=2**n\n    s=''\n    for i in range(n):\n        if 1<=b<=all//2:\n            if h_pos[i+1]<=2**(i+1)//2:\n                b=all//2-b+1\n                s+='L'\n            else:\n                s+='R'\n        else:\n            if h_pos[i+1]<=2**(i+1)//2:\n                b=all-b+1\n                s+='R'\n            else:\n                b=b-all//2\n                s+='L'\n        all//=2\n    print(s)\n"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::fmt;\nuse std::cmp::{Ordering, min, max};\nuse std::fmt::{Display, Error, Formatter, Binary, Pointer};\nuse std::f32::MAX;\nuse std::ops::{Add, Sub, Mul, Div, Neg, Index, IndexMut};\nuse std::collections::{BTreeMap, VecDeque, BinaryHeap, BTreeSet};\n\nfn show<T: Display>(vec: &Vec<T>) {\n    if vec.is_empty() {\n        println!(\"[]\");\n    }else {\n        print!(\"[{}\", vec[0]);\n        for i in 1 .. vec.len() {\n            print!(\", {}\", vec[i]);\n        }\n        println!(\"]\");\n    }\n}\nfn show2<T: Display>(vec: &Vec<Vec<T>>) {\n    if vec.is_empty() {\n        println!(\"[]\");\n    }else {\n        for l in vec {\n            show(l);\n        }\n    }\n}\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\nmacro_rules! read_value{\n    () => {\n        read_line!().trim().parse().ok().unwrap()\n    }\n}\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\nmacro_rules! let_mut_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let mut $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\n\nfn main() {\n    loop {\n        let_all!(n: usize, i: i64, j: i64);\n        if n == 0 {\n            return\n        }\n        println!(\"{}\", f(n, i, j));\n    }\n}\nfn f(n: usize, i: i64, j: i64) -> String{\n    let mut d = 1_i64 << n as i64;\n    let mut u = d - i;\n    let mut res = Vec::with_capacity(n);\n    for _ in 0 .. n {\n        d >>= 1;\n        if d <= u {\n            res.push(true);\n            u = d * 2 - u - 1;\n        }else {\n            res.push(false);\n        }\n    }\n    let mut result = Vec::with_capacity(n);\n    let mut j = j - 1;\n    let mut length = 1_i64 << n as i64;\n    res.reverse();\n    for r in res {\n        length >>= 1;\n        if r {\n            if length <= j {\n                j = length * 2 - j - 1;\n                result.push('R');\n            }else {\n                j = length - j - 1;\n                result.push('L');\n            }\n        }else {\n            if length <= j {\n                j -= length;\n                result.push('L');\n            }else {\n                result.push('R');\n            }\n        }\n    }\n    result.iter().collect()\n}\n"
  }
]