[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LEN 20\n#define MAX_NAMES 1000\n\nint min(int a, int b, int c) {\n    if (a < b && a < c) return a;\n    if (b < c) return b;\n    return c;\n}\n\nint levenshtein_distance(const char *s1, const char *s2) {\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    int dp[MAX_LEN + 1][MAX_LEN + 1];\n\n    for (int i = 0; i <= len1; i++) {\n        for (int j = 0; j <= len2; j++) {\n            if (i == 0) {\n                dp[i][j] = j;\n            } else if (j == 0) {\n                dp[i][j] = i;\n            } else if (s1[i - 1] == s2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);\n            }\n        }\n    }\n    return dp[len1][len2];\n}\n\nint adjacent_swap_distance(const char *s1, const char *s2) {\n    int len = strlen(s1);\n    if (len != strlen(s2)) return MAX_LEN + 1;\n\n    char temp[MAX_LEN + 1];\n    strcpy(temp, s1);\n    for (int i = 0; i < len - 1; i++) {\n        char t = temp[i];\n        temp[i] = temp[i + 1];\n        temp[i + 1] = t;\n        if (strcmp(temp, s2) == 0) {\n            return 1;\n        }\n        strcpy(temp, s1);\n    }\n    return MAX_LEN + 1;\n}\n\nint calculate_distance(const char *s1, const char *s2) {\n    int dist = levenshtein_distance(s1, s2);\n    int swap_dist = adjacent_swap_distance(s1, s2);\n    return (swap_dist < dist) ? swap_dist : dist;\n}\n\nint compare_strings(const void *a, const void *b) {\n    return strcmp(*(const char **)a, *(const char **)b);\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    for (int t = 0; t < T; t++) {\n        int N, K;\n        scanf(\"%d %d\", &N, &K);\n\n        char names[MAX_NAMES][MAX_LEN + 1];\n        for (int i = 0; i < N; i++) {\n            scanf(\"%s\", names[i]);\n        }\n\n        qsort(names, N, sizeof(names[0]), compare_strings);\n\n        int count = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                int dist = calculate_distance(names[i], names[j]);\n                if (dist <= K) {\n                    count++;\n                }\n            }\n        }\n\n        printf(\"%d\\n\", count);\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                int dist = calculate_distance(names[i], names[j]);\n                if (dist <= K) {\n                    printf(\"%s %s %d\\n\", names[i], names[j], dist);\n                }\n            }\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:16:32"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ConfusingLoginNames {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int datasets = scanner.nextInt();\n\n        for (int d = 0; d < datasets; d++) {\n            int n = scanner.nextInt();\n            int threshold = scanner.nextInt();\n            String[] names = new String[n];\n\n            for (int i = 0; i < n; i++) {\n                names[i] = scanner.next();\n            }\n\n            List<String> confusingPairs = findConfusingPairs(names, threshold);\n            System.out.println(confusingPairs.size());\n            for (String pair : confusingPairs) {\n                System.out.println(pair);\n            }\n        }\n        scanner.close();\n    }\n\n    static List<String> findConfusingPairs(String[] names, int threshold) {\n        List<String> pairs = new ArrayList<>();\n        Arrays.sort(names);\n\n        for (int i = 0; i < names.length; i++) {\n            for (int j = i + 1; j < names.length; j++) {\n                if (calculateDistance(names[i], names[j]) <= threshold) {\n                    pairs.add(names[i] + \" \" + names[j]);\n                }\n            }\n        }\n\n        Collections.sort(pairs);\n        return pairs;\n    }\n\n    static int calculateDistance(String s1, String s2) {\n        int[][] dp = new int[s1.length() + 1][s2.length() + 1];\n\n        for (int i = 0; i <= s1.length(); i++) {\n            dp[i][0] = i;\n        }\n        for (int j = 0; j <= s2.length(); j++) {\n            dp[0][j] = j;\n        }\n\n        for (int i = 1; i <= s1.length(); i++) {\n            for (int j = 1; j <= s2.length(); j++) {\n                int cost = (s1.charAt(i - 1) == s2.charAt(j - 1)) ? 0 : 1;\n\n                dp[i][j] = Math.min(\n                    dp[i - 1][j] + 1,        // deletion\n                    Math.min(\n                        dp[i][j - 1] + 1,    // insertion\n                        dp[i - 1][j - 1] + cost  // replacement\n                    )\n                );\n\n                // Swapping adjacent characters\n                if (i > 1 && j > 1 && \n                    s1.charAt(i - 1) == s2.charAt(j - 2) && \n                    s1.charAt(i - 2) == s2.charAt(j - 1)) {\n                    dp[i][j] = Math.min(dp[i][j], dp[i - 2][j - 2] + 1);\n                }\n            }\n        }\n\n        return dp[s1.length()][s2.length()];\n    }\n}",
    "timestamp": "2025-08-05 19:16:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nint calculateDistance(const string &a, const string &b) {\n    int m = a.size(), n = b.size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n\n    for (int i = 0; i <= m; ++i) dp[i][0] = i;\n    for (int j = 0; j <= n; ++j) dp[0][j] = j;\n\n    for (int i = 1; i <= m; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            if (a[i - 1] == b[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = 1 + min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]});\n            }\n            if (i > 1 && j > 1 && a[i - 1] == b[j - 2] && a[i - 2] == b[j - 1]) {\n                dp[i][j] = min(dp[i][j], 1 + dp[i - 2][j - 2]);\n            }\n        }\n    }\n    return dp[m][n];\n}\n\nvoid solve() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        vector<string> names(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> names[i];\n        }\n        sort(names.begin(), names.end());\n\n        vector<pair<string, string>> pairs;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                int dist = calculateDistance(names[i], names[j]);\n                if (dist <= k) {\n                    pairs.emplace_back(names[i], names[j]);\n                }\n            }\n        }\n\n        cout << pairs.size() << endl;\n        for (const auto &p : pairs) {\n            cout << p.first << \" \" << p.second << endl;\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    solve();\n    return 0;\n}",
    "timestamp": "2025-08-05 19:17:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_NAMES 1000\n#define MAX_NAME_LENGTH 50\n\nint min(int a, int b, int c, int d) {\n    int m = a;\n    if (b < m) m = b;\n    if (c < m) m = c;\n    if (d < m) m = d;\n    return m;\n}\n\nint calculate_distance(char* s1, char* s2) {\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    int dp[MAX_NAME_LENGTH + 1][MAX_NAME_LENGTH + 1];\n\n    for (int i = 0; i <= len1; i++) dp[i][0] = i;\n    for (int j = 0; j <= len2; j++) dp[0][j] = j;\n\n    for (int i = 1; i <= len1; i++) {\n        for (int j = 1; j <= len2; j++) {\n            int replace_cost = (s1[i-1] != s2[j-1]);\n            \n            int swap_cost = INT_MAX;\n            if (i > 1 && j > 1 && s1[i-1] == s2[j-2] && s1[i-2] == s2[j-1]) {\n                swap_cost = dp[i-2][j-2] + 1;\n            }\n\n            dp[i][j] = min(\n                dp[i-1][j] + 1,    // deletion\n                dp[i][j-1] + 1,    // insertion\n                dp[i-1][j-1] + replace_cost,  // replacement\n                swap_cost\n            );\n        }\n    }\n\n    return dp[len1][len2];\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    for (int t = 1; t <= T; t++) {\n        int N, K;\n        scanf(\"%d %d\", &N, &K);\n\n        char names[MAX_NAMES][MAX_NAME_LENGTH];\n        for (int i = 0; i < N; i++) {\n            scanf(\"%s\", names[i]);\n        }\n\n        printf(\"Case %d:\\n\", t);\n\n        int total_confusing_pairs = 0;\n        char confusing_pairs[MAX_NAMES * MAX_NAMES][2][MAX_NAME_LENGTH];\n\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                int distance = calculate_distance(names[i], names[j]);\n                if (distance <= K) {\n                    strcpy(confusing_pairs[total_confusing_pairs][0], names[i]);\n                    strcpy(confusing_pairs[total_confusing_pairs][1], names[j]);\n                    total_confusing_pairs++;\n                }\n            }\n        }\n\n        // Sort confusing pairs\n        for (int i = 0; i < total_confusing_pairs - 1; i++) {\n            for (int j = 0; j < total_confusing_pairs - i - 1; j++) {\n                if (strcmp(confusing_pairs[j][0], confusing_pairs[j+1][0]) > 0 ||\n                    (strcmp(confusing_pairs[j][0], confusing_pairs[j+1][0]) == 0 &&\n                     strcmp(confusing_pairs[j][1], confusing_pairs[j+1][1]) > 0)) {\n                    char temp1[MAX_NAME_LENGTH], temp2[MAX_NAME_LENGTH];\n                    strcpy(temp1, confusing_pairs[j][0]);\n                    strcpy(temp2, confusing_pairs[j][1]);\n                    strcpy(confusing_pairs[j][0], confusing_pairs[j+1][0]);\n                    strcpy(confusing_pairs[j][1], confusing_pairs[j+1][1]);\n                    strcpy(confusing_pairs[j+1][0], temp1);\n                    strcpy(confusing_pairs[j+1][1], temp2);\n                }\n            }\n        }\n\n        printf(\"%d\\n\", total_confusing_pairs);\n        for (int i = 0; i < total_confusing_pairs; i++) {\n            printf(\"%s %s\\n\", confusing_pairs[i][0], confusing_pairs[i][1]);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:17:23"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nint computeDistance(const string& s1, const string& s2) {\n    vector<vector<int>> dp(s1.length() + 1, vector<int>(s2.length() + 1, 0));\n    \n    for (int i = 0; i <= s1.length(); ++i) {\n        for (int j = 0; j <= s2.length(); ++j) {\n            if (i == 0) dp[i][j] = j;\n            else if (j == 0) dp[i][j] = i;\n            else if (s1[i-1] == s2[j-1]) dp[i][j] = dp[i-1][j-1];\n            else {\n                int replace = dp[i-1][j-1] + 1;\n                int insert = dp[i][j-1] + 1;\n                int remove = dp[i-1][j] + 1;\n                \n                dp[i][j] = min({replace, insert, remove});\n                \n                // Additional check for adjacent character swap\n                if (i > 1 && j > 1 && \n                    s1[i-1] == s2[j-2] && \n                    s1[i-2] == s2[j-1]) {\n                    dp[i][j] = min(dp[i][j], dp[i-2][j-2] + 1);\n                }\n            }\n        }\n    }\n    \n    return dp[s1.length()][s2.length()];\n}\n\nint main() {\n    int T;\n    cin >> T;\n    \n    while (T--) {\n        int N, threshold;\n        cin >> N >> threshold;\n        \n        vector<string> loginNames(N);\n        for (int i = 0; i < N; ++i) {\n            cin >> loginNames[i];\n        }\n        \n        set<pair<string, string>> confusingPairs;\n        int pairCount = 0;\n        \n        for (int i = 0; i < N; ++i) {\n            for (int j = i + 1; j < N; ++j) {\n                int distance = computeDistance(loginNames[i], loginNames[j]);\n                \n                if (distance <= threshold) {\n                    pairCount++;\n                    confusingPairs.insert({min(loginNames[i], loginNames[j]), \n                                           max(loginNames[i], loginNames[j])});\n                }\n            }\n        }\n        \n        cout << pairCount << endl;\n        for (const auto& pair : confusingPairs) {\n            cout << pair.first << \" \" << pair.second << endl;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:17:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ConfusingLoginPairs {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int T = scanner.nextInt();\n        scanner.nextLine(); // consume newline\n\n        for (int t = 0; t < T; t++) {\n            int N = scanner.nextInt();\n            int K = scanner.nextInt();\n            scanner.nextLine(); // consume newline\n\n            List<String> names = new ArrayList<>();\n            for (int i = 0; i < N; i++) {\n                names.add(scanner.nextLine().trim());\n            }\n\n            List<String[]> pairs = new ArrayList<>();\n            for (int i = 0; i < N; i++) {\n                for (int j = i + 1; j < N; j++) {\n                    String a = names.get(i);\n                    String b = names.get(j);\n                    int distance = calculateDistance(a, b);\n                    if (distance <= K) {\n                        if (a.compareTo(b) < 0) {\n                            pairs.add(new String[]{a, b});\n                        } else {\n                            pairs.add(new String[]{b, a});\n                        }\n                    }\n                }\n            }\n\n            pairs.sort((p1, p2) -> {\n                int cmp = p1[0].compareTo(p2[0]);\n                if (cmp != 0) return cmp;\n                return p1[1].compareTo(p2[1]);\n            });\n\n            System.out.println(pairs.size());\n            for (String[] pair : pairs) {\n                System.out.println(pair[0] + \" \" + pair[1]);\n            }\n        }\n        scanner.close();\n    }\n\n    private static int calculateDistance(String a, String b) {\n        int m = a.length();\n        int n = b.length();\n        int[][] dp = new int[m + 1][n + 1];\n\n        for (int i = 0; i <= m; i++) {\n            dp[i][0] = i;\n        }\n        for (int j = 0; j <= n; j++) {\n            dp[0][j] = j;\n        }\n\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (a.charAt(i - 1) == b.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = 1 + Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1]));\n                }\n\n                if (i > 1 && j > 1 && a.charAt(i - 1) == b.charAt(j - 2) && a.charAt(i - 2) == b.charAt(j - 1)) {\n                    dp[i][j] = Math.min(dp[i][j], dp[i - 2][j - 2] + 1);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n}",
    "timestamp": "2025-08-05 19:18:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_distance(a, b):\n    m, n = len(a), len(b)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            else:\n                dp[i][j] = min(dp[i - 1][j] + 1,     # Deletion\n                               dp[i][j - 1] + 1,     # Insertion\n                               dp[i - 1][j - 1] + (a[i - 1] != b[j - 1])) # Replacement\n                \n                if i > 1 and j > 1 and a[i - 1] == b[j - 2] and a[i - 2] == b[j - 1]:\n                    dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + 1) # Swap\n    \n    return dp[m][n]\n\ndef find_confusing_pairs(datasets, threshold):\n    results = []\n    for names in datasets:\n        confusing_pairs = []\n        names = sorted(names)\n        n = len(names)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if calculate_distance(names[i], names[j]) <= threshold:\n                    confusing_pairs.append((names[i], names[j]))\n        \n        confusing_pairs.sort()\n        results.append((confusing_pairs, len(confusing_pairs)))\n    \n    return results\n\n# Multiple datasets example\ndatasets = [\n    [\"alice\", \"alicce\", \"bob\", \"bbc\"],\n    [\"charlie\", \"charles\", \"cale\", \"karli\"]\n]\nthreshold = 2\n\n# Find and print confusing pairs for each dataset\nfor idx, result in enumerate(find_confusing_pairs(datasets, threshold)):\n    pairs, count = result\n    print(f\"Dataset {idx + 1}:\")\n    for pair in pairs:\n        print(pair)\n    print(\"Total pairs:\", count)\n    print()",
    "timestamp": "2025-08-13 03:19:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class ConfusingLoginNamePairs {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int datasets = scanner.nextInt();\n        while (datasets-- > 0) {\n            int n = scanner.nextInt();\n            int threshold = scanner.nextInt();\n            scanner.nextLine(); // Consume newline\n            \n            List<String> names = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                names.add(scanner.nextLine());\n            }\n            \n            List<Pair> confusingPairs = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    if (calculateDistance(names.get(i), names.get(j)) <= threshold) {\n                        confusingPairs.add(new Pair(names.get(i), names.get(j)));\n                    }\n                }\n            }\n            \n            Collections.sort(confusingPairs);\n            \n            for (Pair pair : confusingPairs) {\n                System.out.println(pair.first + \" \" + pair.second);\n            }\n            \n            System.out.println(\"Total: \" + confusingPairs.size());\n        }\n        scanner.close();\n    }\n    \n    private static int calculateDistance(String s1, String s2) {\n        int len1 = s1.length();\n        int len2 = s2.length();\n        \n        int[][] dp = new int[len1 + 1][len2 + 1];\n        \n        for (int i = 0; i <= len1; i++) {\n            for (int j = 0; j <= len2; j++) {\n                \n                if (i == 0) {\n                    dp[i][j] = j;\n                } else if (j == 0) {\n                    dp[i][j] = i;\n                } else {\n                    int cost = (s1.charAt(i - 1) == s2.charAt(j - 1)) ? 0 : 1;\n                    dp[i][j] = Math.min(dp[i - 1][j - 1] + cost, \n                                    Math.min(dp[i - 1][j] + 1, \n                                             dp[i][j - 1] + 1));\n\n                    if (i > 1 && j > 1 && s1.charAt(i - 1) == s2.charAt(j - 2) && s1.charAt(i - 2) == s2.charAt(j - 1)) {\n                        dp[i][j] = Math.min(dp[i][j], dp[i - 2][j - 2] + 1); // swap\n                    }\n                }\n            }\n        }\n        \n        return dp[len1][len2];\n    }\n    \n    static class Pair implements Comparable<Pair> {\n        String first, second;\n        \n        Pair(String first, String second) {\n            if (first.compareTo(second) < 0) {\n                this.first = first;\n                this.second = second;\n            } else {\n                this.first = second;\n                this.second = first;\n            }\n        }\n        \n        public int compareTo(Pair o) {\n            int cmp = this.first.compareTo(o.first);\n            return (cmp != 0) ? cmp : this.second.compareTo(o.second);\n        }\n    }\n}",
    "timestamp": "2025-08-13 03:19:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_NAME_LENGTH 100\n#define MAX_NAMES_COUNT 1000\n\ntypedef struct {\n    char name1[MAX_NAME_LENGTH];\n    char name2[MAX_NAME_LENGTH];\n} NamePair;\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint calculate_distance(const char *s1, const char *s2) {\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    int i, j;\n    int dist[len1 + 1][len2 + 1];\n    \n    for (i = 0; i <= len1; i++) {\n        for (j = 0; j <= len2; j++) {\n            if (i == 0) {\n                dist[i][j] = j; // Insert all characters from s2\n            } else if (j == 0) {\n                dist[i][j] = i; // Delete all characters from s1\n            } else if (s1[i - 1] == s2[j - 1]) {\n                dist[i][j] = dist[i - 1][j - 1]; // Characters match\n            } else {\n                dist[i][j] = min(min(\n                    dist[i - 1][j - 1] + 1, // Replace\n                    dist[i - 1][j] + 1),   // Delete\n                dist[i][j - 1] + 1);       // Insert\n\n                if (i > 1 && j > 1 && s1[i - 1] == s2[j - 2] && s1[i - 2] == s2[j - 1]) {\n                    dist[i][j] = min(dist[i][j], dist[i - 2][j - 2] + 1); // Swap\n                }\n            }\n        }\n    }\n    return dist[len1][len2];\n}\n\nint compare_pairs(const void *a, const void *b) {\n    NamePair *pair1 = (NamePair*)a;\n    NamePair *pair2 = (NamePair*)b;\n    int cmp = strcmp(pair1->name1, pair2->name1);\n    if (cmp == 0) {\n        return strcmp(pair1->name2, pair2->name2);\n    }\n    return cmp;\n}\n\nvoid find_confusing_pairs(char names[][MAX_NAME_LENGTH], int count, int threshold) {\n    NamePair pairs[MAX_NAMES_COUNT * (MAX_NAMES_COUNT - 1) / 2];\n    int pair_count = 0;\n    \n    for (int i = 0; i < count; i++) {\n        for (int j = i + 1; j < count; j++) {\n            int distance = calculate_distance(names[i], names[j]);\n            if (distance <= threshold) {\n                if (strcmp(names[i], names[j]) < 0) {\n                    strcpy(pairs[pair_count].name1, names[i]);\n                    strcpy(pairs[pair_count].name2, names[j]);\n                } else {\n                    strcpy(pairs[pair_count].name1, names[j]);\n                    strcpy(pairs[pair_count].name2, names[i]);\n                }\n                pair_count++;\n            }\n        }\n    }\n    \n    qsort(pairs, pair_count, sizeof(NamePair), compare_pairs);\n    \n    for (int i = 0; i < pair_count; i++) {\n        printf(\"%s %s\\n\", pairs[i].name1, pairs[i].name2);\n    }\n\n    printf(\"Total pairs: %d\\n\", pair_count);\n}\n\nint main() {\n    int num_datasets;\n    scanf(\"%d\", &num_datasets);\n    \n    for (int dataset = 0; dataset < num_datasets; dataset++) {\n        char names[MAX_NAMES_COUNT][MAX_NAME_LENGTH];\n        int count, threshold;\n        scanf(\"%d %d\", &count, &threshold);\n        \n        for (int i = 0; i < count; i++) {\n            scanf(\"%s\", names[i]);\n        }\n        \n        find_confusing_pairs(names, count, threshold);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 03:19:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_distance(s1, s2):\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i-1] == s2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                delete = dp[i-1][j] + 1\n                insert = dp[i][j-1] + 1\n                replace = dp[i-1][j-1] + 1\n                \n                # Check for swap\n                swap = float('inf')\n                if i > 1 and j > 1 and s1[i-1] == s2[j-2] and s1[i-2] == s2[j-1]:\n                    swap = dp[i-2][j-2] + 1\n                \n                dp[i][j] = min(delete, insert, replace, swap)\n    \n    return dp[m][n]\n\ndef find_confusing_names(names, threshold):\n    confusing_pairs = []\n    \n    for i in range(len(names)):\n        for j in range(i+1, len(names)):\n            distance = calculate_distance(names[i], names[j])\n            if distance <= threshold:\n                confusing_pairs.append((names[i], names[j]))\n    \n    confusing_pairs.sort()\n    return confusing_pairs\n\ndef main():\n    T = int(input())\n    \n    for _ in range(T):\n        N, K = map(int, input().split())\n        names = []\n        \n        for _ in range(N):\n            names.append(input().strip())\n        \n        confusing_pairs = find_confusing_names(names, K)\n        \n        print(len(confusing_pairs))\n        for pair in confusing_pairs:\n            print(f\"{pair[0]} {pair[1]}\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 03:19:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\ndef levenshtein_distance(s1, s2):\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    \n    previous_row = range(len(s2) + 1)\n    for i, c1 in enumerate(s1):\n        current_row = [i + 1]\n        for j, c2 in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    \n    return previous_row[-1]\n\ndef adjacent_swap_distance(s1, s2):\n    if len(s1) != len(s2):\n        return float('inf')\n    s1, s2 = list(s1), list(s2)\n    swaps = 0\n    for i in range(len(s1) - 1):\n        if s1[i] == s2[i]:\n            continue\n        if s1[i] == s2[i+1] and s1[i+1] == s2[i]:\n            s1[i], s1[i+1] = s1[i+1], s1[i]\n            swaps += 1\n        else:\n            return float('inf')\n    return swaps if s1 == s2 else float('inf')\n\ndef calculate_distance(s1, s2):\n    dist = levenshtein_distance(s1, s2)\n    swap_dist = adjacent_swap_distance(s1, s2)\n    return min(dist, swap_dist)\n\ndef solve():\n    input_lines = [line.strip() for line in sys.stdin if line.strip()]\n    idx = 0\n    while idx < len(input_lines):\n        N, K = map(int, input_lines[idx].split())\n        idx += 1\n        names = input_lines[idx:idx+N]\n        idx += N\n        \n        pairs = []\n        for i in range(N):\n            for j in range(i + 1, N):\n                s1, s2 = names[i], names[j]\n                dist = calculate_distance(s1, s2)\n                if dist <= K:\n                    if s1 < s2:\n                        pairs.append((s1, s2))\n                    else:\n                        pairs.append((s2, s1))\n        \n        pairs.sort()\n        for pair in pairs:\n            print(f\"{pair[0]} {pair[1]}\")\n        print(len(pairs))\n\nif __name__ == \"__main__\":\n    solve()",
    "timestamp": "2025-08-13 03:20:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n\n// Function to calculate the distance between two strings using the defined operations\nint calculateDistance(const std::string &s1, const std::string &s2) {\n    int m = s1.size(), n = s2.size();\n    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1, 0));\n\n    for (int i = 0; i <= m; ++i) dp[i][0] = i;\n    for (int j = 0; j <= n; ++j) dp[0][j] = j;\n\n    for (int i = 1; i <= m; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            if (s1[i - 1] == s2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = std::min({dp[i - 1][j - 1] + 1, // replace\n                                     dp[i - 1][j] + 1,   // delete\n                                     dp[i][j - 1] + 1}); // insert\n            }\n            if (i > 1 && j > 1 && s1[i - 1] == s2[j - 2] && s1[i - 2] == s2[j - 1]) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 2][j - 2] + 1); // swap\n            }\n        }\n    }\n    return dp[m][n];\n}\n\n// Function to generate confusing pairs\nvoid generateConfusingPairs(const std::vector<std::string> &names, int threshold) {\n    std::set<std::pair<std::string, std::string>> confusingPairs;\n\n    for (size_t i = 0; i < names.size(); ++i) {\n        for (size_t j = i + 1; j < names.size(); ++j) {\n            if (calculateDistance(names[i], names[j]) <= threshold) {\n                confusingPairs.emplace(std::min(names[i], names[j]), std::max(names[i], names[j]));\n            }\n        }\n    }\n\n    // Output sorted pairs and their count\n    for (const auto &pair : confusingPairs) {\n        std::cout << pair.first << \" \" << pair.second << \"\\n\";\n    }\n    std::cout << \"Total Count: \" << confusingPairs.size() << \"\\n\";\n}\n\nint main() {\n    int numDatasets;\n    std::cin >> numDatasets;\n    \n    while (numDatasets-- > 0) {\n        int numNames, threshold;\n        std::cin >> numNames >> threshold;\n        \n        std::vector<std::string> names(numNames);\n        for (int i = 0; i < numNames; ++i) {\n            std::cin >> names[i];\n        }\n        \n        generateConfusingPairs(names, threshold);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:11:04"
  }
]