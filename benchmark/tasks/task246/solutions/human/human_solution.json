[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<string,string> P;\n\nint n,d;\nint ans=0;\nset<string> mp[201];\nint cnt[201][201];\nvector<P> vec;\nstring str[201];\nqueue<int> que;\n\nvoid dfs(int v,string s,int nd,int uk=0){\n\tif(nd==0){\n\t\tmp[v].insert(s);\n\t\tfor(int i=0;i+1<s.size();i++){\n\t\t\tswap(s[i],s[i+1]);\n\t\t\tdfs(v,s,nd+1);\n\t\t\tswap(s[i],s[i+1]);\n\t\t}\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tdfs(v,s.substr(0,i)+s.substr(i+1),nd+1);\n\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\tstring gu=\"\";\n\t\t\t\tgu+=('a'+j);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i+1),nd+1,1);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i),nd+1,1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<26;i++){\n\t\t\tstring gu=\"\";\n\t\t\tgu+=('a'+i);\n\t\t\tdfs(v,s+gu,nd+1);\n\t\t}\n\t}else if(nd==1){\n\t\tmp[v].insert(s);\n\t}\n}\n\nvoid dfs2(int v,string s,int nd,int uk=0){\n\tif(nd==0){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(mp[i].find(s)!=mp[i].end()){\n\t\t\t\tcnt[v][i]++;\n\t\t\t\tcnt[i][v]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i+1<s.size();i++){\n\t\t\tswap(s[i],s[i+1]);\n\t\t\tdfs2(v,s,nd+1);\n\t\t\tswap(s[i],s[i+1]);\n\t\t}\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tdfs2(v,s.substr(0,i)+s.substr(i+1),nd+1);\n\t\t}\n\t\tfor(int i=0;i<26;i++){\n\t\t\tstring gu=\"\";\n\t\t\tgu+=('a'+i);\n\t\t\tdfs2(v,s+gu,nd+1);\n\t\t}\n\t}else if(nd==1){\n\t\tif(d==2 && uk==0){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(mp[i].find(s)!=mp[i].end()){\n\t\t\t\t\tcnt[v][i]++;\n\t\t\t\t\tcnt[i][v]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tvec.clear();\n\tfor(int i=0;i<n;i++){\n\t\tmp[i].clear();\n\t}\n\tscanf(\"%d\",&d);\n\tans=0;\n\tfor(int i=0;i<n;i++){\n\t\tmemset(cnt,0,sizeof(cnt));\n\t\tcin >> str[i];\n\t\twhile(que.size())que.pop();\n\t\tfor(int j=0;j<i;j++){\n\t\t\tque.push(j);\n\t\t}\n\t\tdfs(i,str[i],0);\n\t\t\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tdfs2(i,str[i],0);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(cnt[i][j]>0){\n\t\t\t\tans++;\n\t\t\t\tvec.push_back(P(min(str[i],str[j]),max(str[i],str[j])));\n\t\t\t}\n\t\t}\n\t}\n\tsort(vec.begin(),vec.end());\n\tfor(int i=0;i<vec.size();i++){\n\t\tcout << vec[i].first << \",\" << vec[i].second << endl;\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\nusing namespace std;\n \ntypedef pair<int,int> P;\n \nint n, d;\nstring t[202];\nmap<string, set<int> > idx;\n \nvector<string> getV(string v){\n  vector<string> res;\n  string s = v;\n \n  for(int a = 0; a < s.length() - 1; a++){\n    swap(s[a], s[a + 1]);\n    res.push_back(s);\n    swap(s[a], s[a + 1]);\n  }\n \n  for(char ch = 'a'; ch <= 'z'; ch++){\n    for(int j = 0; j < v.length(); j++){\n      s = v;\n      s[j] = ch;\n      res.push_back(s);\n      s[j] = v[j];\n    }\n \n    for(int j = 0; j < v.length() + 1; j++){\n      s = v.substr(0, j) + ch + v.substr(j);\n      res.push_back(s);\n    }\n  }\n \n  for(int j = 0; j < v.length(); j++){\n    s = v.substr(0, j) + v.substr(j + 1);\n    res.push_back(s);\n  }\n \n  return res;\n}\n \nint main(){\n  while(cin >> n, n){\n    cin >> d;\n \n    for(int i = 0; i < n; i++){\n      cin >> t[i];\n    }\n    sort(t, t + n);\n \n    idx.clear();\n \n    for(int i = 0; i < n; i++){\n      vector<string> v = getV(t[i]);\n \n      for(int j = 0; j < v.size(); j++){\n        idx[v[j]].insert(i);\n      }\n    }\n \n    set<P> ans;\n \n    for(int i = 0; i < n; i++){\n      for(int j = i + 1; j < n; j++){\n        if(idx[t[j]].find(i) != idx[t[j]].end()){\n          ans.insert(P(i, j));\n        }\n      }\n    }\n \n    if(d == 2){\n      for(map<string,set<int> >::iterator iter = idx.begin(); iter != idx.end(); iter++){\n        set<int> stt = iter->second;\n        for(set<int>::iterator iter2 = stt.begin(); iter2 != stt.end(); iter2++){\n          for(set<int>::iterator iter3 = stt.begin(); iter3 != stt.end(); iter3++){\n            if(*iter2 < *iter3)\n              ans.insert(P(*iter2, *iter3));\n          }\n        }\n      }\n    }\n \n    for(set<P>::iterator iter = ans.begin(); iter != ans.end(); iter++){\n      P p = *iter;\n      cout << t[p.first] << \",\" << t[p.second] << endl;\n    }\n \n    cout << ans.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\nusing ps = pair<string,string>;\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        int d;\n        cin >>d;\n        vector<string> name(n);\n        rep(i,n) cin >>name[i];\n        sort(all(name));\n\n        vector<set<string>> v(n);\n        rep(i,n){\n            string s = name[i];\n            int S = s.size();\n            string t;\n\n            // delete\n            rep(j,S){\n                t = s;\n                t.erase(t.begin()+j);\n                v[i].insert(t);\n            }\n\n            // insert\n            rep(j,S+1){\n                rep(k,26){\n                    char c = 'a'+k;\n                    t = s;\n                    t.insert(j,string(1,c));\n                    v[i].insert(t);\n                }\n            }\n\n            // replace\n            rep(j,S){\n                rep(k,26){\n                    char c = 'a'+k;\n                    t = s;\n                    if(t[j] != c){\n                        t[j] = c;\n                        v[i].insert(t);\n                    }\n                }\n            }\n\n            // swap\n            rep(j,S)for(int k=j+1; k<S; ++k){\n                t = s;\n                if(t[j]!=t[k]){\n                    swap(t[j],t[k]);\n                    v[i].insert(t);\n                }\n            }\n        }\n\n        map<string,vector<int>> idx;\n        rep(i,n){\n            for(string ss:v[i]) idx[ss].pb(i);\n        }\n\n        // dbg(name);\n\n        set<pi> ans;\n        // d==1\n        rep(i,n)for(int j=i+1; j<n; ++j){\n            if(v[i].count(name[j])) ans.insert({i,j});\n        }\n        if(d==2){\n            for(const auto p:idx){\n                vector<int> tt = p.se;\n                int sz = tt.size();\n\n                rep(i,sz)rep(j,i){\n                    if(tt[j]!=tt[i]) ans.insert({tt[j],tt[i]});\n                }\n            }\n        }\n\n        // for(pi p:ans) dbg(p);\n        for(pi p:ans) cout << name[p.fi] << \",\" << name[p.se] << \"\\n\";\n        cout << ans.size() << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define FOR(it,o)  for(__typeof((o).begin()) it =(o).begin();it != (o).end();it++)\n#define pb         push_back\n#define mp         make_pair\n\n\ntypedef unsigned long long           ull;\ntypedef pair<string,string> pss;\ntypedef vector<pss>         vpss;\n\nconst ull tmp = 10007;\n\null calchash(string &in){\n  ull ret= 0;\n  rep(i,(int)in.size()){\n    ret=ret*tmp + in[i];\n  }\n  return ret;\n}\n\n\nbool isok[200][200];\nint ed[200][200];\nint cost[20][20];\nint edit_distance(string tr,string tc){\n  string r,c;\n  r=' ';\n  c=' ';\n  rep(i,tr.size())r+=tr[i];\n  rep(i,tc.size())c+=tc[i];\n  rep(i,r.size())rep(j,c.size())cost[i][j]=(1<<21);\n\n  rep(i,r.size())cost[i][0]=i;\n  rep(i,c.size())cost[0][i]=i;\n\n  REP(i,1,r.size()){\n    REP(j,1,c.size()){\n      int tmp =r[i]==c[j]?0:1;\n      int opt[3];\n      opt[0]=cost[i-1][j-1]+tmp;\n      opt[1]=cost[i-1][j]+1;\n      opt[2]=cost[i][j-1]+1;\n      rep(k,3)cost[i][j]=min(cost[i][j],opt[k]);\n    }\n  }\n  return cost[r.size()-1][c.size()-1];\n}\n\n\nvoid ed1(vector<string>&in,set<ull> S[]){\n  rep(i,(int)in.size()){\n    REP(j,i+1,(int)in.size()){\n      if (S[j].find(calchash(in[i])) != S[j].end()){\n\tisok[i][j] = true;\n      }\n    }    \n  }\n}\n\t \nvoid ed2(vector<string> &in,set<ull> S[]){\n  rep(i,(int)in.size()){\n    REP(j,i+1,(int)in.size()){\n      if (isok[i][j]||ed[i][j] > 4)continue;\n      FOR(it,S[i]){\n\tif (S[j].find( *it) != S[j].end()){\n\t  isok[i][j]=true;\n\t  break;\n\t}\n      }\n    }\n  }\n}\n\nvoid del_string(string &in,set<ull>&S){\n  rep(i,(int)in.size()){\n    string tmp = in;\n    tmp.erase(tmp.begin()+i);\n    S.insert(calchash(tmp));\n  }\n}\n\nvoid insert_string(string &in,set<ull>&S){\n  rep(i,(int)in.size()+1){\n    rep(j,26){\n      string tmp=in.substr(0,i);\n      tmp+='a'+j;\n      //tmp+=string(1,'a'+j);\n      string tmp2=in.substr(i);\n      rep(k,tmp2.size())tmp+=(char)tmp2[k];\n      //tmp=string(tmp)+string(in.substr(i));\n      S.insert(calchash(tmp));\n    }\n  }\n}\n\nvoid replace_string(string &in,set<ull>&S){\n  rep(i,(int)in.size()){\n    char tmp = in[i];\n    rep(j,26){\n      in[i]='a'+j;\n      S.insert(calchash(in));\n    }\n    in[i]=tmp;\n  }\n}\n\nvoid swap_string(string&in,set<ull>&S){\n  rep(i,(int)in.size()-1){\n    swap(in[i],in[i+1]);\n    S.insert(calchash(in));\n    swap(in[i],in[i+1]);\n  }\n}\n\nvoid make_string(vector<string>& in,set<ull> S[]){\n  rep(i,(int)in.size()){\n    del_string(in[i],S[i]);\n    insert_string(in[i],S[i]);\n    replace_string(in[i],S[i]);\n    swap_string(in[i],S[i]);\n  }\n}\n\nvoid solve(vector<string>in,set<ull>S[],int d){\n  int n=(int)in.size();\n  rep(i,n){\n    REP(j,i+1,n){\n      ed[i][j]=edit_distance(in[i],in[j]);\n      if (ed[i][j] <= d)isok[i][j]=true;\n    }\n  }\n  \n  make_string(in,S);\n  ed1(in,S);\n  if (d==2)ed2(in,S);\n  int cnt=0;\n  rep(i,n){\n    rep(j,n)if (isok[i][j])cnt++,cout<<in[i]<<\",\"<<in[j]<<endl;\n  }\n  cout << cnt << endl;\n}\n\nvoid test(){\n  string in=\"test\";\n  set<ull> S;\n  insert_string(in,S);\n}\n\nmain(){\n  //test();\n  int n,d;\n  while(cin>>n>>d && n){\n    vector<string> in;\n    rep(i,n)rep(j,n)isok[i][j]=false,ed[i][j]=(1<<21);\n    set<ull> S[n];\n    rep(i,n){\n      string tmp;\n      cin>>tmp;\n      in.pb(tmp);\n    }\n    sort(ALL(in));\n    rep(i,(int)in.size())S[i].insert(calchash(in[i]));\n    solve(in,S,d);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nvoid change(const string& s, set<string>& dest){\n  dest.insert(s);\n  for(int i=0;i<SZ(s);++i){\n\tstring tmp = s;\n\ttmp.erase(i, 1);\n\tdest.insert(tmp);\n  }\n  for(int i=0;i<=SZ(s);++i){\n\tstring tmp = s;\n\ttmp.insert(i, \".\");\n\tREP(c,26){\n\t  tmp[i] = c + 'a';\n\t  dest.insert(tmp);\n\t}\n  }\n  \n  for(int i=0;i<SZ(s);++i){\n\tstring tmp = s;\n\tREP(c,26){\n\t  tmp[i] = c + 'a';\n\t  dest.insert(tmp);\n\t}\n  }\n  for(int i=0;i+1<SZ(s);++i){\n\tstring tmp = s;\n\tswap(tmp[i], tmp[i+1]);\n\tdest.insert(tmp);\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, D;\n  while(cin >> N, N){\n\tcin >> D;\n\tVS vs(N);\n\tREP(i,N){\n\t  cin >> vs[i];\n\t}\n\n\tvector<set<string>> memo(N);\n\tmap<string,VI> ids;\n\tREP(i,N){\n\t  change(vs[i], memo[i]);\n\t  for(auto& s: memo[i])\n\t\tids[s].PB(i);\n\t}\n\n\tvector<pair<string,string>> ans;\n\tfor(auto& p: ids){\n\t  if(SZ(p.SS) == 1) continue;\n\t  if(D == 2){\n\t\tREP(ii,SZ(p.SS)) REP(jj,ii){\n\t\t  int i = p.SS[ii], j = p.SS[jj];\n\t\t  if(vs[i] < vs[j])\n\t\t\tans.EB(vs[i], vs[j]);\n\t\t  else\n\t\t\tans.EB(vs[j], vs[i]);\n\t\t}\n\t  }\n\t  REP(ii,SZ(p.SS)) REP(jj,SZ(p.SS)){\n\t\tif(ii == jj) continue;\n\t\tint i = p.SS[ii], j = p.SS[jj];\n\t\tif(p.FF != vs[i] && p.FF != vs[j]) continue;\n\t\t\n\t\tif(vs[i] < vs[j])\n\t\t  ans.EB(vs[i], vs[j]);\n\t\telse\n\t\t  ans.EB(vs[j], vs[i]);\n\t  }\n\t}\n\n\tSORT(ans);\n\tUNIQ(ans);\n\tfor(auto& p: ans)\n\t  cout << p.FF << \",\" << p.SS << endl;\n\tcout << SZ(ans) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nbool check(string a,string b,int d){\n  if(a.size()<b.size())swap(a,b);\n  if(a==b) return 1;\n  int A = a.size(),B=b.size();\n  if(d==0||A-B>d)return 0;\n\n\n  //erase\n  for(int i=0;i<A;i++){\n    char ch = a[i];\n    \n    a.erase(a.begin()+i);\n    if(check(a,b,d-1))return 1;\n    a.insert(a.begin()+i,ch);\n  }\n\n  if(A!=B) return 0;\n\n  //swap\n  for(int i=0;i<A-1;i++){\n    if(a[i]==a[i+1]||a[i+1]!=b[i]||a[i]!=b[i+1])continue;\n    swap(a[i],a[i+1]);\n    if(check(a,b,d-1))return 1;\n    swap(a[i],a[i+1]);\n  }\n  \n  //change\n  int cnt=0;\n  for(int i=0;i<A;i++) cnt+=a[i]!=b[i];\n  return cnt<=d;\n}\n\nint main(){\n  int n,d;\n  while(cin>>n,n){\n    cin>>d;\n    string str[201];\n    for(int i=0;i<n;i++)cin>>str[i];\n    sort(str,str+n);\n\n    int cnt=0;    \n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++)\n\tif(check(str[i],str[j],d)) cout<<str[i]<<\",\"<<str[j]<<endl,cnt++;\n    cout<<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 201\ntypedef pair<string,string> P;\n\nint N,D,idx;\nstring s[MAX];\nmap<int,set<string> > mp;\nvector<P> vec;\n\nvoid dfs(string now,int step){\n  if(step == 1){\n    mp[idx].insert(now);\n    return;\n  }\n  \n  int len = now.size();\n  // delete\n  for(int i = 0 ; i < len ; i++){\n    string tmp = now;\n    tmp.erase(tmp.begin()+i);\n    dfs(tmp,step+1);\n  }\n \n  // swap\n  for(int i = 0 ; i < len-1 ; i++){\n    swap(now[i],now[i+1]);\n    dfs(now,step+1);\n    swap(now[i],now[i+1]);\n  }\n\n  // insert\n  for(char ch = 'a' ; ch <= 'z' ; ch++){\n    for(int j = 0 ; j < len+1 ; j++){\n      string tmp = now;\n      tmp = tmp.substr(0,j) + ch + tmp.substr(j);\n      dfs(tmp,step+1);\n    }\n  }\n \n  // replace\n  for(char ch = 'a' ; ch <= 'z' ; ch++){\n    for(int j = 0 ; j < len ; j++){\n      char c = now[j];\n      now[j] = ch;\n      dfs(now,step+1);\n      now[j] = c;\n    }\n  }\n}\n\nvoid init(){\n  mp.clear();\n  vec.clear();\n}\n\nint main(){\n  while(cin >> N, N){\n    cin >> D;\n    init();\n    for(int i = 0 ; i < N ; i++){\n      cin >> s[i];\n    }\n    for(int i = 0 ; i < N ; i++){\n      idx = i;\n      dfs(s[i],0);\n    }\n\n    vector<string> v[MAX];\n    for(int i = 0 ; i < N ; i++){\n      set<string> st = mp[i];\n      set<string>::iterator it;\n      for(it = st.begin() ; it != st.end() ; ++it){\n        v[i].push_back(*it);\n      }\n    } \n\n    if(D == 1){\n      for(int i = 0 ; i < N ; i++){\n        unordered_map<string,bool> ump;\n        for(int j = 0 ; j < (int)v[i].size() ; j++){\n          ump[v[i][j]] = true;\n        }\n        for(int j = i+1 ; j < N ; j++){\n          if(ump.find(s[j]) != ump.end()){\n           vec.push_back(P(s[i],s[j]));\n          }\n        }\n      }\n    }else{\n      for(int i = 0 ; i < N ; i++){\n        unordered_map<string,bool> ump;\n        for(int j = 0 ; j < (int)v[i].size() ; j++){\n          ump[v[i][j]] = true;\n        }\n        for(int j = i+1 ; j < N ; j++){\n          for(int k = 0 ; k < (int)v[j].size() ; k++){\n            if(ump.find(v[j][k]) != ump.end()){\n              vec.push_back(P(s[i],s[j]));\n              break;\n            }\n          }\n        }\n      }\n    }\n    int len = vec.size();\n    for(int i = 0 ; i < len ; i++){\n      if(vec[i].first > vec[i].second){\n        swap(vec[i].first,vec[i].second);\n      }\n    }\n    sort(vec.begin(),vec.end());\n    for(int i = 0 ; i < len ; i++){\n      cout << vec[i].first << \",\" << vec[i].second << endl;\n    }\n    cout << len << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 334\ntypedef pair<string,string> P;\n \nint N,D,idx;\nstring s[MAX];\nmap<int,set<string> > mp;\nvector<P> vec;\n \nvoid dfs(string now,int step){\n  if(step == 1){\n    mp[idx].insert(now);\n    return;\n  }\n \n  int len = now.size();\n  // delete\n  for(int i = 0 ; i < len ; i++){\n    string tmp = now;\n    tmp.erase(tmp.begin()+i);\n    dfs(tmp,step+1);\n  }\n \n  // swap\n  for(int i = 0 ; i < len-1 ; i++){\n    for(int j = i+1 ; j < len ; j++){\n      swap(now[i],now[j]);\n      dfs(now,step+1);\n      swap(now[i],now[j]);\n    }\n  }\n   \n  // insert\n  for(char ch = 'a' ; ch <= 'z' ; ch++){\n    for(int j = 0 ; j < len+1 ; j++){\n      string tmp = now;\n      tmp = tmp.substr(0,j) + ch + tmp.substr(j);\n      dfs(tmp,step+1);\n    }\n  }\n \n  // replace\n  for(char ch = 'a' ; ch <= 'z' ; ch++){\n    for(int j = 0 ; j < len ; j++){\n      string tmp = now; tmp[j] = ch;\n      dfs(tmp,step+1);\n    }\n  }\n}\n \nvoid init(){\n  mp.clear();\n  vec.clear();\n}\n \nint main(){\n  while(cin >> N, N){\n    cin >> D;\n    init();\n    for(int i = 0 ; i < N ; i++){\n      cin >> s[i];\n    }\n    for(int i = 0 ; i < N ; i++){\n      idx = i;\n      dfs(s[i],0);\n    }\n    \n    vector<string> v[MAX];\n    for(int i = 0 ; i < N ; i++){\n      set<string> st = mp[i];\n      set<string>::iterator it;\n      for(it = st.begin() ; it != st.end() ; ++it){\n        v[i].push_back(*it);\n      }\n    }\n    if(D == 1){\n      for(int i = 0 ; i < N ; i++){\n        for(int j = i+1 ; j < N ; j++){\n          if(binary_search(v[i].begin(),v[i].end(),s[j])){\n            vec.push_back(P(s[i],s[j]));\n          }\n        }\n      }\n    }else{\n      for(int i = 0 ; i < N ; i++){\n        for(int j = i+1 ; j < N ; j++){\n          vector<string>::iterator it;\n          for(it = v[i].begin() ; it != v[i].end() ; ++it){\n            if(binary_search(v[j].begin(),v[j].end(),*it)){\n              vec.push_back(P(s[i],s[j]));\n              break;\n            }\n          }\n        }\n      }\n    }\n    int len = vec.size();\n    for(int i = 0 ; i < len ; i++){\n      if(vec[i].first > vec[i].second){\n        swap(vec[i].first,vec[i].second);\n      }\n    }\n    sort(vec.begin(),vec.end());\n    for(int i = 0 ; i < len ; i++){\n      cout << vec[i].first << \",\" << vec[i].second << endl;\n    }\n    cout << len << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n){\n    int d;\n    vector<string> name(n);\n    cin >> d;\n    rep(i,0,n) cin >> name[i];\n\n    auto hash_string=hash<string>();\n    function<set<size_t>(const string&,const int)> enumerate_neighborhood=[&](const string &s,int d){\n        if(d==0) return set<size_t>({hash_string(s)});\n        set<size_t> res;\n        //replace\n        rep(i,0,s.size()){\n            string t=s;\n            rep(j,0,26){\n                t[i]='a'+j;\n                auto tmp=enumerate_neighborhood(t,d-1);\n                res.insert(tmp.begin(),tmp.end());\n            }\n        }\n        //insert\n        rep(i,0,s.size()+1){\n            string x=s.substr(0,i),y=s.substr(i);\n            rep(j,0,26){\n                x.push_back('a'+j);\n                auto t=x+y;\n                auto tmp=enumerate_neighborhood(t,d-1);\n                res.insert(tmp.begin(),tmp.end());\n                x.pop_back();\n            }\n        }\n        //delete\n        rep(i,0,s.size()){\n            string t=s.substr(0,i)+s.substr(i+1);\n            auto tmp=enumerate_neighborhood(t,d-1);\n            res.insert(tmp.begin(),tmp.end());\n        }\n        //swap adjacent\n        rep(i,0,s.size()-1){\n            string t=s;\n            swap(t[i],t[i+1]);\n            auto tmp=enumerate_neighborhood(t,d-1);\n            res.insert(tmp.begin(),tmp.end());\n            swap(t[i],t[i+1]);\n        }\n        return res;\n    };\n\n    vector<set<size_t>> u(n);\n    rep(i,0,n) u[i]=enumerate_neighborhood(name[i],d);\n\n    vector<pair<string,string>> ans;\n    rep(i,0,n) rep(j,i+1,n){\n        int i1=i,j1=j;\n        if(u[i].size()>u[j].size()) swap(i1,j1);\n        if(u[i1].find(hash_string(name[j1]))==u[i1].end()) continue;\n        ans.push_back(make_pair(min(name[i],name[j]),max(name[i],name[j])));\n    }\n\n    sort(ans.begin(),ans.end());\n    rep(i,0,ans.size()) cout << ans[i].first << \",\" << ans[i].second << endl;\n    cout << ans.size() << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint LevenshteinDist(const string& s, const string& t)\n{\n    int n = s.size();\n    int m = t.size();\n    vector<vector<int> > minCost(n+2, vector<int>(m+2, INT_MAX));\n    minCost[0][0] = 0;\n    for(int i=0; i<=n; ++i){\n        for(int j=0; j<=m; ++j){\n            minCost[i+1][j] = min(minCost[i+1][j], minCost[i][j] + 1);\n            minCost[i][j+1] = min(minCost[i][j+1], minCost[i][j] + 1);\n            if(i < n && j < m && s[i] == t[j])\n                minCost[i+1][j+1] = min(minCost[i+1][j+1], minCost[i][j]);\n            else\n                minCost[i+1][j+1] = min(minCost[i+1][j+1], minCost[i][j] + 1);\n        }\n    }\n    return minCost[n][m];\n}\n\nint main()\n{\n    for(;;){\n        int n, d;\n        cin >> n >> d;\n        if(n == 0)\n            return 0;\n\n        vector<string> s(n);\n        for(int i=0; i<n; ++i)\n            cin >> s[i];\n        sort(s.begin(), s.end());\n\n        vector<set<string> > vss(n);\n        for(int i=0; i<n; ++i){\n            int m = s[i].size();\n            /* swap */\n            for(int j=0; j<m; ++j){\n                for(int k=j+1; k<m; ++k){\n                    string t = s[i];\n                    swap(t[j], t[k]);\n                    vss[i].insert(t);\n                }\n            }\n        }\n\n        int ret = 0;\n        for(int i=0; i<n; ++i){\n            for(int j=i+1; j<n; ++j){\n                bool confuse = false;\n\n                if(LevenshteinDist(s[i], s[j]) <= d)\n                    confuse = true;\n\n                set<string>::iterator it;\n                for(it=vss[i].begin(); it!=vss[i].end(); ++it){\n                    if(LevenshteinDist(*it, s[j]) <= d-1)\n                        confuse = true;\n                }\n                for(it=vss[j].begin(); it!=vss[j].end(); ++it){\n                    if(LevenshteinDist(s[i], *it) <= d-1)\n                        confuse = true;\n                }\n\n                if(d == 2 && s[i].size() == s[j].size()){\n                    int num = 0;\n                    vector<int> diff(26);\n                    for(unsigned k=0; k<s[i].size(); ++k){\n                        if(s[i][k] != s[j][k]){\n                            ++ num;\n                            ++ diff[s[i][k]-'a'];\n                            -- diff[s[j][k]-'a'];\n                        }\n                        if(num <= 4 && count(diff.begin(), diff.end(), 0) == 26)\n                            confuse = true;\n                    }\n                }\n\n                if(confuse){\n                    cout << s[i] << ',' << s[j] << endl;\n                    ++ ret;\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing std::sort;\nusing std::swap;\n\nint N, D;\nstruct Name{\n    char s[20];\n    bool operator<(const Name &b)const{\n        for(int i=0;;i++){\n            if(b.s[i]=='\\0') return false;\n            if(s[i]=='\\0') return true;\n            if(s[i] < b.s[i]) return false;\n            if(s[i] > b.s[i]) return true;\n        }\n    }\n}name[300];\n\nbool distance(int a, int b, int x, int y, int d){\n    if(d > D) return false;\n    if(name[a].s[x]=='\\0' && name[b].s[y]=='\\0') return true;\n    if(name[a].s[x] == '\\0') return distance(a, b, x, y+1, d+1);\n    if(name[b].s[y] == '\\0') return distance(a, b, x+1, y, d+1);\n    if(name[a].s[x] == name[b].s[y]) return distance(a, b, x+1, y+1, d); //always best\n    if(distance(a, b, x+1, y, d+1)) return true; //del a[x]->x++ or Insert b[y]\n    if(distance(a, b, x, y+1, d+1)) return true; //del b[y]->y++ or Insert a[x]\n    if(distance(a, b, x+1, y+1, d+1)) return true; //Replacing\n    if(name[a].s[x+1]!='\\0'){\n        swap(name[a].s[x], name[a].s[x+1]);\n        if(distance(a, b, x, y, d+1)){\n            swap(name[a].s[x], name[a].s[x+1]);\n            return true;\n        }\n        swap(name[a].s[x], name[a].s[x+1]);\n        //swap a a+2 ans delete a+1...\n        if(name[a].s[x+2]!='\\0'){\n            swap(name[a].s[x], name[a].s[x+2]);\n            char tmp = name[a].s[x+1];\n            int i;\n            for(i=x+2;name[a].s[i-1]!='\\0';i++) name[a].s[i-1] = name[a].s[i];\n            bool res = distance(a, b, x, y, d+2);\n            for(;i>x;i--) name[a].s[i] = name[a].s[i-1];\n            name[a].s[x+1] = tmp;\n            swap(name[a].s[x], name[a].s[x+2]);\n            return res;\n        }\n    }\n    return false;\n}\nint main(){\n    while(scanf(\"%d %d\", &N, &D) && N){\n        for(int i=0;i<N;i++)\n            scanf(\"%s\", name[i].s);\n        sort(name, name+N);\n        int res = 0;\n        for(int i=N-1;i>=0;i--){\n            for(int j=i-1;j>=0;j--){\n                if(distance(i, j, 0, 0, 0)){\n                    printf(\"%s,%s\\n\", name[i].s, name[j].s);\n                    res++;\n                }\n            }\n        }\n        printf(\"%d\\n\", res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <vector>\n#include <map>\n#include <algorithm>\n \nusing namespace std;\ntypedef unsigned long long ulli;\n \nconst ulli B = 100000007ULL;\n \nint n, d;\nvector<string> dat;\nvector<pair<string, string> > ans;\nset<ulli> vis;\n \nvoid init(){\n  dat.clear();\n  ans.clear();\n}\n \nulli getHash(const string &s) {\n  ulli res = 0;\n  for(int i = 0; i < s.size(); ++i) {\n    res = res * B + s[i];\n  }\n  return res;\n}\n \nbool calc(const string &s, int x, bool f){\n  ulli h = getHash(s);\n  if(x >= 1 || (!f && d == x) || (f && d == 1)){\n    if(!f){\n      vis.insert(h);\n    }\n    if(f && vis.find(h) != vis.end()){\n      return true;\n    }\n  }else{\n    string t;\n    //remove\n    for(int i=0;i<s.size();i++){\n      t.clear();\n      for(int j=0;j<s.size();j++){\n        if(i == j) continue;\n        t.push_back(s[j]);\n      }\n      if(calc(t, x + 1, f)) return true;\n    }\n    //add\n    for(int i=0;i<=s.size();i++){\n      for(int k=0;k<26;k++){\n        t.clear();\n        for(int j=0;j<s.size();j++){\n          if(i == j){\n            t.push_back((char)k + 'a');\n          }\n          t.push_back(s[j]);\n          if(i == s.size() && j + 1 == s.size()){\n            t.push_back((char)k + 'a');\n          }\n        }\n        if(calc(t, x + 1, f)) return true;\n      }\n    }\n    //change\n    for(int i=0;i<s.size();i++){\n      for(int k=0;k<26;k++){\n        t.clear();\n        for(int j=0;j<s.size();j++){\n          if(i == j){\n            t.push_back((char)k + 'a');\n          }else{\n            t.push_back(s[j]);\n          }\n        }\n        if(calc(t, x + 1, f)) return true;\n      }\n    }\n    //swap\n    t = s;\n    for(int i=1;i<s.size();i++){\n      swap(t[i-1], t[i]);\n      if(calc(t, x + 1, f)) return true;\n      swap(t[i-1], t[i]);\n    }\n  }\n  return false;\n}\n \nmain(){\n  while(cin >> n && n){\n    cin >> d;\n    init();\n    for(int i=0;i<n;i++){\n      string in;\n      cin >> in;\n      dat.push_back(in);\n    }\n    sort(dat.begin(), dat.end());\n    for(int i=0;i<n;i++){\n      vis.clear();\n      calc(dat[i], 0, false);\n      for(int j=i+1;j<n;j++){\n        if(calc(dat[j], 0, true)){\n          ans.push_back(make_pair(dat[i], dat[j]));\n        }\n      }\n    }\n    for(int i=0;i<ans.size();i++){\n      cout << ans[i].first << \",\" << ans[i].second << endl;\n    }\n    cout << ans.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool check(string a,string b,int d){\n  if(a.size()<b.size())swap(a,b);\n  if(a==b) return 1;\n  if(d==0||a.empty())return 0;\n\n\n  //erase\n  for(int i=0;i<a.size()&&a.size()>b.size();i++){\n    string t = a;\n    t.erase(t.begin()+i);\n    if(check(t,b,d-1))return 1;\n  }\n\n  if(a.size()!=b.size()) return 0;\n\n  //swap\n  for(int i=0;i<(int)a.size()-1;i++){\n    swap(a[i],a[i+1]);\n    if(check(a,b,d-1))return 1;\n    swap(a[i],a[i+1]);\n  }\n\n  \n  //change\n  for(int i=0;i<a.size();i++){\n    char ch = a[i];\n    if(a[i]!=b[i]) a[i] = b[i];\n    if(check(a,b,d-1))return 1;\n    a[i] = ch;\n  }\n  return 0;\n}\n\nint main(){\n  int n,d;\n  while(cin>>n,n){\n    cin>>d;\n    string str[201];\n    for(int i=0;i<n;i++)cin>>str[i];\n    sort(str,str+n);\n\n    int cnt=0;    \n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++)\n\tif(check(str[i],str[j],d)) cout<<str[i]<<\",\"<<str[j]<<endl,cnt++;\n    cout<<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint LevenshteinDist(const string& s, const string& t)\n{\n    int n = s.size();\n    int m = t.size();\n    vector<vector<int> > minCost(n+2, vector<int>(m+2, INT_MAX));\n    minCost[0][0] = 0;\n    for(int i=0; i<=n; ++i){\n        for(int j=0; j<=m; ++j){\n            minCost[i+1][j] = min(minCost[i+1][j], minCost[i][j] + 1);\n            minCost[i][j+1] = min(minCost[i][j+1], minCost[i][j] + 1);\n            if(i < n && j < m && s[i] == t[j])\n                minCost[i+1][j+1] = min(minCost[i+1][j+1], minCost[i][j]);\n            else\n                minCost[i+1][j+1] = min(minCost[i+1][j+1], minCost[i][j] + 1);\n        }\n    }\n    return minCost[n][m];\n}\n\nint main()\n{\n    for(;;){\n        int n, d;\n        cin >> n >> d;\n        if(n == 0)\n            return 0;\n\n        vector<string> s(n);\n        for(int i=0; i<n; ++i)\n            cin >> s[i];\n        sort(s.begin(), s.end());\n\n        vector<set<string> > vss(n);\n        for(int i=0; i<n; ++i){\n            int m = s[i].size();\n            /* swap */\n            for(int j=0; j<m; ++j){\n                for(int k=j+1; k<m; ++k){\n                    string t = s[i];\n                    swap(t[j], t[k]);\n                    vss[i].insert(t);\n                }\n            }\n        }\n\n        int ret = 0;\n        for(int i=0; i<n; ++i){\n            for(int j=i+1; j<n; ++j){\n                bool confuse = false;\n\n                if(LevenshteinDist(s[i], s[j]) <= d)\n                    confuse = true;\n\n                set<string>::iterator it1, it2;\n                for(it1=vss[i].begin(); it1!=vss[i].end(); ++it1){\n                    if(LevenshteinDist(*it1, s[j]) <= d-1)\n                        confuse = true;\n                }\n                for(it2=vss[j].begin(); it2!=vss[j].end(); ++it2){\n                    if(LevenshteinDist(s[i], *it2) <= d-1)\n                        confuse = true;\n                }\n\n                if(d == 2){\n                    it1 = vss[i].begin();\n                    it2 = vss[j].begin();\n                    while(it1 != vss[i].end() && it2 != vss[j].end()){\n                        if(*it1 == *it2)\n                            confuse = true;\n                        else if(*it1 < *it2)\n                            ++ it1;\n                        else\n                            ++ it2;\n                    }\n                }\n\n                if(confuse){\n                    cout << s[i] << ',' << s[j] << endl;\n                    ++ ret;\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n\nconst int INF = 1e8;\nint levenshteinDistance(string& s, string& t){\n\tvector<vector<int>> dp(s.size() + 1, vector<int>(t.size() + 1, INF));\n\trep(i, s.size() + 1) dp[i][0] = i;\n\trep(i, t.size() + 1) dp[0][i] = i;\n\n\trange(i,1,s.size() + 1){\n\t\trange(j,1,t.size() + 1){\n\t\t\tint cost = s[i - 1] == t[j - 1] ? 0 : 1;\n\t\t\tdp[i][j] = min({\n\t\t\t\t\tdp[i - 1][j] + 1,\t\t\t// Insertion\n\t\t\t\t\tdp[i][j - 1] + 1,\t\t\t// Deletion\n\t\t\t\t\tdp[i - 1][j - 1] + cost});\t// Replace\n\t\t}\n\t}\n\treturn dp[s.size()][t.size()];\n}\n\nvoid check(set<pair<int,int>>& ans, vector<string>& s, int d, string& t, int i, int j, int cnt){\n\tif(levenshteinDistance(t, s[j]) + cnt <= d){\n\t\tif(t < s[j]) ans.emplace(i, j);\n\t\telse ans.emplace(j,i);\n\t}\n}\n\nvoid ansEmplace(set<pair<int, int>>& ans, vector<string>& s, int i, int j){\n\tif(s[i] < s[j]) ans.emplace(i,j);\n\telse ans.emplace(j,i);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tint d;\n\t\tcin >> d;\n\n\t\tvector<string> s(n);\n\t\trep(i,n){\n\t\t\tcin >> s[i];\n\t\t}\n\n\t\tset<pair<int,int>> ans;\n\n\t\t// swap回数が0のとき\n\t\trep(i,n){\n\t\t\trange(j,i + 1,n){\n\t\t\t\tif(levenshteinDistance(s[i], s[j]) <= d){\n\t\t\t\t\tansEmplace(ans, s, i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// swap回数が1のとき\n\t\tif(d >= 1){\n\t\t\trep(i,n){\n\t\t\t\tvector<string> ss;\n\t\t\t\trep(j, s[i].size() - 1){\n\t\t\t\t\tstring t = s[i];\n\t\t\t\t\tswap(t[j], t[j + 1]);\n\t\t\t\t\tss.emplace_back(t);\n\t\t\t\t}\n\n\t\t\t\trep(j,ss.size()){\n\t\t\t\t\trange(k,i + 1,n){\n\t\t\t\t\t\tif(levenshteinDistance(ss[j], s[k]) <= d - 1){\n\t\t\t\t\t\t\tansEmplace(ans, s, i, k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// swap回数が2のとき\n\t\tif(d >= 2){\n\t\t\trep(i,n){\n\t\t\t\trep(j,s[i].size()){\n\t\t\t\t\trep(k,s[i].size()){\n\t\t\t\t\t\tstring t = s[i];\n\t\t\t\t\t\tswap(t[j], t[j + 1]);\n\t\t\t\t\t\tswap(t[k], t[k + 1]);\n\n\t\t\t\t\t\trange(l,i + 1,n){\n\t\t\t\t\t\t\tif(t == s[l]){\n\t\t\t\t\t\t\t\tansEmplace(ans, s, i, l);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<pair<string,string>> v;\n\n\t\tfor(auto p : ans){\n\t\t\tv.emplace_back(s[p.first],s[p.second]);\n\t\t}\n\t\tsort(all(v));\n\t\tfor(auto p : v){\n\t\t\tcout << p.first << ',' << p.second << endl;\n\t\t}\n\t\tcout << v.size() << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <stdlib.h>\n\nusing namespace std;\n\nint n, d;\nvector<string> vec;\n\nbool contain(string &a, string &b)\n{\n\tstring s, t;\n\tif(a.size() > b.size()) s = a, t = b;\n\telse s = b, t = a;\n\t\n\tint pos = 0;\n\tfor(int i = 0; i < s.size(); i++){\n\t\tif(pos < t.size() && s[i] == t[pos]) pos++;\n\t}\n\treturn pos >= t.size();\n}\n\nbool check(string &s, string &t, int d)\n{\n\tint dif = 0;\n\tvector<int> vec;\n\t\n\tfor(int i = 0; i < s.size(); i++){\n\t\tif(s[i] != t[i]){\n\t\t\tdif++;\n\t\t\tvec.push_back(i);\n\t\t}\n\t}\n\t\n\tif(dif <= d) return true;\n\tif(dif > 2*d) return false;\n\t\n\tif(d == 1){\n\t\treturn vec[0] + 1 == vec[1] && s[vec[0]] == t[vec[1]] && s[vec[1]] == t[vec[0]];\n\t}\n\tif(d == 2){\n\t\tif(dif == 4){\n\t\t\treturn (vec[0] + 1 == vec[1] && s[vec[0]] == t[vec[1]] && s[vec[1]] == t[vec[0]])\n\t\t\t&& (vec[2] + 1 == vec[3] && s[vec[2]] == t[vec[3]] && s[vec[3]] == t[vec[2]]);\n\t\t}\n\t\tif(dif == 3){\n\t\t\tif(vec[0] + 1 != vec[1]) \n\t\t\t\treturn (vec[1] + 1 == vec[2] && s[vec[1]] == t[vec[2]] && s[vec[2]] == t[vec[1]]);\n\t\t\tif(vec[1] + 1 != vec[2]) \n\t\t\t\treturn (vec[0] + 1 == vec[1] && s[vec[0]] == t[vec[1]] && s[vec[1]] == t[vec[0]]);\n\t\t\t\n\t\t\tif(s[vec[0]] == t[vec[1]] && s[vec[1]] == t[vec[0]]) return true;\n\t\t\tif(s[vec[1]] == t[vec[2]] && s[vec[2]] == t[vec[1]]) return true;\n\t\t\tif(s[vec[0]] == t[vec[1]] && s[vec[1]] == t[vec[2]] && s[vec[2]] == t[vec[0]]) return true;\n\t\t\tif(s[vec[0]] == t[vec[1]] && s[vec[1]] == t[vec[2]] && s[vec[2]] == t[vec[0]]) return true;\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tcin >> d;\n\t\t\n\t\tstring s;\n\t\tvec.clear();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> s;\n\t\t\tvec.push_back(s);\n\t\t}\n\t\tsort(vec.begin(), vec.end());\n\t\t\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < vec.size(); i++){\n\t\t\tfor(int j = 0; j < vec.size(); j++){\n\t\t\t\tif(i >= j) continue;\n\t\t\t\t\n\t\t\t\tint dif = abs((int)vec[i].size() - (int)vec[j].size());\n\t\t\t\tif(dif > d) continue;\n\t\t\t\tif(dif == d) if(contain(vec[i], vec[j])) goto NEAR;\n\t\t\t\t\n\t\t\t\tif(d == 2 && dif == 1){\n\t\t\t\t\tstring s, t;\n\t\t\t\t\tif(vec[i].size() > vec[j].size()) s = vec[i], t = vec[j];\n\t\t\t\t\telse s = vec[j], t = vec[i];\n\t\t\t\t\tfor(int k = 0; k < s.size(); k++){\n\t\t\t\t\t\tstring u = s.substr(0, k) + s.substr(k+1);\n\t\t\t\t\t\tif(check(u, t, 1)) goto NEAR;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(check(vec[i], vec[j], d)) goto NEAR;\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tNEAR:;\n\t\t\t\tcnt++;\n\t\t\t\tcout << vec[i] << \",\" << vec[j] << endl;\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint edit_dist(const string& s, const string& t, int B){\n  int l1 = s.size();\n  int l2 = t.size();\n  int dp[32][32] = {};\n  REP(i, l1) dp[i + 1][0] = i + 1;\n  REP(j, l2) dp[0][j + 1] = j + 1;\n  REP(i, l1) {\n    int min_d = INF;\n    REP(j, l2){\n      if(s[i] == t[j]) dp[i + 1][j + 1] = dp[i][j];\n      else dp[i + 1][j + 1] = min(dp[i][j], min(dp[i + 1][j], dp[i][j + 1])) + 1;\n      min_d = min(min_d, dp[i + 1][j + 1]);\n    }\n    //if(min_d > B) return B + 1;\n  }\n  return dp[l1][l2];\n}\nbool check(string s, string t, int D){\n  if(D == 0){\n    if(s == t) return true;\n  }else if(D == 1){\n    if(edit_dist(s, t, 1) <= 1) return true;\n    if(s.size() == t.size()) REP(i, s.size()) FOR(j, i + 1, s.size()){\n      swap(s[i], s[j]);\n      if(s == t) return true;\n      swap(s[i], s[j]);\n    }\n  }else if(D == 2){\n    if(edit_dist(s, t, 2) <= 2) return true;\n    REP(i, s.size()) FOR(j, i + 1, s.size()){\n      swap(s[i], s[j]);\n      if(edit_dist(s, t, 1) <= 1) return true;\n      if(s.size() == t.size()) REP(k, s.size()) if(s[k] != t[k]) FOR(l, k + 1, s.size()) if(s[l] != t[l]) {\n        swap(s[k], s[l]);\n        if(s == t) return true;\n        swap(s[k], s[l]);\n      }\n      swap(s[i], s[j]);\n    }\n  }else {\n    assert(false);\n  }\n  return false;\n}\nint main(){\n  int N, D;\n  while(cin >> N >> D && N){\n    vector<string> name(N);\n    REP(i, N) cin >> name[i];\n    vector< pair<string, string> > ans;\n    REP(i, N) FOR(j, i + 1, N){\n      if(check(name[i], name[j], D)) ans.push_back(make_pair( min(name[i], name[j]), max(name[i], name[j]) ));\n    }\n    sort(ans.begin(), ans.end());\n    REP(i, ans.size()){\n      printf(\"%s,%s\\n\", ans[i].first.c_str(), ans[i].second.c_str());\n    }\n    printf(\"%d\\n\", (int)ans.size());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<cstdio>\n#include<algorithm>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\nusing namespace std;\n\nint main(){\n  int n, d;\n  while(cin >> n >> d){\n    vector<string> name(n);\n    REP(i,n) cin >> name[i];\n    sort(name.begin(), name.end());\n\n    map<string, set<pair<int, int> > > conflict;\n\n    typedef pair<int, pair<int,string> > data;\n    queue<data> que;\n\n    REP(i,n){\n      que.push(make_pair(0, make_pair(i, name[i])));\n    }\n\n    while(que.size()){\n      data dt = que.front(); que.pop();\n      int cnt                = dt.first;\n      const int &original    = dt.second.first;\n      const string &modified = dt.second.second;\n\n      if(conflict[modified].count(make_pair(original, cnt)) != 0) continue;\n\n      conflict[modified].insert(make_pair(original, cnt));\n\n      if(cnt < (d == 0 ? 0 : 1)){\n        // swap\n        for(int i = 0; i < modified.size(); i++){\n          for(int j = i + 1; j < modified.size(); j++){\n            string str = modified; swap(str[i], str[j]);\n            que.push(make_pair(cnt + 1, make_pair(original, str)));\n          }\n        }\n        // delete\n        for(int i = 0; i < modified.size(); i++){\n          string str = modified; str.erase(str.begin() + i);\n          que.push(make_pair(cnt + 1, make_pair(original, str)));\n        }\n        // insert\n        for(int i = 0; i <= modified.size(); i++){\n          for(int j = 'a'; j <= 'z'; j++){\n            string str = modified; str.insert(str.begin() + i, (char)j);\n            que.push(make_pair(cnt + 1, make_pair(original, str)));\n          }\n        }\n        // modify\n        for(int i = 0; i < modified.size(); i++){\n          for(int j = 'a'; j <= 'z'; j++){\n            string str = modified; str[i] = j;\n            que.push(make_pair(cnt + 1, make_pair(original, str)));\n          }\n        }\n      }\n    }\n\n    set<pair<int, int> > ans;\n    FOR(it, conflict) if(it->second.size() > 1){\n      vector<pair<int, int> > tmp(it->second.begin(), it->second.end());\n      const int sz = tmp.size();\n\n      for(int i = 0; i < sz; i++)\n        for(int j = i + 1; j < sz; j++)\n          if(tmp[i].first != tmp[j].first && tmp[i].second + tmp[j].second <= d)\n            ans.insert(make_pair(tmp[i].first, tmp[j].first));\n    }\n\n    FOR(it, ans){\n      cout << name[it->first] << \",\" << name[it->second] << endl;\n    }\n    cout << ans.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<string,string> P;\n\nint n,d;\nint ans=0;\nset<string> mp[201];\nint cnt[201];\nvector<P> vec;\nstring str[201];\nqueue<int> que;\n\nvoid dfs(int v,string s,int nd,int uk=0){\n\tif(nd==0){\n\t\tint r=que.size();\n\t\tfor(int i=0;i<r;i++){\n\t\t\tint nv=que.front();\n\t\t\tque.pop();\n\t\t\tif(mp[nv].find(s)!=mp[nv].end()){\n\t\t\t\tcnt[nv]++;\n\t\t\t}else{\n\t\t\t\tque.push(nv);\n\t\t\t}\n\t\t}\n\t\tmp[v].insert(s);\n\t\tfor(int i=0;i+1<s.size();i++){\n\t\t\tswap(s[i],s[i+1]);\n\t\t\tdfs(v,s,nd+1);\n\t\t\tswap(s[i],s[i+1]);\n\t\t}\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tdfs(v,s.substr(0,i)+s.substr(i+1),nd+1);\n\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\tstring gu=\"\";\n\t\t\t\tgu+=('a'+j);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i+1),nd+1,1);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i),nd+1,1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<26;i++){\n\t\t\tstring gu=\"\";\n\t\t\tgu+=('a'+i);\n\t\t\tdfs(v,s+gu,nd+1);\n\t\t}\n\t}else if(nd==1){\n\t\tmp[v].insert(s);\n\t\tif(d==2 && uk==0){\n\t\t\tint r=que.size();\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tint nv=que.front();\n\t\t\t\tque.pop();\n\t\t\t\tif(mp[nv].find(s)!=mp[nv].end()){\n\t\t\t\t\tcnt[nv]++;\n\t\t\t\t}else{\n\t\t\t\t\tque.push(nv);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tvec.clear();\n\tfor(int i=0;i<n;i++){\n\t\tmp[i].clear();\n\t}\n\tscanf(\"%d\",&d);\n\tans=0;\n\tfor(int i=0;i<n;i++){\n\t\tmemset(cnt,0,sizeof(cnt));\n\t\tcin >> str[i];\n\t\twhile(que.size())que.pop();\n\t\tfor(int j=0;j<i;j++){\n\t\t\tque.push(j);\n\t\t}\n\t\tdfs(i,str[i],0);\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(cnt[j]>0){\n\t\t\t\tans++;\n\t\t\t\tvec.push_back(P(min(str[i],str[j]),max(str[i],str[j])));\n\t\t\t}\n\t\t}\n\t}\n\tsort(vec.begin(),vec.end());\n\tfor(int i=0;i<vec.size();i++){\n\t\tcout << vec[i].first << \",\" << vec[i].second << endl;\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 201\ntypedef pair<string,string> P;\n\nstruct Trie{\n  bool l;\n  Trie *next[26];\n  \n  Trie(){\n    l = false;\n    fill(next,next+26,(Trie *)0);\n  }\n  \n  int c(char ch){\n    if(islower(ch)){\n      return ch-'a';\n    }\n    return -1;\n  }\n  \n  void insert(string &s){\n    Trie *t = this;\n    for(int i = 0 ; i < (int)s.size() ; i++){\n      int v = c(s[i]);\n      if(!t->next[v]){\n        t->next[v] = new Trie;\n      }\n      t = t->next[v];\n    }\n    t->l = true;\n  }\n  \n  bool find(string &s){\n    Trie *t = this;\n    for(int i = 0 ; i < (int)s.size() ; i++){\n      int v = c(s[i]);\n      if(!t->next[v]){ return false; }\n      t = t->next[v];\n    }\n    return t->l;\n  }\n};\n\nint N,D,idx;\nstring s[MAX];\nmap<int,set<string> > mp;\nvector<P> vec;\n\nvoid dfs(string now,int step){\n  if(step == 1){\n    mp[idx].insert(now);\n    return;\n  }\n  \n  int len = now.size();\n  // delete\n  for(int i = 0 ; i < len ; i++){\n    string tmp = now;\n    tmp.erase(tmp.begin()+i);\n    dfs(tmp,step+1);\n  }\n \n  // swap\n  for(int i = 0 ; i < len-1 ; i++){\n    swap(now[i],now[i+1]);\n    dfs(now,step+1);\n    swap(now[i],now[i+1]);\n  }\n\n  // insert\n  for(char ch = 'a' ; ch <= 'z' ; ch++){\n    for(int j = 0 ; j < len+1 ; j++){\n      string tmp = now;\n      tmp = tmp.substr(0,j) + ch + tmp.substr(j);\n      dfs(tmp,step+1);\n    }\n  }\n \n  // replace\n  for(char ch = 'a' ; ch <= 'z' ; ch++){\n    for(int j = 0 ; j < len ; j++){\n      char c = now[j];\n      now[j] = ch;\n      dfs(now,step+1);\n      now[j] = c;\n    }\n  }\n}\n\nvoid init(){\n  mp.clear();\n  vec.clear();\n}\n\nint main(){\n  while(cin >> N, N){\n    cin >> D;\n    init();\n    for(int i = 0 ; i < N ; i++){\n      cin >> s[i];\n    }\n    for(int i = 0 ; i < N ; i++){\n      idx = i;\n      dfs(s[i],0);\n    }\n\n    vector<string> v[MAX];\n    for(int i = 0 ; i < N ; i++){\n      set<string> st = mp[i];\n      set<string>::iterator it;\n      for(it = st.begin() ; it != st.end() ; ++it){\n        v[i].push_back(*it);\n      }\n    } \n\n    if(D == 1){\n      for(int i = 0 ; i < N ; i++){\n        Trie trie;\n        for(int j = 0 ; j < (int)v[i].size() ; j++){\n          trie.insert(v[i][j]);\n        }\n        for(int j = i+1 ; j < N ; j++){\n          if(trie.find(s[j])){\n            vec.push_back(P(s[i],s[j]));\n          }\n        }\n      }\n    }else{\n      for(int i = 0 ; i < N ; i++){\n        Trie trie;\n        for(int j = 0 ; j < (int)v[i].size() ; j++){\n          trie.insert(v[i][j]);\n        }\n        for(int j = i+1 ; j < N ; j++){\n          for(int k = 0 ; k < (int)v[j].size() ; k++){\n            if(trie.find(v[j][k])){\n              vec.push_back(P(s[i],s[j]));\n              break;\n            }\n          }\n        }\n      }\n    }\n    int len = vec.size();\n    for(int i = 0 ; i < len ; i++){\n      if(vec[i].first > vec[i].second){\n        swap(vec[i].first,vec[i].second);\n      }\n    }\n    sort(vec.begin(),vec.end());\n    for(int i = 0 ; i < len ; i++){\n      cout << vec[i].first << \",\" << vec[i].second << endl;\n    }\n    cout << len << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\nchar in[20];\nstring str[210];\nvector<string> lis[210];\nchar ch[2];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tint b;scanf(\"%d\",&b);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tstr[i]=in;\n\t\t}\n\t\tstd::sort(str,str+a);\n\t\tfor(int i=0;i<a;i++)lis[i].clear();\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=0;j<str[i].size();j++){\n\t\t\t\tstring tmp=str[i].substr(0,j)+str[i].substr(j+1);\n\t\t\t\tlis[i].push_back(tmp);\n\t\t\t}\n\t\t\tfor(int j=0;j<=str[i].size();j++){\n\t\t\t\tfor(int k=0;k<26;k++){\n\t\t\t\t\tstring tmp=str[i].substr(0,j);\n\t\t\t\t\tch[0]='a'+k;\n\t\t\t\t\ttmp.append(ch);\n\t\t\t\t\ttmp.append(str[i].substr(j));\n\t\t\t\t\tlis[i].push_back(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<str[i].size();j++){\n\t\t\t\tchar rev=str[i][j];\n\t\t\t\tfor(int k=0;k<26;k++){\n\t\t\t\t\tstr[i][j]='a'+k;\n\t\t\t\t\tlis[i].push_back(str[i]);\n\t\t\t\t}\n\t\t\t\tstr[i][j]=rev;\n\t\t\t}\n\t\t\tfor(int j=0;j<str[i].size()-1;j++){\n\t\t\t\tswap(str[i][j],str[i][j+1]);\n\t\t\t\tlis[i].push_back(str[i]);\n\t\t\t\tswap(str[i][j],str[i][j+1]);\n\t\t\t}\n\t\t\tstd::sort(lis[i].begin(),lis[i].end());\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=i+1;j<a;j++){\n\t\t\t\tbool ok=false;\n\t\t\t\tif(b==1){\n\t\t\t\t\tif(binary_search(lis[i].begin(),lis[i].end(),str[j]))ok=true;\n\t\t\t\t}else{\n\t\t\t\t\tfor(int k=0;k<lis[j].size();k++){\n\t\t\t\t\t\tif(binary_search(lis[i].begin(),lis[i].end(),lis[j][k])){\n\t\t\t\t\t\t\tok=true;break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok){\n\t\t\t\t\tret++;\n\t\t\t\t\tprintf(\"%s,%s\\n\",str[i].c_str(),str[j].c_str());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n\null B=10000007;\nint n,d,len;\nchar s[200][15];\null t[200];\nint G[200][200];\nbool f[200][200];\nmap<ull,bool> mp[200];\n\nstruct data{\n  int fi,se;\n  bool operator < (const data &d)const{\n    return (G[fi][d.fi]!=0?G[fi][d.fi]<0:G[se][d.se]<0);\n  }\n};\n\nvector< data > v;\n\null Deleting(int x,char* ch){\n  ull res=0;\n  for(int i=0;i<len;i++)\n    if(i!=x)res=res*B+ch[i];\n  return res;\n}\n\null Inserting(int x,char y,char* ch){\n  ull res=0;\n  for(int i=0;i<=len;i++){\n    if(i==x)res=res*B+y;\n    if(i<len)res=res*B+ch[i];\n  }\n  return res;\n}\n\null Replacing(int x,char y,char* ch){\n  ull res=0;\n  for(int i=0;i<len;i++){\n    if(i==x)res=res*B+y;\n    else res=res*B+ch[i];\n  }\n  return res;\n}\n\null Swapping(int x,char* ch){\n  ull res=0;\n  for(int i=0;i<len;i++){\n    if(i==x)res=res*B+ch[i+1];\n    else if(i==x+1)res=res*B+ch[x];\n    else res=res*B+ch[i];\n  }\n  return res;\n}\n\nvoid init(){\n  for(int i=0;i<200;i++){\n    mp[i].clear();\n  }\n  v.clear();\n  memset(f,false,sizeof(f));\n}\n\nint main(){\n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    init();\n    scanf(\"%d\",&d);\n\n    for(int i=0;i<n;i++){\n      scanf(\"%s\",s[i]);\n      len=strlen(s[i]);\n\n      t[i]=Swapping(-10,s[i]);\n      \n      for(int j=0;j<len;j++){\n        mp[i][Deleting(j,s[i])]=true;\n      }\n      \n      for(int j=0;j<=len;j++){\n        for(char k='a';k<='z';k++){\n          mp[i][Inserting(j,k,s[i])]=true;\n        }\n      }\n      \n      for(int j=0;j<len;j++){\n        for(char k='a';k<='z';k++){\n          if(s[i][j]!=k){\n            mp[i][Replacing(j,k,s[i])]=true;\n          }\n        }\n      }\n      \n      for(int j=0;j+1<len;j++){\n        mp[i][Swapping(j,s[i])]=true;\n      }\n    }\n\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n        G[i][j]=strcmp(s[i],s[j]);\n    \n    for(int i=1;i<n;i++){\n      for(int j=0;j<i;j++){\n        int a=i,b=j;\n        if(G[a][b]>0)swap(a,b);\n        if( mp[a][ t[b] ] == true && !f[a][b] ){\n          v.push_back( (data){a,b} );\n          f[a][b]=true;\n        }\n        if(d==1)continue;\n        map<ull,bool> :: iterator it;\n        for(it=mp[b].begin();it!=mp[b].end();it++){\n          if( mp[a][it->first] == true && !f[a][b] ){\n            v.push_back( (data){a,b} );\n            f[a][b]=true;\n          }\n        }\n      }\n    }\n    sort( v.begin() , v.end() );\n    for(int i=0;i<(int)v.size();i++){\n      printf(\"%s,%s\\n\",s[v[i].fi],s[v[i].se]);\n    }\n    printf(\"%d\\n\",(int)v.size());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tchar buf[20];\n};\n\nstruct Data{\n\tchar left[20],right[20];\n};\n\nint N,DIST;\nInfo info[200];\nvector<Info> V[200];\nbool check[200][200];\n\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nint strCmp2(char* left,char* right){\n\tint i;\n\n\tif(strCmp(left,right))return 3;\n\n\tfor(i=0;left[i] != '\\0' && right[i] != '\\0'; i++){\n\t\tif(left[i] != right[i]){\n\t\t\tif(left[i] < right[i])return 1;\n\t\t\telse{\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\t}\n\tif(left[i] == '\\0')return 1;\n\telse{\n\t\treturn 2;\n\t}\n}\n\n\nvoid makeDist1(int id){\n\n\tchar work[20];\n\n\tint length,index;\n\tfor(length = 0; info[id].buf[length] != '\\0'; length++);\n\n\tfor(int del_loc = 0; del_loc < length; del_loc++){\n\t\tindex = 0;\n\t\tfor(int i = 0; i < length; i++){\n\t\t\tif(i == del_loc)continue;\n\t\t\twork[index++] = info[id].buf[i];\n\t\t}\n\t\twork[index] = '\\0';\n\t\tInfo new_info;\n\t\tstrcpy(new_info.buf,work);\n\t\tV[id].push_back(new_info);\n\t}\n\n\tfor(int word = 0; word < 26; word++){\n\t\tfor(int loc = 0; loc <= length; loc++){\n\t\t\tindex = 0;\n\t\t\tfor(int i = 0; i < loc; i++){\n\t\t\t\twork[index++] = info[id].buf[i];\n\t\t\t}\n\t\t\twork[index++] = 'a'+word;\n\t\t\tfor(int i = loc; i < length; i++){\n\t\t\t\twork[index++] = info[id].buf[i];\n\t\t\t}\n\t\t\twork[index] = '\\0';\n\t\t\tInfo new_info;\n\t\t\tstrcpy(new_info.buf,work);\n\t\t\tV[id].push_back(new_info);\n\t\t}\n\t}\n\n\tfor(int word = 0; word < 26; word++){\n\t\tfor(int loc = 0; loc < length; loc++){\n\t\t\tindex = 0;\n\t\t\tfor(int i = 0; i < length; i++){\n\t\t\t\tif(i != loc){\n\t\t\t\t\twork[index++] = info[id].buf[i];\n\t\t\t\t}else{\n\t\t\t\t\twork[index++] = 'a'+word;\n\t\t\t\t}\n\t\t\t}\n\t\t\twork[index] = '\\0';\n\t\t\tInfo new_info;\n\t\t\tstrcpy(new_info.buf,work);\n\t\t\tV[id].push_back(new_info);\n\t\t}\n\t}\n\n\tfor(int a = 0; a < length-1; a++){\n\t\tfor(int b = 0; b < length; b++){\n\t\t\tindex = 0;\n\t\t\tfor(int i = 0; i < length; i++){\n\t\t\t\twork[index++] = info[id].buf[i];\n\t\t\t}\n\t\t\tswap(work[a],work[b]);\n\t\t\twork[index] = '\\0';\n\t\t\tInfo new_info;\n\t\t\tstrcpy(new_info.buf,work);\n\t\t\tV[id].push_back(new_info);\n\t\t}\n\t}\n\n}\n\nvoid func(){\n\n\tscanf(\"%d\",&DIST);\n\n\tfor(int i = 0; i < N; i++)V[i].clear();\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%s\",info[i].buf);\n\t\tmakeDist1(i);\n\t}\n\n\tvector<Data> ANS;\n\tbool FLG;\n\n\tfor(int i = 0; i < N-1; i++){\n\t\tfor(int k = i+1; k < N; k++)check[i][k] = false;\n\t}\n\n\tif(DIST == 1){\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int p = i+1; p < N; p++){\n\t\t\t\tfor(int k = 0; k < V[i].size(); k++){\n\t\t\t\t\tif(strCmp(V[i][k].buf,info[p].buf)){\n\t\t\t\t\t\tcheck[i][p] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}else{\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int p = i+1; p < N; p++){\n\t\t\t\tFLG = false;\n\t\t\t\tfor(int k = 0; k < V[i].size(); k++){\n\t\t\t\t\tif(strCmp(V[i][k].buf,info[p].buf)){\n\t\t\t\t\t\tcheck[i][p] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int q = 0; q < V[p].size(); q++){\n\t\t\t\t\t\tif(strCmp(V[i][k].buf,V[p][q].buf)){\n\t\t\t\t\t\t\tcheck[i][p] = true;\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(FLG)break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N-1; i++){\n\t\tfor(int p = i+1; p < N; p++){\n\t\t\tif(check[i][p]){\n\t\t\t\tData data;\n\t\t\t\tif(strCmp2(info[i].buf,info[p].buf) == 1){\n\t\t\t\t\tstrcpy(data.left,info[i].buf);\n\t\t\t\t\tstrcpy(data.right,info[p].buf);\n\t\t\t\t}else{\n\t\t\t\t\tstrcpy(data.right,info[i].buf);\n\t\t\t\t\tstrcpy(data.left,info[p].buf);\n\t\t\t\t}\n\t\t\t\tANS.push_back(data);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i < ANS.size(); i++){\n\t\tfor(int k = ANS.size()-1; k >= i; k--){\n\t\t\tif(strCmp2(ANS[k].left,ANS[k-1].left) == 1){\n\t\t\t\tswap(ANS[k],ANS[k-1]);\n\t\t\t}else if(strCmp2(ANS[k].left,ANS[k-1].left) == 3 && strCmp2(ANS[k].right,ANS[k-1].right) == 1){\n\t\t\t\tswap(ANS[k],ANS[k-1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < ANS.size(); i++){\n\t\tprintf(\"%s,%s\\n\",ANS[i].left,ANS[i].right);\n\t}\n\tprintf(\"%lld\\n\",ANS.size());\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define REP(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define ALL(x) begin(x), end(x)\n\nbool dfs(int rest, size_t s_idx, size_t t_idx, string &s, string &t) {\n\tif(s_idx == s.size() && t_idx == t.size()) return true;\n\tif(s_idx == s.size()) return t.size() - t_idx <= rest;\n\tif(t_idx == t.size()) return s.size() - s_idx <= rest;\n\n\tif(s[s_idx] == t[t_idx]) return dfs(rest, s_idx + 1, t_idx + 1, s, t);\n\n\tif(rest == 0) return false;\n\tif(dfs(rest - 1, s_idx + 1, t_idx, s, t)) return true; // delete\n\tif(dfs(rest - 1, s_idx, t_idx + 1, s, t)) return true; // insert\n\tif(dfs(rest - 1, s_idx + 1, t_idx + 1, s, t)) return true; // replace\n\n\t// swap\n\tif(s_idx + 1 < s.size() && t_idx + 1 < t.size() && s[s_idx] == t[t_idx + 1] && s[s_idx + 1] == t[t_idx]) {\n\t\tif(dfs(rest - 1, s_idx + 2, t_idx + 2, s, t)) return true;\n\t}\n\n\tif(rest == 2) { // delete and swap\n\t\tif(s_idx + 2 < s.size() && s[s_idx + 2] == t[t_idx]) {\n\t\t\tswap(s[s_idx], s[s_idx + 2]);\n\t\t\tconst bool ok = dfs(rest - 2, s_idx + 2, t_idx + 1, s, t);\n\t\t\tswap(s[s_idx], s[s_idx + 2]);\n\t\t\tif(ok) return true;\n\t\t}\n\n\t\tif(t_idx + 2 < t.size() && s[s_idx] == t[t_idx + 2]) {\n\t\t\tswap(t[t_idx], t[t_idx + 2]);\n\t\t\tconst bool ok = dfs(rest - 2, s_idx + 1, t_idx + 2, s, t);\n\t\t\tswap(t[t_idx], t[t_idx + 2]);\n\t\t\tif(ok) return true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n && n;) {\n\t\tint d;\n\t\tcin >> d;\n\n\t\tvector<string> name(n);\n\t\tfor(auto &e : name) cin >> e;\n\n\t\tvector<string> ans;\n\t\trep(i, n) {\n\t\t\trep(j, i) {\n\t\t\t\tif(dfs(d, 0, 0, name[i], name[j])) {\n\t\t\t\t\tif(name[i] < name[j]) {\n\t\t\t\t\t\tans.emplace_back(name[i] + \",\" + name[j]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tans.emplace_back(name[j] + \",\" + name[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsort(ALL(ans));\n\t\tfor(const auto &s : ans) {\n\t\t\tcout << s << endl;\n\t\t}\n\t\tcout << ans.size() << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<string,string> P;\n\nint N, D;\nstring t[202];\nvector<string> vecs[202];\n\nvoid change(string s, vector<string> &st){\n  st.clear();\n\n  int n = s.size();\n\n  //delete\n  for(int i = 0; i < n; i++){\n    string s2 = s;\n    s2.erase(s2.begin() + i);\n    st.push_back(s2);\n  }\n\n  for(char ch = 'a'; ch <= 'z'; ch++){\n    //insert\n    for(int i = 0; i <= n; i++){\n      string s2 = s;\n      s2.insert(s2.begin() + i, ch);\n      st.push_back(s2);\n    }\n\n    //replace\n    for(int i = 0; i < n; i++){\n      string s2 = s;\n      s2[i] = ch;\n      st.push_back(s2);\n    }\n  }\n\n  //swap\n  for(int i = 0; i < n - 1; i++){\n    string s2 = s;\n    swap(s2[i], s2[i + 1]);\n    st.push_back(s2);\n  }\n}\n\nint main(){\n  while(cin >> N >> D){\n    for(int i = 0; i < N; i++){\n      cin >> t[i];\n      change(t[i], vecs[i]);\n      sort(vecs[i].begin(), vecs[i].end());\n    }\n\n    vector<P> vt;\n\n    for(int i = 0; i < N; i++){\n      for(int j = i + 1; j < N; j++){\n        bool flg = false;\n\n        if(binary_search(vecs[j].begin(), vecs[j].end(), t[i])){\n          flg = true;\n        }\n\n        if(!flg && D == 2){\n          for(int k = 0; k < vecs[i].size(); k++){\n            if(binary_search(vecs[j].begin(), vecs[j].end(), vecs[i][k])){\n              flg = true;\n              break;\n            }\n          }\n        }\n\n        if(flg){\n          if(t[i] < t[j]) vt.push_back(P(t[i], t[j]));\n          else            vt.push_back(P(t[j], t[i]));\n        }\n      }\n    }\n\n    sort(vt.begin(), vt.end());\n\n    for(int i = 0; i < vt.size(); i++){\n      cout << vt[i].first << \",\" << vt[i].second << endl;\n    }\n    cout << vt.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n){\n    int d;\n    vector<string> name(n);\n    cin >> d;\n    rep(i,0,n) cin >> name[i];\n    sort(name.begin(),name.end());\n\n    function<void(const int,const string&,map<string,bool>&)> enumerate_neighborhood=[&](int d,const string &s,map<string,bool> &mp){\n        if(d==0){\n            if(mp.find(s)!=mp.end()) mp[s]=true;\n            return;\n        }\n        //replace\n        {\n            string t=s;\n            rep(i,0,s.size()){\n                rep(j,0,26){\n                    t[i]='a'+j;\n                    enumerate_neighborhood(d-1,t,mp);\n                }\n                t[i]=s[i];\n            }\n        }\n        //insert\n        {\n            string x;\n            rep(i,0,s.size()+1){\n                string y=s.substr(i);\n                rep(j,0,26){\n                    x.push_back('a'+j);\n                    auto t=x+y;\n                    enumerate_neighborhood(d-1,t,mp);\n                    x.pop_back();\n                }\n                x+=s[i];\n            }\n        }\n        //delete\n        {\n            string x;\n            rep(i,0,s.size()){\n                string t=x+s.substr(i+1);\n                enumerate_neighborhood(d-1,t,mp);\n                x+=s[i];\n            }\n        }\n        //swap adjacent\n        {\n            string t=s;\n            rep(i,0,s.size()-1){\n                swap(t[i],t[i+1]);\n                enumerate_neighborhood(d-1,t,mp);\n                swap(t[i],t[i+1]);\n            }\n        }\n    };\n\n    int count=0;\n    rep(i,0,n){\n        map<string,bool> mp;\n        rep(j,i+1,n) mp[name[j]]=false;\n        enumerate_neighborhood(d,name[i],mp);\n        rep(j,i+1,n){\n            if(!mp[name[j]]) continue;\n            cout << name[i] << \",\" << name[j] << endl;\n            ++count;\n        }\n    }\n    cout << count << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n\nconst int INF = 1e8;\nint levenshteinDistance(string& s, string& t){\n\tvector<vector<int>> dp(s.size() + 1, vector<int>(t.size() + 1, INF));\n\trep(i, s.size() + 1) dp[i][0] = i;\n\trep(i, t.size() + 1) dp[0][i] = i;\n\n\trange(i,1,s.size() + 1){\n\t\trange(j,1,t.size() + 1){\n\t\t\tint cost = s[i - 1] == t[j - 1] ? 0 : 1;\n\t\t\tdp[i][j] = min({\n\t\t\t\t\tdp[i - 1][j] + 1,\t\t\t// Insertion\n\t\t\t\t\tdp[i][j - 1] + 1,\t\t\t// Deletion\n\t\t\t\t\tdp[i - 1][j - 1] + cost});\t// Replace\n\t\t}\n\t}\n\treturn dp[s.size()][t.size()];\n}\n\nvoid check(set<pair<int,int>>& ans, vector<string>& s, int d, string& t, int i, int j, int cnt){\n\tif(levenshteinDistance(t, s[j]) + cnt <= d){\n\t\tif(t < s[j]) ans.emplace(i, j);\n\t\telse ans.emplace(j,i);\n\t}\n}\n\nvoid ansEmplace(set<pair<int, int>>& ans, vector<string>& s, int i, int j){\n\tif(s[i] < s[j]) ans.emplace(i,j);\n\telse ans.emplace(j,i);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tint d;\n\t\tcin >> d;\n\n\t\tvector<string> s(n);\n\t\trep(i,n){\n\t\t\tcin >> s[i];\n\t\t}\n\n\t\tset<pair<int,int>> ans;\n\n\t\t// swap回数が0のとき\n\t\trep(i,n){\n\t\t\trange(j,i + 1,n){\n\t\t\t\tif(levenshteinDistance(s[i], s[j]) <= d){\n\t\t\t\t\tansEmplace(ans, s, i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// swap回数が1のとき\n\t\tif(d >= 1){\n\t\t\trep(i,n){\n\t\t\t\tvector<string> ss;\n\t\t\t\trep(j, s[i].size() - 1){\n\t\t\t\t\tstring t = s[i];\n\t\t\t\t\tswap(t[j], t[j + 1]);\n\t\t\t\t\tss.emplace_back(t);\n\t\t\t\t}\n\n\t\t\t\trep(j,ss.size()){\n\t\t\t\t\trange(k,i + 1,n){\n\t\t\t\t\t\tif(levenshteinDistance(ss[j], s[k]) <= d - 1){\n\t\t\t\t\t\t\tansEmplace(ans, s, i, k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// swap回数が2のとき\n\t\tif(d >= 2){\n\t\t\trep(i,n){\n\t\t\t\trep(j,s[i].size()){\n\t\t\t\t\trep(k,s[i].size()){\n\t\t\t\t\t\tstring t = s[i];\n\t\t\t\t\t\tswap(t[j], t[j + 1]);\n\t\t\t\t\t\tswap(t[k], t[k + 1]);\n\n\t\t\t\t\t\trange(l,i + 1,n){\n\t\t\t\t\t\t\tif(t == s[l]){\n\t\t\t\t\t\t\t\tansEmplace(ans, s, i, l);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 削除を一回行ってからswapしたとき\n\t\tif(d >= 2){\n\t\t\trep(i,n){\n\t\t\t\tvector<string> ss;\n\t\t\t\trep(j, s[i].size()){\n\t\t\t\t\tstring t = s[i];\n\t\t\t\t\tt.erase(next(t.begin(),j));\n\n\t\t\t\t\trep(k,t.size() - 1){\n\t\t\t\t\t\tstring tt = t;\n\t\t\t\t\t\tswap(tt[j], tt[j + 1]);\n\t\t\t\t\t\tss.emplace_back(tt);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trep(j,ss.size()){\n\t\t\t\t\trange(k,i + 1,n){\n\t\t\t\t\t\tif(ss[j] == s[k]){\n\t\t\t\t\t\t\tansEmplace(ans, s, i, k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<pair<string,string>> v;\n\n\t\tfor(auto p : ans){\n\t\t\tv.emplace_back(s[p.first],s[p.second]);\n\t\t}\n\t\tsort(all(v));\n\t\tfor(auto p : v){\n\t\t\tcout << p.first << ',' << p.second << endl;\n\t\t}\n\t\tcout << v.size() << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 334\ntypedef pair<string,string> P;\ntypedef pair<string,int> P2;\n\nint N,D;\nstring s[MAX],start;\nmap<string,bool> mp;\nset<P> st;\nvector<P> vec;\nset<P2> visited;\n\nvoid dfs(string now,int step, int z){\n  //if(visited.find(P2(now,step)) != visited.end()){ return; }\n  //visited.insert(P2(now,step));\n  if(step == D){\n    if(mp.find(now) != mp.end() && now != start){\n      bool repl = false;\n      if(start > now){ repl = true; swap(start,now); }\n      st.insert(P(start,now));\n      if(repl){ swap(start,now); }\n    }\n    return;\n  }\n  int len = now.size();\n  // delete\n  if(z<=0) {\n    for(int i = 0 ; i < len ; i++){\n      string tmp = now;\n      tmp.erase(tmp.begin()+i);\n      dfs(tmp,step+1,0);\n    }\n  }\n\n  // swap\n  if(z<=1) {\n    for(int i = 0 ; i < len-1 ; i++){\n      for(int j = i+1 ; j < len ; j++){\n\tswap(now[i],now[j]);\n\tdfs(now,step+1,1);\n\tswap(now[i],now[j]);\n      }\n    }\n  }\n\n  // insert\n  if(z<=2) {\n    for(char ch = 'a' ; ch <= 'z' ; ch++){\n      for(int j = 0 ; j < len+1 ; j++){\n\tstring tmp = now;\n\ttmp = tmp.substr(0,j) + ch + tmp.substr(j);\n\tdfs(tmp,step+1,2);\n      }\n    }\n  }\n  \n  // replace\n  for(char ch = 'a' ; ch <= 'z' ; ch++){\n    for(int j = 0 ; j < len ; j++){\n      string tmp = now; tmp[j] = ch;\n      dfs(tmp,step+1,3);\n    }\n  }\n}\n\nint main(){\n  while(cin >> N, N){\n    cin >> D;\n    mp.clear(); visited.clear();\n    for(int i = 0 ; i < N ; i++){\n      cin >> s[i];\n      mp[s[i]] = true;\n    }\n    vec.clear(); st.clear();\n    for(int i = 0 ; i < N ; i++){\n      start = s[i];\n      dfs(start,0,0);\n    }\n    for(set<P>::iterator it = st.begin() ; it != st.end() ; ++it){\n      vec.push_back(*it);\n    }\n    int len = vec.size();\n    sort(vec.begin(),vec.end());\n    for(int i = 0 ; i < len ; i++){\n      cout << vec[i].first << \",\" << vec[i].second << endl;\n    }\n    cout << len << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    int d;\n    cin>>d;\n    set<string> ss;\n    for(int i=0;i<n;i++){\n      string s;\n      cin>>s;\n      ss.emplace(s);\n    }\n    using P = pair<string, string>;\n    set<P> ans;\n    auto calc=[](string s){\n      int n=s.size();\n      set<string> ss;\n      for(int i=0;i<n;i++){\n\tstring t=s;\n\tt.erase(t.begin()+i);\n\tss.emplace(t);\n      }\n      for(int i=0;i<n;i++){\n\tfor(char c='a';c<='z';c++){\n\t  string t=s;\n\t  t[i]=c;\n\t  ss.emplace(t);\n\t}\n      }\n      for(int i=0;i<n-1;i++){\n\tswap(s[i],s[i+1]);\n\tss.emplace(s);\n\tswap(s[i],s[i+1]);\n      }\n      return ss;\n    };\n    map<string,vector<string> > ms;\n    for(string s:ss){\n      if(d==1){\n\tmap<string,int> dp;\n\tqueue<string> q;\n\tdp[s]=0;\n\tq.emplace(s);\n\twhile(!q.empty()){\n\t  string t=q.front();q.pop();\n\t  if(dp[t]>=d) continue;\n\t  auto xs=calc(t);\n\t  for(string x:xs){\n\t    if(dp.count(x)) continue;\n\t    dp[x]=dp[t]+1;\n\t    q.emplace(x);\n\t  }\n\t}\n\tfor(auto p:dp){\n\t  if(p.first==s||p.second>d) continue;\n\t  if(ss.count(p.first)) ans.emplace(minmax({s,p.first}));\n\t}\n      }\n      if(d==2){\n\tcontinue;\n\tmap<string,int> dp;\n\tqueue<string> q;\n\tdp[s]=0;\n\tq.emplace(s);\n\twhile(!q.empty()){\n\t  string t=q.front();q.pop();\n\t  if(dp[t]>=2) continue;\n\t  auto xs=calc(t);\n\t  for(string x:xs){\n\t    if(dp.count(x)) continue;\n\t    dp[x]=dp[t]+1;\n\t    q.emplace(x);\n\t  }\n\t}\n\tfor(auto p:dp){\n\t  if(p.second==1){\n\t    for(auto x:ms[p.first])\n\t      ans.emplace(minmax({s,x}));\n\t    \n\t    ms[p.first].emplace_back(s);\n\t  }\n\t  if(p.first==s||p.second>d) continue;\n\t  if(ss.count(p.first)) ans.emplace(minmax({s,p.first}));\n\t}\n      }\n    }\n    for(P p:ans)\n      cout<<p.first<<\",\"<<p.second<<endl;\n    cout<<ans.size()<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 334\ntypedef pair<string,string> P;\ntypedef pair<string,int> P2;\n\nint N,D;\nstring s[MAX],start;\nmap<string,bool> mp;\nset<P> st;\nvector<P> vec;\nset<P2> visited;\n\nvoid dfs(string now,int step){\n  // if(visited.find(P2(now,step)) != visited.end()){ return; }\n  // visited.insert(P2(now,step));\n  if(step == D){\n    if(mp.find(now) != mp.end() && now != start){\n      bool repl = false;\n      if(start > now){ repl = true; swap(start,now); }\n      st.insert(P(start,now));\n      if(repl){ swap(start,now); }\n    }\n    return;\n  }\n  int len = now.size();\n  // delete\n  for(int i = 0 ; i < len ; i++){\n    string tmp = now;\n    tmp.erase(tmp.begin()+i);\n    dfs(tmp,step+1);\n  }\n  // insert\n  for(char ch = 'a' ; ch <= 'z' ; ch++){\n    for(int j = 0 ; j < len+1 ; j++){\n      string tmp = now;\n      tmp = tmp.substr(0,j) + ch + tmp.substr(j);\n      dfs(tmp,step+1);\n    }\n  }\n\n  // swap\n  for(int i = 0 ; i < len-1 ; i++){\n    for(int j = i+1 ; j < len ; j++){\n      swap(now[i],now[j]);\n      dfs(now,step+1);\n      swap(now[i],now[j]);\n    }\n  }\n  \n  // replace\n  for(char ch = 'a' ; ch <= 'z' ; ch++){\n    for(int j = 0 ; j < len ; j++){\n      string tmp = now; tmp[j] = ch;\n      dfs(tmp,step+1);\n    }\n  }\n}\n\nint main(){\n  while(cin >> N, N){\n    cin >> D;\n    mp.clear(); visited.clear();\n    for(int i = 0 ; i < N ; i++){\n      cin >> s[i];\n      mp[s[i]] = true;\n    }\n    vec.clear(); st.clear();\n    for(int i = 0 ; i < N ; i++){\n      start = s[i];\n      dfs(start,0);\n    }\n    for(set<P>::iterator it = st.begin() ; it != st.end() ; ++it){\n      vec.push_back(*it);\n    }\n    int len = vec.size();\n    sort(vec.begin(),vec.end());\n    for(int i = 0 ; i < len ; i++){\n      cout << vec[i].first << \",\" << vec[i].second << endl;\n    }\n    cout << len << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 201\ntypedef pair<string,string> P;\n\nint N,D,idx;\nstring s[MAX];\nmap<int,set<string> > mp;\nvector<P> vec;\n\nvoid dfs(string now,int step){\n  if(step == 1){\n    mp[idx].insert(now);\n    return;\n  }\n  \n  int len = now.size();\n  // delete\n  for(int i = 0 ; i < len ; i++){\n    string tmp = now;\n    tmp.erase(tmp.begin()+i);\n    dfs(tmp,step+1);\n  }\n \n  // swap\n  for(int i = 0 ; i < len-1 ; i++){\n    swap(now[i],now[i+1]);\n    dfs(now,step+1);\n    swap(now[i],now[i+1]);\n  }\n\n  // insert\n  for(char ch = 'a' ; ch <= 'z' ; ch++){\n    for(int j = 0 ; j < len+1 ; j++){\n      string tmp = now;\n      tmp = tmp.substr(0,j) + ch + tmp.substr(j);\n      dfs(tmp,step+1);\n    }\n  }\n \n  // replace\n  for(char ch = 'a' ; ch <= 'z' ; ch++){\n    for(int j = 0 ; j < len ; j++){\n      char c = now[j];\n      now[j] = ch;\n      dfs(now,step+1);\n      now[j] = c;\n    }\n  }\n}\n\nvoid init(){\n  mp.clear();\n  vec.clear();\n}\n\nint main(){\n  while(cin >> N, N){\n    cin >> D;\n    init();\n    for(int i = 0 ; i < N ; i++){\n      cin >> s[i];\n    }\n    for(int i = 0 ; i < N ; i++){\n      idx = i;\n      dfs(s[i],0);\n    }\n\n    vector<string> v[MAX];\n    for(int i = 0 ; i < N ; i++){\n      set<string> st = mp[i];\n      set<string>::iterator it;\n      for(it = st.begin() ; it != st.end() ; ++it){\n        v[i].push_back(*it);\n      }\n    } \n\n    if(D == 1){\n      for(int i = 0 ; i < N ; i++){\n        unordered_map<string,bool> ump;\n        for(int j = 0 ; j < (int)v[i].size() ; j++){\n          ump[v[i][j]] = true;\n        }\n        for(int j = i+1 ; j < N ; j++){\n          if(ump.find(s[j]) != ump.end()){\n           vec.push_back(P(s[i],s[j]));\n          }\n        }\n      }\n    }else{\n      for(int i = 0 ; i < N ; i++){\n        unordered_map<string,bool> ump;\n        for(int j = 0 ; j < (int)v[i].size() ; j++){\n          ump[v[i][j]] = true;\n        }\n        for(int j = i+1 ; j < N ; j++){\n          for(int k = 0 ; k < (int)v[j].size() ; k++){\n            if(ump.find(v[j][k]) != ump.end()){\n              vec.push_back(P(s[i],s[j]));\n              break;\n            }\n          }\n        }\n      }\n    }\n    int len = vec.size();\n    for(int i = 0 ; i < len ; i++){\n      if(vec[i].first > vec[i].second){\n        swap(vec[i].first,vec[i].second);\n      }\n    }\n    sort(vec.begin(),vec.end());\n    for(int i = 0 ; i < len ; i++){\n      cout << vec[i].first << \",\" << vec[i].second << endl;\n    }\n    cout << len << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nvoid transforms(const string& s1,set<string>& s){\n    string tmp;\n    for(int i = 0; i < s1.length();i++){\n        tmp = s1;\n        tmp.erase(tmp.begin() + i);\n        s.insert(tmp);\n    }\n    for(int i = 0; i <=s1.length();i++){\n        for(int j = 0; j < 26;j++){\n            tmp = s1;\n            char c = 'a' + j;\n            tmp.insert(i,string(1,c));\n            s.insert(tmp);\n        }\n    }\n    for(int i = 0; i < s1.length();i++){\n        for(int j = 0; j < 26;j++){\n            tmp = s1;\n            char c = 'a' + j;\n            tmp.replace(i,1,string(1,c));\n            s.insert(tmp);\n        }\n    }\n    for(int i = 0; i < s1.length() - 1;i++){\n        tmp = s1;\n        swap(tmp[i],tmp[i+1]);\n        s.insert(tmp);\n    }\n}\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n,d;\n    vector<pii> res;\n    vector<string> name;\n    while(cin >> n, n){\n        cin >> d;\n        res.clear();\n        name.clear();\n        name.resize(n);\n        for(int i = 0; i < n;i++){\n            cin >> name[i];\n        }\n        sort(name.begin(),name.end());\n        if(d == 1){\n            set<string> s;\n            for(int i = 0; i < n - 1;i++){\n                s.clear();\n                transforms(name[i],s);\n                for(int j = i + 1; j < n;j++){\n                    if(s.find(name[j]) != s.end()){\n                        res.push_back({i,j});\n                    }\n                }\n            }\n        }else{\n            set<string> s1;\n            set<string> s2;\n            for(int i = 0; i < n-1;i++){\n                for(int j = i + 1; j < n;j++){\n                    s1.clear(); s2.clear();\n                    transforms(name[i],s1);\n                    transforms(name[j],s2);\n                    for(auto tmp_s:s1){\n                        if(s2.find(tmp_s) != s2.end()){\n                            res.push_back({i,j});\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        \n        for(auto ans:res){\n            cout << name[ans.first] << \",\" <<name[ans.second]<<endl;\n        }\n        cout << res.size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool check(string a,string b,int d){\n  if(a.size()<b.size())swap(a,b);\n  if(a==b) return 1;\n  if(d==0||a.empty())return 0;\n\n  //erase\n  for(int i=0;i<a.size()&&a.size()>b.size();i++){\n    string t = a;\n    t.erase(t.begin()+i);\n    if(check(t,b,d-1))return 1;\n  }\n\n  //swap\n  for(int i=0;i<(int)a.size()-1;i++){\n    swap(a[i],a[i+1]);\n    if(check(a,b,d-1))return 1;\n    swap(a[i],a[i+1]);\n  }\n  \n  //change\n  for(int i=0;i<b.size();i++){\n    char ch = a[i];\n    if(a[i]!=b[i]) a[i] = b[i];\n    if(check(a,b,d-1))return 1;\n    a[i] = ch;\n  }\n  return 0;\n}\n\nint main(){\n  int n,d;\n  while(cin>>n,n){\n    cin>>d;\n    string str[201];\n    for(int i=0;i<n;i++)cin>>str[i];\n    sort(str,str+n);\n\n    int cnt=0;    \n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++)\n\tif(check(str[i],str[j],d))\n\t  printf(\"%s,%s\\n\",&str[i][0],&str[j][0]),cnt++;\n    cout<<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n){\n    int d;\n    vector<string> name(n);\n    cin >> d;\n    rep(i,0,n) cin >> name[i];\n\n    auto hash_string=hash<string>();\n    function<set<size_t>(const string&,const int)> enumerate_neighborhood=[&](const string &s,int d){\n        if(d==0) return set<size_t>({hash_string(s)});\n        set<size_t> res;\n        //replace\n        rep(i,0,s.size()){\n            string t=s;\n            rep(j,0,26){\n                t[i]='a'+j;\n                auto tmp=enumerate_neighborhood(t,d-1);\n                res.insert(tmp.begin(),tmp.end());\n            }\n        }\n        //insert\n        rep(i,0,s.size()+1){\n            string x=s.substr(0,i),y=s.substr(i);\n            rep(j,0,26){\n                x.push_back('a'+j);\n                auto t=x+y;\n                auto tmp=enumerate_neighborhood(t,d-1);\n                res.insert(tmp.begin(),tmp.end());\n                x.pop_back();\n            }\n        }\n        //delete\n        rep(i,0,s.size()){\n            string t=s.substr(0,i)+s.substr(i+1);\n            auto tmp=enumerate_neighborhood(t,d-1);\n            res.insert(tmp.begin(),tmp.end());\n        }\n        //swap adjacent\n        rep(i,0,s.size()-1){\n            string t=s;\n            swap(t[i],t[i+1]);\n            auto tmp=enumerate_neighborhood(t,d-1);\n            res.insert(tmp.begin(),tmp.end());\n            swap(t[i],t[i+1]);\n        }\n        return res;\n    };\n\n    vector<set<size_t>> u(n);\n    rep(i,0,n) u[i]=enumerate_neighborhood(name[i],d);\n\n    vector<pair<string,string>> ans;\n    rep(i,0,n) rep(j,i+1,n){\n        int i1=i,j1=j;\n        if(u[i].size()>u[j].size()) swap(i1,j1);\n        if(u[i1].find(hash_string(name[j1]))==u[i1].end()) continue;\n        ans.push_back(make_pair(min(name[i],name[j]),max(name[i],name[j])));\n    }\n\n    sort(ans.begin(),ans.end());\n    rep(i,0,ans.size()) cout << ans[i].first << \",\" << ans[i].second << endl;\n    cout << ans.size() << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 334\ntypedef pair<string,string> P;\n\nint N,D,idx;\nstring s[MAX];\nmap<int,map<string,bool> > mp;\nvector<P> vec;\n\nvoid dfs(string now,int step){\n  if(step == 1){\n    mp[idx][now] = true;\n    return;\n  }\n\n  int len = now.size();\n  // delete\n  for(int i = 0 ; i < len ; i++){\n    string tmp = now;\n    tmp.erase(tmp.begin()+i);\n    dfs(tmp,step+1);\n  }\n\n  // swap\n  for(int i = 0 ; i < len-1 ; i++){\n    for(int j = i+1 ; j < len ; j++){\n      swap(now[i],now[j]);\n      dfs(now,step+1);\n      swap(now[i],now[j]);\n    }\n  }\n  \n  // insert\n  for(char ch = 'a' ; ch <= 'z' ; ch++){\n    for(int j = 0 ; j < len+1 ; j++){\n      string tmp = now;\n      tmp = tmp.substr(0,j) + ch + tmp.substr(j);\n      dfs(tmp,step+1);\n    }\n  }\n\n  // replace\n  for(char ch = 'a' ; ch <= 'z' ; ch++){\n    for(int j = 0 ; j < len ; j++){\n      string tmp = now; tmp[j] = ch;\n      dfs(tmp,step+1);\n    }\n  }\n}\n\nvoid init(){\n  mp.clear();\n  vec.clear();\n}\n\nint main(){\n  while(cin >> N, N){\n    cin >> D;\n    init();\n    for(int i = 0 ; i < N ; i++){\n      cin >> s[i];\n    }\n    for(int i = 0 ; i < N ; i++){\n      idx = i;\n      dfs(s[i],0);\n    }\n    \n    if(D == 1){\n      for(int i = 0 ; i < N ; i++){\n\tmap<string,bool> st = mp[i];\n\tfor(int j=i+1; j<N; j++) {\n\t  if(st[s[j]]){\n\t    vec.push_back(P(s[i],s[j]));\n\t  }\n\t}\n      }\n    }else{\n      for(int i = 0 ; i < N ; i++){\n\tfor(int j = i+1 ; j < N ; j++){\n\t  map<string,bool> st = mp[i],st2 = mp[j];\n\t  map<string,bool>::iterator it;\n\t  for(it = st.begin() ; it != st.end() ; ++it){\n\t    if(st2[it->first]){\n\t      vec.push_back(P(s[i],s[j]));\n\t      break;\n\t    }\n\t  }\n\t}\n      }\n    }\n    int len = vec.size();\n    for(int i = 0 ; i < len ; i++){\n      if(vec[i].first > vec[i].second){\n\tswap(vec[i].first,vec[i].second);\n      }\n    }\n    sort(vec.begin(),vec.end());\n    for(int i = 0 ; i < len ; i++){\n      cout << vec[i].first << \",\" << vec[i].second << endl;\n    }\n    cout << len << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n, d;\nstring t[202];\nmap<string, set<int> > idx;\n\nvector<string> getV(string v){\n  vector<string> res;\n  string s = v;\n\n  for(int a = 0; a < s.length() - 1; a++){\n    swap(s[a], s[a + 1]);\n    res.push_back(s);\n    swap(s[a], s[a + 1]);\n  }\n\n  for(char ch = 'a'; ch <= 'z'; ch++){\n    for(int j = 0; j < v.length(); j++){\n      s = v;\n      s[j] = ch;\n      res.push_back(s);\n      s[j] = v[j];\n    }\n\n    for(int j = 0; j < v.length() + 1; j++){\n      s = v.substr(0, j) + ch + v.substr(j);\n      res.push_back(s);\n    }\n  }\n\n  for(int j = 0; j < v.length(); j++){\n    s = v.substr(0, j) + v.substr(j + 1);\n    res.push_back(s);\n  }\n\n  return res;\n}\n\nint main(){\n  while(cin >> n, n){\n    cin >> d;\n\n    for(int i = 0; i < n; i++){\n      cin >> t[i];\n    }\n    sort(t, t + n);\n\n    idx.clear();\n\n    for(int i = 0; i < n; i++){\n      vector<string> v = getV(t[i]);\n\n      for(int j = 0; j < v.size(); j++){\n        idx[v[j]].insert(i);\n      }\n    }\n\n    set<P> ans;\n\n    for(int i = 0; i < n; i++){\n      for(int j = i + 1; j < n; j++){\n        if(idx[t[j]].find(i) != idx[t[j]].end()){\n          ans.insert(P(i, j));\n        }\n      }\n    }\n\n    if(d == 2){\n      for(map<string,set<int> >::iterator iter = idx.begin(); iter != idx.end(); iter++){\n        set<int> stt = iter->second;\n        for(set<int>::iterator iter2 = stt.begin(); iter2 != stt.end(); iter2++){\n          for(set<int>::iterator iter3 = stt.begin(); iter3 != stt.end(); iter3++){\n            if(*iter2 < *iter3)\n              ans.insert(P(*iter2, *iter3));\n          }\n        }\n      }\n    }\n\n    for(set<P>::iterator iter = ans.begin(); iter != ans.end(); iter++){\n      P p = *iter;\n      cout << t[p.first] << \",\" << t[p.second] << endl;\n    }\n\n    cout << ans.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nbool comp(string s, string t){\n\tfor(int i = 0; i < min(s.size(), t.size()); i++){\n\t\tif(s[i] < t[i]) return true;\n\t\tif(s[i] > t[i]) return false;\n\t}\n\treturn s.size() <= t.size();\n}\n\nint getDist(const string& s, const string& t){\n\tint dp[20][20];\n\tfor(int i = 0; i <= s.size(); i++) dp[i][0] = i;\n\tfor(int i = 0; i <= t.size(); i++) dp[0][i] = i;\n\n\tfor(int i = 1; i <= s.size(); i++)\n\t\tfor(int j = 1; j <= t.size(); j++)\n\t\t\tdp[i][j] = min(min(dp[i - 1][j] + 1, dp[i][j - 1] + 1),\n\t\t\t\t\t\t   dp[i - 1][j - 1] + (s[i - 1] != t[j - 1]));\n\treturn (dp[s.size()][t.size()]);\n}\n\nstring name[256];\n\nbool f(string s, string t, int d){\n\tif(s == t) return true;\n\tif(getDist(s, t) <= d) return true;\n\n\tif(d >= 1){\n\t\t// 1???????????????\n\t\tif(s.size() == t.size()){\n\t\t\tfor(int i = 0; i < s.size() - 1; i++){\n\t\t\t\tswap(s[i], s[i + 1]);\n\t\t\t\tif(s == t) return true;\n\t\t\t\tswap(s[i], s[i + 1]);\n\t\t\t}\n\t\t}\n\t}\n\tif(d == 2){\n\t\t// 2???????????????\n\t\tfor(int i = 0; i < s.size() - 1; i++){\n\t\t\tswap(s[i], s[i + 1]);\n\t\t\tfor(int j = 0; j < s.size() - 1; j++){\n\t\t\t\tif(i == j) continue;\n\t\t\t\tswap(s[j], s[j + 1]);\n\t\t\t\tif(s == t) return true;\n\t\t\t\tswap(s[j], s[j + 1]);\n\t\t\t}\n\t\t\tswap(s[i], s[i + 1]);\n\t\t}\n\t\t// 1?????????????????§??¨????????¢1\n\t\tfor(int i = 0; i < s.size() - 1; i++){\n\t\t\tswap(s[i], s[i + 1]);\n\t\t\tif(getDist(s, t) <= 1) return true;\n\t\t\tswap(s[i], s[i + 1]);\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tint n, d;\n\twhile(cin >> n >> d, n){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> name[i];\n\t\t}\n\n\t\tvector<pair<string, string>> ans;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tif(f(name[i], name[j], d)){\n\t\t\t\t\tstring s1 = min(name[i], name[j], comp);\n\t\t\t\t\tstring s2 = max(name[i], name[j], comp);\n\t\t\t\t\tans.push_back({ s1, s2 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(ans.begin(), ans.end());\n\t\tfor(auto v : ans){\n\t\t\tcout << v.first + \",\" + v.second << endl;\n\t\t}\n\t\tcout << ans.size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n, d;\nstring t[202];\n\nvector<string> getV(string v){\n  vector<string> res;\n  string s = v;\n\n  for(int a = 0; a < s.length(); a++){\n    for(int b = a + 1; b < s.length(); b++){\n      swap(s[a], s[b]);\n      res.push_back(s);\n      swap(s[a], s[b]);\n    }\n  }\n\n  for(char ch = 'a'; ch <= 'z'; ch++){\n    for(int j = 0; j < v.length(); j++){\n      s = v;\n      s[j] = ch;\n      res.push_back(s);\n      s[j] = v[j];\n    }\n\n    for(int j = 0; j < v.length() + 1; j++){\n      s = v.substr(0, j) + ch + v.substr(j);\n      res.push_back(s);\n    }\n  }\n\n  for(int j = 0; j < v.length(); j++){\n    s = v.substr(0, j) + v.substr(j + 1);\n    res.push_back(s);\n  }\n\n  return res;\n}\n\nint main(){\n  while(cin >> n, n){\n    cin >> d;\n\n    for(int i = 0; i < n; i++){\n      cin >> t[i];\n    }\n    sort(t, t + n);\n\n    int cnt = 0;\n\n    vector<string> v[n];\n    set<string> st[n];\n    map<string, set<int> > idx;\n\n    for(int i = 0; i < n; i++){\n      v[i] = getV(t[i]);\n\n      for(int j = 0; j < v[i].size(); j++){\n        st[i].insert(v[i][j]);\n        idx[v[i][j]].insert(i);\n      }\n    }\n\n    set<P> ans;\n\n    for(int i = 0; i < n; i++){\n      for(int j = i + 1; j < n; j++){\n        if(st[i].find(t[j]) != st[i].end()){\n          ans.insert(P(i, j));\n        }\n      }\n    }\n\n    if(d == 2){\n      for(map<string,set<int> >::iterator iter = idx.begin(); iter != idx.end(); iter++){\n        set<int> stt = iter->second;\n        for(set<int>::iterator iter2 = stt.begin(); iter2 != stt.end(); iter2++){\n          for(set<int>::iterator iter3 = stt.begin(); iter3 != stt.end(); iter3++){\n            if(*iter2 < *iter3)\n              ans.insert(P(*iter2, *iter3));\n          }\n        }\n      }\n    }\n\n    for(set<P>::iterator iter = ans.begin(); iter != ans.end(); iter++){\n      P p = *iter;\n      cout << t[p.first] << \",\" << t[p.second] << endl;\n    }\n\n    cout << ans.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int N = 1e6;\nvi graph[N];\n\nusing ResElem = tuple<string, string>;\nset<ResElem> s;\n\ninline void add_edge(int a, int b){\n    graph[a].emplace_back(b);\n    graph[b].emplace_back(a);\n}\n\nint d, n;\nmap<string, int> s2i;\nmap<int, string> i2s;\n\nvoid dfs(int sv, int v, int depth){\n    if(depth > d) return;\n    if(sv != v and v < n){\n        string a = i2s[v], b = i2s[sv];\n        if(a > b) swap(a, b);\n        s.insert(ResElem(a, b));\n    }\n\n    for(auto& nv : graph[v]){\n        dfs(sv, nv, depth + 1);\n    }\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(; cin >> n >> d, n;){\n        vector<string> names(n);\n        for(auto& e : names) cin >> e;\n\n        s2i.clear();\n        i2s.clear();\n        int idx = 0;\n        auto add_vertex = [&](string& name){\n            if(s2i.find(name) == end(s2i)){\n                s2i[name] = idx; i2s[idx] = name; idx++;\n            }\n            return s2i[name];\n        };\n        for(auto& e : names) add_vertex(e);\n\n        rep(i, N) graph[i].clear();\n        for(auto& cur : names){\n            string next;\n            int len = cur.size();\n            int v = s2i[cur];\n\n            // delete\n            rep(i, len){\n                next = cur.substr(0, i) + cur.substr(i + 1);\n                int nv = add_vertex(next);\n                add_edge(v, nv);\n            }\n\n            // insert\n            rep(i, len + 1){\n                rep(j, 'z' - 'a' + 1){\n                    char c = (char)('a' + j);\n                    next = cur.substr(0, i) + c + cur.substr(i);\n                    int nv = add_vertex(next);\n                    add_edge(v, nv);\n                }\n            }\n\n            // replace\n            rep(i, len){\n                rep(j, 'z' - 'a' + 1){\n                    char c = (char)('a' + j);\n                    next = cur.substr(0, i) + c;\n                    if(i + 1 < len) next += cur.substr(i + 1);\n                    int nv = add_vertex(next);\n                    add_edge(v, nv);\n                }\n            }\n\n            // swap\n            rep(i, len - 1){\n                next = cur;\n                swap(next[i], next[i + 1]);\n                int nv = add_vertex(next);\n                add_edge(v, nv);\n            }\n        }\n\n        s.clear();\n        rep(i, n){\n            dfs(i, i, 0);\n        }\n\n        for(auto& e : s){\n            string a, b; tie(a, b) = e;\n            cout << a << \",\" << b << endl;\n        }\n        cout << s.size() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\ntypedef pair<string,string> s2;\nint n,d;\nstring name[210];\nunordered_map<string,int> memo;\n\nvoid dfs(int cur,string s,const string &target,int cost,int &mini){\n  if( cost >= mini ) return;\n  if( cost > d ) return;\n  //cout << s << endl;\n  if( cur >= target.size() ) {\n    rep(i,s.size()) if( i >= s.size() && s[i] != ' ' ) ++cost;\n    mini = min(mini,cost);\n    return;\n  }\n  if( s[cur] == target[cur] ) {\n    dfs(cur+1,s,target,cost,mini);\n    return;\n  }\n\n  if( memo.count(s) ) if( memo[s] <= cost )return;\n\n  string ns;\n  //  Delete\n  if( s[cur] != ' ' ) {\n    ns = s.substr(0,cur) + s.substr(cur+1) + \" \";\n    dfs(cur,ns,target,cost+1,mini);\n  }\n\n  // Insert\n  ns = s.substr(0,cur) + target[cur] + s.substr(cur);\n  dfs(cur+1,ns,target,cost+1,mini);\n\n  // Replace\n  if( s[cur] != ' ' ) {\n    ns = s;\n    ns[cur] = target[cur];\n    dfs(cur+1,ns,target,cost+1,mini);\n  }\n\n  // Swap\n  ns = s;\n  REP(i,cur+1,ns.size()) if( ns[i] == target[cur] ) {\n    swap(ns[i],ns[cur]);\n    dfs(cur+1,ns,target,cost+1,mini);\n    swap(ns[i],ns[cur]);\n  }\n  if( memo.count(s) ) memo[s] = min(memo[s],mini);\n  else memo[s] = mini;\n}\n\nint compute(string a,string b){\n  if( (int)a.size() > (int)b.size() ) swap(a,b);\n  a = a + string((int)b.size()-(int)a.size(),' ');\n  memo.clear();\n  int mini = b.size();\n  dfs(0,a,b,0,mini);\n  return mini;\n}\n\nint main(){\n\n\n  while( cin >> n,n ){\n    cin >> d;\n    rep(i,n) cin >> name[i];\n    vector<s2> vec;\n    rep(i,n) REP(j,i+1,n){\n      int dist = compute(name[i],name[j]);\n      string a = name[i], b = name[j];\n      if( a > b ) swap(a,b);\n      if( dist <= d ) vec.push_back(s2(a,b));\n    }\n    sort(vec.begin(),vec.end());    \n    rep(i,vec.size()) cout << vec[i].first << \",\" << vec[i].second << endl;\n    cout << (int)vec.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n){\n    int d;\n    vector<string> name(n);\n    cin >> d;\n    rep(i,0,n) cin >> name[i];\n    sort(name.begin(),name.end());\n\n    function<void(const int,const string&,int,vector<bool>&)> enumerate_neighborhood=[&](int d,const string &s,int k,vector<bool> &f){\n        if(d==0){\n            rep(i,k,n) if(s==name[i]) f[i]=true;\n            return;\n        }\n        //replace\n        rep(i,0,s.size()){\n            string t=s;\n            rep(j,0,26){\n                t[i]='a'+j;\n                enumerate_neighborhood(d-1,t,k,f);\n            }\n        }\n        //insert\n        rep(i,0,s.size()+1){\n            string x=s.substr(0,i),y=s.substr(i);\n            rep(j,0,26){\n                x.push_back('a'+j);\n                auto t=x+y;\n                enumerate_neighborhood(d-1,t,k,f);\n                x.pop_back();\n            }\n        }\n        //delete\n        rep(i,0,s.size()){\n            string t=s.substr(0,i)+s.substr(i+1);\n            enumerate_neighborhood(d-1,t,k,f);\n        }\n        //swap adjacent\n        rep(i,0,s.size()-1){\n            string t=s;\n            swap(t[i],t[i+1]);\n            enumerate_neighborhood(d-1,t,k,f);\n        }\n    };\n\n    int count=0;\n    rep(i,0,n){\n        vector<bool> f(n);\n        enumerate_neighborhood(d,name[i],i+1,f);\n        rep(j,i+1,n){\n            if(!f[j]) continue;\n            cout << min(name[i],name[j]) << \",\" << max(name[i],name[j]) << endl;\n            ++count;\n        }\n    }\n    cout << count << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint LevenshteinDist(const string& s, const string& t)\n{\n    int n = s.size();\n    int m = t.size();\n    vector<vector<int> > minCost(n+2, vector<int>(m+2, INT_MAX));\n    minCost[0][0] = 0;\n    for(int i=0; i<=n; ++i){\n        for(int j=0; j<=m; ++j){\n            minCost[i+1][j] = min(minCost[i+1][j], minCost[i][j] + 1);\n            minCost[i][j+1] = min(minCost[i][j+1], minCost[i][j] + 1);\n            if(i < n && j < m && s[i] == t[j])\n                minCost[i+1][j+1] = min(minCost[i+1][j+1], minCost[i][j]);\n            else\n                minCost[i+1][j+1] = min(minCost[i+1][j+1], minCost[i][j] + 1);\n        }\n    }\n    return minCost[n][m];\n}\n\nint main()\n{\n    for(;;){\n        int n, d;\n        cin >> n >> d;\n        if(n == 0)\n            return 0;\n\n        vector<string> s(n);\n        for(int i=0; i<n; ++i)\n            cin >> s[i];\n        sort(s.begin(), s.end());\n\n        vector<set<string> > vss(n);\n        for(int i=0; i<n; ++i){\n            int m = s[i].size();\n            /* swap */\n            for(int j=0; j<m; ++j){\n                for(int k=j+1; k<m; ++k){\n                    string t = s[i];\n                    swap(t[j], t[k]);\n                    vss[i].insert(t);\n                }\n            }\n        }\n\n        int ret = 0;\n        for(int i=0; i<n; ++i){\n            for(int j=i+1; j<n; ++j){\n                bool confuse = false;\n\n                if(LevenshteinDist(s[i], s[j]) <= d)\n                    confuse = true;\n\n                set<string>::iterator it1, it2;\n                for(it1=vss[i].begin(); it1!=vss[i].end(); ++it1){\n                    if(LevenshteinDist(*it1, s[j]) <= d-1)\n                        confuse = true;\n                }\n                for(it2=vss[j].begin(); it2!=vss[j].end(); ++it2){\n                    if(LevenshteinDist(s[i], *it2) <= d-1)\n                        confuse = true;\n                }\n\n                if(d == 2){\n                    it1 = vss[i].begin();\n                    it2 = vss[j].begin();\n                    while(it1 != vss[i].end() && it2 != vss[j].end()){\n                        if(*it1 == *it2){\n                            confuse = true;\n                            break;\n                        }else if(*it1 < *it2)\n                            ++ it1;\n                        else\n                            ++ it2;\n                    }\n                }\n\n                if(confuse){\n                    cout << s[i] << ',' << s[j] << endl;\n                    ++ ret;\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint N,D;\nmap<string,vector<P> > ss;\nstring s[200];\nbool ok[202][202];\n\nint main(){\n  while(1){\n    cin>>N;\n    if(N==0)break;\n    cin>>D;\n    memset(ok,0,sizeof(ok));\n    ss.clear();\n    rep(i,N){\n      cin>>s[i];\n      int sz=s[i].size();\n      ss[s[i]].push_back(P(i,0));\n      rep(j,sz){ // delete\n        string t=s[i];\n        t=t.substr(0,j)+t.substr(j+1,sz-1-j);\n        ss[t].push_back(P(i,1));\n      }\n      rep(j,sz)rep(k,j){ // swap\n        string t=s[i];\n        swap(t[j],t[k]);\n        ss[t].push_back(P(i,1));\n      }\n      rep(j,sz)repl(c,'a','z'+1){ // mutate\n        string t=s[i];\n        t[j]=c;\n        ss[t].push_back(P(i,1));\n      }\n      rep(j,sz+1)repl(c,'a','z'+1){ // insert\n        string t=s[i];\n        t=t.substr(0,j)+to_string(c)+t.substr(j,sz-j);\n        ss[t].push_back(P(i,1));\n      }\n    }\n    for(auto it : ss){\n      for(auto it1 : it.se){\n        for(auto it2 : it.se){\n          if(it1.se+it2.se<=D){\n            ok[it1.fi][it2.fi]=true;\n            ok[it2.fi][it1.fi]=true;\n          }\n        }\n      }\n    }\n    vector<pair<string,string> > res;\n    rep(i,N)rep(j,i){\n      if(ok[i][j]){\n        res.push_back(pair<string,string>(min(s[i],s[j]),max(s[i],s[j])));\n      }\n    }\n    sort(all(res));\n    rep(i,res.size())cout<<res[i].fi<<\",\"<<res[i].se<<endl;\n    cout<<res.size()<<endl;\n  }\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef pair<string,string> P;\n\null B=10000007;\nint n,d,len;\nchar s[200][15];\null t[200];\nstring u[200];\nint G[200][200];\nbool f[200][200];\nmap<ull,bool> mp[200];\n\nvector< P > v;\n\null Deleting(int x,char* ch){\n  ull res=0;\n  for(int i=0;i<len;i++)\n    if(i!=x)res=res*B+ch[i];\n  return res;\n}\n\null Inserting(int x,char y,char* ch){\n  ull res=0;\n  for(int i=0;i<=len;i++){\n    if(i==x)res=res*B+y;\n    if(i<len)res=res*B+ch[i];\n  }\n  return res;\n}\n\null Replacing(int x,char y,char* ch){\n  ull res=0;\n  for(int i=0;i<len;i++){\n    if(i==x)res=res*B+y;\n    else res=res*B+ch[i];\n  }\n  return res;\n}\n\null Swapping(int x,char* ch){\n  ull res=0;\n  for(int i=0;i<len;i++){\n    if(i==x)res=res*B+ch[i+1];\n    else if(i==x+1)res=res*B+ch[x];\n    else res=res*B+ch[i];\n  }\n  return res;\n}\n\nvoid init(){\n  for(int i=0;i<200;i++){\n    mp[i].clear();\n  }\n  v.clear();\n  memset(f,false,sizeof(f));\n}\n\nint main(){\n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    init();\n    scanf(\"%d\",&d);\n\n    for(int i=0;i<n;i++){\n      scanf(\"%s\",s[i]);\n      len=strlen(s[i]);\n\n      t[i]=Swapping(-10,s[i]);\n      \n      for(int j=0;j<len;j++){\n        mp[i][Deleting(j,s[i])]=true;\n      }\n      \n      for(int j=0;j<=len;j++){\n        for(char k='a';k<='z';k++){\n          mp[i][Inserting(j,k,s[i])]=true;\n        }\n      }\n      \n      for(int j=0;j<len;j++){\n        for(char k='a';k<='z';k++){\n          if(s[i][j]!=k){\n            mp[i][Replacing(j,k,s[i])]=true;\n          }\n        }\n      }\n      \n      for(int j=0;j+1<len;j++){\n        mp[i][Swapping(j,s[i])]=true;\n      }\n\n      u[i]=\"\";\n      for(int j=0;j<len;j++)\n        u[i]+=s[i][j];\n    }\n\n    for(int i=1;i<n;i++){\n      for(int j=0;j<i;j++){\n        int a=i,b=j;\n        if( mp[a].count(t[b]) > 0 ){\n          v.push_back( P(u[a],u[b]) );\n          break;\n        }\n        if(d==1)continue;\n        map<ull,bool> :: iterator it;\n        for(it=mp[b].begin();it!=mp[b].end();it++){\n          if( mp[a].count(it->first) > 0 ){\n            v.push_back( P(u[a],u[b]) );\n            break;\n          }\n        }\n      }\n    }\n    sort( v.begin() , v.end() );\n    for(int i=0;i<(int)v.size();i++){\n      cout<<v[i].first<<','<<v[i].second<<endl;\n    }\n    printf(\"%d\\n\",(int)v.size());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n){\n    int d;\n    vector<string> name(n);\n    cin >> d;\n    rep(i,0,n) cin >> name[i];\n\n    function<set<string>(const string&,const int)> enumerate_neighborhood=[&](const string &s,int d){\n        if(d==0) return set<string>({s});\n        set<string> res;\n        //replace\n        rep(i,0,s.size()){\n            string t=s;\n            rep(j,0,26){\n                t[i]='a'+j;\n                auto tmp=enumerate_neighborhood(t,d-1);\n                res.insert(tmp.begin(),tmp.end());\n            }\n        }\n        //insert\n        rep(i,0,s.size()+1){\n            string x=s.substr(0,i),y=s.substr(i);\n            rep(j,0,26){\n                x.push_back('a'+j);\n                auto t=x+y;\n                auto tmp=enumerate_neighborhood(t,d-1);\n                res.insert(tmp.begin(),tmp.end());\n                x.pop_back();\n            }\n        }\n        //delete\n        rep(i,0,s.size()){\n            string t=s.substr(0,i)+s.substr(i+1);\n            auto tmp=enumerate_neighborhood(t,d-1);\n            res.insert(tmp.begin(),tmp.end());\n        }\n        //swap adjacent\n        rep(i,0,s.size()-1){\n            string t=s;\n            swap(t[i],t[i+1]);\n            auto tmp=enumerate_neighborhood(t,d-1);\n            res.insert(tmp.begin(),tmp.end());\n            swap(t[i],t[i+1]);\n        }\n        return res;\n    };\n\n    vector<set<string>> u(n);\n    rep(i,0,n) u[i]=enumerate_neighborhood(name[i],d);\n\n    vector<pair<string,string>> ans;\n    rep(i,0,n) rep(j,i+1,n){\n        int i1=i,j1=j;\n        if(u[i].size()>u[j].size()) swap(i1,j1);\n        if(u[i1].find(name[j1])==u[i1].end()) continue;\n        ans.push_back(make_pair(min(name[i],name[j]),max(name[i],name[j])));\n    }\n\n    sort(ans.begin(),ans.end());\n    rep(i,0,ans.size()) cout << ans[i].first << \",\" << ans[i].second << endl;\n    cout << ans.size() << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint LevenshteinDist(const string& s, const string& t)\n{\n    int n = s.size();\n    int m = t.size();\n    vector<vector<int> > minCost(n+2, vector<int>(m+2, INT_MAX));\n    minCost[0][0] = 0;\n    for(int i=0; i<=n; ++i){\n        for(int j=0; j<=m; ++j){\n            minCost[i+1][j] = min(minCost[i+1][j], minCost[i][j] + 1);\n            minCost[i][j+1] = min(minCost[i][j+1], minCost[i][j] + 1);\n            if(i < n && j < m && s[i] == t[j])\n                minCost[i+1][j+1] = min(minCost[i+1][j+1], minCost[i][j]);\n            else\n                minCost[i+1][j+1] = min(minCost[i+1][j+1], minCost[i][j] + 1);\n        }\n    }\n    return minCost[n][m];\n}\n\nint main()\n{\n    for(;;){\n        int n, d;\n        cin >> n >> d;\n        if(n == 0)\n            return 0;\n\n        vector<string> s(n);\n        for(int i=0; i<n; ++i)\n            cin >> s[i];\n        sort(s.begin(), s.end());\n\n        vector<set<string> > vss(n);\n        for(int i=0; i<n; ++i){\n            int m = s[i].size();\n            /* swap */\n            for(int j=0; j<m-1; ++j){\n                string t = s[i];\n                swap(t[j], t[j+1]);\n                vss[i].insert(t);\n            }\n        }\n\n        int ret = 0;\n        for(int i=0; i<n; ++i){\n            for(int j=i+1; j<n; ++j){\n                bool confuse = false;\n                if(LevenshteinDist(s[i], s[j]) <= d)\n                    confuse = true;\n\n                set<string>::iterator it1, it2;\n                for(it1=vss[i].begin(); it1!=vss[i].end(); ++it1){\n                    if(LevenshteinDist(*it1, s[j]) <= d-1)\n                        confuse = true;\n                }\n                for(it2=vss[j].begin(); it2!=vss[j].end(); ++it2){\n                    if(LevenshteinDist(s[i], *it2) <= d-1)\n                        confuse = true;\n                }\n\n                if(d == 2){\n                    it1 = vss[i].begin();\n                    it2 = vss[j].begin();\n                    while(it1 != vss[i].end() && it2 != vss[j].end()){\n                        if(*it1 == *it2){\n                            confuse = true;\n                            break;\n                        }\n                        if(*it1 < *it2)\n                            ++ it1;\n                        else\n                            ++ it2;\n                    }\n                }\n\n                if(confuse){\n                    cout << s[i] << ',' << s[j] << endl;\n                    ++ ret;\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint d;\nchar buf[114514];\nmap<string, set<int> > mp; \nstring names[114514];\nset<int> ans[114514];\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) return 0;\n\n    scanf(\"%d\", &d);\n    for (int i=0; i<n; i++) {\n      scanf(\"%s\", buf);\n      names[i] = buf;\n      ans[i].clear();\n    }\n    sort(names, names+n);\n    mp.clear();\n    for (int i=0; i<n; i++) {\n      mp[names[i]].insert(i);\n    }\n\n    if (d == 1) {\n      for (int i=0; i<n; i++) {\n        for (int j=0; j<names[i].size(); j++) {\n          for (int k : mp[names[i].substr(0, j) + names[i].substr(j+1)]) {\n            if (k != i) {\n              ans[min(i, k)].insert(max(i, k));\n            }\n          }\n\n          for (char k='a'; k<='z'; k++) {\n            //cout << \"rep: \" << names[i].substr(0, j)+k+names[i].substr(j+1) << \"\\n\";\n            for (int t : mp[names[i].substr(0, j)+k+names[i].substr(j+1)]) {\n              if (t != i) {\n                ans[min(i, t)].insert(max(i, t));\n              }\n            }\n\n            //cout << \"ins: \" << names[i].substr(0, j)+k+names[i].substr(j) << \"\\n\";\n            for (int t : mp[names[i].substr(0, j)+k+names[i].substr(j)]) {\n              if (t != i) {\n                ans[min(i, t)].insert(max(i, t));\n              }\n            }\n          }\n\n          for (int k=j+1; k<names[i].size(); k++) {\n            string g = names[i].substr(0, j)+names[i][k]+names[i].substr(j+1, k-j-1)+names[i][j]+names[i].substr(k+1);\n            //cout << \"sw: \" << g << \"\\n\";\n            for (int t : mp[g]) {\n              if (t != i) {\n                ans[min(i, t)].insert(max(i, t));\n              }\n            }\n          }\n        }\n\n        for (char k='a'; k<='z'; k++) {\n          //cout << \"ins: \" << names[i]+k << \"\\n\";\n          for (int t : mp[names[i]+k]) {\n            if (t != i) {\n              ans[min(i, t)].insert(max(i, t));\n            }\n          }\n        }\n      }\n    } else if (d == 2) {\n      for (int i=0; i<n; i++) {\n        for (int j=0; j<names[i].size(); j++) {\n          //cout << \"del: \" << names[i].substr(0, j) + names[i].substr(j+1) << \"\\n\";\n          mp[names[i].substr(0, j) + names[i].substr(j+1)].insert(i);\n          for (char k='a'; k<='z'; k++) {\n            mp[names[i].substr(0, j)+k+names[i].substr(j+1)].insert(i);\n            mp[names[i].substr(0, j)+k+names[i].substr(j)].insert(i);\n          }\n\n          for (int k=j+1; k<names[i].size(); k++) {\n            string g = names[i].substr(0, j)+names[i][k]+names[i].substr(j+1, k-j-1)+names[i][j]+names[i].substr(k+1);\n            mp[g].insert(i);\n          }\n        }\n\n        for (char k='a'; k<='z'; k++) {\n          mp[names[i]+k].insert(i);\n        }\n      }\n\n      for (auto itr : mp) {\n        for (int i : itr.second) {\n          for (int j : itr.second) {\n            if (i < j) ans[i].insert(j);\n          }\n        } \n      }\n    } else assert(0);\n\n    int cnt = 0;\n    for (int i=0; i<n; i++) {\n      for (int j : ans[i]) {\n        printf(\"%s,%s\\n\", names[i].c_str(), names[j].c_str());\n        cnt++;\n      }\n    }\n    printf(\"%d\\n\", cnt);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing std::sort;\nusing std::swap;\n\nint N, D;\nstruct Name{\n    char s[20];\n    bool operator<(const Name &b)const{\n        for(int i=0;;i++){\n            if(b.s[i]=='\\0') return false;\n            if(s[i]=='\\0') return true;\n            if(s[i] < b.s[i]) return false;\n            if(s[i] > b.s[i]) return true;\n        }\n    }\n}name[300];\n\nbool distance(int a, int b, int x, int y, int d){\n    if(d > D) return false;\n    if(name[a].s[x]=='\\0' && name[b].s[y]=='\\0') return true;\n    if(name[a].s[x] == '\\0') return distance(a, b, x, y+1, d+1);\n    if(name[b].s[y] == '\\0') return distance(a, b, x+1, y, d+1);\n    if(name[a].s[x] == name[b].s[y]) return distance(a, b, x+1, y+1, d); //always best\n    if(distance(a, b, x+1, y, d+1)) return true; //del a[x]->x++ or Insert b[y]\n    if(distance(a, b, x, y+1, d+1)) return true; //del b[y]->y++ or Insert a[x]\n    if(distance(a, b, x+1, y+1, d+1)) return true; //Replacing\n    if(name[a].s[x+1]!='\\0'){\n        swap(name[a].s[x], name[a].s[x+1]);\n        if(distance(a, b, x, y, d+1)){\n            swap(name[a].s[x], name[a].s[x+1]);\n            return true;\n        }\n        swap(name[a].s[x], name[a].s[x+1]);\n    }\n    return false;\n}\nint main(){\n    while(scanf(\"%d %d\", &N, &D) && N){\n        for(int i=0;i<N;i++)\n            scanf(\"%s\", name[i].s);\n        sort(name, name+N);\n        int res = 0;\n        for(int i=N-1;i>=0;i--){\n            for(int j=i-1;j>=0;j--){\n                if(distance(i, j, 0, 0, 0)){\n                    printf(\"%s,%s\\n\", name[i].s, name[j].s);\n                    res++;\n                }\n            }\n        }\n        printf(\"%d\\n\", res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\n\nint N, D;\nvector<string> names;\n//\n//ll to_int(string s){\n//    const int MOD = 1000000009;\n//    ll res = 0;\n//    for(auto c: s){\n//        res = (res*26 + (c - 'a')) % MOD;\n//    }\n//    return res;\n//}\n\nvoid solve(){\n    sort(names.begin(), names.end());\n    \n    map<string, set<int>> mp;\n    for(int ni=0; ni<N; ni++){\n        string name = names[ni];\n        int L = name.size();\n        \n        //delete\n        for(int i=0; i<L; i++){\n            string t = name;\n            t.erase(t.begin()+i);\n            mp[t].insert(ni);\n        }\n        //insert\n        for(int i=0; i<=L; i++){\n            for(char c='a'; c<='z'; c++){\n                string t = name;\n                t.insert(t.begin()+i, c);\n                mp[t].insert(ni);\n            }\n        }\n        //replace\n        for(int i=0; i<L; i++){\n            for(char c='a'; c<='z'; c++){\n                string t = name;\n                t[i] = c;\n                mp[t].insert(ni);\n            }\n        }\n        //swap\n        for(int i=0; i<L-1; i++){\n            string t = name;\n            swap(t[i], t[i+1]);\n            mp[t].insert(ni);\n        }\n    }\n    if(D == 1){\n        int cnt = 0;\n        for(int ni=0; ni<N; ni++){\n            string name = names[ni];\n            if(mp[name].size() > 1){\n                for(auto v: mp[name]){\n                    if(v <= ni) continue;\n                    cout << name << \",\" << names[v] << endl;\n                    cnt++;\n                }\n            }\n        }\n        cout << cnt << endl;\n    }\n    if(D == 2){\n        set<pair<int, int>> s;\n        for(auto v: mp) if(v.second.size() > 1){\n            vector<int> vec;\n            for(auto vv: v.second) vec.push_back(vv);\n            for(int i=0; i<vec.size(); i++){\n                for(int j=i+1; j<vec.size(); j++){\n                    s.insert(make_pair(vec[i], vec[j]));\n                }\n            }\n        }\n        for(auto v: s){\n            cout << names[v.first] << \",\" << names[v.second] << endl;\n        }\n        cout << s.size() << endl;\n    }\n\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    while(cin>>N, N){\n        cin >> D;\n        names.resize(N);\n        for(auto &v: names) cin >> v;\n        solve();\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\ntypedef unsigned long long ll;\nvector<ll> vc[200];\nstring ss[200];\nbool con[200][200];\ntypedef pair<string,string> P;\nvector<P> ans;\nll b=1e9+7;\nll hash(string s){\n\tll ret=0;\n\trep(i,s.size()){\n\t\tret*=b;\n\t\tret+=s[i];\n\t}\n\treturn ret;\n}\nint main(){\n\twhile(true){\n\t\tint n,d;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcin>>d;\n\t\trep(i,n){\n\t\t\tvc[i].clear();\n\t\t\tstring s,sc;\n\t\t\tcin>>s;\n\t\t\tss[i]=s;\n\t\t\tint m=s.size();\n\t\t\trep(j,m){\n\t\t\t\tsc=s;\n\t\t\t\tsc.erase(j,1);\n\t\t\t\tvc[i].pb(hash(sc));\n\t\t\t}\n\t\t\trep(k,m+1){\n\t\t\t\trep(j,26){\n\t\t\t\t\tsc=s;\n\t\t\t\t\tsc.insert(sc.begin()+k,'a'+j);\n\t\t\t\t\tvc[i].pb(hash(sc));\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(k,m){\n\t\t\t\trep(j,26){\n\t\t\t\t\tsc=s;\n\t\t\t\t\tsc[k]='a'+j;\n\t\t\t\t\tvc[i].pb(hash(sc));\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,m-1){\n\t\t\t\tsc=s;\n\t\t\t\tswap(sc[j],sc[j+1]);\n\t\t\t\tvc[i].pb(hash(sc));\n\t\t\t}\n\t\t\tsort(all(vc[i]));\n\t\t\tvc[i].erase(unique(all(vc[i])),vc[i].end());\n\t\t}\n\t\trep(i,n) rep(j,n) con[i][j]=0;\n\t\tif(d==1){\n\t\t\trep(i,n){\n\t\t\t\tll s=hash(ss[i]);\n\t\t\t\trep(j,i){\n\t\t\t\t\tif(binary_search(all(vc[j]),s)) con[i][j]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\trep(i,n){\n\t\t\t\trep(k,vc[i].size()){\n\t\t\t\t\tll s=vc[i][k];\n\t\t\t\t\trep(j,i){\n\t\t\t\t\t\tif(binary_search(all(vc[j]),s)) con[i][j]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans.clear();\n\t\trep(i,n) rep(j,n){\n\t\t\tif(con[i][j]){\n\t\t\t\tif(ss[i]<ss[j]) ans.pb(P(ss[i],ss[j]));\n\t\t\t\telse ans.pb(P(ss[j],ss[i]));\n\t\t\t}\n\t\t}\n\t\tsort(all(ans));\n\t\trep(i,ans.size()) cout<<ans[i].fs<<\",\"<<ans[i].sc<<endl;\n\t\tcout<<ans.size()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, d;\nstring in[200];\n\nint main(){\n\twhile(cin >> n, n){\n\t\tcin >> d;\n\t\trep(i, n) cin >> in[i];\n\t\tvector<pair<string, string> > ans;\n\t\tmap<string, vi> m;\n\t\t\n\t\trep(i, n){\n\t\t\tvector<string> ss;\n\t\t\trep(j, in[i].size() + 1){\n\t\t\t\tstring s = in[i];\n\t\t\t\tif(j < s.size() - 1){\n\t\t\t\t\tswap(s[j], s[j + 1]);\n\t\t\t\t\tss.pb(s);\n\t\t\t\t}\n\t\t\t\ts = in[i];\n\t\t\t\tif(j < s.size()){\n\t\t\t\t\ts.erase(s.begin() + j);\n\t\t\t\t\tss.pb(s);\n\t\t\t\t\t\n\t\t\t\t\trep(k, 26){\n\t\t\t\t\t\ts = in[i];\n\t\t\t\t\t\ts[j] = 'a' + k;\n\t\t\t\t\t\tss.pb(s);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(k, 26){\n\t\t\t\t\ts = in[i];\n\t\t\t\t\ts.insert(s.begin() + j, 'a' + k);\n\t\t\t\t\tss.pb(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tss.pb(in[i]);\n\t\t\trep(j, ss.size()) if(m.count(ss[j])){\n\t\t\t\teach(k, m[ss[j]]){\n\t\t\t\t\tstring a = in[*k], b = in[i];\n\t\t\t\t\tif(a > b) swap(a, b);\n\t\t\t\t\tans.pb(mp(a, b));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tm[in[i]].pb(i);\n\t\t\tif(d > 1) rep(j, ss.size()){\n\t\t\t\tif(!m.count(ss[j]) || m[ss[j]].back() != i)\n\t\t\t\tm[ss[j]].pb(i);\n\t\t\t}\n\t\t}\n\t\tsort(all(ans));\n\t\trep(i, ans.size()) cout << ans[i].first << \",\" << ans[i].second << endl;\n\t\tcout << ans.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 334\ntypedef pair<string,string> P;\n \nint N,D,idx;\nstring s[MAX];\nmap<int,set<string> > mp;\nvector<P> vec;\n \nvoid dfs(string now,int step){\n  if(step == 1){\n    mp[idx].insert(now);\n    return;\n  }\n \n  int len = now.size();\n  // delete\n  for(int i = 0 ; i < len ; i++){\n    string tmp = now;\n    tmp.erase(tmp.begin()+i);\n    dfs(tmp,step+1);\n  }\n \n  // swap\n  for(int i = 0 ; i < len-1 ; i++){\n    swap(now[i],now[i+1]);\n    dfs(now,step+1);\n    swap(now[i],now[i+1]);\n  }\n   \n  // insert\n  for(char ch = 'a' ; ch <= 'z' ; ch++){\n    for(int j = 0 ; j < len+1 ; j++){\n      string tmp = now;\n      tmp = tmp.substr(0,j) + ch + tmp.substr(j);\n      dfs(tmp,step+1);\n    }\n  }\n \n  // replace\n  for(char ch = 'a' ; ch <= 'z' ; ch++){\n    for(int j = 0 ; j < len ; j++){\n      string tmp = now; tmp[j] = ch;\n      dfs(tmp,step+1);\n    }\n  }\n}\n \nvoid init(){\n  mp.clear();\n  vec.clear();\n}\n \nint main(){\n  while(cin >> N, N){\n    cin >> D;\n    init();\n    for(int i = 0 ; i < N ; i++){\n      cin >> s[i];\n    }\n    for(int i = 0 ; i < N ; i++){\n      idx = i;\n      dfs(s[i],0);\n    }\n    \n    vector<string> v[MAX];\n    for(int i = 0 ; i < N ; i++){\n      set<string> st = mp[i];\n      set<string>::iterator it;\n      for(it = st.begin() ; it != st.end() ; ++it){\n        v[i].push_back(*it);\n      }\n    }\n    if(D == 1){\n      for(int i = 0 ; i < N ; i++){\n        for(int j = i+1 ; j < N ; j++){\n          if(binary_search(v[i].begin(),v[i].end(),s[j])){\n            vec.push_back(P(s[i],s[j]));\n          }\n        }\n      }\n    }else{\n      for(int i = 0 ; i < N ; i++){\n        for(int j = i+1 ; j < N ; j++){\n          vector<string>::iterator it;\n          for(it = v[i].begin() ; it != v[i].end() ; ++it){\n            if(binary_search(v[j].begin(),v[j].end(),*it)){\n              vec.push_back(P(s[i],s[j]));\n              break;\n            }\n          }\n        }\n      }\n    }\n    int len = vec.size();\n    for(int i = 0 ; i < len ; i++){\n      if(vec[i].first > vec[i].second){\n        swap(vec[i].first,vec[i].second);\n      }\n    }\n    sort(vec.begin(),vec.end());\n    for(int i = 0 ; i < len ; i++){\n      cout << vec[i].first << \",\" << vec[i].second << endl;\n    }\n    cout << len << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\ntypedef pair<string,string> s2;\nint n,d;\nstring name[210];\nunordered_map<string,int> memo;\n\nvoid dfs(int cur,string s,const string &target,int cost,int &mini){\n  if( cost >= mini ) return;\n  if( cost > d ) return;\n  //cout << s << endl;\n  if( cur >= target.size() ) {\n    rep(i,s.size()) if( i >= s.size() && s[i] != ' ' ) ++cost;\n    mini = min(mini,cost);\n    return;\n  }\n  if( s[cur] == target[cur] ) {\n    dfs(cur+1,s,target,cost,mini);\n    return;\n  }\n\n  if( memo.count(s) ) return;\n\n  string ns;\n  //  Delete\n  if( s[cur] != ' ' ) {\n    ns = s.substr(0,cur) + s.substr(cur+1) + \" \";\n    dfs(cur,ns,target,cost+1,mini);\n  }\n\n  // Insert\n  ns = s.substr(0,cur) + target[cur] + s.substr(cur);\n  dfs(cur+1,ns,target,cost+1,mini);\n\n  // Replace\n  if( s[cur] != ' ' ) {\n    ns = s;\n    ns[cur] = target[cur];\n    dfs(cur+1,ns,target,cost+1,mini);\n  }\n\n  // Swap\n  ns = s;\n  REP(i,cur+1,ns.size()) if( ns[i] == target[cur] ) {\n    swap(ns[i],ns[cur]);\n    dfs(cur+1,ns,target,cost+1,mini);\n    swap(ns[i],ns[cur]);\n  }\n  if( memo.count(s) ) memo[s] = min(memo[s],mini);\n  else memo[s] = mini;\n}\n\nint compute(string a,string b){\n  if( (int)a.size() > (int)b.size() ) swap(a,b);\n  a = a + string((int)b.size()-(int)a.size(),' ');\n  memo.clear();\n  int mini = b.size();\n  dfs(0,a,b,0,mini);\n  return mini;\n}\n\nint main(){\n\n\n  while( cin >> n,n ){\n    cin >> d;\n    rep(i,n) cin >> name[i];\n    vector<s2> vec;\n    rep(i,n) REP(j,i+1,n){\n      int dist = compute(name[i],name[j]);\n      string a = name[i], b = name[j];\n      if( a > b ) swap(a,b);\n      if( dist <= d ) vec.push_back(s2(a,b));\n    }\n    sort(vec.begin(),vec.end());    \n    rep(i,vec.size()) cout << vec[i].first << \",\" << vec[i].second << endl;\n    cout << (int)vec.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nset<string> make(string s)\n{\n\tset<string> res;\n\tint n = s.size();\n\tREP(i, n)\n\t{\n\t\tstring tmp = s;\n\t\ttmp.erase(tmp.begin() + i);\n\t\tres.insert(tmp);\n\t}\n\tREP(i, n + 1)\n\t{\n\t\tREP(j, 26)\n\t\t{\n\t\t\tchar c = 'a' + j;\n\t\t\tstring tmp = s;\n\t\t\ttmp.insert(tmp.begin() + i, c);\n\t\t\tres.insert(tmp);\n\t\t}\n\t}\n\tREP(i, n)\n\t{\n\t\tREP(j, 26)\n\t\t{\n\t\t\tchar c = 'a' + j;\n\t\t\tstring tmp = s;\n\t\t\ttmp[i] = c;\n\t\t\tres.insert(tmp);\n\t\t}\n\t}\n\tREP(i, n - 1)\n\t{\n\t\tstring tmp = s;\n\t\tswap(tmp[i], tmp[i + 1]);\n\t\tres.insert(tmp);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, d;\n\twhile (cin >> n >> d, n)\n\t{\n\t\tvs v(n);\n\t\tREP(i, n) cin >> v[i];\n\t\tsort(ALL(v));\n\t\tset<string> ans;\n\t\tif (d == 0)\n\t\t{\n\t\t\tREP(i, n)REP(j, i)\n\t\t\t{\n\t\t\t\tif (v[i] == v[j]) ans.insert(v[j] + \",\" + v[i]);\n\t\t\t}\n\t\t}\n\t\tvector<set<string>> st(n);\n\t\tREP(i, n)\n\t\t{\n\t\t\tst[i] = make(v[i]);\n\t\t}\n\t\tif (d == 1)\n\t\t{\n\t\t\tREP(i, n)REP(j, i)\n\t\t\t{\n\t\t\t\tif (st[i].count(v[j])) ans.insert(v[j] + \",\" + v[i]);\n\t\t\t}\n\t\t}\n\t\tif (d == 2)\n\t\t{\n\n\t\t\tREP(i, n)REP(j, i)\n\t\t\t{\n\t\t\t\tfor (auto k : st[j])\n\t\t\t\t{\n\t\t\t\t\tif (st[i].count(k))\n\t\t\t\t\t{\n\t\t\t\t\t\tans.insert(v[j] + \",\" + v[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (auto i : ans) cout << i << endl;\n\t\tcout << ans.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 334\ntypedef pair<string,string> P;\n \nint N,D,idx;\nstring s[MAX];\nmap<int,set<string> > mp;\nvector<P> vec;\n \nvoid dfs(string now,int step){\n  if(step == 1){\n    mp[idx].insert(now);\n    return;\n  }\n \n  int len = now.size();\n  // delete\n  for(int i = 0 ; i < len ; i++){\n    string tmp = now;\n    tmp.erase(tmp.begin()+i);\n    dfs(tmp,step+1);\n  }\n \n  // swap\n  for(int i = 0 ; i < len-1 ; i++){\n    for(int j = i+1 ; j < len ; j++){\n      swap(now[i],now[j]);\n      dfs(now,step+1);\n      swap(now[i],now[j]);\n    }\n  }\n   \n  // insert\n  for(char ch = 'a' ; ch <= 'z' ; ch++){\n    for(int j = 0 ; j < len+1 ; j++){\n      string tmp = now;\n      tmp = tmp.substr(0,j) + ch + tmp.substr(j);\n      dfs(tmp,step+1);\n    }\n  }\n \n  // replace\n  for(char ch = 'a' ; ch <= 'z' ; ch++){\n    for(int j = 0 ; j < len ; j++){\n      string tmp = now; tmp[j] = ch;\n      dfs(tmp,step+1);\n    }\n  }\n}\n \nvoid init(){\n  mp.clear();\n  vec.clear();\n}\n \nint main(){\n  while(cin >> N, N){\n    cin >> D;\n    init();\n    for(int i = 0 ; i < N ; i++){\n      cin >> s[i];\n    }\n    for(int i = 0 ; i < N ; i++){\n      idx = i;\n      dfs(s[i],0);\n    }\n    \n    vector<string> v[MAX];\n    for(int i = 0 ; i < N ; i++){\n      set<string> st = mp[i];\n      set<string>::iterator it;\n      for(it = st.begin() ; it != st.end() ; ++it){\n        v[i].push_back(*it);\n      }\n    }\n    if(D == 1){\n      for(int i = 0 ; i < N ; i++){\n        set<string> st = mp[i];\n        for(int j = i+1 ; j < N ; j++){\n          if(st.find(s[j]) != st.end()){\n            vec.push_back(P(s[i],s[j]));\n          }\n        }\n      }\n    }else{\n      for(int i = 0 ; i < N ; i++){\n        for(int j = i+1 ; j < N ; j++){\n          vector<string>::iterator it;\n          for(it = v[i].begin() ; it != v[i].end() ; ++it){\n            if(binary_search(v[j].begin(),v[j].end(),*it)){\n              vec.push_back(P(s[i],s[j]));\n              break;\n            }\n          }\n        }\n      }\n    }\n    int len = vec.size();\n    for(int i = 0 ; i < len ; i++){\n      if(vec[i].first > vec[i].second){\n        swap(vec[i].first,vec[i].second);\n      }\n    }\n    sort(vec.begin(),vec.end());\n    for(int i = 0 ; i < len ; i++){\n      cout << vec[i].first << \",\" << vec[i].second << endl;\n    }\n    cout << len << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\ntypedef complex<ld> Point;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n\nint dp[17][17];\nint logdist(string s, string t) {\n\tint ls = s.length(), lt = t.length();\n\trep(i, ls + 1) {\n\t\trep(j, lt + 1) {\n\t\t\tdp[i][j] = mod;\n\t\t}\n\t}\n\tdp[0][0] = 0;\n\trep(i, ls+1) {\n\t\trep(j, lt + 1) {\n\t\t\tif (i < ls) {\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + 1);\n\t\t\t}\n\t\t\tif (j < lt) {\n\t\t\t\tdp[i][j + 1] = min(dp[i][j + 1], dp[i][j] + 1);\n\t\t\t}\n\t\t\tif (i < ls&&j < lt) {\n\t\t\t\tif (s[i] == t[j]) {\n\t\t\t\t\tdp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[ls][lt];\n}\nint dist(string s, string t) {\n\tif (s.length() < t.length()) {\n\t\tswap(s, t);\n\t}\n\tint ret = logdist(s, t);\n\tint len = s.length();\n\tif (len - t.length() >= 2)return ret;\n\tif (s.length() == t.length()) {\n\t\trep(i, len - 1) {\n\t\t\trep(j, len - 1) {\n\t\t\t\tstring u = s;\n\t\t\t\tswap(u[i], u[i + 1]);\n\t\t\t\tswap(u[j], u[j + 1]);\n\t\t\t\tif (u == t)ret = min(ret, 2);\n\t\t\t}\n\t\t}\n\t\trep(i, len - 1) {\n\t\t\tstring u = s;\n\t\t\tswap(u[i], u[i + 1]);\n\t\t\tint cnt = 0;\n\t\t\trep(j, len) {\n\t\t\t\tif (u[j] != t[j])cnt++;\n\t\t\t}\n\t\t\tif (cnt == 0)ret = min(ret, 1);\n\t\t\telse if (cnt == 1)ret = min(ret, 2);\n\t\t}\n\t\trep(i, len - 1) {\n\t\t\tstring u = t;\n\t\t\tswap(u[i], u[i + 1]);\n\t\t\tint cnt = 0;\n\t\t\trep(j, len) {\n\t\t\t\tif (u[j] != s[j])cnt++;\n\t\t\t}\n\t\t\tif (cnt == 0)ret = min(ret, 1);\n\t\t\telse if (cnt == 1)ret = min(ret, 2);\n\t\t}\n\t}\n\telse {\n\t\trep(i, len) {\n\t\t\tstring u = s;\n\t\t\tu.erase(u.begin() + i);\n\t\t\trep(j, len - 2) {\n\t\t\t\tstring z = u;\n\t\t\t\tswap(z[j], z[j + 1]);\n\t\t\t\tif (z == t)ret = min(ret, 2);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nvoid solve() {\n\tint n, d;\n\twhile (cin >> n, n) {\n\t\tint d; cin >> d;\n\t\tvector<string> v(n);\n\t\tvector<pair<string, string>> ans;\n\t\trep(i, n) {\n\t\t\tcin >> v[i];\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\trep(i, v.size()) {\n\t\t\tRep(j, i + 1, v.size()) {\n\t\t\t\tif (dist(v[i], v[j]) <= d) {\n\t\t\t\t\tans.push_back({ v[i],v[j] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(ans.begin(), ans.end());\n\t\trep(i, ans.size()) {\n\t\t\tcout << ans[i].first << \",\" << ans[i].second << endl;\n\t\t}\n\t\tcout << ans.size() << endl;\n\t}\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nvoid transforms(const string& s1,set<string>& s){\n    string tmp;\n    for(int i = 0; i < s1.length();i++){\n        tmp = s1;\n        tmp.erase(tmp.begin() + i);\n        s.insert(tmp);\n    }\n    for(int i = 0; i <=s1.length();i++){\n        for(int j = 0; j < 26;j++){\n            tmp = s1;\n            char c = 'a' + j;\n            tmp.insert(i,string(1,c));\n            s.insert(tmp);\n        }\n    }\n    for(int i = 0; i < s1.length();i++){\n        for(int j = 0; j < 26;j++){\n            tmp = s1;\n            char c = 'a' + j;\n            tmp.replace(i,1,string(1,c));\n            s.insert(tmp);\n        }\n    }\n    for(int i = 0; i < s1.length() - 1;i++){\n        tmp = s1;\n        swap(tmp[i],tmp[i+1]);\n        s.insert(tmp);\n    }\n}\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n,d;\n    vector<pii> res;\n    vector<string> name;\n    while(cin >> n, n){\n        cin >> d;\n        res.clear();\n        name.clear();\n        name.resize(n);\n        for(int i = 0; i < n;i++){\n            cin >> name[i];\n        }\n        sort(name.begin(),name.end());\n        if(d == 1){\n            set<string> s;\n            for(int i = 0; i < n - 1;i++){\n                s.clear();\n                transforms(name[i],s);\n                for(int j = i + 1; j < n;j++){\n                    if(s.find(name[j]) != s.end()){\n                        res.push_back({i,j});\n                    }\n                }\n            }\n        }else{\n            vector<set<string>> s;\n            for(int i = 0; i < n;i++){\n                transforms(name[i],s[i]);\n            }\n //          set<string> s1;\n //           set<string> s2;\n            for(int i = 0; i < n-1;i++){\n                for(int j = i + 1; j < n;j++){\n //                   s1.clear(); s2.clear();\n //                   transforms(name[i],s1);\n //                   transforms(name[j],s2);\n                    for(auto tmp_s:s[i]){\n                        if(s[j].find(tmp_s) != s[j].end()){\n                            res.push_back({i,j});\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        \n        for(auto ans:res){\n            cout << name[ans.first] << \",\" <<name[ans.second]<<endl;\n        }\n        cout << res.size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<string,string> P;\n\nint N, D;\nstring t[202];\nvector<string> vecs[202];\n\nvoid change(string v, vector<string> &res){\n  res.clear();\n  string s = v;\n  \n  for(int a = 0; a < s.length() - 1; a++){\n    swap(s[a], s[a + 1]);\n    res.push_back(s);\n    swap(s[a], s[a + 1]);\n  }\n  \n  for(char ch = 'a'; ch <= 'z'; ch++){\n    for(int j = 0; j < v.length(); j++){\n      s = v;\n      s[j] = ch;\n      res.push_back(s);\n      s[j] = v[j];\n    }\n  \n    for(int j = 0; j < v.length() + 1; j++){\n      s = v.substr(0, j) + ch + v.substr(j);\n      res.push_back(s);\n    }\n  }\n  \n  for(int j = 0; j < v.length(); j++){\n    s = v.substr(0, j) + v.substr(j + 1);\n    res.push_back(s);\n  }\n}\n/*\nvoid change(string s, vector<string> &st){\n  st.clear();\n\n  int n = s.size();\n\n  //delete\n  for(int i = 0; i < n; i++){\n    string s2 = s;\n    s2.erase(s2.begin() + i);\n    st.push_back(s2);\n  }\n\n  for(char ch = 'a'; ch <= 'z'; ch++){\n    //insert\n    for(int i = 0; i <= n; i++){\n      string s2 = s;\n      s2.insert(s2.begin() + i, ch);\n      st.push_back(s2);\n    }\n\n    //replace\n    for(int i = 0; i < n; i++){\n      string s2 = s;\n      s2[i] = ch;\n      st.push_back(s2);\n    }\n  }\n\n  //swap\n  for(int i = 0; i < n - 1; i++){\n    string s2 = s;\n    swap(s2[i], s2[i + 1]);\n    st.push_back(s2);\n  }\n}\n*/\n\nint main(){\n  while(cin >> N >> D){\n    for(int i = 0; i < N; i++){\n      cin >> t[i];\n      change(t[i], vecs[i]);\n      sort(vecs[i].begin(), vecs[i].end());\n    }\n\n    vector<P> vt;\n\n    for(int i = 0; i < N; i++){\n      for(int j = i + 1; j < N; j++){\n        bool flg = false;\n\n        if(binary_search(vecs[j].begin(), vecs[j].end(), t[i])){\n          flg = true;\n        }\n\n        if(!flg && D == 2){\n          for(int k = 0; k < vecs[i].size(); k++){\n            if(binary_search(vecs[j].begin(), vecs[j].end(), vecs[i][k])){\n              flg = true;\n              break;\n            }\n          }\n        }\n\n        if(flg){\n          if(t[i] < t[j]) vt.push_back(P(t[i], t[j]));\n          else            vt.push_back(P(t[j], t[i]));\n        }\n      }\n    }\n\n    sort(vt.begin(), vt.end());\n\n    for(int i = 0; i < vt.size(); i++){\n      cout << vt[i].first << \",\" << vt[i].second << endl;\n    }\n    cout << vt.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define FOR(it,o)  for(__typeof((o).begin()) it =(o).begin();it != (o).end();it++)\n#define pb         push_back\n#define mp         make_pair\n\n\ntypedef unsigned long long           ull;\ntypedef pair<string,string> pss;\ntypedef vector<pss>         vpss;\n\nconst ull tmp = 10007;\n\null calchash(string &in){\n  ull ret= 0;\n  rep(i,in.size()){\n    ret=ret*tmp + in[i];\n  }\n  return ret;\n}\n\n\nbool isok[200][200];\nvoid ed1(vector<string>&in,set<ull> *S){\n  rep(i,in.size()){\n    REP(j,i+1,in.size()){\n      if (S[j].find(calchash(in[i])) != S[j].end()){\n\tisok[i][j] = true;\n      }\n    }    \n  }\n}\n\t \nvoid ed2(vector<string> &in,set<ull> *S){\n  rep(i,in.size()){\n    REP(j,i+1,in.size()){\n      if (isok[i][j])continue;\n      FOR(it,S[i]){\n\tif (S[j].find(*it) != S[j].end()){\n\t  isok[i][j]=true;\n\t  break;\n\t}\n      }\n    }\n  }\n}\n\nvoid del_string(string &in,set<ull>&S){\n  rep(i,in.size()){\n    string tmp = in;\n    tmp.erase(tmp.begin()+i);\n    S.insert(calchash(tmp));\n  }\n}\n\nvoid insert_string(string &in,set<ull>&S){\n  rep(i,in.size()+1){\n    rep(j,26){\n      string tmp=in.substr(0,i);\n      tmp+=string(1,'a'+j);\n      tmp+=in.substr(i);\n      S.insert(calchash(tmp));\n    }\n  }\n}\n\nvoid replace_string(string &in,set<ull>&S){\n  rep(i,in.size()){\n    char tmp = in[i];\n    rep(j,26){\n      in[i]='a'+j;\n      S.insert(calchash(in));\n    }\n    in[i]=tmp;\n  }\n}\n\nvoid swap_string(string&in,set<ull>&S){\n  rep(i,(int)in.size()-1){\n    swap(in[i],in[i+1]);\n    S.insert(calchash(in));\n    swap(in[i],in[i+1]);\n  }\n}\n\nvoid make_string(vector<string>& in,set<ull> *S){\n  rep(i,in.size()){\n    del_string(in[i],S[i]);\n    insert_string(in[i],S[i]);\n    replace_string(in[i],S[i]);\n    swap_string(in[i],S[i]);\n  }\n}\n\nvoid solve(vector<string>in,set<ull>*S,int d){\n  int n=in.size();\n  make_string(in,S);\n  ed1(in,S);\n  if (d==2)ed2(in,S);\n  int cnt=0;\n  rep(i,n){\n    rep(j,n)if (isok[i][j])cnt++,cout<<in[i]<<\",\"<<in[j]<<endl;\n  }\n  cout << cnt << endl;\n}\n\nvoid test(){\n  string in=\"test\";\n  set<ull> S;\n  insert_string(in,S);\n}\n\nmain(){\n  //test();\n  int n,d;\n  while(cin>>n>>d && n){\n    vector<string> in;\n    rep(i,n)rep(j,n)isok[i][j]=false;\n    set<ull> S[n];\n    rep(i,n){\n      string tmp;\n      cin>>tmp;\n      in.pb(tmp);\n    }\n    sort(ALL(in));\n    rep(i,in.size())S[i].insert(calchash(in[i]));\n    solve(in,S,d);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    for(;;){\n        int n, d;\n        cin >> n >> d;\n        if(n == 0)\n            return 0;\n\n        vector<string> s(n);\n        for(int i=0; i<n; ++i)\n            cin >> s[i];\n        sort(s.begin(), s.end());\n\n        vector<set<string> > vss(n);\n        for(int i=0; i<n; ++i){\n            int m = s[i].size();\n            /* delete */\n            for(int j=0; j<m; ++j){\n                string t = s[i];\n                t.erase(j, 1);\n                vss[i].insert(t);\n            }\n            /* insert */\n            for(int j=0; j<m+1; ++j){\n                for(int k=0; k<26; ++k){\n                    string t = s[i];\n                    t.insert(t.begin()+j, 'a'+k);\n                    vss[i].insert(t);\n                }\n            }\n            /* replace */\n            for(int j=0; j<m; ++j){\n                for(int k=0; k<26; ++k){\n                    string t = s[i];\n                    t[j] = 'a'+k;\n                    vss[i].insert(t);\n                }\n            }\n            /* swap */\n            for(int j=0; j<m; ++j){\n                for(int k=j+1; k<m; ++k){\n                    string t = s[i];\n                    swap(t[j], t[k]);\n                    vss[i].insert(t);\n                }\n            }\n        }\n\n        int ret = 0;\n        for(int i=0; i<n; ++i){\n            for(int j=i+1; j<n; ++j){\n                set<string>::iterator it1 = vss[i].begin();\n                if(d == 2){\n                    set<string>::iterator it2 = vss[j].begin();\n                    while(it1 != vss[i].end() && it2 != vss[j].end()){\n                        if(*it1 == *it2){\n                            cout << s[i] << ',' << s[j] << endl;\n                            ++ ret;\n                            break;\n                        }else if(*it1 < *it2){\n                            ++ it1;\n                        }else{\n                            ++ it2;\n                        }\n                    }\n                }else{\n                    while(it1 != vss[i].end()){\n                        if(*it1 == s[j]){\n                            cout << s[i] << ',' << s[j] << endl;\n                            ++ ret;\n                            break;\n                        }\n                        ++ it1;\n                    }\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint DamerauLevensteinDistance(string a,string b)\n{\n\tint m=a.size(),n=b.size();\n\tvvi dp(m+1,vi(n+1,INF));\n\trep(i,m+1) dp[i][0]=i;\n\trep(i,n+1) dp[0][i]=i;\n\tvi last(26,-1);\n\trep(i,m){\n\t\tint pj=-1;\n\t\trep(j,n){\n\t\t\tint pi=last[b[j]-'a'];\n\t\t\tif(a[i]==b[j]) pj=j;\n\t\t\tdp[i+1][j+1]=min({dp[i][j]+(a[i]!=b[j]),dp[i][j+1]+1,dp[i+1][j]+1});\n\t\t\tif(pi==-1 || pj==-1) continue;\n\t\t\tdp[i+1][j+1]=min(dp[i+1][j+1],dp[pi][pj]+(i-pi-1)+(j-pj-1)+1);\n\t\t}\n\t\tlast[a[i]-'a']=i;\n\t}\n\treturn dp[m][n];\n}\n\nint main()\n{\n\tfor(int n,d;cin>>n>>d && n;){\n\t\tvs ws(n);\n\t\trep(i,n) cin>>ws[i];\n\t\t\n\t\tsort(all(ws));\n\t\t\n\t\tint cnt=0;\n\t\trep(i,n) repi(j,i+1,n)\n\t\t\tif(DamerauLevensteinDistance(ws[i],ws[j])<=d){\n\t\t\t\tcout<<ws[i]<<','<<ws[j]<<endl;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-5L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\n// geometry library\n\n#define int long long\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < eps) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < eps);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist + eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n            (aa * target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor() {\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a) {\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this->data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this->data[i][0]) * (obj.data[0][q]);\n                for (int t = 1; t < obj.data[i].size(); ++t) {\n                    hoge += this->data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix& operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\ntemplate <std::uint_fast64_t mod>\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    modint(ll a) : value(((a% mod) + 2 * mod) % mod) {\n\n    }\n\n    constexpr modint operator+(const modint rhs) const {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint& operator+=(const modint rhs) {\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    constexpr modint& operator-=(const modint rhs) {\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    constexpr modint& operator*=(const modint rhs) {\n        value = (value * rhs.value) % mod;\n        return *this;\n    }\n    constexpr modint& operator/=(modint rhs) {\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    bool operator <(modint rhs) const {\n        return value < rhs.value;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nclass Dice {\npublic:\n    vector<ll> vertexs;\n    //Up: 0,Left: 1,Center: 2,Right: 3,Adj: 4, Down: 5\n    Dice(vector<ll> init) :vertexs(init) {\n\n    }\n    //Look from Center\n    void RtoL() {\n        for (int q = 1; q < 4; ++q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void LtoR() {\n        for (int q = 3; q >= 1; --q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void UtoD() {\n        swap(vertexs[5], vertexs[4]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[0], vertexs[2]);\n    }\n    void DtoU() {\n        swap(vertexs[0], vertexs[2]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[5], vertexs[4]);\n    }\n    bool ReachAble(Dice now) {\n        set<Dice> hoge;\n        queue<Dice> next;\n        next.push(now);\n        hoge.insert(now);\n        while (next.empty() == false) {\n            Dice seeing = next.front();\n            next.pop();\n            if (seeing == *this) return true;\n            seeing.RtoL();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.LtoR();\n            seeing.LtoR();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.RtoL();\n            seeing.UtoD();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.DtoU();\n            seeing.DtoU();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n        }\n        return false;\n    }\n    bool operator ==(const Dice& a) {\n        for (int q = 0; q < 6; ++q) {\n            if (a.vertexs[q] != (*this).vertexs[q]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool operator <(const Dice& a) const {\n        return (*this).vertexs < a.vertexs;\n    }\n};\n\npair<Dice, Dice> TwoDimDice(int center, int up) {\n    int target = 1;\n    while (true) {\n        if (center != target && 7 - center != target && up != target && 7 - up != target) {\n            break;\n        }\n        target++;\n    }\n    return mp(Dice(vector<ll>{up, target, center, 7 - target, 7 - center, 7 - up}), Dice(vector<ll>{up, 7 - target, center, target, 7 - center, 7 - up}));\n}\n\ntuple<Dice, Dice, Dice, Dice> OneDimDice(int center) {\n    int bo = min(center, 7 - center);\n    pair<int, int> goa;\n    if (bo == 1) {\n        goa = mp(2, 3);\n    }\n    else if (bo == 2) {\n        goa = mp(1, 3);\n    }\n    else if (bo == 3) {\n        goa = mp(1, 2);\n    }\n    tuple<Dice, Dice, Dice, Dice> now = make_tuple(Dice(vector<ll>{goa.first, goa.second, center, 7 - goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{goa.first, 7 - goa.second, center, goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{7 - goa.first, goa.second, center, 7 - goa.second, 7 - center, goa.first}),\n        Dice(vector<ll>{7 - goa.first, 7 - goa.second, center, goa.second, 7 - center, goa.first}));\n    return now;\n}\n\ntemplate<typename A, typename B>\nclass Dijkstra {\npublic:\n    vector<vector<pair<int, A>>> vertexs;\n    B Cost_Function;\n    Dijkstra(int n, B cost) : Cost_Function(cost) {\n        vertexs = vector<vector<pair<int, A>>>(n, vector<pair<int, A>>{});\n    }\n    ~Dijkstra() {\n        vertexs.clear();\n    }\n    void add_edge(int a, int b, A c) {\n        vertexs[a].push_back(mp(b, c));\n    }\n    vector<ll> build_result(int StartPoint) {\n        vector<ll> dist(vertexs.size(), 2e18);\n        dist[StartPoint] = 0;\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> next;\n        next.push(make_pair(0, StartPoint));\n        while (next.empty() == false) {\n            pair<ll, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (auto x : vertexs[now.second]) {\n                ll now_cost = now.first + Cost_Function(x.second);\n                if (dist[x.first] > now_cost) {\n                    dist[x.first] = now_cost;\n                    next.push(mp(now_cost, x.first));\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nclass Dinic {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n    vector<vector<edge>> Graph;\n    vector<int> level;\n    vector<int> itr;\n    Dinic(int n) {\n        Graph = vector<vector<edge>>(n, vector<edge>());\n    }\n    void add_edge(int a, int b, int cap) {\n        Graph[a].push_back(edge{ b, cap ,(int)Graph[b].size() });\n        Graph[b].push_back(edge{ a,0,(int)Graph[a].size() - 1 });\n    }\n    void bfs(int s) {\n        level = vector<int>(Graph.size(), -1);\n        level[s] = 0;\n        queue<int> next;\n        next.push(s);\n        while (next.empty() == false) {\n            int now = next.front();\n            next.pop();\n            for (auto x : Graph[now]) {\n                if (x.cap == 0) continue;\n                if (level[x.to] == -1) {\n                    level[x.to] = level[now] + 1;\n                    next.push(x.to);\n                }\n            }\n        }\n    }\n    int dfs(int now, int goal, int val) {\n        if (goal == now) return val;\n        for (int& i = itr[now]; i < (int)Graph[now].size(); ++i) {\n            edge& target = Graph[now][i];\n            if (target.cap > 0 && level[now] < level[target.to]) {\n                int d = dfs(target.to, goal, min(val, target.cap));\n                if (d > 0) {\n                    target.cap -= d;\n                    Graph[target.to][target.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int run(int s, int t) {\n        int ans = 0;\n        int f = 0;\n        while (bfs(s), level[t] >= 0) {\n            itr = vector<int>(Graph.size(), 0);\n            while ((f = dfs(s, t, 1e9)) > 0) {\n                ans += f;\n            }\n        }\n        return ans;\n    }\n};\n\n\nclass HLDecomposition {\npublic:\n    vector<vector<int>> vertexs;\n    vector<int> depth;\n    vector<int> backs;\n    vector<int> connections;\n    vector<int> zip, unzip;\n    HLDecomposition(int n) {\n        vertexs = vector<vector<int>>(n, vector<int>());\n        depth = vector<int>(n);\n        zip = vector<int>(n);\n        unzip = zip;\n    }\n    void add_edge(int a,int b) {\n        vertexs[a].push_back(b);\n        vertexs[b].push_back(a);\n    }\n    int depth_dfs(int now, int back) {\n        depth[now] = 0;\n        for (auto x : vertexs[now]) {\n            if (x == back) continue;\n            depth[now] = max(depth[now], 1 + depth_dfs(x, now));\n        }\n        return depth[now];\n    }\n    void dfs(int now,int backing) {\n        zip[now] = backs.size();\n        unzip[backs.size()] = now;\n        backs.push_back(backing);\n        int now_max = -1;\n        int itr = -1;\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (now_max < depth[x]) {\n                now_max = depth[x];\n                itr = x;\n            }\n        }\n        if (itr == -1) return;\n        connections.push_back(connections.back());\n        dfs(itr,backing);\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (x == itr) continue;\n            connections.push_back(zip[now]);\n            dfs(x, backs.size());\n        }\n        return;\n    }\n    void build() {\n        depth_dfs(0, -1);\n        connections.push_back(-1);\n        dfs(0, -1);\n    }\n    vector<pair<int,int>> query(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        vector<pair<int, int>> ans;\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            ans.push_back(mp(backs[a], a + 1));\n            a = connections[a];\n        }\n        if (a > b) swap(a, b);\n        ans.push_back(mp(a, b + 1));\n        return ans;\n    } \n    int lca(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            a = connections[a];\n        }\n        return unzip[min(a, b)];\n    }\n};\n//by ei1333\n//https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz + 1, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n    using G = function< Monoid(Monoid, OperatorMonoid,int) >;\n    using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n\n    int sz, height;\n    vector< Monoid > data;\n    vector< OperatorMonoid > lazy;\n    const F f;\n    const G g;\n    const H h;\n    const Monoid M1;\n    const OperatorMonoid OM0;\n\n\n    LazySegmentTree(int n, const F f, const G g, const H h,\n        const Monoid& M1, const OperatorMonoid OM0)\n        : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n        sz = 1;\n        height = 0;\n        while (sz < n) sz <<= 1, height++;\n        data.assign(2 * sz, M1);\n        lazy.assign(2 * sz, OM0);\n    }\n\n    void set(int k, const Monoid& x) {\n        data[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n        }\n    }\n\n    inline void propagate(int k) {\n        if (lazy[k] != OM0) {\n            lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n            data[k] = reflect(k);\n            lazy[k] = OM0;\n        }\n    }\n\n    inline Monoid reflect(int k) {\n        if (lazy[k] == OM0) return data[k];\n        for (int q = sz; q >= 0; q /= 2) {\n            if (q & k) {\n                return g(data[k], lazy[k], sz / q);\n            }\n        }\n    }\n\n    inline void recalc(int k) {\n        while (k >>= 1) data[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n    }\n\n    inline void thrust(int k) {\n        for (int i = height; i > 0; i--) propagate(k >> i);\n    }\n\n    void update(int a, int b, const OperatorMonoid& x) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) lazy[l] = h(lazy[l], x), ++l;\n            if (r & 1) --r, lazy[r] = h(lazy[r], x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n\n    Monoid query(int a, int b) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        Monoid L = M1, R = M1;\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) L = f(L, reflect(l++));\n            if (r & 1) R = f(reflect(--r), R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) {\n        return query(k, k + 1);\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            propagate(a);\n            Monoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, reflect(1)))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        thrust(a + sz);\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, reflect(a));\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(reflect(1), R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        thrust(b + sz - 1);\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(reflect(--b), R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\n\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\nvector<string> calc(string now,int d) {\n    if (d == 0) return vector<string>{now};\n    vector<string> ans;\n    REP(i, now.length() - 1) {\n        swap(now[i], now[i + 1]);\n        vector<string> next = calc(now, d - 1);\n        for (auto x : next) {\n            ans.push_back(x);\n        }\n        swap(now[i], now[i + 1]);\n    }\n    REP(i, now.length() + 1) {\n        if(i < now.length()){\n            {\n                string b = now;\n                b.erase(b.begin() + i);\n                vector<string> next = calc(b, d - 1);\n                for (auto x : next) {\n                    ans.push_back(x);\n                }\n            }\n            REP(q, 26) {\n                string b = now;\n                b[i] = 'a' + q;\n                vector<string> next = calc(b, d - 1);\n                for (auto x : next) {\n                    ans.push_back(x);\n                }\n            }\n        }\n        REP(q,26){\n            string b = now;\n            b.insert(b.begin() + i, q + 'a');\n            vector<string> next = calc(b, d - 1);\n            for (auto x : next) {\n                ans.push_back(x);\n            }\n        }\n    }\n    return ans;\n}\n\nvoid solve(){\n    while (true) {\n        int n, d;\n        cin >> n;\n        if (n == 0) return;\n        cin >> d;\n        vector<string> ans;\n        map<string, vector<string>> gogos;\n        {\n            REP(i, n) {\n                string a;\n                cin >> a;\n                vector<string> now = calc(a, 1);\n                sort(ALL(now));\n                now.erase(unique(ALL(now)), now.end());\n                for (auto x : now) {\n                    for (auto y : gogos[x]) {\n                        ans.push_back(min(y, a) + \",\" + max(a, y));\n                    }\n                    if(d == 2)\n                    gogos[x].push_back(a);\n                }\n                gogos[a].push_back(a);\n            }\n        }\n        sort(ALL(ans));\n        ans.erase(unique(ALL(ans)), ans.end());\n        REP(i, ans.size()) {\n            cout << ans[i] << endl;\n        }\n        cout << ans.size() << endl;\n    }\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double eps = 1e-7;\n\nint main() {\n    int n;\n    double x1, y1, x2, y2, x3, y3, x4, y4;\n    cin >> n;\n    while(n--) {\n        cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4;\n        cout << (abs((x2-x1)*(y4-y3) - (x4-x3)*(y2-y1)) < eps ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nint damerau_levenshtein_distance(const string &a,const string &b,const int alphabet_size){\n    unordered_map<int,int> da;\n    unordered_map<int,map<int,int>> d;\n    int maxdist=a.size()+b.size();\n    d[-1][-1]=maxdist;\n    for(int i=0; i<=a.size(); ++i){\n        d[i][-1]=maxdist;\n        d[i][0]=i;\n    }\n    for(int i=0; i<=b.size(); ++i){\n        d[-1][i]=maxdist;\n        d[0][i]=i;\n    }\n    for(int i=1; i<=a.size(); ++i){\n        int db=0;\n        for(int j=1; j<=b.size(); ++j){\n            int k=da[b[j-1]],l=db,cost;\n            if(a[i-1]==b[j-1]){\n                cost=0;\n                db=j;\n            }else cost=1;\n            d[i][j]=min({d[i-1][j-1]+cost,d[i][j-1]+1,d[i-1][j]+1,d[k-1][l-1]+(i-k-1)+1+(j-l-1)});\n        }\n        da[a[i-1]]=i;\n    }\n    return d[a.size()][b.size()];\n}\n\nvoid solve(int n){\n    int d;\n    vector<string> name(n);\n    cin >> d;\n    rep(i,0,n) cin >> name[i];\n    sort(name.begin(),name.end());\n\n    int count=0;\n    rep(i,0,n){\n        rep(j,i+1,n){\n            if(damerau_levenshtein_distance(name[i],name[j],26)>d) continue;\n            ++count;\n            cout << name[i] << \",\" << name[j] << endl;\n        }\n    }\n    cout << count << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int N = 1e6;\nvi graph[N];\n\nusing ResElem = tuple<int, int>;\nset<ResElem> s;\n\ninline void add_edge(int a, int b){\n    graph[a].emplace_back(b);\n    graph[b].emplace_back(a);\n}\n\nint d, n;\nmap<string, int> s2i;\nmap<int, string> i2s;\n\nvoid dfs(int sv, int v, int depth){\n    if(depth > d) return;\n    if(sv != v and v < n){\n        string a = i2s[v], b = i2s[sv];\n        if(a > b) swap(a, b);\n        s.insert(ResElem(s2i[a], s2i[b]));\n    }\n\n    for(auto& nv : graph[v]){\n        dfs(sv, nv, depth + 1);\n    }\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(; cin >> n >> d, n;){\n        vector<string> names(n);\n        for(auto& e : names) cin >> e;\n\n        s2i.clear();\n        i2s.clear();\n        int idx = 0;\n        auto add_vertex = [&](string& name){\n            if(s2i.find(name) == end(s2i)){\n                s2i[name] = idx; i2s[idx] = name; idx++;\n            }\n            return s2i[name];\n        };\n        for(auto& e : names) add_vertex(e);\n\n        rep(i, N) graph[i].clear();\n        for(auto& cur : names){\n            string next;\n            int len = cur.size();\n            int v = s2i[cur];\n\n            // delete\n            rep(i, len){\n                next = cur.substr(0, i) + cur.substr(i + 1);\n                int nv = add_vertex(next);\n                add_edge(v, nv);\n            }\n\n            // insert\n            rep(i, len + 1){\n                rep(j, 'z' - 'a' + 1){\n                    char c = (char)('a' + j);\n                    next = cur.substr(0, i) + c + cur.substr(i);\n                    int nv = add_vertex(next);\n                    add_edge(v, nv);\n                }\n            }\n\n            // replace\n            rep(i, len){\n                rep(j, 'z' - 'a' + 1){\n                    char c = (char)('a' + j);\n                    next = cur.substr(0, i) + c;\n                    if(i + 1 < len) next += cur.substr(i + 1);\n                    int nv = add_vertex(next);\n                    add_edge(v, nv);\n                }\n            }\n\n            // swap\n            rep(i, len - 1){\n                next = cur;\n                swap(next[i], next[i + 1]);\n                int nv = add_vertex(next);\n                add_edge(v, nv);\n            }\n        }\n\n        s.clear();\n        rep(i, n){\n            dfs(i, i, 0);\n        }\n\n        for(auto& e : s){\n            int a, b; tie(a, b) = e;\n            cout << i2s[a] << \",\" << i2s[b] << endl;\n        }\n        cout << s.size() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <stdlib.h>\n\nusing namespace std;\n\nint n, d;\nvector<string> vec;\n\nbool contain(string &a, string &b)\n{\n\tstring s, t;\n\tif(a.size() > b.size()) s = a, t = b;\n\telse s = b, t = a;\n\t\n\tint pos = 0;\n\tfor(int i = 0; i < s.size(); i++){\n\t\tif(pos < t.size() && s[i] == t[pos]) pos++;\n\t}\n\treturn pos >= t.size();\n}\n\nbool check(string &s, string &t, int d)\n{\n\tint dif = 0;\n\tvector<int> vec;\n\t\n\tfor(int i = 0; i < s.size(); i++){\n\t\tif(s[i] != t[i]){\n\t\t\tdif++;\n\t\t\tvec.push_back(i);\n\t\t}\n\t}\n\t\n\tif(dif <= d) return true;\n\t\n\tif(d == 1){\n\t\tif(dif > 2) return false;\n\t\treturn vec[0] + 1 == vec[1] && s[vec[0]] == t[vec[1]] && s[vec[1]] == t[vec[0]];\n\t}\n\tif(d == 2){\n\t\tfor(int i = 0; i < s.size(); i++){\n\t\t\tstring u = s.substr(0, i) + s.substr(i+1);\n\t\t\tif(contain(u, t)) return true;\n\t\t}\n\t\tif(dif == 4){\n\t\t\treturn (vec[0] + 1 == vec[1] && s[vec[0]] == t[vec[1]] && s[vec[1]] == t[vec[0]])\n\t\t\t&& (vec[2] + 1 == vec[3] && s[vec[2]] == t[vec[3]] && s[vec[3]] == t[vec[2]]);\n\t\t}\n\t\tif(dif == 3){\n\t\t\tif(vec[0] + 1 != vec[1]) \n\t\t\t\treturn (vec[1] + 1 == vec[2] && s[vec[1]] == t[vec[2]] && s[vec[2]] == t[vec[1]]);\n\t\t\tif(vec[1] + 1 != vec[2]) \n\t\t\t\treturn (vec[0] + 1 == vec[1] && s[vec[0]] == t[vec[1]] && s[vec[1]] == t[vec[0]]);\n\t\t\t\n\t\t\tif(s[vec[0]] == t[vec[1]] && s[vec[1]] == t[vec[0]]) return true;\n\t\t\tif(s[vec[1]] == t[vec[2]] && s[vec[2]] == t[vec[1]]) return true;\n\t\t\tif(s[vec[0]] == t[vec[1]] && s[vec[1]] == t[vec[2]] && s[vec[2]] == t[vec[0]]) return true;\n\t\t\tif(s[vec[0]] == t[vec[1]] && s[vec[1]] == t[vec[2]] && s[vec[2]] == t[vec[0]]) return true;\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tcin >> d;\n\t\t\n\t\tstring s;\n\t\tvec.clear();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> s;\n\t\t\tvec.push_back(s);\n\t\t}\n\t\tsort(vec.begin(), vec.end());\n\t\t\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < vec.size(); i++){\n\t\t\tfor(int j = 0; j < vec.size(); j++){\n\t\t\t\tif(i >= j) continue;\n\t\t\t\t\n\t\t\t\tint dif = abs((int)vec[i].size() - (int)vec[j].size());\n\t\t\t\tif(dif > d) continue;\n\t\t\t\tif(dif == d) if(contain(vec[i], vec[j])) goto NEAR;\n\t\t\t\t\n\t\t\t\tif(d == 2 && dif == 1){\n\t\t\t\t\tstring s, t;\n\t\t\t\t\tif(vec[i].size() > vec[j].size()) s = vec[i], t = vec[j];\n\t\t\t\t\telse s = vec[j], t = vec[i];\n\t\t\t\t\tfor(int k = 0; k < s.size(); k++){\n\t\t\t\t\t\tstring u = s.substr(0, k) + s.substr(k+1);\n\t\t\t\t\t\tif(check(u, t, 1)) goto NEAR;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(check(vec[i], vec[j], d)) goto NEAR;\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tNEAR:;\n\t\t\t\tcnt++;\n\t\t\t\tcout << vec[i] << \",\" << vec[j] << endl;\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define FOR(it,o)  for(__typeof((o).begin()) it =(o).begin();it != (o).end();it++)\n#define pb         push_back\n#define mp         make_pair\n\n\ntypedef unsigned long long           ull;\ntypedef pair<string,string> pss;\ntypedef vector<pss>         vpss;\n\nconst ull tmp = 100000007;\n\null calchash(string &in){\n  ull ret= 0;\n  rep(i,in.size()){\n    ret=ret*tmp + in[i];\n  }\n  return ret;\n}\n\n\nbool isok[200][200];\nvoid ed1(vector<string>&in,set<ull> *S){\n  rep(i,in.size()){\n    REP(j,i+1,in.size()){\n      if (S[j].find(calchash(in[i])) != S[j].end()){\n\tisok[i][j] = true;\n      }\n    }    \n  }\n}\n\t \nvoid ed2(vector<string> &in,set<ull> *S){\n  rep(i,in.size()){\n    REP(j,i+1,in.size()){\n      if (isok[i][j])continue;\n      FOR(it,S[i]){\n\tif (S[j].find(*it) != S[j].end()){\n\t  isok[i][j]=true;\n\t  break;\n\t}\n      }\n    }\n  }\n}\n\nvoid del_string(string &in,set<ull>&S){\n  rep(i,in.size()){\n    string tmp = in;\n    tmp.erase(tmp.begin()+i);\n    S.insert(calchash(tmp));\n  }\n}\n\nvoid insert_string(string &in,set<ull>&S){\n  rep(i,in.size()){\n    rep(j,26){\n      string tmp=in.substr(0,i);\n      tmp+=string(1,'a'+j);\n      tmp+=in.substr(i);\n      S.insert(calchash(tmp));\n    }\n  }\n}\n\nvoid replace_string(string &in,set<ull>&S){\n  rep(i,in.size()){\n    char tmp = in[i];\n    rep(j,26){\n      in[i]='a'+j;\n      S.insert(calchash(in));\n    }\n    in[i]=tmp;\n  }\n}\n\nvoid swap_string(string&in,set<ull>&S){\n  rep(i,(int)in.size()-1){\n    swap(in[i],in[i+1]);\n    S.insert(calchash(in));\n    swap(in[i],in[i+1]);\n  }\n}\n\nvoid make_string(vector<string>& in,set<ull> *S){\n  rep(i,in.size()){\n    del_string(in[i],S[i]);\n    insert_string(in[i],S[i]);\n    replace_string(in[i],S[i]);\n    swap_string(in[i],S[i]);\n  }\n}\n\nvoid solve(vector<string>in,set<ull>*S,int d){\n  int n=in.size();\n  make_string(in,S);\n  ed1(in,S);\n  if (d==2)ed2(in,S);\n  int cnt=0;\n  rep(i,n){\n    rep(j,n)if (isok[i][j])cnt++,cout<<in[i]<<\",\"<<in[j]<<endl;\n  }\n  cout << cnt << endl;\n}\n\nmain(){\n  int n,d;\n  while(cin>>n>>d && n){\n    vector<string> in;\n    rep(i,n)rep(j,n)isok[i][j]=false;\n    set<ull> S[n];\n    rep(i,n){\n      string tmp;\n      cin>>tmp;\n      in.pb(tmp);\n    }\n    sort(ALL(in));\n    solve(in,S,d);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\ntypedef pair<string,string> s2;\nint n,d;\nstring name[210];\nunordered_map<string,int> memo;\n\nvoid dfs(int cur,string s,const string &target,int cost,int &mini){\n  if( cost >= mini ) return;\n  if( cost > d ) return;\n  //cout << s << endl;\n  if( cur >= target.size() ) {\n    rep(i,s.size()) if( i >= target.size() && s[i] != ' ' ) ++cost;\n    mini = min(mini,cost);\n\n    return;\n  }\n  if( s[cur] == target[cur] ) {\n    dfs(cur+1,s,target,cost,mini);\n    return;\n  }\n\n  if( memo.count(s) ) if( memo[s] <= cost )return;\n\n  string ns;\n  //  Delete\n  if( s[cur] != ' ' ) {\n    ns = s.substr(0,cur) + s.substr(cur+1) + \" \";\n    dfs(cur,ns,target,cost+1,mini);\n  }\n\n  // Insert\n  ns = s.substr(0,cur) + target[cur] + s.substr(cur);\n  dfs(cur+1,ns,target,cost+1,mini);\n\n  // Replace\n  if( s[cur] != ' ' ) {\n    ns = s;\n    ns[cur] = target[cur];\n    dfs(cur+1,ns,target,cost+1,mini);\n  }\n\n  // Swap\n  ns = s;\n  if( ns[cur+1] == target[cur] ) {\n    swap(ns[cur+1],ns[cur]);\n    dfs(cur+1,ns,target,cost+1,mini);\n    swap(ns[cur+1],ns[cur]);\n  }\n  if( memo.count(s) ) memo[s] = min(memo[s],cost);\n  else memo[s] = cost;\n}\n\nint compute(string a,string b){\n  if( (int)a.size() > (int)b.size() ) swap(a,b);\n  a = a + string((int)b.size()-(int)a.size(),' ');\n  memo.clear();\n  int mini = b.size();\n  dfs(0,a,b,0,mini);\n  return mini;\n}\n\nint main(){\n\n\n\n\n  while( cin >> n,n ){\n    cin >> d;\n    rep(i,n) cin >> name[i];\n    vector<s2> vec;\n    rep(i,n) REP(j,i+1,n){\n      int dist = compute(name[i],name[j]);\n      string a = name[i], b = name[j];\n      if( a > b ) swap(a,b);\n      if( dist <= d ) vec.push_back(s2(a,b));\n    }\n    sort(vec.begin(),vec.end());    \n    rep(i,vec.size()) cout << vec[i].first << \",\" << vec[i].second << endl;\n    cout << (int)vec.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nbool check(string a,string b,int d){\n  if(a.size()<b.size())swap(a,b);\n  if(a==b) return 1;\n  int A = a.size(),B=b.size();\n  if(d==0||A-B>d)return 0;\n\n\n  //erase\n  for(int i=0;i<A;i++){\n    char ch = a[i];\n    a.erase(a.begin()+i);\n    if(check(a,b,d-1))return 1;\n    a.insert(a.begin()+i,ch);\n  }\n\n  if(A!=B) return 0;\n\n  //change\n  int cnt=0;\n  for(int i=0;i<A;i++) cnt+=a[i]!=b[i];\n  if(cnt<=d)return 1;\n  if(cnt>4) return 0;\n  \n\n  //swap\n  for(int i=0;i<A-1;i++){\n    if(a[i]==a[i+1]||a[i+1]!=b[i]||a[i]!=b[i+1])continue;\n    swap(a[i],a[i+1]);\n    if(check(a,b,d-1))return 1;\n    swap(a[i],a[i+1]);\n  }\n  return 0;\n}\n\nint main(){\n  int n,d;\n  while(cin>>n,n){\n    cin>>d;\n    string str[201];\n    for(int i=0;i<n;i++)cin>>str[i];\n    sort(str,str+n);\n\n    int cnt=0;    \n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++)\n\tif(check(str[i],str[j],d)) cout<<str[i]<<\",\"<<str[j]<<endl,cnt++;\n    cout<<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\ntypedef pair<string,string> s2;\nint n,d;\nstring name[210];\nunordered_set<string> memo;\n\nvoid dfs(int cur,string s,const string &target,int cost,int &mini){\n  if( cost >= mini ) return;\n  if( cost > d ) return;\n  //cout << s << endl;\n  if( cur >= target.size() ) {\n    rep(i,s.size()) if( i >= target.size() && s[i] != ' ' ) ++cost;\n    mini = min(mini,cost);\n\n    return;\n  }\n  if( s[cur] == target[cur] ) {\n    dfs(cur+1,s,target,cost,mini);\n    return;\n  }\n\n  if( memo.count(s) ) return;\n\n  string ns;\n  //  Delete\n  if( s[cur] != ' ' ) {\n    ns = s.substr(0,cur) + s.substr(cur+1) + \" \";\n    dfs(cur,ns,target,cost+1,mini);\n  }\n\n  // Insert\n  ns = s.substr(0,cur) + target[cur] + s.substr(cur);\n  dfs(cur+1,ns,target,cost+1,mini);\n\n  // Replace\n  if( s[cur] != ' ' ) {\n    ns = s;\n    ns[cur] = target[cur];\n    dfs(cur+1,ns,target,cost+1,mini);\n  }\n\n  // Swap\n  ns = s;\n  if( ns[cur+1] == target[cur] ) {\n    swap(ns[cur+1],ns[cur]);\n    dfs(cur+1,ns,target,cost+1,mini);\n    swap(ns[cur+1],ns[cur]);\n  }\n  memo.insert(s);\n}\n\nint compute(string a,string b){\n  if( (int)a.size() > (int)b.size() ) swap(a,b);\n  a = a + string((int)b.size()-(int)a.size(),' ');\n  memo.clear();\n  int mini = b.size();\n  dfs(0,a,b,0,mini);\n  return mini;\n}\n\nint main(){\n\n  while( cin >> n,n ){\n    cin >> d;\n    rep(i,n) cin >> name[i];\n    vector<s2> vec;\n    rep(i,n) REP(j,i+1,n){\n      int dist = compute(name[i],name[j]);\n      string a = name[i], b = name[j];\n      if( a > b ) swap(a,b);\n      if( dist <= d ) vec.push_back(s2(a,b));\n    }\n    sort(vec.begin(),vec.end());    \n    rep(i,vec.size()) cout << vec[i].first << \",\" << vec[i].second << endl;\n    cout << (int)vec.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n \ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n \ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint edit_dist(const string& s, const string& t){\n  int l1 = s.size();\n  int l2 = t.size();\n  int dp[32][32] = {};\n  REP(i, l1) dp[i + 1][0] = i + 1;\n  REP(j, l2) dp[0][j + 1] = j + 1;\n  REP(i, l1) {\n    REP(j, l2){\n      if(s[i] == t[j]) dp[i + 1][j + 1] = dp[i][j];\n      else dp[i + 1][j + 1] = min(dp[i][j], min(dp[i + 1][j], dp[i][j + 1])) + 1;\n    }\n  }\n  return dp[l1][l2];\n}\nbool check(string s, string t, int D){\n  if(D == 0){\n    if(s == t) return true;\n  }else if(D == 1){\n    if(edit_dist(s, t) <= 1) return true;\n    if(s.size() == t.size()) REP(i, s.size() - 1){\n      swap(s[i], s[i + 1]);\n      if(s == t) return true;\n      swap(s[i], s[i + 1]);\n    }\n  }else if(D == 2){\n    if(edit_dist(s, t) <= 2) return true;\n    REP(i, s.size() - 1){\n      swap(s[i], s[i + 1]);\n      if(edit_dist(s, t) <= 1) return true;\n      if(s.size() == t.size()) REP(k, s.size() - 1) {\n        swap(s[k], s[k + 1]);\n        if(s == t) return true;\n        swap(s[k], s[k + 1]);\n      }\n      swap(s[i], s[i + 1]);\n    }\n    REP(i, s.size() - 2){\n      string ss = s.substr(0, i) + s[i + 2] + s[i] + s.substr(i + 3);\n      if(ss == t) return true;\n    }\n  }else {\n    assert(false);\n  }\n  return false;\n}\nint main(){\n  int N, D;\n  while(cin >> N >> D && N){\n    vector<string> name(N);\n    REP(i, N) cin >> name[i];\n    vector< pair<string, string> > ans;\n    REP(i, N) FOR(j, i + 1, N){\n      if(check(name[i], name[j], D)) ans.push_back(make_pair( min(name[i], name[j]), max(name[i], name[j]) ));\n    }\n    sort(ans.begin(), ans.end());\n    REP(i, ans.size()){\n      printf(\"%s,%s\\n\", ans[i].first.c_str(), ans[i].second.c_str());\n    }\n    printf(\"%d\\n\", (int)ans.size());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool check(string a,string b,int d){\n  if(a.size()<b.size())swap(a,b);\n  if(a==b) return 1;\n  if(d==0||a.empty())return 0;\n\n  //erase\n  for(int i=0;i<a.size();i++){\n    string t = a;\n    t.erase(t.begin()+i);\n    if(check(t,b,d-1))return 1;\n  }\n\n  //swap\n  for(int i=0;i<(int)a.size()-1;i++){\n    swap(a[i],a[i+1]);\n    if(check(a,b,d-1))return 1;\n    swap(a[i],a[i+1]);\n  }\n  \n  //change\n  for(int i=0;i<b.size();i++){\n    char ch = a[i];\n    if(a[i]!=b[i]) a[i] = b[i];\n    if(check(a,b,d-1))return 1;\n    a[i] = ch;\n  }\n  return 0;\n}\n\nint main(){\n  int n,d;\n  while(cin>>n,n){\n    cin>>d;\n    string str[201];\n    for(int i=0;i<n;i++)cin>>str[i];\n    sort(str,str+n);\n\n    int cnt=0;    \n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++)\n\tif(check(str[i],str[j],d)) cout<<str[i]<<\",\"<<str[j]<<endl,cnt++;\n    cout<<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n){\n    int d;\n    vector<string> name(n);\n    cin >> d;\n    rep(i,0,n) cin >> name[i];\n    sort(name.begin(),name.end());\n\n    function<bool(const int,const string&,const string&)> in_neighborhood=[&](int d,const string &s1,const string &s2){\n        if(d==0) return s1==s2;\n        //replace\n        {\n            string t=s2;\n            rep(i,0,s2.size()){\n                rep(j,0,26){\n                    t[i]='a'+j;\n                    if(in_neighborhood(d-1,s1,t)) return true;\n                }\n                t[i]=s2[i];\n            }\n        }\n        //insert\n        {\n            string x;\n            rep(i,0,s2.size()+1){\n                string y=s2.substr(i);\n                rep(j,0,26){\n                    x.push_back('a'+j);\n                    auto t=x+y;\n                    if(in_neighborhood(d-1,s1,t)) return true;\n                    x.pop_back();\n                }\n                x.push_back(s2[i]);\n            }\n        }\n        //delete\n        {\n            string x;\n            rep(i,0,s2.size()){\n                string t=x+s2.substr(i+1);\n                if(in_neighborhood(d-1,s1,t)) return true;\n                x.push_back(s2[i]);\n            }\n        }\n        //swap adjacent\n        {\n            string t=s2;\n            rep(i,0,s2.size()-1){\n                swap(t[i],t[i+1]);\n                if(in_neighborhood(d-1,s1,t)) return true;\n                swap(t[i],t[i+1]);\n            }\n        }\n        return false;\n    };\n\n    int count=0;\n    rep(i,0,n) rep(j,i+1,n){\n        if(name[i].size()>name[j].size()){\n            if(!in_neighborhood(d,name[i],name[j])) continue;\n        }else{\n            if(!in_neighborhood(d,name[j],name[i])) continue;\n        }\n\n        cout << min(name[i],name[j]) << \",\" << max(name[i],name[j]) << endl;\n        ++count;\n    }\n    cout << count << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solve(int n){\n    int d;\n    cin>>d;\n    vector<string> name(n);\n    for(int i=0;i<n;i++) cin>>name[i];\n\n    auto trans=[&](string s){\n        set<string> resp;\n        //insert\n        for(int i=0;i<=s.size();i++){\n            for(int k=0;k<='z'-'a';k++){\n                char x='a'+k;\n                string tmp=s.substr(0,i)+x+s.substr(i);\n                resp.insert(tmp);\n            }\n        }\n        //delete\n        for(int i=0;i<s.size();i++){\n            string tmp=s.substr(0,i)+s.substr(i+1);\n            resp.insert(tmp);\n        }\n        //replace\n        for(int i=0;i<s.size();i++){\n            for(int k=0;k<='z'-'a';k++){\n                char x='a'+k;\n                string tmp=s.substr(0,i)+x+s.substr(i+1);\n                resp.insert(tmp);\n            }\n        }\n        //swap\n        for(int i=0;i+1<s.size();i++){\n            string tmp=s;\n            swap(tmp[i],tmp[i+1]);\n            resp.insert(tmp);\n        }\n        return resp;\n    };\n    vector<set<string>> ss(n);\n    for(int i=0;i<n;i++){\n        ss[i]=trans(name[i]);\n    }\n    set<pair<string,string>> res;\n    if(d==1){\n        for(int i=0;i<n;i++){\n            for(int j=0;j<i;j++){\n                if(ss[j].count(name[i])){\n                    res.insert({min(name[i],name[j]),max(name[i],name[j])});\n                }\n            }\n        }\n    }\n    else{\n        for(int i=0;i<n;i++){\n            for(int j=0;j<i;j++){\n                for(auto &str:ss[i]){\n                    if(ss[j].count(str)){\n                        res.insert({min(name[i],name[j]),max(name[i],name[j])});\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    for(auto p:res) cout<<p.first<<\",\"<<p.second<<endl;\n    cout<<res.size()<<endl;\n}\nint main(){\n    int n;\n    while(cin>>n,n){\n        solve(n);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint getDist(const string& s, const string& t){\n\tint dp[20][20];\n\tfor(int i = 0; i <= s.size(); i++) dp[i][0] = i;\n\tfor(int i = 0; i <= t.size(); i++) dp[0][i] = i;\n\n\tfor(int i = 1; i <= s.size(); i++)\n\t\tfor(int j = 1; j <= t.size(); j++)\n\t\t\tdp[i][j] = min(min(dp[i - 1][j] + 1, dp[i][j - 1] + 1),\n\t\t\t\t\t\t   dp[i - 1][j - 1] + (s[i - 1] != t[j - 1]));\n\treturn (dp[s.size()][t.size()]);\n}\n\nstring name[256];\n\nbool f(string s, string t, int d){\n\tif(s == t) return true;\n\tif(getDist(s, t) <= d) return true;\n\n\tif(d >= 1){\n\t\t// 1???????????????\n\t\tif(s.size() == t.size()){\n\t\t\tfor(int i = 0; i < s.size() - 1; i++){\n\t\t\t\tswap(s[i], s[i + 1]);\n\t\t\t\tif(s == t) return true;\n\t\t\t\tswap(s[i], s[i + 1]);\n\t\t\t}\n\t\t}\n\t}\n\tif(d == 2){\n\t\t// 2???????????????\n\t\tfor(int i = 0; i < s.size() - 1; i++){\n\t\t\tswap(s[i], s[i + 1]);\n\t\t\tfor(int j = 0; j < s.size() - 1; j++){\n\t\t\t\tif(i == j) continue;\n\t\t\t\tswap(s[j], s[j + 1]);\n\t\t\t\tif(s == t) return true;\n\t\t\t\tswap(s[j], s[j + 1]);\n\t\t\t}\n\t\t\tswap(s[i], s[i + 1]);\n\t\t}\n\t\t// 1?????????????????§??¨????????¢1\n\t\tfor(int i = 0; i < s.size() - 1; i++){\n\t\t\tswap(s[i], s[i + 1]);\n\t\t\tif(getDist(s, t) <= 1) return true;\n\t\t\tswap(s[i], s[i + 1]);\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tint n, d;\n\twhile(cin >> n >> d, n){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> name[i];\n\t\t}\n\n\t\tvector<pair<string, string>> ans;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tif(f(name[i], name[j], d)){\n\t\t\t\t\tstring s1 = min(name[i], name[j]);\n\t\t\t\t\tstring s2 = max(name[i], name[j]);\n\t\t\t\t\tans.push_back({ s1, s2 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(ans.begin(), ans.end());\n\t\tfor(auto v : ans){\n\t\t\tcout << v.first + \",\" + v.second << endl;\n\t\t}\n\t\tcout << ans.size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool check(string a,string b,int d){\n  if(a.size()<b.size())swap(a,b);\n  if(a==b) return 1;\n  if(d==0||a.empty())return 0;\n\n\n  //erase\n  for(int i=0;i<a.size();i++){\n    string t = a;\n    t.erase(t.begin()+i);\n    if(check(t,b,d-1))return 1;\n  }\n\n  if(a.size()!=b.size()) return 0;\n\n  //swap\n  for(int i=0;i<(int)a.size()-1;i++){\n    swap(a[i],a[i+1]);\n    if(check(a,b,d-1))return 1;\n    swap(a[i],a[i+1]);\n  }\n\n  \n  //change\n  for(int i=0;i<b.size();i++){\n    char ch = a[i];\n    if(a[i]!=b[i]) a[i] = b[i];\n    if(check(a,b,d-1))return 1;\n    a[i] = ch;\n  }\n  return 0;\n}\n\nint main(){\n  int n,d;\n  while(cin>>n,n){\n    cin>>d;\n    string str[201];\n    for(int i=0;i<n;i++)cin>>str[i];\n    sort(str,str+n);\n\n    int cnt=0;    \n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++)\n\tif(check(str[i],str[j],d)) cout<<str[i]<<\",\"<<str[j]<<endl,cnt++;\n    cout<<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#define INF (1<<29)\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\ntypedef pair<string,string> pss;\n\nint dist(string s,string t) {\n  int d[20][20];\n  fill(d[0],d[20],INF);\n\n  int n=s.size(),m=t.size();\n  for(int i=0;i<=n;i++)d[i][0]=i;\n  for(int i=0;i<=m;i++)d[0][i]=i;\n  \n  int sp[128],tp[128];\n  fill(sp,sp+128,-1);\n  for(int i=0;i<n;i++){\n    fill(tp,tp+128,-1);\n    for(int j=0;j<m;j++){\n      int cost=(s[i]!=t[j]);\n      d[i+1][j+1]=min(min(d[i][j+1],d[i+1][j])+1,d[i][j]+cost);\n      if(sp[t[j]]>=0 && tp[s[i]]>=0)\n\td[i+1][j+1]=min(d[i+1][j+1],d[sp[t[j]]][tp[s[i]]]+cost);\n      tp[t[j]]=j;\n    }\n    sp[s[i]]=i;\n  }\n  return d[n][m]; \n}\n\nint main(void){\n\n  int n,d;\n  while(cin >> n,n){\n    cin >> d;\n    vector<string> v(n);\n    for(int i=0;i<n;i++)cin >> v[i];\n\n    vector<pair<string,string> >res;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(dist(v[i],v[j])<=d){\n\t  res.push_back(pss(min(v[i],v[j]),max(v[i],v[j])));\n\t}\n      }\n    }\n    sort(all(res));\n    for(int i=0;i<res.size();i++)\n      cout << res[i].first << \",\" << res[i].second << endl;\n    cout << res.size() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nint damerau_levenshtein_distance(const string &a,const string &b,const int alphabet_size){\n    unordered_map<int,int> da;\n    unordered_map<int,unordered_map<int,int>> d;\n    int maxdist=a.size()+b.size();\n    d[-1][-1]=maxdist;\n    for(int i=0; i<=a.size(); ++i){\n        d[i][-1]=maxdist;\n        d[i][0]=i;\n    }\n    for(int i=0; i<=b.size(); ++i){\n        d[-1][i]=maxdist;\n        d[0][i]=i;\n    }\n    for(int i=1; i<=a.size(); ++i){\n        int db=0;\n        for(int j=1; j<=b.size(); ++j){\n            int k=da[b[j-1]],l=db,cost;\n            if(a[i-1]==b[j-1]){\n                cost=0;\n                db=j;\n            }else cost=1;\n            d[i][j]=min({d[i-1][j-1]+cost,d[i][j-1]+1,d[i-1][j]+1,d[k-1][l-1]+(i-k-1)+1+(j-l-1)});\n        }\n        da[a[i-1]]=i;\n    }\n    return d[a.size()][b.size()];\n}\n\nvoid solve(int n){\n    int d;\n    vector<string> name(n);\n    cin >> d;\n    rep(i,0,n) cin >> name[i];\n    sort(name.begin(),name.end());\n\n    int count=0;\n    rep(i,0,n){\n        rep(j,i+1,n){\n            if(damerau_levenshtein_distance(name[i],name[j],26)>d) continue;\n            ++count;\n            cout << name[i] << \",\" << name[j] << endl;\n        }\n    }\n    cout << count << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<vector>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int LMAX=16;\n\nint Damerau_Levenshtein(const char *s,const char *t,int INS=1,int DEL=1,int RPL=1,int SWP=1){\n\tint m=strlen(s),n=strlen(t);\n\tstatic int dp[LMAX+1][LMAX+1];\n\n\trep(i,m+1) dp[i][0]=i*DEL;\n\trep(j,n+1) dp[0][j]=j*INS;\n\n\tint s_last[128],t_last[128];\n\tmemset(s_last,-1,sizeof s_last);\n\trep(i,m){\n\t\tmemset(t_last,-1,sizeof t_last);\n\t\trep(j,n){\n\t\t\tint i1=s_last[t[j]],j1=t_last[s[i]];\n\n\t\t\tdp[i+1][j+1]=min(dp[i+1][j]+INS,dp[i][j+1]+DEL);\n\t\t\tdp[i+1][j+1]=min(dp[i+1][j+1],dp[i][j]+(s[i]==t[j]?0:RPL));\n\t\t\tif(i1>=0 && j1>=0){\n\t\t\t\tdp[i+1][j+1]=min(dp[i+1][j+1],dp[i1][j1]+(i-i1-1)*DEL+SWP+(j-j1-1)*INS);\n\t\t\t}\n\n\t\t\tt_last[t[j]]=j;\n\t\t}\n\t\ts_last[s[i]]=i;\n\t}\n\n\treturn dp[m][n];\n}\n\nint main(){\n\tfor(int n,d;scanf(\"%d%d\",&n,&d),n;){\n\t\tchar s[200][20];\n\t\trep(i,n) scanf(\"%s\",s[i]);\n\n\t\tvector< pair<string,string> > ans;\n\t\trep(i,n) rep(j,i) if(Damerau_Levenshtein(s[i],s[j])<=d) {\n\t\t\tif((string)s[i]<s[j]) ans.push_back(make_pair(s[i],s[j]));\n\t\t\telse                  ans.push_back(make_pair(s[j],s[i]));\n\t\t}\n\t\tsort(ans.begin(),ans.end());\n\n\t\trep(i,ans.size()) printf(\"%s,%s\\n\",ans[i].first.c_str(),ans[i].second.c_str());\n\t\tprintf(\"%d\\n\",ans.size());\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\nvector<string> vc[200];\nstring ss[200];\nbool con[200][200];\ntypedef pair<string,string> P;\nvector<P> ans;\nint main(){\n\twhile(true){\n\t\tint n,d;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcin>>d;\n\t\trep(i,n){\n\t\t\tvc[i].clear();\n\t\t\tstring s,sc;\n\t\t\tcin>>s;\n\t\t\tss[i]=s;\n\t\t\tint m=s.size();\n\t\t\trep(j,m){\n\t\t\t\tsc=s;\n\t\t\t\tsc.erase(j,1);\n\t\t\t\tvc[i].pb(sc);\n\t\t\t}\n\t\t\trep(k,m+1){\n\t\t\t\trep(j,26){\n\t\t\t\t\tsc=s;\n\t\t\t\t\tsc.insert(sc.begin()+k,'a'+j);\n\t\t\t\t\tvc[i].pb(sc);\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(k,m){\n\t\t\t\trep(j,26){\n\t\t\t\t\tsc=s;\n\t\t\t\t\tsc[k]='a'+j;\n\t\t\t\t\tvc[i].pb(sc);\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,m-1){\n\t\t\t\tsc=s;\n\t\t\t\tswap(sc[j],sc[j+1]);\n\t\t\t\tvc[i].pb(sc);\n\t\t\t}\n\t\t\tsort(all(vc[i]));\n\t\t\tvc[i].erase(unique(all(vc[i])),vc[i].end());\n\t\t}\n\t\trep(i,n) rep(j,n) con[i][j]=0;\n\t\tif(d==1){\n\t\t\trep(i,n){\n\t\t\t\tstring s=ss[i];\n\t\t\t\trep(j,i){\n\t\t\t\t\tif(binary_search(all(vc[j]),s)) con[i][j]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\trep(i,n){\n\t\t\t\trep(k,vc[i].size()){\n\t\t\t\t\tstring s=vc[i][k];\n\t\t\t\t\trep(j,i){\n\t\t\t\t\t\tif(binary_search(all(vc[j]),s)) con[i][j]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans.clear();\n\t\trep(i,n) rep(j,n){\n\t\t\tif(con[i][j]){\n\t\t\t\tif(ss[i]<ss[j]) ans.pb(P(ss[i],ss[j]));\n\t\t\t\telse ans.pb(P(ss[j],ss[i]));\n\t\t\t}\n\t\t}\n\t\tsort(all(ans));\n\t\trep(i,ans.size()) cout<<ans[i].fs<<\",\"<<ans[i].sc<<endl;\n\t\tcout<<ans.size()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint levenshtein(const string &a, const string &b){\n    int n = a.length();\n    int m = b.length();\n    vector<vector<int>> dp(n+1, vector<int>(m+1));\n    for(int i=0; i<n+1; i++) dp[i][0] = i;\n    for(int j=0; j<m+1; j++) dp[0][j] = j;\n    for(int i=1; i<n+1; i++){\n        for(int j=1; j<m+1; j++){\n            int cost = (a[i-1]==b[j-1])? 0: 1;\n            dp[i][j] = min({dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost});\n        }\n    }\n    return dp[n][m];\n}\n\nint swap_or_replace(string a, string b){\n    int n = a.length();\n    int m = b.length();\n    if(n != m){\n        return max(n, m); \n    }\n    int res = 0;\n    for(int i=0; i<n; i++){\n        if(a[i] == b[i]) continue;\n        res++;\n        if(i<n-1 and a[i]==b[i+1] and a[i+1]==b[i]){\n            b[i+1] = b[i];\n        }\n    }\n    return res;\n}\n\nint dist(string a, string b){\n    int res = levenshtein(a, b);\n    if(a.length() > b.length()) swap(a, b);\n    int n = a.length();\n    int m = b.length();\n    if(n+1 == m){\n        for(int i=0; i<m; i++){\n            string c = b.substr(0, i) +b.substr(i+1, m-i-1);\n            res = min(res, swap_or_replace(a, c)+1);\n        }\n    }\n    if(m == n){\n        for(int d=0; d<2; d++){\n            res = min(res, swap_or_replace(a, b));\n            reverse(a.begin(), a.end());\n            reverse(b.begin(), b.end());\n        }\n    }\n    return res;\n}\n\nint main(){\n    while(1){\n        int n,d;\n        cin >> n >> d;\n        if(n == 0) break;\n\n        vector<string> s(n);\n        for(int i=0; i<n; i++){\n            cin >> s[i];\n        }\n        sort(s.begin(), s.end());\n        int num = 0;\n        for(int i=0; i<n; i++){\n            for(int j=i+1; j<n; j++){\n                if(dist(s[i], s[j]) <= d){\n                    num++;\n                    cout << s[i] << \",\" << s[j] << endl;\n                }\n            }\n        }\n        cout << num << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<string,string> P;\n\nint n,d;\nint ans=0;\nset<string> mp[201];\nint cnt[201][201];\nvector<P> vec;\nstring str[201];\n\nvoid dfs(int v,string s,int nd,int uk=0){\n\tif(nd==0){\n\t\tmp[v].insert(s);\n\t\tfor(int i=0;i+1<s.size();i++){\n\t\t\tswap(s[i],s[i+1]);\n\t\t\tdfs(v,s,nd+1);\n\t\t\tswap(s[i],s[i+1]);\n\t\t}\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tdfs(v,s.substr(0,i)+s.substr(i+1),nd+1);\n\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\tstring gu=\"\";\n\t\t\t\tgu+=('a'+j);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i+1),nd+1,1);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i),nd+1,1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<26;i++){\n\t\t\tstring gu=\"\";\n\t\t\tgu+=('a'+i);\n\t\t\tdfs(v,s+gu,nd+1);\n\t\t}\n\t}else if(nd==1){\n\t\tmp[v].insert(s);\n\t}\n}\n\nvoid dfs2(int v,string s,int nd){\n\tif(nd==0){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(mp[i].find(s)!=mp[i].end()){\n\t\t\t\tcnt[v][i]++;\n\t\t\t\tcnt[i][v]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i+1<s.size();i++){\n\t\t\tswap(s[i],s[i+1]);\n\t\t\tdfs2(v,s,nd+1);\n\t\t\tswap(s[i],s[i+1]);\n\t\t}\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tdfs2(v,s.substr(0,i)+s.substr(i+1),nd+1);\n\t\t}\n\t\tfor(int i=0;i<26;i++){\n\t\t\tstring gu=\"\";\n\t\t\tgu+=('a'+i);\n\t\t\tdfs2(v,s+gu,nd+1);\n\t\t}\n\t}else if(nd==1){\n\t\tif(d==2){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(mp[i].find(s)!=mp[i].end()){\n\t\t\t\t\tcnt[v][i]++;\n\t\t\t\t\tcnt[i][v]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tvec.clear();\n\tfor(int i=0;i<n;i++){\n\t\tmp[i].clear();\n\t}\n\tscanf(\"%d\",&d);\n\tans=0;\n\tmemset(cnt,0,sizeof(cnt));\n\tfor(int i=0;i<n;i++){\n\t\tcin >> str[i];\n\t\tdfs(i,str[i],0);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tdfs2(i,str[i],0);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(cnt[i][j]>0){\n\t\t\t\tans++;\n\t\t\t\tvec.push_back(P(min(str[i],str[j]),max(str[i],str[j])));\n\t\t\t}\n\t\t}\n\t}\n\tsort(vec.begin(),vec.end());\n\tfor(int i=0;i<vec.size();i++){\n\t\tcout << vec[i].first << \",\" << vec[i].second << endl;\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\n//const ll mod = 1000000007;\nint N;\nll d;\nstring S[300];\nset<string> st[300];\n\nset<string> f(string S) {\n    set<string> ret;\n    for(int i = 0; i < S.size(); i++) {\n        for(char a = 'a'; a <= 'z'; a++) {\n            string T = S;\n            T[i] = a;\n            ret.insert(T);\n        }\n        string T = S;\n        T.erase(T.begin() + i);\n        ret.insert(T);\n    }\n    for(int i = 0; i <= S.size(); i++) {\n        for(char a = 'a'; a <= 'z'; a++) {\n            string T = S;\n            T.insert(T.begin() + i, a);\n            ret.insert(T);\n        }\n    }\n    for(int i = 0; i + 1 < S.size(); i++) {\n        string T = S;\n        swap(T[i], T[i+1]);\n        ret.insert(T);\n    }\n    return ret;\n}\n\nvoid solve() {\n    cin >> d;\n    for(int i = 0; i < N; i++) {\n        cin >> S[i];\n    }\n    sort(S, S+N);\n    for(int i = 0; i < N; i++) {\n        st[i] = f(S[i]);\n    }\n    vector<pair<string, string>> ans;\n    for(int i = 0; i < N; i++) {\n        set<string> tmp1 = st[i];\n        for(int j = i + 1; j < N; j++) {\n            set<string> tmp2;\n            tmp2.insert(S[j]);\n            set<string> tmp;\n            if(d == 1) set_intersection(tmp1.begin(), tmp1.end(), tmp2.begin(), tmp2.end(), inserter(tmp, tmp.end()));\n            if(d == 2) set_intersection(tmp1.begin(), tmp1.end(), st[j].begin(), st[j].end(), inserter(tmp, tmp.end()));\n            if(tmp.size() >= 1) ans.push_back({S[i], S[j]});\n        }\n    }\n    for(auto tmp : ans) {\n        cout << tmp.first << \",\" << tmp.second << endl;\n    }\n    cout << ans.size() << endl;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> N) {\n        if(N == 0) break;\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n){\n    int d;\n    vector<string> name(n);\n    cin >> d;\n    rep(i,0,n) cin >> name[i];\n    sort(name.begin(),name.end());\n\n    function<bool(const int,const string&,const string&)> in_neighborhood=[&](int d,const string &s1,const string &s2){\n        if(d==0) return s1==s2;\n        //replace\n        rep(i,0,s2.size()){\n            string t=s2;\n            rep(j,0,26){\n                t[i]='a'+j;\n                if(in_neighborhood(d-1,s1,t)) return true;\n            }\n        }\n        //insert\n        rep(i,0,s2.size()+1){\n            string x=s2.substr(0,i),y=s2.substr(i);\n            rep(j,0,26){\n                x.push_back('a'+j);\n                auto t=x+y;\n                if(in_neighborhood(d-1,s1,t)) return true;\n                x.pop_back();\n            }\n        }\n        //delete\n        rep(i,0,s2.size()){\n            string t=s2.substr(0,i)+s2.substr(i+1);\n            if(in_neighborhood(d-1,s1,t)) return true;\n        }\n        //swap adjacent\n        rep(i,0,s2.size()-1){\n            string t=s2;\n            swap(t[i],t[i+1]);\n            if(in_neighborhood(d-1,s1,t)) return true;\n            swap(t[i],t[i+1]);\n        }\n        return false;\n    };\n\n    int count=0;\n    rep(i,0,n) rep(j,i+1,n){\n        if(name[i].size()>name[j].size()){\n            if(!in_neighborhood(d,name[i],name[j])) continue;\n        }else{\n            if(!in_neighborhood(d,name[j],name[i])) continue;\n        }\n\n        cout << min(name[i],name[j]) << \",\" << max(name[i],name[j]) << endl;\n        ++count;\n    }\n    cout << count << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint LevenshteinDist(const string& s, const string& t)\n{\n    int n = s.size();\n    int m = t.size();\n    vector<vector<int> > minCost(n+2, vector<int>(m+2, INT_MAX));\n    minCost[0][0] = 0;\n    for(int i=0; i<=n; ++i){\n        for(int j=0; j<=m; ++j){\n            minCost[i+1][j] = min(minCost[i+1][j], minCost[i][j] + 1);\n            minCost[i][j+1] = min(minCost[i][j+1], minCost[i][j] + 1);\n            if(i < n && j < m && s[i] == t[j])\n                minCost[i+1][j+1] = min(minCost[i+1][j+1], minCost[i][j]);\n            else\n                minCost[i+1][j+1] = min(minCost[i+1][j+1], minCost[i][j] + 1);\n        }\n    }\n    return minCost[n][m];\n}\n\nint main()\n{\n    for(;;){\n        int n, d;\n        cin >> n >> d;\n        if(n == 0)\n            return 0;\n\n        vector<string> s(n);\n        for(int i=0; i<n; ++i)\n            cin >> s[i];\n        sort(s.begin(), s.end());\n\n        vector<set<string> > vss(n);\n        for(int i=0; i<n; ++i){\n            int m = s[i].size();\n            /* swap */\n            for(int j=0; j<m; ++j){\n                for(int k=j+1; k<m; ++k){\n                    string t = s[i];\n                    swap(t[j], t[k]);\n                    vss[i].insert(t);\n                }\n            }\n        }\n\n        int ret = 0;\n        for(int i=0; i<n; ++i){\n            for(int j=i+1; j<n; ++j){\n                bool confuse = false;\n\n                if(LevenshteinDist(s[i], s[j]) <= d)\n                    confuse = true;\n\n                set<string>::iterator it;\n                for(it=vss[i].begin(); it!=vss[i].end(); ++it){\n                    if(LevenshteinDist(*it, s[j]) <= d-1)\n                        confuse = true;\n                }\n                for(it=vss[j].begin(); it!=vss[j].end(); ++it){\n                    if(LevenshteinDist(s[i], *it) <= d-1)\n                        confuse = true;\n                }\n\n                if(d == 2 && s[i].size() == s[j].size()){\n                    int num = 0;\n                    vector<int> diff(26, 0);\n                    for(unsigned k=0; k<s[i].size(); ++k){\n                        if(s[i][k] != s[j][k]){\n                            ++ num;\n                            ++ diff[s[i][k]-'a'];\n                            -- diff[s[j][k]-'a'];\n                        }\n                    }\n                    if(num <= 4 && count(diff.begin(), diff.end(), 0) == 26)\n                        confuse = true;\n                }\n\n                if(confuse){\n                    cout << s[i] << ',' << s[j] << endl;\n                    ++ ret;\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<set>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\nchar in[20];\nstring str[210];\nset<pair<long long,long long> > lis[210];\nchar ch[2];\ninline pair<long long,long long> conv(string s){\n\tlong long r1=0;\n\tlong long r2=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tif(i<8){\n\t\t\tr1+=((long long)(s[i]-'a'+1))<<(i*5);\n\t\t}else r2+=((long long)(s[i]-'a'+1))<<((i-8)*5);\n\t}\n\treturn make_pair(r1,r2);\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tint b;scanf(\"%d\",&b);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tstr[i]=in;\n\t\t}\n\t\tstd::sort(str,str+a);\n\t\tfor(int i=0;i<a;i++)lis[i].clear();\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=0;j<str[i].size();j++){\n\t\t\t\tstring tmp=str[i].substr(0,j)+str[i].substr(j+1);\n\t\t\t\tlis[i].insert(conv(tmp));\n\t\t\t}\n\t\t\tfor(int j=0;j<=str[i].size();j++){\n\t\t\t\tfor(int k=0;k<26;k++){\n\t\t\t\t\tstring tmp=str[i].substr(0,j);\n\t\t\t\t\tch[0]='a'+k;\n\t\t\t\t\ttmp.append(ch);\n\t\t\t\t\ttmp.append(str[i].substr(j));\n\t\t\t\t\tlis[i].insert(conv(tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<str[i].size();j++){\n\t\t\t\tchar rev=str[i][j];\n\t\t\t\tfor(int k=0;k<26;k++){\n\t\t\t\t\tstr[i][j]='a'+k;\n\t\t\t\t\tlis[i].insert(conv(str[i]));\n\t\t\t\t}\n\t\t\t\tstr[i][j]=rev;\n\t\t\t}\n\t\t\tfor(int j=0;j<str[i].size()-1;j++){\n\t\t\t\tswap(str[i][j],str[i][j+1]);\n\t\t\t\tlis[i].insert(conv(str[i]));\n\t\t\t\tswap(str[i][j],str[i][j+1]);\n\t\t\t}\n\t\t//\tstd::sort(lis[i].begin(),lis[i].end());\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=i+1;j<a;j++){\n\t\t\t\tbool ok=false;\n\t\t\t\tif(b==1){\n\t\t\t\t\tif(lis[i].count(conv(str[j])))ok=true;\n\t\t\t\t}else{\n\t\t\t\t\tfor(set<pair<long long,long long> >::iterator it=lis[j].begin();it!=lis[j].end();it++){\n\t\t\t\t\t\tif(lis[i].count(*it)){\n\t\t\t\t\t\t\tok=true;break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok){\n\t\t\t\t\tret++;\n\t\t\t\t\tprintf(\"%s,%s\\n\",str[i].c_str(),str[j].c_str());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nint damerau_levenshtein_distance(const string &a,const string &b,const int alphabet_size){\n    unordered_map<int,int> da;\n    map<int,unordered_map<int,int>> d;\n    int maxdist=a.size()+b.size();\n    d[-1][-1]=maxdist;\n    for(int i=0; i<=a.size(); ++i){\n        d[i][-1]=maxdist;\n        d[i][0]=i;\n    }\n    for(int i=0; i<=b.size(); ++i){\n        d[-1][i]=maxdist;\n        d[0][i]=i;\n    }\n    for(int i=1; i<=a.size(); ++i){\n        int db=0;\n        for(int j=1; j<=b.size(); ++j){\n            int k=da[b[j-1]],l=db,cost;\n            if(a[i-1]==b[j-1]){\n                cost=0;\n                db=j;\n            }else cost=1;\n            d[i][j]=min({d[i-1][j-1]+cost,d[i][j-1]+1,d[i-1][j]+1,d[k-1][l-1]+(i-k-1)+1+(j-l-1)});\n        }\n        da[a[i-1]]=i;\n    }\n    return d[a.size()][b.size()];\n}\n\nvoid solve(int n){\n    int d;\n    vector<string> name(n);\n    cin >> d;\n    rep(i,0,n) cin >> name[i];\n    sort(name.begin(),name.end());\n\n    int count=0;\n    rep(i,0,n){\n        rep(j,i+1,n){\n            if(damerau_levenshtein_distance(name[i],name[j],26)>d) continue;\n            ++count;\n            cout << name[i] << \",\" << name[j] << endl;\n        }\n    }\n    cout << count << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ulli;\n\nconst ulli B = 1000000007ULL;\n\n\nulli getHash(const string &s) {\n  int n = s.size();\n  ulli res = 0;\n  for(int i = 0; i < n; ++i) {\n    res = res * B + s[i];\n  }\n  return res;\n}\n\nint main() {\n  for(int n, d; cin >> n && n; ) {\n    cin >> d;\n    vector<string> ss(n);\n    for(int i = 0; i < n; ++i) {\n      cin >> ss[i];\n    }\n\n    sort(ss.begin(), ss.end());\n\n    vector<set<ulli> > nextHash(n);\n    for(int k = 0; k < n; ++k) {\n      string s = ss[k];\n      // Deleting\n      for(int i = 0; i < s.size(); ++i) {\n        char tmp = s[i];\n        s.erase(i, 1);\n        nextHash[k].insert(getHash(s));\n        s.insert(i, string(1, tmp));\n      }\n      // Inserting\n      for(int i = 0; i <= s.size(); ++i) {\n        for(char c = 'a'; c <= 'z'; ++c) {\n          s.insert(i, string(1, c));\n          nextHash[k].insert(getHash(s));\n          s.erase(i, 1);\n        }\n      }\n      // Replacing\n      for(int i = 0; i < s.size(); ++i) {\n        char tmp = s[i];\n        for(char c = 'a'; c <= 'z'; ++c) {\n          s[i] = c;\n          nextHash[k].insert(getHash(s));\n        }\n        s[i] = tmp;\n      }\n      // Swapping\n      for(int i = 0; i < s.size(); ++i) {\n        for(int j = i + 1; j < s.size(); ++j) {\n          swap(s[i], s[j]);\n          nextHash[k].insert(getHash(s));\n          swap(s[i], s[j]);\n        }\n      }\n    }\n\n    map<ulli, int> A;\n    map<ulli, set<int> > B;\n    for(int i = 0; i < n; ++i) {\n      A[getHash(ss[i])] = i;\n      if(d <= 1) continue;\n      for(set<ulli>::iterator it = nextHash[i].begin();\n          it != nextHash[i].end(); ++it) {\n        B[*it].insert(i);\n      }\n    }\n\n    set<pair<int, int> > ans;\n    for(int i = 0; i < n; ++i) {\n      for(set<ulli>::iterator it = nextHash[i].begin();\n          it != nextHash[i].end(); ++it) {\n        if(A.count(*it)) {\n          pair<int, int> p(i, A[*it]);\n          if(p.first == p.second) continue;\n          if(p.first > p.second) swap(p.first, p.second);\n          ans.insert(p);\n        }\n      }\n      for(set<ulli>::iterator it = nextHash[i].begin();\n          it != nextHash[i].end(); ++it) {\n        if(B.count(*it)) {\n          for(set<int>::iterator it2 = B[*it].begin();\n              it2 != B[*it].end(); ++it2) {\n            pair<int, int> p(i, *it2);\n            if(p.first == p.second) continue;\n            if(p.first > p.second) swap(p.first, p.second);\n            ans.insert(p);\n          }\n        }\n      }\n    }\n\n    for(set<pair<int, int> >::iterator it = ans.begin();\n        it != ans.end(); ++it) {\n      cout << ss[it->first] << \",\" << ss[it->second] << endl;\n    }\n    cout << ans.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, D;\n\nint dp[20][20];\nint distance(string& s1, string& s2){\n\tfor(int i = 0; i <= s1.length(); i++){\n\t\tdp[i][0] = i;\n\t}\n\tfor(int j = 0; j <= s2.length(); j++){\n\t\tdp[0][j] = j;\n\t}\n\tfor(int i = 0; i < s1.length(); i++){\n\t\tfor(int j = 0; j < s2.length(); j++){\n\t\t\tint ans = 100000;\n\t\t\tans = min(ans, dp[i][j + 1] + 1);\n\t\t\tans = min(ans, dp[i + 1][j] + 1);\n\t\t\tif(s1[i] == s2[j]){\n\t\t\t\tans = min(ans, dp[i][j]);\n\t\t\t}else{\n\t\t\t\tans = min(ans, dp[i][j] + 1);\n\t\t\t}\n\t\t\tif(i > 1 && j > 1 && s1[i] == s2[j - 1] && s1[i - 1] == s2[j]){\n\t\t\t\tans = min(ans, dp[i - 2][j - 2] + 1);\n\t\t\t}\n\t\t\tif(i > 2 && j > 1 && s1[i] == s2[j - 1] && s1[i - 2] == s2[j]){\n\t\t\t\tans = min(ans, dp[i - 3][j - 2] + 2);\n\t\t\t}\n\t\t\tif(i > 1 && j > 2 && s1[i] == s2[j - 2] && s1[i - 1] == s2[j]){\n\t\t\t\tans = min(ans, dp[i - 2][j - 3] + 2);\n\t\t\t}\n\t\t\tdp[i + 1][j + 1] = ans;\n\t\t}\n\t}\n\t/*\n\tfor(int i = 0; i <= s1.length(); i++){\n\t\tfor(int j = 0; j <= s2.length(); j++){\n\t\t\tcout << \" \" << dp[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << s1 << \":\" << s2 << dp[s1.length()][s2.length()] << endl;\n\t*/\n\treturn dp[s1.length()][s2.length()];\n}\n\nint main(){\n\twhile(cin >> N, N){\n\t\tcin >> D;\n\t\tvector<string> names(N);\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> names[i];\n\t\t}\n\t\tsort(names.begin(), names.end());\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = i + 1; j < N; j++){\n\t\t\t\tif(distance(names[i], names[j]) <= D){\n\t\t\t\t\tcout << names[i] << \",\" << names[j] << endl;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    while(cin>>n,n){\n        int d;cin>>d;\n        vector<string> name(n);\n        for(int i=0;i<n;i++) cin>>name[i];\n        sort(name.begin(),name.end());\n        vector<set<string>> s(n);\n        for(int i=0;i<n;i++){\n            int len=name[i].length();\n\n            // delete\n            s[i].insert(name[i].substr(0,len-1));\n            s[i].insert(name[i].substr(1,len-1));\n            for(int j=1;j<len-1;j++){\n                string tmp=name[i].substr(0,j);\n                tmp+=name[i].substr(j+1,len-1-j);\n                s[i].insert(tmp);\n            }\n\n            // swap\n            for(int j=1;j<len;j++){\n                string tmp=name[i];\n                char c=tmp[j];\n                tmp[j]=tmp[j-1];\n                tmp[j-1]=c;\n                s[i].insert(tmp);\n            }\n\n            // insert\n            for(char c='a';c<='z';c++){\n                string tmp=\"\"; tmp+=c;\n                tmp+=name[i];\n                s[i].insert(tmp);\n\n                tmp=name[i]; tmp+=c;\n                s[i].insert(tmp);\n            }\n            for(int j=1;j<len;j++){\n                for(char c='a';c<='z';c++){\n                    string tmp=name[i].substr(0,j);\n                    tmp+=c;\n                    tmp+=name[i].substr(j,len-j);\n                    s[i].insert(tmp);\n                }\n            }\n\n            // replace\n            for(int j=0;j<len;j++){\n                for(char c='a';c<='z';c++){\n                    if(name[i][j]==c) continue;\n                    string tmp=name[i];\n                    tmp[j]=c;\n                    s[i].insert(tmp);\n                    //cout<<tmp<<endl;\n                }\n            }\n            //cout<<s[i].size()<<endl;\n            \n        }\n        int res=0;\n        for(int i=0;i<n;i++){\n            for(int j=i+1;j<n;j++){\n                bool one=false,two=false;\n                if(s[j].find(name[i])!=s[j].end()) one=true;\n                if(s[i].find(name[j])!=s[i].end()) one=true;\n\n                for(auto itr=s[i].begin();itr!=s[i].end();itr++){\n                    string ss=*itr;\n                    if(s[j].find(ss)!=s[j].end()) two=true;\n                }\n\n                if(d==1){\n                    if(one){\n                        cout<<name[i]<<\",\"<<name[j]<<endl;\n                        res++;\n                    }\n                }\n                else{\n                    if(one || two){\n                        cout<<name[i]<<\",\"<<name[j]<<endl;\n                        res++;\n                    }\n                }\n            }\n        }\n        cout<<res<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    int d;\n    cin>>d;\n    set<string> ss;\n    for(int i=0;i<n;i++){\n      string s;\n      cin>>s;\n      ss.emplace(s);\n    }\n    using P = pair<string, string>;\n    set<P> ans;\n    auto calc=[](string s){\n      int n=s.size();\n      set<string> ss;\n      for(int i=0;i<n;i++){\n\tstring t=s;\n\tt.erase(t.begin()+i);\n\tss.emplace(t);\n      }\n      for(int i=0;i<=n;i++){\n\tfor(char c='a';c<='z';c++){\n\t  string t=s;\n\t  t.insert(t.begin()+i,c);\n\t  ss.emplace(t);\n\t}\n      }\n      for(int i=0;i<n;i++){\n\tfor(char c='a';c<='z';c++){\n\t  string t=s;\n\t  t[i]=c;\n\t  ss.emplace(t);\n\t}\n      }\n      for(int i=0;i<n-1;i++){\n\tswap(s[i],s[i+1]);\n\tss.emplace(s);\n\tswap(s[i],s[i+1]);\n      }\n      return ss;\n    };\n    map<string,vector<string> > ms;\n    for(string s:ss){\n      if(d==1){\n\tmap<string,int> dp;\n\tqueue<string> q;\n\tdp[s]=0;\n\tq.emplace(s);\n\twhile(!q.empty()){\n\t  string t=q.front();q.pop();\n\t  if(dp[t]>=d) continue;\n\t  auto xs=calc(t);\n\t  for(string x:xs){\n\t    if(dp.count(x)) continue;\n\t    dp[x]=dp[t]+1;\n\t    q.emplace(x);\n\t  }\n\t}\n\tfor(auto p:dp){\n\t  if(p.first==s||p.second>d) continue;\n\t  if(ss.count(p.first)) ans.emplace(minmax({s,p.first}));\n\t}\n      }\n      if(d==2){\n\tmap<string,int> dp;\n\tqueue<string> q;\n\tdp[s]=0;\n\tq.emplace(s);\n\twhile(!q.empty()){\n\t  string t=q.front();q.pop();\n\t  if(dp[t]>=1) continue;\n\t  auto xs=calc(t);\n\t  for(string x:xs){\n\t    if(dp.count(x)) continue;\n\t    dp[x]=dp[t]+1;\n\t    q.emplace(x);\n\t  }\n\t}\n\tfor(auto p:dp){\n\t  if(p.second==1){\n\t    for(auto x:ms[p.first])\n\t      ans.emplace(minmax({s,x}));\n\t    \n\t    ms[p.first].emplace_back(s);\n\t  }\n\t  if(p.first==s||p.second>d) continue;\n\t  if(ss.count(p.first)) ans.emplace(minmax({s,p.first}));\n\t}\n      }\n    }\n    for(P p:ans)\n      cout<<p.first<<\",\"<<p.second<<endl;\n    cout<<ans.size()<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nint check(string a, string b) {\n\tif (a.size() > b.size())return check(b, a);\n\telse if (a.size() == b.size()) {\n\t\t\n\t\tvector<int>anums(26), bnums(26);\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tanums[a[i] - 'a']++;\n\t\t}\n\t\tfor (int i = 0; i < b.size(); ++i) {\n\t\t\tbnums[b[i] - 'a']++;\n\t\t}\n\t\tif (anums == bnums) {\n\t\t\tfor (int i = 0; i < a.size() - 1; ++i) {\n\t\t\t\tswap(a[i], a[i + 1]);\n\t\t\t\tif (a == b)return 1;\n\t\t\t\tswap(a[i], a[i + 1]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tvector<int>amanys, bmanys;\n\t\t\tfor (int i = 0; i < 26; ++i) {\n\t\t\t\tif (anums[i] > bnums[i]) {\n\t\t\t\t\tfor (int j = 0; j < anums[i]-bnums[i]; ++j) {\n\t\t\t\t\t\tamanys.push_back(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (anums[i] < bnums[i]) {\n\t\t\t\t\tfor (int j = 0; j < bnums[i] - anums[i]; ++j) {\n\t\t\t\t\t\tbmanys.push_back(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (amanys.size() > 2)return -1;\n\t\t}\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tint N, D; cin >> N >> D;\n\t\tif (!N)break;\n\t\tvector<string>names;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring name; cin >> name;\n\t\t\tnames.push_back(name);\n\t\t}\n\t\tsort(names.begin(), names.end());\n\t\tvector<vector<string>>sas(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring aname(names[i]);\n\t\t\tfor (int j = 0; j < aname.size(); ++j) {\n\t\t\t\tfor (int k = 'a'; k <= 'z'; ++k) {\n\t\t\t\t\tstring st(aname);\n\t\t\t\t\tif (k != st[j]) {\n\t\t\t\t\t\tst[j] = k;\n\t\t\t\t\t\tsas[i].push_back(st);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < aname.size(); ++j) {\n\t\t\t\tstring st(aname);\n\t\t\t\tst.erase(st.begin() + j);\n\t\t\t\tsas[i].push_back(st);\n\t\t\t}\n\t\t\tfor (int j = 0; j <= aname.size(); ++j) {\n\t\t\t\tfor (int k = 'a'; k <= 'z'; ++k) {\n\t\t\t\t\tstring st(aname);\n\t\t\t\t\tst.insert(st.begin() + j, k);\n\t\t\t\t\tsas[i].push_back(st);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < aname.size()-1; ++j) {\n\t\t\t\tstring st(aname);\n\t\t\t\tswap(st[j], st[j + 1]);\n\t\t\t\tsas[i].push_back(st);\n\t\t\t}\n\t\t\tsort(sas[i].begin(), sas[i].end());\n\t\t}\n\t\tvector<pair<int, int>>anss;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i+1; j < N; ++j) {\n\t\t\t\tbool flag = false;\n\t\t\t\tfor (int k = 0; k < sas[i].size(); ++k) {\n\t\t\t\t\t\n\t\t\t\t\tif (D==2&&binary_search(sas[j].begin(), sas[j].end(), sas[i][k])) {\n\t\t\t\t\t\tanss.push_back(make_pair(i, j));\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (sas[i][k] == names[j]) {\n\t\t\t\t\t\tanss.push_back(make_pair(i, j));\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (flag)break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < anss.size(); ++i) {\n\t\t\tcout << names[anss[i].first] << ',' << names[anss[i].second] << endl;\n\t\t}\n\t\tcout << anss.size() << endl;\n\t}\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <stdlib.h>\n\nusing namespace std;\n\nint n, d;\nvector<string> vec;\n\nbool contain(string &a, string &b)\n{\n\tstring s, t;\n\tif(a.size() > b.size()) s = a, t = b;\n\telse s = b, t = a;\n\t\n\tint pos = 0;\n\tfor(int i = 0; i < s.size(); i++){\n\t\tif(pos < t.size() && s[i] == t[pos]) pos++;\n\t}\n\treturn pos >= t.size();\n}\n\nbool check(string &s, string &t, int d)\n{\n\tint dif = 0;\n\tvector<int> vec;\n\t\n\tfor(int i = 0; i < s.size(); i++){\n\t\tif(s[i] != t[i]){\n\t\t\tdif++;\n\t\t\tvec.push_back(i);\n\t\t}\n\t}\n\t\n\tif(dif <= d) return true;\n\t\n\tif(d == 1){\n\t\tif(dif > 2) return false;\n\t\treturn vec[0] + 1 == vec[1] && s[vec[0]] == t[vec[1]] && s[vec[1]] == t[vec[0]];\n\t}\n\tif(d == 2){\n\t\tfor(int i = 0; i < s.size(); i++){\n\t\t\tstring u = s.substr(0, i) + s.substr(i+1);\n\t\t\tif(contain(u, t)) return true;\n\t\t}\n\t\tif(dif == 4){\n\t\t\treturn (vec[0] + 1 == vec[1] && s[vec[0]] == t[vec[1]] && s[vec[1]] == t[vec[0]])\n\t\t\t&& (vec[2] + 1 == vec[3] && s[vec[2]] == t[vec[3]] && s[vec[3]] == t[vec[2]]);\n\t\t}\n\t\tif(dif == 3){\n\t\t\tif(vec[0] + 1 != vec[1]) \n\t\t\t\treturn (vec[1] + 1 == vec[2] && s[vec[1]] == t[vec[2]] && s[vec[2]] == t[vec[1]]);\n\t\t\tif(vec[1] + 1 != vec[2]) \n\t\t\t\treturn (vec[0] + 1 == vec[1] && s[vec[0]] == t[vec[1]] && s[vec[1]] == t[vec[0]]);\n\t\t\t\n\t\t\tif(s[vec[0]] == t[vec[1]] && s[vec[1]] == t[vec[0]]) return true;\n\t\t\tif(s[vec[1]] == t[vec[2]] && s[vec[2]] == t[vec[1]]) return true;\n\t\t\tif(s[vec[0]] == t[vec[1]] && s[vec[1]] == t[vec[2]] && s[vec[2]] == t[vec[0]]) return true;\n\t\t\tif(s[vec[0]] == t[vec[1]] && s[vec[1]] == t[vec[2]] && s[vec[2]] == t[vec[0]]) return true;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tcin >> d;\n\t\t\n\t\tstring s;\n\t\tvec.clear();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> s;\n\t\t\tvec.push_back(s);\n\t\t}\n\t\tsort(vec.begin(), vec.end());\n\t\t\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < vec.size(); i++){\n\t\t\tfor(int j = 0; j < vec.size(); j++){\n\t\t\t\tif(i >= j) continue;\n\t\t\t\t\n\t\t\t\tint dif = abs((int)vec[i].size() - (int)vec[j].size());\n\t\t\t\tif(dif > d) continue;\n\t\t\t\tif(dif == d){\n\t\t\t\t\tif(contain(vec[i], vec[j]) )goto NEAR;\n\t\t\t\t\telse continue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(d == 2 && dif == 1){\n\t\t\t\t\tstring s, t;\n\t\t\t\t\tif(vec[i].size() > vec[j].size()) s = vec[i], t = vec[j];\n\t\t\t\t\telse s = vec[j], t = vec[i];\n\t\t\t\t\tfor(int k = 0; k < s.size(); k++){\n\t\t\t\t\t\tstring u = s.substr(0, k) + s.substr(k+1);\n\t\t\t\t\t\tif(check(u, t, 1)) goto NEAR;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(check(vec[i], vec[j], d)) goto NEAR;\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tNEAR:;\n\t\t\t\tcnt++;\n\t\t\t\tcout << vec[i] << \",\" << vec[j] << endl;\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing std::sort;\nusing std::swap;\n\nint N, D;\nstruct Name{\n    char s[20];\n    bool operator<(const Name &b)const{\n        for(int i=0;;i++){\n            if(b.s[i] == '\\0') return true;\n            if(s[i] == '\\0') return false;\n            if(s[i] < b.s[i]) return true;\n            if(s[i] > b.s[i]) return false;\n        }\n    }\n}name[300];\n\nbool comp(Name a, Name b){\n    for(int i=0;;i++){\n        if(b.s[i] == '\\0') return false;\n        if(a.s[i] == '\\0') return true;\n        if(a.s[i] < b.s[i]) return true;\n        if(a.s[i] > b.s[i]) return false;\n    }\n}\n\nbool distance(int a, int b, int x, int y, int d){\n    if(d > D) return false;\n    if(name[a].s[x]=='\\0' && name[b].s[y]=='\\0') return true;\n    if(name[a].s[x] == '\\0') return distance(a, b, x, y+1, d+1);\n    if(name[b].s[y] == '\\0') return distance(a, b, x+1, y, d+1);\n    if(name[a].s[x] == name[b].s[y]) return distance(a, b, x+1, y+1, d); //always best\n    if(distance(a, b, x+1, y, d+1)) return true; //del a[x]->x++ or Insert b[y]\n    if(distance(a, b, x, y+1, d+1)) return true; //del b[y]->y++ or Insert a[x]\n    if(distance(a, b, x+1, y+1, d+1)) return true; //Replacing\n    if(name[a].s[x+1]!='\\0'){\n        swap(name[a].s[x], name[a].s[x+1]);\n        if(distance(a, b, x, y, d+1)){\n            swap(name[a].s[x], name[a].s[x+1]);\n            return true;\n        }\n        swap(name[a].s[x], name[a].s[x+1]);\n        //swap a a+2 ans delete a+1...\n        if(name[a].s[x+2]!='\\0'){\n            swap(name[a].s[x], name[a].s[x+2]);\n            char tmp = name[a].s[x+1];\n            int i;\n            for(i=x+2;name[a].s[i-1]!='\\0';i++) name[a].s[i-1] = name[a].s[i];\n            bool res = distance(a, b, x, y, d+2);\n            for(;i>x;i--) name[a].s[i] = name[a].s[i-1];\n            name[a].s[x+1] = tmp;\n            swap(name[a].s[x], name[a].s[x+2]);\n            return res;\n        }\n    }\n    return false;\n}\nint main(){\n    while(scanf(\"%d %d\", &N, &D) && N){\n        for(int i=0;i<N;i++)\n            scanf(\"%s\", name[i].s);\n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                if(!comp(name[i], name[j]) )\n                    swap(name[i], name[j]);\n            }\n        }\n        int res = 0;\n        for(int i=N-1;i>=0;i--){\n            for(int j=i-1;j>=0;j--){\n                if(distance(i, j, 0, 0, 0)){\n                    printf(\"%s,%s\\n\", name[i].s, name[j].s);\n                    res++;\n                }\n            }\n        }\n        printf(\"%d\\n\", res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint edit_dist(const string& s, const string& t, int B){\n  int l1 = s.size();\n  int l2 = t.size();\n  int dp[32][32] = {};\n  REP(i, l1) dp[i + 1][0] = i + 1;\n  REP(j, l2) dp[0][j + 1] = j + 1;\n  REP(i, l1) {\n    int min_d = INF;\n    REP(j, l2){\n      if(s[i] == t[j]) dp[i + 1][j + 1] = dp[i][j];\n      else dp[i + 1][j + 1] = min(dp[i][j], min(dp[i + 1][j], dp[i][j + 1])) + 1;\n      min_d = min(min_d, dp[i + 1][j + 1]);\n    }\n    if(min_d > B) return B + 1;\n  }\n  return dp[l1][l2];\n}\nbool check(string s, string t, int D){\n  if(D == 0){\n    if(s == t) return true;\n  }else if(D == 1){\n    if(edit_dist(s, t, 1) <= 1) return true;\n    if(s.size() == t.size()) REP(i, s.size()) FOR(j, i + 1, s.size()){\n      swap(s[i], s[j]);\n      if(s == t) return true;\n      swap(s[i], s[j]);\n    }\n  }else if(D == 2){\n    if(edit_dist(s, t, 2) <= 2) return true;\n    REP(i, s.size()) FOR(j, i + 1, s.size()){\n      swap(s[i], s[j]);\n      if(edit_dist(s, t, 1) <= 1) return true;\n      if(s.size() == t.size()) REP(k, s.size()) if(s[k] != t[k]) FOR(l, k + 1, s.size()) if(s[l] != t[l]) {\n        swap(s[k], s[l]);\n        if(s == t) return true;\n        swap(s[k], s[l]);\n      }\n      swap(s[i], s[j]);\n    }\n  }else {\n    assert(false);\n  }\n  return false;\n}\nint main(){\n  int N, D;\n  while(cin >> N >> D && N){\n    vector<string> name(N);\n    REP(i, N) cin >> name[i];\n    vector< pair<string, string> > ans;\n    REP(i, N) FOR(j, i + 1, N){\n      if(check(name[i], name[j], D)) ans.push_back(make_pair( min(name[i], name[j]), max(name[i], name[j]) ));\n    }\n    sort(ans.begin(), ans.end());\n    REP(i, ans.size()){\n      printf(\"%s,%s\\n\", ans[i].first.c_str(), ans[i].second.c_str());\n    }\n    printf(\"%d\\n\", (int)ans.size());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, d;\nstring in[200];\n\nint main(){\n\twhile(cin >> n, n){\n\t\tcin >> d;\n\t\trep(i, n) cin >> in[i];\n\t\tvector<pair<string, string> > ans;\n\t\tmap<string, vi> m;\n\t\t\n\t\trep(i, n){\n\t\t\tvector<string> ss;\n\t\t\trep(j, in[i].size() + 1){\n\t\t\t\tstring s = in[i];\n\t\t\t\tif(j < s.size() - 1){\n\t\t\t\t\tswap(s[j], s[j + 1]);\n\t\t\t\t\tss.pb(s);\n\t\t\t\t}\n\t\t\t\ts = in[i];\n\t\t\t\tif(j < s.size()){\n\t\t\t\t\ts.erase(s.begin() + j);\n\t\t\t\t\tss.pb(s);\n\t\t\t\t\t\n\t\t\t\t\trep(k, 26){\n\t\t\t\t\t\ts = in[i];\n\t\t\t\t\t\ts[j] = 'a' + k;\n\t\t\t\t\t\tss.pb(s);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(k, 26){\n\t\t\t\t\ts = in[i];\n\t\t\t\t\ts.insert(s.begin() + j, 'a' + k);\n\t\t\t\t\tss.pb(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, ss.size()) if(m.count(ss[j])){\n\t\t\t\teach(k, m[ss[j]]){\n\t\t\t\t\tstring a = in[*k], b = in[i];\n\t\t\t\t\tif(a > b) swap(a, b);\n\t\t\t\t\tans.pb(mp(a, b));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tm[in[i]].pb(i);\n\t\t\tif(d > 1) rep(j, ss.size()){\n\t\t\t\tif(!m.count(ss[j]) || m[ss[j]].back() != i)\n\t\t\t\tm[ss[j]].pb(i);\n\t\t\t}\n\t\t}\n\t\tsort(all(ans));\n\t\trep(i, ans.size()) cout << ans[i].first << \",\" << ans[i].second << endl;\n\t\tcout << ans.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint LevenshteinDist(const string& s, const string& t)\n{\n    int n = s.size();\n    int m = t.size();\n    vector<vector<int> > minCost(n+2, vector<int>(m+2, INT_MAX));\n    minCost[0][0] = 0;\n    for(int i=0; i<=n; ++i){\n        for(int j=0; j<=m; ++j){\n            minCost[i+1][j] = min(minCost[i+1][j], minCost[i][j] + 1);\n            minCost[i][j+1] = min(minCost[i][j+1], minCost[i][j] + 1);\n            if(i < n && j < m && s[i] == t[j])\n                minCost[i+1][j+1] = min(minCost[i+1][j+1], minCost[i][j]);\n            else\n                minCost[i+1][j+1] = min(minCost[i+1][j+1], minCost[i][j] + 1);\n        }\n    }\n    return minCost[n][m];\n}\n\nint main()\n{\n    for(;;){\n        int n, d;\n        cin >> n >> d;\n        if(n == 0)\n            return 0;\n\n        vector<string> s(n);\n        for(int i=0; i<n; ++i)\n            cin >> s[i];\n        sort(s.begin(), s.end());\n\n        vector<set<string> > vss(n);\n        for(int i=0; i<n; ++i){\n            int m = s[i].size();\n            /* swap */\n            for(int j=0; j<m-1; ++j){\n                string t = s[i];\n                swap(t[j], t[j+1]);\n                vss[i].insert(t);\n            }\n        }\n\n        int ret = 0;\n        for(int i=0; i<n; ++i){\n            for(int j=i+1; j<n; ++j){\n                bool confuse = false;\n                if(LevenshteinDist(s[i], s[j]) <= d)\n                    confuse = true;\n\n                set<string>::iterator it1, it2;\n                for(it1=vss[i].begin(); it1!=vss[i].end(); ++it1){\n                    if(LevenshteinDist(*it1, s[j]) <= d-1){\n                        confuse = true;\n                        break;\n                    }\n                }\n                if(!confuse){\n                    for(it2=vss[j].begin(); it2!=vss[j].end(); ++it2){\n                        if(LevenshteinDist(s[i], *it2) <= d-1){\n                            confuse = true;\n                            break;\n                        }\n                    }\n                }\n\n                if(d == 2 && !confuse){\n                    it1 = vss[i].begin();\n                    it2 = vss[j].begin();\n                    while(it1 != vss[i].end() && it2 != vss[j].end()){\n                        if(*it1 == *it2){\n                            confuse = true;\n                            break;\n                        }\n                        if(*it1 < *it2)\n                            ++ it1;\n                        else\n                            ++ it2;\n                    }\n                }\n\n                if(confuse){\n                    cout << s[i] << ',' << s[j] << endl;\n                    ++ ret;\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<utility>\n#include<string>\n\nusing namespace std;\n\nbool check(const string &s1,const string &s2,int d){\n  if(s1==s2)return true;\n  if(d==1){\n    if(s1.empty()&&s2.size()==1||s2.empty()&&s1.size()==1)return true;\n    int ld=abs(int(s1.size())-(int)(s2.size()));\n    if(ld>1)return false;\n    int h1=0,h2=0;\n    int t1=s1.size(),t2=s2.size();\n    while(h1<s1.size()&&h2<s2.size()&&s1[h1]==s2[h2]){\n      h1++;\n      h2++;\n    }\n    while(t1>0&&t2>0&&s1[t1-1]==s2[t2-1]){\n      t1--;\n      t2--;\n    }\n    if(ld==1){\n      return h1==t1||h2==t2;\n    }else{\n      return h1+1==t1||h1+2==t1&&s1[h1]==s2[t2-1]&&s1[t1-1]==s2[h2];\n    }\n  }else{\n    for(int i=0;i<s1.size()+1;i++){\n      string ns=s1;\n      ns.insert(ns.begin()+i,' ');\n      for(char c='a';c<='z';c++){\n\tns[i]=c;\n\tif(check(ns,s2,1))return true;\n      }\n    }\n    for(int i=0;i<s1.size();i++){\n      if(check(s1.substr(0,i)+s1.substr(i+1),s2,1))return true;\n      string ns=s1;\n      for(char c='a';c<='z';c++){\n\tns[i]=c;\n\tif(check(ns,s2,1))return true;\n      }\n    }\n    string ns=s1;\n    for(int i=0;i+1<s1.size();i++){\n      swap(ns[i],ns[i+1]);\n      if(check(ns,s2,1))return true;\n      swap(ns[i],ns[i+1]); \n    }\n    return false;\n  }\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    int d;\n    cin>>d;\n    string names[223];\n    for(int i=0;i<n;i++){\n      cin>>names[i];\n    }\n    sort(names,names+n);\n    vector<pair<string,string> > ans;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(check(names[i],names[j],d)){\n\t  ans.emplace_back(names[i],names[j]);\n\t}\n      }\n    }\n    for(auto e:ans){\n      cout<<e.first<<','<<e.second<<endl;\n    }\n    cout<<ans.size()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint d;\nchar buf[114514];\nmap<string, set<int> > mp; \nstring names[114514];\nset<int> ans[114514];\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) return 0;\n\n    scanf(\"%d\", &d);\n    for (int i=0; i<n; i++) {\n      scanf(\"%s\", buf);\n      names[i] = buf;\n      ans[i].clear();\n    }\n    sort(names, names+n);\n    mp.clear();\n    for (int i=0; i<n; i++) {\n      mp[names[i]].insert(i);\n    }\n\n    if (d == 1) {\n      for (int i=0; i<n; i++) {\n        for (int j=0; j<names[i].size(); j++) {\n          for (int k : mp[names[i].substr(0, j) + names[i].substr(j+1)]) {\n            if (k != i) {\n              ans[min(i, k)].insert(max(i, k));\n            }\n          }\n\n          for (char k='a'; k<='z'; k++) {\n            //cout << \"rep: \" << names[i].substr(0, j)+k+names[i].substr(j+1) << \"\\n\";\n            for (int t : mp[names[i].substr(0, j)+k+names[i].substr(j+1)]) {\n              if (t != i) {\n                ans[min(i, t)].insert(max(i, t));\n              }\n            }\n\n            //cout << \"ins: \" << names[i].substr(0, j)+k+names[i].substr(j) << \"\\n\";\n            for (int t : mp[names[i].substr(0, j)+k+names[i].substr(j)]) {\n              if (t != i) {\n                ans[min(i, t)].insert(max(i, t));\n              }\n            }\n          }\n\n          for (int k=j+1; k<names[i].size(); k++) {\n            string g = names[i].substr(0, j)+names[i][k]+names[i].substr(j+1, k-j-1)+names[i][j]+names[i].substr(k+1);\n            //cout << \"sw: \" << g << \"\\n\";\n            for (int t : mp[g]) {\n              if (t != i) {\n                ans[min(i, t)].insert(max(i, t));\n              }\n            }\n            break;\n          }\n        }\n\n        for (char k='a'; k<='z'; k++) {\n          //cout << \"ins: \" << names[i]+k << \"\\n\";\n          for (int t : mp[names[i]+k]) {\n            if (t != i) {\n              ans[min(i, t)].insert(max(i, t));\n            }\n          }\n        }\n      }\n    } else if (d == 2) {\n      for (int i=0; i<n; i++) {\n        for (int j=0; j<names[i].size(); j++) {\n          //cout << \"del: \" << names[i].substr(0, j) + names[i].substr(j+1) << \"\\n\";\n          mp[names[i].substr(0, j) + names[i].substr(j+1)].insert(i);\n          for (char k='a'; k<='z'; k++) {\n            mp[names[i].substr(0, j)+k+names[i].substr(j+1)].insert(i);\n            mp[names[i].substr(0, j)+k+names[i].substr(j)].insert(i);\n          }\n\n          for (int k=j+1; k<names[i].size(); k++) {\n            string g = names[i].substr(0, j)+names[i][k]+names[i].substr(j+1, k-j-1)+names[i][j]+names[i].substr(k+1);\n            mp[g].insert(i);\n            break;\n          }\n        }\n\n        for (char k='a'; k<='z'; k++) {\n          mp[names[i]+k].insert(i);\n        }\n      }\n\n      for (auto itr : mp) {\n        for (int i : itr.second) {\n          for (int j : itr.second) {\n            if (i < j) ans[i].insert(j);\n          }\n        } \n      }\n    } else assert(0);\n\n    int cnt = 0;\n    for (int i=0; i<n; i++) {\n      for (int j : ans[i]) {\n        printf(\"%s,%s\\n\", names[i].c_str(), names[j].c_str());\n        cnt++;\n      }\n    }\n    printf(\"%d\\n\", cnt);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\ntemplate <class T>\nbool chmax(T &a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <class T>\nbool chmin(T &a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconstexpr int INF = 1e9;\n\nint memo[20][20];\nvoid init_memo() {\n    rep(i, 0, 20) rep(j, 0, 20) memo[i][j] = INF;\n}\nint distance(string &s, string &t, int i, int j) {\n    auto &MEMO = memo[i][j];\n    if (MEMO != INF) return MEMO;\n\n    if (i >= s.size() && j >= t.size()) return MEMO = 0;\n    if (i >= s.size()) return MEMO = (int)t.size() - j;\n    if (j >= t.size()) return MEMO = (int)s.size() - i;\n    \n    int ret = INF;\n\n    if (s[i] == t[j]) {\n        chmin(ret, distance(s, t, i + 1, j + 1));\n    } else {\n        chmin(ret, distance(s, t, i + 1, j    ) + 1);\n        chmin(ret, distance(s, t, i    , j + 1) + 1);\n        chmin(ret, distance(s, t, i + 1, j + 1) + 1);\n    }\n\n    rep(k, j + 1, t.size()) {\n        if (s[i] == t[k] && s[i + 1] == t[j]) {\n            chmin(ret, distance(s, t, i + 2, k + 1) + 1 + abs(k - (j + 1)));\n        }\n    }\n    rep(k, i + 1, s.size()) {\n        if (s[i] == t[j + 1] && s[k] == t[j]) {\n            chmin(ret, distance(s, t, k + 1, j + 2) + 1 + abs(k - (i + 1)));\n        }\n    }\n\n    return MEMO = ret;\n}\n\nsigned main_() {\n    string s, t;\n    cin >> s >> t;\n    init_memo();\n    cout << distance(s, t, 0, 0) << endl;\n}\nsigned main() {\n    while (1) {\n        int n, d;\n        cin >> n;\n        if (n == 0) break;\n        cin >> d;\n        vector<string> S(n);\n        rep(i, 0, n) {\n            cin >> S[i];\n        }\n        sort(S.begin(), S.end());\n        vector<pair<string, string>> ans;\n        rep(i, 0, n) {\n            rep(j, i + 1, n) {\n                init_memo();\n                // cerr << i << \", \" << j << \" = \" << distance(S[i], S[j], 0, 0) << endl;\n                if (distance(S[i], S[j], 0, 0) <= d) {\n                    ans.push_back({S[i], S[j]});\n                }\n            }\n        }\n        sort(ans.begin(), ans.end());\n        for (auto &x : ans) {\n            cout << x.first << \",\" << x.second << endl;\n        }\n        cout << ans.size() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint LevenshteinDist(const string& s, const string& t)\n{\n    int n = s.size();\n    int m = t.size();\n    vector<vector<int> > minCost(n+2, vector<int>(m+2, INT_MAX));\n    minCost[0][0] = 0;\n    for(int i=0; i<=n; ++i){\n        for(int j=0; j<=m; ++j){\n            minCost[i+1][j] = min(minCost[i+1][j], minCost[i][j] + 1);\n            minCost[i][j+1] = min(minCost[i][j+1], minCost[i][j] + 1);\n            if(i < n && j < m && s[i] == t[j])\n                minCost[i+1][j+1] = min(minCost[i+1][j+1], minCost[i][j]);\n            else\n                minCost[i+1][j+1] = min(minCost[i+1][j+1], minCost[i][j] + 1);\n        }\n    }\n    return minCost[n][m];\n}\n\nint main()\n{\n    for(;;){\n        int n, d;\n        cin >> n >> d;\n        if(n == 0)\n            return 0;\n\n        vector<string> s(n);\n        for(int i=0; i<n; ++i)\n            cin >> s[i];\n        sort(s.begin(), s.end());\n\n        vector<set<string> > vss(n);\n        for(int i=0; i<n; ++i){\n            int m = s[i].size();\n            for(int j=0; j<m-1; ++j){\n                string t = s[i];\n                swap(t[j], t[j+1]);\n                vss[i].insert(t);\n            }\n        }\n\n        int ret = 0;\n        for(int i=0; i<n; ++i){\n            for(int j=i+1; j<n; ++j){\n                bool confuse = false;\n                int ld = LevenshteinDist(s[i], s[j]);\n                if(ld > d*2)\n                    continue;\n\n                if(ld <= d)\n                    confuse = true;\n\n                set<string>::iterator it1, it2;\n                for(it1=vss[i].begin(); it1!=vss[i].end(); ++it1){\n                    if(LevenshteinDist(*it1, s[j]) <= d-1){\n                        confuse = true;\n                        break;\n                    }\n                }\n                for(it2=vss[j].begin(); it2!=vss[j].end(); ++it2){\n                    if(LevenshteinDist(s[i], *it2) <= d-1){\n                        confuse = true;\n                        break;\n                    }\n                }\n\n                if(d == 2){\n                    it1 = vss[i].begin();\n                    it2 = vss[j].begin();\n                    while(it1 != vss[i].end() && it2 != vss[j].end()){\n                        if(*it1 == *it2){\n                            confuse = true;\n                            break;\n                        }\n                        if(*it1 < *it2)\n                            ++ it1;\n                        else\n                            ++ it2;\n                    }\n                }\n\n                if(confuse){\n                    cout << s[i] << ',' << s[j] << endl;\n                    ++ ret;\n                }\n            }\n        }\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<utility>\n#include<string>\n\nusing namespace std;\n\nbool check(const string &s1,const string &s2,int d){\n  if(s1==s2)return true;\n  if(d==1){\n    int ld=abs(int(s1.size())-(int)(s2.size()));\n    if(ld>1)return false;\n    int h1=0,h2=0;\n    int t1=s1.size()-1,t2=s2.size()-1;\n    while(s1[h1]==s2[h2]){\n      h1++;\n      h2++;\n    }\n    while(s1[t1]==s2[t2]){\n      t1--;\n      t2--;\n    }\n    if(ld==1){\n      return h1==t1||h2==t2;\n    }else{\n      return h1==t1||(h1+1==t1&&s1[h1]==s2[t2]&&s1[t1]==s2[h2]);\n    }\n  }else{\n    for(int i=0;i<s1.size()+1;i++){\n      string ns=s1;\n      ns.insert(ns.begin()+i,' ');\n      for(char c='a';c<='z';c++){\n\tns[i]=c;\n\tif(check(ns,s2,1))return true;\n      }\n    }\n    for(int i=0;i<s1.size();i++){\n      if(check(s1.substr(0,i)+s1.substr(i+1),s2,1))return true;\n      string ns=s1;\n      for(char c='a';c<='z';c++){\n\tns[i]=c;\n\tif(check(ns,s2,1))return true;\n      }\n    }\n    string ns=s1;\n    for(int i=0;i+1<s1.size();i++){\n      swap(ns[i],ns[i+1]);\n      if(check(ns,s2,1))return true;\n      swap(ns[i],ns[i+1]); \n    }\n    return false;\n  }\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    int d;\n    cin>>d;\n    string names[223];\n    for(int i=0;i<n;i++){\n      cin>>names[i];\n    }\n    sort(names,names+n);\n    vector<pair<string,string> > ans;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(check(names[i],names[j],d)){\n\t  ans.emplace_back(names[i],names[j]);\n\t}\n      }\n    }\n    for(auto e:ans){\n      cout<<e.first<<','<<e.second<<endl;\n    }\n    cout<<ans.size()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    int d;\n    cin>>d;\n    set<string> ss;\n    for(int i=0;i<n;i++){\n      string s;\n      cin>>s;\n      ss.emplace(s);\n    }\n    using P = pair<string, string>;\n    set<P> ans;\n    auto calc=[](string s){\n      int n=s.size();\n      set<string> ss;\n      for(int i=0;i<n;i++){\n\tstring t=s;\n\tt.erase(t.begin()+i);\n\tss.emplace(t);\n      }\n      for(int i=0;i<n;i++){\n\tfor(char c='a';c<='z';c++){\n\t  string t=s;\n\t  t[i]=c;\n\t  ss.emplace(t);\n\t}\n      }\n      for(int i=0;i<n-1;i++){\n\tswap(s[i],s[i+1]);\n\tss.emplace(s);\n\tswap(s[i],s[i+1]);\n      }\n      return ss;\n    };\n    map<string,vector<string> > ms;\n    for(string s:ss){\n      if(d==1){\n\tmap<string,int> dp;\n\tqueue<string> q;\n\tdp[s]=0;\n\tq.emplace(s);\n\twhile(!q.empty()){\n\t  string t=q.front();q.pop();\n\t  if(dp[t]>=d) continue;\n\t  auto xs=calc(t);\n\t  for(string x:xs){\n\t    if(dp.count(x)) continue;\n\t    dp[x]=dp[t]+1;\n\t    q.emplace(x);\n\t  }\n\t}\n\tfor(auto p:dp){\n\t  if(p.first==s||p.second>d) continue;\n\t  if(ss.count(p.first)) ans.emplace(minmax({s,p.first}));\n\t}\n      }\n      if(d==2){\n\tmap<string,int> dp;\n\tqueue<string> q;\n\tdp[s]=0;\n\tq.emplace(s);\n\twhile(!q.empty()){\n\t  string t=q.front();q.pop();\n\t  if(dp[t]>=2) continue;\n\t  auto xs=calc(t);\n\t  for(string x:xs){\n\t    if(dp.count(x)) continue;\n\t    dp[x]=dp[t]+1;\n\t    q.emplace(x);\n\t  }\n\t}\n\tfor(auto p:dp){\n\t  if(p.second==1){\n\t    for(auto x:ms[p.first])\n\t      ans.emplace(minmax({s,x}));\n\t    \n\t    ms[p.first].emplace_back(s);\n\t  }\n\t  if(p.first==s||p.second>d) continue;\n\t  if(ss.count(p.first)) ans.emplace(minmax({s,p.first}));\n\t}\n      }\n    }\n    for(P p:ans)\n      cout<<p.first<<\",\"<<p.second<<endl;\n    cout<<ans.size()<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nbool check(string a,string b,int d){\n  if(a.size()<b.size())swap(a,b);\n  if(a==b) return 1;\n  if(d==0)return 0;\n\n\n  //erase\n  for(int i=0;i<a.size();i++){\n    string t = a;\n    t.erase(t.begin()+i);\n    if(check(t,b,d-1))return 1;\n  }\n\n  if(a.size()!=b.size()) return 0;\n\n  //swap\n  for(int i=0;i<(int)a.size()-1;i++){\n    if(a[i]==a[i+1]||a[i+1]!=b[i])continue;\n    swap(a[i],a[i+1]);\n    if(check(a,b,d-1))return 1;\n    swap(a[i],a[i+1]);\n  }\n  \n  //change\n  int cnt=0;\n  for(int i=0;i<a.size();i++) cnt+=a[i]!=b[i];\n  return cnt<=d;\n}\n\nint main(){\n  int n,d;\n  while(cin>>n,n){\n    cin>>d;\n    string str[201];\n    for(int i=0;i<n;i++)cin>>str[i];\n    sort(str,str+n);\n\n    int cnt=0;    \n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++)\n\tif(check(str[i],str[j],d)) cout<<str[i]<<\",\"<<str[j]<<endl,cnt++;\n    cout<<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nint n,d;\nstring strs[1000];\nint dp[20][20];\n\nconst int INF=1000000000;\n\nint dfs(int a,int b,string &str1,string &str2){\n    if(a==0&&b==2&&str2==\"hayashi\"&&str1==\"yoshoi\"){\n       // cout<<endl;\n    }\n    if(a==-1&&b==-1)\n        return 0;\n    if(a==-1)\n        return b+1;\n    if(b==-1)\n        return a+1;\n    if(dp[a][b]!=-1){\n        return dp[a][b];\n    }\n    int res=INF;\n    // match\n    if(str1[a]==str2[b])\n        res=min(res,dfs(a-1,b-1,str1,str2));\n    // delete\n    res=min(res,dfs(a,b-1,str1,str2)+1);\n    res=min(res,dfs(a-1,b,str1,str2)+1);\n    // replace\n    res=min(res,dfs(a-1,b-1,str1,str2)+1);\n    // swap\n    if(a-1>=0&&str1[a-1]==str2[b]){\n        // ¶ðüêÖ¦½ ÆAÌ¶ðÁ·ê\n        res=min(res,dfs(a-2,b-1,str1,str2)+2);\n        if(b-2>=0&&str1[a]==str2[b-2])\n            res=min(res,dfs(a-2,b-3,str1,str2)+2);\n        // Ì¶àêv\n        if(b-1>=0&&str1[a]==str2[b-1])\n            res=min(res,dfs(a-2,b-2,str1,str2)+1);\n        // ³çÉêv\n        if(a-2>=0&&b-2>=0&&str1[a-2]==str2[b-1]&&str1[a]==str2[b-2])\n            res=min(res,dfs(a-3,b-3,str1,str2)+2);\n        if(a-2>=0&&b-2>=0&&str1[a-2]==str2[b-2]&&str1[a]==str2[b-1])\n            res=min(res,dfs(a-3,b-3,str1,str2)+1);\n    }\n    // swap2\n    if(b-1>=0&&str2[b-1]==str1[a]){\n        // ¶ðüêÖ¦½ ÆAÌ¶ðÁ·ê\n        res=min(res,dfs(a-1,b-2,str1,str2)+2);\n        if(a-2>=0&&str2[b]==str1[a-2])\n            res=min(res,dfs(a-3,b-2,str1,str2)+2);\n        // Ì¶àêv\n        if(a-1>=0&&str2[b]==str1[a-1])\n            res=min(res,dfs(a-2,b-2,str1,str2)+1);\n        // ³çÉêv\n        if(a-2>=0&&b-2>=0&&str2[b-2]==str1[a-1]&&str2[b]==str1[a-2])\n            res=min(res,dfs(a-3,b-3,str1,str2)+2);\n        if(a-2>=0&&b-2>=0&&str2[b-2]==str1[a-2]&&str2[b]==str1[a-1])\n            res=min(res,dfs(a-3,b-3,str1,str2)+1);\n    }\n    return dp[a][b]=res;\n}\n\nbool check(string &str1,string &str2){\n\n    memset(dp,-1,sizeof(dp));\n    if(str1==\"abcdef\"&&str2==\"abdxcef\"){\n      //  cout<<endl;\n    }\n    int res=dfs(str1.size()-1,str2.size()-1,str1,str2);\n    return res<=d;\n}\n\nint main(){\n    while(cin>>n>>d&&!(n==0&&d==0)){\n        vector<pair<string,string> > vpss;\n        for(int i = 0; i < n; i++)\n            cin>>strs[i];\n        for(int i = 0; i < n; i++){\n            for(int j = i+1; j < n; j++){\n                if(check(strs[i],strs[j])){\n                    if(strs[i]<strs[j])\n                        vpss.push_back(make_pair(strs[i],strs[j]));\n                    else\n                        vpss.push_back(make_pair(strs[j],strs[i]));\n                }\n            }\n        }\n        sort(vpss.begin(),vpss.end());\n        for(int i = 0; i < vpss.size(); i++)\n            cout<<vpss[i].first<<\",\"<<vpss[i].second<<endl;\n        cout<<vpss.size()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n){\n    int d;\n    vector<string> name(n);\n    cin >> d;\n    rep(i,0,n) cin >> name[i];\n    sort(name.begin(),name.end());\n\n    function<bool(const int,const string&,const string&)> in_neighborhood=[&](int d,const string &s1,const string &s2){\n        if(d==0) return s1==s2;\n        //replace\n        rep(i,0,s2.size()){\n            string t=s2;\n            rep(j,0,26){\n                t[i]='a'+j;\n                if(in_neighborhood(d-1,s1,t)) return true;\n            }\n        }\n        //insert\n        rep(i,0,s2.size()+1){\n            string x=s2.substr(0,i),y=s2.substr(i);\n            rep(j,0,26){\n                x.push_back('a'+j);\n                auto t=x+y;\n                if(in_neighborhood(d-1,s1,t)) return true;\n                x.pop_back();\n            }\n        }\n        //delete\n        rep(i,0,s2.size()){\n            string t=s2.substr(0,i)+s2.substr(i+1);\n            if(in_neighborhood(d-1,s1,t)) return true;\n        }\n        //swap adjacent\n        rep(i,0,s2.size()-1){\n            string t=s2;\n            swap(t[i],t[i+1]);\n            if(in_neighborhood(d-1,s1,t)) return true;\n            swap(t[i],t[i+1]);\n        }\n        return false;\n    };\n\n    int count=0;\n    rep(i,0,n) rep(j,i+1,n){\n        if(!in_neighborhood(d,name[i],name[j])) continue;\n        cout << min(name[i],name[j]) << \",\" << max(name[i],name[j]) << endl;\n        ++count;\n    }\n    cout << count << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, D;\n\nint dp[20][20];\nint distance(string& s1, string& s2){\n\tfor(int i = 0; i <= s1.length(); i++){\n\t\tdp[i][0] = i;\n\t}\n\tfor(int j = 0; j <= s2.length(); j++){\n\t\tdp[0][j] = j;\n\t}\n\tfor(int i = 0; i < s1.length(); i++){\n\t\tfor(int j = 0; j < s2.length(); j++){\n\t\t\tint ans = 100000;\n\t\t\tans = min(ans, dp[i][j + 1] + 1);\n\t\t\tans = min(ans, dp[i + 1][j] + 1);\n\t\t\tif(s1[i] == s2[j]){\n\t\t\t\tans = min(ans, dp[i][j]);\n\t\t\t}else{\n\t\t\t\tans = min(ans, dp[i][j] + 1);\n\t\t\t}\n\t\t\tif(i >= 1 && j >= 1 && s1[i] == s2[j - 1] && s1[i - 1] == s2[j]){\n\t\t\t\tans = min(ans, dp[i - 1][j - 1] + 1);\n\t\t\t}\n\n\t\t\tif(i >= 2 && j >= 1 && s1[i] == s2[j - 1] && s1[i - 2] == s2[j]){\n\t\t\t\tans = min(ans, dp[i - 2][j - 1] + 2);\n\t\t\t}\t\n\t\t\tif(i >= 1 && j >= 2 && s1[i] == s2[j - 2] && s1[i - 1] == s2[j]){\n\t\t\t\tans = min(ans, dp[i - 1][j - 2] + 2);\n\t\t\t}\n\t\t\tdp[i + 1][j + 1] = ans;\n\t\t}\n\t}\n\t/*\n\tfor(int i = 0; i <= s1.length(); i++){\n\t\tfor(int j = 0; j <= s2.length(); j++){\n\t\t\tcout << \" \" << dp[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << s1 << \":\" << s2 << dp[s1.length()][s2.length()] << endl;\n\t*/\n\treturn dp[s1.length()][s2.length()];\n}\n\nint main(){\n\twhile(cin >> N, N){\n\t\tcin >> D;\n\t\tvector<string> names(N);\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> names[i];\n\t\t}\n\t\tsort(names.begin(), names.end());\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = i + 1; j < N; j++){\n\t\t\t\tif(distance(names[i], names[j]) <= D){\n\t\t\t\t\tcout << names[i] << \",\" << names[j] << endl;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\n// Levenshtein Distance\nint levenshtein(string a, string b) {\n  int n = a.size(), m = b.size();\n  int d[n+1][m+1];\n  REP(i, n+1) d[i][0] = i;\n  REP(i, m+1) d[0][i] = i;\n  for (int i=1; i<=n; ++i) {\n    for (int j=1; j<=m; ++j) {\n      d[i][j] = min(min(d[i-1][j] + 1,  // a deletion\n                        d[i][j-1] + 1), // an insertion\n                    d[i-1][j-1] + (a[i-1] != b[j-1])); // a substituion\n      if (i>=2 && j>=2 && a[i-2]==b[j-1] && a[i-1]==b[j-2])\n        d[i][j] = min(d[i][j], d[i-2][j-2]+1);\n      //printf(\"(%d,%d):%d:%d \",i,j,d[i][j],a[i-1]!=b[j-1]);\n    }\n    //cout << endl;\n  }\n  return d[n][m];\n}\n\nbool judge(string a, string b, int d) {\n  REP(i, a.size()-1) {\n    string tmp = a;\n    swap(tmp[i], tmp[i+1]);\n    //cout << tmp << \" \" << b << \" \" << levenshtein(tmp, b) << endl;\n    if (levenshtein(tmp, b) <= d-1) return 1;\n  }\n  REP(i, b.size()-1) {\n    string tmp = b;\n    swap(tmp[i], tmp[i+1]);\n    //cout << tmp << \" \" << a << \" \" << levenshtein(tmp, a) << endl;\n    if (levenshtein(tmp, a) <= d-1) return 1;\n  }\n  \n  return 0;\n}\n\n\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    int d;\n    cin >> d;\n    string name[n];\n    REP(i, n) {\n      cin >> name[i];\n    }\n    set<pair<string, string> > se;\n    sort(name, name+n);\n    REP(i, n) {\n      REP(j, i) {\n        //cout << name[j] <<\",\" <<name[i]<< \" :  \" << levenshtein(name[j], name[i]) << endl;\n        int l = levenshtein(name[j], name[i]);\n        if (l <= d || d == 2 && l <= 3 && judge(name[j], name[i], d))\n          se.insert(make_pair(name[j], name[i]));\n      }\n    }\n    FOR(it, se) {\n      cout << it->first << \",\" << it->second << endl;\n    }\n    cout << se.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nvoid transforms(const string& s1,set<string>& s){\n    string tmp;\n    for(int i = 0; i < s1.length();i++){\n        tmp = s1;\n        tmp.erase(tmp.begin() + i);\n        s.insert(tmp);\n    }\n    for(int i = 0; i <=s1.length();i++){\n        for(int j = 0; j < 26;j++){\n            tmp = s1;\n            char c = 'a' + j;\n            tmp.insert(i,string(1,c));\n            s.insert(tmp);\n        }\n    }\n    for(int i = 0; i < s1.length();i++){\n        for(int j = 0; j < 26;j++){\n            tmp = s1;\n            char c = 'a' + j;\n            tmp.replace(i,1,string(1,c));\n            s.insert(tmp);\n        }\n    }\n    for(int i = 0; i < s1.length() - 1;i++){\n        tmp = s1;\n        swap(tmp[i],tmp[i+1]);\n        s.insert(tmp);\n    }\n}\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n,d;\n    vector<pii> res;\n    vector<string> name;\n    set<string> s[201];\n    while(cin >> n, n){\n        cin >> d;\n        res.clear();\n        name.clear();\n        name.resize(n);\n        for(int i = 0; i < n;i++){\n            cin >> name[i];\n        }\n        sort(name.begin(),name.end());\n        \n        for(int i = 0; i < n;i++){\n            s[i].clear();\n            transforms(name[i],s[i]);\n        }\n        \n        if(d == 1){\n            for(int i = 0; i < n - 1;i++){\n                for(int j = i + 1; j < n;j++){\n                    if(s[i].find(name[j]) != s[i].end()){\n                        res.push_back({i,j});\n                    }\n                }\n            }\n        }else{\n            for(int i = 0; i < n-1;i++){\n                for(int j = i + 1; j < n;j++){\n                    for(auto tmp_s:s[i]){\n                        if(s[j].find(tmp_s) != s[j].end()){\n                            res.push_back({i,j});\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        \n        for(auto ans:res){\n            cout << name[ans.first] << \",\" <<name[ans.second]<<endl;\n        }\n        cout << res.size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define INF (1<<29)\n#define EPS (1e-10)\n#define mp make_pair\n#define pb push_back\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef pair<int,int> pii;\n\nint dx[] = {0,1,0,-1}, dy[] = {1,0,-1,0};\n\nint main(){\n\tint n;\n\twhile( cin >> n, n ){\n\t\tint d;\n\t\tcin >> d;\n\t\tvector<string> data(n);\n\t\tfor( int i = 0; i < n; i++ ){\n\t\t\tcin >> data[i];\n\t\t}\n\t\tint cnt = 0;\n\t\tsort(data.begin(), data.end());\n\t\t//vii dists(n, vi(n,INF));\n\t\tfor( int i = 0; i < n; i++ ){\n\t\t\tfor( int j = i+1; j < n; j++ ){\n\t\t\t\tvii dp(n+1, vi(n+1, 0));\n\t\t\t\tfor( int k = 1; k <= n; k++ ){\n\t\t\t\t\tfor( int l = 1; l <= n; l++ ){\n\t\t\t\t\t\tif( data[i][k-1] == data[j][l-1] ){\n\t\t\t\t\t\t\tdp[k][l] = dp[k-1][l-1];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tdp[k][l] = min(dp[k-1][l]+1, min(dp[k][l-1]+1, dp[k-1][l-1]+1));\n\t\t\t\t\t\t\t//if( k < n && data[i][k] == data[j][l-1] ) dp[k][l] = min(dp[k][l], data[k-1][l]+1);\n\t\t\t\t\t\t\tif( 1 < k && 1 < l && data[i][k-2] == data[j][l-1] && data[i][k-1] == data[j][l-2] ) dp[k][l] = min(dp[k][l], data[k-2][l-2]+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//dists[i][j] = dists[j][i] = dp[n][n];\n\t\t\t\tif( dp[n][n] <= d ){\n\t\t\t\t\tcout << data[i] << \",\" << data[j] << endl;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, d;\nstring in[200];\n\nint main(){\n\twhile(cin >> n, n){\n\t\tcin >> d;\n\t\trep(i, n) cin >> in[i];\n\t\tvector<pair<string, string> > ans;\n\t\tmap<string, vi> m;\n\t\t\n\t\trep(i, n){\n\t\t\tvector<string> ss;\n\t\t\trep(j, in[i].size() + 1){\n\t\t\t\tstring s = in[i];\n\t\t\t\tif(j < s.size() - 1){\n\t\t\t\t\tswap(s[j], s[j + 1]);\n\t\t\t\t\tss.pb(s);\n\t\t\t\t}\n\t\t\t\ts = in[i];\n\t\t\t\tif(j < s.size()){\n\t\t\t\t\ts.erase(s.begin() + j);\n\t\t\t\t\tss.pb(s);\n\t\t\t\t\t\n\t\t\t\t\trep(k, 26){\n\t\t\t\t\t\ts = in[i];\n\t\t\t\t\t\ts[j] = 'a' + k;\n\t\t\t\t\t\tss.pb(s);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(k, 26){\n\t\t\t\t\ts = in[i];\n\t\t\t\t\ts.insert(s.begin() + j, 'a' + k);\n\t\t\t\t\tss.pb(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tss.pb(in[i]);\n\t\t\tbool ok[200] = {};\n\t\t\trep(j, ss.size()) if(m.count(ss[j])){\n\t\t\t\teach(k, m[ss[j]]){\n\t\t\t\t\tif(ok[*k]) continue;\n\t\t\t\t\tok[*k] = 1;\n\t\t\t\t\tstring a = in[*k], b = in[i];\n\t\t\t\t\tif(a > b) swap(a, b);\n\t\t\t\t\tans.pb(mp(a, b));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tm[in[i]].pb(i);\n\t\t\tif(d > 1) rep(j, ss.size()){\n\t\t\t\tif(!m.count(ss[j]) || m[ss[j]].back() != i)\n\t\t\t\tm[ss[j]].pb(i);\n\t\t\t}\n\t\t}\n\t\tsort(all(ans));\n\t\trep(i, ans.size()) cout << ans[i].first << \",\" << ans[i].second << endl;\n\t\tcout << ans.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\n// Damerau???Levenshtein distance\n// Levenshtein distance ??? transposition (??£????£????swap) ?????????\n// ca -> ac ????????????1\n// https://en.wikipedia.org/wiki/Damerau???Levenshtein_distance\n// wiki ???????£?????????????????????£?????????????????????????????£?????????\n// https://doi.org/10.1145%2F363958.363994\n// ????????????????§£??§????????????\nint damerauLevenshteinDistance(const string &a, const string &b) {\n\tint m = a.size(), n = b.size();\n\tvector<vector<int>> d(m + 1, vector<int>(n + 1, INF));\n\tstatic int da[128];\n\tmemset(da, 0, sizeof(da));\n\trep(i, 0, m + 1)d[i][0] = i;\n\trep(j, 0, n + 1)d[0][j] = j;\n\trep(i, 1, m + 1) {\n\t\tint db = 0;\n\t\trep(j, 1, n + 1) {\n\t\t\tint k = da[b[j - 1]];\n\t\t\tint l = db;\n\t\t\tint cost = 1;\n\t\t\tif (a[i - 1] == b[j - 1]) {\n\t\t\t\tcost = 0;\n\t\t\t\tdb = j;\n\t\t\t}\n\t\t\td[i][j] = min({\n\t\t\t\td[i - 1][j] + 1,\n\t\t\t\td[i][j - 1] + 1,\n\t\t\t\td[i - 1][j - 1] + cost\n\t\t\t});\n\t\t\tif (k - 1 >= 0 && l - 1 >= 0) {\n\t\t\t\tchmin(d[i][j], d[k - 1][l - 1] + (i - k - 1) + 1 + (j - l - 1));\n\t\t\t}\n\t\t}\n\t\tda[a[i - 1]] = i;\n\t}\n\treturn d[m][n];\n}\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int n; cin >> n&&n;) {\n\t\tint d; cin >> d;\n\t\tvector<string> s(n); rep(i, 0, n) {\n\t\t\tcin >> s[i];\n\t\t}\n\t\tsort(all(s));\n\t\tint x = 0;\n\t\trep(i, 0, n)rep(j, i + 1, n) {\n\t\t\tint dst = damerauLevenshteinDistance(s[i], s[j]);\n\t\t\tif (dst <= d) {\n\t\t\t\tcout << s[i] + \",\" + s[j] << endl;\n\t\t\t\tx++;\n\t\t\t}\n\t\t}\n\t\tcout << x << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool check(string a,string b,int d){\n  if(a.size()<b.size())swap(a,b);\n  if(a==b) return 1;\n  if(d==0||a.empty())return 0;\n\n  //erase\n  for(int i=0;i<a.size()&&a.size()>b.size();i++){\n    string t = a;\n    t.erase(t.begin()+i);\n    if(check(t,b,d-1))return 1;\n  }\n\n  //swap\n  for(int i=0;i<(int)a.size()-1;i++){\n    swap(a[i],a[i+1]);\n    if(check(a,b,d-1))return 1;\n    swap(a[i],a[i+1]);\n  }\n  \n  //change\n  for(int i=0;i<b.size();i++){\n    char ch = a[i];\n    if(a[i]!=b[i]) a[i] = b[i];\n    if(check(a,b,d-1))return 1;\n    a[i] = ch;\n  }\n  return 0;\n}\n\nint main(){\n  int n,d;\n  while(cin>>n,n){\n    cin>>d;\n    string str[201];\n    for(int i=0;i<n;i++)cin>>str[i];\n    sort(str,str+n);\n\n    int cnt=0;    \n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++)\n\tif(check(str[i],str[j],d)) cout<<str[i]<<\",\"<<str[j]<<endl,cnt++;\n    cout<<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<string,string> P;\n\nint n,d;\nint ans=0;\nset<string> mp[201];\nint cnt[201][201];\nvector<P> vec;\nstring str[201];\n\nvoid dfs(int v,string s,int nd,int uk=0){\n\tif(nd==0){\n\t\tmp[v].insert(s);\n\t\tfor(int i=0;i+1<s.size();i++){\n\t\t\tswap(s[i],s[i+1]);\n\t\t\tdfs(v,s,nd+1);\n\t\t\tswap(s[i],s[i+1]);\n\t\t}\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tdfs(v,s.substr(0,i)+s.substr(i+1),nd+1);\n\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\tstring gu=\"\";\n\t\t\t\tgu+=('a'+j);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i+1),nd+1,1);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i),nd+1,1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<26;i++){\n\t\t\tstring gu=\"\";\n\t\t\tgu+=('a'+i);\n\t\t\tdfs(v,s+gu,nd+1);\n\t\t}\n\t}else if(nd==1){\n\t\tmp[v].insert(s);\n\t}\n}\n\nvoid dfs2(int v,string s,int nd){\n\tif(nd==0){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(mp[i].find(s)!=mp[i].end()){\n\t\t\t\tcnt[v][i]++;\n\t\t\t\tcnt[i][v]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i+1<s.size();i++){\n\t\t\tswap(s[i],s[i+1]);\n\t\t\tdfs2(v,s,nd+1);\n\t\t\tswap(s[i],s[i+1]);\n\t\t}\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tdfs2(v,s.substr(0,i)+s.substr(i+1),nd+1);\n\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\tstring gu=\"\";\n\t\t\t\tgu+=('a'+j);\n\t\t\t\tdfs2(v,s.substr(0,i)+gu+s.substr(i+1),nd+1);\n\t\t\t\tdfs2(v,s.substr(0,i)+gu+s.substr(i),nd+1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<26;i++){\n\t\t\tstring gu=\"\";\n\t\t\tgu+=('a'+i);\n\t\t\tdfs2(v,s+gu,nd+1);\n\t\t}\n\t}else if(nd==1){\n\t\tif(d==2){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(mp[i].find(s)!=mp[i].end()){\n\t\t\t\t\tcnt[v][i]++;\n\t\t\t\t\tcnt[i][v]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tvec.clear();\n\tfor(int i=0;i<n;i++){\n\t\tmp[i].clear();\n\t}\n\tscanf(\"%d\",&d);\n\tans=0;\n\tmemset(cnt,0,sizeof(cnt));\n\tfor(int i=0;i<n;i++){\n\t\tcin >> str[i];\n\t\tdfs(i,str[i],0);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tdfs2(i,str[i],0);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(cnt[i][j]>0){\n\t\t\t\tans++;\n\t\t\t\tvec.push_back(P(min(str[i],str[j]),max(str[i],str[j])));\n\t\t\t}\n\t\t}\n\t}\n\tsort(vec.begin(),vec.end());\n\tfor(int i=0;i<vec.size();i++){\n\t\tcout << vec[i].first << \",\" << vec[i].second << endl;\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n){\n    int d;\n    vector<string> name(n);\n    cin >> d;\n    rep(i,0,n) cin >> name[i];\n    sort(name.begin(),name.end());\n\n    auto hash_string=hash<string>();\n    function<set<size_t>(const string&,const int)> enumerate_neighborhood=[&](const string &s,int d){\n        if(d==0) return set<size_t>({hash_string(s)});\n        set<size_t> res;\n        //replace\n        rep(i,0,s.size()){\n            string t=s;\n            rep(j,0,26){\n                t[i]='a'+j;\n                auto tmp=enumerate_neighborhood(t,d-1);\n                res.insert(tmp.begin(),tmp.end());\n            }\n        }\n        //insert\n        rep(i,0,s.size()+1){\n            string x=s.substr(0,i),y=s.substr(i);\n            rep(j,0,26){\n                x.push_back('a'+j);\n                auto t=x+y;\n                auto tmp=enumerate_neighborhood(t,d-1);\n                res.insert(tmp.begin(),tmp.end());\n                x.pop_back();\n            }\n        }\n        //delete\n        rep(i,0,s.size()){\n            string t=s.substr(0,i)+s.substr(i+1);\n            auto tmp=enumerate_neighborhood(t,d-1);\n            res.insert(tmp.begin(),tmp.end());\n        }\n        //swap adjacent\n        rep(i,0,s.size()-1){\n            string t=s;\n            swap(t[i],t[i+1]);\n            auto tmp=enumerate_neighborhood(t,d-1);\n            res.insert(tmp.begin(),tmp.end());\n            swap(t[i],t[i+1]);\n        }\n        return res;\n    };\n\n    rep(i,0,n) rep(j,i+1,n){\n        auto u=enumerate_neighborhood(name[i],d);\n        if(u.find(hash_string(name[j]))==u.end()) continue;\n        cout << min(name[i],name[j]) << \",\" << max(name[i],name[j]) << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int inf = 1e9;\n\nint levenshtein_distance(string s1, string s2) {\n    const int n = s1.size(), m = s2.size();\n    vector<vector<int>> dp(n + 1, vector<int>(m + 1, inf));\n    for(int i = 0; i <= n; ++i) dp[i][0] = i;\n    for(int j = 0; j <= m; ++j) dp[0][j] = j;\n    for(int i = 1; i <= n; ++i) {\n        for(int j = 1; j <= m; ++j) {\n            dp[i][j] = min({dp[i][j],\n                            dp[i - 1][j] + 1,\n                            dp[i][j - 1] + 1,\n                            dp[i - 1][j - 1] + (s1[i - 1] != s2[j - 1])});\n        }\n    }\n    return dp[n][m];\n}\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        int d;\n        cin >> d;\n        vector<string> name(n);\n        for(int i = 0; i < n; ++i) {\n            cin >> name[i];\n        }\n\n        vector<string> ans;\n        for(int i = 0; i < n; ++i) {\n            for(int j = i + 1; j < n; ++j) {\n                auto s1 = name[i], s2 = name[j];\n                if(s1.size() < s2.size()) swap(s1, s2);\n                const int m = s1.size();\n\n                int min_d = levenshtein_distance(s1, s2);\n\n                // swap -> levenshtein\n                for(int k = 0; k + 1 < m; ++k) {\n                    swap(s1[k], s1[k + 1]);\n                    min_d = min(min_d, levenshtein_distance(s1, s2) + 1);\n                    swap(s1[k], s1[k + 1]);\n                }\n\n                // swap -> swap\n                for(int k = 0; k + 1 < m && min_d >= 3; ++k) {\n                    swap(s1[k], s1[k + 1]);\n                    for(int l = 0; l + 1 < m; ++l) {\n                        swap(s1[l], s1[l + 1]);\n                        if(s1 == s2) min_d = 2;\n                        swap(s1[l], s1[l + 1]);\n                    }\n                    swap(s1[k], s1[k + 1]);\n                }\n\n                // delete -> swap\n                for(int k = 0; k < m && min_d >= 3; ++k) {\n                    auto ss1 = (k == 0 ? string(\"\") : s1.substr(0, k)) + (k + 1 == m ? string(\"\") : s1.substr(k + 1));\n                    for(int l = 0; l + 1 < m - 1; ++l) {\n                        swap(ss1[l], ss1[l + 1]);\n                        if(ss1 == s2) min_d = 2;\n                        swap(ss1[l], ss1[l + 1]);\n                    }\n                }\n\n                if(min_d <= d) {\n                    ans.push_back(min(name[i], name[j]) + \",\" + max(name[i], name[j]));\n                }\n            }\n        }\n\n        sort(begin(ans), end(ans));\n        for(auto x : ans) {\n            cout << x << endl;\n        }\n        cout << ans.size() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int N = 1e5;\nvi graph[N];\n\nusing ResElem = tuple<int, int>;\nset<ResElem> s;\n\ninline void add_edge(int a, int b){\n    graph[a].emplace_back(b);\n    graph[b].emplace_back(a);\n}\n\nint d, n;\nmap<string, int> s2i;\nmap<int, string> i2s;\n\nvoid dfs(int sv, int v, int depth){\n    if(depth > d) return;\n    if(sv != v and v < n){\n        string a = i2s[v], b = i2s[sv];\n        if(a > b) swap(a, b);\n        s.insert(ResElem(s2i[a], s2i[b]));\n    }\n\n    for(auto& nv : graph[v]){\n        dfs(sv, nv, depth + 1);\n    }\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(; cin >> n >> d, n;){\n        vector<string> names(n);\n        for(auto& e : names) cin >> e;\n\n        s2i.clear();\n        i2s.clear();\n        int idx = 0;\n        auto add_vertex = [&](string& name){\n            if(s2i.find(name) == end(s2i)){\n                s2i[name] = idx; i2s[idx] = name; idx++;\n            }\n            return s2i[name];\n        };\n        for(auto& e : names) add_vertex(e);\n\n        rep(i, N) graph[i].clear();\n        for(auto& cur : names){\n            string next;\n            int len = cur.size();\n            int v = s2i[cur];\n\n            // delete\n            rep(i, len){\n                next = cur.substr(0, i) + cur.substr(i + 1);\n                int nv = add_vertex(next);\n                add_edge(v, nv);\n            }\n\n            // insert\n            rep(i, len + 1){\n                rep(j, 'z' - 'a' + 1){\n                    char c = (char)('a' + j);\n                    next = cur.substr(0, i) + c + cur.substr(i);\n                    int nv = add_vertex(next);\n                    add_edge(v, nv);\n                }\n            }\n\n            // replace\n            rep(i, len){\n                rep(j, 'z' - 'a' + 1){\n                    char c = (char)('a' + j);\n                    next = cur.substr(0, i) + c + cur.substr(i + 1);\n                    int nv = add_vertex(next);\n                    add_edge(v, nv);\n                }\n            }\n\n            // swap\n            rep(i, len - 1){\n                next = cur;\n                swap(next[i], next[i + 1]);\n                int nv = add_vertex(next);\n                add_edge(v, nv);\n            }\n        }\n\n        s.clear();\n        rep(i, n){\n            dfs(i, i, 0);\n        }\n\n        for(auto& e : s){\n            int a, b; tie(a, b) = e;\n            cout << i2s[a] << \",\" << i2s[b] << endl;\n        }\n        cout << s.size() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n){\n    int d;\n    vector<string> name(n);\n    cin >> d;\n    rep(i,0,n) cin >> name[i];\n    sort(name.begin(),name.end());\n\n    auto hash_string=hash<string>();\n    function<set<size_t>(const string&,const int)> enumerate_neighborhood=[&](const string &s,int d){\n        if(d==0) return set<size_t>({hash_string(s)});\n        set<size_t> res;\n        //replace\n        rep(i,0,s.size()){\n            string t=s;\n            rep(j,0,26){\n                t[i]='a'+j;\n                auto tmp=enumerate_neighborhood(t,d-1);\n                res.insert(tmp.begin(),tmp.end());\n            }\n        }\n        //insert\n        rep(i,0,s.size()+1){\n            string x=s.substr(0,i),y=s.substr(i);\n            rep(j,0,26){\n                x.push_back('a'+j);\n                auto t=x+y;\n                auto tmp=enumerate_neighborhood(t,d-1);\n                res.insert(tmp.begin(),tmp.end());\n                x.pop_back();\n            }\n        }\n        //delete\n        rep(i,0,s.size()){\n            string t=s.substr(0,i)+s.substr(i+1);\n            auto tmp=enumerate_neighborhood(t,d-1);\n            res.insert(tmp.begin(),tmp.end());\n        }\n        //swap adjacent\n        rep(i,0,s.size()-1){\n            string t=s;\n            swap(t[i],t[i+1]);\n            auto tmp=enumerate_neighborhood(t,d-1);\n            res.insert(tmp.begin(),tmp.end());\n            swap(t[i],t[i+1]);\n        }\n        return res;\n    };\n\n    int count=0;\n    rep(i,0,n){\n        auto u=enumerate_neighborhood(name[i],d);\n        rep(j,i+1,n){\n            if(u.find(hash_string(name[j]))==u.end()) continue;\n            cout << min(name[i],name[j]) << \",\" << max(name[i],name[j]) << endl;\n            ++count;\n        }\n    }\n    cout << count << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing std::sort;\nusing std::swap;\nint N, D;\nstruct Name{\n    char s[20];\n}name[300];\n\nbool comp(Name a, Name b){\n    int i=0;\n    while(true){\n        if(a.s[i]=='\\0') return true;\n        if(b.s[i]=='\\0') return false;\n        if(a.s[i] < b.s[i]) return true;\n        if(a.s[i] > b.s[i]) return false;\n        i++;\n    }return true;\n}\n\nbool distance(int a, int b, int x, int y, int d){\n    if(d > D) return false;\n    if(name[a].s[x] == '\\0'){\n        int del = 0;\n        while(name[b].s[y+del]!='\\0') del++;\n        return del+d <= D;\n    }\n    if(name[b].s[y] == '\\0'){\n        int del = 0;\n        while(name[a].s[x+del]!='\\0') del++;\n        return del+d <= D;\n    }\n    if(name[a].s[x] == name[b].s[y]) return distance(a, b, x+1, y+1, d); //always best\n    if(distance(a, b, x+1, y, d+1)) return true; //del a[x]->x++ or Insert b[y]\n    if(distance(a, b, x, y+1, d+1)) return true; //del b[y]->y++ or Insert a[x]\n    if(distance(a, b, x+1, y+1, d+1)) return true; //Replacing\n    //swap = =...\n    for(int i=x+1 ; name[a].s[i]!='\\0' ; i++){\n        swap(name[a].s[i], name[a].s[x]);\n        if(distance(a, b, x, y, d+1)){\n            swap(name[a].s[i], name[a].s[x]);\n            return true;\n        }\n        swap(name[a].s[i], name[a].s[x]);\n    }\n    return false;\n}\n\nint main(){\n    while(scanf(\"%d %d\", &N, &D) && N){\n        for(int i=0;i<N;i++){\n            scanf(\"%s\", name[i].s);\n        }\n        sort(name, name+N, comp);\n        int res = 0;\n        for(int i=0;i<N;i++){\n            for(int j=i+1;j<N;j++){\n                if(distance(i, j, 0, 0, 0)){\n                    printf(\"%s,%s\\n\", name[i].s, name[j].s);\n                    res++;\n                }\n            }\n        }\n        printf(\"%d\\n\", res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nint n,d;\nstring s[222];\nset<string>st[222];\nbool used[222][222];\nset<string>::iterator it,it2;\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(cin>>n,n){\n    memset(used,0,sizeof(used));\n    cin>>d;\n    r(i,n)cin>>s[i];\n    sort(s,s+n);\n    r(i,n)st[i].clear();\n    r(i,n){\n      r(j,s[i].size()){\n        string t=s[i];\n        t.erase(t.begin()+j);\n        st[i].insert(t);\n      }\n      r(j,s[i].size()+1){\n        r(k,26){\n          string t=s[i];\n          t=t.substr(0,j)+(char)(k+'a')+t.substr(j);\n          st[i].insert(t);\n        }\n      }\n      r(j,s[i].size()+1){\n        r(k,26){\n          string t=s[i];\n          t[j]=(char)(k+'a');\n          st[i].insert(t);\n        }\n      }\n      r(j,s[i].size()-1){\n          string t=s[i];\n          swap(t[j],t[j+1]);\n          st[i].insert(t);\n      }\n    }\n    int ans=0;\n    if(d==1){\n      r(i,n)for(int j=i+1;j<n;j++)if(i!=j&&!used[i][j]){{\n        for(it=st[i].begin();it!=st[i].end();it++){\n            if(s[j]==(*it)){\n                used[i][j]=used[j][i]=1;\n                cout<<s[i]<<','<<s[j]<<endl;\n                ans++;\n                break;\n            }\n          }\n        }\n      }\n    }\n    else{\n      r(i,n)for(int j=i+1;j<n;j++)if(i!=j&&!used[i][j]){\n        for(it=st[i].begin();it!=st[i].end();it++){\n              if(st[j].count(*it)){\n                used[i][j]=used[j][i]=1;\n                cout<<s[i]<<','<<s[j]<<endl;\n                ans++;\n                break;\n              }\n          }\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint N,D;\nmap<string,vector<P> > ss;\nstring s[202];\nbool ok[202][202];\n\nint main(){\n  while(1){\n    cin>>N;\n    if(N==0)break;\n    cin>>D;\n    memset(ok,0,sizeof(ok));\n    ss.clear();\n    rep(i,N){\n      cin>>s[i];\n      int sz=s[i].size();\n      ss[s[i]].push_back(P(i,0));\n      rep(j,sz){ // delete\n        string t=s[i];\n        t=t.substr(0,j)+t.substr(j+1,sz-1-j);\n        ss[t].push_back(P(i,1));\n      }\n      rep(j,sz-1){ // swap\n        string t=s[i];\n        swap(t[j],t[j+1]);\n        ss[t].push_back(P(i,1));\n      }\n      rep(j,sz)repl(c,'a','z'+1){ // mutate\n        string t=s[i];\n        t[j]=c;\n        ss[t].push_back(P(i,1));\n      }\n      rep(j,sz+1)for(char c='a';c<='z';c++){ // insert\n        string t=s[i];\n        string u;\n        u+=t.substr(0,j);\n        u+=c;\n        u+=t.substr(j,sz-j);\n        ss[u].push_back(P(i,1));\n      }\n    }\n    for(auto it : ss){\n      for(auto it1 : it.se){\n        for(auto it2 : it.se){\n          if(it1.se+it2.se<=D){\n            ok[it1.fi][it2.fi]=true;\n            ok[it2.fi][it1.fi]=true;\n          }\n        }\n      }\n    }\n    vector<pair<string,string> > res;\n    rep(i,N)rep(j,i){\n      if(ok[i][j]){\n        res.push_back(pair<string,string>(min(s[i],s[j]),max(s[i],s[j])));\n      }\n    }\n    sort(all(res));\n    rep(i,res.size())cout<<res[i].fi<<\",\"<<res[i].se<<endl;\n    cout<<res.size()<<endl;\n  }\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\nusing ps = pair<string,string>;\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        int d;\n        cin >>d;\n        vector<string> name(n);\n        rep(i,n) cin >>name[i];\n        sort(all(name));\n\n        vector<set<string>> v(n);\n        rep(i,n){\n            string s = name[i];\n            int S = s.size();\n            string t;\n\n            // delete\n            rep(j,S){\n                t = s;\n                t.erase(t.begin()+j);\n                v[i].insert(t);\n            }\n\n            // insert\n            rep(j,S+1){\n                rep(k,26){\n                    char c = 'a'+k;\n                    t = s;\n                    t.insert(j,string(1,c));\n                    v[i].insert(t);\n                }\n            }\n\n            // replace\n            rep(j,S){\n                rep(k,26){\n                    char c = 'a'+k;\n                    t = s;\n                    if(t[j] != c){\n                        t[j] = c;\n                        v[i].insert(t);\n                    }\n                }\n            }\n\n            // swap ADJACENT\n            rep(j,S-1){\n                t = s;\n                if(t[j]!=t[j+1]){\n                    swap(t[j],t[j+1]);\n                    v[i].insert(t);\n                }\n            }\n        }\n\n        map<string,vector<int>> idx;\n        rep(i,n){\n            for(string ss:v[i]) idx[ss].pb(i);\n        }\n\n        set<pi> ans;\n        // d==1\n        rep(i,n)for(int j=i+1; j<n; ++j){\n            if(v[i].count(name[j])) ans.insert({i,j});\n        }\n        if(d==2){\n            for(const auto p:idx){\n                vector<int> tt = p.se;\n                int sz = tt.size();\n\n                rep(i,sz)rep(j,i){\n                    if(tt[j]!=tt[i]) ans.insert({tt[j],tt[i]});\n                }\n            }\n        }\n\n        // for(pi p:ans) dbg(p);\n        for(pi p:ans) cout << name[p.fi] << \",\" << name[p.se] << \"\\n\";\n        cout << ans.size() << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    int d;\n    cin>>d;\n    set<string> ss;\n    for(int i=0;i<n;i++){\n      string s;\n      cin>>s;\n      ss.emplace(s);\n    }\n    using P = pair<string, string>;\n    set<P> ans;\n    auto calc=[](string s){\n      int n=s.size();\n      set<string> ss;\n      for(int i=0;i<n;i++){\n\tstring t=s;\n\tt.erase(t.begin()+i);\n\tss.emplace(t);\n      }\n      for(int i=0;i<=n;i++){\n\tfor(char c='a';c<='z';c++){\n\t  string t=s;\n\t  t.insert(t.begin()+i,c);\n\t  ss.emplace(t);\n\t}\n      }\n      for(int i=0;i<n;i++){\n\tfor(char c='a';c<='z';c++){\n\t  string t=s;\n\t  t[i]=c;\n\t  ss.emplace(t);\n\t}\n      }\n      for(int i=0;i<n-1;i++){\n\tswap(s[i],s[i+1]);\n\tss.emplace(s);\n\tswap(s[i],s[i+1]);\n      }\n      return ss;\n    };\n    \n    for(string s:ss){\n      map<string,int> dp;\n      queue<string> q;\n      dp[s]=0;\n      q.emplace(s);\n      while(!q.empty()){\n\tstring t=q.front();q.pop();\n\tif(dp[t]>=d) continue;\n\tauto xs=calc(t);\n\tfor(string x:xs){\n\t  if(dp.count(x)) continue;\n\t  dp[x]=dp[t]+1;\n\t  q.emplace(x);\n\t}\n      }\n      for(auto p:dp){\n\tif(p.first==s||p.second>d) continue;\n\tif(ss.count(p.first)) ans.emplace(minmax({s,p.first}));\n      }\n    }\n    for(P p:ans)\n      cout<<p.first<<\",\"<<p.second<<endl;\n    cout<<ans.size()<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nint damerau_levenshtein_distance(const string &a,const string &b){\n    vector<int> da(26);\n    vector<vector<int>> d(a.size()+2,vector<int>(b.size()+2));\n    int maxdist=a.size()+b.size();\n    const int dummy=1;\n    d[-1+dummy][-1+dummy]=maxdist;\n    for(int i=0; i<=a.size(); ++i){\n        d[i+dummy][-1+dummy]=maxdist;\n        d[i+dummy][0+dummy]=i;\n    }\n    for(int i=0; i<=b.size(); ++i){\n        d[-1+dummy][i+dummy]=maxdist;\n        d[0+dummy][i+dummy]=i;\n    }\n    for(int i=1; i<=a.size(); ++i){\n        int db=0;\n        for(int j=1; j<=b.size(); ++j){\n            int k=da[b[j-1]-'a'],l=db,cost;\n            if(a[i-1]==b[j-1]){\n                cost=0;\n                db=j;\n            }else cost=1;\n            d[i+dummy][j+dummy]=min({d[i-1+dummy][j-1+dummy]+cost,d[i+dummy][j-1+dummy]+1,d[i-1+dummy][j+dummy]+1,d[k-1+dummy][l-1+dummy]+(i-k-1)+1+(j-l-1)});\n        }\n        da[a[i-1]-'a']=i;\n    }\n    return d[a.size()][b.size()];\n}\n\nvoid solve(int n){\n    int d;\n    vector<string> name(n);\n    cin >> d;\n    rep(i,0,n) cin >> name[i];\n    sort(name.begin(),name.end());\n\n    int count=0;\n    rep(i,0,n){\n        rep(j,i+1,n){\n            if(damerau_levenshtein_distance(name[i],name[j])>d) continue;\n            ++count;\n            cout << name[i] << \",\" << name[j] << endl;\n        }\n    }\n    cout << count << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    int d;\n    cin>>d;\n    set<string> ss;\n    for(int i=0;i<n;i++){\n      string s;\n      cin>>s;\n      ss.emplace(s);\n    }\n    using P = pair<string, string>;\n    set<P> ans;\n    auto calc=[](string s){\n      int n=s.size();\n      set<string> ss;\n      for(int i=0;i<n;i++){\n\tstring t=s;\n\tt.erase(t.begin()+i);\n\tss.emplace(t);\n      }\n      for(int i=0;i<n;i++){\n\tfor(char c='a';c<='z';c++){\n\t  string t=s;\n\t  t[i]=c;\n\t  ss.emplace(t);\n\t}\n      }\n      for(int i=0;i<n-1;i++){\n\tswap(s[i],s[i+1]);\n\tss.emplace(s);\n\tswap(s[i],s[i+1]);\n      }\n      return ss;\n    };\n    map<string,vector<string> > ms;\n    for(string s:ss){\n      if(d==1){\n\tmap<string,int> dp;\n\tqueue<string> q;\n\tdp[s]=0;\n\tq.emplace(s);\n\twhile(!q.empty()){\n\t  string t=q.front();q.pop();\n\t  if(dp[t]>=d) continue;\n\t  auto xs=calc(t);\n\t  for(string x:xs){\n\t    if(dp.count(x)) continue;\n\t    dp[x]=dp[t]+1;\n\t    q.emplace(x);\n\t  }\n\t}\n\tfor(auto p:dp){\n\t  if(p.first==s||p.second>d) continue;\n\t  if(ss.count(p.first)) ans.emplace(minmax({s,p.first}));\n\t}\n      }\n      if(d==2){\n\tmap<string,int> dp;\n\tqueue<string> q;\n\tdp[s]=0;\n\tq.emplace(s);\n\twhile(!q.empty()){\n\t  string t=q.front();q.pop();\n\t  if(dp[t]>=2) continue;\n\t  auto xs=calc(t);\n\t  for(string x:xs){\n\t    if(dp.count(x)) continue;\n\t    dp[x]=dp[t]+1;\n\t    q.emplace(x);\n\t  }\n\t}\n\tcontinue;\n\tfor(auto p:dp){\n\t  if(p.second==1){\n\t    for(auto x:ms[p.first])\n\t      ans.emplace(minmax({s,x}));\n\t    \n\t    ms[p.first].emplace_back(s);\n\t  }\n\t  if(p.first==s||p.second>d) continue;\n\t  if(ss.count(p.first)) ans.emplace(minmax({s,p.first}));\n\t}\n      }\n    }\n    for(P p:ans)\n      cout<<p.first<<\",\"<<p.second<<endl;\n    cout<<ans.size()<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ulli;\n\nconst ulli B = 1000000007ULL;\n\n\nulli getHash(const string &s) {\n  int n = s.size();\n  ulli res = 0;\n  for(int i = 0; i < n; ++i) {\n    res = res * B + s[i];\n  }\n  return res;\n}\n\nint main() {\n  for(int n, d; cin >> n && n; ) {\n    cin >> d;\n    vector<string> ss(n);\n    for(int i = 0; i < n; ++i) {\n      cin >> ss[i];\n    }\n\n    sort(ss.begin(), ss.end());\n\n    vector<set<ulli> > nextHash(n);\n    for(int k = 0; k < n; ++k) {\n      string s = ss[k];\n      // Deleting\n      for(int i = 0; i < s.size(); ++i) {\n        char tmp = s[i];\n        s.erase(i, 1);\n        nextHash[k].insert(getHash(s));\n        s.insert(i, string(1, tmp));\n      }\n      // Inserting\n      for(int i = 0; i <= s.size(); ++i) {\n        for(char c = 'a'; c <= 'z'; ++c) {\n          s.insert(i, string(1, c));\n          nextHash[k].insert(getHash(s));\n          s.erase(i, 1);\n        }\n      }\n      // Replacing\n      for(int i = 0; i < s.size(); ++i) {\n        char tmp = s[i];\n        for(char c = 'a'; c <= 'z'; ++c) {\n          s[i] = c;\n          nextHash[k].insert(getHash(s));\n        }\n        s[i] = tmp;\n      }\n      // Swapping\n      for(int i = 0; i + 1 < s.size(); ++i) {\n        int j = i + 1;\n        swap(s[i], s[j]);\n        nextHash[k].insert(getHash(s));\n        swap(s[i], s[j]);\n      }\n    }\n\n    map<ulli, int> A;\n    map<ulli, set<int> > B;\n    for(int i = 0; i < n; ++i) {\n      A[getHash(ss[i])] = i;\n      if(d <= 1) continue;\n      for(set<ulli>::iterator it = nextHash[i].begin();\n          it != nextHash[i].end(); ++it) {\n        B[*it].insert(i);\n      }\n    }\n\n    set<pair<int, int> > ans;\n    for(int i = 0; i < n; ++i) {\n      for(set<ulli>::iterator it = nextHash[i].begin();\n          it != nextHash[i].end(); ++it) {\n        if(A.count(*it)) {\n          pair<int, int> p(i, A[*it]);\n          if(p.first > p.second) swap(p.first, p.second);\n          ans.insert(p);\n        }\n      }\n      for(set<ulli>::iterator it = nextHash[i].begin();\n          it != nextHash[i].end(); ++it) {\n        if(B.count(*it)) {\n          for(set<int>::iterator it2 = B[*it].begin();\n              it2 != B[*it].end(); ++it2) {\n            pair<int, int> p(i, *it2);\n            if(p.first > p.second) swap(p.first, p.second);\n            ans.insert(p);\n          }\n        }\n      }\n    }\n\n    int res = 0;\n    for(set<pair<int, int> >::iterator it = ans.begin();\n        it != ans.end(); ++it) {\n      if(it->first == it->second) continue;\n      ++res;\n      cout << ss[it->first] << \",\" << ss[it->second] << endl;\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n)-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(b)-1;i>=(a);--i)\n#define ALL(a) a.begin(),a.end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n    if (a > b) { a = b; return true; }\n    return false;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"{\";\n    int a = 0;\n    for (auto &tp : mp) {\n        if (a) os << \", \"; a = 1;\n        os << tp;\n    }\n    return os << \"}\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    for (;;) {\n        int n; cin >> n;\n        if (n == 0) break;\n\n        int d; cin >> d;\n        vector<string> names(n);\n        REP(i, n) cin >> names[i];\n        sort(ALL(names));\n\n        map<string,int> nameDict;\n        for (string name : names) nameDict[name] = -1;\n        int cnt = 0;\n        for (auto &tp : nameDict) tp.second = cnt++;\n        // DUMP(nameDict);\n\n        map<string,map<string,bool>> edit;\n\n        for (string name : names) {\n            // delete\n            REP(i, name.size()) {\n                string s = name.substr(0,i) + name.substr(i+1, name.size());\n                edit[s][name] = 1;\n            }\n            // swap\n            REP(i, SZ(name)-1) {\n                string s = name;\n                swap(s[i], s[i+1]);\n                edit[s][name] = 1;\n            }\n            // insert\n            REP(i, name.size()+1) {\n                REP(c, 26) {\n                    string s = name.substr(0, i) + (char)(c + 'a') + name.substr(i, name.size());\n                    edit[s][name] = 1;\n                }\n            }\n            // replace\n            REP(i, name.size()+1) {\n                REP(c, 26) {\n                    string s = name;\n                    s[i] = c + 'a';\n                    edit[s][name] = 1;\n                }\n            }\n        }\n\n        // DEBUG(edit);\n\n        vvi ans(cnt, vi(cnt, 0));\n\n        if (d == 1) {\n            for (auto &to : edit) {\n                if (nameDict.count(to.first)) {\n                    for (auto &from : to.second) {\n                        ans[nameDict[from.first]][nameDict[to.first]] = 1;\n                        ans[nameDict[to.first]][nameDict[from.first]] = 1;\n                    }\n                }\n            }\n        } else {\n            for (auto &tp : edit) {\n                for (auto &from : tp.second) {\n                    for (auto &to : tp.second) {\n                        ans[nameDict[from.first]][nameDict[to.first]] = 1;\n                        ans[nameDict[to.first]][nameDict[from.first]] = 1;\n                    }\n                }\n            }\n        }\n\n        // REP(i, cnt) DUMP(ans[i]);\n        int total = 0;\n        REP(i, cnt) {\n            FOR(j, i+1, cnt) {\n                if (ans[i][j]) {\n                    ++total;\n                    cout << names[i] << \",\" << names[j] << endl;\n                }\n            }\n        }\n        cout << total << endl;\n    }\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n){\n    int d;\n    vector<string> name(n);\n    cin >> d;\n    rep(i,0,n) cin >> name[i];\n    sort(name.begin(),name.end());\n\n    function<vector<string>(const string&)> enumerate_neighborhood=[&](const string &s){\n        vector<string> st;\n        //replace\n        {\n            string t=s;\n            rep(i,0,s.size()){\n                rep(j,0,26){\n                    t[i]='a'+j;\n                    st.push_back(t);\n                }\n                t[i]=s[i];\n            }\n        }\n        //insert\n        {\n            string x;\n            rep(i,0,s.size()+1){\n                string y=s.substr(i);\n                rep(j,0,26){\n                    x.push_back('a'+j);\n                    auto t=x+y;\n                    st.push_back(t);\n                    x.pop_back();\n                }\n                x+=s[i];\n            }\n        }\n        //delete\n        {\n            string x;\n            rep(i,0,s.size()){\n                string t=x+s.substr(i+1);\n                st.push_back(t);\n                x+=s[i];\n            }\n        }\n        //swap adjacent\n        {\n            string t=s;\n            rep(i,0,s.size()-1){\n                swap(t[i],t[i+1]);\n                st.push_back(t);\n                swap(t[i],t[i+1]);\n            }\n        }\n        return st;\n    };\n\n    vector<vector<string>> us(n);\n    rep(i,0,n){\n        us[i]=enumerate_neighborhood(name[i]);\n        sort(us[i].begin(),us[i].end());\n    }\n\n    int count=0;\n    rep(i,0,n){\n        rep(j,i+1,n){\n            if(d==1){\n                if(find(us[i].begin(),us[i].end(),name[j])==us[i].end()) continue;\n            }else{\n                vector<string> v;\n                set_intersection(us[i].begin(),us[i].end(),us[j].begin(),us[j].end(),back_inserter(v));\n                if(v.empty()) continue;\n            }\n            cout << name[i] << \",\" << name[j] << endl;\n            ++count;\n        }\n    }\n    cout << count << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nbool check(string a,string b,int d){\n  if(a.size()<b.size())swap(a,b);\n  if(a==b) return 1;\n  int A = a.size(),B=b.size();\n  if(d==0||A-B>d)return 0;\n\n\n  //erase\n  for(int i=0;i<A;i++){\n    char ch = a[i];\n    a.erase(a.begin()+i);\n    if(check(a,b,d-1))return 1;\n    a.insert(a.begin()+i,ch);\n  }\n  \n  if(A!=B) return 0;\n\n  \n  //swap\n  for(int i=0;i<A-1;i++){\n    if(a[i]==a[i+1]||a[i+1]!=b[i]||a[i]!=b[i+1])continue;\n    swap(a[i],a[i+1]);\n    if(check(a,b,d-1))return 1;\n    swap(a[i],a[i+1]);\n  }\n\n  //change\n  int cnt=0;\n  for(int i=0;i<A;i++) cnt+=a[i]!=b[i];\n  if(cnt<=d)return 1;\n  \n  return 0;\n}\n\nint main(){\n  int n,d;\n  while(cin>>n,n){\n    cin>>d;\n    string str[201];\n    for(int i=0;i<n;i++)cin>>str[i];\n    sort(str,str+n);\n\n    int cnt=0;    \n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++)\n\tif(check(str[i],str[j],d)) cout<<str[i]<<\",\"<<str[j]<<endl,cnt++;\n    cout<<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n/* -----  2017/11/13  Problem: NU_27_A / Link: __CONTEST_URL__  ----- */\n/* ------問題------\n\n\n\n-----問題ここまで----- */\n/* -----解説等-----\n\n\n\n----解説ここまで---- */\n\nint N;\n\n\nint func_dp(string&s, string&t, int d) {\n\tint SZ_S = SZ(s);\n\tint SZ_T = SZ(t);\n\n\tvector<VVI> dp(SZ_S + 1, VVI(SZ_T + 1, VI(26, 10)));//init 10 1index\n\t// 0はまだどれもswapしてない\n\t/*VVI ruis(SZ_S + 1, VI(26, 0));\n\tVVI ruit(SZ_T + 1, VI(26, 0));*/\n\tFOR(i, 0, SZ_S + 1) {\n\t\tdp[i][0][0] = i;\n\t}\n\tFOR(j, 0, SZ_T + 1) {\n\t\tdp[0][j][0] = j;\n\t}\n\t/*FOR(i, 0, SZ_S) {\n\t\tFOR(j, 0, 26)\n\t\t\truis[i + 1][j] += ruis[i][j] + (s[i] == ('a' + j) ? 1 : 0);\n\t}\n\tFOR(i, 0, SZ_T) {\n\t\tFOR(j, 0, 26)\n\t\t\truis[i + 1][j] += ruis[i][j] + (t[i] == ('a' + j) ? 1 : 0);\n\t}*/\n\tint c = 0;\n\tint INDEX_S = 0;\n\tint INDEX_T = 0;\n\tFOR(i, 1, SZ_S + 1) {\n\t\tFOR(j, 1, SZ_T + 1) {\n\t\t\tif (s[i - 1] == t[j - 1])c = 0, INDEX_S = INDEX_T = 100;\n\t\t\telse {//ちゃう\n\t\t\t\t//swap可能\n\t\t\t\tINDEX_T = t.find(s[i - 1]);\n\t\t\t\tINDEX_S = s.find(t[i - 1]);// if no -1(npos)\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\tFOR(k, 0, 26) {\n\t\t\t\tdp[i][j][k] = min(dp[i][j][k], dp[i - 1][j - 1][k] + c*((INDEX_T == k || INDEX_S == k) ? 0 : 1));\n\t\t\t\tdp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k] + c*((INDEX_T == k || INDEX_S == k) ? 0 : 1));\n\t\t\t\tdp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k] + c*((INDEX_T == k || INDEX_S == k) ? 0 : 1));\n\t\t\t}\n\t\t}\n\t}\n\tFOR(k, 0, 26) {\n\t\tif (dp[SZ_S][SZ_T][k] <= d)return 1;\n\t}\n\treturn 0;\n}\n\nint main() {\n\n\twhile (scanf(\"%d\", &N), N) {\n\t\tint d; scanf(\"%d\", &d);\n\t\tchar str[200][20];\n\t\tVS orig(N);\n\t\tstring ss;\n\t\tFOR(i, 0, N) {\n\t\t\tscanf(\"%s\", str[i]);\n\t\t\torig[i] = str[i];\n\t\t}\n\t\tset<PII>se;\n\t\tFOR(i, 0, N) {\n\t\t\tFOR(j, i + 1, N) {\n\t\t\t\tif (func_dp(orig[i], orig[j], d)) {\n\t\t\t\t\tse.insert(PII(i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = SZ(se);\n\t\tfor (auto i : se)\n\t\t\tprintf(\"%s,%s\\n\", str[i.first], str[i.second]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t//printf(\"%s\\n\", str);\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nbool comp(string s, string t){\n\tfor(int i = 0; i < min(s.size(), t.size()); i++){\n\t\tif(s[i] < t[i]) return true;\n\t\tif(s[i] > t[i]) return false;\n\t}\n\treturn s.size() <= t.size();\n}\n\nint getDist(const string& s, const string& t){\n\tint dp[20][20];\n\tfor(int i = 0; i <= s.size(); i++) dp[i][0] = i;\n\tfor(int i = 0; i <= t.size(); i++) dp[0][i] = i;\n\n\tfor(int i = 1; i <= s.size(); i++)\n\t\tfor(int j = 1; j <= t.size(); j++)\n\t\t\tdp[i][j] = min(min(dp[i - 1][j] + 1, dp[i][j - 1] + 1),\n\t\t\t\t\t\t   dp[i - 1][j - 1] + (s[i - 1] != t[j - 1]));\n\treturn (dp[s.size()][t.size()]);\n}\n\nstring name[256];\n\nbool f(string s, string t, int d){\n\tif(s == t) return true;\n\tif(getDist(s, t) <= d) return true;\n\n\tif(d >= 1){\n\t\t// 1???????????????\n\t\tif(s.size() == t.size()){\n\t\t\tfor(int i = 0; i < s.size() - 1; i++){\n\t\t\t\tswap(s[i], s[i + 1]);\n\t\t\t\tif(s == t) return true;\n\t\t\t\tswap(s[i], s[i + 1]);\n\t\t\t}\n\t\t}\n\t}\n\tif(d == 2){\n\t\t// 2???????????????\n\t\tif(s.size() == t.size()){\n\t\t\tfor(int i = 0; i < s.size() - 1; i++){\n\t\t\t\tswap(s[i], s[i + 1]);\n\t\t\t\tfor(int j = 0; j < s.size() - 1; j++){\n\t\t\t\t\tif(i == j) continue;\n\t\t\t\t\tswap(s[j], s[j + 1]);\n\t\t\t\t\tif(s == t) return true;\n\t\t\t\t\tswap(s[j], s[j + 1]);\n\t\t\t\t}\n\t\t\t\tswap(s[i], s[i + 1]);\n\t\t\t}\n\t\t}\n\t\tif(s.size() - 1 == t.size()){\n\t\t\t// ???????????£???????????????\n\t\t\tfor(int i = 0; i < s.size() - 2; i++){\n\t\t\t\tswap(s[i], s[i + 2]);\n\t\t\t\tint l = i + 1, r = s.size() - 1 - l;\n\t\t\t\tstring ss = s.substr(0, i + 1) + s.substr(i + 2, r);\n\t\t\t\tif(ss == t) return true;\n\t\t\t\tswap(s[i], s[i + 2]);\n\t\t\t}\n\t\t}\n\t\tif(t.size() - 1 == t.size()){\n\t\t\t// ???????????£???????????????\n\t\t\tfor(int i = 0; i < t.size() - 2; i++){\n\t\t\t\tswap(t[i], t[i + 2]);\n\t\t\t\tint l = i + 1, r = t.size() - 1 - l;\n\t\t\t\tstring tt = t.substr(0, i + 1) + t.substr(i + 2, r);\n\t\t\t\tif(tt == s) return true;\n\t\t\t\tswap(t[i], t[i + 2]);\n\t\t\t}\n\t\t}\n\t\t// 1?????????????????§??¨????????¢1\n\t\tfor(int i = 0; i < s.size() - 1; i++){\n\t\t\tswap(s[i], s[i + 1]);\n\t\t\tif(getDist(s, t) <= 1) return true;\n\t\t\tswap(s[i], s[i + 1]);\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tint n, d;\n\twhile(cin >> n >> d, n){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> name[i];\n\t\t}\n\n\t\tvector<pair<string, string>> ans;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tif(f(name[i], name[j], d)){\n\t\t\t\t\tstring s1 = min(name[i], name[j], comp);\n\t\t\t\t\tstring s2 = max(name[i], name[j], comp);\n\t\t\t\t\tans.push_back({ s1, s2 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(ans.begin(), ans.end());\n\t\tfor(auto v : ans){\n\t\t\tcout << v.first + \",\" + v.second << endl;\n\t\t}\n\t\tcout << ans.size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <stdlib.h>\n\nusing namespace std;\n\nint n, d;\nvector<string> vec;\n\nbool contain(string &a, string &b)\n{\n\tstring s, t;\n\tif(a.size() > b.size()) s = a, t = b;\n\telse s = b, t = a;\n\t\n\tint pos = 0;\n\tfor(int i = 0; i < s.size(); i++){\n\t\tif(pos < t.size() && s[i] == t[pos]) pos++;\n\t}\n\treturn pos >= t.size();\n}\n\nbool check(string &s, string &t, int d)\n{\n\tint dif = 0;\n\tvector<int> vec;\n\t\n\tfor(int i = 0; i < s.size(); i++){\n\t\tif(s[i] != t[i]){\n\t\t\tdif++;\n\t\t\tvec.push_back(i);\n\t\t}\n\t}\n\t\n\tif(dif <= d) return true;\n\t\n\tif(d == 1){\n\t\tif(dif > 2) return false;\n\t\treturn vec[0] + 1 == vec[1] && s[vec[0]] == t[vec[1]] && s[vec[1]] == t[vec[0]];\n\t}\n\tif(d == 2){\n\t\tfor(int i = 0; i < s.size(); i++){\n\t\t\tstring u = s.substr(0, i) + s.substr(i+1);\n\t\t\tif(contain(u, t)) return true;\n\t\t}\n\t\tif(dif == 4){\n\t\t\treturn (vec[0] + 1 == vec[1] && s[vec[0]] == t[vec[1]] && s[vec[1]] == t[vec[0]])\n\t\t\t&& (vec[2] + 1 == vec[3] && s[vec[2]] == t[vec[3]] && s[vec[3]] == t[vec[2]]);\n\t\t}\n\t\tif(dif == 3){\n\t\t\tif(vec[0] + 1 != vec[1]) \n\t\t\t\treturn (vec[1] + 1 == vec[2] && s[vec[1]] == t[vec[2]] && s[vec[2]] == t[vec[1]]);\n\t\t\tif(vec[1] + 1 != vec[2]) \n\t\t\t\treturn (vec[0] + 1 == vec[1] && s[vec[0]] == t[vec[1]] && s[vec[1]] == t[vec[0]]);\n\t\t\t\n\t\t\tif(s[vec[0]] == t[vec[1]] && s[vec[1]] == t[vec[0]]) return true;\n\t\t\tif(s[vec[1]] == t[vec[2]] && s[vec[2]] == t[vec[1]]) return true;\n\t\t\tif(s[vec[0]] == t[vec[1]] && s[vec[1]] == t[vec[2]] && s[vec[2]] == t[vec[0]]) return true;\n\t\t\tif(s[vec[0]] == t[vec[1]] && s[vec[1]] == t[vec[2]] && s[vec[2]] == t[vec[0]]) return true;\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tcin >> d;\n\t\t\n\t\tstring s;\n\t\tvec.clear();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> s;\n\t\t\tvec.push_back(s);\n\t\t}\n\t\tsort(vec.begin(), vec.end());\n\t\t\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < vec.size(); i++){\n\t\t\tfor(int j = 0; j < vec.size(); j++){\n\t\t\t\tif(i >= j) continue;\n\t\t\t\t\n\t\t\t\tint dif = abs((int)vec[i].size() - (int)vec[j].size());\n\t\t\t\tif(dif > d) continue;\n\t\t\t\tif(dif == d){\n\t\t\t\t\tif(contain(vec[i], vec[j]) )goto NEAR;\n\t\t\t\t\telse continue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(d == 2 && dif == 1){\n\t\t\t\t\tstring s, t;\n\t\t\t\t\tif(vec[i].size() > vec[j].size()) s = vec[i], t = vec[j];\n\t\t\t\t\telse s = vec[j], t = vec[i];\n\t\t\t\t\tfor(int k = 0; k < s.size(); k++){\n\t\t\t\t\t\tstring u = s.substr(0, k) + s.substr(k+1);\n\t\t\t\t\t\tif(check(u, t, 1)) goto NEAR;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(check(vec[i], vec[j], d)) goto NEAR;\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tNEAR:;\n\t\t\t\tcnt++;\n\t\t\t\tcout << vec[i] << \",\" << vec[j] << endl;\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define FOR(it,o)  for(__typeof((o).begin()) it =(o).begin();it != (o).end();it++)\n#define pb         push_back\n#define mp         make_pair\n\n\ntypedef unsigned long long           ull;\ntypedef pair<string,string> pss;\ntypedef vector<pss>         vpss;\n\nconst ull tmp = 10007;\n\null calchash(string &in){\n  ull ret= 0;\n  rep(i,(int)in.size()){\n    ret=ret*tmp + in[i];\n  }\n  return ret;\n}\n\n\nbool isok[200][200];\nint ed[200][200];\nint cost[20][20];\nint edit_distance(string tr,string tc){\n  string r,c;\n  r=' ';\n  c=' ';\n  rep(i,tr.size())r+=tr[i];\n  rep(i,tc.size())c+=tc[i];\n  rep(i,r.size())rep(j,c.size())cost[i][j]=(1<<21);\n\n  rep(i,r.size())cost[i][0]=i;\n  rep(i,c.size())cost[0][i]=i;\n\n  REP(i,1,r.size()){\n    REP(j,1,c.size()){\n      int tmp =r[i]==c[j]?0:1;\n      int opt[3];\n      opt[0]=cost[i-1][j-1]+tmp;\n      opt[1]=cost[i-1][j]+1;\n      opt[2]=cost[i][j-1]+1;\n      rep(k,3)cost[i][j]=min(cost[i][j],opt[k]);\n    }\n  }\n  return cost[r.size()-1][c.size()-1];\n}\n\n\nvoid ed1(vector<string>&in,set<ull> S[]){\n  rep(i,(int)in.size()){\n    REP(j,i+1,(int)in.size()){\n      if (S[j].find(calchash(in[i])) != S[j].end()){\n\tisok[i][j] = true;\n      }\n    }    \n  }\n}\n\t \nvoid ed2(vector<string> &in,set<ull> S[]){\n  rep(i,(int)in.size()){\n    REP(j,i+1,(int)in.size()){\n      if (isok[i][j]||ed[i][j] > 4)continue;\n      FOR(it,S[i]){\n\tif (S[j].find( *it) != S[j].end()){\n\t  isok[i][j]=true;\n\t  break;\n\t}\n      }\n    }\n  }\n}\n\nvoid del_string(string &in,set<ull>&S){\n  rep(i,(int)in.size()){\n    string tmp = in;\n    tmp.erase(tmp.begin()+i);\n    S.insert(calchash(tmp));\n  }\n}\n\nvoid insert_string(string &in,set<ull>&S){\n  rep(i,(int)in.size()+1){\n    rep(j,26){\n      string tmp=in.substr(0,i);\n      tmp+='a'+j;\n      //tmp+=string(1,'a'+j);\n      string tmp2=in.substr(i);\n      rep(k,tmp2.size())tmp+=(char)tmp2[k];\n      //tmp=string(tmp)+string(in.substr(i));\n      S.insert(calchash(tmp));\n    }\n  }\n}\n\nvoid replace_string(string &in,set<ull>&S){\n  rep(i,(int)in.size()){\n    char tmp = in[i];\n    rep(j,26){\n      in[i]='a'+j;\n      S.insert(calchash(in));\n    }\n    in[i]=tmp;\n  }\n}\n\nvoid swap_string(string&in,set<ull>&S){\n  rep(i,(int)in.size()-1){\n    swap(in[i],in[i+1]);\n    S.insert(calchash(in));\n    swap(in[i],in[i+1]);\n  }\n}\n\nvoid make_string(vector<string>& in,set<ull> S[]){\n  rep(i,(int)in.size()){\n    del_string(in[i],S[i]);\n    insert_string(in[i],S[i]);\n    replace_string(in[i],S[i]);\n    swap_string(in[i],S[i]);\n  }\n}\n\nvoid solve(vector<string>in,set<ull>S[],int d){\n  int n=(int)in.size();\n  rep(i,n){\n    REP(j,i+1,n){\n      ed[i][j]=edit_distance(in[i],in[j]);\n      if (ed[i][j] <= d)isok[i][j]=true;\n    }\n  }\n  \n  make_string(in,S);\n  ed1(in,S);\n  if (d==2)ed2(in,S);\n  int cnt=0;\n  rep(i,n){\n    rep(j,n)if (isok[i][j])cnt++,cout<<in[i]<<\",\"<<in[j]<<endl;\n  }\n  cout << cnt << endl;\n}\n\nvoid test(){\n  string in=\"test\";\n  set<ull> S;\n  insert_string(in,S);\n}\n\nmain(){\n  //test();\n  int n,d;\n  while(cin>>n>>d && n){\n    vector<string> in;\n    rep(i,n)rep(j,n)isok[i][j]=false,cost[i][j]=(1<<21);\n    set<ull> S[n];\n    rep(i,n){\n      string tmp;\n      cin>>tmp;\n      in.pb(tmp);\n    }\n    sort(ALL(in));\n    rep(i,(int)in.size())S[i].insert(calchash(in[i]));\n    solve(in,S,d);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint edit_dist(const string& s, const string& t, int B){\n  int l1 = s.size();\n  int l2 = t.size();\n  int dp[32][32] = {};\n  REP(i, l1) dp[i + 1][0] = i + 1;\n  REP(j, l2) dp[0][j + 1] = j + 1;\n  REP(i, l1) {\n    int min_d = INF;\n    REP(j, l2){\n      if(s[i] == t[j]) dp[i + 1][j + 1] = dp[i][j];\n      else dp[i + 1][j + 1] = min(dp[i][j], min(dp[i + 1][j], dp[i][j + 1])) + 1;\n      min_d = min(min_d, dp[i + 1][j + 1]);\n    }\n    //if(min_d > B) return B + 1;\n  }\n  return dp[l1][l2];\n}\nbool check(string s, string t, int D){\n  if(D == 0){\n    if(s == t) return true;\n  }else if(D == 1){\n    if(edit_dist(s, t, 1) <= 1) return true;\n    if(s.size() == t.size()) REP(i, s.size() - 1){\n      swap(s[i], s[i + 1]);\n      if(s == t) return true;\n      swap(s[i], s[i + 1]);\n    }\n  }else if(D == 2){\n    if(edit_dist(s, t, 2) <= 2) return true;\n    REP(i, s.size() - 1){\n      swap(s[i], s[i + 1]);\n      if(edit_dist(s, t, 1) <= 1) return true;\n      if(s.size() == t.size()) REP(k, s.size() - 1) {\n        swap(s[k], s[k + 1]);\n        if(s == t) return true;\n        swap(s[k], s[k + 1]);\n      }\n      swap(s[i], s[i + 1]);\n    }\n  }else {\n    assert(false);\n  }\n  return false;\n}\nint main(){\n  int N, D;\n  while(cin >> N >> D && N){\n    vector<string> name(N);\n    REP(i, N) cin >> name[i];\n    vector< pair<string, string> > ans;\n    REP(i, N) FOR(j, i + 1, N){\n      if(check(name[i], name[j], D)) ans.push_back(make_pair( min(name[i], name[j]), max(name[i], name[j]) ));\n    }\n    sort(ans.begin(), ans.end());\n    REP(i, ans.size()){\n      printf(\"%s,%s\\n\", ans[i].first.c_str(), ans[i].second.c_str());\n    }\n    printf(\"%d\\n\", (int)ans.size());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<string,string> P;\n\nint n,d;\nint ans=0;\nmap<string,int> mp[201];\nint cnt[201];\nvector<P> vec;\nstring str[201];\n\nvoid dfs(int v,string s,int nd){\n\tif(nd==0){\n\t\tfor(int i=0;i<v;i++){\n\t\t\tif(mp[i].find(s)!=mp[i].end()){\n\t\t\t\tcnt[i]++;\n\t\t\t}\n\t\t}\n\t\tmp[v][s]=1;\n\t\tfor(int i=0;i+1<s.size();i++){\n\t\t\tswap(s[i],s[i+1]);\n\t\t\tdfs(v,s,nd+1);\n\t\t\tswap(s[i],s[i+1]);\n\t\t}\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tdfs(v,s.substr(0,i)+s.substr(i+1),nd+1);\n\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\tstring gu=\"\";\n\t\t\t\tgu+=('a'+j);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i+1),nd+1);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i),nd+1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<26;i++){\n\t\t\tstring gu=\"\";\n\t\t\tgu+=('a'+i);\n\t\t\tdfs(v,s+gu,nd+1);\n\t\t}\n\t}else if(nd==1){\n\t\tmp[v][s]=1;\n\t\tif(d==2){\n\t\t\tfor(int i=0;i<v;i++){\n\t\t\t\tif(mp[i].find(s)!=mp[i].end()){\n\t\t\t\t\tcnt[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tvec.clear();\n\tfor(int i=0;i<n;i++){\n\t\tmp[i].clear();\n\t}\n\tscanf(\"%d\",&d);\n\tans=0;\n\tfor(int i=0;i<n;i++){\n\t\tmemset(cnt,0,sizeof(cnt));\n\t\tcin >> str[i];\n\t\tdfs(i,str[i],0);\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(cnt[j]>0){\n\t\t\t\tans++;\n\t\t\t\tvec.push_back(P(min(str[i],str[j]),max(str[i],str[j])));\n\t\t\t}\n\t\t}\n\t}\n\tsort(vec.begin(),vec.end());\n\tfor(int i=0;i<vec.size();i++){\n\t\tcout << vec[i].first << \",\" << vec[i].second << endl;\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define FOR(it,o)  for(__typeof((o).begin()) it =(o).begin();it != (o).end();it++)\n#define pb         push_back\n#define mp         make_pair\n\ntypedef pair<string,string> pss;\ntypedef vector<pss>         vpss;\nbool isok[200][200];\nvoid ed1(vector<string>&in,set<string> *S){\n  rep(i,in.size()){\n    REP(j,i+1,in.size()){\n      if (S[j].find(in[i]) != S[j].end()){\n\tisok[i][j] = true;\n      }\n    }    \n  }\n}\n\t \nvoid ed2(vector<string> &in,set<string> *S){\n  rep(i,in.size()){\n    REP(j,i+1,in.size()){\n      if (isok[i][j])continue;\n      FOR(it,S[i]){\n\tif (S[j].find(*it) != S[j].end()){\n\t  isok[i][j]=true;\n\t  break;\n\t}\n      }\n    }\n  }\n}\n\nvoid del_string(string &in,set<string>&S){\n  rep(i,in.size()){\n    string tmp = in;\n    tmp.erase(tmp.begin()+i);\n    S.insert(tmp);\n  }\n}\n\nvoid insert_string(string &in,set<string>&S){\n  rep(i,in.size()){\n    rep(j,26){\n      string tmp=in.substr(0,i);\n      tmp+=string(1,'a'+j);\n      tmp+=in.substr(i);\n      S.insert(tmp);\n    }\n  }\n}\n\nvoid replace_string(string &in,set<string>&S){\n  rep(i,in.size()){\n    char tmp = in[i];\n    rep(j,26){\n      in[i]='a'+j;\n      S.insert(in);\n    }\n    in[i]=tmp;\n  }\n}\n\nvoid swap_string(string&in,set<string>&S){\n  rep(i,(int)in.size()-1){\n    swap(in[i],in[i+1]);\n    S.insert(in);\n    swap(in[i],in[i+1]);\n  }\n}\n\nvoid make_string(vector<string>& in,set<string> *S){\n  rep(i,in.size()){\n    del_string(in[i],S[i]);\n    insert_string(in[i],S[i]);\n    replace_string(in[i],S[i]);\n    swap_string(in[i],S[i]);\n  }\n}\n\nvoid solve(vector<string>in,set<string>*S,int d){\n  int n=in.size();\n  make_string(in,S);\n  ed1(in,S);\n  //if (d==2)ed2(in,S);\n  int cnt=0;\n  rep(i,n){\n    rep(j,n)if (isok[i][j])cnt++,cout<<in[i]<<\",\"<<in[j]<<endl;\n  }\n  cout << cnt << endl;\n}\n\nmain(){\n  int n,d;\n  while(cin>>n>>d && n){\n    vector<string> in;\n    rep(i,n)rep(j,n)isok[i][j]=false;\n    set<string> S[n];\n    rep(i,n){\n      string tmp;\n      cin>>tmp;\n      in.pb(tmp);\n    }\n    sort(ALL(in));\n    solve(in,S,d);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<cstdio>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\nusing namespace std;\n\nint main(){\n  int n, d;\n  while(cin >> n >> d){\n    vector<string> name(n);\n    REP(i,n) cin >> name[i];\n\n    map<string, set<string> > conflict;\n\n    typedef pair<int, pair<string,string> > data;\n    queue<data> que;\n\n    REP(i,n){\n      que.push(make_pair(0, make_pair(name[i], name[i])));\n    }\n\n    while(que.size()){\n      data dt = que.front(); que.pop();\n      int cnt                = dt.first;\n      const string &original = dt.second.first;\n      const string &modified = dt.second.second;\n\n      if(conflict[modified].count(original) != 0) continue;\n\n      conflict[modified].insert(original);\n\n      if(cnt < d){\n        // swap\n        for(int i = 0; i < modified.size(); i++){\n          for(int j = i + 1; j < modified.size(); j++){\n            string str = modified; swap(str[i], str[j]);\n            que.push(make_pair(cnt + 1, make_pair(original, str)));\n          }\n        }\n        // delete\n        for(int i = 0; i < modified.size(); i++){\n          string str = modified; str.erase(str.begin() + i);\n          que.push(make_pair(cnt + 1, make_pair(original, str)));\n        }\n        // insert\n        for(int i = 0; i <= modified.size(); i++){\n          for(int j = 'a'; j <= 'z'; j++){\n            string str = modified; str.insert(str.begin() + i, (char)j);\n            que.push(make_pair(cnt + 1, make_pair(original, str)));\n          }\n        }\n        // modify\n        for(int i = 0; i < modified.size(); i++){\n          for(int j = 'a'; j <= 'z'; j++){\n            string str = modified; str[i] = j;\n            que.push(make_pair(cnt + 1, make_pair(original, str)));\n          }\n        }\n      }\n    }\n\n    set<pair<string, string> > ans;\n    FOR(it, conflict) if(it->second.size() > 1){\n      vector<string> tmp(it->second.begin(), it->second.end());\n      const int sz = tmp.size();\n\n      for(int i = 0; i < sz; i++)\n        for(int j = i + 1; j < sz; j++)\n          ans.insert(make_pair(tmp[i], tmp[j]));\n    }\n\n    FOR(it, ans){\n      cout << it->first << \",\" << it->second << endl;\n    }\n    cout << ans.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#define INF (1<<29)\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\ntypedef pair<string,string> pss;\n\nint dist(string s,string t) {\n  int d[20][20];\n  fill(d[0],d[20],INF);\n\n  int n=s.size(),m=t.size();\n  for(int i=0;i<=n;i++)d[i][0]=i;\n  for(int i=0;i<=m;i++)d[0][i]=i;\n  \n  int sp[128],tp[128];\n  fill(sp,sp+128,-1);\n  for(int i=0;i<n;sp[s[i]]=i,i++){\n    fill(tp,tp+128,-1);\n    for(int j=0;j<m;tp[t[j]]=j,j++){\n      int cost=(s[i]!=t[j]);\n      int ii=sp[t[j]],jj=tp[s[i]];\n      d[i+1][j+1]=min(min(d[i][j+1],d[i+1][j])+1,d[i][j]+cost);\n      if(ii>=0 && jj>=0)\n\td[i+1][j+1]=min(d[i+1][j+1],d[ii][jj]+i-ii+j-jj-1);\n    }\n  }\n  return d[n][m]; \n}\n\nint main(void){\n\n  int n,d;\n  while(cin >> n,n){\n    cin >> d;\n    vector<string> v(n);\n    for(int i=0;i<n;i++)cin >> v[i];\n\n    vector<pair<string,string> >res;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(dist(v[i],v[j])<=d){\n\t  res.push_back(pss(min(v[i],v[j]),max(v[i],v[j])));\n\t}\n      }\n    }\n    sort(all(res));\n    for(int i=0;i<res.size();i++)\n      cout << res[i].first << \",\" << res[i].second << endl;\n    cout << res.size() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<string,string> P;\n\nint n,d;\nint ans=0;\nset<string> mp[201];\nint cnt[201];\nvector<P> vec;\nstring str[201];\n\nvoid dfs(int v,string s,int nd){\n\tif(nd==0){\n\t\tfor(int i=0;i<v;i++){\n\t\t\tif(mp[i].find(s)!=mp[i].end()){\n\t\t\t\tcnt[i]++;\n\t\t\t}\n\t\t}\n\t\tmp[v].insert(s);\n\t\tfor(int i=0;i+1<s.size();i++){\n\t\t\tswap(s[i],s[i+1]);\n\t\t\tdfs(v,s,nd+1);\n\t\t\tswap(s[i],s[i+1]);\n\t\t}\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tdfs(v,s.substr(0,i)+s.substr(i+1),nd+1);\n\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\tstring gu=\"\";\n\t\t\t\tgu+=('a'+j);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i+1),nd+1);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i),nd+1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<26;i++){\n\t\t\tstring gu=\"\";\n\t\t\tgu+=('a'+i);\n\t\t\tdfs(v,s+gu,nd+1);\n\t\t}\n\t}else if(nd==1){\n\t\tmp[v].insert(s);\n\t\tif(d==2){\n\t\t\tfor(int i=0;i<v;i++){\n\t\t\t\tif(mp[i].find(s)!=mp[i].end()){\n\t\t\t\t\tcnt[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tvec.clear();\n\tfor(int i=0;i<n;i++){\n\t\tmp[i].clear();\n\t}\n\tscanf(\"%d\",&d);\n\tans=0;\n\tfor(int i=0;i<n;i++){\n\t\tmemset(cnt,0,sizeof(cnt));\n\t\tcin >> str[i];\n\t\tdfs(i,str[i],0);\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(cnt[j]>0){\n\t\t\t\tans++;\n\t\t\t\tvec.push_back(P(min(str[i],str[j]),max(str[i],str[j])));\n\t\t\t}\n\t\t}\n\t}\n\tsort(vec.begin(),vec.end());\n\tfor(int i=0;i<vec.size();i++){\n\t\tcout << vec[i].first << \",\" << vec[i].second << endl;\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define FOR(it,o)  for(__typeof((o).begin()) it =(o).begin();it != (o).end();it++)\n#define pb         push_back\n#define mp         make_pair\n\ntypedef pair<string,string> pss;\ntypedef vector<pss>         vpss;\n\nvoid ed1(vector<string>&in,set<string> *S,\n\t vpss &ans){\n  rep(i,in.size()){\n    REP(j,i+1,in.size()){\n      if (S[j].find(in[i]) != S[j].end()){\n\tans.pb(mp(in[i],in[j]));\n      }\n    }    \n  }\n}\n\t \nvoid ed2(vector<string> &in,set<string> *S,vpss &ans){\n  rep(i,in.size()){\n    REP(j,i+1,in.size()){\n      FOR(it,S[i]){\n\tif (S[j].find(*it) != S[j].end()){\n\t  ans.pb(mp(in[i],in[j]));\n\t  break;\n\t}\n      }\n    }\n  }\n}\n\nvoid del_string(string &in,set<string>&S){\n  rep(i,in.size()){\n    string tmp = in;\n    tmp.erase(tmp.begin()+i);\n    S.insert(tmp);\n  }\n}\n\nvoid insert_string(string &in,set<string>&S){\n  rep(i,in.size()){\n    rep(j,26){\n      string tmp=in.substr(0,i);\n      tmp+=string(1,'a'+j);\n      tmp+=in.substr(i);\n      S.insert(tmp);\n    }\n  }\n}\n\nvoid replace_string(string &in,set<string>&S){\n  rep(i,in.size()){\n    char tmp = in[i];\n    rep(j,26){\n      in[i]='a'+j;\n      S.insert(in);\n    }\n    in[i]=tmp;\n  }\n}\n\nvoid swap_string(string&in,set<string>&S){\n  rep(i,(int)in.size()-1){\n    swap(in[i],in[i+1]);\n    S.insert(in);\n    swap(in[i],in[i+1]);\n  }\n}\n\nvoid make_string(vector<string>& in,set<string> *S){\n  rep(i,in.size()){\n    del_string(in[i],S[i]);\n    insert_string(in[i],S[i]);\n    replace_string(in[i],S[i]);\n    swap_string(in[i],S[i]);\n  }\n}\n\nvoid solve(vector<string>in,set<string>*S,int d){\n  vpss ans;\n  make_string(in,S);\n  ed1(in,S,ans);\n  if (d==2)ed2(in,S,ans);\n  sort(ALL(ans));\n  ans.erase(unique(ALL(ans)),ans.end());\n  rep(i,ans.size()){\n    cout << ans[i].first<<\",\"<<ans[i].second<<endl;\n  }\n  cout << ans.size()<<endl;\n}\n\nmain(){\n  int n,d;\n  while(cin>>n>>d && n){\n    vector<string> in;\n    set<string> S[n];\n    rep(i,n){\n      string tmp;\n      cin>>tmp;\n      in.pb(tmp);\n    }\n    sort(ALL(in));\n    solve(in,S,d);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solve(int n){\n    int d;\n    cin>>d;\n    vector<string> name(n);\n    for(int i=0;i<n;i++) cin>>name[i];\n    vector<pair<string,string>> res;\n    auto check=[&](int i){\n        vector<string> strs;\n        function<void(string,int)> dfs=[&](string s,int cnt){\n            if(cnt==0){\n                strs.push_back(s);\n                return;\n            }\n            //insert\n            for(int i=0;i<=s.size();i++){\n                for(int k=0;k<='z'-'a';k++){\n                    char x='a'+k;\n                    string tmp=s.substr(0,i)+x+s.substr(i);\n                    dfs(tmp,cnt-1);\n                }\n            }\n            //delete\n            for(int i=0;i<s.size();i++){\n                string tmp=s.substr(0,i)+s.substr(i+1);\n                dfs(tmp,cnt-1);\n            }\n            //replace\n            for(int i=0;i<s.size();i++){\n                for(int k=0;k<='z'-'a';k++){\n                    char x='a'+k;\n                    string tmp=s.substr(0,i)+x+s.substr(i+1);\n                    dfs(tmp,cnt-1);\n                }\n            }\n            //swap\n            for(int i=0;i+1<s.size();i++){\n                string tmp=s;\n                swap(tmp[i],tmp[i+1]);\n                dfs(tmp,cnt-1);\n            }\n        };\n        dfs(name[i],d);\n        vector<int> isok(i,false);\n        for(int j=0;j<i;j++){\n            for(auto str:strs){\n                if(str==name[j]) isok[j]=true;\n            }\n        }\n        for(int j=0;j<i;j++) if(isok[j]) res.push_back({min(name[i],name[j]),max(name[i],name[j])});\n    };\n    for(int i=0;i<n;i++){\n        check(i);\n    }   \n    sort(res.begin(),res.end());\n    for(int i=0;i<res.size();i++){\n        cout<<res[i].first<<\",\"<<res[i].second<<endl;\n    }\n    cout<<res.size()<<endl;\n}\nint main(){\n    int n;\n    while(cin>>n,n){\n        solve(n);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define FOR(it,o)  for(__typeof((o).begin()) it =(o).begin();it != (o).end();it++)\n#define pb         push_back\n#define mp         make_pair\n\n\ntypedef unsigned long long           ull;\ntypedef pair<string,string> pss;\ntypedef vector<pss>         vpss;\n\nconst ull tmp = 10007;\n\null calchash(string &in){\n  ull ret= 0;\n  rep(i,in.size()){\n    ret=ret*tmp + in[i];\n  }\n  return ret;\n}\n\n\nbool isok[200][200];\nvoid ed1(vector<string>&in,set<ull> *S){\n  rep(i,in.size()){\n    REP(j,i+1,in.size()){\n      if (S[j].find(calchash(in[i])) != S[j].end()){\n\tisok[i][j] = true;\n      }\n    }    \n  }\n}\n\t \nvoid ed2(vector<string> &in,set<ull> *S){\n  rep(i,in.size()){\n    REP(j,i+1,in.size()){\n      if (isok[i][j])continue;\n      FOR(it,S[i]){\n\tif (S[j].find(*it) != S[j].end()){\n\t  isok[i][j]=true;\n\t  break;\n\t}\n      }\n    }\n  }\n}\n\nvoid del_string(string &in,set<ull>&S){\n  rep(i,in.size()){\n    string tmp = in;\n    tmp.erase(tmp.begin()+i);\n    S.insert(calchash(tmp));\n  }\n}\n\nvoid insert_string(string &in,set<ull>&S){\n  rep(i,in.size()){\n    rep(j,26){\n      string tmp=in.substr(0,i);\n      tmp+=string(1,'a'+j);\n      tmp+=in.substr(i);\n      S.insert(calchash(tmp));\n    }\n  }\n}\n\nvoid replace_string(string &in,set<ull>&S){\n  rep(i,in.size()){\n    char tmp = in[i];\n    rep(j,26){\n      in[i]='a'+j;\n      S.insert(calchash(in));\n    }\n    in[i]=tmp;\n  }\n}\n\nvoid swap_string(string&in,set<ull>&S){\n  rep(i,(int)in.size()-1){\n    swap(in[i],in[i+1]);\n    S.insert(calchash(in));\n    swap(in[i],in[i+1]);\n  }\n}\n\nvoid make_string(vector<string>& in,set<ull> *S){\n  rep(i,in.size()){\n    del_string(in[i],S[i]);\n    insert_string(in[i],S[i]);\n    replace_string(in[i],S[i]);\n    swap_string(in[i],S[i]);\n  }\n}\n\nvoid solve(vector<string>in,set<ull>*S,int d){\n  int n=in.size();\n  make_string(in,S);\n  ed1(in,S);\n  if (d==2)ed2(in,S);\n  int cnt=0;\n  rep(i,n){\n    rep(j,n)if (isok[i][j])cnt++,cout<<in[i]<<\",\"<<in[j]<<endl;\n  }\n  cout << cnt << endl;\n}\n\nmain(){\n  int n,d;\n  while(cin>>n>>d && n){\n    vector<string> in;\n    rep(i,n)rep(j,n)isok[i][j]=false;\n    set<ull> S[n];\n    rep(i,n){\n      string tmp;\n      cin>>tmp;\n      in.pb(tmp);\n    }\n    sort(ALL(in));\n    solve(in,S,d);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<string,string> P;\n\nint n,d;\nint ans=0;\nset<string> mp[201];\nint cnt[201];\nvector<P> vec;\nstring str[201];\nqueue<int> que;\n\nvoid dfs(int v,string s,int nd){\n\tif(nd==0){\n\t\tint r=que.size();\n\t\tfor(int i=0;i<r;i++){\n\t\t\tint nv=que.front();\n\t\t\tque.pop();\n\t\t\tif(mp[nv].find(s)!=mp[nv].end()){\n\t\t\t\tcnt[nv]++;\n\t\t\t}else{\n\t\t\t\tque.push(nv);\n\t\t\t}\n\t\t}\n\t\tmp[v].insert(s);\n\t\tfor(int i=0;i+1<s.size();i++){\n\t\t\tswap(s[i],s[i+1]);\n\t\t\tdfs(v,s,nd+1);\n\t\t\tswap(s[i],s[i+1]);\n\t\t}\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tdfs(v,s.substr(0,i)+s.substr(i+1),nd+1);\n\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\tstring gu=\"\";\n\t\t\t\tgu+=('a'+j);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i+1),nd+1);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i),nd+1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<26;i++){\n\t\t\tstring gu=\"\";\n\t\t\tgu+=('a'+i);\n\t\t\tdfs(v,s+gu,nd+1);\n\t\t}\n\t}else if(nd==1){\n\t\tmp[v].insert(s);\n\t\tif(d==2){\n\t\t\tint r=que.size();\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tint nv=que.front();\n\t\t\t\tque.pop();\n\t\t\t\tif(mp[nv].find(s)!=mp[nv].end()){\n\t\t\t\t\tcnt[nv]++;\n\t\t\t\t}else{\n\t\t\t\t\tque.push(nv);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tvec.clear();\n\tfor(int i=0;i<n;i++){\n\t\tmp[i].clear();\n\t}\n\tscanf(\"%d\",&d);\n\tans=0;\n\tfor(int i=0;i<n;i++){\n\t\tmemset(cnt,0,sizeof(cnt));\n\t\tcin >> str[i];\n\t\twhile(que.size())que.pop();\n\t\tfor(int j=0;j<i;j++){\n\t\t\tque.push(j);\n\t\t}\n\t\tdfs(i,str[i],0);\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(cnt[j]>0){\n\t\t\t\tans++;\n\t\t\t\tvec.push_back(P(min(str[i],str[j]),max(str[i],str[j])));\n\t\t\t}\n\t\t}\n\t}\n\tsort(vec.begin(),vec.end());\n\tfor(int i=0;i<vec.size();i++){\n\t\tcout << vec[i].first << \",\" << vec[i].second << endl;\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<string,string> P;\n\nint n,d;\nint ans=0;\nset<string> mp[201];\nint cnt[201][201];\nvector<P> vec;\nstring str[201];\n\nvoid dfs(int v,string s,int nd,int uk=0){\n\tif(nd==0){\n\t\tif(s.size()==0)while(1);\n\t\tmp[v].insert(s);\n\t\tfor(int i=0;i+1<s.size();i++){\n\t\t\tswap(s[i],s[i+1]);\n\t\t\tdfs(v,s,nd+1);\n\t\t\tswap(s[i],s[i+1]);\n\t\t}\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tdfs(v,s.substr(0,i)+s.substr(i+1),nd+1);\n\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\tstring gu=\"\";\n\t\t\t\tgu+=('a'+j);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i+1),nd+1,1);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i),nd+1,1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<26;i++){\n\t\t\tstring gu=\"\";\n\t\t\tgu+=('a'+i);\n\t\t\tdfs(v,s+gu,nd+1);\n\t\t}\n\t}else if(nd==1){\n\t\tmp[v].insert(s);\n\t}\n}\n\nvoid dfs2(int v,string s,int nd){\n\tcout << s << endl;\n\tif(nd==0){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(mp[i].find(s)!=mp[i].end()){\n\t\t\t\tcnt[v][i]++;\n\t\t\t\tcnt[i][v]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i+1<s.size();i++){\n\t\t\tswap(s[i],s[i+1]);\n\t\t\tdfs2(v,s,nd+1);\n\t\t\tswap(s[i],s[i+1]);\n\t\t}\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tdfs2(v,s.substr(0,i)+s.substr(i+1),nd+1);\n\t\t}\n\t\tfor(int i=0;i<26;i++){\n\t\t\tstring gu=\"\";\n\t\t\tgu+=('a'+i);\n\t\t\tdfs2(v,s+gu,nd+1);\n\t\t}\n\t}else if(nd==1){\n\t\tif(d==2){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(mp[i].find(s)!=mp[i].end()){\n\t\t\t\t\tcnt[v][i]++;\n\t\t\t\t\tcnt[i][v]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tvec.clear();\n\tfor(int i=0;i<n;i++){\n\t\tmp[i].clear();\n\t}\n\tscanf(\"%d\",&d);\n\tans=0;\n\tmemset(cnt,0,sizeof(cnt));\n\tfor(int i=0;i<n;i++){\n\t\tcin >> str[i];\n\t\tdfs(i,str[i],0);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tdfs2(i,str[i],0);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(cnt[i][j]>0){\n\t\t\t\tans++;\n\t\t\t\tvec.push_back(P(min(str[i],str[j]),max(str[i],str[j])));\n\t\t\t}\n\t\t}\n\t}\n\tsort(vec.begin(),vec.end());\n\tfor(int i=0;i<vec.size();i++){\n\t\tcout << vec[i].first << \",\" << vec[i].second << endl;\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<string,string> P;\n\nint n,d;\nint ans=0;\nset<string> mp[201];\nint cnt[201];\nvector<P> vec;\nstring str[201];\n\nvoid dfs(int v,string s,int nd){\n\tif(nd==0){\n\t\tfor(int i=0;i<v;i++){\n\t\t\tif(cnt[i]>0)continue;\n\t\t\tif(mp[i].find(s)!=mp[i].end()){\n\t\t\t\tcnt[i]++;\n\t\t\t}\n\t\t}\n\t\tmp[v].insert(s);\n\t\tfor(int i=0;i+1<s.size();i++){\n\t\t\tswap(s[i],s[i+1]);\n\t\t\tdfs(v,s,nd+1);\n\t\t\tswap(s[i],s[i+1]);\n\t\t}\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tdfs(v,s.substr(0,i)+s.substr(i+1),nd+1);\n\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\tstring gu=\"\";\n\t\t\t\tgu+=('a'+j);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i+1),nd+1);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i),nd+1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<26;i++){\n\t\t\tstring gu=\"\";\n\t\t\tgu+=('a'+i);\n\t\t\tdfs(v,s+gu,nd+1);\n\t\t}\n\t}else if(nd==1){\n\t\tmp[v].insert(s);\n\t\tif(d==2){\n\t\t\tfor(int i=0;i<v;i++){\n\t\t\t\tif(cnt[i]>0)continue;\n\t\t\t\tif(mp[i].find(s)!=mp[i].end()){\n\t\t\t\t\tcnt[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tvec.clear();\n\tfor(int i=0;i<n;i++){\n\t\tmp[i].clear();\n\t}\n\tscanf(\"%d\",&d);\n\tans=0;\n\tfor(int i=0;i<n;i++){\n\t\tmemset(cnt,0,sizeof(cnt));\n\t\tcin >> str[i];\n\t\tdfs(i,str[i],0);\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(cnt[j]>0){\n\t\t\t\tans++;\n\t\t\t\tvec.push_back(P(min(str[i],str[j]),max(str[i],str[j])));\n\t\t\t}\n\t\t}\n\t}\n\tsort(vec.begin(),vec.end());\n\tfor(int i=0;i<vec.size();i++){\n\t\tcout << vec[i].first << \",\" << vec[i].second << endl;\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<set>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\nchar in[20];\nstring str[210];\nset<string> lis[210];\nchar ch[2];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tint b;scanf(\"%d\",&b);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tstr[i]=in;\n\t\t}\n\t\tstd::sort(str,str+a);\n\t\tfor(int i=0;i<a;i++)lis[i].clear();\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=0;j<str[i].size();j++){\n\t\t\t\tstring tmp=str[i].substr(0,j)+str[i].substr(j+1);\n\t\t\t\tlis[i].insert(tmp);\n\t\t\t}\n\t\t\tfor(int j=0;j<=str[i].size();j++){\n\t\t\t\tfor(int k=0;k<26;k++){\n\t\t\t\t\tstring tmp=str[i].substr(0,j);\n\t\t\t\t\tch[0]='a'+k;\n\t\t\t\t\ttmp.append(ch);\n\t\t\t\t\ttmp.append(str[i].substr(j));\n\t\t\t\t\tlis[i].insert(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<str[i].size();j++){\n\t\t\t\tchar rev=str[i][j];\n\t\t\t\tfor(int k=0;k<26;k++){\n\t\t\t\t\tstr[i][j]='a'+k;\n\t\t\t\t\tlis[i].insert(str[i]);\n\t\t\t\t}\n\t\t\t\tstr[i][j]=rev;\n\t\t\t}\n\t\t\tfor(int j=0;j<str[i].size()-1;j++){\n\t\t\t\tswap(str[i][j],str[i][j+1]);\n\t\t\t\tlis[i].insert(str[i]);\n\t\t\t\tswap(str[i][j],str[i][j+1]);\n\t\t\t}\n\t\t//\tstd::sort(lis[i].begin(),lis[i].end());\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=i+1;j<a;j++){\n\t\t\t\tbool ok=false;\n\t\t\t\tif(b==1){\n\t\t\t\t\tif(lis[i].count(str[j]))ok=true;\n\t\t\t\t}else{\n\t\t\t\t\tfor(set<string>::iterator it=lis[j].begin();it!=lis[j].end();it++){\n\t\t\t\t\t\tif(lis[i].count(*it)){\n\t\t\t\t\t\t\tok=true;break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok){\n\t\t\t\t\tret++;\n\t\t\t\t\tprintf(\"%s,%s\\n\",str[i].c_str(),str[j].c_str());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\n// Levenshtein Distance\nint levenshtein(string a, string b) {\n  int n = a.size(), m = b.size();\n  int d[n+1][m+1];\n  REP(i, n+1) d[i][0] = i;\n  REP(i, m+1) d[0][i] = i;\n  for (int i=1; i<=n; ++i) {\n    for (int j=1; j<=m; ++j) {\n      d[i][j] = min(min(d[i-1][j] + 1,  // a deletion\n                        d[i][j-1] + 1), // an insertion\n                    d[i-1][j-1] + (a[i-1] != b[j-1])); // a substituion\n      if (i>=2 && j>=2 && a[i-2]==b[j-1] && a[i-1]==b[j-2])\n        d[i][j] = min(d[i][j], d[i-2][j-2]+1);\n      //printf(\"(%d,%d):%d:%d \",i,j,d[i][j],a[i-1]!=b[j-1]);\n    }\n    //cout << endl;\n  }\n  return d[n][m];\n}\n\nbool judge(string a, string b, int d) {\n  if (levenshtein(a,b) <= d) return 1;\n  REP(i, a.size()-1) {\n    string tmp = a;\n    swap(tmp[i], tmp[i+1]);\n    //cout << tmp << \" \" << b << \" \" << levenshtein(tmp, b) << endl;\n    if (levenshtein(tmp, b) <= d-1) return 1;\n  }\n  REP(i, b.size()-1) {\n    string tmp = b;\n    swap(tmp[i], tmp[i+1]);\n    //cout << tmp << \" \" << a << \" \" << levenshtein(tmp, a) << endl;\n    if (levenshtein(tmp, a) <= d-1) return 1;\n  }\n  \n  return 0;\n}\n\n\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    int d;\n    cin >> d;\n    string name[n];\n    REP(i, n) {\n      cin >> name[i];\n    }\n    set<pair<string, string> > se;\n    sort(name, name+n);\n    REP(i, n) {\n      REP(j, i) {\n        //cout << name[j] <<\",\" <<name[i]<< \" :  \" << levenshtein(name[j], name[i]) << endl;\n        if (judge(name[j], name[i], d))\n          se.insert(make_pair(name[j], name[i]));\n      }\n    }\n    FOR(it, se) {\n      cout << it->first << \",\" << it->second << endl;\n    }\n    cout << se.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n){\n    int d;\n    vector<string> name(n);\n    cin >> d;\n    rep(i,0,n) cin >> name[i];\n    sort(name.begin(),name.end());\n\n    function<void(const int,const string&,unordered_set<string>&)> enumerate_neighborhood=[&](int d,const string &s,unordered_set<string> &st){\n        if(d==0){\n            st.insert(s);\n            return;\n        }\n        //replace\n        {\n            string t=s;\n            rep(i,0,s.size()){\n                rep(j,0,26){\n                    t[i]='a'+j;\n                    enumerate_neighborhood(d-1,t,st);\n                }\n                t[i]=s[i];\n            }\n        }\n        //insert\n        {\n            string x;\n            rep(i,0,s.size()+1){\n                string y=s.substr(i);\n                rep(j,0,26){\n                    x.push_back('a'+j);\n                    auto t=x+y;\n                    enumerate_neighborhood(d-1,t,st);\n                    x.pop_back();\n                }\n                x+=s[i];\n            }\n        }\n        //delete\n        {\n            string x;\n            rep(i,0,s.size()){\n                string t=x+s.substr(i+1);\n                enumerate_neighborhood(d-1,t,st);\n                x+=s[i];\n            }\n        }\n        //swap adjacent\n        {\n            string t=s;\n            rep(i,0,s.size()-1){\n                swap(t[i],t[i+1]);\n                enumerate_neighborhood(d-1,t,st);\n                swap(t[i],t[i+1]);\n            }\n        }\n    };\n\n    int count=0;\n    rep(i,0,n){\n        unordered_set<string> st;\n        enumerate_neighborhood(d,name[i],st);\n        rep(j,i+1,n){\n            if(st.find(name[j])==st.end()) continue;\n            cout << name[i] << \",\" << name[j] << endl;\n            ++count;\n        }\n    }\n    cout << count << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nint calc(const string& s1,const string& s2){\n    vector<vector<int>> dp(s1.length() + 1, vector<int>(s2.length() + 1, INF));\n    \n    /* dp[i][j] := 文字列s1[0..(i-1)] から 文字列s2[0..(j-1)]の編集距離 ( 添え字0はヌル ) */\n    dp[0][0] = 0;\n    for (int i = 1; i <= s1.length();i++) dp[i][0] = i;\n    for (int j = 1; j <= s2.length(); j++) dp[0][j] = j;\n    \n    for (int i = 1; i <= s1.length(); i++) {\n        for (int j = 1; j <= s2.length(); j++) {\n            dp[i][j] = min({\n                dp[i][j - 1] + 1,\n                dp[i - 1][j] + 1,\n                dp[i - 1][j - 1] + (s1[i - 1] != s2[j - 1])\n            });\n        }\n    }\n    \n    return dp[s1.length()][s2.length()];\n}\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n,d;\n    set<pair<int,int>> s;\n    vector<string> name;\n    while(cin >> n, n){\n        cin >> d;\n        s.clear();\n        name.clear();\n        name.resize(n);\n        for(int i = 0; i < n;i++){\n            cin >> name[i];\n        }\n        sort(name.begin(),name.end());\n        for(int i = 0; i < n;i++){\n            for(int j = 0; j < n;j++){\n                if(i == j) continue;\n                int dist = calc(name[i],name[j]);\n                if(dist <= d){\n                    if(i < j){\n                        s.insert({i,j});\n                    }else{\n                        s.insert({j,i});\n                    }\n                    continue;\n                }\n                string tmp;\n                bool f = false;\n                for(int k = 0; k < name[i].length() -1;k++){\n                    for(int l = 0; l < name[i].length() - 1;l++){\n                        tmp = name[i];\n                        int cost = 1;\n                        swap(tmp[k],tmp[k+1]);\n                        if(k != l){\n                            swap(tmp[l],tmp[l+1]);\n                            cost++;\n                        }\n                        dist = calc(tmp,name[j]) + cost;\n                        if(dist <= d){\n                            if(i < j){\n                                s.insert({i,j});\n                            }else{\n                                s.insert({j,i});\n                            }\n                            f = true;\n                            break;\n                        }\n                    }\n                    if(f)break;\n                }\n            }\n        }\n        for(auto pii:s){\n            cout << name[pii.first] << \",\" << name[pii.second] << endl;\n        }\n        cout << s.size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nint n,d;\nstring s[222];\nunordered_set<string>st[222];\nbool used[222][222];\nunordered_set<string>::iterator it,it2;\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(cin>>n,n){\n    memset(used,0,sizeof(used));\n    cin>>d;\n    r(i,n)cin>>s[i];\n    sort(s,s+n);\n    r(i,n)st[i].clear();\n    r(i,n){\n      r(j,s[i].size()){\n        string t=s[i];\n        t.erase(t.begin()+j);\n        st[i].insert(t);\n      }\n      r(j,s[i].size()+1){\n        r(k,26){\n          string t=s[i];\n          t=t.substr(0,j)+(char)(k+'a')+t.substr(j);\n          st[i].insert(t);\n        }\n      }\n      r(j,s[i].size()+1){\n        r(k,26){\n          string t=s[i];\n          t[j]=(char)(k+'a');\n          st[i].insert(t);\n        }\n      }\n      r(j,s[i].size()-1){\n          string t=s[i];\n          swap(t[j],t[j+1]);\n          st[i].insert(t);\n      }\n    }\n    int ans=0;\n    if(d==1){\n      r(i,n)r(j,n)if(i!=j&&!used[i][j]){{\n        for(it=st[i].begin();it!=st[i].end();it++){\n            if(s[j]==(*it)){\n                used[i][j]=used[j][i]=1;\n                cout<<s[i]<<','<<s[j]<<endl;\n                ans++;\n                break;\n            }\n          }\n        }\n      }\n    }\n    else{\n      r(i,n)r(j,n)if(i!=j&&!used[i][j]){\n        for(it=st[i].begin();it!=st[i].end();it++){\n              if(st[j].count(*it)){\n                used[i][j]=used[j][i]=1;\n                cout<<s[i]<<','<<s[j]<<endl;\n                ans++;\n                break;\n              }\n          }\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#define INF (1<<29)\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\ntypedef pair<string,string> pss;\n\nint dist(string s,string t) {\n  int d[20][20];\n  fill(d[0],d[20],INF);\n\n  int n=s.size(),m=t.size();\n  for(int i=0;i<=n;i++)d[i][0]=i;\n  for(int i=0;i<=m;i++)d[0][i]=i;\n  \n  int sp[128],tp[128];\n  fill(sp,sp+128,-1);\n  for(int i=0;i<=n;i++){\n    fill(tp,tp+128,-1);\n    for(int j=0;j<=m;j++){\n      int cost=(s[i+1]!=t[j+1]);\n      d[i+1][j+1]=min(min(d[i][j+1],d[i+1][j])+1,d[i][j]+cost);\n      if(sp[t[j]]>=0 && tp[s[i]]>=0)\n\td[i+1][j+1]=min(d[i+1][j+1],d[i-1][j-1]+cost);\n      tp[t[j]]=j;\n    }\n    sp[s[i]]=i;\n  }\n  return d[n][m]; \n}\n\nint main(void){\n\n  int n,d;\n  while(cin >> n,n){\n    cin >> d;\n    vector<string> v(n);\n    for(int i=0;i<n;i++)cin >> v[i];\n\n    vector<pair<string,string> >res;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(dist(v[i],v[j])<=d){\n\t  res.push_back(pss(min(v[i],v[j]),max(v[i],v[j])));\n\t}\n      }\n    }\n    sort(all(res));\n    for(int i=0;i<res.size();i++)\n      cout << res[i].first << \" \" << res[i].second << endl;\n    cout << res.size() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<string,string> P;\n\nint n,d;\nint ans=0;\nset<string> mp[201][18];\nint cnt[201][201];\nvector<P> vec;\nstring str[201];\n\nvoid dfs(int v,string s,int nd,int uk=0){\n\tif(nd==0){\n\t\tmp[v][s.size()].insert(s);\n\t\tfor(int i=0;i+1<s.size();i++){\n\t\t\tswap(s[i],s[i+1]);\n\t\t\tdfs(v,s,nd+1);\n\t\t\tswap(s[i],s[i+1]);\n\t\t}\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tdfs(v,s.substr(0,i)+s.substr(i+1),nd+1);\n\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\tstring gu=\"\";\n\t\t\t\tgu+=('a'+j);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i+1),nd+1,1);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i),nd+1,1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<26;i++){\n\t\t\tstring gu=\"\";\n\t\t\tgu+=('a'+i);\n\t\t\tdfs(v,s+gu,nd+1);\n\t\t}\n\t}else if(nd==1){\n\t\tmp[v][s.size()].insert(s);\n\t}\n}\n\nvoid dfs2(int v,string s,int nd){\n\tif(nd==0){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(mp[i][s.size()].find(s)!=mp[i][s.size()].end()){\n\t\t\t\tcnt[v][i]++;\n\t\t\t\tcnt[i][v]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i+1<s.size();i++){\n\t\t\tswap(s[i],s[i+1]);\n\t\t\tdfs2(v,s,nd+1);\n\t\t\tswap(s[i],s[i+1]);\n\t\t}\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tdfs2(v,s.substr(0,i)+s.substr(i+1),nd+1);\n\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\tstring gu=\"\";\n\t\t\t\tgu+=('a'+j);\n\t\t\t\tdfs2(v,s.substr(0,i)+gu+s.substr(i+1),nd+1);\n\t\t\t\tdfs2(v,s.substr(0,i)+gu+s.substr(i),nd+1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<26;i++){\n\t\t\tstring gu=\"\";\n\t\t\tgu+=('a'+i);\n\t\t\tdfs2(v,s+gu,nd+1);\n\t\t}\n\t}else if(nd==1){\n\t\tif(d==2){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(mp[i][s.size()].find(s)!=mp[i][s.size()].end()){\n\t\t\t\t\tcnt[v][i]++;\n\t\t\t\t\tcnt[i][v]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tvec.clear();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<18;j++){\n\t\t\tmp[i][j].clear();\n\t\t}\n\t}\n\tscanf(\"%d\",&d);\n\tans=0;\n\tmemset(cnt,0,sizeof(cnt));\n\tfor(int i=0;i<n;i++){\n\t\tcin >> str[i];\n\t\tdfs(i,str[i],0);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tdfs2(i,str[i],0);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(cnt[i][j]>0){\n\t\t\t\tans++;\n\t\t\t\tvec.push_back(P(min(str[i],str[j]),max(str[i],str[j])));\n\t\t\t}\n\t\t}\n\t}\n\tsort(vec.begin(),vec.end());\n\tfor(int i=0;i<vec.size();i++){\n\t\tcout << vec[i].first << \",\" << vec[i].second << endl;\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cmath>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n\nusing namespace std;\n\nint main(){\n\tint n, d;\n\twhile(cin >> n, n){\n\t\tcin >> d;\n\t\tvector<string> name(n);\n\t\trep(i, n) cin >> name[i];\n\t\tsort(name.begin(), name.end());\n\n\t\tvector<map<string, bool> > table(n);\n\t\trep(k, n){\n\t\t\tint len = name[k].size();\n\t\t\trep(i, len){\n\t\t\t\tstring s = name[k], t;\n\t\t\t\t// 追加\n\t\t\t\trep(j, 26){\n\t\t\t\t\tt = s.substr(0, i) + (char)('a'+j) + s.substr(i);\n\t\t\t\t\ttable[k][t] = true;\n\t\t\t\t}\n\t\t\t\t// 削除\n\t\t\t\tif(i+1 <= len) t = s.substr(0, i) + s.substr(i+1);\n\t\t\t\ttable[k][t] = true;\n\t\t\t\t// 置換\n\t\t\t\trep(j, 26){\n\t\t\t\t\tt = s;\n\t\t\t\t\tt[i] = 'a'+j;\n\t\t\t\t\ttable[k][t] = true;\n\t\t\t\t}\n\t\t\t\t// 交換\n\t\t\t\tif(i+1 < len){\n\t\t\t\t\tt = s;\n\t\t\t\t\tswap(t[i], t[i+1]);\n\t\t\t\t\ttable[k][t] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\trep(i, n){\n\t\t\tfor(int j = i+1; j < n; j++){\n\t\t\t\tint dist = name[i].size()-name[j].size();\n\t\t\t\tif(abs(dist) > d) continue;\n\t\t\t\tmap<string, bool>::iterator it;\n\t\t\t\tbool ok = false;\n\t\t\t\tstring t;\n\t\t\t\tif(d == 1){\n\t\t\t\t\tt = name[j];\n\t\t\t\t\tif(table[i][t]){\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tfor(it = table[j].begin(); it != table[j].end(); it++){\n\t\t\t\t\t\tt = it->first;\n\t\t\t\t\t\tif(table[i][t]){\n\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok){\n\t\t\t\t\tcout << name[i] << ',' << name[j] << endl;\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<string,string> P;\n\nint n,d;\nint ans=0;\nset<string> mp[201][18];\nint cnt[201][201];\nvector<P> vec;\nstring str[201];\n\nvoid dfs(int v,string s,int nd,int uk=0){\n\tif(nd==0){\n\t\tmp[v][s.size()].insert(s);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(mp[i][s.size()].find(s)!=mp[i][s.size()].end()){\n\t\t\t\tcnt[v][i]++;\n\t\t\t\tcnt[i][v]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i+1<s.size();i++){\n\t\t\tswap(s[i],s[i+1]);\n\t\t\tdfs(v,s,nd+1);\n\t\t\tswap(s[i],s[i+1]);\n\t\t}\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tdfs(v,s.substr(0,i)+s.substr(i+1),nd+1);\n\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\tstring gu=\"\";\n\t\t\t\tgu+=('a'+j);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i+1),nd+1,1);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i),nd+1,1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<26;i++){\n\t\t\tstring gu=\"\";\n\t\t\tgu+=('a'+i);\n\t\t\tdfs(v,s+gu,nd+1);\n\t\t}\n\t}else if(nd==1){\n\t\tmp[v][s.size()].insert(s);\n\t\tif(d==2){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(mp[i][s.size()].find(s)!=mp[i][s.size()].end()){\n\t\t\t\t\tcnt[v][i]++;\n\t\t\t\t\tcnt[i][v]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tvec.clear();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<18;j++){\n\t\t\tmp[i][j].clear();\n\t\t}\n\t}\n\tscanf(\"%d\",&d);\n\tans=0;\n\tmemset(cnt,0,sizeof(cnt));\n\tfor(int i=0;i<n;i++){\n\t\tcin >> str[i];\n\t\tdfs(i,str[i],0);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(cnt[i][j]>0){\n\t\t\t\tans++;\n\t\t\t\tvec.push_back(P(min(str[i],str[j]),max(str[i],str[j])));\n\t\t\t}\n\t\t}\n\t}\n\tsort(vec.begin(),vec.end());\n\tfor(int i=0;i<vec.size();i++){\n\t\tcout << vec[i].first << \",\" << vec[i].second << endl;\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<map>\n#include<set>\n#include<numeric>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<climits>\n#include<cstring>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<string, string>\nconst int INF = INT_MAX;\n\nint n, d;\n\nvector<char> make_using_char(string a, string b){\n  set<char> s;\n  REP(i, a.length()) s.insert(a[i]);\n  REP(i, b.length()) s.insert(b[i]);\n  vector<char> ret;\n  for(set<char>::iterator it = s.begin(); it != s.end(); ++it) ret.push_back((*it));\n  return ret;\n}\n\nstring str_delete(string str, int p){\n  stringstream ss;\n  REP(i, str.length()) if(i != p) ss <<str[i];\n  return ss.str();\n}\n\nstring str_insert(string str, int p, char c){\n  if(p == -1) return c + str;\n  stringstream ss;\n  REP(i, str.length()){\n    ss <<str[i];\n    if(i == p) ss <<c;\n  }\n  return ss.str();\n}\n\nstring str_replace(string str, int p, char c){\n  str[p] = c;\n  return str;\n}\n\nstring str_swap(string str, int p, char pp){\n  char tmp = str[p];\n  str[p] = str[pp];\n  str[pp] = tmp;\n  return str;\n}\n\nbool check(string bef, string aft, int cnt, vector<char> &using_char){\n  if(bef == aft) return true;\n  else if (cnt >= d) return false;\n\n  bool ret = false;\n  //delete\n  REP(i, bef.length()) ret = max(ret, check(str_delete(bef, i), aft, cnt + 1, using_char));\n  //insert\n  REP(i, bef.length()) REP(j, using_char.size()) ret = max(ret, check(str_insert(bef, i, using_char[j]), aft, cnt + 1, using_char));\n  //replace\n  REP(i, bef.length()) REP(j, using_char.size()) ret = max(ret, check(str_replace(bef, i, using_char[j]), aft, cnt + 1, using_char));\n  //swap\n  REP(i, bef.length()) REP(j, bef.length()) ret = max(ret, check(str_swap(bef, i, j), aft, cnt + 1, using_char));\n\n  return ret;\n}\n\nint main(){\n  while(cin >>n && n){\n    cin >>d;\n    vector<P> ans;\n    vector<string> v(n);\n    REP(i, n) cin >>v[i];\n    sort(v.begin(), v.end());\n\n    REP(i, n){\n      FOR(j, i + 1, n){\n        vector<char> tmp = make_using_char(v[i], v[j]);\n        if(check(v[i], v[j], 0, tmp)) ans.push_back( P(v[i], v[j]) );\n      }\n    }\n    sort(ans.begin(), ans.end());\n    REP(i, (int)(ans.size())) cout <<ans[i].first <<\",\" <<ans[i].second <<endl;\n    cout <<(int)(ans.size()) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    int d;\n    cin>>d;\n    set<string> ss;\n    for(int i=0;i<n;i++){\n      string s;\n      cin>>s;\n      ss.emplace(s);\n    }\n    using P = pair<string, string>;\n    set<P> ans;\n    auto calc=[](string s){\n      int n=s.size();\n      set<string> ss;\n      for(int i=0;i<n;i++){\n\tstring t=s;\n\tt.erase(t.begin()+i);\n\tss.emplace(t);\n      }\n      for(int i=0;i<n;i++){\n\tfor(char c='a';c<='z';c++){\n\t  string t=s;\n\t  t[i]=c;\n\t  ss.emplace(t);\n\t}\n      }\n      for(int i=0;i<n-1;i++){\n\tswap(s[i],s[i+1]);\n\tss.emplace(s);\n\tswap(s[i],s[i+1]);\n      }\n      return ss;\n    };\n    map<string,vector<string> > ms;\n    for(string s:ss){\n      if(d==1){\n\tmap<string,int> dp;\n\tqueue<string> q;\n\tdp[s]=0;\n\tq.emplace(s);\n\twhile(!q.empty()){\n\t  string t=q.front();q.pop();\n\t  if(dp[t]>=d) continue;\n\t  auto xs=calc(t);\n\t  for(string x:xs){\n\t    if(dp.count(x)) continue;\n\t    dp[x]=dp[t]+1;\n\t    q.emplace(x);\n\t  }\n\t}\n\tfor(auto p:dp){\n\t  if(p.first==s||p.second>d) continue;\n\t  if(ss.count(p.first)) ans.emplace(minmax({s,p.first}));\n\t}\n      }\n      if(d==2){\n\tmap<string,int> dp;\n\tqueue<string> q;\n\tdp[s]=0;\n\tq.emplace(s);\n\twhile(!q.empty()){\n\t  string t=q.front();q.pop();\n\t  if(dp[t]>=1) continue;\n\t  auto xs=calc(t);\n\t  for(string x:xs){\n\t    if(dp.count(x)) continue;\n\t    dp[x]=dp[t]+1;\n\t    q.emplace(x);\n\t  }\n\t}\n\tfor(auto p:dp){\n\t  if(p.second==1){\n\t    for(auto x:ms[p.first])\n\t      ans.emplace(minmax({s,x}));\n\t    \n\t    ms[p.first].emplace_back(s);\n\t  }\n\t  if(p.first==s||p.second>d) continue;\n\t  if(ss.count(p.first)) ans.emplace(minmax({s,p.first}));\n\t}\n      }\n    }\n    for(P p:ans)\n      cout<<p.first<<\",\"<<p.second<<endl;\n    cout<<ans.size()<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n \null B=10000007;\nint n,d,len;\nchar s[200][17];\null t[200];\nint G[200][200];\nbool f[200][200];\nmap<ull,bool> mp[200];\nvector<ull> L[200];\n\nstruct data{\n  int fi,se;\n  bool operator < (const data &d)const{\n    return (G[fi][d.fi]!=0?G[fi][d.fi]<0:G[se][d.se]<0);\n  }\n};\n \nvector< data > v;\n \null Deleting(int x,char* ch){\n  ull res=0;\n  for(int i=0;i<len;i++)\n    if(i!=x)res=res*B+ch[i];\n  return res;\n}\n \null Inserting(int x,char y,char* ch){\n  ull res=0;\n  for(int i=0;i<=len;i++){\n    if(i==x)res=res*B+y;\n    if(i<len)res=res*B+ch[i];\n  }\n  return res;\n}\n \null Replacing(int x,char y,char* ch){\n  ull res=0;\n  for(int i=0;i<len;i++){\n    if(i==x)res=res*B+y;\n    else res=res*B+ch[i];\n  }\n  return res;\n}\n \null Swapping(int x,char* ch){\n  ull res=0;\n  for(int i=0;i<len;i++){\n    if(i==x)res=res*B+ch[i+1];\n    else if(i==x+1)res=res*B+ch[x];\n    else res=res*B+ch[i];\n  }\n  return res;\n}\n \nvoid init(){\n  for(int i=0;i<200;i++){\n    mp[i].clear();\n    L[i].clear();\n  }\n  v.clear();\n  memset(f,false,sizeof(f));\n}\n \nint main(){\n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    init();\n    scanf(\"%d\",&d);\n \n    for(int i=0;i<n;i++){\n      scanf(\"%s\",s[i]);\n      len=strlen(s[i]);\n \n      t[i]=Swapping(-10,s[i]);\n      ull key;\n      for(int j=0;j<len;j++){\n        key=Deleting(j,s[i]);\n        mp[i][key]=true;\n        L[i].push_back(key);\n      }\n       \n      for(int j=0;j<=len;j++){\n        for(char k='a';k<='z';k++){\n          key=Inserting(j,k,s[i]);\n          mp[i][key]=true;\n          L[i].push_back(key);\n        }\n      }\n       \n      for(int j=0;j<len;j++){\n        for(char k='a';k<='z';k++){\n          if(s[i][j]!=k){\n            key=Replacing(j,k,s[i]);\n            mp[i][key]=true;\n            L[i].push_back(key);\n          }\n        }\n      }\n       \n      for(int j=0;j+1<len;j++){\n        key=Swapping(j,s[i]);\n        mp[i][key]=true;\n        L[i].push_back(key);\n      }\n    }\n \n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n        G[i][j]=strcmp(s[i],s[j]);\n     \n    for(int i=1;i<n;i++){\n      for(int j=0;j<i;j++){\n        int a=i,b=j;\n        if(G[a][b]>0)swap(a,b);\n        if( mp[a].count(t[b]) && !f[a][b] ){\n          v.push_back( (data){a,b} );\n          f[a][b]=true;\n        }\n        if(d==1)continue;\n        vector<ull> :: iterator it;\n        for(it=L[b].begin();it!=L[b].end();it++){\n          if( mp[a].count(*it) && !f[a][b] ){\n            v.push_back( (data){a,b} );\n            f[a][b]=true;\n          }\n        }\n      }\n    }\n    sort( v.begin() , v.end() );\n    for(int i=0;i<(int)v.size();i++){\n      printf(\"%s,%s\\n\",s[v[i].fi],s[v[i].se]);\n    }\n    printf(\"%d\\n\",(int)v.size());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<utility>\n#include<string>\n\nusing namespace std;\n\nbool check(const string &s1,const string &s2,int d){\n  if(s1==s2)return true;\n  if(d==1){\n    if(s1.empty()&&s2.size()==1||s2.empty()&&s1.size()==1)return true;\n    int ld=abs(int(s1.size())-(int)(s2.size()));\n    if(ld>1)return false;\n    int h1=0,h2=0;\n    int t1=s1.size()-1,t2=s2.size()-1;\n    while(s1[h1]==s2[h2]){\n      h1++;\n      h2++;\n    }\n    while(s1[t1]==s2[t2]){\n      t1--;\n      t2--;\n    }\n    if(ld==1){\n      return h1==t1||h2==t2;\n    }else{\n      return h1==t1||(h1+1==t1&&s1[h1]==s2[t2]&&s1[t1]==s2[h2]);\n    }\n  }else{\n    for(int i=0;i<s1.size()+1;i++){\n      string ns=s1;\n      ns.insert(ns.begin()+i,' ');\n      for(char c='a';c<='z';c++){\n\tns[i]=c;\n\tif(check(ns,s2,1))return true;\n      }\n    }\n    for(int i=0;i<s1.size();i++){\n      if(check(s1.substr(0,i)+s1.substr(i+1),s2,1))return true;\n      string ns=s1;\n      for(char c='a';c<='z';c++){\n\tns[i]=c;\n\tif(check(ns,s2,1))return true;\n      }\n    }\n    string ns=s1;\n    for(int i=0;i+1<s1.size();i++){\n      swap(ns[i],ns[i+1]);\n      if(check(ns,s2,1))return true;\n      swap(ns[i],ns[i+1]); \n    }\n    return false;\n  }\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    int d;\n    cin>>d;\n    string names[223];\n    for(int i=0;i<n;i++){\n      cin>>names[i];\n    }\n    sort(names,names+n);\n    vector<pair<string,string> > ans;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(check(names[i],names[j],d)){\n\t  ans.emplace_back(names[i],names[j]);\n\t}\n      }\n    }\n    for(auto e:ans){\n      cout<<e.first<<','<<e.second<<endl;\n    }\n    cout<<ans.size()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nvoid transforms(const string& s1,set<string>& s){\n    string tmp;\n    for(int i = 0; i < s1.length();i++){\n        tmp = s1;\n        tmp.erase(tmp.begin() + i);\n        s.insert(tmp);\n    }\n    for(int i = 0; i <=s1.length();i++){\n        for(int j = 0; j < 26;j++){\n            tmp = s1;\n            char c = 'a' + j;\n            tmp.insert(i,string(1,c));\n            s.insert(tmp);\n        }\n    }\n    for(int i = 0; i < s1.length();i++){\n        for(int j = 0; j < 26;j++){\n            tmp = s1;\n            char c = 'a' + j;\n            tmp.replace(i,1,string(1,c));\n            s.insert(tmp);\n        }\n    }\n    for(int i = 0; i < s1.length() - 1;i++){\n        tmp = s1;\n        swap(tmp[i],tmp[i+1]);\n        s.insert(tmp);\n    }\n}\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n,d;\n    vector<pii> res;\n    vector<string> name;\n    while(cin >> n, n){\n        cin >> d;\n        res.clear();\n        name.clear();\n        name.resize(n);\n        for(int i = 0; i < n;i++){\n            cin >> name[i];\n        }\n        sort(name.begin(),name.end());\n        if(d == 1){\n            set<string> s;\n            for(int i = 0; i < n - 1;i++){\n                s.clear();\n                transforms(name[i],s);\n                for(int j = i + 1; j < n;j++){\n                    if(s.find(name[j]) != s.end()){\n                        res.push_back({i,j});\n                    }\n                }\n            }\n        }else{\n            set<string> s1;\n            set<string> s2;\n            for(int i = 0; i < n-1;i++){\n                for(int j = i + 1; j < n;j++){\n                    s1.clear(); s2.clear();\n                    transforms(name[i],s1);\n                    transforms(name[j],s2);\n                    for(auto tmp_s:s1){\n                        if(s2.find(tmp_s) != s2.end()){\n                            res.push_back({i,j});\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        \n        for(auto ans:res){\n            cout << name[ans.first] << \",\" <<name[ans.second]<<endl;\n        }\n        cout << res.size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\nusing ps = pair<string,string>;\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        int d;\n        cin >>d;\n        vector<string> name(n);\n        rep(i,n) cin >>name[i];\n        sort(all(name));\n\n        vector<set<string>> v(n);\n        rep(i,n){\n            string s = name[i];\n            int S = s.size();\n            string t;\n\n            // delete\n            rep(j,S){\n                t = s;\n                t.erase(t.begin()+j);\n                v[i].insert(t);\n            }\n\n            // insert\n            rep(j,S+1){\n                rep(k,26){\n                    char c = 'a'+k;\n                    t = s;\n                    t.insert(j,string(1,c));\n                    v[i].insert(t);\n                }\n            }\n\n            // replace\n            rep(j,S){\n                rep(k,26){\n                    char c = 'a'+k;\n                    t = s;\n                    if(t[j] != c){\n                        t[j] = c;\n                        v[i].insert(t);\n                    }\n                }\n            }\n\n            // swap\n            rep(j,S)for(int k=j+1; k<S; ++k){\n                t = s;\n                if(t[j]!=t[k]){\n                    swap(t[j],t[k]);\n                    v[i].insert(t);\n                }\n            }\n        }\n\n        map<string,vector<int>> idx;\n        rep(i,n){\n            for(string ss:v[i]) idx[ss].pb(i);\n        }\n\n        // dbg(name);\n\n        set<pi> ans;\n        // d==1\n        rep(i,n)for(int j=i+1; j<n; ++j){\n            if(v[i].count(name[j])) ans.insert({i,j});\n        }\n        if(d==2){\n            for(const auto p:idx){\n                vector<int> tt = p.se;\n                int sz = tt.size();\n\n                rep(i,sz)rep(j,i) ans.insert({tt[j],tt[i]});\n            }\n        }\n\n        // for(pi p:ans) dbg(p);\n        for(pi p:ans) cout << name[p.fi] << \",\" << name[p.se] << \"\\n\";\n        cout << ans.size() << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nint damerau_levenshtein_distance(const string &a,const string &b,const int alphabet_size){\n    map<int,int> da;\n    map<int,map<int,int>> d;\n    int maxdist=a.size()+b.size();\n    d[-1][-1]=maxdist;\n    for(int i=0; i<=a.size(); ++i){\n        d[i][-1]=maxdist;\n        d[i][0]=i;\n    }\n    for(int i=0; i<=b.size(); ++i){\n        d[-1][i]=maxdist;\n        d[0][i]=i;\n    }\n    for(int i=1; i<=a.size(); ++i){\n        int db=0;\n        for(int j=1; j<=b.size(); ++j){\n            int k=da[b[j-1]],l=db,cost;\n            if(a[i-1]==b[j-1]){\n                cost=0;\n                db=j;\n            }else cost=1;\n            d[i][j]=min({d[i-1][j-1]+cost,d[i][j-1]+1,d[i-1][j]+1,d[k-1][l-1]+(i-k-1)+1+(j-l-1)});\n        }\n        da[a[i-1]]=i;\n    }\n    return d[a.size()][b.size()];\n}\n\nvoid solve(int n){\n    int d;\n    vector<string> name(n);\n    cin >> d;\n    rep(i,0,n) cin >> name[i];\n    sort(name.begin(),name.end());\n\n    int count=0;\n    rep(i,0,n){\n        rep(j,i+1,n){\n            if(damerau_levenshtein_distance(name[i],name[j],26)>d) continue;\n            ++count;\n            cout << name[i] << \",\" << name[j] << endl;\n        }\n    }\n    cout << count << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 201\ntypedef pair<string,string> P;\n\nstruct Trie{\n  bool l;\n  Trie *next[26];\n  \n  Trie(){\n    l = false;\n    fill(next,next+26,(Trie *)0);\n  }\n  \n  int c(char ch){\n    if(islower(ch)){\n      return ch-'a';\n    }\n    return -1;\n  }\n  \n  void insert(string &s){\n    Trie *t = this;\n    for(int i = 0 ; i < (int)s.size() ; i++){\n      int v = c(s[i]);\n      if(!t->next[v]){\n        t->next[v] = new Trie;\n      }\n      t = t->next[v];\n    }\n    t->l = true;\n  }\n  \n  bool find(string &s){\n    Trie *t = this;\n    for(int i = 0 ; i < (int)s.size() ; i++){\n      int v = c(s[i]);\n      if(!t->next[v]){ return false; }\n      t = t->next[v];\n    }\n    return t->l;\n  }\n}; \n\nint N,D,idx;\nstring s[MAX];\nmap<int,set<string> > mp;\nvector<P> vec;\n \nvoid dfs(string now,int step){\n  if(step == 1){\n    mp[idx].insert(now);\n    return;\n  }\n  \n  int len = now.size();\n  // delete\n  for(int i = 0 ; i < len ; i++){\n    string tmp = now;\n    tmp.erase(tmp.begin()+i);\n    dfs(tmp,step+1);\n  }\n \n  // swap\n  for(int i = 0 ; i < len-1 ; i++){\n    swap(now[i],now[i+1]);\n    dfs(now,step+1);\n    swap(now[i],now[i+1]);\n  }\n\n  // insert\n  for(char ch = 'a' ; ch <= 'z' ; ch++){\n    for(int j = 0 ; j < len+1 ; j++){\n      string tmp = now;\n      tmp = tmp.substr(0,j) + ch + tmp.substr(j);\n      dfs(tmp,step+1);\n    }\n  }\n \n  // replace\n  for(char ch = 'a' ; ch <= 'z' ; ch++){\n    for(int j = 0 ; j < len ; j++){\n      char c = now[j];\n      now[j] = ch;\n      dfs(now,step+1);\n      now[j] = c;\n    }\n  }\n}\n\nvoid init(){\n  mp.clear();\n  vec.clear();\n}\n\nint main(){\n  while(cin >> N, N){\n    cin >> D;\n    init();\n    for(int i = 0 ; i < N ; i++){\n      cin >> s[i];\n    }\n    for(int i = 0 ; i < N ; i++){\n      idx = i;\n      dfs(s[i],0);\n    }\n\n    vector<string> v[MAX];\n    for(int i = 0 ; i < N ; i++){\n      set<string> st = mp[i];\n      set<string>::iterator it;\n      for(it = st.begin() ; it != st.end() ; ++it){\n        v[i].push_back(*it);\n      }\n    }\n    Trie tries[MAX];\n    for(int i = 0 ; i < N ; i++){\n      for(int j = 0 ; j < (int)v[i].size() ; j++){\n        tries[i].insert(v[i][j]);\n      }\n    }\n    if(D == 1){\n      for(int i = 0 ; i < N ; i++){\n        for(int j = i+1 ; j < N ; j++){\n          if(tries[i].find(s[j])){\n            vec.push_back(P(s[i],s[j]));\n          }\n        }\n      }\n    }else{\n      for(int i = 0 ; i < N ; i++){\n        for(int j = i+1 ; j < N ; j++){\n          vector<string>::iterator it;\n          for(it = v[i].begin() ; it != v[i].end() ; ++it){\n            if(tries[j].find(*it)){\n              vec.push_back(P(s[i],s[j]));\n              break;\n            }\n          }\n        }\n      }\n    }\n    int len = vec.size();\n    for(int i = 0 ; i < len ; i++){\n      if(vec[i].first > vec[i].second){\n        swap(vec[i].first,vec[i].second);\n      }\n    }\n    sort(vec.begin(),vec.end());\n    for(int i = 0 ; i < len ; i++){\n      cout << vec[i].first << \",\" << vec[i].second << endl;\n    }\n    cout << len << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define FOR(it,o)  for(__typeof((o).begin()) it =(o).begin();it != (o).end();it++)\n#define pb         push_back\n#define mp         make_pair\n\n\ntypedef unsigned long long           ull;\ntypedef pair<string,string> pss;\ntypedef vector<pss>         vpss;\n\nconst ull tmp = 10007;\n\null calchash(string &in){\n  ull ret= 0;\n  rep(i,in.size()){\n    ret=ret*tmp + in[i];\n  }\n  return ret;\n}\n\n\nbool isok[200][200];\nvoid ed1(vector<string>&in,set<ull> *S){\n  rep(i,in.size()){\n    REP(j,i+1,in.size()){\n      if (S[j].find(calchash(in[i])) != S[j].end()){\n\tisok[i][j] = true;\n      }\n    }    \n  }\n}\n\t \nvoid ed2(vector<string> &in,set<ull> *S){\n  rep(i,in.size()){\n    REP(j,i+1,in.size()){\n      if (isok[i][j])continue;\n      FOR(it,S[i]){\n\tif (S[j].find(*it) != S[j].end()){\n\t  isok[i][j]=true;\n\t  break;\n\t}\n      }\n    }\n  }\n}\n\nvoid del_string(string &in,set<ull>&S){\n  rep(i,in.size()){\n    string tmp = in;\n    tmp.erase(tmp.begin()+i);\n    S.insert(calchash(tmp));\n  }\n}\n\nvoid insert_string(string &in,set<ull>&S){\n  rep(i,in.size()){\n    rep(j,26){\n      string tmp=in.substr(0,i);\n      tmp+=string(1,'a'+j);\n      tmp+=in.substr(i);\n      S.insert(calchash(tmp));\n    }\n  }\n}\n\nvoid replace_string(string &in,set<ull>&S){\n  rep(i,in.size()){\n    char tmp = in[i];\n    rep(j,26){\n      in[i]='a'+j;\n      S.insert(calchash(in));\n    }\n    in[i]=tmp;\n  }\n}\n\nvoid swap_string(string&in,set<ull>&S){\n  rep(i,(int)in.size()-1){\n    swap(in[i],in[i+1]);\n    S.insert(calchash(in));\n    swap(in[i],in[i+1]);\n  }\n}\n\nvoid make_string(vector<string>& in,set<ull> *S){\n  rep(i,in.size()){\n    del_string(in[i],S[i]);\n    insert_string(in[i],S[i]);\n    replace_string(in[i],S[i]);\n    swap_string(in[i],S[i]);\n  }\n}\n\nvoid solve(vector<string>in,set<ull>*S,int d){\n  int n=in.size();\n  make_string(in,S);\n  ed1(in,S);\n  if (d==2)ed2(in,S);\n  int cnt=0;\n  rep(i,n){\n    rep(j,n)if (isok[i][j])cnt++,cout<<in[i]<<\",\"<<in[j]<<endl;\n  }\n  cout << cnt << endl;\n}\n\nvoid test(){\n\n}\n\nmain(){\n  test();\n  int n,d;\n  while(cin>>n>>d && n){\n    vector<string> in;\n    rep(i,n)rep(j,n)isok[i][j]=false;\n    set<ull> S[n];\n    rep(i,n){\n      string tmp;\n      cin>>tmp;\n      in.pb(tmp);\n    }\n    sort(ALL(in));\n    rep(i,in.size())S[i].insert(calchash(in[i]));\n    solve(in,S,d);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n \null B=10000007;\nint n,d,len;\nchar s[200][17];\null t[200];\nint G[200][200];\nbool f[200][200];\nmap<ull,bool> mp[200];\n \nstruct data{\n  int fi,se;\n  bool operator < (const data &d)const{\n    return (G[fi][d.fi]!=0?G[fi][d.fi]<0:G[se][d.se]<0);\n  }\n};\n \nvector< data > v;\n \null Deleting(int x,char* ch){\n  ull res=0;\n  for(int i=0;i<len;i++)\n    if(i!=x)res=res*B+ch[i];\n  return res;\n}\n \null Inserting(int x,char y,char* ch){\n  ull res=0;\n  for(int i=0;i<=len;i++){\n    if(i==x)res=res*B+y;\n    if(i<len)res=res*B+ch[i];\n  }\n  return res;\n}\n \null Replacing(int x,char y,char* ch){\n  ull res=0;\n  for(int i=0;i<len;i++){\n    if(i==x)res=res*B+y;\n    else res=res*B+ch[i];\n  }\n  return res;\n}\n \null Swapping(int x,char* ch){\n  ull res=0;\n  for(int i=0;i<len;i++){\n    if(i==x)res=res*B+ch[i+1];\n    else if(i==x+1)res=res*B+ch[x];\n    else res=res*B+ch[i];\n  }\n  return res;\n}\n \nvoid init(){\n  for(int i=0;i<200;i++){\n    mp[i].clear();\n  }\n  v.clear();\n  memset(f,false,sizeof(f));\n}\n \nint main(){\n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    init();\n    scanf(\"%d\",&d);\n \n    for(int i=0;i<n;i++){\n      scanf(\"%s\",s[i]);\n      len=strlen(s[i]);\n \n      t[i]=Swapping(-10,s[i]);\n       \n      for(int j=0;j<len;j++){\n        mp[i][Deleting(j,s[i])]=true;\n      }\n       \n      for(int j=0;j<=len;j++){\n        for(char k='a';k<='z';k++){\n          mp[i][Inserting(j,k,s[i])]=true;\n        }\n      }\n       \n      for(int j=0;j<len;j++){\n        for(char k='a';k<='z';k++){\n          if(s[i][j]!=k){\n            mp[i][Replacing(j,k,s[i])]=true;\n          }\n        }\n      }\n       \n      for(int j=0;j+1<len;j++){\n        mp[i][Swapping(j,s[i])]=true;\n      }\n    }\n \n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n        G[i][j]=strcmp(s[i],s[j]);\n     \n    for(int i=1;i<n;i++){\n      for(int j=0;j<i;j++){\n        int a=i,b=j;\n        if(G[a][b]>0)swap(a,b);\n        if( mp[a].count(t[b]) && !f[a][b] ){\n          v.push_back( (data){a,b} );\n          f[a][b]=true;\n        }\n        if(d==1)continue;\n        map<ull,bool> :: iterator it;\n        for(it=mp[b].begin();it!=mp[b].end();it++){\n          if( mp[a].count(it->first) && !f[a][b] ){\n            v.push_back( (data){a,b} );\n            f[a][b]=true;\n          }\n        }\n      }\n    }\n    sort( v.begin() , v.end() );\n    for(int i=0;i<(int)v.size();i++){\n      printf(\"%s,%s\\n\",s[v[i].fi],s[v[i].se]);\n    }\n    printf(\"%d\\n\",(int)v.size());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<iomanip>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#define int long long\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define shosu(x) fixed<<setprecision(x)\n#define all(in) in.begin(),in.end()\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\nconst double EPS=1e-5;\nconst int inf=1e10;\n\nsigned main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tint d;\n\t\tcin>>d;\n\t\tvs in(n);\n\t\trep(i,n)cin>>in[i];\n\t\tsort(all(in));\n\t\tint co=0;\n\t\trep(x,n)loop(y,x+1,n){\n\t\t\tint n1=in[x].size();\n\t\t\tint n2=in[y].size();\n\t\t\tvvi dp(n1+1,vi(n2+1,inf));\n\t\t\tdp[0][0]=0;\n\t\t\trep(i,n1+1)rep(j,n2+1){\n\t\t\t\tif(i&&j){\n\t\t\t\t\trep(l,i-1)rep(w,j-1)if(in[x][i-1]==in[y][w]&&in[x][l]==in[y][j-1]){\n\t\t\t\t\t\tdp[i][j]=min(dp[i][j],dp[l][w]+i-l-2+j-w-2+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i<n1&&j<n2)dp[i+1][j+1]=min(dp[i+1][j+1],dp[i][j]+(in[x][i]!=in[y][j]));\n\t\t\t\tif(i<n1&&j<n2)dp[i+1][j+1]=min(dp[i+1][j+1],dp[i][j]+1);\n\t\t\t\tif(i<n1)dp[i+1][j]=min(dp[i+1][j],dp[i][j]+1);\n\t\t\t\tif(j<n2)dp[i][j+1]=min(dp[i][j+1],dp[i][j]+1);\n\t\t\t}\n\t\t\t// rep(i,n1+1){rep(j,n2+1)cout<<\" \"<<dp[i][j];cout<<endl;}\n\t\t\tif(dp[n1][n2]<=d){\n\t\t\t\tco++;\n\t\t\t\tcout<<in[x]<<\",\"<<in[y]<<endl;\n\t\t\t}\n\t\t}\n\t\tcout<<co<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n \null B=10000007;\nint n,d,len;\nchar s[200][15];\null t[200];\nint G[200][200];\nbool f[200][200];\nmap<ull,bool> mp[200];\n \nstruct data{\n  int fi,se;\n  bool operator < (const data &d)const{\n    return (G[fi][d.fi]!=0?G[fi][d.fi]<0:G[se][d.se]<0);\n  }\n};\n \nvector< data > v;\n \null Deleting(int x,char* ch){\n  ull res=0;\n  for(int i=0;i<len;i++)\n    if(i!=x)res=res*B+ch[i];\n  return res;\n}\n \null Inserting(int x,char y,char* ch){\n  ull res=0;\n  for(int i=0;i<=len;i++){\n    if(i==x)res=res*B+y;\n    if(i<len)res=res*B+ch[i];\n  }\n  return res;\n}\n \null Replacing(int x,char y,char* ch){\n  ull res=0;\n  for(int i=0;i<len;i++){\n    if(i==x)res=res*B+y;\n    else res=res*B+ch[i];\n  }\n  return res;\n}\n \null Swapping(int x,char* ch){\n  ull res=0;\n  for(int i=0;i<len;i++){\n    if(i==x)res=res*B+ch[i+1];\n    else if(i==x+1)res=res*B+ch[x];\n    else res=res*B+ch[i];\n  }\n  return res;\n}\n \nvoid init(){\n  for(int i=0;i<200;i++){\n    mp[i].clear();\n  }\n  v.clear();\n  memset(f,false,sizeof(f));\n}\n \nint main(){\n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    init();\n    scanf(\"%d\",&d);\n \n    for(int i=0;i<n;i++){\n      scanf(\"%s\",s[i]);\n      len=strlen(s[i]);\n \n      t[i]=Swapping(-10,s[i]);\n       \n      for(int j=0;j<len;j++){\n        mp[i][Deleting(j,s[i])]=true;\n      }\n       \n      for(int j=0;j<=len;j++){\n        for(char k='a';k<='z';k++){\n          mp[i][Inserting(j,k,s[i])]=true;\n        }\n      }\n       \n      for(int j=0;j<len;j++){\n        for(char k='a';k<='z';k++){\n          if(s[i][j]!=k){\n            mp[i][Replacing(j,k,s[i])]=true;\n          }\n        }\n      }\n       \n      for(int j=0;j+1<len;j++){\n        mp[i][Swapping(j,s[i])]=true;\n      }\n    }\n \n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n        G[i][j]=strcmp(s[i],s[j]);\n     \n    for(int i=1;i<n;i++){\n      for(int j=0;j<i;j++){\n        int a=i,b=j;\n        if(G[a][b]>0)swap(a,b);\n        if( mp[a].count(t[b]) && !f[a][b] ){\n          v.push_back( (data){a,b} );\n          f[a][b]=true;\n        }\n        if(d==1)continue;\n        map<ull,bool> :: iterator it;\n        for(it=mp[b].begin();it!=mp[b].end();it++){\n          if( mp[a].count(it->first) && !f[a][b] ){\n            v.push_back( (data){a,b} );\n            f[a][b]=true;\n          }\n        }\n      }\n    }\n    sort( v.begin() , v.end() );\n    for(int i=0;i<(int)v.size();i++){\n      printf(\"%s,%s\\n\",s[v[i].fi],s[v[i].se]);\n    }\n    printf(\"%d\\n\",(int)v.size());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 334\ntypedef pair<string,string> P;\ntypedef pair<string,int> P2;\n\nint N,D,idx;\nstring s[MAX];\nmap<int,set<string> > mp;\nvector<P> vec;\n\nvoid dfs(string now,int step){\n  if(step == 1){\n    mp[idx].insert(now);\n    return;\n  }\n\n  int len = now.size();\n  // delete\n  for(int i = 0 ; i < len ; i++){\n    string tmp = now;\n    tmp.erase(tmp.begin()+i);\n    dfs(tmp,step+1);\n  }\n\n  // swap\n  for(int i = 0 ; i < len-1 ; i++){\n    for(int j = i+1 ; j < len ; j++){\n      swap(now[i],now[j]);\n      dfs(now,step+1);\n      swap(now[i],now[j]);\n    }\n  }\n  \n  // insert\n  for(char ch = 'a' ; ch <= 'z' ; ch++){\n    for(int j = 0 ; j < len+1 ; j++){\n      string tmp = now;\n      tmp = tmp.substr(0,j) + ch + tmp.substr(j);\n      dfs(tmp,step+1);\n    }\n  }\n\n  // replace\n  for(char ch = 'a' ; ch <= 'z' ; ch++){\n    for(int j = 0 ; j < len ; j++){\n      string tmp = now; tmp[j] = ch;\n      dfs(tmp,step+1);\n    }\n  }\n}\n\nvoid init(){\n  mp.clear();\n  vec.clear();\n}\n\nint main(){\n  while(cin >> N, N){\n    cin >> D;\n    init();\n    for(int i = 0 ; i < N ; i++){\n      cin >> s[i];\n    }\n    for(int i = 0 ; i < N ; i++){\n      idx = i;\n      dfs(s[i],0);\n    }\n    \n    if(D == 1){\n      for(int i = 0 ; i < N ; i++){\n\tset<string> st = mp[i];\n\tfor(int j=i+1; j<N; j++) {\n\t  if(st.count(s[j])){\n\t    vec.push_back(P(s[i],s[j]));\n\t  }\n\t}\n      }\n    }else{\n      for(int i = 0 ; i < N ; i++){\n\tfor(int j = i+1 ; j < N ; j++){\n\t  set<string> st = mp[i],st2 = mp[j];\n\t  set<string>::iterator it;\n\t  for(it = st.begin() ; it != st.end() ; ++it){\n\t    if(st2.find(*it) != st2.end()){\n\t      vec.push_back(P(s[i],s[j]));\n\t      break;\n\t    }\n\t  }\n\t}\n      }\n    }\n    int len = vec.size();\n    for(int i = 0 ; i < len ; i++){\n      if(vec[i].first > vec[i].second){\n\tswap(vec[i].first,vec[i].second);\n      }\n    }\n    sort(vec.begin(),vec.end());\n    for(int i = 0 ; i < len ; i++){\n      cout << vec[i].first << \",\" << vec[i].second << endl;\n    }\n    cout << len << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<string,string> P;\n\nint n,d;\nint ans=0;\nset<string> mp[201][18];\nint cnt[201][201];\nvector<P> vec;\nstring str[201];\n\nvoid dfs(int v,string s,int nd,int uk=0){\n\tif(nd==0){\n\t\tmp[v][s.size()].insert(s);\n\t\tfor(int i=0;i+1<s.size();i++){\n\t\t\tswap(s[i],s[i+1]);\n\t\t\tdfs(v,s,nd+1);\n\t\t\tswap(s[i],s[i+1]);\n\t\t}\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tdfs(v,s.substr(0,i)+s.substr(i+1),nd+1);\n\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\tstring gu=\"\";\n\t\t\t\tgu+=('a'+j);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i+1),nd+1,1);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i),nd+1,1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<26;i++){\n\t\t\tstring gu=\"\";\n\t\t\tgu+=('a'+i);\n\t\t\tdfs(v,s+gu,nd+1);\n\t\t}\n\t}else if(nd==1){\n\t\tmp[v][s.size()].insert(s);\n\t}\n}\n\nvoid dfs2(int v,string s,int nd){\n\tif(nd==0){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(mp[i][s.size()].find(s)!=mp[i].end()){\n\t\t\t\tcnt[v][i]++;\n\t\t\t\tcnt[i][v]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i+1<s.size();i++){\n\t\t\tswap(s[i],s[i+1]);\n\t\t\tdfs2(v,s,nd+1);\n\t\t\tswap(s[i],s[i+1]);\n\t\t}\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tdfs2(v,s.substr(0,i)+s.substr(i+1),nd+1);\n\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\tstring gu=\"\";\n\t\t\t\tgu+=('a'+j);\n\t\t\t\tdfs2(v,s.substr(0,i)+gu+s.substr(i+1),nd+1);\n\t\t\t\tdfs2(v,s.substr(0,i)+gu+s.substr(i),nd+1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<26;i++){\n\t\t\tstring gu=\"\";\n\t\t\tgu+=('a'+i);\n\t\t\tdfs2(v,s+gu,nd+1);\n\t\t}\n\t}else if(nd==1){\n\t\tif(d==2){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(mp[i][s.size()].find(s)!=mp[i].end()){\n\t\t\t\t\tcnt[v][i]++;\n\t\t\t\t\tcnt[i][v]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tvec.clear();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<18;j++){\n\t\t\tmp[i][j].clear();\n\t\t}\n\t}\n\tscanf(\"%d\",&d);\n\tans=0;\n\tmemset(cnt,0,sizeof(cnt));\n\tfor(int i=0;i<n;i++){\n\t\tcin >> str[i];\n\t\tdfs(i,str[i],0);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tdfs2(i,str[i],0);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(cnt[i][j]>0){\n\t\t\t\tans++;\n\t\t\t\tvec.push_back(P(min(str[i],str[j]),max(str[i],str[j])));\n\t\t\t}\n\t\t}\n\t}\n\tsort(vec.begin(),vec.end());\n\tfor(int i=0;i<vec.size();i++){\n\t\tcout << vec[i].first << \",\" << vec[i].second << endl;\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\n\nint N, D;\nvector<string> names;\n//\n//ll to_int(string s){\n//    const int MOD = 1000000009;\n//    ll res = 0;\n//    for(auto c: s){\n//        res = (res*26 + (c - 'a')) % MOD;\n//    }\n//    return res;\n//}\n\nvoid solve(){\n    sort(names.begin(), names.end());\n    \n    map<string, set<int>> mp;\n    for(int ni=0; ni<N; ni++){\n        string name = names[ni];\n        int L = name.size();\n        \n        //delete\n        for(int i=0; i<L; i++){\n            string t = name;\n            t.erase(t.begin()+i);\n            mp[t].insert(ni);\n        }\n        //insert\n        for(int i=0; i<=L; i++){\n            for(char c='a'; c<='z'; c++){\n                string t = name;\n                t.insert(t.begin()+i, c);\n                mp[t].insert(ni);\n            }\n        }\n        //replace\n        for(int i=0; i<L; i++){\n            for(char c='a'; c<='z'; c++){\n                string t = name;\n                t[i] = c;\n                mp[t].insert(ni);\n            }\n        }\n        //swap\n        for(int i=0; i<L-1; i++){\n            string t = name;\n            swap(t[i], t[i+1]);\n            mp[t].insert(ni);\n        }\n    }\n    if(D == 1){\n        int cnt = 0;\n        for(int ni=0; ni<N; ni++){\n            string name = names[ni];\n            if(mp[name].size() > 1){\n                for(auto v: mp[name]){\n                    if(v <= ni) continue;\n                    cout << name << \",\" << names[v] << endl;\n                    cnt++;\n                }\n            }\n        }\n        cout << cnt << endl;\n    }\n    if(D == 2){\n        set<pair<int, int>> s;\n        for(auto v: mp) if(v.second.size() > 1){\n            vector<int> vec;\n            for(auto vv: v.second) vec.push_back(vv);\n            for(int i=0; i<vec.size(); i++){\n                for(int j=i+1; j<vec.size(); j++){\n                    s.insert(make_pair(vec[i], vec[j]));\n                }\n            }\n        }\n        for(auto v: s){\n            cout << names[v.first] << \",\" << names[v.second] << endl;\n        }\n        cout << s.size() << endl;\n    }\n\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    while(cin>>N, N){\n        cin >> D;\n        names.resize(N);\n        for(auto &v: names) cin >> v;\n        solve();\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ulli;\n\nconst ulli B = 1000000007ULL;\n\n\nulli getHash(const string &s) {\n  int n = s.size();\n  ulli res = 0;\n  for(int i = 0; i < n; ++i) {\n    res = res * B + s[i];\n  }\n  return res;\n}\n\nint main() {\n  for(int n, d; cin >> n && n; ) {\n    cin >> d;\n    vector<string> ss(n);\n    for(int i = 0; i < n; ++i) {\n      cin >> ss[i];\n    }\n\n    sort(ss.begin(), ss.end());\n\n    vector<set<ulli> > nextHash(n);\n    for(int k = 0; k < n; ++k) {\n      string s = ss[k];\n      // Deleting\n      for(int i = 0; i < s.size(); ++i) {\n        char tmp = s[i];\n        s.erase(i, 1);\n        nextHash[k].insert(getHash(s));\n        s.insert(i, string(1, tmp));\n      }\n      // Inserting\n      for(int i = 0; i <= s.size(); ++i) {\n        for(char c = 'a'; c <= 'z'; ++c) {\n          s.insert(i, string(1, c));\n          nextHash[k].insert(getHash(s));\n          s.erase(i, 1);\n        }\n      }\n      // Replacing\n      for(int i = 0; i < s.size(); ++i) {\n        char tmp = s[i];\n        for(char c = 'a'; c <= 'z'; ++c) {\n          s[i] = c;\n          nextHash[k].insert(getHash(s));\n        }\n        s[i] = tmp;\n      }\n      // Swapping\n      for(int i = 0; i + 1 < s.size(); ++i) {\n        int j = i + 1;\n        swap(s[i], s[j]);\n        nextHash[k].insert(getHash(s));\n        swap(s[i], s[j]);\n      }\n    }\n\n    map<ulli, int> A;\n    map<ulli, set<int> > B;\n    for(int i = 0; i < n; ++i) {\n      A[getHash(ss[i])] = i;\n      if(d <= 1) continue;\n      for(set<ulli>::iterator it = nextHash[i].begin();\n          it != nextHash[i].end(); ++it) {\n        B[*it].insert(i);\n      }\n    }\n\n    set<pair<int, int> > ans;\n    for(int i = 0; i < n; ++i) {\n      for(set<ulli>::iterator it = nextHash[i].begin();\n          it != nextHash[i].end(); ++it) {\n        if(A.count(*it)) {\n          pair<int, int> p(i, A[*it]);\n          if(p.first > p.second) swap(p.first, p.second);\n          ans.insert(p);\n        }\n      }\n      for(set<ulli>::iterator it = nextHash[i].begin();\n          it != nextHash[i].end(); ++it) {\n        if(B.count(*it)) {\n          for(set<int>::iterator it2 = B[*it].begin();\n              it2 != B[*it].end(); ++it2) {\n            pair<int, int> p(i, *it2);\n            if(p.first > p.second) swap(p.first, p.second);\n            ans.insert(p);\n          }\n        }\n      }\n    }\n\n    int res = 0;\n    for(set<pair<int, int> >::iterator it = ans.begin();\n        it != ans.end(); ++it) {\n      if(it->first == it->second) continue;\n      ++res;\n      cout << ss[it->first] << \",\" << ss[it->second] << endl;\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<string,string> P;\n\nint N, D;\nstring t[202];\nset<string> sets[202];\n\nvoid change(string s, set<string> &st){\n  st.clear();\n\n  int n = s.size();\n\n  //delete\n  for(int i = 0; i < n; i++){\n    string s2 = s;\n    s2.erase(s2.begin() + i);\n    st.insert(s2);\n  }\n\n  for(char ch = 'a'; ch <= 'z'; ch++){\n    //insert\n    for(int i = 0; i <= n; i++){\n      string s2 = s;\n      s2.insert(s2.begin() + i, ch);\n      st.insert(s2);\n    }\n\n    //replace\n    for(int i = 0; i < n; i++){\n      string s2 = s;\n      s2[i] = ch;\n      st.insert(s2);\n    }\n  }\n\n  //swap\n  for(int i = 0; i < n - 1; i++){\n    string s2 = s;\n    swap(s2[i], s2[i + 1]);\n    st.insert(s2);\n  }\n}\n\nint main(){\n  while(cin >> N >> D){\n    for(int i = 0; i < N; i++){\n      cin >> t[i];\n      change(t[i], sets[i]);\n    }\n\n    vector<P> vt;\n\n    for(int i = 0; i < N; i++){\n      for(int j = i + 1; j < N; j++){\n        bool flg = false;\n\n        if(sets[j].find(t[i]) != sets[j].end()){\n          flg = true;\n        }\n\n        if(!flg && D == 2){\n          for(set<string>::iterator iter = sets[i].begin(); iter != sets[i].end(); iter++){\n            string s = *iter;\n            if(sets[j].find(s) != sets[j].end()){\n              flg = true;\n              break;\n            }\n          }\n        }\n\n        if(flg){\n          if(t[i] < t[j]) vt.push_back(P(t[i], t[j]));\n          else            vt.push_back(P(t[j], t[i]));\n        }\n      }\n    }\n\n    sort(vt.begin(), vt.end());\n\n    for(int i = 0; i < vt.size(); i++){\n      cout << vt[i].first << \",\" << vt[i].second << endl;\n    }\n    cout << vt.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int N = 1e6;\nvi graph[N];\n\nusing ResElem = tuple<int, int>;\nset<ResElem> s;\n\ninline void add_edge(int a, int b){\n    graph[a].emplace_back(b);\n    graph[b].emplace_back(a);\n}\n\nint d, n;\nmap<string, int> s2i;\nmap<int, string> i2s;\n\nvoid dfs(int sv, int v, int depth){\n    if(depth > d) return;\n    if(sv != v and v < n){\n        string a = i2s[v], b = i2s[sv];\n        if(a > b) swap(a, b);\n        s.insert(ResElem(s2i[a], s2i[b]));\n    }\n\n    for(auto& nv : graph[v]){\n        dfs(sv, nv, depth + 1);\n    }\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(; cin >> n >> d, n;){\n        vector<string> names(n);\n        for(auto& e : names) cin >> e;\n\n        s2i.clear();\n        i2s.clear();\n        int idx = 0;\n        auto add_vertex = [&](string& name){\n            if(s2i.find(name) == end(s2i)){\n                s2i[name] = idx; i2s[idx] = name; idx++;\n            }\n            return s2i[name];\n        };\n        for(auto& e : names) add_vertex(e);\n\n        rep(i, N) graph[i].clear();\n        for(auto& cur : names){\n            string next;\n            int len = cur.size();\n            int v = s2i[cur];\n\n            // delete\n            rep(i, len){\n                next = cur.substr(0, i) + cur.substr(i + 1);\n                int nv = add_vertex(next);\n                add_edge(v, nv);\n            }\n\n            // insert\n            rep(i, len + 1){\n                rep(j, 'z' - 'a' + 1){\n                    char c = (char)('a' + j);\n                    next = cur.substr(0, i) + c + cur.substr(i);\n                    int nv = add_vertex(next);\n                    add_edge(v, nv);\n                }\n            }\n\n            // replace\n            rep(i, len){\n                rep(j, 'z' - 'a' + 1){\n                    char c = (char)('a' + j);\n                    next = cur.substr(0, i) + c + cur.substr(i + 1);\n                    int nv = add_vertex(next);\n                    add_edge(v, nv);\n                }\n            }\n\n            // swap\n            rep(i, len - 1){\n                next = cur;\n                swap(next[i], next[i + 1]);\n                int nv = add_vertex(next);\n                add_edge(v, nv);\n            }\n        }\n\n        s.clear();\n        rep(i, n){\n            dfs(i, i, 0);\n        }\n\n        for(auto& e : s){\n            int a, b; tie(a, b) = e;\n            cout << i2s[a] << \",\" << i2s[b] << endl;\n        }\n        cout << s.size() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n){\n    int d;\n    vector<string> name(n);\n    cin >> d;\n    rep(i,0,n) cin >> name[i];\n    sort(name.begin(),name.end());\n\n    function<set<string>(const string&)> enumerate_neighborhood=[&](const string &s){\n        set<string> st;\n        //replace\n        {\n            string t=s;\n            rep(i,0,s.size()){\n                rep(j,0,26){\n                    t[i]='a'+j;\n                    st.insert(t);\n                }\n                t[i]=s[i];\n            }\n        }\n        //insert\n        {\n            string x;\n            rep(i,0,s.size()+1){\n                string y=s.substr(i);\n                rep(j,0,26){\n                    x.push_back('a'+j);\n                    auto t=x+y;\n                    st.insert(t);\n                    x.pop_back();\n                }\n                x+=s[i];\n            }\n        }\n        //delete\n        {\n            string x;\n            rep(i,0,s.size()){\n                string t=x+s.substr(i+1);\n                st.insert(t);\n                x+=s[i];\n            }\n        }\n        //swap adjacent\n        {\n            string t=s;\n            rep(i,0,s.size()-1){\n                swap(t[i],t[i+1]);\n                st.insert(t);\n                swap(t[i],t[i+1]);\n            }\n        }\n        return st;\n    };\n\n    vector<set<string>> us(n);\n    rep(i,0,n) us[i]=enumerate_neighborhood(name[i]);\n\n    int count=0;\n    rep(i,0,n){\n        rep(j,i+1,n){\n            if(d==1){\n                if(us[i].find(name[j])==us[i].end()) continue;\n            }else{\n                vector<string> v;\n                set_intersection(us[i].begin(),us[i].end(),us[j].begin(),us[j].end(),back_inserter(v));\n                if(v.empty()) continue;\n            }\n            cout << name[i] << \",\" << name[j] << endl;\n            ++count;\n        }\n    }\n    cout << count << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tchar buf[20];\n};\n\nstruct Data{\n\tchar left[20],right[20];\n};\n\nint N,DIST;\nInfo info[200];\nvector<Info> V[200];\nbool check[200][200];\n\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nint strCmp2(char* left,char* right){\n\tint i;\n\n\tif(strCmp(left,right))return 3;\n\n\tfor(i=0;left[i] != '\\0' && right[i] != '\\0'; i++){\n\t\tif(left[i] != right[i]){\n\t\t\tif(left[i] < right[i])return 1;\n\t\t\telse{\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\t}\n\tif(left[i] == '\\0')return 1;\n\telse{\n\t\treturn 2;\n\t}\n}\n\n\nvoid makeDist1(int id){\n\n\tchar work[20];\n\n\tint length,index;\n\tfor(length = 0; info[id].buf[length] != '\\0'; length++);\n\n\tfor(int del_loc = 0; del_loc < length; del_loc++){\n\t\tindex = 0;\n\t\tfor(int i = 0; i < length; i++){\n\t\t\tif(i == del_loc)continue;\n\t\t\twork[index++] = info[id].buf[i];\n\t\t}\n\t\twork[index] = '\\0';\n\t\tInfo new_info;\n\t\tstrcpy(new_info.buf,work);\n\t\tV[id].push_back(new_info);\n\t}\n\n\tfor(int word = 0; word < 26; word++){\n\t\tfor(int loc = 0; loc <= length; loc++){\n\t\t\tindex = 0;\n\t\t\tfor(int i = 0; i < loc; i++){\n\t\t\t\twork[index++] = info[id].buf[i];\n\t\t\t}\n\t\t\twork[index++] = 'a'+word;\n\t\t\tfor(int i = loc; i < length; i++){\n\t\t\t\twork[index++] = info[id].buf[i];\n\t\t\t}\n\t\t\twork[index] = '\\0';\n\t\t\tInfo new_info;\n\t\t\tstrcpy(new_info.buf,work);\n\t\t\tV[id].push_back(new_info);\n\t\t}\n\t}\n\n\tfor(int word = 0; word < 26; word++){\n\t\tfor(int loc = 0; loc < length; loc++){\n\t\t\tindex = 0;\n\t\t\tfor(int i = 0; i < length; i++){\n\t\t\t\tif(i != loc){\n\t\t\t\t\twork[index++] = info[id].buf[i];\n\t\t\t\t}else{\n\t\t\t\t\twork[index++] = 'a'+word;\n\t\t\t\t}\n\t\t\t}\n\t\t\twork[index] = '\\0';\n\t\t\tInfo new_info;\n\t\t\tstrcpy(new_info.buf,work);\n\t\t\tV[id].push_back(new_info);\n\t\t}\n\t}\n\n\tfor(int a = 0; a < length-1; a++){\n\t\tint b = a+1;\n\t\tindex = 0;\n\t\tfor(int i = 0; i < length; i++){\n\t\t\twork[index++] = info[id].buf[i];\n\t\t}\n\t\tswap(work[a],work[b]);\n\t\twork[index] = '\\0';\n\t\tInfo new_info;\n\t\tstrcpy(new_info.buf,work);\n\t\tV[id].push_back(new_info);\n\t}\n}\n\nvoid func(){\n\n\tscanf(\"%d\",&DIST);\n\n\tfor(int i = 0; i < N; i++)V[i].clear();\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%s\",info[i].buf);\n\t\tmakeDist1(i);\n\t}\n\n\tvector<Data> ANS;\n\tbool FLG;\n\n\tfor(int i = 0; i < N-1; i++){\n\t\tfor(int k = i+1; k < N; k++)check[i][k] = false;\n\t}\n\n\tif(DIST == 1){\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int p = i+1; p < N; p++){\n\t\t\t\tfor(int k = 0; k < V[i].size(); k++){\n\t\t\t\t\tif(strCmp(V[i][k].buf,info[p].buf)){\n\t\t\t\t\t\tcheck[i][p] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}else{\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int p = i+1; p < N; p++){\n\t\t\t\tFLG = false;\n\t\t\t\tfor(int k = 0; k < V[i].size(); k++){\n\t\t\t\t\tif(strCmp(V[i][k].buf,info[p].buf)){\n\t\t\t\t\t\tcheck[i][p] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int q = 0; q < V[p].size(); q++){\n\t\t\t\t\t\tif(strCmp(V[i][k].buf,V[p][q].buf)){\n\t\t\t\t\t\t\tcheck[i][p] = true;\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(FLG)break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N-1; i++){\n\t\tfor(int p = i+1; p < N; p++){\n\t\t\tif(check[i][p]){\n\t\t\t\tData data;\n\t\t\t\tif(strCmp2(info[i].buf,info[p].buf) == 1){\n\t\t\t\t\tstrcpy(data.left,info[i].buf);\n\t\t\t\t\tstrcpy(data.right,info[p].buf);\n\t\t\t\t}else{\n\t\t\t\t\tstrcpy(data.right,info[i].buf);\n\t\t\t\t\tstrcpy(data.left,info[p].buf);\n\t\t\t\t}\n\t\t\t\tANS.push_back(data);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i < ANS.size(); i++){\n\t\tfor(int k = ANS.size()-1; k >= i; k--){\n\t\t\tif(strCmp2(ANS[k].left,ANS[k-1].left) == 1){\n\t\t\t\tswap(ANS[k],ANS[k-1]);\n\t\t\t}else if(strCmp2(ANS[k].left,ANS[k-1].left) == 3 && strCmp2(ANS[k].right,ANS[k-1].right) == 1){\n\t\t\t\tswap(ANS[k],ANS[k-1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < ANS.size(); i++){\n\t\tprintf(\"%s,%s\\n\",ANS[i].left,ANS[i].right);\n\t}\n\tprintf(\"%lld\\n\",ANS.size());\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\ntypedef pair<string,string> s2;\nint n,d;\nstring name[210];\nunordered_set<string> memo;\n\nvoid dfs(int cur,string s,const string &target,int cost,int &mini){\n  if( cost >= mini ) return;\n  if( cost > d ) return;\n  //cout << s << endl;\n  if( cur >= target.size() ) {\n    rep(i,s.size()) if( i >= target.size() && s[i] != ' ' ) ++cost;\n    mini = min(mini,cost);\n\n    return;\n  }\n  if( s[cur] == target[cur] ) {\n    dfs(cur+1,s,target,cost,mini);\n    return;\n  }\n\n  if( memo.count(s) ) return;\n\n  string ns;\n  //  Delete\n  if( s[cur] != ' ' ) {\n    ns = s.substr(0,cur) + s.substr(cur+1) + \" \";\n    dfs(cur,ns,target,cost+1,mini);\n  }\n\n  // Insert\n  ns = s.substr(0,cur) + target[cur] + s.substr(cur);\n  dfs(cur+1,ns,target,cost+1,mini);\n\n  // Replace\n  if( s[cur] != ' ' ) {\n    ns = s;\n    ns[cur] = target[cur];\n    dfs(cur+1,ns,target,cost+1,mini);\n  }\n\n  // Swap\n  ns = s;\n  REP(i,cur+1,ns.size()) if( ns[i] == target[cur] ) {\n    swap(ns[i],ns[cur]);\n    dfs(cur+1,ns,target,cost+1,mini);\n    swap(ns[i],ns[cur]);\n  }\n  memo.insert(s);\n}\n\nint compute(string a,string b){\n  if( (int)a.size() > (int)b.size() ) swap(a,b);\n  a = a + string((int)b.size()-(int)a.size(),' ');\n  memo.clear();\n  int mini = b.size();\n  dfs(0,a,b,0,mini);\n  return mini;\n}\n\nint main(){\n  while( cin >> n,n ){\n    cin >> d;\n    rep(i,n) cin >> name[i];\n    vector<s2> vec;\n    rep(i,n) REP(j,i+1,n){\n      int dist = compute(name[i],name[j]);\n      string a = name[i], b = name[j];\n      if( a > b ) swap(a,b);\n      if( dist <= d ) vec.push_back(s2(a,b));\n    }\n    sort(vec.begin(),vec.end());    \n    rep(i,vec.size()) cout << vec[i].first << \",\" << vec[i].second << endl;\n    cout << (int)vec.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<string,string> P;\nconst int M=1000000007;\nclass RH {\npublic:\n  unsigned long long p[111],h[111];\n  int n;\n  void init(string s) {\n    n=s.size();\n    p[0]=1;h[0]=0;\n    for(int i=0; i<n; i++) {\n      h[i+1]=h[i]*M+s[i];\n      p[i+1]=p[i]*M;\n    }\n  }\n  unsigned long long H() {\n    return h[n];\n  }\n};\nmap<unsigned long long,vector<string> > m;\n \nvoid change(string s) {\n  int n=s.size();\n  for(int i=0; i<n; i++) {\n    string t=s.substr(0,i)+s.substr(i+1);\n    RH r;\n    r.init(t);\n    m[r.H()].push_back(s);\n    for(int j=0; j<26; j++) {\n      t=s;\n      t[i]='a'+j;\n      r.init(t);\n      m[r.H()].push_back(s);\n    } \n  }\n  for(int i=0; i<=n; i++) {\n    for(int j=0; j<26; j++) {\n      string t=s.substr(0,i)+(char)('a'+j)+s.substr(i);\n      RH r;\n      r.init(t);\n      m[r.H()].push_back(s);\n    }\n  }\n  for(int i=0; i<n-1; i++) {\n    swap(s[i],s[i+1]);\n    RH r;\n    r.init(s);\n    swap(s[i],s[i+1]);\n    m[r.H()].push_back(s);\n  }\n}\nint main() {\n  int n;\n  while(cin >> n && n) {\n    m.clear();\n    int d;\n    cin >> d;\n    string s[n];\n    for(int i=0; i<n; i++) {\n      cin >> s[i];\n      change(s[i]);\n    }\n    vector<P> ans;\n    if(d==1) {\n      for(int i=0; i<n; i++) {\n        RH r;\n        r.init(s[i]);\n        vector<string> v=m[r.H()];\n        for(int j=0; j<v.size(); j++) {\n          if(s[i]==v[j]) continue;\n          P p=P(s[i],v[j]);\n          if(p.first>p.second) swap(p.first,p.second);\n          ans.push_back(p);\n        }\n      }\n    } else {\n      for(map<unsigned long long,vector<string> >::iterator it=m.begin(); it!=m.end(); it++) {\n        vector<string> v=it->second;\n        sort(v.begin(),v.end());\n        v.erase(unique(v.begin(),v.end()),v.end());\n        for(int i=0; i<v.size(); i++) {\n          for(int j=i+1; j<v.size(); j++) {\n            ans.push_back(P(v[i],v[j]));\n          }\n        }\n      }\n    }\n    sort(ans.begin(),ans.end());\n    ans.erase(unique(ans.begin(),ans.end()),ans.end());\n    for(int i=0; i<ans.size(); i++) cout << ans[i].first << \",\" << ans[i].second << endl;\n    cout << ans.size() << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<string,string> P;\n\nint n,d;\nint ans=0;\nset<string> mp[201];\nint cnt[201][201];\nvector<P> vec;\nstring str[201];\nqueue<int> que;\n\nvoid dfs(int v,string s,int nd,int uk=0){\n\tif(nd==0){\n\t\tmp[v].insert(s);\n\t\tfor(int i=0;i+1<s.size();i++){\n\t\t\tswap(s[i],s[i+1]);\n\t\t\tdfs(v,s,nd+1);\n\t\t\tswap(s[i],s[i+1]);\n\t\t}\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tdfs(v,s.substr(0,i)+s.substr(i+1),nd+1);\n\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\tstring gu=\"\";\n\t\t\t\tgu+=('a'+j);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i+1),nd+1,1);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i),nd+1,1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<26;i++){\n\t\t\tstring gu=\"\";\n\t\t\tgu+=('a'+i);\n\t\t\tdfs(v,s+gu,nd+1);\n\t\t}\n\t}else if(nd==1){\n\t\tmp[v].insert(s);\n\t}\n}\n\nvoid dfs2(int v,string s,int nd,int uk=0){\n\tif(nd==0){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(mp[i].find(s)!=mp[i].end()){\n\t\t\t\tcnt[v][i]++;\n\t\t\t\tcnt[i][v]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i+1<s.size();i++){\n\t\t\tswap(s[i],s[i+1]);\n\t\t\tdfs2(v,s,nd+1);\n\t\t\tswap(s[i],s[i+1]);\n\t\t}\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tdfs2(v,s.substr(0,i)+s.substr(i+1),nd+1);\n\t\t}\n\t\tfor(int i=0;i<26;i++){\n\t\t\tstring gu=\"\";\n\t\t\tgu+=('a'+i);\n\t\t\tdfs2(v,s+gu,nd+1);\n\t\t}\n\t}else if(nd==1){\n\t\tif(d==2 && uk==0){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(mp[i].find(s)!=mp[i].end()){\n\t\t\t\t\tcnt[v][i]++;\n\t\t\t\t\tcnt[i][v]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tvec.clear();\n\tfor(int i=0;i<n;i++){\n\t\tmp[i].clear();\n\t}\n\tscanf(\"%d\",&d);\n\tans=0;\n\tmemset(cnt,0,sizeof(cnt));\n\tfor(int i=0;i<n;i++){\n\t\tcin >> str[i];\n\t\twhile(que.size())que.pop();\n\t\tfor(int j=0;j<i;j++){\n\t\t\tque.push(j);\n\t\t}\n\t\tdfs(i,str[i],0);\n\t\t\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tdfs2(i,str[i],0);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(cnt[i][j]>0){\n\t\t\t\tans++;\n\t\t\t\tvec.push_back(P(min(str[i],str[j]),max(str[i],str[j])));\n\t\t\t}\n\t\t}\n\t}\n\tsort(vec.begin(),vec.end());\n\tfor(int i=0;i<vec.size();i++){\n\t\tcout << vec[i].first << \",\" << vec[i].second << endl;\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint d;\nchar buf[114514];\nmap<string, set<int> > mp; \nstring names[114514];\nset<int> ans[114514];\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) return 0;\n\n    scanf(\"%d\", &d);\n    for (int i=0; i<n; i++) {\n      scanf(\"%s\", buf);\n      names[i] = buf;\n      ans[i].clear();\n    }\n    sort(names, names+n);\n    mp.clear();\n    for (int i=0; i<n; i++) {\n      mp[names[i]].insert(i);\n    }\n\n    if (d == 1) {\n      for (int i=0; i<n; i++) {\n        for (int j=0; j<names[i].size(); j++) {\n          for (int k : mp[names[i].substr(0, j) + names[i].substr(j+1)]) {\n            if (k != i) {\n              ans[min(i, k)].insert(max(i, k));\n            }\n          }\n\n          for (char k='a'; k<='z'; k++) {\n            //cout << \"rep: \" << names[i].substr(0, j)+k+names[i].substr(j+1) << \"\\n\";\n            for (int t : mp[names[i].substr(0, j)+k+names[i].substr(j+1)]) {\n              if (t != i) {\n                ans[min(i, t)].insert(max(i, t));\n              }\n            }\n\n            //cout << \"ins: \" << names[i].substr(0, j)+k+names[i].substr(j) << \"\\n\";\n            for (int t : mp[names[i].substr(0, j)+k+names[i].substr(j)]) {\n              if (t != i) {\n                ans[min(i, t)].insert(max(i, t));\n              }\n            }\n          }\n\n          for (int k=j+1; k<names[i].size(); k++) {\n            string g = names[i].substr(0, j)+names[i][k]+names[i].substr(j+1, k-j-1)+names[i][j]+names[i].substr(k+1);\n            //cout << \"sw: \" << g << \"\\n\";\n            for (int t : mp[g]) {\n              if (t != i) {\n                ans[min(i, t)].insert(max(i, t));\n              }\n            }\n          }\n        }\n\n        for (char k='a'; k<='z'; k++) {\n          //cout << \"ins: \" << names[i]+k << \"\\n\";\n          for (int t : mp[names[i]+k]) {\n            if (t != i) {\n              ans[min(i, t)].insert(max(i, t));\n            }\n          }\n        }\n      }\n    } else if (d == 2) {\n      for (int i=0; i<n; i++) {\n        for (int j=0; j<names[i].size(); j++) {\n          //cout << \"del: \" << names[i].substr(0, j) + names[i].substr(j+1) << \"\\n\";\n          mp[names[i].substr(0, j) + names[i].substr(j+1)].insert(i);\n          for (char k='a'; k<='z'; k++) {\n            mp[names[i].substr(0, j)+k+names[i].substr(j+1)].insert(i);\n            mp[names[i].substr(0, j)+k+names[i].substr(j)].insert(i);\n          }\n\n          for (int k=j+1; k<names[i].size(); k++) {\n            string g = names[i].substr(0, j)+names[i][k]+names[i].substr(j+1, k-j-1)+names[i][j]+names[i].substr(k+1);\n            mp[g].insert(i);\n          }\n        }\n\n        for (char k='a'; k<='z'; k++) {\n          mp[names[i]+k].insert(i);\n        }\n      }\n\n      for (auto itr : mp) {\n        for (int i : itr.second) {\n          for (int j : itr.second) {\n            if (i < j) ans[i].insert(j);\n          }\n        } \n      }\n    }\n\n    int cnt = 0;\n    for (int i=0; i<n; i++) {\n      for (int j : ans[i]) {\n        printf(\"%s,%s\\n\", names[i].c_str(), names[j].c_str());\n        cnt++;\n      }\n    }\n    printf(\"%d\\n\", cnt);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 334\ntypedef pair<string,string> P;\ntypedef pair<string,int> P2;\n\nint N,D,idx;\nstring s[MAX];\nmap<int,set<string> > mp;\nvector<P> vec;\n\nvoid dfs(string now,int step){\n  if(step == 1){\n    mp[idx].insert(now);\n    return;\n  }\n\n  int len = now.size();\n  // delete\n  for(int i = 0 ; i < len ; i++){\n    string tmp = now;\n    tmp.erase(tmp.begin()+i);\n    dfs(tmp,step+1);\n  }\n\n  // swap\n  for(int i = 0 ; i < len-1 ; i++){\n    for(int j = i+1 ; j < len ; j++){\n      swap(now[i],now[j]);\n      dfs(now,step+1);\n      swap(now[i],now[j]);\n    }\n  }\n  \n  // insert\n  for(char ch = 'a' ; ch <= 'z' ; ch++){\n    for(int j = 0 ; j < len+1 ; j++){\n      string tmp = now;\n      tmp = tmp.substr(0,j) + ch + tmp.substr(j);\n      dfs(tmp,step+1);\n    }\n  }\n\n  // replace\n  for(char ch = 'a' ; ch <= 'z' ; ch++){\n    for(int j = 0 ; j < len ; j++){\n      string tmp = now; tmp[j] = ch;\n      dfs(tmp,step+1);\n    }\n  }\n}\n\nint main(){\n  while(cin >> N, N){\n    cin >> D;\n    mp.clear();\n    for(int i = 0 ; i < N ; i++){\n      cin >> s[i];\n    }\n    vec.clear();\n    for(int i = 0 ; i < N ; i++){\n      idx = i;\n      dfs(s[i],0);\n    }\n    \n    if(D == 1){\n      for(int i = 0 ; i < N ; i++){\n\tset<string> st = mp[i];\n\tfor(int j=i+1; j<N; j++) {\n\t  if(st.count(s[j])){\n\t    vec.push_back(P(s[i],s[j]));\n\t  }\n\t}\n      }\n    }else{\n      for(int i = 0 ; i < N ; i++){\n\tfor(int j = i+1 ; j < N ; j++){\n\t  set<string> st = mp[i],st2 = mp[j];\n\t  set<string>::iterator it;\n\t  for(it = st.begin() ; it != st.end() ; ++it){\n\t    if(st2.count(*it)){\n\t      vec.push_back(P(s[i],s[j]));\n\t      break;\n\t    }\n\t  }\n\t}\n      }\n    }\n    int len = vec.size();\n    for(int i = 0 ; i < len ; i++){\n      if(vec[i].first > vec[i].second){\n\tswap(vec[i].first,vec[i].second);\n      }\n    }\n    sort(vec.begin(),vec.end());\n    vec.erase(unique(vec.begin(),vec.end()),vec.end());\n    for(int i = 0 ; i < len ; i++){\n      cout << vec[i].first << \",\" << vec[i].second << endl;\n    }\n    cout << len << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tchar buf[20];\n};\n\nstruct Data{\n\tchar left[20],right[20];\n};\n\nint N,DIST;\nInfo info[200];\nvector<Info> V[200];\nbool check[200][200];\n\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\n\nint strCmp2(char* left,char* right){\n\tint i;\n\n\tif(strCmp(left,right))return 3;\n\n\tfor(i=0;left[i] != '\\0' && right[i] != '\\0'; i++){\n\t\tif(left[i] != right[i]){\n\t\t\tif(left[i] < right[i])return 1;\n\t\t\telse{\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\t}\n\tif(left[i] == '\\0')return 1;\n\telse{\n\t\treturn 2;\n\t}\n}\n\n\nvoid makeDist1(int id){\n\n\tchar work[20];\n\n\tint length,index;\n\tfor(length = 0; info[id].buf[length] != '\\0'; length++);\n\n\tfor(int del_loc = 0; del_loc < length; del_loc++){\n\t\tindex = 0;\n\t\tfor(int i = 0; i < length; i++){\n\t\t\tif(i == del_loc)continue;\n\t\t\twork[index++] = info[id].buf[i];\n\t\t}\n\t\twork[index] = '\\0';\n\t\tInfo new_info;\n\t\tstrcpy(new_info.buf,work);\n\t\tV[id].push_back(new_info);\n\t}\n\n\tfor(int word = 0; word < 26; word++){\n\t\tfor(int loc = 0; loc <= length; loc++){\n\t\t\tindex = 0;\n\t\t\tfor(int i = 0; i < loc; i++){\n\t\t\t\twork[index++] = info[id].buf[i];\n\t\t\t}\n\t\t\twork[index++] = 'a'+word;\n\t\t\tfor(int i = loc; i < length; i++){\n\t\t\t\twork[index++] = info[id].buf[i];\n\t\t\t}\n\t\t\twork[index] = '\\0';\n\t\t\tInfo new_info;\n\t\t\tstrcpy(new_info.buf,work);\n\t\t\tV[id].push_back(new_info);\n\t\t}\n\t}\n\n\tfor(int word = 0; word < 26; word++){\n\t\tfor(int loc = 0; loc < length; loc++){\n\t\t\tindex = 0;\n\t\t\tfor(int i = 0; i < length; i++){\n\t\t\t\tif(i != loc){\n\t\t\t\t\twork[index++] = info[id].buf[i];\n\t\t\t\t}else{\n\t\t\t\t\twork[index++] = 'a'+word;\n\t\t\t\t}\n\t\t\t}\n\t\t\twork[index] = '\\0';\n\t\t\tInfo new_info;\n\t\t\tstrcpy(new_info.buf,work);\n\t\t\tV[id].push_back(new_info);\n\t\t}\n\t}\n\n\tfor(int a = 0; a < length-1; a++){\n\t\tfor(int b = 0; b < length; b++){\n\t\t\tindex = 0;\n\t\t\tfor(int i = 0; i < length; i++){\n\t\t\t\twork[index++] = info[id].buf[i];\n\t\t\t}\n\t\t\tswap(work[a],work[b]);\n\t\t\twork[index] = '\\0';\n\t\t\tInfo new_info;\n\t\t\tstrcpy(new_info.buf,work);\n\t\t\tV[id].push_back(new_info);\n\t\t}\n\t}\n\n}\n\nvoid func(){\n\n\tscanf(\"%d\",&DIST);\n\n\tfor(int i = 0; i < N; i++)V[i].clear();\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%s\",info[i].buf);\n\t\tmakeDist1(i);\n\t}\n\n\tvector<Data> ANS;\n\tbool FLG;\n\n\tfor(int i = 0; i < N-1; i++){\n\t\tfor(int k = i+1; k < N; k++)check[i][k] = false;\n\t}\n\n\tif(DIST == 1){\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int k = 0; k < V[i].size(); k++){\n\t\t\t\tfor(int p = i+1; p < N; p++){\n\t\t\t\t\tif(strCmp(V[i][k].buf,info[p].buf)){\n\t\t\t\t\t\tcheck[i][p] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}else{\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int k = 0; k < V[i].size(); k++){\n\t\t\t\tfor(int p = i+1; p < N; p++){\n\t\t\t\t\tif(strCmp(V[i][k].buf,info[p].buf)){\n\t\t\t\t\t\tcheck[i][p] = true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int q = 0; q < V[p].size(); q++){\n\t\t\t\t\t\tif(strCmp(V[i][k].buf,V[p][q].buf)){\n\t\t\t\t\t\t\tcheck[i][p] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N-1; i++){\n\t\tfor(int p = i+1; p < N; p++){\n\t\t\tif(check[i][p]){\n\t\t\t\tData data;\n\t\t\t\tif(strCmp2(info[i].buf,info[p].buf) == 1){\n\t\t\t\t\tstrcpy(data.left,info[i].buf);\n\t\t\t\t\tstrcpy(data.right,info[p].buf);\n\t\t\t\t}else{\n\t\t\t\t\tstrcpy(data.right,info[i].buf);\n\t\t\t\t\tstrcpy(data.left,info[p].buf);\n\t\t\t\t}\n\t\t\t\tANS.push_back(data);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i < ANS.size(); i++){\n\t\tfor(int k = ANS.size()-1; k >= i; k--){\n\t\t\tif(strCmp2(ANS[k].left,ANS[k-1].left) == 1){\n\t\t\t\tswap(ANS[k],ANS[k-1]);\n\t\t\t}else if(strCmp2(ANS[k].left,ANS[k-1].left) == 3 && strCmp2(ANS[k].right,ANS[k-1].right) == 1){\n\t\t\t\tswap(ANS[k],ANS[k-1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < ANS.size(); i++){\n\t\tprintf(\"%s,%s\\n\",ANS[i].left,ANS[i].right);\n\t}\n\tprintf(\"%lld\\n\",ANS.size());\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<string,string> P;\n\nint N, D;\nstring t[202];\nset<string> sets[202];\n\nvoid change(string s, set<string> &st){\n  st.clear();\n\n  int n = s.size();\n\n  //delete\n  for(int i = 0; i < n; i++){\n    string s2 = s;\n    s2.erase(s2.begin() + i);\n    st.insert(s2);\n  }\n\n  for(char ch = 'a'; ch <= 'z'; ch++){\n    //insert\n    for(int i = 0; i <= n; i++){\n      string s2 = s;\n      s2.insert(s2.begin() + i, ch);\n      st.insert(s2);\n    }\n\n    //replace\n    for(int i = 0; i < n; i++){\n      string s2 = s;\n      s2[i] = ch;\n      st.insert(s2);\n    }\n  }\n\n  //swap\n  for(int i = 0; i < n - 1; i++){\n    string s2 = s;\n    swap(s2[i], s2[i + 1]);\n    st.insert(s2);\n  }\n}\n\nint main(){\n  while(cin >> N >> D){\n    for(int i = 0; i < N; i++){\n      cin >> t[i];\n      change(t[i], sets[i]);\n    }\n\n    vector<P> vt;\n\n    for(int i = 0; i < N; i++){\n      for(int j = i + 1; j < N; j++){\n        bool flg = false;\n\n        if(D == 2){\n          for(set<string>::iterator iter = sets[i].begin(); iter != sets[i].end(); iter++){\n            string s = *iter;\n            if(sets[j].find(s) != sets[j].end()){\n              flg = true;\n              break;\n            }\n          }\n        }\n\n        if(!flg){\n          if(sets[j].find(t[i]) != sets[j].end()){\n            flg = true;\n          }\n        }\n\n        if(flg){\n          if(t[i] < t[j]) vt.push_back(P(t[i], t[j]));\n          else            vt.push_back(P(t[j], t[i]));\n        }\n      }\n    }\n\n    sort(vt.begin(), vt.end());\n\n    for(int i = 0; i < vt.size(); i++){\n      cout << vt[i].first << \",\" << vt[i].second << endl;\n    }\n    cout << vt.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    int d;\n    cin>>d;\n    set<string> ss;\n    for(int i=0;i<n;i++){\n      string s;\n      cin>>s;\n      ss.emplace(s);\n    }\n    using P = pair<string, string>;\n    set<P> ans;\n    auto calc=[](string s){\n      int n=s.size();\n      set<string> ss;\n      for(int i=0;i<n;i++){\n\tstring t=s;\n\tt.erase(t.begin()+i);\n\tss.emplace(t);\n      }\n      for(int i=0;i<n;i++){\n\tfor(char c='a';c<='z';c++){\n\t  string t=s;\n\t  t[i]=c;\n\t  ss.emplace(t);\n\t}\n      }\n      for(int i=0;i<n-1;i++){\n\tswap(s[i],s[i+1]);\n\tss.emplace(s);\n\tswap(s[i],s[i+1]);\n      }\n      return ss;\n    };\n    map<string,vector<string> > ms;\n    for(string s:ss){\n      if(d==1){\n\tmap<string,int> dp;\n\tqueue<string> q;\n\tdp[s]=0;\n\tq.emplace(s);\n\twhile(!q.empty()){\n\t  string t=q.front();q.pop();\n\t  if(dp[t]>=d) continue;\n\t  auto xs=calc(t);\n\t  for(string x:xs){\n\t    if(dp.count(x)) continue;\n\t    dp[x]=dp[t]+1;\n\t    q.emplace(x);\n\t  }\n\t}\n\tfor(auto p:dp){\n\t  if(p.first==s||p.second>d) continue;\n\t  if(ss.count(p.first)) ans.emplace(minmax({s,p.first}));\n\t}\n      }\n      if(d==2){\n\tmap<string,int> dp;\n\tqueue<string> q;\n\tdp[s]=0;\n\tq.emplace(s);\n\twhile(!q.empty()){\n\t  string t=q.front();q.pop();\n\t  if(dp[t]>=1) continue;\n\t  auto xs=calc(t);\n\t  for(string x:xs){\n\t    if(dp.count(x)) continue;\n\t    dp[x]=dp[t]+1;\n\t    q.emplace(x);\n\t  }\n\t}\n\tcontinue;\n\tfor(auto p:dp){\n\t  if(p.second==1){\n\t    for(auto x:ms[p.first])\n\t      ans.emplace(minmax({s,x}));\n\t    \n\t    ms[p.first].emplace_back(s);\n\t  }\n\t  if(p.first==s||p.second>d) continue;\n\t  if(ss.count(p.first)) ans.emplace(minmax({s,p.first}));\n\t}\n      }\n    }\n    for(P p:ans)\n      cout<<p.first<<\",\"<<p.second<<endl;\n    cout<<ans.size()<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\n\nint N, D;\nvector<string> names;\n//\n//ll to_int(string s){\n//    const int MOD = 1000000009;\n//    ll res = 0;\n//    for(auto c: s){\n//        res = (res*26 + (c - 'a')) % MOD;\n//    }\n//    return res;\n//}\n\nvoid solve(){\n    sort(names.begin(), names.end());\n    \n    map<string, set<int>> mp;\n    for(int ni=0; ni<N; ni++){\n        string name = names[ni];\n        int L = name.size();\n        \n        //delete\n        for(int i=0; i<L; i++){\n            string t = name;\n            t.erase(t.begin()+i);\n            mp[t].insert(ni);\n        }\n        //insert\n        for(int i=0; i<=L; i++){\n            for(char c='a'; c<='z'; c++){\n                string t = name;\n                t.insert(t.begin()+i, c);\n                mp[t].insert(ni);\n            }\n        }\n        //replace\n        for(int i=0; i<L; i++){\n            for(char c='a'; c<='z'; c++){\n                string t = name;\n                t[i] = c;\n                mp[t].insert(ni);\n            }\n        }\n        //swap\n        for(int i=0; i<L-1; i++){\n            string t = name;\n            swap(t[i], t[i+1]);\n            mp[t].insert(ni);\n        }\n    }\n    if(D == 1){\n        int cnt = 0;\n        for(int ni=0; ni<N; ni++){\n            string name = names[ni];\n            if(mp[name].size() > 1){\n                for(auto v: mp[name]){\n                    if(v <= ni) continue;\n                    cout << name << \",\" << names[v] << endl;\n                    cnt++;\n                }\n            }\n        }\n        cout << cnt << endl;\n    }\n    if(D == 2){\n        set<pair<int, int>> s;\n        for(auto v: mp) if(v.second.size() > 1){\n            vector<int> vec;\n            for(auto vv: v.second) vec.push_back(vv);\n            for(int i=0; i<vec.size(); i++){\n                for(int j=i+1; j<vec.size(); j++){\n                    s.insert(make_pair(vec[i], vec[j]));\n                }\n            }\n        }\n        for(auto v: s){\n            cout << names[v.first] << \",\" << names[v.second] << endl;\n        }\n        cout << s.size() << endl;\n    }\n\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    while(cin>>N, N){\n        cin >> D;\n        names.resize(N);\n        for(auto &v: names) cin >> v;\n        solve();\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define MAX 201\ntypedef pair<string,string> P;\n \nint N,D,idx;\nstring s[MAX];\nmap<int,set<string> > mp;\nvector<P> vec;\n \nvoid dfs(string now,int step){\n    if(step == 1){\n\tmp[idx].insert(now);\n\treturn;\n    }\n   \n    int len = now.size();\n    // delete\n    for(int i = 0 ; i < len ; i++){\n\tstring tmp = now;\n\ttmp.erase(tmp.begin()+i);\n\tdfs(tmp,step+1);\n    }\n  \n    // swap\n    for(int i = 0 ; i < len-1 ; i++){\n\tswap(now[i],now[i+1]);\n\tdfs(now,step+1);\n\tswap(now[i],now[i+1]);\n    }\n \n    // insert\n    for(char ch = 'a' ; ch <= 'z' ; ch++){\n\tfor(int j = 0 ; j < len+1 ; j++){\n\t    string tmp = now;\n\t    tmp = tmp.substr(0,j) + ch + tmp.substr(j);\n\t    dfs(tmp,step+1);\n\t}\n    }\n  \n    // replace\n    for(char ch = 'a' ; ch <= 'z' ; ch++){\n\tfor(int j = 0 ; j < len ; j++){\n\t    char c = now[j];\n\t    now[j] = ch;\n\t    dfs(now,step+1);\n\t    now[j] = c;\n\t}\n    }\n}\n \nvoid init(){\n    mp.clear();\n    vec.clear();\n}\n \nint main(){\n    while(cin >> N, N){\n\tcin >> D;\n\tinit();\n\tfor(int i = 0 ; i < N ; i++){\n\t    cin >> s[i];\n\t}\n\tfor(int i = 0 ; i < N ; i++){\n\t    idx = i;\n\t    dfs(s[i],0);\n\t}\n \n\tvector<string> v[MAX];\n\tfor(int i = 0 ; i < N ; i++){\n\t    set<string> st = mp[i];\n\t    set<string>::iterator it;\n\t    for(it = st.begin() ; it != st.end() ; ++it){\n\t\tv[i].push_back(*it);\n\t    }\n\t} \n \n\tif(D == 1){\n\t    for(int i = 0 ; i < N ; i++){\n\t\tunordered_map<string,bool> ump;\n\t\tfor(int j = 0 ; j < (int)v[i].size() ; j++){\n\t\t    ump[v[i][j]] = true;\n\t\t}\n\t\tfor(int j = i+1 ; j < N ; j++){\n\t\t    if(ump.find(s[j]) != ump.end()){\n\t\t\tvec.push_back(P(s[i],s[j]));\n\t\t    }\n\t\t}\n\t    }\n\t}else{\n\t    for(int i = 0 ; i < N ; i++){\n\t\tunordered_map<string,bool> ump;\n\t\tfor(int j = 0 ; j < (int)v[i].size() ; j++){\n\t\t    ump[v[i][j]] = true;\n\t\t}\n\t\tfor(int j = i+1 ; j < N ; j++){\n\t\t    for(int k = 0 ; k < (int)v[j].size() ; k++){\n\t\t\tif(ump.find(v[j][k]) != ump.end()){\n\t\t\t    vec.push_back(P(s[i],s[j]));\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tint len = vec.size();\n\tfor(int i = 0 ; i < len ; i++){\n\t    if(vec[i].first > vec[i].second){\n\t\tswap(vec[i].first,vec[i].second);\n\t    }\n\t}\n\tsort(vec.begin(),vec.end());\n\tfor(int i = 0 ; i < len ; i++){\n\t    cout << vec[i].first << \",\" << vec[i].second << endl;\n\t}\n\tcout << len << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int N = 1e6;\nvi graph[N];\n\nusing ResElem = tuple<string, string>;\nset<ResElem> s;\n\ninline void add_edge(int a, int b){\n    graph[a].emplace_back(b);\n    graph[b].emplace_back(a);\n}\n\nint d, n;\nmap<string, int> s2i;\nmap<int, string> i2s;\n\nvoid dfs(int sv, int v, int depth){\n    if(depth > d) return;\n    if(sv != v and v < n){\n        string a = i2s[v], b = i2s[sv];\n        if(a > b) swap(a, b);\n        s.insert(ResElem(a, b));\n    }\n\n    for(auto& nv : graph[v]){\n        dfs(sv, nv, depth + 1);\n    }\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(; cin >> n >> d, n;){\n        vector<string> names(n);\n        for(auto& e : names) cin >> e;\n\n        s2i.clear();\n        i2s.clear();\n        int idx = 0;\n        auto add_vertex = [&](string& name){\n            if(s2i.find(name) == end(s2i)){\n                s2i[name] = idx; i2s[idx] = name; idx++;\n            }\n            return s2i[name];\n        };\n        for(auto& e : names) add_vertex(e);\n\n        rep(i, N) graph[i].clear();\n        for(auto& cur : names){\n            string next;\n            int len = cur.size();\n            int v = s2i[cur];\n\n            // delete\n            rep(i, len){\n                next = cur.substr(0, i) + cur.substr(i + 1);\n                int nv = add_vertex(next);\n                add_edge(v, nv);\n            }\n\n            // insert\n            rep(i, len + 1){\n                rep(j, 'z' - 'a' + 1){\n                    char c = (char)('a' + j);\n                    next = cur.substr(0, i) + c + cur.substr(i);\n                    int nv = add_vertex(next);\n                    add_edge(v, nv);\n                }\n            }\n\n            // replace\n            rep(i, len){\n                rep(j, 'z' - 'a' + 1){\n                    char c = (char)('a' + j);\n                    next = cur.substr(0, i) + c;\n                    if(i + 1 < len) next += cur.substr(i + 1);\n                    int nv = add_vertex(next);\n                    add_edge(v, nv);\n                }\n            }\n\n            // swap\n            rep(i, len - 1){\n                next = cur;\n                swap(next[i], next[i + 1]);\n                int nv = add_vertex(next);\n                add_edge(v, nv);\n            }\n        }\n\n        s.clear();\n        rep(i, n){\n            dfs(i, i, 0);\n        }\n\n        for(auto& e : s){\n            int a, b; tie(a, b) = e;\n            cout << i2s[a] << \",\" << i2s[b] << endl;\n        }\n        cout << s.size() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, D;\nvector<string> names;\n\nset<string> edit(string name){\n    set<string> ret;\n    int L = name.size();\n    \n    //delete\n    for(int i=0; i<L; i++){\n        string t = name;\n        t.erase(t.begin()+i);\n        ret.insert(t);\n    }\n    //insert\n    for(int i=0; i<L; i++){\n        for(char c='a'; c<='z'; c++){\n            string t = name;\n            t.insert(t.begin()+i, c);\n            ret.insert(t);\n        }\n    }\n    //replace\n    for(int i=0; i<L; i++){\n        for(char c='a'; c<='z'; c++){\n            string t = name;\n            t[i] = c;\n            ret.insert(t);\n        }\n    }\n    //swap\n    for(int i=0; i<L-1; i++){\n        string t = name;\n        swap(t[i], t[i+1]);\n        ret.insert(t);\n    }\n    \n    return ret;\n}\n\nvoid solve(){\n    sort(names.begin(), names.end());\n    \n    int cnt = 0;\n    for(int i=0; i<N; i++){\n        set<string> s = edit(names[i]);\n        for(int j=i+1; j<N; j++){\n            if(D == 1){\n                if(s.count(names[j])){\n                    cout << names[i] << \",\" << names[j] << endl;\n                    cnt++;\n                }\n            }\n            if(D == 2){\n                set<string> t = edit(names[j]);\n                for(auto v: t) if(s.count(v)){\n                    cout << names[i] << \",\" << names[j] << endl;\n                    cnt++;\n                    break;\n                }\n            }\n        }\n    }\n    cout << cnt << endl;\n}\n\nint main(){\n    while(cin>>N, N){\n        cin >> D;\n        names.resize(N);\n        for(auto &v: names) cin >> v;\n        solve();\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n/* -----  2017/11/13  Problem: NU_27_A / Link: __CONTEST_URL__  ----- */\n/* ------問題------\n\n\n\n-----問題ここまで----- */\n/* -----解説等-----\n\n\n\n----解説ここまで---- */\n\nvoid get_dist1(string &s, set<string>&a) {\n\ta.insert(s);\n\tFOR(i, 0, SZ(s)) {//delete\n\t\ta.insert(s.substr(0, i) + s.substr(i + 1));\n\t}\n\tFOR(i, 0, SZ(s) - 1) {//swap\n\t\tswap(s[i], s[i + 1]);\n\t\ta.insert(s);\n\t\tswap(s[i], s[i + 1]);\n\t}\n\tFOR(i, 0, SZ(s)) {//replace\n\t\tchar c = s[i];\n\t\tFOR(j, 0, 26) {\n\t\t\ts[i] = 'a' + j;\n\t\t\ta.insert(s);\n\t\t}\n\t\ts[i] = c;\n\t}\n\t//insert\n\tFOR(i, 0, 26)a.insert(s + (char)('a' + i));\n\tFOR(i, 0, SZ(s)) {\n\t\tFOR(j, 0, 26)\n\t\t\ta.insert(s.substr(0, i) + (char)('a' + j) + s.substr(i));\n\t}\n\n}\n\nvoid gen_set(string s, set<string> &d)\n{\n\td.clear();\n\n\t// delete\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tstring tmp;\n\t\tfor (int j = 0; j < s.length(); j++)\n\t\t\tif (i != j) tmp += s[j];\n\t\td.insert(tmp);\n\t}\n\n\t// insert\n\tfor (int i = 0; i <= s.length(); i++) {\n\t\tfor (char c = 'a'; c <= 'z'; c++) {\n\t\t\tstring tmp;\n\t\t\tfor (int j = 0; j < s.length(); j++) {\n\t\t\t\tif (i == j) tmp += c;\n\t\t\t\ttmp += s[j];\n\t\t\t}\n\t\t\tif (i == s.length()) tmp += c;\n\t\t\td.insert(tmp);\n\t\t}\n\t}\n\n\t// replace\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tfor (char c = 'a'; c <= 'z'; c++) {\n\t\t\tstring tmp = s;\n\t\t\ttmp[i] = c;\n\t\t\td.insert(tmp);\n\t\t}\n\t}\n\t//FOR(i, 0, SZ(s)) {//swap\n\t//\tFOR(j, i + 1, SZ(s)) {\n\t//\t\tswap(s[i], s[j]);\n\t//\t\td.insert(s);\n\t//\t\tswap(s[j], s[i]);\n\t//\t}\n\t//}\n\n\t// swap\n\tfor (int i = 0; i < s.length() - 1; i++) {\n\t\tstring tmp = s;\n\t\tswap(tmp[i], tmp[i + 1]);\n\t\td.insert(tmp);\n\t}\n\n\td.insert(s);\n}\n//int matching2(string&s, string&t) {\n//\t/* edit dist <=1を作成 */\n//\tset<string>a(get_dist1(s));\n//\tset<string>b(get_dist1(t));\n//\tfor (string s : a)if(b.find(s)!=b.end())return true;\n//\treturn false;\n//}\n//int matching2(string&s, string&t) {\n//\t/* edit dist <=1を作成 */\n//\tset<string>a(get_dist1(s));\n//\tint SZA = SZ(a);\n//\tset<string>b(get_dist1(t));\n//\tint SZB = SZ(b);\n//\tfor (string s : a)b.insert(s);\n//\tint SZM = SZ(b);\n//\tif (SZM == SZB + SZA)return false;\n//\telse return true;\n//}\n//int matching1(string&s, string&t) {\n//\t/* edit dist <=1を作成 */\n//\tset<string>b(get_dist1(s));\n//\tset<string>a; a.insert(t);\n//\tint SZB = SZ(b);\n//\tint SZA = SZ(a);\n//\tfor (string ss : a)b.insert(ss);\n//\tint SZM = SZ(b);\n//\tif (SZM == SZB + SZA)return false;\n//\telse return true;\n//}\n\nint matching(int i, int j, int d, const VS& vs, const vector<set<string>>&vseset) {\n\t/* edit dist <=1を作成 */\n\tif (d == 1) {\n\t\tif (vseset[i].find(vs[j]) != vseset[i].end())return true;\n\t\telse return false;\n\t}\n\telse {\n\t\tif (vseset[i].size() < vseset[j].size())swap(i, j);\n\t\tfor (string s : vseset[j]) {\n\t\t\tif (vseset[i].find(s) != vseset[i].end())return true;\n\t\t}\n\t\treturn false;\n\t}\n}\n//int matching(string &s, string &t, int d) {\n//\treturn (d == 1 ? matching1(s, t) : matching2(s, t));\n//}\nint N;\nint dp[17][17];\n//\n//int func_dp(string&s, string&t, int d) {\n//\tint SZ_S = SZ(s);\n//\tint SZ_T = SZ(t);\n//\tfill(*dp, *dp + 17 * 17, 100);\n//\t// 0はまだどれもswapしてない\n//\t/*VVI ruis(SZ_S + 1, VI(26, 0));\n//\tVVI ruit(SZ_T + 1, VI(26, 0));*/\n//\tFOR(i, 0, SZ_S + 1) {\n//\t\tdp[i][0] = i;\n//\t}\n//\tFOR(j, 0, SZ_T + 1) {\n//\t\tdp[0][j] = j;\n//\t}\n//\t/*FOR(i, 0, SZ_S) {\n//\t\tFOR(j, 0, 26)\n//\t\t\truis[i + 1][j] += ruis[i][j] + (s[i] == ('a' + j) ? 1 : 0);\n//\t}\n//\tFOR(i, 0, SZ_T) {\n//\t\tFOR(j, 0, 26)\n//\t\t\truis[i + 1][j] += ruis[i][j] + (t[i] == ('a' + j) ? 1 : 0);\n//\t}*/\n//\tint INDEX_T = 0;\n//\tint c = 0;\n//\tFOR(i, 1, SZ_S + 1) {\n//\t\tFOR(j, 1, SZ_T + 1) {\n//\t\t\tif (s[i] != t[j])c = 1;\n//\t\t\telse c = 0;\n//\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + c);\n//\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j] + c);\n//\t\t\tdp[i][j] = min(dp[i][j], dp[i][j - 1] + c);\n//\t\t}\n//\t}\n//\tFOR(k, 0, 26) {\n//\t\tif (dp[SZ_S][SZ_T] <= d)return 1;\n//\t}\n//\treturn 0;\n//}\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\twhile (cin >> N, N) {\n\t\tint d; cin >> d;\n\t\tVS orig(N);\n\t\tstring ss;\n\t\tvector<set<string>>vseset(N, set<string>());\n\t\tFOR(i, 0, N) {\n\t\t\tcin >> orig[i];\n\t\t\t//get_dist1(orig[i], vseset[i]);\n\t\t\tget_dist1(orig[i], vseset[i]);\n\t\t}\n\t\tvector<pair<string, string>>se;\n\t\tFOR(i, 0, N) {\n\t\t\tFOR(j, i + 1, N) {\n\t\t\t\tif (matching(i, j, d, orig, vseset)) {\n\t\t\t\t\tif (orig[i] < orig[j])\n\t\t\t\t\t\tse.push_back(pair<string, string>(orig[i], orig[j]));\n\t\t\t\t\telse\n\t\t\t\t\t\tse.push_back(pair<string, string>(orig[j], orig[i]));\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = SZ(se);\n\t\tSORT(se);\n\t\tFOR(i, 0, ans) {\n\t\t\tcout << se[i].first << \",\" << se[i].second << endl;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t//printf(\"%s\\n\", str);\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, d;\nvector<string> ss;\nset<pair<string, string> > ans;\nset<string> sset;\n\nvoid rec(string s, int i0, int d) {\n  if(sset.count(s) && s != ss[i0]) {\n    pair<string, string> p(s, ss[i0]);\n    if(p.first > p.second) swap(p.first, p.second);\n    ans.insert(p);\n  }\n  if(!d) return;\n  // Deleting\n  for(int i = 0; i < s.size(); ++i) {\n    string t = s;\n    t.erase(i);\n    rec(t, i0, d - 1);\n  }\n  // Inserting\n  for(int i = 0; i <= s.size(); ++i) {\n    for(char c = 'a'; c <= 'z'; ++c) {\n      string t = s;\n      t.insert(i, string(1, c));\n      rec(t, i0, d - 1);\n    }\n  }\n  // Replacing\n  for(int i = 0; i < s.size(); ++i) {\n    char tmp = s[i];\n    for(char c = 'a'; c <= 'z'; ++c) {\n      s[i] = c;\n      rec(s, i0, d - 1);\n    }\n    s[i] = tmp;\n  }\n  // Swapping\n  for(int i = 0; i < s.size(); ++i) {\n    for(int j = i + 1; j < s.size(); ++j) {\n      swap(s[i], s[j]);\n      rec(s, i0, d - 1);\n      swap(s[i], s[j]);\n    }\n  }\n}\n\nint main() {\n  while(cin >> n && n) {\n    cin >> d;\n    ss.resize(n);\n    sset.clear();\n    ans.clear();\n    for(int i = 0; i < n; ++i) {\n      cin >> ss[i];\n      sset.insert(ss[i]);\n    }\n    for(int i = 0; i < n; ++i) {\n      rec(ss[i], i, d);\n    }\n    for(set<pair<string, string> >::iterator it = ans.begin();\n        it != ans.end(); ++it) {\n      cout << it->first << \",\" << it->second << endl;\n    }\n    cout << ans.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint DamerauLevensteinDistance(string a,string b)\n{\n\tint m=a.size(),n=b.size();\n\tvvi dp(m+1,vi(n+1,INF));\n\trep(i,m+1) dp[i][0]=i;\n\trep(i,n+1) dp[0][i]=i;\n\tvi last(26,-1);\n\trep(i,m){\n\t\tint pj=-1;\n\t\trep(j,n){\n\t\t\tdp[i+1][j+1]=min({dp[i][j]+(a[i]!=b[j]),dp[i][j+1]+1,dp[i+1][j]+1});\n\t\t\tint pi=last[b[j]-'a'];\n\t\t\tif(pi!=-1 && pj!=-1)\n\t\t\t\tdp[i+1][j+1]=min(dp[i+1][j+1],dp[pi][pj]+(i-pi-1)+(j-pj-1)+1);\n\t\t\tif(a[i]==b[j]) pj=j;\n\t\t}\n\t\tlast[a[i]-'a']=i;\n\t}\n\treturn dp[m][n];\n}\n\nint main()\n{\n\tfor(int n,d;cin>>n>>d && n;){\n\t\tvs ws(n);\n\t\trep(i,n) cin>>ws[i];\n\t\t\n\t\tsort(all(ws));\n\t\t\n\t\tint cnt=0;\n\t\trep(i,n) repi(j,i+1,n)\n\t\t\tif(DamerauLevensteinDistance(ws[i],ws[j])<=d){\n\t\t\t\tcout<<ws[i]<<','<<ws[j]<<endl;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<string,string> P;\n\nint n,d;\nint ans=0;\nset<string> mp[201];\nint cnt[201][201];\nvector<P> vec;\nstring str[201];\n\nvoid dfs(int v,string s,int nd,int uk=0){\n\tif(nd==0){\n\t\tmp[v].insert(s);\n\t\tfor(int i=0;i+1<s.size();i++){\n\t\t\tswap(s[i],s[i+1]);\n\t\t\tdfs(v,s,nd+1);\n\t\t\tswap(s[i],s[i+1]);\n\t\t}\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tdfs(v,s.substr(0,i)+s.substr(i+1),nd+1);\n\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\tstring gu=\"\";\n\t\t\t\tgu+=('a'+j);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i+1),nd+1,1);\n\t\t\t\tdfs(v,s.substr(0,i)+gu+s.substr(i),nd+1,1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<26;i++){\n\t\t\tstring gu=\"\";\n\t\t\tgu+=('a'+i);\n\t\t\tdfs(v,s+gu,nd+1);\n\t\t}\n\t}else if(nd==1){\n\t\tmp[v].insert(s);\n\t}\n}\n\nvoid dfs2(int v,string s,int nd){\n\tif(nd==0){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(mp[i].find(s)!=mp[i].end()){\n\t\t\t\tcnt[v][i]++;\n\t\t\t\tcnt[i][v]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i+1<s.size();i++){\n\t\t\tswap(s[i],s[i+1]);\n\t\t\tdfs2(v,s,nd+1);\n\t\t\tswap(s[i],s[i+1]);\n\t\t}\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tdfs2(v,s.substr(0,i)+s.substr(i+1),nd+1);\n\t\t}\n\t\tfor(int i=0;i<26;i++){\n\t\t\tstring gu=\"\";\n\t\t\tgu+=('a'+i);\n\t\t\tdfs2(v,s+gu,nd+1);\n\t\t}\n\t}else if(nd==1){\n\t\tif(d==2){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(mp[i].find(s)!=mp[i].end()){\n\t\t\t\t\tcnt[v][i]++;\n\t\t\t\t\tcnt[i][v]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tvec.clear();\n\tfor(int i=0;i<n;i++){\n\t\tmp[i].clear();\n\t}\n\tscanf(\"%d\",&d);\n\tans=0;\n\tmemset(cnt,0,sizeof(cnt));\n\tfor(int i=0;i<n;i++){\n\t\tcin >> str[i];\n\t\tdfs(i,str[i],0);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tdfs2(i,str[i],0);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(cnt[i][j]>0){\n\t\t\t\tans++;\n\t\t\t\tvec.push_back(P(min(str[i],str[j]),max(str[i],str[j])));\n\t\t\t}\n\t\t}\n\t}\n\tsort(vec.begin(),vec.end());\n\tfor(int i=0;i<vec.size();i++){\n\t\tcout << vec[i].first << \",\" << vec[i].second << endl;\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define FOR(it,o)  for(__typeof((o).begin()) it =(o).begin();it != (o).end();it++)\n#define pb         push_back\n#define mp         make_pair\n\ntypedef pair<string,string> pss;\ntypedef vector<pss>         vpss;\nbool isok[200][200];\nvoid ed1(vector<string>&in,set<string> *S){\n  rep(i,in.size()){\n    REP(j,i+1,in.size()){\n      if (S[j].find(in[i]) != S[j].end()){\n\tisok[i][j] = true;\n      }\n    }    \n  }\n}\n\t \nvoid ed2(vector<string> &in,set<string> *S){\n  rep(i,in.size()){\n    REP(j,i+1,in.size()){\n      if (isok[i][j])continue;\n      FOR(it,S[i]){\n\tif (S[j].find(*it) != S[j].end()){\n\t  isok[i][j]=true;\n\t  break;\n\t}\n      }\n    }\n  }\n}\n\nvoid del_string(string &in,set<string>&S){\n  rep(i,in.size()){\n    string tmp = in;\n    tmp.erase(tmp.begin()+i);\n    S.insert(tmp);\n  }\n}\n\nvoid insert_string(string &in,set<string>&S){\n  rep(i,in.size()){\n    rep(j,26){\n      string tmp=in.substr(0,i);\n      tmp+=string(1,'a'+j);\n      tmp+=in.substr(i);\n      S.insert(tmp);\n    }\n  }\n}\n\nvoid replace_string(string &in,set<string>&S){\n  rep(i,in.size()){\n    char tmp = in[i];\n    rep(j,26){\n      in[i]='a'+j;\n      S.insert(in);\n    }\n    in[i]=tmp;\n  }\n}\n\nvoid swap_string(string&in,set<string>&S){\n  rep(i,(int)in.size()-1){\n    swap(in[i],in[i+1]);\n    S.insert(in);\n    swap(in[i],in[i+1]);\n  }\n}\n\nvoid make_string(vector<string>& in,set<string> *S){\n  rep(i,in.size()){\n    del_string(in[i],S[i]);\n    insert_string(in[i],S[i]);\n    replace_string(in[i],S[i]);\n    swap_string(in[i],S[i]);\n  }\n}\n\nvoid solve(vector<string>in,set<string>*S,int d){\n  int n=in.size();\n  make_string(in,S);\n  ed1(in,S);\n  if (d==2)ed2(in,S);\n  int cnt=0;\n  rep(i,n){\n    rep(j,n)if (isok[i][j])cnt++,cout<<in[i]<<\",\"<<in[j]<<endl;\n  }\n  cout << cnt << endl;\n}\n\nmain(){\n  int n,d;\n  while(cin>>n>>d && n){\n    vector<string> in;\n    rep(i,n)rep(j,n)isok[i][j]=false;\n    set<string> S[n];\n    rep(i,n){\n      string tmp;\n      cin>>tmp;\n      in.pb(tmp);\n    }\n    sort(ALL(in));\n    solve(in,S,d);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<string,string> P;\nconst int M=1000000007;\nclass RH {\npublic:\n  unsigned long long p[111],h[111];\n  int n;\n  void init(string s) {\n    n=s.size();\n    p[0]=1;h[0]=0;\n    for(int i=0; i<n; i++) {\n      h[i+1]=h[i]*M+s[i];\n      p[i+1]=p[i]*M;\n    }\n  }\n  unsigned long long H() {\n    return h[n];\n  }\n};\nmap<unsigned long long,vector<string> > m;\n\nvoid change(string s) {\n  int n=s.size();\n  for(int i=0; i<n; i++) {\n    string t=s.substr(0,i)+s.substr(i+1);\n    RH r;\n    r.init(t);\n    m[r.H()].push_back(s);\n    for(int j=0; j<26; j++) {\n      t=s;\n      t[i]='a'+j;\n      r.init(t);\n      m[r.H()].push_back(s);\n    } \n  }\n  for(int i=0; i<=n; i++) {\n    for(int j=0; j<26; j++) {\n      string t=s.substr(0,i)+(char)('a'+j)+s.substr(i);\n      RH r;\n      r.init(t);\n      m[r.H()].push_back(s);\n    }\n  }\n  for(int i=0; i<n-1; i++) {\n    swap(s[i],s[i+1]);\n    RH r;\n    r.init(s);\n    swap(s[i],s[i+1]);\n    m[r.H()].push_back(s);\n  }\n}\nint main() {\n  int n;\n  while(cin >> n && n) {\n    m.clear();\n    int d;\n    cin >> d;\n    string s[n];\n    for(int i=0; i<n; i++) {\n      cin >> s[i];\n      change(s[i]);\n    }\n    vector<P> ans;\n    if(d==1) {\n      for(int i=0; i<n; i++) {\n        RH r;\n        r.init(s[i]);\n        vector<string> v=m[r.H()];\n        for(int j=0; j<v.size(); j++) {\n          if(s[i]==v[j]) continue;\n          P p=P(s[i],v[j]);\n          if(p.first>p.second) swap(p.first,p.second);\n          ans.push_back(p);\n        }\n      }\n    } else {\n      for(map<unsigned long long,vector<string> >::iterator it=m.begin(); it!=m.end(); it++) {\n        vector<string> v=it->second;\n        sort(v.begin(),v.end());\n        v.erase(unique(v.begin(),v.end()),v.end());\n        for(int i=0; i<v.size(); i++) {\n          for(int j=i+1; j<v.size(); j++) {\n            ans.push_back(P(v[i],v[j]));\n          }\n        }\n      }\n    }\n    sort(ans.begin(),ans.end());\n    ans.erase(unique(ans.begin(),ans.end()),ans.end());\n    for(int i=0; i<ans.size(); i++) cout << ans[i].first << \",\" << ans[i].second << endl;\n    cout << ans.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nint damerau_levenshtein_distance(const string &a,const string &b){\n    //unordered_map<int,int> da;\n    //unordered_map<int,map<int,int>> d;\n    vector<int> da_(26);\n    vector<vector<int>> d_(a.size()+2,vector<int>(b.size()+2));\n    auto da=[&](int i)->int&{\n        return da_[i-'a'];\n    };\n    auto d=[&](int i,int j)->int&{\n        return d_[i+1][j+1];\n    };\n    int maxdist=a.size()+b.size();\n    d(-1,-1)=maxdist;\n    for(int i=0; i<=a.size(); ++i){\n        d(i,-1)=maxdist;\n        d(i,0)=i;\n    }\n    for(int i=0; i<=b.size(); ++i){\n        d(-1,i)=maxdist;\n        d(0,i)=i;\n    }\n    for(int i=1; i<=a.size(); ++i){\n        int db=0;\n        for(int j=1; j<=b.size(); ++j){\n            int k=da(b[j-1]),l=db,cost;\n            if(a[i-1]==b[j-1]){\n                cost=0;\n                db=j;\n            }else cost=1;\n            d(i,j)=min({d(i-1,j-1)+cost,d(i,j-1)+1,d(i-1,j)+1,d(k-1,l-1)+(i-k-1)+1+(j-l-1)});\n        }\n        da(a[i-1])=i;\n    }\n    return d(a.size(),b.size());\n}\n\nvoid solve(int n){\n    int d;\n    vector<string> name(n);\n    cin >> d;\n    rep(i,0,n) cin >> name[i];\n    sort(name.begin(),name.end());\n\n    int count=0;\n    rep(i,0,n){\n        rep(j,i+1,n){\n            if(damerau_levenshtein_distance(name[i],name[j])>d) continue;\n            ++count;\n            cout << name[i] << \",\" << name[j] << endl;\n        }\n    }\n    cout << count << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 99999883\n\nstruct Info{\n\tchar buf[20];\n};\n\nstruct Data{\n\tchar left[20],right[20];\n};\n\nint N,DIST;\nInfo info[200];\nvector<Info> V[200];\nmap<ull,bool> MAP[200];\nbool check[200][200];\n\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nint strCmp2(char* left,char* right){\n\tint i;\n\n\tif(strCmp(left,right))return 3;\n\n\tfor(i=0;left[i] != '\\0' && right[i] != '\\0'; i++){\n\t\tif(left[i] != right[i]){\n\t\t\tif(left[i] < right[i])return 1;\n\t\t\telse{\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\t}\n\tif(left[i] == '\\0')return 1;\n\telse{\n\t\treturn 2;\n\t}\n}\n\null makeCode(char buf[20]){\n\n\tint length;\n\tfor(length = 0; buf[length] != '\\0'; length++);\n\n\tull ret = 0;\n\n\tfor(int i = 0; i < length; i++){\n\t\tret = buf[i] + ret*NUM;\n\t}\n\treturn ret;\n}\n\nvoid makeDist1(int id){\n\n\tchar work[20];\n\n\tint length,index;\n\tfor(length = 0; info[id].buf[length] != '\\0'; length++);\n\n\tMAP[id][makeCode(info[id].buf)] = true;\n\n\tfor(int del_loc = 0; del_loc < length; del_loc++){\n\t\tindex = 0;\n\t\tfor(int i = 0; i < length; i++){\n\t\t\tif(i == del_loc)continue;\n\t\t\twork[index++] = info[id].buf[i];\n\t\t}\n\t\twork[index] = '\\0';\n\t\tInfo new_info;\n\t\tstrcpy(new_info.buf,work);\n\t\tV[id].push_back(new_info);\n\t}\n\n\tfor(int word = 0; word < 26; word++){\n\t\tfor(int loc = 0; loc <= length; loc++){\n\t\t\tindex = 0;\n\t\t\tfor(int i = 0; i < loc; i++){\n\t\t\t\twork[index++] = info[id].buf[i];\n\t\t\t}\n\t\t\twork[index++] = 'a'+word;\n\t\t\tfor(int i = loc; i < length; i++){\n\t\t\t\twork[index++] = info[id].buf[i];\n\t\t\t}\n\t\t\twork[index] = '\\0';\n\t\t\tInfo new_info;\n\t\t\tstrcpy(new_info.buf,work);\n\t\t\tV[id].push_back(new_info);\n\t\t}\n\t}\n\n\tfor(int word = 0; word < 26; word++){\n\t\tfor(int loc = 0; loc < length; loc++){\n\t\t\tindex = 0;\n\t\t\tfor(int i = 0; i < length; i++){\n\t\t\t\tif(i != loc){\n\t\t\t\t\twork[index++] = info[id].buf[i];\n\t\t\t\t}else{\n\t\t\t\t\twork[index++] = 'a'+word;\n\t\t\t\t}\n\t\t\t}\n\t\t\twork[index] = '\\0';\n\t\t\tInfo new_info;\n\t\t\tstrcpy(new_info.buf,work);\n\t\t\tV[id].push_back(new_info);\n\t\t}\n\t}\n\n\tfor(int a = 0; a < length-1; a++){\n\t\tint b = a+1;\n\t\tindex = 0;\n\t\tfor(int i = 0; i < length; i++){\n\t\t\twork[index++] = info[id].buf[i];\n\t\t}\n\t\tswap(work[a],work[b]);\n\t\twork[index] = '\\0';\n\t\tInfo new_info;\n\t\tstrcpy(new_info.buf,work);\n\t\tV[id].push_back(new_info);\n\t}\n\n\tfor(int i = 0; i < V[id].size(); i++){\n\t\tMAP[id][makeCode(V[id][i].buf)] = true;\n\t}\n}\n\nvoid func(){\n\n\tscanf(\"%d\",&DIST);\n\n\tfor(int i = 0; i < N; i++){\n\t\tV[i].clear();\n\t\tMAP[i].clear();\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%s\",info[i].buf);\n\t\tmakeDist1(i);\n\t}\n\n\tvector<Data> ANS;\n\n\tfor(int i = 0; i < N-1; i++){\n\t\tfor(int k = i+1; k < N; k++)check[i][k] = false;\n\t}\n\n\tif(DIST == 1){\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int p = i+1; p < N; p++){\n\t\t\t\tfor(int k = 0; k < V[i].size(); k++){\n\t\t\t\t\tif(strCmp(V[i][k].buf,info[p].buf)){\n\t\t\t\t\t\tcheck[i][p] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}else{\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int p = i+1; p < N; p++){\n\t\t\t\tfor(int k = 0; k < V[i].size(); k++){\n\t\t\t\t\tauto at = MAP[p].find(makeCode(V[i][k].buf));\n\t\t\t\t\tif(at != MAP[p].end()){\n\t\t\t\t\t\tcheck[i][p] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N-1; i++){\n\t\tfor(int p = i+1; p < N; p++){\n\t\t\tif(check[i][p]){\n\t\t\t\tData data;\n\t\t\t\tif(strCmp2(info[i].buf,info[p].buf) == 1){\n\t\t\t\t\tstrcpy(data.left,info[i].buf);\n\t\t\t\t\tstrcpy(data.right,info[p].buf);\n\t\t\t\t}else{\n\t\t\t\t\tstrcpy(data.right,info[i].buf);\n\t\t\t\t\tstrcpy(data.left,info[p].buf);\n\t\t\t\t}\n\t\t\t\tANS.push_back(data);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i < ANS.size(); i++){\n\t\tfor(int k = ANS.size()-1; k >= i; k--){\n\t\t\tif(strCmp2(ANS[k].left,ANS[k-1].left) == 1){\n\t\t\t\tswap(ANS[k],ANS[k-1]);\n\t\t\t}else if(strCmp2(ANS[k].left,ANS[k-1].left) == 3 && strCmp2(ANS[k].right,ANS[k-1].right) == 1){\n\t\t\t\tswap(ANS[k],ANS[k-1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < ANS.size(); i++){\n\t\tprintf(\"%s,%s\\n\",ANS[i].left,ANS[i].right);\n\t}\n\tprintf(\"%lld\\n\",ANS.size());\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1252: Confusing Login Names\n// 2017.10.12 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define ABS(a) ((a)>=0?(a):-(a))\n\ntypedef struct { char *s; int w; } T;\nT nm[202];\nchar name[202][18];\nint M[20][20];\n\nint cmp(T *a, T *b) { return strcmp(a->s, b->s); }\n\nint distance(char *s1, int w1, char *s2, int w2)\n{\n    int  i, j;\n\n    for (j = 0; j <= w1; j++) M[j][0] = j;\n    for (i = 0; i <= w2; i++) M[0][i] = i;\n    for (j = 1; j <= w1; j++) {\n        for (i = 1; i <= w2; i++) {\n            int d, min;\n            d = (s1[j-1] != s2[i-1]);\n            min =     M[j-1][i  ] + 1;\n            if (min > M[j  ][i-1] + 1) min = M[j  ][i-1] + 1;\n            if (min > M[j-1][i-1] + d) min = M[j-1][i-1] + d;\n            M[j][i] = min;\n        }\n    }\n    return M[w1][w2];\n}\n\nint check(char *s1, int w1, char *s2, int w2, int d)\n{\n\tchar *t1, *t2;\n\n\tif (ABS(w1-w2) > d) return 0;\n\tif (distance(s1, w1, s2, w2) <= d) return 1;\n\n\tt1 = s1, t2 = s2;\n\tif (d == 1) {\n\t\tif (w1 != w2) return 0;\n\t\twhile (*s1 == *s2) s1++, s2++;\n\t\tif (*s1 == *(s2+1) && *s2 == *(s1+1)) return strcmp(s1+2, s2+2) == 0;\n\t\treturn 0;\n\t}\n\n\ts1 = t1, s2 = t2; while (*s1 == *s2) s1++, s2++;\n\tif (*s1 == *(s2+1) && *s2 == *(s1+1)) {\n\t\ts1 += 2, s2 += 2;\n\t\tif (distance(s1, w1-(s1-t1), s2, w2-(s2-t2)) < d) return 1;\n\t\tif (w1 != w2) return 0;\n\t\twhile (*s1 == *s2) s1++, s2++;\n\t\tif (*s1 == *(s2+1) && *s2 == *(s1+1)) return strcmp(s1+2, s2+2) == 0;\n\t\treturn 0;\n\t}\n\tif (*s1 == *(s2+1) && *s2 == *(s1+2)) return strcmp(s1+3, s2+2) == 0;\n\tif (*s1 == *(s2+2) && *s2 == *(s1+1)) return strcmp(s1+2, s2+3) == 0;\n\n\ts1 = t1+w1, s2 = t2+w2;\n\twhile (*s1 == *s2) s1--, s2--;\n\tif (s2 > t2 && s1 > t1 && *s1 == *(s2-1) && *s2 == *(s1-1)) {\n\t\ts1 -= 2, s2 -= 2;\n\t\treturn distance(t1, s1-t1+1, t2, s2-t2+1) < d;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint n, d, i, j, ans;\n\tchar buf[22];\n\n\twhile (fgets(buf, 20, stdin) && *buf != '0') {\n\t\tn = atoi(buf);\n\t\tfgets(buf, 20, stdin), d = atoi(buf);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfgets(name[i], 17, stdin);\n\t\t\tnm[i].s = name[i], nm[i].w = strlen(name[i])-1, name[i][nm[i].w] = 0;\n\t\t}\n\t\tqsort(nm, n, sizeof(T), cmp);\n\t\tfor (ans = 0, i = 0; i < n; i++) for (j = i+1; j < n; j++) {\n\t\t\tif (check(nm[i].s, nm[i].w, nm[j].s, nm[j].w, d)) {\n\t\t\t\tprintf(\"%s,%s\\n\", nm[i].s, nm[j].s), ans++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1252: Confusing Login Names\n// 2017.10.12 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MIN(a,b) ((a)<=(b)?(a):(b))\n\ntypedef struct { char *s1, *s2; } T;\nT tbl[202]; int sz;\n\ntypedef struct { char *s; } S;\nS nm[202];\nchar name[202][18];\nint M[20][20];\n\nint cmp1(S *a, S *b)\n{\n\treturn strcmp(a->s, b->s);\n}\n\nint cmp2(T *a, T *b)\n{\n\tint k;\n\n\tif ((k = strcmp(a->s1, b->s1)) != 0) return k;\n\treturn strcmp(a->s2, b->s2);\n}\n\nvoid calc(char *s1, int i, char *s2, int j)\n{\n\tint k;\n\n\tif (s1[i] == s2[j]) M[i][j] = M[i-1][j-1];\n\telse M[i][j] = MIN(M[i-1][j-1], MIN(M[i-1][j], M[i][j-1])) + 1;\n\n\tif (j >= 2) for (k = 1; k < i; k++) {\n\t\tif (s1[i-k] == s2[j] && s1[i] == s2[j-1])\n\t\t\tM[i][j] = MIN(M[i][j], M[i-k-1][j-2] + k);\n\t}\n\tif (i >= 2) for (k = 1; k < j; k++) {\n\t\tif (s1[i] == s2[j-k] && s1[i-1] == s2[j])\n\t\t\tM[i][j] = MIN(M[i][j], M[i-2][j-k-1] + k);\n    }\n}\n\nint distance(char *str1, char *str2)\n{\n    int i, j, k;\n    int len1 = strlen(str1);\n    int len2 = strlen(str2);\n\n\tM[0][0] = 0;\n    for (i = 1; i < len1; i++) M[i][0] = i;\n    for (j = 1; j < len2; j++) M[0][j] = j;\n    for (k = 1; k < MIN(len1, len2); k++) {\n\t\tcalc(str1, k, str2, k);\n        for (i = k+1; i < len1; i++) calc(str1, i, str2, k);\n\t\tfor (j = k+1; j < len2; j++) calc(str1, k, str2, j);\n    }\n    return M[len1-1][len2-1];\n}\n\nint main()\n{\n\tint n, d, i, j;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tscanf(\"%d\", &d);\n\t\tsz = 0;\n\t\tfor (i = 0; i < n; i++) scanf(\"%s\", name[i]), nm[i].s = name[i];\n\t\tqsort(nm, n, sizeof(S), cmp1);\n\n\t\tfor (i = 0; i < n; i++) for (j = i+1; j < n; j++) {\n\t\t\tif (distance(nm[i].s, nm[j].s) <= d) \n\t\t\t\ttbl[sz].s1 = nm[i].s, tbl[sz++].s2 = nm[j].s;\n\t\t}\n\t\tqsort(tbl, sz, sizeof(T), cmp2);\n\t\tfor (i = 0; i < sz; i++) printf(\"%s,%s\\n\", tbl[i].s1, tbl[i].s2);\n\t\tprintf(\"%d\\n\", sz);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1252: Confusing Login Names\n// 2017.10.12 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MIN(a,b) ((a)<=(b)?(a):(b))\n#define MAX(a,b) ((a)>=(b)?(a):(b))\n#define ABS(a) ((a)>=0?(a):-(a))\n\ntypedef struct { char *s; int w; } S;\nS nm[202];\nchar name[202][18];\nint M[20][20];\n\nint cmp(S *a, S *b) { return strcmp(a->s, b->s); }\n\nint distance(char *s1, int w1, char *s2, int w2)\n{\n    int  i, j;\n\n    for (j = 0; j <= w1; j++) M[j][0] = j;\n    for (i = 0; i <= w2; i++) M[0][i] = i;\n    for (j = 1; j <= w1; j++) {\n        for (i = 1; i <= w2; i++) {\n            int d, min;\n            d = (s1[j-1] != s2[i-1]);\n            min =     M[j-1][i  ] + 1;\n            if (min > M[j  ][i-1] + 1) min = M[j  ][i-1] + 1;\n            if (min > M[j-1][i-1] + d) min = M[j-1][i-1] + d;\n            M[j][i] = min;\n        }\n    }\n    return M[w1][w2];\n}\n\nint check(char *s1, int w1, char *s2, int w2, int d)\n{\n\tchar *t1, *t2, x;\n\tchar buf[50];\n\n\tif (ABS(w1-w2) > d) return 0;\n\tif (distance(s1, w1, s2, w2) <= d) return 1;\n\n\tmemcpy(buf, s1, w1+1); t1 = s1 = buf, t2 = s2;\n\n\tif (d == 1) {\n\t\tif (w1 != w2) return 0;\n\t\twhile (*s1 == *s2) s1++, s2++;\n\t\tif (*s1 == *(s2+1) && *s2 == *(s1+1)) return strcmp(s1+2, s2+2) == 0;\n\t\treturn 0;\n\t}\n\n\ts1 = t1, s2 = t2; while (*s1 == *s2) s1++, s2++;\n\tif (*s1 == *(s2+1) && *s2 == *(s1+1)) {\n\t\tx = *s1, *s1 = *(s1+1), *(s1+1) = x;\n\t\tif (distance(t1, w1, t2, w2) < d) return 1;\n\t\tif (w1 != w2) return 0;\n\t\twhile (*s1 == *s2) s1++, s2++;\n\t\tif (*s1 == *(s2+1) && *s2 == *(s1+1)) return strcmp(s1+2, s2+2) == 0;\n\t\treturn 0;\n\t}\n\tif (*s1 == *(s2+1) && *s2 == *(s1+2))\n\t\treturn strcmp(s1+3, s2+2) == 0;\n\tif (*s1 == *(s2+2) && *s2 == *(s1+1))\n\t\treturn strcmp(s1+2, s2+3) == 0;\n\n\ts1 = t1+w1, s2 = t2+w2;\n\twhile (*s1 == *s2) s1--, s2--;\n\tif (s2 > t2 && s1 > t1 && *s1 == *(s2-1) && *s2 == *(s1-1)) {\n\t\tx = *s1, *s1 = *(s1-1), *(s1-1) = x;\n\t\treturn distance(t1, w1, t2, w2) < d;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint n, d, i, j, ans;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tscanf(\"%d\", &d);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tscanf(\"%s\", name[i]);\n\t\t\tnm[i].s = name[i], nm[i].w = strlen(name[i]);\n\t\t}\n\t\tqsort(nm, n, sizeof(S), cmp);\n\t\tfor (ans = 0, i = 0; i < n; i++) for (j = i+1; j < n; j++) {\n\t\t\tif (check(nm[i].s, nm[i].w, nm[j].s, nm[j].w, d)) {\n\t\t\t\tprintf(\"%s,%s\\n\", nm[i].s, nm[j].s), ans++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1252\n  Title:Confusing Login Name\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#define diff(x,y) (((x)>(y))?((x)-(y)):((y)-(x)))\nint n,d;\nchar name[200][16];\nint ans [19900][2];\n\n\ncomp_word_pair(void * w1,void * w2)\n{\n  int ret;\n\n  ret=strcmp(&name[((int *)w1)[0]][0],&name[((int *)w2)[0]][0]);\n  if(ret!=0)\n    return(ret);\n  ret=strcmp(&name[((int *)w1)[1]][0],&name[((int *)w2)[1]][0]);\n  return(ret);\n}\n\nvoid swap_alpha1(int a[2])\n{\n  int wk;\n  if(0<strcmp(&name[a[0]][0],&name[a[1]][0]))\n    {\n      wk=a[1];\n      a[1]=a[0];\n      a[0]=wk;\n    }\n}\nvoid swap_alpha_all(int a[][2],int ans_cnt)\n{\n  int i;\n  for(i=0;i<ans_cnt;i++)\n    swap_alpha1(&a[i][0]);\n}\n\npretty_print(int a[][2],int ans_cnt)\n{\n  int i;\n  swap_alpha_all(a,ans_cnt);\n  qsort(a,ans_cnt,sizeof(int)*2,comp_word_pair);\n  for(i=0;i<ans_cnt;i++)\n    printf(\"%s,%s\\n\",name[a[i][0]],name[a[i][1]]);\n  printf(\"%d\\n\",ans_cnt);\n}\n\nstruct x_st \n{\n  char len1;\n  char len2;\n  char cmp_cnt;\n  char cmp_off[2][2];\n  char next1;\n  char next2;\n  int  dist_use;\n}  \ntable[]  ={{0,0,1,0,0,0,0,1,1,0},\n\t   {0,1,0,0,0,0,0,0,1,1},\n\t   {1,0,0,0,0,0,0,1,0,1},\n\t   {1,1,0,0,0,0,0,1,1,1},\n\t   {2,2,2,0,1,1,0,2,2,1},\n\t   {3,2,2,0,1,2,0,3,2,2},\n\t   {2,3,2,1,0,0,2,2,3,2}\n};\nint check(char s1[],char s2[],int dist,int lv,int met)\n{\n  int l1,l2;\n  int ret;\n  int i,j;\n\n  l1=strlen(s1);\n  l2=strlen(s2);\n  if(0==strcmp(s1,s2))\n    ret=1;\n  else if(dist<=0)\n    ret=0;\n  else if(diff(l1,l2)>dist)\n    ret=0;\n  else if(l1<=1 && l2<=1 && dist>0)\n    ret=1;\n  else\n    {\n      ret=0;\n      for(i=0;i<7 && ret==0;i++)\n\t{\n\t  if((l1<table[i].len1) || (l2<table[i].len2) || \\\n\t     (dist < table[i].dist_use))\n\t      goto NEXT;\n\n\t  for(j=0;j<table[i].cmp_cnt;j++)\n\t    if(s1[table[i].cmp_off[j][0]]!=s2[table[i].cmp_off[j][1]])\n\t      goto NEXT;\n\t  ret=check(s1+table[i].next1,s2+table[i].next2,\n\t\t    dist-table[i].dist_use,lv+1,i+1);\n\tNEXT:;\n\t}\n    }\n  return(ret);\n}\n\nint solve(char name[][16],int ans[][2])\n{\n  int i,j,ans_cnt;\n\n  ans_cnt=0;\n  for(i=0;i<n-1;i++)\n    for(j=i+1;j<n;j++)\n      if(check(&name[i][0],&name[j][0],d,0,0))\n\t{\n\t  ans[ans_cnt][0]=i;\n\t  ans[ans_cnt][1]=j;\n\t  ans_cnt++;\n\t}\n  return(ans_cnt);\n}\n\nmain()\n{\n  int i,ans_cnt;\n  while(scanf(\"%d\",&n)  && n)\n    {\n\n      scanf(\"%d\",&d);\n      for(i=0;i<n;i++)\n\tscanf(\"%s\",&name[i][0]);\n      ans_cnt=solve(name,ans);\n      pretty_print(ans,ans_cnt);\n    }\n  return(0);\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n    static HashMap<String,HashSet<String>> map;\n\n    public static void delChar(String s){\n        int n = s.length();\n\n        for(int i=0;i<n;i++){\n            String ss = s.substring(0,i) + s.substring(i+1);\n            if(!map.containsKey(ss)) map.put(ss,new HashSet<String>());\n            map.get(ss).add(s);\n        }\n    }\n\n    public static void insChar(String s){\n        int n = s.length();\n\n        for(int i=0;i<=n;i++){\n            for(int j=0;j<26;j++){\n                String ss = s.substring(0,i) + (char)('a' + j) + s.substring(i);\n                if(!map.containsKey(ss)) map.put(ss,new HashSet<String>());\n                map.get(ss).add(s);\n            }\n        }\n    }\n\n    public static void repChar(String s){\n        int n = s.length();\n\n        for(int i=0;i<n;i++){\n            for(int j=0;j<26;j++){\n                String ss = s.substring(0,i) + (char)('a' + j) + s.substring(i+1);\n                if(!map.containsKey(ss)) map.put(ss,new HashSet<String>());\n                map.get(ss).add(s);\n            }\n        }\n    }\n\n    public static void swapChar(String s){\n        int n = s.length();\n\n        for(int i=0;i<n-1;i++){\n            String ss = s.substring(0,i) + s.charAt(i+1) + s.charAt(i) + s.substring(i+2);\n            if(!map.containsKey(ss)) map.put(ss,new HashSet<String>());\n            map.get(ss).add(s);\n        }\n    }\n\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            int n = sc.nextInt();\n            if(n == 0) break;\n\n            int d = sc.nextInt();\n            String[] s = new String[n];\n\n            for(int i=0;i<n;i++){\n                s[i] = sc.next();\n            }\n\n            map = new HashMap<String,HashSet<String>>();\n\n            Arrays.sort(s);\n\n            for(int i=0;i<n;i++){\n                delChar(s[i]);\n                insChar(s[i]);\n                repChar(s[i]);\n                swapChar(s[i]);\n            }\n\n            int cnt = 0;\n            TreeSet<SS> ans = new TreeSet<SS>();\n\n            for(int i=0;i<n;i++){\n                if(!map.containsKey(s[i])) continue;\n                ArrayList<String> al = new ArrayList<String>(map.get(s[i]));\n                for(int j=0;j<al.size();j++){\n                    if(s[i].equals(al.get(j))) continue;\n                    ans.add(new SS(s[i],al.get(j)));\n                }\n                map.remove(s[i]);\n            }\n\n            if(d == 2){\n                for(String ss : map.keySet()){\n                    ArrayList<String> al = new ArrayList<String>(map.get(ss));\n                    for(int j=0;j<al.size();j++){\n                        for(int k=j+1;k<al.size();k++){\n                            ans.add(new SS(al.get(j),al.get(k)));\n                        }\n                    }\n                }\n            }\n\n            for(SS ss : ans){\n                System.out.println(ss.a + \",\" + ss.b);\n            }\n            System.out.println(ans.size());\n        }\n    }\n}\n\nclass SS implements Comparable<SS>{\n    String a,b;\n\n    public SS(String a,String b){\n        if(a.compareTo(b) < 0){\n            this.a = a;\n            this.b = b;\n        }\n        else{\n            this.a = b;\n            this.b = a;\n        }\n    }\n\n    public int compareTo(SS s){\n        if(a.equals(s.a)){\n            return b.compareTo(s.b);\n        }\n        return a.compareTo(s.a);\n    }\n\n    public boolean equals(SS s){\n        return this.a.equals(s.a) && this.b.equals(s.b);\n    }\n\n    public int hashCode(){\n        return a.hashCode() * b.hashCode(); \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\t//long start=System.currentTimeMillis();\n\t\tnew AOJ1252();\n\t\t//System.out.println(\" [\"+ (System.currentTimeMillis()-start) +\"msec]\");\n\t}\n\t\n\t// Confusing Login Names\n\tclass AOJ1252{\n\t\tAOJ1252(){\n\t\t\twhile(true){\n\t\t\t\tint N=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tsolve(N);\n\t\t\t}\n\t\t}\n\t\tvoid solve(int N){\n\t\t\tint D=sc.nextInt();\n\t\t\tString[] names=new String[N];\n\t\t\tfor(int i=0; i<N; i++)\tnames[i]=sc.next();\n\t\t\tArrays.sort(names);\n\t\t\tArrayList<TreeSet<String>> state1=new ArrayList<TreeSet<String>>(),state2=new ArrayList<TreeSet<String>>();\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tTreeSet<String> tmp=new TreeSet<String>();\n\t\t\t\tfor(int j=0; j<names[i].length(); j++){\n\t\t\t\t\ttmp.add(new StringBuilder(names[i]).deleteCharAt(j).toString());\n\t\t\t\t\tfor(int k=0; k<26; k++){\n\t\t\t\t\t\tchar c=(char)('a'+k);\n\t\t\t\t\t\ttmp.add(new StringBuilder(names[i]).insert(j, c).toString());\n\t\t\t\t\t\tStringBuilder sb=new StringBuilder(names[i]);\n\t\t\t\t\t\tsb.setCharAt(j, c);\n\t\t\t\t\t\ttmp.add(sb.toString());\n\t\t\t\t\t}\n\t\t\t\t\ttmp.add(swap(j,min(j+1,names[i].length()-1),names[i]));\n\t\t\t\t}\n\t\t\t\tfor(int k=0; k<26; k++)\ttmp.add(names[i]+(char)('a'+k));\n\t\t\t\t//System.out.println(tmp);\n\t\t\t\tstate1.add(tmp);\n\t\t\t}\n\t\t\tif(D>1)\tstate2=state1;\n\t\t\telse{\n\t\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t\tTreeSet<String> tmp=new TreeSet<String>();\n\t\t\t\t\ttmp.add(names[i]);\n\t\t\t\t\tstate2.add(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tTreeSet<Pair> ans=new TreeSet<Main.AOJ1252.Pair>();\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(int j=i+1; j<N; j++){\n\t\t\t\t\tif(names[i].length()-names[j].length()>4)\tcontinue;\n\t\t\t\t\tfor(String s:state1.get(i)){\n\t\t\t\t\t\tif(state2.get(j).contains(s))\tans.add(new Pair(names[i],names[j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(Pair p:ans)\tSystem.out.println(p);\n\t\t\tSystem.out.println(ans.size());\n\t\t}\n\t\tString swap(int a,int b,String str){\n\t\t\tStringBuilder sb=new StringBuilder(str);\n\t\t\tchar tmp=sb.charAt(a);\n\t\t\tsb.setCharAt(a, sb.charAt(b));\n\t\t\tsb.setCharAt(b, tmp);\n\t\t\treturn sb.toString();\n\t\t}\n\t\tclass Pair implements Comparable<Pair>{\n\t\t\tString s1,s2;\n\t\t\tPair(String s1,String s2){\n\t\t\t\tthis.s1=s1;\n\t\t\t\tthis.s2=s2;\n\t\t\t}\n\t\t\t@Override public int compareTo(Pair p){\n\t\t\t\tif(s1==p.s2 && s2==p.s1)\treturn 0;\n\t\t\t\treturn s1.compareTo(p.s1)!=0?s1.compareTo(p.s1) :s2.compareTo(p.s2);\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn s1+\",\"+s2;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t// Gap\n\tclass AOJ1245{\n\t\tAOJ1245(){\n\t\t\tint N=sc.nextInt();\n\t\t\twhile(--N>=0)\tsolve();\n\t\t}\n\t\tvoid solve(){\n\t\t\tStringBuilder init=new StringBuilder(),fin=new StringBuilder();\n\t\t\tfor(int i=1; i<=4; i++){\n\t\t\t\tinit.append(\"##\");\n\t\t\t\tfor(int j=1; j<=7; j++){\n\t\t\t\t\tinit.append(sc.nextInt());\n\t\t\t\t\tfin.append(i);\tfin.append(j);\n\t\t\t\t}\n\t\t\t\tfin.append(\"##\");\n\t\t\t}\n\t\t\tfor(int i=0; i<32; i++){\n\t\t\t\tif(init.charAt(i*2+1)=='1')\tnSwap(i*2,(init.charAt(i*2)-'0'-1)*16,init);\n\t\t\t}\n\t\t\tint ans=-1;\n\t\t\tPriorityQueue<State1> open=new PriorityQueue<State1>();\n\t\t\topen.add(new State1(init,0));\n\t\t\tHashMap<String,Integer> closed=new HashMap<String, Integer>();\n\t\t\tclosed.put(init.toString(),0);\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState1 now=open.poll();\n\t\t\t\tif(now.sb.toString().equals(fin.toString())){\n\t\t\t\t\tans=now.step;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<32; i++){\n\t\t\t\t\tif(now.sb.charAt(i*2)=='#' && now.sb.charAt((i-1)*2)!='#'){\n\t\t\t\t\t\tint s=now.sb.charAt((i-1)*2)-'0',v=now.sb.charAt((i-1)*2+1)-'0';\n\t\t\t\t\t\tif(v>=7)\tcontinue;\n\t\t\t\t\t\tboolean bf=false;\n\t\t\t\t\t\tfor(int j=0; j<32; j++){\n\t\t\t\t\t\t\tif(now.sb.charAt(j*2)-'0'==s && now.sb.charAt(j*2+1)-'0'==v+1){\n\t\t\t\t\t\t\t\tStringBuilder tmp=new StringBuilder(now.sb);\n\t\t\t\t\t\t\t\tnSwap(i*2,j*2,tmp);\n\t\t\t\t\t\t\t\tif(tmp.toString().equals(fin.toString())){\n\t\t\t\t\t\t\t\t\tans=now.step+1;\n\t\t\t\t\t\t\t\t\topen.clear();\n\t\t\t\t\t\t\t\t\tbf=true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(closed.containsKey(tmp.toString()) && closed.get(tmp.toString())<=now.step+1)\tbreak;\n\t\t\t\t\t\t\t\topen.add(new State1(tmp,now.step+1));\n\t\t\t\t\t\t\t\tclosed.put(tmp.toString(),now.step+1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(bf)\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\tvoid nSwap(int a,int b,StringBuilder sb){\n\t\t\tif(a==b)\treturn;\n\t\t\tswap(a,b,sb);\n\t\t\tswap(++a,++b,sb);\n\t\t}\n\t\tvoid swap(int a,int b,StringBuilder sb){\n\t\t\tchar tmp=sb.charAt(a);\n\t\t\tsb.setCharAt(a, sb.charAt(b));\n\t\t\tsb.setCharAt(b, tmp);\n\t\t}\n\t\tclass State1 implements Comparable<State1>{\n\t\t\tStringBuilder sb;\n\t\t\tint step;\n\t\t\tState1(StringBuilder sb,int step){\n\t\t\t\tthis.sb=sb;\tthis.step=step;\n\t\t\t}\n\t\t\t@Override public int compareTo(State1 o) {\n\t\t\t\treturn this.step-o.step;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ1258{\n\t\tfinal int INF=Integer.MAX_VALUE/4;\n\t\tAOJ1258(){\n\t\t\twhile(true){\n\t\t\t\tint M=sc.nextInt(),C=sc.nextInt(),N=sc.nextInt();\n\t\t\t\tif(((M|C)|N)==0)\tbreak;\n\t\t\t\tSystem.out.println(solve(M,C,N));\n\t\t\t}\n\t\t}\n\t\tint solve(int M,int C,int N){\n\t\t\tLinkedList<LinkedList<Integer>> q=new LinkedList<LinkedList<Integer>>();\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tq.add(new LinkedList<Integer>());\n\t\t\t\tint K=sc.nextInt();\n\t\t\t\tfor(int j=0; j<K; j++)\tq.getLast().add(sc.nextInt());\n\t\t\t}\n\t\t\tStore store=new Store(M,C);\n\t\t\tint ans=0;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint r=q.getFirst().poll();\n\t\t\t\tans+=store.take(r);\n\t\t\t\tans+=store.put(r);\n\t\t\t\t//debug\n\t\t\t\t//System.out.println(store);\n\t\t\t\tif(q.getFirst().isEmpty())\tq.removeFirst();\n\t\t\t\telse\tq.addLast(q.poll());\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t\tclass Store{\n\t\t\tint M,C,time;\n\t\t\tArrayList<ArrayList<Book>> desks;\n\t\t\tStore(int m,int c){\n\t\t\t\tthis.M=m;\tthis.C=c;\tthis.time=0;\n\t\t\t\tdesks=new ArrayList<ArrayList<Book>>();\n\t\t\t\tfor(int i=0; i<M; i++)\tdesks.add(new ArrayList<Book>());\n\t\t\t}\n\t\t\tint take(int r){\n\t\t\t\tint ret=M+1;\n\t\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\t\tfor(int j=0; j<desks.get(i).size(); j++){\n\t\t\t\t\t\tif(desks.get(i).get(j).id==r){\n\t\t\t\t\t\t\tdesks.get(i).remove(j);\n\t\t\t\t\t\t\tret=i+1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ret<M+1)\tbreak;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tint put(int r){\n\t\t\t\tint ret=M+1;\n\t\t\t\tif(desks.get(0).size()<C){\n\t\t\t\t\tdesks.get(0).add(new Book(r,time++));\n\t\t\t\t\tret=1;\n\t\t\t\t}else{\n\t\t\t\t\tret=0;\n\t\t\t\t\tPair tmpIdx=new Pair(M,0);\n\t\t\t\t\tfor(int i=1; i<M; i++){\n\t\t\t\t\t\tif(desks.get(i).size()<C){\n\t\t\t\t\t\t\ttmpIdx.first=i;\n\t\t\t\t\t\t\tdesks.get(i).add(new Book(INF,INF));\n\t\t\t\t\t\t\ttmpIdx.second=desks.get(i).size()-1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret+=tmpIdx.first+1;\n\t\t\t\t\tint oldestTime=desks.get(0).get(0).t,oldestIdx=0;\n\t\t\t\t\tfor(int i=1; i<desks.get(0).size(); i++){\n\t\t\t\t\t\tif(oldestTime>desks.get(0).get(i).t){\n\t\t\t\t\t\t\toldestTime=desks.get(0).get(i).t;\n\t\t\t\t\t\t\toldestIdx=i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tBook oldest=desks.get(0).remove(oldestIdx);\n\t\t\t\t\tret+=1;\n\t\t\t\t\tint empIdx=M;\n\t\t\t\t\tfor(int i=1; i<M; i++){\n\t\t\t\t\t\tif(desks.get(i).size()<C){\n\t\t\t\t\t\t\tdesks.get(i).add(oldest);\n\t\t\t\t\t\t\tempIdx=i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret+=empIdx+1;\n\t\t\t\t\tif(tmpIdx.first<M)\tdesks.get(tmpIdx.first).remove(tmpIdx.second);\n\t\t\t\t\tret+=tmpIdx.first+1;\n\t\t\t\t\tdesks.get(0).add(new Book(r,time++));\n\t\t\t\t\tret+=1;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t@Override public String toString(){return desks.toString();}\n\t\t}\n\t\tclass Book{\n\t\t\tint id,t;\n\t\t\tBook(int id,int t){this.id=id;this.t=t;}\n\t\t\t@Override public String toString(){return \"ID\"+id+\" T\"+t;}\n\t\t}\n\t\tclass Pair implements Comparable<Pair>{\n\t\t\tint first,second;\n\t\t\tPair(int first,int second){this.first=first; this.second=second;}\n\t\t\t@Override public String toString(){return \"(\"+first+\",\"+second+\")\";}\n\t\t\t@Override public int compareTo(Pair p){\n\t\t\t\tif(this.first<p.first)\treturn -1;\n\t\t\t\tif(this.first>p.first)\treturn 1;\n\t\t\t\tif(this.second<p.second)\treturn -1;\n\t\t\t\tif(this.second>p.second)\treturn 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t@Override public int hashCode(){\n\t\t\t\treturn 17+31*first+second;\n\t\t\t}\n\t\t\t@Override public boolean equals(Object obj){\n\t\t\t\tif(this==obj)\treturn true;\n\t\t\t\tif(obj==null)\treturn false;\n\t\t\t\tif(this.getClass() != obj.getClass())\treturn false;\n\t\t\t\tPair p=(Pair)obj;\n\t\t\t\tif(this.first==p.first&&this.second==p.second)\treturn true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ1262{\n\t\tfinal double INF=Double.MAX_VALUE/4.0;\n\t\tAOJ1262(){\n\t\t\twhile(true){\n\t\t\t\tint N=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tSystem.out.printf(\"%.4f\\n\",solve(N));\n\t\t\t}\n\t\t}\n\t\tdouble solve(int N){\n\t\t\tint[] a=new int[N+1];\n\t\t\tfor(int i=1; i<=N; i++)\ta[i]=sc.nextInt();\n\t\t\tdouble b=sc.nextDouble();\n\t\t\tint r=sc.nextInt();\n\t\t\tdouble v=sc.nextDouble(),e=sc.nextDouble(),f=sc.nextDouble();\n\t\t\tdouble[][] dp=new double[N+1][N+1];\n\t\t\tfor(int i=1; i<=N; i++)for(int j=0; j<=N; j++)dp[i][j]=INF;\n\t\t\t//flash(dp,N);\n\t\t\tdouble tmp=0.0;\n\t\t\tfor(int i=0; i<a[1]; i++)\ttmp+=exp(i,r,v,e,f);\n\t\t\tdp[1][0]=tmp;\n\t\t\tfor(int w=1; w<N; w++){\n\t\t\t\tfor(int h=0; h<w; h++){\n\t\t\t\t\tint d=a[w+1]-a[w],x=a[w]-a[h];\n\t\t\t\t\tdouble exp=0.0;\n\t\t\t\t\tfor(int i=0; i<d; i++)\texp+=exp(x++,r,v,e,f);\n\t\t\t\t\t//debug\n\t\t\t\t\t//System.out.println(exp);\n\t\t\t\t\tdp[w+1][h]=dp[w][h]+exp;\n\t\t\t\t\tdouble exp2=0.0;\n\t\t\t\t\tfor(int i=0; i<d; i++)\texp2+=exp(i,r,v,e,f);\n\t\t\t\t\tdp[w+1][w]=min(dp[w+1][w], dp[w][h]+exp2+b);\n\t\t\t\t}\n\t\t\t\t//debug\n\t\t\t\t//System.out.println(\"new \"+dp[w+1][w]);\n\t\t\t}\n\t\t\t//flash(dp,N);\n\t\t\tdouble ans=INF;\n\t\t\tfor(int i=0; i<=N; i++)\tans=min(ans,dp[N][i]);\n\t\t\treturn ans;\n\t\t}\n\t\tdouble exp(int x,double r,double v,double e,double f){\n\t\t\treturn x>=r?(1/(v-e*(x-r))):(1/(v-f*(r-x)));\n\t\t}\n\t\tvoid flash(double[][] dp,int N){\n\t\t\tfor(int y=0; y<=N; y++){\n\t\t\t\tfor(int x=0; x<=N; x++)\tSystem.out.printf(\"%3.3f \",dp[x][y]>=INF?-1:dp[x][y]);\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\t//long start=System.currentTimeMillis();\n\t\tnew AOJ1252();\n\t\t//System.out.println(\" [\"+ (System.currentTimeMillis()-start) +\"msec]\");\n\t}\n\t\n\t// Confusing Login Names\n\tclass AOJ1252{\n\t\tAOJ1252(){\n\t\t\twhile(true){\n\t\t\t\tint N=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tsolve(N);\n\t\t\t}\n\t\t}\n\t\tvoid solve(int N){\n\t\t\tint D=sc.nextInt();\n\t\t\tString[] names=new String[N];\n\t\t\tfor(int i=0; i<N; i++)\tnames[i]=sc.next();\n\t\t\tArrays.sort(names);\n\t\t\t//ArrayList<TreeSet<String>> state1=new ArrayList<TreeSet<String>>(),state2=new ArrayList<TreeSet<String>>();\n\t\t\tArrayList<HashSet<String>> state1=new ArrayList<HashSet<String>>(),state2=new ArrayList<HashSet<String>>();\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t//TreeSet<String> tmp=new TreeSet<String>();\n\t\t\t\tHashSet<String> tmp=new HashSet<String>();\n\t\t\t\tfor(int j=0; j<names[i].length(); j++){\n\t\t\t\t\ttmp.add(new StringBuilder(names[i]).deleteCharAt(j).toString());\n\t\t\t\t\tfor(int k=0; k<26; k++){\n\t\t\t\t\t\tchar c=(char)('a'+k);\n\t\t\t\t\t\ttmp.add(new StringBuilder(names[i]).insert(j, c).toString());\n\t\t\t\t\t\tStringBuilder sb=new StringBuilder(names[i]);\n\t\t\t\t\t\tsb.setCharAt(j, c);\n\t\t\t\t\t\ttmp.add(sb.toString());\n\t\t\t\t\t}\n\t\t\t\t\ttmp.add(swap(j,min(j+1,names[i].length()-1),names[i]));\n\t\t\t\t}\n\t\t\t\tfor(int k=0; k<26; k++)\ttmp.add(names[i]+(char)('a'+k));\n\t\t\t\t//System.out.println(tmp);\n\t\t\t\tstate1.add(tmp);\n\t\t\t}\n\t\t\tif(D>1)\tstate2=state1;\n\t\t\telse{\n\t\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t\t//TreeSet<String> tmp=new TreeSet<String>();\n\t\t\t\t\tHashSet<String> tmp=new HashSet<String>();\n\t\t\t\t\ttmp.add(names[i]);\n\t\t\t\t\tstate2.add(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tTreeSet<Pair> ans=new TreeSet<Main.AOJ1252.Pair>();\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(int j=i+1; j<N; j++){\n\t\t\t\t\tif(names[i].length()-names[j].length()>4)\tcontinue;\n\t\t\t\t\tfor(String s:state1.get(i)){\n\t\t\t\t\t\tif(state2.get(j).contains(s))\tans.add(new Pair(names[i],names[j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(Pair p:ans)\tSystem.out.println(p);\n\t\t\tSystem.out.println(ans.size());\n\t\t}\n\t\tString swap(int a,int b,String str){\n\t\t\tStringBuilder sb=new StringBuilder(str);\n\t\t\tchar tmp=sb.charAt(a);\n\t\t\tsb.setCharAt(a, sb.charAt(b));\n\t\t\tsb.setCharAt(b, tmp);\n\t\t\treturn sb.toString();\n\t\t}\n\t\tclass Pair implements Comparable<Pair>{\n\t\t\tString s1,s2;\n\t\t\tPair(String s1,String s2){\n\t\t\t\tthis.s1=s1;\n\t\t\t\tthis.s2=s2;\n\t\t\t}\n\t\t\t@Override public int compareTo(Pair p){\n\t\t\t\tif(s1==p.s2 && s2==p.s1)\treturn 0;\n\t\t\t\treturn s1.compareTo(p.s1)!=0?s1.compareTo(p.s1) :s2.compareTo(p.s2);\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn s1+\",\"+s2;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t// Gap\n\tclass AOJ1245{\n\t\tAOJ1245(){\n\t\t\tint N=sc.nextInt();\n\t\t\twhile(--N>=0)\tsolve();\n\t\t}\n\t\tvoid solve(){\n\t\t\tStringBuilder init=new StringBuilder(),fin=new StringBuilder();\n\t\t\tfor(int i=1; i<=4; i++){\n\t\t\t\tinit.append(\"##\");\n\t\t\t\tfor(int j=1; j<=7; j++){\n\t\t\t\t\tinit.append(sc.nextInt());\n\t\t\t\t\tfin.append(i);\tfin.append(j);\n\t\t\t\t}\n\t\t\t\tfin.append(\"##\");\n\t\t\t}\n\t\t\tfor(int i=0; i<32; i++){\n\t\t\t\tif(init.charAt(i*2+1)=='1')\tnSwap(i*2,(init.charAt(i*2)-'0'-1)*16,init);\n\t\t\t}\n\t\t\tint ans=-1;\n\t\t\tPriorityQueue<State1> open=new PriorityQueue<State1>();\n\t\t\topen.add(new State1(init,0));\n\t\t\tHashMap<String,Integer> closed=new HashMap<String, Integer>();\n\t\t\tclosed.put(init.toString(),0);\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState1 now=open.poll();\n\t\t\t\tif(now.sb.toString().equals(fin.toString())){\n\t\t\t\t\tans=now.step;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<32; i++){\n\t\t\t\t\tif(now.sb.charAt(i*2)=='#' && now.sb.charAt((i-1)*2)!='#'){\n\t\t\t\t\t\tint s=now.sb.charAt((i-1)*2)-'0',v=now.sb.charAt((i-1)*2+1)-'0';\n\t\t\t\t\t\tif(v>=7)\tcontinue;\n\t\t\t\t\t\tboolean bf=false;\n\t\t\t\t\t\tfor(int j=0; j<32; j++){\n\t\t\t\t\t\t\tif(now.sb.charAt(j*2)-'0'==s && now.sb.charAt(j*2+1)-'0'==v+1){\n\t\t\t\t\t\t\t\tStringBuilder tmp=new StringBuilder(now.sb);\n\t\t\t\t\t\t\t\tnSwap(i*2,j*2,tmp);\n\t\t\t\t\t\t\t\tif(tmp.toString().equals(fin.toString())){\n\t\t\t\t\t\t\t\t\tans=now.step+1;\n\t\t\t\t\t\t\t\t\topen.clear();\n\t\t\t\t\t\t\t\t\tbf=true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(closed.containsKey(tmp.toString()) && closed.get(tmp.toString())<=now.step+1)\tbreak;\n\t\t\t\t\t\t\t\topen.add(new State1(tmp,now.step+1));\n\t\t\t\t\t\t\t\tclosed.put(tmp.toString(),now.step+1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(bf)\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\tvoid nSwap(int a,int b,StringBuilder sb){\n\t\t\tif(a==b)\treturn;\n\t\t\tswap(a,b,sb);\n\t\t\tswap(++a,++b,sb);\n\t\t}\n\t\tvoid swap(int a,int b,StringBuilder sb){\n\t\t\tchar tmp=sb.charAt(a);\n\t\t\tsb.setCharAt(a, sb.charAt(b));\n\t\t\tsb.setCharAt(b, tmp);\n\t\t}\n\t\tclass State1 implements Comparable<State1>{\n\t\t\tStringBuilder sb;\n\t\t\tint step;\n\t\t\tState1(StringBuilder sb,int step){\n\t\t\t\tthis.sb=sb;\tthis.step=step;\n\t\t\t}\n\t\t\t@Override public int compareTo(State1 o) {\n\t\t\t\treturn this.step-o.step;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ1258{\n\t\tfinal int INF=Integer.MAX_VALUE/4;\n\t\tAOJ1258(){\n\t\t\twhile(true){\n\t\t\t\tint M=sc.nextInt(),C=sc.nextInt(),N=sc.nextInt();\n\t\t\t\tif(((M|C)|N)==0)\tbreak;\n\t\t\t\tSystem.out.println(solve(M,C,N));\n\t\t\t}\n\t\t}\n\t\tint solve(int M,int C,int N){\n\t\t\tLinkedList<LinkedList<Integer>> q=new LinkedList<LinkedList<Integer>>();\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tq.add(new LinkedList<Integer>());\n\t\t\t\tint K=sc.nextInt();\n\t\t\t\tfor(int j=0; j<K; j++)\tq.getLast().add(sc.nextInt());\n\t\t\t}\n\t\t\tStore store=new Store(M,C);\n\t\t\tint ans=0;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint r=q.getFirst().poll();\n\t\t\t\tans+=store.take(r);\n\t\t\t\tans+=store.put(r);\n\t\t\t\t//debug\n\t\t\t\t//System.out.println(store);\n\t\t\t\tif(q.getFirst().isEmpty())\tq.removeFirst();\n\t\t\t\telse\tq.addLast(q.poll());\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t\tclass Store{\n\t\t\tint M,C,time;\n\t\t\tArrayList<ArrayList<Book>> desks;\n\t\t\tStore(int m,int c){\n\t\t\t\tthis.M=m;\tthis.C=c;\tthis.time=0;\n\t\t\t\tdesks=new ArrayList<ArrayList<Book>>();\n\t\t\t\tfor(int i=0; i<M; i++)\tdesks.add(new ArrayList<Book>());\n\t\t\t}\n\t\t\tint take(int r){\n\t\t\t\tint ret=M+1;\n\t\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\t\tfor(int j=0; j<desks.get(i).size(); j++){\n\t\t\t\t\t\tif(desks.get(i).get(j).id==r){\n\t\t\t\t\t\t\tdesks.get(i).remove(j);\n\t\t\t\t\t\t\tret=i+1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ret<M+1)\tbreak;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tint put(int r){\n\t\t\t\tint ret=M+1;\n\t\t\t\tif(desks.get(0).size()<C){\n\t\t\t\t\tdesks.get(0).add(new Book(r,time++));\n\t\t\t\t\tret=1;\n\t\t\t\t}else{\n\t\t\t\t\tret=0;\n\t\t\t\t\tPair tmpIdx=new Pair(M,0);\n\t\t\t\t\tfor(int i=1; i<M; i++){\n\t\t\t\t\t\tif(desks.get(i).size()<C){\n\t\t\t\t\t\t\ttmpIdx.first=i;\n\t\t\t\t\t\t\tdesks.get(i).add(new Book(INF,INF));\n\t\t\t\t\t\t\ttmpIdx.second=desks.get(i).size()-1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret+=tmpIdx.first+1;\n\t\t\t\t\tint oldestTime=desks.get(0).get(0).t,oldestIdx=0;\n\t\t\t\t\tfor(int i=1; i<desks.get(0).size(); i++){\n\t\t\t\t\t\tif(oldestTime>desks.get(0).get(i).t){\n\t\t\t\t\t\t\toldestTime=desks.get(0).get(i).t;\n\t\t\t\t\t\t\toldestIdx=i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tBook oldest=desks.get(0).remove(oldestIdx);\n\t\t\t\t\tret+=1;\n\t\t\t\t\tint empIdx=M;\n\t\t\t\t\tfor(int i=1; i<M; i++){\n\t\t\t\t\t\tif(desks.get(i).size()<C){\n\t\t\t\t\t\t\tdesks.get(i).add(oldest);\n\t\t\t\t\t\t\tempIdx=i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret+=empIdx+1;\n\t\t\t\t\tif(tmpIdx.first<M)\tdesks.get(tmpIdx.first).remove(tmpIdx.second);\n\t\t\t\t\tret+=tmpIdx.first+1;\n\t\t\t\t\tdesks.get(0).add(new Book(r,time++));\n\t\t\t\t\tret+=1;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t@Override public String toString(){return desks.toString();}\n\t\t}\n\t\tclass Book{\n\t\t\tint id,t;\n\t\t\tBook(int id,int t){this.id=id;this.t=t;}\n\t\t\t@Override public String toString(){return \"ID\"+id+\" T\"+t;}\n\t\t}\n\t\tclass Pair implements Comparable<Pair>{\n\t\t\tint first,second;\n\t\t\tPair(int first,int second){this.first=first; this.second=second;}\n\t\t\t@Override public String toString(){return \"(\"+first+\",\"+second+\")\";}\n\t\t\t@Override public int compareTo(Pair p){\n\t\t\t\tif(this.first<p.first)\treturn -1;\n\t\t\t\tif(this.first>p.first)\treturn 1;\n\t\t\t\tif(this.second<p.second)\treturn -1;\n\t\t\t\tif(this.second>p.second)\treturn 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t@Override public int hashCode(){\n\t\t\t\treturn 17+31*first+second;\n\t\t\t}\n\t\t\t@Override public boolean equals(Object obj){\n\t\t\t\tif(this==obj)\treturn true;\n\t\t\t\tif(obj==null)\treturn false;\n\t\t\t\tif(this.getClass() != obj.getClass())\treturn false;\n\t\t\t\tPair p=(Pair)obj;\n\t\t\t\tif(this.first==p.first&&this.second==p.second)\treturn true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ1262{\n\t\tfinal double INF=Double.MAX_VALUE/4.0;\n\t\tAOJ1262(){\n\t\t\twhile(true){\n\t\t\t\tint N=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tSystem.out.printf(\"%.4f\\n\",solve(N));\n\t\t\t}\n\t\t}\n\t\tdouble solve(int N){\n\t\t\tint[] a=new int[N+1];\n\t\t\tfor(int i=1; i<=N; i++)\ta[i]=sc.nextInt();\n\t\t\tdouble b=sc.nextDouble();\n\t\t\tint r=sc.nextInt();\n\t\t\tdouble v=sc.nextDouble(),e=sc.nextDouble(),f=sc.nextDouble();\n\t\t\tdouble[][] dp=new double[N+1][N+1];\n\t\t\tfor(int i=1; i<=N; i++)for(int j=0; j<=N; j++)dp[i][j]=INF;\n\t\t\t//flash(dp,N);\n\t\t\tdouble tmp=0.0;\n\t\t\tfor(int i=0; i<a[1]; i++)\ttmp+=exp(i,r,v,e,f);\n\t\t\tdp[1][0]=tmp;\n\t\t\tfor(int w=1; w<N; w++){\n\t\t\t\tfor(int h=0; h<w; h++){\n\t\t\t\t\tint d=a[w+1]-a[w],x=a[w]-a[h];\n\t\t\t\t\tdouble exp=0.0;\n\t\t\t\t\tfor(int i=0; i<d; i++)\texp+=exp(x++,r,v,e,f);\n\t\t\t\t\t//debug\n\t\t\t\t\t//System.out.println(exp);\n\t\t\t\t\tdp[w+1][h]=dp[w][h]+exp;\n\t\t\t\t\tdouble exp2=0.0;\n\t\t\t\t\tfor(int i=0; i<d; i++)\texp2+=exp(i,r,v,e,f);\n\t\t\t\t\tdp[w+1][w]=min(dp[w+1][w], dp[w][h]+exp2+b);\n\t\t\t\t}\n\t\t\t\t//debug\n\t\t\t\t//System.out.println(\"new \"+dp[w+1][w]);\n\t\t\t}\n\t\t\t//flash(dp,N);\n\t\t\tdouble ans=INF;\n\t\t\tfor(int i=0; i<=N; i++)\tans=min(ans,dp[N][i]);\n\t\t\treturn ans;\n\t\t}\n\t\tdouble exp(int x,double r,double v,double e,double f){\n\t\t\treturn x>=r?(1/(v-e*(x-r))):(1/(v-f*(r-x)));\n\t\t}\n\t\tvoid flash(double[][] dp,int N){\n\t\t\tfor(int y=0; y<=N; y++){\n\t\t\t\tfor(int x=0; x<=N; x++)\tSystem.out.printf(\"%3.3f \",dp[x][y]>=INF?-1:dp[x][y]);\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n    static HashMap<String,HashSet<String>> map;\n    static ArrayList<HashSet<String>> al;\n\n    public static void delChar(String s,int idx){\n        int n = s.length();\n\n        for(int i=0;i<n;i++){\n            String ss = s.substring(0,i) + s.substring(i+1);\n            if(!map.containsKey(ss)) map.put(ss,new HashSet<String>());\n            map.get(ss).add(s);\n            al.get(idx).add(ss);\n        }\n    }\n\n    public static void insChar(String s,int idx){\n        int n = s.length();\n\n        for(int i=0;i<=n;i++){\n            for(int j=0;j<26;j++){\n                String ss = s.substring(0,i) + (char)('a' + j) + s.substring(i);\n                if(!map.containsKey(ss)) map.put(ss,new HashSet<String>());\n                map.get(ss).add(s);\n                al.get(idx).add(ss);\n            }\n        }\n    }\n\n    public static void repChar(String s,int idx){\n        int n = s.length();\n\n        for(int i=0;i<n;i++){\n            for(int j=0;j<26;j++){\n                String ss = s.substring(0,i) + (char)('a' + j) + s.substring(i+1);\n                if(!map.containsKey(ss)) map.put(ss,new HashSet<String>());\n                map.get(ss).add(s);\n                al.get(idx).add(ss);\n            }\n        }\n    }\n\n    public static void swapChar(String s,int idx){\n        int n = s.length();\n\n        for(int i=0;i<n-1;i++){\n            String ss = s.substring(0,i) + s.charAt(i+1) + s.charAt(i) + s.substring(i+2);\n            if(!map.containsKey(ss)) map.put(ss,new HashSet<String>());\n            map.get(ss).add(s);\n            al.get(idx).add(ss);\n        }\n    }\n\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            int n = sc.nextInt();\n            if(n == 0) break;\n\n            int d = sc.nextInt();\n            String[] s = new String[n];\n\n            for(int i=0;i<n;i++){\n                s[i] = sc.next();\n            }\n\n            map = new HashMap<String,HashSet<String>>();\n            al = new ArrayList<HashSet<String>>();\n\n            Arrays.sort(s);\n\n            for(int i=0;i<n;i++){\n                al.add(new HashSet<String>());\n\n                delChar(s[i],i);\n                insChar(s[i],i);\n                repChar(s[i],i);\n                swapChar(s[i],i);\n            }\n\n\n            int cnt = 0;\n\n            for(int i=0;i<n;i++){\n                TreeSet<String> set = new TreeSet<String>();\n                if(map.containsKey(s[i])) set.addAll(map.get(s[i]));\n                if(d == 2){\n                    for(String ss : al.get(i)){\n                        set.addAll(map.get(ss));\n                    }\n                }\n\n                for(String ss : set){\n                    if(s[i].compareTo(ss) < 0){\n                        cnt++;\n                        System.out.println(s[i]+\",\"+ss);\n                    }\n                }\n            }\n\n            System.out.println(cnt);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\t\n\t//0000 start\n\tint n;\n\tString [] data;\n\tArrayList<HashSet<String>> data2;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn= sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint d = sc.nextInt();\n\t\t\tdata = new String[n];\n\t\t\tHashSet<String> set = new HashSet<String>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tdata[i] = sc.next();\n\t\t\t\tset.add(data[i]);\n\t\t\t}\n\t\t\tArrays.sort(data);\n\t\t\tif(d == 0){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tdata2 = new ArrayList<HashSet<String>>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tdata2.add(new HashSet<String>());\n\t\t\t\tdata2.get(i).add(data[i]);\n\t\t\t\tsolve(i);\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tif(d == 1){\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\t\t\tif(data2.get(i).contains(data[j]) || data2.get(j).contains(data[i])){\n\t\t\t\t\t\t\tSystem.out.println(data[i] + \",\" + data[j]);\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\t\t\tfor(String k : data2.get(i)){\n\t\t\t\t\t\t\tif(data2.get(j).contains(k)){\n\t\t\t\t\t\t\t\tSystem.out.println(data[i] + \",\"+data[j]);\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n\tprivate void solve(int ind) {\n\t\tStringBuilder sb = new StringBuilder(data[ind]);\n\t\tint len = sb.length();\n\t\t//delete\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tchar c = sb.charAt(i);\n\t\t\tsb.deleteCharAt(i);\n\t\t\tdata2.get(ind).add(sb.toString());\n\t\t\tsb.insert(i, c);\n\t\t}\n\t\t\n\t\t//insert\n\t\tfor(int i = 0; i <= len; i++){\n\t\t\tfor(int j = 'a'; j <= 'z'; j++){\n\t\t\t\tsb.insert(i, (char)j);\n\t\t\t\tdata2.get(ind).add(sb.toString());\n\t\t\t\tsb.deleteCharAt(i);\n\t\t\t}\n\t\t}\n\t\t//replace\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tfor(int j = 'a'; j <= 'z'; j++){\n\t\t\t\tchar c = sb.charAt(i);\n\t\t\t\tsb.setCharAt(i, (char)j);\n\t\t\t\tdata2.get(ind).add(sb.toString());\n\t\t\t\tsb.setCharAt(i, c);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//swap\n\t\tfor(int i = 1; i < len; i++){\n\t\t\tswap(sb, i-1, i);\n\t\t\tdata2.get(ind).add(sb.toString());\n\t\t\tswap(sb, i-1, i);\n\t\t}\n\t}\n\n\tprivate void swap(StringBuilder sb, int i, int j) {\n\t\tchar c = sb.charAt(i);\n\t\tsb.setCharAt(i, sb.charAt(j));\n\t\tsb.setCharAt(j, c);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ1252();\n\t}\n\t\n\t// Confusing Login Names\n\tclass AOJ1252{\n\t\tAOJ1252(){\n\t\t\twhile(true){\n\t\t\t\tint N=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tsolve(N);\n\t\t\t}\n\t\t}\n\t\tvoid solve(int N){\n\t\t\tint D=sc.nextInt();\n\t\t\tString[] names=new String[N];\n\t\t\tfor(int i=0; i<N; i++)\tnames[i]=sc.next();\n\t\t\tArrays.sort(names);\n\t\t\tArrayList<TreeSet<String>> state1=new ArrayList<TreeSet<String>>(),state2=new ArrayList<TreeSet<String>>();\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tTreeSet<String> tmp=new TreeSet<String>();\n\t\t\t\tfor(int j=0; j<names[i].length(); j++){\n\t\t\t\t\ttmp.add(new StringBuilder(names[i]).deleteCharAt(j).toString());\n\t\t\t\t\tfor(int k=0; k<27; k++){\n\t\t\t\t\t\tchar c=(char)('a'+k);\n\t\t\t\t\t\ttmp.add(new StringBuilder(names[i]).insert(j, c).toString());\n\t\t\t\t\t\tStringBuilder sb=new StringBuilder(names[i]);\n\t\t\t\t\t\tsb.setCharAt(j, c);\n\t\t\t\t\t\ttmp.add(sb.toString());\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=j+1; k<names[i].length(); k++)\ttmp.add(swap(j,k,names[i]));\n\t\t\t\t}\n\t\t\t\tstate1.add(tmp);\n\t\t\t}\n\t\t\tif(D>1)\tstate2=state1;\n\t\t\telse{\n\t\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t\tTreeSet<String> tmp=new TreeSet<String>();\n\t\t\t\t\ttmp.add(names[i]);\n\t\t\t\t\tstate2.add(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tTreeSet<Pair> ans=new TreeSet<Main.AOJ1252.Pair>();\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(String s:state1.get(i)){\n\t\t\t\t\tfor(int j=i+1; j<N; j++){\n\t\t\t\t\t\tif(state2.get(j).contains(s))\tans.add(new Pair(names[i],names[j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(Pair p:ans)\tSystem.out.println(p);\n\t\t\tSystem.out.println(ans.size());\n\t\t}\n\t\tString swap(int a,int b,String str){\n\t\t\tStringBuilder sb=new StringBuilder(str);\n\t\t\tchar tmp=sb.charAt(a);\n\t\t\tsb.setCharAt(a, sb.charAt(b));\n\t\t\tsb.setCharAt(b, tmp);\n\t\t\treturn sb.toString();\n\t\t}\n\t\tclass Pair implements Comparable<Pair>{\n\t\t\tString s1,s2;\n\t\t\tPair(String s1,String s2){\n\t\t\t\tthis.s1=s1;\n\t\t\t\tthis.s2=s2;\n\t\t\t}\n\t\t\t@Override public int compareTo(Pair p){\n\t\t\t\tif(s1==p.s2 && s2==p.s1)\treturn 0;\n\t\t\t\treturn s1.compareTo(p.s1)!=0?s1.compareTo(p.s1) :s2.compareTo(p.s2);\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn s1+\",\"+s2;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t// Gap\n\tclass AOJ1245{\n\t\tAOJ1245(){\n\t\t\tint N=sc.nextInt();\n\t\t\twhile(--N>=0)\tsolve();\n\t\t}\n\t\tvoid solve(){\n\t\t\tStringBuilder init=new StringBuilder(),fin=new StringBuilder();\n\t\t\tfor(int i=1; i<=4; i++){\n\t\t\t\tinit.append(\"##\");\n\t\t\t\tfor(int j=1; j<=7; j++){\n\t\t\t\t\tinit.append(sc.nextInt());\n\t\t\t\t\tfin.append(i);\tfin.append(j);\n\t\t\t\t}\n\t\t\t\tfin.append(\"##\");\n\t\t\t}\n\t\t\tfor(int i=0; i<32; i++){\n\t\t\t\tif(init.charAt(i*2+1)=='1')\tnSwap(i*2,(init.charAt(i*2)-'0'-1)*16,init);\n\t\t\t}\n\t\t\tint ans=-1;\n\t\t\tPriorityQueue<State1> open=new PriorityQueue<State1>();\n\t\t\topen.add(new State1(init,0));\n\t\t\tHashMap<String,Integer> closed=new HashMap<String, Integer>();\n\t\t\tclosed.put(init.toString(),0);\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState1 now=open.poll();\n\t\t\t\tif(now.sb.toString().equals(fin.toString())){\n\t\t\t\t\tans=now.step;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<32; i++){\n\t\t\t\t\tif(now.sb.charAt(i*2)=='#' && now.sb.charAt((i-1)*2)!='#'){\n\t\t\t\t\t\tint s=now.sb.charAt((i-1)*2)-'0',v=now.sb.charAt((i-1)*2+1)-'0';\n\t\t\t\t\t\tif(v>=7)\tcontinue;\n\t\t\t\t\t\tboolean bf=false;\n\t\t\t\t\t\tfor(int j=0; j<32; j++){\n\t\t\t\t\t\t\tif(now.sb.charAt(j*2)-'0'==s && now.sb.charAt(j*2+1)-'0'==v+1){\n\t\t\t\t\t\t\t\tStringBuilder tmp=new StringBuilder(now.sb);\n\t\t\t\t\t\t\t\tnSwap(i*2,j*2,tmp);\n\t\t\t\t\t\t\t\tif(tmp.toString().equals(fin.toString())){\n\t\t\t\t\t\t\t\t\tans=now.step+1;\n\t\t\t\t\t\t\t\t\topen.clear();\n\t\t\t\t\t\t\t\t\tbf=true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(closed.containsKey(tmp.toString()) && closed.get(tmp.toString())<=now.step+1)\tbreak;\n\t\t\t\t\t\t\t\topen.add(new State1(tmp,now.step+1));\n\t\t\t\t\t\t\t\tclosed.put(tmp.toString(),now.step+1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(bf)\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\tvoid nSwap(int a,int b,StringBuilder sb){\n\t\t\tif(a==b)\treturn;\n\t\t\tswap(a,b,sb);\n\t\t\tswap(++a,++b,sb);\n\t\t}\n\t\tvoid swap(int a,int b,StringBuilder sb){\n\t\t\tchar tmp=sb.charAt(a);\n\t\t\tsb.setCharAt(a, sb.charAt(b));\n\t\t\tsb.setCharAt(b, tmp);\n\t\t}\n\t\tclass State1 implements Comparable<State1>{\n\t\t\tStringBuilder sb;\n\t\t\tint step;\n\t\t\tState1(StringBuilder sb,int step){\n\t\t\t\tthis.sb=sb;\tthis.step=step;\n\t\t\t}\n\t\t\t@Override public int compareTo(State1 o) {\n\t\t\t\treturn this.step-o.step;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ1258{\n\t\tfinal int INF=Integer.MAX_VALUE/4;\n\t\tAOJ1258(){\n\t\t\twhile(true){\n\t\t\t\tint M=sc.nextInt(),C=sc.nextInt(),N=sc.nextInt();\n\t\t\t\tif(((M|C)|N)==0)\tbreak;\n\t\t\t\tSystem.out.println(solve(M,C,N));\n\t\t\t}\n\t\t}\n\t\tint solve(int M,int C,int N){\n\t\t\tLinkedList<LinkedList<Integer>> q=new LinkedList<LinkedList<Integer>>();\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tq.add(new LinkedList<Integer>());\n\t\t\t\tint K=sc.nextInt();\n\t\t\t\tfor(int j=0; j<K; j++)\tq.getLast().add(sc.nextInt());\n\t\t\t}\n\t\t\tStore store=new Store(M,C);\n\t\t\tint ans=0;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint r=q.getFirst().poll();\n\t\t\t\tans+=store.take(r);\n\t\t\t\tans+=store.put(r);\n\t\t\t\t//debug\n\t\t\t\t//System.out.println(store);\n\t\t\t\tif(q.getFirst().isEmpty())\tq.removeFirst();\n\t\t\t\telse\tq.addLast(q.poll());\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t\tclass Store{\n\t\t\tint M,C,time;\n\t\t\tArrayList<ArrayList<Book>> desks;\n\t\t\tStore(int m,int c){\n\t\t\t\tthis.M=m;\tthis.C=c;\tthis.time=0;\n\t\t\t\tdesks=new ArrayList<ArrayList<Book>>();\n\t\t\t\tfor(int i=0; i<M; i++)\tdesks.add(new ArrayList<Book>());\n\t\t\t}\n\t\t\tint take(int r){\n\t\t\t\tint ret=M+1;\n\t\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\t\tfor(int j=0; j<desks.get(i).size(); j++){\n\t\t\t\t\t\tif(desks.get(i).get(j).id==r){\n\t\t\t\t\t\t\tdesks.get(i).remove(j);\n\t\t\t\t\t\t\tret=i+1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ret<M+1)\tbreak;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tint put(int r){\n\t\t\t\tint ret=M+1;\n\t\t\t\tif(desks.get(0).size()<C){\n\t\t\t\t\tdesks.get(0).add(new Book(r,time++));\n\t\t\t\t\tret=1;\n\t\t\t\t}else{\n\t\t\t\t\tret=0;\n\t\t\t\t\tPair tmpIdx=new Pair(M,0);\n\t\t\t\t\tfor(int i=1; i<M; i++){\n\t\t\t\t\t\tif(desks.get(i).size()<C){\n\t\t\t\t\t\t\ttmpIdx.first=i;\n\t\t\t\t\t\t\tdesks.get(i).add(new Book(INF,INF));\n\t\t\t\t\t\t\ttmpIdx.second=desks.get(i).size()-1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret+=tmpIdx.first+1;\n\t\t\t\t\tint oldestTime=desks.get(0).get(0).t,oldestIdx=0;\n\t\t\t\t\tfor(int i=1; i<desks.get(0).size(); i++){\n\t\t\t\t\t\tif(oldestTime>desks.get(0).get(i).t){\n\t\t\t\t\t\t\toldestTime=desks.get(0).get(i).t;\n\t\t\t\t\t\t\toldestIdx=i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tBook oldest=desks.get(0).remove(oldestIdx);\n\t\t\t\t\tret+=1;\n\t\t\t\t\tint empIdx=M;\n\t\t\t\t\tfor(int i=1; i<M; i++){\n\t\t\t\t\t\tif(desks.get(i).size()<C){\n\t\t\t\t\t\t\tdesks.get(i).add(oldest);\n\t\t\t\t\t\t\tempIdx=i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret+=empIdx+1;\n\t\t\t\t\tif(tmpIdx.first<M)\tdesks.get(tmpIdx.first).remove(tmpIdx.second);\n\t\t\t\t\tret+=tmpIdx.first+1;\n\t\t\t\t\tdesks.get(0).add(new Book(r,time++));\n\t\t\t\t\tret+=1;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t@Override public String toString(){return desks.toString();}\n\t\t}\n\t\tclass Book{\n\t\t\tint id,t;\n\t\t\tBook(int id,int t){this.id=id;this.t=t;}\n\t\t\t@Override public String toString(){return \"ID\"+id+\" T\"+t;}\n\t\t}\n\t\tclass Pair implements Comparable<Pair>{\n\t\t\tint first,second;\n\t\t\tPair(int first,int second){this.first=first; this.second=second;}\n\t\t\t@Override public String toString(){return \"(\"+first+\",\"+second+\")\";}\n\t\t\t@Override public int compareTo(Pair p){\n\t\t\t\tif(this.first<p.first)\treturn -1;\n\t\t\t\tif(this.first>p.first)\treturn 1;\n\t\t\t\tif(this.second<p.second)\treturn -1;\n\t\t\t\tif(this.second>p.second)\treturn 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t@Override public int hashCode(){\n\t\t\t\treturn 17+31*first+second;\n\t\t\t}\n\t\t\t@Override public boolean equals(Object obj){\n\t\t\t\tif(this==obj)\treturn true;\n\t\t\t\tif(obj==null)\treturn false;\n\t\t\t\tif(this.getClass() != obj.getClass())\treturn false;\n\t\t\t\tPair p=(Pair)obj;\n\t\t\t\tif(this.first==p.first&&this.second==p.second)\treturn true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ1262{\n\t\tfinal double INF=Double.MAX_VALUE/4.0;\n\t\tAOJ1262(){\n\t\t\twhile(true){\n\t\t\t\tint N=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tSystem.out.printf(\"%.4f\\n\",solve(N));\n\t\t\t}\n\t\t}\n\t\tdouble solve(int N){\n\t\t\tint[] a=new int[N+1];\n\t\t\tfor(int i=1; i<=N; i++)\ta[i]=sc.nextInt();\n\t\t\tdouble b=sc.nextDouble();\n\t\t\tint r=sc.nextInt();\n\t\t\tdouble v=sc.nextDouble(),e=sc.nextDouble(),f=sc.nextDouble();\n\t\t\tdouble[][] dp=new double[N+1][N+1];\n\t\t\tfor(int i=1; i<=N; i++)for(int j=0; j<=N; j++)dp[i][j]=INF;\n\t\t\t//flash(dp,N);\n\t\t\tdouble tmp=0.0;\n\t\t\tfor(int i=0; i<a[1]; i++)\ttmp+=exp(i,r,v,e,f);\n\t\t\tdp[1][0]=tmp;\n\t\t\tfor(int w=1; w<N; w++){\n\t\t\t\tfor(int h=0; h<w; h++){\n\t\t\t\t\tint d=a[w+1]-a[w],x=a[w]-a[h];\n\t\t\t\t\tdouble exp=0.0;\n\t\t\t\t\tfor(int i=0; i<d; i++)\texp+=exp(x++,r,v,e,f);\n\t\t\t\t\t//debug\n\t\t\t\t\t//System.out.println(exp);\n\t\t\t\t\tdp[w+1][h]=dp[w][h]+exp;\n\t\t\t\t\tdouble exp2=0.0;\n\t\t\t\t\tfor(int i=0; i<d; i++)\texp2+=exp(i,r,v,e,f);\n\t\t\t\t\tdp[w+1][w]=min(dp[w+1][w], dp[w][h]+exp2+b);\n\t\t\t\t}\n\t\t\t\t//debug\n\t\t\t\t//System.out.println(\"new \"+dp[w+1][w]);\n\t\t\t}\n\t\t\t//flash(dp,N);\n\t\t\tdouble ans=INF;\n\t\t\tfor(int i=0; i<=N; i++)\tans=min(ans,dp[N][i]);\n\t\t\treturn ans;\n\t\t}\n\t\tdouble exp(int x,double r,double v,double e,double f){\n\t\t\treturn x>=r?(1/(v-e*(x-r))):(1/(v-f*(r-x)));\n\t\t}\n\t\tvoid flash(double[][] dp,int N){\n\t\t\tfor(int y=0; y<=N; y++){\n\t\t\t\tfor(int x=0; x<=N; x++)\tSystem.out.printf(\"%3.3f \",dp[x][y]>=INF?-1:dp[x][y]);\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Confusing Login Names\npublic class Main{\n\n\tSet<String>[] s;\n\t\n\tclass P implements Comparable<P>{\n\t\tString s, t;\n\t\tpublic P(String s, String t) {\n\t\t\tthis.s = s.compareTo(t)<0?s:t;\n\t\t\tthis.t = s.compareTo(t)<0?t:s;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\treturn s.equals(o.s)?t.compareTo(o.t):s.compareTo(o.s);\n\t\t}\n\t}\n\t\n\tvoid make(int i, String v){\n\t\tint n = v.length();\n\t\tStringBuffer f = new StringBuffer(v);\n\t\t//delete\n\t\tfor(int j=0;j<n;j++){\n\t\t\tchar ch = f.charAt(j);\n\t\t\tf.deleteCharAt(j);\n\t\t\ts[i].add(f.toString());\n\t\t\tf.insert(j, ch);\n\t\t}\n\t\t//insert\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(char ch='a';ch<='z';ch++){\n\t\t\t\tf.insert(j, ch); s[i].add(f.toString()); f.deleteCharAt(j);\n\t\t\t}\n\t\t}\n\t\t//replace\n\t\tfor(int j=0;j<n;j++){\n\t\t\tchar ch = f.charAt(j);\n\t\t\tfor(char c='a';c<='z';c++){\n\t\t\t\tf.setCharAt(j, c); s[i].add(f.toString());\n\t\t\t}\n\t\t\tf.setCharAt(j, ch);\n\t\t}\n\t\t//swap\n\t\tfor(int j=0;j<n-1;j++){\n\t\t\tchar a = f.charAt(j), b = f.charAt(j+1);\n\t\t\tf.setCharAt(j, b); f.setCharAt(j+1, a);\n\t\t\ts[i].add(f.toString());\n\t\t\tf.setCharAt(j, a); f.setCharAt(j+1, b);\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint d = sc.nextInt();\n\t\t\ts = new HashSet[n];\n\t\t\tString[] name = new String[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tname[i] = sc.next();\n\t\t\t\ts[i] = new HashSet<String>();\n\t\t\t\tmake(i, name[i]);\n\t\t\t}\n\t\t\tPriorityQueue<P> q = new PriorityQueue<P>();\n\t\t\tfor(int i=0;i<n;i++)for(int j=i+1;j<n;j++){\n\t\t\t\tif(d==1){\n\t\t\t\t\tif(s[i].contains(name[j]))q.add(new P(name[i], name[j]));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(s[i].contains(name[j]))q.add(new P(name[i], name[j]));\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(String v:s[i])if(s[j].contains(v)){\n\t\t\t\t\t\t\tq.add(new P(name[i], name[j]));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r = q.size();\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tP p = q.poll(); System.out.println(p.s+\",\"+p.t);\n\t\t\t}\n\t\t\tSystem.out.println(r);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\t\n\t//0000 start\n\tint n;\n\tString [] data;\n\tArrayList<HashSet<String>> data2;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn= sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint d = sc.nextInt();\n\t\t\tdata = new String[n];\n\t\t\tHashSet<String> set = new HashSet<String>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tdata[i] = sc.next();\n\t\t\t\tset.add(data[i]);\n\t\t\t}\n\t\t\tif(d == 0){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tArrays.sort(data);\n\t\t\t\n\t\t\tdata2 = new ArrayList<HashSet<String>>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tdata2.add(new HashSet<String>());\n\t\t\t\tsolve(i);\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tif(d == 1){\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\t\t\tif(data2.get(i).contains(data[j])){\n\t\t\t\t\t\t\tSystem.out.println(data[i] + \",\" + data[j]);\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\t\t\tfor(String k : data2.get(i)){\n\t\t\t\t\t\t\tif(data2.get(j).contains(k) || k.equals(data[j])){\n\t\t\t\t\t\t\t\tSystem.out.println(data[i] + \",\"+data[j]);\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n\tprivate void solve(int ind) {\n\t\tStringBuilder sb = new StringBuilder(data[ind]);\n\t\tint len = sb.length();\n\t\t//delete\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tchar c = sb.charAt(i);\n\t\t\tsb.deleteCharAt(i);\n\t\t\tdata2.get(ind).add(sb.toString());\n\t\t\tsb.insert(i, c);\n\t\t}\n\t\t\n\t\t//insert\n\t\tfor(int i = 0; i <= len; i++){\n\t\t\tfor(int j = 'a'; j <= 'z'; j++){\n\t\t\t\tsb.insert(i, (char)j);\n\t\t\t\tdata2.get(ind).add(sb.toString());\n\t\t\t\tsb.deleteCharAt(i);\n\t\t\t}\n\t\t}\n\t\t//replace\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tfor(int j = 'a'; j <= 'z'; j++){\n\t\t\t\tchar c = sb.charAt(i);\n\t\t\t\tsb.setCharAt(i, (char)j);\n\t\t\t\tdata2.get(ind).add(sb.toString());\n\t\t\t\tsb.setCharAt(i, c);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//swap\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tfor(int j = i+1; j < len; j++){\n\t\t\t\tswap(sb, i, j);\n\t\t\t\tdata2.get(ind).add(sb.toString());\n\t\t\t\tswap(sb, i, j);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void swap(StringBuilder sb, int i, int j) {\n\t\tchar c = sb.charAt(i);\n\t\tsb.setCharAt(i, sb.charAt(j));\n\t\tsb.setCharAt(j, c);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tHashSet<String> gHs;\n\n\tvoid eM(String s, HashSet<String> l) {\n\t\tint n = s.length();\n\n\t\tString pre[] = new String[n];\n\t\tString post[] = new String[n+1];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpre[i] = s.substring(0, i);\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpost[i] = s.substring(i);\n\t\t}\n\t\tpost[n] =\"\"; \n\t\tfor (int i = 0; i < n ; i++) {\n\t\t\tl.add(pre[i] + post[i + 1]); // del\n//\t\t\tSystem.out.println(pre[i]+post[i+1]);\n\t\t\t// gHs.add(pre[i] + post[i + 1]);\n\t\t\tfor (char c = 'a'; c <= 'z'; c++) {\n\t\t\t\tl.add(pre[i] + c + post[i + 1]); // rep\n\t\t\t\t// gHs.add(pre[i] +c+ post[i + 1]);\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (char c = 'a'; c <= 'z'; c++) {\n\t\t\t\tl.add(pre[i] + c + post[i]); // ins\n\t\t\t\t// gHs.add(pre[i]+c + post[i ]);\n\t\t\t}\n\t\t}\n\t\tfor (char c = 'a'; c <= 'z'; c++) {\n\t\t\tl.add(s + c);\n\t\t\tl.add(c+s);\n\t\t\t// gHs.add(s+c);\n\t\t}\n\n\t\tchar[] chmap = s.toCharArray();\n\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tint j = i + 1;\n\t\t\t{\n\t\t\t\tchar sw = chmap[i];\n\t\t\t\tchmap[i] = chmap[j];\n\t\t\t\tchmap[j] = sw;\n\t\t\t\tl.add(new String(chmap)); // exc\n\t\t\t\t// gHs.add(new String(chmap));\n\t\t\t\tsw = chmap[i];\n\t\t\t\tchmap[i] = chmap[j];\n\t\t\t\tchmap[j] = sw;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint d = sc.nextInt();\n\t\t\tgHs = new HashSet<String>();\n\t\t\tString[] name = new String[n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tname[i] = sc.next();\n\t\t\t}\n\n\t\t\tArrays.sort(name);\n\n\t\t\t// System.out.println(Arrays.toString(name));\n\t\t\tint cnt = 0;\n\n\t\t\tHashSet<String>[] llst = new HashSet[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tllst[i] = new HashSet<String>();\n\t\t\t\teM(name[i], llst[i]);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (name[i].equals(name[j])) {\n\t\t\t\t\t\tSystem.out.println(name[i] + \",\" + name[j]);\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t} else if (d > 0) {\n\t\t\t\t\t\tboolean check = llst[i].contains(name[j]);\n\t\t\t\t\t\tif (check) {\n\t\t\t\t\t\t\tSystem.out.println(name[i] + \",\" + name[j]);\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t} else if (d > 1) {\n\t\t\t\t\t\t\tboolean check2 = false;\n\t\t\t\t\t\t\tfor (String str : llst[i]) {\n\t\t\t\t\t\t\t\tcheck2 = llst[j].contains(str);\n\t\t\t\t\t\t\t\tif (check2) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (check2) {\n\t\t\t\t\t\t\t\tSystem.out.println(name[i] + \",\" + name[j]);\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cnt);\n\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\t\n\t//0000 start\n\tint n;\n\tString [] data;\n\tArrayList<HashSet<String>> data2;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn= sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint d = sc.nextInt();\n\t\t\tdata = new String[n];\n\t\t\tHashSet<String> set = new HashSet<String>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tdata[i] = sc.next();\n\t\t\t\tset.add(data[i]);\n\t\t\t}\n\t\t\tArrays.sort(data);\n\t\t\tif(d == 0){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tdata2 = new ArrayList<HashSet<String>>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tdata2.add(new HashSet<String>());\n\t\t\t\tsolve(i);\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tif(d == 1){\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\t\t\tif(data2.get(i).contains(data[j]) || data2.get(j).contains(data[i])){\n\t\t\t\t\t\t\tSystem.out.println(data[i] + \",\" + data[j]);\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\t\t\tfor(String k : data2.get(i)){\n\t\t\t\t\t\t\tif(data2.get(j).contains(k) || k.equals(data[j])){\n\t\t\t\t\t\t\t\tSystem.out.println(data[i] + \",\"+data[j]);\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n\tprivate void solve(int ind) {\n\t\tStringBuilder sb = new StringBuilder(data[ind]);\n\t\tint len = sb.length();\n\t\t//delete\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tchar c = sb.charAt(i);\n\t\t\tsb.deleteCharAt(i);\n\t\t\tdata2.get(ind).add(sb.toString());\n\t\t\tsb.insert(i, c);\n\t\t}\n\t\t\n\t\t//insert\n\t\tfor(int i = 0; i <= len; i++){\n\t\t\tfor(int j = 'a'; j <= 'z'; j++){\n\t\t\t\tsb.insert(i, (char)j);\n\t\t\t\tdata2.get(ind).add(sb.toString());\n\t\t\t\tsb.deleteCharAt(i);\n\t\t\t}\n\t\t}\n\t\t//replace\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tfor(int j = 'a'; j <= 'z'; j++){\n\t\t\t\tchar c = sb.charAt(i);\n\t\t\t\tsb.setCharAt(i, (char)j);\n\t\t\t\tdata2.get(ind).add(sb.toString());\n\t\t\t\tsb.setCharAt(i, c);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//swap\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tfor(int j = i+1; j < len; j++){\n\t\t\t\tswap(sb, i, j);\n\t\t\t\tdata2.get(ind).add(sb.toString());\n\t\t\t\tswap(sb, i, j);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void swap(StringBuilder sb, int i, int j) {\n\t\tchar c = sb.charAt(i);\n\t\tsb.setCharAt(i, sb.charAt(j));\n\t\tsb.setCharAt(j, c);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n    static HashMap<String,HashSet<String>> map;\n\n    public static void delChar(String s){\n        int n = s.length();\n\n        for(int i=0;i<n;i++){\n            String ss = s.substring(0,i) + s.substring(i+1);\n            if(!map.containsKey(ss)) map.put(ss,new HashSet<String>());\n            map.get(ss).add(s);\n        }\n    }\n\n    public static void insChar(String s){\n        int n = s.length();\n\n        for(int i=0;i<=n;i++){\n            for(int j=0;j<26;j++){\n                String ss = s.substring(0,i) + (char)('a' + j) + s.substring(i);\n                if(!map.containsKey(ss)) map.put(ss,new HashSet<String>());\n                map.get(ss).add(s);\n            }\n        }\n    }\n\n    public static void repChar(String s){\n        int n = s.length();\n\n        for(int i=0;i<n;i++){\n            for(int j=0;j<26;j++){\n                String ss = s.substring(0,i) + (char)('a' + j) + s.substring(i+1);\n                if(!map.containsKey(ss)) map.put(ss,new HashSet<String>());\n                map.get(ss).add(s);\n            }\n        }\n    }\n\n    public static void swapChar(String s){\n        int n = s.length();\n\n        for(int i=0;i<n-1;i++){\n            String ss = s.substring(0,i) + s.charAt(i+1) + s.charAt(i) + s.substring(i+2);\n            if(!map.containsKey(ss)) map.put(ss,new HashSet<String>());\n            map.get(ss).add(s);\n        }\n    }\n\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            int n = sc.nextInt();\n            if(n == 0) break;\n\n            int d = sc.nextInt();\n            String[] s = new String[n];\n\n            for(int i=0;i<n;i++){\n                s[i] = sc.next();\n            }\n\n            map = new HashMap<String,HashSet<String>>();\n\n            /*\n            swapChar(\"xy\");\n            System.out.println(map);\n            */\n            for(int i=0;i<n;i++){\n                delChar(s[i]);\n                insChar(s[i]);\n                repChar(s[i]);\n                swapChar(s[i]);\n            }\n\n            Arrays.sort(s);\n\n            int cnt = 0;\n\n            for(int i=0;i<n;i++){\n                TreeSet<String> set = new TreeSet<String>();\n                if(map.containsKey(s[i])) set.addAll(map.get(s[i]));\n                for(String ss : map.keySet()){\n                    if(map.get(ss).contains(s[i])){\n                        set.addAll(map.get(ss));\n                    }\n                }\n\n                for(String ss : set){\n                    if(s[i].compareTo(ss) < 0){\n                        cnt++;\n                        System.out.println(s[i]+\",\"+ss);\n                    }\n                }\n            }\n\n            System.out.println(cnt);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\t\n\t//0000 start\n\tint n;\n\tString [] data;\n\tArrayList<HashSet<String>> data2;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn= sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint d = sc.nextInt();\n\t\t\tdata = new String[n];\n\t\t\tHashSet<String> set = new HashSet<String>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tdata[i] = sc.next();\n\t\t\t\tset.add(data[i]);\n\t\t\t}\n\t\t\tArrays.sort(data);\n\t\t\tif(d == 0){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tdata2 = new ArrayList<HashSet<String>>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tdata2.add(new HashSet<String>());\n\t\t\t\tdata2.get(i).add(data[i]);\n\t\t\t\tsolve(i);\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tif(d == 1){\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\t\t\tif(data2.get(i).contains(data[j]) || data2.get(j).contains(data[i])){\n\t\t\t\t\t\t\tSystem.out.println(data[i] + \",\" + data[j]);\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\t\t\tfor(String k : data2.get(i)){\n\t\t\t\t\t\t\tif(data2.get(j).contains(k)){\n\t\t\t\t\t\t\t\tSystem.out.println(data[i] + \",\"+data[j]);\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n\tprivate void solve(int ind) {\n\t\tStringBuilder sb = new StringBuilder(data[ind]);\n\t\tint len = sb.length();\n\t\t//delete\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tchar c = sb.charAt(i);\n\t\t\tsb.deleteCharAt(i);\n\t\t\tdata2.get(ind).add(sb.toString());\n\t\t\tsb.insert(i, c);\n\t\t}\n\t\t\n\t\t//insert\n\t\tfor(int i = 0; i <= len; i++){\n\t\t\tfor(int j = 'a'; j <= 'z'; j++){\n\t\t\t\tsb.insert(i, (char)j);\n\t\t\t\tdata2.get(ind).add(sb.toString());\n\t\t\t\tsb.deleteCharAt(i);\n\t\t\t}\n\t\t}\n\t\t//replace\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tfor(int j = 'a'; j <= 'z'; j++){\n\t\t\t\tchar c = sb.charAt(i);\n\t\t\t\tsb.setCharAt(i, (char)j);\n\t\t\t\tdata2.get(ind).add(sb.toString());\n\t\t\t\tsb.setCharAt(i, c);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//swap\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tfor(int j = i+1; j < len; j++){\n\t\t\t\tswap(sb, i, j);\n\t\t\t\tdata2.get(ind).add(sb.toString());\n\t\t\t\tswap(sb, i, j);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void swap(StringBuilder sb, int i, int j) {\n\t\tchar c = sb.charAt(i);\n\t\tsb.setCharAt(i, sb.charAt(j));\n\t\tsb.setCharAt(j, c);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tHashSet<String> gHs;\n\n\tvoid eM(String s, HashSet<String> l) {\n\t\tint n = s.length();\n\n\t\tString pre[] = new String[n];\n\t\tString post[] = new String[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpre[i] = s.substring(0, i);\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpost[i] = s.substring(i);\n\t\t}\n\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tl.add(pre[i] + post[i + 1]); // del\n\t\t\t// gHs.add(pre[i] + post[i + 1]);\n\t\t\tfor (char c = 'a'; c <= 'z'; c++) {\n\t\t\t\tl.add(pre[i] + c + post[i + 1]); // rep\n\t\t\t\t// gHs.add(pre[i] +c+ post[i + 1]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (char c = 'a'; c <= 'z'; c++) {\n\t\t\t\tl.add(pre[i] + c + post[i]); // ins\n\t\t\t\t// gHs.add(pre[i]+c + post[i ]);\n\t\t\t}\n\t\t}\n\t\tfor (char c = 'a'; c <= 'z'; c++) {\n\t\t\tl.add(s + c);\n\t\t\t// gHs.add(s+c);\n\t\t}\n\n\t\tchar[] chmap = s.toCharArray();\n\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tint j = i + 1;\n\t\t\t{\n\t\t\t\tchar sw = chmap[i];\n\t\t\t\tchmap[i] = chmap[j];\n\t\t\t\tchmap[j] = sw;\n\t\t\t\tl.add(new String(chmap)); // exc\n\t\t\t\t// gHs.add(new String(chmap));\n\t\t\t\tsw = chmap[i];\n\t\t\t\tchmap[i] = chmap[j];\n\t\t\t\tchmap[j] = sw;\n\t\t\t}\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint d = sc.nextInt();\n\t\t\tgHs = new HashSet<String>();\n\t\t\tString[] name = new String[n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tname[i] = sc.next();\n\t\t\t}\n\n\t\t\tArrays.sort(name);\n\n\t\t\t// System.out.println(Arrays.toString(name));\n\t\t\tint cnt = 0;\n\n\t\t\tHashSet<String>[] llst = new HashSet[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tllst[i] = new HashSet<String>();\n\t\t\t\teM(name[i], llst[i]);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (name[i].equals(name[j])) {\n\t\t\t\t\t\tSystem.out.println(name[i] + \",\" + name[j]);\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t} else if (d > 0) {\n\t\t\t\t\t\tboolean check = llst[i].contains(name[j]);\n\t\t\t\t\t\tif (check) {\n\t\t\t\t\t\t\tSystem.out.println(name[i] + \",\" + name[j]);\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t} else if (d > 1) {\n\t\t\t\t\t\t\tboolean check2 = false;\n\t\t\t\t\t\t\tfor (String str : llst[i]) {\n\n\t\t\t\t\t\t\t\tcheck2 = llst[j].contains(str);\n\t\t\t\t\t\t\t\tif (check2) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (check2) {\n\t\t\t\t\t\t\t\tSystem.out.println(name[i] + \",\" + name[j]);\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cnt);\n\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nINF = 1 << 30\n\n### subroutines\n\ndef transform(login)\n  trans = {}\n  len = login.length\n  \n  # 1. Delete\n  for i in (0...len)\n    v = login.clone\n    v[i] = ''\n    trans[v] = true\n  end\n\n  # 2. Insert\n  for i in (0..len)\n    for ch in ('a'..'z')\n      v = login.clone\n      v[i, 0] = ch\n      trans[v] = true\n    end\n  end\n\n  # 3. Replace\n  for i in (0...len)\n    for ch in ('a'..'z')\n      next if login[i] == ch\n      v = login.clone\n      v[i] = ch\n      trans[v] = true\n    end\n  end\n\n  # 4. Swap\n  (0...len).each_cons(2) do |i, j|\n    next if login[i] == login[j]\n    v = login.clone\n    v[i] = login[j]\n    v[j] = login[i]\n    trans[v] = true\n  end\n\n  trans\nend\n\n### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  d = gets.to_i\n\n  logins = n.times.map{gets.strip}\n  #p logins\n\n  ltrs = {}\n  logins.each{|l| ltrs[l] = transform(l)}\n  \n  clogins = []\n\n  for i in (0...n)\n    li = logins[i]\n    likeys = ltrs[li].keys\n\n    for j in ((i + 1)...n)\n      lj = logins[j]\n\n      # d == 1\n      if ltrs[li][lj] || ltrs[lj][li]\n        clogins << [li, lj].sort\n        next\n      end\n      next if d < 2\n      \n      # d == 2\n      for lii in likeys\n        if ltrs[lj][lii]\n          clogins << [li, lj].sort\n          break\n        end\n      end\n    end\n  end\n\n  clogins.sort.each do |l0, l1|\n    puts \"#{l0},#{l1}\"\n  end\n  puts clogins.length\nend"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef transform(name)\n  trans = {}\n  len = name.length\n\n  # 1. Delete\n  for i in (0...len)\n    v = name.clone\n    v[i] = ''\n    trans[v] = true\n  end\n\n  # 2. Insert\n  for i in (0..len)\n    for ch in ('a'..'z')\n      v = name.clone\n      v[i, 0] = ch\n      trans[v] = true\n    end\n  end\n\n  # 3. Replace\n  for i in (0...len)\n    for ch in ('a'..'z')\n      v = name.clone\n      v[i] = ch\n      trans[v] = true\n    end\n  end\n\n  # 4. Swap\n  (0...len).each_cons(2) do |i, j|\n    v = name.clone\n    v[i] = name[j]\n    v[j] = name[i]\n    trans[v] = true\n  end\n\n  trans\nend\n\n### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  d = gets.to_i\n\n  names = []\n  nmthash = {}\n  nmts = {}\n\n  n.times do\n    name = gets.strip\n    names << name\n    trans = transform(name)\n    nmthash[name] = trans\n    nmts[name] = trans.keys\n  end\n\n  confs = []\n\n  for i in (0...n)\n    nmi = names[i]\n    nmithash = nmthash[nmi]\n\n    for j in ((i + 1)...n)\n      nmj = names[j]\n\n      if nmithash[nmj]\n        confs << [nmi, nmj].sort\n        next\n      end\n      next if d < 2\n\n      nmts[nmj].each do |nmtj|\n        if nmithash[nmtj]\n          confs << [nmi, nmj].sort\n          break\n        end\n      end\n    end\n  end\n\n  confs.sort.each do |nm0, nm1|\n    puts [nm0, nm1].join(',')\n  end\n  puts confs.length\nend"
  },
  {
    "language": "Ruby",
    "code": "def f(d, name1, name2)\n    return f(d, name2, name1) if name1.size < name2.size\n    return name1 == name2 if d == 0\n    return false if name1.size > name2.size + d\n\n    if name1.size == name2.size + d\n        return name2 =~ (/^#{name1.split(\"\").join(??)}?$/)\n    end\n\n    return true if name2 == \"\"\n\n    if name1[0] == name2[0]\n        return f(d, name1[1..-1], name2[1..-1])\n    else\n        b = f(d-1, name1[1..-1], name2)\n        return true if b\n        b = f(d-1, name1[1..-1], name2[1..-1])\n        return true if b\n        if name1.size >= 2\n            b = f(d-1, name1[0..1].reverse + name1[2..-1], name2)\n            return true if b\n        end\n        if name1.size >= 2\n            b = f(d-1, name1, name2[0..1].reverse + name2[2..-1])\n            return true if b\n        end\n    end\n    \n    return false\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    d = gets.to_i\n    \n    names = (1..n).map { gets.chomp }\n\n    ans = []\n    names.combination(2) do |name1, name2|\n        ans << [name1, name2].sort if f(d, name1, name2)\n    end\n    puts ans.sort.map {|n1, n2| \"#{n1},#{n2}\"}\n    puts ans.size\nend"
  },
  {
    "language": "Ruby",
    "code": "def f(d, name1, name2)\n    return f(d, name2, name1) if name1.size < name2.size\n    return name1 == name2 if d == 0\n    return false if name1.size > name2.size + d\n\n    if name1.size == name2.size + d\n        return name2 =~ (/^#{name1.split(\"\").join(??)}?$/)\n    end\n\n    return true if name2 == \"\"\n\n    if name1[0] == name2[0]\n        return f(d, name1[1..-1], name2[1..-1])\n    else\n        b = f(d-1, name1[1..-1], name2)\n        return true if b\n        if name1.size == name2.size\n            b = f(d-1, name2[1..-1], name1)\n            return true if b\n        end\n        b = f(d-1, name1[1..-1], name2[1..-1])\n        return true if b\n        if name1.size >= 2\n            b = f(d-1, name1[0..1].reverse + name1[2..-1], name2)\n            return true if b\n        end\n        if name2.size >= 2\n            b = f(d-1, name1, name2[0..1].reverse + name2[2..-1])\n            return true if b\n        end\n    end\n    \n    return false\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    d = gets.to_i\n    \n    names = (1..n).map { gets.chomp }\n\n    ans = []\n    names.combination(2) do |name1, name2|\n        ans << [name1, name2].sort if f(d, name1, name2)\n    end\n    puts ans.sort.map {|n1, n2| \"#{n1},#{n2}\"}\n    puts ans.size\nend"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\nfrom itertools import permutations\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\ndef solve():\n    N = int(readline())\n    if N == 0:\n        return False\n    def dist(a, b):\n        LA = len(a); LB = len(b)\n        dp = [[10**18]*(LB+1) for i in range(LA+1)]\n        dp[0][0] = 0\n        for i in range(LA):\n            for j in range(LB):\n                v = dp[i][j]\n                if a[i] == b[j]:\n                    dp[i+1][j+1] = min(dp[i+1][j+1], v)\n                else:\n                    dp[i+1][j+1] = min(dp[i+1][j+1], v+1)\n                dp[i+1][j] = min(dp[i+1][j], v+1)\n                dp[i][j+1] = min(dp[i][j+1], v+1)\n            dp[i+1][LB] = min(dp[i+1][LB], dp[i][LB]+1)\n        for j in range(LB):\n            dp[LA][j+1] = min(dp[LA][j+1], dp[LA][j] + 1)\n        return dp[LA][LB]\n    def check(a, b):\n        LA = len(a); LB = len(b)\n        if abs(LA - LB) > D:\n            return False\n        d = dist(a, b)\n        if d <= D:\n            return True\n        if d == 2 and LA == LB:\n            ra = []; rb = []; rp = []\n            for i in range(LA):\n                if a[i] != b[i]:\n                    rp.append(i)\n                    ra.append(a[i])\n                    rb.append(b[i])\n            if len(rp) == 2 and rp[1] - rp[0] == 1:\n                ra.reverse()\n                if ra == rb:\n                    return True\n        if D == 2:\n            if d == 4 and LA == LB:\n                ra = []; rb = []; rp = []\n                for i in range(LA):\n                    if a[i] != b[i]:\n                        rp.append(i)\n                        ra.append(a[i])\n                        rb.append(b[i])\n                if len(rp) == 4 and rp[1] - rp[0] == 1 and rp[3] - rp[2] == 1:\n                    ra[0], ra[1] = ra[1], ra[0]\n                    ra[2], ra[3] = ra[3], ra[2]\n                    return ra == rb\n            if d == 3 and abs(LA - LB) < D:\n                a = list(a); b = list(b)\n                if not LA < LB:\n                    LA, LB = LB, LA\n                    a, b = b, a\n                for i in range(LA-1):\n                    a[i], a[i+1] = a[i+1], a[i]\n                    if dist(a, b) <= D-1:\n                        return True\n                    for j in range(LA-1):\n                        a[j], a[j+1] = a[j+1], a[j]\n                        if a == b:\n                            return True\n                        a[j], a[j+1] = a[j+1], a[j]\n                    a[i], a[i+1] = a[i+1], a[i]\n        return False\n    D = int(readline())\n    S = [readline().strip() for i in range(N)]\n    ans = []\n    for i in range(N):\n        for j in range(i+1, N):\n            if check(S[i], S[j]):\n                ans.append((S[i], S[j]) if S[i] < S[j] else (S[j], S[i]))\n    ans.sort()\n    for e in ans:\n        write(\"%s,%s\\n\" % e)\n    write(\"%d\\n\" % len(ans))\n    return True\nwhile solve():\n    ...\n"
  }
]