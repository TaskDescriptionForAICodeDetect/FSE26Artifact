[
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\nusing namespace std;\n#define rg register\nvoid read(int &x){\n    char ch;bool ok;\n    for(ok=0,ch=getchar();!isdigit(ch);ch=getchar())if(ch=='-')ok=1;\n    for(x=0;isdigit(ch);x=x*10+ch-'0',ch=getchar());if(ok)x=-x;\n}\nconst int maxn=2010,mod=1e9+7,N=4e6;\nint n,m,f[maxn][maxn],fac[maxn*maxn],inv[maxn*maxn];\nint mul(int x,int y){return 1ll*x*y-1ll*x*y/mod*mod;}\nint add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\nint del(int x,int y){return x-y<0?x-y+mod:x-y;}\nint mi(int a,int b){int ans=1;while(b){if(b&1)ans=mul(ans,a);b>>=1,a=mul(a,a);}return ans;}\nvoid prepare(){\n    fac[0]=inv[0]=1;\n    for(rg int i=1;i<=N;i++)fac[i]=mul(fac[i-1],i);\n    inv[N]=mi(fac[N],mod-2);\n    for(rg int i=N-1;i;i--)inv[i]=mul(inv[i+1],i+1);\n}\nint C(int n,int m){return mul(fac[n],mul(inv[m],inv[n-m]));}\nint main(){\n    read(n),read(m),prepare();\n    if(m==1)return printf(\"1\\n\"),0;\n    for(rg int i=1;i<=n;i++){\n\tf[i][0]=1;\n\tfor(rg int j=1;j<=i;j++)\n\t    f[i][j]=add(f[i-1][j],mul(mul(f[i][j-1],n-j+1),C(n*m-(j-1)*(m-1)-i-1,m-2)));\n    }\n    printf(\"%d\\n\",f[n][n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "//AtCoder-agc002F\n#include <cstdio>\n#define rg register\n\nconst int N=2018,M=N*N,p=1e9+7;\nint inv[M],fac[M],f[N][N];\nint n,m;\n\ntemplate <typename _Tp> inline void pls(_Tp&A,_Tp B){A=A+B<p?A+B:A+B-p;}\n\ninline int qpow(int A,int B){\n\tint res(1);while(B){\n\t\tif(B&1)res=1ll*res*A%p;\n\t\tA=1ll*A*A%p;B>>=1;\n\t}return res;\n}\n\nvoid prework(){\n\tinv[0]=inv[1]=fac[0]=fac[1]=1;\n\tfor(rg int i=2;i<M;++i)fac[i]=1ll*fac[i-1]*i%p;\n\tinv[M-1]=qpow(fac[M-1],p-2);\n\tfor(rg int i=M-2;i;--i)inv[i]=1ll*inv[i+1]*(i+1)%p;\n}\n\ninline int c(int nn,int mm){return 1ll*fac[nn]*inv[mm]%p*inv[nn-mm]%p;}\n\nint main(){\n\tprework();scanf(\"%d%d\",&n,&m);\n\tif(m==1){puts(\"1\");return 0;}\n\tf[0][0]=1;\n\tfor(rg int i=1;i<=n;++i){\n\t\tpls(f[i][0],(int)(1ll*f[i-1][0]*c(i*m-i-1,m-2)%p));\n\t\tfor(rg int j=1;j<=i;++j){\n\t\t\tf[i][j]=f[i][j-1];\n\t\t\tpls(f[i][j],(int)(1ll*f[i-1][j]*c(i*m+j-i-1,m-2)%p));\n\t\t}\n\t}printf(\"%lld\\n\",1ll*f[n][n]*fac[n]%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\n#define MOD 1000000007\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int MAXN = 2000 + 10;\nconst int MAXM = 4e06 + 10;\n\nint N, K;\n\nLL fact[MAXM]= {0}, invfact[MAXM]= {0};\nvoid init () {\n\tfact[0] = fact[1] = invfact[0] = invfact[1] = 1;\n\tfor (int i = 2; i <= N * K; i ++) {\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\tinvfact[i] = (MOD - MOD / i) * invfact[MOD % i] % MOD;\n\t}\n\tfor (int i = 1; i <= N * K; i ++)\n\t\tinvfact[i] = invfact[i - 1] * invfact[i] % MOD;\n}\nLL C (int n, int m) {\n\tif (m == 0) return 1;\n\treturn fact[n] * invfact[m] % MOD * invfact[n - m] % MOD;\n}\n\nLL f[MAXN][MAXN]= {0};\n\nint main () {\n\tscanf (\"%d%d\", & N, & K);\n\tif (K == 1) {\n\t\tputs (\"1\");\n\t\treturn 0;\n\t}\n\tinit ();\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= N; i ++)\n\t\tfor (int j = 0; j <= i; j ++) {\n\t\t\tLL delta = f[i][j - 1] * (N - j + 1) % MOD * C (N * K - i - (K - 1) * (j - 1) - 1, K - 2) % MOD;\n\t\t\tif (j == 0) delta = 0;\n\t\t\tf[i][j] = (f[i][j] + f[i - 1][j] + delta) % MOD;\n\t\t}\n\tcout << f[N][N] << endl;\n\n\treturn 0;\n}\n\n/*\n2 2\n*/\n\n/*\n3 1\n*/\n\n/*\n2 3\n*/\n\n/*\n2000 2000\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, l, r) for (register int i = (l), i##end = (int)(r); i <= i##end; ++i)\n#define Fordown(i, r, l) for (register int i = (r), i##end = (int)(l); i >= i##end; --i)\n#define Rep(i, r) for (register int i = (0), i##end = (int)(r); i < i##end; ++i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define debug(x) cout << #x << \": \" << (x) << endl\n\nusing namespace std;\n\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, T b) { return b > a ? a = b, 1 : 0; }\n\ninline int read() {\n\tint x(0), sgn(1); char ch(getchar());\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') sgn = -1;\n\tfor (; isdigit(ch); ch = getchar()) x = (x * 10) + (ch ^ 48);\n\treturn x * sgn;\n}\n\nvoid File() {\n\tfreopen (\"F.in\", \"r\", stdin);\n\tfreopen (\"F.out\", \"w\", stdout);\n}\n\nconst int N = 2010, Mod = 1e9 + 7;\n\nint fac[N * N], ifac[N * N];\n\nint fpm(int x, int power) {\n\tint res = 1;\n\tfor (; power; power >>= 1, x = 1ll * x * x % Mod)\n\t\tif (power & 1) res = 1ll * res * x % Mod;\n\treturn res;\n}\n\nvoid Math_Init(int maxn) {\n\tfac[0] = ifac[0] = 1;\n\tFor (i, 1, maxn) fac[i] = 1ll * fac[i - 1] * i % Mod;\n\tifac[maxn] = fpm(fac[maxn], Mod - 2);\n\tFordown (i, maxn - 1, 1) ifac[i] = ifac[i + 1] * (i + 1ll) % Mod;\n}\n\ninline int Comb(int n, int m) {\n\tif (n < 0 || m < 0 || n < m) return 0;\n\treturn 1ll * fac[n] * ifac[m] % Mod * ifac[n - m] % Mod;\n}\n \nint n, k, dp[N][N];\n\nint main () {\n\n\tn = read(); k = read();\n\n\tif (k == 1) return puts(\"1\"), 0;\n\n\tMath_Init(n * k);\n\n\tdp[0][0] = 1;\n\tFor (i, 0, n) For (j, 0, i) if (dp[i][j]) {\n\t//\tcout << i << ' ' << j << ' ' << dp[i][j] << endl;\n\t\t(dp[i + 1][j] += dp[i][j]) %= Mod;\n\n\t\tdp[i][j + 1] = (dp[i][j + 1] + \n\t\t\t\t1ll * (n - j) * Comb(n * k - (i + 1) - j * (k - 1), k - 2) % Mod * dp[i][j]) % Mod;\n\t}\n\tprintf (\"%d\\n\", dp[n][n]);\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define N 2001\n#define LL long long\n#define add_edge(u,v) nxt[++cnt]=head[u],head[u]=cnt,to[cnt]=v\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\nchar ch;bool fs;void re(int& x)\n{\n\twhile(ch=getchar(),ch<33);\n\tif(ch=='-')fs=1,x=0;else fs=0,x=ch-48;\n\twhile(ch=getchar(),ch>33)x=x*10+ch-48;\n\tif(fs)x=-x;\t\n}\nusing namespace std;\nconst int mod=1000000007;\nint inv[N*N],ifac[N*N],fac[N*N];\nint n,k,f[N][N];\nint C(int n,int m)\n{\n\treturn 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\nint main()\n{\n\tre(n),re(k);\n\tif(k==1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tinv[0]=inv[1]=ifac[0]=fac[0]=1;\n\tfor(int i=1;i<=n*k;++i)\n\t{\n\t\tif(i>1)inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\t\tfac[i]=1ll*i*fac[i-1]%mod;\n\t\tifac[i]=1ll*inv[i]*ifac[i-1]%mod;\n\t}\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<=i;++j)\n\t\t\tf[i][j]=(f[i-1][j]+(j?1ll*C(n-i+(n-j+1)*(k-1)-1,k-2)*f[i][j-1]:0))%mod;\n\tprintf(\"%d\\n\",1ll*f[n][n]*fac[n]%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9+7;\nlong long n,k;\nlong long dp[2010][2010];\nlong long fac[4000010],inv[4000010];\nlong long fpm(long long a,long long b){\n    long long res = 1;\n    while(b){\n        if (b&1){\n            res = res*a%mod;\n            b--;\n        }\n        a = a*a%mod;\n        b>>=1;\n    }\n    return res;\n}\nlong long C(long long n,long long m){\n    if (n<m){\n        return 0;\n    }\n    return fac[n]*inv[n-m]%mod*inv[m]%mod;\n}\nint main () {\n    scanf(\"%lld%lld\",&n,&k);\n    if (k==1){\n        printf(\"1\");\n        return 0;\n    }\n    fac[0] = 1;\n    inv[0] = 1;\n    for (register int i = 1; i <= 4000000; i++){\n        fac[i] = fac[i-1]*i%mod;\n        inv[i] = fpm(fac[i],mod-2)%mod;\n    }\n    dp[0][0] = 1;\n    for (register int i = 1; i <= n; i++){\n        for (register int j = 0; j <= i; j++){\n            dp[i][j] = dp[i-1][j];\n            if (j==0){\n                continue;\n            }\n            dp[i][j] += dp[i][j-1]*(n-j+1)%mod*C(n-i+(n-j+1)*(k-1)-1,k-2)%mod;\n            dp[i][j] %= mod;\n        }\n    }\n    printf(\"%lld\",dp[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int Mod=1e9+7;\nint fac[4110000],ifac[4110000],f[2100][2100],n,k;\n\nint pow(int x,int l){\n\tif(l==0)return 1;\n\tint t=pow(x,l/2);\n\tt=(ll)t*t%Mod;\n\tif(l&1)t=(ll)t*x%Mod;\n\treturn t;\n}\n\nint C(int x,int y){\n\treturn (ll)fac[x]*ifac[y]%Mod*ifac[x-y]%Mod;\n}\n\nint main(){\n\tscanf(\"%d %d\",&n,&k);\n\tif(k==1){\n\t\tprintf(\"%d\\n\",1);\n\t\treturn 0;\n\t}\n\tfac[0]=1;for(int i=1;i<=4099999;i++)fac[i]=(ll)fac[i-1]*i%Mod;\n\tifac[4099999]=pow(fac[4099999],Mod-2);for(int i=4099998;i>=0;i--)ifac[i]=(ll)ifac[i+1]*(i+1)%Mod;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tf[0][i]=(ll)f[0][i-1]*C(0+i*(k-1)-1,k-2)%Mod;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i][i]=f[i-1][i];\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tf[i][j]=(f[i-1][j]+(ll)f[i][j-1]*C(i+j*(k-1)-1,k-2))%Mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(ll)f[n][n]*fac[n]%Mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mod 1000000007\n#define maxn 2005\n#define ll long long\n\nusing namespace std;\n\nll silnia[maxn*maxn];\nll dp[maxn][maxn];\n\n\nvoid licz(int zosia)\n{\n\tsilnia[0]=1;\n\tfor(int i=1; i<=zosia; ++i)\n\t{\n\t\tll a=i;\n\t\tsilnia[i]=(silnia[i-1]*a)%mod;\n\t}\n}\n\nll qpow(ll zosia, int n)\n{\n\tll wynik=1;\n\twhile(n!=0)\n\t{\n\t\tif(n%2==1)\n\t\t\twynik=(wynik*zosia)%mod;\n\t\tzosia=(zosia*zosia)%mod;\n\t\tn/=2;\n\t}\n\treturn wynik;\n}\n\nll dwumian(int slonko, int misiu)\n{\n\tll c=(silnia[slonko-misiu]*silnia[misiu])%mod;\n\t//cout << c << endl;\n\t//cout << slonko << endl;\n\t//cout << silnia[slonko] << endl;\n\treturn (silnia[slonko]*qpow(c,mod-2))%mod;\n}\n\nint main()\n{\n\t//cout << dwumian(2,0) << endl;\n\tll n,k;\n\tscanf(\"%lld%lld\", &n, &k);\n\t\n\tif(k==1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tlicz(n+n*k);\n\t//cout << dwumian(2,0) << endl;\n\t\n\tdp[0][0]=1;\n\tfor(int i=0; i<=n; ++i)\n\t{\n\t\tfor(int j=max(i,1); j<=n; ++j)\n\t\t{\n\t\t\tif(i!=0)\n\t\t\tdp[i][j]=(dp[i][j]+dp[i-1][j])%mod;\n\t\t\t//cout << i+j*(k-1) << \" \" << k-2 << endl;\n\t\t\t//cout << dwumian(i+j*(k-1),k-2) << endl;\n\t\t\tif(j!=0)\n\t\t\t\tdp[i][j]=(dp[i][j]+(dwumian(i+j*(k-1)-1,k-2)*dp[i][j-1])%mod)%mod;\n\t\t\t//cout << i << \" \" << j << dp[i][j] << endl;\n\t\t}\n\t}\n\tprintf(\"%lld\", (dp[n][n]*silnia[n])%mod);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int N = 2222;\nconst int mod = 1e9 + 7;\n\nint dp[N][N] , n , k , fac[N * N] , inv[N * N];\n\nint Pow(int x , int y = mod - 2) {\n\tint res = 1;\n\tfor(; y ; y >>= 1 , x = x * x % mod) {\n\t\tif(y & 1) {\n\t\t\tres = res * x % mod;\n\t\t}\n\t}\n\treturn res;\n}\n\nint C(int x , int y) {\n\tif(x < y)\n\treturn 0;\n\treturn fac[x] * inv[x - y]  % mod * inv[y] % mod;\n}\n\nvoid Add(int &x , int y) {\n\t(x += y) %= mod;\n}\n\nmain(void) {\n\tscanf(\"%lld%lld\" , &n , &k);\n\tif(k == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0] = 1;\n\tfor(int i = 1;i <= 4e6;++ i) \n\tfac[i] = fac[i - 1] * i % mod;\n\tinv[4000000] = Pow(fac[4000000]);\n\tfor(int i = 4000000 - 1;i >= 0;-- i) {\n\t\tinv[i] = inv[i + 1] * (i + 1) % mod;\n\t}\n\tdp[0][0] = 1;\n\tint All = n * k;\n\tfor(int i = 0;i <= n;++ i) {\n\t\tfor(int j = n;j >= 0;-- j) \n\t\tif(dp[i][j]){\n\t\t\tif(j) {\n\t\t\t\tAdd(dp[i][j - 1] , dp[i][j] * (n - i + j) % mod * C(All - (i + (i - j) * (k - 1) + 1) , k - 2));\n\t\t\t}\n\t\t\tAdd(dp[i + 1][j + 1] , dp[i][j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\" , dp[n][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pi acos(-1)\nusing namespace std;\nconst int mod=1e9+7;\nconst int N=2005;\ninline ll rd(){\n\tll x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=0;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}\n\treturn f?x:-x;\n}int n,k,mx;\nll f[N][N],fac[N*N],inv[N*N];\ninline ll kasumi(ll x,int mi){\n\tll res=1;\n\twhile(mi){\n\t\tif(mi&1) res=res*x%mod;\n\t\tx=x*x%mod;mi>>=1;\n\t}return res;\n}\ninline ll C(int n,int m){\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main(){\n\tn=rd(),k=rd();mx=n*k;\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}fac[0]=inv[0]=1;\n\tfor(int i=1;i<=mx;i++) fac[i]=fac[i-1]*i%mod;\n\tinv[mx]=kasumi(fac[mx],mod-2);\n\tfor(int i=mx-1;i>=1;i--) inv[i]=inv[i+1]*(i+1)%mod;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tf[i][j]=(f[i][j]+f[i-1][j])%mod;\n\t\t\tif(j){\n\t\t\t\tf[i][j]=(f[i][j]+1ll*f[i][j-1]*(n-(j-1))%mod*C(n*k-i-(j-1)*(k-1)-1,k-2)%mod)%mod;\n\t\t\t}\n\t\t}\n\t}cout<<f[n][n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//n种颜色，每种颜色k个球排成一列，将每种颜色最左边的球涂白，求最终状态数\n#include <iostream>\n#include <cstdio>\n#define int long long\nusing namespace std;\nconst int MAX=3e3+5;\nconst int mod=1e9+7;\nint n,k;\nint inv[MAX*MAX],fac[MAX*MAX],facinv[MAX*MAX],dp[MAX][MAX];    //已经放了i个白球和j种颜色的球，当前空格放白色或一种新颜色：dp[i][j]=dp[i-1][j]+dp[\ninline void pre(){\n    fac[0]=facinv[0]=1;\n    inv[1]=fac[1]=facinv[1]=1;\n    for(int i=2;i<MAX*MAX;i++){\n        inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n        fac[i]=fac[i-1]*i%mod;\n        facinv[i]=facinv[i-1]*inv[i]%mod;\n    }\n}\ninline int C(int x,int y){\n    return (fac[x]*facinv[y]%mod)*facinv[x-y]%mod;\n}\nsigned main(){\n    scanf(\"%lld %lld\",&n,&k);\n    if(k==1){\n        printf(\"1\\n\");\n        return 0;\n    }\n    pre();\n    for(int i=1;i<=n;i++){\n        dp[i][0]=1;\n        for(int j=1;j<=i;j++){\n            dp[i][j]=dp[i-1][j]+(dp[i][j-1]*C(n*k-i-(j-1)*(k-1)-1,k-2)%mod)*(n-j+1)%mod;    //从后面空格中选k-2个放当前颜色，枚举当前颜色\n            dp[i][j]%=mod;\n        }\n    }\n    printf(\"%lld\",dp[n][n]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>  \n#define Rg register \n#define i60 long long \n#define fp( i , x , y ) for(Rg int i=(x); i<=(y); ++i) \n#define fq( i , x , y ) for(Rg int i=(y); i>=(x); --i) \nusing namespace std ; \nconst int hgs = 1e9+7 , N = 2005 ; \ni60 f[N][N] , n , k , fac[N*N] , inv[N*N] ; \ni60 power( i60 A , int B ) { \n    i60 tep = 1 ; \n    for( ; B ; B >>= 1 ) { \n        if( B&1 ) tep = tep * A % hgs ; \n        A = A * A % hgs ; \n\t} return tep ;  } \ni60 C ( int A , int B ) { return A == 0 ? 1 : fac[B] * inv[A] % hgs * inv[B-A] % hgs ; }  \nsigned main( ) { \n    cin >> n >> k ;  fac[0] = 1 ; \n    if( k == 1 ) { cout << 1 << endl ; return 0 ; } \n    fp( i , 1 , n*k ) fac[i] = fac[i-1] * i % hgs ;  \n    fp( i , 0 , n*k ) inv[i] = power( fac[i] , hgs-2 ) ;  \n    fp( i , 1 , n ) f[i][0] = 1 ; \n    fp( i , 1 , n ) \n      fp( j , 1 , i ) \n\t    f[i][j] = ( f[i-1][j] + f[i][j-1] \n\t\t   * (n-j+1) % hgs * C( k-2 , n*k-i-(k-1)*(j-1)-1 ) ) % hgs ; \n\tcout << f[n][n] << endl ; \n    return 0 ; \n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define taskname \"A\"\n#define pb  push_back\n#define mp  make_pair\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> ii;\nconst int maxn = 2e3 + 5;\nconst int maxm = maxn * maxn;\nconst int mod = 1e9 + 7;\nint n , k , dp[maxn][maxn];\nint f[maxm] , rf[maxm];\nint C(int n , int k){\n    if(k < 0 || n < 0 || k > n)return 0;\n    return (ll)f[n] * rf[n - k] % mod * rf[k] % mod;\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\",\"r\")){\n        freopen(taskname\".INP\", \"r\",stdin);\n        freopen(taskname\".OUT\", \"w\",stdout);\n    }\n    cin >> n >> k;\n    dp[0][0] = 1;\n    f[0] = f[1] = rf[0] = rf[1] = 1;\n    if(k == 0)return cout << 1 , 0;\n    for(int i = 2 ; i < maxm ; ++i){\n        f[i] = (ll)f[i - 1] * i % mod;\n        rf[i] = (mod - (ll)(mod / i) * rf[mod % i] % mod);\n    }\n    for(int i = 2 ; i < maxm ; ++i)rf[i] = (ll)rf[i - 1] * rf[i] % mod;\n    for(int i = 0 ; i <= n ; ++i){\n        for(int j = 0 ; j <= n ; ++j){\n            if(i == 0 && j == 0)continue;\n            if(i > j)continue;\n            if(i > 0)dp[i][j] = dp[i - 1][j];\n            if(j > 0)dp[i][j] += (ll)dp[i][j - 1] * C(i + j * (k - 1) - 1 , k - 2) % mod;\n            if(dp[i][j] >= mod)dp[i][j] -= mod;\n//            cout << i << \" \" << j << \" \" << dp[i][j] << \" \" <<\n//            i + j * (k - 1) - 1 << \" \" << k - 2 << \" \"  << C(i + j * (k - 1) - 1 , k - 2) <<endl;\n        }\n    }\n    cout << ((ll)dp[n][n] * f[n]) % mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nArthor : Ender_zzm\nE-mail zzm_ender_wiggin@outlook.com\nBlog ender-zzm.enbar.cn\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\ninline int Isdigit(char c) {\n\tif (c < '0' || c > '9') return 0;\n\treturn 1;\n}\ninline int readint(){\n    register int x = 0, flag = 1;\n    register char ch;\n    while (!Isdigit(ch = getchar())) if (ch == '-') flag = -1;\n    while (x = x * 10 + (ch & 15), Isdigit(ch = getchar()));\n\treturn x * flag;\n}\n\ninline long long readlong() {\n\tregister long long x = 0, flag = 1;\n\tregister char ch;\n\twhile (!Isdigit(ch = getchar())) if (ch == '-') flag = -1;\n    while (x = x * 10 + (ch & 15), Isdigit(ch = getchar()));\n\treturn x * flag;\n}\ntemplate <class T>\ninline void write(T x){\n    if (x < 0)\n        putchar('-'), x = -x;\n    if(x >= 10) write(x / 10); \n    putchar(x % 10 + '0');\n}\n\ntemplate<class T> inline bool Chkmax(T& x, const T& y) { return x < y ? x = y, true : false; }\ntemplate<class T> inline bool Chkmin(T& x, const T& y) { return x > y ? x = y, true : false; }\n\n#define For(i, x, y) for (int i = (x); i <= (y); i++) \n#define Rep(i, x, y) for (int i = (x); i >= (y); i--) \n#define ri readint\n#define rl readlong\n\nconst int Mod = 1e9 + 7;\nconst int maxn = 2010;\t\nconst int NN = 2000 * 2000 + 20;\nint n, k;\nint f[maxn][maxn];\nint fac[NN], inv[NN];\nint Pow(int x, int y) {\n\tint ans = 1;\n\twhile (y) {\n\t\tif (y & 1) ans = 1ll * ans * x % Mod;\n\t\tx = 1ll * x * x % Mod;\n\t\ty >>= 1;\n\t}\n\treturn ans;\n}\nlong long C(int n, int m) {\n\treturn 1ll * fac[n] * inv[m] % Mod * inv[n - m] % Mod;\n}\nint main() {\n\tn = ri(), k = ri();\n\tif (k == 1) {\n\t\tputs(\"1\"); return 0;\n\t}\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n * k; i++) {\n\t\tfac[i] = 1ll * fac[i - 1] * i % Mod;\n\t}\n\tinv[n * k] = Pow(fac[n * k], Mod - 2);\n\tfor (int i = n * k - 1; i >= 0; i--) {\n\t\tinv[i] = 1ll * inv[i + 1] * (i + 1) % Mod;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[i][0] = 1;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tf[i][j] += f[i - 1][j];\n\t\t\tif (j == 0) continue;\n\t\t\t(f[i][j] += 1ll * f[i][j - 1] * (n - j + 1) % Mod * C(n * k - i - (j - 1) * (k - 1) - 1, k - 2) % Mod) %= Mod;\n\t\t}\n\t}\n\tcout << f[n][n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int N = 2000 + 10;\nconstexpr int MOD = 1e9 + 7;\n\nlong long dp[N][N], fact[N * N], n, k;\n\nlong long mypow (long long a, long long b) {\n    return b ? (mypow (a * a % MOD, b >> 1) * (b & 1 ? a : 1)) % MOD : 1;\n}\n\nlong long ch (long long a, long long b) {\n    return (fact[a] * mypow (fact[b] * fact[a - b] % MOD, MOD - 2)) % MOD;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> k;\n    fact[0] = 1;\n    for (int i = 1; i < N * N; i++)\n        fact[i] = (fact[i - 1] * i) % MOD;\n    for (int i = 0; i <= n; i++) {\n        for (int j = i; j <= n; j++) {\n            if (i == 0) {\n                if (j == 0)\n                    dp[i][j] = 1;\n                else {\n                    dp[i][j] = ch (j * (k - 1) - 1, k - 2) * dp[i][j - 1];\n                    dp[i][j] %= MOD;\n                }\n                continue;\n            }\n            dp[i][j] = dp[i - 1][j] + ch (i + j * (k - 1) - 1, k - 2) * dp[i][j - 1];\n            dp[i][j] %= MOD;\n        }\n    }\n    cout << (dp[n][n] * fact[n]) % MOD << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <memory.h>\n\ntypedef long long ll;\n\nconst ll N = 2e3 + 5;\nconst ll P = 1e9 + 7;\n\nll n, k;\nll fac[N * N];\nll f[N][N];\n\nll read()\n{\n    ll x = 0, f = 1;\n    char ch = getchar();\n    while ('0' > ch or ch > '9')\n        f = ch == '-' ? -1 : 1, ch = getchar();\n    while ('0' <= ch and ch <= '9')\n        x = x * 10 + ch - 48, ch = getchar();\n    return x * f;\n}\n\nll pow(ll x, ll k)\n{\n    ll res = 1;\n    for (x %= P; k; k >>= 1, x = x * x % P)\n        if (k & 1)\n            res = res * x % P;\n    return res;\n}\n\nll C(ll n, ll m) { return ((fac[n] * pow(fac[m], P - 2)) % P * pow(fac[n - m], P - 2) % P); }\n\nsigned main()\n{\n    n = read(), k = read();\n    if (k == 1)\n    {\n        puts(\"1\");\n        return 0;\n    }\n    fac[0] = 1;\n    for (ll i = 1; i <= n * k; i++)\n        fac[i] = fac[i - 1] * i % P;\n    for (ll i = 0; i <= n; i++)\n        f[i][0] = 1;\n    for (ll i = 1; i <= n; i++)\n        for (ll j = 1; j <= i; j++)\n            f[i][j] = f[i - 1][j] +\n                      f[i][j - 1] * (n - j + 1) % P *\n                          C(n * k - i - (j - 1) * (k - 1) - 1, k - 2) % P;\n    printf(\"%lld\", f[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2017-10-13\n//miaomiao\n//\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define For(i, a, b) for(int i = (a); i <= (int)(b); ++i)\n#define Forr(i, a, b) for(int i = (a); i >= (int)(b); --i)\n\n#define N (2000+5)\n#define M (4000000+5)\n\nconst int P = 1e9 + 7;\n\nint Pow(int a, int anum){\n\tint ret = 1;\n\twhile(anum){\n\t\tif(anum & 1) ret = 1ll * ret * a % P;\n\t\ta = 1ll * a * a % P; anum >>= 1;\n\t}\n\treturn ret;\n}\n\nint fac[M], rfac[M], f[N][N];\n\nvoid Init(int n){\n\tfac[0] = rfac[0] = 1;\n\tFor(i, 1, n) fac[i] = 1ll * fac[i-1] * i % P;\n\n\trfac[n] = Pow(fac[n], P-2);\n\tForr(i, n-1, 1) rfac[i] = 1ll * rfac[i+1] * (i+1) % P;\n}\n\nint C(int a, int b){\n\tif(a < b) return 0;\n\treturn 1ll * fac[a] * rfac[b] % P * 1ll * rfac[a-b] % P;\n}\n\nint main(){\n\tInit(4000000);\n\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\t\n\tif(k == 1){\n\t\tputs(\"1\"); return 0;\n\t}\n\t\n\tf[0][0] = 1;\n\tFor(i, 0, n) For(j, i, n){\n\t\tif(i < n) (f[i+1][j] += f[i][j]) %= P;\n\t\tif(j < n) (f[i][j+1] += 1ll * C(i+(j+1)*(k-1)-1, k-2) * f[i][j] % P) %= P;\n\t}\n\tprintf(\"%d\\n\", 1ll * f[n][n] * fac[n] % P);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n\nconst int mo=1e9+7;\nconst int maxn=2010*2010;\n\nint n,k,dp[2][2010],fac[maxn],inv[maxn];\n\nint power(int x,int k)\n{\n\tint res=1;\n\twhile (k)\n\t{\n\t\tif (k&1) res=(LL)res*x%mo;\n\t\tx=(LL)x*x%mo;\n\t\tk>>=1;\n\t}\n\treturn res;\n}\n\nint C(int n,int m)\n{\n\treturn (LL)fac[n]*inv[n-m]%mo*inv[m]%mo;\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"ball.in\",\"r\",stdin);\n\tfreopen(\"ball.out\",\"w\",stdout);\n#endif\n\tint i,j,fk=0;\n\tscanf(\"%d%d\",&n,&k);\n\tif (k==1) {puts(\"1\"); return 0;}\n\tfac[0]=1;\n\tfor (i=1;i<=n*k;i++)\n\t\tfac[i]=(LL)i*fac[i-1]%mo;\n\tinv[0]=inv[1]=1;\n\tfor (i=2;i<=n*k;i++)\n\t\tinv[i]=mo-(LL)inv[mo%i]*(mo/i)%mo;\n\tfor (i=1;i<=n*k;i++)\n\t\tinv[i]=(LL)inv[i]*inv[i-1]%mo;\n\n\tdp[fk][0]=1;\n\tfor (i=0;i<n<<1;i++)\n\t{\n\t\tfk^=1;\n\t\tmemset(dp[fk],0,sizeof(dp[fk]));\n\t\tfor (j=1;j<=n&&j<=n+n-i;j++)\n\t\t\t(dp[fk][j-1]+=dp[fk^1][j])%=mo;\n\t\tfor (j=0;j<n&&j<n+n-i;j++)\n\t\t\tif (dp[fk^1][j]) (dp[fk][j+1]+=(LL)dp[fk^1][j]*C((i+j)*k/2-j+k-2,k-2)%mo)%=mo;\n\t}\n\tprintf(\"%lld\\n\",(LL)dp[fk][0]*fac[n]%mo);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2010, MOD = (int)(1e9 + 7);\nint dp[N][N],n,k;\ntypedef long long ll;\nll power(ll a,int b) {\n  ll ret = 1;\n  while (b) {\n    if (b&1) ret = 1ll * ret * a % MOD;\n    a = 1ll * a * a % MOD;\n    b >>= 1;\n  }\n  return ret;\n}\nll jc[N * N],inv[N * N];\nll comb(int a,int b) {\n  if (a < 0 || b < 0 || a < b) return 0;\n  return 1ll * jc[a] * inv[b] % MOD * inv[a-b] % MOD;\n}\nint main() {\n  scanf(\"%d%d\",&n,&k);\n  if (k == 1) return puts(\"0\"), 0;\n  jc[0] = 1;\n  for (int i = 1 ; i <= n * k ; ++ i)\n    jc[i] = 1ll * jc[i-1] * i % MOD;\n  inv[n*k] = power(jc[n*k],MOD-2);\n  for (int i = n*k-1 ; i >= 0 ; -- i)\n    inv[i] = 1ll * inv[i+1] * (i+1) % MOD;\n  dp[0][0] = 1;\n  for (int i = 0 ; i <= n ; ++ i)\n    for (int j = 0 ; j <= i ; ++ j) {\n      (dp[i+1][j] += dp[i][j]) %= MOD;\n      if (i > j) (dp[i][j+1] += 1ll * comb(n*k-j*k-(i-j)-1,k-2) * dp[i][j] % MOD) %= MOD;\n    }\n  printf(\"%lld\\n\",1ll * dp[n][n] * jc[n] % MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define loop(n,i) for(register int i=1;i<=(n);++i)\n#define zxc(x) cerr<<(#x)<<'='<<(x)<<'\\n'\n#define zxcv(x) cerr<<(#x)<<'='<<(x)<<','\n#define zcx zxc\n#define MAX 5000009\n#define int long long\n#define P 1000000007\nusing namespace std;\ntypedef pair<int,int> pr;\ninline int icin(){\n\tchar c=getchar();int s=0;bool sign=0;\n\twhile(!isdigit(c)&&c^'-')c=getchar();\n\tif(c=='-')c=getchar(),sign=1;\n\twhile(isdigit(c))s=(s<<1)+(s<<3)+c-'0',c=getchar();\n\treturn sign?-s:s;\n}\nint n,k;\ninline int Quick(int a,int m){int ans=1;for(;m;m>>=1,a=a*a%P) if(m&1) ans=ans*a%P;return ans;}\nint fact[MAX],ifact[MAX];\ninline int binom(int n,int m){return n<m?0:fact[n]*ifact[m]%P*ifact[n-m]%P;}\nint f[MAX];\nmain(){\n\tn=icin(),k=icin();\n\tint bound=n*k+k;\n\tfact[0]=1;loop(bound,i) fact[i]=fact[i-1]*i%P;\n\tifact[bound]=Quick(fact[bound],P-2);for(register int i=bound;i;--i) ifact[i-1]=ifact[i]*i%P;\n\tf[1]=1;\n\tfor(register int i=2;i<=n;++i){\n\t\tfor(register int j=0;j<=k-1;++j){\n\t\t\t(f[i]+=f[i-1]*binom((i-1)*(k-1)+j,j)%P*(j<k-1?i:1)%P)%=P;\n\t\t}\n\t}\n\tcout<<f[n];\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int maxN = 2e3 + 13, mod = 1e9 + 7;\nint n, k, dp[maxN][maxN], fac[maxN * maxN], rfac[maxN * maxN];\n\nint pw (int a, int b) {\n    int ret = 1;\n    for (; b; b >>= 1, a = 1ll * a * a % mod)\n\tif (b & 1)\n\t    ret = 1ll * ret * a % mod;\n    return ret;\n}\n\nint c (int a, int b) {\n    return 1ll * fac[b] * rfac[a] % mod * rfac[b - a] % mod;\n}\n\nint32_t main () {\n    cin >> n >> k;\n    dp[0][0] = 1;\n    fac[0] = rfac[0] = 1;\n    for (int i = 1; i <= n * k; i++) {\n\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\trfac[i] = 1ll * rfac[i - 1] * pw(i, mod - 2) % mod;\n    }\n\n    for (int i = 1; i <= n; i++)\n\tfor (int j = 0; j <= i; j++) {\n\t    if (j)\n\t\tdp[i][j] = dp[i][j - 1];\n\t    dp[i][j] = (dp[i][j] + (1ll * dp[i - 1][j] * c(k - 2, i * (k - 1) + j - 1) % mod)) % mod;\n\t    // cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t}\n    //cout << dp[n][n] << endl;\n    if (k == 1)\n\treturn cout << 1 << endl, 0;\n    cout << 1ll * dp[n][n] * fac[n] % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int p=1e9+7,N=4010,M=4e6+5;\nint dp[N][N],fac[M],finv[M],inv[M];\nint comb(int n,int m){return n<m?0:fac[n]*1ll*finv[m]%p*finv[n-m]%p;}\nint main()\n{\n    int n=4e6,k;\n    fac[1]=fac[0]=finv[1]=finv[0]=inv[1]=1;\n    for(int i=2;i<=n;i++)\n        inv[i]=(p-p/i)*1ll*inv[p%i]%p,fac[i]=1ll*fac[i-1]*i%p,\n        finv[i]=finv[i-1]*1ll*inv[i]%p;\n    cin>>n>>k;\n    if(k==1){cout<<1<<endl;return 0;}\n    dp[1][0]=1;\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=0;j<=i;j++)\n        {\n            if(i==1&&j==0)continue;\n            dp[i][j]=((j!=i)*dp[i-1][j]+\n                     (j!=0)*1ll*comb(n-i+(n-j+1)*(k-1)-1,k-2)*dp[i][j-1])%p;\n        }\n    }\n    printf(\"%lld\\n\",1ll*dp[n][n]*fac[n]%p);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: CNYALI_LK\nLANG: C++\nPROG: f.cpp\nMail: cnyalilk@vip.qq.com\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\n#define int long long\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst signed inf=0x3f3f3f3f;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T>int chkmin(T &a,T b){return a>b?a=b,1:0;}\ntemplate<class T>int chkmax(T &a,T b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T>T mmin(T a,T b){return a<b?a:b;}\ntemplate<class T>T mmax(T a,T b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\tinline void read (signed &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t}\n\n\tinline void read (long long &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t}\n\tinline void read (char &x) {\n\t\tx=gc();\n\t}\n\tinline void read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'))*(++x)=gc();\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline void read(A &x,B &...y){\n\t\tread(x);read(y...);\n\t}\n\t// print a signed integer\n\tinline void write (signed x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\n\tinline void write (long long x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\tinline void write (char x) {\n\t\tputc(x);\n\t}\n\tinline void write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t}\n\tinline void write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline void write(A x,B ...y){\n\t\twrite(x);write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint fac[4000005],inv[4000005],invf[4000005];\nint f[2005][2005];\nconst int p=1000000007;\nint C(int a,int b){return a<0||a<b||b<0?0:fac[a]*invf[b]%p*invf[a-b]%p;}\nsigned main(){\n#ifdef cnyali_lk\n\tfreopen(\"f.in\",\"r\",stdin);\n\tfreopen(\"f.out\",\"w\",stdout);\n#endif\n\tint n,k;\t\n\tread(n,k);\n\tif(k==1)return printf(\"1\\n\"),0;\n\tfac[0]=fac[1]=inv[1]=invf[0]=invf[1]=1;\n\tfor(int i=2;i<=n*k;++i){\n\t\tfac[i]=fac[i-1]*i%p;\n\t\tinv[i]=(p-p/i)*inv[p%i]%p;\n\t\tinvf[i]=inv[i]*invf[i-1]%p;\n\t}\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tf[i][0]=1;\n\t\tfor(int j=1;j<=i;++j){\n\t\t\tf[i][j]=(f[i-1][j]+f[i][j-1]*C(n-i+(n-j+1)*(k-1)-1,k-2))%p;\n//\t\t\twrite(f[i][j],j==i?'\\n':' ');\n//\t\t\twrite('(',n-i+(n-j+1)*(k-1),',',j-1,\")=\",C(n-i+(n-j+1)*(k-1),j-1),j==i?'\\n':' ');\n\t\t}\n\t}\n\twrite(f[n][n]*(k>1?fac[n]:1)%p,'\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MN = 20123, MOD = 1000 * 1000 * 1000 + 7;\nint inv[MN], fict[MN], invf[MN], dp[MN][MN];\n\nvoid fact() {\n\tfict[0] = inv[0] = invf[0] = 1;\n\tfict[1] = inv[1] = invf[1] = 1;\n\tfor (int i = 2; i < MN; i++) {\n\t\tinv[i] = 1ll * inv[MOD % i] * (MOD - MOD / i) % MOD;\n\t\tfict[i] = 1ll * fict[i - 1] * i % MOD;\n\t\tinvf[i] = 1ll * invf[i - 1] * inv[i] % MOD;\n\t}\n}\n\nint chose(int a, int b) {\n\treturn 1ll * fict[b] * invf[a] % MOD * invf[b - a] % MOD;\n}\n\nint main() {\n\tfact();\n\tint n, k;\n\tcin >> n >> k;\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tif (j > i)\n    \t          continue;\n\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\tif (j)\n\t\t\t\tdp[i][j] = (dp[i][j] + 1ll * dp[i][j - 1] * chose(k - 2, n * k - (j - 1) * (k - 1) - i - 1) % MOD) % MOD;\n        }\n\tcout << 1ll * dp[n][n] * fict[n] % MOD;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nll mo=1000000007;\nll combi(ll N_, ll C_) {\n\tconst int NUM_=4500001;\n\tstatic ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];\n\tif (fact[0]==0) {\n\t\tinv[1]=fact[0]=factr[0]=1;\n\t\tfor (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\t\tfor (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;\n\t}\n\tif(C_<0 || C_>N_) return 0;\n\treturn factr[C_]*fact[N_]%mo*factr[N_-C_]%mo;\n}\n\nint N,K;\nll dp[2020][2020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>K;\n\tif(K==1) return _P(\"1\\n\");\n\t\n\tdp[0][1]=1;\n\tfor(y=2;y<=N;y++) dp[0][y] = dp[0][y-1]*combi(y*(K-1)-1,K-2)%mo;\n\t\n\tfor(x=1;x<=N;x++) {\n\t\t\n\t\tif(x==1) dp[1][1]=1;\n\t\telse dp[x][x]=dp[x-1][x];\n\t\t\n\t\tfor(y=x+1;y<=N;y++) dp[x][y] = (dp[x-1][y] + dp[x][y-1]*combi(x+y*(K-1)-1,K-2))%mo;\n\t}\n\t\n\tll ret=dp[N][N];\n\tfor(i=1;i<=N;i++) ret=ret*i%mo;\n\tcout<<ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cstdlib>\n#include <utility>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstring>\n\nusing namespace std;\n\n#define ll long long\n\n#ifndef ONLINE_JUDGE\n#define debug(format, ...) fprintf(stderr, \\\n    \"%s:%d: \" format \"\\n\", __func__, __LINE__,##__VA_ARGS__)\n#else\n#define debug(format, ...)\n#define NDEBUG\n#endif\n\n#define DEFMOD(mod, type) typedef ModInt<mod, int> type;     \\\n                          type operator \"\" _m(unsigned long long x) {   \\\n                              type res = x; return res; \\\n                          }\n\ntemplate<int mod, class itype> struct ModInt {\n    int val;\n    ModInt() {\n        val = 0;\n    }\n    ModInt(int a) {\n        val = a % mod;\n    }\n};\n\n/* MODIFY AS NEEDED */\n\nDEFMOD(1000000007, mi)\n\ntemplate<int mod, class itype> ModInt<mod, itype> fpow(ModInt<mod, itype> base, int exponent)\n{\n    ModInt<mod, itype> ans = 1_m;\n    ModInt<mod, itype> cur = base;\n    while (exponent) {\n        if (exponent & 1) ans = ans * cur;\n        cur = cur * cur; exponent >>= 1;\n    }\n    return ans;\n}\n\ntemplate<int mod, class itype> ModInt<mod, itype> operator+(ModInt<mod, itype> a, ModInt<mod, itype> b)\n{\n    ModInt<mod, itype> ans;\n    ll val = (ll)(a.val) + (ll)(b.val);\n    if (val >= mod) val -= mod;\n    ans.val = val; return ans;\n}\n\ntemplate<int mod, class itype> ModInt<mod, itype> operator-(ModInt<mod, itype> a, ModInt<mod, itype> b)\n{\n    ModInt<mod, itype> ans;\n    ans.val = a.val - b.val;\n    if (ans.val < 0) ans.val += mod;\n    return ans;\n}\n\ntemplate<int mod, class itype> ModInt<mod, itype> operator*(ModInt<mod, itype> a, ModInt<mod, itype> b)\n{\n    ModInt<mod, itype> ans;\n    ans.val = ((ll)(a.val) * (ll)(b.val)) % (ll)mod;\n    return ans;\n}\n\n// PRIME MOD ONLY!\ntemplate<int mod, class itype> ModInt<mod, itype> operator/(ModInt<mod, itype> a, ModInt<mod, itype> b)\n{\n#ifndef ONLINE_JUDGE\n    if (b.val == 0) {\n        fprintf(stderr, \"Division by zero :(\\n\"); abort();\n    }\n#endif\n    return a * fpow(b, mod - 2);\n}\n\nmi f[2005][2005];\nint n, k;\n\nmi fact[4000005];\nmi ifact[4000005];\n\nmi C(int x, int y)\n{\n    return fact[x] * ifact[y] * ifact[x-y];\n}\n\nint main()\n{\n    fact[0] = 1_m;\n    for (int i = 1; i <= 4000000; i++) {\n        fact[i] = (mi)i * fact[i-1];\n    }\n    ifact[4000000] = 1_m / fact[4000000];\n    for (int i = 3999999; i >= 0; i--) {\n        ifact[i] = ifact[i+1] * (mi)(i + 1);\n    }\n    scanf(\"%d%d\", &n, &k);\n    if (k == 1) {\n        printf(\"1\"); return 0;\n    }\n    f[0][0] = 1_m;\n    for (int j = 1; j <= n; j++) {\n        for (int i = n; i >= 0; i--) {\n            f[i][j] = (i > 0 ? C(k * j - i - 1, k - 2) * f[i-1][j-1] : 0_m)\n                + f[i+1][j];\n        }\n    }\n    printf(\"%d\", (f[0][n] * fact[n]).val);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 2005\nusing namespace std;\nint n,m;\nconst int mod=1e9+7; \nlong long ans=1,res=1,a[M*M],inv[M*M],f[M][M];\ninline long long ksm(long long k,long long x)\n{\n\tlong long y=1;\n\twhile(x)\n\t{\n\t\tif(x&1)y=y*k%mod;\n\t\tx>>=1;\n\t\tk=k*k%mod;\n\t}\n\treturn y;\n}\ninline long long c(int n,int m)\n{\n\treturn a[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main()\n{\n\tregister int i,j;\n\tscanf(\"%d%d\",&n,&m);\n\tif(m==1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\ta[0]=1;inv[0]=1;\n\tfor(i=1;i<=n*m;i++)a[i]=a[i-1]*i%mod,inv[i]=inv[i-1]*ksm(i,mod-2)%mod;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tf[i][0]=1;\n\t\tfor(j=1;j<=i;j++)\n\t\t{\n\t\t\tf[i][j]=(f[i-1][j]+f[i][j-1]*(n-j+1)%mod*c(n*m-i-(j-1)*(m-1)-1,m-2)%mod)%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\",f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconstexpr LL MOD = 1'000'000'007LL;\nint N, K;\nLL fac[4'000'001], fac_inv[4'000'001];\nLL mpow(LL a, LL n) {\n    LL r = 1;\n    while (n) {\n        if (n % 2) r = r * a % MOD;\n        n /= 2, a = a * a % MOD;\n    }\n    return r;\n}\nLL C(int n, int m) {\n    if (m > n) return 0;\n    return fac[n] * fac_inv[m] % MOD * fac_inv[n - m] % MOD;\n}\nLL dp[2001][2001];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    fac[0] = fac_inv[0] = 1;\n    for (int i = 1; i <= 4000000; i++) {\n        fac[i] = fac[i - 1] * i % MOD;\n        fac_inv[i] = mpow(fac[i], MOD - 2);\n    }\n    cin >> N >> K;\n    if (N == 1 || K == 1) {\n        cout << \"1\\n\";\n    } else {\n        dp[0][0] = 1;\n        for (int j = 1; j <= N; j++) {\n            dp[0][j] = dp[0][j - 1] * C((K - 1) * j - 1, K - 2) % MOD;\n        }\n        for (int i = 1; i <= N; i++) {\n            dp[i][i] = dp[i - 1][i];\n            for (int j = i + 1; j <= N; j++) {\n                dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] * C(K * i + (K - 1) * (j - i) - 1, K - 2)) % MOD;\n            }\n        }\n        cout << dp[N][N] * fac[N] % MOD << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define IL inline\n#define RG register\n#define LL long long\n#define Upd(a) (a)>=mod?(a-=mod):1\nusing namespace std;\ntemplate <class T>\nIL char gc () {\n\tstatic char buf[1<<6], *p1=buf, *p2=buf;\n\treturn (p1==p2) && (p2=(p1=buf)+fread(buf,1,1<<6,stdin), p1==p2) ?EOF:*p1++;\n}\ntemplate <typename T>\nIL void read (T&data) {\n\tdata=0;\n\tRG char ch=0;\n\twhile (ch<'0' || ch>'9') ch=getchar();\n\twhile (ch<='9' && ch>='0') data=(data<<1)+(data<<3)+(ch&15), ch=getchar();\n}\nconst int mod = 1e9+7;\nconst int _ =2001;\nint n, k;\nint dp[2][_], jc[_*_], jcn[_*_];\nIL int poww (RG int a, RG int b) {\n\tRG int ret=1, Base=a;\n\tfor (;b;b>>=1, Base=1LL*Base*Base%mod) if (b&1) ret=1LL*ret*Base%mod;\n\treturn ret;\n}\nIL int C (RG int a, RG int b) {\n\tif (a<b) return 0;\n\treturn 1LL*jc[a]*jcn[b]%mod*jcn[a-b]%mod;\n}\nint main () {\n\tread(n), read(k);\n\tif (k<=1) {puts(\"1\"); return 0;}\n\tjc[0]=jcn[0]=1;\n\tRG int i, j, pre=1, cur=0;\n\tfor (i=1; i<=n*k; ++i) jc[i]=1LL*jc[i-1]*i%mod, jcn[i]=poww(jc[i], mod-2);\n\tdp[0][0]=1;\n\tfor (i=1; i<=n*2; ++i) {\n\t\tswap(cur, pre);\n\t\tfor (j=0; j<min(i,n+1); ++j) dp[cur][j]=0;\n\t\tfor (j=1; j<=min(i,n); ++j) {\n\t\t\tif ((i-j)%2) continue;\n\t\t\tif (n*2-i+1<j) break;\n\t\t\tRG int a=(i+j-2)>>1, b=(i-j)>>1;\n\t\t\tdp[cur][j]=1LL*dp[pre][j-1]*C(a*(k-1)+b+k-1-1,k-1-1)%mod;\n\t\t\tdp[cur][j]+=dp[pre][j+1];\n\t\t\tUpd(dp[cur][j]);\n\t\t}\n\t\tif (cur%2==0) dp[cur][0]=dp[pre][1];\n\t}\n\tprintf(\"%lld\",1LL*dp[cur][0]*jc[n]%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int TT=1e9+7;\nint n,k,F[2005][2005],fact[5005000];\ninline int power(int base,int p,int ret=1) {\n\tfor (;p;base=1ll*base*base%TT,p>>=1) if (p&1) ret=1ll*ret*base%TT; return ret;\n}\ninline int C(int x,int y) {\n\treturn 1ll*fact[x]*power(1ll*fact[y]*fact[x-y]%TT,TT-2)%TT;\n}\ninline void M(int &x) {\n\tif (x>=TT) x-=TT;\n}\nint main() {\n\tcin>>n>>k;\n\tfact[0]=1; for (int i=1;i<=n*k;i++) fact[i]=1ll*fact[i-1]*i%TT;\n\tif (k==1) return cout<<1<<endl, 0;\n\tfor (int i=1;i<=n;i++) F[i][0]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=i;j++) \n\t\t\tF[i][j]=F[i-1][j]+1ll*(n-j+1)*F[i][j-1]%TT*C(n*k-i-(k-1)*(j-1)-1,k-2)%TT, M(F[i][j]);\n\treturn cout<<F[n][n], 0;\n}\n/*\n\t\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\nconst int mo = 1e9 + 7, N = 2e3 + 10, E = 5e6;\ntypedef long long ll;\nll f[N][N],jc[E],njc[E],suf[N][N];\nll n,k;\nll ksm(ll x,ll y) {\n\tll ret = 1; for (; y; y>>=1) {if (y&1) ret = ret * x % mo;\n\t\tx = x * x % mo;\n\t}\n\treturn ret;\n}\nll C(ll x,ll y) {\n\tif (x < y) return 0;\n\treturn jc[x] * njc[x-y] % mo * njc[y] % mo;\n}\nint main() {\n\tcin>>n>>k; if (k == 1) {\n\t\tprintf(\"1\"); return 0;\n\t}\n\tsuf[0][0] = f[0][0] = 1;\n\tjc[0] = 1; for (int i = 1; i < E; i++) jc[i] = jc[i-1] * i % mo;\n\tnjc[E-1] = ksm(jc[E - 1],mo-2);\n\tfor (int i = E-2; ~i; i--) njc[i] = njc[i+1] * (i+1) % mo;\n\tfor (int i = 1; i <= n; suf[i][0]=suf[i][1],i++) for (int j = i; j; j--) {\n\t\tf[i][j] = suf[i-1][j-1] * C(k+k*(i-1)-j-1,(i-1)*k-j+1) % mo;\n\t\tsuf[i][j] = (suf[i][j+1] + f[i][j]) % mo;\n\t}\n\tprintf(\"%lld\\n\",suf[n][1] * jc[n] % mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\n#define MAXN 2050\n#define ll long long\n#define Mod 1000000007\n\nusing namespace std ; int i, j ; int N, M ; \nll Fac[MAXN * MAXN], Inv[MAXN * MAXN]/*Co[MAXN][MAXN], */, dp[MAXN][MAXN] ;\n\nll expow(ll a, int b){\n\tll res = 1 ; \n\twhile (b){\n\t\tif (b & 1) res = res * a % Mod ;\n\t\ta = a * a % Mod, b = b >> 1 ;\n\t}\n\treturn res ;\n} \nll Co(int n, int m){\n\tif (n < m) return 0 ; \n\treturn Fac[n] * Inv[m] % Mod * Inv[n - m] % Mod ; \n}\nint main(){\n\tcin >> N >> M ; /*Co[0][0] = 1 ; */\t Inv[0] = 1 ;\n\tfor (i = 0 ; i <= N ; ++ i) dp[i][0] = 1 ; Fac[0] = 1 ;\n\tfor (i = 1 ; i <= N * M ; ++ i) Fac[i] = Fac[i - 1] * i % Mod ;\n\tfor (i = 1 ; i <= N * M ; ++ i) Inv[i] = expow(Fac[i], Mod - 2) ;  \n\t/*for (i = 1 ; i <= N ; ++ i){\n        Co[i][0] = 1 ;\n        for (j = 1 ; j <= N ; ++ j) Co[i][j] = (Co[i - 1][j - 1] + Co[i - 1][j]) % Mod ;\n    }*/\n\tfor (i = 1 ; i <= N ; ++ i)\n\t\tfor (j = 1 ; j <= i ; ++ j)\n\t\t\tdp[i][j] = (dp[i - 1][j]  + dp[i][j - 1] * (N - j + 1) % Mod * Co(N * M - i - (j - 1) * (M - 1) - 1, M - 2) % Mod) % Mod ;\n\tcout << (M <= 1 ? 1 : dp[N][N]) << endl ; return 0 ; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=8000005;\nll n,k,fac[N],inv[N],f[2005][2005],mod=1e9+7;\nll power(ll a,ll b){\n\tll res=1,tmp=a;\n\twhile(b){\n\t\tif(b&1)res=res*tmp%mod;\n\t\ttmp=tmp*tmp%mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nll C(ll n,ll m){\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n} \nint main(){\n\tscanf(\"%lld%lld\",&n,&k);\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=n*k;i++){\n\t\tfac[i]=fac[i-1]*i%mod;\n\t\tinv[i]=power(fac[i],mod-2);\n\t}\n\tfor(int i=0;i<=n;i++)f[i][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t\tf[i][j]=f[i-1][j]%mod+f[i][j-1]%mod*(n-j+1)%mod*C(n*k-i-1-(j-1)*(k-1),k-2)%mod;\n\tprintf(\"%lld\",f[n][n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll maxx = 2005, mod = 1e9 + 7;\n\nll dp[maxx][maxx], n, k, fac[maxx * maxx];\n\nll pw(ll a, ll b)\n{\n\tif (!b) return 1ll;\n\tll x = pw(a, b / 2);\n\tx = (x * x) % mod;\n\tif (b % 2) x = (x * a) % mod;\n\treturn x;\n}\n\nll sel(ll a, ll b)\n{\n\tll x = fac[a];\n\tx = (x * pw(fac[b], mod - 2)) % mod;\n\tx = (x * pw(fac[a-b], mod - 2)) % mod;\n\treturn x;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tfac[0] = 1ll; for(ll i = 1; i < maxx * maxx; i++) fac[i] = (fac[i-1] * i) % mod;\n//\tcout << pw(2, 11111) << \" \" << sel(45 * 46 - 1, 44) << endl;\n\tcin >> n >> k;\n\tif (k == 1) return cout << 1 << endl, 0;\n\tdp[0][0] = 1;\n\tfor(ll i = 1; i <= n; i++)\n\t{\n\t\tfor(ll j = 0; j < i; j++)\n\t\t{\n\t\t\tdp[i][j] = ((j ? dp[i][j-1] : 0ll) + (((sel(i * (k - 1) + j - 1, k - 2)) * dp[i-1][j]) % mod)) % mod;\n//\t\t\tif (i == n)\n//\t\t\tcout << i << \" \" << j << \"     \" << dp[i][j] << endl;\n\t\t}\n\t\tdp[i][i] = dp[i][i-1]; \n//\t\tcout << i << \" \" << i << \"      \" << dp[i][i] << endl;\n\t}\n//\tcout << dp[n][n] << endl;\n\tcout << (1ll * dp[n][n] * fac[n]) % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\ninline ll read() {char ch = getchar(); ll x = 0, f = 1;while(ch < '0' || ch > '9') {if(ch == '-') f = -1;ch = getchar();}while('0' <= ch && ch <= '9') {x = x * 10 + ch - '0';ch = getchar();} return x * f;}\nint fastmi(int i,int b,int p){ll ans=1,now=i;while (b)\t{if (b&1)  ans=now*ans%p;now=now*now%p;b>>=1;}return ans;}\nconst int kcz=1e9+7;\nconst int N=2005;\nconst int M=4e6+7;\nll f[N][N],mi[M],inv[M],jv[M];\nll C(int n,int m){\n\treturn mi[m]*jv[n]%kcz*jv[m-n]%kcz;}\nint main(){\n\tint n=read(),k=read();\n\tif (k==1) {printf(\"1\");return 0;}\n\t\n\tmi[0]=1;\n\tinv[0]=1;\n\tinv[1]=1;\n\tjv[1]=jv[0]=1;\n\tfor (int i=1;i<=n*k;i++) mi[i]=mi[i-1]*i%kcz;\n\tfor (int i=2;i<=n*k;i++) inv[i]=inv[kcz%i]*(kcz-kcz/i)%kcz;\n\tfor (int i=2;i<=n*k;i++) jv[i]=jv[i-1]*inv[i]%kcz;\n\t\n\t\n\tf[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=0;j<=i;j++)\n\t\t{\n\t\t\tf[i][j]=(f[i][j]+f[i-1][j])%kcz;\n\t\t\tif (j)\n\t\t\t\tf[i][j]=(f[i][j]+f[i][j-1]*(n-j+1)%kcz*C(k-2,n-i+(n-j+1)*(k-1)-1))%kcz;\n\t\t}\n\t}\n\tprintf(\"%lld\",f[n][n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "\n/*{{{*/\n//#pragma GCC optimize(\"O3\")\n\n#include <bits/stdc++.h>\n\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\n\ntypedef long long ll;\ntypedef std::pair<int, int> pii;\n\nstd::string Name = __FILE__;\nstd::string iput = Name.substr(0, Name.length() - 4) + \".in\";\nstd::string oput = Name.substr(0, Name.length() - 4) + \".out\";\n\ntemplate <class T> inline bool chkmin(T &x, T y) { return x > y ? x = y, true : false; }\ntemplate <class T> inline bool chkmax(T &x, T y) { return x < y ? x = y, true : false; }\n\ntemplate <class T> inline T &read(T &x)\n{\n    static int f;\n    static char c; \n    for (f = 1; !isdigit(c = getchar()); ) {\n        if (c == '-')\n            f = -1;\n    }\n    for (x = 0; isdigit(c); c = getchar()) {\n        x = x * 10 + c - 48;\n    }\n    return x *= f;\n}\n \ntemplate <class T> inline void write(T x, const char p = '\\n')\n{\n    static int top;\n    static int s[30];\n    if (x < 0) {\n        x = -x;\n        putchar('-');\n    }\n    do s[++ top] = x % 10 + 48;\n    while (x /= 10);\n    while (top)\n        putchar(s[top --]);\n    putchar(p);\n}\n/*}}}*/\n \nconst int maxn = 2000 + 5;\nconst int mo = 1e9 + 7;\n\ninline long long qpow(long long a, long long n)\n{\n    long long ret = 1;\n    while (n) {\n        if (n & 1) ret = ret * a % mo;\n        a = a * a % mo;\n        n >>= 1;\n    }\n    return ret;\n}\n \nint n;\nint k;\nint f[maxn][maxn];\n\nlong long fac[maxn * maxn], inv[maxn * maxn];\n\nlong long C(int a, int b)\n{\n    return fac[a] * inv[b] % mo * inv[a - b] % mo;\n}\n\nvoid exec()\n{\n    read(n), read(k);\n    if (k == 1) write(1), exit(0);\n\n    for (int i = fac[0] = 1; i <= n * k; ++ i) {\n        fac[i] = fac[i - 1] * i % mo;\n    }\n    inv[n * k] = qpow(fac[n * k], mo - 2);\n    for (int i = n * k - 1; ~i; -- i) {\n        inv[i] = inv[i + 1] * (i + 1) % mo;\n    }\n\n    f[n][n] = 1;\n    for (int i = n; ~i; -- i)\n        for (int j = n; j >= i; -- j) {\n            if (i) (f[i - 1][j] += f[i][j]) %= mo;\n            if (j > i) (f[i][j - 1] += f[i][j] * C(i + j * (k - 1) - 1, k - 2) % mo) %= mo;\n        }\n\n    long long ans = f[0][0] * fac[n] % mo;\n    write(ans);\n}\n\n/*{{{*/\nint main() \n{\n    if (fopen(iput.c_str(), \"r\") != NULL) {\n        freopen(iput.c_str(), \"r\", stdin);\n        freopen(oput.c_str(), \"w\", stdout);\n    }\n\n    exec();\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n/*}}}*/\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#define file(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout);\nusing namespace std;\nconst int MAXN = 2005;\nconst int MOD = 1e9 + 7;\nint n, K;\nint jc[MAXN * MAXN] = {1}, inv[MAXN * MAXN];\nint f[MAXN][MAXN];\n\nint quick_pow(int a, int x) {\n    int res = 1;\n    while (x) {\n        if (x & 1)\n            res = 1ll * res * a % MOD;\n        a = 1ll * a * a % MOD, x >>= 1;\n    }\n    return res;\n}\n\nint calc_C(int n, int r) {\n    if (n < r)\n        return 0;\n    return 1ll * jc[n] * inv[r] % MOD * inv[n - r] % MOD;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &K);\n    if (K == 1) {\n        printf(\"1\");\n        return 0;\n    }\n    for (int i = 1; i <= n * n; i++)\n        jc[i] = 1ll * jc[i - 1] * i % MOD;\n    inv[n * n] = quick_pow(jc[n * n], MOD - 2);\n    for (int i = n * n; i; i--)\n        inv[i - 1] = 1ll * i * inv[i] % MOD;\n    f[0][0] = 1;\n    for (int i = 0; i <= n; i++)\n        for (int j = 0; j <= n; j++) {\n            if (i != j)\n                f[i + 1][j] = (f[i + 1][j] + f[i][j]) % MOD;\n            f[i][j + 1] = (f[i][j + 1] + 1ll * f[i][j] * calc_C((j + 1) * (K - 1) + i - 1, K - 2) % MOD) % MOD;\n        }\n    printf(\"%lld\", 1ll * f[n][n] * jc[n] % MOD);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*只要保证这个颜色开始的第一个填在第一个空位上\n之后的都随便填即可\n所以方案数就是C(空格位置-1,数量-1),组合意义就是这个颜色的小球中有一个填的位置是被钦定的，然后有一个空位也是被钦定填的，所以都要-1*/\n#include<bits/stdc++.h>\n#define Mod 1000000007\n#define N 2005\n#define M N*N\nusing namespace std;\nint n,K,dp[N][N],fac[M],inv[M];\ninline int ksm(int x,int y){\n\tint ans1=1;while (y){\n\t\tif (y&1) ans1=1ll*ans1*x%Mod;\n\t\ty>>=1;x=1ll*x*x%Mod;\n\t}return ans1;\n}\ninline int C(int n,int m){return 1ll*fac[n]*inv[m]%Mod*inv[n-m]%Mod;}\nint main(){\n\tscanf(\"%d%d\",&n,&K);\n\tif (K==1) return puts(\"1\"),0;dp[0][0]=1;\n\tfac[0]=1;for (int i=1;i<M;i++) fac[i]=1ll*fac[i-1]*i%Mod;\n\tinv[M-1]=ksm(fac[M-1],Mod-2);\n\tfor (int i=M-2;~i;i--) inv[i]=1ll*inv[i+1]*(i+1)%Mod;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<=i;j++){\n\t\t\tif (i) dp[i][j]=1ll*(dp[i][j]+dp[i-1][j])%Mod;\n\t\t\tif (j) dp[i][j]=1ll*(1ll*dp[i][j-1]*C(n*K-i-(j-1)*(K-1)-1,K-2)%Mod+dp[i][j])%Mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",1ll*dp[n][n]*fac[n]%Mod);//颜色序列有n!种排列 \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 2005\n\nusing namespace std;\ninline int Get() {int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}while('0'<=ch&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}return x*f;}\n\nconst ll mod=1e9+7;\nll ksm(ll t,ll x) {\n\tll ans=1;\n\tfor(;x;x>>=1,t=t*t%mod)\n\t\tif(x&1) ans=ans*t%mod;\n\treturn ans;\n}\nint n,k;\nll fac[N*N],ifac[N*N];\nvoid pre(int n) {\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++) fac[i]=fac[i-1]*i%mod;\n\tifac[n]=ksm(fac[n],mod-2);\n\tfor(int i=n-1;i>=0;i--) ifac[i]=ifac[i+1]*(i+1)%mod;\n}\nll C(int n,int m) {return fac[n]*ifac[m]%mod*ifac[n-m]%mod;}\nll f[N][N];\nint main() {\n\tpre(4e6);\n\tn=Get(),k=Get();\n\tif(k==1) {\n\t\tcout<<1;\n\t} else {\n\t\tf[0][0]=1;\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tfor(int j=0;j<i;j++) {\n\t\t\t\tif(!f[i-1][j]) continue ;\n//\t\t\t\tcout<<\"i=\"<<i<<\" j=\"<<j<<\" f=\"<<f[i-1][j]<<\" \"<<C(i*(k-1)+j-1,k-2)<<\"\\n\";\n\t\t\t\t(f[i][j]+=f[i-1][j]*C(i*(k-1)+j-1,k-2))%=mod;\n\t\t\t}\n\t\t\tfor(int j=1;j<=i;j++) (f[i][j]+=f[i][j-1])%=mod;\n\t\t}\n\t\tcout<<f[n][n]*fac[n]%mod;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,inline,unroll-loops,fast-math\")\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#define N 2020\n#define M 4000020\n#define MOD 1000000007\nusing namespace std;\n \nint Power(int, int);\n \nnamespace Comb\n{\n    int f[M], g[M];\n \n    void InitComb(void)\n    {\n        int i;\n \n        for(i = f[0] = 1; i < M; i ++)\n            f[i] = (long long)f[i - 1] * i % MOD;\n        g[M - 1] = Power(f[M - 1], MOD - 2);\n        for(i = M - 2; i > -1; i --)\n            g[i] = (long long)g[i + 1] * (i + 1) % MOD;\n \n        return;\n    }\n \n    int C(int n, int m)\n    {\n        return m < 0 || m > n ? 0 : (long long)f[n] * g[n - m] % MOD * g[m] % MOD;\n    }\n}\n \nint f[N][N];\n \ninline int Mod(int x)\n{\n    return x + ((x >> 31) & MOD);\n}\n \nint Power(int x, int y)\n{\n    int o;\n \n    for(o = 1; y; y >>= 1)\n    {\n        if(y & 1)\n            o = (long long)o * x % MOD;\n        x = (long long)x * x % MOD;\n    }\n \n    return o;\n}\n \nint main(void)\n{\n    int n, k;\n    int i, j;\n \n    Comb::InitComb();\n    scanf(\"%d %d\", &n, &k);\n    if(k == 1)\n    {\n        printf(\"1\\n\");\n \n        return 0;\n    }\n\n    f[0][0] = 1;\n    for(i = 1; i <= n; i ++)\n        for(j = 0; j <= i; j ++)\n        {\n            f[i][j] = f[i - 1][j];\n            if(j)\n                f[i][j] = Mod(f[i][j] + (long long)f[i][j - 1] * (n - j + 1) % MOD * Comb::C(n * k - i - (j - 1) * (k - 1) - 1, k - 2) % MOD - MOD);\n        }\n    printf(\"%d\\n\", f[n][n]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n#define debug(x) cout << #x << \": \" << x << endl\n#else\n#define debug(x)\n#endif\nusing namespace std;\ntypedef long long ll;\nconst int maxn=4e6+7;\nconst int inf=0x3f3f3f3f;\nconst int mod=1e9+7;\n\nll quick(ll x,ll n)\n{\n    ll res=1;\n    while(n)\n    {\n        if(n&1) res=(res*x)%mod;\n        x=x*x%mod;\n        n>>=1;\n    }\n    return res;\n}\nll inv(ll x) {return quick(x,mod-2);}\n\nll fac[maxn],invfac[maxn];\nvoid init()\n{\n    fac[0]=1;\n    for(int i=1;i<maxn;++i) fac[i]=(fac[i-1]*i)%mod;\n    invfac[maxn-1]=inv(fac[maxn-1]);\n    for(int i=maxn-2;i>=0;--i) invfac[i]=(invfac[i+1]*(i+1))%mod;\n}\n\nll C(int n,int m)\n{\n    return fac[n]*invfac[m]%mod*invfac[n-m]%mod;\n}\n\nll dp[2007][2007];\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    init();\n    int n,k;\n    cin>>n>>k;\n    if(k==1) cout<<1<<endl;\n    else\n    {\n        dp[0][0]=1;\n        for(int i=1;i<=n;++i)\n        {\n            for(int j=0;j<=i;++j)\n            {\n                if(j==0) dp[i][j]=1;\n                else\n                {\n                    assert(n*k-i-(j-1)*(k-1)-1>=k-2);\n                    dp[i][j]=(dp[i-1][j]+1ll*dp[i][j-1]*(n-j+1)%mod*C(n*k-i-(j-1)*(k-1)-1,k-2)%mod)%mod;\n                }\n            }\n        }\n        cout<<dp[n][n]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\n#define int long long\n\ninline int read () {\n    int ret = 0, t = 1;\n    char c = getchar();\n    while ((c < '0' || c > '9') && c != '-') c = getchar();\n    if (c == '-') t = -1, c = getchar();\n    while (c >= '0' && c <= '9') ret = ret * 10 + c - '0', c = getchar();\n    return ret * t;\n}\n\nconst int MAXN = 2020;\nconst int mod = 1e9 + 7;\n\nint qpow (int x, int y) {\n    int ret = 1;\n    while (y) {\n        if (y & 1) ret = ret * x % mod;\n        x = x * x % mod;\n        y >>= 1;\n    }\n    return ret;\n}\nint inv (int x) { return qpow(x, mod - 2); }\n\nint fac[MAXN * MAXN];\nint binom (int x, int y) { return fac[x] * inv(fac[y]) % mod * inv(fac[x - y]) % mod; }\n\nint n, k;\nint dp[MAXN][MAXN];\n\nsigned main () {\n    n = read(), k = read();\n    if (k == 1) { puts(\"1\"); return 0; }\n    int i, j;\n    dp[0][0] = fac[0] = 1;\n    for (i = 1; i <= n * k; i++) fac[i] = fac[i - 1] * i % mod;\n    for (i = 1; i <= n; i++) for (j = 0; j <= i; j++) {\n        dp[i][j] = dp[i - 1][j];\n        if (j) \n            dp[i][j] += dp[i][j - 1] * (n - j + 1) % mod * binom(n * k - i - 1 - (j - 1) * (k - 1), k - 2) % mod, dp[i][j] %= mod;\n    }\n    printf(\"%lld\\n\", dp[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#define ll long long\n#define res register ll\n#define N 2005\nusing namespace std;\nll inv[N*N+N+N],jie[N*N+N+N],k,n,f[N][N];\nconst ll mod=1e9+7;\ninline ll read()\n{\n  ll X=0,w=0;\n  char ch=0;\n  while(!isdigit(ch))\n  {\n    w|=ch=='-';\n    ch=getchar();\n  }\n  while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();\n  return w?-X:X;\n}\ninline ll quickpow(res base,res num)\n{\n  res ans=1;\n  for(; num; num>>=1,base=1LL*base*base%mod)\n    if(num&1)\n      ans=1LL*ans*base%mod;\n  return ans;\n}\ninline void init()\n{\n  jie[0]=jie[1]=inv[0]=inv[1]=1;\n  for(res i=2; i<=n*k+n+k; i++)\n  {\n    jie[i]=1LL*jie[i-1]*i%mod;\n    inv[i]=quickpow(jie[i],mod-2);\n  }\n}\ninline ll C(ll m,ll n)\n{\n  return 1LL*jie[m]*inv[n]%mod*1LL*inv[m-n]%mod;\n}\nint main()\n{\n  n=read(),k=read()-1;\n  if(!k)\n  {\n    puts(\"1\");\n    return 0;\n  }\n  init();\n  f[0][0]=1;\n  for(res i=0; i<=n; i++)\n    for(res j=i; j<=n; j++)\n    {\n      if(i) f[i][j]=(f[i][j]+f[i-1][j])%mod;\n      if(j) f[i][j]=(f[i][j]+1LL*f[i][j-1]*C(i+j*k-1,k-1)%mod)%mod;\n    }\n  printf(\"%lld\\n\",1LL*f[n][n]*jie[n]%mod);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MOD 1000000007\n \nusing namespace std;\n \ntypedef long long ll;\n \nll pow_mod(ll x,int k) {\n  ll ans=1;\n  while (k) {\n    if (k&1) ans=ans*x%MOD;\n    x=x*x%MOD;\n    k>>=1;\n  }\n  return ans;\n}\n \nll facd[4000005],facv[4000005];\n \nvoid pre(int n) {\n  facd[0]=1;\n  for(int i=1;i<=n;i++) facd[i]=facd[i-1]*i%MOD;\n  facv[n]=pow_mod(facd[n],MOD-2);\n  for(int i=n-1;i>=0;i--) facv[i]=facv[i+1]*(i+1)%MOD;\n}\n \ninline ll C(int n,int m) {\n  return facd[n]*facv[m]%MOD*facv[n-m]%MOD;\n}\n \nll f[2005][2005],sum[2005][2005];\n \nint main() {\n  int n,k;\n  scanf(\"%d%d\",&n,&k);\n  if (k==1) {\n    puts(\"1\");\n    return 0;\n  }\n  pre(n*k);\n  f[0][0]=sum[0][0]=1;\n  for(int i=1;i<=n;i++)\n    for(int j=1;j<=i;j++) {\n        f[i][j]=sum[i-1][i-1];\n        if (j>1) f[i][j]=(f[i][j]-sum[i-1][j-2]+MOD)%MOD;\n        f[i][j]=C(i*k-j-1,k-2)*f[i][j]%MOD;\n        sum[i][j]=(sum[i][j-1]+f[i][j])%MOD;\n    }\n  printf(\"%lld\\n\",sum[n][n]*facd[n]%MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#define Pr(f,...) fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n\ntypedef long long ll;\n\ntemplate<typename T>\nvoid read(T &x){\n\tx=0; \n\tchar c;\n\tfor(c=getchar();!isdigit(c);c=getchar()); \n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0'; \n}\n\nconst int N=2005,M=N*N+N+N,P=1e9+7;\n\nint mul(int a,int b){ return 1ll*a*b%P; }\nint add(int a,int b){ a+=b; return a>=P?a-P:a; }\nint sub(int a,int b){ a-=b; return a<0?a+P:a; }\n\nint n,k,f[N][N],fac[M],inv[M];\n\nint C(int n,int m){\n\tif(m<0||m>n)return 0;\n\treturn mul(fac[n],mul(inv[m],inv[n-m])); \n}\n\nint main(int argc,char *argv[]){\n#ifdef CURIOUSCAT\n\t//freopen(\"dat.in\",\"r\",stdin);\n\t//freopen(\"my.out\",\"w\",stdout);\n#endif\n\tfac[0]=1; lop(i,1,M)fac[i]=mul(fac[i-1],i); \n\tinv[1]=1; lop(i,2,M)inv[i]=mul(P-P/i,inv[P%i]);\n\tinv[0]=1; lop(i,1,M)inv[i]=mul(inv[i-1],inv[i]); \n\n\tcin>>n>>k;\t\n\tif(--k==0){\n\t\tputs(\"1\"); \n\t\treturn 0; \n\t}\n\tf[0][0]=1;\n\trep(i,0,n)rep(j,i,n){\n\t\tif(i+1<=n)f[i+1][j]=add(f[i+1][j],f[i][j]); \t\n\t\tif(j+1<=n)f[i][j+1]=add(f[i][j+1],mul(f[i][j],C(k-1+j*k+i+1-1,j*k+i+1-1)));\n\t\t//Pr(\"f[%d][%d]=%d\\n\",i,j,f[i][j]); \n\t}\n\tprintf(\"%d\\n\",mul(f[n][n],fac[n]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\ntypedef long long ll;\nconst int N = 2e3 + 5;\nconst int A = 4e6 + 6;\nconst int Mod = 1e9 + 7;\nint n, m, Ax, g[N][N], fac[A], Ifac[A];\ninline int pow(int x, int k) {\n\tll res = 1, r = x;\n\tfor (; k; k >>= 1, (r *= r) %= Mod)\n\t\tif (k & 1) (res *= r) %= Mod;\n\treturn res;\n}\ninline int calc(int n, int m) {\n\treturn (ll)fac[n] * Ifac[m] % Mod * Ifac[n - m] % Mod;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tif (m == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\t\n\tAx = n * m, fac[0] = 1;\n\tfor (int i = 1; i <= Ax; ++i) fac[i] = (ll)fac[i - 1] * i % Mod;\n\t\n\tIfac[Ax] = pow(fac[Ax], Mod - 2);\n\tfor (int i = Ax; i; --i) Ifac[i - 1] = (ll)Ifac[i] * i % Mod;\n\t\t\t\n\tg[0][0] = 1;\n\tfor (int k = 1; k <= n; ++k) {\n\t\tg[k][0] = (g[k - 1][0] + g[k - 1][1]) % Mod;\n\t\tfor (int i = 1; i + k <= n; ++i) (g[k][i] = g[k][i - 1] + g[k - 1][i + 1]) %= Mod;\n\t\t\n\t\tfor (int i = 0; i + k <= n; ++i) {\n\t\t\tint ret = Ax - (k - 1) * m - i - 2;\n\t\t\tg[k][i] = (ll)g[k][i] * calc(ret, m - 2) % Mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", (ll)g[n][0] * fac[n] % Mod);\n}"
  },
  {
    "language": "C++",
    "code": "// Leftmost Ball\n// * frank_c1\n// * 2017 / 09 / 29\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nLL pow_mod(LL b, LL p, LL k) {\n\tLL ret = 1;\n\tfor (; p; p >>= 1) {\n\t\tif (p & 1) ret = ret * b % k;\n\t\tb = b * b % k;\n\t} return ret;\n}\n\nconst int maxn = 3005;\nconst int mo = (int)(1e9) + 7;\nLL fac[maxn * maxn], ivf[maxn * maxn];\nint f[maxn][maxn];\n\ninline LL C(int n, int m) {\n\tif (m < 0 || n - m < 0) return 0;\n\treturn (fac[n] * ivf[m] % mo) * ivf[n - m] % mo;\n}\n\ninline void add(int& x, int v) {\n\tx += v; if (x >= mo) x -= mo;\n}\n\nint main() {\n\tint n, K;\n\tscanf(\"%d%d\", &n, &K);\n\tif (K == 1) return printf(\"1\\n\"), 0;\n\tint mx = n * (K + 1);\n\tfac[0] = ivf[0] = 1;\n\tfor (int i = 1; i <= mx; ++i) fac[i] = fac[i - 1] * i % mo;\n\tivf[mx] = pow_mod(fac[mx], mo - 2, mo);\n\tfor (int i = mx - 1; i >= 1; --i) ivf[i] = ivf[i + 1] * (i + 1) % mo;\n\tf[0][0] = 1;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\tif (i < j) add(f[i + 1][j], f[i][j]);\n\t\t\tif (j < n) add(f[i][j + 1], 1LL * f[i][j] * C(i + (j + 1) * (K - 1) - 1, K - 2) % mo);\n\t\t}\n\t} int ret = f[n][n];\n\tfor (int i = 1; i <= n; ++i) ret = 1LL * ret * i % mo;\n\treturn printf(\"%d\\n\", ret), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#define re register\n#define LL long long\n#define N 2005\n#define Maxn 4000000\nusing namespace std;\nconst int Mod=1e9+7;\nint n,k;\nLL f[N][N],fac[Maxn+5],inv_fac[Maxn+5];\ninline LL C(int n,int m){ return (((fac[m]*inv_fac[n])%Mod)*inv_fac[m-n])%Mod; }\nLL power(LL x,int P){\n    LL ans=1,m=x;\n    while(P){\n        if(P&1) (ans*=m)%=Mod;\n        P>>=1;(m*=m)%=Mod;\n    }\n    return ans;\n}\nint main(){\n    scanf(\"%d%d\",&n,&k);\n    if(k==1){ printf(\"%d\\n\",1); return 0; }\n    fac[0]=1; for(re int i=1;i<=Maxn;++i) fac[i]=(fac[i-1]*i)%Mod;\n    inv_fac[Maxn]=power(fac[Maxn],Mod-2); for(re int i=Maxn-1;i>=0;--i) inv_fac[i]=(inv_fac[i+1]*(i+1))%Mod;\n    f[0][0]=1;\n    for(re int i=1;i<=n;++i){\n        for(re int j=0;j<=i;++j){\n            f[i][j]=f[i-1][j];\n            if(!j) continue;\n            (f[i][j]+=f[i][j-1]*(n-j+1)%Mod*C(k-2,n-i+(n-j+1)*(k-1)-1)%Mod)%=Mod;\n        }\n    }\n    printf(\"%lld\\n\",f[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=2003;\nconst int mod=1e9+7;\nint n,K;\nint f[maxn][maxn];\nint Fac[maxn*maxn],Inv[maxn*maxn];\ninline int Pow(int a,int n){\n\tint ans=1;\n\tfor(;n;n>>=1,a=a*1ll*a%mod)if(n&1)ans=ans*1ll*a%mod;\n\treturn ans;\n}\ninline int C(int n,int m){\n\tif(n<m||m<0)return 0;\n\treturn Fac[n]*1ll*Inv[m]%mod*Inv[n-m]%mod;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&K);\n\tif(K==1)return puts(\"1\"),0;\n\tFac[0]=1;\n\tfor(int i=1;i<=n*K;i++)Fac[i]=Fac[i-1]*1ll*i%mod;\n\tInv[n*K]=Pow(Fac[n*K],mod-2);\n\tfor(int i=n*K-1;i>=0;i--)Inv[i]=Inv[i+1]*(i+1ll)%mod;\n\tf[0][0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\t(f[i+1][j]+=f[i][j])%=mod;\n\t\t\tf[i][j+1]=(f[i][j+1]+f[i][j]*1ll*C(n*K-(i+j*(K-1))-1,K-2))%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[n][n]*1ll*Fac[n]%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define forE(i,x) for(int i=head[x];i!=-1;i=ne[i])\nusing namespace std;\ntypedef long long i64;\ntypedef unsigned long long u64;\ntypedef unsigned u32;\ntypedef pair<int,int> pin;\n#define mk(a,b) make_pair(a,b)\n#define lowbit(x) ((x)&(-(x)))\n#define sqr(a) ((a)*(a))\n#define clr(a) (memset((a),0,sizeof(a)))\n#define ls ((x)<<1)\n#define rs (((x)<<1)|1)\n#define mid (((l)+(r))>>1)\n#define pb push_back\n#define w1 first\n#define w2 second\ninline void read(int &x){\n\tx=0;int f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\tx*=f;\n}\ninline void judge(){\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n}\n/*******************************head*******************************/\nconst int maxn=2105;\nint f[maxn][maxn];\nint fac[maxn*maxn],facinv[maxn*maxn];\nconst int mod=1e9+7;\ninline int powmod(int a,int b){\n\tint res=1;for(;b;b>>=1){\n\t\tif(b&1)res=1ll*res*a%mod;\n\t\ta=1ll*a*a%mod;\n\t}return res;\n}\ninline void prprpr(){\n\tfac[0]=1;\n\trep(i,1,2000*2001)fac[i]=1ll*fac[i-1]*i%mod;\n\tfacinv[2000*2001]=powmod(fac[2000*2001],mod-2);\n\tper(i,2000*2001-1,0)facinv[i]=1ll*facinv[i+1]*(i+1)%mod;\n}\ninline int C(int n,int m){\n\tif(m<0||n<0||m>n)return 0;\n\treturn 1ll*fac[n]*facinv[m]%mod*facinv[n-m]%mod;\n}\ninline void add(int &x,int y){\n\tx=((x+y)>=mod?(x+y-mod):(x+y));\n}\nint n,k;\ninline void solve(){\n\tread(n);read(k);\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn;\n\t}\n\trep(i,0,n)f[i][0]=1;\n\trep(i,0,n)rep(j,i,n){\n\t\tif(i)add(f[i][j],f[i-1][j]);\n\t\tif(i<j)add(f[i][j],1ll*f[i][j-1]*C((k-1)*(j-1)+i+k-2,k-2)%mod);\n\t}\n\tcout<<1ll*fac[n]*f[n][n]%mod<<endl;\n}\nint main(){\n    prprpr();\n   solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nint const N = 2000 + 20 , mod = 1e9 + 7 ;\nint n , k , dp[N][N] , fac[N * N]  ;\n\ninline int pw (int a , int b) {\n\tint res = 1 ;\n\twhile (b) {\n\t\tif (b & 1) res = 1ll * res * a % mod ;\n\t\ta = 1ll * a * a % mod ;\n\t\tb >>= 1 ;\n\t}\n\treturn res ;\n}\n\ninline int inv (int x) { return pw(x , mod - 2) ; }\n\nvoid pre () {\n\tfac[0] = 1 ;\n\tfor (int i = 1 ; i < N * N ; i ++) fac[i] = 1ll * fac[i - 1] * i % mod ;\n}\n\ninline bool ok (int x) { return 0 <= x && x < mod ; }\n\ninline int Comb (int n , int k) {\n\tif (k < 0 || k > n) return 0 ;\n\tassert(ok(inv(fac[k]))) ;\n\tassert(ok(inv(fac[n - k]))) ;\n\treturn 1ll * fac[n] * inv(fac[k]) % mod * inv(fac[n - k]) % mod ;\n}\n\ninline void add (int &a , int b) {\n\ta += b ;\n\tif (a >= mod) a -= mod ;\n\tif (a < 0) a += mod ;\n}\n\nint main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tpre() ;\n\n\tcin >> n >> k ;\n\n\tif (k == 1) return cout << \"1\\n\" , 0 ;\n\n\tdp[n][n] = 1 ;\n\n\tfor (int i = n ; ~i ; i --)\n\t\tfor (int j = i ; ~j ; j --) {\n\t\t\tif (j == n) continue ;\n\n\t\t\tif (i < n) add(dp[i][j] , 1ll * (n - i) * dp[i + 1][j] % mod) ;\n\t\t\tif (j < i) add(dp[i][j] , 1ll * Comb(n * k - (i + j * (k - 1) + 1) , k - 2) * dp[i][j + 1] % mod) ; \n\t\t}\n\n\tcout << dp[0][0] << '\\n' ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2005;\nconst long long mod = 1e9 + 7;\n\nlong long mod_pow(long long x, long long n){\n\tlong long ret = 1;\n\twhile (n){\n\t\tif (n & 1) ret = ret * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nlong long p[N * N], inv[N * N];\nlong long dp[N][N];\n\nlong long C(int x, int y){\n\tif (x < y) return 0;\n\treturn p[x] * inv[y] % mod * inv[x - y] % mod;\n}\n\nint main(){\n\tint n, k;\n\tscanf(\"%d %d\",&n,&k);\n\tif (k == 1){\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tp[0] = inv[0] = 1;\n\tfor (int i = 1; i <= n * k; i++){\n\t\tp[i] = p[i - 1] * i % mod;\n\t\tinv[i] = mod_pow(p[i], mod - 2);\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= n; i++){\n\t\tfor (int j = 0; j <= i; j++){\n\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\tdp[i][j] %= mod;\n\t\t\tif (j){\n\t\t\t\tdp[i][j] += dp[i][j - 1] * C(n - i + (n - j + 1) * (k - 1) - 1, k - 2) % mod * (n - j + 1) % mod;\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[n][n]);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "/*\nThough leaves are many , the root is one.\nThrough all the lying days of my youth\nI swayed my leaves and flowers in the sun.\nNow I may wither into the truth.\n\t  \t  \t- William Butler Yeats\n*/\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n#include<bits/stdc++.h>\n#pragma comment(\"-Wl,--stack=1024000000\")\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\ntypedef long long ll;\n#ifndef LOCAL\n#define cerr if(0)cout\n#define eprintf(...) 0\n#else\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#endif\ninline string getstr(string &s,int l,int r){string ret=\"\";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){int ret=1;do{if(y&1)ret=(ll)ret*x%md;x=(ll)x*x%md;}while(y>>=1);return ret;}\ninline int Rand(){return rand()*32768+rand();}\nint dp[2005][2005],fact[4000005],inv[4000005];\ninline int C(int nn,int mm){\n\treturn (ll)fact[nn]*inv[mm]%mod*inv[nn-mm]%mod;\n}\ninline void add(int &x,int y){\n\tx+=y;if(x>=mod)x-=mod;\n}\nint main(){\n\tfact[0]=1;\n\tfor(int i=1;i<=4e6;i++)fact[i]=(ll)fact[i-1]*i%mod;\n\tinv[4000000]=modpow(fact[4000000],mod-2);\n\tfor(int i=4e6-1;i>=0;i--)inv[i]=(ll)inv[i+1]*(i+1)%mod;\n\tint n,k;cin>>n>>k;\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tdp[i][j]=(dp[i-1][j]+(!j?0ll:1ll*dp[i][j-1]*C(n-i+n-j+(n-j+1)*(k-2),k-2)%mod))%mod;\n//\t\t\tcerr<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n\t\t}\n\t}\n\tcout<<(ll)dp[n][n]*fact[n]%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for(register int i = a; i <= b; i++)\n#define per(i, a, b) for(register int i = a; i >= b; i--)\ntypedef long long LL;\nconst LL mod = 1e9 + 7;\nconst int N = 2005;\n\nint n, k;\nLL f[N][N], fac[N*N], inv[N*N];\n\nLL Ksm(LL a, LL b) {\n\tLL res = 1;\n\twhile(b) {\n\t\tif(b&1) res = res*a%mod;\n\t\tb /= 2;\n\t\ta = a*a%mod;\n\t}\n\treturn res;\n}\n\nvoid Init() {\n\tfac[0] = inv[0] = 1;\n\trep(i, 1, n*k)\n\t   fac[i] = fac[i - 1]*i%mod, inv[i] = Ksm(fac[i], mod - 2);\n}\n\nLL Cal(int n, int k) {\n\treturn fac[n]*inv[k]%mod*inv[n - k]%mod;\n}\n\nint main() {\n\tcin>>n>>k;\n\tif(k == 1) {\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tInit();\n\tf[0][0] = 1;\n\trep(i, 1, n)\n\t    rep(j, 0, i) {\n\t    \tif(j < i) f[i][j] += f[i - 1][j];\n\t    \tif(j) f[i][j] += f[i][j - 1]*(n - j + 1)%mod*Cal(n*k - j*k - i + j + k - 2, k - 2)%mod;\n\t    \tf[i][j] %= mod;\n\t    }\n\tcout<<f[n][n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n\ntemplate<Int MOD = 1000000007>\nstruct Mod{\n  Int prev=0;\n  vector<Int> fact,inv,finv;\n  Mod(){}\n  Mod(Int n){init(n);}\n  \n  Int pow(Int x,Int n){\n    Int res=1;\n    while(n){\n      if(n&1) (res*=x)%=MOD;\n      (x*=x)%=MOD;\n      n>>=1;\n    }\n    return res;\n  }\n  \n  Int inverse(Int a){\n    return pow(a,MOD-2);\n  }\n  \n  void init(Int n){\n    if(prev>=n) return;\n    prev=n;\n    fact=inv=finv=vector<Int>(n);\n    \n    fact[0]=1;\n    for(Int i=1;i<n;i++)\n      fact[i]=(fact[i-1]*i)%MOD;\n    \n    inv[1]=1;\n    for(Int i=2;i<n;i++)\n      inv[i]=inv[MOD%i]*(MOD-MOD/i)%MOD;\n    \n    finv[0]=1;\n    for(Int i=1;i<n;i++)\n      finv[i]=finv[i-1]*inv[i]%MOD;\n  }\n  \n  Int comb(Int n,Int k){\n    Int res=1;\n    for(Int i=0;i<k;i++){\n      res*=(n-i)%MOD;\n      res%=MOD;\n      res*=inverse(i+1);\n      res%=MOD;\n    }\n    return res;\n  }\n  \n  //only for prime MOD\n  Int C(Int n,Int k){\n    if(k<0||k>n) return 0;\n    return fact[n]*finv[k]%MOD*finv[n-k]%MOD;\n  }\n  \n  Int P(Int n,Int k){\n    if(k<0||k>n) return 0;\n    return fact[n]*finv[n-k]%MOD;    \n  }\n\n  Int H(Int n,Int k){\n    return C(n+k-1,n);\n  }\n\n  Int S(Int n,Int k){\n    Int res=0;\n    for(Int i=1;i<=k;i++){\n      Int tmp=C(k,i)*pow(i,n)%MOD;\n      if((k-i)&1) res+=MOD-tmp;\n      else res+=tmp;\n      res%=MOD;\n    }\n    res=res*finv[k]%MOD;\n    return res;\n  }\n  \n  Int B(Int n,Int k){\n    Int res=0;\n    for(Int j=1;j<=k;j++){\n      res+=S(n,j);\n      res%=MOD;\n    }\n    return res;\n  }\n  \n  vector<vector<Int> > D(Int n,Int m){\n    vector<vector<Int> > dp(n+1,vector<Int>(m+1,0));\n    dp[0][0]=1;\n    for(Int i=0;i<=n;i++){\n      for(Int j=1;j<=m;j++){\n\tif(i-j>=0) dp[i][j]=(dp[i][j-1]+dp[i-j][j])%MOD;\n\telse dp[i][j]=dp[i][j-1];\n      }\n    }\n    return dp;\n  }\n  \n  Int montmort(Int n){\n    Int res=0,rinv=1;\n    for(Int k=2;k<=n;k++){\n      rinv=rinv*inverse(k)%MOD;\n      if(k%2) res+=MOD-rinv;\n      else res+=rinv;\n      res%=MOD;\n    }\n    for(Int i=1;i<=n;i++) res=res*i%MOD;\n    return res;\n  }\n  \n  // calculate P(t) from given points in [0,N]\n  Int LagrangePolynomial(vector<Int> &y,Int t){\n    Int n=y.size()-1;\n    init(n+1);\n    Int num=1;\n    for(Int i=0;i<=n;i++)\n      num=num*((t-i)%MOD)%MOD;\n    Int res=0;\n    for(Int i=0;i<=n;i++){\n      Int tmp=(y[i]*num%MOD)*inverse((t-i)%MOD)%MOD;\n      tmp=tmp*finv[i]%MOD;\n      tmp=tmp*finv[n-i]%MOD;\n      if((n-i)&1) tmp=MOD-tmp;\n      res=(res+tmp)%MOD;\n    }\n    return res;\n  }\n};\n\n\n//INSERT ABOVE HERE\nInt dp[2020][2020];\nsigned main(){\n  const Int MOD = 1e9+7;\n  Mod<MOD> mod(5e6);\n  Int n,k;\n  cin>>n>>k;\n  if(k==1) return cout<<1<<endl,0;\n\n  auto add=[&](Int &a,Int b){a+=b;a%=MOD;};\n  \n  memset(dp,0,sizeof(dp));\n  dp[0][0]=1;\n  for(Int i=0;i<=n;i++){\n    for(Int j=0;j<=n;j++){\n      //cout<<i<<\" \"<<j<<\":\"<<dp[i][j]<<endl;\n      Int s=i+j*(k-1);\n      if(i<j) add(dp[i+1][j],dp[i][j]);\n      if(j<n) add(dp[i][j+1],dp[i][j]*mod.C(s+k-2,s)%MOD);\n    }\n  }\n  Int ans=dp[n][n]*mod.fact[n]%MOD;\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k){\n        if(k&1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k>>=1;\n    }\n    return ans;\n}\nll inv(ll a){\n\treturn powmod(a, MOD-2);\n}\nll f[4000001], invf[4000001];\nvoid fac(int n){\n    f[0]=1;\n    for(ll i=1; i<=n; i++) f[i]=f[i-1]*i%MOD;\n    invf[n]=inv(f[n]);\n    for(ll i=n-1; i>=0; i--) invf[i]=invf[i+1]*(i+1)%MOD;\n}\nll comb(int x, int y){\n    if(x<y) return 0;\n    return f[x]*invf[y]%MOD*invf[x-y]%MOD;\n}\nint main()\n{\n    int n, k; cin>>n>>k;\n    if(k==1){\n        cout<<1<<endl;\n        return 0;\n    }\n    fac(n*k);\n    ll dp[2003][2003]={};\n    dp[1][0]=1;\n    for(int i=1; i<=n; i++){\n        for(int j=i-1; j<=n; j++){\n            if(j<n){\n                dp[i][j+1]+=dp[i][j]*comb(j*(k-1)+i-1+k-2, k-2);\n                dp[i][j+1]%=MOD;\n            }\n            if(j>=i){\n                dp[i+1][j]+=dp[i][j];\n                dp[i+1][j]%=MOD;\n            }\n        }\n    }\n    cout<<dp[n][n]*f[n]%MOD<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nint f[2010][2010],fac[4000010],inv[4000010];\ninline int qpow(int a,int b) {\n\tint ans=1;\n\twhile(b) {\n\t\tif(b&1)ans=1ll*ans*a%mod;\n\t\ta=1ll*a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\ninline int C(int n,int m) {\n\tif(n<m)return 0;\n\treturn 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main() {\n\tint n,k;\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\tfor(int i=1;i<=n*k;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[n*k]=qpow(fac[n*k],mod-2);\n\tfor(int i=n*k-1;i>=0;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tf[0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++) {\n\t\t\tf[i+1][j]=(f[i+1][j]+f[i][j])%mod;\n\t\t\tf[i][j+1]=(f[i][j+1]+1ll*C(n*k-i-j*(k-1)-1,k-2)*f[i][j])%mod;\n\t\t}\n\tprintf(\"%lld\\n\",1ll*f[n][n]*fac[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2050\n#define mod 1000000007\nusing namespace std;\ntypedef long long LL;\nconst int tp = 4000000;\n\nint n,k;\nLL F[N][N],jc[N*N],inv[N*N],invjc[N*N];\ninline int rd() {int r;scanf(\"%d\",&r);return r;}\n\ninline LL C(int x,int y) {\n\tif (x < y) return 0;\n\treturn 1LL * jc[x] * invjc[y] % mod * invjc[x-y] % mod;\n}\n\ninline void inc(LL &x, LL y) {x=(x+y)%mod;}\n\nint main() {\n\tn = rd(), k = rd();\n\t\n\tif (k == 1) {puts(\"1\"); return 0;} \n\t\n\tjc[0] = jc[1] = 1LL;\n\tfor (int i=2;i<=tp;i++) jc[i] = 1LL * jc[i-1] * i % mod;\n\t\n\tinv[0] = inv[1] = 1LL;\n\tfor (int i=2;i<=tp;i++) inv[i] = 1LL * (mod-mod/i) * inv[mod % i] % mod;\n\t\n\tinvjc[0] = invjc[1] = 1LL;\n\tfor (int i=2;i<=tp;i++) invjc[i] = 1LL * invjc[i-1] * inv[i] % mod;\n\n\tF[0][1] = 1LL;\n\tfor (int i=2;i<=n;i++)\n\t\tF[0][i] = 1LL * F[0][i-1] * C(i*(k-1)-1, k-2) % mod;\n\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=i;j<=n;j++) {\n\t\t\tif (i-1 >= 0) inc(F[i][j], F[i-1][j]);\n\t\t\tif (j-1 >= 0) inc(F[i][j], 1LL * C(i+j*(k-1)-1, k-2) * F[i][j-1] % mod);\n\t\t}\n\n\tLL ans = 1LL * F[n][n] * jc[n] % mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9+7;\nlong long n,k;\nlong long dp[2010][2010];\nlong long fac[4000010],inv[4000010];\nlong long fpm(long long a,long long b){\n    long long res = 1;\n    while(b){\n        if (b&1){\n            res = res*a%mod;\n            b--;\n        }\n        a = a*a%mod;\n        b>>=1;\n    }\n    return res;\n}\nlong long C(long long n,long long m){\n    if (n<m){\n        return 0;\n    }\n    return fac[n]*inv[n-m]%mod*inv[m]%mod;\n}\nint main () {\n    scanf(\"%lld%lld\",&n,&k);\n    if (k==1){\n        printf(\"1\");\n        return 0;\n    }\n    fac[0] = 1;\n    inv[0] = 1;\n    for (register int i = 1; i <= 4000000; i++){\n        fac[i] = fac[i-1]*i%mod;\n        inv[i] = fpm(fac[i],mod-2)%mod;\n    }\n    dp[0][0] = 1;\n    for (register int i = 1; i <= n; i++){\n        for (register int j = 0; j <= i; j++){\n            dp[i][j] = dp[i-1][j];\n            if (j==0){\n                continue;\n            }\n            dp[i][j] += dp[i][j-1]*(n-j+1)*C(n-i+(n-j+1)*(k-1)-1,k-2)%mod;\n            dp[i][j] %= mod;\n        }\n    }\n    printf(\"%lld\",dp[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define il inline\n#define vd void\n#define mod 1000000007\ntypedef long long ll;\nil int gi(){\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)){\n\t\tif(ch=='-')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\nint f[2010][2010];\nint inv[4001000],C[4001000];\nint main(){\n\tint n=gi(),k=gi();\n\tinv[1]=1;for(int i=2;i<=n*k;++i)inv[i]=mod-1ll*(mod/i)*inv[mod%i]%mod;\n\tC[k-2]=1;\n\tfor(int i=k-1;i<=n*k;++i)C[i]=1ll*C[i-1]*inv[i-k+2]%mod*i%mod;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<=std::min(i,k);++j){\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tf[i][j]=(f[i][j]+1ll*C[(n-i)+(n-j+1)*(k-1)-1]*f[i][j-1]%mod*(n-j+1)%mod)%mod;\n\t\t}\n\tprintf(\"%d\\n\",f[n][k]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\ntemplate<unsigned MOD> struct ModInt {\n    static const unsigned static_MOD = MOD;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 1000000007;\n//const LL MOD = 998244353;\ntypedef ModInt<MOD> Mint;\n\nconst int MAX = 4000011;\nMint inv[MAX+1], fact[MAX+1], fact_inv[MAX+1];\n\nvoid init() {\n    inv[1] = 1;\n    for (int i=2; i<=MAX; i++) inv[i] = inv[MOD%i] * (MOD-MOD/i);\n\n    fact[0] = fact_inv[0] = 1;\n    for (int i=1; i<=MAX; i++) {\n\tfact[i] = fact[i-1] * i;\n\tfact_inv[i] = fact_inv[i-1] * inv[i];\n    }\n}\n\nMint nCk(int n, int k) {\n    return fact[n] * fact_inv[k] * fact_inv[n-k];\n}\n\n\nint N, K;\nMint dp[2011][2011];\nMint sums[2011];\n\nMint f(int sep, int ball) {\n    return nCk(sep+ball, sep);\n}\n\nvoid MAIN() {\n    init();\n    scanf(\"%d%d\", &N, &K);\n\n    if (K == 1) {\n\tputs(\"1\");\n\treturn;\n    }\n\n    dp[1][1] = 1;\n    for (int i=1; i<N; i++) {\n\tREP (a, i+2) sums[a+1] = sums[a] + dp[i][a];\n\tfor (int b=1; b<=i+1; b++) {\n\t    dp[i+1][b] = (sums[i+2]-sums[b-1]) * f(i*K-b+1, K-2);\n\t}\n    }\n\n    Mint ans = 0;\n    REP (b, N+1) ans += dp[N][b];\n    ans *= fact[N];\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(_v % MD + MD); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(ull(v) * r.v % MD); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\nusing Mint = ModInt<TEN(9) + 7>;\n// template<> const Mint Mint::G = Mint(3);\n\nconst int B = 4242424;\nint n, k;\nMint dp[2333][2333];\nbool used[2333][2333];\nMint fac[B], ifac[B];\n\nvoid first() {\n    fac[0] = 1;\n    for (int i = 1; i < B; i++) fac[i] = Mint(i) * fac[i - 1];\n    ifac[B - 1] = fac[B - 1].inv();\n    for (int i = B - 2; i >= 0; i--) ifac[i] = Mint(i + 1) * ifac[i + 1];\n}\n\nMint C(int n, int k) {\n    if (n < 0 || k < 0 || n < k) return Mint(0);\n    return fac[n] * ifac[k] * ifac[n - k];\n}\n\nMint calc(int a, int b) {\n    if (a > n || b > n || a < b) return Mint(0);\n    if (used[a][b]) return dp[a][b];\n    used[a][b] = true;\n    return dp[a][b] = \n        calc(a + 1, b) + calc(a, b + 1) * C(n * k - a - b * (k - 1) - 1, k - 2);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20) << fixed;\n\n    cin >> n >> k;\n    if (k == 1) {\n        cout << 1 << endl;\n        return 0;\n    }\n    first();\n    used[n][n] = true;\n    dp[n][n] = 1;\n    cout << calc(0, 0) * fac[n] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define Inv(x) QPow(x,Mod-2);\n\nconst int maxN=2005;\nconst int maxM=maxN*maxN;\nconst int Mod=1e9+7;\n\nint n,K;\nint Fc[maxM],Ifc[maxM];\nint F[maxN][maxN];\n\nint QPow(int x,int cnt);\nint C(int n,int m);\nint main(){\n    Fc[0]=Ifc[0]=1;for (int i=1;i<maxM;i++) Fc[i]=1ll*Fc[i-1]*i%Mod;\n    Ifc[maxM-1]=Inv(Fc[maxM-1]);for (int i=maxM-2;i>=1;i--) Ifc[i]=1ll*Ifc[i+1]*(i+1)%Mod;\n    \n    scanf(\"%d%d\",&n,&K);\n    if (K==1){\n\tputs(\"1\");return 0;\n    }\n\n    F[0][0]=1;\n    for (int i=1;i<=n;i++)\n\tfor (int j=n;j>=0;j--){\n\t    if (j<=i&&j>=0) F[i][j]=1ll*F[i-1][j-1]*C(i*K-j-1,K-2)%Mod;\n\t    F[i][j]=(F[i][j]+F[i][j+1])%Mod;\n\t}\n    /*\n    for (int i=0;i<=n;i++){\n\tfor (int j=0;j<=n;j++) cout<<F[i][j]<<\" \";\n\tcout<<endl;\n    }//*/\n    int Ans=1ll*F[n][0]*Fc[n]%Mod;\n    printf(\"%d\\n\",Ans);return 0;\n}\nint QPow(int x,int cnt){\n    int ret=1;\n    while (cnt){\n\tif (cnt&1) ret=1ll*ret*x%Mod;\n\tx=1ll*x*x%Mod;cnt>>=1;\n    }\n    return ret;\n}\nint C(int n,int m){\n    if (n<0||m<0||n<m) return 0;\n    return 1ll*Fc[n]*Ifc[m]%Mod*Ifc[n-m]%Mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#define re register\n#define LL long long\n#define N 2005\n#define Maxn 4000000\nusing namespace std;\nconst int Mod=1e9+7;\nint n,k;\nLL f[N][N],fac[Maxn+5],inv_fac[Maxn+5];\ninline LL C(int n,int m){ return (((fac[m]*inv_fac[n])%Mod)*inv_fac[m-n])%Mod; }\nLL power(LL x,int P){\n    LL ans=1,m=x;\n    while(P){\n        if(P&1) (ans*=m)%=Mod;\n        P>>=1;(m*=m)%=Mod;\n    }\n    return ans;\n}\nint main(){\n    scanf(\"%d%d\",&n,&k);\n    if(k==1){ printf(\"%d\\n\",1); return 0; }\n    fac[0]=1; for(re int i=1;i<=Maxn;++i) fac[i]=(fac[i-1]*i)%Mod;\n    inv_fac[Maxn]=power(fac[Maxn],Mod-2); for(re int i=Maxn-1;i>=0;--i) inv_fac[i]=(inv_fac[i+1]*(i+1))%Mod;\n    f[0][0]=1;\n    for(re int i=1;i<=n;++i){\n        for(re int j=0;j<=i;++j){\n            f[i][j]=f[i-1][j];\n            if(!j) continue;\n            (f[i][j]+=f[i][j-1]*(n-j+1)%Mod*C(k-2,n-i+(n-j+1)*(k-1)-1)%Mod)%=Mod;\n        }\n    }\n    printf(\"%lld\\n\",f[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N=2005,M=1e5+5;\nint fa[M];\nint sz[M];\nint find_father(int x){\n    if(fa[x]==x)\n        return x;\n    return fa[x]=find_father(fa[x]);\n}\nvoid Merge(int x,int y){\n    find_father(x);\n    find_father(y);\n    if(fa[x]==fa[y])\n        return ;\n    sz[fa[y]]+=sz[fa[x]];\n    fa[fa[x]]=fa[y];\n}\nint n,m;\nint a[M],b[M];\nint main()\n{\n    //freopen(\"rally.in\",\"r\",stdin);\n   // freopen(\"rally.out\",\"w\",stdout);\n    scanf(\"%d%d\",&n,&m);\n    if(n>2000)\n        return 0;\n    for(int i=1;i<=m;i++){\n        scanf(\"%d%d\",&a[i],&b[i]);\n    }\n    int q;\n    scanf(\"%d\",&q);\n    while(q--){\n        int x,y,z;\n        scanf(\"%d%d%d\",&x,&y,&z);\n        for(int i=1;i<=n;i++)\n            fa[i]=i,sz[i]=1;\n        for(int i=1;i<=m;i++){\n            Merge(a[i],b[i]);\n            int f1=find_father(x),f2=find_father(y);\n            if(f1==f2){\n                if(sz[f1]>=z){\n                    printf(\"%d\\n\",i);\n                    break;\n                }\n            }\n            else{\n                if(sz[f1]+sz[f2]>=z){\n                    printf(\"%d\\n\",i);\n                    break;\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define ll long long\n#define MAX 2010\n#define MOD 1000000007\nvoid add(int &x,int y){x+=y;if(x>=MOD)x-=MOD;}\ninline int read()\n{\n\tint x=0;bool t=false;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')t=true,ch=getchar();\n\twhile(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n\treturn t?-x:x;\n}\nint n,k,mx,f[MAX][MAX];\nint jc[MAX*MAX],jv[MAX*MAX],inv[MAX*MAX];\nint C(int n,int m){return 1ll*jc[n]*jv[m]%MOD*jv[n-m]%MOD;}\nint main()\n{\n\tn=read();k=read();mx=n*k;\n\tif(k==1){puts(\"1\");return 0;}\n\tjc[0]=jv[0]=inv[0]=inv[1]=1;\n\tfor(int i=1;i<=mx;++i)jc[i]=1ll*jc[i-1]*i%MOD;\n\tfor(int i=2;i<=mx;++i)inv[i]=1ll*inv[MOD%i]*(MOD-MOD/i)%MOD;\n\tfor(int i=1;i<=mx;++i)jv[i]=1ll*jv[i-1]*inv[i]%MOD;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<=i;++j)\n\t\t{\n\t\t\tadd(f[i][j],f[i-1][j]);\n\t\t\tif(j)add(f[i][j],1ll*f[i][j-1]*(n-j+1)%MOD*C((n-i)+(n-j+1)*(k-1)-1,k-2)%MOD);\n\t\t}\n\tprintf(\"%d\\n\",f[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long lint;\n\n#define MAXN 2005\n\nusing namespace std;\n\nint n, k;\nlint f[MAXN][MAXN], fac[MAXN * MAXN], inf[MAXN * MAXN];\nconst int mod = 1e9 + 7, N = 4000000;\n\nlint power(lint a, int b) {\n    lint res = 1;\n    while (b) {\n        if (b & 1)\n            res = res * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return res;\n}\n\nvoid init() {\n    inf[0] = fac[0] = 1;\n    for (int i = 1; i <= N; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    inf[N] = power(fac[N], mod - 2);\n    for (int i = N - 1; i >= 1; --i)\n        inf[i] = inf[i + 1] * (i + 1) % mod;\n}\n\nlint C(int n, int m) {\n    return fac[n] * inf[n - m] % mod * inf[m] % mod;\n}\n\nint main() {\n    init();\n    scanf(\"%d%d\", &n, &k);\n    if (k == 1) {\n        puts(\"1\");\n        return 0;\n    }\n    f[0][0] = 1;\n    for (int i = 1; i <= n; ++i)\n        for (int j = 0; j <= i; ++j)\n            if (!j)\n                f[i][j] = f[i - 1][j];\n            else\n                f[i][j] = (f[i - 1][j] + f[i][j - 1] * C(n * k - (j - 1) * (k - 1) - i - 1, k - 2) % mod * (n - j + 1) % mod) % mod;\n    printf(\"%lld\\n\", f[n][n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int maxn=2005;\nconst int maxf=4e6+5;\nconst LL mo=1e9+7;\nint n,k;\nLL F[maxn][maxn],fac[maxf],inv[maxf];\nLL kpow(LL x,LL y,LL p)\n{\n\tLL s=1LL;\n\twhile(y){\n\t\tif((y&1LL)) s=s*x%p;\n\t\tx=x*x%p;\n\t\ty>>=1;\n\t}\n\treturn s;\n}\nLL C(int x,int y)\n{\n\tif(x<y||y<0) return 0;\n\tif(!y||x==y) return 1LL;\n\treturn (fac[x]*inv[y]%mo)*inv[x-y]%mo;\n}\nvoid pre()\n{\n\tfac[0]=1LL;\n\tfor(int i=1;i<=n*k;++i) fac[i]=fac[i-1]*i%mo;\n\tinv[n*k]=kpow(fac[n*k],mo-2,mo);\n\tfor(int i=n*k-1;i>=1;--i) inv[i]=inv[i+1]*(i+1)%mo;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;++i) F[i][0]=1;\n\tif(k==1) printf(\"1\");\n\telse{\n\t\tpre();\n\t\t//cout<<C(1,1);\n\t\tfor(int i=1;i<=n;++i)\n\t\t  for(int j=1;j<=i;++j){\n\t\t  \tLL s=F[i][j-1]*(n-j+1)%mo;\n\t\t  \ts=s*C(n*k-i-(j-1)*(k-1)-1,k-2)%mo;\n\t\t  \tF[i][j]=(F[i-1][j]+s)%mo;\n\t\t  \t//cout<<i<<\" \"<<j<<\" \"<<F[i][j]<<\" \"<<F[i-1][j]<<\" \"<<F[i][j-1]<<endl;\n\t\t  \t//cout<<(n*k-i-(j-1)*(k-1)-1)<<\" \"<<k-2<<\" \"<<C(n*k-i-(j-1)*(k-1)-1,k-2)<<endl;\n\t\t  }\n\t\tprintf(\"%lld\",F[n][n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for(int i=(a),_ed=(b);i<=_ed;++i)\n#define DREP(i,a,b) for(int i=(a),_ed=(b);i>=_ed;--i)\n#define mp(x,y) make_pair((x),(y))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int,int> pii;\ninline int read(){\n    register int x=0,f=1;register char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=0;ch=getchar();}\n    while(isdigit(ch)){x=x*10+(ch^'0');ch=getchar();}\n    return f?x:-x;\n}\n\nconst int mod=1000000007;\nint n,k,f[4005][2005],fac[16000005],ifc[16000005];\ninline void inc(int& x,int y){x=x+y<mod?x+y:x+y-mod;}\ninline void dec(int& x,int y){x=x-y>=0?x-y:x-y+mod;}\ninline int power(int b,int n){int ans=1;for(;n;n>>=1,b=1ll*b*b%mod)if(n&1)ans=1ll*ans*b%mod;return ans;}\ninline int C(int n,int m){return (n<0||m<0||n<m)?0:1ll*fac[n]*ifc[m]%mod*ifc[n-m]%mod;}\n\nint main(){\n\t// freopen(\"in.in\",\"r\",stdin);\n\tn=read(),k=read();\n\tREP(i,fac[0]=1,16000001)fac[i]=1ll*fac[i-1]*i%mod;\n\tifc[16000001]=power(fac[16000001],mod-2);\n\tDREP(i,16000001,1)ifc[i-1]=1ll*ifc[i]*i%mod;\n\tif(k==1)return puts(\"1\"),0;\n\tf[0][0]=1;\n\tREP(i,0,n+n-1)REP(j,0,i>>1)if(f[i][j]){\n\t\tif(i-j>j)inc(f[i+1][j+1],f[i][j]);\n\t\tint num=(i-j)*(k-1)+j+1;\n\t\tinc(f[i+1][j],1ll*(n-i+j)*f[i][j]%mod*C(k-2+num-1,num-1)%mod);\n\t}\n\tprintf(\"%d\\n\",f[n+n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nconst int N = 2e3 + 5;\nconst int mod = 1e9 + 7;\ntypedef long long LL;\n\nLL fastpow(LL a, LL b) {\n    if (!b) return 1;\n    LL t = fastpow(a, b / 2);\n    if (b & 1) return t * t % mod * a % mod;\n    else return t * t % mod;\n}\n\nLL fact[N * N], invf[N * N];\nvoid prework(int n) {\n    fact[0] = 1ll;\n    for (int i = 1; i <= n; i++)\n        fact[i] = fact[i - 1] * i % mod;\n    invf[n] = fastpow(fact[n], mod - 2ll);\n    for (int i = n - 1; ~i; i--)\n        invf[i] = invf[i + 1] * (i + 1) % mod;\n}\n\nLL comb(int n, int m) {\n    return fact[n]\n         * invf[m] % mod\n         * invf[n - m] % mod;\n}\n\nint k, n;\nLL f[N][N];\n\nsigned main() {\n    prework(4e6);\n    cin >> n >> k;\n\n    if (k == 1) {\n        cout << 1 << endl;\n        return 0;\n    }\n\n    for (int i = 0; i <= n; i++)\n        f[i][0] = 1ll;\n    \n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= i; j++) {\n            f[i][j] += (f[i][j - 1] * (n - j + 1) % mod\n                     * comb(n - i + (n - j + 1) * (k - 1) - 1, k - 2) % mod\n                     + f[i - 1][j]) % mod;\n        }\n    \n    cout << f[n][n] << endl;\n    return 0;\n}//233"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\n\nlong long dp[2005][2005];\nint n, k;\n\nlong long fac[5000010];\nlong long inv[5000010];\n\nlong long modpow(int x, int p) {\n    if(p == 0) return 1;\n    if(p & 1) return (modpow(x, p-1) * x) % mod;\n    long long m = modpow(x, p >> 1);\n    return (m * m) % mod;\n}\nlong long inverse(int x) {\n    return modpow(x, mod - 2);\n}\n\nint cell(int i, int j) {\n    return (i * k) + ((j - i) * (k - 1));\n}\n\nlong long nCr(int n, int r) {\n    long long num = fac[n];\n    long long den = (inv[r] * inv[n - r]) % mod;\n    return (num * den) % mod;\n}\nlong long stars_bars(int n, int r) {\n    return nCr(n + r - 1, r - 1);\n}\n\nint main() {\n    fac[0] = inv[0] = 1;\n    for(int i = 1; i <= 4100000; i++) {\n        fac[i] = fac[i-1] * i;\n        fac[i] %= mod;\n        inv[i] = modpow(fac[i], mod - 2);\n    }\n    cin >> n >> k;\n    if(k == 1) {\n        cout << 1 << endl;\n        exit(0);\n    }\n    for(int i = 0; i <= n; i++) {\n        for(int j = i; j <= n; j++) {\n            if(i == 0 && j == 0) {\n                dp[0][0] = 1;\n                continue;\n            }\n            dp[i][j] = 0;\n            if(i > 0) dp[i][j] += dp[i - 1][j];\n            if(j > i) {\n                int slot = cell(i, j - 1) + 1;\n                int cell = k - 2;\n                long long opt = stars_bars(cell, slot);\n                dp[i][j] += dp[i][j - 1] * opt;\n            }\n            dp[i][j] %= mod;\n        }\n    }\n    dp[n][n] *= fac[n];\n    dp[n][n] %= mod;\n    cout << dp[n][n] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long   ll;\n\nconst int   N   = 2e3 + 1;\nconst ll    mod = 1e9 + 7;\n\nvoid add(int &a,int b)  {\n    a += b;\n    if(a >= mod)a -= mod;\n    if(a < 0)   a += mod;\n}\n\nll  qpow(ll a,int exp)  {\n    ll ans = 1;\n    while(exp)  {\n        if(exp & 1) ans = ans * a % mod;\n        a = a * a % mod;  exp >>= 1;\n    }\n    return ans;\n}\n\nll  Fac[N * N];\nll  Inv[N * N];\n\nint Ckn(int n,int k)    {\n    if(n < k || n < 0 || k < 0) return 0;\n    ll  res = Inv[k] * Inv[n - k] % mod;\n        res = Fac[n] * res % mod;\n    return (int)res;\n}\n\nint f[N][N];\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n, K;   cin >> n >> K;\n\n    if(K < 2)   return puts(\"1\"),0;\n\n    Fac[0] = 1;\n\n    for(int i = 1 ; i <= n * K ; ++i)\n        Fac[i] = 1ll * Fac[i - 1] * i % mod;\n\n    Inv[n * K] = qpow(Fac[n * K],mod - 2);\n    for(int i = n * K - 1 ; ~i ; --i)\n        Inv[i] = 1ll * Inv[i + 1] * (i + 1) % mod;\n\n    f[0][0] = 1;\n\n    for(int i = 1 ; i <= n ; ++i)\n        for(int j = 0 ; j <= i ; ++j)   {\n            if(i)   add(f[i][j],f[i - 1][j]);\n            if(j)   add(f[i][j],1ll * f[i][j - 1] * Ckn(n * K - i - (j - 1) * (K - 1) - 1,K - 2) % mod);\n        }\n\n    cout << 1ll * f[n][n] * Fac[n] % mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2017 __debug.\n\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n\n#define x first\n#define y second\n#define MP std::make_pair\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\nstring procStatus()\n{\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\ntemplate<typename T> T read(T &x)\n{\n    int f = 1;\n    char ch = getchar();\n    for (; !isdigit(ch); ch = getchar())\n        f = (ch == '-' ? -1 : 1);\n    for (x = 0; isdigit(ch); ch = getchar())\n        x = 10 * x + ch - '0';\n    return x *= f;\n}\ntemplate<typename T> void write(T x)\n{\n    if (x == 0) {\n        putchar('0');\n        return;\n    }\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    static char s[20];\n    int top = 0;\n    for (; x; x /= 10)\n        s[++top] = x % 10 + '0';\n    while (top)\n        putchar(s[top--]);\n}\n// EOT\n\nconst int MAXN = 2e3 + 5, SIZE = MAXN * MAXN;\nconst int MOD = 1e9 + 7;\n\nint N, K;\n\nvoid input()\n{\n    read(N); read(K);\n}\n\nLL fpm(LL base, LL exp)\n{\n    LL ret = 1;\n    for (; exp; exp >>= 1) {\n        if (exp & 1)\n            (ret *= base) %= MOD;\n        (base *= base) %= MOD;\n    }\n    return ret;\n}\n\nint fac[SIZE], ifac[SIZE];\n\ninline int C(int n, int k)\n{\n    assert(0 <= k && k <= n);\n    return (LL)fac[n] * ifac[k] % MOD * ifac[n - k] % MOD;\n}\n\nvoid solve()\n{\n    if (K == 1) {\n        puts(\"1\");\n        return;\n    }\n\n    int max = N * K;\n\n    fac[0] = 1;\n    for (int i = 1; i <= max; ++i) {\n        fac[i] = (LL)fac[i - 1] * i % MOD;\n    }\n    ifac[max] = fpm(fac[max], MOD - 2);\n    for (int i = max; i >= 1; --i) {\n        ifac[i - 1] = (LL)ifac[i] * i % MOD;\n    }\n\n    static int dp[MAXN][MAXN];\n\n    dp[0][0] = 1;\n    for (int i = 0; i <= N; ++i) {\n        for (int j = 0; j <= i; ++j) {\n            (dp[i + 1][j] += dp[i][j]) %= MOD;\n            if (j < i)\n                (dp[i][j + 1] += (LL)dp[i][j] * C((K - 1) * (N - j) + N - i - 1, K - 2) % MOD) %= MOD;\n        }\n    }\n    int ans = (LL)dp[N][N] * fac[N] % MOD;\n\n    printf(\"%d\\n\", ans);\n}\n\nint main()\n{\n#ifdef __DEBUG\n    freopen(\"F.in\", \"r\", stdin);\n    freopen(\"F.out\", \"w\", stdout);\n#endif\n\n    input();\n    solve();\n\n    return 0;\n}\n\n// 相思黄叶落，白露湿青苔。\n//     -- 李白《长相思三首》\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define LL long long\n//#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)\n//char buf[(1 << 21) + 1], *p1 = buf, *p2 = buf;\ninline int read() {\n\tbool f=0;int x=0;char c=getchar();\n\twhile(c<'0'||'9'<c){if(c==EOF)exit(0);if(c=='-')f=1;c=getchar();}\n\twhile('0'<=c&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();\n\treturn !f?x:-x;\n}\n#define MAXN 2000\n#define INF 0x3f3f3f3f\n#define Mod (int)(1e9+7)\nLL fac[MAXN*MAXN+5],inv[MAXN*MAXN+5];\nLL Pow(LL x,LL y){\n\tLL ret=1;\n\twhile(y){\n\t\tif(y&1) ret=ret*x%Mod;\n\t\tx=x*x%Mod,y>>=1;\n\t}\n\treturn ret;\n}\nvoid Prepare(){\n\tfac[0]=1;\n\tfor(int i=1;i<=MAXN*MAXN;i++)\n\t\tfac[i]=fac[i-1]*i%Mod;\n\tinv[MAXN*MAXN]=Pow(fac[MAXN*MAXN],Mod-2);\n\tfor(int i=MAXN*MAXN-1;i>=0;i--)\n\t\tinv[i]=inv[i+1]*(i+1)%Mod;\n\treturn ;\n}\nLL f[MAXN+5][MAXN+5];\nLL C(int n,int m){\n\tif(n<m) return 0;\n\treturn fac[n]*inv[m]%Mod*inv[n-m]%Mod;\n}\nint main(){\n\tPrepare();\n\tint n=read(),k=read();\n\tif(k==1)\n\t\tputs(\"1\"),exit(0);\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tf[i][j]=(f[i-1][j]+C(n-i+(n-(j-1))*(k-1)-1,k-2)*f[i][j-1]%Mod)%Mod;\n\t}\n\tprintf(\"%lld\\n\",f[n][n]*fac[n]%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F first\n#define S second\n#define pii pair<int,int>\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\nconst int M = 4 * 1e6 + 10 , N = 2017 , mod = 1e9 + 7;\nll fact[M] , inv[M] , f[N] , dp[N];\nint n , k;\n\nint power(int a , int b){\n    if(b == 0)return 1;\n    ll ret = power(a , b/2);\n    ret *= ret; ret %= mod;\n    if(b % 2)ret *= a; ret %= mod;\n    return ret;\n}\n\n\nint comb(int n , int k){\n    if(k > n)return 0;\n    ll ret = fact[n];\n    ret *= inv[k]; ret %= mod;\n    ret *= inv[n - k]; ret %= mod;\n    return ret;\n}\n\nvoid Piri(){\n    fact[0] = 1;\n    for(int i=1;i<M;i++)fact[i] = (fact[i - 1] * i) % mod;\n    inv[M - 1] = power(fact[M - 1] , mod - 2);\n    for(int i=M-2;i>=0;i--)inv[i] = (inv[i + 1] * (i + 1)) % mod;\n    f[0] = 1;\n    for(int i=1;i<=n;i++){\n        ll way = f[i - 1];\n        way *= fact[i * (k - 1)]; way %= mod;\n        way *= inv[(i - 1) * (k - 1)]; way %= mod;\n        way *= inv[(k - 1)]; way %= mod;\n        f[i] = way;\n    }\n}\n\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> k;\n    if(k == 1)return cout << 1 << '\\n' , 0;\n    Piri();\n    dp[0] = dp[1] = 1;\n    for(int i=2;i<=n;i++){\n        for(int j=1;j<=i;j++){\n            ll way = comb(i , j);\n            way *= dp[i - j]; way %= mod;\n            //num = j * (k - 1) - 1;\n            //kol = (i - j) * k + 1 taa ja .\n            ll kol = (i - j) * k +  j * (k - 1) - 1;\n            way *= comb(kol , (i - j) * k); way %= mod;\n            way *= f[j]; way %= mod;\n            dp[i] += way; dp[i] %= mod;\n        }\n    }cout << dp[n] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=2100;\n#define mod 1000000007\nint i,j,k,n,m,x,y,t;\nll fac[N*N],inv[N*N],f[N][N];\nll c(int x,int y){ return fac[x]*inv[y]%mod*inv[x-y]%mod; }\nint read(){ int x=0,f=1;char ch=getchar(); for (;!isdigit(ch);ch=getchar()) if (ch=='-')  f=-f; for (;isdigit(ch);ch=getchar()) x=x*10+ch-'0'; return x*f; }\nint main(){\n\tn=read();k=read();f[n][n]=1;\n\tif (k==1) {printf(\"1\\n\");return 0;}\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor (int i=2;i<N*N;i++) fac[i]=fac[i-1]*i%mod;\n\tfor (int i=2;i<N*N;i++) inv[i]=-(mod/i)*inv[mod%i]%mod;\n\tfor (int i=2;i<N*N;i++) inv[i]=inv[i-1]*(inv[i]+mod)%mod;\n\tfor (int i=n;i>=0;i--) for (int j=i;j>=0;j--){ f[i][j]=(f[i][j]+f[i+1][j])%mod; if (i>j) f[i][j]=(f[i][j]+f[i][j+1]*c((n-j)*k-(i-j)-1,k-2))%mod; }\n\tprintf(\"%lld\\n\",f[0][0]*fac[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\nconst ll MOD = 1e9+7;\n\nll minv[4000001];\nll C[4000001];\nint N,K;\n\nll dp[2001][2001];\nll back(ll i, ll j){\n    ll &ret = dp[i][j];\n    if(ret) return ret;\n    if(i==0&&j==0) return ret=1;\n\n    if(i) ret += back(i-1,j);\n    if(j>i) ret += back(i,j-1)*C[i+j*(K-1)-1]%MOD;\n    return ret %= MOD;\n}\n\nint main(){\n    scanf(\"%d%d\",&N,&K);\n\n    minv[1] = 1;\n    for(int i=2;i<=N*K;i++){\n        minv[i] = MOD - (MOD/i)*minv[MOD%i]%MOD;\n    }\n\n    C[K-2] = 1;\n    for(int i=K-1;i<=N*K;i++){\n        C[i] = C[i-1]*i%MOD*minv[i-(K-2)]%MOD;\n    }\n\n    if(K==1) printf(\"1\");\n    else{\n        ll ans = back(N,N);\n        for(int i=1;i<=N;i++) ans=ans*i%MOD;\n        printf(\"%lld\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#define LL long long\n\nconst int maxN = 2e3 + 2;\nconst int MOD = 1e9 + 7;\n\nint N, K;\nint F[maxN][maxN], fac[maxN * maxN];\n\nLL qpow(LL a, LL b) {\n    LL ans = 1;\n    while (b) {\n        if (b & 1) {\n            ans = ans * a % MOD;\n        }\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return ans;\n}\n\nvoid init() {\n    fac[0] = 1;\n    for (int i = 1; i <= N * K; ++i) \n        fac[i] = 1ll * fac[i - 1] * i % MOD; \n}\n\nint Combine(int n, int m) { \n    if (n < m) return 0;\n    return 1ll * fac[n] * qpow(fac[m], MOD - 2) % MOD * qpow(fac[n - m], MOD - 2) % MOD;\n}\n\nsigned main() {\n   \n    cin >> N >> K;\n    if (K == 1) return puts(\"1\"), 0;\n    init();\n    F[0][0] = 1;\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 0; j <= i; ++j) {\n            F[i][j] = (1ll * F[i - 1][j] + 1ll * (i > 0) * F[i][j - 1] *\n                        Combine(N * K - (j - 1) * (K - 1) - i - 1, K - 2) % MOD) % MOD;\n        }\n    }\n    cout << 1ll * F[N][N] * fac[N] % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=2005;\nconst int MOD=1000000007;\n\nint n,k,f[N][N],jc[N*N+N*2],ny[N*N+N*2];\n\nvoid updata(int &x,int y)\n{\n\tx+=y,x-=x>=MOD?MOD:0;\n}\n\nint C(int n,int m)\n{\n\treturn (LL)jc[n]*ny[m]%MOD*ny[n-m]%MOD;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);k--;\n\tif (!k) {puts(\"1\");return 0;}\n\tjc[0]=jc[1]=ny[0]=ny[1]=1;\n\tfor (int i=2;i<=n*k+n+k;i++) jc[i]=(LL)jc[i-1]*i%MOD,ny[i]=(LL)(MOD-MOD/i)*ny[MOD%i]%MOD;\n\tfor (int i=2;i<=n*k+n+k;i++) ny[i]=(LL)ny[i-1]*ny[i]%MOD;\n\tf[0][0]=1;\n\tfor (int i=0;i<=n;i++)\n\t\tfor (int j=i;j<=n;j++)\n\t\t{\n\t\t\tif (i) updata(f[i][j],f[i-1][j]);\n\t\t\tif (j) updata(f[i][j],(LL)f[i][j-1]*C(i+(j-1)*k+k-1,k-1)%MOD);\n\t\t}\n\tprintf(\"%d\",(LL)f[n][n]*jc[n]%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int lzw=4000000+3,mod=1e9+7;\nint n,k,fac[lzw],ine[lzw],f[lzw],dp[2000][2000];\nint comb(int a, int b) {\n\tif (b > a) return 0;\n\treturn b ? fac[a] * f[a - b] % mod * f[b] % mod : 1; \n}\nvoid pre(){\n\tfac[0]=1;\n\tfor(int i=1;i<=lzw-3;i++) fac[i]=fac[i-1]%mod*i%mod;\n\tine[1]=1;\n\tfor(int i=2;i<=lzw-3;i++){\n\t\tint a=mod/i,b=mod%i;\n\t\tine[i]=(-a*ine[b]%mod+mod)%mod;\n\t}\n\tf[0]=1;\n\tfor(int i=1;i<=lzw-3;i++) f[i]=f[i-1]%mod*ine[i]%mod;\n}\nsigned main(){\n\tpre();\n\tdp[0][0]=1;\n\tscanf(\"%lld%lld\",&n,&k);\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=i;j<=n;j++){\n\t\t\tif(i) dp[i][j]=dp[i-1][j];\n\t\t\tif(j) dp[i][j]=(dp[i][j]+dp[i][j-1]*comb(i+j*(k-1)-1,k-2))%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n][n]*fac[n]%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong long N, K, fact[5000009], inv[5000009], INV[5000009], dp[2009][2009], mod = 1000000007;\n\nlong long ncr(long long n, long long r, long long m) {\n\treturn (((fact[n] * inv[r]) % m)*inv[n - r]) % m;\n}\n\nint main() {\n\tcin >> N >> K; if (N == 1 || K == 1) { cout << \"1\" << endl; return 0; }\n\tfact[0] = 1; inv[0] = 1; INV[0] = 1; INV[1] = 1;\n\tfor (int i = 2; i <= 5000000; i++) INV[i] = (mod - (mod / i)*INV[mod%i] + mod*mod) % mod;\n\tfor (int i = 1; i <= 5000000; i++) fact[i] = (fact[i - 1] * i) % mod;\n\tfor (int i = 1; i <= 5000000; i++) inv[i] = (inv[i - 1] * INV[i]) % mod;\n\tdp[0][0] = 1;\n\tfor (int i = 0; i <= N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (dp[i][j] == 0) continue;\n\t\t\tif (i < N) {\n\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\tdp[i + 1][j] %= mod;\n\t\t\t}\n\t\t\tif (i > j) {\n\t\t\t\tlong long A = K - 2;\n\t\t\t\tlong long B = (N - i) + (N - j - 1)*(K - 1);\n\t\t\t\tdp[i][j + 1] += dp[i][j] * ncr(A + B, A, mod);\n\t\t\t\tdp[i][j + 1] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout << (dp[N][N] * fact[N]) % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n#define mp make_pair\n#define ff first\n#define ss second\n#define pb push_back\n#define pf push_front\n#define popb pop_back\n#define popf pop_front\n#define all(v) v.begin(),v.end()\n\nconst int maxn = 2e3 + 100;\nconst ll inf = 2e18, mod = 1e9 + 7;\n\nint n, k;\nll fact[maxn * maxn], invfact[maxn * maxn], dp[maxn][maxn];\n\nll powmod(ll a, ll b)\n{\n\tif (b == 1)\n\t\treturn a;\n\tll tmp = powmod(a, b / 2);\n\ttmp = tmp * tmp % mod;\n\tif (b & 1)\n\t\ttmp = tmp * a % mod;\n\treturn tmp;\n}\n\nll comb(int n, int r)\n{\n\treturn (fact[n] * (invfact[r] * invfact[n - r] % mod) % mod);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tfact[0] = invfact[0] = 1;\n\tfor (int i = 1; i < maxn * maxn; i++)\n\t{\n\t\tfact[i] = fact[i - 1] * i % mod;\n\t\tinvfact[i] = powmod(fact[i], mod - 2);\n\t}\n\n\tcin >> n >> k;\n\tif (k == 1)\n\t{\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tdp[1][0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 0; j <= i; j++)\n\t\t{\n\t\t\tif (i < n)\n\t\t\t\tdp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % mod;\n\t\t\tif (j < i)\n\t\t\t\tdp[i][j + 1] = (dp[i][j + 1] + dp[i][j] * comb(n * k - i - j * (k - 1) - 1, k - 2)) % mod;\n\t\t}\n\tcout << dp[n][n] * fact[n] % mod << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 2000 * 2000 + 100;\nconst int Mod = 1e9 + 7;\n\nint N, K;\nint fac[Maxn], ifac[Maxn];\nint Dp[2010][2010];\n\ninline int C (int n, int m) { return (LL) fac[n] * ifac[m] % Mod * ifac[n - m] % Mod; }\n\ninline int Pow (int a, int b)\n{\n\tint ans = 1;\n\tfor (int i = b; i; i >>= 1, a = (LL) a * a % Mod) if (i & 1) ans = (LL) ans * a % Mod;\n\treturn ans;\n}\n\ninline void Init ()\n{\n\tfac[0] = 1;\n\tfor (int i = 1; i <= N * K; ++i) fac[i] = (LL) fac[i - 1] * i % Mod;\n\tifac[N * K] = Pow (fac[N * K], Mod - 2);\n\tfor (int i = N * K - 1; i >= 0; --i) ifac[i] = (LL) ifac[i + 1] * (i + 1) % Mod;\n}\n\ninline void Solve ()\n{\n\tif (K == 1) { puts(\"1\"); return ; }\n\tInit ();\n\n\tDp[0][0] = 1;\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tDp[i][0] = 1;\n\t\tfor (int j = 1; j <= i; ++j)\n\t\t\tDp[i][j] = (Dp[i - 1][j] + (LL) Dp[i][j - 1] * C (N * K - i - (j - 1) * (K - 1) - 1, K - 2) % Mod) % Mod;\n\t}\n\n\tcout << (LL) Dp[N][N] * fac[N] % Mod << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), K = read<int>();\n}\n\nint main()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n#define per(i,r,l) for(int i=r;i>=l;--i)\n\ntypedef long long ll;\n\nconst int N=2333,NN=5e6;\nconst ll p=1e9+7;\n\nint n,k;\nll jc[NN+3],njc[NN+3],f[N][N],g[N][N];\n\nll ksm(ll x,ll w){\n\tll ans=1;\n\twhile(w){\n\t\tif(w&1ll) (ans*=x)%=p;\n\t\t(x*=x)%=p;\n\t\tw>>=1;\n\t}\n\treturn ans;\n}\n\nll C(ll a,ll b){\n\treturn (jc[a]*njc[b]%p)*njc[a-b]%p;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\n\tif(k==1){\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t} \n\n\tjc[0]=njc[0]=1;int L=5e6;\n\trep(i,1,L) jc[i]=(jc[i-1]*i)%p;\n\trep(i,1,L) njc[i]=ksm(jc[i],p-2);\n\n\trep(j,1,n) g[n][j]=1;f[n][n]=1;\n\tper(i,n-1,1){\n\t\trep(j,i,n)\n\t\t\tf[i][j]=(g[i+1][j]*C(n-j+(n-i+1)*(k-1)-1,k-2))%p;\n\t\tper(j,n,1) g[i][j]=(g[i][j+1]+f[i][j])%p;\n\t} \n\n\tll ans=0;\n\trep(i,1,n) (ans+=f[1][i])%=p;\n\t(ans*=jc[n])%=p;\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2050\n#define mod 1000000007\nusing namespace std;\ntypedef long long LL;\n\nint n, k, tp;\nLL fac[N*N], inv[N*N], infac[N*N], F[N][N];\n\nvoid inc(LL &x, LL y) {x=(x+y)%mod;}\n\ninline LL C(LL n, LL m) {\n\tif (n < m) return 0LL;\n\tif (n == m || m == 0) return 1LL;\n\treturn 1LL * fac[n] * infac[m] % mod * infac[n-m] % mod;\n}\n\nint main() {\n\tcin >> n >> k;\n\ttp = (2000+1) * (2000+1);\n\tif (k == 1) return puts(\"1\"), 0;\n\tfac[0] = fac[1] = 1LL;\n\tfor (int i=2;i<=tp;i++)\n\t\tfac[i] = 1LL * fac[i-1] * i % mod;\n\t\n\tinv[0] = inv[1] = 1LL;\n\tfor (int i=2;i<=tp;i++)\n\t\tinv[i] = 1LL * (mod-mod/i) * inv[mod%i] % mod;\n\t\n\tinfac[0] = infac[1] = 1LL;\n\tfor (int i=2;i<=tp;i++)\n\t\tinfac[i] = 1LL * infac[i-1] * inv[i] % mod;\n\t\t\n\tF[0][0] = 1LL;\n\t\n\tfor (int i=0;i<=n;i++)\n\t\tfor (int j=i;j<=n;j++) {\n\t\t\tif (i) inc(F[i][j], F[i-1][j]);\n\t\t\tif (j) inc(F[i][j], 1LL * F[i][j-1] * C(i+(j-1)*(k-1)+k-2, k-2) % mod);\n\t\t}\n\t\n\tLL ans = 1LL * F[n][n] * fac[n] % mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reg register int\n#define il inline\n#define fi first\n#define se second\n#define mk(a,b) make_pair(a,b)\n#define numb (ch^'0')\n#define pb push_back\n#define solid const auto &\n#define enter cout<<endl\n#define pii pair<int,int>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>il void rd(T &x){\n    char ch;x=0;bool fl=false;while(!isdigit(ch=getchar()))(ch=='-')&&(fl=true);\n    for(x=numb;isdigit(ch=getchar());x=x*10+numb);(fl==true)&&(x=-x);}\ntemplate<class T>il void output(T x){if(x/10)output(x/10);putchar(x%10+'0');}\ntemplate<class T>il void ot(T x){if(x<0) putchar('-'),x=-x;output(x);putchar(' ');}\ntemplate<class T>il void prt(T a[],int st,int nd){for(reg i=st;i<=nd;++i) ot(a[i]);putchar('\\n');}\nnamespace Modulo{\nconst int mod=1e9+7;\nint ad(int x,int y){return (x+y)>=mod?x+y-mod:x+y;}\nvoid inc(int &x,int y){x=ad(x,y);}\nint mul(int x,int y){return (ll)x*y%mod;}\nvoid inc2(int &x,int y){x=mul(x,y);}\nint qm(int x,int y=mod-2){int ret=1;while(y){if(y&1) ret=mul(x,ret);x=mul(x,x);y>>=1;}return ret;}\n}\nusing namespace Modulo;\nnamespace Miracle{\nconst int N=2002;\nconst int M=4000000+5+N+N;\nint n,k;\nint f[2][N];\nint jie[M],inv[M];\nint C(int n,int m){\n    if(n<0||m<0||n<m) return 0;\n    return mul(jie[n],mul(inv[m],inv[n-m]));\n}\nint main(){\n    rd(n);rd(k);\n    if(k==1){\n        puts(\"1\");return 0;\n    }\n    int lim=n*k+n+n;\n    jie[0]=1;\n    for(reg i=1;i<=lim;++i) jie[i]=mul(jie[i-1],i);\n    inv[lim]=qm(jie[lim]);\n    for(reg i=lim-1;i>=0;--i) inv[i]=mul(inv[i+1],i+1);\n    int tmp=0;\n    f[0][0]=1;\n    for(reg i=2*n;i>=1;--i){\n        tmp^=1;\n        memset(f[tmp],0,sizeof f[tmp]);\n        int re=2*n-i;\n        for(reg j=0;j<=min(re,n);++j){\n            if(!f[tmp^1][j]) continue;\n            int le=re-j;\n            if(le+1<=j) f[tmp][j]=ad(f[tmp][j],f[tmp^1][j]);\n            if(j!=n){\n                f[tmp][j+1]=ad(f[tmp][j+1],mul(f[tmp^1][j],C(k-2+le+j*(k-1),le+j*(k-1))));\n            }\n        }\n    }\n    ll ans=mul(f[tmp][n],jie[n]);\n    ot(ans);\n    return 0;\n}\n\n}\nsigned main(){\n    Miracle::main();\n    return 0;\n}\n\n/*\n   Author: *Miracle*\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 2010\n#define lim 5000010\n#define mod 1000000007\nusing namespace std;\nint fac[lim+10],inv[lim+10],dp[maxn][maxn],n,k;\nint qpow(int a,int b){\n\tint ans=1,tmp=a;\n\tfor(;b;b>>=1,tmp=1ll*tmp*tmp%mod)\n\t\tif(b&1)ans=1ll*ans*tmp%mod;\n\treturn ans;\n}\nint C(int x,int y){\n\treturn 1ll*fac[y]*inv[x]%mod*inv[y-x]%mod;\n}\nint cal(int pos,int x){\n\treturn C(x-1,x+pos-1);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k),inv[0]=fac[0]=1;\n\tif(k==1)return puts(\"1\"),0;\n\tfor(int i=1;i<lim;++i)fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[lim-1]=qpow(fac[lim-1],mod-2);\n\tfor(int i=lim-2;i>=1;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tdp[0][0]=1;\n\tfor(int i=0;i<=n;++i)\n\t\tfor(int j=i;j<=n;++j){\n\t\t\tdp[i+1][j]=(dp[i+1][j]+dp[i][j])%mod;\n\t\t\tdp[i][j+1]=(dp[i][j+1]+1ll*dp[i][j]*cal((j)*(k-1)+i,k-1))%mod;\n\t\t}\n\tprintf(\"%d\",1ll*dp[n][n]*fac[n]%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define MOD 1000000007\n\n#define MAXN 2000\n#define MAXT 2000*2000\n\nint fact[MAXT+1], invFact[MAXT+1];\nint dp[MAXN+1][MAXN+1];\n\ninline int lgput(int a, int n){\n    int r=1;\n    while(n>0){\n        if(n%2) r=1LL*r*a%MOD;\n        n/=2;\n        a=1LL*a*a%MOD;\n    }\n    return r;\n}\n\ninline int comb(int n, int k){\n    return 1LL*fact[n]*invFact[k]%MOD*invFact[n-k]%MOD;\n}\n\nint main(){\n    int n, k;\n    scanf(\"%d%d\", &n, &k);\n\n    if(k==1){\n        printf(\"1\\n\");\n        return 0;\n    }\n\n    int t=n*k;\n\n    fact[0]=1;\n    for(int i=1; i<=t; i++)\n        fact[i]=1LL*fact[i-1]*i%MOD;\n    invFact[t]=lgput(fact[t], MOD-2);\n    for(int i=t-1; i>=0; i--)\n        invFact[i]=1LL*invFact[i+1]*(i+1)%MOD;\n\n    dp[0][0]=1;\n    for(int i=1; i<=n; i++){\n        dp[i][0]=1LL*dp[i-1][0]*comb(i*(k-1)-1, k-2)%MOD;\n        for(int j=1; j<=i; j++)\n            dp[i][j]=(dp[i][j-1]+1LL*dp[i-1][j]*comb(j+i*(k-1)-1, k-2))%MOD;\n    }\n\n    int ans=1LL*dp[n][n]*fact[n]%MOD;\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define N 2001\n#define P 4000001\n#define M 1000000007LL\n\nlong long p[2][P], f[N][N];\nint n, k, t;\n\nlong long sel(int n, int m)\n{\n    return n >= m ? p[0][n] * p[1][m] % M * p[1][n - m] % M : 0;\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &k);\n    t = n * k;\n\n    p[0][0] = 1;\n    for (int i = 1; i <= t; i++)\n        p[0][i] = p[0][i - 1] * i % M;\n\n    p[1][t] = 1;\n    for (long long x = p[0][t], e = M - 2; e; e >>= 1, x = x * x % M)\n        if (e & 1)\n            p[1][t] = p[1][t] * x % M;\n\n    for (int i = t; i; i--)\n        p[1][i - 1] = p[1][i] * i % M;\n\n    f[0][0] = 1;\n    for (int i = 0; i <= n; i++)\n    {\n        for (int j = i; j <= n; j++)\n        {\n            f[i][j + 1] = (f[i][j + 1] + f[i][j]) % M;\n            f[i + 1][j] = (f[i + 1][j] + f[i][j] * sel(t - i * (k - 1) - j - 1, k - 2) % M) % M;\n        }\n    }\n\n    printf(\"%lld\\n\", f[n][n] * p[0][n] % M);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nconst int N = 4e6 + 5, Mod = 1e9 + 7;\n\nint n, k;\nll p[N], inv[N], P[N];\n\nll Pow(ll x, ll y) {\n\tll cur = 1;\n\twhile (y) {\n\t\tif (y & 1) cur = cur * x % Mod;\n\t\tx = x * x % Mod;\n\t\ty >>= 1;\n\t}\n\treturn cur;\n}\n\nvoid Pre() {\n\tp[0] = 1; for (int i = 1; i < N; ++ i) p[i] = p[i - 1] * (ll)i % Mod;\n\tinv[N - 1] = Pow(p[N - 1], Mod - 2);\n\tfor (int i = N - 2; i >= 0; -- i) inv[i] = inv[i + 1] * (ll)(i + 1) % Mod;\n}\n\nll Calc(int x, int y) {\n\treturn p[x] * inv[x - y] % Mod * inv[y] % Mod;\n}\n\nvoid Mul(ll &x, ll y) {\n\tx *= y; x %= Mod;\n}\n\nll f[2005][2005];\n\nint main(void) {\n\tPre();\n\tscanf(\"%d%d\", &n, &k);\n\tif (k == 1) return 0 * puts(\"1\");\n\n\tf[0][1] = 1;\n\tfor (int i = 2; i <= n; ++ i) {\n\t\tf[0][i] = f[0][i - 1] * Calc(i*(k-1)-1, k - 2) % Mod;\t\n\t}\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tfor (int j = i; j <= n; ++ j) {\n\t\t\tf[i][j] = f[i][j - 1] * Calc(i + j * (k - 1) - 1, k - 2) % Mod;\n\t\t\tif (f[i][j] >= Mod) f[i][j] -= Mod;\n\t\t\tf[i][j] += f[i - 1][j];\n\t\t\tif (f[i][j] >= Mod) f[i][j] -= Mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", f[n][n] * p[n] % Mod);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nconst int MAXN = 2e3 + 10, MAXL = 4e6 + 10;\n\nint n, m, L;\nint dp[MAXN][MAXN], fac[MAXL], inv[MAXL];\n\nint C(int n, int m) {\n\tif (n < m) return 0;\n\treturn (long long)fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tif (m <= 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tL = n * m;\n\tfac[0] = fac[1] = inv[0] = inv[1] = 1;\n\tfor (int i = 2; i <= L; ++i) {\n\t\tfac[i] = (long long)fac[i - 1] * i % mod;\n\t\tinv[i] = (long long)(mod - mod / i) * inv[mod % i] % mod;\n\t}\n\tfor (int i = 2; i <= L; ++i)\n\t\tinv[i] = (long long)inv[i - 1] * inv[i] % mod;\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = i; ~j; --j) {\n\t\t\tdp[i][j] = dp[i][j + 1]; // put white\n\t\t\tif (j) (dp[i][j] += (long long)dp[i - 1][j - 1] * C(i * m - j - 1, m - 2) % mod) %= mod;\n\t\t}\n\tprintf(\"%d\\n\", static_cast<int>((long long)dp[n][0] * fac[n] % mod));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\nusing namespace std;\ntypedef long long ll; \ntypedef long double ld;\ntypedef pair<ll, ll> pll;\n\nconst ll N = 2300, Mod = 1e9 + 7;\nconst ll SQ = 330;\n\n\nll n, k, dp[N][N], I[N * N], F[N * N];\nll sum(ll a, ll b) {\n\treturn (a + b + Mod) % Mod;\n}\nll mul(ll a, ll b) {\n\treturn (a * b) % Mod;\n}\nll Pow(ll a, ll b) {\n\tll res = 1;\n\tfor (; b; b >>= 1, a = mul(a, a))\n\t\tif (b & 1)\n\t\t\tres = mul(res, a);\n\treturn res;\n}\n\nll C(ll r, ll n) {\n\tif (r > n || r < 0)\n\t\treturn 0;\n\treturn mul(F[n], mul(I[r], I[n - r]));\n}\nint main () {\n    ios::sync_with_stdio(0), cin.tie(0);\n    F[0] = 1;\n    for (int i = 1; i < N * N; i ++)\n    \tF[i] = mul(i, F[i - 1]);\n    I[N * N - 1] = Pow(F[N * N - 1], Mod - 2);\n    for (int i = N * N - 2; ~i; i --)\n    \tI[i] = mul(i + 1, I[i + 1]);\n    //cout << C(0, 0) << endl;\n    cin >> n >> k;\n    if (k == 1)\n    \treturn cout << 1, 0;\n    dp[0][0] = 1;\n    for (int i = 0; i <= n; i ++) { // zero\n    \tfor (int j = 0; j <= n; j ++) { // col\n    \t\tif (i < j) continue;\n    \t\tif (i + j == 0) continue;\n    \t\tif (i) {\n    \t\t\tdp[i][j] = sum(dp[i][j], dp[i - 1][j]);\n\t\t\t}\n\t\t\tif (j) {\n\t\t\t\tll res = C(k - 2, n * k - i - ((j - 1)* (k - 1)) - 1);\n\t\t\t\tres =  mul(res, dp[i][j - 1]);\n\t\t\t\tdp[i][j] = sum(dp[i][j], res);\n\t\t\t}\n\t\t}\n\t}\n\tll ans = mul(dp[n][n], F[n]);\n\tcout << ans;\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int mod = 1000000007, N = 2005;\ntypedef long long LL;\n\nint n, k, f[N * N], inv[N * N], dp[N][N];\nint pow(int x, int y, int ans = 1) {\n\tfor (; y; y >>= 1, x = (LL) x * x % mod)\n\t\tif (y & 1) ans = (LL) ans * x % mod;\n\treturn ans;\n}\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n >> k;\n\tif (k == 1) return std::cout << 1 << '\\n', 0;\n\tf[k - 2] = 1, inv[1] = 1;\n\tfor (int i = 2; i <= n * k - (k - 2); ++i)\n\t\tinv[i] = (LL) inv[mod % i] * (mod - mod / i) % mod;\n\tfor (int i = k - 1; i <= n * k; ++i)\n\t\tf[i] = (LL) f[i - 1] * i % mod * pow(i - (k - 2), mod - 2) % mod;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tdp[i][0] = 1;\n\t\tfor (int j = 1; j <= i; ++j)\n\t\t\tdp[i][j] = (dp[i - 1][j] + (LL) dp[i][j - 1] * f[n * k - i - (j - 1) * (k - 1) - 1]) % mod;\n\t}\n\tint ans = dp[n][n];\n\tfor (int i = 1; i <= n; ++i) ans = (LL) ans * i % mod;\n\tstd::cout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nlong long Mod = 1000000007, Inv[4010000], F[4010000], InvF[4010000], D[2010][2010];\nlong long Comb(int a, int b){\n    return F[a]*InvF[b]%Mod*InvF[a-b]%Mod;\n}\nint n, K;\nint main(){\n    int i, j;\n    scanf(\"%d%d\",&n,&K);\n    Inv[1]=F[0]=InvF[0]=1;\n    for(i=2;i<=n*K;i++){\n        Inv[i] = Inv[Mod%i] * (Mod-Mod/i)%Mod;\n    }\n    for(i=1;i<=n*K;i++){\n        F[i]=F[i-1]*i%Mod;\n        InvF[i]=InvF[i-1]*Inv[i]%Mod;\n    }\n    for(i=0;i<=n;i++){\n        for(j=i;j<=n;j++){\n            if(i==0&&j==0)D[i][j]=1;\n            if(i) D[i][j] = D[i-1][j];\n            if(j>i) D[i][j] = (D[i][j] + D[i][j-1]* Comb(n*K - (n-i) - (n-j)*(K-1) - 1, K-2))%Mod;\n        }\n    }\n    printf(\"%lld\\n\",D[n][n]*F[n]%Mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#define re register\n#define LL long long\n#define N 2005\n#define Maxn 4000000\nusing namespace std;\nconst int Mod=1e9+7;\nint n,k;\nLL f[N][N],fac[Maxn+5],inv_fac[Maxn+5];\ninline LL C(int n,int m){ return (((fac[m]*inv_fac[n])%Mod)*inv_fac[m-n])%Mod; }\nLL power(LL x,int P){\n    LL ans=1,m=x;\n    while(P){\n        if(P&1) (ans*=m)%=Mod;\n        P>>=1;(m*=m)%=Mod;\n    }\n    return ans;\n}\nint main(){\n    scanf(\"%d%d\",&n,&k);\n    if(k==1){ printf(\"%d\\n\",1); return 0; }\n    fac[0]=1; for(re int i=1;i<=Maxn;++i) fac[i]=(fac[i-1]*i)%Mod;\n    inv_fac[Maxn]=power(fac[Maxn],Mod-2); for(re int i=Maxn-1;i>=0;--i) inv_fac[i]=(inv_fac[i+1]*(i+1))%Mod;\n    f[0][0]=1;\n    for(re int i=1;i<=n;++i){\n        for(re int j=0;j<=i;++j){\n            f[i][j]=f[i-1][j];\n            if(!j) continue;\n            (f[i][j]+=f[i][j-1]*(n-j+1)%Mod*C(k-2,n-i+(n-j+1)*(k-1)-1)%Mod)%=Mod;\n        }\n    }\n    printf(\"%lld\\n\",f[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define HEAP priority_queue\n#define rep(i, n) for(int i = 0, _end_ = (n); i < _end_; ++i)\n#define per(i, n) for(int i = (n) - 1; i >= 0 ; --i)\n#define forn(i, l, r) for(int i = (l), _end_ = (r); i <= _end_; ++i)\n#define nrof(i, r, l) for(int i = (r), _end_ = (l); i >= _end_; --i)\n#define FOR(a, b) for(auto (a): (b))\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-6\n#define pi 3.1415926535897932384626433832795\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef vector<LL> vl;\ntypedef pair<int,int> pii;\ntypedef pair<int,LL> pil;\ntypedef pair<LL,int> pli;\ntypedef pair<LL,LL> pll;\ntypedef vector<pil> vil;\ntypedef vector<pii> vii;\ntypedef vector<pli> vli;\ntypedef vector<pll> vll;\n\nconst int iinf = 1e9 + 7;\nconst int oo = 0x3f3f3f3f;\nconst LL linf = 1ll << 60;\nconst flt dinf = 1e60;\n\ntemplate <typename T> inline void scf(T &x) {\n\tbool f = 0;\n\tx = 0;\n\tchar c = getchar();\n\twhile(c != '-' && (c < '0' || c > '9')) c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\tif(f) x = -x;\n\treturn;\n}\n\ntemplate <typename T1, typename T2> void scf(T1 &x, T2 &y) {\n\tscf(x);\n\treturn scf(y);\n}\n\ntemplate <typename T1, typename T2, typename T3> void scf(T1 &x, T2 &y, T3 &z) {\n\tscf(x);\n\tscf(y);\n\treturn scf(z);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4> void scf(T1 &x, T2 &y, T3 &z, T4 &w) {\n\tscf(x);\n\tscf(y);\n\tscf(z);\n\treturn scf(w);\n}\n\ninline char mygetchar() {\n\tchar c = getchar();\n\twhile(c == ' ' || c == '\\n') c = getchar();\n\treturn c;\n}\n\ntemplate <typename T> inline bool chkmax(T &x, const T &y) {\n\treturn y > x ? x = y, 1 : 0;\n}\n\ntemplate <typename T> inline bool chkmin(T &x, const T &y) {\n\treturn y < x ? x = y, 1 : 0;\n}\n\n#ifdef King_George\n#define DEBUG\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\n//---------------------------------------------------------head----------------------------------------------------\n\nconst int maxn = 2010;\n\nconst int maxm = maxn * maxn;\n\nconst int mod = 1e9 + 7;\n\nint n, k;\nint dp[maxn][maxn];\nint fac[maxm], ifac[maxm];\n\nint pow_mod(int x, int n) {\n\tint y = 1;\n\twhile(n) {\n\t\tif(n & 1) {\n\t\t\ty = 1ll * y * x % mod;\n\t\t}\n\t\tx = 1ll * x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn y;\n}\n\nvoid pre() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < maxm; ++i) {\n\t\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\t}\n\tifac[maxm - 1] = pow_mod(fac[maxm - 1], mod - 2);\n\tfor (int i = maxm - 1; i >= 1; --i) {\n\t\tifac[i - 1] = 1ll * ifac[i] * i % mod;\n\t}\n\treturn;\n}\n\nint C(int n, int m) {\n\treturn (n < m || m < 0) ? 0 : 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nint main() {\n\tpre();\n\tscf(n, k);\n\tif(k == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tdp[0][0] = 1;\n\tint tmp;\n\tforn(i, 0, n) {\n\t\tforn(j, 0, n) {\n\t\t\tif(tmp = dp[i][j]) {\n\t\t\t\tif(j < i) {\n\t\t\t\t\tdp[i][j + 1] = (1ll * tmp * C((n - j) * (k - 1) + n - i - 1, k - 2) + dp[i][j + 1]) % mod;\n\t\t\t\t}\n\t\t\t\t(dp[i + 1][j] += tmp) %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", 1ll * fac[n] * dp[n][n] % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long int ll;\n\nll mod=1e9+7;\n\nll mod_pow(ll a,ll b){\n    a%=mod;\n    if(b==0)return 1;\n    if(b==1)return a;\n    ll res=mod_pow(a,b/2)%mod;\n    res*=res; res%=mod;\n    if(b%2)res*=a;\n    return res%mod;\n}\n\nstruct perm{\nprivate:\n    int sz;\n    vector<ll> p,invp;\npublic:\n    perm(int n){\n        sz=n+1;\n        p.resize(sz),invp.resize(sz);\n        p[0]=1;\n        for(int i=1;i<=sz-1;i++){\n            p[i]=p[i-1]*i%mod;\n        }\n        invp[sz-1]=mod_pow(p[sz-1],mod-2);\n        for(int i=sz-2;i>=0;i--){\n            invp[i]=invp[i+1]*(i+1)%mod;\n        }\n    }\n    ll comb(ll x,ll y){\n        if(x<y||y<0)return 0;\n        return (p[x]*invp[x-y]%mod)*invp[y]%mod;\n    }\n};\nperm p(1<<22);\n\nll dp[2020][2020];\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n,k; cin >> n >> k;\n    if(k==1){\n        cout << 1 << endl;\n        return 0;\n    }\n    dp[0][1]=1;\n    for(int i=2;i<=n;i++){\n        dp[0][i]=dp[0][i-1]*p.comb(i*(k-1)-1,k-2)%mod;\n    }\n    for(int i=1;i<=n;i++){\n        dp[i][i]=dp[i-1][i];\n        for(int j=i+1;j<=n;j++){\n            dp[i][j]=(dp[i-1][j]+dp[i][j-1]*p.comb(j*(k-1)+i-1,k-2))%mod;\n        }\n    }\n    ll res=dp[n][n];\n    for(ll i=1;i<=n;i++){\n        (res*=i)%=mod;\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#define res register int\n#define N 2005\nusing namespace std;\nint inv[N*N+N+N],jie[N*N+N+N],k,n,f[N][N];\nconst int mod=1e9+7;\ninline int read()\n{\n  int X=0,w=0;\n  char ch=0;\n  while(!isdigit(ch))\n  {\n    w|=ch=='-';\n    ch=getchar();\n  }\n  while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();\n  return w?-X:X;\n}\ninline int quickpow(res base,res num)\n{\n  res ans=1;\n  for(; num; num>>=1,base=1LL*base*base%mod)\n    if(num&1)\n      ans=1LL*ans*base%mod;\n  return ans;\n}\ninline void init()\n{\n  jie[0]=jie[1]=inv[0]=inv[1]=1;\n  for(res i=2; i<=n*n+n+k; i++)\n  {\n    jie[i]=1LL*jie[i-1]*i%mod;\n    inv[i]=quickpow(jie[i],mod-2);\n  }\n}\ninline int C(int m,int n)\n{\n  return 1LL*jie[m]*inv[n]%mod*inv[m-n]%mod;\n}\nint main()\n{\n  n=read(),k=read()-1;\n  if(!k)\n  {\n    puts(\"1\");\n    return 0;\n  }\n  init();\n  f[0][0]=1;\n  for(res i=0; i<=n; i++)\n    for(res j=i; j<=n; j++)\n    {\n      if(i) f[i][j]=(f[i][j]+f[i-1][j])%mod;\n      if(j) f[i][j]=(f[i][j]+1LL*f[i][j-1]*C(i+j*k-1,k-1)%mod)%mod;\n    }\n  printf(\"%d\\n\",1LL*f[n][n]*jie[n]%mod);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int maxn=2000+10;\nconst int p=1e9+7;\nint n,k,f[maxn][maxn],farc[maxn*maxn],inv[maxn*maxn];\n\nint C(int n,int m){\n\treturn (ll)farc[n]*inv[m]%p*(ll)inv[n-m]%p;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);k--;\n\tfarc[0]=farc[1]=inv[0]=inv[1]=1;\n\tfor(int i=2;i<=n*k+n+k;i++){\n\t\tfarc[i]=(ll)farc[i-1]*i%p;\n\t\tinv[i]=(ll)(p-p/i)*inv[p%i]%p;\n\t}\n\tfor(int i=2;i<=n*k+n+k;i++) inv[i]=(ll)inv[i]*inv[i-1]%p;\n\tf[0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=i;j<=n;j++){\n\t\t\tif(i>0) f[i][j]=f[i-1][j];\n\t\t\tif(j>0) f[i][j]=(f[i][j]+(ll)f[i][j-1]*C(i+(j-1)*k+k-1,k-1)%p)%p;\n\t\t}\n\tprintf(\"%d\\n\",f[n][n]*farc[n]%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int MAXN=4000000;\nconst int MOD=1e9+7;\nlong long a[MAXN+10],pre[MAXN+10],n,k,f[2200][2200];\nlong long C(long long p,int x){\n\treturn ((pre[p]*a[x])%MOD)*a[p-x]%MOD;\n}\nlong long pp(int x,int p){\n\tlong long ans=1,m=x;\n\twhile(p){\n\t\tif(p&1)(ans*=m)%=MOD;\n\t\tp>>=1;(m*=m)%=MOD;\n\t}\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n    if(k==1){\n        printf(\"1\");\n        return 0;\n    }\n\tpre[0]=1;\n\tfor(int i=1;i<=MAXN;i++)pre[i]=i*pre[i-1]%MOD;\n\ta[MAXN]=pp(pre[MAXN],MOD-2);for(int i=MAXN-1;i>=0;i--)a[i]=a[i+1]*(i+1)%MOD;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(i)f[i][j]=(f[i-1][j]+f[i][j-1])%MOD;\n\t\t\tif(j)f[i][j]=f[i-1][j]+f[i][j-1]*(n-j+1)*C(n*k-i-(j-1)*(k-1)-1,k-2)%MOD;\n\t\t}\n\t}\n\n\tprintf(\"%d\",f[n][n]%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst int MAX = 5000000;\n\nll mod_pow(ll x, ll e){\n  ll v = 1;\n  for(;e;e>>=1){\n    if(e & 1)v = (v * x) % MOD;\n    x = (x * x) % MOD;\n  }\n  return v;\n}\n\nll f[MAX], finv[MAX];\nvoid init(){\n  f[0] = 1;\n  for(int i=1;i<MAX;i++)f[i] = f[i-1] * i % MOD;\n  finv[MAX-1] = mod_pow(f[MAX-1], MOD-2);\n  for(int i=MAX-2;i>=0;i--)finv[i] = finv[i+1] * (i+1) % MOD;\n}\n\nll C(int n, int k){\n  return f[n] * finv[k] % MOD * finv[n-k] % MOD;\n}\n\nint N, K;\n\nll dp[2010][2010]; // (i <= j)\nll solve(int i, int j){\n  if(i == 0 && j == 0)return 1;\n  if(dp[i][j] != -1)return dp[i][j];\n  ll res = 0;\n  if(i > 0)\n    res = (res + solve(i - 1, j)) % MOD;\n  if(i <= j - 1){\n    int n = i + (j - 1) * (K - 1) + K - 2;\n    int k = K - 2;\n    ll tmp = solve(i, j - 1) * C(n, k) % MOD;\n    res = (res + tmp) % MOD;\n  }\n  return dp[i][j] = res;\n}\n\nint main(){\n  init();\n\n  cin >> N >> K;\n  if(K == 1){\n    cout << 1 << endl;\n    return 0;\n  }\n  \n  memset(dp, -1, sizeof(dp));\n  ll res = solve(N, N) * f[N] % MOD;\n  cout << res << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nconst int N = 2005, M = 4000005, mo = 1e9 + 7;\nint n, k; ll ans;\nll fac[M], ivf[M], inv[M], f[N][N];\nvoid prep () {\n\tfac[0] = ivf[0] = 1;\n\tfac[1] = ivf[1] = inv[1] = 1;\n\tfor (int i = 2; i < M; ++i) {\n\t\tfac[i] = fac[i - 1] * i % mo;\n\t\tinv[i] = mo - 1ll * mo / i * inv[mo % i] % mo;\n\t\tivf[i] = ivf[i - 1] * inv[i] % mo;\n\t}\n}\nll C (int n, int r) {\n\tif (r < 0 || n < r)\n\t\treturn 0;\n\treturn fac[n] * ivf[r] % mo * ivf[n - r] % mo;\n}\nll get (int a, int b) {\n\treturn C(a + b, a);\n}\nint main () {\n\tcin >> n >> k, prep();\n\tif (k == 1)\n\t\treturn puts(\"1\"), 0;\n\tf[n][n] = 1;\n\tfor (int i = n; ~i; --i)\n\t\tfor (int j = n; ~j; --j) {\n\t\t\tif (i)\n\t\t\t\tf[i - 1][j] += f[i][j], f[i - 1][j] %= mo;\n\t\t\tif (i <= j - 1 && j) {\n\t\t\t\tf[i][j - 1] += f[i][j] * get(k - 2, (k - 1) * (j - 1) + i);\n\t\t\t\tf[i][j - 1] %= mo;\n\t\t\t}\n\t\t}\n\tcout << f[0][0] * fac[n] % mo << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2020, M = N * N;\nconst int MOD = 1e9 + 7;\nint f[N][N], fra[M], inv[M];\n\nint qpow(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % MOD)\n\t\tif (b & 1) res = 1ll * res * a % MOD;\n\treturn res;\n}\n \nvoid init(int n) {\n\tfra[0] = 1;\n\tfor (int i = 1; i <= n; i++) fra[i] = 1ll * fra[i - 1] * i % MOD;\n\tinv[n] = qpow(fra[n], MOD - 2);\n\tfor (int i = n - 1; i >= 0; i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % MOD;\n}\n\nint C(int n, int m) {\n\tif (m > n) return 0;\n\treturn 1ll * fra[n] * inv[n - m] % MOD * inv[m] % MOD;\n}\n\nint main() {\n\tinit(2000 * 2000);\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tif (k == 1) {\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i <= n; i++) f[i][0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= i; j++)\n\t\t\tf[i][j] = (f[i - 1][j] + (long long)f[i][j - 1] * C(n * k - i - 1- (k - 1) * (j - 1), k - 2) % MOD) % MOD;\n//\tfor (int i = 1; i <= n; i++)\n//\t\tfor (int j = 0; j <= i; j++)\n//\t\t\tprintf(\"%d%c\", f[i][j], \" \\n\"[j == i]);\n\tint ans = 1ll * f[n][n] * fra[n] % MOD;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\nconst int maxn = 2005, mod = 1e9 + 7;\n\nint n, k, m, fac[maxn * maxn], ifac[maxn * maxn], f[maxn][maxn];\n\ninline int gi()\n{\n\tchar c = getchar();\n\twhile (c < '0' || c > '9') c = getchar();\n\tint sum = 0;\n\twhile ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();\n\treturn sum;\n}\n\ninline void inc(int &a, int b) {a += b; if (a >= mod) a -= mod;}\ninline int C(int n, int m)\n{\n\treturn (lint)fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nint main()\n{\n\tn = gi(); k = gi();\n\tif (k == 1) return puts(\"1\"), 0;\n\n\tm = n * k;\n\tfac[0] = ifac[0] = ifac[1] = 1;\n\tfor (int i = 1; i <= m; ++i) fac[i] = (lint)fac[i - 1] * i % mod;\n\tfor (int i = 2; i <= m; ++i) ifac[i] = (lint)(mod - mod / i) * ifac[mod % i] % mod;\n\tfor (int i = 1; i <= m; ++i) ifac[i] = (lint)ifac[i - 1] * ifac[i] % mod;\n\n\tf[1][0] = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tif (i > j) inc(f[i][j], f[i - 1][j]);\n\t\t\tif (j) inc(f[i][j], (lint)f[i][j - 1] * C(m - i - (j - 1) * (k - 1) - 1, k - 2) % mod);\n\t\t}\n\n\tprintf(\"%lld\\n\", (lint)f[n][n] * fac[n] % mod);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 2000 + 5\n#define M 4000000 + 5\n#define Mod 1000000007\n#define rep(i, l, r) for(int i = l; i <= r; ++i)\n#define dep(i, l, r) for(int i = r; i >= l; --i)\nint n, k, f[M], inv[M], dp[N][N];\nint read(){\n    char c; int x = 0, f = 1;\n    c = getchar();\n    while(c > '9' || c < '0'){ if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nint Inc(int a, int b){ return (a += b) >= Mod ? a - Mod : a;}\nint Mul(int a, int b){ return 1ll * a * b % Mod;}\nint Qpow(int a, int b){\n    int ans = 1;\n    while(b){\n        if(b & 1) ans = Mul(ans, a);\n        a = Mul(a, a), b >>= 1;\n    }\n    return ans;\n}\nint C(int n, int m){\n    if(m > n) return 0;\n    return Mul(f[n], Mul(inv[m], inv[n - m]));\n}\nint main(){\n    n = read(), k = read();\n    if(k == 1){ puts(\"1\"); return 0;}\n    f[0] = inv[0] = 1;\n    rep(i, 1, M - 5) f[i] = Mul(f[i - 1], i);\n    inv[M - 5] = Qpow(f[M - 5], Mod - 2);\n    dep(i, 1, M - 6) inv[i] = Mul(inv[i + 1], i + 1);\n    dp[0][0] = 1;\n    rep(i, 1, n) rep(j, 0, i){\n        dp[i][j] = Inc(dp[i][j], dp[i - 1][j]);\n        if(j >= 1) dp[i][j] = Inc(dp[i][j], Mul(dp[i][j - 1], C(n * k - i - (j - 1) * (k - 1) - 1, k - 2)));\n    }\n    printf(\"%d\", Mul(dp[n][n], f[n]));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2018.9.25 by ljz\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define eps 1e-15\ninline int read(){\n    res s=0;\n    bool w=0;\n    char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')w=1;ch=getchar();}\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();\n    return w?-s:s;\n}\ninline void _swap(res &x,res &y){\n    x^=y^=x^=y;\n}\ninline int _abs(const res &x){\n    return x>0?x:-x;\n}\ninline int _max(const res &x,const res &y){\n    return x>y?x:y;\n}\ninline int _min(const res &x,const res &y){\n    return x<y?x:y;\n}\nconst int kcz=1e9+7;\nconst int NN=2e3+10,KK=2e3+10,N=NN*KK+NN+KK;\nnamespace MAIN{\n    inline int qpow(res x,res y,const res &kcz){\n        res ans=1;\n        while(y){\n            if(y&1)ans=(LL)ans*x%kcz;\n            x=(LL)x*x%kcz,y>>=1;\n        }\n        return ans%kcz;\n    }\n    int inv[N],fac[N];\n    inline void pre(){\n        inv[0]=inv[1]=fac[0]=fac[1]=1;\n        for(res i=2;i<=N-10;i++)fac[i]=(LL)fac[i-1]*i%kcz,inv[i]=(LL)(kcz-kcz/i)*inv[kcz%i]%kcz;\n        for(res i=2;i<=N-10;i++)inv[i]=(LL)inv[i-1]*inv[i]%kcz;\n    }\n    inline int C(const res &x,const res &y){\n        return (LL)fac[x]*inv[y]%kcz*inv[x-y]%kcz;\n    }\n    int n,k;\n    int dp[NN][KK];\n    inline void add(res &x,const res &y){\n        x+=y;\n        x>=kcz?x-=kcz:1;\n    }\n    inline void MAIN(){\n        pre();\n        n=read(),k=read()-1;\n        if(!k){puts(\"1\");return;}\n        dp[0][0]=1;\n        for(res i=0;i<=n;i++)\n            for(res j=i;j<=n;j++){\n                if(i)add(dp[i][j],dp[i-1][j]);\n                if(j)add(dp[i][j],(LL)dp[i][j-1]*C(i+j*k-1,k-1)%kcz);\n            }\n        printf(\"%d\\n\",(LL)dp[n][n]*fac[n]%kcz);\n    }\n}\nint main(){\n    MAIN::MAIN();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nconst int mod = 1e9 + 7;\nint n, k, jc[4000010], ny[4000010];\nint f[2010][2010];\ninline int ksm (int a, int p) {\n\tint res = 1;\n\twhile (p) {\n\t\tif (p & 1) res = 1ll * res * a % mod;\n\t\ta = 1ll * a * a % mod, p >>= 1;\n\t}\n\treturn res;\n}\ninline int C (int n, int m) { return 1ll * jc[n] * ny[m] % mod * ny[n - m] % mod; }\nint main () {\n\tscanf (\"%d%d\", &n, &k);\n\tif (k == 1) { printf (\"1\\n\"); return 0; }\n\tjc[0] = 1; for (int i = 1; i <= 4000000; i++) jc[i] = 1ll * jc[i - 1] * i % mod;\n\tny[4000000] = ksm (jc[4000000], mod - 2);\n\tfor (int i = 4000000; i >= 1; i--) ny[i - 1] = 1ll * ny[i] * i % mod;\n\tf[0][0] = 1;\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\t(f[i + 1][j] += f[i][j]) %= mod;\n\t\t\tint x = n * k - j * k - i + j;\n\t\t\t(f[i][j + 1] += 1ll * f[i][j] * C (x - 1, k - 2) % mod) %= mod;\n\t\t}\n\t\t(f[i + 1][i] += f[i][i]) %= mod;\n\t}\n\tfor (int i = 1; i <= n; i++) f[n][n] = 1ll * f[n][n] * i % mod;\n\tprintf (\"%d\\n\", f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\nll p=1000000007;\nll fac[4000010];\nll ifac[4000010];\nll inv[4000010];\nvoid init(int n)\n{\n    int i;\n    fac[0]=fac[1]=ifac[0]=ifac[1]=inv[0]=inv[1]=1;\n    for(i=2;i<=n;i++)\n    {\n        inv[i]=-(p/i)*inv[p%i]%p;\n        fac[i]=fac[i-1]*i%p;\n        ifac[i]=ifac[i-1]*inv[i]%p;\n    }\n}\nll c(int x,int y)\n{\n    if(x<y)\n        return 0;\n    return fac[x]*ifac[y]%p*ifac[x-y]%p;\n}\nll f[2010][2010];\nint main()\n{\n    int n,k;\n    scanf(\"%d%d\",&n,&k);\n    if(k<=1)\n    {\n        printf(\"1\\n\");\n        return 0;\n    }\n    init(n*k);\n    int i,j;\n    f[0][0]=1;\n    for(i=1;i<=n;i++)\n        for(j=n;j>=0;j--)\n        {\n            if(j<=i)\n                f[i][j]+=f[i-1][j-1]*c(k*i-j-1,k-2)%p;\n            f[i][j]=(f[i][j]+f[i][j+1])%p;\n        }\n    ll ans=(f[n][0]%p+p)%p;\n    ans=ans*fac[n]%p;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\ntypedef long long ll;\nll mod=1e9+7;\nll dp[2001][2001];\nconst int M=2000*2000;\nll f[M+1],g[M+1],inv[M+1];\nvoid precalc(){\n\tf[0]=1;\n\trep1(i,M) f[i]=f[i-1]*i%mod;\n\tinv[1]=1;\n\tfor(int i=2;i<=M;i++) inv[i]=mod-mod/i*inv[mod%i]%mod;\n\tg[0]=1;\n\trep1(i,M) g[i]=g[i-1]*inv[i]%mod;\n}\nll C(int x,int y){\n\treturn f[x]*g[y]%mod*g[x-y]%mod;\n}\nvoid add(ll &x,ll y){\n\tx+=y;\n\tx%=mod;\n}\nint main(){\n\tprecalc();\n\tint N,K;\n\tcin>>N>>K;\n\tif(K==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tdp[1][0]=1;\n\trep1(i,N) rep(j,i+1){\n//\t\tprintf(\"dp[%d][%d]=%lld\\n\",i,j,dp[i][j]);\n\t\tif(i!=N) add(dp[i+1][j],dp[i][j]);\n\t\tif(j!=i){\n\t\t\tint left=N*K-i-j*(K-1)-1;\n\t\t\tadd(dp[i][j+1],dp[i][j]*C(left,K-2));\n\t\t}\n\t}\n\tll ans=dp[N][N];\n\trep1(i,N) ans=ans*i%mod;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//make_tuple emplace_back next_permutation push_back make_pair second first\n\n#if MYDEBUG\n#define DBG(...) {string dst__=#__VA_ARGS__;dbgsplit(dst__);stringstream dss__; dss__<<dst__; debug(dss__,__VA_ARGS__);}\n#else\n#define DBG(...)\n#endif\nvoid debug(stringstream& ds){cerr<<endl;return;}\ntemplate<typename F, typename... R>void debug(stringstream& ds,const F& f, const R&... r){string n; ds>>n; cerr<< n <<'='<<f<<' '; debug(ds,r...);}\nvoid dbgsplit(string &s){int l=s.length(),n=0;for(int i=0; i<l; ++i){if(s[i]=='(')++n;if(s[i]==')')--n;if(s[i]==','&&!n)s[i]=' ';}}\nusing LL = long long;\nconstexpr long long LINF=334ll<<53; constexpr int INF=15<<26; constexpr long long MOD=1E9+7;\n\nlong long modpow(long long a, long long n,long long mod=MOD){\n    long long i=1,ret=1,p=a;\n    while(i<=n){\n        if(i&n) ret=(ret*p)%mod;\n        i=(i<<1);\n        p=(p*p)%mod;\n    }\n    return ret;\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n\n    int n,k;\n    cin >> n >> k;\n    if(k==1){cout << 1 <<\"\\n\"; return 0;}\n\n    vector<vector<LL>> dp (n+1,vector<LL>(n+1));\n    vector<LL> fac(n*k+1),inv(n*k+1);\n    fac[0]=1;\n    for(int i=1; i<=n*k; ++i){\n         fac[i]=fac[i-1]*i%MOD;\n     }\n     inv[n*k]=modpow(fac[n*k],MOD-2);\n     for(int i=n*k-1; i>=0; --i){\n         inv[i]=inv[i+1]*(i+1)%MOD;\n     }\n     dp[0][0]=1;\n     for(int i=1; i<=n; ++i){\n        dp[i][0]=1;\n         for(int j=1; j<=i; ++j){\n             dp[i][j]=(dp[i-1][j]+((dp[i][j-1]*fac[n*k-i-(j-1)*(k-1)-1]%MOD)*inv[k-2]%MOD)*inv[n*k-i-(j-1)*(k-1)-k+1])%MOD;\n         }\n     }\n\n     cout <<dp[n][n]*fac[n]%MOD<<\"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cassert>\n#include<cmath>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<vector>\n#include<time.h>\n#include<algorithm>\nusing namespace std;\n#define REP(i,x,y) for(ll i=x;i<=y;i++)\n#define rep(i,n) REP(i,1,n)\n#define rep0(i,n) REP(i,0,n-1)\n#define repG(i,x) for(ll i=pos[x];~i;i=e[i].next)\n#define ll long long\n#define db double\nconst ll N=2007;\nconst ll mod=1e9+7;\nll Pow(ll x,ll y){\n\tll ans=1,now=x;\n\twhile(y){\n\t\tif(y&1)ans=ans*now%mod;\n\t\tnow=now*now%mod;\n\t\ty>>=1;\n\t}\n\treturn ans;\n}\nll f[N][N],fac[N*N],inv[N*N],s[N];\nll n,k;\nll C(ll x,ll y){return fac[x]*inv[y]%mod*inv[x-y]%mod;}\nint main(){\n\tscanf(\"%lld%lld\",&n,&k);\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\trep(i,n*k)fac[i]=fac[i-1]*i%mod;\n\tinv[n*k]=Pow(fac[n*k],mod-2);\n\tfor(ll i=n*k;i;i--)inv[i-1]=inv[i]*i%mod;\n\tf[0][0]=1;\n\trep0(i,n){\n\t\tfor(ll j=i;~j;j--)s[j]=(s[j+1]+f[i][j])%mod;\n\t\trep0(j,i+1)f[i+1][j+1]=s[j]*C(i*k-j+k-2,k-2)%mod;\n\t}\n\tfor(ll j=n;~j;j--)s[j]=(s[j+1]+f[n][j])%mod;\n\tprintf(\"%lld\\n\",s[0]*fac[n]%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int DIM = 2e3 + 5;\nconst int MOD = 1e9 + 7;\n\nint dp[DIM][DIM], fct[DIM * DIM], inv[DIM * DIM];\n\nint lgput( int x, int n ) {\n    if( n == 0 )\n        return 1;\n    \n    int y = lgput( x, n / 2 );\n    y = ( 1LL * y * y ) % MOD;\n    \n    if( n % 2 == 1 )\n        y = ( y * 1LL * x ) % MOD;\n    \n    return y;\n}\n\ninline int comb( int n, int k ) {\n    return ( ( ( 1LL * fct[n] * inv[k] ) % MOD ) * inv[n - k] ) % MOD;\n}\n\nint main( void ) {\n    \n    int n, k;\n    cin >> n >> k;\n    \n    if( k == 1 )\n        cout << \"1\\n\";\n    else {\n        fct[0] = inv[0] = 1;\n        for( int i = 1; i <= n * k; i ++ )\n            fct[i] = ( 1LL * fct[i - 1] * i ) % MOD;\n        \n        inv[n * k] = lgput( fct[n * k], MOD - 2 );\n        for( int i = n * k - 1; i >= 1; i -- )\n            inv[i] = ( 1LL * inv[i + 1] * (i + 1) ) % MOD;\n        \n        for( int i = 0; i <= n; i ++ ) {\n        for( int j = i; j <= n; j ++ ) {\n            if( i <= 1 && j <= 1 )\n                dp[i][j] = 1;\n            else {\n                if( i != 0 )\n                    dp[i][j] = dp[i - 1][j];\n                \n                if( i != j )\n                    dp[i][j] = ( dp[i][j] + ( 1LL * dp[i][j - 1] * comb( i + j * (k - 1) - 1, k - 2 ) ) % MOD ) % MOD;\n            }\n        } }\n\n        for( int i = 1; i <= n; i ++ )\n            dp[n][n] = ( 1LL * dp[n][n] * i ) % MOD;\n        cout << dp[n][n] << \"\\n\";\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define ll long long\n#define MAX 2010\n#define MOD 1000000007\nvoid add(int &x,int y){x+=y;if(x>=MOD)x-=MOD;}\ninline int read()\n{\n    int x=0;bool t=false;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n    if(ch=='-')t=true,ch=getchar();\n    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n    return t?-x:x;\n}\nint n,k,mx,f[MAX][MAX];\nint jc[MAX*MAX],jv[MAX*MAX],inv[MAX*MAX];\nint C(int n,int m){return 1ll*jc[n]*jv[m]%MOD*jv[n-m]%MOD;}\nint main()\n{\n    n=read();k=read();mx=n*k;\n    if(k==1){puts(\"1\");return 0;}\n    jc[0]=jv[0]=inv[0]=inv[1]=1;\n    for(int i=1;i<=mx;++i)jc[i]=1ll*jc[i-1]*i%MOD;\n    for(int i=2;i<=mx;++i)inv[i]=1ll*inv[MOD%i]*(MOD-MOD/i)%MOD;\n    for(int i=1;i<=mx;++i)jv[i]=1ll*jv[i-1]*inv[i]%MOD;\n    f[0][0]=1;\n    for(int i=1;i<=n;++i)\n        for(int j=0;j<=i;++j)\n        {\n            add(f[i][j],f[i-1][j]);\n            if(j)add(f[i][j],1ll*f[i][j-1]*(n-j+1)%MOD*C((n-i)+(n-j+1)*(k-1)-1,k-2)%MOD);\n        }\n    printf(\"%d\\n\",f[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region\n#ifndef M207\n#pragma GCC optimize(\"O2,Ofast,inline,unroll-all-loops,-ffast-math\")\n#pragma GCC target(\"avx,sse2,sse3,sse4,popcnt\")\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\n#define il inline\n#define LL long long\n#define uint unsigned int\n#define ull unsigned long long\n#define solid const auto &\n#define pb emplace_back\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define fi first\n#define se second\n#define gm int mid((l+r)/2)\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define rd() ({ri t;in(t);t;})\n#define Size(x) ((int)x.size())\n#define mem(x,y) memset(x,y,sizeof(x))\ntemplate<class T>il void in(T &x)\n{\n\tx=0; char c=getchar(); bool f=0;\n\twhile(!isdigit(c)) f|=(c=='-'),c=getchar();\n\twhile(isdigit(c)) x=x*10+(c^'0'),c=getchar();\n\tf?x=-x:0;\n}\ntemplate<class T>il void out(T x,const char c='\\n')\n{\n\tstatic short st[30]; short m=0;\n\tif(x<0) putchar('-'),x=-x;\n\tdo st[++m]=x%10,x/=10; while(x);\n\twhile(m) putchar(st[m--]|'0');\n\tputchar(c);\n}\ntemplate<class T>il void err(const T &x,const char c='\\n') {cerr<<x<<c;}\ntemplate<class T,class ...Args>il void in(T &x,Args &...args) {in(x); in(args...);}\ntemplate<class T,class ...Args>il void out(const T &x,const Args &...args) {out(x,' '); out(args...);}\ntemplate<class T,class ...Args>il void err(const T &x,const Args &...args) {err(x,' '); err(args...);}\ntemplate<class T>il void prt(T a[],int n) {for(ri i=0; i<n; ++i) out(a[i],i==n-1?'\\n':' ');}\ntemplate<class T>il void clr(T a[],int n) {memset(a,0,sizeof(T)*n);}\ntemplate<class T>il void clr(T *a,T *b) {memset(a,0,sizeof(T)*(b-a));}\ntemplate<class T>il bool ckmax(T &a,const T &b) {return a<b?a=b,1:0;}\ntemplate<class T>il bool ckmin(T &a,const T &b) {return a>b?a=b,1:0;}\nnamespace MOD_CALC\n{\nconst int md=1e9+7,inv2=(md+1)/2;\nil int add(const int a,const int b) {return a+b>=md?a+b-md:a+b;}\nil int sub(const int a,const int b) {return a-b<0?a-b+md:a-b;}\nil int mul(const int a,const int b) {return (LL)a*b%md;}\nil void inc(int &a,const int b) {(a+=b)>=md?a-=md:0;}\nil void dec(int &a,const int b) {(a-=b)<0?a+=md:0;}\nil int qpow(int a,int b) {int r=1; for(; b; b>>=1,a=mul(a,a)) if(b&1) r=mul(r,a); return r;}\nil int qpow(int a,int b,const int p) {int r=1; for(; b; b>>=1,a=(LL)a*a%p) if(b&1) r=(LL)r*a%p; return r;}\nil int mdinv(const int a) {return qpow(a,md-2);}\ntemplate<class ...Args>il int add(const int a,const int b,const Args &...args) {return add(add(a,b),args...);}\ntemplate<class ...Args>il int mul(const int a,const int b,const Args &...args) {return mul(mul(a,b),args...);}\n} using namespace MOD_CALC;\nnamespace i207M\n{\n#pragma endregion\n#define N 2000*2000+5\nint fac[N],ifac[N];\nil void init(int n)\n{\n\tfac[0]=1;\n\tfor(ri i=1; i<=n; ++i) fac[i]=mul(fac[i-1],i);\n\tifac[n]=mdinv(fac[n]);\n\tfor(ri i=n; i>=1; --i) ifac[i-1]=mul(ifac[i],i);\n}\nil int C(int n,int m) {return n<m?0:mul(fac[n],ifac[m],ifac[n-m]);}\nint n,K;\nint f[2005][2005];\nsigned main()\n{\n#ifdef M207\n\tfreopen(\"in.in\",\"r\",stdin);\n\t// freopen(\"ot.out\",\"w\",stdout);\n#endif\n\tin(n,K);\n\tif(K==1)\n\t{\n\t\tout(1);\n\t\treturn 0;\n\t}\n\tinit(n*K);\n\tfor(ri i=0; i<=n; ++i) f[0][i]=1;\n\tfor(ri i=1; i<=n; ++i)\n\t\tfor(ri j=i; j<=n; ++j)\n\t\t{\n\t\t\tf[i][j]=f[i][j-1];\n\t\t\tinc(f[i][j],mul(f[i-1][j],(n-i+1),C(n*K-j-(i-1)*(K-1)-1,K-2)));\n\t\t\t// out(i,j,f[i][j],n*K-j-(i-1)*(K-1)-1,K-2);\n\t\t}\n\tout(f[n][n]);\n\treturn 0;\n}\n#pragma region\n}\nsigned main()\n{\n\ti207M::main();\n\treturn 0;\n}\n#pragma endregion\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define mod 1000000007\n#define maxn 2005\nint n,k,fact[maxn*maxn],inv[maxn*maxn],dp[maxn][maxn];\nvoid init()\n{\n\tfact[0]=1;\n\tfor(int i=1;i<=n*k;i++) fact[i]=1ll*fact[i-1]*i%mod;\n\tinv[1]=1;\n\tfor(int i=2;i<=n*k;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\tinv[0]=1;\n\tfor(int i=1;i<=n*k;i++) inv[i]=1ll*inv[i-1]*inv[i]%mod;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1) { printf(\"1\\n\"); return 0; }\n\tinit();\n\tdp[0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tif(i) dp[i][j]=(dp[i][j]+dp[i-1][j])%mod;\n\t\t\tif(j)\n\t\t\t{\n\t\t\t\tint x=n*k-i-(j-1)*(k-1)-1;\n\t\t\t\tdp[i][j]=(dp[i][j]+1ll*dp[i][j-1]*fact[x]%mod*inv[k-2]%mod*inv[x-k+2]%mod)%mod;\n\t\t\t}\n\t\t}\n\tint ans=1ll*dp[n][n]*fact[n]%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst ll mod=1e9+7;\n#define N 2010\n\nint n,m;\nll dp[N][N],fac[N*N],inv[N*N];\n\nll power(ll x,ll y) {\n\tll ret=1;\n\tfor (;y;y>>=1,x=x*x%mod)\n\t\tif (y&1) ret=ret*x%mod;\n\treturn ret;\n}\n\nll C(ll x,ll y) {\n\tif (y>x) return 0;\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tif (m==1) return puts(\"1\"),0;\n\tfac[0]=1; for (int i=1;i<=n*m;i++) fac[i]=fac[i-1]*i%mod;\n\tinv[n*m]=power(fac[n*m],mod-2);\n\tfor (int i=n*m-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n\tdp[0][1]=1;\n\tfor (int i=2;i<=n;i++) dp[0][i]=dp[0][i-1]*C(i*(m-1)-1,m-2)%mod;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=i;j<=n;j++)\n\t\t\tdp[i][j]=(dp[i-1][j]+dp[i][j-1]*C(j*(m-1)+i-1,m-2)%mod)%mod;\n\tprintf(\"%lld\\n\",dp[n][n]*fac[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int MAXN = 2e3 + 10;\nconst int MOD = 1e9 + 7;\n \nlong long dp[MAXN][MAXN];\nlong long fac[MAXN * MAXN];\nint n, k;\n \n// asdjgfsadjkgfjksdgjfka\n// sadjkgfasjdgfjasdgfjgasdgfaskjdf\n// asdjgfajsdgfjasgdfgasdkjfgsadgfkjasdgfkjasdgfksadgf\n#define fsgdfjasgdfgsadkjfg asdkjgfkjsagdfsgadjfgasdkjfaksjdf\n#define hdgfhadfhasdhfgasjdgfjadgsjfkgsajdfgsadhjgfjksgadfj jsdgfjkasdgjfksgadkjfa\n#define hafsdhfashfh ashdfshgadfadsjhgfashgdfshgadfshadfjshgadfj\nint fsdgasdjkfjajksadgfkjags = 213213123;\nlong long fdashf = 13243543;\n\nlong long po(long long v, long long u)\n{\n\treturn u ? (po(v * v % MOD, u >> 1) * (u & 1 ? v : 1) % MOD) : 1;\n}\n \nlong long ente(int i, int j)\n{\n\tlong long res = po(fac[i], MOD - 2) * po(fac[j - i], MOD - 2);\n\tres %= MOD;\n\tres *= fac[j];\n\treturn res % MOD;\n}\n \nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcin >> n >> k;\n\tfac[0] = 1;\n\tfor (int i = 1; i < MAXN * MAXN; i++)\n\t\tfac[i] = (fac[i - 1] * i) % MOD;\n\tif (k == 1)\n\t\treturn cout << 1 << '\\n', 0;\n\tdp[0][0] = 1;\n\tfor (int i = 0; i <= n; i++)\n\t{\n\t\tfor (int j = i; j <= n; j++)\n\t\t{\n\t\t\tif (i)\n\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\tif (j)\n\t\t\t\tdp[i][j] += dp[i][j - 1] * ente(k - 2, i + j * (k - 1) - 1);\n\t\t\tdp[i][j] %= MOD;\n\t\t}\n\t}\n\tdp[n][n] = (dp[n][n] * fac[n]) % MOD;\n\tcout << dp[n][n] << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0, _n = (int)(n); i < _n; ++i)\n#define int long long\nconst int N = 2005, M = N * N, mod = (int) 1e9 + 7;\nint pw(int a, int b) { return b != 0? pw(a * a % mod, b >> 1) * (b & 1? a: 1) % mod: 1; }\nint ft[M], fi[M];\nint dp[N][N];\n\nint comb(int n, int r) {\n    if (r < 0 || n < 0 || n - r < 0) return 0;\n    return ft[n] * fi[r] % mod * fi[n - r] % mod;\n}\nvoid sadd(int &x, int y) {\n    x += y;\n    x %= mod;\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    ft[0] = fi[0] = 1;\n    for (int i = 1; i < M; ++i)\n        ft[i] = ft[i - 1] * i % mod;\n    fi[M - 1] = pw(ft[M - 1], mod - 2);\n    for (int i = M - 2; i >= 0; --i)\n        fi[i] = fi[i + 1] * (i + 1) % mod;\n    int n, k;\n    cin >> n >> k;\n    if (k == 1) {\n        cout << 1 << endl;\n        return 0;\n    }\n    /*\n    if (k == 2) {\n        cout << (mod + comb(n + n, n) - comb(n + n, n + 1)) % mod;\n        return 0;\n    } */\n    dp[0][0] = 1;\n    for (int p1 = 0; p1 <= n; ++p1)\n        for (int p0 = 0; p0 <= p1; ++p0) {\n            if (p1) {\n                int g = p0 * k + (p1 - p0 - 1) * (k - 1);\n                sadd(dp[p1][p0], dp[p1 - 1][p0] * comb(g + 1 + k - 2 - 1, g) % mod);\n            }\n            if (p0) {\n                sadd(dp[p1][p0], dp[p1][p0 - 1]);\n            }\n        }\n    cout << dp[n][n] * ft[n] % mod << endl;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\nconst int N=2005;\nconst int MOD=1e9+7;\n\nint n,k,f[N][N],fac[N*N],inv[N*N];\n\ninline int fast_pow(int x,int y){\n\tint ret=1;\n\tfor(;y;y>>=1){\n\t\tif(y&1) ret=(LL)ret*x%MOD;\n\t\tx=(LL)x*x%MOD;\n\t}\t\n\treturn ret;\n}\n\ninline int C(int x,int y){\n\treturn 1ll*fac[x]*inv[y]%MOD*inv[x-y]%MOD;\t\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&k); if(k==1) {puts(\"1\"); return 0;}\n\tf[0][0]=1; fac[0]=1;\n\tfor(int i=1;i<=n*k;i++) fac[i]=1ll*fac[i-1]*i%MOD;\n\tinv[n*k]=fast_pow(fac[n*k],MOD-2);\n\tfor(int i=n*k-1;~i;i--) inv[i]=1ll*inv[i+1]*(i+1)%MOD;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(j!=i) f[i][j]=1ll*f[i-1][j]*(n-i+1)%MOD;\n\t\t\tif(j!=0) (f[i][j]+=1ll*f[i][j-1]*C(n*k-(i+(j-1)*(k-1))-1,k-2)%MOD)%=MOD;\n\t\t}\n\tprintf(\"%d\\n\",f[n][n]);\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n#define MAXN 2005\n#define INF 0x3f3f3f3f\n#define p 1000000007\n#define rint register int\n#define LL long long\n#define LD long double\nusing namespace std;\n\nint n, k, f[MAXN][MAXN], inv[MAXN*MAXN], fac[MAXN*MAXN];\n\nvoid init()\n{\n    inv[0]=inv[1]=fac[0]=fac[1]=1;\n    for(rint i=2; i<=n*k; ++i) inv[i]=1LL*inv[p%i]*(p-p/i)%p;\n    for(rint i=2; i<=n*k; ++i)\n    {\n        inv[i]=1LL*inv[i]*inv[i-1]%p;\n        fac[i]=1LL*fac[i-1]*i%p;\n    }\n}\n\nint comb(int x, int y)\n{\n    return 1LL*fac[x]*inv[y]%p*inv[x-y]%p;\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &k);\n    init();\n    f[0][0]=1;\n    if(k==1) {printf(\"1\\n\"); return 0;}\n    for(rint i=1; i<=n; ++i)\n        for(rint j=0; j<=i; ++j)\n        {\n            f[i][j]=(f[i][j]+f[i-1][j])%p;\n            if(j)\n            {\n                int temp=n-i+(n-j+1)*(k-1)-1;\n                f[i][j]=(f[i][j]+1LL*f[i][j-1]*(n-j+1)%p*comb(temp, k-2)%p)%p;\n            }\n        }\n    printf(\"%d\\n\", f[n][n]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define inf(x) (ll)(1e##x)\nusing namespace std;\nconst int mod = 1e9+7;\nint n,k,f[2010][2010];\nll inv[4001000],fac[4001000],ifac[4001000];\nll C(int n,int m){return fac[n]*ifac[m]%mod*ifac[n-m]%mod;}\nvoid upd(int &a,ll b){a=(a+b)%mod;}\nint main(){\n\tcin>>n>>k;\n\tif(k==1){cout<<1<<'\\n';return 0;}\n\tf[0][0]=1;\n\tinv[1]=1;\n\tfor(int i=2;i<=4000000;i++) inv[i]=inv[mod%i]*-(mod/i)%mod;\n\tfac[0]=ifac[0]=1;\n\tfor(int i=1;i<=4000000;i++) fac[i]=fac[i-1]*i%mod,ifac[i]=ifac[i-1]*inv[i]%mod;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tupd(f[i+1][j],f[i][j]);\n\t\t\tif(i>j) upd(f[i][j+1],f[i][j]*C((n-i)+(n-j)*(k-1)-1,k-2));\n\t\t}\n\tll ans=f[n][n]*fac[n]%mod;\n\tcout<<(ans+mod)%mod<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define N 4000005\n#define MOD 1000000007\nusing namespace std;\nint n,k,f[2005][2005],inv[N],fac[N];\nint C(int x,int y){\n\treturn x>=y?fac[x]*inv[y]%MOD*inv[x-y]%MOD:0;\n}\nsigned main(){\n\tcin>>n>>k;\n\tif(k==1){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tfac[0]=inv[0]=inv[1]=1;//first deal\n\tfor(int i=1;i<=n*k;i++)\n\t\tfac[i]=fac[i-1]*i%MOD;\n\tfor(int i=2;i<=n*k;i++)\n\t\tinv[i]=inv[MOD%i]*(MOD-MOD/i)%MOD;\n\tfor(int i=1;i<=n*k;i++)\n\t\tinv[i]=inv[i-1]%MOD*inv[i]%MOD;\n\tfor(int i=0;i<=n;i++)\n\t\tf[i][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=k&&j<=i;j++){\n//\t\t\tcout<<i<<\" \"<<j<<\"*\"<<\"%\"<<C(k-2,(n-i)+(n-j+1)*(k-1)-1)<<endl;\n\t\t\tf[i][j]=(f[i-1][j]+C((n-i)+(n-j+1)*(k-1)-1,k-2)*f[i][j-1]%MOD*(n-j+1)%MOD)%MOD;\n//\t\t\tcout<<f[1][1]<<endl;\n\t\t}\n\t}\n\tcout<<f[n][n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 262144\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\n\n#define ll long long\nll mo = 1000000007;\nll combi(ll N_, ll C_) {\n\tconst int NUM_ = 4500001;\n\tstatic ll fact[NUM_ + 1], factr[NUM_ + 1], inv[NUM_ + 1];\n\tif (fact[0] == 0) {\n\t\tinv[1] = fact[0] = factr[0] = 1;\n\t\tfor (int i = 2; i <= NUM_; ++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\t\tfor (int i = 1; i <= NUM_; ++i) fact[i] = fact[i - 1] * i % mo, factr[i] = factr[i - 1] * inv[i] % mo;\n\t}\n\tif (C_<0 || C_>N_) return 0;\n\treturn factr[C_] * fact[N_] % mo * factr[N_ - C_] % mo;\n}\n\nlong long dp[3000][3000];\nlong long omote[2000*2001];\nlong long inv[2000 * 2001];\nlong long n, k;\nlong long combination(long long a, long long b) {\n\tif (a < b) return 0;\n\tlong long ans = omote[a];\n\tans *= inv[b];\n\tans %= MAX_MOD;\n\tans *= inv[a - b];\n\tans %= MAX_MOD;\n\treturn ans;\n}\nint main() {\n\tomote[0] = 1;\n\tinv[0] = 1;\n\tomote[1] = 1;\n\tinv[1] = 1;\n\tfor (long long i = 2; i <= 2000 * 2000; ++i) {\n\t\tomote[i] = omote[i - 1] * i;\n\t\tomote[i] %= MAX_MOD;\n\t\tinv[i] = inv[MAX_MOD % i] * (MAX_MOD - MAX_MOD / i) % MAX_MOD;\n\t}\n\tfor (long long i = 2; i <= 2000 * 2000; ++i) {\n\t\tinv[i] *= inv[i - 1];\n\t\tinv[i] %= MAX_MOD;\n\t}\n\tcin >> n >> k;\n\tif (k == 1) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tdp[0][1] = 1;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tlong long go = combination(i * (k - 1) - 1, k - 2);\n\t\tdp[0][i] = dp[0][i - 1] * go % MAX_MOD;\n\t}\n\tfor (int x = 1; x <= n; x++) {\n\t\tif (x == 1) dp[1][1] = 1;\n\t\telse dp[x][x] = dp[x - 1][x];\n\t\tfor (int y = x + 1; y <= n; ++y) {\n\t\t\tlong long go = combination(x + y * (k - 1) - 1, k - 2);\n\t\t\tdp[x][y] = (dp[x - 1][y] + dp[x][y - 1] * go) % MAX_MOD;\n\t\t}\n\t}\n\tlong long ans = dp[n][n] * omote[n]%MAX_MOD;\n\tcout << ans%MAX_MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2050\n#define mod 1000000007\nusing namespace std;\ntypedef long long LL;\nconst int tp = 4000000;\n\nint n,k;\nLL F[N][N],jc[N*N],inv[N*N],invjc[N*N];\ninline int rd() {int r;scanf(\"%d\",&r);return r;}\n\ninline LL C(int x,int y) {\n\tif (x < y) return 0;\n\treturn 1LL * jc[x] * invjc[y] % mod * invjc[x-y] % mod;\n}\n\ninline void inc(LL &x, LL y) {x=(x+y)%mod;}\n\nint main() {\n\tn = rd(), k = rd();\n\t\n\tjc[0] = jc[1] = 1LL;\n\tfor (int i=2;i<=tp;i++) jc[i] = 1LL * jc[i-1] * i % mod;\n\t\n\tinv[0] = inv[1] = 1LL;\n\tfor (int i=2;i<=tp;i++) inv[i] = 1LL * (mod-mod/i) * inv[mod % i] % mod;\n\t\n\tinvjc[0] = invjc[1] = 1LL;\n\tfor (int i=2;i<=tp;i++) invjc[i] = 1LL * invjc[i-1] * inv[i] % mod;\n\n\tF[0][1] = 1LL;\t\n\tfor(int i=2;i<=n;i++)\n\t\tF[0][i] = 1LL * F[0][i-1]*C(i*(k-1)-1, k-2) % mod;\n\t\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=i;j<=n;j++) {\n\t\t\tif (i-1 >= 0) inc(F[i][j], F[i-1][j]);\n\t\t\tif (j-1 >= 0) inc(F[i][j], 1LL * C(i+j*(k-1)-1, k-2) * F[i][j-1] % mod);\n\t\t}\n\tLL ans = 1LL * F[n][n] * jc[n] % mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n\nusing namespace std;\n\nconst int Max_N(2050);\nconst int Max_V(2000 * 2000);\nconst int MOD(1000000000 + 7);\ntypedef long long int LL;\n\ninline void update(int &a, const int &b)\n{\n\t((a += b) >= MOD) ? (a -= MOD) : 0;\n}\n\ninline int Mult(const int &a, const int &b)\n{\n\treturn static_cast<int>(static_cast<LL>(a) * static_cast<LL>(b) % static_cast<LL>(MOD));\n}\n\nint N, K, F[Max_N][Max_N], Fac[Max_V + 5], Inv[Max_V + 5];\n//每个颜色相当于放一个0然后在后面放K - 1个某种颜色 \n//F[i][j]表示放了i个0，确定了j个某种颜色剩下K - 1个位置的方案数\n//转移枚举当前位置放一个0，还是增加某种颜色的K - 1个位置（当前位置必须是这种颜色） \n\nvoid exgcd(const int &a, const int &b, int &x, int &y)\n{\n\tif (b == 0)\n\t\tx = 1, y = 0;\n\telse\n\t\texgcd(b, a % b, y, x), y -= x * (a / b);\n}\n\ninline int inverse(const int &a)\n{\n\tint invx, invy;\n\texgcd(a, MOD, invx, invy);\n\treturn (invx % MOD + MOD) % MOD;\n}\n\ninline int C(const int &n, const int &m)\n{\n\treturn Mult(Mult(Fac[n], Inv[n - m]), Inv[m]);\n}\n\nint main()\n{\n\tFac[0] = 1;\n\tfor (int i = 1;i <= Max_V;++i)\n\t\tFac[i] = Mult(Fac[i - 1], i);\n\tInv[Max_V] = inverse(Fac[Max_V]);\n\tfor (int i = Max_V - 1;i >= 0;--i)\n\t\tInv[i] = Mult(Inv[i + 1], i + 1);\n\tscanf(\"%d%d\", &N, &K);\n\tif (K == 1)\n\t{\n\t\tprintf(\"1\");\n\t\treturn 0;\n\t}\n\tF[1][0] = 1;\n\tfor (int i = 1;i <= N;++i)\n\t\tfor (int j = 0;j <= i;++j)\n\t\t{\n\t\t\tupdate(F[i + 1][j], F[i][j]);\n\t\t\tif (j + 1 <= i)\n\t\t\t\tupdate(F[i][j + 1], Mult(Mult(F[i][j], N - j), C((N - i) + (N - j) * (K - 1) - 1, K - 2)));\n\t\t}\n\tprintf(\"%d\", F[N][N]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if (v+o.v >= N) v += o.v - N; else v += o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v -= o.v-N; else v-=o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\ttemplate <typename T>\n\tstatic T div(T p, T q, T N) {\n\t\tT t=0,nt=1,r=N,nr=q;\n\t\twhile(nr!=0){ T q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r!=0) { return 0; }\n\t\treturn (t*p/r)%N;\n\t}\n};\n#endif\n\n\nclass FLeftmostBall {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N, K; cin >> N >> K;\n        if (K == 1) {\n            cout << 1 << endl;\n            return;\n        }\n\n        auto F = FieldMod::fact(N*K);\n        auto I = FieldMod::invfact(N*K);\n\n        vector2<FieldMod> A(N+1, N+1, 0);\n        A[0][0] = 1;\n        for (int i = 0; i <= N; ++i) {\n            for (int j = 0; j <= i; ++j) {\n                if (i != N) {\n                    A[i+1][j] += A[i][j];\n                }\n\n                if (i != j) {\n                    int k = (N - (j+1)) * (K-1) + (N - i);\n                    A[i][j+1] += A[i][j] * F[k + K - 2] * I[k];\n                }\n            }\n        }\n        cout << A[N][N] * F[N] * I[K-2].pow(N) << endl;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tFLeftmostBall solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#define file(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout);\nusing namespace std;\nconst int MAXN = 2005;\nconst int MOD = 1e9 + 7;\nint n, K;\nint jc[MAXN * MAXN] = {1}, inv[MAXN * MAXN];\nint f[MAXN][MAXN];\n\nint quick_pow(int a, int x) {\n    int res = 1;\n    while (x) {\n        if (x & 1)\n            res = 1ll * res * a % MOD;\n        a = 1ll * a * a % MOD, x >>= 1;\n    }\n    return res;\n}\n\nint calc_C(int n, int r) {\n    if (n < r)\n        return 0;\n    return 1ll * jc[n] * inv[r] % MOD * inv[n - r] % MOD;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &K);\n    if (K == 1) {\n        printf(\"1\");\n        return 0;\n    }\n    for (int i = 1; i <= n * (n + 1); i++)\n        jc[i] = 1ll * jc[i - 1] * i % MOD;\n    inv[n * (n + 1)] = quick_pow(jc[n * (n + 1)], MOD - 2);\n    for (int i = n * (n + 1); i; i--)\n        inv[i - 1] = 1ll * i * inv[i] % MOD;\n    f[0][0] = 1;\n    for (int i = 0; i <= n; i++)\n        for (int j = i; j <= n; j++) {\n            if (i != j)\n                f[i + 1][j] = (f[i + 1][j] + f[i][j]) % MOD;\n            f[i][j + 1] = (f[i][j + 1] + 1ll * f[i][j] * calc_C((j + 1) * (K - 1) + i - 1, K - 2) % MOD) % MOD;\n        }\n    printf(\"%lld\", 1ll * f[n][n] * jc[n] % MOD);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define Mx 4000000\nusing namespace std;\nconst int p=1e9+7;\nint n,k;\nint f[2010][2010],a[4000010],i_a[4000010];\nint calc(int x,int y){ return (((a[y]*i_a[x])%p)*i_a[y-x])%p; }\nint power(int x,int y)\n{\n    int s1=1,s2=x;\n    while(y)\n\t{\n        if(y%2)s1*=s2,s1%=p;\n        s2*=s2;\n        s2%=p;\n        y/=2;\n    }\n    return s1;\n}\nsigned main()\n{\n    cin>>n>>k;\n    if(k==1)\n\t{\n\t\tcout<<1;\n\t\treturn 0;\n\t}\n    a[0]=1; \n\tfor(int i=1;i<=Mx;i++)a[i]=(a[i-1]*i)%p;\n    i_a[Mx]=power(a[Mx],p-2); \n\tfor(int i=Mx-1;i>=0;i--)i_a[i]=(i_a[i+1]*(i+1))%p;\n    f[0][0]=1;\n    for(int i=1;i<=n;i++)\n\t  for(int j=0;j<=i;j++)\n\t  {\n          f[i][j]=f[i-1][j];\n          if(j)f[i][j]+=(f[i][j-1]*(n-j+1)%p*calc(k-2,n-i+(n-j+1)*(k-1)-1)%p)%p;\n      }\n    cout<<f[n][n];\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define mod 1000000007\n#define maxn 2003\nusing namespace std;\nint fac[maxn * maxn], inv[maxn * maxn], f[maxn][maxn];\nint fpw(int x, int y){\n    int ans = 1;\n    for (int i = 1; i <= y; i <<= 1, x = 1LL * x * x % mod)\n        if (y & i)\n            ans = 1LL * ans * x % mod;\n    return ans;\n}\nint C(int n, int m){\n    return 1LL * fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\nint main(){\n    int n, k;\n    cin >> n >> k;\n    if (k == 1){\n        cout << 1 << endl;\n        return 0;\n    }\n    fac[0] = 1;\n    for (int i = 1; i <= n * k; ++ i)\n        fac[i] = 1LL * fac[i - 1] * i % mod;\n    inv[n * k] = fpw(fac[n * k], mod - 2);\n    for (int i = n * k - 1; i >= 0; -- i)\n        inv[i] = 1LL * inv[i + 1] * (i + 1) % mod;\n    f[0][0] = 1;\n    for (int i = 1; i <= n; ++ i)\n        for (int j = 0; j <= i; ++ j){\n            f[i][j] = f[i - 1][j];\n            if (j)\n                f[i][j] = (f[i][j] + 1LL * f[i][j - 1] * C(n * k - (j - 1) * (k - 1) - i - 1, k - 2) % mod * (n - j + 1)) % mod;\n        }\n    cout << f[n][n] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=2010,N2=N*N,mod=1000000007;\ntypedef long long ll;\nint ksm(ll a,int b,int c=1){\n\tfor(;b;b/=2,a=a*a%mod)\n\t\tif(b&1)c=c*a%mod;\n\treturn c;\n}\n\nint jc[N2],jc2[N2],n,K,f[N][N];\n\nint C(int n,int k){\n\tif(k<0||n<k)return 0;\n\treturn (ll)jc[n]*jc2[k]%mod*jc2[n-k]%mod;\n}\n\nvoid Init(){\n\tjc[0]=1;\n\tfor(int i=1;i<N2;++i)jc[i]=(ll)jc[i-1]*i%mod;\n\tjc2[N2-1]=ksm(jc[N2-1],mod-2);\n\tfor(int i=N2-1;i;--i)jc2[i-1]=(ll)jc2[i]*i%mod;\n}\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n>>K;Init();--K;\n\tif(!K){\n\t\tcout<<1<<'\\n';\n\t\treturn 0;\n\t}\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<=i;++j)f[i][j]=(f[i-1][j]+(ll)f[i][j-1]*C((n-j+1)*K+n-i-1,K-1))%mod;\n\tcout<<(ll)f[n][n]*jc[n]%mod<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst long long MOD = (long long)(1e9 + 7);\nconst int kK = (int)(2049 * 2049);\n\nlong long fac[kK + 5], inv[kK + 5];\n\nlong long qpow(long long base,int power)\n{\n\tlong long ret = 1;\n\tfor(; power; power >>= 1)\n\t{\n\t\tif(power & 1) ret = ret * base % MOD;\n\t\tbase = base * base % MOD;\n\t}\n\treturn ret;\n}\n\ninline long long C(int x, int y)\n{\n\treturn(((fac[y] * inv[x]) % MOD) * inv[y - x]) % MOD;\n}\n\nint n, k;\nlong long f[2049][2049];\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin >> n >> k;\n\tif(k == 1)\n\t{\n\t\tcout << 1 <<endl;\n\t\treturn 0;\n\t}\n\tfac[0] = 1;\n\tfor(int i = 1; i <= kK; ++i) fac[i] = fac[i-1] * i % MOD;\n\tinv[kK] = qpow(fac[kK], MOD - 2);\n\tfor(int i = kK; i >= 1; --i) inv[i - 1] = inv[i] * i % MOD;\n\tf[0][0] = 1;\n\tfor(int i = 1;i <= n; ++i)\n\t{\n\t\tf[i][0] = f[i - 1][0];\n\t\tfor(int j = 1; j <= i; ++j)\n\t\t{\n\t\t\tf[i][j] = f[i - 1][j];\n\t\t\tf[i][j] = f[i][j] + f[i][j - 1] * C(k - 2, n * k - i - (j - 1)*(k - 1) - 1);\n\t\t\tf[i][j] %= MOD;\n\t\t}\n\t}\n\tcout << fac[n] * f[n][n] % MOD<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\ntypedef long long ll;\ninline ll rd(){\n    ll x=0,p=1;\n    char a=getchar();\n    while((a<48||a>57)&&a!='-')a=getchar();\n    if(a=='-')p=-p,a=getchar();\n    while(a>47&&a<58)x=(x<<1)+(x<<3)+(a&15),a=getchar();\n    return x*p;\n}\nconst int N=2002;\nconst ll mod=1e9+7;\ninline ll fpow(ll b,ll p,ll mod){\n\tll ans=1,tmp=b;\n\twhile(p){\n\t\tif(p&1)ans=ans*tmp%mod;\n\t\ttmp=tmp*tmp%mod;\n\t\tp>>=1;\n\t}\n\treturn ans;\n}\nint n,k;\nll fac[N*N],inv[N*N],f[N][N];\ninline ll C(int n,int m){\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main(){\n\tfac[0]=1;\n\tn=rd(),k=rd();\n\tif(k==1)return puts(\"1\"),0;\n\tfor(int i=1;i<=4000000;i++)fac[i]=fac[i-1]*i%mod;\n\tf[0][0]=1;\n\tinv[4000000]=fpow(fac[4000000],mod-2,mod);\n\tfor(int i=3999999;i>=0;i--)inv[i]=(inv[i+1]*(i+1))%mod;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(j)f[i][j]=(f[i][j]+f[i][j-1]*(n-j+1)%mod*C(n-i+(n-j+1)*(k-1)-1,k-2)%mod)%mod;\n\t\t}\n\tprintf(\"%lld\\n\",f[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?(c=getchar()):0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\nconst int N=2010,O=1000000007;\ninline int fpow(lint x,int n){\n\tint a=1;\n\tfor(;n;n>>=1,x=x*x%O){\n\t\tif(n&1){\n\t\t\ta=a*x%O;\n\t\t}\n\t}\n\treturn a;\n}\ninline int inv(int x){\n\treturn fpow(x,O-2);\n}\nint fac[N*N],invfac[N*N];\ninline void gmath(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfac[i]=(lint)fac[i-1]*i%O;\n\t}\n\tinvfac[n]=inv(fac[n]);\n\tfor(int i=n;i>=1;i--){\n\t\tinvfac[i-1]=(lint)invfac[i]*i%O;\n\t}\n}\ninline int C(int n,int m){\n\tif(n<m){\n\t\treturn 0;\n\t}\n\treturn (lint)fac[n]*invfac[m]%O*invfac[n-m]%O;\n}\nlint f[N];\nint main(){\n\tint n=ni,k=ni;\n\tif(k<=1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tgmath(n*k);\n\tmemset(f,0,sizeof(f));\n\tf[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i;j>=0;j--){\n\t\t\tf[j]=f[j+1];\n\t\t\tif(j){\n\t\t\t\t(f[j]+=(lint)f[j-1]*C((i-1)*(k-1)+(i-j)+(k-2),k-2)%O*(n-i+1))%=O;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\ntemplate<unsigned P> struct ModInt {\n  using M = ModInt;\n  unsigned v;\n  ModInt() : v(0) {}\n  template<class Z> ModInt(Z x) : v(x >= 0 ? x % P : (P - -x % P) % P) {}\n  constexpr ModInt(unsigned v, int) : v(v) {}\n  static constexpr unsigned p() { return P; }\n  M operator+() const { return *this; }\n  M operator-() const { return {v ? P - v : 0, 0}; }\n  explicit operator bool() const noexcept { return v; }\n  bool operator!() const noexcept { return !(bool) *this; }\n  M operator*(M r) const { return M(*this) *= r; }\n  M operator/(M r) const { return M(*this) /= r; }\n  M operator+(M r) const { return M(*this) += r; }\n  M operator-(M r) const { return M(*this) -= r; }\n  bool operator==(M r) const { return v == r.v; }\n  bool operator!=(M r) const { return !(*this == r); }\n  M& operator*=(M r) { v = (uint64_t) v * r.v % P; return *this; }\n  M& operator/=(M r) { return *this *= r.inv(); }\n  M& operator+=(M r) { if ((v += r.v) >= P) v -= P; return *this; }\n  M& operator-=(M r) { if ((v += P - r.v) >= P) v -= P; return *this; }\n  M inv() const {\n    int a = v, b = P, x = 1, u = 0;\n    while (b) {\n      int q = a / b;\n      swap(a -= q * b, b);\n      swap(x -= q * u, u);\n    }\n    assert(a == 1);\n    return x;\n  }\n  template<class Z> M pow(Z n) const {\n    if (n < 0) return pow(-n).inv();\n    M res = 1;\n    for (M a = *this; n; a *= a, n >>= 1) if (n & 1) res *= a;\n    return res;\n  }\n  template<class Z> friend M operator*(Z l, M r) { return M(l) *= r; }\n  template<class Z> friend M operator/(Z l, M r) { return M(l) /= r; }\n  template<class Z> friend M operator+(Z l, M r) { return M(l) += r; }\n  template<class Z> friend M operator-(Z l, M r) { return M(l) -= r; }\n  friend ostream& operator<<(ostream& os, M r) { return os << r.v; }\n  friend istream& operator>>(istream& is, M& r) { lint x; is >> x; r = x; return is; }\n  template<class Z> friend bool operator==(Z l, M r) { return M(l) == r; }\n  template<class Z> friend bool operator!=(Z l, M r) { return !(l == r); }\n};\nusing Mint = ModInt<(unsigned)(1e9 + 7)>;\n\nV<Mint> fact, ifact, inv, powB;\nvoid init(int n, int B = 2) {\n  fact.resize(n + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    fact[i] = i * fact[i - 1];\n  }\n  ifact.resize(n + 1);\n  ifact[n] = fact[n].inv();\n  for (int i = n; i > 0; --i) {\n    ifact[i - 1] = i * ifact[i];\n  }\n  inv.resize(n + 1);\n  inv[1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    int q = Mint::p() / i;\n    inv[i] = -q * inv[Mint::p() - i * q];\n  }\n  powB.resize(n + 1);\n  powB[0] = 1;\n  for (int i = 0; i < n; ++i) {\n    powB[i + 1] = powB[i] * B;\n  }\n}\nMint comb(int n, int r) {\n  if (r < 0 or r > n) return 0;\n  return fact[n] * ifact[r] * ifact[n - r];\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n, k; cin >> n >> k;\n  /*{\n    V<> a;\n    for (int i = 1; i <= n; ++i) {\n      for (int _ = 0; _ < k; ++_) a.push_back(i);\n    }\n    set< V<> > se;\n    do {\n      auto b = a;\n      for (int i = 1; i <= n; ++i) {\n        for (auto&& e : b) if (e == i) {\n          e = 0;\n          break;\n        }\n      }\n      se.insert(b);\n    } while (next_permutation(begin(a), end(a)));\n    cerr << se.size() << '\\n';\n  }*/\n\n  {\n    init(n * k);\n    V<> a(2 * n);\n    fill(begin(a) + n, end(a), 1);\n    Mint res;\n    do {\n      int t = 0;\n      bool ok = true;\n      for (int e : a) {\n        if (!e) ++t;\n        else --t;\n        if (t < 0) ok = false;\n      }\n      if (!ok) continue;\n      V<> x;\n      for (int i = 0; i < 2 * n; ++i) if (!a[i]) {\n        x.push_back(i);\n      }\n      Mint curr = 1;\n      for (int i = 0; i < n; ++i) {\n        curr *= comb(x[i] + (i + 1) * (k - 2), k - 2);\n      }\n      res += curr;\n    } while (next_permutation(begin(a), end(a)));\n    res *= fact[n];\n    cout << res << '\\n';\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,k;\nll dp[2005][2005];\nll modpow(ll x,ll n){\n\tll res=1;\n\twhile(n>0){\n\t\tif(n&1) res=res*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nll F[4000005],R[4000005];\nvoid make(){\n\tF[0] = 1;\n\tfor(int i=1;i<4000005;i++) F[i] = F[i-1]*i%mod;\n\tR[4000000] = modpow(F[4000000],mod-2);\n\tfor(int i=4000000;i>=1;i--) R[i-1] = R[i]*1LL*i%mod;\n}\nll C(int a,int b){\n\treturn F[a]*R[b]%mod*R[a-b]%mod;\n}\nint main(){\n\tcin>>n>>k; if(k==1){puts(\"1\");return 0;} make();\n\tdp[0][0] = 1;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tif(dp[i][j] == 0) continue;\n\t\t\tif(i!=n) dp[i+1][j] = (dp[i+1][j]+dp[i][j])%mod;\n\t\t\tif(i>=j+1) dp[i][j+1] = (dp[i][j+1]+dp[i][j]*C(n*k-j*(k-1)-i-1,k-2)%mod)%mod;\n\t\t}\n\t}\n\tcout<<dp[n][n]*F[n]%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\nconst long long mod = 1000000007;\n\nlong long fact[4000400];\nlong long ifact[4000400];\nlong long invs[4000400];\n\nconst int MA = 4000300;\n\nvoid init(){\n\t//factorial\n\tinvs[1] = 1;\n\tfor(int i = 2; i < MA; ++i){\n\t\tlong long k = mod / i;\n\t\tlong long l = mod % i;\n\t\tlong long tmp = -k * invs[l];\n\t\ttmp %= mod;\n\t\tif(tmp < 0) tmp += mod;\n\t\tinvs[i] = tmp;\n\t}\n\t\n\tfact[0] = 1;\n\tifact[0] = 1;\n\tfor(int i = 1; i < MA; ++i){\n\t\tfact[i] = (fact[i - 1] * i) % mod;\n\t\tifact[i] = (ifact[i - 1] * invs[i]) % mod;\n\t}\n}\n\nlong long C(int n, int k){\n\tif(k < 0 || k > n) return 0;\n\tlong long res = fact[n];\n\tres *= ifact[k];\n\tres %= mod;\n\tres *= ifact[n - k];\n\tres %= mod;\n\treturn res;\n}\n\nint N, K;\n\nlong long dp[2020][2020];\nlong long sum[2020][2020];\n\nlong long solve(){\n\tif(K == 1) return 1;\n\tfor(int i = 0; i <= N; ++i){\n\t\tfor(int j = 0; j <= N; ++j){\n\t\t\tdp[i][j] = 0;\n\t\t\tsum[i][j] = 0;\n\t\t}\n\t}\n\tdp[N][1] = 1;\n\tsum[N][1] = 1;\n\tsum[N][0] = 1;\n\tfor(int i = N - 1; i >= 1; --i){\n\t\tfor(int j = 1; j <= N; ++j){\n\t\t\tint d = N - i;\n\t\t\tif(j > d + 1){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint num = d * K - (j - 1);\n\t\t\tint cur = K - 1;\n\t\t\tlong long coe = C(num + cur - 1, cur - 1);\n\t\t\tdp[i][j] += dp[i + 1][j - 1] * coe;\n\t\t\tdp[i][j] %= mod;\n\t\t\t\n\t\t\tcoe = C(num + cur - 1, cur - 1);\n\t\t\tdp[i][j] += sum[i + 1][j] * coe;\n\t\t\tdp[i][j] %= mod;\n\t\t}\n\t\tsum[i][N] = dp[i][N];\n\t\tfor(int j = N - 1; j >= 0; --j){\n\t\t\tsum[i][j] = (sum[i][j + 1] + dp[i][j]) % mod;\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor(int i = 0; i <= N; ++i){\n\t\tans += dp[1][i];\n\t\tans %= mod;\n\t}\n\tans *= fact[N];\n\tans %= mod;\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d%d\", &N, &K);\n\tinit();\n\tlong long ans = solve();\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N=2010,mo=int(1e9+7);\nint n,k,f[N][N],fac[N*N],ifac[N*N];\n\nint qpow(int a,int b)\n{\n\tint x=a;  a=1;\n\twhile (b)\n\t\t{\n\t\t\tif (b&1)  a=1LL*a*x%mo;\n\t\t\tx=1LL*x*x%mo,b>>=1;\n\t\t}\n\treturn a;\n}\n\nint C(int n,int m){return 1LL*fac[n]*ifac[m]%mo*ifac[n-m]%mo;}\n\nvoid work()\n{\n\tscanf(\"%d %d\",&n,&k);\n\tif (k==1)  puts(\"1\"),exit(0);\n\tfac[0]=1;\n\tfor (int i=1; i<=n*k; i++)  fac[i]=1LL*fac[i-1]*i%mo;\n\tifac[n*k]=qpow(fac[n*k],mo-2);\n\tfor (int i=n*k; i; i--)  ifac[i-1]=1LL*ifac[i]*i%mo;\n\tf[0][0]=1;\n\tfor (int i=0; i<=n; i++)\n\t\tfor (int j=i; j<=n; j++)\n\t\t\t{\n\t\t\t\tif (i<j)  (f[i+1][j]+=f[i][j])%=mo;\n\t\t\t\tif (j<n)  f[i][j+1]=(f[i][j+1]+1LL*f[i][j]*C(i-1+(k-1)*(j+1),k-2))%mo;\n\t\t\t}\n\tprintf(\"%d\",int(1LL*f[n][n]*fac[n]%mo));\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define Vector point\nusing namespace std;\ninline int read()\n{\n\tint x=0,fl=1;char st=getchar();\n\twhile(st<'0'||st>'9'){ if(st=='-')fl=-1; st=getchar();}\n\twhile(st>='0'&&st<='9') x=x*10+st-'0',st=getchar();\n\treturn x*fl;\n}\nconst int N=2005,mod=1e9+7;\nint n,k;\nll f[N<<1][N],fac[N*N],invfac[N*N];\ninline ll ksm(int x,int y)\n{\n\tll res=1;\n\twhile(y)\n\t{\n\t\tif(y&1) res=res*x%mod;\n\t\tx=(ll)x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\ninline ll C(int x,int y)\n{\n\tif(y==0) return 1ll;\n\treturn fac[x]*invfac[x-y]%mod*invfac[y]%mod;\n}\nint main()\n{\n\tn=read();k=read();\n\tif(k==1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=1;invfac[0]=1;\n\tfor(int i=1;i<=n*k;i++)\n\t\tfac[i]=(ll)fac[i-1]*i%mod,invfac[i]=ksm(fac[i],mod-2);\n\tf[0][0]=1;\n\tfor(int i=1;i<=2*n;i++)\n\t\tfor(int j=0;j<=min(n,i);j++)\n\t\t{\n\t\t\tif(j) f[i][j]=(f[i][j]+f[i-1][j-1])%mod;\n\t\t\tif(j+1<=i-1)\n\t\t\t{\n\t\t\t\tint numc=(i-1-j-1)/2;\n\t\t\t\tf[i][j]=(f[i][j]+f[i-1][j+1]*(n-numc)%mod*C(n*k-i-numc*(k-2),k-2)%mod)%mod;\n\t\t\t}\n\t\t}\n\tprintf(\"%lld\",f[n<<1][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<cmath>\nusing namespace std;\n#define int long long\nvoid read(int &x) {\n\tchar ch; bool ok;\n\tfor(ok=0,ch=getchar(); !isdigit(ch); ch=getchar()) if(ch=='-') ok=1;\n\tfor(x=0; isdigit(ch); x=x*10+ch-'0',ch=getchar()); if(ok) x=-x;\n}\n#define rg register\nconst int maxn=5e5+10;map<int,int>mp;\nint sum,n,k,now,tot,ans,a[maxn],mx,d,g,w[maxn],q[100],f[maxn];\nsigned main(){\n\tread(n);\n\tfor(rg int i=1;i<=n;i++)read(a[i]),w[++tot]=a[i];\n\tsort(w+1,w+tot+1);\n\tfor(rg int i=1;i<=tot;i++)if(!mp[w[i]])mp[w[i]]=++now;\n\tfor(rg int i=1;i<=tot;i++)a[i]=mp[a[i]],f[a[i]]++;\n\tsort(f+1,f+now+1);q[0]=1;\n\tfor(rg int i=1;i<=63;i++)q[i]=q[i-1]*2;\n\tfor(rg int j=1;j<=n;j++){\n\t\tint v=j,sum=0,k=1;\n\t\twhile(v<=f[now]){\n\t\t\tint s=lower_bound(f+k,f+now+1,v)-f;\n\t\t\tif(s<=now)sum+=v,v<<=1,k=s+1;\n\t\t\telse break;\n\t\t\t\n\t\t}\n\t\tif(sum>ans)ans=sum;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\nclose"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 2000*2000+1;\nstruct combination {\n    long long kai[MAXN];\n    long long inv[MAXN];\n    long long mod = 1e9+7;\n    combination() { initkai(); }\n    long long mp(long long a, long long b) {\n        if (b == 0) return 1LL;\n        long long ret = mp(a, b / 2);\n        ret = (ret * ret) % mod;\n        if (b & 1) ret *= a;\n        return ret % mod;\n    }\n    void initkai() {\n        kai[0] = 1; kai[1] = 1;\n        for (long long i = 2; i < MAXN; i++) kai[i] = kai[i - 1] * i % mod;\n        for (long long i = 0; i < MAXN; i++) inv[i] = mp(kai[i], mod-2);\n    }\n    long long calc(long long n, long long k) { return kai[n] * inv[k] % mod * inv[n - k] % mod; }\n} c;\n\nll n,k;\nll dp[2010][2010];\nbool ok[2010][2010];\n\nll dfs(int a, int b) {\n    if (ok[a][b]) return dp[a][b];\n    ll ret = 0;\n    if (a - 1 >= 0) ret += dfs(a-1,b);\n    if (b - 1 >= a) ret += dfs(a, b-1) * c.calc(a + b * (k - 1) - 1, k - 2) % c.mod;\n    ok[a][b] = 1;\n    return dp[a][b] = ret % c.mod;\n}\n\nint main() {\n    cin >> n >> k;\n    if (k == 1) {\n        cout << 1 << endl;\n        return 0;\n    }\n    dp[0][0] = 1;\n    ok[0][0] = 1;\n    ll ret = dfs(n,n);\n    for (ll i = 1; i <= n; i++) ret = ret * i % c.mod;\n    cout << ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#define mod 1000000007\ntypedef long long ll;\n\nusing namespace std;\n#define N 2010\n#define M 5000010\nclass Comb{\n  public:\n  ll fac[M],inv[M],ivf[M];\n  void init(){\n    fac[0]=ivf[0]=inv[1]=1;\n    for(ll i=1;i<M;i++){\n      if(i>1)inv[i]=(mod-mod/i*inv[mod%i]%mod)%mod;\n      fac[i]=fac[i-1]*i%mod;\n      ivf[i]=ivf[i-1]*inv[i]%mod;\n    }\n  }\n  ll qry(ll n,ll k){\n    return fac[n]*ivf[n-k]%mod*ivf[k]%mod;\n  }\n};Comb C;\nll f[N][N],n,k;\nint main(){\n    C.init();\n    cin>>n>>k;\n    if(k==1){cout<<1<<endl; return 0;}\n    for(ll i=0;i<N;i++)for(ll j=0;j<N;j++)f[i][j]=0; f[0][0]=1;\n    for(ll x=0;x<N;x++)for(ll y=0;y<N;y++){\n      if(x+1<=y){\n\tf[x+1][y]=(f[x+1][y]+f[x][y])%mod;\n      }\n      if(y+1<=n){\n\tf[x][y+1]=(f[x][y+1]+f[x][y]*C.qry(x+y*(k-1)+k-2,k-2))%mod;\n      }\n    }\n    cout<<f[n][n]*C.fac[n]%mod<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Wrong Coding:\n//j 1 to i not m\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#define llong long long\nusing namespace std;\n\nconst int N = 2000;\nconst int P = 1e9+7;\nllong dp[N+3][N+3];\nllong fact[5000003],finv[5000003];\nint n,m;\n\nllong quickpow(llong x,llong y)\n{\n\tllong cur = x,ret = 1ll;\n\tfor(int i=0; y; i++)\n\t{\n\t\tif(y&(1ll<<i)) {y-=(1ll<<i); ret = ret*cur%P;}\n\t\tcur = cur*cur%P;\n\t}\n\treturn ret;\n}\n\nllong comb(llong x,llong y) {return x<0 || y<0 || x<y ? 0ll : fact[x]*finv[y]%P*finv[x-y]%P;}\n\nint main()\n{\n\tfact[0] = 1ll; for(int i=1; i<=5000000; i++) fact[i] = fact[i-1]*i%P;\n\tfinv[5000000] = quickpow(fact[5000000],P-2); for(int i=5000000-1; i>=0; i--) finv[i] = finv[i+1]*(i+1)%P;\n\tscanf(\"%d%d\",&n,&m);\n\tif(m==1) {printf(\"1\"); return 0;}\n\tdp[0][0] = 1ll;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tdp[i][0] = 1ll;\n\t\tfor(int j=1; j<=i; j++)\n\t\t{\n\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\tdp[i][j] += comb((n-i)+(n-(j-1))*(m-1)-1,m-2)*dp[i][j-1]%P;\n\t\t\tdp[i][j] %= P;\n\t\t}\n\t}\n\tllong ans = dp[n][n]*fact[n]%P;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\n#define maxn 4000000 \nusing namespace std;\nint n,k;\nint dp[2005][2005];\nint fac[4000005],ifac[4000005];\n\nint ksm(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=1ll*res*x%mod;\n\t\tx=1ll*x*x%mod,y/=2;\n\t}\n\treturn res;\n}\n\nint C(int x,int y){\n\tint res=1ll*fac[x]*ifac[y]%mod*ifac[x-y]%mod;\n\treturn res;\n}\n\nint main(){\n\tscanf(\"%d %d\",&n,&k);\n\tif(k==1){\n\t\tputs(\"1\");return 0;\n\t}\n\tfac[0]=1;for(int i=1;i<=maxn;i++) fac[i]=1ll*i*fac[i-1]%mod;\n\tifac[maxn]=ksm(fac[maxn],mod-2);\n\tfor(int i=maxn-1;i>=0;i--) ifac[i]=1ll*(i+1)*ifac[i+1]%mod;\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\tif(j){\n\t\t\t\tdp[i][j]+=1ll*dp[i][j-1]*(n-j+1)%mod*C(n*k-i-(j-1)*(k-1)-1,k-2)%mod;\n\t\t\t\tif(dp[i][j]>=mod) dp[i][j]-=mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[n][n]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#define rep(i,a,b) for(int i = a; i <= b; i++)\n#define dep(i,a,b) for(int i = a; i >= b; i--)\n#define Rep(i,a) for(int i = 0; i < a; i++)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\n#define x first\n#define y second\n#define pb(a) push_back(a)\nconst int N = 2010, mod = 1e9 + 7;\nint n, k, f[N][N], fac[N * N], inv[N * N];\nint C(int n, int m) { return 1LL * fac[n] * inv[n - m] % mod * inv[m] % mod; }\nint pw(int a, int b) { \n\tint w = 1; \n\tfor(;b; b >>= 1, a = 1LL * a * a % mod) \n\t\tif (b & 1) w = 1LL * w * a % mod; \n\treturn w; \n}\nint main() {\n\tscanf(\"%d%d\",&n,&k);\n\tif (k == 1) { printf(\"1\\n\"); return 0; } \n\tf[0][0] = 1;\n\tfac[0] = 1; rep(i,1,n * k) fac[i] = 1LL * fac[i - 1] * i % mod;\n\tinv[n * k - 1] = pw(fac[n * k - 1], mod - 2);\n\tdep(i,n * k - 2,0) inv[i] = 1LL * (i + 1) * inv[i + 1] % mod;\n\n\trep(i,0,n - 1) rep(j,0,n - i) if (f[i][j]) {\n\t\tif (j < n) (f[i][j + 1] += f[i][j]) %= mod;\n\t\tif (j) f[i + 1][j - 1] = (f[i + 1][j - 1] + 1LL * C(k * (n - i) - j - 1, k - 2) * (n - i) % mod * f[i][j]) % mod; \n\t}\n\tprintf(\"%d\\n\",f[n][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define IL inline\n#define RG register\n#define LL long long\n#define Upd(a) (a)>=mod?(a-=mod):1\nusing namespace std;\ntemplate <class T>\nIL char gc () {\n\tstatic char buf[1<<6], *p1=buf, *p2=buf;\n\treturn (p1==p2) && (p2=(p1=buf)+fread(buf,1,1<<6,stdin), p1==p2) ?EOF:*p1++;\n}\ntemplate <typename T>\nIL void read (T&data) {\n\tdata=0;\n\tRG char ch=0;\n\twhile (ch<'0' || ch>'9') ch=getchar();\n\twhile (ch<='9' && ch>='0') data=(data<<1)+(data<<3)+(ch&15), ch=getchar();\n}\nconst int mod = 1e9+7;\nconst int _ =2011;\nint n, k;\nLL dp[2][_], jc[_*_], jcn[_*_];\nIL int poww (RG int a, RG int b) {\n\tRG int ret=1, Base=a;\n\tfor (;b;b>>=1, Base=1LL*Base*Base%mod) if (b&1) ret=1LL*ret*Base%mod;\n\treturn ret;\n}\nIL int C (RG int a, RG int b) {\n\tif (a<b) return 0;\n\treturn jc[a]*jcn[b]%mod*jcn[a-b]%mod;\n}\nint main (/*int aa, int bb*/) {\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\t//n=aa, k=bb;\n\tread(n), read(k);\n\tif (k<=1) {puts(\"1\"); return 0;}\n\tjc[0]=jcn[0]=1;\n\tRG int i, j, pre=1, cur=0;\n\tfor (i=1; i<=n*k; ++i) jc[i]=jc[i-1]*i%mod, jcn[i]=poww(jc[i], mod-2);\n\tdp[0][0]=1;\n\tfor (i=1; i<=n*2; ++i) {\n\t\tswap(cur, pre);\n\t\tfor (j=0; j<min(i,n+1); ++j) dp[cur][j]=0;\n\t\tfor (j=1; j<=min(i,n); ++j) {\n\t\t\tif ((i-j)%2) continue;\n\t\t\tif (n*2-i+1<j) break;\n\t\t\tRG int a=(i+j-2)>>1, b=(i-j)>>1;\n\t\t\tdp[cur][j]=1LL*dp[pre][j-1]*C(a*(k-1)+b+k-1-1,k-1-1)%mod;\n\t\t\tdp[cur][j]+=dp[pre][j+1];\n\t\t\tUpd(dp[cur][j]);\n\t\t}\n\t\tif (cur%2==0) dp[cur][0]=dp[pre][1];\n\t}\n\t//return 1LL*dp[cur][0]*jc[n]%mod;\n\tprintf(\"%lld\",1LL*dp[cur][0]*jc[n]%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n@Date    : 2019-08-20 10:13:37\n@Author  : Adscn (adscn@qq.com)\n@Link    : https://www.cnblogs.com/LLCSBlog\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define IL inline\n#define RG register\n#define gi getint()\n#define gc getchar()\n#define File(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\nIL int getint()\n{\n\tRG int xi=0;\n\tRG char ch=gc;\n\tbool f=0;\n\twhile(ch<'0'||ch>'9')ch=='-'?f=1:f,ch=gc;\n\twhile(ch>='0'&&ch<='9')xi=(xi<<1)+(xi<<3)+ch-48,ch=gc;\n\treturn f?-xi:xi;\n}\ntemplate<typename T>\nIL void pi(T k,char ch=0)\n{\n\tif(k<0)k=-k,putchar('-');\n\tif(k>=10)pi(k/10,0);\n\tputchar(k%10+'0');\n\tif(ch)putchar(ch);\n}\n#define int long long\nconst int N=2000+7;\nconst int mod=1e9+7;\ninline void exgcd(int a,int b,int &x,int &y)\n{\n\tif(!b){\n\t\tx=1,y=0;\n\t\treturn;\n\t}\n\texgcd(b,a%b,y,x);\n\ty-=a/b*x;\n}\ninline int inv(int qwq){\n\tint x,y;\n\texgcd(qwq,mod,x,y);\n\treturn (x%mod+mod)%mod;\n}\nlong long invf[N*N],fac[N*N];\nlong long f[N][N];\ninline int C(int n,int m){\n//\tif(n>m)return 0;\n\treturn (1ll*fac[m]*invf[n]%mod*invf[m-n])%mod;\n}\nsigned main(void)\n{\n\t#ifndef ONLINE_JUDGE\n//\tFile(\"\");\n\t#endif\n\tint n=gi,k=gi;\n\tif(k==1)return pi(1),0;\n\tfac[0]=1;\n\tfor(int i=1;i<=N*N;++i)fac[i]=(1ll*fac[i-1]*i)%mod;\n\tinvf[N*N]=inv(fac[N*N]);\n\tfor(int i=N*N-1;~i;--i)invf[i]=(1ll*invf[i+1]*(i+1))%mod;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<=i;++j)\n\t\t{\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(j)(f[i][j]+=f[i][j-1]*(n-j+1)%mod*C(k-2,n-i+(n-j+1)*(k-1)-1)%mod)%=mod;\n\t\t}\n\tcout<<f[n][n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll P=1e9+7,MAXN=4e6+10;\nll n,k,fac[MAXN],inv[MAXN],dp[2010][2010];\nll qpow (ll a,ll b) {\n\tll res=1;\n\twhile (b) {\n\t\tif (b&1) {\n\t\t\tres=(res*a)%P;\n\t\t}\n\t\ta=(a*a)%P;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nll c (ll n,ll m) {\n\treturn (((fac[n]*inv[m])%P)*inv[n-m])%P;\n}\nint main () {\n\tscanf(\"%lld%lld\",&n,&k);\n\tif (k==1) {\n\t\tprintf(\"%d\\n\",1);\n\t\treturn 0;\n\t}\n\tfac[0]=inv[0]=1;\n\tfor (ll i=1;i<=n*k;i++) {\n\t\tfac[i]=(i*fac[i-1])%P;\n\t}\n\tinv[n*k]=qpow(fac[n*k],P-2);\n\tfor (ll i=n*k-1;i>=1;i--) {\n\t\tinv[i]=(inv[i+1]*(i+1))%P;\n\t}\n\tfor (int i=1;i<=n;i++) {\n\t\tdp[i][0]=1;\n\t}\n\tfor (int i=1;i<=n;i++) {\n\t\tfor (int j=1;j<=i;j++) {\n\t\t\tdp[i][j]=(dp[i-1][j]+(((dp[i][j-1]*(n-j+1))%P)*c(n*k-i-1-(j-1)*(k-1),k-2))%P)%P;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nnamespace Wo_Zhen_Cai_A\n{\n\ttypedef long long ll;\n\tconst int N=2010,MOD=1000000007;\n\tinline void inc(ll a,ll &b){b=(a+b)%MOD;} \n\tll qpow(ll a,ll b){ll c=1;for(;b;b>>=1,a=a*a%MOD)if(b&1)c=c*a%MOD;return c;}\n\tll fact[N*N],ifact[N*N];\n\tll C(int n,int m){return fact[n]*ifact[n-m]%MOD*ifact[m]%MOD;}\n\tll f[N][N];\n\tint n,k;\n\tvoid solve()\n\t{\n\t\tscanf(\"%d%d\",&n,&k);\n\t\tif(k==1){printf(\"1\\n\");return;}\n\t\tfact[0]=1;for(int i=1,tmp=n*k;i<=tmp;i++)fact[i]=fact[i-1]*i%MOD;\n\t\tifact[n*k]=qpow(fact[n*k],MOD-2);\n\t\tfor(int i=n*k;i;i--)ifact[i-1]=ifact[i]*i%MOD;\n\n\t\tf[0][0]=1;\n\t\tfor(int i=0;i<=n;i++)\n\t\t\tfor(int j=i;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(i+j==0)continue;\n\n\t\t\t\tif(i)inc(f[i-1][j],f[i][j]);\n\t\t\t\tif(j)inc(f[i][j-1]*C(k*i+(k-1)*(j-i-1)+k-2,k-2)%MOD,f[i][j]);\n\n\n//\t\t\t\tprintf(\"f[%d][%d] = %lld\\n\",i,j,f[i][j]);\n\t\t\t}\n\t\tprintf(\"%lld\\n\",f[n][n]*fact[n]%MOD);\n\t}\n}\nint main()\n{\n\tWo_Zhen_Cai_A::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int MAXN = 2005, mod = 1e9 + 7;\ninline int powmod(int a, int x) {\n    long long cur = a, res = 1;\n    while(x) {\n        if(x & 1) res = (res * cur) % mod;\n        cur = (cur * cur) % mod;\n        x >>= 1;\n    }\n    return (int)res;\n}\nint n, k, f[MAXN][MAXN];\nint fac[MAXN * MAXN], rev_fac[MAXN * MAXN];\ninline int commod(int n, int m) {\n    return ((((long long)fac[n] * rev_fac[m]) % mod) * rev_fac[n - m]) % mod;\n}\nint main() {\n    fac[0] = 1;\n    rev_fac[0] = powmod(fac[0], mod - 2);\n    for(int i = 1; i < MAXN * MAXN; i++) {\n        fac[i] = ((long long)fac[i - 1] * i) % mod;\n        rev_fac[i] = powmod(fac[i], mod - 2);\n    }\n    scanf(\"%d%d\", &n, &k);\n    int ans;\n    if(k == 1) {\n        ans = 1;\n    }\n    else {\n        for(int i = 0; i <= n; i++) {\n            for(int j = i; j <= n; j++) {\n                if(i == 0 && j == 0) f[i][j] = 1;\n                if(i - 1 >= 0) f[i][j] = f[i - 1][j];\n                if(j > i) {\n                    int t = ((long long)f[i][j - 1] * commod(i + j * (k - 1) - 1, k - 2)) % mod;\n                    f[i][j] += t;\n                    if(f[i][j] >= mod) f[i][j] -= mod;\n                }\n            }\n        }\n        ans = ((long long)fac[n] * f[n][n]) % mod;\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,k;\nlong long f[2005][2005],fac[4000005],inv_fac[4000005];\ninline long long C(int n,int m)\n{ \n\treturn (((fac[m]*inv_fac[n])%1000000007)*inv_fac[m-n])%1000000007; \n}\nlong long power(long long x,int p)\n{\n    long long ans=1,m=x;\n    while(p)\n\t{\n        if(p%2==1) \n\t\t{\n        \tans*=m;\n\t\t\tans%=1000000007;\n\t\t}\n\t\tp/=2;\n\t\tm*=m;\n\t\tm%=1000000007;\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    if(k==1)\n\t{ \n\t\tprintf(\"%d\\n\",1); \n\t\treturn 0; \n\t}\n    fac[0]=1; \n\tfor(register int i=1;i<=4000005;i++) \n\t\tfac[i]=(fac[i-1]*i)%1000000007;\n    inv_fac[4000005]=power(fac[4000005],1000000005); \n\tfor(register int i=4000004;i>=0;i--) \n\t\tinv_fac[i]=(inv_fac[i+1]*(i+1))%1000000007;\n    f[0][0]=1;\n    for(register int i=1;i<=n;i++)\n\t{\n        for(register int j=0;j<=i;j++)\n\t\t{\n            f[i][j]=f[i-1][j];\n            if(!j) \n\t\t\t\tcontinue;\n            (f[i][j]+=f[i][j-1]*(n-j+1)%1000000007*C(k-2,n-i+(n-j+1)*(k-1)-1)%1000000007)%=1000000007;\n        }\n    }\n    printf(\"%lld\\n\",f[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define taskname \"A\"\n#define pb  push_back\n#define mp  make_pair\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> ii;\nconst int maxn = 2e3 + 5;\nconst int maxm = maxn * maxn;\nconst int mod = 1e9 + 7;\nint n , k , dp[maxn][maxn];\nint f[maxm] , rf[maxm];\nint C(int n , int k){\n    if(k < 0 || n < 0 || k > n)return 0;\n    return (ll)f[n] * rf[n - k] % mod * rf[k] % mod;\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\",\"r\")){\n        freopen(taskname\".INP\", \"r\",stdin);\n        freopen(taskname\".OUT\", \"w\",stdout);\n    }\n    cin >> n >> k;\n    dp[0][0] = 1;\n    f[0] = f[1] = rf[0] = rf[1] = 1;\n    if(k == 1)return cout << 1 , 0;\n    for(int i = 2 ; i < maxm ; ++i){\n        f[i] = (ll)f[i - 1] * i % mod;\n        rf[i] = (mod - (ll)(mod / i) * rf[mod % i] % mod);\n    }\n    for(int i = 2 ; i < maxm ; ++i)rf[i] = (ll)rf[i - 1] * rf[i] % mod;\n    for(int i = 0 ; i <= n ; ++i){\n        for(int j = 0 ; j <= n ; ++j){\n            if(i == 0 && j == 0)continue;\n            if(i > j)continue;\n            if(i > 0)dp[i][j] = dp[i - 1][j];\n            if(j > 0)dp[i][j] += (ll)dp[i][j - 1] * C(i + j * (k - 1) - 1 , k - 2) % mod;\n            if(dp[i][j] >= mod)dp[i][j] -= mod;\n//            cout << i << \" \" << j << \" \" << dp[i][j] << \" \" <<\n//            i + j * (k - 1) - 1 << \" \" << k - 2 << \" \"  << C(i + j * (k - 1) - 1 , k - 2) <<endl;\n        }\n    }\n    cout << ((ll)dp[n][n] * f[n]) % mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MX=2011,md=1000000007;\n\ntypedef long long LL;\nint dp[MX][MX];\nint n,k;\nint fac[MX*MX],inv[MX*MX],facinv[MX*MX];\n\n#define C(x,y) ((LL)fac[x]*facinv[y]%md*facinv[(x)-(y)]%md)\n\nvoid ini(int m){\n\tinv[1]=1;for(int i=2;i<=m;i++)inv[i]=(LL)inv[md%i]*(md-md/i)%md;\n\tfac[0]=1;for(int i=1;i<=m;i++)fac[i]=(LL)fac[i-1]*i%md;\n\tfacinv[0]=1;for(int i=1;i<=m;i++)facinv[i]=(LL)facinv[i-1]*inv[i]%md;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1)return puts(\"1\"),0;\n\tini(n*k);--k;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=i;j<=n;j++){\n\t\t\tif(!i&&!j)dp[i][j]=1;\n\t\t\telse if(i==j)dp[i][j]=dp[i-1][j];\n\t\t\telse if(!i)dp[i][j]=(LL)dp[i][j-1]*C(j*k-1,k-1)%md;\n\t\t\telse dp[i][j]=((LL)dp[i-1][j]+(LL)dp[i][j-1]*C(j*k-1+i,k-1)%md)%md;\n\t\t}\n\tprintf(\"%lld\\n\",(LL)fac[n]*dp[n][n]%md);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define next Next\n#define gc getchar\n#define int long long\n/*char buf[1<<21],*p1=buf,*p2=buf;\ninline int gc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}*/\ninline int read()\n{\n    int ret=0,f=0;char c=gc();\n    while(!isdigit(c)){if(c=='-')f=1;c=gc();}\n    while(isdigit(c)){ret=ret*10+c-48;c=gc();}\n    if(f)return -ret;return ret;\n}\nconst int mod=1e9+7;\nconst int N=2005;\nint n,k;\nint f[N][N],jc[N*N],inv[N*N];\ninline int C(int n,int m)\n{\n\treturn jc[n]*inv[m]%mod*inv[n-m]%mod;\n}\nsigned main()\n{\n    n=read();k=read();\n    if(k==1){cout<<1;return 0;}\n    jc[0]=jc[1]=inv[0]=inv[1]=1;\n\tfor(int i=2;i<=4000000;i++)jc[i]=jc[i-1]*i%mod;\n    for(int i=2;i<=4000000;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n    for(int i=2;i<=4000000;i++)inv[i]=inv[i]*inv[i-1]%mod;\n    f[0][0]=1;\n    for(int i=1;i<=n;i++)\n\t{\n        for(int j=0;j<=i;j++)\n\t\t{\n            f[i][j]=f[i-1][j];\n            if(!j)continue;\n            (f[i][j]+=f[i][j-1]*(n-j+1)%mod*C(n-i+(n-j+1)*(k-1)-1,k-2)%mod)%=mod;\n        }\n    }\n    printf(\"%lld\\n\",f[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing uint = unsigned int;\nusing ull = unsigned long long;\n\ntemplate <uint MOD>\nstruct modnum {\n\tusing num = modnum;\n\tuint v;\n\tmodnum(uint _v = 0) : v(_v) {}\n\tnum& operator += (const num& r) {\n\t\tif ((v += r.v) >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tnum& operator -= (const num& r) {\n\t\tif ((r += MOD - r.v) >= MOD) r -= MOD;\n\t\treturn *this;\n\t}\n\tnum& operator *= (const num& r) {\n\t\tv = ull(v) * r.v % MOD;\n\t\treturn *this;\n\t}\n\tnum operator + (const num& r) const { return num(*this) += r; }\n\tnum operator - (const num& r) const { return num(*this) -= r; }\n\tnum operator * (const num& r) const { return num(*this) *= r; }\n\tnum pow(int b) const {\n\t\tnum r = 1, a = *this;\n\t\twhile (b) {\n\t\t\tif (b & 1) {\n\t\t\t\tr *= a;\n\t\t\t}\n\t\t\ta *= a;\n\t\t\tb /= 2;\n\t\t}\n\t\treturn r;\n\t}\n\tnum inv() const { return pow(MOD - 2); }\n};\nusing num = modnum<int(1e9) + 7>;\n\nconst int MAXN = 2010;\nconst int MAXD = MAXN * MAXN;\nint N, K;\nbool used[MAXN][MAXN];\nnum dp[MAXN][MAXN];\nnum fact[MAXD], ifact[MAXD];\n\nvoid precomp() {\n\tfact[0] = 1;\n\tfor (int i = 1; i < MAXD; i++) {\n\t\tfact[i] = num(i) * fact[i-1];\n\t}\n\tifact[MAXD-1] = fact[MAXD-1].inv();\n\tfor (int i = MAXD-2; i >= 0; i--) {\n\t\tifact[i] = num(i+1) * ifact[i+1];\n\t}\n}\n\nnum C(int a, int b) {\n\treturn fact[a] * ifact[b] * ifact[a-b];\n}\n\nnum go(int a, int b) {\n\tif (a > N || b > N || a < b) return num(0);\n\tif (!used[a][b]) {\n\t\tused[a][b] = true;\n\t\tdp[a][b] = go(a+1, b) + go(a, b+1) * C(N*K - a - b*(K-1) - 1, K-2);\n\t}\n\treturn dp[a][b];\n}\n\nint main() {\n\tprecomp();\n\tcin >> N >> K;\n\tused[N][N] = true;\n\tdp[N][N] = 1;\n\tnum ans = fact[N] * go(0, 0);\n\tcout << ans.v << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int maxN = 2e3 + 13, mod = 1e9 + 7;\nint n, k, dp[maxN][maxN], fac[maxN * maxN], rfac[maxN * maxN];\n\nint pw (int a, int b) {\n    int ret = 1;\n    for (; b; b >>= 1, a = 1ll * a * a % mod)\n\tif (b & 1)\n\t    ret = 1ll * ret * a % mod;\n    return ret;\n}\n\nint c (int a, int b) {\n    return 1ll * fac[b] * rfac[a] % mod * rfac[b - a] % mod;\n}\n\nint32_t main () {\n    cin >> n >> k;\n    dp[0][0] = 1;\n    fac[0] = rfac[0] = 1;\n    for (int i = 1; i <= n * k; i++) {\n\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\trfac[i] = 1ll * rfac[i - 1] * pw(i, mod - 2) % mod;\n    }\n\n    for (int i = 1; i <= n; i++)\n\tfor (int j = 0; j <= i; j++) {\n\t    if (j)\n\t\tdp[i][j] = dp[i][j - 1];\n\t    dp[i][j] = (dp[i][j] + (1ll * dp[i - 1][j] * c(k - 2, i * (k - 1) + j - 1) % mod)) % mod;\n\t    // cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t}\n    //cout << dp[n][n] << endl;\n    cout << 1ll * dp[n][n] * fac[n] % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n \nusing namespace std;\n \n# define REP(i, a, b) for(int i = a; i <= b; ++ i)\n# define CLR(i, a) memset(i, a, sizeof(i))\n# define REPD(i, a, b) for(int i = a; i >= b; -- i) \n \nconst int N = 2e3 + 5, MOD = 1e9 + 7;\n \nint n, k, f[N][N], inv[N * N], fac[N * N];\n \ninline void inc(int &a, int b) { a = (a + b) % MOD; }\n \ninline int binom(int x, int y) { return (y < 0 || y < x) ? 0 : 1ll * fac[y] * inv[x] % MOD * inv[y - x] % MOD; }\nint pow_(int x, int k) {\n\tint ret = 1;\n\twhile(k) {\n\t\tif(k & 1) ret = 1ll * ret * x % MOD;\n\t\tx = 1ll * x * x % MOD;\n\t\tk >>= 1;\n\t}\n\treturn ret;\n}\n \nint main() {\n\tscanf(\"%d%d\", &n ,&k);\n    if(k == 1) puts(\"1\"), exit(0);\n\tfac[0] = 1;\n\tREP(i, 1, n * k + 1) fac[i] = 1ll * fac[i - 1] * i % MOD;\n\tinv[n * k + 1] = pow_(fac[n * k + 1], MOD - 2);\n\tREPD(i, n * k, 0) inv[i] = 1ll * inv[i + 1] * (i + 1) % MOD;\n\tf[0][0] = 1;\n\tREP(i, 0, n) {\n\t\tREPD(j, i, 0) {\n\t\t\tinc(f[i + 1][j + 1], 1ll * f[i][j] * binom(k - 2, i * k - j + k - 2) % MOD);\n\t\t\tif(j) inc(f[i][j - 1], f[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", 1ll * f[n][0] * fac[n] % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Achen\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<vector>\n#include<cstdio>\n#include<queue>\n#include<cmath>\n#include<set>\n#include<map>\n#define For(i,a,b) for(int i=(a);i<=(b);i++)\n#define Rep(i,a,b) for(int i=(a);i>=(b);i--)\nconst int N=2007,mod=1e9+7;\ntypedef long long LL; \ntypedef double db;\nusing namespace std;\nint n,k;\nLL dp[N][N],fac[N*N],inv[N*N];\n\ntemplate<typename T> void read(T &x) {\n    char ch=getchar(); x=0; T f=1;\n    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n    if(ch=='-') f=-1,ch=getchar();\n    for(;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0'; x*=f;\n}\n\nLL C(int n,int m) {\n\tif(n<m) return 0;\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\n\n//#define DEBUG\nint main() {\n#ifdef DEBUG\n\tfreopen(\"1.in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n#endif\n\tread(n); read(k);\n\tfac[0]=inv[0]=inv[1]=1;\n\tFor(i,1,n*k) fac[i]=fac[i-1]*i%mod;\n\tFor(i,2,n*k) inv[i]=(mod-mod/i*inv[mod%i]%mod)%mod;\n\tFor(i,2,n*k) inv[i]=inv[i-1]*inv[i]%mod; \n\tif(k==1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tdp[n][n]=1;\n\tRep(i,n,0) {\n\t\tRep(j,n,i) {\n\t\t\tif(i) \n\t\t\t\t(dp[i-1][j]+=dp[i][j])%=mod;\n\t\t\tif(j>i) \n\t\t\t\t(dp[i][j-1]+=dp[i][j]*(k>2?C(i+j*(k-1)-1,k-2):1)%mod)%=mod;\n\t\t}\n\t}\n\tLL ans=dp[0][0]*fac[n]%mod;\n\tprintf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ; \n\n#define int long long\nconst int MAXN = 2e3 + 100 ; \nconst int MAXH = 4e6 + 100 ; \nconst int Mod = 1e9 + 7 ;\n\nint fact[MAXH] ;\n\nvoid Pre(){\n\tfact[0] = 1 ; \n\tfor(int i = 1 ; i < MAXH ; i ++)fact[i] = fact[i - 1] * i % Mod ; \n}\nint power(int n , int m = Mod - 2){\n\tif(! m)return  1 ; \n\tif(m % 2)\treturn power(n , m - 1) * n % Mod ; \n\t\t\t\treturn power(n * n % Mod , m / 2) ; \n}\nint choose(int n , int m){\n\tif(n > m)return 0 ; \n\treturn fact[m] * power(fact[n]) % Mod * power(fact[m - n]) % Mod ; \n}\nint dp[MAXN][MAXN] ; \nint32_t main(){ \n\tios_base::sync_with_stdio(0) ; \n\tcin . tie(0) ; cout . tie(0) ; \n\t\n\tPre() ; \n\n\tint n , k ;  cin >> n >> k ; \n        if(k == 1)return cout << 1 << '\\n' , 0 ;\n\tdp[0][0] = 1 ; \n\tfor(int i = 0 ; i <= n ; i ++){\n\t\tfor(int j = i + (i == 0) ; j <= n ; j ++){\n\t\t\tif(i > 0)dp[i][j] += dp[i - 1][j] ; \n\t\t\tif(j > 0)dp[i][j] += dp[i][j - 1] * choose(k - 2 , j * (k - 1) + i - 1) % Mod ;\n\t\t\tdp[i][j] %= Mod ; \n\t\t\tcout << i << ' ' << j << ' ' << ':' << dp[i][j] << ' ' ;\n\t\t}\n\t\tcout << '\\n' ; \n\t}\n\tcout << dp[n][n] * fact[n] % Mod << '\\n' ; \n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\nconst double EPS = 1e-9;\nconst ll MOD = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n\n#define SIZE 4000001\n\nll kai[SIZE];\nll mokai[SIZE];\n\nll mod_pow (ll x, ll y) {\n    ll ret = 1;\n    while (y) {\n        if (y&1) ret = ret*x%MOD;\n        x = x*x%MOD;\n        y /= 2;\n    }\n    return ret;\n}\n\nvoid init () {\n    kai[0] = 1;\n    for (int i = 1; i < SIZE; i++) kai[i] = kai[i-1]*i%MOD;\n    for (int i = 0; i < SIZE; i++) mokai[i] = mod_pow(kai[i],MOD-2);\n}\n\nll conb (ll x, ll y) {\n    ll z = x-y;\n    ll ret = kai[x]*mokai[y]%MOD;\n    ret = ret*mokai[z]%MOD;\n    return ret;\n}\n\nll n, k;\nll dp[2001][2001];\n\ninline ll mmul (ll x, ll y) {\n    return x*y%MOD;\n}\n\nint main() {\n    cin >> n >> k;\n    init();\n    if (k == 1) {\n        cout << 1 << endl;\n        return 0;\n    }\n    dp[0][0] = 1;\n    for (ll i = 1; i <= n; i++) {\n        dp[i][0] = mmul(dp[i-1][0], conb(i*(k-1)-1,k-2));\n    }\n    for (ll j = 1; j <= k; j++) {\n        for (ll i = j; i <= n; i++) {\n            if (i == j) {\n                dp[i][j] = dp[i][j-1];\n            } else {\n                dp[i][j] = (mmul(dp[i-1][j], conb(i*k-(i-j)-1, k-2)) + dp[i][j-1]) % MOD;\n            }\n        }\n    }\n    cout << (dp[n][n] * kai[n]) % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll MAX_N = 3000 + 10, MOD = 1e9 + 7;\nll n, k, dp[MAX_N][MAX_N], fac[MAX_N * MAX_N], en[MAX_N * MAX_N], r,pwmakh, makh = 1;\nll pw(int x,int y){\n\tif(!y) return 1ll;\n\tll t = pw(x, y / 2);\n\tt = 1ll * t * t % MOD;\n\tif(y & 1) t = 1ll * t * x % MOD;\n\treturn t;\n}\nint main(){\n    cin>>n>>k;\n    fac[0] = 1;\n    for(int i = 1; i <= n * k; i++){\n        fac[i] = fac[i - 1] * i;\n        fac[i] %= MOD;\n    }\n    for(int i = 1; i <= k - 2; i++){\n        makh *= i;\n        makh %= MOD;\n    }\n    pwmakh = pw(makh, MOD - 2);\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j <= n; j++){\n            if(j > 0){\n                if(en[i * k + j * (k - 1) - 1] == 0){\n                    r = fac[i * k + j * (k - 1) - 1] * pwmakh % MOD * pw(fac[i * k + j * (k - 1) - 1 - (k - 2)], MOD - 2) % MOD;\n                    en[i * k + j * (k - 1) - 1] = r;\n                }\n                else{\n                    r = en[i * k + j * (k - 1) - 1];\n                }\n            }\n            if(i > 0 && j > 0){\n                dp[i][j] = dp[i - 1][j + 1] + (dp[i][j - 1] * r) % MOD;\n            }\n            else if(i == 0 && j > 0){\n                dp[i][j] = dp[i][j - 1] * r;\n            }\n            else if(i > 0 && j == 0){\n                dp[i][j] = dp[i - 1][j + 1];\n            }\n            else{\n                dp[i][j] = 1;\n            }\n            dp[i][j] %= MOD;\n        }\n    }\n    ll ans = 1ll * dp[n][0] * fac[n] % MOD;\n    cout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long s64;\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n#define per(i,r,l) for(int i=r;i>=l;--i)\nconst int N=2000+5,D=1e9+7;\ns64 mi(s64 x,int y=D-2)\n{\n\ts64 ans=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ans=ans*x%D;\n\t\tx=x*x%D;y>>=1;\n\t}\n\treturn ans;\n}\ns64 dp[2][N],jie[N*N],niv_jie[N*N];\nvoid init_jie(int n)\n{\n\tjie[0]=1;\n\trep(i,1,n)jie[i]=jie[i-1]*i%D;\n\tniv_jie[n]=mi(jie[n]);\n\tper(i,n,1)niv_jie[i-1]=niv_jie[i]*i%D;\n}\ns64 C(int n,int m)\n{\n\tassert(n<N*N);\n\treturn jie[n]*niv_jie[m]%D*niv_jie[n-m]%D;\n}\n\nint main()\n{\n#ifdef kcz\n\tfreopen(\"1.in\",\"r\",stdin);\n#endif\n\tint n,k;\n\tcin>>n>>k;\n\tif(k==1)\n\t{\n\t\tputs(\"1\");\n\t\texit(0);\n\t}\n\tinit_jie(n*k);\n\tbool d=1;\n\tdp[d][0]=1;\n\tper(i,n*2,1)\n\t{\n\t\tmemset(dp[d^1],0,sizeof(dp[d^1]));\n\trep(j,0,min(2*n-i,i))\n\tif(dp[d][j])\n\t{\n//\t\tcerr<<i<<\" \"<<j<<\" \"<<dp[d][j]<<endl;\n\t\tint l=(n*2-i-j)/2,r=n*2-i-l;\n//\t\tif(j+1<=i-1)cerr<<i<<\" \"<<j<<r*(k-1)+l+k-2<<\" \"<<k-2<<endl;\n\t\t(dp[d^1][j+1]+=dp[d][j]*C(r*(k-1)+l+k-2,k-2))%=D;\n\t\tif(j)(dp[d^1][j-1]+=dp[d][j])%=D;\n\t}\n\t\td^=1;\n\t}\n\tcout<<(dp[d][0]*jie[n]%D+D)%D;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int MAXN = 2005, mod = 1e9 + 7;\ninline int addmod(int a, int b) { return (a + b) % mod; }\ninline int mulmod(long long a, int b) { return (a * b) % mod; }\ninline int powmod(int a, int x) {\n    long long cur = a, res = 1;\n    while(x) {\n        if(x & 1) res = (res * cur) % mod;\n        cur = (cur * cur) % mod;\n        x >>= 1;\n    }\n    return (int)res;\n}\nint n, k, f[MAXN][MAXN], fac[MAXN * MAXN], rev_fac[MAXN * MAXN];\ninline int commod(int n, int m) {\n    return mulmod(fac[n], mulmod(rev_fac[m], rev_fac[n - m]));\n}\nint main() {\n    fac[0] = 1;\n    rev_fac[0] = powmod(fac[0], mod - 2);\n    for(int i = 1; i < MAXN * MAXN; i++) fac[i] = mulmod(fac[i - 1], i), rev_fac[i] = powmod(fac[i], mod - 2);\n    scanf(\"%d%d\", &n, &k);\n    int ans;\n    if(k == 1) {\n        ans = 1;\n    }\n    else {\n        for(int i = 0; i <= n; i++) {\n            for(int j = i; j <= n; j++) {\n                if(i == 0 && j == 0) f[i][j] = 1;\n                if(i - 1 >= 0) f[i][j] = f[i - 1][j];\n                if(j > i)\n                    f[i][j] = addmod(f[i][j], mulmod(f[i][j - 1], commod(i + j * (k - 1) - 1, k - 2)));\n            }\n        }\n        ans = mulmod(fac[n], f[n][n]);\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\nusing namespace std;\nint fac[5001000],nifac[5001000],dp[2010][2010];\nint getmi(int a,int x)\n{\n\tint ans=1;\n\twhile (x)\n\t{\n\t\tif (x&1) ans=(long long)ans*a%mo;\n\t\ta=(long long)a*a%mo;\n\t\tx>>=1;\n\t}\n\treturn ans;\n}\nint C(int n,int m){return (long long)fac[n]*nifac[m]%mo*nifac[n-m]%mo;}\nint main()\n{\n\tint n,k;scanf(\"%d%d\",&n,&k);\n\tfac[0]=1;for (int i=1;i<=n*n;i++) fac[i]=(long long)fac[i-1]*i%mo;\n\tnifac[n*n]=getmi(fac[n*n],mo-2);\n\tfor (int i=n*n-1;i>=0;i--) nifac[i]=(long long)nifac[i+1]*(i+1)%mo;\n\tdp[0][0]=1;\n\tfor (int i=0;i<=n;i++)\n\tfor (int j=0;j<=n;j++)\n\t{\n\t\tif (i) dp[i][j]=dp[i-1][j];\n\t\tif ((i!=j)&&(j)) dp[i][j]=(dp[i][j]+(long long)dp[i][j-1]*C(i+j*(k-1)-1,k-2))%mo;\n\t}\n\tprintf(\"%d\\n\",(long long)fac[n]*dp[n][n]%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize (\"Ofast\")\nusing namespace std;\n/// khodaya komak kon\n/// ya navid navid\nconst int N=2001*2001+3;\nll mod=1e9+7;\nll dp[2001][2001];\nll fac[N];\nll power(ll n, ll k){\n    if (k==0){\n        return 1;\n    }\n    else{\n        if (k%2==0){\n            ll x=power(n,k/2);\n            return x*x%mod;\n        }\n        else{\n            ll x=power(n,k/2);\n            x=x*x%mod;\n            return x*n%mod;\n        }\n    }\n}\nll fm[N];\nll ent(ll k, ll n){\n\tif (k==0 || k==n){\n        return 1;\n\t}\n\n\treturn (((fac[n]*fm[k])%mod)*fm[n-k])%mod;\n}\nll pd[N];\nint32_t main(){\n    fac[0] = 1;\n\n\tfor(int i=1;i<N;i++) {\n        fac[i]=(fac[i-1]*i)%mod;\n\t}\n\tfor(int i=0;i<N;i++) {\n        fm[i]=power(fac[i],mod-2);\n\t}\n\tll ans=1;\n    ll n,k;\n    cin >> n >> k;\n    if (k==1){\n        cout << 1 << endl;\n        return 0;\n    }\n //   dp[0]=1;\n   // dp[1]=1;\n    dp[0][0]=1;\n    for (int i=1;i<=n;i++){\n        for (int j=i;j>0;j--){\n            dp[i][j]=dp[i][j+1];\n            dp[i][j]+=dp[i-1][j-1]*ent(k-2,i*k-j-1)%mod*i%mod;\n            dp[i][j]%=mod;\n        //cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n        }\n        dp[i][0]=dp[i][1];\n    }\n    cout << dp[n][1] << endl;\n    /*\n    for (int i=2;i<=n;i++){\n        ll p1=1;\n        for (int j=1;j<=i;j++){\n            dp[i]+=ent(j,i)*ent((k-1)*j-1,i*k-j-1)%mod*pd[j]%mod*dp[i-j]%mod;\n           // dp[i]+=(n-i+1)*ent(k-2,i*k-2)%mod*dp[i-1]%mod;\n            //dp[i]+=(n-i+1)*ent(k-1,i*k-2)%mod*dp[i-1]%mod*fm[2]%mod;\n            cout << i << \" \" << j << \" \" << dp[i] << endl;\n            dp[i]%=mod;\n        }\n    }\n    cout << dp[n] << endl;\n    */\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nThough leaves are many , the root is one.\nThrough all the lying days of my youth\nI swayed my leaves and flowers in the sun.\nNow I may wither into the truth.\n\t  \t  \t- William Butler Yeats\n*/\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n#pragma GCC target(\"avx,tune=native\")\n#include<bits/stdc++.h>\n#pragma comment(\"-Wl,--stack=1024000000\")\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\ntypedef long long ll;\n#ifndef LOCAL\n#define cerr if(0)cout\n#define eprintf(...) 0\n#else\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#endif\ninline string getstr(string &s,int l,int r){string ret=\"\";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){int ret=1;do{if(y&1)ret=(ll)ret*x%md;x=(ll)x*x%md;}while(y>>=1);return ret;}\ninline int Rand(){return rand()*32768+rand();}\nint dp[2005][2005],fact[4000005],inv[4000005];\ninline int C(int nn,int mm){\n\treturn (ll)fact[nn]*inv[mm]%mod*inv[nn-mm]%mod;\n}\ninline void add(int &x,int y){\n\tx+=y;if(x>=mod)x-=mod;\n}\nint main(){\n\tfact[0]=1;\n\tfor(int i=1;i<=4e6;i++)fact[i]=(ll)fact[i-1]*i%mod;\n\tinv[4000000]=modpow(fact[4000000],mod-2);\n\tfor(int i=4e6-1;i>=0;i--)inv[i]=(ll)inv[i+1]*(i+1)%mod;\n\tint n,k;cin>>n>>k;\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tdp[i][j]=(dp[i-1][j]+(!j?0ll:1ll*dp[i][j-1]*C(n-i+n-j+(n-j+1)*(k-2),k-2)%mod))%mod;\n//\t\t\tcerr<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n\t\t}\n\t}\n\tcout<<(ll)dp[n][n]*fact[n]%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconst int NMAX = 2000 + 5;\nconst int MOD = 1000000000 + 7;\n\nint raise(int a, int b) {\n    if (!b)\n        return 1;\n    else if (b & 1)\n        return (1LL * a * raise(a, b - 1)) % MOD;\n    else {\n        int aux = raise(a, b >> 1);\n        return (1LL * aux * aux) % MOD;\n    }\n}\n\nint inv(int nr) {\n    return raise(nr, MOD - 2);\n}\n\nint facts[NMAX * NMAX];\nint invFacts[NMAX * NMAX];\n\nvoid precalcFacts() {\n    facts[0] = 1;\n    for (int i = 1; i < NMAX * NMAX; ++ i)\n        facts[i] = (1LL * i * facts[i - 1]) % MOD;\n\n    invFacts[NMAX * NMAX - 1] = inv(facts[NMAX * NMAX - 1]);\n    for (int i = NMAX * NMAX - 2; i >= 0; -- i)\n        invFacts[i] = ((i + 1LL) * invFacts[i + 1]) % MOD;\n}\n\ninline int choose(int n, int k) {\n    return ((1LL * facts[n] * invFacts[k]) % MOD * invFacts[n - k]) % MOD;\n}\n\nint dp[NMAX][NMAX];\n\nint main()\n{\n    precalcFacts();\n\n    int N, K;\n    cin >> N >> K;\n\n    K --;\n    if (K == 0) {\n        cout << \"1\\n\";\n        return 0;\n    }\n\n    dp[0][0] = 1;\n    for (int i = 0; i <= N; ++ i)\n        for (int j = i; j <= N; ++ j)\n            if (i + j) {\n                //We have i 0s left to place and j firsts to place\n                if (i) //Place a 0\n                    dp[i][j] = dp[i - 1][j];\n                //Place a first\n                dp[i][j] = (dp[i][j] + (1LL * dp[i][j - 1] * j) % MOD * choose(i + K * j - 1, K - 1)) % MOD;\n            }\n\n    cout << dp[N][N] << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7 , MAXN = 5e6 + 10;\nint fac[MAXN] , finv[MAXN];\nint f[2020][2020];\nint n , k;\nvoid init(){\n\tfac[0] = finv[0] = fac[1] = finv[1] = 1;\n\tfor(int i = 2 ; i <= 5000000 ; ++ i)\n\t\tfac[i] = 1ll * i * fac[i - 1] % MOD;\n\tfor(int i = 2 ; i <= 5000000 ; ++ i)\n\t\tfinv[i] = MOD - 1ll * (MOD / i) * finv[MOD % i] % MOD;\n\tfor(int i = 1 ; i <= 5000000 ; ++ i)\n\t\tfinv[i] = 1ll * finv[i - 1] * finv[i] % MOD;\n}\nint C(int x , int y){\n\treturn 1ll * fac[x] * finv[y] % MOD * finv[x - y] % MOD;\n}\nint main(){\n\tcin >> n >> k;\n\tif(k == 1){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tinit();\n\tf[0][0] = 1;\n\tfor(int i = 1 ; i <= n ; ++ i){\n\t\tfor(int j = 1 ; j < i ; ++ j)\n\t\t\tf[i - 1][j] = (f[i - 1][j] + f[i - 1][j - 1]) % MOD;\n\t\tfor(int j = 0 ; j < i ; ++ j)\n\t\t\tf[i][j] = 1ll * f[i - 1][j] * C(i * (k - 1) + j - 1 , k - 2) % MOD;\n\t}\n\tint ans = 0;\n\tfor(int i = 0 ; i < n ; ++ i)\n\t\tans = (ans + f[n][i]) % MOD;\n\tcout << 1ll * ans * fac[n] % MOD << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define LD long double\n#define DD double\n#define inf 1000000000\n#define eps 0.000001\n#define maxn 2000\n#define mod 1000000007\nusing namespace std;\n\nint n, k, inv[maxn * maxn + 1], fac[maxn * maxn + 1];\nint f[maxn + 1][maxn + 1];\n\nvoid read(int &x){\n\tchar ch;\n\tbool ok;\n\tfor(ok = 0, ch = getchar(); !isdigit(ch); ch = getchar()) if(ch == '-') ok = 1;\n\tfor(x = 0; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\tif(ok) x = -x;\n}\n\nint c(int x, int y){\n\tif(x < y) return 0;\n\treturn 1ll * fac[x] * inv[y] % mod * inv[x - y] % mod;\n}\n\nint main(){\n\tread(n); read(k);\n\tif(k == 1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tinv[0] = inv[1] = fac[0] = fac[1] = 1;\n\tfor(int i = 2; i <= n * k; ++i) inv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod;\n\tfor(int i = 2; i <= n * k; ++i){\n\t\tinv[i] = 1ll * inv[i - 1] * inv[i] % mod;\n\t\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\t}\n\tf[0][0] = 1;\n\tfor(int i = 1; i <= n; ++i){\n\t\tfor(int j = 0; j <= i; ++j){\n\t\t\tif(j) f[i][j] = (1ll * f[i][j] + f[i][j - 1]) % mod;\n\t\t\tf[i][j] = (1ll * f[i][j] + 1ll * f[i - 1][j] * (n - (i - 1)) % mod * c((i - 1) * (k - 1) + j + k - 2, k - 2) % mod) % mod;\n\t\t}\n\t}\n//\tcout << c() << endl;\n\tprintf(\"%d\\n\", f[n][n]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<sstream>\n#include<algorithm>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<iomanip>\n#include<utility>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n#define rg register\n#define il inline\n#define lch(x) ((x)<<1)\n#define rch(x) ((x)<<1^1)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define rep0(i,n) for(register int i=0;i<(n);++i)\n#define per0(i,n) for(register int i=(n)-1;i>=0;--i)\n#define rep(i,st,ed) for(register int i=(st);i<=(ed);++i)\n#define per(i,ed,st) for(register int i=(ed);i>=(st);--i)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef double dbl;\ntypedef long double ldb;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<typename T> il T qmin(const T &a,const T &b){return a<b?a:b;}\ntemplate<typename T> il T qmax(const T &a,const T &b){return a>b?a:b;}\ntemplate<typename T> il void getmin(T &a,const T &b){if(a>b) a=b;}\ntemplate<typename T> il void getmax(T &a,const T &b){if(a<b) a=b;}\nil void fileio(string s){\n\tfreopen((s+\".in\").c_str(),\"r\",stdin);\n\tfreopen((s+\".out\").c_str(),\"w\",stdout);\n}\n\nconst int mod=(int)1e9+7;\nconst ll linf=(ll)1e17+7;\nconst int N=2005,mx=N*N+N;\n\nll fac[mx+1],inv[mx+1];\nint n,k,f[N][N];\n\nil void inc(int &x,const int &y){\n\tx+=y;\n\tif(x>=mod) x-=mod;\n}\n\nil int c(int n,int k){\n\treturn fac[n]*inv[n-k]%mod*inv[k]%mod;\n}\n\nint main(){\n\tinv[1]=1;\n\trep(i,2,mx) inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\tfac[0]=inv[0]=1;\n\trep(i,1,mx){\n\t\tfac[i]=fac[i-1]*i%mod;\n\t\tinv[i]=inv[i-1]*inv[i]%mod;\n\t}\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1) return puts(\"1\"),0;\n\t--k;\n\tf[0][0]=1;\n\trep(i,1,n){\n\t\tf[i][0]=(ll)f[i-1][0]*c(i*k-1,k-1)%mod;\n\t\trep(j,1,i){\n\t\t\tf[i][j]=f[i][j-1];\n\t\t\tinc(f[i][j],(ll)f[i-1][j]*c(i*k+j-1,k-1)%mod);\n\t\t}\n\t} \n\tprintf(\"%d\\n\",fac[n]*f[n][n]%mod); \n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fastcall __attribute__((optimize(\"-O3\")))\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"inline\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-fipa-sra\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-ffast-math\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fdevirtualize\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"inline-functions\")\n#pragma GCC optimize(\"-ftree-tail-merge\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fpartial-inlining\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-fhoist-adjacent-loads\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"inline-small-functions\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"inline-functions-called-once\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#define int long long\nusing namespace std; \nint n,k,ans,dp[2001][2001],a[4000001],b[4000001],mod=1e9+7;\ninline int read()\n{\n    int sum=0,x=1;\n    char ch=getchar();\n    while (!isdigit(ch))\n\t{\n        if (ch=='-')\n\t\t  x=-1;\n        ch=getchar();\n    }\n    while (isdigit(ch))\n\t{\n        sum=(sum<<1)+(sum<<3)+(ch^'0');\n        ch=getchar();\n    }\n    return sum*x;\n}\ninline void write(int x)\n{\n    if (x<0)\n\t{\n        putchar('-');\n        x=-x;\n    }  \n    if (x>9)\n      write(x/10);\n    putchar(x%10+'0');\n}\ninline int power(int x,int y)\n{\n    int s=1;\n    for (;y;y>>=1,x=x*x%mod)\n      if (y&1)\n\t\ts=s*x%mod;\n    return s;\n}\nsigned main()\n{\n    n=read();k=read();\n    if (k<2)\n    {\n        write(1);\n        return 0;\n    }\n    a[0]=b[0]=1;\n    for (register int i=1;i<=n*k;++i)\n    {\n    \ta[i]=a[i-1]*i%mod;\n\t\tb[i]=power(a[i],mod-2);\n\t}\n    dp[0][0]=1;\n    for (register int i=1;i<=n;++i)\n      for (register int j=i;j>=0;--j)\n        if (k*i-j>=k-1)\n          (dp[i][j]+=dp[i-1][j-1]*a[k*i-j-1]*b[k-2]%mod*b[k*i-j-k+1]%mod+dp[i][j+1])%=mod;else\n          (dp[i][j]+=dp[i][j+1])%=mod;\n    write(dp[n][0]*a[n]%mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 5e6 + 10, mod = 1e9 + 7;\n\nll pw(ll a, ll b) {\n    ll r = 1;\n    for( ; b ; b >>= 1, a = a * a % mod) {\n        if(b & 1) {\n            r = r * a % mod;\n        }\n    }\n    return r;\n}\nll fac[N], invfac[N];\nvoid init(int n) {\n    fac[0] = invfac[0] = 1;\n    for(int i = 1 ; i <= n ; ++ i) {\n        fac[i] = fac[i - 1] * i % mod;\n    }\n    invfac[n] = pw(fac[n], mod - 2);\n    for(int i = n - 1 ; i ; -- i) {\n        invfac[i] = invfac[i + 1] * (i + 1) % mod;\n    }\n}\nll C(int n, int m) {\n    return n < m || m < 0 ? 0 : fac[n] * invfac[m] % mod * invfac[n - m] % mod;\n}\n\nint n, k;\nll f[2010][2010];\nvoid upd(ll &x, ll y) {\n    x = (x + y) % mod;\n}\n\nint main() {\n    init(N - 1);\n    scanf(\"%d%d\", &n, &k);\n    if(! -- k) {\n        puts(\"1\");\n    } else {\n        f[0][0] = 1;\n        for(int i = 0 ; i <= n ; ++ i) {\n            for(int j = i ; j <= n ; ++ j) {\n                if(j) {\n                    if(i - 1 >= 0) {\n                        upd(f[i][j], f[i - 1][j]);\n                    }\n                    upd(f[i][j], f[i][j - 1] * C(i + (j - 1) * k + k - 1, k - 1) % mod);\n                }\n            }\n        }\n        printf(\"%lld\\n\", f[n][n] * fac[n] % mod);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int L=4000005,N=2005,M=1e9+7;\nint fac[L],inv[L],dp[N][N],n,m;\nint ksm(int x,int y){\n\tif (!y)return 1;\n\tint z=ksm(x,y/2);\n\tz*=z;z%=M;\n\tif (y&1)z*=x;\n\treturn z%M;\n}\nint C(int x,int y){\n\treturn fac[x]*inv[y]%M*inv[x-y]%M;\n}\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tif (!m){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=inv[0]=1;\n\tfor (int i=1;i<L;i++)fac[i]=fac[i-1]*i%M;\n\tinv[L-1]=ksm(fac[L-1],M-2);\n\tfor (int i=L-2;i>=0;i--)inv[i]=(i+1)*inv[i+1]%M;\n\tdp[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=0;j<=i;j++)\n\t\t\tdp[i][j]=((j>0?dp[i][j-1]:0)+dp[i-1][j]*C((i-1)*m-(i-j-1)+m-2,m-2))%M;\n\tprintf(\"%lld\\n\",dp[n][n]*fac[n]%M);\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF=1000000000,mod=1e9+7;\nconst double eps = 1e-7;\n\nint f[2001][2001],c[5000000];\n\nint inv(int a,int m)\n{\n\tif(a==1)\n\t\treturn 1;\n\treturn (long long)(inv(m%a,m))*(m-m/a)%m;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\",\"r\",stdin);\n\tint t;\n\tint n,m,q;\n//\tcin>>t;\n//\twhile(t--)\n//\twhile(scanf(\"%d\",&n)!=EOF) \n\t{\n\t\tcin>>n>>m;\n\t\tf[0][0]=1;\n\t\tf[0][1]=1;\n\t\tc[m-2]=1;\n\t\tfor(int i=m-1;i<=n*m;i++)\n\t\t\tc[i]=(long long)c[i-1]*i%mod*inv(i-m+2,mod)%mod;\n\t\tfor(int i=2;i<=n;i++)\n\t\t\tf[0][i]=(long long)f[0][i-1]*c[i*(m-1)-1]%mod;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=i;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tf[i][j]=f[i-1][j];\n\t\t\t\telse\n\t\t\t\t\tf[i][j]=(f[i-1][j]+(long long)f[i][j-1]*c[i*m+(j-i)*(m-1)-1]%mod)%mod;\n\t\t\t}\n//\t\tfor(int i=1;i<=n;i++)\n//\t\t\tfor(int j=i;j<=n;j++)\n//\t\t\t\tcout<<i<<' '<<j<<' '<<f[i][j]<<endl;\n\t\tlong long ans=f[n][n];\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tans=ans*i%mod;\n\t\tcout<<ans<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#define rep(i,a,b) for(int i = a; i <= b; i++)\n#define dep(i,a,b) for(int i = a; i >= b; i--)\n#define Rep(i,a) for(int i = 0; i < a; i++)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\n#define x first\n#define y second\n#define pb(a) push_back(a)\nconst int N = 2010, mod = 1e9 + 7;\nint n, k, f[N][N], fac[N * N], inv[N * N];\nint C(int n, int m) { return 1LL * fac[n] * inv[n - m] % mod * inv[m] % mod; }\nint pw(int a, int b) { \n\tint w = 1; \n\tfor(;b; b >>= 1, a = 1LL * a * a % mod) \n\t\tif (b & 1) w = 1LL * w * a % mod; \n\treturn w; \n}\nint main() {\n\tscanf(\"%d%d\",&n,&k);\n\tif (k == 1) { printf(\"1\\n\"); return 0; } \n\tf[0][0] = 1;\n\tfac[0] = 1; rep(i,1,N * N - 1) fac[i] = 1LL * fac[i - 1] * i % mod;\n\tinv[N * N - 1] = pw(fac[N * N - 1], mod - 2);\n\tdep(i,N * N - 2,0) inv[i] = 1LL * (i + 1) * inv[i + 1] % mod;\n\n\trep(i,0,n - 1) rep(j,0,n) if (f[i][j]) {\n\t\tif (j < n) (f[i][j + 1] += f[i][j]) %= mod;\n\t\tif (j) f[i + 1][j - 1] = (f[i + 1][j - 1] + 1LL * C(k * (n - i) - j - 1, k - 2) * (n - i) % mod * f[i][j]) % mod; \n\t}\n\tprintf(\"%d\\n\",f[n][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/// {{{ Author: Wang, Yen-Jen\n// include\n#include <bits/stdc++.h>\n\n// using\nusing namespace std;\n\n// types\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\n// macro\n#define SZ(x) ((int)x.size())\n#define ALL(x) (x).begin() , (x).end()\n#define REP(i , n) for(int i = 0; i < int(n); i++)\n#define REP1(i , a , b) for(int i = a; i <= int(b); i++)\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define LC o<<1 , l , m\n#define RC o<<1|1 , m + 1 , r\n#define MS(x , v) memset(x , (v) , sizeof(x))\n\n// input\ninline bool SR(int &x) {\n  return scanf(\"%d\",&x) == 1;\n}\n\ninline bool SR(ll &x) {\n  return scanf(\"%lld\",&x) == 1;\n}\n\ninline bool SR(double &x) {\n  return scanf(\"%lf\",&x) == 1;\n}\n\ninline bool SR(char *s) {\n  return scanf(\"%s\",s) == 1;\n}\n\ninline bool RI() {\n  return true;\n}\n\ntemplate<typename I , typename... T> inline bool RI(I &x , T&... tail) {\n  return SR(x) && RI(tail...);\n}\n\n// output\ninline void SP(const int x) {\n  printf(\"%d\",x);\n}\n\ninline void SP(const ll x) {\n  printf(\"%lld\",x);\n}\n\ninline void SP(const double x) {\n  printf(\"%.16lf\",x);\n}\n\ninline void SP(const char *s) {\n  printf(\"%s\",s);\n}\n\ninline void PL() {\n  puts(\"\");\n}\n\ntemplate<typename I , typename... T> inline void PL(const I x , const T... tail) {\n  SP(x);\n  if(sizeof...(tail)) putchar(' ');\n  PL(tail...);\n}\n\n// debug\n#define WangYenJen\n\n#ifdef WangYenJen\ntemplate<typename I> void _DOING(const char *s , I&& x) {\n  cerr << s << \" = \" << x << endl;\n}\n\ntemplate<typename I , typename... T> void _DOING(const char *s , I&& x , T&&... tail) {\n  int c = 0;\n  while(*s != ',' || c != 0) {\n    if(*s == '(' || *s == '[' || *s == '{') c++;\n    if(*s == ')' || *s == ']' || *s == '}') c--;\n    cerr << *s++;\n  }\n  cerr << \" = \" << x << \" , \";\n  _DOING(s + 1 , tail...);\n}\n\n#define DEBUG(...) \\\ndo {\\\n  fprintf(stderr , \"%s: Line %d - \",__PRETTY_FUNCTION__,__LINE__);\\\n  _DOING(#__VA_ARGS__ , __VA_ARGS__);\\\n} while(0);\n\n#else\n#define DEBUG(...)\n\n#endif\n\n// constant number\nconst int INF = 0x3f3f3f3f;\nconst ll INF64 = 0x3f3f3f3f3f3f3f3fll;\n\n// random function\ninline int RAND() {\n  static int x = 880301;\n  return (x = x * 0xdefaced + 1) % 0x7fffffff;\n}\n/// }}}\n\nconst int MAX_N = 2000 + 7;\nconst ll MOD = 1000000000 + 7;\n\nll K;\nll dp[MAX_N][MAX_N];\nll fact[MAX_N * MAX_N];\n\nll power(ll a, ll n) {\n  ll x = 1;\n  while (n) {\n    if (n & 1) x = x * a % MOD;\n    a = a * a % MOD;\n    n >>= 1;\n  }\n  return x;\n}\n\nll inv(ll x) {\n  return power(x, MOD - 2);\n}\n\nll C(ll n, ll m) {\n  if (n < m) return 0;\n  else return fact[n] * inv(fact[n - m] * fact[m] % MOD) % MOD;\n}\n\nll dfs(int x, int y) {\n  ll &res = dp[x][y];\n  if (res != -1) return res;\n  if (x == 0 && y == 0) return 1;\n  res = 0;\n  if (x > 0) {\n    res += dfs(x - 1, y);\n    if (res >= MOD) res -= MOD;\n  }\n  if (y > x) {\n    res += C(x + y * (K - 1) - 1, K - 2) * dfs(x, y - 1) % MOD;\n    if (res >= MOD) res -= MOD;\n  }\n  return res;\n}\n\nint main() {\n  fact[0] = 1;\n  REP1(i, 1, MAX_N * MAX_N - 1) fact[i] = fact[i - 1] * i % MOD;\n  int N;\n  RI(N, K);\n  if (K == 1) PL(1);\n  else {\n    MS(dp, -1);\n    PL(dfs(N, N) * fact[N] % MOD);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 2e3 + 32, M = 4e6 + 64, P = 1e9 + 7;\n\nint pw(int x, int y) {\n\tint r = 1;\n\tfor (; y; y >>= 1, x = 1ll * x * x % P)\n\t\tif (y & 1) r = 1ll * r * x % P;\n\treturn r;\n}\n\nint fac[M], ifac[M];\nint c(int n, int m) { return 1ll * n[fac] * m[ifac] % P * (n - m)[ifac] % P; }\n\nint n, k, dp[N][N];\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tif (k == 1) return puts(\"1\"), 0;\n\t0 [fac] = 0 [ifac] = 1;\n\tfor (int i = 1; i <= n * k; i++) i[fac] = 1ll * (i - 1)[fac] * i % P;\n\t(n * k)[ifac] = pw((n * k)[fac], P - 2);\n\tfor (int i = n * k - 1; i >= 1; i--) i[ifac] = 1ll * (i + 1)[ifac] * (i + 1) % P;\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int j = 0; j <= i; j++)\n\t\t\tif (i || j)\n\t\t\t\tdp[i][j] = (dp[i - 1][j] +\n\t\t\t\t\t\t\t(n - j + 1ll) * c(n * k - i - (j - 1) * (k - 1) - 1, k - 2) %\n\t\t\t\t\t\t\t\tP * dp[i][j - 1]) %\n\t\t\t\t\t\t   P;\n\t\t\telse\n\t\t\t\tdp[0][0] = 1;\n\tprintf(\"%d\", dp[n][n]);\n}"
  },
  {
    "language": "C++",
    "code": "                                // ALLAH \\\\\n                        who is Hussain? -> whoishussain.org\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,n,a) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define aLL(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long LL;\ntypedef pair<int,int> PII;\nconst int mod=1000000007;\nLL powmod(LL a,LL b) {LL res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nint in(){ int x; scanf(\"%d\",&x); return x; }\nconst int N = 4e6;\nint n, k, fact[N], dp[2001][2001];\nint C(int n, int nn){\n        return 1ll*fact[n]*powmod(fact[nn],mod-2)%mod * powmod(fact[n-nn],mod-2)%mod;\n}\nint32_t main(){\n        cin >>n >> k;\n        if( k == 1 ) return cout << 1 << endl,0;\n        int ans = 1;\n        fact[0] = 1;\n        for(int i = 1; i < N; i++)\n                fact[i] = 1ll*fact[i-1]*i%mod;\n        dp[1][0] = dp[0][0] =  1;\n        for(int i = 1;i <= n;i ++)\n        {\n                dp[i][i] = (dp[i-1][i] + 1ll*dp[i-1][i-1]*C(i*(k-1)+i-2,k-2)%mod)%mod; \n               for(int j = i+1; j <= n; j++){\n                       dp[i][j] = (dp[i-1][j] + 1ll*dp[i][j-1]*C(j*(k-1)+i-2,k-2)%mod)%mod; \n               } \n        }\n        cout << 1ll*dp[n][n]*fact[n]%mod << endl;\n}\n\n// C/C++ File\n// AUTHOR:   truth-seeker\n// FILE:     le.cpp\n// ROLE:     TODO (some explanation)\n// CREATED:  2017-01-20 16:56:08\n// MODIFIED: 2017-01-20 16:56:08\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i, l, r) for(int i = (l), _end_ = (int)(r); i <= _end_; ++i)\n#define f(i, r, l) for(int i = (r), _end_ = (int)(l); i >= _end_; --i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define file(a) freopen(a\".in\",\"r\",stdin),freopen(a\".out\",\"w\",stdout)\nusing namespace std;\n\ntemplate<typename T>bool chkmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool chkmin(T &a,T b){return (a>b)?a=b,1:0;}\n\ninline int read() {\n int x = 0, fh = 1; char ch = getchar();\n    for (; !isdigit(ch); ch = getchar() ) if (ch == '-') fh = -1;\n    for (; isdigit(ch); ch = getchar() ) x = (x<<1) + (x<<3) + (ch ^ '0');\n    return x * fh;\n}\nint n,k;\nint dp[2005][2005];\nconst int mod=1e9+7;\nlong long qpow(long long x,long long y){\n    long long res=1;\n\twhile(y){\n\t    if(y&1)res=res*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint ff[2005*2500],inv[2005*2500];\nint main () {\n#ifndef ONLINE_JUDGE\n//file(\"agc002f\");\n#endif\n    n=read();k=read();\n\tk--;\n\tif(!k){\n\t  puts(\"1\");\n\t  return 0;\n\t}\n\tff[0]=1;\n\tF(i,1,n*k+n+k)ff[i]=1ll*i*ff[i-1]%mod;\n\tinv[n*k+n+k]=qpow(ff[n*k+n+k],mod-2);\n\tf(i,n*k+n+k-1,0)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tdp[0][0]=1;\n\tF(i,0,n){\n\t   F(j,i,n){\n\t     if(i)dp[i][j]=dp[i-1][j];\n\t\t if(j)dp[i][j]=(dp[i][j]+1ll*dp[i][j-1]*inv[k-1]%mod*ff[i+(j-1)*k+k-1]%mod*inv[i+(j-1)*k]%mod)%mod;\n\t   }\n\t}\n\tprintf(\"%lld\\n\",1ll*dp[n][n]*ff[n]%mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#define ll long long\n#define re register\n#define il inline\n#define fp(i,a,b) for(re int i=a;i<=b;++i)\n#define fq(i,a,b) for(re int i=a;i>=b;--i)\nusing namespace std;\nconst int N=2010,mod=1e9+7;\nint n,k,f[N][N],jc[N*N],inv[N*N],gu;\nil int gi()\n{\n  re int x=0,t=1;\n  re char ch=getchar();\n  while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n  if(ch=='-') t=-1,ch=getchar();\n  while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();\n  return x*t;\n}\nil ll ksm(re ll S,re ll n)\n{\n\tre ll T=S;S=1;\n  while(n)\n\t{\n\t\tif(n&1) S=S*T%mod;\n\t\tT=T*T%mod;\n\t\tn>>=1;\n\t}\n  return S;\n}\nil ll C(re int x,re int y)\n{\n\tif(x<0||y<0||x<y) return 0;\n\treturn 1ll*jc[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main()\n{\n  n=gi();k=gi();gu=n*n;\n\tif(k==1) {puts(\"1\");return 0;}\n\tjc[0]=inv[0]=1;\n\tfp(i,1,gu) jc[i]=1ll*jc[i-1]*i%mod;inv[gu]=ksm(jc[gu],mod-2);\n\tfq(i,gu-1,1) inv[i]=1ll*inv[i+1]*(i+1)%mod;\n  f[0][0]=1;\n\tfp(i,1,n)\n\t\tfp(j,0,i)\n\t{\n\t\t(f[i][j]+=f[i-1][j])%=mod;\n\t\tif(j) (f[i][j]+=C(n*k-(j-1)*(k-1)-i-1,k-2)*f[i][j-1]%mod*(n-j+1)%mod)%=mod;\n\t}\n  printf(\"%d\\n\",f[n][n]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int L=4000005,N=2005,M=1e9+7;\nint fac[L],inv[L],dp[N][N],n,m;\nint ksm(int x,int y){\n\tif (!y)return 1;\n\tint z=ksm(x,y/2);\n\tz*=z;z%=M;\n\tif (y&1)z*=x;\n\treturn z%M;\n}\nint C(int x,int y){\n\treturn fac[x]*inv[y]%M*inv[x-y]%M;\n}\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tfac[0]=inv[0]=1;\n\tfor (int i=1;i<N;i++)fac[i]=fac[i-1]*i%M;\n\tinv[N-1]=ksm(fac[N-1],M-2);\n\tfor (int i=N-2;i>=0;i--)inv[i]=(i+1)*inv[i+1]%M;\n\tdp[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=0;j<=i;j++)\n\t\t\tdp[i][j]=((j>0?dp[i][j-1]:0)+dp[i-1][j]*C((i-1)*m-(i-j-1)+m-2,m-2))%M;\n\tprintf(\"%lld\\n\",dp[n][n]*fac[n]%M);\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define ll long long\n#define rep(i,j,k) for (i=j;i<=k;i++)\n#define down(i,j,k) for (i=j;i>=k;i--)\nusing namespace std;\nconst int N=2e3+5,B=4e6+5,mod=1e9+7;\nint n,k,i,j,ans,f[N][N],fac[B],inv[B];\nint fgm(int a,int n)\n{\n\tint ret=1,bsc=a;\n\tfor (;n>0;n>>=1,bsc=(ll)bsc*bsc%mod)\n\tif (n&1) ret=(ll)ret*bsc%mod;\n\treturn ret;\n}\nint C(int n,int m)\n{\n\tif (n<m) return 0;\n\tif (!m || !(n-m)) return 1;\n\treturn (ll)fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main()\n{\n//\tfreopen(\"leftmost.in\",\"r\",stdin);\n//\tfreopen(\"leftmost.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&k);\n\tif (k==1) {\n\t\tprintf(\"1\\n\"); return 0;\n\t}\n\n\tfac[1]=fac[0]=inv[1]=inv[0]=1; \n\trep(i,2,n*k) fac[i]=(ll)fac[i-1]*i%mod;\n\tinv[n*k]=fgm(fac[n*k],mod-2);\n\tdown(i,n*k-1,2)\tinv[i]=(ll)(i+1)*inv[i+1]%mod;\n\t\n\tf[0][0]=1;\n\trep(i,0,n)\n\t\trep(j,i,n)\n\t\t{\n\t\t\tif (i>0) f[i][j]=f[i-1][j];\n\t\t\tif (j>0 && i<j) f[i][j]=(f[i][j]+(ll)f[i][j-1]*C(j*(k-1)+i-1,k-2) )%mod;\n\t\t}\n\tans=(ll)f[n][n]*fac[n]%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define N 4000005\n#define MOD 1000000007\nusing namespace std;\nint n,k,f[2005][2005],inv[N],fac[N],infac[N];\nint C(int x,int y){\n\treturn x>=y ? fac[x]*infac[y]%MOD*infac[x-y]%MOD : 0;\n}\nsigned main(){\n\tcin>>n>>k;\n\tif(k==1){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tfac[0]=infac[0]=inv[1]=1;//first deal\n\tfor(int i=1;i<=n*k;i++)\n\t\tfac[i]=fac[i-1]*i%MOD;\n\tfor(int i=2;i<=n*k;i++)\n\t\tinv[i]=inv[MOD%i]*(MOD-MOD/i)%MOD;\n\tfor(int i=1;i<=n*k;i++)\n\t\tinfac[i]=infac[i-1]%MOD*inv[i]%MOD;\n\tfor(int i=1;i<=n;i++)\n\t\tf[i][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=i;j++){\n//\t\t\tcout<<i<<\" \"<<j<<\"*\"<<\"%\"<<C(k-2,(n-i)+(n-j+1)*(k-1)-1)<<endl;\n\t\t\tf[i][j]=(f[i-1][j]+C((n-i)+(n-j+1)*(k-1)-1,k-2)*f[i][j-1]%MOD*(n-j+1)%MOD)%MOD;\n//\t\t\tcout<<f[1][1]<<endl;\n\t\t}\n\t}\n\tcout<<f[n][n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#define debug(x) cout<<#x<<\"=\"<<x<<endl;\n#define chk() cout<<C((n-j+1)*(k-1)+(n-i)-1,k-2)<<endl;\nusing namespace std;\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())if(ch=='-')f=-1;\n\tfor(;isdigit(ch);ch=getchar())x=(x<<3)+(x<<1)+(ch^'0');\n\treturn x*f;\n}\nconst int maxn=2010;\nconst int mod=1e9+7;\nint ifac[maxn*maxn],fac[maxn*maxn],inv[maxn*maxn];\nint f[maxn][maxn];\ninline int C(int n,int m){\n\tif(m==0)return 1;\n\tif(n<m)return 0;\n\treturn 1ll*fac[n]*ifac[n-m]%mod*ifac[m]%mod;\n}\nint n,k;\ninline void init(){\n\tn=read(),k=read();\n\tif(n==0 || k==0)printf(\"0\"),exit(0);\n\tif(k==1)puts(\"1\"),exit(0);\n\tinv[0]=inv[1]=1;\n\tfor(register int i=2;i<=maxn*maxn;++i)\n\t\tinv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\tfac[0]=fac[1]=1;\n\tfor(register int i=2;i<=maxn*maxn;++i)\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\tifac[0]=ifac[1]=1;\n\tfor(register int i=1;i<=maxn*maxn;++i)\n\t\tifac[i]=1ll*ifac[i-1]*inv[i]%mod;\n\n}\ninline void solve(){\n\tf[1][0]=1;\n\tfor(register int i=0;i<=n;++i)\n\t\tfor(register int j=0;j<=i;++j){\n\t\t\tif(i)(f[i][j]+=f[i-1][j])%=mod;\n\t\t\tif(j)(f[i][j]+=1ll*C((n-j+1)*(k-1)+(n-i)-1,k-2)*f[i][j-1]%mod)%=mod;\n\t\t}\n\tcout<<1ll*f[n][n]*fac[n]%mod;\n}\nint main(){\n\tinit();\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define taskname \"A\"\n#define pb  push_back\n#define mp  make_pair\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> ii;\nconst int maxn = 2e3 + 5;\nconst int maxm = maxn * maxn;\nconst int mod = 1e9 + 7;\nint n , k , dp[maxn][maxn];\nint f[maxm] , rf[maxm];\nint C(int n , int k){\n    if(k < 0 || n < 0)return 0;\n    return (ll)f[n] * rf[n - k] % mod * rf[k] % mod;\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\",\"r\")){\n        freopen(taskname\".INP\", \"r\",stdin);\n        freopen(taskname\".OUT\", \"w\",stdout);\n    }\n    cin >> n >> k;\n    dp[0][0] = 1;\n    f[0] = f[1] = rf[0] = rf[1] = 1;\n    for(int i = 2 ; i < maxm ; ++i){\n        f[i] = (ll)f[i - 1] * i % mod;\n        rf[i] = (mod - (ll)(mod / i) * rf[mod % i] % mod);\n    }\n    for(int i = 2 ; i < maxm ; ++i)rf[i] = (ll)rf[i - 1] * rf[i] % mod;\n    for(int i = 0 ; i <= n ; ++i){\n        for(int j = 0 ; j <= n ; ++j){\n            if(i == 0 && j == 0)continue;\n            if(i > j)continue;\n            if(i > 0)dp[i][j] = dp[i - 1][j];\n            if(j > 0)dp[i][j] += (ll)dp[i][j - 1] * C(i + j * (k - 1) - 1 , k - 2) % mod;\n            if(dp[i][j] >= mod)dp[i][j] -= mod;\n//            cout << i << \" \" << j << \" \" << dp[i][j] << \" \" <<\n//            i + j * (k - 1) - 1 << \" \" << k - 2 << \" \"  << C(i + j * (k - 1) - 1 , k - 2) <<endl;\n        }\n    }\n    cout << ((ll)dp[n][n] * f[n]) % mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\n#define forg(i,x) for(int i=first[x];i;i=nxt[i])\n#define uu unsigned\n#define fi first\n#define se second\n#define lam(z,k) [&](const z &a,const z &b){ return k; }\n#define od(x) ((x)&1)\n#define ev(x) (od(x)^1)\n#define mi2(x) (1<<(x))\n#define scanf a1234=scanf\nint a1234;\nchar buf[1<<18],*bufs=buf,*buft=buf;\ninline int gc(){\n    return bufs==buft&&(buft=(bufs=buf)+fread(buf,1,1<<18,stdin)),bufs==buft?-1:*bufs++;\n}\ninline void xxx(){for(;;);}\n\nconst int mxn=2003,mod=1e9+7;\nint n,k;\nint dp[mxn][mxn],fac[mxn*mxn],inv[mxn*mxn];\ninline int por(long long a,int b){\n    long long res=1;\n    for(;b;b>>=1){\n        if(b&1)res=res*a%mod;\n        a=a*a%mod;\n    }\n    return res;\n}\ninline long long C(int a,int b){return 1ll*fac[a]*inv[a-b]%mod*inv[b]%mod;}\ninline long long P(int a,int b){return 1ll*fac[a]*inv[a-b]%mod;}\ninline long long cha(int a,int b){return C(a+b,a);}\ntemplate<class T>inline void tsum(T &a,int b){a+=b;if(a>=mod)a-=mod;}\nint main(){\n    scanf(\"%d%d\",&n,&k);if(k==1)return puts(\"1\"),0;\n    fac[0]=inv[0]=1;for(int i=1;i<=n*k;++i)fac[i]=1ll*fac[i-1]*i%mod;\n    inv[n*k]=por(fac[n*k],mod-2);for(int i=n*k-1;i;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n    dp[1][1]=1;\n    for(int i=1;i<=n;++i)for(int j=i;j;--j){\n        //printf(\"%d %d %d\\n\",i,j,dp[i][j]);\n        tsum(dp[i][j-1],dp[i][j]);\n        if(!dp[i][j])continue;\n        dp[i][j]=dp[i][j]*cha((i-1)*k-j+1,k-2)%mod;\n        \n        tsum(dp[i+1][j+1],dp[i][j]);\n//        for(int jj=1;jj<=j+1;++jj)tsum(dp[i+1][jj],dp[i][j]*cha(i*k-jj+1,k-2)%mod);//,printf(\"%d %d %d\\n\",i+1,jj,dp[i+1][jj]);\n    }\n    long long ans=0;\n    for(int i=1;i<=n;++i)tsum(ans,dp[n][i]);\n    printf(\"%lld\\n\",ans*fac[n]%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst long long MOD = (long long)(1e9 + 7);\nconst int kK = (int)(2049 * 2049);\n\nlong long fac[kK + 5], inv[kK + 5];\n\nlong long qpow(long long base,int power)\n{\n\tlong long ret = 1;\n\tfor(; power; power >>= 1)\n\t{\n\t\tif(power & 1) ret = ret * base % MOD;\n\t\tbase = base * base % MOD;\n\t}\n\treturn ret;\n}\n\ninline long long C(int x, int y)\n{\n\treturn(((fac[y] * inv[x]) % MOD) * inv[y - x]) % MOD;\n}\n\nint n, k;\nlong long f[2049][2049];\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin >> n >> k;\n\tif(k == 1)\n\t{\n\t\tcout << 1 <<endl;\n\t\treturn 0;\n\t}\n\tfac[0] = 1;\n\tfor(int i = 1; i <= kK; ++i) fac[i] = fac[i-1] * i % MOD;\n\tinv[kK] = qpow(fac[kK], MOD - 2);\n\tfor(int i = kK; i >= 1; --i) inv[i - 1] = inv[i] * i % MOD;\n\tf[0][0] = 1;\n\tfor(int i = 1;i <= n; ++i)\n\t{\n\t\tf[i][0] = f[i - 1][0];\n\t\tfor(int j = 1; j <= i; ++j)\n\t\t{\n\t\t\tf[i][j] = f[i - 1][j];\n\t\t\tf[i][j] = f[i][j] + f[i][j - 1] * C(k - 2, n * k - i - (j - 1)*(k - 1) - 1);\n\t\t\tf[i][j] %= MOD;\n\t\t}\n\t}\n\tcout << fac[n] * f[n][n] % MOD<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <bitset>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\n#define PR pair\n#define fi first\n#define se second\n#define mk make_pair\n#define pb push_back\n#define REP(i, x, y)   for(int i = (int)(x); i <= (int)(y); i++)\n#define FOR(i, x, y)   for(int i = (int)(x); i <  (int)(y); i++)\n#define PER(i ,x, y)  for(int i = (int)(x); i >= (int)(y); i--)\n#define CH\t         ch = getchar()\n#define Exit(...)    printf(__VA_ARGS__), exit(0)\n#define dln()        fprintf(stderr,\"\\n\")\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntypedef double\t  db;\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<VI > VII;\ntypedef PR<int,int> PII;\ntypedef vector<PII> VPI;\nconst\tint inf=2e9;\nconst\tLL Inf=1e10;\nconst\tint P=1e9+7;\nconst\tint N=2005;\n\ninline LL IN(){\n\tLL x = 0;\n\tint ch = 0, f = 0;\n\tfor (CH; ch != -1 && (ch < 48 || ch > 57); CH) f = (ch == '-');\n\tfor (; ch >= 48 && ch <= 57; CH) x = (x << 1) + (x << 3) + ch - '0';\n\treturn f ? (-x) : x;\n}\ntemplate<typename T> inline int chkmin(T &a, const T &b){if(b < a) return a = b, 1; return 0;}\ntemplate<typename T> inline int chkmax(T &a, const T &b){if(b > a) return a = b, 1; return 0;}\n\nvoid renew(int &x, const int &y){\n\tx += y;\n\tif(x >= P) x -= P;\n\tif(x <  0) x += P;\n}\n\nint Pow(int x, int y, int p){\n\tint a = 1;\n\tfor (; y; y >>= 1, x = (LL)x * x %p) if(y & 1) a=(LL)a * x%p;\n\treturn a;\n}\n\nint n, k, S;\nint fac[4000005], inv[4000005], f[4000005];\nint DP[N << 1][N];\n\nint main(){\n\tscanf(\"%d%d\", &n, &k);\n\tif(k == 1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tS = n * k;\n\tfac[0] = inv[0] = fac[1] = inv[1] = 1;\n\tREP(i, 1, 4000000) fac[i] = (LL)fac[i - 1] * i % P;\n\tREP(i, 2, 4000000) inv[i] = (LL)inv[P % i] * (P - P / i) % P;\n\tREP(i, 2, 4000000) inv[i] = (LL)inv[i - 1] * inv[i] % P;\n\tREP(i, k - 2, 4000000) f[i] = (LL)fac[i] * inv[k - 2] % P * inv[i - k + 2] % P;\n\tDP[0][0] = 1;\n\t//DP[i][j] 考虑[1..i],填了j个数字。\n\tFOR(i, 0, n + n){\n\t\tfor(int j = 0; 2 * j < i; j ++) DP[i][j] = 0;\n\t\tREP(j, 0, n){\n\t\t\tint val = DP[i][j];\n\t\t\tif(!val) continue;\n\t\t\trenew(DP[i + 1][j], val);\n\t\t\tint cf = f[i + (j + 1) * (k - 2)];\n\t\t\trenew(DP[i + 1][j + 1], (LL)val * cf % P);\n\t\t}\n\t}\n\tint ans = DP[n + n][n];\n\tREP(i, 1, n) ans = (LL)ans * i % P;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#define rs register short\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 2005;\nconst LL mod = 1e9 + 7;\n\nnamespace MathCal {\n#define ri register int\n  static const int R = N * N;\n  LL fac[R], inv[R];\n  inline LL pow(LL x, LL e) {\n    LL res = 1;\n    for (; e; e >>= 1, x = x * x % mod)\n      if (e & 1) res = res * x % mod;\n    return res;\n  }\n  inline void Init(int n) {\n    for (ri i = fac[0] = 1; i <= n; i ++) fac[i] = fac[i - 1] * i % mod;\n    inv[n] = pow(fac[n], mod - 2);\n    for (ri i = n; i; i --) inv[i - 1] = inv[i] * i % mod;\n  }\n  inline LL Co(int x, int y) {\n    if (y > x) return 0;\n    return fac[x] * inv[y] % mod * inv[x - y] % mod;\n  }\n#undef ri\n}\nusing namespace MathCal;\n\nLL dp[N][N];\n\nint main() {\n  int n, k;\n  scanf(\"%d%d\", &n, &k);\n  if (k == 1 || n == 1) return !puts(\"1\");\n  MathCal::Init(n * k);\n  dp[0][0] = 1;\n  for (rs i = 1; i <= n; i ++)\n    for (rs j = 0; j <= i; j ++) {\n      dp[i][j] = dp[i - 1][j];\n      if (j) {\n\tdp[i][j] += Co(n * k - i - (k - 1) * (j - 1) - 1, k - 2) * dp[i][j - 1] % mod;\n\tif (dp[i][j] >= mod) dp[i][j] -= mod;\n      }\n    }\n  printf(\"%lld\\n\", dp[n][n] * fac[n] % mod);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<string>\n#include<cstring> \n#include<cassert>\n#include<cmath>\n#include<sstream>\n#include<fstream>\n#include<map>\n#include<set>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nconst long long MOD=1e9+7;\nlong long quickpow(long long x,int times){\n\tlong long tmp=1;\n\twhile(times){\n\t\tif(times&1) tmp=tmp*x%MOD;\n\t\tx=x*x%MOD;\n\t\ttimes>>=1;\n\t}\n\treturn tmp;\n}\nlong long dp[2005][2005],po[5000005],inpo[5000005];\nlong long C(int n,int m){\n\treturn (po[n]*inpo[m]%MOD*inpo[n-m]%MOD);\n}\nint main(){\n\tint n,k;\n\tscanf(\"%d %d\",&n,&k);\n\tif(k==1){\n\t\tcout<<1;\n\t\treturn 0;\n\t}\n\tpo[0]=1;\n\tinpo[0]=1;\n\tfor(int i=1;i<=5000002;i++){\n\t\tpo[i]=i*po[i-1]%MOD;\n\t\tinpo[i]=quickpow(po[i],MOD-2);\n\t}\n\tdp[0][0]=1;\n//\tcout<<C(0,0)<<endl;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tdp[i][j]=(dp[i-1][j]+((j!=0)?dp[i][j-1]*C(k*n-i-(j-1)*(k-1)-1,(k-2))%MOD*(n-j+1):0))%MOD;\n\t\t//\tcout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n\t\t}\n\t}\n\tcout<<dp[n][n];\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#define N 2010\n#define M 4000000\n#define P 1000000007\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n,k;\nll f[N][N],fac[N*N],inv[N*N];\n\ninline int C(int x,int y){\n  if(x<y) return 0;\n  return fac[x]*inv[y]%P*inv[x-y]%P;\n}\n\nint main(){\n  //freopen(\"1.in\",\"r\",stdin);\n  //freopen(\"1.out\",\"w\",stdout);\n  scanf(\"%d%d\",&n,&k);\n  if(k==1) return puts(\"1\"),0;\n  fac[0]=inv[0]=inv[1]=1;\n  for(int i=1;i<=M;i++) fac[i]=fac[i-1]*i%P;\n  for(int i=2;i<=M;i++) inv[i]=(P-P/i)*inv[P%i]%P;\n  for(int i=1;i<=M;i++) inv[i]=inv[i]*inv[i-1]%P;\n  f[0][0]=1;\n  for(int i=1;i<=n;i++)\n    for(int j=i;~j;j--){\n      f[i][j]=f[i][j+1]%P;\n      if(j) (f[i][j]+=f[i-1][j-1]*C(i*k-j-1,k-2))%=P;\n    }\n  printf(\"%lld\\n\",f[n][0]*fac[n]%P);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef long long ll;\n#define N 4000011\nconst int p=1e9+7;\nint n,k,dp[2002][2002],inv[N],f[N],finv[N];\ninline int C(int nn,int mm)\n{\n\tif(mm==nn||mm==0)return 1;if(nn<mm)return 0;\n\treturn 1ll*f[nn]*finv[mm]%p*finv[nn-mm]%p;\n}\nint main()\n{\n\tf[1]=finv[1]=inv[1]=1;\n\tfor(int i=2;i<=4000000;i++)\n\t{\n\t\tinv[i]=1ll*(p-p/i)*inv[p%i]%p;\n\t\tf[i]=1ll*f[i-1]*i%p;finv[i]=1ll*finv[i-1]*inv[i]%p;\n\t}\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1){puts(\"1\");return 0;}\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++)for(int j=0;j<=i;j++)\n\t{\n\t\tdp[i][j]=dp[i-1][j];\n\t\tif(j)(dp[i][j]+=1ll*C(n-i+(n-j+1)*(k-1)-1,k-2)*dp[i][j-1]%p)%=p;\n\t}\n\tprintf(\"%d\\n\",1ll*dp[n][n]*f[n]%p);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline int read(){\n\tint ans=0,w=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar();\n\treturn ans*w;\n}\nconst int N=2005,Maxn=2000*2000+1e5+5,mod=1e9+7;\nint n,k,f[N][N],fac[Maxn],ifac[Maxn];\ninline int C(int n,int m){return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;}\nint main(){\n\tn=read(),k=read(),ifac[0]=fac[0]=fac[1]=ifac[1]=1;\n\tif(k==1)return puts(\"1\"),0;\n\tfor(int i=2;i<=n*(n+1);++i)fac[i]=1ll*fac[i-1]*i%mod,ifac[i]=1ll*(mod-mod/i)*ifac[mod%i]%mod;\n\tfor(int i=2;i<=n*(n+1);++i)ifac[i]=1ll*ifac[i]*ifac[i-1]%mod;\n\tf[1][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<=i;++j){\n\t\t\tif(i^j)(f[i][j+1]+=f[i][j]%=mod);\n\t\t\tif(i^n)(f[i+1][j]+=1ll*f[i][j]*C((k-2)+(i*(k-1)+j),k-2)%mod)%=mod;\n\t\t}\n\tcout<<1ll*f[n][n]*fac[n]%mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long \nusing namespace std;\nconst int N=2200;\nconst int MAXN=4e6;\nconst int M=1e9+7;\nll fac[N*N],inv[N*N],f[N][N];\nint n,k;\ninline ll qpow(ll a,ll b){\n\tll ans=1;\n\twhile(b){\n\t\tif(b&1) ans=ans*a%M;\n\t\tb>>=1;a=a*a%M;\n\t} \n\treturn ans;\n}\nvoid init(){\n\tfac[0]=1;\n\tfor(int i=1;i<=MAXN;i++) fac[i]=fac[i-1]*i%M;\n\tinv[MAXN]=qpow(fac[MAXN],M-2); \n\tfor(int i=MAXN;i>=1;i--) inv[i-1]=inv[i]*i%M;\n}\ninline ll C(int n,int m){\n\tif(n<m) return 0;\n\treturn fac[n]*inv[m]%M*inv[n-m]%M;\n}\nint main(){\n//\tfreopen(\"at2000.in\",\"r\",stdin);\n\tinit();\n\tscanf(\"%d%d\",&n,&k);f[0][0]=1;\n\tif(k==1) {printf(\"1\\n\");return 0; } \n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++) f[i][j]=(f[i-1][j]+(n-j+1)*C(n*k-i-(j-1)*(k-1)-1,k-2)%M*f[i][j-1])%M;\n\tprintf(\"%lld\\n\",f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <unordered_map>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\nusing namespace std;\n\nint n, k;\nlong long F[4000001];\nlong long inv[4000001];\nlong long invF[4000001];\n\nlong long mod = 1000000007LL;\n\nlong long C(int a, int b)\n{\n\tif(b < 0 || b > a) return 0;\n\tlong long ret = F[a];\n\tret *= invF[b];\n\tret %= mod;\n\tret *= invF[a-b];\n\tret %= mod;\n\treturn ret;\n}\n\nlong long ways(int nLocation, int nObject)\n{\n\treturn C(nLocation + nObject - 1, nLocation - 1);\n}\n\nlong long DP[2001][2001];\n\nlong long dp(int nZero, int nColor)\n{\n\tif(nZero > n || nColor > n) return 0;\n\tif(nZero == n && nColor == n) return 1;\n\tlong long &ret = DP[nZero][nColor];\n\tif(ret != -1) return ret;\n\tret = 0;\n\tif(nZero <= nColor)\n\t\tret += dp(nZero + 1, nColor);\n\tlong long mul = ways(\n\t\t\tnZero + nColor * (k - 1),\n\t\t\tk - 2\n\t\t);\n\t\n\tret += dp(nZero, nColor + 1) * mul;\n\tret %= mod;\n\t//cout << nZero << \" \" << nColor << \" : \" << ret << endl;\n\treturn ret;\n}\n\nint MAIN()\n{\n\tcin >> n >> k;\n\tF[0] = invF[0] = 1;\n\tinv[1] = 1;\n\tfor(int i = 2; i <= 4000000; i++)\n\t\tinv[i] = (mod - (mod/i) * inv[mod%i] % mod) % mod;\n\n\tfor(int i = 1; i <= 4000000; i++)\n\t{\n\t\tF[i] = (F[i-1] * i) % mod;\n\t\tinvF[i] = (invF[i-1] * inv[i] % mod);\n\t}\n\tmemset(DP, 0xff, sizeof(DP));\n\tlong long ans = 1;\n\tif(k > 1)\n\t{\n\t\tans = dp(1, 0);\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tans = (ans * i) % mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\nint main()\n{\n\tint start = clock();\n\t#ifdef LOCAL_TEST\n\t\tfreopen(\"in.txt\", \"r\", stdin);\n\t\tfreopen(\"out.txt\", \"w\", stdout);\n\t#endif\n\tios :: sync_with_stdio(false);\n\tcout << fixed << setprecision(16);\n\tint ret = MAIN();\n\t#ifdef LOCAL_TEST\n\t\tcout << \"[Finished in \" << clock() - start << \" ms]\" << endl;\n\t#endif\n\treturn ret;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int MAXN = 2005, MOD = 1e9 + 7;\nlong long f[MAXN * MAXN];\nlong long dp[MAXN][MAXN], n, k;\nlong long rev(long long a) {\n\tint b = MOD - 2;\n\tlong long res = 1;\n\tfor (b; b; b /= 2) {\n\t\tif (b % 2)\n\t\t\tres *= a, res %= MOD;\n\t\ta *= a, a %= MOD;\n\t}\n\treturn res;\n}\nlong long ch(int a, int b) {\n\treturn f[a] * rev(f[b]) % MOD * rev(f[a - b]) % MOD;\n}\n\nint main() {\n\tcin >> n >> k;\n\tif (k == 1)\n\t\treturn cout << 1, 0;\n\tf[0] = 1;\n\tfor (int i = 1; i < MAXN * MAXN; i++)\n\t\tf[i] = f[i - 1] * i, f[i] %= MOD;\n\tfor (int i = 0; i <= n; i++)\n\t\tdp[0][i] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = i; j <= n; j++)\n\t\t\tdp[i][j] = dp[i - 1][j] * ch(n * k - j - (i - 1) * (k - 1) - 1, k - 2) + dp[i][j - 1], dp[i][j] %= MOD;\n\tcout << f[n] * dp[n][n] % MOD;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 2000 + 100;\nconst int MOD = 1000000000 + 7;\nconst int MAXM = MAXN * MAXN;\n\nint fac[MAXM], inv[MAXM];\n\nint fpow(int x, int p)\n{\n\tint ret = 1;\n\tfor(; p; p >>= 1, x = (long long)x * x % MOD)\n\t\tif(p & 1)\n\t\t\tret = (long long)ret * x % MOD;\n\treturn ret;\n}\n\nint get_inv(int x)\n{\n\treturn fpow(x, MOD - 2);\n}\n\nvoid init()\n{\n\tfac[0] = 1;\n\tfor(int i = 1; i < MAXM; i++)\n\t\tfac[i] = (long long)fac[i - 1] * i % MOD;\n\tinv[MAXM - 1] = get_inv(fac[MAXM - 1]);\n\tfor(int i = MAXM - 2; i >= 0; i--)\n\t\tinv[i] = (long long)inv[i + 1] * (i + 1) % MOD;\n}\n\nint get_c(int x, int y)\n{\n\tif(x < 0 || y < 0 || x < y)\n\t\treturn 0;\n\treturn (long long)fac[x] * inv[y] % MOD * inv[x - y] % MOD;\n}\n\nint n, m;\nint f[MAXN][MAXN];\n\nint dp(int x, int y)\n{\n\tif(x == 0)\n\t\treturn 1;\n\tif(x == y)\n\t\treturn dp(x, y - 1);\n\tif(f[x][y] != -1)\n\t\treturn f[x][y];\n\tint ret = 0;\n\tif(y > 0)\n\t\tret = (ret + dp(x, y - 1)) % MOD;\n\tint A = (m - 1) * (x - 1) + y;\n\tret = (ret + (long long)get_c(A + m - 2, A) * dp(x - 1, y)) % MOD;\n\t// cerr << x << ' ' << y << ' ' << ret << endl;\n\treturn f[x][y] = ret;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tcin >> n >> m;\n\n\tif(m == 1)\n\t{\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\n\tinit();\n\tmemset(f, -1, sizeof(f));\n\n\tint ans = dp(n, n);\n\tans = (long long)ans * fac[n] % MOD;\n\tcout << ans << endl;\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//waz\n#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)((x).size()))\n \ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef long long int64;\ntypedef unsigned int uint;\ntypedef unsigned long long uint64;\n \n#define gi(x) ((x) = F())\n#define gii(x, y) (gi(x), gi(y))\n#define giii(x, y, z) (gii(x, y), gi(z))\n \nint F()\n{\n\tchar ch;\n\tint x, a;\n\twhile (ch = getchar(), (ch < '0' || ch > '9') && ch != '-');\n\tif (ch == '-') ch = getchar(), a = -1;\n\telse a = 1;\n\tx = ch - '0';\n\twhile (ch = getchar(), ch >= '0' && ch <= '9')\n\t\tx = (x << 1) + (x << 3) + ch - '0';\n\treturn a * x;\n}\n\nconst int mod = 1e9 + 7;\n\nint fpow(int a, int x)\n{\n\tint ret = 1;\n\tfor (; x; x >>= 1)\n\t{\n\t\tif (x & 1) ret = 1LL * ret * a % mod;\n\t\ta = 1LL * a * a % mod;\n\t}\n\treturn ret;\n}\n\nint f[2010][2010], n, k, fac[2010 * 2010], ifac[2010 * 2010];\n\nint C(int n, int m)\n{\n\tif (n < m || m < 0) return 0;\n\treturn 1LL * fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nint get(int x, int y)\n{\n\treturn C(x + y, y);\n}\n\nint main()\n{\n\tgii(n, k);\n\tif (k == 1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tf[0][0] = 1;\n\tfac[0] = 1;\n\tfor (int i = 1; i <= (n + 2) * (k + 2); ++i) fac[i] = 1LL * fac[i - 1] * i % mod;\n\tifac[(n + 2) * (k + 2)] = fpow(fac[(n + 2) * (k + 2)], mod - 2);\n\tfor (int i = (n + 2) * (k + 2); i; --i) ifac[i - 1] = 1LL * ifac[i] * i % mod;\n\tfor (int i = 0; i <= n; ++i)\n\t\tfor (int j = i; j <= n; ++j)\n\t\t{\n\t\t\t\n\t\t\tif (i) f[i][j] = (f[i][j] + f[i - 1][j]) % mod;\n\t\t\tif (j) f[i][j] = (f[i][j] + 1LL * f[i][j - 1] * get((j - 1) * (k - 1) + i, k - 2)) % mod;\n\t\t\t//cerr << \"get = \" << get(j * (k - 1), k - 2) << endl;\n\t\t}\n\tprintf(\"%d\\n\", int((1LL * f[n][n] * fac[n]) % mod));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n设f[i][j]表示当前有i个白球，一共放完了j种球\n显然有j <= i\n* 放白球 从f[i-1][j]转移\n* 放没有出现过的球 (n - j + 1) * f[i][j - 1] * C(k - 2, n * k - i - (j - 1) * (k - 1) - 1)\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 2020;\nconst int mod = 1e9 + 7;\n\nint inv[N * N], fac[N * N];\nint f[N][N];\nint n, k;\n\nint power(int a, int b) {\n\ta %= mod; int ans = 1;\n\twhile(b) {\n\t\tif(b & 1) ans = 1ll * ans * a % mod;\n\t\ta = 1ll * a * a % mod; b >>= 1;\n\t}\n\treturn ans;\n}\n\nint C(int n, int m) {\n\treturn 1ll * fac[m] * inv[n] % mod * inv[m - n] % mod;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tfac[0] = 1;\n\tfor(int i = 1; i < N * N; ++i) \n\t\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\tfor(int i = 0; i < N * N; ++i) \n\t\tinv[i] = power(fac[i], mod - 2);\n\tfor(int i = 0; i <= n; ++i) f[i][0] = 1;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tfor(int j = 1; j <= i; ++j) {\n\t\t\tf[i][j] = f[i - 1][j];\n\t\t\t(f[i][j] += 1ll * (n - j + 1) * f[i][j - 1] % mod * C(k - 2, n * k - i - (j - 1) * (k - 1) - 1) % mod) %= mod;\n\t\t\t(f[i][j] += mod) %= mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", (f[n][n] % mod + mod) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2020, M = N * N, MOD = 1000 * 1000 * 1000 + 7;\n\nint sum(int a, int b) {\n\ta += b;\n\tif(a < 0)\n\t\ta += MOD;\n\telse if(a >= MOD)\n\t\ta -= MOD;\n\treturn a;\n}\n\nvoid _sum(int &a, int b) {\n\ta = sum(a, b);\n}\n\nint mul(int a, int b) {\n\treturn 1LL * a * b % MOD;\n}\n\nvoid _mul(int &a, int b) {\n\ta = mul(a, b);\n}\n\nint power(int a, int b) {\n\tint res = 1;\n\twhile(b) {\n\t\tif(b & 1)\n\t\t\tres = mul(res, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint n, k, dp[N], fac[M], pow_fac[M];\n\nint f(int a) {\n\treturn power(a, MOD - 2);\n}\n\nint choose(int a, int b) {\n\treturn (a > b? 0: mul(fac[b], mul(pow_fac[a], pow_fac[b - a])));\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tfac[0] = 1;\n\tfor (int i = 1; i < M; i++)\n\t\tfac[i] = mul(fac[i - 1], i);\n\tfor (int i = 0; i < M; i++)\n\t\tpow_fac[i] = f(fac[i]);\n\tcin >> n >> k;\n\tif(k == 1) {\n\t\tcout << 1;\n\t\treturn 0;\n\t}\n\tdp[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tint val = choose(j, i);\n\t\t\t_mul(val, choose(j * k - j, i * k - j));\n\t\t\t_mul(val, mul(fac[j * (k - 1)], f(power(fac[k - 1], j))));\n\t\t\t_mul(val, dp[i - j]);\n\t\t\tdp[i] = sum(dp[i], (j & 1? 1: -1) * val);\n\t\t}\n\t}\n\tcout << dp[n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\ntypedef long long ll ;\n#define F first\n#define S second\n#define pb push_back\n#define pii pair<int ,int>\n//#define int long long\nconst int N = 2005 , N1 = 4e6 + 5  ;\nconst int mod = 1e9 + 7 ;\nint n , k ,f[N1] , fi[N1] , dp[N][N] , sum[2 * N] , t  ;\nint poww(int x , int y){\n    if(y == 0) return 1 ;\n    int tmp = poww(x , y / 2);\n    tmp = (1ll * tmp * tmp) % mod ;\n    if(y % 2) tmp = (1ll * tmp * x) % mod ;\n    return tmp ;\n}\nint c(int a , int b){\n    if(b > a) return 0 ;\n    return (((1ll * f[a] * fi[b]) % mod) * fi[a - b]) % mod ;\n}\nint ps(int a , int b){\n    t = max(t, a) ;\n    if(b == 0) return sum[a];\n    int ans = sum[a] - sum[b - 1] ;\n    return (1ll * ans + mod) % mod ;\n}\nint32_t main (){\n    ios_base::sync_with_stdio(0) ;\n    cin.tie(0) ;\n    cout.tie(0) ;\n    //freopen (\"input.txt\",\"r\",stdin);\n    //freopen (\"output.txt\",\"w\",stdout);\n    cin >> n >> k ;\n    f[0] = 1 ;\n    fi[0] = 1 ;\n    for(int i = 1 ; i < N1 ; i++) f[i] = (1ll * f[i - 1] * i) % mod ;\n    fi[N1 - 1] = poww(f[N1 - 1] , mod - 2) ;\n    for(int i = N1 - 2 ; i ; i--) fi[i] = (1ll * fi[i + 1] * (i + 1)) % mod ;\n    sum[1] = 1 ;\n    for(int i = 2 ;i <= n ; i++ ) sum[i] = sum[i - 1] ;\n    for(int j = 2 ; j <= n ; j++){\n        for(int i = 0 ; i <= j ; i++){\n            dp[i][j] = (((1ll * j * c(j * k - i - 1 , k - 2)) % mod) * ps(i - 1 + j - 1 , i - 1)) % mod ;\n        }\n        sum[0] = dp[0][j] ;\n        for(int i = 1;  i <= n ; i++){\n            sum[i] = (sum[i - 1] + dp[i][j]) % mod ;\n        }\n        for(int i = n + 1 ; i <= 2 * n ; i++) sum[i] = sum[i - 1] ;\n    }\n    cout << \"max alloc = \" << t << \"\\n\" ;\n    return cout << sum[n] , 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <memory.h>\n\ntypedef long long ll;\n\nconst ll N = 2e3 + 5;\nconst ll P = 1e9 + 7;\n\nll n, k;\nll fac[N * N];\nll f[N][N];\n\nll read()\n{\n    ll x = 0, f = 1;\n    char ch = getchar();\n    while ('0' > ch or ch > '9')\n        f = ch == '-' ? -1 : 1, ch = getchar();\n    while ('0' <= ch and ch <= '9')\n        x = x * 10 + ch - 48, ch = getchar();\n    return x * f;\n}\n\nll pow(ll x, ll k)\n{\n    ll res = 1;\n    for (x %= P; k; k >>= 1, x = x * x % P)\n        if (k & 1)\n            res = res * x % P;\n    return res;\n}\n\nll C(ll n, ll m) { return ((fac[n] * pow(fac[m], P - 2)) % P * pow(fac[n - m], P - 2) % P); }\n\nsigned main()\n{\n    n = read(), k = read();\n    if (k == 1)\n    {\n        puts(\"1\");\n        return 0;\n    }\n    fac[0] = 1;\n    for (ll i = 1; i <= n * k; i++)\n        fac[i] = fac[i - 1] * i % P;\n    for (ll i = 0; i <= n; i++)\n        f[i][0] = 1;\n    for (ll i = 1; i <= n; i++)\n        for (ll j = 1; j <= i; j++)\n            f[i][j] = f[i - 1][j] +\n                      f[i][j - 1] * (n - j + 1) *\n                          C(n * k - i - (j - 1) * (k - 1) - 1, k - 2) % P;\n    printf(\"%lld\", f[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long int ll;\n\nll mod=1e9+7;\n\nll mod_pow(ll a,ll b){\n    a%=mod;\n    if(b==0)return 1;\n    if(b==1)return a;\n    ll res=mod_pow(a,b/2)%mod;\n    res*=res; res%=mod;\n    if(b%2)res*=a;\n    return res%mod;\n}\n\nstruct perm{\nprivate:\n    int sz;\n    vector<ll> p,invp;\npublic:\n    perm(int n){\n        sz=n+1;\n        p.resize(sz),invp.resize(sz);\n        p[0]=1;\n        for(int i=1;i<=sz-1;i++){\n            p[i]=p[i-1]*i%mod;\n        }\n        invp[sz-1]=mod_pow(p[sz-1],mod-2);\n        for(int i=sz-2;i>=0;i--){\n            invp[i]=invp[i+1]*(i+1)%mod;\n        }\n    }\n    ll comb(ll x,ll y){\n        if(x<y||y<0)return 0;\n        return (p[x]*invp[x-y]%mod)*invp[y]%mod;\n    }\n};\nperm p(1<<22);\n\nll dp[2020][2020];\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n,k; cin >> n >> k;\n    if(k==1){\n        cout << 1 << endl;\n        return 0;\n    }\n    dp[0][1]=1;\n    for(int i=2;i<=n;i++){\n        dp[0][i]=dp[0][i-1]*p.comb((i-1)*(k-1)+k-2,k-2)%mod;\n    }\n    for(int i=1;i<=n;i++){\n        dp[i][i]=dp[i-1][i]; //最上段左端を取るしかない\n        for(int j=i+1;j<=n;j++){\n            dp[i][j]=(dp[i-1][j]+dp[i][j-1]*p.comb(j*(k-1)+i-1,k-2))%mod;\n        } // k-2+(j-1)*(k-1)+i=j*(k-1)+i-1\n    }\n    ll res=dp[n][n];\n    for(ll i=1;i<=n;i++){\n        (res*=i)%=mod;\n    }\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include<bits/stdc++.h>\nusing namespace std;\nconst int M=1e9+7,N=2002*2002;\nint pw(int x,int y){\n\tint z=1;\n\tfor (;y;y>>=1,x=1ll*x*x%M)\n\t\tif (y&1) z=1ll*z*x%M;\n\treturn z;\n}\nint INV(int x){return pw(x,M-2);}\nint fac[N],inv[N],f[2002][2002],i,j,n,k;\nint C(int n,int m){return 1ll*fac[n]*inv[m]%M*inv[n-m]%M;}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tif (k==1) return puts(\"1\"),0;\n\tfac[0]=1;\n\tfor (i=1;i<N;i++) fac[i]=1ll*fac[i-1]*i%M;\n\tinv[N-1]=INV(fac[N-1]);\n\tfor (i=N-2;~i;i--) inv[i]=1ll*inv[i+1]*(i+1)%M;\n\tfor (i=0;i<=n;i++)\n\t\tfor (f[i][0]=1,j=1;j<=i;j++) f[i][j]=(f[i-1][j]+1ll*f[i][j-1]*(n-j+1)%M*C(n*k-i-(j-1)*(k-1)-1,k-2)%M)%M;\n\tprintf(\"%d\",f[n][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 2005\nconst int mod = 1000000007;\n#define add(x, y) (x + y >= mod ? x + y - mod : x + y)\n#define dec(x, y) (x < y ? x - y + mod : x - y)\n\nint Pow(int x, int k)\n{\n\tint ans = 1, base = x;\n\twhile(k)\n\t{\n\t\tif(k & 1) ans = 1ll * ans * base % mod;\n\t\tbase = 1ll * base * base % mod;\n\t\tk >>= 1;\n\t}\n\treturn ans;\n}\n\nint n, k, f[N][N], pw[N * N], inv[N * N];\n\nint C(int x, int y)\n{\n\treturn 1ll * pw[y] * inv[y - x] % mod * inv[x] % mod;\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &k);\n\tpw[0] = inv[0] = 1;\n\tfor(int i = 1; i <= n * k; i++) pw[i] = 1ll * pw[i - 1] * i % mod, inv[i] = Pow(pw[i], mod - 2);\n\tif(k == 1) {cout << 1 << endl; return 0;}\n\tf[0][0] = 1;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = 0; j <= i; j++)\n\t\t{\n\t\t\tf[i][j] = add(f[i - 1][j], (1ll * f[i][j - 1] * (n - j + 1) % mod * C(k - 2, n * k - i - (j - 1) * (k - 1) - 1) % mod));\n\t\t}\n\t}\n\tprintf(\"%d\\n\", f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define C(x,y) (fct[x]*ifct[y]%TT*ifct[(x)-(y)]%TT)\nusing namespace std;\nconst int maxn=2005,TT=1e9+7;\nint n,K,m,F[maxn][maxn];\nlong long fct[maxn*maxn],ifct[maxn*maxn];\ninline int read(){\n\tint ret=0;bool f=0;char ch=getchar();\n\twhile(ch>'9'||ch<'0') f^=ch=='-',ch=getchar();\n\twhile(ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();\n\treturn f?-ret:ret;\n}\ninline long long pow(int x,int y){\n\tlong long ret=1,w=x;\n\twhile(1){\n\t\tif(y&1) ret=ret*w%TT;\n\t\tif(!(y>>=1)) return ret;\n\t\tw=w*w%TT;\n\t}\n}\ninline void add(int&x,int y){if((x+=y)>=TT) x-=TT;}\nint main(){\n\tn=read(),K=read();m=n*K;\n\tif(K==1) return puts(\"1\")&0;\n\tfor (int i=fct[0]=1;i<=m;i++) fct[i]=fct[i-1]*i%TT;\n\tifct[m]=pow(fct[m],TT-2);\n\tfor (int i=m;i;i--) ifct[i-1]=ifct[i]*i%TT;\n\tF[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=0;j<=i;j++){\n\t\tif(j<i) add(F[i][j],F[i-1][j]);\n\t\tif(j) add(F[i][j],C(m-i-(j-1)*(K-1)-1,K-2)*F[i][j-1]%TT);\n\t}\n\tprintf(\"%lld\\n\",fct[n]*F[n][n]%TT);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\nconst int mod=1e9+7;\nstruct Combin{\n\t#define N 4000005\n\tint fac[N],rv[N],facrv[N];\n\tCombin(){\n\t\tfac[0]=rv[1]=facrv[0]=1;\n\t\tfor(int i=2;i<N;i++) rv[i]=((-(LL)(mod/i)*rv[mod%i]%mod)+mod)%mod;\n\t\tfor(int i=1;i<N;i++) fac[i]=(LL)fac[i-1]*i%mod;\n\t\tfor(int i=1;i<N;i++) facrv[i]=(LL)facrv[i-1]*rv[i]%mod;\n\t}\n\tint C(int r1,int n1){\n\t\tif(r1>n1) return 0;\n\t\treturn fac[n1]*(LL)facrv[r1]%mod*facrv[n1-r1]%mod;\n\t}\n\t#undef N\n}C;\nint n,k;\nint dp[2][2005];\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1) return puts(\"1\"),0;\n\tint now=0;\n\tfor(int i=0;i<=n;i++){\n\t\tmemset(dp[now],0,sizeof(dp[0]));\n\t\tfor(int j=i;j<=n;j++){\n\t\t\tif(j==i) dp[now][j]=i==0? 1:dp[now^1][j];\n\t\t\telse dp[now][j]=(dp[now^1][j] + dp[now][j-1]*1LL*C.C(k-2,k-2+i*k+(j-i-1)*(k-1)))%mod;\n\t\t}\n\t\tnow^=1;\n\t}\n\tcout<<dp[now^1][n]*1LL*C.fac[n]%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=4000005;\nll n,k,fac[N],inv[N],f[2005][2005],mod=1e9+7;\nll power(ll a,ll b){\n\tll res=1,tmp=a;\n\twhile(b){\n\t\tif(b&1)res=res*tmp%mod;\n\t\ttmp=tmp*tmp%mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nll C(ll n,ll m){\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n} \nint main(){\n\tscanf(\"%lld%lld\",&n,&k);\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=N-5;i++){\n\t\tfac[i]=fac[i-1]*i%mod;\n\t\tinv[i]=power(fac[i],mod-2);\n\t}\n\tfor(int i=0;i<=n;i++)f[i][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t\tf[i][j]=f[i-1][j]%mod+f[i][j-1]%mod*(n-j+1)%mod*C(n*k-i-1-(j-1)*(k-1),k-2)%mod;\n\tprintf(\"%lld\",f[n][n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*          (: -_-_-_- IN THE NAME OF ALLAH -_-_-_- :)          */\n/*                    | S e y e d |                             */\n/*                    |    3 7    |                             */\n/*                   HASHEMESHOON hastam ;)                     */\n/*//*//*//*//*//*//*//*//*//*//*//*//*//*//*//*//*//*//*//*//*//*/\n#include <bits/stdc++.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\n#include <cstdio>\n#include <map>\n#include <string>\n#include <set>\n#include <vector>\n#include <stack>\n#include <deque>\n#include <queue>\n#include <ctime>\n#include <list>\n#include <iterator>\n#define ll long long\n#define ss second\n#define ff first\n#define pb push_back\nusing namespace std;\nll n,m,x,y,z,w,ans,dp[2][4002100],f[4002100],t[4002100],mod=1e9+7;\nll tav(ll xx,ll yy){\n    if(yy==0)return 1;\n    ll zz=tav(xx,yy/2);\n    (zz*=zz)%=mod;\n    if(yy%2==1)return (zz*xx)%mod;\n    else return zz;\n}\nll c(ll nn,ll kk){\n    return (f[nn]*((t[kk]*(t[nn-kk]))%mod))%mod;\n}\nint main(){\n    //ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    cin>>n>>m;\n    f[0]=1;\n    for(ll i=1;i<=n*m+2000;i++){\n        f[i]=f[i-1]*i;\n        f[i]%=mod;\n        t[i]=tav(f[i],mod-1);\n    }\n    t[0]=1;\n    dp[0][m-1]=1;\n    for(int o=1;o<n;o++){\n        ll p=o%2,q=1-p;\n        for(int i=0;i<=(o+1)*(m-1)+2000;i++){\n                dp[p][i+m-1]=dp[q][i]*(c(i+m-1,i));\n                dp[p][i+m-1]%=mod;\n        }\n    }\n    for(int i=0;i<=n*m+2000;i++){\n        ans+=dp[1-n%2][i];\n        ans%=mod;\n    }\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 1000000007\n#define ll long long\n#define N 2001\nint n, k;\nll fac[N * N], inv[N * N], dp[N][N] = {1};\nll Qpow(ll x, ll n) {\n    ll s = 1;\n    while (n) {\n        if (n & 1) s = s * x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return s;\n}\nll C(int n, int m) {\n    if (m < 0 || m > n) return 0;\n    return fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\nint main() {\n    scanf(\"%d%d\", &n, &k);\n    if (k == 1) {\n        puts(\"1\");\n        return 0;\n    }\n    for (int i = fac[0] = 1; i <= n * k; i++) fac[i] = fac[i - 1] * i % mod;\n    inv[n * k] = Qpow(fac[n * k], mod - 2);\n    for (int i = n * k; i; i--) inv[i + 1] = inv[i] * i % mod;\n    for (int i = 0; i <= n; i++)\n        for (int j = i; j <= n; j++) {\n            dp[i][j + 1] = (dp[i][j + 1] + dp[i][j]) % mod;\n            ll s = C(k * (n - i) - (j - i) - 1, k - 2) + dp[i + 1][j];\n            dp[i + 1][j] = dp[i][j] * s % mod;\n        }\n    printf(\"%lld\", dp[n][n] * fac[n] % mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<complex>\n#include<array>\nusing namespace std;\n#define rrep(i,m,n) for(int (i)=(int)(m);(i)>=(int)(n);(i)--)\n#define rep(i,m,n) for(int (i)=(int)(m);i<(int)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ll long long\n#define ull unsigned long long\n#define all(hoge) (hoge).begin(),(hoge).end()\n#define M_PI 3.1415926535897932LL;\ntypedef pair<ll, ll> P;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 60;\nconstexpr long double EPS = 1e-10;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct Edge {//グラフ\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, ll from, ll to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\n\nll max_flow_dfs(Graph& G, ll v, ll t, ll f, vector<bool>& used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph& G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d, Array& negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = ((i != j) ? INF : 0);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\tchmin(d[i][G[i][j].to], G[i][j].cap);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, vector<int>& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tlca() {}\n\n\tlca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\nvoid visit(const Graph& g, int v, Matrix& scc, stack<ll>& S, Array& inS, Array& low, Array& num, int& time) {\n\tlow[v] = num[v] = ++time;\n\tS.push(v); inS[v] = true;\n\tFOR(e, g[v]) {\n\t\tint w = e->to;\n\t\tif (num[w] == 0) {\n\t\t\tvisit(g, w, scc, S, inS, low, num, time);\n\t\t\tlow[v] = min(low[v], low[w]);\n\t\t}\n\t\telse if (inS[w])\n\t\t\tlow[v] = min(low[v], num[w]);\n\t}\n\tif (low[v] == num[v]) {\n\t\tscc.push_back(Array());\n\t\twhile (1) {\n\t\t\tint w = S.top(); S.pop(); inS[w] = false;\n\t\t\tscc.back().push_back(w);\n\t\t\tif (v == w) break;\n\t\t}\n\t}\n}\nvoid stronglyConnectedComponents(const Graph& g, Matrix& scc) {//強連結成分分解 O(E+V)\n\tconst int n = g.size();\n\tArray num(n), low(n);\n\tstack<ll> S;\n\tArray inS(n);\n\tint time = 0;\n\tREP(u, n) if (num[u] == 0)\n\t\tvisit(g, u, scc, S, inS, low, num, time);\n}\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tll size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tll numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\nclass SumSegTree {\nprivate:\n\n\tll _sum(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return 0;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _sum(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _sum(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn s1 + s2;\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tSumSegTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1, 0);\n\t}\n\n\t// 場所i(0-indexed)にxを足す\n\tvoid add(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] += x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] += x;\n\t\t}\n\t}\n\n\t// 区間[a,b)の総和。ノードk=[l,r)に着目している。\n\tll sum(ll a, ll b) {\n\t\treturn _sum(a, b, 0, 0, n);\n\t}\n};\nclass RmqTree {\nprivate:\n\n\tll _find(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return INF;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _find(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _find(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn min(s1, s2);\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tRmqTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1, INF);\n\t}\n\n\t// 場所i(0-indexed)をxにする\n\tvoid update(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] = x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\n\t// 区間[a,b)の最小値。ノードk=[l,r)に着目している。\n\tll find(ll a, ll b) {\n\t\treturn _find(a, b, 0, 0, n);\n\t}\n};\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n}\n\nvoid divisor_prime(ll n, vector<P>& ret) {\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back({ i,0 });\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tret[ret.size() - 1].second++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1)ret.push_back({ n,1 });\n}\n\n\nll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n//nCrとか\nclass Combination {\npublic:\n\tArray fact;\n\tArray inv;\n\tll mod;\n\tll mod_inv(ll x) {\n\t\tll n = mod - 2LL;\n\t\tll res = 1LL;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res = res * x % mod;\n\t\t\tx = x * x % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tll nCr(ll n, ll r) {\n\t\tif (n < r)return 0;\n\t\tif (n < mod)return ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n\t\tll ret = 1;\n\t\twhile (n || r) {\n\t\t\tll _n = n % mod, _r = r % mod;\n\t\t\tn /= mod; r /= mod;\n\t\t\t(ret *= nCr(_n, _r)) %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll _n, ll _mod) {\n\t\tmod = _mod;\n\t\tll n = min(_n+1, mod);\n\t\tfact.resize(n);\n\t\tfact[0] = 1;\n\t\tREP(i, n-1) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tinv.resize(n);\n\t\tinv[n-1] = mod_inv(fact[n-1]);\n\t\tfor (int i = n-1; i > 0; i--) {\n\t\t\tinv[i - 1] = inv[i] * i % mod;\n\t\t}\n\t}\n};\n\nll gcd(ll m, ll n) {\n\tif (n == 0)return m;\n\treturn gcd(n, m % n);\n}//gcd\n\nll lcm(ll m, ll n) {\n\treturn m / gcd(m, n) * n;\n}\n\nll popcount(ll x) {\n\tx = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n\tx = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n\tx = (x & 0x0F0F0F0F0F0F0F0F) + (x >> 4 & 0x0F0F0F0F0F0F0F0F);\n\tx = (x & 0x00FF00FF00FF00FF) + (x >> 8 & 0x00FF00FF00FF00FF);\n\tx = (x & 0x0000FFFF0000FFFF) + (x >> 16 & 0x0000FFFF0000FFFF);\n\tx = (x & 0x00000000FFFFFFFF) + (x >> 32 & 0x00000000FFFFFFFF);\n\n\treturn x;\n}\n\n\n\n\nll dp[2020][2020];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tll n, k;\n\tcin >> n >> k;\n\n\tCombination comb(n * k, MOD);\n\tdp[0][0] = 1;\n\tREP(i, n + 1) {\n\t\tREP(j, n + 1) {\n\t\t\tif (j > i)continue;\n\t\t\t(dp[i + 1][j] += dp[i][j]) %= MOD;\n\t\t\tif (i > j&& k > 1) {\n\t\t\t\t(dp[i][j + 1] += comb.nCr(n * k - i - j * (k - 1) - 1, k - 2) * dp[i][j] % MOD) %= MOD;\n\t\t\t}\n\t\t\telse dp[i][j + 1] = dp[i][j];\n\t\t}\n\t}\n\tcout << dp[n][n] * (k != 1 ? comb.fact[n] : 1) % MOD << endl;\n\n\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\ntypedef long long LL;\nconst int maxn=2005,TT=1000000007;\nint n,K,fac[maxn*maxn],inv[maxn*maxn],F[maxn][maxn];\ninline int read()\n{\n\tint ret=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){ret=ret*10+ch-'0';ch=getchar();}\n\treturn ret*f;\n}\ninline int QP(int a,int b)\n{\n\tint ret=1,w=a;\n\twhile(b)\n\t{\n\t\tif(b&1) ret=(LL)ret*w%TT;\n\t\tw=(LL)w*w%TT;b>>=1;\n\t}\n\treturn ret;\n}\ninline int C(int n,int m){return (LL)fac[n]*inv[m]%TT*inv[n-m]%TT;}\nint main()\n{\n\tn=read();K=read();fac[0]=1;\n\tfor(int i=1;i<=4000000;i++) fac[i]=(LL)fac[i-1]*i%TT;\n\tinv[4000000]=QP(fac[4000000],TT-2);\n\tfor(int i=4000000-1;i>=0;i--) inv[i]=(LL)inv[i+1]*(i+1)%TT;\n\tF[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t\tF[i][j]=(F[i-1][j]+(j?((LL)F[i][j-1]*(n-j+1)*C(n*K-i-(j-1)*(K-1)-1,K-2)):0))%TT;\n\tprintf(\"%d\\n\",F[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int MOD=1000000007;\nint n,k;\nLL fac[4000000],inv_fac[4000000],dp[2001];\nvoid check_mod(LL &a) { if (a>=MOD) a%=MOD; }\nint ksm(LL a, int b)\n{\n\tLL ret=1ll;\n\twhile (b) {\n\t\tif (b&1) ret*=a;\n\t\tcheck_mod(ret);\n\t\ta*=a;\n\t\tcheck_mod(a);\n\t\tb>>=1;\n\t}\n\treturn ret;\n}\nint main()\n{\n\tLL lt;\n\tint t;\n\tscanf(\"%d%d\",&n,&k);\n\tif (k==1) {\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\tt=n*k;\n\tfor (int i = 1; i < t; ++i) {\n\t\tfac[i]=1ll*i*fac[i - 1];\n\t\tcheck_mod(fac[i]);\n\t}\n\tinv_fac[t-1]=ksm(fac[t-1],MOD-2);\n\tfor (int i=t-2;i;--i) {\n\t\tinv_fac[i]=1ll*(i+1)*inv_fac[i+1];\n\t\tcheck_mod(inv_fac[i]);\n\t}\n\tinv_fac[0]=1;\n\tdp[0]=1;\n\tt=-2;\n\tfor (int i=1;i<=n;++i) {\n\t\tt+=k-1;\n\t\tfor (int j=0;j<=i;++j) {\n\t\t\t++t;\n\t\t\tlt=fac[t]*inv_fac[t-k+2];\n\t\t\tcheck_mod(lt);\n\t\t\tlt*=inv_fac[k-2];\n\t\t\tcheck_mod(lt);\n\t\t\tdp[j]*=lt;\n\t\t\tif (j) dp[j]+=dp[j - 1];\n\t\t\tcheck_mod(dp[j]);\n\t\t}\n\t\tt-=i+1;\n\t}\n\tprintf(\"%lld\\n\",dp[n]*fac[n]%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int maxn=2000+10;\nconst int p=1e9+7;\nint n,k,f[maxn][maxn],farc[maxn*maxn],inv[maxn*maxn];\n\nint C(int n,int m){\n\treturn (ll)farc[n]*inv[m]%p*(ll)inv[n-m]%p;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);k--;\n\tif(!k){printf(\"1\\n\");return 0;}\n\tfarc[0]=farc[1]=inv[0]=inv[1]=1;\n\tfor(int i=2;i<=n*k+n+k;i++){\n\t\tfarc[i]=(ll)farc[i-1]*i%p;\n\t\tinv[i]=(ll)(p-p/i)*inv[p%i]%p;\n\t}\n\tfor(int i=2;i<=n*k+n+k;i++) inv[i]=(ll)inv[i]*inv[i-1]%p;\n\tf[0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=i;j<=n;j++){\n\t\t\tif(i>0) f[i][j]=(f[i][j]+f[i-1][j])%p;\n\t\t\tif(j>0) f[i][j]=(f[i][j]+(ll)f[i][j-1]*C(i+(j-1)*k+k-1,k-1)%p)%p;\n\t\t}\n\tprintf(\"%d\\n\",(ll)f[n][n]*farc[n]%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <stack>\n#include <sstream>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nconst int maxn = 2005;\nlong long ksm(const long long &a, const long long &k)\n{\n\tlong long ans = 1;\n\tfor(long long x = a % mod, asd = k; asd; asd >>= 1, (x *= x) %= mod)\n\t\tif(asd & 1)\n\t\t\t(ans *= x) %= mod;\n\treturn ans;\n}\nlong long fac[maxn * maxn], invfac[maxn * maxn];\nlong long calc(const int &n, const int &k)\n{\n\tif(k < 0 || n < k)\n\t\treturn 0;\n\treturn fac[n] * invfac[k] % mod * invfac[n - k] % mod;\n}\nlong long dp[maxn][maxn];\nint main()\n{\n\tstd::ios::sync_with_stdio(false);\n\tint n, k;\n\tcin >> n >> k;\n\tif(n * k < n + k)\n\t{\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tfac[0] = 1;\n\tfor(int i = 1; i <= n * k; i ++)\n\t\tfac[i] = fac[i - 1] * i % mod;\n\tinvfac[n * k] = ksm(fac[n * k], mod - 2);\n\tfor(int i = n * k - 1; i >= 0; i --)\n\t\tinvfac[i] = invfac[i + 1] * (i + 1) % mod;\n\tdp[0][0] = 1;\n\tfor(int i = 1; i <= n; i ++)\n\t\tdp[0][i] = dp[0][i - 1] * calc(i * (k - 1) - 1, k - 2) % mod;\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = i; j <= n; j ++)\n\t\t\tdp[i][j] = (dp[i - 1][j] + dp[i][j - 1] * calc(j * (k - 1) + i - 1, k - 2)) % mod;\n\tcout << dp[n][n] * fac[n] % mod << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#define ll long long\n#define re register\n#define il inline\n#define fp(i,a,b) for(re int i=a;i<=b;++i)\n#define fq(i,a,b) for(re int i=a;i>=b;--i)\nusing namespace std;\nconst int N=2010,mod=1e9+7;\nint n,k,f[N][N],jc[N*N],inv[N*N],gu;\nil int gi()\n{\n  re int x=0,t=1;\n  re char ch=getchar();\n  while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n  if(ch=='-') t=-1,ch=getchar();\n  while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();\n  return x*t;\n}\nil ll ksm(re ll S,re ll n)\n{\n\tre ll T=S;S=1;\n  while(n)\n\t{\n\t\tif(n&1) S=S*T%mod;\n\t\tT=T*T%mod;\n\t\tn>>=1;\n\t}\n  return S;\n}\nil ll C(re int x,re int y)\n{\n\tif(x<0||y<0||x<y) return 0;\n\treturn 1ll*jc[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main()\n{\n  n=gi();k=gi();gu=N*N;\n\tif(k==1) {puts(\"1\");return 0;}\n\tjc[0]=inv[0]=1;\n\tfp(i,1,gu) jc[i]=1ll*jc[i-1]*i%mod;inv[gu]=ksm(jc[gu],mod-2);\n\tfq(i,gu-1,1) inv[i]=1ll*inv[i+1]*(i+1)%mod;\n  f[0][0]=1;\n\tfp(i,1,n)\n\t\tfp(j,0,i)\n\t{\n\t\t(f[i][j]+=f[i-1][j])%=mod;\n\t\tif(j) (f[i][j]+=C(n*k-(j-1)*(k-1)-i-1,k-2)*f[i][j-1]%mod*(n-j+1)%mod)%=mod;\n\t}\n  printf(\"%d\\n\",f[n][n]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Code by Enderturtle\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(register int i=a;i<=b;++i)\n#define repe(i,a) for(register int i=head[a];i;i=e[i].nxt)\n#define il inline\n#define pii pair<int,int>\n#define mp(a,b) make_pair(a,b)\ntypedef long long ll;\nusing namespace std;\nil void filejudge(){\n\tfreopen(\".in\",\"r\",stdin);\n\tfreopen(\".out\",\"w\",stdout);\n}\nil int read(){\n\tint x=0;bool f=1;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-') f=0;ch=getchar();}\n\twhile(isdigit(ch)){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}\n\treturn f?x:-x;\n}\n/*----- head end -----*/\nconst int N=2010,mod=1e9+7;\nll fac[N*N],inv[N*N];\n\nil ll ksm(ll x,ll y){\n\tll res=1;\n\twhile(y){\n\t\tif(y&1)\n\t\t\tres=res*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nil void init(){\n\tconst int ed=2000*2000;\n\tfac[0]=1;\n\trep(i,1,ed) fac[i]=fac[i-1]*i%mod;\n\tinv[ed]=ksm(fac[ed],mod-2);\n\tfor(register int i=ed-1;i>=1;--i) inv[i]=inv[i+1]*(i+1ll)%mod;\n\tinv[0]=1;\n}\nil ll c(int x,int y){ return fac[x]*inv[y]%mod*inv[x-y]%mod;}\n\nll dp[N][N];\nint n,k;\n\nil void add(ll &x,ll y){\n\tx+=y;\n\tif(x>=mod) x-=mod;\n}\n\nint main(){\n\tinit();\n\tn=read();k=read();\n\tif(k==1){puts(\"1\");return 0;}\n\tdp[0][0]=1;\n//\trep(i,1,n*n) cerr<<fac[i]<<' '<<inv[i]<<endl;\n\trep(i,0,n-1){\n\t\trep(j,i,n){\n\t\t\tif(dp[i][j]){\n\t\t\t\tif(i<j) add(dp[i+1][j],dp[i][j]);\n\t\t\t\tif(j<n) add(dp[i][j+1],c(i+j*(k-1)+k-2,k-2)*dp[i][j]%mod);\n\t\t\t//\tcerr<<i+j*(k-1)+k-1<<' '<<k-1<<endl;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n][n]*fac[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=2007,P=1000000007;\nint n,m,k,fac[N*N],ifac[N*N],f[N][N];\nvoid inc(int&a,int b){a+=b-P,a+=a>>31&P;}\nvoid mul(int&a,int b){a=1ll*a*b%P;}\nint C(int n,int m){return 1ll*fac[n]*ifac[m]%P*ifac[n-m]%P;}\nint pow(int a,int b){int r=1;for(;b;b>>=1,mul(a,a))if(b&1)mul(r,a);return r;}\nint main()\n{\n    scanf(\"%d%d\",&n,&k),m=n*k,f[0][0]=1;\n    if(k==1) return puts(\"1\"),0;\n    fac[0]=1;for(int i=1;i<=m;++i)mul(fac[i]=fac[i-1],i);\n    ifac[m]=pow(fac[m],P-2);for(int i=m;i;--i)mul(ifac[i-1]=ifac[i],i);\n    for(int i=0,z=k-1;i<=n;++i,z+=k-1)\n\tfor(int j=0;j<=i;++j)\n\t    inc(f[i+1][j],1ll*f[i][j]*C(z+j-1,k-2)%P),inc(f[i][j+1],f[i][j]);\n    mul(f[n][n],fac[n]),printf(\"%d\",f[n][n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2005, mod = 1e9+7;\n\nint dp[MAXN][MAXN];\nint n, k;\n\nint inv[MAXN*MAXN], fac[MAXN*MAXN], ifac[MAXN*MAXN];\n\ninline int choose(int n, int m)\n{\n\tif (n < m) return 0;\n\treturn (long long)fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint dfs(int i, int j)\n{\n\tif (j == 0 && i == 0) return 1;\n\tif (i < 0 || j < 0) return 0;\n\tif (dp[i][j] != -1) return dp[i][j];\n\tdp[i][j] = (dfs(i-1, j)+(long long)dfs(i+1, j-1)*choose((n-j+1)*k-(i+1)-1, k-2))%mod;\n\treturn dp[i][j];\n}\n\nint main()\n{\n\tcin >> n >> k;\n\tif (k == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tmemset(dp, -1, sizeof dp);\n\tinv[1] = 1;\n\tfor (int i = 2; i <= n*k; i++) inv[i] = (mod-(long long)mod/i*inv[mod%i]%mod)%mod;\n\tfac[0] = 1, ifac[0] = 1;\n\tfor (int i = 1; i <= n*k; i++)\n\t\tfac[i] = (long long)fac[i-1]*i%mod, ifac[i] = (long long)ifac[i-1]*inv[i]%mod;\n\tcout << (long long)dfs(0, n)*fac[n]%mod << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long i64;\n\nconst int MAXN = 2000 + 5;\nconst int MOD = 1e9 + 7;\n\nint N, K;\ni64 fact[MAXN * MAXN], inverse[MAXN * MAXN];\ni64 DP[MAXN][MAXN];\n\ni64 modularExp(i64 base, i64 exp)\n{\n\ti64 ret = 1;\n\twhile (exp)\n\t{\n\t\tif (exp & 1)\n\t\t\tret = ret * base % MOD;\n\t\tbase = base * base % MOD;\n\t\texp = exp >> 1;\n\t}\n\treturn ret;\n}\n\nvoid prepare()\n{\n\tfact[0] = 1;\n\tfor (int i = 1; i < MAXN * MAXN; i++)\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\n\tinverse[MAXN * MAXN - 1] = modularExp(fact[MAXN * MAXN - 1], MOD - 2) % MOD;\n\tfor (int i = MAXN * MAXN - 2; i >= 0; i--)\n\t\tinverse[i] = inverse[i + 1] * (i + 1) % MOD;\n\n\tassert(inverse[1] == 1);\n}\n\ni64 getC(int n, int m)\n{\n\treturn fact[n] * inverse[m] % MOD * inverse[n - m] % MOD;\n}\n\nint main()\n{\n\tprepare();\n\tcin >> N >> K;\n\n\tif(K == 1)\n\t\tcout << 1 << endl, exit(0);\n\n\tDP[0][0] = 1;\n\tfor (int i = 0; i <= N; i++)\n\t\tfor (int j = i; j <= N; j++)\n\t\t{\n\t\t\tDP[i][j + 1] = (DP[i][j + 1] + DP[i][j]) % MOD;\n\t\t\tDP[i + 1][j] = (DP[i][j] * getC(K * (N - i) - (j - i) - 1, K - 2)\n\t\t\t\t\t+ DP[i + 1][j]) % MOD;\n\t\t}\n\tcout << DP[N][N] * fact[N] % MOD << endl ;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int P = 1e9 + 7;\nconst int N = 2010 * 2010;\n\nint jc[N], jv[N], f[2010][2010];\nint qpow(int a, int b) {\n  int res = 1;\n  for (; b; b >>= 1) {\n    if (b & 1) res = (1ll * res * a) % P;\n    a = (1ll * a * a) % P;\n  }\n  return res;\n}\nint C(int n, int m) {\n  if (n < m) return 0;\n  return ((1ll * jc[n] * jv[m]) % P * jv[n - m]) % P;\n}\n\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n\n  int n, k;\n  std::cin >> n >> k;\n  if (k == 1) {\n    std::cout << 1 << '\\n';\n    return 0;\n  }\n  jc[0] = 1;\n  for (int i = 1; i <= n * k; ++i) jc[i] = (1ll * jc[i - 1] * i) % P;\n  for (int i = 0; i <= n * k; ++i) jv[i] = qpow(jc[i], P - 2);\n  \n  f[0][0] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j <= i; j++) {\n      f[i][j] = f[i - 1][j];\n      if (j) {\n        int tmp = (1ll * f[i][j - 1] * C(n - i + (n - j + 1) * (k - 1) - 1, k - 2)) % P;\n        tmp = (1ll * tmp * (n - j + 1)) % P;\n        f[i][j] = (f[i][j] + tmp) % P;\n      }\n    }\n  }\n  \n  std::cout << f[n][n] << '\\n';\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define SQRN 4000000\n#define Mod 1000000007ll\ntypedef long long ll;\nll jc[SQRN+50],inv[SQRN+50],f[2050][2050];\nint n,k;\ninline ll qpow(ll b,ll p){\n\tll res=1ll;\n\twhile(p){\n\t\tif(p&1) (res*=b)%=Mod;\n\t\tp>>=1ll;\n\t\t(b*=b)%=Mod;\n\t}return res;\n}\ninline ll C(ll x,ll y){\n\treturn jc[x]*inv[y]%Mod*inv[x-y]%Mod;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1)\n\t\treturn puts(\"1\"),0;\n\tjc[0]=1ll;\n\tfor(ll i=1;i<=SQRN;++i)\n\t\tjc[i]=jc[i-1]*i%Mod;\n\tinv[SQRN]=qpow(jc[SQRN],Mod-2ll);\n\tfor(ll i=SQRN;i>=1;--i)\n\t\tinv[i-1]=inv[i]*i%Mod;\n//\tprintf(\"** %lld\\n\",inv[10]);\n\tfor(int i=1;i<=n;++i)\n\t\tf[i][0]=1ll;\n\tfor(int i=1;i<=n;++i){\n//\t\tprintf(\"** %d: \",i);\n\t\tfor(int j=1;j<=i;++j){\n\t\t\t(f[i][j]=f[i-1][j]+f[i][j-1]*1ll*(n-j+1)%Mod*C(n-i+(n-j+1)*(k-1)-1,k-2)%Mod)%=Mod;\n//\t\t\tprintf(\"|* %lld %lld %lld *|\",f[i-1][j],f[i][j-1]*(n-j+1),C(n-1+(n-j+1)*(k-1),k-2));\n\t\t}\n//\t\tputs(\"\");\n\t}\n\tprintf(\"%lld\\n\",f[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\ninline int add(int a,int b)\n{a+=b;return a>=MOD?a-MOD:a;}\ninline int mul(int a,int b)\n{return 1LL*a*b%MOD;}\nint ksm(int a,int b)\n{\n\tint ans=1;\n\tfor(;b;b>>=1,a=mul(a,a))\n\t\tif(b&1)ans=mul(ans,a);\n\treturn ans;\n}\nconst int Q=2005;\nint fac[Q*Q],ifac[Q*Q];\nint F(int n,int m)\n{return mul(fac[n+m-1],mul(ifac[m-1],ifac[n]));}\nvoid Init(int n)\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfac[i]=mul(fac[i-1],i);\n\tifac[n]=ksm(fac[n],MOD-2);\n\tfor(int i=n;i;--i)\n\t\tifac[i-1]=mul(ifac[i],i);\n}\nint f[Q][Q];\nint main()\n{\n\tint n,k;\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1)return 0&puts(\"1\");\n\tInit(n*k);\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i;j>=0;--j)\n\t\t\tf[i][j]=add(f[i][j+1],j==0?0:mul(f[i-1][j-1],mul(n-i+1,F(k-2,(i-1)*k-(j-1)+1))));\n\tprintf(\"%d\\n\",f[n][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n/*\n2000 2000\n*/\n#include<cstdio>\nconst int N=2010,p=1e9+7,maxn=1e7+10;\nint dp[N][N],fac[maxn],f[maxn],inv[maxn];\nvoid init(){\n    fac[1]=1;inv[1]=1;\n    for(int i=2;i<=maxn-10;i++){\n        fac[i]=1ll*fac[i-1]*i%p;\n        inv[i]=1ll*(p-p/i)*inv[p%i]%p;\n   \t}\n    f[1]=inv[1];\n    for(int i=2;i<=maxn-10;i++)\n        f[i]=1ll*f[i-1]*inv[i]%p;\n}\nint C(int n,int m){\n    if(n==m||m==0)return 1;\n    return 1ll*fac[n]*f[m]%p*f[n-m]%p;\n}\nint main(){\n\tinit();\n\tint n,k;\n\tscanf(\"%d%d\",&n,&k);\n\tdp[0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=i;j<=n;j++){\n\t\t\tif(i)dp[i][j]=dp[i-1][j];\n\t\t\tif(j)dp[i][j]=(dp[i][j]+dp[i][j-1]*1ll*C(i+j*(k-1)-1,k-2))%p;\n\t\t}\n\tprintf(\"%lld\\n\",dp[n][n]*1ll*fac[n]%p);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define LL long long\n#define RG register\n#define R RG int\nusing namespace std;\nconst LL N=2009,M=N*N,YL=1e9+7;\nint f[N][N],fac[M],inv[M];\ninline int fm(RG LL b){\n    RG LL a=1;\n    for(R k=YL-2;k;k>>=1,b=b*b%YL)\n        if(k&1)a=a*b%YL;\n    return a;\n}\ninline int C(R n,R m){\n    if(n<0||m<0||n<m)return 0;\n    return(LL)fac[n]*inv[m]%YL*inv[n-m]%YL;\n}\nint main(){\n    R n,k,nk;\n    scanf(\"%d%d\",&n,&k);nk=n*k;\n    if(k==1)return puts(\"1\"),0;\n    for(R i=fac[0]=1;i<=nk;++i)\n        fac[i]=fac[i-1]*(LL)i%YL;\n    inv[nk]=fm(fac[nk]);\n    for(R i=nk;i;--i)\n        inv[i-1]=inv[i]*(LL)i%YL;\n    f[0][0]=1;\n    for(R i=1;i<=n;++i)\n        for(R j=f[i][0]=1;j<=i;++j)\n            f[i][j]=(f[i-1][j]+(LL)f[i][j-1]*(n-j+1)%YL*C(n-i+(n-j+1)*(k-1)-1,k-2))%YL;\n    printf(\"%d\\n\",f[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int __SIZE = 1 << 18;\nchar ibuf[__SIZE], *iS, *iT;\n\n#define ge (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n#define ri read_int()\n#define rl read_ll()\n#define FILE(s) freopen(s\"in\", \"r\", stdin), freopen(s\"out\", \"w\", stdout)\n\ntemplate<typename T>\ninline void read(T &x) {\n\tchar ch, t = 0; x = 0;\n\twhile(!isdigit(ch = ge)) t |= ch == '-';\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = ge;\n\tx = t ? -x : x;\n}\ninline int read_int() { int x; return read(x), x; }\ninline ll read_ll() { ll x; return read(x), x; }\n\ntemplate<typename T>\ninline void chkmin(T&a, T b) { a = a < b ? a : b; }\n\nconst int MAXN = 2010;\nconst int mod = 1e9 + 7;\n\ninline int ksm(int x, int k = mod - 2) {\n\tint s = 1;\n\twhile(k) {\n\t\tif(k & 1) s = 1LL * s * x % mod;\n\t\tx = 1LL * x * x % mod, k >>= 1;\n\t} return s;\n}\n\nint fac[MAXN * MAXN];\nint ifac[MAXN * MAXN];\nint f[MAXN][MAXN];\n\ninline void init(int n) {\n\tfac[0] = 1;\n\tfor(int i = 1; i <= n; i++) fac[i] = 1LL * fac[i - 1] * i % mod;\n\tifac[n] = ksm(fac[n]);\n\tfor(int i = n; i >= 1; i--) ifac[i - 1] = 1LL * ifac[i] * i % mod;\n}\n\ninline int C(int n, int m) {\n\treturn 1LL * fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nint main() {\n#ifdef LOCAL\n\tFILE(\"\");\n#endif\n\n\tint n = ri, k = ri, N = n * k;\n\tinit(N);\n\n\tfor(int i = 0; i <= n; i++) f[i][0] = 1;\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 0; j <= i; j++)\n\t\t\tif(j) f[i][j] = (f[i - 1][j] + 1LL * f[i][j - 1] * C(N - i - (j - 1) * (k - 1) - 1, k - 2)) % mod;\n\t\t\telse f[i][j] = f[i - 1][j];\n\n\tprintf(\"%lld\\n\", 1LL * f[n][n] * fac[n] % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int MAXN = 2000 , MAXM = MAXN * MAXN , Mod = 1e9 + 7;\nint n , k , Fac[ MAXM + 5 ] , Inv[ MAXM + 5 ] , dp[ MAXN + 5 ][ MAXN + 5 ];\n\nint Quick_pow( int x , int po ) {\n\tint Ans = 1;\n\tfor( ; po ; po >>= 1 , x = 1ll * x * x % Mod )\n\t\tif( po & 1 ) Ans = 1ll * Ans * x % Mod;\n\treturn Ans;\n}\nvoid Init( ) {\n\tFac[ 0 ] = 1;\n\tfor( int i = 1 ; i <= MAXM ; i ++ )\n\t\tFac[ i ] = 1ll * Fac[ i - 1 ] * i % Mod;\n\tInv[ MAXM ] = Quick_pow( Fac[ MAXM ] , Mod - 2 );\n\tfor( int i = MAXM - 1 ; i >= 0 ; i -- )\n\t\tInv[ i ] = 1ll * Inv[ i + 1 ] * ( i + 1 ) % Mod;\n}\nint C( int n , int m ) {\n\treturn 1ll * Fac[ n ] * Inv[ m ] % Mod * Inv[ n - m ] % Mod;\n}\n\nint main( ) {\n\tInit( );\n\tscanf(\"%d %d\",&n,&k);\n\tif( k == 1 ) return !printf(\"%d\\n\", 1 );\n\t\n\tfor( int i = 1 ; i <= n ; i ++ )\n\t\tdp[ i ][ 0 ] = 1;\n\tfor( int i = 1 ; i <= n ; i ++ )\n\t\tfor( int j = 1 ; j <= i ; j ++ )\n\t\t\tdp[ i ][ j ] = ( dp[ i - 1 ][ j ] + 1ll * dp[ i ][ j - 1 ] * ( n - j + 1 ) % Mod * C( n * k - i - ( j - 1 ) * ( k - 1 ) - 1 , k - 2 ) % Mod ) % Mod;// , printf(\"%d%c\",dp[i][j],j==i?'\\n':' ');\n\tprintf(\"%d\\n\", dp[ n ][ n ] );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint exp(int x, int n) {\n    int ret = 1;\n    while(n) {\n        if(n & 1) ret = 1LL * ret * x % mod;\n        x = 1LL * x * x % mod;\n        n >>= 1;\n    }\n    return ret;\n}\nint inv(int x) {\n    return exp(x, mod - 2);\n}\nint fact[5000010], invf[5000010];\nint comb(int n, int k) {\n    return 1LL * fact[n] * invf[k] % mod * invf[n - k] % mod;\n}\nint H(int n, int k) {\n    return comb(n + k - 1, k);\n}\n\nint N, K;\n\nint cc[2010][2010];\nint dp(int n, int r) {\n    if(n == -1) return 1;\n    int &ret = cc[n][r];\n    if(ret != -1) return ret;\n\n    ret = 0;\n\n    int rem = (N - r) - (N - 1 - n);\n    int len = (N - r) * (K - 1) + (N - 1 - n);\n\n    if(rem) {\n        ret += dp(n - 1, r);\n        ret %= mod;\n    }\n    if(r) {\n        ret += 1LL * r * H(len + 1, K - 2) % mod * dp(n, r - 1) % mod;\n        ret %= mod;\n    }\n    return ret;\n}\n\nint main() {\n    fact[0] = 1;\n    for(int i = 1; i < 5000010; i++) {\n        fact[i] = 1LL * fact[i - 1] * i % mod;\n    }\n    for(int i = 0; i < 5000010; i++) {\n        invf[i] = inv(fact[i]);\n    }\n\n    cin >> N >> K;\n\n    if(K == 1) {\n        printf(\"1\");\n        return 0;\n    }\n\n    memset(cc, -1, sizeof(cc));\n    printf(\"%d\", dp(N - 1, N));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define il inline\n#define ri register int\n#define pb push_back\n#define mp make_pair\n#define fir first\n#define sec second\n#define mid ((l+r)>>1)\n#define MAXN 2050\n#define MAXM MAXN * MAXN\n#define mod 1000000007\n#define inf (1<<30)\n#define eps (1e-6)\n#define alpha 0.75\n#define rep(i, x, y) for(ri i = x; i <= y; ++i)\n#define repd(i, x, y) for(ri i = x; i >= y; --i)\n#define file(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, int> pli;\ntypedef pair <int, ll> pil;\ntypedef pair <ll, ll> pll;\ntemplate <typename T> il bool chkmin(T &x, T y) {return x > y ? x = y, 1 : 0;}\ntemplate <typename T> il bool chkmax(T &x, T y) {return x < y ? x = y, 1 : 0;}\ntemplate <typename T> il void read(T &x) {\n\tchar ch = getchar(); int f = 1; x = 0;\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = x*10+ch-'0', ch = getchar();\n\tx *= f;\n}\ntemplate <typename T, typename... Args> il void read(T &x, Args &...args) {\n\tread(x), read(args...);\n}\nint n, k;\nll fac[MAXM], invf[MAXM], dp[MAXN][MAXN];\nll fpow(ll x, ll y) {\n\tll ret = 1;\n\twhile(y) {\n\t\tif(y & 1) ret = ret * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn ret;\n}\nll C(int n, int m) {\n\treturn fac[n] * invf[m] % mod * invf[n-m] % mod;\n}\nint main() {\n\tread(n, k);\n\tfac[0] = 1;\n\trep(i, 1, n*k) fac[i] = fac[i-1] * i % mod;\n\tinvf[n*k] = fpow(fac[n*k], mod-2);\n\trepd(i, n*k, 1) invf[i-1] = invf[i] * i % mod;\n\tdp[0][0] = 1;\n\trep(j, 1, n) dp[0][j] = dp[0][j-1] * C(j*(k-1)-1, k-2) % mod;\n\trep(i, 1, n)\n\t\trep(j, i, n)\n\t\t\tdp[i][j] = (dp[i-1][j] + dp[i][j-1] * C(j*(k-1)+i-1, k-2)) % mod;\n\tcout << dp[n][n] * fac[n] % mod << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\nusing namespace std;\n\ntypedef long long LL;\n\ninline int read()\n{\n\tchar c=getchar();int num=0,f=1;\n\tfor(;!isdigit(c);c=getchar())\n\t\tf=c=='-'?-1:f;\n\tfor(;isdigit(c);c=getchar())\n\t\tnum=num*10+c-'0';\n\treturn num*f;\n}\n\nconst int N=2e3+5;\nconst int M=N*N;\nconst int mod=1e9+7;\n\ninline void add(int &x,int y){(x+=y)>=mod?x-=mod:0;}\n\nint ksm(int x,int k)\n{\n\tint res=1;\n\tfor(;k;k>>=1,x=1ll*x*x%mod)\n\t\tif(k&1) res=1ll*res*x%mod;\n\treturn res;\n}\n\nint n,k;\nint f[N][N],fac[M],ifac[M];\n\nint C(int n,int m){return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;}\n\nint main()\n{\n\tn=read(),k=read();\n\tif(k==1)\n\t{\n\t\tcout<<1;\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\tfor(int i=1;i<=n*k;++i) fac[i]=1ll*fac[i-1]*i%mod;\n\tifac[n*k]=ksm(fac[n*k],mod-2);\n\tfor(int i=n*k-1;~i;--i) ifac[i]=1ll*ifac[i+1]*(i+1)%mod;\n\tf[0][0]=1;\n\tfor(int i=0;i<=n;++i)\n\t{\n\t\tfor(int j=0;j<=i;++j)\n\t\t{\n\t\t\tif(i) add(f[i][j],f[i-1][j]);\n\t\t\tif(j) add(f[i][j],1ll*f[i][j-1]*C(n-i+(n-j+1)*(k-1)-1,k-2)%mod);\n\t\t}\n\t}\n\tcout<<1ll*f[n][n]*fac[n]%mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<assert.h>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define fo(i,a,b) for(int i=(a);i<=(b);++i)\n#define fd(i,b,a) for(int i=(b);i>=(a);--i)\n#define mset(a,x) memset(a,x,sizeof(a))\ntemplate<typename T> bool chkmin(T &a,const T &b) {return b<a?a=b,1:0;}\ntemplate<typename T> bool chkmax(T &a,const T &b) {return b>a?a=b,1:0;}\nusing namespace std;\ntypedef long long ll;\nint read(){int n=0,p=1;char ch;for(ch=getchar();ch<'0' || ch>'9';ch=getchar())if(ch=='-') p=-1;for(;'0'<=ch && ch<='9';ch=getchar()) n=n*10+ch-'0';return n*p;}\nconst int N=2005,M=8e6,mo=1e9+7;\nll qmi(ll x,ll n)\n{\n\tll t=1;\n\tfor(x%=mo;n;n>>=1,x=x*x%mo) if(n&1) t=t*x%mo;\n\treturn t;\n}\nll fac[M+5],inv[M+5],f[N][N];\nll C(ll m,ll n){return fac[m]*inv[n]%mo*inv[m-n]%mo;}\nvoid inc(ll &x,ll y){x=(x+y)%mo;}\nint n,m;\nll calc(ll m,ll n)\n{\n\treturn C(m+n-1,m-1);\n}\nint main()\n{\n\tfac[0]=inv[0]=1;fo(i,1,M) fac[i]=fac[i-1]*i%mo;\n\tinv[M]=qmi(fac[M],mo-2);\n\tfd(i,M-1,1) inv[i]=inv[i+1]*(i+1)%mo;\n\tn=read(),m=read();\n\tif(m==1) return puts(\"1\"),0;\n\tf[0][0]=1;\n\tfo(i,0,n)\n\t{\n\t\tfo(j,0,i)\n\t\t{\n\t\t\tif(j<i) inc(f[i][j+1],f[i][j]);\n\t\t\tinc(f[i+1][j],f[i][j]*calc(j+i*(m-1)+1,m-2)%mo);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[n][n]*fac[n]%mo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\ntypedef long long ll ;\n#define F first\n#define S second\n#define pb push_back\n#define pii pair<int ,int>\n//#define int long long\nconst int N = 2005 , N1 = 4e6 + 5  ;\nconst int mod = 1e9 + 7 ;\nint n , k ,f[N1] , fi[N1] , dp[N][N] , sum[2 * N] , t  ;\nint poww(int x , int y){\n    if(y == 0) return 1 ;\n    int tmp = poww(x , y / 2);\n    tmp = (1ll * tmp * tmp) % mod ;\n    if(y % 2) tmp = (1ll * tmp * x) % mod ;\n    return tmp ;\n}\nint c(int a , int b){\n    if(b > a) return 0 ;\n    return (((1ll * f[a] * fi[b]) % mod) * fi[a - b]) % mod ;\n}\nint ps(int a , int b){\n    t = max(t, a) ;\n    if(b == 0) return sum[a];\n    int ans = sum[a] - sum[b - 1] ;\n    return (1ll * ans + mod) % mod ;\n}\nint32_t main (){\n    ios_base::sync_with_stdio(0) ;\n    cin.tie(0) ;\n    cout.tie(0) ;\n    //freopen (\"input.txt\",\"r\",stdin);\n    //freopen (\"output.txt\",\"w\",stdout);\n    cin >> n >> k ;\n    f[0] = 1 ;\n    fi[0] = 1 ;\n    for(int i = 1 ; i < N1 ; i++) f[i] = (1ll * f[i - 1] * i) % mod ;\n    fi[N1 - 1] = poww(f[N1 - 1] , mod - 2) ;\n    for(int i = N1 - 2 ; i ; i--) fi[i] = (1ll * fi[i + 1] * (i + 1)) % mod ;\n    sum[1] = 1 ;\n    for(int i = 2 ;i <= n ; i++ ) sum[i] = sum[i - 1] ;\n    for(int j = 2 ; j <= n ; j++){\n        for(int i = 0 ; i <= j ; i++){\n            dp[i][j] = (((1ll * j * c(j * k - i - 1 , k - 2)) % mod) * ps(i - 1 + j - 1 , i - 1)) % mod ;\n        }\n        sum[0] = dp[0][j] ;\n        for(int i = 1;  i <= n ; i++){\n            sum[i] = (sum[i - 1] + dp[i][j]) % mod ;\n        }\n        for(int i = n + 1 ; i <= 2 * n ; i++) sum[i] = sum[i - 1] ;\n    }\n    //cout << \"max alloc = \" << t << \"\\n\" ;\n    return cout << sum[n] , 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nconst int mod=1e9+7,N=2e3+50;\ninline int add(int x,int y) {return (x+y>=mod)?(x+y-mod):(x+y);}\ninline int mul(int x,int y) {return (LL)x*y%mod;}\ninline int power(int a,int b) {\n    int rs=1;\n    for(;b;b>>=1,a=mul(a,a)) if(b&1) rs=mul(rs,a);\n    return rs;\n}\nint n,k,dp[N][N],fac[N*N*2],ifac[N*N*2];\ninline int C(int x,int y) {return mul(ifac[x-y],mul(fac[x],ifac[y]));}\nint main() {\n    cin>>n>>k; int l=2*n*k;\n    if(k==1) {puts(\"1\"); return 0;}\n    fac[0]=1;\n    for(int i=1;i<=l;i++) fac[i]=mul(fac[i-1],i);\n    ifac[l]=power(fac[l],mod-2);\n    for(int i=l-1;~i;i--) ifac[i]=mul(ifac[i+1],i+1);\n    dp[0][0]=1;\n    for(int i=1;i<=n;i++)\n        for(int j=0;j<=i;j++) {\n            if(j==i) dp[i][j]=dp[i][j-1];\n            else dp[i][j]=add(dp[i][j-1],mul(dp[i-1][j],C(k-2+(i-1)*k-(i-j-1),k-2)));\n        }\n    printf(\"%d\\n\",mul(dp[n][n],fac[n]));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for(int i = (a), i##_end_ = (b); i <= i##_end_; ++i)\n#define drep(i, a, b) for(int i = (a), i##_end_ = (b); i >= i##_end_; --i)\n#define clar(a, b) memset((a), (b), sizeof(a))\n#define debug(...) fprintf(stderr, __VA_ARGS__)\ntypedef long long LL;\ntypedef long double LD;\nconst int BUF_SIZE = (int)1e6 + 10;\nstruct fastIO {\n\tchar buf[BUF_SIZE], buf1[BUF_SIZE];\n\tint cur, cur1; FILE *in, *out;\n\tfastIO() { cur = BUF_SIZE, in = stdin, out = stdout; cur1 = 0; }\n\tinline char getchar() { if(cur == BUF_SIZE) fread(buf, BUF_SIZE, 1, in), cur = 0; return *(buf + (cur++)); }\n\tinline void putchar(char ch) { *(buf1 + (cur1++)) = ch; if (cur1 == BUF_SIZE) fwrite(buf1, BUF_SIZE, 1, out), cur1 = 0; } inline int flush() { if (cur1 > 0) fwrite(buf1, cur1, 1, out); return cur1 = 0; }\n}IO;\n#define getchar IO.getchar\n#define putchar IO.putchar\nLL read() {\n\tchar ch = getchar();\n\tLL x = 0, flag = 1;\n\tfor (;!isdigit(ch); ch = getchar()) if (ch == '-') flag *= -1;\n\tfor (;isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n\treturn x * flag;\n}\nvoid write(LL x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x >= 10) write(x / 10);\n\tputchar(x % 10 + 48);\n}\n\nconst int Maxn = 4009, Mod = 1e9 + 7;\nint n, k, fac[Maxn * Maxn / 4], invFac[Maxn * Maxn / 4];\n\nLL fpm(LL base, LL tims) {\n\tLL r = 1;\n\twhile (tims) {\n\t\tif (tims & 1) r = r * 1ll * base % Mod;\n\t\tbase = base * 1ll * base % Mod;\n\t\ttims >>= 1;\n\t}\n\treturn r;\n}\n\nvoid init() {\n\tn = read(), k = read();\n\tfac[0] = 1;\n\trep (i, 1, n * k) fac[i] = fac[i - 1] * 1ll * i % Mod;\n\tinvFac[n * k] = fpm(fac[n * k], Mod - 2);\n\tdrep (i, n * k - 1, 0) invFac[i] = invFac[i + 1] * (i + 1ll) % Mod;\n}\n\nLL C(int n, int m) {\n\tif (n < m) return 0;\n\treturn 1ll * fac[n] * invFac[m] % Mod * invFac[n - m] % Mod;\n}\n\nLL dp[Maxn][Maxn];\nvoid solve() {\n\tdp[0][0] = 1;\n\trep (i, 0, n)\n\t\trep (j, 0, i) {\n\t\t\t(dp[i + 1][j] += dp[i][j]) %= Mod;\n\t\t\t(dp[i][j + 1] += dp[i][j] * 1ll * C(n * k - i - j * (k - 1) - 1, k - 2) % Mod) %= Mod;\n\t\t}\n\tcout << 1ll * dp[n][n] * fac[n] % Mod << endl;\n}\n\nint main() {\n//\tfreopen(\"bosky.in\", \"r\", stdin);\n//\tfreopen(\"bosky.out\", \"w\", stdout);\n\n\tinit();\n\tsolve();\n\n#ifdef Qrsikno\n\tdebug(\"\\nRunning time: %.3lf(s)\\n\", clock() * 1.0 / CLOCKS_PER_SEC);\n#endif\n\treturn IO.flush();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define IL inline\n#define RG register\n#define LL long long\n#define Upd(a) (a)>=mod?(a-=mod):1\nusing namespace std;\ntemplate <class T>\nIL char gc () {\n\tstatic char buf[1<<6], *p1=buf, *p2=buf;\n\treturn (p1==p2) && (p2=(p1=buf)+fread(buf,1,1<<6,stdin), p1==p2) ?EOF:*p1++;\n}\ntemplate <typename T>\nIL void read (T&data) {\n\tdata=0;\n\tRG char ch=0;\n\twhile (ch<'0' || ch>'9') ch=getchar();\n\twhile (ch<='9' && ch>='0') data=(data<<1)+(data<<3)+(ch&15), ch=getchar();\n}\nconst int mod = 1e9+7;\nconst int _ =2001;\nint n, k;\nint dp[2][_], jc[_*_], jcn[_*_];\nIL int poww (RG int a, RG int b) {\n\tRG int ret=1, Base=a;\n\tfor (;b;b>>=1, Base=1LL*Base*Base%mod) if (b&1) ret=1LL*ret*Base%mod;\n\treturn ret;\n}\nIL int C (RG int a, RG int b) {\n\tif (a<b) return 0;\n\treturn 1LL*jc[a]*jcn[b]%mod*jcn[a-b]%mod;\n}\nint main (/*int aa, int bb*/) {\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\t//n=aa, k=bb;\n\tread(n), read(k);\n\tif (k<=1) {puts(\"1\"); return 0;}\n\tjc[0]=jcn[0]=1;\n\tRG int i, j, pre=1, cur=0;\n\tfor (i=1; i<=n*k; ++i) jc[i]=1LL*jc[i-1]*i%mod, jcn[i]=poww(jc[i], mod-2);\n\tdp[0][0]=1;\n\tfor (i=1; i<=n*2; ++i) {\n\t\tswap(cur, pre);\n\t\tfor (j=0; j<min(i,n+1); ++j) dp[cur][j]=0;\n\t\tfor (j=1; j<=min(i,n); ++j) {\n\t\t\tif ((i-j)%2) continue;\n\t\t\tif (n*2-i+1<j) break;\n\t\t\tRG int a=(i+j-2)>>1, b=(i-j)>>1;\n\t\t\tdp[cur][j]=1LL*dp[pre][j-1]*C(a*(k-1)+b+k-1-1,k-1-1)%mod;\n\t\t\tdp[cur][j]+=dp[pre][j+1];\n\t\t\tUpd(dp[cur][j]);\n\t\t}\n\t\tif (cur%2==0) dp[cur][0]=dp[pre][1];\n\t}\n\t//return 1LL*dp[cur][0]*jc[n]%mod;\n\tprintf(\"%lld\",1LL*dp[cur][0]*jc[n]%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\nusing namespace std;\nconst int mod=1e9+7;\nint n,m,fac[4000010],ifc[4000010],dp[2010][2010];\nint pow(int k,int i)\n{\n\tint t=1;\n\twhile(i)\n\t{\n\t\tif(i&1) t=1ll*t*k%mod;\n\t\tk=1ll*k*k%mod;i>>=1;\n\t}\n\treturn t;\n}\nint C(int x,int y)\n{\n\tif(x<y) return 0;\n\treturn 1ll*fac[x]*ifc[y]%mod*ifc[x-y]%mod;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tif(m==1) {puts(\"1\"); return 0;}\n\tfac[0]=1;dp[0][0]=1;\n\tfor(int i=1;i<=n*m;++i) fac[i]=1ll*fac[i-1]*i%mod;\n\tifc[n*m]=pow(fac[n*m],mod-2);\n\tfor(int i=n*m-1;~i;--i) ifc[i]=1ll*ifc[i+1]*(i+1)%mod;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<=i;++j)\n\t\t{\n\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\tif(!j) continue;\n\t\t\tdp[i][j]=(dp[i][j]+1ll*dp[i][j-1]*C(n*m-i-(j-1)*(m-1)-1,m-2))%mod;\n\t\t}\n\tprintf(\"%lld\\n\",1ll*dp[n][n]*fac[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = (int)1e9 + 7;\nconst int MAXN = 2000 + 10;\nint n, k;\nint cnt;\n\nint a[MAXN], b[MAXN], t[MAXN];\nbool vis[MAXN];\n\nint tot;\n\nset<string> ans;\n\nvoid dfs(int dep)\n{\n\tif(dep == cnt + 1)\n\t{\n\t\tmemset(t,0,sizeof(t));\n\t\t\n\t\tfor(int i = 1; i <= cnt; i++)\n\t\t\tt[i] = a[b[i]];\n\t\t\t\n    \tbool h[MAXN];\n\t\tmemset(h,false,sizeof(h));\n\t\t\n\t\tfor(int i = 1; i <= cnt; i++)\n\t\t{\n\t\t\tif(!h[t[i]])\n\t\t\t{\n\t\t\t\th[t[i]] = true;\n\t\t\t\tt[i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tstring str = \"\";\n\t\tfor(int i = 1; i <= cnt; i++)\n\t\t\tstr += t[i] + '0' + ',';\n\t\tans.insert(str);\n\t\t\t\t\n\t\treturn; \n\t}\n\tfor(int i = 1; i <= cnt; i++)\n\t{\n\t\tif(!vis[i])\n\t\t{\n\t\t\tvis[i] = true;\n\t\t\tb[dep] = i;\n\t\t\tdfs(dep + 1);\n\t\t\tvis[i] = false;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin >> n >> k;\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= k; j++)\n\t\t\ta[++cnt] = i;\n\t\n\tdfs(1);\n\t\n\tcout << ans.size() % MOD << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\npublic:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\nprivate:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\nconstexpr int md = (int)1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nMint dp[2010][2010];\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, k;\n  cin >> n >> k;\n  if (k == 1) {\n    cout << 1;\n    return 0;\n  }\n  vector<Mint> fac(n * k + 1), ifac(n * k + 1);\n  fac[0] = 1;\n  for (int i = 1; i <= n * k; ++i) fac[i] = fac[i - 1] * i;\n  ifac[n * k] = 1 / fac[n * k];\n  for (int i = n * k; i; --i) ifac[i - 1] = ifac[i] * i;\n  function<Mint(int, int)> binom = [&](int n, int m) {return fac[n] * ifac[m] * ifac[n - m]; };\n  dp[0][0] = 1;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 0; j <= i; ++j) {\n      if (i > j)\n        dp[i][j] += dp[i - 1][j] * binom((i - 1) * (k - 1) + j + k - 2, k - 2);\n      if (j > 0)\n        dp[i][j] += dp[i][j - 1];\n    }\n  cout << (dp[n][n] * fac[n]);\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#if __cplusplus >= 201103L\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n#pragma comment(linker, \"/STACK:1024000000,1024000000\") \n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define EPS 1e-10\n#define set0(x) memset((x),0,sizeof(x))\n#define setINF(x) memset((x),63,sizeof(x))\nusing namespace std;\nint n,k;\nlong long fac[4000005],inv[4000005],dp[2005][2005];\ninline long long fpow(long long x,long long y){\n\tif(y==1)return x;\n\tlong long t=fpow(x,y>>1);\n\tt=t*t%MOD;\n\tif(y&1)t=t*x%MOD;\n\treturn t;\n}\ninline long long C(long long x,long long y){\n\treturn (fac[x]*inv[y]%MOD)*inv[x-y]%MOD;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin>>n>>k;\n\tif(k==1){\n\t\tcout<<\"1\\n\";\n\t\treturn 0;\n\t}\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=n*n;i++){\n\t\tfac[i]=fac[i-1]*i%MOD;\n\t\tinv[i]=fpow(fac[i],MOD-2);\n\t}\n\tdp[0][0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=i;j<=n;j++){\n\t\t\tif(i)dp[i][j]=dp[i-1][j]%MOD;\n\t\t\tif(j>i)dp[i][j]=(dp[i][j]+1ll*dp[i][j-1]*C(j*(k-1)+i-1,k-2)%MOD)%MOD;\n\t\t}\n\t}\n\tcout<<(1ll*dp[n][n]*fac[n])%MOD<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define uint unsigned\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){\n\tint x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n\twrite(a); puts(\"\");\n}\nconst int N=2005,mod=1000000007;\nint n,k,c[N*N],dp[N][N];\ninline void add(int &a,ll b){\n\ta=(a+b)%mod;\n}\ninline int ksm(ll a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1){\n\t\tif(b&1)ans=ans*a%mod;\n\t\ta=a*a%mod;\n\t}\n\treturn ans;\n}\nint main(){\n\tn=read(); k=read();\n\tif(k==1){puts(\"1\"); return 0;}\n\tc[k-2]=1; for(int i=k-1;i<=n*k;i++)c[i]=(ll)c[i-1]*i%mod*ksm(i-(k-2),mod-2)%mod;\n\tdp[0][0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=i;j<=n;j++){\n\t\t\tadd(dp[i+1][j],(ll)dp[i][j]*c[n*k-i*(k-1)-j-1]);\n\t\t\tadd(dp[i][j+1],dp[i][j]);\n\t\t\t//cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n\t\t}\n\t}\n\tll ans=dp[n][n];\n\tfor(int i=1;i<=n;i++)ans=ans*i%mod;\n\tcout<<ans<<endl;\n}\n/*\n5*4*3=4*3*2\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\nconst int FACT_SIZE=9111111;\nint fact[FACT_SIZE];\nint inv[FACT_SIZE];\nstruct fact_exec{\n    fact_exec(){\n        fact[0]=1;\n        for(int i=1;i<FACT_SIZE;i++)fact[i]=fact[i-1]*i%mod;\n        inv[FACT_SIZE-1]=mpow(fact[FACT_SIZE-1],mod-2);\n        for(int i=FACT_SIZE-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    }\n}factexec;\nint nCk(int n,int k){\n    if(n<0|k<0||k>n)return 0;\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\nint nPk(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*inv[n-k]%mod;\n}\n\nint dp[2222][2222];\n\nsigned main(){\n    int N,K;\n    cin>>N>>K;\n\n    if(K==1){\n        cout<<1<<endl;\n        return 0;\n    }\n\n    dp[0][0]=1;\n    for(int i=0;i<=N;i++){\n        for(int j=0;j<=N;j++){\n            if(i<N&&i<=j)add(dp[i+1][j],dp[i][j]);\n            if(j<N){\n                add(dp[i][j+1],dp[i][j]*nCk(K-2+i-1+j*(K-1),K-2)%mod);\n            }\n        }\n    }\n\n    cout<<dp[N][N]*fact[N]%mod<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Be Name Khoda, Besmellah Rahmane Rahim, In The Name Of God;\n//#include<bits/stdc++.h>\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <deque>\n#include <map>\n#include <stack>\n#include<bitset>\n#include<list>\n#include<cassert>\n#include<numeric>\n#include <stdio.h>\n#include <string.h>\n#include<iomanip>\n#include<unordered_map>\n#include<unordered_set>\n\nusing namespace std;\n\nconst long long N = 2e3 + 5;\nconst long long mod = 1e9 + 7;\nlong long dp[N][N];\nlong long fact[N * N];\nlong long n, k;\n//dp[i][j] = the number of ways when i zero has come and j colorful ball has come\n\n\nvoid pre()\n{\n\tfact[0] = 1;\n\tfor (long long i = 1; i < N * N; i++)\n\t{\n\t\tfact[i] = fact[i - 1] * i;\n\t\tfact[i] = fact[i] % mod;\n\t}\n}\n\nlong long power(long long a, long long b)\n{\n\tif (!b)\n\t{\n\t\treturn 1;\n\t}\n\tlong long ans = power(a, b / 2);\n\tans = ans * ans;\n\tans = ans % mod;\n\tif (b % 2)\n\t{\n\t\tans = ans * a;\n\t\tans = ans % mod;\n\t}\n\treturn ans % mod;\n}\n\nlong long choose(long long a, long long b)\n{\n\tif (a > b)\n\t{\n\t\treturn 0;\n\t}\n\tlong long ans = fact[b];\n\tans = ans * power(fact[a], mod - 2);\n\tans = ans % mod;\n\tans = ans * power(fact[b - a], mod - 2);\n\tans = ans % mod;\n\treturn ans;\n}\n\n\nint main()\n{\n\tstd::ios::sync_with_stdio(false);\n\tcin.tie(0);\n\tpre();\n\tcin >> n >> k;\n\tdp[0][0] = 1;\n\tfor (int i = 0; i <= n; i++)\n\t{\n\t\tfor (int j = 0; j <= n; j++)\n\t\t{\n\t\t\t// the i + j * (k - 1) + 1th ball \n\t\t\tif (j > i)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == j) // this ball only can be zero\n\t\t\t{\n\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\tdp[i + 1][j] %= mod;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//this ball is zero\n\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\tdp[i + 1][j] %= mod;\n\t\t\t\t// this ball is colorful\n\t\t\t\tdp[i][j + 1] += dp[i][j] * choose(k - 2, n * k - i - j * (k - 1) - 1);\n\t\t\t\tdp[i][j + 1] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tif (k > 1)\n\t{\n\t\tcout << (dp[n][n] * fact[n]) % mod << endl;\n\t}\n\telse\n\t{\n\t\tcout << 1 << endl;\n\t}\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define ll long long\nusing namespace std;\nconst ll mod=1e9 +7;\nint n,k;\nll f[2020][2020],jc[4040404],jc_n[4040404];\nll C(int x,int y)\n{\n\tif (y<0 || y>x) return 0;\n\tif (y==0 || x==y) return 1;\n\tll sss=jc[x];\n\tsss=sss*jc_n[x-y]%mod*jc_n[y]%mod;\n\treturn sss;\n}\nint main()\n{\n\tjc[1]=1;\n\tjc_n[1]=1;\n\tfor (int i=2;i<=4000010;++i)\n\t{\n\t\tjc[i]=jc[i-1]*i%mod;\n\t\tjc_n[i]=(mod-mod/i)*jc_n[mod%i]%mod;\n\t}\n\tfor (int i=2;i<=4000010;++i)\n\t\tjc_n[i]=jc_n[i]*jc_n[i-1]%mod;\n\n\t//printf(\"%lld\\n\",C(5,1));\n\tscanf(\"%d%d\",&n,&k);\n\tif (k==1)\n\t{\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tf[0][0]=1;\n\tfor (int i=0;i<=n;++i)\n\t\tfor (int j=n;j>=0;--j)\n\t\tif (f[i][j])\n\t\t{\n\t\t\tif (j) f[i][j-1]=(f[i][j-1]+f[i][j])%mod;\n\t\t\tf[i+1][j+1]=(f[i+1][j+1]+C(i*k-j+k-2,k-2)*f[i][j]%mod)%mod;\n\t\t}\n\tprintf(\"%lld\\n\",f[n][0]*jc[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll n,k;\nconst int MAXN = 2000*2000+1;\nlong long kai[MAXN];\nlong long inv[MAXN];\nlong long mod = 1e9+7;\nlong long mp(long long a, long long b) {\n    long long res = 1;\n    for (; b; b >>= 1) {\n        if (b & 1) res = (res * a) % mod;\n        a = (a * a) % mod;\n    }\n    return res;\n}\nvoid init() {\n    kai[0] = 1;\n    for (long long i = 1; i <= n*k; i++) kai[i] = kai[i - 1] * i % mod;\n    for (long long i = 0; i <= n*k; i++) inv[i] = mp(kai[i], mod-2);\n}\nlong long calc(long long n, long long k) {\n    if (n < k) return 0;\n    return (kai[n] * inv[k]) % mod * inv[n - k] % mod;\n}\n\nll dp[2010][2010];\nbool ok[2010][2010];\n\nll dfs(int a, int b) {\n    if (ok[a][b]) return dp[a][b];\n    ll ret = 0;\n    if (a - 1 >= 0) ret += dfs(a-1,b);\n    if (b - 1 >= a) ret += dfs(a, b-1) * calc(a + b * (k - 1) - 1, k - 2) % mod;\n    ok[a][b] = 1;\n    return dp[a][b] = ret % mod;\n}\n\nint main() {\n    cin >> n >> k;\n    init();\n    if (k == 1) {\n        cout << 1 << endl;\n        return 0;\n    }\n    dp[0][0] = 1;\n    ok[0][0] = 1;\n    ll ret = dfs(n,n);\n    for (ll i = 1; i <= n; i++) ret = ret * i % mod;\n    cout << ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconstexpr int maxn = 2000;\nconstexpr int maxm = 4000000;\nconstexpr LL mod = 1000000007;\nLL f[maxm + 1], g[maxm + 1];\nLL dp[maxn + 1][maxn + 1];\nLL F(int n, int m){\n    return f[n + m] * g[n] % mod * g[m] % mod;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int N, K;\n    cin >> N >> K;\n    if(K == 1){\n        cout << 1;\n        return 0;\n    }\n    for(int i = 1; i <= maxm; i += 1)\n        g[i] = i == 1 ? 1 : (mod - mod / i) * g[mod % i] % mod;\n    for(int i = 0; i <= maxm; i += 1){\n        f[i] = i ? f[i - 1] * i % mod : 1;\n        g[i] = i ? g[i - 1] * g[i] % mod : 1;\n    }\n    for(int i = 0; i <= N; i += 1)\n        for(int j = i; j <= N; j += 1)\n            if(not j) dp[i][j] = 1;\n            else{\n                if(i) dp[i][j] = dp[i - 1][j];\n                if(j > i) dp[i][j] = (dp[i][j] + dp[i][j - 1] * F((j - 1) * (K - 1) + i, K - 2)) % mod;\n            }\n    cout << dp[N][N] * f[N] % mod;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int maxn = 2e3 + 10;\nconst int Mod = 1e9 + 7;\n\nvoid Chkadd(int &x, const int &y) { if ((x += y) >= Mod) x -= Mod; }\n\nint Power(int a, int k)\n{\n\tint x = 1;\n\tfor (; k; k >>= 1)\n\t{\n\t\tif (k & 1) x = 1ll * x * a % Mod;\n\t\ta = 1ll * a * a % Mod;\n\t}\n\treturn x;\n}\n\nint fac[maxn * maxn], inv[maxn * maxn];\n\nvoid Prepare_fac(int n)\n{\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; ++ i)\n\t\tfac[i] = 1ll * fac[i - 1] * i % Mod;\n\tinv[n] = Power(fac[n], Mod - 2);\n\tfor (int i = n; i; -- i)\n\t\tinv[i - 1] = 1ll * inv[i] * i % Mod;\n}\n\nint C(int n, int m)\n{\n\tif (n < 0 || n < m || m < 0) return 0;\n\treturn 1ll * fac[n] * inv[m] % Mod * inv[n - m] % Mod;\n}\n\nint f[maxn][maxn];\n\nint main()\n{\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tPrepare_fac(n * k);\n\tif (k == 1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tf[0][0] = 1;\n\tfor (int i = 0; i <= n; ++ i)\n\t{\n\t\tif (i) f[i][i] = f[i - 1][i];\n\t\tfor (int j = i + 1; j <= n; ++ j)\n\t\t{\n\t\t\tf[i][j] = 1ll * f[i][j - 1] * C(i + j * (k - 1) - 1, k - 2) % Mod;\n\t\t\tif (i) Chkadd(f[i][j], f[i - 1][j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", 1ll * f[n][n] * fac[n] % Mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e3L + 11;\nusing ll = long long;\nconst ll mod = 1e9L + 7;\n\nconst int M = 1e7L + 11;\nll fac[M], inv[M];\nll binom(int n, int m) {\n\treturn fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\n\nll f[N][N];\n\nint main() {\n\tfac[0] = inv[0] = fac[1] = inv[1] = 1;\n\tfor(int i = 2; i < M; i ++)\n\t\tinv[i] = (mod - mod / i) * inv[mod % i] % mod;\n\tfor(int i = 2; i < M; i ++) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = inv[i - 1] * inv[i] % mod;\n\t}\n\tios :: sync_with_stdio(0);\n\tint n, m; cin >> n >> m;\n\tif(m == 1) {\n\t\tcout << \"1\\n\";\n\t\treturn 0;\n\t}\n\tf[0][0] = 1;\n\tfor(int i = 0; i <= n; i ++)\n\t\tfor(int j = 0; j <= n; j ++) {\n\t\t\tif(i) f[i][j] += f[i - 1][j];\n\t\t\tif(j) f[i][j] += f[i][j - 1] * binom(i + j * (m - 1) - 1, m - 2) % mod;\n\t\t\tf[i][j] %= mod;\n\t\t\tif(i > j) f[i][j] = 0;\n\t\t}\n\n\tll ans = f[n][n] * fac[n] % mod;\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long LL;\nconst int maxn = 2005;\nconst int maxm = 4000005;\nconst int N = 4e6;\nconst int mod = 1e9+7;\n\nint fac[maxm],inc[maxm];\nint n,K,ans,dp[maxn][maxn];\nLL fpm(LL p,LL k) {\n\tLL res=1ll;\n\twhile (k) {\n\t\tif (k&1) (res*=p)%=mod;\n\t\t(p*=p)%=mod;k>>=1;\n\t}\n\treturn res;\n}\nLL comb(int n,int m) {\n\treturn (LL)fac[n]*inc[m]%mod*(LL)inc[n-m]%mod;\n}\nint main()\n{\n\t#ifdef Amberframe\n\t\tfreopen(\"agc002f.in\",\"r\",stdin);\n\t\tfreopen(\"agc002f.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%d %d\",&n,&K);fac[0]=inc[0]=1;\n\tfor (int i=1;i<=N;i++) fac[i]=(LL)fac[i-1]*i%mod;\n\tinc[N]=fpm(fac[N],mod-2);\n\tfor (int i=N;i>=2;i--) inc[i-1]=(LL)inc[i]*i%mod;\n\t\n\tdp[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=n;j>=0;j--)\n\t\tdp[i][j]=(dp[i][j+1]+dp[i-1][j-1]*comb(i*K-j-1,K-2))%mod;\n\tprintf(\"%d\",dp[n][0]*(LL)fac[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define N 4000005\n#define MOD 1000000007\nusing namespace std;\nint n,k,f[2005][2005],inv[N],fac[N];\nint C(int x,int y){\n\treturn x>=y?fac[x]*inv[y]%MOD*inv[x-y]%MOD:0;\n}\nsigned main(){\n\tcin>>n>>k;\n\tif(k==1){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tfac[0]=inv[0]=inv[1]=1;//first deal\n\tfor(int i=1;i<=n*k;i++)\n\t\tfac[i]=fac[i-1]*i%MOD;\n\tfor(int i=2;i<=n*k;i++)\n\t\tinv[i]=inv[MOD%i]*(MOD-MOD/i)%MOD;\n\tfor(int i=1;i<=n*k;i++)\n\t\tinv[i]=inv[i-1]%MOD*inv[i]%MOD;\n\tfor(int i=0;i<=n;i++)\n\t\tf[i][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=i;j++){\n//\t\t\tcout<<i<<\" \"<<j<<\"*\"<<\"%\"<<C(k-2,(n-i)+(n-j+1)*(k-1)-1)<<endl;\n\t\t\tf[i][j]=(f[i-1][j]+C((n-i)+(n-j+1)*(k-1)-1,k-2)*f[i][j-1]%MOD*(n-j+1)%MOD)%MOD;\n//\t\t\tcout<<f[1][1]<<endl;\n\t\t}\n\t}\n\tcout<<f[n][n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MOD=1e9+7,inv2=5e8+4;\ninline int poww(long long x,int y)\n{\n\tlong long ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ret*=x,ret%=MOD;\n\t\tx*=x,x%=MOD;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\nint n,k;\nlong long dp[2333][2333];\nlong long fac[4555555],invfac[4555555];\ninline long long c(int a,int b)\n{\n\treturn fac[a]*invfac[b]%MOD*invfac[a-b]%MOD;\n}\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin>>n>>k;\n\tif(k==1)return cout<<1<<endl,0;\n\tfac[0]=1;\n\tfor(int i=1;i<=4000000;i++)fac[i]=fac[i-1]*i%MOD;\n\tinvfac[4000000]=poww(fac[4000000],MOD-2);\n\tfor(int i=4000000;i>=1;i--)invfac[i-1]=invfac[i]*i%MOD;\n\tdp[n+1][n]=1;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tlong long sum=0;\n\t\tfor(int j=n;j>=i;j--)\n\t\t{\n\t\t\tsum+=dp[i+1][j];sum%=MOD;\n\t\t\tdp[i][j]=c(n-j+(n-i)*(k-1)+k-2,k-2)*sum%MOD;\n//\t\t\tcerr<<\"dp \"<<i<<','<<j<<'='<<dp[i][j]<<endl;\n\t\t}\n\t}\n\tlong long sum=0;\n\tfor(int i=1;i<=n;i++)sum+=dp[1][i];\n\tcout<<sum%MOD*fac[n]%MOD<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,l,r) for (int i=l;i<=r;i++)\nusing namespace std;\nconst int maxn=200500;\nconst int inf=1e9;\ntypedef long long ll;\nconst ll mm=1e9+7;\nll fac[4050000],inv[4050000];\nint n,k;\nll f[2050][2050];\nll Pow(ll x,ll y){\n    ll ans=1;\n    while (y){\n        if (y&1) ans=ans*x%mm;\n        x=x*x%mm;\n        y/=2;\n    }\n    return ans;\n}\nll C(ll n,ll m){\n    return fac[n]*inv[m]%mm*inv[n-m]%mm;\n}\nint main(){\n    int N=4000000;\n    fac[0]=1;\n    rep(i,1,N) fac[i]=fac[i-1]*i%mm;\n    inv[N]=Pow(fac[N],mm-2);\n    for (int i=N;i>=1;i--) inv[i-1]=inv[i]*i%mm;\n    //rep(i,1,10) printf(\"%lld %lld\\n\",fac[i],inv[i]);\n    scanf(\"%d%d\",&n,&k);\n    f[0][0]=1;\n    rep(i,1,n) rep(j,0,i){\n        if (i-1>=j) f[i][j]=f[i-1][j];\n        if (j) (f[i][j]+=C(n-i+(n-j+1)*(k-1)-1,k-2)*f[i][j-1]%mm*(n-j+1)%mm)%=mm;\n    }\n    if (k>1) printf(\"%lld\\n\",f[n][n]);\n    else printf(\"%lld\\n\",f[n][0]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\nconst int N = 2005;\nconst int mod = 1e9 + 7;\n\nint n, k;\nLL f[N][N], fac[N * N], inv[N * N], fav[N * N];\n\ninline void Add(LL &x, LL y) {\n\tx += y;\n\tif (x >= mod) x -= mod;\n}\n\ninline LL C(LL x, LL y) {\n\tif (x < 0 || x < y) return 0;\n\treturn (fac[x] * fav[y] % mod * fav[x - y] % mod);\n}\n\nint main() {\n\tcin >> n >> k;\n\tif (k == 1) return 0 * puts(\"1\");\n\tfac[0] = fav[0] = 1;\n\tfac[1] = fav[1] = inv[1] = 1;\n\tfor (int i = 2; i < N * N; ++i) {\n\t\tinv[i] = (-mod / i * inv[mod % i] % mod) + mod;\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tfav[i] = fav[i - 1] * inv[i] % mod;\n\t}\n\tf[0][0] = 1;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tfor (int j = i; j <= n; ++j) {\n\t\t\tif (j < n) {\n\t\t\t\tAdd(f[i][j + 1], f[i][j]);\n\t\t\t}\n\t\t\tif (i < j) {\n\t\t\t\tif ((n - i) * k - j + i - 1 >= 0)\n\t\t\t\t\tAdd(f[i + 1][j], f[i][j] * C((n - i) * k - j + i - 1, k - 2) % mod);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tf[n][n] = f[n][n] * i % mod;\n\t}\n\tcout << f[n][n] << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define int long long\nconst int N = 4e6 + 10, M = 2e3 + 10, MOD = 1e9 + 7;\nint fac[N], inv[N], dp[M][M], ps[M][M];\n\nint sum(int a, int b) {return (a + b) % MOD;}\nint mul(int a, int b) {return (a * b) % MOD;}\nint Pow(int a, int b)\n{\n    int res = 1;\n    for (; b; b>>=1, a = mul(a, a)) if (b & 1) res = mul(res, a);\n    return res;\n}\n\nint C(int n, int k)\n{\n    if (k < 0 || n < 0 || k > n) return 0;\n    return mul(fac[n], mul(inv[k], inv[n - k]));\n}\n\n\nint32_t main()\n{\n    fac[0] = 1;\n    for (int i = 1; i < N; i++) fac[i] = mul(fac[i - 1], i);\n    inv[N - 1] = Pow(fac[N - 1], MOD - 2);\n    for (int i = N - 2; i >= 0; i--) inv[i] = mul(inv[i + 1], i + 1);\n    int n, k; cin >> n >> k;\n    if (k == 1) return cout << \"1\\n\", 0;\n    ps[1][1] = dp[1][1] = 1;\n    for (int i = 2; i <= n; i++) {\n        dp[i][1] = mul(ps[i - 1][1], C(i * k - 2, k - 2));\n        for (int j = 2; j <= i; j++) {\n            dp[i][j] = mul(ps[i - 1][j - 1], C(i * k - j - 1, k - 2));\n        }\n        for (int j = i; j >= 1; j--) ps[i][j] = sum(ps[i][j + 1], dp[i][j]);\n    }\n    cout << mul(ps[n][1], fac[n]) << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MN = 20123, INF = 5012345, MOD = 1000 * 1000 * 1000 + 7;\nint inv[INF], fict[INF], invf[INF], dp[MN][MN];\n\nvoid fact() {\n\tfict[0] = inv[0] = invf[0] = 1;\n\tfict[1] = inv[1] = invf[1] = 1;\n\tfor (int i = 2; i < INF; i++) {\n\t\tinv[i] = 1ll * inv[MOD % i] * (MOD - MOD / i) % MOD;\n\t\tfict[i] = 1ll * fict[i - 1] * i % MOD;\n\t\tinvf[i] = 1ll * invf[i - 1] * inv[i] % MOD;\n\t}\n}\n\nint chose(int a, int b) {\n\treturn 1ll * fict[b] * invf[a] % MOD * invf[b - a] % MOD;\n}\n\nint main() {\n\tfact();\n\tint n, k;\n\tcin >> n >> k;\n  \tif (k == 1)\n      return cout << 1, 0;\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tif (j > i)\n    \t          continue;\n\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\tif (j)\n\t\t\t\tdp[i][j] = (dp[i][j] + 1ll * dp[i][j - 1] * chose(k - 2, n * k - (j - 1) * (k - 1) - i - 1) % MOD) % MOD;\n        }\n\tcout << 1ll * dp[n][n] * fict[n] % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long \n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define F first\n#define S second\nint const M=2000+10,mod=1e9+7,inf=1e9+10;\nint dp[M][M],rev[M*M],fact[M*M];\nint pw(int x,int y)\n{\n\tif(y==0)return 1;\n\tint tmp=pw(x,y/2);\n\tif(y%2==0)return (tmp*tmp)%mod;\n\treturn ((tmp*tmp)%mod*x)%mod;\n}\nint C(int n,int r)\n{\n\tint tmp=fact[r]*fact[n-r];\n\ttmp%=mod;\n\ttmp=pw(tmp,mod-2);\n\ttmp*=fact[n];\n\ttmp%=mod;\n\treturn tmp;\n}\nint32_t main()\n{\t\n\tint n,k;\n\tcin>>n>>k;\n\tfact[0]=1;\n\tfor(int i=1;i<=4e6;i++)fact[i]=fact[i-1]*i,fact[i]%=mod,rev[i]=pw(fact[i],mod-2);\n\tif(k==1)return cout<<1,0;\n\tfor(int i=n+1;i>=1;i--)\n\t{\n\t\tfor(int j=i;j>=1;j--)\n\t\t{\n\t\t\tif(i==n+1 && j==n+1)\n\t\t\t{\n\t\t\t\tdp[i][j]=1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdp[i][j]+=dp[i+1][j];\n\t\t\tdp[i][j]%=mod;\n\t\t\tif(n*k-(i-1)-((j-1)*(k-1))-1>=0)\n\t\t\t\tdp[i][j]+=C(n*k-(i-1)-((j-1)*(k-1))-1,k-2)*dp[i][j+1];\n\t\t\tdp[i][j]%=mod;\n\t\t\t//cout<<c[n*k-(i-1)-((j-1)*(k-1))][k-1]<<\" \"<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n\t\t}\n\t}\n\tcout<<(dp[1][1]*fact[n])%mod;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define M 2010\n#define LL long long\n#define MOD 1000000007\n#define rep(i, x, y) for(int i = (x); i <= (y); i ++)\ninline int read() {\n\tchar ch = getchar(); int x = 0, f = 1;\n\twhile(ch < '0' || ch > '9') {\n\t\tif(ch == '-') f = -1;\n\t\tch = getchar();\n\t} while('0' <= ch && ch <= '9') {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t} return x * f;\n}\nint f[M][M];\nint fac[M*M], inv[M*M];\ninline void init(int n) {\n\tfac[0] = 1;\n\trep(i, 1, n) fac[i] = 1ll * fac[i - 1] * i % MOD;\n\tinv[0] = inv[1] = 1;\n\trep(i, 2, n) inv[i] = 1ll * inv[MOD % i] * (MOD - MOD / i) % MOD;\n\trep(i, 1, n) inv[i] = 1ll * inv[i - 1] * inv[i] % MOD;\n}\ninline int C(int n, int m) {\n\treturn 1ll * fac[n] * inv[m] % MOD * inv[n - m] % MOD;\n}\nint main() {\n\tint n = read(), k = read();\n\tf[0][0] = 1; init(n*k);\n\trep(i, 1, n) {\n\t\tfor(int j = i; j >= 0; j --) {\n\t\t\tf[i][j] = f[i][j + 1];\n\t\t\tif(j) (f[i][j] += 1ll * f[i - 1][j - 1] * C(i*k-j-1,k-2) % MOD) %= MOD;\n\t\t}\n\t} printf(\"%d\\n\", 1ll * f[n][0] * fac[n] % MOD);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=2002,M=1e9+7;\nint n,m,k,f[N*N],F[N*N],g[N][N];\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=1LL*a*a%M)if(b&1)s=1LL*s*a%M;\n\treturn s;\n}\nint main(){\n\tcin>>n>>k;m=n*k;\n\tif(k==1){puts(\"1\");return 0;}\n\tf[0]=1;\n\tfor(int i=1;i<=m;++i)f[i]=1LL*f[i-1]*i%M;\n\tF[m]=mi(F[m],M-2);\n\tfor(int i=m;i>=1;--i)F[i-1]=1LL*F[i]*i%M;\n\tg[0][0]=1;\n\tfor(int i=0,I=k-1;i<=n;++i,I+=k-1)for(int j=0;j<=i;++j){\n\t\t(g[i+1][j]+=1LL*g[i][j]*f[I+j-1]%M*F[I+j-k+1]%M*F[k-2]%M)%=M;\n\t\t(g[i][j+1]+=g[i][j])%=M;\n\t}\n\tcout<<1LL*g[n][n]*f[n]%M<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nnamespace IO {\n    const int maxn(1 << 21 | 1);\n\n    char ibuf[maxn], *iS, *iT, c;\n    int f;\n\n    inline char Getc() {\n        return iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, maxn, stdin), (iS == iT ? EOF : *iS++)) : *iS++;\n    }\n\n    template <class Int> inline void In(Int &x) {\n        for (f = 1, c = Getc(); c < '0' || c > '9'; c = Getc()) f = c == '-' ? -1 : 1;\n        for (x = 0; c >= '0' && c <= '9'; c = Getc()) x = (x << 1) + (x << 3) + (c ^ 48);\n        x *= f;\n    }\n}\n\nusing IO :: In;\n\nconst int maxn(2005);\nconst int maxm(maxn * maxn);\nconst int mod(1e9 + 7);\n\nint n, k, f[maxn][maxn], fac[maxm], ifac[maxm], inv[maxm];\n\ninline void Inc(int &x, int y) {\n\tx += y;\n\tif (x >= mod) x -= mod;\n}\n\ninline int C(int x, int y) {\n\tif (y > x) return 0;\n\treturn 1LL * fac[x] * ifac[y] % mod * ifac[x - y] % mod;\n}\n\nint main() {\n\tIn(n), In(k), f[1][0] = 1;\n\tif (k == 1) return puts(\"1\"), 0;\n\tint mx = n * k;\n\tfac[1] = ifac[1] = fac[0] = ifac[0] = inv[1] = 1;\n\tfor (int i = 2; i <= mx; ++i) {\n\t\tinv[i] = 1LL * (mod - mod / i) * inv[mod % i] % mod;\n\t\tfac[i] = 1LL * fac[i - 1] * i % mod;\n\t\tifac[i] = 1LL * ifac[i - 1] * inv[i] % mod;\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tif (i > j) Inc(f[i][j], f[i - 1][j]);\n\t\t\tif (j) Inc(f[i][j], 1LL * f[i][j - 1] * C(mx - i - (j - 1) * (k - 1) - 1, k - 2) % mod);\n\t\t}\n\tprintf(\"%lld\\n\", 1LL * f[n][n] * fac[n] % mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x < 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nlong long pw(long long a, long long e, long long mod) {\n\tif(e <= 0) return 1;\n\tlong long x =pw(a,e/2,mod);\n\tx =(x*x)%mod;\n\tif(e%2 != 0) x =(x*a)%mod;\n\treturn x;}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N,K;\n\tcin >> N >> K;\n\tif(K == 1) {cout << \"1\\n\"; return 0;}\n\tlong long mod =1000000007;\n\tvector<long long> fac(N*K+tisic,1),inv(N*K+tisic,0);\n\tfor(int i =1; i <= N*K; i++) fac[i] =(i*fac[i-1])%mod;\n\tinv[0] =inv[1] =1;\n\tfor(int i =2; i <= N*K; i++) if(inv[i] == 0) {\n\t\tinv[i] =pw(i,mod-2,mod);\n\t\tfor(int j =2; j <= (N*K)/i; j++) inv[i*j] =(inv[i]*inv[j])%mod;}\n\tfor(int i =2; i <= N*K; i++) inv[i] =(inv[i]*inv[i-1])%mod;\n\tvector< vector<long long> > P(N+1,vector<long long>(N+1,0));\n\tP[1][1] =1;\n\tvector<long long> S(N+2,0);\n\tfor(int i =2; i <= N; i++) {\n\t\tfor(int j =N; j >= 0; j--) S[j] =(S[j+1]+P[i-1][j])%mod;\n\t\tfor(int j =1; j <= i; j++) {\n\t\t\tif(i*K-j-1 < K-2) break; \n\t\t\tP[i][j] =(S[j-1]*fac[i*K-j-1])%mod;\n\t\t\tP[i][j] =(P[i][j]*inv[K-2])%mod;\n\t\t\tP[i][j] =(P[i][j]*inv[(i-1)*K-j+1])%mod;}\n\t\t}\n\tlong long ansF =0;\n\tfor(int i =1; i <= N; i++) ansF =(ansF+P[N][i])%mod;\n\tansF =(ansF*fac[N])%mod;\n\tif(ansF < 0) ansF +=mod;\n\tcout << ansF << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N = 2333,mo=1e9+7;\nint n,k,f[N][N],g[N*N],fac[N];\nint power(int a, int n){\n\tint res=1;\n\twhile(n){\n\t\tif(n&1)res=1LL*res*a%mo;a=1LL*a*a%mo;n>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);if(k==1){puts(\"1\");return 0;}\n\tfor(int i=k-2,j=1;i<=n*k;i++)g[i]=j,j=1LL*j*(i+1)%mo*power(i-k+3,mo-2)%mo;\n\tfac[0]=1;for(int i=1;i<=n;i++)fac[i]=1LL*fac[i-1]*i%mo;\n\tfor(int i=0;i<=n;i++)for(int j=i;j<=n;j++)\n\t\tif(i==0){\n\t\t\tif(j==0)f[i][j]=1;else f[i][j]=1LL*f[i][j-1]*g[i+j*k-j-1]%mo;\n\t\t}else f[i][j]=(f[i-1][j]+1LL*f[i][j-1]*g[i+j*k-j-1])%mo;\n\tprintf(\"%lld\",1LL*f[n][n]*fac[n]%mo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nconst int mod = 1e9+7;\nint ad(int x,int y) { x+=y; return x>=mod?x-mod:x; }\nint sb(int x,int y) { x-=y; return x<0?x+mod:x; }\nint mu(int x,int y) { return 1ll*x*y%mod; }\nint ksm(int a,int b) {\n\tint ans = 1;\n\tfor(;b;b>>=1,a=mu(a,a))\n\t\tif(b&1) ans = mu(ans,a);\n\treturn ans;\n}\nint fac[4000005],piv[4000005],n,k;\nint GC(int a,int b) {\n\tif(a<b) return 0;\n\treturn mu(fac[a],mu(piv[b],piv[a-b]));\n}\nint f[2005][2005];\nint main() {\n\tscanf(\"%d%d\",&n,&k);\n\tfac[0] = 1;\n\tfor(int i=1;i<=n*k;i++) fac[i] = mu(fac[i-1],i);\n\tpiv[n*k] = ksm(fac[n*k],mod-2);\n\tfor(int i=n*k-1;i>=0;i--) piv[i] = mu(piv[i+1],i+1);\n\tf[0][0] = 1;\n\tfor(int i=1;i<=n;i++) {\n\t\tf[i][0] = 1;\n\t\tfor(int j=1;j<=i;j++) {\n\t\t\tf[i][j] = ad(f[i-1][j],mu(GC((n-i)+(n-j+1)*(k-1)-1,k-2),mu(f[i][j-1],n-j+1)));\n\t\t}\n\t}\n\tprintf(\"%d\",f[n][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#define MOD 1000000007\n#define MAXN 2005\nusing namespace std;\ntypedef long long LL;\nint d[MAXN][MAXN],num[MAXN][MAXN],inv[MAXN*MAXN],kinv,n,k;\nvoid pre()\n{\n    inv[1]=1;kinv=1;\n    for(int i=2;i<MAXN*MAXN;i++) inv[i]=(MOD-MOD/i)*(LL)inv[MOD%i]%MOD;\n    for(int i=2;i<=k-2;i++) kinv=(LL)kinv*inv[i]%MOD;\n    num[0][0]=1;\n    for(int j=1;j<n;j++)\n    {\n        num[0][j]=1;\n        for(int m=1;m<=k-2;m++) num[0][j]=(LL)num[0][j]*(j*k-j+m)%MOD;\n        num[0][j]=(LL)num[0][j]*kinv%MOD;\n        //cout<<j<<' '<<num[0][j]<<endl;\n    }\n    for(int j=1;j<n;j++)\n        for(int i=1;i<=j;i++)\n    {   num[i][j]=(LL)num[i-1][j]*(j*k-j+k+i-2)%MOD*inv[j*k-j+i]%MOD;\n        //cout<<j*k-j+k-2+i<<' '<<k-2<<' '<<num[i][j]<<endl;\n    }\n}\nint main()\n{\n\n    cin>>n>>k;\n    if(k==1) {cout<<1<<endl;return 0;}\n    pre();\n    d[0][1]=1;\n    for(int j=2;j<=n;j++)\n        d[0][j]=(LL)d[0][j-1]*num[0][j-1]%MOD;\n    for(int i=1;i<=n;i++)\n        for(int j=i;j<=n;j++)\n    {\n        d[i][j]=(d[i-1][j]+(LL)d[i][j-1]*num[i][j-1]%MOD)%MOD;\n    }\n    int ans=d[n][n];\n    for(int i=2;i<=n;i++) ans=(LL)ans*i%MOD;\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long LL;\nconst int maxn = 2005;\nconst int maxm = 4000005;\nconst int N = 4e6;\nconst int mod = 1e9+7;\n\nint fac[maxm],inc[maxm];\nint n,K,ans,dp[maxn][maxn];\nLL fpm(LL p,LL k) {\n\tLL res=1ll;\n\twhile (k) {\n\t\tif (k&1) (res*=p)%=mod;\n\t\t(p*=p)%=mod;k>>=1;\n\t}\n\treturn res;\n}\nLL comb(int n,int m) {\n\treturn (LL)fac[n]*inc[m]%mod*(LL)inc[n-m]%mod;\n}\nint main()\n{\n\t#ifdef Amberframe\n\t\tfreopen(\"agc002f.in\",\"r\",stdin);\n\t\tfreopen(\"agc002f.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%d %d\",&n,&K);fac[0]=inc[0]=1;\n\tfor (int i=1;i<=N;i++) fac[i]=(LL)fac[i-1]*i%mod;\n\tinc[N]=fpm(fac[N],mod-2);\n\tfor (int i=N;i>=2;i--) inc[i-1]=(LL)inc[i]*i%mod;\n\t\n\tdp[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=i;j>=0;j--)\n\t\tdp[i][j]=(dp[i][j+1]+dp[i-1][j-1]*comb(i*K-j-1,K-2))%mod;\n\tprintf(\"%d\",K>1?dp[n][0]*(LL)fac[n]%mod:1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define LL long long\nconst int maxn = 4e6 + 5;\nconst int mo = 1e9 + 7;\nusing namespace std;\nLL f[2005][2005], fac[maxn], inv[maxn];\nLL C(int n, int m){\n\tif (m == 0 || m == n) return 1;\n\tif (m > n) return 0;\n\treturn fac[n] * inv[n - m] % mo * inv[m] % mo;\n}\nLL pow(LL x, int t){\n\tLL res = 1; x %= mo;\n\twhile (t > 0){\n\t\tif (t & 1) res = res * x % mo;\n\t\tx = x * x % mo;\n\t\tt >>= 1;\n\t}\n\treturn res;\n}\nint n, k; \nint main(){\n\tscanf(\"%d%d\", &n, &k);\n\tif (k == 1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0] = 1; \n\tfor (int i = 1; i <= n * k; i++) fac[i] = fac[i - 1] * i % mo;\n\tinv[n * k] = pow(fac[n * k], mo - 2);\n\tfor (int i = n * k - 1; i >= 1; i--) inv[i] = inv[i + 1] * (i + 1) % mo;\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int j = i; j <= n; j++){\n\t\t\tif (i == 0 && j == 0) f[i][j] = 1;\n\t\t\tif (j != 0) f[i][j] = (f[i][j] + f[i][j - 1]) % mo;\n\t\t\tif (i != 0) f[i][j] = (f[i][j] + f[i - 1][j] * (n - i + 1) % mo * C(n * k - (i - 1) * (k - 1) - j - 1, k - 2) % mo) % mo;\n\t\t}\n\tprintf(\"%lld\\n\", f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nconst int maxn=2e3+5,pps=1e9+7;\n\nint n,k,ans;\nint f[maxn],fac[maxn*maxn],inv[maxn*maxn];\n\nint read() {\n\tint x=0,f=1;char ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;\n\tfor(;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';\n\treturn x*f;\n}\n\nint quick(int a,int b) {\n\tint sum=1;\n\twhile(b) {\n\t\tif(b&1)sum=1ll*sum*a%pps;\n\t\ta=1ll*a*a%pps;b>>=1;\n\t}\n\treturn sum;\n}\n\nvoid prepare(int N) {\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=N;i++)\n\t\tfac[i]=1ll*fac[i-1]*i%pps;\n\tinv[N]=quick(fac[N],pps-2);\n\tfor(int i=N-1;i;i--)\n\t\tinv[i]=1ll*inv[i+1]*(i+1)%pps;\n}\n\nint C(int a,int b) {\n\treturn 1ll*fac[a]*inv[b]%pps*inv[a-b]%pps;\n}\n\nint main() {\n\tn=read(),k=read()-1;\n\tif(!k) {puts(\"1\");return 0;}\n\tprepare(n*k+n);f[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tf[j]=(f[j]+1ll*C(n*k+n-i-(j-1)*k-1,k-1)*f[j-1]%pps)%pps;\n\tans=1ll*f[n]*fac[n]%pps;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define N 4006\n#define mo 1000000007\nusing namespace std;\nint n,k,f[N][N],fac[4000006],inv[4000006];\nint ksm(int x,int y)\n{\n\tif(y==0)return 1;if(y==1)return x;int p=ksm(x,y>>1);\n\tif(y&1)return 1LL*p*p%mo*x%mo;return 1LL*p*p%mo;\n}\nint C(int a,int b)\n{\n\treturn 1LL*fac[a]*inv[b]%mo*inv[a-b]%mo;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);fac[0]=inv[0]=1;\n\tif(k==1)return puts(\"1\"),0;\n\tfor(int i=1;i<=n*k;i++)fac[i]=1LL*fac[i-1]*i%mo;\n\tinv[n*k]=ksm(fac[n*k],mo-2);\n\tfor(int i=n*k-1;i>=1;i--)inv[i]=1LL*inv[i+1]*(i+1)%mo;\n\tf[1][1]=1;\n\tfor(int i=2;i<=2*n;i++)\n\t\tfor(int j=1;j<=min(i,n);j++){\n\t\t\tf[i][j]=f[i-1][j-1];\n\t\t\tif(j>=(i+1)/2)f[i][j]=(f[i][j]+1LL*f[i-1][j]*C(n*k-j-1-(k-1)*(i-j-1),k-2)%mo)%mo;\n\t\t}\n\tprintf(\"%d\\n\",1LL*f[2*n][n]*fac[n]%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int maxn=2000+10;\nconst int p=1e9+7;\nint n,k,f[maxn][maxn],farc[maxn*maxn],inv[maxn*maxn];\n\nint C(int n,int m){\n\treturn (ll)farc[n]*inv[m]%p*(ll)inv[n-m]%p;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);k--;\n\tif(!k){printf(\"1\\n\");return 0;}\n\tfarc[0]=farc[1]=inv[0]=inv[1]=1;\n\tfor(int i=2;i<=n*k+n+k;i++){\n\t\tfarc[i]=(ll)farc[i-1]*i%p;\n\t\tinv[i]=(ll)(p-p/i)*inv[p%i]%p;\n\t}\n\tfor(int i=2;i<=n*k+n+k;i++) inv[i]=(ll)inv[i]*inv[i-1]%p;\n\tf[0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=i;j<=n;j++){\n\t\t\tif(i>0) f[i][j]=(f[i][j]+f[i-1][j])%p;\n\t\t\tif(j>0) f[i][j]=(f[i][j]+(ll)f[i][j-1]*C(i+(j-1)*k+k-1,k-1)%p)%p;\n\t\t}\n\tprintf(\"%d\\n\",(ll)f[n][n]*farc[n]%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// And in the end, the love you take is equal to the love you make.\n//                      Paul McCartney (the Beatles). The End. Abbey Road.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1e5;\nchar buff[BUFF], *begin = buff, *end = buff;\nchar getc() {\n    if (begin == end) {\n        begin = buff;\n        end = buff + fread(buff, 1, BUFF, stdin);\n    }\n    return begin == end ? -1 : *begin++;\n}\n\n}\n\nll read() {\n    using namespace _buff;\n    ll ret = 0; bool pos = true; char c = getc();\n    for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n        assert(~c);\n    }\n    if (c == '-') {\n        pos = false;\n        c = getc();\n    }\n    for (; c >= '0' && c <= '9'; c = getc()) {\n        ret = (ret << 3) + (ret << 1) + (c ^ 48);\n    }\n    return pos ? ret : -ret;\n}\n\nconst size_t N = 2000 + 5;\nconst size_t M = N * N;\nconst ll MOD = 1e9 + 7;\n\nvoid add(ll &dp, ll val) {\n    dp += val;\n    if (dp >= MOD) {\n        dp -= MOD;\n    }\n}\n\nll fac[M], inv[M], finv[M];\n\nvoid prep() {\n    fac[0] = inv[0] = finv[0] =\n    fac[1] = inv[1] = finv[1] = 1;\n    for (int i = 2; i < M; ++i) {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - MOD / i * inv[MOD % i] % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\nll C(int n, int m) {\n    return fac[n] * finv[m] % MOD * finv[n - m] % MOD;\n}\n\nll dp[N][N];\n\nint main() {\n    prep();\n    int n = read(), k = read() - 1;\n    if (!k) {\n        return puts(\"1\"), 0;\n    }\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 0; j <= i; ++j) {\n            if (j) dp[i][j] = dp[i][j - 1];\n            add(dp[i][j], dp[i - 1][j] * C(i * k + j - 1, k - 1) % MOD);\n        }\n    }\n    cout << dp[n][n] * fac[n] % MOD << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\n#define MOD 1000000007\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int MAXN = 2000 + 10;\nconst int MAXM = 4e06 + 10;\n\nint N, K;\n\nLL fact[MAXN]= {0}, invfact[MAXN]= {0};\nvoid init () {\n\tfact[0] = fact[1] = invfact[0] = invfact[1] = 1;\n\tfor (int i = 2; i <= N * K; i ++) {\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\tinvfact[i] = (MOD - MOD / i) * invfact[MOD % i] % MOD;\n\t}\n\tfor (int i = 1; i <= N * K; i ++)\n\t\tinvfact[i] = invfact[i - 1] * invfact[i] % MOD;\n}\nLL C (int n, int m) {\n\tif (m == 0) return 1;\n\treturn fact[n] * invfact[m] % MOD * invfact[n - m] % MOD;\n}\n\nLL f[MAXN][MAXN]= {0};\n\nint main () {\n\tscanf (\"%d%d\", & N, & K);\n\tif (K == 1) {\n\t\tputs (\"1\");\n\t\treturn 0;\n\t}\n\tinit ();\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= N; i ++)\n\t\tfor (int j = 0; j <= i; j ++) {\n\t\t\tLL delta = f[i][j - 1] * (N - j + 1) % MOD * C (N * K - i - (K - 1) * (j - 1) - 1, K - 2) % MOD;\n\t\t\tif (j == 0) delta = 0;\n\t\t\tf[i][j] = (f[i][j] + f[i - 1][j] + delta) % MOD;\n\t\t}\n\tcout << f[N][N] << endl;\n\n\treturn 0;\n}\n\n/*\n2 2\n*/\n\n/*\n3 1\n*/\n\n/*\n2 3\n*/\n\n/*\n2000 2000\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std ;\n#define int unsigned long long\nconst int mxn = 8000005 ;\nconst int Mod = 1e9+7 ;\nint frac[mxn], inv[mxn];\nint f[2005][2005], n, k;\nint power(int a, int b){\n    int res=1, car=a; \n    while(b){\n        if(b&1) (res*=car)%=Mod;\n        (car*=car)%=Mod;\n        b>>=1;\n    }\n    return res;\n}\nvoid init(){\n    frac[0]=1 ;\n    for(int i=1;i<mxn;++i) (frac[i]=frac[i-1]*i)%=Mod ;\n    inv[mxn-1] = power(frac[mxn-1], Mod-2);\n    for(int i=mxn-2;i>0;--i) inv[i]=(inv[i+1]*(i+1))%Mod ;\n    inv[0] = 1 ;\n}\nint C(int n, int k){\n    return ((frac[n]*inv[k]%Mod)*inv[n-k])%Mod ;\n}\nsigned main(){\n    init() ;\n    cin>>n>>k;\n    if(k==1) return puts(\"1\"),0 ;\n    f[0][0] = 1 ;\n    for(int i=1;i<=n;++i)\n        for(int j=0;j<=i;++j)\n            (f[i][j] = f[i-1][j]+(j?((((f[i][j-1]*(n-j+1))%Mod)*C(n*k-i-(j-1)*(k-1)-1, k-2))%Mod):(0)))%=Mod ;\n    cout<<f[n][n]<<endl ;\n}"
  },
  {
    "language": "C++",
    "code": "// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //\n// IN THE NAME OF GOD\n#include <bits/stdc++.h>\n\n#define ff first\n#define endl '\\n'\n#define in insert\n#define ss second\n#define ll long long\n#define pb push_back\n#define ld long double\n#define pii pair <int, int>\n#define pll pair <long long, long long>\n\nusing namespace std;\n\nconst int mod = 1e9 + 7, N = 2222, MAXN = 4e6 + 46;\nll n, k, dp[N][N], fact[MAXN], inv[MAXN], f[MAXN];\n\ninline int C(int x, int y){\n  return fact[x] * inv[y] % mod * inv[x - y] % mod;\n}\n\nint main(){\n  //ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  cin >> n >> k;\n  if(k == 1) return cout << 1, 0;\n\n  fact[0] = inv[0] = inv[1] = f[0] = f[1] = dp[0][0] = 1;\n\n  for(int i = 1; i < MAXN; i++){\n    fact[i] = fact[i - 1] * i;\n    fact[i] %= mod;\n  }\n  for(int i = 2; i < MAXN; i++){\n    f[i] = (mod - mod / i) * f[mod % i];\n    f[i] %= mod;\n    inv[i] = f[i] * inv[i - 1];\n    inv[i] %= mod;\n  }\n  for(int i = 1; i <= n; i++){\n    for(int j = i; j >= 1; j--){\n      dp[i][j] = dp[i][j + 1];\n      dp[i][j] += dp[i - 1][j - 1] * (i * k - j - 1 < k - 2 ? 0 : C(i * k - j - 1, k - 2));\n      dp[i][j] %= mod;\n    }\n    dp[i][0] = dp[i][1];\n  }\n  cout << (dp[n][0] * fact[n]) % mod;\n}\n// programmer: a_h_k_81\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nconst int mod=1e9+7;\nconst int M=2e3+10;\nconst int N=4e6+10;\nusing namespace std;\nint n,k,h[N],inv[N],finv[N],f[M][M];\nint C(int n,int m) {\n\treturn 1ll*h[n]*finv[m]%mod*finv[n-m]%mod;\n}\nvoid Pre() {\n\th[0]=finv[0]=inv[1]=1;\n\tfor(int i=1;i<=4e6;i++) h[i]=1ll*h[i-1]*i%mod;\n\tfor(int i=2;i<=4e6;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=1;i<=4e6;i++) finv[i]=1ll*finv[i-1]*inv[i]%mod;\n}\nint main() {\n\tPre();\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1) {puts(\"1\");return 0;}\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++) {\n\t\t\tif(!j) f[i][j]=f[i-1][j];\n\t\t\telse f[i][j]=(f[i-1][j]+1ll*f[i][j-1]*(n-j+1)%mod*C(n-i+(n-j+1)*(k-1)-1,k-2)%mod)%mod;\n\t}\n\tprintf(\"%d\\n\",f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<LL, LL> pll;\ntypedef pair<int, int> pii;\n\nconst int mod = 1e9 + 7;\nconst int maxn = 4000 + 5;\nconst int maxm = 4e6 + 10;\nconst int oo = 0x3f3f3f3f;\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\n#define fst first\n#define snd second\n#define pb push_back\n\ntemplate<typename T> T read() {\n\tT n(0), f(1);\n\tchar ch = getchar();\n\tfor( ;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n\tfor( ; isdigit(ch); ch = getchar()) n = n * 10 + ch - 48;\n\treturn n * f;\n}\n\nLL Fac(int n) {\n    LL res = 1;\n    for(int i = 2; i <= n; i++) (res *= i) %= mod;\n    return res;\n}\n\nLL fpm(LL a, LL b) {\n    LL ans = 1;\n    for(; b > 0; b >>= 1) {\n        if(b & 1) \n            ans = ans * a % mod;\n        a = a * a % mod;\n    }\n    return ans;\n}\n\nLL f[maxn][maxn];\nLL fac[maxm], ifac[maxm];\n\nvoid init() {\n    fac[0] = 1;\n    ifac[0] = 1;\n    for(int i = 1; i < maxm; i++) {\n        fac[i] = fac[i-1] * i % mod;\n        ifac[i] = fpm(fac[i], mod-2);\n    }\n}\nLL C(int n, int k) {\n    return fac[n] * ifac[n-k] % mod * ifac[k] % mod;\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n    //freopen(\"data.txt\", \"r\", stdin);\n    //freopen(\"ans.txt\", \"w\", stdout);\n#endif\n\n    init();\n\n    int n, k;\n    n = read<int>(), k = read<int>();\n    if(k == 1) { puts(\"1\"); return 0; }\n\n    f[n][n] = 1;\n\n    for(int i = n; i >= 0; i--) {\n        for(int j = n; j >= 0; j--) if(f[i][j]) {\n            if(i > 0) (f[i-1][j] += f[i][j]) %= mod;\n            if(j > i) (f[i][j-1] += f[i][j] * C(i+j*(k-1)-1, k-2) % mod) %= mod;\n        }\n    }\n    printf(\"%lld\\n\", f[0][0] * Fac(n) % mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define mod 1000000007\nusing namespace std;\nint n,K,m;\nint f[2002][2002];\nint fac[4000010],inv[4000010];\nint quick_pow(int x,int p)\n{\n    int an=1,po=x;\n    while(p)\n    {\n        if(p&1)  an=1ll*an*po%mod;\n        po=1ll*po*po%mod;\n        p>>=1;\n    }\n    return an;\n}\nint C(int x,int y)\n{\n    if(x<y)  return 0;\n    return 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main()\n{\n    fac[0]=1;\n    for(int i=1;i<=4000000;i++)  fac[i]=1ll*fac[i-1]*i%mod;\n    inv[4000000]=quick_pow(fac[4000000],mod-2);\n    for(int i=3999999;i>=0;i--)   inv[i]=1ll*inv[i+1]*(i+1)%mod;\n    cin>>n>>K;\n    if(K==1)\n    {\n        puts(\"1\");\n        return 0;\n    }\n    m=n*K;\n    f[0][0]=1;\n    for(int i=0;i<=n;i++)\n    {\n        for(int j=0;j<=i;j++)\n        {\n            if(i)  f[i][j]=f[i-1][j];\n            if(j)  f[i][j]=(f[i][j]+1ll*C(m-(j-1)*(K-1)-i-1,K-2)*f[i][j-1]%mod)%mod;\n        }\n    }\n    int ans=1ll*f[n][n]*fac[n]%mod;\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define M 2010\n#define LL long long\n#define MOD 1000000007\n#define rep(i, x, y) for(int i = (x); i <= (y); i ++)\ninline int read() {\n\tchar ch = getchar(); int x = 0, f = 1;\n\twhile(ch < '0' || ch > '9') {\n\t\tif(ch == '-') f = -1;\n\t\tch = getchar();\n\t} while('0' <= ch && ch <= '9') {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t} return x * f;\n}\nint f[M][M];\nint fac[M*M], inv[M*M];\ninline void init(int n) {\n\tfac[0] = 1;\n\trep(i, 1, n) fac[i] = 1ll * fac[i - 1] * i % MOD;\n\tinv[0] = inv[1] = 1;\n\trep(i, 2, n) inv[i] = 1ll * inv[MOD % i] * (MOD - MOD / i) % MOD;\n\trep(i, 1, n) inv[i] = 1ll * inv[i - 1] * inv[i] % MOD;\n}\ninline int C(int n, int m) {\n\tif(n < 0 || m < 0) return 1;\n\treturn 1ll * fac[n] * inv[m] % MOD * inv[n - m] % MOD;\n}\nint main() {\n\tint n = read(), k = read();\n\tf[0][0] = 1; init(n*k);\n\trep(i, 1, n) {\n\t\tfor(int j = i; j >= 0; j --) {\n\t\t\tf[i][j] = f[i][j + 1];\n\t\t\tif(j) (f[i][j] += 1ll * f[i - 1][j - 1] * C(i*k-j-1,k-2) % MOD) %= MOD;\n\t\t}\n\t} printf(\"%d\\n\", 1ll * f[n][0] * fac[n] % MOD);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=2005,mod=1e9+7;\nint C[N*N],f[N],inv[N*N],n,K;\nvoid prework(int n)\n{\n    inv[1]=1;for(int i=2;i<=n;i++)inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n    C[K-2]=1;for(int i=K-1;i<=n;i++)C[i]=1ll*C[i-1]*i%mod*inv[i-K+2]%mod;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&K);\n    if(K==1){puts(\"1\");return 0;}\n    prework(n*K);\n    f[0]=1;\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=i;j++)\n            f[j]=(f[j]+1ll*f[j-1]*C[n*K-(j-1)*(K-1)-i-1])%mod;\n    }\n    int ans=f[n];\n    for(int i=1;i<=n;i++)ans=1ll*ans*i%mod;\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long i64;\n\nconst int MAXN = 2000 + 5;\nconst int MOD = 1e9 + 7;\n\nint N, K;\ni64 fact[MAXN * MAXN], inverse[MAXN * MAXN];\ni64 DP[MAXN][MAXN];\n\ni64 modularExp(i64 base, i64 exp)\n{\n\ti64 ret = 1;\n\twhile (exp)\n\t{\n\t\tif (exp & 1)\n\t\t\tret = ret * base % MOD;\n\t\tbase = base * base % MOD;\n\t\texp = exp >> 1;\n\t}\n\treturn ret;\n}\n\nvoid prepare()\n{\n\tfact[0] = 1;\n\tfor (int i = 1; i < MAXN * MAXN; i++)\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\n\tinverse[MAXN * MAXN - 1] = modularExp(fact[MAXN * MAXN - 1], MOD - 2) % MOD;\n\tfor (int i = MAXN * MAXN - 2; i >= 0; i--)\n\t\tinverse[i] = inverse[i + 1] * (i + 1) % MOD;\n\n\tassert(inverse[1] == 1);\n}\n\ni64 getC(int n, int m)\n{\n\treturn fact[n] * inverse[m] % MOD * inverse[n - m] % MOD;\n}\n\nint main()\n{\n\tprepare();\n\tcin >> N >> K;\n\n\tif(K == 1)\n\t\tcout << 1 << endl, exit(0);\n\n\tDP[0][0] = 1;\n\tfor (int i = 0; i <= N; i++)\n\t\tfor (int j = i; j <= N; j++)\n\t\t{\n\t\t\tDP[i][j + 1] = (DP[i][j + 1] + DP[i][j]) % MOD;\n\t\t\tDP[i + 1][j] = (DP[i][j] * getC(K * (N - i) - (j - i) - 1, K - 2)\n\t\t\t\t\t+ DP[i + 1][j]) % MOD;\n\t\t}\n\tcout << DP[N][N] * fact[N] % MOD << endl ;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\nconst double EPS = 1e-9;\nconst ll MOD = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n\n#define SIZE 4000001\n\nll kai[SIZE];\nll mokai[SIZE];\n\nll mod_pow (ll x, ll y) {\n    ll ret = 1;\n    while (y) {\n        if (y&1) ret = ret*x%MOD;\n        x = x*x%MOD;\n        y /= 2;\n    }\n    return ret;\n}\n\nvoid init () {\n    kai[0] = 1;\n    for (int i = 1; i < SIZE; i++) kai[i] = kai[i-1]*i%MOD;\n    for (int i = 0; i < SIZE; i++) mokai[i] = mod_pow(kai[i],MOD-2);\n}\n\nll conb (ll x, ll y) {\n    ll z = x-y;\n    ll ret = kai[x]*mokai[y]%MOD;\n    ret = ret*mokai[z]%MOD;\n    return ret;\n}\n\nll n, k;\nll dp[2001][2001];\n\ninline ll mmul (ll x, ll y) {\n    return x*y%MOD;\n}\n\nint main() {\n    cin >> n >> k;\n    init();\n    if (k == 1) {\n        cout << 1 << endl;\n        return 0;\n    }\n    dp[0][0] = 1;\n    for (ll i = 1; i <= n; i++) {\n        dp[i][0] = mmul(dp[i-1][0], conb(i*(k-1)-1,k-2));\n    }\n    for (ll j = 1; j <= n; j++) {\n        for (ll i = j; i <= n; i++) {\n            if (i == j) {\n                dp[i][j] = dp[i][j-1];\n            } else {\n                dp[i][j] = (mmul(dp[i-1][j], conb(i*k-(i-j)-1, k-2)) + dp[i][j-1]) % MOD;\n            }\n        }\n    }\n    cout << (dp[n][n] * kai[n]) % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\nusing namespace std;\nint fac[5001000],nifac[5001000],dp[2010][2010];\nint getmi(int a,int x)\n{\n\tint ans=1;\n\twhile (x)\n\t{\n\t\tif (x&1) ans=(long long)ans*a%mo;\n\t\ta=(long long)a*a%mo;\n\t\tx>>=1;\n\t}\n\treturn ans;\n}\nint C(int n,int m){return (long long)fac[n]*nifac[m]%mo*nifac[n-m]%mo;}\nint main()\n{\n\tint n,k;scanf(\"%d%d\",&n,&k);\n\tif (k==1) {puts(\"1\");return 0;}\n\tfac[0]=1;for (int i=1;i<=n*n;i++) fac[i]=(long long)fac[i-1]*i%mo;\n\tnifac[n*n]=getmi(fac[n*n],mo-2);\n\tfor (int i=n*n-1;i>=0;i--) nifac[i]=(long long)nifac[i+1]*(i+1)%mo;\n\tdp[0][0]=1;\n\tfor (int i=0;i<=n;i++)\n\tfor (int j=0;j<=n;j++)\n\t{\n\t\tif (i) dp[i][j]=dp[i-1][j];\n\t\tif ((i!=j)&&(j)) dp[i][j]=(dp[i][j]+(long long)dp[i][j-1]*C(i+j*(k-1)-1,k-2))%mo;\n\t}\n\tprintf(\"%lld\\n\",(long long)fac[n]*dp[n][n]%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int P = 1e9+7;\ntypedef long long i64;\n\nint fpm(int x,int d) {\n  int ret = 1;\n  for(; d; x = (i64) x*x % P, d >>= 1)\n    if(d & 1) ret = (i64) ret*x % P;\n  return ret;\n}\n\nint fac[4000005];\nint inv[4000005];\nint f[2005][2005];\n\nint C(int n,int m) {\n  return (i64) fac[n] * inv[m] % P * inv[n-m] % P;\n}\n\nint N, K;\nint main() {\n  if(fopen(\"input.txt\",\"r\")) {\n    freopen(\"input.txt\",\"r\",stdin);\n    freopen(\"output.txt\",\"w\",stdout);\n  }\n\n  scanf(\"%d%d\", &N, &K);\n\n  if(K == 1) {\n    puts(\"1\");\n    return 0;\n  }\n  \n  int n = N * K;\n  \n  fac[0] = 1;\n  for(int i = 1;i <= n; ++i) \n    fac[i] = (i64) fac[i-1] * i % P;\n  inv[n] = fpm(fac[n], P-2);\n  for(int i = n-1; ~i; --i)\n    inv[i] = (i64) inv[i+1] * (i+1) % P;\n\n  f[N][N] = 1;\n  for(int i = N; ~i; --i) {\n    for(int j = N; ~j; --j) {\n      if(i) (f[i-1][j] += f[i][j]) %= P;\n      if(i < j) (f[i][j-1] += (i64) f[i][j] * C(i+j*(K-1)-1,K-2) % P) %= P;\n    }\n  }\n  \n  // for(int i = 0;i <= N; ++i)\n  //   for(int j = 0;j <= N; ++j)\n  //     printf(\"%d%c\", f[i][j], \" \\n\"[j == N]);\n  \n  printf(\"%lld\", (i64) f[0][0] * fac[N] % P);\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n设f[i][j]表示当前有i个白球，一共放完了j种球\n显然有j <= i\n* 放白球 从f[i-1][j]转移\n* 放没有出现过的球 (n - j + 1) * f[i][j - 1] * C(k - 2, n * k - i - (j - 1) * (k - 1) - 1)\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int N = 2020;\nconst int mod = 1e9 + 7;\n\nint inv[N * N], fac[N * N];\nint f[N][N];\nint n, k;\n\nint power(int a, int b) {\n\ta %= mod; int ans = 1;\n\twhile(b) {\n\t\tif(b & 1) ans = 1ll * ans * a % mod;\n\t\ta = 1ll * a * a % mod; b >>= 1;\n\t}\n\treturn ans;\n}\n\nint C(int n, int m) {\n\treturn 1ll * fac[m] * inv[n] % mod * inv[m - n] % mod;\n}\n\nsigned main() {\n\tscanf(\"%d%d\", &n, &k);\n\tfac[0] = 1;\n\tfor(int i = 1; i < N * N; ++i) \n\t\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\tfor(int i = 0; i < N * N; ++i) \n\t\tinv[i] = power(fac[i], mod - 2);\n\tfor(int i = 0; i <= n; ++i) f[i][0] = 1;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tfor(int j = 1; j <= i; ++j) {\n\t\t\tf[i][j] = f[i - 1][j];\n\t\t\t(f[i][j] += 1ll * (n - j + 1) * f[i][j - 1] % mod * C(k - 2, n * k - i - (j - 1) * (k - 1) - 1) % mod) %= mod;\n\t\t\t(f[i][j] += mod) %= mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", (f[n][n] % mod + mod) % mod);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge {c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\ntypedef long long ll;\n\nconst int mod = 1e9 + 7;\nint add(int a, int b) { return (a + b) % mod; }\nvoid add_self(int & a, int b) { a = add(a, b); }\nint mul(int a, int b) { return (ll) a * b % mod; }\n\nint my_pow(int a, int b) {\n\tint r = 1;\n\twhile(b) {\n\t\tif(b % 2) r = mul(r, a);\n\t\ta = mul(a, a);\n\t\tb /= 2;\n\t}\n\treturn r;\n}\nint my_inv(int a) { return my_pow(a, mod - 2); }\nint my_div(int a, int b) { return mul(a, my_inv(b)); }\n\nconst int nax = 2005;\nint factorial[nax*nax];\nint dp[nax][nax];\n\nint C(int a, int b) {\n\tassert(0 <= b && b <= a && a < nax * nax);\n\treturn my_div(factorial[a], mul(factorial[b], factorial[a-b]));\n}\n\nint main() {\n\tfactorial[0] = 1;\n\tfor(int i = 1; i < nax * nax; ++i)\n\t\tfactorial[i] = mul(factorial[i-1], i);\n\t\n\tint n, k;\n\tcin >> n >> k; // k colors, n balls in each color\n\tswap(n, k);\n\tif(n == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tconst int down = n - 2;\n\t// width = k\n\t#define n n_dont_use\n\tdebug() << imie(k) imie(down);\n\tdp[0][0] = 1;\n\tfor(int a = 0; a <= k; ++a)\n\t\tfor(int b = 0; b <= a; ++b) {\n\t\t\tdebug dd;\n\t\t\tdd << imie(a) imie(b) imie(dp[a][b]);\n\t\t\tif(a != k) add_self(dp[a+1][b], dp[a][b]);\n\t\t\tif(b < a) {\n\t\t\t\tint still = (k - a) + (k - b - 1) + (k - b) * down;\n\t\t\t\tdd << imie(still);\n\t\t\t\tadd_self(dp[a][b+1], mul(dp[a][b], C(still, down)));\n\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\", mul(dp[k][k], factorial[k]));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define MOD 1000000007\nusing namespace std;\nint N,K;\nLL fac[5000010],inv[5000010],ifac[5000010],d[2010][2010];\nint main()\n{\n\tcin>>N>>K;\n\tif(K==1)\n\t{\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tfac[0]=inv[0]=ifac[0]=fac[1]=inv[1]=ifac[1]=1;\n\tfor(int i=2;i<=5000000;i++)\n\t{\n\t\tfac[i]=(fac[i-1]*i)%MOD;\n\t\tinv[i]=inv[MOD%i]*(MOD-MOD/i)%MOD;\n\t\tifac[i]=(ifac[i-1]*inv[i])%MOD;\n\t}\n\td[0][1]=1;\n\tfor(int i=2;i<=N;i++)\n\t{\n\t\td[0][i]=d[0][i-1]*(fac[i*(K-1)-1]*ifac[K-2]%MOD*ifac[(i-1)*(K-1)]%MOD)%MOD;\n\t}\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tfor(int j=i;j<=N;j++)\n\t\t{\n\t\t\td[i][j]=(d[i-1][j]+d[i][j-1]*(fac[i+j*(K-1)-1]*ifac[K-2]%MOD*ifac[i+(j-1)*(K-1)]%MOD))%MOD;\n// \t\t\tcout<<i<<' '<<j<<' '<<d[i][j]<<endl;\n\t\t}\n\t}\n\tcout<<(d[N][N]*fac[N])%MOD<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PP;\n\n/*\n    freopen(\"input\",\"r\",stdin);\n    freopen(\"output\",\"w\",stdout);\n*/\n\nll DP[2001][2001];\n\nll F[4000001];\nll I[4000001];\n\nll MOD = 1E9 + 7;\n\nint power(int a, int b)\n{\n    int ret=1;\n    for(; b>0; b/=2)\n    {\n        if(b&1)\n            ret=1LL*ret*a%MOD;\n        a=1LL*a*a%MOD;\n    }\n    return ret;\n}\n\nvoid init() {\n\tF[0] = 1;\n\tfor (ll i = 1;i <= 4000000;i++) {\n\t\tF[i] = F[i - 1] * i;\n\t\tF[i] %= MOD;\n\t}\n\tmemset(I, 0, sizeof(I));\n\treturn;\n}\n\nll nchoosek(int a, int b) {\n\tif (b == 0 || a == b) return 1;\n\tll up = F[a];\n    if (I[a- b] == 0) I[a - b] = power(F[a - b], MOD - 2);\n    if (I[b] == 0) I[b] = power(F[b], MOD - 2);\n\tll down = I[a - b] * I[b];\n\tdown %= MOD;\n\tup *= down;\n\treturn up %= MOD;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    init();\n    memset(DP, 0, sizeof(DP));\n    DP[0][0] = 1;\n    int N, K, T;\n    cin >> N >> K;\n    if (K == 1) {\n    \tcout << 1 << endl;\n    \treturn 0;\n    }\n    T = N * K;\n    for (int i = 0;i <= N;i++) {\n    \t// Opened Slot.\n    \tfor (int j = 0;j <= i;j++) {\n    \t\t// Closed Slot.\n\n    \t\tif (i != N) {\n    \t\t\t// Open a slot.\n    \t\t\tDP[i + 1][j] += DP[i][j];\n    \t\t\tDP[i + 1][j] %= MOD;\n    \t\t}\n\n    \t\tif (i != j) {\n    \t\t\t// Close a slot.\n\n    \t\t\t// Choose One Color.\n    \t\t\tll ans = (N - j);\n\n    \t\t\tll rem = T - j * K - (i - j);\n\n    \t\t\tans *= nchoosek(rem - 1, K - 2);\n    \t\t\tans %= MOD;\n\n    \t\t\tans *= DP[i][j];\n    \t\t\tans %= MOD;\n\n    \t\t\tDP[i][j + 1] += ans;\n    \t\t\tDP[i][j + 1] %= MOD;\n    \t\t}\n\n    \t}\n    }\n    cout << DP[N][N] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize (\"Ofast\")\nusing namespace std;\n/// khodaya komak kon\n/// ya navid navid\nconst int N=2001*2001+3;\nll mod=1e9+7;\nll dp[2001][2001];\nll fac[N];\nll power(ll n, ll k){\n    if (k==0){\n        return 1;\n    }\n    else{\n        if (k%2==0){\n            ll x=power(n,k/2);\n            return x*x%mod;\n        }\n        else{\n            ll x=power(n,k/2);\n            x=x*x%mod;\n            return x*n%mod;\n        }\n    }\n}\nll fm[N];\nll ent(ll k, ll n){\n\tif (k==0 || k==n){\n        return 1;\n\t}\n\n\treturn (((fac[n]*fm[k])%mod)*fm[n-k])%mod;\n}\nll pd[N];\nint32_t main(){\n    sync;\n    fac[0] = 1;\n\n\tfor(int i=1;i<N;i++) {\n        fac[i]=(fac[i-1]*i)%mod;\n\t}\n\tfm[N - 1] = power(fac[N - 1], mod - 2);\n    for(int i = N - 2; i >= 0; i--) fm[i] = (fm[i + 1] * (i + 1)) % mod;\n\tll ans=1;\n    ll n,k;\n    cin >> n >> k;\n    if (k==1){\n        cout << 1 << endl;\n        return 0;\n    }\n //   dp[0]=1;\n   // dp[1]=1;\n    dp[0][0]=1;\n    for (int i=1;i<=n;i++){\n        for (int j=i;j>0;j--){\n            dp[i][j]=dp[i][j+1];\n            dp[i][j]+=dp[i-1][j-1]*ent(k-2,i*k-j-1)%mod*i%mod;\n            dp[i][j]%=mod;\n        //cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n        }\n        dp[i][0]=dp[i][1];\n    }\n    cout << dp[n][1] << endl;\n    /*\n    for (int i=2;i<=n;i++){\n        ll p1=1;\n        for (int j=1;j<=i;j++){\n            dp[i]+=ent(j,i)*ent((k-1)*j-1,i*k-j-1)%mod*pd[j]%mod*dp[i-j]%mod;\n           // dp[i]+=(n-i+1)*ent(k-2,i*k-2)%mod*dp[i-1]%mod;\n            //dp[i]+=(n-i+1)*ent(k-1,i*k-2)%mod*dp[i-1]%mod*fm[2]%mod;\n            cout << i << \" \" << j << \" \" << dp[i] << endl;\n            dp[i]%=mod;\n        }\n    }\n    cout << dp[n] << endl;\n    */\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define run(v) for(int k=head[v];k;k=e[k].ne)\n#define v e[k].t\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef pair<int,int> pa;\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\nconst int N=5e3+5,M=1e7+5,INF=1e9,mod=1e9+7;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);}\nil void gen(){freopen(\"data.in\",\"w\",stdout);}\nll fac[M],ifac[M],dp[N][N];\nint n,k;\nil ll C(ll n,ll m){\n\tif(!n||!m||n<m)return 0;\n\treturn fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\nint main(){\n\tread(n,k);\n\tfac[0]=1;rep(i,1,n*k)fac[i]=(fac[i-1]*i)%mod;\n\tifac[n*k]=qpow(fac[n*k],mod-2,mod);\n\trepd(i,n*k-1,0)ifac[i]=ifac[i+1]*(i+1)%mod;\n\tdp[0][0]=1;\n\trep(i,0,n)rep(j,i,n){\n\t\tif(i)dp[i][j]=dp[i-1][j];\t\n\t\tif(j)dp[i][j]=(dp[i][j]+dp[i][j-1]*C(i+j*(k-1)-1,k-2))%mod;\n\t}\n\tcout<<fac[n]*dp[n][n]%mod;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,ll>\n#define mk make_pair\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define fi first\n#define se second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXM=5e6+5,MAXN=2005,Mod=1e9+7;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nint n,k,Fac[MAXM],iFac[MAXM],F[MAXN][MAXN];\ninline int Fp(int x,int k){int ans=1;for(;k;k>>=1,x=1ll*x*x%Mod)if(k&1)ans=1ll*ans*x%Mod;return ans;}\ninline void Init(int n){\n\tFac[0]=1;Rep(i,1,n)Fac[i]=1ll*Fac[i-1]*i%Mod;\n\tiFac[n]=Fp(Fac[n],Mod-2);Red(i,n,1)iFac[i-1]=1ll*iFac[i]*i%Mod;\n}\ninline int C(int n,int m){return n<0||m<0||n<m?0:1ll*Fac[n]*iFac[m]%Mod*iFac[n-m]%Mod;}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),k=read();\n\tif(n==1||k==1)return puts(\"1\"),0;\n\tInit((n+1)*k);F[0][0]=1;Rep(i,1,n)F[0][i]=1ll*F[0][i-1]*C(i*(k-1)-1,k-2)%Mod;\n\tRep(i,1,n)Rep(j,i,n)F[i][j]=(F[i-1][j]+1ll*F[i][j-1]*C(i+j*(k-1)-1,k-2))%Mod;\n\tcout<<1ll*F[n][n]*Fac[n]%Mod<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <assert.h>\n#include <fstream>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 2005;\nconst ll MOD = 1000000007;\n\nint n,k;\n\nll fac[MAXN * MAXN];\nll inv[MAXN * MAXN];\nll f[MAXN][MAXN];\n\nll power(ll a,ll b)\n{\n\tll res = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1)\n\t\t\t(res *= a) %= MOD;\n\t\t(a *= a) %= MOD;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nvoid init()\n{\n\tfac[0] = 1;\n\tfor (int i = 1;i <= n * k;i++)\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\tinv[n * k] = power(fac[n * k],MOD - 2);\n\tfor (int i = n * k;i >= 1;i--)\n\t\tinv[i - 1] = inv[i] * i % MOD;\n}\n\nll C(int x,int y)\n{\n\treturn x < y ? 0 : fac[x] * inv[y] % MOD * inv[x - y] % MOD;\n}\n\nint main()\n{\n\tcin >> n >> k;\n\tif (k == 1)\n\t{\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tinit();\n\tf[0][0] = 1;\n\tfor (int i = 1;i <= n;i++)\n\t\tf[0][i] = f[0][i - 1] * C((k - 1) * i - 1,k - 2) % MOD;\n\tfor (int i = 1;i <= n;i++)\n\t\tfor (int j = i;j <= n;j++)\n\t\t{\n\t\t\tf[i][j] = f[i - 1][j];\n\t\t\tif (i < j)\n\t\t\t\t(f[i][j] += f[i][j - 1] * C((k - 1) * j + i - 1,k - 2)) %= MOD;\n\t\t}\n\tcout << f[n][n] * fac[n] % MOD << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define N (5000000+1000)\n#define MOD (1000000007)\nusing namespace std;\n\nlong long n,k,fac[N],inv[N],facinv[N],f[2010][2010];\n\nvoid Init()\n{\n\tfac[0]=inv[1]=facinv[0]=1;\n\tfor (int i=1; i<=5000000; ++i)\n\t{\n\t\tif (i!=1) inv[i]=(MOD-MOD/i)*inv[MOD%i]%MOD;\n\t\tfac[i]=fac[i-1]*i%MOD; \n\t\tfacinv[i]=facinv[i-1]*inv[i]%MOD;\n\t}\n}\n\nlong long C(long long n,long long m)\n{\n\tif (m>n) return 0;\n\treturn fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;\n}\n\nint main()\n{\n\tInit();\n\tscanf(\"%lld%lld\",&n,&k);\n\tif (k==1){printf(\"1\"); return 0;}\n\tf[0][1]=1;\n\tfor (int i=2; i<=n; ++i)\n\t\tf[0][i]=f[0][i-1]*C(i*(k-1)-1,k-2)%MOD;\n\tfor (int i=1; i<=n; ++i)\n\t\tfor (int j=i; j<=n; ++j)\n\t\t\tf[i][j]=(f[i-1][j]+f[i][j-1]*C(i+j*(k-1)-1,k-2)%MOD)%MOD;\n\tprintf(\"%lld\",f[n][n]*fac[n]%MOD);\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fo(i,a,b) for (int i = (a); i < (b); i++)\n#define MOD 1000000007LL\n#define N 2002\ntypedef long long ll;\n\nint n, k;\nll dp[N][N], fct[N*N], inv[N*N], ifct[N*N];\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\tif (k==1) puts(\"1\"), exit(0);\n\tfct[0] = 1;\n\tfo(i,1,N*N) fct[i] = (i * fct[i-1])%MOD;\n\tinv[1] = 1;\n\tfo(i,2,N*N) inv[i] = (-(MOD/i) * inv[MOD % i]) % MOD + MOD;\n\tifct[0] = 1;\n\tfo(i,1,N*N) ifct[i] = (inv[i] * ifct[i-1])%MOD;\n\tdp[0][0] = 1;\n\tfo(i,0,n+1) fo(j,0,i+1) {\n\t\tdp[i+1][j] = (dp[i+1][j] + dp[i][j])%MOD;\n\t\tif (j < i) {\n\t\t\tint lft = n-i + (k-1)*(n - j - 1);\n\t\t\tdp[i][j+1] = (dp[i][j+1] + fct[lft + k-2] * (ifct[lft] * (ifct[k-2] * dp[i][j] % MOD)%MOD))%MOD;\n\t\t}\n\t}\n\tll ans = (dp[n][n] * fct[n])%MOD;\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nconst long long int MOD=1000000007;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nint main(){\n  int N,M;\n  cin>>N>>M;\n  if(M==1){\n    cout<<1<<endl;\n    return 0;\n  }\n  vector<int>by(N*M+1,1);\n  vector<int>rev_by(N*M+1,1);\n  for(int i=1;i<=N*M;i++){\n    by[i]=(1LL*by[i-1]*i)%MOD;\n    rev_by[i]=power(by[i],MOD-2,MOD);\n  }\n  vector<vector<long long int>>dp(N+1,vector<long long int>(N+1));\n  dp[0][0]=1;\n  for(int i=0;i<=N;i++){\n    for(int j=i;j<=N;j++){\n      if(i)dp[i][j]=dp[i-1][j];\n      if(j){\n        long long int add=dp[i][j-1];\n        add*=by[i+j*(M-1)-1];\n        add%=MOD;\n        add*=rev_by[M-2];\n        add%=MOD;\n        add*=rev_by[i+j*(M-1)-1-(M-2)];\n        add%=MOD;\n        dp[i][j]+=add;\n        dp[i][j]%=MOD;\n      }\n    }\n  }\n  cout<<(dp.back().back()*by[N])%MOD<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#define RG register\n#define LL long long\nusing namespace std;\nconst int N=2e3+10;\nconst LL mod=1e9+7;\nint n,k,maxx;\nLL inv[N*N]={0,1},fac1[N*N]={1},fac2[N*N]={1},dp[N][N];\nLL C(int nn,int mm){return fac1[nn]*fac2[mm]%mod*fac2[nn-mm]%mod;}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&k); maxx=n*k;\n\tif(k==1) { printf(\"1\\n\"); return 0; }\n\tfor(RG int i=1;i<=maxx;i++) fac1[i]=fac1[i-1]*i%mod;\n\tfor(RG int i=2;i<=maxx;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\tfor(RG int i=1;i<=maxx;i++) fac2[i]=fac2[i-1]*inv[i]%mod;\n\tdp[0][0]=1;\n\tfor(RG int i=1;i<=n;i++)\n\t for(RG int j=0;j<=i;j++)//\n\t  dp[i][j]=(dp[i-1][j]+(j!=0)*C(n-i+(n-j+1)*(k-1)-1,k-2)*dp[i][j-1]%mod*(n-j+1)%mod)%mod;\n\tprintf(\"%lld\",dp[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\n\n#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i <= i##_END_; i++)\n#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i >= i##_END_; i--)\n\ntemplate <typename Tp> void in(Tp &x) {\n\tchar ch = getchar(), f = 1; x = 0;\n\twhile (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();\n\tif (ch == '-') ch = getchar(), f = -1;\n\twhile (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();\n\tx *= f;\n}\n\ntemplate <typename Tp> void out(Tp x) {\n\tif (x > 9) out(x / 10);\n\tputchar(x % 10 + '0');\n\treturn;\n}\n\ntemplate <typename Tp> Tp Max(const Tp &x, const Tp &y) {return x > y ? x : y;}\ntemplate <typename Tp> Tp Min(const Tp &x, const Tp &y) {return x < y ? x : y;}\ntemplate <typename Tp> bool chkmax(Tp &x, Tp y) {return x >= y ? 0 : (x=y, 1);}\ntemplate <typename Tp> bool chkmin(Tp &x, Tp y) {return x <= y ? 0 : (x=y, 1);}\n\nconst int MAXN = 2010;\nconst int MOD = 1000000007;\n\nint n, k;\nint f[MAXN][MAXN];\nint fac[MAXN * MAXN], inv[MAXN * MAXN];\n\nint power(int x, int y)\n{\n\tint ret = 1;\n\twhile (y) {\n\t\tif (y & 1) ret = 1ll * ret * x % MOD;\n\t\tx = 1ll * x * x % MOD;\n\t\ty >>= 1;\n\t}\n\treturn ret;\n}\n\nint C(int x, int y)\n{\n\tassert(x >= y);\n\treturn 1ll * fac[x] * inv[y] % MOD * inv[x - y] % MOD;\n}\n\nint main()\n{\n\tin(n); in(k);\n\n\tif (k == 1) {\n\t\tprintf(\"1\\n\"); return 0;\n\t}\n\t\n\tf[0][0] = 1;\n\n\tfac[0] = 1;\n\tFOR(i, 1, n * k) fac[i] = 1ll * fac[i - 1] * i % MOD;\n\n\tinv[n * k] = power(fac[n * k], MOD - 2);\n\tDNF(i, n * k - 1, 0) inv[i] = 1ll * inv[i + 1] * (i + 1) % MOD;\n\n\tFOR(i, 0, n) FOR(j, i, n) {\n\t\tif (!i && !j) continue;\n\t\tif (n - i < n - j) continue;\n\t\tint emp = n * k - (n - i) - (k - 1) * (n - j);\n\t\tf[i][j] = 0;\n\t\tif (i) f[i][j] = f[i - 1][j];\n\t\tif (n - i < n - j + 1) continue;\n\t\tif (j) f[i][j] = (f[i][j] + 1ll * f[i][j - 1] * C(emp - 1, k - 2) % MOD * j) % MOD;\n\t}\n\n\tprintf(\"%d\\n\", f[n][n]);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nll read(){\n\tchar c=getchar();bool flag=0;ll x=0;\n\twhile(c<'0'||c>'9'){if(c=='-')flag=1;c=getchar();}\n\twhile(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}\n\treturn flag?-x:x;\n}\n#define N 2010 \nconst ll p=1e9+7;\nll dp[N][N],fac[N*N],inv[N*N];\nll fpow(ll a,ll x){\n\tll ans=1;\n\twhile(x){\n\t\tif(x&1) ans=ans*a%p;\n\t\ta=a*a%p,x=x/2; \n\t}\n\treturn ans;\n}\nll Cnt(ll n,ll m){\n\treturn fac[m]*inv[fac[n]]%p*inv[fac[m-n]]%p;\n}\nint main(){\n\tll n=read(),k=read();\n\tif(k==1){\n\t\tprintf(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\tfor(ll i=1;i<=n*k;i++) fac[i]=fac[i-1]*i%p;\n\tinv[n*k]=fpow(fac[n*k],p-2);\n\tfor(ll i=n*k-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%p;\n\tfor(ll i=1;i<=n;i++) dp[i][0]=1;\n\tfor(ll i=1;i<=n;i++){\n\t\tfor(ll j=1;j<=i;j++){\n\t\t\tdp[i][j]=dp[i-1][j]+dp[i][j-1]*(n-(j-1))*Cnt(k-2,n*k-i-(j-1)*(k-1)-1);\n\t\t}\n\t}\n\tprintf(\"%lld\",dp[n][n]); \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include<ctime>\n#include<cassert>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n \ni64 modpow(i64 a, i64 p = MOD - 2)\n{\n\tif (p == 0) return 1;\n\ti64 tmp = modpow(a, p / 2);\n\ttmp = tmp * tmp % MOD;\n\tif (p % 2) tmp = tmp * a % MOD;\n\treturn tmp;\n}\n \nint N, K;\ni64 fact[4040404], frev[4040404];\n \ni64 C(int a, int b)\n{\n\tif (a < b) return 0;\n\treturn fact[a] * frev[b] % MOD * frev[a - b] % MOD;\n}\n \ni64 dp[4020][2020];\n \ni64 solve(int nz, int nk)\n{\n\tif (dp[nz][nk] != -1) return dp[nz][nk];\n\n\tif (nz == N && nk == N) return dp[nz][nk] = 1;\n\tdp[nz][nk] = 0;\n\tif (nz < N) {\n\t//\tADD(dp[nz][nk], solve(nz + 1, nk));\n\t\tdp[nz][nk]=solve(nz+1,nk);\n\t}\n\tif (nk < N && nk < nz) {\n\t//\tprintf(\"%d %d, %d %d\\n\", nz, nk, N * K - nz - nk * (K - 1) - 1, K - 2);\n\t//\tADD(dp[nz][nk], solve(nz, nk + 1) * C(N * K - nz - nk * (K - 1) - 1, K - 2) % MOD);\n\t\tdp[nz][nk]+=solve(nz, nk + 1) * C(N * K - nz - nk * (K - 1) - 1, K - 2)%MOD;\n\t\tif(dp[nz][nk]>=MOD) dp[nz][nk]-=MOD;\n\t}\n\t//printf(\"%d %d: %lld\\n\", nz, nk, dp[nz][nk]);\n\treturn dp[nz][nk];\n}\n \nint main()\n{\n\tscanf(\"%d%d\", &N, &K);\n \n\tif (K == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\t//mod1\n\tfrev[0]=frev[1]=1;\n\tfor(int i=2;i<4040404;++i){\n\t\tfrev[i]=MOD-(MOD/i)*frev[MOD%i]%MOD;\n\t}\n\tfact[0] = 1;\n\tfor (int i = 1; i < 4040404; ++i) {\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\tfrev[i] = frev[i]*frev[i-1]%MOD;\n\t}\n \t//mod2\n\tfor (int i = 0; i <= N; ++i) {\n\t\tfor (int j = 0; j <= N; ++j) dp[i][j] = -1;\n\t}\n\ti64 sol = solve(0, 0);\n\tsol = sol * fact[N] % MOD;\n\tprintf(\"%lld\\n\", sol);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef Lin1043\n    #define DEBUG(msg, ...) printf(\"(%s #%d) \" msg, __FUNCTION__, __LINE__, __VA_ARGS__)\n    #define massert(...) assert(...)\n#else\n    #define DEBUG(...)\n    #define massert(...)\n#endif\n\n#define rep(i , l , r) for(int i = (l) , ___ = (r) ; i <= ___ ; ++i )\n#define per(i , r , l) for(int i = (r) , ___ = (l) ; i >= ___ ; --i )\n\nstruct iopener\n{\n    iopener()\n    {\n#ifdef Lin1043\n        freopen(\"./in\" , \"r\" , stdin);\n#endif\n    }\n} iop;\n\ntypedef long long LL;\n\ntemplate<typename T>inline bool chkmin(T &x , const T &y) { return x > y ? (x = y , 1) : 0; }\ntemplate<typename T>inline bool chkmax(T &x , const T &y) { return x < y ? (x = y , 1) : 0; }\n\ntemplate<typename T>inline T read(T &f)\n{\n    f = 0; int x = 1 ; char c = getchar();\n    while(!isdigit(c)) x = (c == '-' ? -1 : 1) , c = getchar();\n    while(isdigit(c)) (f *= 10) += c & 15 , c = getchar();\n    return f = x * f;\n}\n\nconst int N = 2000 + 5 , L = 4000000;\n\nint n , k ;\nLL fac[L+10] , inv[L+10];\n\nconst int KCZ = 1e9 + 7;\n\nLL mp(LL x , LL y = KCZ - 2)\n{\n    LL res = 1;\n    while(y)\n    {\n        if(y & 1)\n            res = res * x % KCZ;\n        x = x * x % KCZ;\n        y >>= 1;\n    }\n    return res;\n}\n\nvoid init()\n{\n    fac[0] = 1;\n    rep(i , 1 , L) fac[i] = fac[i - 1] * i % KCZ;\n    inv[L] = mp(fac[L]);\n    per(i , L - 1 , 1) inv[i] = inv[i + 1] * (i + 1) % KCZ;\n    inv[0] = 1;\n}\n\nLL C(int n , int m)\n{\n    if(n < m) return 0;\n    return fac[n] * inv[m] % KCZ * inv[n - m] % KCZ;\n}\n\nLL f[N][N];\n\nvoid add(LL &x , const LL &y)\n{\n    x += y; if(x >= KCZ) x -= KCZ;\n}\n\nint main()\n{\n    read(n) , read(k) , init();\n    if(k == 1)\n        return puts(\"1\") , 0;\n    f[0][0] = 1;\n    rep(i , 1 , n)\n    {\n        per(j , i , 0)\n        {\n            f[i][j] = f[i][j + 1]; \n            if(j >= 1)\n                add(f[i][j] , f[i - 1][j - 1] * C(i * k - j - 1 , k - 2) % KCZ);\n        }\n    }\n    printf(\"%lld\\n\" , f[n][0] * fac[n] % KCZ);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include <bits/stdc++.h>\n#define LL long long\n#define int LL\n#define P pair<int, int>\nconst LL N = 2e3 + 10;\nconst LL mod = 1e9 + 7;\nconst LL inf = 0x3f3f3f3f;\nusing namespace std;\ntemplate <typename tp>\ninline void read(tp &x)\n{\n    x = 0;char c = getchar();bool f = 0;\n    for (; c < '0' || c > '9'; f |= (c == '-'), c = getchar());\n    for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n    if (f) x = -x;\n}\nint n, k, f[N][N], fac[N * N + N * 2], inv[N * N + N * 2];\nvoid updata(int &x, int y) { x += y, x -= x >= mod ? mod : 0; }\nint C(int n, int m) { return fac[n] * inv[m] % mod * inv[n - m] % mod; }\nsigned main()\n{\n    read(n),read(k); k--;\n    if (!k) return 0*puts(\"1\");\n    fac[0] = fac[1] = inv[0] = inv[1] = 1;\n    for (int i = 2; i <= n * k + n + k; i++) fac[i] = (LL)fac[i - 1] * i % mod, inv[i] = (LL)(mod - mod / i) * inv[mod % i] % mod;\n    for (int i = 2; i <= n * k + n + k; i++) inv[i] = (LL)inv[i - 1] * inv[i] % mod;\n    f[0][0] = 1;\n    for (int i = 0; i <= n; i++)\n        for (int j = i; j <= n; j++)\n        {\n            if (i) updata(f[i][j], f[i - 1][j]);\n            if (j) updata(f[i][j], (LL)f[i][j - 1] * C(i + (j - 1) * k + k - 1, k - 1) % mod);\n        }\n    printf(\"%lld\\n\", f[n][n] * fac[n] % mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int maxn = 2000 + 7;\n\nlong long f[maxn][maxn];\nlong long step[maxn * maxn], inv[maxn * maxn];\n\nlong long C(int n, int m) {\n    return step[n] * inv[m] % mod * inv[n - m] % mod;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    if (k == 1) {\n        printf(\"1\\n\");\n        return 0;\n    }\n\n    long long ans = 1;\n    for (int i = 1; i <= n; i++) ans = ans * i % mod;\n\n    step[0] = 1;\n    for (int i = 1; i <= n * k; i++) step[i] = step[i - 1] * i % mod;\n\n    inv[0] = inv[1] = 1;\n    for (int i = 2; i <= n * k; i++) \n        inv[i] = mod - (mod / i) * inv[mod % i] % mod;\n    for (int i = 2; i <= n * k; i++) \n        inv[i] = inv[i  - 1] * inv[i] % mod;\n    \n    f[0][0] = 1;\n\n    for (int i = 0; i <= n; i++) \n    for (int j = i; j <= n; j++) {\n        long long &rt = f[i][j];\n\n        if (j > i) \n            rt = C((k - 1) * j + i - 1, k - 2) * f[i][j - 1] % mod;\n        if (i > 0) {\n            rt = (rt + f[i - 1][j]) % mod;\n        }\n    }\n\n    cout << ans * f[n][n] % mod << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#define re register\n#define LL long long\n#define N 2005\n#define Maxn 4000000\nusing namespace std;\nconst int Mod=1e9+7;\nint n,k,koiu=0;\nLL f[N][N],fac[Maxn+5],inv_fac[Maxn+5];\ninline LL C(int n,int m)\n{\n    return (((fac[m]*inv_fac[n])%Mod)*inv_fac[m-n])%Mod;\n}\nLL power(LL x,int P)\n{\n    LL ans=1,m=x;\n    while(P)\n    {\n        if(P&1) (ans*=m)%=Mod;\n        P>>=1;(m*=m)%=Mod;\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    if(k==1)\n    {\n        printf(\"%d\\n\",1);\n        return 0;\n    }\n    fac[0]=1; for(re int i=1;i<=Maxn;++i) fac[i]=(fac[i-1]*i)%Mod;\n    inv_fac[Maxn]=power(fac[Maxn],Mod-2); for(re int i=Maxn-1;i>=0;--i) inv_fac[i]=(inv_fac[i+1]*(i+1))%Mod;\n    f[0][0]=1;\n    for(re int i=1;i<=n;++i)\n    {\n        for(re int j=0;j<=i;++j)\n        {\n            f[i][j]=f[i-1][j];\n            if(!j) continue;\n            (f[i][j]+=f[i][j-1]*(n-j+1)%Mod*C(k-2,n-i+(n-j+1)*(k-1)-1)%Mod)%=Mod;\n        }\n    }\n    printf(\"%lld\\n\",f[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 2e3 + 10;\nconst int MOD = 1e9 + 7;\n\nlong long dp[MAXN][MAXN];\nlong long fac[MAXN * MAXN];\nint n, k;\n\nlong long po(long long v, long long u)\n{\n\treturn u ? (po(v * v % MOD, u >> 1) * (u & 1 ? v : 1) % MOD) : 1;\n}\n\nlong long ente(int i, int j)\n{\n\tlong long res = po(fac[i], MOD - 2) * po(fac[j - i], MOD - 2);\n\tres %= MOD;\n\tres *= fac[j];\n\treturn res % MOD;\n}\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcin >> n >> k;\n\tfac[0] = 1;\n\tfor (int i = 1; i < MAXN * MAXN; i++)\n\t\tfac[i] = (fac[i - 1] * i) % MOD;\n\tif (k == 1)\n\t\treturn cout << 1 << '\\n', 0;\n\tdp[0][0] = 1;\n\tfor (int i = 0; i <= n; i++)\n\t{\n\t\tfor (int j = i; j <= n; j++)\n\t\t{\n\t\t\tif (i)\n\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\tif (j)\n\t\t\t\tdp[i][j] += dp[i][j - 1] * ente(k - 2, i + j * (k - 1) - 1);\n\t\t\tdp[i][j] %= MOD;\n\t\t}\n\t}\n\tdp[n][n] = (dp[n][n] * fac[n]) % MOD;\n\tcout << dp[n][n] << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#define ll long long\n#define res register ll\n#define N 2005\nusing namespace std;\nll inv[N*N+N+N],jie[N*N+N+N],k,n,f[N][N];\nconst ll mod=1e9+7;\ninline ll read()\n{\n  ll X=0,w=0;\n  char ch=0;\n  while(!isdigit(ch))\n  {\n    w|=ch=='-';\n    ch=getchar();\n  }\n  while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();\n  return w?-X:X;\n}\ninline ll quickpow(res base,res num)\n{\n  res ans=1;\n  for(; num; num>>=1,base=1LL*base*base%mod)\n    if(num&1)\n      ans=1LL*ans*base%mod;\n  return ans;\n}\ninline void init()\n{\n  jie[0]=jie[1]=inv[0]=inv[1]=1;\n  for(res i=2; i<=n*k+n+k; i++)\n  {\n    jie[i]=1LL*jie[i-1]*i%mod;\n    inv[i]=quickpow(jie[i],mod-2);\n  }\n}\ninline ll C(ll m,ll n)\n{\n  return 1LL*jie[m]*inv[n]%mod*1LL*inv[m-n]%mod;\n}\nint main()\n{\n  n=read(),k=read()-1;\n  if(!k)\n  {\n    puts(\"1\");\n    return 0;\n  }\n  init();\n  f[0][0]=1;\n  for(res i=0; i<=n; i++)\n    for(res j=i; j<=n; j++)\n    {\n      if(i) f[i][j]=(f[i][j]+f[i-1][j])%mod;\n      if(j) f[i][j]=(f[i][j]+1LL*f[i][j-1]*C(i+j*k-1,k-1)%mod)%mod;\n    }\n  printf(\"%lld\\n\",1LL*f[n][n]*jie[n]%mod);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll mod = 1000000007;\n#define SIZE 5000000\nll inv[SIZE + 1];\nll kai[SIZE + 1];\nll invkai[SIZE + 1];\nvoid invinit()\n{\n\tinv[1] = 1;\n\tfor (int i = 2; i <= SIZE; i++)\n\t{\n\t\tinv[i] = mod - (mod / i)*inv[mod%i] % mod;\n\t}\n\tkai[0] = invkai[0] = 1;\n\tfor (int i = 1; i <= SIZE; i++)\n\t{\n\t\tkai[i] = kai[i - 1] * i%mod;\n\t\tinvkai[i] = invkai[i - 1] * inv[i] % mod;\n\t}\n}\nll com(ll a, ll b)\n{\n\tif (b < 0 || a < b)return 0;\n\treturn (invkai[b] * invkai[a - b]) % mod*kai[a] % mod;\n}\nll dp[2001][2001];\nint main()\n{\n\tinvinit();\n\tint num, k;\n\tscanf(\"%d%d\", &num, &k);\n\tif (k == 1)\n\t{\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= num; i++)\n\t{\n\t\tll sum = 0;\n\t\tfor (int j = i; j >= 1; j--)\n\t\t{\n\t\t\tsum = (sum + dp[i - 1][j - 1]) % mod;\n\t\t\tdp[i][j] = sum*com(i*k - j - 1, k - 2) % mod;\n\t\t}\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i <= num; i++)ans = (ans + dp[num][i]) % mod;\n\tfor (int i = 1; i <= num; i++)ans = ans*i%mod;\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define IL inline\n#define rep(i,j,k) for(int i=j;i<=k;++i)\n#define repd(i,j,k) for(int i=j;i>=k;--i)\n#define pb push_back\n#define db double\n#define mp make_pair\n#define mp3(a,b,c) mp(mp(a,b),c)\n#define pii pair<int,int>\n#define piii pair<pii,int>\n#define fr first\n#define se second\n#define ll long long\n#define ull unsigned long long\n#define pbc(x) __builtin_popcount(x)\n#define clr(x) memset(x,0,sizeof x)\n#define SIZE(x) (int)(x.size())\nconst int mod=1e9+7;\nIL int pls(int x,int y){x+=y;return x>=mod?x-mod:x;}\nIL int dec(int x,int y){x-=y;return x<0?x+mod:x;}\nIL int mul(int x,int y){return 1ll*x*y%mod;}\nIL int mul(int x,int y,int z){return mul(mul(x,y),z);}\nIL int mul(int x,int y,int z,int p){return mul(mul(x,y),mul(z,p));}\nIL void add(int &x,int y){x+=y;x=(x>=mod)?x-mod:x;}\nIL int fpw(int x,int y,int r=1){for(;y;y>>=1,x=mul(x,x))if(y&1)r=mul(r,x);return r;}\nIL int inv(int x){return fpw(x,mod-2);}\nIL int gi(){int x;int _w=scanf(\"%d\",&x);return x;}\nIL void gi(int &x){int _w=scanf(\"%d\",&x);}\nIL void write(int x){printf(\"%d\\n\",x);}\nvoid chkmax(int &x,int y){x=(x>y)?x:y;}\nvoid chkmin(int &x,int y){x=(x<y)?x:y;}\nconst int INF=0x3f3f3f3f;\ntemplate<typename T>IL void debug(T x){cerr<<x;return;}\n/* --------------------------------------------------------------------------------------------------------- */\nconst int maxn=4000+10;\nconst int LIMIT=4e6;\nint f[maxn][maxn],n,k,fac[LIMIT+10],ifac[LIMIT+10];\nIL int C(int n,int m){return mul(fac[n],ifac[m],ifac[n-m]);}\nint main(){\n\tn=gi(),k=gi();\n\tif(k==1)cout<<1<<endl;\n\telse{\n\t\tfac[0]=ifac[0]=1;\n\t\trep(i,1,LIMIT)fac[i]=mul(fac[i-1],i);\n\t\tifac[LIMIT]=inv(fac[LIMIT]);\n\t\trepd(i,LIMIT-1,1)ifac[i]=mul(ifac[i+1],i+1);\n\n\t\tf[0][0]=1;\n\t\trep(i,0,n)rep(j,i,n){\n\t\t\tif(i)f[i][j]=pls(f[i][j],f[i-1][j]);\n\t\t\tif(j)f[i][j]=pls(f[i][j],mul(f[i][j-1],C(i+(j-1)*(k-1)+k-2,k-2)));\n\t\t}\n\t\tcout<<mul(f[n][n],fac[n])<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2017-10-13\n//miaomiao\n//\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define For(i, a, b) for(int i = (a); i <= (int)(b); ++i)\n#define Forr(i, a, b) for(int i = (a); i >= (int)(b); --i)\n\n#define N (2000+5)\n#define M (4000000+5)\n\nconst int P = 1e9 + 7;\n\nint Pow(int a, int anum){\n\tint ret = 1;\n\twhile(anum){\n\t\tif(anum & 1) ret = 1ll * ret * a % P;\n\t\ta = 1ll * a * a % P; anum >>= 1;\n\t}\n\treturn ret;\n}\n\nint fac[M], rfac[M], f[N][N];\n\nvoid Init(int n){\n\tfac[0] = rfac[0] = 1;\n\tFor(i, 1, n) fac[i] = 1ll * fac[i-1] * i % P;\n\n\trfac[n] = Pow(fac[n], P-2);\n\tForr(i, n-1, 1) rfac[i] = 1ll * rfac[i+1] * (i+1) % P;\n}\n\nint C(int a, int b){\n\treturn 1ll * fac[a] * rfac[b] % P * 1ll * rfac[a-b] % P;\n}\n\nint main(){\n\tInit(4000000);\n\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\t\n\tif(k == 1){\n\t\tputs(\"1\"); return 0;\n\t}\n\t\n\tf[0][0] = 1;\n\tFor(i, 0, n) For(j, i, n){\n\t\t(f[i+1][j] += f[i][j]) %= P;\n\t\t(f[i][j+1] += 1ll * C(i+(j+1)*(k-1)-1, k-2) * f[i][j] % P) %= P;\n\t}\n\tprintf(\"%d\\n\", 1ll * f[n][n] * fac[n] % P);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int MAXN = 2000, MAXL = MAXN * MAXN, MOD = 1e9 + 7;\nint n, K, fac[MAXL + 5], ifac[MAXL + 5], f[MAXN + 5][MAXN + 5];\n\ninline void addeq ( int& a, const int b ) { if ( ( a += b ) >= MOD ) a -= MOD; }\n\ninline int qkpow ( int a, int b ) {\n\tint ret = 1;\n\tfor ( ; b; a = 1ll * a * a % MOD, b >>= 1 ) ret = 1ll * ret * ( b & 1 ? a : 1 ) % MOD;\n\treturn ret;\n}\n\ninline void init ( const int n ) {\n\tfac[0] = 1;\n\tfor ( int i = 1; i <= n; ++ i ) fac[i] = 1ll * i * fac[i - 1] % MOD;\n\tifac[n] = qkpow ( fac[n], MOD - 2 );\n\tfor ( int i = n - 1; ~ i; -- i ) ifac[i] = ( i + 1ll ) * ifac[i + 1] % MOD;\n}\n\ninline int C ( const int n, const int m ) {\n\treturn n < m ? 0 : 1ll * fac[n] * ifac[m] % MOD * ifac[n - m] % MOD;\n}\n\nint main () {\n\tscanf ( \"%d %d\", &n, &K );\n\tif ( K == 1 ) return puts ( \"1\" ), 0;\n\tinit ( n * K ), f[0][0] = 1;\n\tfor ( int i = 1; i <= n; ++ i ) {\n\t\tfor ( int j = 0; j <= i; ++ j ) {\n\t\t\tint& cur = f[i][j];\n\t\t\tif ( i ^ j ) addeq ( cur, f[i - 1][j] );\n\t\t\tif ( j ) addeq ( cur, 1ll * f[i][j - 1]\n\t\t\t\t* C ( n * K - i - ( j - 1 ) * ( K - 1 ) - 1, K - 2 ) % MOD );\n\t\t}\n\t}\n\tprintf ( \"%d\\n\", int ( 1ll * f[n][n] * fac[n] % MOD ) );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=2005;\nconst int MOD=1000000007;\n\nint n,k,f[N][N],jc[N*N+N*2],ny[N*N+N*2];\n\nvoid updata(int &x,int y)\n{\n    x+=y,x-=x>=MOD?MOD:0;\n}\n\nint C(int n,int m)\n{\n    return (LL)jc[n]*ny[m]%MOD*ny[n-m]%MOD;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&k);k--;\n    if (!k) {puts(\"1\");return 0;}\n    jc[0]=jc[1]=ny[0]=ny[1]=1;\n    for (int i=2;i<=n*k+n+k;i++) jc[i]=(LL)jc[i-1]*i%MOD,ny[i]=(LL)(MOD-MOD/i)*ny[MOD%i]%MOD;\n    for (int i=2;i<=n*k+n+k;i++) ny[i]=(LL)ny[i-1]*ny[i]%MOD;\n    f[0][0]=1;\n    for (int i=0;i<=n;i++)\n        for (int j=i;j<=n;j++)\n        {\n            if (i) updata(f[i][j],f[i-1][j]);\n            if (j) updata(f[i][j],(LL)f[i][j-1]*C(i+(j-1)*k+k-1,k-1)%MOD);\n        }\n    printf(\"%d\",(LL)f[n][n]*jc[n]%MOD);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 0x7fffffff\n#define RG register\n#define inf 0x7fffffff\n#define mkp make_pair\n#define maxn 100205\ntypedef unsigned int U;\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1e9+7;\nconst  double eps = 1e-8;\nconst double pi = acos(-1);\ninline ll read(){\n    ll x = 0, f = 1;\n    char ch = getchar();\n    while(ch > '9' || ch < '0') {if(ch == '-') f = -1;ch = getchar();}\n    while(ch >= '0' && ch <= '9'){x = x *10 + ch -'0';ch = getchar();}\n    return x * f;\n}\nint n,k;\nint fac[4000005],inv[4000005];\nint f[2005][2005];\nint qpow(int a,int b){\n\tint ans=1,base=a;\n\twhile(b){\n\t\tif(b&1) ans=1ll*ans*base%mod;\n\t\tbase=1ll*base*base%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint C(int n,int m){return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint main(){\n\tint i,j,u,v,e,w;\n\t//freopen(\"a.out\",\"r\",stdin);\n\t//freopen(\"a.ans\",\"w\",stdout);n\n\tn=read(),k=read();\n\tif(k==1) {puts(\"1\");return 0;}\n\tfac[0]=1;\n\tfor(i=1;i<=n*k;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[n*k]=qpow(fac[n*k],mod-2);\n\tfor(i=n*k-1;i>=0;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tf[0][0]=1;\n\tfor(i=0;i<=n;i++){\n\t\tfor(j=i;j<=n;j++){\n\t\t\tif(i+1<=j) f[i+1][j]=(f[i+1][j]+f[i][j])%mod;\n\t\t\tif(j+1<=n) f[i][j+1]=(f[i][j+1]+1ll*f[i][j]*C(i+(k-1)*j+k-2,k-2)%mod)%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",1ll*f[n][n]*fac[n]%mod);\n\treturn 0;\n}\n/*\n8\n0 0 0 0\n0 0 1 1\n0 1 0 1\n0 1 1 0\n1 0 0 1\n1 0 1 0\n1 1 0 0\n1 1 1 1\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int N=2005,M=4000005,P=1E9+7;\n\nint fac[M],ifac[M],n,K,m,dp[N][N];\ninline int power(int a,int t){static int r;for(r=1;t;a=(ll)a*a%P,t>>=1)if(t&1)r=(ll)r*a%P;return r;}\ninline int C(int n,int m){return(ll)fac[n]*ifac[m]%P*ifac[n-m]%P;}\n\nint main(){\n\tscanf(\"%d%d\",&n,&K);\n\tif(K==1)puts(\"1\"),exit(0);\n\tm=n*K,fac[0]=1;\n\tfor(int i=1;i<=m;i++)fac[i]=(ll)fac[i-1]*i%P;\n\tifac[m]=power(fac[m],P-2);\n\tfor(int i=m;i>=1;i--)ifac[i-1]=(ll)ifac[i]*i%P;\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++)for(int j=0;j<=i;j++){\n\t\tif(j)dp[i][j]=dp[i][j-1];\n\t\tdp[i][j]=(dp[i][j]+(ll)dp[i-1][j]*C(i*(K-1)+j-1,K-2))%P;\n\t}\n\tprintf(\"%d\\n\",(ll)dp[n][n]*fac[n]%P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define IL inline\n#define RG register\n#define LL long long\n#define Upd(a) (a)>=mod?(a-=mod):1\nusing namespace std;\ntemplate <class T>\nIL char gc () {\n\tstatic char buf[1<<6], *p1=buf, *p2=buf;\n\treturn (p1==p2) && (p2=(p1=buf)+fread(buf,1,1<<6,stdin), p1==p2) ?EOF:*p1++;\n}\ntemplate <typename T>\nIL void read (T&data) {\n\tdata=0;\n\tRG char ch=0;\n\twhile (ch<'0' || ch>'9') ch=getchar();\n\twhile (ch<='9' && ch>='0') data=(data<<1)+(data<<3)+(ch&15), ch=getchar();\n}\nconst int mod = 1e9+7;\nconst int _ =2011;\nint n, k;\nint dp[2][_], jc[_*_], jcn[_*_];\nIL int poww (RG int a, RG int b) {\n\tRG int ret=1, Base=a;\n\tfor (;b;b>>=1, Base=1LL*Base*Base%mod) if (b&1) ret=1LL*ret*Base%mod;\n\treturn ret;\n}\nIL int C (RG int a, RG int b) {\n\tif (a<b) return 0;\n\treturn 1LL*jc[a]*jcn[b]%mod*jcn[a-b]%mod;\n}\nint main (/*int aa, int bb*/) {\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\t//n=aa, k=bb;\n\tread(n), read(k);\n\tif (k<=1) {puts(\"1\"); return 0;}\n\tjc[0]=jcn[0]=1;\n\tRG int i, j, pre=1, cur=0;\n\tfor (i=1; i<=n*k; ++i) jc[i]=1LL*jc[i-1]*i%mod, jcn[i]=poww(jc[i], mod-2);\n\tdp[0][0]=1;\n\tfor (i=1; i<=n*2; ++i) {\n\t\tswap(cur, pre);\n\t\tfor (j=0; j<min(i,n+1); ++j) dp[cur][j]=0;\n\t\tfor (j=1; j<=min(i,n); ++j) {\n\t\t\tif ((i-j)%2) continue;\n\t\t\tif (n*2-i+1<j) break;\n\t\t\tRG int a=(i+j-2)>>1, b=(i-j)>>1;\n\t\t\tdp[cur][j]=1LL*dp[pre][j-1]*C(a*(k-1)+b+k-1-1,k-1-1)%mod;\n\t\t\tdp[cur][j]+=dp[pre][j+1];\n\t\t\tUpd(dp[cur][j]);\n\t\t}\n\t\tif (cur%2==0) dp[cur][0]=dp[pre][1];\n\t}\n\t//return 1LL*dp[cur][0]*jc[n]%mod;\n\tprintf(\"%lld\",1LL*dp[cur][0]*jc[n]%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst ll MOD = 1000000007;\n\nll f[4000010];\nll invf[4000010];\n\nll mod_pow(ll x, ll k)\n{\n    ll res = 1;\n    for (; k; x = x * x % MOD, k /= 2) if (k & 1) res = res * x % MOD;\n    return res;\n}\n\nll comb(int n, int k)\n{\n    if (k < 0 || k > n) return 0;\n    return f[n] * invf[k] % MOD * invf[n-k] % MOD;\n}\n\nint N, K;\n\nll dp[2010][2010]; // j = num of front 0\nll acm[2010];\n\nint main() {\n    f[0] = invf[0] = 1;\n\n    for (int i = 1; i <= 4000000; ++i) {\n\tf[i] = f[i-1] * i % MOD;\n\tinvf[i] = mod_pow(f[i], MOD - 2);\n    }\n    \n    cin >> N >> K;\n\n    if (K == 1) {\n\tputs(\"1\");\n\treturn 0;\n    }\n\n    dp[1][1] = 1;\n\n    for (int i = 2; i <= N; ++i) {\n\tmemset(acm, 0, sizeof(acm));\n\n\tfor (int j = 2000; j >= 0; --j) {\n\t    acm[j] = (acm[j + 1] + dp[i-1][j]) % MOD;\n\t}\n\n\tfor (int j = 1; j <= i; ++j) {\n\t    int pos = (i - 1) * K - j + 1;\n\n\t    ll t = comb(pos + K - 2, K - 2);\n\t    dp[i][j] = (dp[i][j] + acm[j - 1] * t) % MOD;\n\t}\n    }\n\n    ll ret = 0;\n    rep(i, 2010) ret = (ret + dp[N][i]) % MOD;\n    ret = ret * f[N] % MOD;\n\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n#define debug(x) cout << #x << \": \" << x << endl\n#else\n#define debug(x)\n#endif\nusing namespace std;\ntypedef long long ll;\nconst int maxn=4e6+7;\nconst int inf=0x3f3f3f3f;\nconst int mod=1e9+7;\n\nll quick(ll x,ll n)\n{\n    ll res=1;\n    while(n)\n    {\n        if(n&1) res=(res*x)%mod;\n        x=x*x%mod;\n        n>>=1;\n    }\n    return res;\n}\nll inv(ll x) {return quick(x,mod-2);}\n\nll fac[maxn];\nvoid init()\n{\n    fac[0]=1;\n    for(int i=1;i<maxn;++i) fac[i]=(fac[i-1]*i)%mod;\n}\n\nll C(int n,int m)\n{\n    return fac[n]*inv(fac[m])%mod*inv(fac[n-m])%mod;\n}\n\nll dp[2007][2007];\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    init();\n    int n,k;\n    cin>>n>>k;\n    if(k==1) cout<<1<<endl;\n    else\n    {\n        dp[0][0]=1;\n        for(int i=1;i<=n;++i)\n        {\n            for(int j=0;j<=i;++j)\n            {\n                if(j==0) dp[i][j]=1;\n                else\n                {\n                    assert(n*k-i-(j-1)*(k-1)-1>=k-2);\n                    dp[i][j]=(dp[i-1][j]+1ll*dp[i][j-1]*(n-j+1)%mod*C(n*k-i-(j-1)*(k-1)-1,k-2)%mod)%mod;\n                }\n            }\n        }\n        cout<<dp[n][n]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if (v+o.v >= N) v += o.v - N; else v += o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v -= o.v-N; else v-=o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\ttemplate <typename T>\n\tstatic T div(T p, T q, T N) {\n\t\tT t=0,nt=1,r=N,nr=q;\n\t\twhile(nr!=0){ T q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r!=0) { return 0; }\n\t\treturn (t*p/r)%N;\n\t}\n};\n#endif\n\n\nclass FLeftmostBall {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N, K; cin >> N >> K;\n        if (K == 1) {\n            cout << 1 << endl;\n            return;\n        }\n\n        auto F = FieldMod::fact(N*K);\n        auto I = FieldMod::invfact(N*K);\n\n        vector2<FieldMod> A(N+1, N+1, 0);\n        A[0][0] = 1;\n        for (int i = 0; i <= N; ++i) {\n            for (int j = 0; j <= N; ++j) {\n                if (i != N) {\n                    A[i+1][j] += A[i][j];\n                }\n\n                if (i != j) {\n                    int k = (N - (j+1)) * (K-1) + (N - i);\n                    A[i][j+1] += A[i][j] * F[k + K - 2] * I[k];\n                }\n            }\n        }\n        cout << A[N][N] * F[N] * I[K-2].pow(N) << endl;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tFLeftmostBall solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll n,m,f[2010][2010],jc[4000010],ny[4000010],p=1e9+7;\nll C(ll x,ll y){\n\treturn jc[x]*ny[y]%p*ny[x-y]%p;\n}\nll ksm(ll x,ll y){\n\tll xlh=1;\n\twhile(y){\n\t\tif(y&1)xlh=xlh*x%p;\n\t\tx=x*x%p;\n\t\ty/=2;\n\t}\n\treturn xlh;\n}\nint main(){\n\tll i,j;\n\tscanf(\"%lld%lld\",&n,&m);\n\tif(m==1)return puts(\"1\"),0;\n\tjc[0]=1;ny[0]=ny[1]=1;\n\tfor(i=1;i<=n*m;i++)jc[i]=jc[i-1]*i%p;\n\tny[n*m]=ksm(jc[n*m],p-2)%p;\n\tfor(i=n*m-1;i>=2;i--){\n\t ny[i]=ny[i+1]*(i+1)%p;\n\t //printf(\"%lld %lld %lld\\n\",i,jc[i],ny[i]);\n}\n\tfor(i=0;i<=n;i++)f[i][0]=1;\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=i;j++){\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tf[i][j]=(f[i][j]+f[i][j-1]*(n-j+1)%p*C(n*m-i-(j-1)*(m-1)-1,m-2))%p;\n\t\t\t//printf(\"%lld %lld %lld %lld %lld %lld\\n\",i,j,f[i][j],f[i-1][j],n*m-i-(j-1)*(m-1)-1,C(n*m-i-(j-1)*(m-1)-1,m-2));\n\t\t}\n\t}\n\tprintf(\"%lld\",f[n][n]);\n}\n/*\n没有想到把当前放的固定在原序列上 \n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\n\n\n\nconst int MAXN = 2000 + 23, MXNK = MAXN * MAXN + 23, D = 1000 * 1000 * 1000 + 7;\n\n\n\n\n\n\n\n\n\n\n\nint n, k, f[MXNK], ivf[MXNK], dp[MAXN][MAXN];\n\nint inv(int x) {\n\tint ret = 1;\n\tfor (int y = D - 2; y; (y >>= 1), (x = x * x % D)) if (y & 1) ret = ret * x % D;\n\treturn ret;\n}\nint ent(int x, int y) { return f[y] * ivf[y - x] % D * ivf[x] % D; }\n\n\n\n\nint32_t main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr), cout.tie(nullptr);\n\tf[0] = 1;\n\tfor (int i = 1; i < MXNK; i++) f[i] = f[i - 1] * i % D;\n\tivf[MXNK - 1] = inv(f[MXNK - 1]);\n\tfor (int i = MXNK - 2; ~i; i--) ivf[i] = ivf[i + 1] * (i + 1) % D;\n\tcin >> n >> k;\n\tif (k == 1) return cout << 1, 0;\n\tdp[n][n] = 1;\n\tfor (int i = n; ~i; i--) for (int j = i; ~j; j--) {\n\t\tif (j < i) dp[i][j] = (dp[i][j] + ent(k - 2, n * k - i - j * (k - 1) - 1) * dp[i][j + 1]) % D;\n\t\tif (i < n) dp[i][j] = (dp[i + 1][j] + dp[i][j]) % D;\n\t}\n\tcout << dp[0][0] * f[n] % D;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define MAXN 2010\n#define LL long long\n#define P 1000000007\n\nint n,m,N;\nLL fac[MAXN*MAXN],invfac[MAXN*MAXN];\nLL f[MAXN][MAXN];\n\nLL getPow(LL x,LL y){\n\tLL res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%P;\n\t\tx=x*x%P;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\n\nLL getC(LL x,LL y){\n\tif(x<y) return 0;\n\treturn fac[x]*invfac[y]%P*invfac[x-y]%P;\n}\n\nLL calc_g(LL x,LL y){ return getC(x+y-1,y); }\n\nvoid init(){\n\tfac[0]=1;\n\tfor(int i=1;i<=N;i++)\n\t\tfac[i]=fac[i-1]*i%P;\n\tinvfac[N]=getPow(fac[N],P-2);\n\tfor(int i=N-1;i>=0;i--)\n\t\tinvfac[i]=invfac[i+1]*(i+1)%P;\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"F.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d%d\",&n,&m);\n\tif(m==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tN=n*m;\n\tinit();\n\tf[1][0]=f[1][1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int j=0;j<i;j++)\n\t\t\tf[i][j+1]=f[i-1][j]*calc_g(m*(i-1)-j+1,m-2)%P;\n\t\tfor(int j=i-1;j;j--)\n\t\t\tf[i][j]=(f[i][j]+f[i][j+1])%P;\n\t\tf[i][0]=f[i][1];\n\t}\n\tLL ans=f[n][0]*fac[n]%P;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=2e3+10,mod=1e9+7;\ninline int ksm(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=(ll)res*x%mod;\n\t\tx=(ll)x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint dp[maxn][maxn],fac[maxn*maxn],ifac[maxn*maxn];\ninline int C(int n,int m){\n\treturn (ll)fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\ninline void init(int n){\n\tfac[0]=1;\n\tREP(i,1,n) fac[i]=(ll)i*fac[i-1]%mod;\n\tifac[n]=ksm(fac[n],mod-2);\n\tDREP(i,n,1) ifac[i-1]=(ll)i*ifac[i]%mod;\n}\nint main(){\n#ifndef ONLINE_JUDGE\n\tfreopen(\"f.in\",\"r\",stdin);\n\tfreopen(\"f.out\",\"w\",stdout);\n#endif\n\tint n=read(),k=read();\n\tif(k==1){\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tinit(n*k);\n\tdp[0][0]=1;\n\tREP(i,1,n) REP(j,0,i){\n\t\tdp[i][j]=dp[i-1][j];\n\t\tif(j) dp[i][j]=(dp[i][j]+(ll)dp[i][j-1]*(n-j+1)%mod*C(n*k-i-(j-1)*(k-1)-1,k-2))%mod;\n\t}\n\tprintf(\"%d\\n\",dp[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// WARN : use H with larger N\n/// --- Modulo Factorial {{{ ///\ntemplate < int N, int mod = (int) 1e9 + 7 >\nstruct Factorial {\n  constexpr ll extgcd(ll a, ll b, ll &x, ll &y) {\n    ll d = 0;\n    return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n      : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  constexpr ll modinv(ll a) {\n    ll x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    return (x + mod) % mod;\n  }\n  int arr[N + 1], inv[N + 1];\n  ll operator[](int i) const { return arr[i]; }\n    Factorial()\n    : arr(), inv() {\n      arr[0] = 1;\n      for(int i = 1; i <= N; i++) {\n        arr[i] = (ll) i * arr[i - 1] % mod;\n      }\n      inv[N] = modinv(arr[N]);\n      for(int i = N - 1; i >= 0; i--) {\n        inv[i] = (ll)(i + 1) * inv[i + 1] % mod;\n      }\n    }\n  ll C(int n, int r) const {\n    if(n < 0 || r < 0 || n < r) return 0;\n    return (ll) arr[n] * inv[r] % mod * inv[n - r] % mod;\n  }\n  ll H(int n, int r) const { return C(n + r - 1, r); }\n};\n/// }}}--- ///\n\nconst int N = 2000 + 10;\nFactorial < N * N + N > fact;\n\n/// --- ModInt Library {{{ ///\n#include <ostream>\ntemplate < ll mod = (ll) 1e9 + 7 >\nstruct ModInt {\n  // math {{{\n  static inline ll extgcd(ll a, ll b, ll &x, ll &y) {\n    ll d;\n    return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n      : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  static inline ll modinv(ll a) {\n    ll x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    if(x < 0) x += mod;\n    return x;\n  }\n  static inline ll modpow(ll a, ll b) {\n    if(b < 0) b = -b, a = modinv(a);\n    ll r = 1;\n    a %= mod;\n    while(b) {\n      if(b & 1) r = r * a % mod;\n      a = a * a % mod;\n      b >>= 1;\n    }\n    return r;\n  }\n  // }}}\n\n  ll val;\n  constexpr ModInt() : val(0) {}\n  constexpr ModInt(ll t) {\n    val = t % mod;\n    if(val < 0) val += mod;\n  }\n\nprivate:\n  // strict constructor\n  constexpr ModInt(ll t, int) : val(t) {}\n\npublic:\n  template < class T >\n    explicit operator T() {\n      return T(val);\n    }\n  // ModInt <arithmetic-operator>[=] ModInt {{{\n  ModInt operator+(ModInt const &rhs) const {\n    ModInt tmp = *this;\n    tmp += rhs;\n    return tmp;\n  }\n  ModInt operator-(ModInt const &rhs) const {\n    ModInt tmp = *this;\n    tmp -= rhs;\n    return tmp;\n  }\n  ModInt operator*(ModInt const &rhs) const {\n    ModInt tmp = *this;\n    tmp *= rhs;\n    return tmp;\n  }\n  ModInt operator/(ModInt const &rhs) const {\n    ModInt tmp = *this;\n    tmp /= rhs;\n    return tmp;\n  }\n  ModInt &operator+=(ModInt const &rhs) {\n    val = val + rhs.val;\n    if(val >= mod) val -= mod;\n    return *this;\n  }\n  ModInt &operator-=(ModInt const &rhs) { return *this += -rhs; }\n  ModInt &operator*=(ModInt const &rhs) {\n    val = val * rhs.val % mod;\n    return *this;\n  }\n  ModInt &operator/=(ModInt const &rhs) { return *this *= rhs.inv(); }\n  // }}}\n  // increment, decrement {{{\n  ModInt operator++(int) {\n    ModInt tmp = *this;\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return tmp;\n  }\n  ModInt operator--(int) {\n    ModInt tmp = *this;\n    val = val == 0 ? mod - 1 : val - 1;\n    return tmp;\n  }\n  ModInt &operator++() {\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return *this;\n  }\n  ModInt &operator--() {\n    val = val == 0 ? mod - 1 : val - 1;\n    return *this;\n  }\n  // }}}\n  ModInt operator-() const { return ModInt(val == 0 ? 0 : mod - val, 0); }\n  // ModInt <arithmetic-operator>[=] T {{{\n  template < typename T >\n    ModInt operator+(T const &rhs) const {\n      return ModInt(val + rhs % mod);\n    }\n  template < typename T >\n    ModInt operator-(T const &rhs) const {\n      return ModInt(mod + val - rhs % mod);\n    }\n  template < typename T >\n    ModInt operator*(T const &rhs) const {\n      return ModInt(val * (rhs % mod));\n    }\n  template < typename T >\n    ModInt operator/(T const &rhs) const {\n      return ModInt(val * modinv(rhs));\n    }\n  template < typename T >\n    ModInt &operator+=(T const &rhs) {\n      val = (mod + val + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModInt &operator-=(T const &rhs) {\n      val = (mod + val - rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModInt &operator*=(T const &rhs) {\n      val = val * (mod + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModInt &operator/=(T const &rhs) {\n      val = val * modinv(rhs) % mod;\n      return *this;\n    }\n  // }}}\n  ModInt inv() const { return ModInt(modinv(val), 0); }\n  ModInt operator~() const { return inv(); }\n  friend ostream &operator<<(ostream &os, ModInt const &mv) {\n    os << mv.val;\n    return os;\n  }\n  // equality operator {{{\n  ModInt operator==(const ModInt &a) const { return val == a.val; }\n  ModInt operator!=(const ModInt &a) const { return val != a.val; }\n  ModInt operator==(const ll &a) const { return val == ModInt(a); }\n  ModInt operator!=(const ll &a) const { return val != ModInt(a); }\n  // }}}\n  // T <arithmetic-operator> ModInt {{{\n  friend constexpr ModInt operator+(ll a, ModInt const &mv) {\n    return ModInt(a % mod + mv.val);\n  }\n  friend constexpr ModInt operator-(ll a, ModInt const &mv) {\n    return ModInt(a % mod - mv.val);\n  }\n  friend constexpr ModInt operator*(ll a, ModInt const &mv) {\n    return ModInt((mod + a % mod) * mv.val % mod, 0);\n  }\n  friend constexpr ModInt operator/(ll a, ModInt const &mv) {\n    return ModInt((mod + a % mod) * modinv(mv.val) % mod, 0);\n  }\n  // }}}\n  // power {{{\n  ModInt operator^(ll x) const { return pow(*this, x); }\n  ModInt &operator^=(ll x) {\n    val = modpow(val, x);\n    return *this;\n  }\n  friend ModInt pow(ModInt x, ll y) { return ModInt(modpow(x.val, y), 0); }\n  // }}}\n};\n/// }}}--- ///\n\nusing modint = ModInt<>;\n\nmodint dp[N][N];\n\nint n, k;\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n >> k;\n  if(n == 1 || k == 1) {\n    cout << 1 << endl;\n    return 0;\n  }\n  for(int i = n; i >= 0; i--) for(int j = i; j >= 0; j--) {\n    if(i == j) {\n      if(i == n) {\n        dp[i][j] = 1;\n      } else {\n        dp[i][j] = dp[i+1][j];\n      }\n    } else {\n      int v = (n - i) + (n - j - 1) * (k - 1);\n      dp[i][j] = dp[i][j+1] * fact.C(v + k - 2, k - 2);\n      dp[i][j] += dp[i+1][j];\n    }\n  }\n  cout << dp[0][0] * fact[n] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\n#define int long long\n#define ll long long\nusing namespace std;\nconst int maxn=2001;\nconst int mmd=4000010;\nconst int mod=1e9+7;\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9') {if(ch=='-') f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9') {x=x*10+(ch^48); ch=getchar();}\n\treturn x*f;\n}\nint n,k;\nll f[maxn+10][maxn+10],inv[mmd],fac[mmd];\nll qpow(ll a,ll b)\n{\n\tll base=1;\n\ta%=mod;\n\twhile(b)\n\t{\n\t\tif(b&1) base=base*a%mod;\n\t\tb>>=1;\n\t\ta=a*a%mod;\n\t}\n\treturn base;\n}\ninline ll C(int n,int m){ return (((fac[m]*inv[n])%mod)*inv[m-n])%mod; }\nsigned main()\n{\n\tn=read(); k=read();\n\tif(k==1) \n\t{\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n//\tinc(i,1,maxn) \n\tfor(int i=1;i<=mmd;i++)\n\tfac[i]=(fac[i-1]*i)%mod;\n\tinv[mmd]=qpow(fac[mmd],mod-2);\n//\tdec(i,maxn-1,0) \n\tfor(int i=mmd-1;i>=0;--i)\n\tinv[i]=(inv[i+1]*(i+1))%mod;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=0;j<=i;++j)\n\t\t{\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(j==0) continue;\n\t\t\t(f[i][j]+=f[i][j-1]*(n-j+1)%mod*C(k-2,n-i+(n-j+1)*(k-1)-1)%mod)%=mod;\n\t\t}\n\t}\n\tcout<<f[n][n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\ntemplate<typename T> inline void chkmin(T &a, const T &b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T &a, const T &b) { a = a > b ? a : b; }\n\nconst int MAXN = 2005, MAXM = 4000005, MOD = 1e9 + 7;\nint f[MAXN][MAXN], g[MAXM], inv[MAXM], n, K;\n\nint main() {\n\tscanf(\"%d%d\", &n, &K);\n\tif (K == 1) return puts(\"1\") * 0;\n\tinv[1] = 1;\n\tfor (int i = 2; i <= n * K; i++)\n\t\tinv[i] = MOD - (LL)MOD / i * inv[MOD % i] % MOD;\n\tg[K - 2] = 1;\n\tfor (int i = K - 1; i <= n * K; i++)\n\t\tg[i] = (LL)g[i - 1] * i % MOD * inv[i - K + 2] % MOD;\n\tf[n][n] = 1;\n\tfor (int i = n - 1; i >= 0; i--)\n\tfor (int j = n; j >= i; j--)\n\t\tf[i][j] = (f[i + 1][j] + (LL)f[i][j + 1] * g[i + (K - 1) * (j + 1) - 1] % MOD * (j + 1)) % MOD;\n\tprintf(\"%d\\n\", f[0][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define ll long long\n#define pb push_back\n \nconst int maxn = 2e3 + 20;\nconst int maxm = maxn * maxn + 20;\nconst int mod = 1e9 + 7;\n\nint dp[maxn][maxn] , fac[maxm] , caf[maxm];\n\ninline void mkay(int &a)\n{\n\tif(a >= mod)\n\t\ta -= mod;\n\telse if(a < 0)\n\t\ta += mod;\n}\n\nint bpw(int a , int b)\n{\n\tif(!b)\n\t\treturn 1;\n\tint x = bpw(a , b / 2);\n\n\tx = 1LL * x * x % mod;\n\tif(b&1)\n\t\tx = 1LL * x * a % mod;\n\n\treturn x;\n}\n\nint c(int s , int r)\n{\n\tif(r < 0 || r > s)\n\t\treturn 0;\n\n\treturn 1LL * fac[s] * caf[r] % mod * caf[s - r] % mod;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tfac[0] = 1;\n\tfor(int i = 1; i < maxm; i++)\n\t\tfac[i] = 1LL * fac[i - 1] * i % mod;\n\n\tcaf[maxm - 1] = bpw(fac[maxm - 1] , mod - 2);\n\tfor(int i = maxm - 1; i > 0; i--)\n\t\tcaf[i - 1] = 1LL * caf[i] * i % mod;\n\n\tint n , k;\n\tcin >> n >> k;\n\n\tif(k == 1)\n\t\treturn cout << 1 << endl , 0;\n\n\tdp[0][0] = 1;\n\tfor(int j = 0; j <= n; j++)\n\t\tfor(int i = 0; i <= j; i++)\n\t\t{\n\t\t\tmkay(dp[i + 1][j] += 1LL * dp[i][j] * (n - i) % mod * c(n * k - (k - 1) * i - j - 1 , k - 2) % mod);\n\t\t\tmkay(dp[i][j + 1] += dp[i][j]);\n\t\t}\n\n\tcout << dp[n][n] << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<set>\n#include<vector>\nusing namespace std;\nlong long mod=1000000007;\nint M=8050000;\nlong long fact[8100000];\nlong long inv[8100000];\nlong long factinv[8100000];\nlong long dp[2100][2100];\nlong long C(int a,int b){\n\treturn fact[a]*factinv[a-b]%mod*factinv[b]%mod;\n}\nint N;\nint K;\nlong long calc(int a,int b){\n\tif(dp[a][b]!=-1)return dp[a][b];\n\tif(a==0&&b==0)return 1;\n\tlong long ret=0;\n\tif(a){\n\t\tret+=calc(a-1,b);\n\t}\n\tif(a<b){\n\t\tret=(ret+calc(a,b-1)*C((K-1)*b+a-1,K-2))%mod;\n\t}\n\treturn dp[a][b]=ret;\n}\nint main(){\n\tinv[1]=fact[0]=factinv[0]=1;\n\tfor(int i=2;i<M;i++)inv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\tfor(int i=1;i<M;i++)fact[i]=fact[i-1]*i%mod;\n\tfor(int i=1;i<M;i++)factinv[i]=factinv[i-1]*inv[i]%mod;\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tN=a;\n\tK=b;\n\tif(K==1){\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<=a;i++)for(int j=0;j<=a;j++)\n\t\tdp[i][j]=-1;\n\tprintf(\"%lld\\n\",calc(a,a)*fact[a]%mod);\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 19.01.2020 00:19:49       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  if (k == 1) {\n    cout << 1 << '\\n';\n    return 0;\n  }\n  vector<Mint> fact(n * k + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= n * k; i++) {\n    fact[i] = fact[i - 1] * i;\n  }\n  auto C = [&](int N, int K) -> Mint {\n    if (K < 0 || K > N) {\n      return 0;\n    }\n    return fact[N] / (fact[K] * fact[N - K]);\n  };\n  vector<vector<Mint>> dp(2 * n + 1, vector<Mint>(n + 1, 0));\n  dp[0][0] = 1;\n  for (int i = 0; i < 2 * n; i++) {\n    for (int j = 0; j <= n; j++) {\n      if (2 * j > i) {\n        dp[i + 1][j] += dp[i][j];\n      }\n      if (j < n) {\n        dp[i + 1][j + 1] += dp[i][j] * C(i + j * (k - 2) + (k - 2), k - 2);\n      }\n    }\n  }\n  cout << dp[2 * n][n] * fact[n] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//BadWaper gg\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<deque>\n#include<bitset>\n#include<map>\n#include<set>\n#define inf 1e9\n#define eps 1e-6\n#define mp make_pair\n#define N 2010\n#define M 4000010\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ninline ll read()\n{\n\tchar ch=getchar();\n\tll s=0,w=1;\n\twhile(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}\n\treturn s*w;\n}\nint f[N][N];\nint fac[M],inv[M];\nint n,k;\nconst int mod=1e9+7;\ninline int C(int n,int m){if(n<m)return 0;return 1LL*fac[n]*inv[m]%mod*inv[n-m]%mod;}\ninline int Z(int x){return x>=mod?x-mod:x;}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read(),k=read();\n\tif(k==1){printf(\"1\\n\");return 0;}\n\tfac[0]=1;\n\tfor(register int i=1;i<=n*k;i++)fac[i]=1LL*fac[i-1]*i%mod;\n\tinv[0]=inv[1]=1;\n\tfor(register int i=2;i<=n*k;i++)inv[i]=1LL*(mod-mod/i)*inv[mod%i]%mod;\n\tfor(register int i=2;i<=n*k;i++)inv[i]=1LL*inv[i]*inv[i-1]%mod;\n\tf[0][0]=1;\n\tfor(register int i=1;i<=n;i++)\n\t{\n\t\tf[i][0]=1;\n\t\tfor(register int j=1;j<=i;j++)\n\t\t{\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tf[i][j]=Z(f[i][j]+1LL*f[i][j-1]*(n-j+1)%mod*C(n*k-(j-1)*(k-1)-i-1,k-2)%mod);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\ntypedef long long ll;\nconst int Imx=2147483647;\nconst ll Lbig=2e18;\nconst int mod=1e9+7;\nll qpow(ll x,ll k){return k==0?1:qpow(x*x%mod,k>>=1)*(k&1?x:1)%mod;}\nint n,k;\nll fac[4000111],ifac[4000111];\nll dp[2011][2011];\nll C(ll x,ll y){return fac[x]*ifac[y]%mod*ifac[x-y]%mod;}\nint main()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=4000005;i++)fac[i]=fac[i-1]*i%mod;\n\tifac[4000005]=qpow(fac[4000005],mod-2);\n\tfor(int i=4000004;i>=0;i--)ifac[i]=ifac[i+1]*(i+1)%mod;\n\tcin>>n>>k;\n\tif(k==1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tll ans=1;\n\tint cur=0;\n\tdp[1][1]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tfor(int j=i;j>=1;j--)\n\t\t{\n\t\t\tll &cur=dp[i][j];\n\t\t\tcur=(dp[i][j+1]+dp[i-1][max(1,j-1)]*C(k*i-j-1,k-2))%mod;\n//\t\t\tcout<<i<<\" \"<<j<<\":\"<<cur<<endl;\n\t\t}\n\t}\n\tcout<<dp[n][1]*fac[n]%mod;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 1e9+7;\n\nint power(int a, int p) {\n    if (p == 0) return 1;\n    int ans = power(a, p/2);\n    ans = (1LL*ans * ans)%M;\n    if (p%2)    ans = (1LL*ans*a)%M;\n    return ans;\n}\n\nconst int N = 4e6+7, K = 2005;\nint fac[N], invfac[N];\nvoid pre() {\n    fac[0] = 1;\n    for(int i=1; i<N; i++)  fac[i] = (1LL*i*fac[i-1])%M;\n    invfac[N-1] = power(fac[N-1], M-2);\n    for (int i=N-2; i>=0; i--)  invfac[i] = (1LL*invfac[i+1]*(i+1))%M;\n}\n\nint C(int n, int r) {\n    if (r<0 || r>n) return 0;\n    int denom = (1LL*invfac[r]*invfac[n-r])%M;\n    return (1LL*fac[n]*denom)%M;\n}\n\nint dp[K][K];\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    pre();\n\n    int n, k;\n    cin>>n>>k;\n\n    if (k == 1) {\n        cout<<1<<endl;\n        return 0;\n    }\n\n    dp[n][n] = 1;\n    for (int b=n-1; b>=0; b--) {\n        for (int a=n; a>=0; a--) {\n            if (a < n)      dp[b][a] = dp[b][a+1];\n            if (a != b) {\n                int rem = n-a + (k-1)*(n-b);\n                dp[b][a] = (dp[b][a] + 1LL*C(rem-1, k-2)*dp[b+1][a])%M;\n            }\n        }\n    }\n    cout<<(1LL*dp[0][0]*fac[n])%M<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long LL;\nconst int maxn = 2005;\nconst int maxm = 4000005;\nconst int N = 4e6;\nconst int mod = 1e9+7;\n\nint fac[maxm],inc[maxm];\nint n,K,ans,dp[maxn][maxn];\nLL fpm(LL p,LL k) {\n\tLL res=1ll;\n\twhile (k) {\n\t\tif (k&1) (res*=p)%=mod;\n\t\t(p*=p)%=mod;k>>=1;\n\t}\n\treturn res;\n}\nLL comb(int n,int m) {\n\treturn (LL)fac[n]*inc[m]%mod*(LL)inc[n-m]%mod;\n}\nint main()\n{\n\t#ifdef Amberframe\n\t\tfreopen(\"agc002f.in\",\"r\",stdin);\n\t\tfreopen(\"agc002f.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%d %d\",&n,&K);fac[0]=inc[0]=1;\n\tfor (int i=1;i<=N;i++) fac[i]=(LL)fac[i-1]*i%mod;\n\tinc[N]=fpm(fac[N],mod-2);\n\tfor (int i=N;i>=2;i--) inc[i-1]=(LL)inc[i]*i%mod;\n\t\n\tdp[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=i;j>=0;j--)\n\t\tdp[i][j]=(dp[i][j+1]+dp[i-1][j-1]*comb(i*K-j-1,K-2))%mod;\n\tprintf(\"%d\",dp[n][0]*(LL)fac[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nconst long long int MOD=1000000007;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nint main(){\n  int N,M;\n  cin>>N>>M;\n  if(M==1){\n    cout<<1<<endl;\n    return 0;\n  }\n  vector<long long int>by(N*M+1,1);\n  vector<long long int>rev_by(N*M+1,1);\n  for(int i=1;i<=N*M;i++){\n    by[i]=by[i-1]*i;\n    by[i]%=MOD;\n    rev_by[i]=power(by[i],MOD-2,MOD);\n  }\n  vector<vector<long long int>>dp(N+1,vector<long long int>(N+1));\n  dp[0][0]=1;\n  for(int i=0;i<=N;i++){\n    for(int j=i;j<=N;j++){\n      if(i)dp[i][j]=dp[i-1][j];\n      if(j){\n        long long int add=dp[i][j-1];\n        add*=by[i+j*(M-1)-1];\n        add%=MOD;\n        add*=rev_by[M-2];\n        add%=MOD;\n        add*=rev_by[i+j*(M-1)-1-(M-2)];\n        add%=MOD;\n        dp[i][j]+=add;\n        dp[i][j]%=MOD;\n      }\n    }\n  }\n  cout<<(dp.back().back()*by[N])%MOD<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n#define ll long long\n\nusing namespace std;\n\nconst int N=4000100,mod=1e9+7;\nint n,k,fac[N],inv[N],f[2100][2100],ans;\n\nint ksm(int x,int y){\n\tint s=1;\n\tfor (;y;y>>=1,x=(ll)x*x%mod) if (y&1) s=(ll)s*x%mod;\n\treturn s;\n}\n\nvoid init(int n){\n\tfac[0]=1;\n\trep (i,1,n) fac[i]=(ll)fac[i-1]*i%mod;\n\tinv[n]=ksm(fac[n],mod-2);\n\tfor (int i=n-1;~i;i--) inv[i]=(ll)inv[i+1]*(i+1)%mod;\n}\n\nint C(int n,int m){return (ll)fac[n]*inv[m]%mod*inv[n-m]%mod;}\n\nvoid upd(int &x,int y){x+=y; x-=x>=mod?mod:0;}\n\nint main(){\n\tscanf(\"%d%d\",&n,&k); init(n*k+1);\n\tif (k==1) return puts(\"1\"),0;\n\tf[0][0]=1;\n\trep (i,0,n) rep (j,0,i){\n\t\tif (i==n&&j==n){\n\t\t\tprintf(\"%lld\\n\",(ll)f[n][n]*fac[n]%mod);\n\t\t\tbreak;\n\t\t}\n\t\tif (i<n) upd(f[i+1][j],f[i][j]);\n\t\tif (j<n) upd(f[i][j+1],(ll)f[i][j]*C(n*k-i-j*(k-1)-1,k-2)%mod);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); i++)\n#define per(i,a,b) for (int i=(a); i>=(b); i--)\nusing namespace std;\n\nconst int maxn = 2005;\nconst int mod = 1000000007;\nint fac[maxn*maxn], rev[maxn*maxn], f[maxn<<1][maxn];\nint n, K, ans;\n\ninline int power(int x, int p) {\n\tint res = 1;\n\twhile (p) {\n\t\tif (p & 1) res = 1ll * res * x % mod;\n\t\tx = 1ll * x * x % mod; p >>= 1;\n\t}\n\treturn res;\n}\n\ninline int C(int n, int m) {\n\treturn 1ll * fac[n] * rev[m] % mod * rev[n-m] % mod;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &K);\n\tif (K == 1) return puts(\"0\"), 0;\n\tfac[0] = rev[0] = 1;\n\trep (i, 1, maxn*maxn-1) {\n\t\tfac[i] = 1ll * fac[i-1] * i % mod;\n\t\trev[i] = power(fac[i], mod - 2);\n\t}\n\tf[0][0] = 1;\n\trep (i, 1, n*2) rep (j, 0, n)\n\t\tif (f[i-1][j]) {\n\t\t\tif (j*2 > i-1) \n\t\t\t\tf[i][j] = (f[i][j] + f[i-1][j]) % mod;\n\t\t\tf[i][j+1] = (f[i][j+1] + 1ll * f[i-1][j] * C(K * (i-1-j) + (K-1) * (2*j-i+1) + K-2, K-2)) % mod;\n\t\t}\n\tans = 1ll * f[n*2][n] * fac[n] % mod;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll n,k;\nconst int MAXN = 2000*2000;\nlong long kai[MAXN+1];\nlong long inv[MAXN+1];\nlong long mod = 1e9+7;\nlong long mp(long long a, long long b) {\n    long long res = 1;\n    for (; b; b >>= 1) {\n        if (b & 1) res = (res * a) % mod;\n        a = (a * a) % mod;\n    }\n    return res;\n}\nvoid init() {\n    kai[0] = 1;\n    for (long long i = 1; i <= MAXN; i++) kai[i] = kai[i - 1] * i % mod;\n    inv[MAXN] = mp(kai[MAXN], mod-2);\n    for (long long i = MAXN; i >= 1; i--) inv[i - 1] = inv[i] * i % mod;\n}\nlong long calc(long long n, long long k) {\n    if (n < k) return 0;\n    return (kai[n] * inv[k]) % mod * inv[n - k] % mod;\n}\n\nll dp[2010][2010];\nbool ok[2010][2010];\n\nll dfs(int a, int b) {\n    if (ok[a][b]) return dp[a][b];\n    ll ret = 0;\n    if (a - 1 >= 0) ret += dfs(a-1,b);\n    if (b - 1 >= a) ret += dfs(a, b-1) * calc(a + b * (k - 1) - 1, k - 2) % mod;\n    ok[a][b] = 1;\n    return dp[a][b] = ret % mod;\n}\n\nint main() {\n    cin >> n >> k;\n    init();\n    if (k == 1) {\n        cout << 1 << endl;\n        return 0;\n    }\n    dp[0][0] = 1;\n    ok[0][0] = 1;\n    ll ret = dfs(n,n);\n    for (ll i = 1; i <= n; i++) ret = ret * i % mod;\n    cout << ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2010,p=1e9+7;\nint mpow(int a,int n){\n    int ret=1;\n    while(n){\n        if(n&1)ret=1ll*ret*a%p;\n        a=1ll*a*a%p;\n        n/=2;\n\t}\n\treturn ret;\n}\nint fac[N*N],inv[N*N];\nint C(int n,int m){\n    return 1ll*fac[n]*inv[m]%p*inv[n-m]%p;\n}\nint n,m;\nint f[2010][2010];\nint main(){\n    fac[0]=1;\n    for(int i=1;i<N*N;++i)fac[i]=1ll*fac[i-1]*i%p;\n    inv[N*N-1]=mpow(fac[N*N-1],p-2);\n    for(int i=N*N-2;i;--i)inv[i]=1ll*inv[i+1]*(i+1)%p;\n    inv[0]=1;\n    cin>>n>>m;\n    if(m==1){\n        cout<<1<<endl;\n        return 0;\n\t}\n    f[0][0]=1;\n    for(int i=1;i<=n;++i){\n    \tfor(int j=n;j>=0;--j){\n    \t    if(j<=i&&j){\n    \t        f[i][j]=(f[i][j]+1ll*f[i-1][j-1]*C(m*i-j-1,m-2)%p)%p;\n\t\t\t}\n\t\t\tf[i][j]+=f[i][j+1];\n\t\t\tf[i][j]%=p;\n\t\t}\n\t}\n\tf[n][0]=1ll*f[n][0]*fac[n]%p;\n\tcout<<f[n][0];\n}"
  },
  {
    "language": "C++",
    "code": "    #include <iostream>\n    #include <string>\n    #include <set>  \n    #include <algorithm>\n    #include <vector>\n    #include <cmath>\n    #include <queue>\n    #include <deque>\n    #include <cstring>\n    #include <cstdio>\n    #include <map>\n    #include <numeric>\n    #include <cassert>\n    #include <iomanip>\n    #include <sstream>\nusing namespace std;\ntypedef long long LL;\nconst int MAXN=2002;\nconst int MAXM=MAXN*MAXN;\nconst LL M=1e9+7;\nLL fac[MAXM],inv[MAXM],f[MAXN][MAXN];\nint N,K;\nLL C(int x,int y)\n{\n\tif(x<y)return 0;\n\treturn fac[x]*inv[y]%M*inv[x-y]%M;\n}\nint main()\n{\n\tscanf(\"%d %d\",&N,&K);\n\tfac[0]=inv[0]=inv[1]=1;\n\tfor(int i=1;i<=MAXM;i++)\n\t\tfac[i]=1LL*fac[i-1]*i%M;\n\tfor(int i=2;i<=MAXM;i++)\n\t\tinv[i]=1LL*(M-M/i)*inv[M%i]%M;\n\tfor(int i=1;i<=MAXM;i++)\n\t\tinv[i]=inv[i-1]*inv[i]%M;\n\tf[0][0]=1;\n\tfor(int i=1;i<=N;i++)\n\t\tfor(int j=i;~j;j--)\n\t\t{\n\t\t\tf[i][j]=f[i][j+1];\n\t\t\tif(j)f[i][j]+=f[i-1][j-1]*C(i*K-j-1,K-2)%M;\n\t\t}\n\tprintf(\"%lld\\n\",f[N][0]*fac[N]%M);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=2e3+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint n,k;\nint mc[N*N],inv[N*N];\nvoid input()\n{\n\tn=read<int>(),k=read<int>();\n}\nconst int mo=1e9+7;\nll power(ll x,int y)\n{\n\tll res=1;\n\tfor(;y;x=x*x%mo,y>>=1)if(y&1)res=res*x%mo;\n\treturn res;\n}\nint Max;\nvoid init()\n{\n\tMax=n*k;\n\tmc[0]=inv[0]=1;\n\tFor(i,1,Max)mc[i]=1ll*mc[i-1]*i%mo;\n\tinv[Max]=power(mc[Max],mo-2);\n\tFordown(i,Max-1,1)inv[i]=1ll*inv[i+1]*(i+1)%mo;\n}\nll C(int x,int y){return 1ll*mc[x]*inv[y]%mo*inv[x-y]%mo;}\nint dp[N][N];\nvoid add(int &x,int y)\n{\n\tx+=y;x-=(x>=mo?mo:0);\n}\nvoid work()\n{\n\tif(k==1){puts(\"1\");return;}\n\tdp[0][0]=1;\n\tFor(i,0,n)For(j,0,i)\n\t{\n\t\tadd(dp[i+1][j],dp[i][j]);\n\t\tadd(dp[i][j+1],1ll*dp[i][j]*(n-j)%mo*C(n*k-j*(k-1)-i-1,k-2)%mo);\n\t}\n\twrite(dp[n][n],'\\n');\n}\nint main()\n{\n\t//file();\n\tinput();\n\tinit();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define IL inline\n#define RG register\n#define LL long long\n#define Upd(a) (a)>=mod?(a-=mod):1\nusing namespace std;\ntemplate <class T>\nIL char gc () {\n\tstatic char buf[1<<6], *p1=buf, *p2=buf;\n\treturn (p1==p2) && (p2=(p1=buf)+fread(buf,1,1<<6,stdin), p1==p2) ?EOF:*p1++;\n}\ntemplate <typename T>\nIL void read (T&data) {\n\tdata=0;\n\tRG char ch=0;\n\twhile (ch<'0' || ch>'9') ch=getchar();\n\twhile (ch<='9' && ch>='0') data=(data<<1)+(data<<3)+(ch&15), ch=getchar();\n}\nconst int mod = 1e9+7;\nconst int _ =2001;\nint n, k;\nint dp[2][_], jc[_*_], jcn[_*_];\nIL int poww (RG int a, RG int b) {\n\tRG int ret=1, Base=a;\n\tfor (;b;b>>=1, Base=1LL*Base*Base%mod) if (b&1) ret=1LL*ret*Base%mod;\n\treturn ret;\n}\nIL int C (RG int a, RG int b) {\n\t//if (a>2000*2000) cout<< a<<endl, exit (0);\n\treturn 1LL*jc[a]*jcn[b]%mod*jcn[a-b]%mod;\n}\nint main () {\n\tread(n), read(k);\n\tif (k==1) {puts(\"1\"); return 0;}\n\tjc[0]=jcn[0]=1;\n\tRG int i, j, pre=1, cur=0;\n\tfor (i=1; i<=n*n; ++i) jc[i]=1LL*jc[i-1]*i%mod, jcn[i]=poww(jc[i], mod-2);\n\tdp[0][0]=1;\n\tfor (i=1; i<=n*2; ++i) {\n\t\tswap(cur, pre);\n\t\tfor (j=0; j<min(i,n+1); ++j) dp[cur][j]=0;\n\t\tfor (j=1; j<=min(i,n); ++j) {\n\t\t\tif ((i-j)%2) continue;\n\t\t\tif (n*2-i+1<j) break;\n\t\t\tRG int a=(i+j-2)>>1, b=(i-j)>>1;\n\t\t\tdp[cur][j]=1LL*dp[pre][j-1]*C(a*(k-1)+b+k-1-1,k-1-1)%mod;\n\t\t\tdp[cur][j]+=dp[pre][j+1];\n\t\t\tUpd(dp[cur][j]);\n\t\t}\n\t\tif (cur%2==0) dp[cur][0]=dp[pre][1];\n\t\t//for (j=0; j<=min(i, n); ++j) printf(\"%d \",dp[cur][j]);puts(\"\");\n\t}\n\tprintf(\"%lld\",1LL*dp[cur][0]*jc[n]%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define MOD 1000000007\nusing namespace std;\nint N,K;\nLL fac[5000010],inv[5000010],ifac[5000010],d[2010][2010];\nint main()\n{\n\tcin>>N>>K;\n\tfac[0]=inv[0]=ifac[0]=fac[1]=inv[1]=ifac[1]=1;\n\tfor(int i=2;i<=5000000;i++)\n\t{\n\t\tfac[i]=(fac[i-1]*i)%MOD;\n\t\tinv[i]=inv[MOD%i]*(MOD-MOD/i)%MOD;\n\t\tifac[i]=(ifac[i-1]*inv[i])%MOD;\n\t}\n\td[0][1]=1;\n\tfor(int i=2;i<=N;i++)\n\t{\n\t\td[0][i]=d[0][i-1]*(fac[i*(K-1)-1]*ifac[K-2]%MOD*ifac[(i-1)*(K-1)]%MOD)%MOD;\n\t}\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tfor(int j=i;j<=N;j++)\n\t\t{\n\t\t\td[i][j]=(d[i-1][j]+d[i][j-1]*(fac[i+j*(K-1)-1]*ifac[K-2]%MOD*ifac[i+(j-1)*(K-1)]%MOD))%MOD;\n// \t\t\tcout<<i<<' '<<j<<' '<<d[i][j]<<endl;\n\t\t}\n\t}\n\tcout<<(d[N][N]*fac[N])%MOD<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 2002\n#define MOD 1000000007\n\nlong long int dp[MAX][MAX];\n\nclass Combination{\n\tlong long int ppow(long long int i, long long int j){\n\t\tlong long int res = 1LL;\n\t\twhile (j){\n\t\t\tif ((j & 1LL)){\n\t\t\t\tres *= i;\n\t\t\t\tif (res >= MOD){\n\t\t\t\t\tres %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj >>= 1;\n\t\t\ti *= i;\n\t\t\tif (i >= MOD){\n\t\t\t\ti %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\npublic:\n\tvector<long long int> k;\n\tvector<long long int> r;\n\tvoid resize(int N){\n\t\tk.resize(N + 2);\n\t\tr.resize(N + 2);\n\t\tk[0] = 1;\n\t\tfor (int i = 1; i < N+2; i++){\n\t\t\tk[i] = k[i - 1];\n\t\t\tk[i] *= i;\n\t\t\tif (k[i] >= MOD)k[i] %= MOD;\n\t\t}\n\t\tlong long int al = k[k.size() - 1];\n\t\tlong long int iv = ppow(k[k.size() - 1],MOD-2);\n\t\tr[k.size() - 1] = iv;\n\t\tfor (int i = (int)(r.size()) - 2; i >= 0; i--){\n\t\t\tr[i] = r[i + 1] * (i + 1);\n\t\t\tif (r[i] >= MOD){\n\t\t\t\tr[i] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int C(int a, int b){\n\t\tif (a < b)return 0;\n\t\twhile (k.size() <= a){\n\t\t\tk.push_back((k.back()*(long long int)(k.size())) % MOD);\n\t\t}\n\t\tlong long int up = k[a];\n\t\tlong long int dw = r[b] * r[a - b];\n\t\tdw %= MOD;\n\t\tup *= dw;\n\t\tup %= MOD;\n\t\treturn up;\n\t}\n\tlong long int H(int a, int b){\n\t\treturn C(a + b - 1, b);\n\t}\n\tlong long int catalan_number(int n){\n\t\treturn (C(2 * n, n) + MOD - C(2 * n, n - 1)) % MOD;\n\t}\n};\n\n\nCombination C;\nint main(){\n\tint n;\n\tint k;\n\tcin >> n >> k;\n\tC.resize(2002*2002);\n\tdp[0][0] = 1;\n\tif (k == 1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i <= n; i++){\n\t\tfor (int j = 0; j <= n; j++){\n\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\tif (dp[i + 1][j] >= MOD){\n\t\t\t\tdp[i + 1][j] %= MOD;\n\t\t\t}\n\t\t\tif (j + 1 <= i){\n\t\t\t\tdp[i][j + 1] += dp[i][j] * C.C(n*k-((k-2)*j+j+i+1), k-2);\n\t\t\t\tif (dp[i][j + 1] >= MOD){\n\t\t\t\t\tdp[i][j + 1] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long int ans = dp[n][n]*C.k[n];\n\tif (ans >= MOD)ans %= MOD;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 2000\n#define MOD 1000000007\n#define rint register int\n#define gc() getchar()\ninline int read(int r=0,int s=0,int c=gc()){for(;c<48||c>57;s=c,c=gc());for(;c>=48&&c<=57;(r*=10)+=c-48,c=gc());return s^'-'?r:-r;}\ninline int fxp(int s, int n=MOD-2){int a=1; for(; n; n&1 ? a = 1ll*a*s%MOD : 0, s = 1ll*s*s%MOD, n >>= 1); return a;}\nint fac[4002005], efac[4002005], f[MAXN+5][MAXN+5], n, m, N; inline int C(int n, int k){return n<0||k<0||n<k?0:1ll*fac[n]*efac[k]%MOD*efac[n-k]%MOD;}\nint main()\n{\n\tn = read(), m = read(), N = n*m; if(m==1||n==1) return puts(\"1\"),0; for(rint i = fac[0] = 1; i <= N; fac[i] = 1ll*i*fac[i-1]%MOD, i++);\n\tefac[N] = fxp(fac[N]); for(rint i = N; i; efac[i-1] = 1ll*i*efac[i]%MOD, i--); f[0][0] = 1;\n\tfor(rint i = 0, j; i <= n; i++) for(j = i; j <= n; j++)\n\t\tf[i+1][j] = (f[i+1][j]+f[i][j])%MOD, f[i][j+1] = (f[i][j+1]+1ll*C(i+j*(m-1)+m-2,m-2)*f[i][j])%MOD;\n\tprintf(\"%d\\n\",1ll*fac[n]*f[n][n]%MOD); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ninline int read(){\n\tint ans=0,w=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar();\n\treturn ans*w;\n}\nconst int N=2005,Maxn=4100005,mod=1e9+7;\nint n,k,f[N][N],fac[Maxn],ifac[Maxn];\ninline int C(int n,int m){return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;}\nsigned main(){\n\tn=read(),k=read(),ifac[0]=fac[0]=fac[1]=ifac[1]=1;\n\tif(k==1)return puts(\"1\"),0;\n\tfor(int i=2;i<=n*(n+1);++i)fac[i]=1ll*fac[i-1]*i%mod,ifac[i]=1ll*(mod-mod/i)*ifac[mod%i]%mod;\n\tfor(int i=2;i<=n*(n+1);++i)ifac[i]=1ll*ifac[i]*ifac[i-1]%mod;\n\tf[1][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<=i;++j){\n\t\t\tif(i^j)(f[i][j+1]+=f[i][j]%=mod);\n\t\t\tif(i^n)(f[i+1][j]+=1ll*f[i][j]*C((k-2)+(i*(k-1)+j),k-2)%mod)%=mod;\n\t\t}\n\tcout<<1ll*f[n][n]*fac[n]%mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "const long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef complex<double> cd;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define pb push_back\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\nstring Yes[2] = {\"No\\n\", \"Yes\\n\"};\nstring YES[2] = {\"NO\\n\", \"YES\\n\"};\nstring Possible[2] = {\"Impossible\\n\", \"Possible\\n\"};\nstring POSSIBLE[2] = {\"IMPOSSIBLE\\n\", \"POSSIBLE\\n\"};\n\nint ok(int x, int n)\n{\n    return 0 <= x && x < n;\n}\n\nll log10(ll x)\n{\n    if (x < 10) re 1;\n    re 1 + log10(x / 10);\n}\n\nll ds(ll x)\n{\n    if (x < 10) return x;\n    re x % 10 + ds(x / 10);\n}\n\ndouble sqr(double x)\n{\n    return x * x;\n}\n\nbool inmask(int bit, int mask)\n{\n    return (mask & (1 << bit)) > 0;\n}\n\nvoid Del(vector<int> &v, int pos)\n{\n    swap(v[pos], v[v.size() - 1]);\n    v.pop_back();\n}\n\nlong long g(vector<long long> &p, int pos)\n{\n    if (ok(pos, p.size())) return p[pos];\n    if (pos < 0 || p.size() == 0) return 0;\n    return p.back();\n}\n\nint g(vector<int> &p, int pos)\n{\n    if (ok(pos, p.size())) return p[pos];\n    if (pos < 0 || p.size() == 0) return 0;\n    return p.back();\n}\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nint __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\ninline void __precompute_combinatorics(int __n)\n{\n    if (__precomputed_combinatorics >= __n)\n        return;\n    __fact.resize(__n);\n    __ufact.resize(__n);\n    __rev.resize(__n);\n    __rev[1] = 1;\n    for (int i = max(2, __precomputed_combinatorics); i < __n; i++)\n        __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = max(1, __precomputed_combinatorics); i < __n; i++)\n        __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n    __precomputed_combinatorics = __n;\n}\n\nll fact(int x)\n{\n    if (__precomputed_combinatorics <= x)\n        __precompute_combinatorics(x + 1);\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (k < 0 || k > n)\n        return 0;\n    if (__precomputed_combinatorics <= n)\n        __precompute_combinatorics(n + 1);\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nll inq(ll x, ll y, ll mod)\n{\n    if (y == 0) return 1 % mod;\n    ll l = inq(x, y / 2, mod);\n    if (y % 2) return l * l % mod * x % mod;\n    return l * l % mod;\n}\n\nll gcdex(ll a, ll b, ll &x, ll &y)\n{\n    // Solves the equation ax + by = gcd(a, b)\n    // returns gcd(a, b)\n    // save x and y in given values\n    //\n    // Correctness tested on random tests.\n    // Correctness tested on the following problem:\n    // https://atcoder.jp/contests/tenka1-2017/tasks/tenka1_2017_f\n    //\n    if (a == 0)\n    {\n        x = 0, y = 1;\n        return b;\n    }\n    ll x1, y1;\n    ll g = gcdex(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return g;\n}\n\npair<ll, ll> crt(vector<ll> r, vector<ll> m)\n{\n    // Finds such x, that x mod m[i] = r[i] for each i\n    // if such x does not exist returns {0, 0}\n    //\n    // Correctness tested on random tests.\n    // Correctness tested on the following problem:\n    // https://atcoder.jp/contests/tenka1-2017/tasks/tenka1_2017_f\n    //\n    int n = r.size();\n    for (int i = 0; i < n; i++) r[i] %= m[i];\n    ll r0 = 0, m0 = 1;\n    for (int i = 0; i < n; i++)\n    {\n        ll r1 = r[i], m1 = m[i];\n        if (m0 < m1)\n        {\n            swap(m0, m1);\n            swap(r0, r1);\n        }\n        if (m0 % m1 == 0)\n        {\n            if (r0 % m1 != r1) return {0, 0};\n            continue;\n        }\n        ll x, y;\n        ll g = gcdex(m0, m1, x, y);\n        ll u = m1 / g;\n        if ((r0 - r1) % g != 0)\n            return {0, 0};\n        ll z = (r1 - r0) / g % u * x % u;\n        r0 += z * m0;\n        m0 *= u;\n        if (r0 < 0) r0 += m0;\n    }\n    return {r0, m0};\n}\n\nstruct dsu\n{\n    vector<int> root;\n    vector<int> sz;\n\n    dsu(int _n)\n    {\n        root.resize(_n);\n        iota(all(root), 0);\n        sz.resize(_n, 1);\n    }\n\n    dsu()\n    {\n        dsu(0);\n    }\n\n    void Reset(int _n)\n    {\n        root.resize(_n);\n        sz.resize(_n);\n        for (int i = 0; i < (int)root.size(); i++)\n        {\n            root[i] = i;\n            sz[i] = 1;\n        }\n    }\n\n    void Reset()\n    {\n        Reset(root.size());\n    }\n\n    int Root(int x)\n    {\n        if (x == root[x]) return x;\n        return root[x] = Root(root[x]);\n    }\n\n    void Merge(int v, int u)\n    {\n        v = Root(v), u = Root(u);\n        if (v == u) return;\n        if (sz[v] < sz[u])\n        {\n            sz[u] += sz[v];\n            root[v] = u;\n        }\n        else\n        {\n            sz[v] += sz[u];\n            root[u] = v;\n        }\n    }\n};\n\nstruct dsu_cut\n{\n    vector<int> root;\n    vector<int> sz;\n    stack<int> cuts;\n\n    dsu_cut(int _n)\n    {\n        root.resize(_n);\n        iota(all(root), 0);\n        sz.resize(_n, 1);\n    }\n\n    dsu_cut()\n    {\n        dsu_cut(0);\n    }\n\n    void Cut()\n    {\n        if (!cuts.size()) return;\n        int v = cuts.top();\n        sz[root[v]] -= sz[v];\n        root[v] = v;\n        cuts.pop();\n    }\n\n    void Reset(int _n)\n    {\n        root.resize(_n);\n        sz.resize(_n);\n        for (int i = 0; i < (int)root.size(); i++)\n        {\n            root[i] = i;\n            sz[i] = 1;\n        }\n    }\n\n    void Reset()\n    {\n        if (cuts.size() < root.size())\n        {\n            while (cuts.size())\n            {\n                Cut();\n            }\n        }\n        else\n        {\n            Reset(root.size());\n        }\n    }\n\n    int Root(int x)\n    {\n        if (x == root[x]) return x;\n        return Root(root[x]);\n    }\n\n    void Merge(int v, int u)\n    {\n        v = Root(v), u = Root(u);\n        if (v == u) return;\n        if (sz[v] < sz[u])\n        {\n            sz[u] += sz[v];\n            root[v] = u;\n            cuts.push(v);\n        }\n        else\n        {\n            sz[v] += sz[u];\n            root[u] = v;\n            cuts.push(u);\n        }\n    }\n};\n\nvoid bfs(int v, vi &dist, vector<vi> &graph)\n{\n    fill(all(dist), -1);\n    dist[v] = 0;\n    vi q = {v};\n    for (int i = 0; i < (int)q.size(); i++)\n    {\n        for (auto u : graph[q[i]])\n        {\n            if (dist[u] == -1)\n            {\n                dist[u] = dist[q[i]] + 1;\n                q.push_back(u);\n            }\n        }\n    }\n}\n\nvector<int> z_func(string &s)\n{\n    // Calculates z-function of string s\n    // z[0] = s.size(), s should not be empty\n    //\n    // Tested on the following problem:\n    // https://codeforces.com/edu/course/2/lesson/3/3/practice/contest/272263/problem/A\n    //\n    vector<int> z(s.size());\n    z[0] = s.size();\n    int L = 0, R = 0;\n    for (int i = 1; i < (int)s.size(); i++)\n    {\n        z[i] = max(0, min(z[i - L], R - i));\n        while (i + z[i] < (int)s.size() && s[i + z[i]] == s[z[i]]) z[i]++;\n        if (i + z[i] > R)\n        {\n            R = i + z[i];\n            L = i;\n        }\n    }\n    return z;\n}\n\nvector<int> p_func(string &s)\n{\n    // Calculates prefix function of string s\n    //\n    //\n    vector<int> p(s.size());\n    for (int i = 1; i < (int)s.size(); i++)\n    {\n        int j = p[i - 1];\n        while (j > 0 && s[i] != s[j])\n            j = p[j - 1];\n        if (s[i] == s[j])\n            j++;\n        p[i] = j;\n    }\n    return p;\n}\n\nvector<int> d1_func(string &s)\n{\n    // Calculates max length of palindrome centered in positions and i for each i\n    //\n    //\n    vector<int> d1(s.size());\n    int L = 0, R = -1;\n    for (int i = 0; i < (int)s.size(); i++)\n    {\n        int k = 0;\n        if (i <= R) k = min(R - i + 1, d1[R - i + L]);\n        while (i + k < (int)s.size() && i - k >= 0 && s[i - k] == s[i + k])\n            k++;\n        d1[i] = k--;\n        if (i + k > R)\n        {\n            L = i - k;\n            R = i + k;\n        }\n    }\n    return d1;\n}\n\nvector<int> d2_func(string &s)\n{\n    // Calculates max length of palindrome centered in positions i - 1 and i for each i\n    //\n    //\n    vector<int> d2(s.size());\n    int L = 0, R = -1;\n    for (int i = 1; i < (int)s.size(); i++)\n    {\n        int k = 0;\n        if (i <= R) k = min(R - i + 1, d2[R - i + L + 1]);\n        while (i + k < (int)s.size() && i - k - 1 >= 0 && s[i - k - 1] == s[i + k])\n            k++;\n        d2[i] = k--;\n        if (i + k > R)\n        {\n            L = i - k - 1;\n            R = i + k;\n        }\n    }\n    return d2;\n}\n\ntemplate<class T> void add(int pos, T x, vector<T> &fenw)\n{\n    // Performs add query on Fenwick tree\n    //\n    // Tested on the following problem:\n    // https://atcoder.jp/contests/practice2/tasks/practice2_b\n    //\n    while (pos < (int)fenw.size())\n    {\n        fenw[pos] += x;\n        pos |= (pos + 1);\n    }\n}\n\ntemplate<class T> T get(int pos, vector<T> &fenw)\n{\n    // Performs get query on Fenwick tree\n    //\n    // Tested on the following problem:\n    // https://atcoder.jp/contests/practice2/tasks/practice2_b\n    //\n    ll res = 0;\n    while (pos >= 0)\n    {\n        res += fenw[pos];\n        pos = (pos & (pos + 1)) - 1;\n    }\n    return res;\n}\n\ntemplate<class T> vector<int> different_on_segment_offline(vector<T> a, vector<int> l, vector<int> r)\n{\n    // For each segment [l[i], r[i]] of calculates number of different elements in array A\n    //\n    // Correctness tested on random tests with n <= 25000, q <= 25000, different maxA, T = int\n    // Speed tested on random tests with n = 250000, q = 250000, maxA = maxRand, T = int, average = 0.108ms/test (local)\n    //\n    map<T, int> lst;\n    vector<int> ans(l.size());\n    vector<vector<int> > ends(a.size());\n    vector<int> fenw(a.size());\n    for (int i = 0; i < (int)l.size(); i++)\n    {\n        ends[r[i]].push_back(i);\n    }\n    for (int i = 0; i < (int)a.size(); i++)\n    {\n        if (lst.find(a[i]) != lst.end())\n        {\n            add(lst[a[i]], -1, fenw);\n        }\n        lst[a[i]] = i;\n        add(i, 1, fenw);\n        for (auto q : ends[i])\n        {\n            ans[q] = get(i, fenw) - get(l[q] - 1, fenw);\n        }\n    }\n    return ans;\n}\n\nstruct dcp_offine{\n    // Given n, m and arrays v, u, t of length m\n    // -1 <= t[i] <= 1 and 0 <= v[i], u[i] < n satisfied for t[i] != -1\n    // t[i] = 0 asks to change state of edge (v[i], u[i])\n    // t[i] = -1 asks to calculate number of connected components\n    // t[i] = 1 asks to check if v[i] and u[i] are in the same connected component\n    // After creating following holds:\n    // ans[i] contains -1 for t[i] = 0 and answer for the i-th query otherwise\n    //\n    // Correctness t[i] <= 0 tested on the following problem:\n    // https://codeforces.com/edu/course/2/lesson/7/3/practice/contest/289392/problem/C\n    // Correctness tested on random tests with m = 40000\n    // Speed tested on random tests with m = 2e6, average = 0.955ms/test (local)\n    //\n    int n, m;\n    dsu_cut dcp;\n    vector<int> ans;\n    void solve(int l, int r, vi &v, vi &u, vi &t, vi &L, vi &R)\n    {\n        if (l >= r) return;\n        if (l + 1 == r)\n        {\n            if (t[l] == -1)\n            {\n                ans[l] = n - dcp.cuts.size();\n            }\n            if (t[l] == 1)\n            {\n                ans[l] = dcp.Root(v[l]) == dcp.Root(u[l]);\n            }\n            return;\n        }\n        int m = (l + r) / 2;\n        int ss = dcp.cuts.size();\n        for (int i = l; i < m; i++)\n        {\n            if (R[i] >= r) dcp.Merge(v[i], u[i]);\n        }\n        solve(m, r, v, u, t, L, R);\n        while ((int)dcp.cuts.size() > ss) dcp.Cut();\n        for (int i = r - 1; i >= m; i--)\n        {\n            if (L[i] < l) dcp.Merge(v[i], u[i]);\n        }\n        solve(l, m, v, u, t, L, R);\n        while ((int)dcp.cuts.size() > ss) dcp.Cut();\n    }\n    dcp_offine(int _n, int _m, vi v, vi u, vi t)\n    {\n        n = _n, m = _m;\n        dcp.Reset(n);\n        ans.resize(m, -1);\n        map<pair<int, int>, int> mm;\n        vi L(m, INF), R(m, -INF);\n        for (int i = 0; i < m; i++)\n        {\n            if (t[i] != 0) continue;\n            if (v[i] > u[i]) swap(v[i], u[i]);\n            if (mm.find({v[i], u[i]}) == mm.end())\n            {\n                mm[{v[i], u[i]}] = i;\n            }\n            else\n            {\n                int t = mm[{v[i], u[i]}];\n                R[t] = i;\n                L[i] = t;\n                mm.erase({v[i], u[i]});\n            }\n        }\n        while (mm.size())\n        {\n            t.push_back(0);\n            ans.push_back(-1);\n            L.push_back(INF);\n            R.push_back(-INF);\n            auto it = mm.begin();\n            pair<int, int> s = (*it).first;\n            int t = (*it).second;\n            R[t] = m;\n            L[m] = t;\n            v.push_back(s.first);\n            u.push_back(s.second);\n            mm.erase(mm.begin());\n            m++;\n        }\n        solve(0, m, v, u, t, L, R);\n    }\n};\n\ntemplate<class T> struct sparse_min{\n    // Returns min on segment [l, r] of predefined array a\n    //\n    // Correctness tested on the following problem:\n    // https://codeforces.com/contest/1304/problem/E\n    // Speed tested on random tests with n = 4e6, q = 4e6, T = int, average = 0.508ms/test (local)\n    // Speed tested on random tests with n = 4e6, q = 4e7, T = int, average = 1.778ms/test (local)\n    //\n    vector<vector<T> > sp;\n    vector<int> H;\n    T get(int l, int r)\n    {\n        int h = H[r - l + 1];\n        return min(sp[h][l], sp[h][r - (1 << h) + 1]);\n    }\n    sparse_min(vector<T> a)\n    {\n        int n = a.size();\n        H = vector<int>(n + 1);\n        for (int i = 3; i < n + 1; i++)\n        {\n            H[i] = H[i - 1] + (((i - 1) & (i - 2)) == 0);\n        }\n        int s = 0;\n        while ((1 << s) < n) s++;\n        sp = vector<vector<T>>(s, vector<T>(n));\n        for (int i = 0; i < n; i++)\n        {\n            sp[0][i] = a[i];\n        }\n        for (int j = 1; j < s; j++)\n        {\n            for (int i = 0; i + (1 << j) - 1 < n; i++)\n            {\n                sp[j][i] = get(i, i + (1 << j) - 1);\n            }\n        }\n    }\n};\n\ntemplate<class T> struct sparse_max{\n    // Returns min on segment [l, r] of predefined array a\n    //\n    // Correctness tested on the following problem:\n    // https://codeforces.com/contest/1304/problem/E\n    // Speed tested on random tests with n = 4e6, q = 4e6, T = int, average = 0.508ms/test (local)\n    // Speed tested on random tests with n = 4e6, q = 4e7, T = int, average = 1.778ms/test (local)\n    //\n    vector<vector<T> > sp;\n    vector<int> H;\n    T get(int l, int r)\n    {\n        int h = H[r - l + 1];\n        return max(sp[h][l], sp[h][r - (1 << h) + 1]);\n    }\n    sparse_max(vector<T> a)\n    {\n        int n = a.size();\n        H = vector<int>(n + 1);\n        for (int i = 3; i < n + 1; i++)\n        {\n            H[i] = H[i - 1] + (((i - 1) & (i - 2)) == 0);\n        }\n        int s = 0;\n        while ((1 << s) < n) s++;\n        sp = vector<vector<T>>(s, vector<T>(n));\n        for (int i = 0; i < n; i++)\n        {\n            sp[0][i] = a[i];\n        }\n        for (int j = 1; j < s; j++)\n        {\n            for (int i = 0; i + (1 << j) - 1 < n; i++)\n            {\n                sp[j][i] = get(i, i + (1 << j) - 1);\n            }\n        }\n    }\n};\n\nstruct graph_scc{\n    // Finds Strongly Connected Components of given graph\n    //\n    // Correctness tested on the following problem:\n    // https://atcoder.jp/contests/arc069/tasks/arc069_d\n    //\n    int n;\n    vector<vector<int> > graph;\n    vector<vector<int> > inv_graph;\n    vector<int> fr, to;\n    vector<int> fn;\n    vector<int> vis;\n    vector<int> component;\n    int col;\n    void inv_dfs(int v)\n    {\n        vis[v] = 1;\n        for (auto id : inv_graph[v])\n        {\n            int u = fr[id];\n            if (!vis[u])\n            {\n                inv_dfs(u);\n            }\n        }\n        fn.push_back(v);\n    }\n    void dfs(int v)\n    {\n        component[v] = col;\n        for (auto id : graph[v])\n        {\n            int u = to[id];\n            if (component[u] == -1)\n            {\n                dfs(u);\n            }\n        }\n    }\n    graph_scc(int _n)\n    {\n        n = _n;\n        graph = vector<vector<int> >(n);\n        inv_graph = vector<vector<int> >(n);\n    }\n    void add_edge(int v, int u)\n    {\n        graph[v].push_back(fr.size());\n        inv_graph[u].push_back(fr.size());\n        fr.push_back(v);\n        to.push_back(u);\n    }\n    vector<vector<int> > scc()\n    {\n        vis = vector<int>(n);\n        component = vector<int>(n, -1);\n        fn = {};\n        col = 0;\n        for (int i = 0; i < n; i++)\n        {\n            if (!vis[i])\n            {\n                inv_dfs(i);\n            }\n        }\n        reverse(fn.begin(), fn.end());\n        for (auto i : fn)\n        {\n            if (component[i] == -1)\n            {\n                dfs(i);\n                col++;\n            }\n        }\n        vector<vector<int> > res(col);\n        for (int i = 0; i < n; i++)\n        {\n            res[component[i]].push_back(i);\n        }\n        return res;\n    }\n};\n\nstruct graph_bridges{\n    // Finds bridges of given graph\n    // Marks them in array isbridge\n    // graph_bridges.dlc() returns doubly linked components of a given graph\n    //\n    // Correctness (bridges) tested on the following problem:\n    // https://informatics.msk.ru/mod/statements/view.php?chapterid=111689#1\n    //\n    // Correctness (dlc) tested on the following problem:\n    // https://judge.yosupo.jp/problem/two_edge_connected_components\n    //\n    int n;\n    vector<vector<int> > graph;\n    vector<int> v;\n    vector<int> u;\n    vector<int> isbridge;\n    vector<int> in, out, up;\n    vector<int> color;\n    vector<int> par;\n    int T;\n    void dfs(int V, int P, int edge_in)\n    {\n        par[V] = P;\n        in[V] = up[V] = T++;\n        for (auto id : graph[V])\n        {\n            int t = v[id] + u[id] - V;\n            if (in[t] == -1)\n            {\n                dfs(t, V, id);\n                up[V] = min(up[V], up[t]);\n            }\n            else if (id != edge_in)\n            {\n                up[V] = min(up[V], in[t]);\n            }\n        }\n        out[V] = T++;\n    }\n    void dfs_dlc(int V, int P)\n    {\n        color[V] = T;\n        for (auto id : graph[V])\n        {\n            int t = v[id] + u[id] - V;\n            if (!isbridge[id] && color[t] == -1)\n            {\n                dfs_dlc(t, V);\n            }\n        }\n    }\n    graph_bridges(int _n)\n    {\n        n = _n;\n        graph = vector<vector<int> >(n);\n    }\n    void add_edge(int V, int U)\n    {\n        graph[V].push_back(v.size());\n        graph[U].push_back(v.size());\n        v.push_back(V);\n        u.push_back(U);\n    }\n    void mark_bridges()\n    {\n        in = vector<int>(n, -1);\n        out = vector<int>(n, -1);\n        up = vector<int>(n, -1);\n        par = vector<int>(n, -1);\n        isbridge = vector<int>(v.size(), 0);\n        T = 0;\n        for (int i = 0; i < n; i++)\n        {\n            if (in[i] == -1)\n            {\n                dfs(i, -1, -1);\n            }\n        }\n        int m = v.size();\n        for (int i = 0; i < m; i++)\n        {\n            if (par[u[i]] == v[i] && up[u[i]] == in[u[i]])\n            {\n                isbridge[i] = 1;\n            }\n            if (par[v[i]] == u[i] && up[v[i]] == in[v[i]])\n            {\n                isbridge[i] = 1;\n            }\n        }\n    }\n    vector<vector<int> > dlc()\n    {\n        mark_bridges();\n        color = vector<int>(n, -1);\n        T = 0;\n        for (int i = 0; i < n; i++)\n        {\n            if (color[i] == -1)\n            {\n                dfs_dlc(i, -1);\n                T++;\n            }\n        }\n        vector<vector<int> > res(T);\n        for (int i = 0; i < n; i++)\n        {\n            res[color[i]].push_back(i);\n        }\n        return res;\n    }\n};\n\nstruct graph_AP{\n    // Finds articulation points of given graph\n    // Marks them in array isAP\n    // graph_AP.blocks() returns blocks of a given graph\n    //\n    // Correctness (AP) tested on the following problem:\n    // https://informatics.msk.ru/mod/statements/view.php?chapterid=111690#1\n    //\n    // Correctness (blocks) tested on the following problem:\n    // https://atcoder.jp/contests/arc062/tasks/arc062_d\n    //\n    int n;\n    vector<vector<int> > graph;\n    vector<int> v;\n    vector<int> u;\n    vector<int> isAP;\n    vector<int> in, out, up;\n    vector<int> par;\n    vector<int> color;\n    vector<int> vis;\n    int T, rd;\n    int maxColor;\n    void dfs(int V, int P)\n    {\n        par[V] = P;\n        in[V] = up[V] = T++;\n        for (auto id : graph[V])\n        {\n            int t = v[id] + u[id] - V;\n            if (in[t] == -1)\n            {\n                if (P == -1)\n                    rd++;\n                dfs(t, V);\n                up[V] = min(up[V], up[t]);\n            }\n            else if (t != P)\n            {\n                up[V] = min(up[V], in[t]);\n            }\n        }\n        out[V] = T++;\n    }\n    void dfs_blocks(int V, int P, int c)\n    {\n        vis[V] = 1;\n        for (auto id : graph[V])\n        {\n            int t = v[id] + u[id] - V;\n            if (t == P)\n            {\n                continue;\n            }\n            if (!vis[t])\n            {\n                if (up[t] >= in[V])\n                {\n                    maxColor++;\n                    color[id] = maxColor - 1;\n                    dfs_blocks(t, V, maxColor - 1);\n                }\n                else\n                {\n                    color[id] = c;\n                    dfs_blocks(t, V, c);\n                }\n            }\n            else\n            {\n                if (in[t] < in[V])\n                {\n                    color[id] = c;\n                }\n            }\n        }\n    }\n    graph_AP(int _n)\n    {\n        n = _n;\n        graph = vector<vector<int> >(n);\n    }\n    void add_edge(int V, int U)\n    {\n        graph[V].push_back(v.size());\n        graph[U].push_back(v.size());\n        v.push_back(V);\n        u.push_back(U);\n    }\n    void mark_AP()\n    {\n        in = vector<int>(n, -1);\n        out = vector<int>(n, -1);\n        up = vector<int>(n, -1);\n        par = vector<int>(n, -1);\n        isAP = vector<int>(n, 0);\n        T = 0;\n        for (int i = 0; i < n; i++)\n        {\n            if (in[i] == -1)\n            {\n                rd = 0;\n                dfs(i, -1);\n                if (rd > 1)\n                    isAP[i] = 1;\n                else\n                    isAP[i] = -1;\n            }\n        }\n        for (int i = 0; i < n; i++)\n        {\n            if (isAP[i] == 0)\n            {\n                for (auto id : graph[i])\n                {\n                    int t = v[id] + u[id] - i;\n                    if (par[t] == i && in[i] <= up[t])\n                        isAP[i] = 1;\n                }\n            }\n            else\n            {\n                if (isAP[i] == -1)\n                {\n                    isAP[i] = 0;\n                }\n            }\n        }\n    }\n    vector<vector<int> > blocks()\n    {\n        mark_AP();\n        color = vector<int>(v.size(), -1);\n        vis = vector<int>(n, 0);\n        maxColor = 0;\n        for (int i = 0; i < n; i++)\n        {\n            if (!vis[i])\n            {\n                dfs_blocks(i, -1, maxColor);\n                maxColor++;\n            }\n        }\n        vector<vector<int> > res = vector<vector<int> >(maxColor);\n        for (int i = 0; i < (int)v.size(); i++)\n        {\n            res[color[i]].push_back(i);\n        }\n        vector<vector<int> > res2;\n        for (int i = 0; i < (int)res.size(); i++)\n        {\n            if (res[i].size())\n            {\n                res2.push_back(res[i]);\n            }\n        }\n        return res2;\n    }\n};\n\nconst int N = 2010;\n\nint dp[N][N];\n\nsigned main()\n{\n    srand(time(NULL));\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n, k;\n    cin >> n >> k;\n    if (k == 1)\n    {\n        cout << 1;\n        return 0;\n    }\n    dp[0][0] = 1;\n    for (int i = 0; i <= n; i++)\n    {\n        for (int j = 0; j <= i; j++)\n        {\n            int cnt = i * (k - 1) + j;\n            dp[i][j + 1] = (dp[i][j + 1] + dp[i][j]) % MOD;\n            dp[i + 1][j] = (dp[i + 1][j] + dp[i][j] * cnk(cnt + k - 2, k - 2)) % MOD;\n        }\n    }\n    cout << dp[n][n] * fact(n) % MOD;\n}\n\n/* Note:\nCheck constants at the beginning of the code (MOD, INF, INFLL)\nCheck corner cases.\n    N = 1\nNo def int long long for now.\nAdd something here.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\n#define MAXN 2005\n\n\nint n, k;\nLL f[MAXN][MAXN], fac[MAXN * MAXN], inf[MAXN * MAXN];\nconst int mod = 1e9 + 7, N = 4000000;\n\nLL power(LL a, int b) {\n    LL res = 1;\n    while (b) {\n        if (b & 1)\n            res = res * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return res;\n}\n\nvoid init() {\n    inf[0] = fac[0] = 1;\n    for (int i = 1; i <= N; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    inf[N] = power(fac[N], mod - 2);\n    for (int i = N - 1; i >= 1; --i)\n        inf[i] = inf[i + 1] * (i + 1) % mod;\n}\n\nLL C(int n, int m) {\n    return fac[n] * inf[n - m] % mod * inf[m] % mod;\n}\n\nint main() {\n    init();\n    scanf(\"%d%d\", &n, &k);\n    if (k == 1) {\n        puts(\"1\");\n        return 0;\n    }\n    f[0][0] = 1;\n    for (int i = 1; i <= n; ++i)\n        for (int j = 0; j <= i; ++j)\n            if (!j)\n                f[i][j] = f[i - 1][j]; //白球\n            else\n                f[i][j] = (f[i - 1][j] + f[i][j - 1] * C(n * k - (j - 1) * (k - 1) - i - 1, k - 2) % mod * (n - j + 1) % mod) % mod;\n    printf(\"%lld\\n\", f[n][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <type_traits>\nusing namespace std;\n\nusing ll=int64_t;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(x) x.begin(),x.end()\nauto& errStream=cerr;\n#ifdef LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nll read(){\n\tll i;\n\tscanf(\"%\"  SCNd64,&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nconst int mod=1000000007;\ntemplate<class T,class U>\nvoid add(T& a,U b){\n\t//a=((ll)a+b)%mod;\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\n\ntemplate<class T,class U>\nvoid sub(T& a,U b){\n\t//a=((ll)a-b%mod+mod)%mod;\n\ta-=b;\n\tif(a<0)a+=mod;\n}\n\ntemplate<class T,class U>\nvoid mult(T& a,U b){\n\ta=((ll)a*b)%mod;\n}\n\nll modPow(ll a,ll p){\n\tll s=1;\n\twhile(p){\n\t\tif(p&1)mult(s,a);\n\t\tmult(a,a);\n\t\tp>>=1;\n\t}\n\treturn s;\n}\n\nll modInv(ll a){\n\treturn modPow(a,mod-2);\n}\n\nconst int Vmax=4010010;\nint fact[Vmax],factInv[Vmax],invs[Vmax];\nvoid InitFact(){\n\tfact[0]=1;\n\tFOR(i,1,Vmax){\n\t\tfact[i]=fact[i-1];\n\t\tmult(fact[i],i);\n\t}\n\tfactInv[Vmax-1]=modInv(fact[Vmax-1]);\n\tfor(int i=Vmax-2;i>=0;i--){\n\t\tfactInv[i]=factInv[i+1];\n\t\tmult(factInv[i],i+1);\n\t}\n\tfor(int i=Vmax-1;i>=1;i--){\n\t\tinvs[i]=factInv[i];\n\t\tmult(invs[i],fact[i-1]);\n\t}\n}\nint Choose(int n,int k){\n\treturn ll(fact[n])*factInv[n-k]%mod*factInv[k]%mod;\n}\nint Binom(int a,int b){\n\treturn ll(fact[a+b])*factInv[a]%mod*factInv[b]%mod;\n}\n\nconst int Nmax=2010;\nint dp[Nmax][Nmax];\n\nsigned main(){\n\tInitFact();\n\tint n=read(),k=read();\n\tif(k==1){\n\t\tprint(1);\n\t\treturn 0;\n\t}\n\tdp[0][0]=1;\n\tREP(i,n+1)REP(j,i+1){\n\t\tadd(dp[i][j+1],dp[i][j]);\n\t\tint w=dp[i][j];\n\t\tmult(w,Binom(i*(k-1)+j,k-2));\n\t\tadd(dp[i+1][j],w);\n\t}\n\tint ans=dp[n][n];\n\tmult(ans,fact[n]);\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef Lin1043\n    #define DEBUG(msg, ...) printf(\"(%s #%d) \" msg, __FUNCTION__, __LINE__, __VA_ARGS__)\n    #define massert(...) assert(...)\n#else\n    #define DEBUG(...)\n    #define massert(...)\n#endif\n\n#define rep(i , l , r) for(int i = (l) , ___ = (r) ; i <= ___ ; ++i )\n#define per(i , r , l) for(int i = (r) , ___ = (l) ; i >= ___ ; --i )\n\nstruct iopener\n{\n    iopener()\n    {\n#ifdef Lin1043\n        freopen(\"./in\" , \"r\" , stdin);\n#endif\n    }\n} iop;\n\ntypedef long long LL;\n\ntemplate<typename T>inline bool chkmin(T &x , const T &y) { return x > y ? (x = y , 1) : 0; }\ntemplate<typename T>inline bool chkmax(T &x , const T &y) { return x < y ? (x = y , 1) : 0; }\n\ntemplate<typename T>inline T read(T &f)\n{\n    f = 0; int x = 1 ; char c = getchar();\n    while(!isdigit(c)) x = (c == '-' ? -1 : 1) , c = getchar();\n    while(isdigit(c)) (f *= 10) += c & 15 , c = getchar();\n    return f = x * f;\n}\n\nconst int N = 2000 + 5 , L = 1000000;\n\nint n , k ;\nLL fac[L+10] , inv[L+10];\n\nconst int KCZ = 1e9 + 7;\n\nLL mp(LL x , LL y = KCZ - 2)\n{\n    LL res = 1;\n    while(y)\n    {\n        if(y & 1)\n            res = res * x % KCZ;\n        x = x * x % KCZ;\n        y >>= 1;\n    }\n    return res;\n}\n\nvoid init()\n{\n    fac[0] = 1;\n    rep(i , 1 , L) fac[i] = fac[i - 1] * i % KCZ;\n    inv[L] = mp(fac[L]);\n    per(i , L - 1 , 1) inv[i] = inv[i + 1] * (i + 1) % KCZ;\n    inv[0] = 1;\n}\n\nLL C(int n , int m)\n{\n    if(n < m) return 0;\n    return fac[n] * inv[m] % KCZ * inv[n - m] % KCZ;\n}\n\nLL f[N][N];\n\nvoid add(LL &x , const LL &y)\n{\n    x += y; if(x >= KCZ) x -= KCZ;\n}\n\nint main()\n{\n    read(n) , read(k) , init();\n    if(k == 1)\n        return puts(\"1\") , 0;\n    f[0][0] = 1;\n    rep(i , 1 , n)\n    {\n        per(j , i , 0)\n        {\n            f[i][j] = f[i][j + 1]; \n            if(j >= 1)\n                add(f[i][j] , f[i - 1][j - 1] * C(i * k - j - 1 , k - 2) % KCZ);\n        }\n    }\n    printf(\"%lld\\n\" , f[n][0] * fac[n] % KCZ);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC optimize(3)\n#include <map>\n#include <set>\n#include <queue>\n#include <cmath>\n#include <vector>\n#include <cstdio>\n#include <bitset>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define maxn 2010\n#define int long long\n#define MOD 1000000007\nusing namespace std;\nvoid write(int x){if(x<0){putchar('-');x=-x;}if(x>9) write(x/10);putchar(x%10+'0');}\nint read(){int d=0,w=1;char c=getchar();for(;c<'0'||c>'9';c=getchar())if(c=='-')\nw=-1;for(;c>='0'&&c<='9';c=getchar())d=(d<<1)+(d<<3)+c-48;return d*w;}\nvoid wln(int x){write(x);putchar('\\n');}\nvoid wrs(int x){write(x);putchar(' ');}\nint n,k,f[maxn][maxn],jc[maxn*maxn],ni[maxn*maxn],jcn[maxn*maxn];\nint calc(int x,int y)\n{\n\treturn x>=y?jc[x]*jcn[y]%MOD*jcn[x-y]%MOD:0;\n}\nsigned main()\n{\n\t// freopen(\".in\",\"r\",stdin);\n\t// freopen(\".out\",\"w\",stdout);\n\tn=read();\n\tk=read();\n\tif(k==1)\n\t{\n\t\twrite(1);\n\t\treturn 0;\n\t}\n\tjc[0]=1;\n\tfor(int i=1;i<=k*n;i++)\n\t\tjc[i]=jc[i-1]*i%MOD;\n\tni[0]=0;\n\tni[1]=1;\n\tfor(int i=2;i<=n*k;i++)\n\t\tni[i]=(-MOD/i*ni[MOD%i]%MOD+MOD)%MOD;\n\tjcn[0]=1;\n\tfor(int i=1;i<=n*k;i++)\n\t\tjcn[i]=jcn[i-1]*ni[i]%MOD;\n\tf[0][1]=1;\n\tfor(int i=2;i<=n;i++)\n\t\tf[0][i]=f[0][i-1]*calc(i*(k-1)-1,k-2)%MOD;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i;j<=n;j++)\n\t\t\tf[i][j]=(f[i-1][j]+f[i][j-1]*calc(i+j*(k-1)-1,k-2)%MOD)%MOD;\n\twrite(f[n][n]*jc[n]%MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) v += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n\n\n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\nconst int MAX = 5000000;\nconst int MOD = 1000000007;\nusing mint = Fp<MOD>;\n\nmint solve(int N, int K) {\n    BiCoef<mint> bc(MAX);\n\n    if (K == 1) return 1;\n    vector<vector<mint> > dp(N+2, vector<mint>(N+1, 0)), sdp(N+1, vector<mint>(N+2, 0));\n    dp[1][1] = 1;\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 0; j < N+1; ++j) sdp[i][j+1] = sdp[i][j] + dp[i][j];\n        for (int k = 1; k <= N; ++k) {\n            dp[i+1][k] = (sdp[i][N+1] - sdp[i][k-1]) * bc.com((i+1)*K - k - 1, K - 2);\n        }\n    }\n    mint res = 0;\n    for (int k = 1; k <= N; ++k) res += dp[N][k];\n    return res * bc.fact(N);\n}\n\nint main() {\n    int N, K; cin >> N >> K;\n    cout << solve(N, K) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define NDEBUG\nNDEBUG\n\n\n#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <memory>\n#include <random>\n\n\ntypedef int64_t int64;\n\n\nusing namespace std;\n\n/// caide keep\nbool __hack = std::ios::sync_with_stdio(false);\n/// caide keep\nauto __hack1 = cin.tie(nullptr);\n\n\nnamespace template_util {\n    \n\n    constexpr int bytecount(uint64_t x) {\n        return x ? 1 + bytecount(x >> 8) : 0;\n    }\n\n    /// caide keep\n    template<int N>\n    struct bytetype {\n        \n    };\n\n    /// caide keep\n    template<>\n    struct bytetype<4> {\n        \n    };\n\n    /// caide keep\n    template<>\n    struct bytetype<3> {\n        \n    };\n\n    /// caide keep\n    template<>\n    struct bytetype<2> {\n        \n    };\n\n    /// caide keep\n    template<>\n    struct bytetype<1> {\n        \n    };\n\n    /// caide keep\n    template<>\n    struct bytetype<0> {\n        \n    };\n\n    /// caide keep\n    template<uint64_t N>\n    struct minimal_uint : bytetype<bytecount(N)> {\n    };\n}\n\n\ntemplate<class T>\nT next(istream& in) {\n    T ret;\n    in >> ret;\n    return ret;\n}\n\n\nconst int MOD = (int)1e9 + 7;\nconst int MAXN = 2003;\nconst int MAX = 2003 * 2003;\n\nvector<int64> getFactorials(int n, int64 MOD) {\n    vector<int64> res(n);\n    res[0] = res[1] = 1;\n    for (int i = 2; i < n; ++i) {\n        res[i] = (res[i-1] * i) % MOD;\n    }\n    return res;\n}\n\nvector<int64> getRevs(int n, int64 MOD) {\n    vector<int64> res(n, 0);\n    if (n > 1) {\n        res[1] = 1;\n    }\n    for (int i = 2; i < n; ++i) {\n        res[i] = (MOD - MOD / i * res[((int) (MOD % i))] % MOD) % MOD;\n    }\n    return res;\n}\n\nvector<int64> getReverseFactorials(int n, int64 MOD) {\n    vector<int64> revs = getRevs(n, MOD);\n    vector<int64> res(n);\n    res[0] = res[1] = 1;\n    for (int i = 2; i < n; ++i) {\n        res[i] = (res[i-1] * revs[i]) % MOD;\n    }\n    return res;\n}\n\nvector<int64> factorials, r_factorials;\n\nint64 getC(int n, int k) {\n    int64 res = factorials[n];\n    res *= r_factorials[n - k];\n    if (res >= MOD) {\n        res %= MOD;\n    }\n    res *= r_factorials[k];\n    if (res >= MOD) {\n        res %= MOD;\n    }\n    return res;\n}\n\nint dp[MAXN][MAXN];\nint n, k;\n\nvoid add(int& a, int b) {\n    a += b;\n    if (a >= MOD) {\n        a -= MOD;\n    }\n}\n\nint rec(int x, int y) {\n    if (x == 0 && y == 0) {\n        return 1;\n    }\n    if (y < x) {\n        return 0;\n    }\n    int& ret = dp[x][y];\n    if (ret != -1) return ret;\n    ret = 0;\n\n    if (x != 0) {\n        add(ret, rec(x - 1, y));\n    }\n    if (y > x) {\n        int64 cc = getC(x + y * (k - 1) - 1, k - 2);\n        int64 r = (cc * rec(x, y - 1)) % MOD;\n        add(ret, (int)r);\n    }\n    return ret;\n}\n\nvoid solve(istream& in, ostream& out) {\n    factorials = getFactorials(MAX, MOD);\n    r_factorials = getReverseFactorials(MAX, MOD);\n    n = next<int>(in);\n    k = next<int>(in);\n    if (k == 1) {\n        out << 1 << endl;\n        return;\n    }\n    memset(dp, -1, sizeof dp);\n    out << (rec(n, n) * factorials[n]) % MOD << endl;\n}\n\n\nint main() {\n    solve(cin, cout);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize (\"Ofast\")\nusing namespace std;\n/// khodaya komak kon\n/// ya navid navid\nconst int N=2001*2001+3;\nll mod=1e9+7;\nll dp[2001][2001];\nll fac[N];\nll power(ll n, ll k){\n    if (k==0){\n        return 1;\n    }\n    else{\n        if (k%2==0){\n            ll x=power(n,k/2);\n            return x*x%mod;\n        }\n        else{\n            ll x=power(n,k/2);\n            x=x*x%mod;\n            return x*n%mod;\n        }\n    }\n}\nll fm[N];\nll ent(ll k, ll n){\n\tif (k==0 || k==n){\n        return 1;\n\t}\n\n\treturn (((fac[n]*fm[k])%mod)*fm[n-k])%mod;\n}\nll pd[N];\nint32_t main(){\n    sync;\n    fac[0] = 1;\n\n\tfor(int i=1;i<N;i++) {\n        fac[i]=(fac[i-1]*i)%mod;\n\t}\n\tfm[N - 1] = power(fac[N - 1], mod - 2);\n    for(int i = N - 2; i >= 0; i--) fm[i] = (fm[i + 1] * (i + 1)) % mod;\n\tll ans=1;\n    ll n,k;\n    cin >> n >> k;\n    if (k==1){\n        cout << 1 << endl;\n        return 0;\n    }\n //   dp[0]=1;\n   // dp[1]=1;\n    dp[0][0]=1;\n    for (int i=1;i<=n;i++){\n        for (int j=i;j>0;j--){\n            dp[i][j]=dp[i][j+1];\n            dp[i][j]+=dp[i-1][j-1]*ent(k-2,i*k-j-1)%mod*i%mod;\n            dp[i][j]%=mod;\n        //cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n        }\n        dp[i][0]=dp[i][1];\n    }\n    cout << dp[n][1] << endl;\n    /*\n    for (int i=2;i<=n;i++){\n        ll p1=1;\n        for (int j=1;j<=i;j++){\n            dp[i]+=ent(j,i)*ent((k-1)*j-1,i*k-j-1)%mod*pd[j]%mod*dp[i-j]%mod;\n           // dp[i]+=(n-i+1)*ent(k-2,i*k-2)%mod*dp[i-1]%mod;\n            //dp[i]+=(n-i+1)*ent(k-1,i*k-2)%mod*dp[i-1]%mod*fm[2]%mod;\n            cout << i << \" \" << j << \" \" << dp[i] << endl;\n            dp[i]%=mod;\n        }\n    }\n    cout << dp[n] << endl;\n    */\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nconst int MOD(1000000007);\nint n, k;\nint fac[4000000], inv_fac[4000000], dp[2001][2001];\n\n\nint Power(long long a, int b)\n{\n\tlong long ret(1ll);\n\t\n\twhile (b) {\n\t\tb & 1 && (ret *= a);\n\t\tret >= MOD && (ret %= MOD);\n\t\ta *= a;\n\t\ta >= MOD && (a %= MOD);\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\n\n\nint main()\n{\n\tlong long lt;\n\tint t;\n\t\n\tscanf(\"%d%d\", &n, &k);\n\tif (k == 1) {\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tfac[0] = 1;\n\tt = n * k;\n\tfor (int i = 1; i < t; ++i) {\n\t\tlt = (long long)i * fac[i - 1];\n\t\tfac[i] = lt < MOD ? lt : lt % MOD; \n\t}\n\tinv_fac[t - 1] = Power((long long)fac[t - 1], MOD - 2);\n\tfor (int i = t - 2; i; --i) {\n\t\tlt = (long long)(i + 1) * inv_fac[i + 1];\n\t\tinv_fac[i] = lt < MOD ? lt : lt % MOD;\n\t}\n\tinv_fac[0] = 1;\n\tdp[0][0] = 1;\n\tt = -2;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tt += k - 1;\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\t++t;\n\t\t\tlt = (long long)fac[t] * inv_fac[t - k + 2];\n\t\t\tlt >= MOD && (lt %= MOD);\n\t\t\tlt *= (long long)inv_fac[k - 2];\n\t\t\tlt >= MOD && (lt %= MOD);\n\t\t\tlt *= (long long)dp[i - 1][j];\n\t\t\tj && (lt += dp[i][j - 1]);\n\t\t\tdp[i][j] = lt < MOD ? lt : lt % MOD;\n\t\t}\n\t\tt -= i + 1;\n\t}\n\tlt = (long long)dp[n][n] * fac[n] % MOD;\n\tprintf(\"%lld\\n\", lt);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define MOD 1000000007LL\n\nusing namespace std;\n\nlong long dp[2048][2048], fact[4000010], inv[4000010];\n\nlong long put (long long n, long long p)\n{\n    long long rez = 1LL;\n\n    for (long long i = 0LL; (1LL << i) <= p; i += 1LL)\n    {\n        if ((1LL << i) & p) rez *= n, rez %= MOD;\n\n        n *= n;\n        n %= MOD;\n    }\n\n    return rez;\n}\n\nlong long comb (int n, int k)\n{\n    long long rez = fact[n] * inv[k];\n    rez %= MOD;\n\n    rez *= inv[n - k];\n    rez %= MOD;\n\n    return rez;\n}\n\nint main ()\n{\n //   freopen (\"file.in\", \"r\", stdin);\n\n    int n, k;\n    scanf (\"%d %d\", &n, &k);\n\n    if (k == 1)\n    {\n        printf (\"1\\n\");\n        return 0;\n    }\n\n    fact[0] = inv[0] = 1LL;\n    for (int i = 1; i <= n * k; ++i)\n        fact[i] = 1LL * i * fact[i - 1] % MOD;\n\n    inv[n * k] = put (fact[n * k], MOD - 2LL);\n\n    for (int i = n * k - 1; i; --i)\n        inv[i] = 1LL * (i + 1) * inv[i + 1] % MOD;\n\n    dp[0][0] = 1LL;\n\n    for (int i = 0; i <= n; ++i)\n        for (int j = i; j <= n; ++j)\n        {\n            if (i == 0 && j == 0) continue;\n\n            dp[i][j] = (i > 0 ? dp[i - 1][j] : 0LL) + dp[i][j - 1] * comb (i + j * (k - 1) - 1, k - 2);\n            dp[i][j] %= MOD;\n        }\n\n    printf (\"%lld\\n\", dp[n][n] * fact[n] % MOD);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Khodaya aghideye man ra az dast oghde am masoon dar!\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\ntemplate <typename T> using ordered_set =  tree<T, null_type, greater<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T> using ordered_multiset =  tree<T, null_type, greater_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntypedef long long ll;\ntypedef long double ld;\n#pragma optimize O3\nconst int MOD = (int)1e9 + 7;\nconst int MAXN = (int)2007;\nconst int MAXS = (int)2007 * 2007;\nconst int infint = (ll)1e9;\nconst ll inf = (ll)1e18;\nll n, k, dp[MAXN][MAXN], fact[MAXS], facrev[MAXS];\nll pwr(ll a, ll b)\n{\n\tif(b == 0)\n\t\treturn 1;\n\tif(b == 1)\n\t\treturn a;\n\tll c = pwr(a, b / 2);\n\tc = (c * c) % MOD;\n\tif(b % 2)\n\t\tc = (c * a) % MOD;\n\treturn c;\n}\nll inv(ll p)\n{\n\treturn pwr(p, MOD - 2);\n}\nll C(ll n, ll k)\n{\n\tll mul = fact[n];\n\tmul = (mul * facrev[k]) % MOD;\n\tmul = (mul * facrev[n - k]) % MOD;\n\treturn mul;\n}\nll f(ll open, ll i)\n{\n\tif(open > i || open < 0)\n\t\treturn 0;\n\tif(dp[open][i] != -1)\n\t\treturn dp[open][i];\n\tif(open + i == 0)\n\t\treturn dp[open][i] = 1;\n\tll sz = i * k - open;\n\tll ans = f(open + 1, i);\n\tll ans2 = f(open - 1, i - 1) * i % MOD * C(sz - 1, k - 2) % MOD;\n\treturn dp[open][i] = (ans + ans2) % MOD;\n}\nint main()\n{\t\n\tios::sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tcin >> n >> k;\n\tfact[0] = 1;\n\tfor (int i = 1; i < MAXS; i++)\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\tfacrev[MAXS - 1] = inv(fact[MAXS - 1]);\n\tfor (int i = MAXS - 1; i > 0; i--)\n\t\tfacrev[i - 1] = (facrev[i] * i) % MOD;\n\tfor (int i = 0; i < MAXN; i++)\n\t\tfor (int j = 0; j < MAXN; j++)\n\t\t\tdp[i][j] = -1;\n\tif(k == 1)\n\t\treturn cout << 1, 0;\n\tcout << f(0, n);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\ntypedef long long ll;\nll mod=1e9+7;\nll dp[2001][2001];\nconst int M=2000*2000;\nll f[M],g[M],inv[M];\nvoid precalc(){\n\tf[0]=1;\n\trep1(i,M) f[i]=f[i-1]*i%mod;\n\tinv[1]=1;\n\tfor(int i=2;i<=M;i++) inv[i]=mod-mod/i*inv[mod%i]%mod;\n\tg[0]=1;\n\trep1(i,M) g[i]=g[i-1]*inv[i]%mod;\n}\nll C(int x,int y){\n\treturn f[x]*g[y]%mod*g[x-y]%mod;\n}\nvoid add(ll &x,ll y){\n\tx+=y;\n\tx%=mod;\n}\nint main(){\n\tprecalc();\n\tint N,K;\n\tcin>>N>>K;\n\tif(K==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tdp[1][0]=1;\n\trep1(i,N) rep(j,i+1){\n//\t\tprintf(\"dp[%d][%d]=%lld\\n\",i,j,dp[i][j]);\n\t\tif(i!=N) add(dp[i+1][j],dp[i][j]);\n\t\tif(j!=i){\n\t\t\tint left=N*K-i-j*(K-1)-1;\n\t\t\tadd(dp[i][j+1],dp[i][j]*C(left,K-2));\n\t\t}\n\t}\n\tll ans=dp[N][N];\n\trep1(i,N) ans=ans*i%mod;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define ll long long\n//{{{ read()\ninline ll read(){\n\tregister ll x=0,f=1;\n\tregister char ch=getchar();\n\twhile(ch<'0'||ch>'9'){\n\t\tif(ch=='-')\tf=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')\tx=x*10+(ch^48),ch=getchar();\n\treturn x*f;\n}\n//}}}\nconst int N=2005;\nconst int M=4e6+5;\nconst int P=1e9+7;\nll fsp(ll x,int y=P-2){\n\tll ans=1;\n\twhile(y){\n\t\tif(y&1)\tans=ans*x%P;\n\t\tx=x*x%P,y>>=1;\n\t}\n\treturn ans;\n}\nint n,k,m,f[N];\nll fac[M],inv[M];\nll C(int n,int m){\n\tif(n<m)\treturn 0;\n\treturn fac[n]*inv[m]%P*inv[n-m]%P;\n}\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read(),k=read(),m=n*k,fac[0]=1;\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=m;i++) fac[i]=fac[i-1]*i%P;\n\tinv[m]=fsp(fac[m]);\n\tfor(int i=m;i;i--) inv[i-1]=inv[i]*i%P;\n\n\tf[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i;j;j--) f[j]=(f[j-1]+f[j+1]*C(m-i-(k-1)*(i-j-1)-1,k-2))%P;\n\t\tf[0]=f[1]*C(m-i-(k-1)*(i-1)-1,k-2)%P;\n\t}\n\tprintf(\"%lld\\n\",1ll*f[0]*fac[n]%P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int N=2005;\nconst int mod=1e9+7;\nint fact[N*N],inv[N*N];\nint d[N][N];\nint n,k;\nvoid Init()\n{\n\tfact[0]=1;\n\tfor(int i=1;i<=n*k;i++) fact[i]=1ll*fact[i-1]*i%mod;\n\tinv[1]=1;\n\tfor(int i=2;i<=n*k;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\tinv[0]=1;\n\tfor(int i=1;i<=n*k;i++) inv[i]=1ll*inv[i-1]*inv[i]%mod;\n}\nint C(int x,int y){\n    return 1ll*fact[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    if(k==1){\n        puts(\"1\");\n        return 0;\n    }\n    Init();\n    d[0][0]=1;\n    for(int i=0;i<=n;i++)\n        for(int j=0;j<=i;j++){\n            if(i>0)\n                d[i][j]+=d[i-1][j],d[i][j]%=mod;\n            if(j>0){\n                int x=n*k-i-(j-1)*(k-1)-1;\n                d[i][j]+=1ll*d[i][j-1]*C(x,k-2)%mod;\n                d[i][j]%=mod;\n            }\n        }\n    int ans=1ll*d[n][n]*fact[n]%mod;\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define mod 1000000007\n#define N 2010\ninline int Pow(int x,int zs){\n\tint ret=1;\n\tfor(;zs;zs>>=1,x=x*1ll*x%mod)\n\t\tif(zs&1)ret=ret*1ll*x%mod;\n\treturn ret;\n}\nint f[N][N],n,k,A[10000010],B[10000010];\ninline int C(int n,int m){\n\tif(m>n||m<0)return 0;\n\tif(n==m||m==0)return 1;\n\treturn A[n]*1ll*B[m]%mod*B[n-m]%mod;\n}\nint main(){\n\tn=1e7;\n\tfor(int i=A[0]=1;i<=n;i++)A[i]=A[i-1]*1ll*i%mod;\n\tB[n]=Pow(A[n],mod-2);\n\tfor(int i=n-1;~i;i--)B[i]=B[i+1]*(i+1ll)%mod;\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1)return puts(\"1\"),0;\n\tf[0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=i;j<=n;j++){\n\t\t\tif(i)f[i][j]=f[i-1][j];\n\t\t\tif(j)f[i][j]=(f[i][j]+f[i][j-1]*1ll*C(i+(j-1)*(k-1)+(k-2),k-2))%mod;\n\t\t}\n\tprintf(\"%lld\\n\",f[n][n]*1ll*A[n]%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst int MAXN = 2020;\nconst int MAX = MAXN * MAXN;\nconst int mod = 1e9 + 7;\n\ninline int add(int a, int b) { return a + b >= mod ? a + b - mod : a + b; }\n\ninline int sub(int a, int b) { return a >= b ? a - b : a - b + mod; }\n\ninline int mul(int a, int b) { return llint(a) * b % mod; }\n\nint f[MAXN][MAXN];\n\nint fact[MAX];\nint inv[MAX];\nint invfact[MAX];\n\nint choose(int n, int k) {\n  return mul(fact[n], mul(invfact[k], invfact[n - k]));\n}\n\nint main(void) {\n  inv[1] = 1;\n  FOR(i, 2, MAX) inv[i] = sub(0, mul(mod / i, inv[mod % i]));\n\n  fact[0] = invfact[0] = 1;\n  FOR(i, 1, MAX) {\n    fact[i] = mul(fact[i - 1], i);\n    invfact[i] = mul(invfact[i - 1], inv[i]);\n  }\n\n  int N, K;\n  scanf(\"%d %d\", &N, &K);\n\n  if (K == 1) {\n    printf(\"%d\\n\", 1);\n    return 0;\n  }\n\n  f[0][0] = 1;\n  REP(i, N + 1) REP(j, N + 1) {\n    if (j < i) continue;\n\n    if (j + 1 <= N) {\n      f[i][j + 1] = add(f[i][j + 1], f[i][j]);\n    }\n\n    if (i + 1 <= j) {\n      int rem_spots = N * K - i * (K - 1) - j - 1;\n      int need_spots = K - 2;\n\n      int ways = choose(rem_spots, need_spots);\n      ways = mul(ways, N - i);\n      f[i + 1][j] = add(f[i + 1][j], mul(ways, f[i][j]));\n    }\n  }\n\n  printf(\"%d\\n\", f[N][N]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef Lin1043\n    #define DEBUG(msg, ...) printf(\"(%s #%d) \" msg, __FUNCTION__, __LINE__, __VA_ARGS__)\n    #define massert(...) assert(...)\n#else\n    #define DEBUG(...)\n    #define massert(...)\n#endif\n\n#define rep(i , l , r) for(int i = (l) , ___ = (r) ; i <= ___ ; ++i )\n#define per(i , r , l) for(int i = (r) , ___ = (l) ; i >= ___ ; --i )\n\nstruct iopener\n{\n    iopener()\n    {\n#ifdef Lin1043\n        freopen(\"./in\" , \"r\" , stdin);\n#endif\n    }\n} iop;\n\ntypedef long long LL;\n\ntemplate<typename T>inline bool chkmin(T &x , const T &y) { return x > y ? (x = y , 1) : 0; }\ntemplate<typename T>inline bool chkmax(T &x , const T &y) { return x < y ? (x = y , 1) : 0; }\n\ntemplate<typename T>inline T read(T &f)\n{\n    f = 0; int x = 1 ; char c = getchar();\n    while(!isdigit(c)) x = (c == '-' ? -1 : 1) , c = getchar();\n    while(isdigit(c)) (f *= 10) += c & 15 , c = getchar();\n    return f = x * f;\n}\n\nconst int N = 2000 + 5 , L = 4000000;\n\nint n , k ;\nLL fac[L+10] , inv[L+10];\n\nconst int KCZ = 1e9 + 7;\n\nLL mp(LL x , LL y = KCZ - 2)\n{\n    LL res = 1;\n    while(y)\n    {\n        if(y & 1)\n            res = res * x % KCZ;\n        x = x * x % KCZ;\n        y >>= 1;\n    }\n    return res;\n}\n\nvoid init()\n{\n    fac[0] = 1;\n    rep(i , 1 , L) fac[i] = fac[i - 1] * i % KCZ;\n    inv[L] = mp(fac[L]);\n    per(i , L - 1 , 1) inv[i] = inv[i + 1] * (i + 1) % KCZ;\n    inv[0] = 1;\n}\n\nLL C(int n , int m)\n{\n    if(n < m) return 0;\n    return fac[n] * inv[m] % KCZ * inv[n - m] % KCZ;\n}\n\nLL f[N][N];\n\nvoid add(LL &x , const LL &y)\n{\n    x += y; if(x >= KCZ) x -= KCZ;\n}\n\nint main()\n{\n    read(n) , read(k) , init();\n    if(k == 1)\n        return puts(\"1\") , 0;\n    f[0][0] = 1;\n    rep(i , 1 , n)\n    {\n        per(j , i , 0)\n        {\n            f[i][j] = f[i][j + 1]; \n            if(j >= 1)\n                add(f[i][j] , f[i - 1][j - 1] * C(i * k - j - 1 , k - 2) % KCZ);\n        }\n    }\n    printf(\"%lld\\n\" , f[n][0] * fac[n] % KCZ);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n\ntemplate<lint mod>\nstruct Int_{\n  unsigned x;\n  unsigned mpow(Int_ a,unsigned k){\n    Int_ res=1;\n    while(k){\n      if(k&1) res=res*a;\n      a=a*a;\n      k>>=1;\n    }\n    return res.x;\n  }\n  unsigned inverse(Int_ a){\n    return mpow(a,mod-2);\n  }\n  Int_(): x(0) { }\n  Int_(long long sig) {\n    int sigt=sig%mod;\n    if(sigt<0) sigt+=mod;\n    x=sigt;\n  }\n  unsigned get() const { return (unsigned)x; }\n  \n  Int_ &operator+=(Int_ that) { if((x += that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator-=(Int_ that) { if((x += mod - that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator*=(Int_ that) { x = (unsigned long long)x * that.x % mod; return *this; }\n  Int_ &operator=(Int_ that) { x=that.x; return *this;}\n  Int_ &operator/=(Int_ that) { x=(unsigned long long) x * inverse(that.x)%mod; return *this;}\n  bool operator==(Int_ that) const { return x==that.x; }\n  bool operator!=(Int_ that) const { return x!=that.x; }\n\n  Int_ operator-() const { return Int_(0)-Int_(*this);}\n  Int_ operator+(Int_ that) const { return Int_(*this) += that; }\n  Int_ operator-(Int_ that) const { return Int_(*this) -= that; }\n  Int_ operator*(Int_ that) const { return Int_(*this) *= that; }\n  Int_ operator/(Int_ that) const { return Int_(*this) /= that; }\n\n};\n\nnamespace std{\n  template<lint mod>\n  ostream &operator <<(ostream& out,const Int_<mod>& a){\n    out<<a.get();\n    return out;\n  }\n  template<lint mod>\n  istream &operator >>(istream& in,Int_<mod>& a){\n    in>>a.x;\n    return in;\n  }\n};\n\ntypedef Int_<1000000007> Int;\n//const int INF=5e8;\nint n,k;\n\nInt dp[2005][2005];\n\nInt fact[4000005],inv[4000005];\nInt C(int a,int b){\n  return fact[a]*inv[b]*inv[a-b];\n}\n\nint main(){\n  const int M=4000000;\n  fact[0]=1;\n  REP(i,M) fact[i+1]=fact[i]*(i+1);\n  Int one=1;\n  REP(i,M) inv[i]=one/fact[i];\n  cin>>n>>k;\n  if(n==1 || k==1){\n    puts(\"1\");\n    return 0;\n  }\n  dp[0][0]=1;\n  REP(i,n+1) REP(j,n+1) if(dp[i][j].x && i>=j){\n    if(i<n){\n      dp[i+1][j]+=dp[i][j];\n    }\n    if(j<n){\n      dp[i][j+1]+=dp[i][j]*C((n-j)*(k-1)+(n-i)-1,k-2)*(n-j);\n    }\n  }\n  Int res=dp[n][n];\n  cout<<res<<endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#define debug(x) cout<<#x<<\"=\"<<x<<endl;\n#define chk() cout<<C((n-j+1)*(k-1)+(n-i)-1,k-2)<<endl;\nusing namespace std;\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())if(ch=='-')f=-1;\n\tfor(;isdigit(ch);ch=getchar())x=(x<<3)+(x<<1)+(ch^'0');\n\treturn x*f;\n}\nconst int maxn=2010;\nconst int mod=1e9+7;\nint ifac[maxn*maxn],fac[maxn*maxn],inv[maxn*maxn];\nint f[maxn][maxn];\ninline int C(int n,int m){\n\tif(m==0)return 1;\n\tif(n<m)return 0;\n\treturn 1ll*fac[n]*ifac[n-m]%mod*ifac[m]%mod;\n}\nint n,k;\ninline void init(){\n\tn=read(),k=read();\n\tif(n==0 || k==0)printf(\"0\"),exit(0);\n\tif(k==1)puts(\"1\"),exit(0);\n\tinv[0]=inv[1]=1;\n\tfor(register int i=2;i<=maxn*maxn;++i)\n\t\tinv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\tfac[0]=fac[1]=1;\n\tfor(register int i=2;i<=maxn*maxn;++i)\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\tifac[0]=ifac[1]=1;\n\tfor(register int i=1;i<=maxn*maxn;++i)\n\t\tifac[i]=1ll*ifac[i-1]*inv[i]%mod;\n\n}\ninline void solve(){\n\tf[1][0]=1;\n\tfor(register int i=0;i<=n;++i)\n\t\tfor(register int j=0;j<=i;++j){\n\t\t\tif(i)(f[i][j]+=f[i-1][j])%=mod;\n\t\t\tif(j)(f[i][j]+=1ll*C((n-j+1)*(k-1)+(n-i)-1,k-2)*f[i][j-1]%mod)%=mod;\n\t\t}\n\tcout<<1ll*f[n][n]*fac[n]%mod;\n}\nint main(){\n#ifndef ONLINE_JUDGE\n\tfreopen(\"AT2000.in\",\"r\",stdin);\n\tfreopen(\"AT2000.out\",\"w\",stdout);\n#endif\n\tinit();\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<algorithm>\n#include<iostream>\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nconst long long mod=1000000007;\nint n,k;\nlong long fac[5000003],inv[5000003],ifac[5000003],d[2003][2003];\ninline long long C(long long n,long long m){\n\tif(n<m){\n\t\treturn 0;\n\t}\n\treturn fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\nint main(){\n\tcin>>n>>k;\n\tif(k==1){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tfac[0]=inv[0]=ifac[0]=fac[1]=inv[1]=ifac[1]=1;\n\tfor(int i=2;i<=5000000;i++){\n\t\tfac[i]=(fac[i-1]*i)%mod;\n\t\tinv[i]=inv[mod%i]*(mod-mod/i)%mod;\n\t\tifac[i]=(ifac[i-1]*inv[i])%mod;\n\t}\n\td[0][1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\td[0][i]=d[0][i-1]*C(i*(k-1)-1,k-2)%mod;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i;j<=n;j++){\n\t\t\td[i][j]=(d[i-1][j]+d[i][j-1]*C(i+j*(k-1)-1,k-2)%mod)%mod;\n\t\t}\n\t}\n\tcout<<(d[n][n]*fac[n])%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\n#define MAX_N 2010\n#define MX 4000010\n#define MOD 1000000007\n\nusing std::cerr;\nusing std::endl;\n\nint N, K, f[MAX_N][MAX_N];\nint fac[MX], ifac[MX], inv[MX];\n\nint C(int x, int y){\n\treturn 1ll * fac[x] * ifac[y] % MOD* ifac[x-y] % MOD;\n}\n\nint main(){\n\tfac[0] = ifac[0] = inv[1] = 1;\n\tfor(int i = 2; i < MX; i++) \n\t\tinv[i] = 1ll * (MOD-MOD/i) * inv[MOD%i] % MOD;\n\tfor(int i = 1; i < MX; i++){\n\t\tfac[i] = 1ll * fac[i-1] * i % MOD;\n\t\tifac[i] = 1ll * ifac[i-1] * inv[i] % MOD;\n\t}\n\tscanf(\"%d%d\", &N, &K);\n\tif(K == 1){\n\t\tputs(\"1\"); return 0;\n\t}\n\tfor(int i = 0; i <= N; i++) f[i][0] = 1;\n\tfor(int i = 1; i <= N; i++)\n\t\tfor(int j = 1; j <= i; j++)\n\t\t\tf[i][j] = (f[i-1][j] + 1ll * f[i][j-1] * C((N-j+1)*(K-1)+(N-i)-1, K-2) % MOD) % MOD;\n\tf[N][N] = 1ll * f[N][N] * fac[N] % MOD;\n\tprintf(\"%d\\n\", f[N][N]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nconst int N=2005;\nconst int M=4000005;\nconst int mod=1000000007;\n\nint n,m,ans;\nint dp[N][N],fac[M],inv[M];\n\nint quickpow(int x,int y){\n\tint s=1;\n\tfor (;y;y>>=1,x=1ll*x*x%mod)\n\t\tif (y&1) s=1ll*s*x%mod;\n\treturn s;\n}\n\nvoid init(int n){\n\tint i,j;\n\tfac[0]=inv[0]=1;\n\tfor (i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[n]=quickpow(fac[n],mod-2);\n\tfor (i=n-1;i;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;\n}\n\nint C(int x,int y){\n\tif (x<y) return 0;\n\treturn 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\n\nint main(){\n\tint i,j;\n\tscanf(\"%d%d\",&n,&m);\n\tif (m==1){\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tinit(M-5);\n\tdp[0][0]=1;\n\tfor (i=0;i<=n;i++)\n\t\tfor (j=0;j<=i;j++) if (dp[i][j]){\n\t\t\t(dp[i][j+1]+=dp[i][j])%=mod;\n\t\t\t(dp[i+1][j]+=1ll*dp[i][j]*C(i*(m-1)+j+m-2,m-2)%mod)%=mod;\n\t\t}\n\tans=dp[n][n];\n\tfor (i=1;i<=n;i++) ans=1ll*ans*i%mod;\n\tprintf(\"%d\\n\",ans); \n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "/*\n把白球当成左括号，把每个颜色的球第一次出现当成右括号\n那么方案合法当且仅当括号匹配，直接dp即可 \n*/\n#include <cstdio>\n\nusing namespace std;\nconst int MOD(1000000000 + 7);\nconst int Max_N(2050);\nconst int Max_K(2050);\n\nconstexpr int Mult(int a, int b)\n{\n\treturn a * 1LL * b % MOD;\n}\n\nconstexpr int Add(int a, int b)\n{\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\n\nvoid exgcd(int a, int b, int &x, int &y)\n{\n\tif (b == 0)\n\t\tx = 1, y = 0;\n\telse\n\t\texgcd(b, a % b, y, x), y -= x * (a / b);\n}\n\ninline int inverse(int a)\n{\n\tint invx, invy;\n\texgcd(a, MOD, invx, invy);\n\treturn (invx % MOD + MOD) % MOD;\n}\n\nint N, K, Fac[Max_N * Max_K], Inv[Max_N * Max_K], F[Max_N][Max_N];\n//F[i][j]表示已经用了i个白球，有j个白球没有用的方案数 \n\ninline void upd(int &a, int b)\n{\n\ta = Add(a, b);\n}\n\ninline int C(int n, int m)\n{\n\treturn Mult(Fac[n], Mult(Inv[m], Inv[n - m]));\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &N, &K);\n\tif (K == 1)\n\t{\n\t\tprintf(\"1\");\n\t\treturn 0;\n\t}\n\tFac[0] = 1;\n\tfor (int i = 1;i <= N * K;++i)\n\t\tFac[i] = Mult(Fac[i - 1], i);\n\tInv[N * K] = inverse(Fac[N * K]);\n\tfor (int i = N * K - 1;i >= 0;--i)\n\t\tInv[i] = Mult(Inv[i + 1], i + 1);\n\tF[0][0] = 1;\n\tfor (int i = 0;i <= N;++i)\n\t\tfor (int j = 0;i + j <= N;++j)\n\t\t{\n\t\t\t//添加一个白球\n\t\t\tupd(F[i][j + 1], F[i][j]);\n\t\t\tif (j)\n\t\t\t\tupd(F[i + 1][j - 1], Mult(F[i][j], C((N - i - j) * K + j * (K - 1) - 1, K - 2)));\n\t\t}\n\tprintf(\"%d\", Mult(F[N][0], Fac[N]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i, v.size()){ cout << v[i] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\ntemplate<typename T> void readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readv_m1(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; };\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; };\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; };\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; };\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nsigned main(){\n\n    int N, K; cin >> N >> K;\n    if(K == 1){\n        cout << 1 << endl;\n        return 0;\n    }\n    mmat dp(N + 1, mvec(N + 1, 0));\n    dp[0][0] = 1;\n    Combination C(N * K);\n    REP(i, N){\n        REP(j, i + 1){\n            int n = K * i - j;\n            dp[i + 1][j + 1] = dp[i][j] * C.nCr(n + K - 2, K - 2);\n        }\n        IREP(j, i + 1) dp[i + 1][j] += dp[i + 1][j + 1];\n    }\n    //mdebug(dp);\n    mint ans = dp[N][0] * C.fact[N];\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\nusing namespace std;\n\n# define REP(i, a, b) for(int i = a; i <= b; ++ i)\n# define CLR(i, a) memset(i, a, sizeof(i))\n# define REPD(i, a, b) for(int i = a; i >= b; -- i) \n\nconst int N = 2e3 + 5, MOD = 1e9 + 7;\n\nint n, k, f[N][N], inv[N * N], fac[N * N];\n\ninline void inc(int &a, int b) { a = (a + b) % MOD; }\n\ninline int binom(int x, int y) { return (y < 0 || y < x) ? 0 : 1ll * fac[y] * inv[x] % MOD * inv[y - x] % MOD; }\nint pow_(int x, int k) {\n\tint ret = 1;\n\twhile(k) {\n\t\tif(k & 1) ret = 1ll * ret * x % MOD;\n\t\tx = 1ll * x * x % MOD;\n\t\tk >>= 1;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n ,&k);\n\tfac[0] = 1;\n\tREP(i, 1, n * k + 1) fac[i] = 1ll * fac[i - 1] * i % MOD;\n\tinv[n * k + 1] = pow_(fac[n * k + 1], MOD - 2);\n\tREPD(i, n * k, 0) inv[i] = 1ll * inv[i + 1] * (i + 1) % MOD;\n\tf[0][0] = 1;\n\tREP(i, 0, n) {\n\t\tREPD(j, i, 0) {\n\t\t\tinc(f[i + 1][j + 1], 1ll * f[i][j] * binom(k - 2, i * k - j + k - 2) % MOD);\n\t\t\tif(j) inc(f[i][j - 1], f[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", 1ll * f[n][0] * fac[n] % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,j,k) for(int i=j;i<=k;++i)\n#define Forr(i,j,k) for(int i=j;i>=k;--i)\n#define ll long long \nusing namespace std;\nconst int N = 2010, INF = 0x3f3f3f3f, Mod = 1e9 + 7;\ntemplate<class T>void read(T &x){\n\tx=0;char c=getchar();\n\twhile(!isdigit(c))c=getchar();\n\twhile( isdigit(c))x=x*10+c-48,c=getchar();\n}\ninline void file(){\n\tfreopen(\"test.in\",\"r\",stdin);\n\tfreopen(\"test.out\",\"w\",stdout);\n}\nint n, k, fac[N * N], ifac[N * N];\nll qpow(ll a, ll b){\n\tll ret=1;\n\tfor(;b;b>>=1,a=a*a%Mod)if(b&1)ret=ret*a%Mod;\n\treturn ret;\n}\nvoid init(){\n\tread(n), read(k);\n\tfac[0] = 1;\n\tFor(i, 1, n * k)fac[i] = 1ll * fac[i - 1] * i % Mod;\n\tifac[n * k] = qpow(fac[n * k], Mod - 2);\n\tForr(i, n * k, 1)ifac[i - 1] = 1ll * ifac[i] * i % Mod;\n}\ninline ll C(int a, int b){\n\tif(a < 0 || b < 0 || a < b)return 0;\n\treturn fac[a] * 1ll * ifac[b] % Mod * ifac[a - b] % Mod;\n}\nint dp[N][N];\nvoid solve(){\n\tdp[0][0] = 1;\n\tFor(i, 0, n)\n\t\tFor(j, i, n){\n\t\t\tif(i) dp[i][j] = dp[i - 1][j];\n\t\t\tif(j) dp[i][j] = (dp[i][j] + dp[i][j - 1] * C(i + j * (k - 1) - 1, k - 2)) % Mod;\n\t\t}\n\tif(k != 1)\n\t\tprintf(\"%lld\\n\", 1ll * dp[n][n] * fac[n] % Mod);\n\telse puts(\"1\");\n}\nint main(){\n\t//file();\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\ntypedef long long LL;\nconst int Mod = 1000000007;\nconst int MN = 2005, MS = 4000005;\n\ninline int qPow(int b, int e) {\n\tint a = 1;\n\tfor (; e; e >>= 1, b = (LL)b * b % Mod)\n\t\tif (e & 1) a = (LL)a * b % Mod;\n\treturn a;\n}\n\nint Fac[MS], iFac[MS];\ninline void Init(int N) {\n\tFac[0] = 1;\n\tfor (int i = 1; i <= N; ++i) Fac[i] = (LL)Fac[i - 1] * i % Mod;\n\tiFac[N] = qPow(Fac[N], Mod - 2);\n\tfor (int i = N; i >= 1; --i) iFac[i - 1] = (LL)iFac[i] * i % Mod;\n}\ninline int Binom(int N, int M) {\n\treturn (LL)Fac[N] * iFac[M] % Mod * iFac[N - M] % Mod;\n}\n\nint N, K;\nint f[MN][MN];\n\nint main() {\n\tscanf(\"%d%d\", &N, &K);\n\tif (K == 1 || N == 1) return puts(\"1\"), 0;\n\tInit(N * K);\n\tf[0][0] = 1;\n\tfor (int j = 1; j <= N; ++j) f[0][j] = (LL)f[0][j - 1] * Binom(j * (K - 1) - 1, K - 2) % Mod;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tf[i][i] = f[i - 1][i];\n\t\tfor (int j = i + 1; j <= N; ++j)\n\t\t\tf[i][j] = (f[i - 1][j] + (LL)f[i][j - 1] * Binom(i + j * (K - 1) - 1, K - 2)) % Mod;\n\t}\n\tprintf(\"%lld\\n\", (LL)f[N][N] * Fac[N] % Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename T>\nvoid read(T &x)\n{\n    x=0;char c=getchar();bool p=0;\n    for(;c<'0'||c>'9';c=getchar())if(c=='-')p=1;\n    for(;c>='0'&&c<='9';c=getchar())x=(x<<3)+(x<<1)+(c^48);\n    if(p)x=-x;\n}\nconst ll MOD=1000000000+7;\nll f[2005][2005];\nll fac[4000005],inv[4000005];\nint n,k;\nll ksm(ll basic,ll mi)\n{\n    ll tmp=1;\n    while(mi)\n    {\n        if(mi&1)tmp=tmp*basic%MOD;\n        mi>>=1;\n        basic=basic*basic%MOD;\n    }\n    return tmp;\n}\nll C(ll x,ll y)\n{\n    return fac[x]*inv[y]%MOD*inv[x-y]%MOD;\n}\nint main()\n{\n    read(n),read(k);\n    fac[0]=inv[0]=1;\n    for(ll i=1;i<=n*k;++i)fac[i]=fac[i-1]*i%MOD;\n    inv[n*k]=ksm(fac[n*k],MOD-2);\n    for(ll i=n*k-1;i;--i)inv[i]=inv[i+1]*(i+1)%MOD;\n    if(k==1)\n    {\n        printf(\"1\\n\");\n        return 0;\n    }\n    f[0][0]=1;\n    for(int i=1;i<=n;++i)\n    {\n        f[i][0]=1;\n        for(int j=1;j<=i;++j)\n        {\n            f[i][j]=(f[i][j]+f[i-1][j]+1ll*f[i][j-1]*(n-j+1)%MOD*C(n*k-i-(j-1)*(k-1)-1,k-2)%MOD)%MOD;\n        }\n    }\n    printf(\"%lld\\n\",f[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e3+7,p=1e9+7;\nint n,k,dp[N][N]; long long fac[N*N],ifac[N*N];\ninline int pows(long long u,int v){\n\tlong long ans=1; while(v>0) {if(v&1) ans=ans*u%p; u=u*u%p,v=v>>1;} return ans;\n}\ninline long long getans(int a,int b){\n\treturn fac[a]*ifac[b]%p*ifac[a-b]%p;\n}\nint main(){\n\tcin>>n>>k,fac[0]=ifac[0]=1;\n\tfor(int i=1;i<=n*k;i++) fac[i]=fac[i-1]*i%p,ifac[i]=pows(fac[i],p-2); dp[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(j>0) dp[i][j]=(dp[i][j-1]*getans(n*k-(k-1)*(j-1)-i-1,k-2)+dp[i-1][j])%p;\n\t\t\telse dp[i][j]=dp[i-1][j];\n\t\t}\n\tif(k==1) cout<<1<<endl; else cout<<dp[n][n]*fac[n]%p<<endl;\n    return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int N=2005,Mod=1e9+7;\nint dp[N][N],fac[N*N],inv[N*N];\ninline int C(int n,int m){\n\treturn 1ll*fac[n]*inv[m]%Mod*inv[n-m]%Mod;\n}\ninline int qpow(int a,int b){\n\tint ans=1;\n\twhile (b){\n\t\tif (b&1) ans=1ll*ans*a%Mod;\n\t\ta=1ll*a*a%Mod,b>>=1;\n\t}\n\treturn ans;\n}\nint main (){\n\tint n,k;scanf (\"%d%d\",&n,&k);\n\tif (k==1) {puts(\"1\");return 0;}\n\tdp[0][0]=1;fac[0]=1;\n\tfor (int i=1;i<=n*k;i++) fac[i]=1ll*fac[i-1]*i%Mod;\n\tinv[n*k]=qpow(fac[n*k],Mod-2);for (int i=n*k-1;i>=0;i--) inv[i]=1ll*inv[i+1]*(i+1)%Mod;\n    for (int i=0;i<=n;i++) dp[i][0]=1;\n\tfor (int i=1;i<=n;i++)\n        for (int j=0;j<=i;j++)\n            dp[i][j]=dp[i-1][j]+1ll*dp[i][j-1]*(n-j+1)%Mod*C(n*k-(i+(j-1)*(k-1))-1,k-2)%Mod,dp[i][j]%=Mod;\n    printf (\"%d\",dp[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// In the name of God \n#include <bits/stdc++.h>\n\nusing namespace std ;\n \n#define int long long\n#define all(v) v.begin() , v.end()\n\ntemplate<typename T> inline bool smin(T &a, const T &b){ return b < a ? a = b,1:0;}\ntemplate<typename T> inline bool smax(T &a, const T &b){ return a < b ? a = b,1:0;}\n\nconst int N = 2000 + 10 , mod = ( int )1e9 + 7 , maxn = 2000 * 2000 + 10 ; \n\nint n , k , dp [ N ] [ N ] , fact [ maxn ] , inv [ maxn ] ;  \n\nint pw ( int x , int y ) {\n\tint ret = 1;\n\tfor ( ; y ; y >>= 1 , ( x *= x ) %= mod )\n\t\tif ( y & 1 )\n\t\t\t( ret *= x ) %= mod ;\n\treturn ret ; \n}\n\nint comb ( int n , int r ) {\n\tif ( n < 0 || r < 0 || n < r ) return 0 ;\n\treturn fact [ n ] * inv [ r ] % mod * inv [ n - r ] % mod ; \n}\n\nint32_t main()                     \n{\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tfact [ 0 ] = inv [ 0 ] = 1 ;\n\tfor ( int j = 1 ; j < maxn ; ++j ) {\n\t\tfact [ j ] = fact [ j - 1 ] * j % mod ;\n\t\tinv [ j ] = pw ( fact [ j ] , mod - 2 ) ; \n\t}\n\tcin >> n >> k ;\n\tif ( k == 1 )\n\t\treturn cout << 1 << '\\n' , 0 ;\n\tdp [ 0 ] [ 0 ] = 1 ; \n\tfor ( int i = 0 ; i <= n ; ++i ) {\n\t\tfor ( int j = 0 ; j <= i ; ++j ) {\n\t\t\tif ( j )\n\t\t\t\tdp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; \n\t\t\tif ( i ) {\n\t\t\t\tint rem = i * ( k - 1 ) + j - 1 ; \n\t\t\t\tdp [ i ] [ j ] += ( dp [ i - 1 ] [ j ] * comb ( rem , k - 2 ) % mod ) ;\n\t\t\t\tif ( dp [ i ] [ j ] >= mod )\n\t\t\t\t\tdp [ i ] [ j ] -= mod ; \n\t\t\t}\n\t\t\t//cout << \"hey \" << i << ' ' << j << ' ' << dp [ i ] [ j ] << '\\n' ; \n\t\t}\n\t}\n\tcout << ( dp [ n ] [ n ] * fact [ n ] ) % mod << '\\n' ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long MAXN=2010;\nlong long n,k,dp[MAXN][MAXN];\nlong long fac[MAXN*MAXN],inv[MAXN*MAXN];\nlong long C(long long x,long long y){return fac[x]*inv[y]%mod*inv[x-y]%mod;}\nint main(){\n\tscanf(\"%lld%lld\",&n,&k);\n\tfac[0]=1;for(register long long i=1;i<=n*k;i++)fac[i]=fac[i-1]*i%mod;\n\tinv[1]=1;for(register long long i=2;i<=n*k;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\tinv[0]=1;for(register long long i=1;i<=n*k;i++)inv[i]=inv[i-1]*inv[i]%mod;\n\tif(k==1){\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tdp[0][0]=1;\n\tfor(register long long i=1;i<=n;i++){\n\t\tfor(register long long j=0;j<=i;j++){\n\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\tif(j)dp[i][j]=(dp[i][j]+(n-j+1)*dp[i][j-1]%mod*C(n*k-i-(k-1)*(j-1)-1,k-2)%mod)%mod;\t\t\t\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n][n]);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "//                             In The Name Of Allah\n#include <bits/stdc++.h>\n#define ss second\n#define ff first\n#define use_fast ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)\n#define ret(n) return cout << n, 0\n#define se(n) cout << setprecision(n) << fixed\n#define pb push_back\n#define int long long\n#define ld long double\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\")\n#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\n\nconst int N = 4e6 + 100, T = 2e3 + 100, OO = 1e12 + 10, M = 1e9 + 7, P = 49157, sq = 360, lg = 30;\ntypedef pair <int, int> pii;\nint dp[T][T];\nint fac[N], inv[N];\n \nint pw(int x, int y) {\n\tif(y == 0)\n\t\treturn 1;\n\tint cnt = pw(x, y / 2);\n\tcnt = (cnt * cnt) % M;\n\tcnt = (cnt * (y % 2 == 1 ? x : 1)) % M;\n\treturn cnt;\n}\n \nvoid prepro() {\n\tfac[0] = 1;\n\tfor(int i = 1; i <= N - lg; i++) \n\t\tfac[i] = (fac[i - 1] * i) % M;\n\tinv[N - lg] = pw(fac[N - lg], M - 2);\n\tfor(int i = N - lg - 1; i > -1; i--) \n\t\tinv[i] = (inv[i + 1] * (i + 1)) % M;\n}\n \nint c(int x, int y) {\n\tif(x == y || y == 0)\n\t\treturn 1;\n\treturn ((fac[x] * inv[y] % M) * inv[x - y]) % M;\n}\n\nint32_t main() {\n\tuse_fast;\n\tprepro();\n\tint n, k;\n\tcin >> n >> k;\n\tif(k == 1)\n\t\treturn cout << 1, 0;\n\tdp[0][0] = 1;\n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int j = i; j >= 1; j--) \n\t\t\tdp[i][j] = (dp[i][j + 1] + (dp[i - 1][j - 1] * i) % M * c(i * k - 1 - j, k - 2)) % M;\n\t\tdp[i][0] = dp[i][1];\n\t}\n\tcout << dp[n][0] << endl;\n\treturn 0;\n} \t\n/*\nbe carefull :\n1- if not solve after 20 min, read again twice\n2- after submit read the code again\n3- fun with contest\n4- ... \n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int P=1e9+7;\nconst int N=2005;\nlong long f[N][N],fac[N*N],inv[N*N];\nlong long fsp(long long x,int y){\n\tlong long ans=1;\n\twhile(y){\n\t\tif(y&1)\tans=ans*x%P;\n\t\tx=x*x%P,y>>=1;\n\t}\n\treturn ans;\n}\nlong long C(int n,int m){\n\treturn fac[n]*inv[m]%P*inv[n-m]%P;\n}\nint n,m,k;\nint main(){\n\tscanf(\"%d%d\",&n,&k),m=n*k;\n\tfac[0]=inv[0]=f[0][0]=1;\n\tfor(int i=1;i<=m;i++){\n\t\tfac[i]=fac[i-1]*i%P;\n\t\tinv[i]=fsp(fac[i],P-2);\n\t}\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t\tf[i][j]=(f[i][j-1]*C(m-i-(j-1)*(k-1)-1,k-2)%P*(n-j+1)+f[i-1][j])%P;\n\tprintf(\"%lld\\n\",f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\n#define N 2010\n#define mod 1000000007\n#define foru(i,l,r) for (int i=l; i<=r; i++)\n#define ford(i,r,l) for (int i=r; i>=l; i--)\n#define read(x) ((x)=getint())\n#define inc(a,b) (((a)+=(b))%=mod)\n#define mul(a,b) (LL(a)*(b)%mod)\ntypedef long long LL;\n\nint n,k,fac[N*N],inv[N*N],f[N][N];\n\nint getint()\n{\n\tint x,f=1; char ch;\n\twhile (!isdigit(ch=getchar())) f=ch=='-'?-1:1;\n\tx=ch-'0';\n\twhile (isdigit(ch=getchar())) x=x*10+ch-'0';\n\treturn f*x;\n}\nint C(int n, int m)\n{\n\tif (n<0||n<m) return 0;\n\treturn mul(mul(fac[n],inv[m]),inv[n-m]);\n}\nint main()\n{\n\tread(n), read(k);\n\tif (k==1) return puts(\"1\"), 0;\n\tfac[0]=inv[0]=fac[1]=inv[1]=1;\n\tforu(i,2,n*k) fac[i]=mul(fac[i-1],i);\n\tforu(i,2,n*k) inv[i]=mul(mod-mod/i,inv[mod%i]);\n\tforu(i,2,n*k) inv[i]=mul(inv[i],inv[i-1]);\n\tf[0][0]=1;\n\tforu(i,0,n)\n\t\tford(j,i,0)\n\t\t{\n\t\t\tinc(f[i+1][j+1],mul(C(i*k-j+k-2,k-2),f[i][j]));\n\t\t\tif (j) inc(f[i][j-1],f[i][j]);\n\t\t}\n\tprintf(\"%lld\\n\",mul(f[n][0],fac[n]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int N = 5000 + 10;\nconstexpr int MOD = 1e9 + 7;\n\nlong long dp[N][N], fact[N * N], n, k;\n\nlong long mypow (long long a, long long b) {\n    return b ? (mypow (a * a % MOD, b >> 1) * (b & 1 ? a : 1)) % MOD : 1;\n}\n\nlong long ch (long long a, long long b) {\n    return (fact[a] * mypow (fact[b] * fact[a - b] % MOD, MOD - 2)) % MOD;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> k;\n    fact[0] = 1;\n    for (int i = 1; i < N * N; i++)\n        fact[i] = (fact[i - 1] * i) % MOD;\n    for (int i = 0; i <= n; i++) {\n        for (int j = i; j <= n; j++) {\n            if (i == 0) {\n                if (j == 0)\n                    dp[i][j] = 1;\n                else {\n                    dp[i][j] = ch (j * (k - 1) - 1, k - 2) * dp[i][j - 1];\n                    dp[i][j] %= MOD;\n                }\n                continue;\n            }\n            dp[i][j] = dp[i - 1][j] + ch (i + j * (k - 1) - 1, k - 2) * dp[i][j - 1];\n            dp[i][j] %= MOD;\n        }\n    }\n    cout << (dp[n][n] * fact[n]) % MOD << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <tuple>\n#include <cstddef>\n#include <iomanip>\n#include <array>\n\n#define ALL(v) std::begin(v), std::end(v)\n#define ALLR(v) std::rbegin(v), std::rend(v)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing pll = std::pair<ll, ll>;\nusing tll = std::tuple<ll, ll, ll>;\ntemplate <typename T> using vec = std::vector<T>;\ntemplate <typename T> using vvec = vec<vec<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return vec<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\nnamespace init__ { \nstruct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; \ntemplate <typename T, std::size_t Head, std::size_t ...Tail> struct multi_dem_array { using type = std::array<typename multi_dem_array<T, Tail...>::type, Head>; };\ntemplate <typename T, std::size_t Head> struct multi_dem_array<T, Head> { using type = std::array<T, Head>; };\n}\n\ntemplate <typename T, std::size_t ...Args>\nusing mdarray = typename init__::multi_dem_array<T, Args...>::type;\n\n\nnamespace math {\n\ntemplate <typename T>\nconstexpr T pow(const T &n, ll k) {\n    T ret = n.mul_id_ele();\n    T cur = n;\n    while (k) {\n        if (k & 1) ret *= cur;\n        cur *= cur;\n        k /= 2;\n    }\n    return ret;\n}\n\n}\n\nnamespace math {\n\ntemplate <ll Mod>\nstruct Modint {\n\n    constexpr Modint(ll x) : x(x % Mod) { }\n    \n    constexpr Modint() : Modint(0) { }\n    \n    constexpr Modint<Mod> add_id_ele() const { \n        return Modint<Mod>(0); \n    }\n    \n    constexpr Modint<Mod> mul_id_ele() const {\n        return Modint<Mod>(1); \n    }\n    \n    constexpr ll& value() { \n        return x; \n    }\n    \n    constexpr ll value() const {\n        return x; \n    }\n\n    constexpr Modint& operator +=(const Modint &oth) {\n        x += oth.value();\n        if (Mod <= x) x -= Mod;\n        return *this;\n    }\n\n    constexpr Modint& operator -=(const Modint &oth) {\n        x += Mod - oth.value();\n        if (Mod <= x) x -= Mod;\n        return *this;\n    }\n\n    constexpr Modint& operator *=(const Modint &oth) {\n        x *= oth.value();\n        x %= Mod;\n        return *this;\n    }\n\n    constexpr Modint& operator /=(const Modint &oth) {\n        x *= oth.inv();\n        x %= Mod;\n        return *this;\n    }\n\n    constexpr Modint operator +(const Modint &oth) const {\n        return Modint(x) += oth;\n    }\n\n    constexpr Modint operator -(const Modint &oth) const {\n        return Modint(x) -= oth;\n    }\n\n    constexpr Modint operator *(const Modint &oth) const {\n        return Modint(x) *= oth;\n    }\n\n    constexpr Modint operator /(const Modint &oth) const {\n        return Modint(x) /= oth;\n    }\n\n    constexpr Modint operator -() const {\n        return Modint((x != 0) * (Mod - x)); \n    }\n\n    template <typename T>\n    constexpr typename std::enable_if<std::is_integral<T>::value, const Modint&>::type\n    operator =(T t) {\n        (*this) = Modint(std::forward<T>(t)); \n        return *this;\n    }\n\n    constexpr Modint inv() const {\n        return ::math::pow(*this, Mod - 2);\n    }\n\n    constexpr ll mod() const {\n        return Mod;\n    }\n\nprivate:\n    ll x;\n};\n\n}\n\nnamespace math {\n\ntemplate <ll Mod>\nclass Combination {\n    using mint = Modint<Mod>;\n\n    ssize_t maxv;\n    vec<mint> factv, ifactv;\n\npublic:\n    Combination(ssize_t maxv) : maxv(maxv), factv(maxv + 1), ifactv(maxv + 1) {\n        factv[0] = mint(1);\n        for (ll i = 1; i <= maxv; i++) factv[i] = factv[i - 1] * i;\n        ifactv.back() = factv.back().inv();\n        for (ll i = maxv - 1; 0 <= i; i--) ifactv[i] = ifactv[i + 1] * (i + 1);\n    }\n\n    mint fact(ll n) const {\n        return factv[n]; \n    }\n\n    mint ifact(ll n) const {\n        return ifactv[n];\n    }\n\n    mint perm(ll n, ll k) const {\n        return factv[n] * ifactv[n - k];\n    }\n\n    mint comb(ll n, ll k) const {\n        return perm(n, k) * ifactv[k];\n    }\n};\n\n}\n\nconst ll inf = 5e15;\nconst ll mod = 1e9 + 7;\nconst std::size_t SIZE = 2010;\nusing mint = math::Modint<mod>;\nmdarray<mint, SIZE, SIZE> dp;\nmdarray<bool, SIZE, SIZE> calced;\nmath::Combination<mod> co(SIZE * SIZE);\n\nll n, k;\n\nmint rec(ll i, ll j) {\n    if (calced[i][j]) return dp[i][j];\n    calced[i][j] = true;\n    ll rest = n * k - (i + (j - 1) * (k - 1));\n    if (j <= i) {\n        mint pre = rec(i, j - 1);\n        mint addv = pre * (n - (j - 1));\n        if (2 <= k) addv *= co.comb(rest - 1, k - 2);\n        dp[i][j] += addv;\n    }\n    if (j < i) {\n        mint pre = rec(i - 1, j);\n        dp[i][j] += pre;\n    }\n    return dp[i][j];\n}\n\nll solve() {\n    std::cin >> n >> k;\n    if (k == 1) return 1;\n    for (ll i = 0; i <= n; i++) {\n        dp[i][0] = 1;\n        calced[i][0] = true;\n    }\n    return rec(n, n).value();\n}\n\nint main() {\n    std::cout << solve() << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\nint read();\nint M(int x) { return x >= mod ? x - mod : x; }\nint fsp(int bs, int p) {\n    int rt = 1;\n    while (p) {\n        if (p & 1) rt = 1ll * rt * bs % mod;\n        bs = 1ll * bs * bs % mod, p >>= 1;\n    }\n    return rt;\n}\n\nint n, k;\nint fac[4000006], caf[4000006];\nvoid init() {\n    int lim = 4000000;\n    fac[0] = 1;\n    for (int i = 1; i <= lim; ++i) fac[i] = 1ll * fac[i - 1] * i % mod;\n    caf[lim] = fsp(fac[lim], mod - 2);\n    for (int i = lim; i >= 1; --i) caf[i - 1] = 1ll * caf[i] * i % mod;\n}\nint C(int x, int y) { return 1ll * fac[x] * caf[y] % mod * caf[x - y] % mod; }\nint f[2003][2003];\n\nint main() {\n    n = read(), k = read(), init();\n    if (k == 1) return puts(\"1\"), 0;\n    for (int i = 1; i <= n; ++i) f[i][0] = 1;\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= i; ++j)\n            f[i][j] = M(f[i - 1][j] +\n                        1ll * f[i][j - 1] * (n - j + 1) % mod *\n                            C(n - i + (n - j + 1) * (k - 1) - 1, k - 2) % mod);\n    printf(\"%d\\n\", f[n][n]);\n    return 0;\n}\n\nint read() {\n    int x = 0, f = 1;\n    char c = getchar();\n    while (c < '0' || c > '9') f = (c == '-') ? -1 : f, c = getchar();\n    while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 2002\n#define mod 1000000007\n#define ll long long\n\nll f[nn*nn],rf[nn*nn];\nll qpow(ll x,ll y)\n{\n\tll res=1;\n\twhile(y)\n\t{\n\t\tif(y&1) res=res*x%mod;\n\t\tx=x*x%mod;y=y/2;\n\t}\n\treturn res;\n}\nll c(ll x,ll y)\n{\n\tif(x>y)  return 0;\n\treturn f[y]*rf[x]%mod*rf[y-x]%mod;\n}\n\nll dp[nn][nn];ll n,k;\nint main()\n{\n\tf[0]=1;for(int i=1;i<nn*nn;i++) f[i]=f[i-1]*i%mod;\n\trf[nn*nn-1]=qpow(f[nn*nn-1],mod-2);\n\tfor(int i=nn*nn-2;i>=0;i--) rf[i]=rf[i+1]*(i+1)%mod;\n\n\tcin>>n>>k;k--;\n\tif(k==1)\n\t{\n\t\tcout<<1;\n\t\texit(0);\n\t}\n\tdp[0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\tdp[i+1][j]%=mod;\n\t\t\tdp[i][j+1]+=dp[i][j]*c(k-1,n*k+n-k*j-i-1);\n\t\t\tdp[i][j+1]%=mod;\n\t\t}\n\t}\n\t\n\tcout<<dp[n][n]*f[n]%mod;\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nsigned main(){\n\n    int N, K; cin >> N >> K;\n    if(K == 1){\n        Out(1);\n        return 0;\n    }\n\n    Combination C(N * K);\n    mmat dp(N + 1, mvec(N + 1, 0));\n    dp[0][0] = 1;\n    REP(i, N){\n        IREP(j, i) dp[i][j] += dp[i][j + 1];\n        int M = K * i;\n        REP(j, i + 1){\n            dp[i + 1][j + 1] = dp[i][j] * C.nCr(M - j + K - 2, K - 2);\n        }\n    }\n    mint ans = 0;\n    REP(j, N + 1) ans += dp[N][j];\n    ans *= C.fact[N];\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; i--)\nusing namespace std;\nusing lli = long long int;\nlli mod = 1e9 + 7;\nlli dp[2010][2010] = {};\n\nlli n, k;\nlli inv[5000005], fact[5000005], ifact[5000005];\nlli comb(lli i, lli j)\n{\n    if (i < j)\n        return 0;\n    if (i == j || j == 0)\n        return 1;\n\n    return (fact[i] * (ifact[j] * ifact[i - j]) % mod) % mod;\n}\nint main()\n{\n    fact[0] = inv[0] = inv[1] = fact[1] = ifact[1] = 1;\n\n    for (lli i = 2; i <= 5000000; ++i) {\n        inv[i] = (inv[mod % i] * (mod - mod / i) % mod + mod) % mod;\n        fact[i] = (fact[i - 1] * i) % mod;\n    }\n    for (lli i = 2; i <= 5000000; ++i) {\n        ifact[i] = (ifact[i - 1] * inv[i]) % mod;\n    }\n\n\n    cin >> n >> k;\n    if (k == 1) {\n        cout << 1 << endl;\n        return 0;\n    }\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int j = i; j >= 0; j--) {\n            dp[i][j] = dp[i][j + 1];\n            if (j > 0) {\n                dp[i][j] = dp[i][j] + dp[i - 1][j - 1] * comb(i * k - j - 1, k - 2);\n                dp[i][j] %= mod;\n            }\n        }\n    }\n    cout << (fact[n] * dp[n][0]) % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\n#define go(u) for(int i = head[u], v = e[i].to; i; i=e[i].lst, v=e[i].to)\n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define pb push_back\n#define re(x) memset(x, 0, sizeof x)\ninline int gi() {\n    int x = 0,f = 1;\n    char ch = getchar();\n    while(!isdigit(ch)) { if(ch == '-') f = -1; ch = getchar();}\n    while(isdigit(ch)) { x = (x << 3) + (x << 1) + ch - 48; ch = getchar();}\n    return x * f;\n}\ntemplate <typename T> inline bool Max(T &a, T b){return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline bool Min(T &a, T b){return a > b ? a = b, 1 : 0;}\nconst int N = 2007, mod = 1e9 + 7;\nint n, k;\nint fac[N * N], invfac[N * N], inv[N * N], f[N][N];\nint C(int n, int m) {\n\treturn (LL) fac[n] * invfac[n - m] % mod * invfac[m] % mod;\n}\nvoid add(int &a, int b) { a += b; if(a >= mod) a -= mod;}\nint main() {\n#ifndef ONLINE_JUDGE\n#endif\n\tn = gi(), k = gi();\n\tif(k == 1) return puts(\"1\"), 0;\n\tinv[1] = fac[0] = invfac[0] = 1;\n\trep(i, 1, n * k) {\n\t\tif(i ^ 1) inv[i] = (LL) (mod - mod / i) * inv[mod % i] % mod;\n\t\tfac[i] = (LL) fac[i - 1] * i % mod;\n\t\tinvfac[i] = (LL) invfac[i - 1] * inv[i] % mod;\n\t}\n\trep(i, 1, n) {\n\t\tf[i][0] = 1;\n\t\trep(j, 1, i) {\n\t\t\tadd(f[i][j] ,f[i - 1][j]);\n\t\t\tadd(f[i][j], (LL) f[i][j - 1] * C((n - i) + (n - j + 1) * (k - 1) - 1, k - 2) % mod * (n - j + 1) % mod);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int M = 2000 + 10, N = 6000000 + 10;\nconst int MOD = 1000000007;\n\nll dp[M][M], n, k, fac[N], inv[N];\n\nll mul(ll a, ll b){\n\treturn a * b % MOD; \n}\n\nll add(ll a, ll b){\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nll POW(ll x, ll t){\n\tll res = 1;\n\twhile (t){\n\t\tif (t & 1) res = mul(res, x);\n\t\tt >>= 1;\n\t\tx = mul(x, x);\n\t}\n\treturn res;\n}\n\nll ted(ll x, ll y){\n\tll res = x * k + (y - x) * (k - 1);\n\treturn res;\n}\n\nll nCr(ll x, ll y){\n\tif (x < 0 || y < 0 || y > x) return 0;\n\tll res = fac[x];\n\tres = mul(res, mul(inv[y], inv[x - y]));\n\treturn res;\n}\n\nll solve(ll ted, ll K){\n\treturn nCr(K + ted - 1, ted - 1);\n}\n\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n >> k;\n\tdp[0][0] = 1;\n\t//cout << POW(2, 4) << '\\n';\n\tfac[0] = 1, inv[0] = 1;\n\tfor (int i = 1; i < N; i++){\n\t\tfac[i] = mul(fac[i - 1], i);\n\t\tinv[i] = POW(fac[i], MOD - 2);\n\t}\n\t//cout << fac[4] << '\\n';\n\t//cout << nCr(4, 2) << '\\n';\n\t//cout << ted(0, 1) << '\\n';\n\tif (k == 1) return cout << 1, 0;\n\tfor (int i = 0; i <= n; i++){\n\t\tfor (int j = i; j <= n; j++){\n\t\t\tif (i == j && i == 0) continue;\n\t\t\tif (i == 0){\n\t\t\t\tif (j == 1) {dp[i][j] = 1;}\n\t\t\t\telse{\n\t\t\t\t\tll res = solve(ted(i,j - 1) + 1, k - 2);\n\t\t\t\t\tdp[i][j] = mul(dp[i][j - 1], res);\n \t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (i == j){\n\t\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\t\t}else{\n\t\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\t\t\tll res = solve(ted(i, j - 1) + 1, k - 2);\n\t\t\t\t\tdp[i][j] = add(dp[i][j], mul(dp[i][j - 1], res));\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << i << ' ' << j << ' ' << dp[i][j] << '\\n';\n\t\t}\t\t\n\t}\n\tcout << mul(dp[n][n], fac[n]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PP;\n\n/*\n    freopen(\"input\",\"r\",stdin);\n    freopen(\"output\",\"w\",stdout);\n*/\n\nll DP[2001][2001];\n\nll F[4000001];\nll I[4000001];\n\nll MOD = 1E9 + 7;\n\nll power(ll a, int b) {\n\tll res = 1;\n\twhile (b > 0) {\n\t\tif (b % 2 == 1) {\n\t\t\tres *= a;\n\t\t\tres %= MOD;\n\t\t}\n\t\tb /= 2;\n\t\ta *= a;\n\t\ta %= MOD;\n\t}\n\treturn res;\n}\n\nvoid init() {\n\tF[0] = 1;\n\tfor (ll i = 1;i <= 4000000;i++) {\n\t\tF[i] = F[i - 1] * i;\n\t\tF[i] %= MOD;\n\t}\n\tmemset(I, 0, sizeof(I));\n\treturn;\n}\n\nll nchoosek(int a, int b) {\n\tif (b == 0 || a == b) return 1;\n\tll up = F[a];\n    if (I[a- b] == 0) I[a - b] = power(F[a - b], MOD - 2);\n    if (I[b] == 0) I[b] = power(F[b], MOD - 2);\n\tll down = I[a - b] * I[b];\n\tdown %= MOD;\n\tup *= down;\n\treturn up %= MOD;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    init();\n    memset(DP, 0, sizeof(DP));\n    DP[0][0] = 1;\n    int N, K, T;\n    cin >> N >> K;\n    if (K == 1) {\n    \tcout << 1 << endl;\n    \treturn 0;\n    }\n    T = N * K;\n    for (int i = 0;i <= N;i++) {\n    \t// Opened Slot.\n    \tfor (int j = 0;j <= i;j++) {\n    \t\t// Closed Slot.\n\n    \t\tif (i != N) {\n    \t\t\t// Open a slot.\n    \t\t\tDP[i + 1][j] += DP[i][j];\n    \t\t\tDP[i + 1][j] %= MOD;\n    \t\t}\n\n    \t\tif (i != j) {\n    \t\t\t// Close a slot.\n\n    \t\t\t// Choose One Color.\n    \t\t\tll ans = (N - j);\n\n    \t\t\tll rem = T - j * K - (i - j);\n\n    \t\t\tans *= nchoosek(rem - 1, K - 2);\n    \t\t\tans %= MOD;\n\n    \t\t\tans *= DP[i][j];\n    \t\t\tans %= MOD;\n\n    \t\t\tDP[i][j + 1] += ans;\n    \t\t\tDP[i][j + 1] %= MOD;\n    \t\t}\n\n    \t}\n    }\n    cout << DP[N][N] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define db double\n#define ll long long\n#define ev edge[i].v\n#define mod 1000000007\n#define pir pair<int,int>\n#define Rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define RepD(i,r,l) for(int i=(r);i>=(l);--i)\n#define RepG(i,x) for(int i=head[x];i;i=edge[i].next)\nusing namespace std;\n\nconst int N=2005;\n\nll f[N][N];\nll fac[N*N],inv[N*N];\n\nll ksm(ll a,ll b){\n\tll res=1;\n\twhile(b){\n\t\tif(b&1) res=res*a%mod;\n\t\ta=a*a%mod,b>>=1;\n\t}\n\treturn res;\n}\n\nll C(ll n,ll m){\n    if(n<0||n<m) return 0;\n    return fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\n\nint main(){\n\tll n,k;\n    scanf(\"%lld%lld\",&n,&k);\n    if(k==1){puts(\"1\");return 0;}\n    fac[0]=inv[0]=f[0][0]=1;\n    Rep(i,1,n*k) fac[i]=fac[i-1]*i%mod;\n    inv[n*k]=ksm(fac[n*k],mod-2);\n    RepD(i,n*k-1,1) inv[i]=inv[i+1]*(i+1)%mod;\n    Rep(i,1,n)\n    \tRep(j,0,i){\n    \t\tif(i) f[i][j]=(f[i][j]+f[i-1][j])%mod;\n\t\t\tif(j) f[i][j]=(f[i][j]+f[i][j-1]*C(n*k-i-(k-1)*(j-1)-1,k-2)%mod)%mod;\n\t\t}\n    printf(\"%lld\\n\",f[n][n]*fac[n]%mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define il inline\n#define RG register\n#define ll long long\n#define rhl (1000000007)\n#define N (5000010)\n\nusing namespace std;\n\nint fac[N],ifac[N],inv[N];\nint f[2010][2010],n,k;\n\nil int C(RG int n,RG int m){\n  return 1LL*fac[n]*ifac[m]%rhl*ifac[n-m]%rhl;\n}\n\nil void add(RG int &x,RG int v){\n  x+=v; if (x>=rhl) x-=rhl; return;\n}\n\nint main(){\n  cin>>n>>k;\n  if (k==1) puts(\"1\"),exit(0); f[0][0]=fac[0]=ifac[0]=1;\n  for (RG int i=1;i<=(n+1)*k;++i){\n    inv[i]=i==1 ? 1 : 1LL*(rhl-rhl/i)*inv[rhl%i]%rhl;\n    fac[i]=1LL*fac[i-1]*i%rhl,ifac[i]=1LL*ifac[i-1]*inv[i]%rhl;\n  }\n  for (RG int i=0;i<=n;++i)\n    for (RG int j=0;j<=n;++j){\n      if (i<j) add(f[i+1][j],f[i][j]);\n      add(f[i][j+1],1LL*f[i][j]*C(i+(j+1)*(k-1)-1,k-2)%rhl);\n    }\n  cout<<1LL*f[n][n]*fac[n]%rhl; return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<set>\n#include<iostream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef tuple<int,int,int> t3;\n\nconst int MX = 2005;\nconst int MM = 1000000007;\n\nint D[MX][MX];\nint F[MX*MX], FI[MX*MX], I[MX*MX];\nint N, K;\n\nll C(int x, int y){\n\tif( y < 0 || x < y ) return 0;\n\treturn (ll)F[x] * FI[y] % MM * FI[x-y] % MM;\n}\n\nint main()\n{\n\tF[0] = FI[0] = I[1] = 1;\n\tfor(int i = 1; i < MX*MX; i++){\n\t\tF[i] = (ll)F[i-1] * i % MM;\n\t\tif(i>=2) I[i] = (ll)I[MM%i] * (MM - MM/i) % MM;\n\t\tFI[i] = (ll)FI[i-1] * I[i] % MM;\n\t}\n\tscanf(\"%d%d\", &N, &K); K--;\n\tif( K == 0 ) return !printf(\"1\\n\");\n\tD[0][0] = 1;\n\tfor(int i = 0; i <= N; i++){\n\t\tfor(int j = 0; j <= N; j++){\n\t\t\tif(i) D[i][j] = (D[i][j] + D[i-1][j]) % MM;\n\t\t\tif(j) D[i][j] = (D[i][j] + C(i+j*K-1, K-1) * D[i][j-1]) % MM;\n\t\t\tif( i > j ) D[i][j] = 0;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", D[N][N] * (ll)F[N] % MM);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int P=1e9+7;\nconst int N=2005;\nlong long f[N][N],fac[N*N],inv[N*N];\nlong long fsp(long long x,int y){\n\tlong long ans=1;\n\twhile(y){\n\t\tif(y&1)\tans=ans*x%P;\n\t\tx=x*x%P,y>>=1;\n\t}\n\treturn ans;\n}\nlong long C(int n,int m){\n\treturn fac[n]*inv[m]%P*inv[n-m]%P;\n}\nint n,m,k;\nint main(){\n\tscanf(\"%d%d\",&n,&k),m=n*k;\n\tfac[0]=inv[0]=f[0][0]=1;\n\tfor(int i=1;i<=m;i++){\n\t\tfac[i]=fac[i-1]*i%P;\n\t\tinv[i]=fsp(fac[i],P-2);\n\t}\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t\tf[i][j]=(f[i][j-1]*C(m-i-(j-1)*(k-1)-1,k-2)%P*(n-j+1)+f[i-1][j])%P;\n\tprintf(\"%lld\\n\",f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\nusing namespace std;\nint fac[5001000],nifac[5001000],dp[2010][2010];\nint getmi(int a,int x)\n{\n\tint ans=1;\n\twhile (x)\n\t{\n\t\tif (x&1) ans=(long long)ans*a%mo;\n\t\ta=(long long)a*a%mo;\n\t\tx>>=1;\n\t}\n\treturn ans;\n}\nint C(int n,int m){return (long long)fac[n]*nifac[m]%mo*nifac[n-m]%mo;}\nint main()\n{\n\tint n,k;scanf(\"%d%d\",&n,&k);\n\tif (k==1) {puts(\"1\");return 0;}\n\tfac[0]=1;for (int i=1;i<=n*k;i++) fac[i]=(long long)fac[i-1]*i%mo;\n\tnifac[n*k]=getmi(fac[n*k],mo-2);\n\tfor (int i=n*k-1;i>=0;i--) nifac[i]=(long long)nifac[i+1]*(i+1)%mo;\n\tdp[0][0]=1;\n\tfor (int i=0;i<=n;i++)\n\tfor (int j=0;j<=n;j++)\n\t{\n\t\tif (i) dp[i][j]=dp[i-1][j];\n\t\tif ((i!=j)&&(j)) dp[i][j]=(dp[i][j]+(long long)dp[i][j-1]*C(i+j*(k-1)-1,k-2))%mo;\n\t}\n\tprintf(\"%lld\\n\",(long long)fac[n]*dp[n][n]%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define ll long long\nusing namespace std;\nconst ll mod=1e9 +7;\nint n,k;\nll f[2020][2020],jc[4040404],jc_n[4040404];\nll C(int x,int y)\n{\n\tif (y<0 || y>x) return 0;\n\tif (y==0 || x==y) return 1;\n\tll sss=jc[x];\n\tsss=sss*jc_n[x-y]%mod*jc_n[y]%mod;\n\treturn sss;\n}\nint main()\n{\n\tjc[1]=1;\n\tjc_n[1]=1;\n\tfor (int i=2;i<=4000010;++i)\n\t{\n\t\tjc[i]=jc[i-1]*i%mod;\n\t\tjc_n[i]=(mod-mod/i)*jc_n[mod%i]%mod;\n\t}\n\tfor (int i=2;i<=4000010;++i)\n\t\tjc_n[i]=jc_n[i]*jc_n[i-1]%mod;\n\n\t//printf(\"%lld\\n\",C(5,1));\n\tscanf(\"%d%d\",&n,&k);\n\tif (k==1)\n\t{\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tf[0][0]=1;\n\tfor (int i=0;i<=n;++i)\n\t\tfor (int j=n;j>=0;--j)\n\t\tif (f[i][j])\n\t\t{\n\t\t\tif (j) f[i][j-1]=(f[i][j-1]+f[i][j])%mod;\n\t\t\tf[i+1][j+1]=(f[i+1][j+1]+C(i*k-j+k-2,k-2)*f[i][j]%mod)%mod;\n\t\t}\n\tprintf(\"%lld\\n\",f[n][0]*jc[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define lor(a,b,c) for(register int a=b;a<=c;++a)\n#define ror(a,b,c) for(register int a=c;a>=b;--a)\n\nconst int N=2005,K=2005,S=N*K,MOD=1e9+7;\nint n,k;\nint fac[S],inv[S];\nint dp[N][K];\n\ninline int qsm(int a,int b) {int ans=1; while(b) {if(b&1) ans=1ll*ans*a%MOD; a=1ll*a*a%MOD; b>>=1;} return ans;}\ninline int C(int a,int b) {return b<0||a<b?0:1ll*fac[a]*inv[b]%MOD*inv[a-b]%MOD;}\ninline void inc(int &a,int b) {(a+=b)>=MOD?a-=MOD:a;}\n\nint main(){\n\t#ifndef ONLINE_JUDGE\n\tfreopen(\"test.in\",\"r\",stdin);\n\t#endif\n\n\tcin>>n>>k;\n\tif(k==1) return puts(\"1\"),0;\n\tfac[0]=1l; lor(i,1,n*k) fac[i]=1ll*fac[i-1]*i%MOD;\n\tinv[n*k]=qsm(fac[n*k],MOD-2); ror(i,0,n*k-1) inv[i]=1ll*inv[i+1]*(i+1)%MOD;\n\tdp[0][0]=1;\n\tlor(i,0,n) lor(j,0,i){\n\t\tif(i) inc(dp[i][j],dp[i-1][j]);\n\t\tif(j) inc(dp[i][j],1ll*dp[i][j-1]*C(n*k-i-(j-1)*(k-1)-1,k-2)%MOD*(n-j+1)%MOD);\n\t}\n\tprintf(\"%d\\n\",dp[n][n]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\n#define go(u) for(int i = head[u], v = e[i].to; i; i=e[i].lst, v=e[i].to)\n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define pb push_back\n#define re(x) memset(x, 0, sizeof x)\ninline int gi() {\n    int x = 0,f = 1;\n    char ch = getchar();\n    while(!isdigit(ch)) { if(ch == '-') f = -1; ch = getchar();}\n    while(isdigit(ch)) { x = (x << 3) + (x << 1) + ch - 48; ch = getchar();}\n    return x * f;\n}\ntemplate <typename T> inline bool Max(T &a, T b){return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline bool Min(T &a, T b){return a > b ? a = b, 1 : 0;}\nconst int N = 2007, mod = 1e9 + 7;\nint n, k;\nint fac[N * N], invfac[N * N], inv[N * N], f[N][N];\nint C(int n, int m) {\n\treturn (LL) fac[n] * invfac[n - m] % mod * invfac[m] % mod;\n}\nvoid add(int &a, int b) { a += b; if(a >= mod) a -= mod;}\nint main() {\n#ifndef ONLINE_JUDGE\n#endif\n\tn = gi(), k = gi();\n\tinv[1] = fac[0] = invfac[0] = 1;\n\trep(i, 1, n * k) {\n\t\tif(i ^ 1) inv[i] = (LL) (mod - mod / i) * inv[mod % i] % mod;\n\t\tfac[i] = (LL) fac[i - 1] * i % mod;\n\t\tinvfac[i] = (LL) invfac[i - 1] * inv[i] % mod;\n\t}\n\trep(i, 1, n) {\n\t\tf[i][0] = 1;\n\t\trep(j, 1, i) {\n\t\t\tadd(f[i][j] ,f[i - 1][j]);\n\t\t\tadd(f[i][j], (LL) f[i][j - 1] * C((n - i) + (n - j + 1) * (k - 1) - 1, k - 2) % mod * (n - j + 1) % mod);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst int MAXN = 2010;\n\nll fac[MAXN*MAXN], ifac[MAXN*MAXN];\n\ninline ll qpow(ll a, ll b) {\n\tll res = 1;\n\twhile(b) {\n\t\tif(b & 1LL) res = res * a % MOD;\n\t\tb >>= 1, a = a * a % MOD;\n\t}\n\treturn res;\n}\n\nint n, k;\nll dp[MAXN][MAXN];\n\ninline ll binom(int x, int y) {\n\treturn fac[x]*ifac[y]%MOD*ifac[x-y]%MOD;\n}\n\ninline void update(ll &cur, ll val) {\n\tcur = cur+val;\n\tif(cur >= MOD) cur -= MOD;\n}\n\nint main() {\n\n\tint i, j;\n\tscanf(\"%d%d\", &n, &k);\n\tif(k == 1) {\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tfac[0] = 1;\n\tfor(i = 1; i <= n*k; i++) fac[i] = fac[i-1]*i%MOD;\n\tifac[n*k] = qpow(fac[n*k], MOD-2);\n\tfor(i = n*k; i >= 1; i--) ifac[i-1] = ifac[i]*i%MOD;\n\tdp[n][n] = 1;\n\tfor(i = n; i >= 0; i--) {\n\t\tfor(j = n; j >= i; j--) {\n\t\t\tif(i == 0 && j == 0) continue;\n\t\t\tif(i != 0) update(dp[i-1][j], dp[i][j]);\n\t\t\tif(j != i) {\n\t\t\t\tupdate(dp[i][j-1], dp[i][j]*binom(j*(k-1)+i-1, k-2)%MOD);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[0][0]*fac[n]%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MN = 20123, INF = 5012345, MOD = 1000 * 1000 * 1000 + 7;\nint inv[INF], fict[INF], invf[INF], dp[MN][MN];\n\nvoid fact() {\n\tfict[0] = inv[0] = invf[0] = 1;\n\tfict[1] = inv[1] = invf[1] = 1;\n\tfor (int i = 2; i < INF; i++) {\n\t\tinv[i] = 1ll * inv[MOD % i] * (MOD - MOD / i) % MOD;\n\t\tfict[i] = 1ll * fict[i - 1] * i % MOD;\n\t\tinvf[i] = 1ll * invf[i - 1] * inv[i] % MOD;\n\t}\n}\n\nint chose(int a, int b) {\n\treturn 1ll * fict[b] * invf[a] % MOD * invf[b - a] % MOD;\n}\n\nint main() {\n\tfact();\n\tint n, k;\n\tcin >> n >> k;\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tif (j > i)\n    \t          continue;\n\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\tif (j)\n\t\t\t\tdp[i][j] = (dp[i][j] + 1ll * dp[i][j - 1] * chose(k - 2, n * k - (j - 1) * (k - 1) - i - 1) % MOD) % MOD;\n        }\n\tcout << 1ll * dp[n][n] * fict[n] % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <unordered_map>\n#include <unordered_set>\n#include <tuple>\n#include <queue>\n\nusing namespace std;\n\n#define pb push_back\n#define pbk pop_back\n#define fs first\n#define sc second\n#define sz(s) ((int) (s).size())\n#define all(x) (x).begin(), (x).end()\n#define mt make_tuple\n#define mp make_pair\n#define next hunext\n#define prev huprev\n\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef long double ld;\n\nconst int inf = 1e9;\nconst double pi = 4 * atan(1.0);\nconst double eps = 1e-9;\nconst int N = 2020;\nconst int MOD = int(1e9) + 7;\n\nint n, k;\nint dp[N][N], f[N * N];\n\ninline int calc(int a, int b) {\n    int res = 1;\n    while (b > 0) {\n        if (b % 2 != 0) {\n            res = (1LL * res * a) % MOD;\n        }\n        a = (1LL * a * a) % MOD;\n        b /= 2;\n    }\n    return res;\n}\n\ninline int solve() {\n    if (k == 1) {\n        return 1;\n    }\n    f[k - 2] = 1;\n    for (int i = k - 1; i <= n * k; ++i) {\n        f[i] = (1LL * f[i - 1] * i) % MOD;\n        f[i] = (1LL * f[i] * calc(i - (k - 2), MOD - 2)) % MOD;\n    }\n    dp[n][n] = 1;\n    for (int zero = n; zero >= 0; --zero) {\n        for (int active = zero; active >= 0; --active) {\n            if (zero > 0 && zero - 1 >= active) {\n                dp[zero - 1][active] = (dp[zero - 1][active] + dp[zero][active]) % MOD;\n            }\n            if (active > 0) {\n                int cur = (1LL * dp[zero][active] * (n - active + 1)) % MOD;\n                int ind = (n - active + 1) * (k - 1) + (n - zero) - 1;\n                assert(ind >= k - 2 && ind <= n * k);\n                cur = (1LL * cur * f[ind]) % MOD;\n                dp[zero][active - 1] = (dp[zero][active - 1] + cur) % MOD;\n            }\n        }\n    }\n    return dp[0][0];\n}\n\nint main() {\n#ifdef LOCAL42\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    cin >> n >> k;\n    cout << solve() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define mod 1000000007\nlong long f[2005][2005],ny[4000005],s[4000005],t[4000005];\nlong long f(long long n,long long m)\n{\n\treturn s[n]*t[m]%mod*t[n-m]%mod;\n}\nint main()\n{\n\tlong long n,k,i,j;\n\tcin>>n>>k;\n\tif(k==1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tny[1]=1;\n\tfor(i=2;i<=4000000;i++)\n\t{\n\t\tny[i]=(mod-mod/i)*ny[mod%i]%mod;\n\t}\n\ts[0]=1,t[0]=1;\n\tfor(i=1;i<=4000000;i++)\n\t{\n\t\ts[i]=s[i-1]*i%mod;\n\t\tt[i]=t[i-1]*ny[i]%mod;\n\t}\n\tfor(i=0;i<=n;i++)\n\t\tf[i][0]=1;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tfor(j=0;j<=i;j++)\n\t\t{\n\t\t\tf[i][j]=f[i-1][j]+f[i][j-1]*(n-j+1)%mod*f(n*k-i-1-(j-1)*(k-1),k-2)%mod;\n\t\t\tf[i][j]%=mod;\n\t\t}\n\t}\n\tcout<<f[n][n]%mod<<endl;\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\n\ninline int read() {\n\tint res=0,fh=1;\n\tchar ch=getchar();\n\twhile((ch>'9'||ch<'0')&&ch!='-')ch=getchar();\n\tif(ch=='-')fh=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9')res=res*10+ch-'0',ch=getchar();\n\treturn fh*res;\n}\n\nconst int maxn=4000010;\nconst int mod=1e9+7;\n\nint fac[maxn],inv[maxn];\ninline int fpw(int x,int a){\n\tint ans=1;\n\twhile(a){\n\t\tif(a&1) (ans*=x)%=mod;\n\t\t(x*=x)%=mod;\n\t\ta>>=1;\n\t}\n\treturn ans;\n}\ninline int C(int n,int m){\n\treturn (((fac[m]*inv[n])%mod)*inv[m-n])%mod;\n}\n\n#define LL int\n#define inv_fac inv\n#define Mod mod\n#define re register\n#define Maxn maxn\ninline void pre(){\n\tfac[0]=1;\n\tfor(int i=1;i<maxn;i++)\n\t\tfac[i]=(fac[i-1]*i)%mod;\n\tinv[maxn-1]=fpw(fac[maxn-1],mod-2);\n\tfor(int i=maxn-2;i>=0;i--)\n\t\tinv[i]=(inv[i+1]*(i+1))%mod;\n}\n\n\nint n,k;\nint f[2010][2010];\n//f[i][j] 表示在这些位置上已经放了i个白球，j种其他颜色的球。(i<j)\n\nsigned main(){\n\tn=read();if((k=read())==1) return puts(\"1\"),0;\n\tpre();\n\tmemset(f,0,sizeof f);f[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(!j) continue;\n\t\t\t(f[i][j]+=f[i][j-1]*(n-j+1)%mod*C(k-2,n-i+(n-j+1)*(k-1)%mod-1)%mod)%=mod;\n\t\t}\n\t}\n\treturn printf(\"%lld\",f[n][n]%mod),0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define MOD 1000000007\nusing namespace std;\nint N,K;\nLL fac[5000010],inv[5000010],ifac[5000010],d[2010][2010];\nint main()\n{\n\tcin>>N>>K;\n\tfac[0]=inv[0]=ifac[0]=fac[1]=inv[1]=ifac[1]=1;\n\tfor(int i=2;i<=5000000;i++)\n\t{\n\t\tfac[i]=(fac[i-1]*i)%MOD;\n\t\tinv[i]=inv[MOD%i]*(MOD-MOD/i)%MOD;\n\t\tifac[i]=(ifac[i-1]*inv[i])%MOD;\n\t}\n\td[0][1]=1;\n\tfor(int i=2;i<=N;i++)\n\t{\n\t\td[0][i]=d[0][i-1]*(fac[i*(K-1)-1]*ifac[K-2]%MOD*ifac[(i-1)*(K-1)]%MOD)%MOD;\n\t}\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tfor(int j=i;j<=N;j++)\n\t\t{\n\t\t\td[i][j]=(d[i-1][j]+d[i][j-1]*(fac[i+j*(K-1)-1]*ifac[K-2]%MOD*ifac[i+(j-1)*(K-1)]%MOD))%MOD;\n// \t\t\tcout<<i<<' '<<j<<' '<<d[i][j]<<endl;\n\t\t}\n\t}\n\tcout<<(d[N][N]*fac[N])%MOD<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 2005 * 2005;\nconst int mod = 1e9 + 7;\n\nint Pow(int x , int y) {\n\tif(y == 0) return 1;\n\tif(y == 1) return x;\n\tint it = Pow(x , y >> 1);\n\tit = it * 1ll * it % mod;\n\tif(y & 1) it = it * 1ll * x % mod;\n\treturn it;\n}\n\nint inv[N] , fac[N] , n , k , dp[2005][2005];\n\nvoid predance(int x) {\n\tfac[0] = inv[0] = 1;\n\tfor(int i = 1;i <= x;i ++) {\n\t\tfac[i] = fac[i - 1] * 1ll * i % mod;\n\t\tinv[i] = Pow(fac[i] , mod - 2);\n\t}\n}\n\nint C(int x , int y) {\n\treturn fac[x] * 1ll * inv[y] % mod * 1ll * inv[x - y] % mod;\n}\n\nint main(void) {\n\tscanf(\"%d%d\" , &n , &k);\n\tif(k == 1) {\n\t\treturn puts(\"1\") * 0;\n\t}\n\tdp[0][0] = 1;\n\tpredance(n * k);\n\tfor(int i = 1;i <= n;i ++) {\n\t\tfor(int j = 0;j <= i;j ++) {\n\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\tif(j) {\n\t\t\t\tdp[i][j] += dp[i][j - 1] * 1ll * C(n * k - (j - 1)* (k - 1) - i - 1 , k - 2) % mod;\n\t\t\t\tif(dp[i][j] >= mod) dp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn printf(\"%d\\n\" , (int)((dp[n][n] * 1ll * fac[n]) % mod));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nll read(){\n\tchar c=getchar();bool flag=0;ll x=0;\n\twhile(c<'0'||c>'9'){if(c=='-')flag=1;c=getchar();}\n\twhile(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}\n\treturn flag?-x:x;\n}\n#define N 2010 \nconst ll p=1e9+7;\nll dp[N][N],fac[N];\nll fpow(ll a,ll x){\n\tll ans=1;\n\twhile(x){\n\t\tif(x&1) ans=ans*a%p;\n\t\ta=a*a%p,x=x/2; \n\t}\n\treturn ans;\n}\nll inv(ll x){\n\treturn fpow(x,p-2);\n}\nll Cnt(ll n,ll m){\n\treturn fac[m]*inv(fac[n])%p*inv(fac[m-n])%p;\n}\nint main(){\n\tll n=read(),k=read();\n\tif(k==1){\n\t\tprintf(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\tfor(ll i=1;i<=n*k;i++) fac[i]=fac[i-1]*i%p;\n\tfor(ll i=1;i<=n;i++) dp[i][0]=1;\n\tfor(ll i=1;i<=n;i++){\n\t\tfor(ll j=1;j<=i;j++){\n\t\t\tdp[i][j]=dp[i-1][j]+dp[i][j-1]*(n-(j-1))*Cnt(k-2,n*k-i-(j-1)*(k-1)-1);\n\t\t}\n\t}\n\tprintf(\"%lld\",dp[n][n]); \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 2002\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7;\nint n,k;\nll dp[N][N],jie[N*N],ni[N*N];\ninline ll rd(){\n    ll x=0;char c=getchar();bool f=0;\n    while(!isdigit(c)){if(c=='-')f=1;c=getchar();}\n    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}\n    return f?-x:x;\n}\ninline ll power(ll x,ll y){\n    ll ans=1;\n    while(y){\n        if(y&1)ans=ans*x%mod;\n        x=x*x%mod;\n        y>>=1;\n    }\n    return ans;\n}\ninline ll C(int n,int m){return jie[n]*ni[m]%mod*ni[n-m]%mod;}\nint main(){\n    n=rd();k=rd();\n    if(k==1){puts(\"1\");return 0;}\n    int x=n*k;\n    jie[0]=1;\n    for(int i=1;i<=x;++i)jie[i]=jie[i-1]*i%mod;\n    ni[x]=power(jie[x],mod-2);\n    for(int i=x-1;i>=0;--i)ni[i]=ni[i+1]*(i+1)%mod;\n    dp[0][0]=1;\n    for(int i=1;i<=n;++i){\n        dp[i][0]=1;\n        for(int j=1;j<=i;++j){\n            dp[i][j]=(dp[i-1][j]+dp[i][j-1]*(n-j+1)%mod*C(n*k-(j-1)*(k-1)-i-1,k-2))%mod;\n        }\n    }\n    cout<<dp[n][n];\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for(int i = (a), i##_end_ = (b); i <= i##_end_; ++i)\n#define drep(i, a, b) for(int i = (a), i##_end_ = (b); i >= i##_end_; --i)\n#define clar(a, b) memset((a), (b), sizeof(a))\n#define debug(...) fprintf(stderr, __VA_ARGS__)\ntypedef long long LL;\ntypedef long double LD;\nconst int BUF_SIZE = (int)1e6 + 10;\nstruct fastIO {\n\tchar buf[BUF_SIZE], buf1[BUF_SIZE];\n\tint cur, cur1; FILE *in, *out;\n\tfastIO() { cur = BUF_SIZE, in = stdin, out = stdout; cur1 = 0; }\n\tinline char getchar() { if(cur == BUF_SIZE) fread(buf, BUF_SIZE, 1, in), cur = 0; return *(buf + (cur++)); }\n\tinline void putchar(char ch) { *(buf1 + (cur1++)) = ch; if (cur1 == BUF_SIZE) fwrite(buf1, BUF_SIZE, 1, out), cur1 = 0; } inline int flush() { if (cur1 > 0) fwrite(buf1, cur1, 1, out); return cur1 = 0; }\n}IO;\n#define getchar IO.getchar\n#define putchar IO.putchar\nLL read() {\n\tchar ch = getchar();\n\tLL x = 0, flag = 1;\n\tfor (;!isdigit(ch); ch = getchar()) if (ch == '-') flag *= -1;\n\tfor (;isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n\treturn x * flag;\n}\nvoid write(LL x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x >= 10) write(x / 10);\n\tputchar(x % 10 + 48);\n}\n\nconst int Maxn = 4009, Mod = 1e9 + 7;\nint n, k, fac[Maxn * Maxn / 4], invFac[Maxn * Maxn / 4];\n\nLL fpm(LL base, LL tims) {\n\tLL r = 1;\n\twhile (tims) {\n\t\tif (tims & 1) r = r * 1ll * base % Mod;\n\t\tbase = base * 1ll * base % Mod;\n\t\ttims >>= 1;\n\t}\n\treturn r;\n}\n\nvoid init() {\n\tn = read(), k = read();\n\tfac[0] = 1;\n\trep (i, 1, n * k) fac[i] = fac[i - 1] * 1ll * i % Mod;\n\tinvFac[n * k] = fpm(fac[n * k], Mod - 2);\n\tdrep (i, n * k - 1, 0) invFac[i] = invFac[i + 1] * (i + 1ll) % Mod;\n}\n\nLL C(int n, int m) {\n\tif (n < m) return 0;\n\treturn 1ll * fac[n] * invFac[m] % Mod * invFac[n - m] % Mod;\n}\n\nLL dp[Maxn][Maxn];\nvoid solve() {\n\tif (k == 1) {\n\t\tputs(\"1\");\n\t\treturn ;\n\t}\n\tdp[0][0] = 1;\n\trep (i, 0, n)\n\t\trep (j, 0, i) {\n\t\t\t(dp[i + 1][j] += dp[i][j]) %= Mod;\n\t\t\t(dp[i][j + 1] += dp[i][j] * 1ll * C(n * k - i - j * (k - 1) - 1, k - 2) % Mod) %= Mod;\n\t\t}\n\tcout << 1ll * dp[n][n] * fac[n] % Mod << endl;\n}\n\nint main() {\n//\tfreopen(\"bosky.in\", \"r\", stdin);\n//\tfreopen(\"bosky.out\", \"w\", stdout);\n\n\tinit();\n\tsolve();\n\n#ifdef Qrsikno\n\tdebug(\"\\nRunning time: %.3lf(s)\\n\", clock() * 1.0 / CLOCKS_PER_SEC);\n#endif\n\treturn IO.flush();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//\n// Created by Ильдар Ялалов on 14.01.2020.\n//\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int inf_int = 1e9 + 100;\nconst ll inf_ll = 1e18;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef long double dbl;\ntypedef unsigned int uint;\n#define pb push_back\n#define eb emplace_back\nconst double pi = 3.1415926535898;\n#define dout if(debug) cout\n#define fi first\n#define se second\n#define sp setprecision\n#define sz(a) (int(a.size()))\n#define mp make_pair\n#define all(a) a.begin(),a.end()\n\n#ifdef zxc\n\n#include \"debug.h\"\n\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nbool debug = 0;\nconst int MAXN = 4e6 + 100;\nconst int LOG = 21;\nconst int mod = 1e9 + 7;\nconst int MX = (1e7 + 100);\n\n\ntemplate<uint MD>\nstruct ModInt {\n    using M = ModInt;\n    uint v;\n\n    ModInt() : v{0} {}\n\n    ModInt(ll _v) : v{normS(_v % MD + MD)} {}\n\n    explicit operator bool() const { return v != 0; }\n\n    static uint normS(uint x) { return (x < MD) ? x : x - MD; };\n\n    static M make(uint x) {\n        M m;\n        m.v = x;\n        return m;\n    }\n\n    static M inv(const M &x) { return x.pow(MD - 2); }\n\n    M operator+(const M &r) const { return make(normS(v + r.v)); }\n\n    M operator-(const M &r) const { return make(normS(v + MD - r.v)); }\n\n    M operator*(const M &r) const { return make(ull(v) * r.v % MD); }\n\n    M operator/(const M &r) const { return *this * inv(r); }\n\n    M &operator+=(const M &r) { return *this = *this + r; }\n\n    M &operator-=(const M &r) { return *this = *this - r; }\n\n    M &operator*=(const M &r) { return *this = *this * r; }\n\n    M &operator/=(const M &r) { return *this = *this / r; }\n\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n};\n\nusing Mint = ModInt<mod>;\nMint fac[MAXN];\nMint inv_fac[MAXN];\n\nMint C(int n, int k) {\n    assert(k >= 0 && k <= n);\n    return fac[n] * inv_fac[k] * inv_fac[n - k];\n}\n\nMint super_C(int n, int k) {\n    return C(k + n - 1, k);\n}\n\nMint dp[2100][2100];\nMint sum[2100][2100];\n\nvoid solve() {\n    fac[0] = 1;\n    inv_fac[0] = 1;\n    for (int i = 1; i < MAXN; ++i) {\n        fac[i] = fac[i - 1] * i;\n        inv_fac[i] = Mint::inv(fac[i]);\n    }\n\n\n    int n, k;\n    cin >> n >> k;\n\n    if (k == 1) {\n        cout << 1;\n        return;\n    }\n    int val = max(n, k) + 1;\n    for (int i = n; i >= 1; --i) {\n        if (i == n) {\n            dp[n][1] = 1;\n        } else {\n            for (int j = val; j >= 0; --j) {\n                sum[i][j] = sum[i][j + 1] + dp[i + 1][j];\n            }\n\n            int total = (n - i) * k;\n\n            for (int j = 0; j <= val && j <= total; ++j) {\n                dp[i][j + 1] = sum[i][j] * super_C(total - j+1, k - 2);\n            }\n        }\n    }\n\n    Mint ans = 0;\n    for (int i = 1; i <= n + 2; ++i) {\n        ans += dp[1][i];\n    }\n    ans = ans * fac[n];\n    cout << ans.v << \"\\n\";\n}\n\n\n// CHECK LIMITS (n <= 10^5)\n// CHECK CORNER CASES ( n==1)\nsigned main() {\n#ifdef zxc\n    freopen(\"../input.txt\", \"r\", stdin);\n//    freopen(\"../output.txt\", \"w\", stdout);\n#else\n#endif //zxc\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(2);\n\n    int t = 1;\n    while (t--) {\n        solve();\n    }\n    debug(1.0 * clock() / CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxn = 2010;\nconst int mod = 1e9 + 7;\nusing namespace std;\n\ninline ll mul(ll a,ll b) { return 1ll * a * b % mod; }\n\nll dp[maxn][maxn], fac[4000005], ifac[4000005];\nint n, m, i, j, k, K;\n\ninline ll qpow(ll a,int b,int p = mod) {\n  ll res = 1;\n  while(b) {\n    if(b & 1) (res *= a) %= p;\n    (a *= a) %= p;  b >>= 1;  \n  }\n  return res;\n}\n\ninline void pre_work(int N) {\n  fac[0] = 1;\n  for(int i = 1;i <= N;i++) fac[i] = (fac[i - 1] * i) % mod;\n  ifac[N] = qpow(fac[N],mod - 2);\n  //printf(\"%lld\\n\",ifac[N]);\n  for(int i = N - 1;~i;i--) ifac[i] = (ifac[i + 1] * (i + 1)) % mod;\n}\n\ninline ll C(int n,int m) { return (((fac[m] * ifac[n]) % mod) * ifac[m - n]) % mod; }\n\nint main()  {\n  scanf(\"%d %d\",&n,&K);  if(K == 1) return 0 & puts(\"1\");\n  dp[0][0] = 1;\n  pre_work(4000000);\n  for(int i = 1;i <= n;i++) {\n      for(int j = 0;j <= i;j++) {\n      dp[i][j] = dp[i - 1][j];  if(j == 0) continue;  int qwq;\n      (dp[i][j] += dp[i][j - 1] * (n - j + 1) % mod * C(K - 2,n - i + (n - j + 1) * (K - 1) - 1) % mod) %= mod;\n    }\n  }\n  printf(\"%lld\\n\",dp[n][n]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define gt getchar()\n#define ll long long\n#define File(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ninline int in()\n{\n\tint k=0;char ch=gt;\n\twhile(ch<'-')ch=gt;\n\twhile(ch>'-')k=k*10+ch-'0',ch=gt;\n\treturn k;\n}\nconst int YL=1e9+7;\ninline int MO(const int &a){return a>=YL?a-YL:a;}\ninline int ksm(int a,int k){int r=1;while(k){if(k&1)r=1ll*r*a%YL;a=1ll*a*a%YL;k>>=1;}return r;}\nint dp[2005][2005],fac[4000005],fnv[4000005];\ninline int C(int x,int y){if(x<y||y<0)return 0;return 1ll*fac[x]*fnv[y]%YL*fnv[x-y]%YL;}\nint main()\n{\n\tint n=in(),k=in();fac[0]=fnv[0]=1;if(k==1)return puts(\"1\"),0;\n\tfor(int i=1;i<=n*k;++i)fac[i]=1ll*fac[i-1]*i%YL;\n\tfnv[n*k]=ksm(fac[n*k],YL-2);\n\tfor(int i=n*k-1;i ;--i)fnv[i]=1ll*fnv[i+1]*(i+1)%YL;\n\tfor(int i=1;i<=n&&(dp[i][0]=1);++i)\n\t\tfor(int j=1;j<=i;++j)\n\t\t{\n\t\t\tdp[i][j]=MO(dp[i-1][j]+1ll*C(n-i-1+(n-j+1)*(k-1),k-2)*dp[i][j-1]%YL*(n-j+1)%YL);\n\t\t}\n\tprintf(\"%d\\n\",dp[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\ntypedef long long ll;\nconst int maxn=2000+10,mod=1000000007;\nll fac[maxn*maxn],ifac[maxn*maxn],f[maxn][maxn];\n\nll power(ll a,ll b){\n\tll ret=1;\n\twhile(b){\n\t\tif(b&1)ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ret;\n}\n\nll C(ll n,ll m){\n\tif(n<m)return 0;\n\treturn fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint main(){\n\t// freopen(\"in.txt\",\"r\",stdin);\n\tint n,m;scanf(\"%d%d\",&n,&m);\n\tif(m==1){printf(\"%d\\n\",1);return 0;}\n\tfac[0]=ifac[0]=1;\n\tfor(int i=1;i<=n*m;++i)fac[i]=fac[i-1]*i%mod;\n\tifac[n*m]=power(fac[n*m],mod-2);\n\tfor(int i=n*m-1;i>=1;--i)ifac[i]=ifac[i+1]*(i+1)%mod;\n\tf[0][0]=1;\n\tfor(int i=0;i<=n;++i)\n\t\tfor(int j=0;j<=i;++j){\n\t\t\tif(i>j)f[i][j]+=f[i-1][j];\n\t\t\tif(j)f[i][j]+=f[i][j-1]*C(n*m-i-(j-1)*(m-1)-1,m-2)%mod;\n\t\t\tf[i][j]%=mod;\n\t\t\t// printf(\"%d %d %lld\\n\",i,j,f[i][j]);\n\t\t}\n\tprintf(\"%lld\\n\",f[n][n]*fac[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#define ll long long\n#define re register\n#define il inline\n#define fp(i,a,b) for(re int i=a;i<=b;++i)\n#define fq(i,a,b) for(re int i=a;i>=b;--i)\nusing namespace std;\nconst int N=2010,mod=1e9+7;\nint n,k,f[N][N],jc[N*N+N],inv[N*N+N],gu;\nil int gi()\n{\n  re int x=0,t=1;\n  re char ch=getchar();\n  while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n  if(ch=='-') t=-1,ch=getchar();\n  while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();\n  return x*t;\n}\nil ll ksm(re ll S,re ll n)\n{\n\tre ll T=S;S=1;\n  while(n)\n\t{\n\t\tif(n&1) S=S*T%mod;\n\t\tT=T*T%mod;\n\t\tn>>=1;\n\t}\n  return S;\n}\nil ll C(re int x,re int y)\n{\n\tif(x<0||y<0||x<y) return 0;\n\treturn 1ll*jc[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main()\n{\n  n=gi();k=gi();gu=n*n+n;\n\tif(k==1) {puts(\"1\");return 0;}\n\tjc[0]=inv[0]=1;\n\tfp(i,1,gu) jc[i]=1ll*jc[i-1]*i%mod;inv[gu]=ksm(jc[gu],mod-2);\n\tfq(i,gu-1,1) inv[i]=1ll*inv[i+1]*(i+1)%mod;\n  f[0][0]=1;\n\tfp(i,1,n)\n\t\tfp(j,0,i)\n\t{\n\t\t(f[i][j]+=f[i-1][j])%=mod;\n\t\tif(j) (f[i][j]+=C((n-i)+(n-j+1)*(k-1)-1,k-2)*f[i][j-1]%mod*(n-j+1)%mod)%=mod;\n\t}\n  printf(\"%d\\n\",f[n][n]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(), vec.end()\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconstexpr ll INF = (1LL << 30) - 1LL;\nconstexpr ll LINF = (1LL << 60) - 1LL;\nconstexpr ll MOD = 1e9 + 7;\ntemplate <typename T> void chmin(T &a, T b) { a = min(a, b); }\ntemplate <typename T> void chmax(T &a, T b) { a = max(a, b); }\ntemplate <std::uint_fast64_t Modulus> class modint {\n    using u64 = std::uint_fast64_t;\n\n  public:\n    u64 a;\n    constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n    constexpr u64 &value() noexcept { return a; }\n    constexpr const u64 &value() const noexcept { return a; }\n    constexpr modint operator+(const modint rhs) const noexcept {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const noexcept {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const noexcept {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const noexcept {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint operator^(const u64 rhs) const noexcept {\n        return modint(*this) ^= rhs;\n    }\n    constexpr modint &operator+=(const modint rhs) noexcept {\n        a += rhs.a;\n        if (a >= Modulus) {\n            a -= Modulus;\n        }\n        return *this;\n    }\n    constexpr modint &operator-=(const modint rhs) noexcept {\n        if (a < rhs.a) {\n            a += Modulus;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr modint &operator*=(const modint rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept {\n        u64 exp = Modulus - 2;\n        while (exp) {\n            if (exp % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            exp /= 2;\n        }\n        return *this;\n    }\n    constexpr modint &operator^=(u64 exp) {\n        modint rhs = modint(*this);\n        a = 1;\n        while (exp) {\n            if (exp % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            exp /= 2;\n        }\n        return *this;\n    }\n};\nusing mint = modint<MOD>;\nvector<mint> f, fi;\nvoid comb(int n) {\n    f.resize(n + 1);\n    fi.resize(n + 1);\n    f[0] = 1;\n    for (ll i = 1; i <= n; i++) {\n        f[i] = f[i - 1] * mint(i);\n    }\n    fi[n] = mint(1) / f[n];\n    for (ll i = n - 1; i >= 0; i--) {\n        fi[i] = fi[i + 1] * mint(i + 1LL);\n    }\n}\nmint ncr(ll n, ll r) {\n    if (n < r) {\n        return mint(0);\n    }\n    if (r == 0) {\n        return mint(1);\n    }\n    return f[n] * fi[n - r] * fi[r];\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n, k;\n    cin >> n >> k;\n    if (k == 1) {\n        cout << 1 << endl;\n        return 0;\n    }\n    comb((n + 1) * (k + 1) + 10);\n    vector<vector<mint>> dp(n + 1, vector<mint>(n + 1));\n    dp[0][1] = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 2; j <= i; j++) {\n            dp[i][j] =\n                dp[i - 1][j - 1] * ncr((i - 1) * k - (j - 1) + k - 2, k - 2);\n        }\n        mint sum = 0;\n        for (int j = i; j >= 1; j--) {\n            sum += dp[i - 1][j];\n            dp[i][j] += sum * ncr((i - 1) * k - (j - 1) + k - 2, k - 2);\n        }\n    }\n    mint res = 0;\n    for (int i = 1; i <= n; i++) {\n        res += dp[n][i];\n    }\n    res *= f[n];\n    cout << res.a << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long fac[4000010], inv[4000010], finv[4000010]; \nlong long MOD = 1000000007; \nvoid COMinit(){\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i = 2; i < 4000005; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t}\n}\nlong long COM(int n, int k) {\n\tif (n < k) return 0;\n\tif (n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nint main(){\n\tint N, K; cin >> N >> K; \n\tif(K == 1){\n\t\tcout << 1 << \"\\n\"; return 0; \n\t}\n\tCOMinit(); \n\tlong long dp[2005][2005] = {}; // dp[i以上の数を並べ終わり][そこまでに0がj個含まれている]\n\tlong long DP[2005][2005] = {}; // その累積和\n\tdp[N][0] = 1;\n\tDP[N][0] = 1; DP[N][1] = 1;\n\tfor(int i = N-1; i >= 1; i--){\t\n\t\tfor(int j = 0; j <= N-i; j++){\n\t\t\tdp[i][j] = DP[i+1][j] * COM((N-i)*(K-1)+j+K-2, K-2) % MOD; \n\t\t}\n\t\tDP[i][0] = dp[i][0]; \n\t\tfor(int j = 1; j <= N+1-i; j++){\n\t\t\tDP[i][j] = DP[i][j-1] + dp[i][j]; \n\t\t\tif(DP[i][j] >= MOD) DP[i][j] -= MOD; \n\t\t}\n\t}\n\tcout << (DP[1][N] * fac[N]) % MOD << \"\\n\"; \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\ntypedef long long s64;\n\nconst int MaxN = 2000;\nconst int MaxNK = 2000;\nconst int MaxNL = MaxN * MaxNK;\n\nconst int M = 1000000007;\n\ninline int modpow(int a, const int &n)\n{\n\tint res = 1;\n\tfor (int i = n; i; i >>= 1)\n\t{\n\t\tif (i & 1)\n\t\t\tres = (s64)res * a % M;\n\t\ta = (s64)a * a % M;\n\t}\n\treturn res;\n}\n\ninline int add(int a, const int &b)\n{\n\ta += b;\n\treturn a >= M ? a - M : a;\n}\ninline int dec(int a, const int &b)\n{\n\ta -= b;\n\treturn a < 0 ? a + M : a;\n}\n\nint n, nK;\n\nint fact[MaxNL];\nint rfact[MaxNL];\n\ninline void init_fact(int n)\n{\n\tfact[0] = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfact[i] = (s64)fact[i - 1] * i % M;\n\n\trfact[n] = modpow(fact[n], M - 2);\n\tfor (int i = n; i; --i)\n\t\trfact[i - 1] = (s64)rfact[i] * i % M;\n}\n\ninline int binom(int n, int m)\n{\n\treturn n < 0 || m < 0 ? 0 : (s64)fact[n] * rfact[m] % M * rfact[n - m] % M;\n}\n\nint f[MaxN + 1][MaxN + 1];\n\nint main()\n{\n\tcin >> n >> nK;\n\n\tif (nK == 1)\n\t{\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\n\tinit_fact(n * nK - 1);\n\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 0; j <= i; ++j)\n\t\t{\n\t\t\tint a = j ? f[i][j - 1] : 0;\n\t\t\tint b = (s64)f[i - 1][j] * binom(i * (nK - 1) + j - 1, nK - 2) % M;\n\t\t\tf[i][j] = add(a, b);\n\t\t}\n\n\tcout << (s64)fact[n] * f[n][n] % M << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\n#define MOD 1000000007\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int MAXN = 2000 + 10;\nconst int MAXM = MAXN * MAXN;\n\nint N, K;\n\nLL fact[MAXM]= {0}, invfact[MAXM]= {0};\nvoid init () {\n\tfact[0] = fact[1] = invfact[0] = invfact[1] = 1;\n\tfor (int i = 2; i <= N * K; i ++) {\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\tinvfact[i] = (MOD - MOD / i) * invfact[MOD % i] % MOD;\n\t}\n\tfor (int i = 1; i <= N * K; i ++)\n\t\tinvfact[i] = invfact[i - 1] * invfact[i] % MOD;\n}\ninline LL C (int n, int m) {\n  \tif (n < 0) return 0;\n\tif (m == 0) return 1;\n\treturn fact[n] * invfact[m] % MOD * invfact[n - m] % MOD;\n}\n\nLL f[MAXN][MAXN]= {0};\n\nint main () {\n\tscanf (\"%d%d\", & N, & K);\n\tif (K == 1) {\n\t\tputs (\"1\");\n\t\treturn 0;\n\t}\n\tinit ();\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= N; i ++)\n\t\tfor (int j = 0; j <= i; j ++) {\n\t\t\tLL delta = f[i][j - 1] * (N - j + 1) % MOD * C (N * K - i - (K - 1) * (j - 1) - 1, K - 2) % MOD;\n\t\t\tif (j == 0) delta = 0;\n\t\t\tf[i][j] = (f[i][j] + f[i - 1][j] + delta) % MOD;\n\t\t}\n\tcout << f[N][N] << endl;\n\n\treturn 0;\n}\n\n/*\n2 2\n*/\n\n/*\n3 1\n*/\n\n/*\n2 3\n*/\n\n/*\n2000 2000\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2010\n#define mod 1000000007\n#define ll long long\nusing namespace std;\n\nll f[N][N];\nll jc[N*N],inv[N*N];\n\nll C(int a,int b){\n\tif(a==b || b==0) return 1;\n\tif(a<b) return 0;\n\treturn 1ll*jc[a]*1ll*inv[a-b]%mod*inv[b]%mod;\n}\nint main(){\n\tint n,k,i,j;\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1){ puts(\"1\");return 0; }\n\tjc[1]=inv[1]=1;\n\tfor(i=0;i<=n;++i) f[i][0]=1;\n\tfor(i=2;i<=n*k;++i) inv[i]=1ll*inv[mod%i]*(mod-mod/i)%mod;\n\tfor(i=2;i<=n*k;++i){\n\t\tjc[i]=1ll*jc[i-1]*i%mod;\n\t\tinv[i]=1ll*inv[i-1]*inv[i]%mod;\n\t}\n\tinv[1]=jc[1]=1;\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=1;j<=i;++j)\n\t\t\tf[i][j]=(f[i-1][j]+1ll*f[i][j-1]*(n-j+1)%mod*C(n*k-i-(j-1)*(k-1)-1,k-2)%mod)%mod;\t\t\n\tprintf(\"%lld\",f[n][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\nconst ll mod = 1000000007;\nvector<ll> inv, FactorialInv, Factorial;\nll beki(ll a, ll b){\n    ll ret = 1 % mod;\n    a %= mod;\n    while(b) {\n        if(b & 1LL) ret = ret * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return ret;\n}\nvoid init_combination(ll MAX){\n    Factorial.resize(MAX + 1);\n    FactorialInv.resize(MAX + 1);\n    inv.resize(MAX + 1);\n    Factorial[0] = 1;\n    inv[0] = 1;\n    for(int i = 1; i <= MAX; i++){\n        Factorial[i] = Factorial[i - 1] * i % mod;\n    }\n    FactorialInv[MAX] = beki(Factorial[MAX], mod - 2);\n    for(ll i = MAX - 1; i >= 0; i--) {\n        FactorialInv[i] = FactorialInv[i+1] * (i+1) % mod;\n    }\n    for(int i = 1; i <= MAX; i++) {\n        inv[i] = FactorialInv[i] * Factorial[i-1] % mod;\n    }\n}\nll combination(ll a, ll b){\n    if((a == b) || (b == 0)){\n        return 1;\n    }\n    if(a < b) return 0;\n    if(b < 0) return 0;\n    ll ans = Factorial[a] * FactorialInv[b] % mod;\n    ans = ans * FactorialInv[a - b] % mod;\n    return ans;\n}\n\nll dp[3000][3000];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    init_combination(5000000);\n    ll N, K;\n    cin >> N >> K;\n    if(K == 1) {\n        cout << 1 << endl;\n        return 0;\n    }\n    dp[0][0] = 1;\n    for(int i = 1; i <= N; i++) {\n        for(int j = 0; j <= N; j++) {\n            dp[i][j] += combination(i-1+(K-1)*(j-1)+K-2, K-2) * (dp[i][j-1]);\n            dp[i][j] += dp[i-1][j];\n            dp[i][j] %= mod;\n        }\n        for(int j = 0; j < i; j++) dp[i][j] = 0;\n        for(int j = 1; j <= N; j++) {\n            //cerr << i << \" \" << j << \" \" << dp[i][j] << endl;\n        }\n    }\n    ll ans = dp[N][N] * Factorial[N] % mod;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int N = 2005, mod = 1000 * 1000 * 1000 + 7;\n\n\nlong long fac[N * N];\nlong long facp[N * N];\nlong long dp[N][N];\nlong long ps[N][N];\n\nint po(int x, int y) {\n\tif (y == 0) {\n\t\treturn 1;\n\t}\n\tlong long ans = po(x, y / 2);\n\tans *= ans;\n\tans %= mod;\n\tif (y % 2) {\n\t\tans *= x;\n\t\tans %= mod;\n\t}\n\treturn ans;\n}\nint chs(int x, int y) {\n\tlong long ans = fac[x];\n\tans *= facp[y];\n\tans %= mod;\n\tans *= facp[x - y];\n\tans %= mod;\n\treturn ans;\n}\nint main() {\n\tint n, k;\n\tcin >> n >> k;\n\tif (k == 1) {\n\t\tcout << 1;\n\t\treturn 0;\n\t}\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n * k; i++) {\n\t\tfac[i] = fac[i - 1] * i;\n\t\tfac[i] %= mod;\n\t}\n\tfacp[n * k] = po(fac[n * k], mod - 2);\n\tfacp[0] = 1;\n\tfor (int i = n * k - 1; i; i--) {\n\t\tfacp[i] = facp[i + 1] * (i + 1);\n\t\tfacp[i] %= mod;\n\t}\n\tdp[1][1] = 1;\n\tps[1][1] = 1;\n//\tcout << chs(4, 2) << endl;\n\tfor (int i = 2; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tdp[i][j] = ps[i - 1][i - 1];\n\t\t\tif (j - 2 >= 0) {\n\t\t\t\tdp[i][j] -= ps[i - 1][j - 2] - mod;\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t\tdp[i][j] *= i;\n\t\t\tdp[i][j] %= mod;\n\t\t\tdp[i][j] *= chs(i * k - j - 1, k - 2);\n\t\t\tdp[i][j] %= mod;\n\t\t//\tcout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t\t\tps[i][j] = ps[i][j - 1] + dp[i][j];\n\t\t\tps[i][j] %= mod;\n\t\t}\n\t}\n\tcout << ps[n][n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <assert.h>\n#include <sys/time.h>\n#include <fstream>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define REP(i,n)  FOR(i,0,n)\n#define each(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define deb(x) cerr << #x << \" = \" << (x) << \" , \";\n#define debl cerr << \" (L\" << __LINE__ << \")\"<< endl;\n#define sz(s) (int)((s).size())\n\n\n#define clr(a) memset((a),0,sizeof(a))\n#define nclr(a) memset((a),-1,sizeof(a))\n#define pb push_back\n#define INRANGE(x,s,e) ((s)<=(x) && (x)<(e))\n#define MP(x,y) make_pair((x),(y))\n\ndouble pi=3.14159265358979323846;\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const vector<T>& z){\n\tos << \"[ \";\n\tREP(i,z.size())os << z[i] << \", \" ;\n\treturn ( os << \"]\" << endl);\n}\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const set<T>& z){\n\tos << \"set( \";\n\tEACH(p,z)os << (*p) << \", \" ;\n\treturn ( os << \")\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const map<T,U>& z){\n\tos << \"{ \";\n\tEACH(p,z)os << (p->first) << \": \" << (p->second) << \", \" ;\n\treturn ( os << \"}\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const pair<T,U>& z){\n\treturn ( os << \"(\" << z.first << \", \" << z.second << \",)\" );\n}\n\ndouble get_time(){\n\tstruct timeval tv;\n\tgettimeofday(&tv, NULL);\n\treturn tv.tv_sec + tv.tv_usec*1e-6;\n}\n\ntypedef unsigned int uint32_t;\nstruct RND{\n\tuint32_t x;\n\tuint32_t y;\n\tuint32_t z;\n\tuint32_t w;\n\tRND(){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=88675123;\n\t}\n\tvoid init(int seed){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=seed+100;\n\t\tREP(i,10)get();\n\t}\n\tuint32_t get(){\n\t\tuint32_t t;\n\t\tt=x^(x<<11);\n\t\tx=y;y=z;z=w;\n\t\tw=(w^(w>>19))^(t^(t>>8));\n\t\treturn w;\n\t}\n};\nRND rnd;\n\nll mod=1000000007;\nstruct mint{\n\tll value;\n\tmint():value(0){}\n\tmint(ll v):value((v%mod+mod)%mod){}\n};\nmint& operator+=(mint&a, mint b){return a=a.value+b.value;}\nmint& operator-=(mint&a, mint b){return a=a.value-b.value;}\nmint& operator*=(mint&a, mint b){return a=a.value*b.value;}\nmint operator+(mint a, mint b){return a+=b;}\nmint operator-(mint a, mint b){return a-=b;}\nmint operator*(mint a, mint b){return a*=b;}\nmint operator-(mint a){return 0-a;}\nbool operator==(mint a, mint b){return a.value==b.value;}\nbool operator!=(mint a, mint b){return a.value!=b.value;}\n\n\nstd::ostream& operator<<(std::ostream& os, const mint& m){\nreturn ( os << m.value );}\nll extgcd(ll a, ll b, ll &x, ll &y){\n\tll d=a;\n\tif(b!=0){\n\t\td=extgcd(b, a%b, y, x);\n\t\ty-=(a/b)*x;\n\t}\n\telse{\n\t\tx=1,y=0;\n\t}\n\treturn d;\n}\nll modinverse(ll a, ll b){\n\tll x,y;\n\tll d=extgcd(a,b, x, y);\n\tassert(d==1);\n\treturn (x%b+b)%b;\n}\nmint& operator/=(mint&a, mint b){return a=a.value*modinverse(b.value,mod);}\nmint operator/(mint a, mint b){return a/=b;}\n\nconst int D=4100000;\nmint factorial[D];\nmint invfactorial[D];\nmint pow2[D];\n\nstruct Precomp{\n\tPrecomp(){\n\t\tfactorial[0]=1;\n\t\tfor(ll k=1; k<D; k++)factorial[k].value = factorial[k-1].value*k%mod;\n\t\tinvfactorial[D-1] = mint(1) / factorial[D-1];\n\t\tfor(ll k=D-2; k>=0; k--) invfactorial[k].value = invfactorial[k+1].value*(k+1)%mod;\n\t\tpow2[0]=1;\n\t\tfor(ll k=1; k<D; k++)pow2[k].value = pow2[k-1].value*2%mod;\n\n\t}\n}precomp;\n\nmint comb(ll n, ll a){\n\tif(0<=a && a<=n)return factorial[n] * invfactorial[a] * invfactorial[n-a];\n\telse return mint(0);\n}\n\nmint Rcomb(ll n, ll r){\n\t// x_1+...+x_r= nの個数\n\tif(n==0 && r>=0)return 1;\n\treturn comb(n+r-1, r-1);\n}\n\nmint a[2010][2010];\n\nvoid _main(istream &inp){\n\tll N,K;\n\tinp >> N >>K;\n\tif(N==1 || K==1){\n\t\tcout << 1 << endl;\n\t\treturn;\n\t}\n\tclr(a);\n\ta[0][0]=1;\n\tfor(ll m=1; m<N; m++){\n\t\tmint su = 0;\n\t\tfor(ll i=0; i<=m; i++){\n\t\t\tsu += a[m-1][i];\n\t\t\ta[m][i] = Rcomb(K-2, m*(K-1)+i+1) * su;\n\t\t}\n\t}\n\tmint res = 0;\n\trep(i,N) res += a[N-1][i];\n\tres = res * factorial[N];\n\tcout << res.value << endl;\n\n\twhile(true){\n\t\tbreak;\n\t}\n\n}\n\nint main(){\n\tif(0){\n\t\tifstream ifs(\"test.txt\");\n\t\t_main(ifs);\n\t}\n\telse{\n\t\t_main(cin);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\nconst int mo = 1e9 + 7;\nusing namespace std;\ntypedef long long ll;\nll fpm(ll a, ll b)\n{\n\tll res = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1) res = res * a % mo;\n\t\ta = a * a % mo;\n\t\tb >>= 1; \n\t}\n\treturn res;\n}\nconst int MAXN = 2e3 + 10;\nconst int MAXV = 4e6 + 10;\nll fac[MAXV], facinv[MAXV];\nint n, k;\ninline void pre()\n{\n\tfac[0] = 1;\n\tfor (register int i = 1; i <= n * k; ++i) fac[i] = 1ll * i * fac[i - 1] % mo;\n\tfacinv[n * k] = fpm(fac[n * k], mo - 2);\n\tfor (register int i = n * k; i > 0; --i) facinv[i - 1] = 1ll * facinv[i] * i % mo;\n\t \n}\ntemplate <class T> \ninline ll binom(T a, T b)\n{\n\tif (a - b < 0) return 0;\n\tif (b < 0) return 0;\n\treturn fac[a] * facinv[b] % mo * facinv[a - b] % mo;\n}\nll f[MAXN][MAXN];\nint main(int argc, char **argv)\n{\n\tcin >> n >> k;\n\tif (k == 1) return puts(\"1\"), 0; \n\tpre();\n\tf[0][0] = 1;\n\tfor (register int i = 1; i <= n; ++i)\n\t{\n\t\tfor (register int j = 0; j <= i; ++j)\n\t\t{\n\t\t\tf[i][j] = f[i - 1][j];\n\t\t\tif (!j) continue;\n\t\t\tf[i][j] = (f[i][j] + f[i][j - 1] * (n - j + 1) % mo * binom(n - i + (n - j + 1) * (k - 1) - 1, k - 2) % mo) % mo; \n\t\t}\n\t}\n\tcout << f[n][n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F(i, a, b) for (register int i = (a), _b = (b); i <= _b; i++)\n#define D(i, a, b) for (register int i = (a), _b = (b); i >= _b; i--)\n \nconst int N = 2005;\nconst int S = 4000005;\nconst int P = 1e9+7;\n \nint n, K;\nint Tn, fac[S], inv[S], ifac[S];\nint f[N][N], g[N];\n \ninline int C(int n, int m) {\n    if (m < 0 || n < m) return 0;\n    return 1LL * fac[n] * ifac[m] % P * ifac[n-m] % P;\n}\ninline int G(int n, int m) { return C(n+m, n); }\n \nint main(void) {     \n    scanf(\"%d %d\", &n, &K);\n    if (K == 1) return puts(\"1\"), 0;\n \n    Tn = n*K;\n    fac[0] = 1;\n    F(i, 1, Tn) fac[i] = 1LL * fac[i-1] * i % P;\n    inv[1] = 1;\n    F(i, 2, Tn) inv[i] = 1LL * (P - P / i) * inv[P % i] % P;\n    ifac[0] = 1;\n    F(i, 1, Tn) ifac[i] = 1LL * ifac[i-1] * inv[i] % P;\n     \n    f[0][0] = 1;\n    F(i, 1, n) {\n        memset(g, 0, sizeof g);\n        D(j, i-1, 0) g[j] = (g[j+1] + f[i-1][j]) % P;\n        D(j, i, 1) \n            f[i][j] = 1LL * g[j-1] * G((i-1)*K-(j-1), K-2) % P;\n    }\n     \n    int ans = 0;\n    F(j, 0, n) ans = (ans + f[n][j]) % P;\n    ans = 1LL * ans * fac[n] % P;\n    printf(\"%d\\n\", ans);\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define mod 1000000007\nusing namespace std;\nint n,K,m;\nint f[2002][2002];\nint fac[4000010],inv[4000010];\nint quick_pow(int x,int p)\n{\n    int an=1,po=x;\n    while(p)\n    {\n        if(p&1)  an=1ll*an*po%mod;\n        po=1ll*po*po%mod;\n        p>>=1;\n    }\n    return an;\n}\nint C(int x,int y)\n{\n    if(x<y)  return 0;\n    return 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main()\n{\n    fac[0]=1;\n    for(int i=1;i<=4000000;i++)  fac[i]=1ll*fac[i-1]*i%mod;\n    inv[4000000]=quick_pow(fac[4000000],mod-2);\n    for(int i=3999999;i>=0;i--)   inv[i]=1ll*inv[i+1]*(i+1)%mod;\n    cin>>n>>K;\n    if(K==1)\n    {\n        puts(\"1\");\n        return 0;\n    }\n    m=n*K;\n    f[0][0]=1;\n    for(int i=0;i<=n;i++)\n    {\n        for(int j=0;j<=i;j++)\n        {\n            if(i)  f[i][j]=f[i-1][j];\n            if(j)  f[i][j]=(f[i][j]+1ll*C(m-(j-1)*(K-1)-i-1,K-2)*f[i][j-1]%mod)%mod;\n        }\n    }\n    int ans=1ll*f[n][n]*fac[n]%mod;\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\nusing namespace std;\nconst long long Mod=1000000007;\nint n,k;\nlong long fac[4000010],inv[4000010],f[2010][2010],s[2010];\nlong long pw(long long x,long long y)\n{\n\tlong long res=1;\n\twhile (y)\n\t{\n\t\tif (y&1)\n\t\t{\n\t\t\tres=res*x%Mod;\n\t\t} \n\t\ty>>=1;\n\t\tx=x*x%Mod;\n\t}\n\treturn res;\n}\nlong long c(int n,int m)\n{\n\tif (n<m)\n\t{\n\t\treturn 0;\n\t}\n\treturn fac[n]*inv[n-m]%Mod*inv[m]%Mod;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tif (k==1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\tfor (int i=1;i<=n*k;i++)\n\t{\n\t\tfac[i]=fac[i-1]*i%Mod;\n\t}\n\tinv[n*k]=pw(fac[n*k],Mod-2);\n\tfor (int i=n*k-1;i>=0;i--)\n\t{\n\t\tinv[i]=inv[i+1]*(i+1)%Mod;\n\t}\n\tf[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\ts[n+1]=0;\n\t\tfor (int j=n;j>=0;j--)\n\t\t{\n\t\t\ts[j]=(s[j+1]+f[i-1][j])%Mod;\n\t\t}\n\t\tfor (int j=1;j<=i;j++)\n\t\t{\n\t\t\tf[i][j]=s[j-1]*c(i*k-j-1,k-2)%Mod;\n\t\t\t//cout<<f[i][j]<<\" \";\n\t\t}\n\t\t//cout<<endl;\n\t}\n\tlong long ans=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tans=(ans+f[n][i])%Mod;\n\t}\n\t//cout<<ans<<endl;\n\tans=ans*fac[n]%Mod;\n\tprintf(\"%lld\\n\",ans);\n    return 0;\n}\n//花开堪折直须折，莫待无花空折枝。\n//——《金缕衣》"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#define re register\n#define LL long long\n#define N 2005\n#define Maxn 4000000\nusing namespace std;\nconst int Mod=1e9+7;\nint n,k;\nLL f[N][N],fac[Maxn+5],inv_fac[Maxn+5];\ninline LL C(int n,int m){ return (((fac[m]*inv_fac[n])%Mod)*inv_fac[m-n])%Mod; }\nLL power(LL x,int P){\n\tLL ans=1,m=x;\n\twhile(P){\n\t\tif(P&1) (ans*=m)%=Mod;\n\t\tP>>=1;(m*=m)%=Mod;\n\t}\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1){ printf(\"%d\\n\",1); return 0; }\n\tfac[0]=1; for(re int i=1;i<=Maxn;++i) fac[i]=(fac[i-1]*i)%Mod;\n\tinv_fac[Maxn]=power(fac[Maxn],Mod-2); for(re int i=Maxn-1;i>=0;--i) inv_fac[i]=(inv_fac[i+1]*(i+1))%Mod;\n\tf[0][0]=1;\n\tfor(re int i=1;i<=n;++i){\n\t\tfor(re int j=0;j<=i;++j){\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(!j) continue;\n\t\t\t(f[i][j]+=f[i][j-1]*(n-j+1)%Mod*C(k-2,n-i+(n-j+1)*(k-1)-1)%Mod)%=Mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<cmath>\n#include<iostream>\n#include<queue>\n#include<string>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<long long,long long> pll;\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define rep(i,j,k)  for(register int i=(int)(j);i<=(int)(k);i++)\n#define rrep(i,j,k) for(register int i=(int)(j);i>=(int)(k);i--)\n\nll read(){\n\tll x=0,f=1;char c=getchar();\n\twhile(c<'0' || c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0' && c<='9'){x=x*10+c-'0';c=getchar();}\n\treturn x*f;\n}\n\nconst int mod=1e9+7;\nconst int maxn=5050;\nint n,k;\nll f[maxn][maxn];\nll fac[maxn*maxn],inv[maxn*maxn];\n\ninline int C(int x,int y){\n\tif(x<y) return 0;\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\n\nint main(){\n\tn=read(),k=read();\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\trep(i,1,5000*4000) fac[i]=fac[i-1]*i%mod;\n\tinv[0]=inv[1]=1;\n\trep(i,2,5000*4000) inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\trep(i,1,5000*4000) inv[i]=inv[i]*inv[i-1]%mod;\n\tf[0][0]=1;\n\trep(i,1,n){\n\t\trrep(j,i,0){\n\t\t\tf[i][j]=f[i][j+1]%mod;\n\t\t\tif(j){\n\t\t\t\tf[i][j]+=f[i-1][j-1]*C(i*k-j-1,k-2)%mod;\n\t\t\t\tf[i][j]%=mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<f[n][0]*fac[n]%mod;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=2010,p=1e9+7;\nint inc(int x,int y){x+=y;return x>=p?x-p:x;}\nint mul(int x,int y){return (ll)x*y%p;}\nint power(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=mul(x,x))\n\t\tif (y&1) ans=mul(ans,x);\n\treturn ans;\n}\nint n,k,dp[N][N],fac[N*N],ifac[N*N];\nint C(int n,int m){\n\treturn mul(fac[n],mul(ifac[m],ifac[n-m]));\n}\nint main()\n{\n\tcin>>n>>k;\n\tif (k==1) return puts(\"1\"),0;\n\tfac[0]=1;\n\tfor (int i=1;i<=n*k;i++) fac[i]=mul(fac[i-1],i);\n\tifac[n*k]=power(fac[n*k],p-2);\n\tfor (int i=n*k;i;i--) ifac[i-1]=mul(ifac[i],i);\n\tdp[0][0]=1;\n\tfor (int i=0;i<=n;i++)\n\tfor (int j=0;j<=n;j++){\n\t\tif (i) dp[i][j]=inc(dp[i][j],dp[i-1][j]);\n\t\tif (i!=j&&j) dp[i][j]=inc(dp[i][j],mul(dp[i][j-1],C(i+j*(k-1)-1,k-2)));\n\t}\n\tprintf(\"%d\\n\",mul(fac[n],dp[n][n]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N=2100,mod=1000000007;\nint n,K;\nint jc[N*N],njc[N*N],f[N][N];\nint qpow(int x,int y)\n{\n\tint ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ret=(ll)ret*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}\n\treturn ret;\n}\nvoid init()\n{\n\tjc[0]=njc[0]=1;\n\tfor(int i=1;i<=n*K;i++)jc[i]=(ll)jc[i-1]*i%mod;\n\tnjc[n*K]=qpow(jc[n*K],mod-2);\n\tfor(int i=n*K-1;i>=1;i--)njc[i]=(ll)njc[i+1]*(i+1)%mod;\n}\nint C(int x,int y){return (ll)jc[x]*njc[y]%mod*njc[x-y]%mod;}\nint main()\n{\n\t//freopen(\"tt.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&K);\n\tif(K==1)return puts(\"1\"),0;\n\tinit();\n\tf[0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=i;j<=n;j++)\n\t\t{\n\t\t\tif(i<j)(f[i+1][j]+=f[i][j])%=mod;\n\t\t\tif(j!=n)(f[i][j+1]+=(ll)f[i][j]*C((K-1)*(j+1)+i-1,K-2)%mod)%=mod;\n\t\t}\n\tprintf(\"%d\\n\",(ll)f[n][n]*jc[n]%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "                                // ALLAH \\\\\n                        who is Hussain? -> whoishussain.org\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,n,a) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define aLL(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long LL;\ntypedef pair<int,int> PII;\nconst int mod=1000000007;\nLL powmod(LL a,LL b) {LL res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nint in(){ int x; scanf(\"%d\",&x); return x; }\nconst int N = 1e6+100;\nint n, k, fact[N];\nint C(int n, int nn){\n        return 1ll*fact[n]*powmod(fact[nn],mod-2)%mod * powmod(fact[n-nn],mod-2)%mod;\n}\nint32_t main(){\n        cin >>n >> k;\n        int ans = 1;\n        fact[0] = 1;\n        for(int i = 1; i < N; i++)\n                fact[i] = 1ll*fact[i-1]*i%mod;\n        for(int i = 0;i < n;i ++)\n                ans = 1ll * ans * C(k+i*k,i*k) %mod; \n        cout << ans << endl;\n}\n\n// C/C++ File\n// AUTHOR:   truth-seeker\n// FILE:     le.cpp\n// ROLE:     TODO (some explanation)\n// CREATED:  2017-01-20 16:56:08\n// MODIFIED: 2017-01-20 16:56:08\n"
  },
  {
    "language": "C++",
    "code": "//AtCoder-agc002F\n#include <cstdio>\n#define rg register\n\nconst int N=2018,M=N*N,p=998244353;\nint inv[M],fac[M],f[N][N];\nint n,m;\n\ntemplate <typename _Tp> inline void pls(_Tp&A,_Tp B){A=A+B<p?A+B:A+B-p;}\n\ninline int qpow(int A,int B){\n\tint res(1);while(B){\n\t\tif(B&1)res=1ll*res*A%p;\n\t\tA=1ll*A*A%p;B>>=1;\n\t}return res;\n}\n\nvoid prework(){\n\tinv[0]=inv[1]=fac[0]=fac[1]=1;\n\tfor(rg int i=2;i<M;++i)fac[i]=1ll*fac[i-1]*i%p;\n\tinv[M-1]=qpow(fac[M-1],p-2);\n\tfor(rg int i=M-2;i;--i)inv[i]=1ll*inv[i+1]*(i+1)%p;\n}\n\ninline int c(int nn,int mm){return 1ll*fac[nn]*inv[mm]%p*inv[nn-mm]%p;}\n\nint main(){\n\tprework();scanf(\"%d%d\",&n,&m);\n\tif(m==1){puts(\"1\");return 0;}\n\tf[0][0]=1;\n\tfor(rg int i=1;i<=n;++i){\n\t\tpls(f[i][0],(int)(1ll*f[i-1][0]*c(i*m-i-1,m-2)%p));\n\t\tfor(rg int j=1;j<=i;++j){\n\t\t\tf[i][j]=f[i][j-1];\n\t\t\tpls(f[i][j],(int)(1ll*f[i-1][j]*c(i*m+j-i-1,m-2)%p));\n\t\t}\n\t}printf(\"%lld\\n\",1ll*f[n][n]*fac[n]%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int __SIZE = 1 << 18;\nchar ibuf[__SIZE], *iS, *iT;\n\n#define ge (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n#define ri read_int()\n#define rl read_ll()\n#define FILE(s) freopen(s\"in\", \"r\", stdin), freopen(s\"out\", \"w\", stdout)\n\ntemplate<typename T>\ninline void read(T &x) {\n\tchar ch, t = 0; x = 0;\n\twhile(!isdigit(ch = ge)) t |= ch == '-';\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = ge;\n\tx = t ? -x : x;\n}\ninline int read_int() { int x; return read(x), x; }\ninline ll read_ll() { ll x; return read(x), x; }\n\ntemplate<typename T>\ninline void chkmin(T&a, T b) { a = a < b ? a : b; }\n\nconst int MAXN = 2010;\nconst int mod = 1e9 + 7;\n\ninline int ksm(int x, int k = mod - 2) {\n\tint s = 1;\n\twhile(k) {\n\t\tif(k & 1) s = 1LL * s * x % mod;\n\t\tx = 1LL * x * x % mod, k >>= 1;\n\t} return s;\n}\n\nint fac[MAXN * MAXN];\nint ifac[MAXN * MAXN];\nint f[MAXN][MAXN];\n\ninline void init(int n) {\n\tfac[0] = 1;\n\tfor(int i = 1; i <= n; i++) fac[i] = 1LL * fac[i - 1] * i % mod;\n\tifac[n] = ksm(fac[n]);\n\tfor(int i = n; i >= 1; i--) ifac[i - 1] = 1LL * ifac[i] * i % mod;\n}\n\ninline int C(int n, int m) {\n\treturn 1LL * fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nint main() {\n#ifdef LOCAL\n\tFILE(\"\");\n#endif\n\n\tint n = ri, k = ri, N = n * k;\n\tinit(N);\n\n\tif(k == 1) return puts(\"1\"), 0;\n\n\tfor(int i = 0; i <= n; i++) f[i][0] = 1;\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 0; j <= i; j++)\n\t\t\tif(j) f[i][j] = (f[i - 1][j] + 1LL * f[i][j - 1] * C(N - i - (j - 1) * (k - 1) - 1, k - 2)) % mod;\n\t\t\telse f[i][j] = f[i - 1][j];\n\n\tprintf(\"%lld\\n\", 1LL * f[n][n] * fac[n] % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=2005,mod=1e9+7;\nint n,k;\nint Fac[N*N],Inv[N*N],dp[N][N];\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=1LL*x*x%mod)\n\t\tif (y&1)\n\t\t\tans=1LL*ans*x%mod;\n\treturn ans;\n}\nint C(int n,int m){\n\tif (m<0||m>n)\n\t\treturn 0;\n\treturn 1LL*Fac[n]*Inv[m]%mod*Inv[n-m]%mod;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tif (k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor (int i=Fac[0]=Inv[0]=1;i<=n*k;i++){\n\t\tFac[i]=1LL*Fac[i-1]*i%mod;\n\t\tInv[i]=1LL*Inv[i-1]*Pow(i,mod-2)%mod;\n\t}\n\tdp[0][0]=1;\n\tfor (int i=0;i<=n;i++)\n\t\tfor (int j=i;j<=n;j++){\n\t\t\tdp[i][j+1]=(dp[i][j+1]+dp[i][j])%mod;\n\t\t\tdp[i+1][j]=(1LL*dp[i][j]*C(k*(n-i)-(j-i)-1,k-2)+dp[i+1][j])%mod;\n\t\t}\n\tprintf(\"%lld\",1LL*dp[n][n]*Fac[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Leftmost Ball\n// * frank_c1\n// * 2017 / 09 / 29\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nLL pow_mod(LL b, LL p, LL k) {\n\tLL ret = 1;\n\tfor (; p; p >>= 1) {\n\t\tif (p & 1) ret = ret * b % k;\n\t\tb = b * b % k;\n\t} return ret;\n}\n\nconst int maxn = 3005;\nconst int mo = (int)(1e9) + 7;\nLL fac[maxn * maxn], ivf[maxn * maxn];\nint f[maxn][maxn];\n\ninline LL C(int n, int m) {\n\tif (m < 0 || n - m < 0) return 0;\n\treturn (fac[n] * ivf[m] % mo) * ivf[n - m] % mo;\n}\n\ninline void add(int& x, int v) {\n\tx += v; if (x >= mo) x -= mo;\n}\n\nint main() {\n\tint n, K;\n\tscanf(\"%d%d\", &n, &K);\n\tif (K == 1) return printf(\"1\\n\"), 0;\n\tint mx = n * (K + 1);\n\tfac[0] = ivf[0] = 1;\n\tfor (int i = 1; i <= mx; ++i) fac[i] = fac[i - 1] * i % mo;\n\tivf[mx] = pow_mod(fac[mx], mo - 2, mo);\n\tfor (int i = mx - 1; i >= 1; --i) ivf[i] = ivf[i + 1] * (i + 1) % mo;\n\tf[0][0] = 1;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\tif (i < j) add(f[i + 1][j], f[i][j]);\n\t\t\tif (j < n) add(f[i][j + 1], 1LL * f[i][j] * C(i + (j + 1) * (K - 1) - 1, K - 2) % mo);\n\t\t}\n\t} int ret = f[n][n];\n\tfor (int i = 1; i <= n; ++i) ret = 1LL * ret * i % mo;\n\treturn printf(\"%d\\n\", ret), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"inline\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-fipa-sra\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-ffast-math\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fdevirtualize\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"inline-functions\")\n#pragma GCC optimize(\"-ftree-tail-merge\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fpartial-inlining\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-fhoist-adjacent-loads\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"inline-small-functions\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"inline-functions-called-once\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#include <bits/stdc++.h>\nusing namespace std;\nconst int Mod=1e9+7,N=2005,Maxn=4000000;\nint n,k;\nlong long dp[N][N],f[Maxn+5],i_f[Maxn+5];\ninline long long C(int n,int m)\n{\n  return (((f[m]*i_f[n])%Mod)*i_f[m-n])%Mod;\n}\nlong long power(long long x,int P)\n{\n  long long ans=1,m=x;\n  while(P)\n  {\n    if(P&1) (ans*=m)%=Mod;\n    P>>=1;\n    (m*=m)%=Mod;\n  }\n  return ans;\n}\nint main()\n{\n  scanf(\"%d%d\",&n,&k),f[0]=1;\n  if(k==1)return puts(\"1\"),0;\n  for(int i=1; i<=Maxn; ++i) f[i]=(f[i-1]*i)%Mod;\n  i_f[Maxn]=power(f[Maxn],Mod-2);\n  for(int i=Maxn-1; i>=0; --i) i_f[i]=(i_f[i+1]*(i+1))%Mod;\n  dp[0][0]=1;\n  for(int i=1; i<=n; ++i)\n  {\n    for(int j=0; j<=i; ++j)\n    {\n      dp[i][j]=dp[i-1][j];\n      if(!j) continue;\n      (dp[i][j]+=dp[i][j-1]*(n-j+1)%Mod*C(k-2,n-i+(n-j+1)*(k-1)-1)%Mod)%=Mod;\n    }\n  }\n  return printf(\"%lld\\n\",dp[n][n]),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int mod=1e9+7;\nlong long f[2010],inv[2010],dp[2010][2010];\nint n,K;\nint ADD(int x)\n{\n\treturn (x>=mod)?x-mod:x;\n}\nlong long calc(long long a,long long b,long long mod)\n{\n\tlong long ans=1,t=a;\n\tfor (;b;b>>=1)\n\t{\n\t\tif (b&1) ans=ans*t%mod;\n\t\tt=t*t%mod;\n\t}\n\treturn ans;\n}\nlong long C(int n,int m)\n{\n\treturn f[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&K);\n\tif (K==1)\n\t{\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tf[0]=1;\n\tfor (int i=1;i<=n*K;i++) f[i]=f[i-1]*i%mod;\n\tinv[n*K]=calc(f[n*K],mod-2,mod);\n\tinv[0]=1;\n\tfor (int i=n*K-1;i>=1;i--) inv[i]=inv[i+1]*(i+1);\n\tdp[0][0]=1;\n\tfor (int i=0;i<=n;i++)\n\t\tfor (int j=0;j<=i;j++)\n\t\t{\n\t\t\tif (i!=0) dp[i][j]=dp[i-1][j];\n\t\t\tif (j!=0) dp[i][j]=ADD(dp[i][j]+dp[i][j-1]*C(n*K-i-(j-1)*(K-1)-1,K-2)%mod);\n\t\t}\n\tprintf(\"%lld\\n\",dp[n][n]*f[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nint n,k,ni[4000001],jie[4000001],m,dp[2001][2001],mo;\nlong long mi(long long aa,long long bb)\n{\n\tlong long s=1;\n\twhile(bb!=0)\n\t{\n\t\tif((bb%2)==1) s=(s*aa)%mo;\n\t\taa=(aa*aa)%mo;\n\t\tbb=bb/2;\n\t}\n\treturn(s);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tmo=1000000007;\n\tm=n*k;\n\tjie[0]=1;\n\tfor(int i=1;i<=m;i++)jie[i]=(1ll*jie[i-1]*i)%mo;\n\tni[m]=mi(jie[m],mo-2);\n\tfor(int i=m;i>=1;i--)ni[i-1]=(1ll*ni[i]*i)%mo;\n\tdp[0][0]=1;\n\tif(k==1) printf(\"1\\n\");\n\telse\n\t{\n\t\tk=k-2;\n\t\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tif(i!=j) dp[i][j+1]=(dp[i][j+1]+1ll*(n-j)*((((1ll*jie[m-j*k-j-1-i]*ni[m-j*k-j-1-k-i])%mo)*((1ll*ni[k]*dp[i][j])%mo))%mo))%mo;\n\t\t\tif(i<n)dp[i+1][j]=(dp[i+1][j]+dp[i][j])%mo;\n\t\t}\n\t\tprintf(\"%d\\n\",dp[n][n]); \n\t}\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int mod = 1e9 + 7;\nconst int MAXN = 2005, MAXS = MAXN * MAXN;\n\ntemplate<typename _T>\nvoid read( _T &x )\n{\n\tx = 0;char s = getchar();int f = 1;\n\twhile( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}\n\twhile( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}\n\tx *= f;\n}\n\ntemplate<typename _T>\nvoid write( _T x )\n{\n\tif( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }\n\tif( 9 < x ){ write( x / 10 ); }\n\tputchar( x % 10 + '0' );\n}\n\nint f[MAXN][MAXN];\nint fac[MAXS], ifac[MAXS];\nint N, K;\n\nint qkpow( int, int );\nint inv( const int a ) { return qkpow( a, mod - 2 ); }\nvoid sub( int &x, const int v ) { x = ( x < v ? x - v + mod : x - v ); }\nvoid add( int &x, const int v ) { x = ( x + v >= mod ? x + v - mod : x + v ); }\n\nint qkpow( int base, int indx )\n{\n\tint ret = 1;\n\twhile( indx )\n\t{\n\t\tif( indx & 1 ) ret = 1ll * ret * base % mod;\n\t\tbase = 1ll * base * base % mod, indx >>= 1;\n\t}\n\treturn ret;\n}\n\nvoid init( const int siz )\n{\n\tfac[0] = ifac[0] = 1;\n\tfor( int i = 1 ; i <= siz ; i ++ ) fac[i] = 1ll * fac[i - 1] * i % mod;\n\tifac[siz] = inv( fac[siz] );\n\tfor( int i = siz - 1 ; ~ i ; i -- ) ifac[i] = 1ll * ifac[i + 1] * ( i + 1 ) % mod;\n}\n\nint C( const int n, const int m ) { return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod; }\n\nint main()\n{\n\tread( N ), read( K );\n\tif( K == 1 ) { puts( \"1\" ); return 0; }\n\tinit( N * K );\n\tfor( int i = 0 ; i <= K ; i ++ ) f[i][0] = 1;\n\tfor( int i = 1 ; i <= K ; i ++ )\n\t\tfor( int j = 1 ; j <= i ; j ++ )\n\t\t{\n\t\t\tf[i][j] = f[i - 1][j];\n\t\t\tint t = N * K - i - ( K - 1 ) * ( j - 1 ) - 1;\n\t\t\tadd( f[i][j], 1ll * f[i][j - 1] * ( N - j + 1 ) % mod * C( t, K - 2 ) % mod );\n\t\t}\n\twrite( f[N][N] ), putchar( '\\n' );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define N 2010\n#define mod 1000000007\nint n,k,f[N*N],inv[N*N],a[N][N];\ninline int C(int x,int y){\n\treturn 1ll*f[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main(){\n//\tfreopen(\"a.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&k);if(k==1){puts(\"1\");return 0;}\n\tf[0]=f[1]=1;for(int i=2;i<=n*k;++i) f[i]=1ll*f[i-1]*i%mod;\n\tinv[0]=inv[1]=1;for(int i=2;i<=n*k;++i) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=2;i<=n*k;++i) inv[i]=1ll*inv[i-1]*inv[i]%mod;\n\ta[0][0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=0;j<=i;++j){\n\t\t\ta[i][j]=a[i-1][j];\n\t\t\tif(j) a[i][j]=(a[i][j]+1ll*(n-j+1)*C(n-i+(n-j+1)*(k-1)-1,k-2)%mod*a[i][j-1]%mod)%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",a[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pdd pair<double,double>\n#define X first\n#define Y second\n#define REP(i,a) for(int i=0;i<a;++i)\n#define REPP(i,a,b) for(int i=a;i<b;++i)\n#define FILL(a,x) memset(a,x,sizeof(a))\n#define\tforeach( gg,itit )\tfor( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )\n#define\tmp make_pair\n#define\tpb push_back\n#define sz(a) int((a).size())\n#define all(a)  a.begin(), a.end()\n#define\tdebug(ccc)\tcout << #ccc << \" = \" << ccc << endl;\n#define present(c,x) ((c).find(x) != (c).end())\nconst double eps = 1e-8;\n#define EQ(a,b) (fabs((a)-(b))<eps)\ninline int max(int a,int b){return a<b?b:a;}\ninline int min(int a,int b){return a>b?b:a;}\ninline ll max(ll a,ll b){return a<b?b:a;}\ninline ll min(ll a,ll b){return a>b?b:a;}\nconst int mod = 1e9+7;\nconst int N = 4e6+10;\nconst ll inf = 1e18;\n\nll power(ll a,ll n){\n\tif(n==0){\n\t\treturn 1;\n\t}\n\tll b = power(a,n/2);\n\tb = b*b%mod;\n\tif(n%2) b= b*a%mod;\n\treturn b;\n}\n\nint add(int a,int b){ return (a+b)%mod;}\nint mul(int a,int b){ return (ll)a*b%mod;}\n\nint n,k;\nll dp[2010][2010],F[N], inv[N];\n\nll nCk(int n,int k){\n\tif(k>n)\treturn 0;\n\treturn F[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nll f(int i,int j){\n\tif(i==n && j==n)\treturn 1;\n\tll &ret = dp[i][j];\n\tif(ret!=-1) return ret;\n\tret = 0;\n\tif(i!=n){\n\t\tret = f(i+1,j);\n\t}\n\tif(i>j){\n\t\tret = (ret+ (n-j)*f(i,j+1)%mod*nCk(n*k-i-j*(k-1)-1,k-2))%mod;\n\t\t// printf(\"%d %d %lld\\n\",n*k-i-j*(k-1)-1,k-2,nCk(n*k-i-j*(k-1)-1,k-2));\n\t}\n\treturn ret;\n}\n\n\nint main(){\n // \tfreopen(\"nice.in\",\"r\",stdin);\n // freopen(\"nice.out\",\"w\",stdout);\n\tscanf(\"%d %d\",&n,&k);\n\tif(k==1){\n\t\tprintf(\"1\\n\");return 0;\n\t}\n\tFILL(dp,-1);\n\tF[0] = inv[0] = 1;\n\tREPP(i,1,N) F[i] = F[i-1]*i%mod;\n\tinv[N-1] = power(F[N-1],mod-2);\n\tfor(int i=N-2;i>=1;i--){\n\t\tinv[i] = inv[i+1]*(i+1)%mod;\n\t\tassert(inv[i]*F[i]%mod==1);\n\t}\n\tprintf(\"%lld\\n\",f(0,0));\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Define\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\ntemplate <class T> using pvector = vector<pair<T, T>>;\ntemplate <class T>\nusing rpriority_queue = priority_queue<T, vector<T>, greater<T>>;\nconstexpr const ll dx[4] = {1, 0, -1, 0};\nconstexpr const ll dy[4] = {0, 1, 0, -1};\nconstexpr const ll MOD = 1e9 + 7;\nconstexpr const ll mod = 998244353;\nconstexpr const ll INF = 1LL << 60;\nconstexpr const ll inf = 1 << 30;\nconstexpr const char rt = '\\n';\nconstexpr const char sp = ' ';\n#define rt(i, n) (i == (ll)(n) -1 ? rt : sp)\n#define len(x) ((ll)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define ifn(x) if (not(x))\n#define elif else if\n#define elifn else ifn\n#define fi first\n#define se second\n#define uniq(x) (sort(all(x)), (x).erase(unique(all(x)), (x).end()))\n\nusing graph = vector<vector<ll>>;\ntemplate <class T> using wgraph = vector<vector<ll, T>>;\nbool __DIRECTED__ = true;\nistream &operator>>(istream &is, graph &g) {\n    ll a, b;\n    is >> a >> b;\n    g[a - 1].pb(b - 1);\n    if (__DIRECTED__ == false) g[b - 1].pb(a - 1);\n    return is;\n}\ntemplate <class T> istream &operator>>(istream &is, wgraph<T> &g) {\n    ll a, b;\n    T c;\n    is >> a >> b >> c;\n    g[a - 1].pb({b - 1, c});\n    if (__DIRECTED__ == false) g[b - 1].pb({a - 1, c});\n    return is;\n}\n\ntemplate <class T> bool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\n// Debug\n#define debug(...)                                                             \\\n    {                                                                          \\\n        cerr << __LINE__ << \": \" << #__VA_ARGS__ << \" = \";                     \\\n        for (auto &&X : {__VA_ARGS__}) cerr << \"[\" << X << \"] \";               \\\n        cerr << rt;                                                            \\\n    }\n\n#define dump(a, h, w)                                                          \\\n    {                                                                          \\\n        cerr << __LINE__ << \": \" << #a << \" = [\" << rt;                        \\\n        rep(_i, h) {                                                           \\\n            rep(_j, w) {                                                       \\\n                if (abs(a[_i][_j]) >= INF / 2 and a[_i][_j] <= -INF / 2)       \\\n                    cerr << '-';                                               \\\n                if (abs(a[_i][_j]) >= INF / 2)                                 \\\n                    cerr << \"∞\" << sp;                                         \\\n                else                                                           \\\n                    cerr << a[_i][_j] << sp;                                   \\\n            }                                                                  \\\n            cerr << rt;                                                        \\\n        }                                                                      \\\n        cerr << \"]\" << rt;                                                     \\\n    }\n\n#define vdump(a, n)                                                            \\\n    {                                                                          \\\n        cerr << __LINE__ << \": \" << #a << \" = [\";                              \\\n        rep(_i, n) {                                                           \\\n            if (_i) cerr << sp;                                                \\\n            if (abs(a[_i]) >= INF / 2 and a[_i] <= -INF / 2) cerr << '-';      \\\n            if (abs(a[_i]) >= INF / 2)                                         \\\n                cerr << \"∞\" << sp;                                             \\\n            else                                                               \\\n                cerr << a[_i];                                                 \\\n        }                                                                      \\\n        cerr << \"]\" << rt;                                                     \\\n    }\n\n// Loop\n#define inc(i, a, n) for (ll i = (a), _##i = (n); i <= _##i; ++i)\n#define dec(i, a, n) for (ll i = (a), _##i = (n); i >= _##i; --i)\n#define rep(i, n) for (ll i = 0, _##i = (n); i < _##i; ++i)\n#define each(i, a) for (auto &&i : a)\n\n// Stream\n#define fout(n) cout << fixed << setprecision(n)\nstruct io {\n    io() { cin.tie(nullptr), ios::sync_with_stdio(false); }\n} io;\n\n// Speed\n#pragma GCC optimize(\"Ofast,unroll-loops\")\n#pragma GCC target(                                                            \\\n    \"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native,arch=skylake-avx512\")\n\n// Math\ninline constexpr ll gcd(const ll a, const ll b) {\n    return b ? gcd(b, a % b) : a;\n}\ninline constexpr ll lcm(const ll a, const ll b) { return a / gcd(a, b) * b; }\n\ninline constexpr ll modulo(const ll n, const ll m = MOD) {\n    ll k = n % m;\n    return k + m * (k < 0);\n}\ninline constexpr ll chmod(ll &n, const ll m = MOD) {\n    n %= m;\n    return n += m * (n < 0);\n}\ninline constexpr ll mpow(ll a, ll n, const ll m = MOD) {\n    ll r = 1;\n    rep(i, 64) {\n        if (n & (1LL << i)) r *= a;\n        chmod(r, m);\n        a *= a;\n        chmod(a, m);\n    }\n    return r;\n}\ninline ll inv(const ll n, const ll m = MOD) {\n    ll a = n, b = m, x = 1, y = 0;\n    while (b) {\n        ll t = a / b;\n        a -= t * b;\n        swap(a, b);\n        x -= t * y;\n        swap(x, y);\n    }\n    return modulo(x, m);\n}\n\nconst ll mo = 1e9 + 7;\nstruct mint {\n    ll x;\n    mint(ll x = 0) : x((x % mo + mo) % mo) {}\n    mint operator-() const { return mint(-x); }\n    mint &operator+=(const mint &a) {\n        if ((x += a.x) >= mo) x -= mo;\n        return *this;\n    }\n    mint &operator-=(const mint &a) {\n        if ((x += mo - a.x) >= mo) x -= mo;\n        return *this;\n    }\n    mint &operator*=(const mint &a) {\n        (x *= a.x) %= mo;\n        return *this;\n    }\n    mint operator+(const mint &a) const { return mint(*this) += a; }\n    mint operator-(const mint &a) const { return mint(*this) -= a; }\n    mint operator*(const mint &a) const { return mint(*this) *= a; }\n    bool operator==(const mint &a) const { return x == a.x; }\n    bool operator!=(const mint &a) const { return x != a.x; }\n    bool operator<=(const mint &a) { return x <= a.x; }\n    bool operator<(const mint &a) { return x < a.x; }\n    friend ll abs(const mint &a) { return a.x; }\n\n    friend mint pow(const mint &a, ll n) {\n        if (!n) return 1;\n        mint b = pow(a, n >> 1);\n        b *= b;\n        if (n & 1) b *= a;\n        return b;\n    }\n\n    mint inv() const { return pow(*this, mo - 2); }\n    mint &operator/=(mint a) { return (*this) *= a.inv(); }\n    mint operator/(mint a) const { return mint(*this) /= a; }\n\n    friend istream &operator>>(istream &is, mint &a) {\n        ll t;\n        is >> t;\n        a = mint(t);\n        return is;\n    }\n    friend ostream &operator<<(ostream &os, mint a) {\n        os << a.x;\n        return os;\n    }\n};\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wliteral-suffix\"\nmint operator\"\" M(const ull n) { return mint(n); }\n#pragma GCC diagnostic pop\n\nstruct modmath {\n    vector<mint> fac, inv;\n\n    modmath(ll n = 1 << 20) : fac(n + 1), inv(n + 1) {\n        fac[0] = 1;\n        rep(i, n) fac[i + 1] = fac[i] * (i + 1);\n        inv[n] = fac[n].inv();\n        dec(i, n - 1, 0) inv[i] = inv[i + 1] * (i + 1);\n    }\n\n    mint F(ll n) {\n        if (n < 0) return 0;\n        return fac[n];\n    }\n    mint P(ll n, ll r) {\n        if (r < 0 || n < r || n < 0) return 0;\n        return fac[n] * inv[n - r];\n    }\n    mint C(ll n, ll r) {\n        if (r < 0 || n < r || n < 0) return 0;\n        return fac[n] * inv[r] * inv[n - r];\n    }\n    mint c(ll n) {\n        if (n < 0) return 0;\n        return fac[2 * n] * inv[n] * inv[n + 1];\n    }\n    mint H(ll n, ll r) { return C(n + r - 1, n - 1); }\n} math(4000000);\n\nmint DP[2001][2001];\nsigned main() {\n    ll N, K;\n    cin >> N >> K;\n    if (K == 1) {\n        cout << 1 << rt;\n        return 0;\n    }\n\n    DP[0][0] = 1;\n    rep(i, N + 1) rep(j, N + 1) {\n        if (i != N) {\n            DP[i + 1][j] += DP[i][j];\n        }\n        if (j != N and i > j) {\n            DP[i][j + 1] +=\n                DP[i][j] *\n                math.C((K - 1) * (N - j - 1) + (N - i) + K - 2, K - 2);\n        }\n    }\n    cout << DP[N][N] * math.F(N) << rt;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define LL long long\n#define N 2200\n\nconst LL mod=1000000007;\nLL n,m,ans,f[N][N],fac[N*N],ifac[N*N];\n\nLL inv(LL x){return x==1?1:(mod-mod/x)*inv(mod%x)%mod;}\n\nLL C(LL x,LL y){\n\treturn fac[x]*ifac[y]%mod*ifac[x-y]%mod;\n}\n\nint main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tfac[0]=1; for (LL i=1;i<=n*m;++i) fac[i]=fac[i-1]*i%mod;\n\tifac[n*m]=inv(fac[n*m]); for (LL i=n*m-1;i>=0;--i) ifac[i]=ifac[i+1]*(i+1)%mod;\n\tif (m==1){puts(\"1\"); return 0;}\n\tf[0][0]=1;\n\tfor (LL i=1;i<=n;++i){\n\t\tf[i][0]=1;\n\t\tfor (LL j=1;j<i;++j)\n\t\t\tf[i][j]=(f[i][j-1]*C(n-i+(n-j+1)*(m-1)-1,m-2)+f[i-1][j])%mod;\n\t\tf[i][i]=f[i][i-1]*C(n-i+(n-i+1)*(m-1)-1,m-2)%mod;\n\t}\n\tans=f[n][n]*fac[n]%mod;\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1e9 + 7;\nll dp[2010][2010] , jc[5000010];\nll Pow(ll x , ll y)\n{\n\tll res = 1;\n\twhile (y)\n\t{\n\t\tif (y & 1)\n\t\t{\n\t\t\tres *= x;\n\t\t\tres %= mod;\n\t\t}\n\t\tx *= x;\n\t\tx %= mod;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\nll getc(int n , int r)\n{\n\treturn (jc[n] * Pow(jc[n - r] * jc[r] % mod , mod - 2)) % mod;\n}\nint main()\n{\n\tint n , k;\n\tscanf(\"%d%d\" , &n , &k);\n\tjc[0] = 1;\n\tfor (int i = 1; i <= 5000000; i++)\n\t{\n\t\tjc[i] = (jc[i - 1] * i) % mod;\n\t}\n\tif (k == 1)\n\t{\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tdp[i][0] = 1;\n\t\tfor (int j = 1; j <= i; j++)\n\t\t{\n\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\tdp[i][j] += dp[i][j - 1] * (n - j + 1) % mod\n\t\t\t* getc((n - j + 1) * (k - 1) + n - i - 1 , k - 2) % mod;\n\t\t\tdp[i][j] %= mod;\n\t\t\t//cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\" , dp[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define rep(i,s,t) for(register int i=s;i<=t;++i)\n#define _rep(i,s,t) for(register int i=s;i>=t;--i)\nusing namespace std;\nconst int N=2011,mod=1e9+7;\nint fac[N*N],ifac[N*N];\nint n,m;\ninline int C(int n,int m){\n\tif(n<0||m<0||n<m)return 0;\n\treturn 1ll*fac[n]*ifac[n-m]%mod*ifac[m]%mod;\n}\nint f[N][N];\ninline int fp(int a,int b){\n\tint res=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1)\n\t\t\tres=1ll*res*a%mod;\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tif(m==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\trep(i,1,4000000)\n\t\tfac[i]=1ll*i*fac[i-1]%mod;\n\tifac[4000000]=fp(fac[4000000],mod-2);\n\t_rep(i,4000000,1)\n\t\tifac[i-1]=1ll*i*ifac[i]%mod;\n\tf[0][0]=1;\n\trep(i,1,n)\n\t\trep(j,0,i){\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(j)f[i][j]=(f[i][j]+1ll*f[i][j-1]*(n-j+1)%mod*C(n-i+(n-j+1)*(m-1)-1,m-2))%mod;\n\t\t}\n\tprintf(\"%d\\n\",f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#include <tr1/unordered_map>\nusing namespace std;\n#define ll long long\n#define re register\n#define pb push_back\n#define fi first\n#define se second\nconst int N=4e6+10;\nconst int mod7=1e9+7;\nconst int mod=1e9+7;\nvoid read(int &a)\n{\n    a=0;int d=1;char ch;\n    while(ch=getchar(),ch>'9'||ch<'0')\n        if(ch=='-')\n            d=-1;\n    a=ch^48;\n    while(ch=getchar(),ch>='0'&&ch<='9')\n        a=(a<<3)+(a<<1)+(ch^48);\n    a*=d;\n}\nvoid read(ll &a)\n{\n    a=0;int d=1;char ch;\n    while(ch=getchar(),ch>'9'||ch<'0')\n        if(ch=='-')\n            d=-1;\n    a=ch^48;\n    while(ch=getchar(),ch>='0'&&ch<='9')\n        a=(a<<3)+(a<<1)+(ch^48);\n    a*=d;\n}\nll f[2005][2005],fac[N],ifac[N];\nll quickmod(ll x,ll y)\n{\n    ll res=1,base=x;\n    while(y)\n    {\n        if(y&1) res=res*base%mod;\n        base=base*base%mod;\n        y>>=1;\n    }\n    return res;\n}\nvoid init(int n)\n{\n    fac[0]=1;\n    for(re ll i=1;i<=n;i++) fac[i]=i*fac[i-1]%mod;\n    ifac[n]=quickmod(fac[n],mod-2);\n    for(re ll i=n-1;~i;i--) ifac[i]=ifac[i+1]*(i+1)%mod;\n}\nll C(int n,int m) {return n<m?0:((fac[n]*ifac[m]%mod)*ifac[n-m])%mod;}\nint main()\n{\n    int n,k;\n    read(n),read(k);\n    if(k==1) return puts(\"1\"),0;\n    init(4000000);\n    f[0][0]=1;\n    for(re int i=1;i<=n;i++)\n    {\n        for(re int j=0;j<=i;j++)\n        {\n            if(!j)\n            {\n                f[i][j]=f[i-1][j];\n                continue;\n            }\n            f[i][j]=f[i-1][j]+f[i][j-1]*(n-j+1)%mod*C(n*k-i-1-(j-1)*(k-1),k-2)%mod;\n            f[i][j]%=mod;\n        }\n    }\n    printf(\"%lld\\n\",f[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e3 + 10;\nconst int Mod = 1e9 + 7;\n\nint add(int a, int b) {\n  return (a += b) >= Mod ? a - Mod : a;\n}\n\nint sub(int a, int b) {\n  return (a -= b) < 0 ? a + Mod : a;\n}\n\nint mul(int a, int b) {\n  return 1ll * a * b % Mod;\n}\n\nint fast_pow(int a, int b) {\n  int res = 1;\n  for (; b; b >>= 1, a = mul(a, a)) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n  }\n  return res;\n}\n\nint n, k, f[N][N], inv[N * N], fac[N * N];\n\nvoid init(int limit) {\n  inv[0] = fac[0] = 1;\n  for (int i = 1; i <= limit; i++) {\n    fac[i] = mul(fac[i - 1], i);\n  }\n  inv[limit] = fast_pow(fac[limit], Mod - 2);\n  for (int i = limit - 1; i >= 1; i--) {\n    inv[i] = mul(inv[i + 1], i + 1);\n  }\n}\n\nint C(int a, int b) {\n  return (a >= b) ? mul(fac[a], mul(inv[b], inv[a - b])) : 0;\n}\n\nint main() {\n  scanf(\"%d %d\", &n, &k);\n  if (k == 1) {\n    puts(\"1\");\n    return 0;\n  }\n  init(n * k);\n  f[0][0] = 1;\n  for (int i = 0; i <= n; i++) {\n    for (int j = i; j <= n; j++) {\n      if (i) {\n        f[i][j] = f[i - 1][j];\n      }\n      if (j > i) {\n        f[i][j] = add(f[i][j], mul(f[i][j - 1], C(i + j * (k - 1) - 1, k - 2)));\n      }\n    }\n  }\n  printf(\"%d\\n\", mul(f[n][n], fac[n]));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\n\nconst int N = 2e3, M = 4e6, MOD = 1e9 + 7;\n\nint n, k, f[N + 5][N + 5], fac[M + 5], ifac[M + 5];\n\ninline void add(int &x, const int &y) {\n\t(x += y) >= MOD && (x -= MOD);\n}\ninline int pow(int x, int k) {\n\tint ans = 1;\n\tfor (; k > 0; k >>= 1, x = (LL)x * x % MOD) {\n\t\tif (k & 1) {\n\t\t\tans = (LL)ans * x % MOD;\n\t\t}\n\t}\n\treturn ans;\n}\ninline int inv(int x) {\n\treturn pow(x, MOD - 2);\n}\nvoid init(int n) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfac[i] = (LL)fac[i - 1] * i % MOD;\n\t}\n\tifac[n] = inv(fac[n]);\n\tfor (int i = n; i >= 1; i--) {\n\t\tifac[i - 1] = (LL)ifac[i] * i % MOD;\n\t}\n}\ninline int binom(int n, int m) {\n\treturn (LL)fac[n] * ifac[m] % MOD * ifac[n - m] % MOD;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tinit(n * k);\n\tf[0][0] = 1;\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= n && j <= i; j++) {\n\t\t\tif (i < n) {\n\t\t\t\tadd(f[i + 1][j], f[i][j]);\n\t\t\t}\n\t\t\tif (j < n) {\n\t\t\t\tadd(f[i][j + 1], (LL)f[i][j] * (n - j) % MOD * binom(n * k - i - j * (k - 1) - 1, k - 2) % MOD);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<cassert>\n#include<vector>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,a) for(int i=start[(a)];i;i=e[i].next)\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\ninline int read()\n{\n\tint sum=0,p=1;char ch=getchar();\n\twhile(!(('0'<=ch && ch<='9') || ch=='-'))ch=getchar();\n\tif(ch=='-')p=-1,ch=getchar();\n\twhile('0'<=ch && ch<='9')sum=sum*10+ch-48,ch=getchar();\n\treturn sum*p;\n}\n\nconst int maxn=2e3+20;\nconst int mod=1e9+7;\ninline void pls(int &a,int b){ a+=b;if(a>=mod)a-=mod;}\n\nint jc[maxn*maxn],jcn[maxn*maxn],inv[maxn*maxn];\n\nint n,k;\n\ninline void init()\n{\n\tn=read();k=read();\n\tif(k==1)puts(\"1\"),exit(0);\n\tjc[0]=jcn[0]=inv[1]=jcn[1]=jc[1]=1;\n\tREP(i,2,n*k)inv[i]=(ll)(mod-mod/i)*inv[mod%i]%mod,jc[i]=(ll)i*jc[i-1]%mod,jcn[i]=(ll)inv[i]*jcn[i-1]%mod;\n}\n\ninline int C(int n,int m){ return (ll)jc[n]*jcn[m]%mod*jcn[n-m]%mod;} \n\nint dp[maxn][maxn];\n\ninline void doing()\n{\n\tdp[1][0]=1;\n\tREP(i,1,n)\n\t{\n\t\tREP(j,0,i)\n\t\t{\n\t\t\tif(i<n)pls(dp[i+1][j],dp[i][j]);\n\t\t\tif(j<i)pls(dp[i][j+1],(ll)dp[i][j]*C(n*k-i-(j)*(k-1)-1,k-2)%mod*(n-j)%mod);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[n][n]);\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 2010;\nconst int MOD = 1e9 + 7;\n\nint dp[N][N], fak[N * N], inv[N * N];\nint n, k;\n\ninline int add(int A, int B){\n\tif(A + B >= MOD) return A + B - MOD;\n\treturn A + B;\n}\n\ninline int mul(int A, int B){\n\treturn (ll)A * B % MOD;\n}\n\ninline int pot(int A, int B){\n\tint ret = 1, bs = A;\n\tfor(;B;B >>= 1){\n\t\tif(B & 1) ret = mul(ret, bs);\n\t\tbs = mul(bs, bs);\n\t}\n\treturn ret;\n}\n\nvoid precompute(){\n\tfak[0] = 1, inv[0] = 1;\n\tfor(int i = 1;i < N * N;i++){\n\t\tfak[i] = mul(fak[i - 1], i);\n\t\tinv[i] = pot(fak[i], MOD - 2);\n\t}\n}\n\ninline int ch(int n, int k){\n\treturn mul(fak[n], mul(inv[k], inv[n - k]));\n}\n\n\nint f(int i,int j){\n\tif(j < i || i < 0) return 0;\n\tif(j == 0) return 1;\n\tif(dp[i][j] != -1) return dp[i][j];\n\treturn dp[i][j] = add(f(i - 1, j), mul(f(i, j - 1), ch((j - 1) * (k - 1) + k - 2 + i,k - 2)));\n}\n\nint main(){\n\tmemset(dp, -1, sizeof(dp));\n\tprecompute();\n\tscanf(\"%d%d\", &n, &k);\n\tif(k == 1)\n\t\tprintf(\"1\\n\");\n\telse\n\t\tprintf(\"%d\\n\", mul(fak[n], f(n, n)));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int N = 2e3+5, M = 4e6+5, P = 1e9+7;\nint n, m, f[N][N], fac[M], ifac[M], inv[M], ans;\nint C(int n, int m) { return 1ll*fac[n]*ifac[n-m]%P*ifac[m]%P; }\nint main()\n{\n    n = read(), m = read(); \n    inv[1] = ifac[0] = fac[0] = 1; \n    for(int i = 2; i <= n*m; ++i) inv[i] = 1ll*(P-P/i)*inv[P%i]%P;\n    for(int i = 1; i <= n*m; ++i) fac[i] = 1ll*i*fac[i-1]%P, ifac[i] = 1ll*inv[i]*ifac[i-1]%P;\n    f[0][0] = 1;\n    for(int i = 1; i <= n; ++i)\n        for(int j = 0; j <= i; ++j)\n        {\n            f[i][j] = f[i-1][j];\n            if(j) f[i][j] = (f[i][j]+1ll*f[i][j-1]*(n-j+1)%P*C(n*m-i-(j-1)*(m-1)-1, m-2)%P)%P;\n        }\n    printf(\"%d\\n\", m == 1?1:f[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define mod 1000000007\nint n,k;\nll dp[2005][2005];\nll modpow(ll x,ll n){\n\tll res=1;\n\twhile(n>0){\n\t\tif(n&1) res=res*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nll F[4000005],R[4000005];\nvoid make(){\n\tF[0] = 1;\n\tfor(int i=1;i<4000005;i++) F[i] = F[i-1]*i%mod;\n\tR[4000000] = modpow(F[4000000],mod-2);\n\tfor(int i=4000000;i>=1;i--) R[i-1] = R[i]*1LL*i%mod;\n}\nll C(int a,int b){\n\treturn F[a]*R[b]%mod*R[a-b]%mod;\n}\nint main(){\n\tcin>>n>>k; if(k==1){puts(\"1\");return 0;} make();\n\tdp[0][0] = 1;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tif(dp[i][j] == 0) continue;\n\t\t\tif(i!=n) dp[i+1][j] = (dp[i+1][j]+dp[i][j])%mod;\n\t\t\tif(i>=j+1) dp[i][j+1] = (dp[i][j+1]+dp[i][j]*C(n*k-j*(k-1)-i-1,k-2)%mod)%mod;\n\t\t}\n\t}\n\tcout<<dp[n][n]*F[n]%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define HEAP priority_queue\n#define rep(i, n) for(int i = 0, _end_ = (n); i < _end_; ++i)\n#define per(i, n) for(int i = (n) - 1; i >= 0 ; --i)\n#define forn(i, l, r) for(int i = (l), _end_ = (r); i <= _end_; ++i)\n#define nrof(i, r, l) for(int i = (r), _end_ = (l); i >= _end_; --i)\n#define FOR(a, b) for(auto (a): (b))\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-6\n#define pi 3.1415926535897932384626433832795\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef vector<LL> vl;\ntypedef pair<int,int> pii;\ntypedef pair<int,LL> pil;\ntypedef pair<LL,int> pli;\ntypedef pair<LL,LL> pll;\ntypedef vector<pil> vil;\ntypedef vector<pii> vii;\ntypedef vector<pli> vli;\ntypedef vector<pll> vll;\n\nconst int iinf = 1e9 + 7;\nconst int oo = 0x3f3f3f3f;\nconst LL linf = 1ll << 60;\nconst flt dinf = 1e60;\n\ntemplate <typename T> inline void scf(T &x) {\n\tbool f = 0;\n\tx = 0;\n\tchar c = getchar();\n\twhile(c != '-' && (c < '0' || c > '9')) c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\tif(f) x = -x;\n\treturn;\n}\n\ntemplate <typename T1, typename T2> void scf(T1 &x, T2 &y) {\n\tscf(x);\n\treturn scf(y);\n}\n\ntemplate <typename T1, typename T2, typename T3> void scf(T1 &x, T2 &y, T3 &z) {\n\tscf(x);\n\tscf(y);\n\treturn scf(z);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4> void scf(T1 &x, T2 &y, T3 &z, T4 &w) {\n\tscf(x);\n\tscf(y);\n\tscf(z);\n\treturn scf(w);\n}\n\ninline char mygetchar() {\n\tchar c = getchar();\n\twhile(c == ' ' || c == '\\n') c = getchar();\n\treturn c;\n}\n\ntemplate <typename T> inline bool chkmax(T &x, const T &y) {\n\treturn y > x ? x = y, 1 : 0;\n}\n\ntemplate <typename T> inline bool chkmin(T &x, const T &y) {\n\treturn y < x ? x = y, 1 : 0;\n}\n\n#ifdef King_George\n#define DEBUG\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\n//---------------------------------------------------------head----------------------------------------------------\n\nconst int maxn = 2010;\n\nconst int maxm = maxn * maxn;\n\nconst int mod = 1e9 + 7;\n\nint n, k;\nint dp[maxn][maxn];\nint fac[maxm], ifac[maxm];\n\nint pow_mod(int x, int n) {\n\tint y = 1;\n\twhile(n) {\n\t\tif(n & 1) {\n\t\t\ty = 1ll * y * x % mod;\n\t\t}\n\t\tx = 1ll * x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn y;\n}\n\nvoid pre() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < maxm; ++i) {\n\t\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\t}\n\tifac[maxm - 1] = pow_mod(fac[maxm - 1], mod - 2);\n\tfor (int i = maxm - 1; i >= 1; --i) {\n\t\tifac[i - 1] = 1ll * ifac[i] * i % mod;\n\t}\n\treturn;\n}\n\nint C(int n, int m) {\n\treturn (n < m || m < 0) ? 0 : 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nint main() {\n\tpre();\n\tscf(n, k);\n\tif(k == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tdp[0][0] = 1;\n\tint tmp;\n\tforn(i, 0, n) {\n\t\tforn(j, 0, n) {\n\t\t\tif(tmp = dp[i][j]) {\n\t\t\t\tif(j < i) {\n\t\t\t\t\tdp[i][j + 1] = (1ll * tmp * C((n - j) * (k - 1) + n - i - 1, k - 2) + dp[i][j + 1]) % mod;\n\t\t\t\t}\n\t\t\t\t(dp[i + 1][j] += tmp) %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", 1ll * fac[n] * dp[n][n] % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=2020;\nconst int mod=1e9+7;\nint inv[N*N],fac[N*N];\nint f[N][N];\nint n, k;\ninline int C(int n, int m) {return 1ll * fac[m] * inv[n] % mod * inv[m - n] % mod;}\ninline int power(int a, int b) \n{\n    a %= mod; int ans = 1;\n    while(b) {\n        if(b & 1) ans = 1ll * ans * a % mod;\n        a = 1ll * a * a % mod; b >>= 1;\n    }\n    return ans%mod;\n}\nint main() {\n    scanf(\"%d%d\", &n, &k);\n    if(k==1) {puts(\"1\"); return 0;}\n    fac[0] = 1;\n    for(int i = 1; i < N * N; ++i) \n        fac[i] = 1ll * fac[i - 1] * i % mod;\n    for(int i = 0; i < N * N; ++i) \n        inv[i] = power(fac[i], mod - 2);\n\tf[0][0]=1;\n    for(int i = 1; i <= n; ++i)\n        for(int j = 0; j <= i; ++j) {\n            f[i][j] = f[i - 1][j];\n\t\t\tif(!j) continue;\n            (f[i][j] += 1ll * (n - j + 1) * f[i][j - 1] % mod * C(k - 2, n * k - i - (j - 1) * (k - 1) - 1) % mod) %= mod;\n            f[i][j]=(f[i][j]+mod)%mod;\n        }\n    printf(\"%d\\n\",f[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<bits/stdc++.h>\n#define mod 1000000007\n#define maxn 4000095\nusing namespace std;\nint f[2005][2005],fac[maxn],inv[maxn];\nint add(int a,int b){a+=b; return a>=mod?a-mod:a;}\nint ksm(int a,int b)\n{\n\tint s=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1) s=1ll*s*a%mod;\n\treturn s;\n}\nint n,k;\nvoid Pre()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<maxn;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[maxn-1]=ksm(fac[maxn-1],mod-2);\n\tfor(int i=maxn-2;i>=0;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;\n}\nint C(int n,int m){return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint main()\n{\n\tPre();\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1) return puts(\"1\"),0;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(j) f[i][j]=add(f[i][j],1ll*C(n*k-i-(j-1)*(k-1)-1,k-2)*(n-j+1)%mod*f[i][j-1]%mod);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2,Ofast,inline,unroll-all-loops,-ffast-math\")\n#pragma GCC target(\"popcnt\")\n#include <bits/stdc++.h>\n#define maxn 2010\n#define maxv 4000010\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define fi first\n#define se second\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define pii pair<int, int>\n#define pil pair<int, ll>\n#define pll pair<ll, ll>\n#define IL inline\n#define ss system\nusing namespace std;\n\nint n, k;\nll f[maxn][maxn], fac[maxv], ifac[maxv];\nconst ll p = 1e9 + 7;\ntemplate <class T> void read (T &x) {\n  char ch = x = 0;\n  bool fl = false;\n  while (!isdigit(ch))\n    fl |= ch == '-', ch = getchar();\n  while (isdigit(ch))\n    x = x * 10 + ch - '0', ch = getchar();\n  x = fl ? -x : x;\n}\nll pw(ll a, ll b) {\n  ll ret = 1;\n  while (b) {\n    if (b & 1)\n      ret = ret * a % p;\n    a = a * a % p, b >>= 1;\n  }\n  return ret;\n}\nll C(int a, int b) {\n  return a < b || b < 0 ? 0 : fac[a] * ifac[b] % p * ifac[a - b] % p;\n}\nvoid init() {\n  fac[0] = 1;\n  for (int i = 1; i < maxv; i++) {\n    fac[i] = fac[i - 1] * i % p;\n  }\n  ifac[maxv - 1] = pw(fac[maxv - 1], p - 2);\n  for (int i = maxv - 2; ~i; i--) {\n    ifac[i] = ifac[i + 1] * (i + 1) % p;\n  }\n}\nint main() {\n  read(n), read(k), init(), f[0][0] = 1;\n  for (int i = 0; i <= n; i++) {\n    for (int j = !i; j <= i; j++) {\n      if (i)\n        f[i][j] = f[i - 1][j];\n      f[i][j] = (f[i][j] + f[i][j - 1] * (n - j + 1) % p * C(n - i + (n - j + 1) * (k - 1) - 1, k - 2)) % p;\n    }\n  }\n  printf(\"%d\\n\", f[n][n * (k > 1)]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN=2005,MOD=1e9+7;\nint n,k,fac[MAXN*MAXN],inv[MAXN*MAXN],dp[MAXN][MAXN];\n\nll quick_pow(ll a,ll b)\n{\n\tll ret=1;\n\tfor(;b;b>>=1,a=a*a%MOD)\n\t\tif(b&1) ret=ret*a%MOD;\n\treturn ret;\n}\nll C(int a,int b)\n{if(a<b) return 0;return 1ll*fac[a]*inv[a-b]%MOD*inv[b]%MOD;}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1) return puts(\"1\"),0;\n\tfac[0]=dp[0][0]=1;\n\tfor(int i=1;i<=n*k;i++) fac[i]=1ll*fac[i-1]*i%MOD;\n\tinv[n*k]=quick_pow(fac[n*k],MOD-2);\n\tfor(int i=n*k-1;i>=0;i--) inv[i]=1ll*inv[i+1]*(i+1)%MOD;\n\t\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(j<=i) dp[i][j]=dp[i-1][j];\n\t\t\telse dp[i][j]=(dp[i][j-1]*C(i+(k-1)*j-1,k-2)%MOD+dp[max(0,i-1)][j])%MOD;\n\t\n\tll res=1ll*dp[n][n]*fac[n]%MOD;\n\tprintf(\"%lld\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\nconst int N = 2010;\nconst int MOD = 1e9 + 7;\n\nint n, K, f[N][N];\nint fac[N*N], rev[N*N];\n\nint quick_pow(int x, int times)\n{\n\tif(x == 0) return 0;\n\tint ans = 1, mult = x;\n\n\twhile(times)\n\t{\n\t\tif(times & 1)\n\t\t\tans *= mult, ans %= MOD;\n\t\tmult *= mult, mult %= MOD, times >>= 1;\n\t}\n\treturn ans;\n}\n\nvoid init()\n{\n\tfac[0] = fac[1] = 1;\n\tfor(register int k = 2; k <= n * K; k++)\n\t\tfac[k] = fac[k - 1] * k % MOD;\n\n\trev[n * K] = quick_pow(fac[n * K], MOD - 2);\n\tfor(register int k = n * K - 1; k >= 0; k--)\n\t\trev[k] = (rev[k + 1] * (k + 1)) % MOD;\n}\n\nint C(int up, int down)\n{\n\treturn ((fac[down] * rev[up] % MOD) * rev[down - up]) % MOD;\n}\n\nsigned main()\n{\n\tscanf(\"%lld %lld\", &n, &K), init();\n\tif(K == 1)\n\t{\n\t\tprintf(\"1\");\n\t\treturn 0;\n\t}\n\n\tf[0][0] = 1;\n\tfor(register int i = 1; i <= n; i++)\n\t\tfor(int j = 0; j <= i; j++)\n\t\t{\n\t\t\tf[i][j] += f[i - 1][j];\n\t\t\tif(j - 1 >= 0)\n\t\t\t\tf[i][j] += (f[i][j - 1] * (n - j + 1) % MOD) * C(K - 2, n * K - i - (j - 1) * (K - 1) - 1) % MOD, f[i][j] %= MOD;\n\t\t}\n\n\tprintf(\"%lld\", f[n][n]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define FILE_IO\n\nconst int mod = 1e9 + 7;\n\nconst int VMAX = 4000000;\n\nint N, K;\nint fct[VMAX + 5], ifct[VMAX + 5];\n\nint dp[2005][2005];\n\nint power(int x, int y)\n{\n    int p = x, r = 1;\n    while(y)\n    {\n        if(y & 1)   r = (1LL * r * p) % mod;\n        p = (1LL * p * p) % mod;\n        y >>= 1;\n    }\n    return r;\n}\n\nint C(int N, int K)\n{\n    int ans = fct[N];\n    ans = (1LL * ans * ifct[K]) % mod;\n    ans = (1LL * ans * ifct[N - K]) % mod;\n    return ans;\n}\n\nvoid precalc()\n{\n    fct[0] = 1;\n    for(int i = 1; i <= VMAX; i++)\n        fct[i] = (1LL * fct[i - 1] * i) % mod;\n    ifct[VMAX] = power(fct[VMAX], mod - 2);\n    for(int i = VMAX - 1; i >= 1; i--)\n        ifct[i] = (1LL * ifct[i + 1] * (i + 1)) % mod;\n    ifct[0] = 1;\n}\n\nint main()\n{\n    #ifdef FILE_IO\n    freopen(\"1.in\", \"r\", stdin);\n    freopen(\"1.out\", \"w\", stdout);\n    #endif\n\n    precalc();\n\n    scanf(\"%d%d\", &N, &K);\n\n    if(N == 1 || K == 1)\n    {\n        printf(\"1\\n\");\n        return 0;\n    }\n\n    /// DP[i][j] - i-th white ball, j-th colors\n    dp[N + 1][N + 1] = 1;\n    for(int i = N + 1; i >= 1; i--)\n        for(int j = i == N + 1 ? N : i; j >= 1; j--)\n        {\n            int white = dp[i + 1][j];\n            int color = ( 1LL * dp[i][j + 1] * C( (N - i + 1) + (N - j + 1) * (K - 1) - 1 , K - 2 ) ) % mod;\n            dp[i][j] = (white + color) % mod;\n        }\n\n    int ans = (1LL * dp[1][1] * fct[N]) % mod;\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\ni64 modpow(i64 a, i64 p = MOD - 2)\n{\n\tif (p == 0) return 1;\n\ti64 tmp = modpow(a, p / 2);\n\ttmp = tmp * tmp % MOD;\n\tif (p % 2) tmp = tmp * a % MOD;\n\treturn tmp;\n}\n\nint N, K;\ni64 fact[4040404], frev[4040404];\n\ni64 C(int a, int b)\n{\n\tif (a < b) return 0;\n\treturn fact[a] * frev[b] % MOD * frev[a - b] % MOD;\n}\n\ni64 dp[4020][2020];\n\ni64 solve(int nz, int nk)\n{\n\tif (dp[nz][nk] != -1) return dp[nz][nk];\n\n\tif (nz == N && nk == N) return dp[nz][nk] = 1;\n\n\tdp[nz][nk] = 0;\n\tif (nz < N) {\n\t\tADD(dp[nz][nk], solve(nz + 1, nk));\n\t}\n\tif (nk < N && nk < nz) {\n\t//\tprintf(\"%d %d, %d %d\\n\", nz, nk, N * K - nz - nk * (K - 1) - 1, K - 2);\n\t\tADD(dp[nz][nk], solve(nz, nk + 1) * C(N * K - nz - nk * (K - 1) - 1, K - 2) % MOD);\n\t}\n\t//printf(\"%d %d: %lld\\n\", nz, nk, dp[nz][nk]);\n\treturn dp[nz][nk];\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &N, &K);\n\n\tif (K == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfact[0] = 1; frev[0] = 1;\n\tfor (int i = 1; i < 4040404; ++i) {\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\tfrev[i] = modpow(fact[i]);\n\t}\n\n\tfor (int i = 0; i <= N + K; ++i) {\n\t\tfor (int j = 0; j <= K; ++j) dp[i][j] = -1;\n\t}\n\ti64 sol = solve(0, 0);\n\tsol = sol * fact[N] % MOD;\n\tprintf(\"%lld\\n\", sol);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 2e3 + 6, MOD = 1e9 + 7;\nint n, k;\nint F[MAX_N * MAX_N];\nint D[MAX_N * MAX_N];\nint dp[MAX_N][MAX_N];\n\nint _sum(int a, int b) {\n\tint c = a + b;\n\tif (MOD <= c)\n\t\tc -= MOD;\n\n\treturn c;\n}\n\nint _mul(int a, int b) {\n\tint res = 1LL * a * b % MOD;\n\treturn res;\n}\n\nint _pow(int a, int b) {\n\tif (!b)\n\t\treturn 1;\n\n\tint res = _pow(a, b >> 1);\n\tres = _mul(res, res);\n\n\tif (b & 1)\n\t\tres = _mul(res, a);\n\n\treturn res;\n}\n\nint choose(int a, int b) {\n\tif (b < a || min(a, b) < 0)\n\t\treturn 0;\n\n\treturn _mul(F[b], _mul(D[a], D[b - a]));\n}\n\nvoid pre_process() {\n\tF[0] = 1;\n\tfor (int i = 1; i < MAX_N * MAX_N; i++)\n\t\tF[i] = _mul(F[i - 1], i);\n\n\tD[0] = 1;\n\tfor (int i = 1; i < MAX_N * MAX_N; i++)\n\t\tD[i] = _pow(F[i], MOD - 2);\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tpre_process();\n\tcin >> n >> k;\n\t\n\tif (k == 1) {\n\t\tcout << \"1\\n\";\n\t\treturn 0;\n\t}\n\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tdp[i][0] = 1;\n\t\tfor (int j = 1; j <= i; j++)\n\t\t\tdp[i][j] = _sum(_mul(dp[i][j - 1], choose(k - 2, n * k - i - (j - 1) * (k - 1) - 1)), dp[i - 1][j]);\n\t}\n\n\tcout << _mul(dp[n][n], F[n]) << \"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define mod (long long)(1e9+7)\nint dp[2001][2001];\nint fac[2001*2001],ifac[2001*2001];\nint fastpow(int x,int y){\n    int res=1;\n    while(y){\n        if(y&1)res=res*x%mod;\n        y>>=1;\n        x=x*x%mod;\n    }\n    return res;\n}\nvoid init(int top){\n    fac[0]=1;\n    for(int i=1;i<=top;++i)fac[i]=(fac[i-1]*i)%mod;\n    ifac[0]=ifac[1]=1;\n    ifac[top]=fastpow(fac[top],mod-2);\n    for(int i=top-1;i>1;--i)ifac[i]=(ifac[i+1]*(i+1))%mod;\n}\nint C(int n,int m){\n    return ((fac[n]*ifac[m])%mod*ifac[n-m])%mod;\n}\nsigned main(){\n    int n,k;\n    scanf(\"%d%d\",&n,&k);\n    if(k==1){\n        puts(\"1\");\n        exit(0);\n    }\n    init(n*k);\n    k--;\n    dp[0][0]=1;\n    for(int i=0;i<=n;++i){\n        for(int j=i;j<=n;++j){\n            if(i)dp[i][j]=(dp[i][j]+dp[i-1][j])%mod;\n            if(j)dp[i][j]=(dp[i][j]+(dp[i][j-1]*C(i+(j-1)*k+k-1,k-1))%mod)%mod;\n        }\n    }\n    printf(\"%lld\\n\",(dp[n][n]*fac[n])%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=2e3+2;\nconst int maxx=maxn*maxn;\nconst int q=1e9+7;\ninline int Plus(int x,int y) {return (x+=y)>=q?x-q:x;}\ninline void Pe(int &x,int y) {x=Plus(x,y);}\ninline int Multi(int x,int y) {return 1ll*x*y%q;}\ninline void Me(int &x,int y) {x=Multi(x,y);}\nnamespace num {\n\tint fac[maxx],ifac[maxx],inv[maxx];\n\tinline int C(int n,int m) {return n<m?0:Multi(Multi(fac[n],ifac[m]),ifac[n-m]);}\n\tvoid init() {\n\t\tfac[0]=fac[1]=ifac[0]=ifac[1]=inv[0]=inv[1]=1;\n\t\tfor (int i=2;i<maxx;++i) {\n\t\t\tinv[i]=Multi(q-q/i,inv[q%i]);\n\t\t\tfac[i]=Multi(fac[i-1],i);\n\t\t\tifac[i]=Multi(ifac[i-1],inv[i]);\n\t\t}\n\t}\n}\nint n,k,f[maxn];\nint main() {\n\tnum::init();\n\tcin>>n>>k;\n\tif (k==1) puts(\"1\"),exit(0);\n\tf[0]=1;\n\tfor (int i=1;i<=n;++i,f[0]=f[1]) {\n\t\tfor (int j=i;j;--j) {\n\t\t\tint tmp=num::C((i-1)*k-(j-1)+k-2,k-2);\n\t\t\tf[j]=Plus(Multi(Multi(n-i+1,f[j-1]),tmp),f[j+1]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Author: ylx\n * Lang: c++\n * Prog: agc002F\n */\n#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nvoid qmax(int &x, int y)\n{\n    if (x < y)\n        x = y;\n}\nvoid qmin(int &x, int y)\n{\n    if (x > y)\n        x = y;\n}\ninline ll read()\n{\n    char s;\n    ll k = 0, base = 1;\n    while ((s = getchar()) != '-' && s != EOF && !(isdigit(s)))\n        ;\n    if (s == EOF)\n        exit(0);\n    if (s == '-')\n        base = -1, s = getchar();\n    while (isdigit(s))\n        k = k * 10 + (s ^ '0'), s = getchar();\n    return k * base;\n}\ninline void write(ll x)\n{\n    static char cnt, num[20];\n    cnt = 0;\n    if (!x)\n    {\n        putchar('0');\n        return;\n    }\n    for (; x; x /= 10)\n        num[++cnt] = x % 10;\n    for (; cnt; putchar(num[cnt--] + 48))\n        ;\n}\nconst int maxn = 4e6 + 100;\nconst ll mod = 1e9 + 7;\nint jie[maxn], ny[maxn];\nint n, m;\nll ksm(ll x, int y)\n{\n    ll sum = 1;\n    while (y)\n    {\n        if (y & 1)\n            sum = sum * x % mod;\n        x = x * x % mod;\n        y >>= 1;\n    }\n    return sum;\n}\nvoid init()\n{\n    n = 4e6;\n    jie[0] = 1;\n    for (int i = 1; i <= n; i++)\n        jie[i] = (ll)jie[i - 1] * i % mod;\n    ny[n] = ksm(jie[n], mod - 2);\n    for (int i = n; i >= 1; i--)\n        ny[i - 1] = (ll)ny[i] * i % mod;\n}\nll C(int x, int y)\n{\n    if (x < y)\n        return 0;\n    return (ll)jie[x] * ny[x - y] % mod * ny[y] % mod;\n}\nll f[2][2030];\nint main()\n{\n#ifdef ylx\n    freopen(\"agc002F.in\", \"r\", stdin);\n    freopen(\"agc002F.out\", \"w\", stdout);\n#endif\n    init();\n    n = read(), m = read();\n    if (m == 1)\n    {\n        cout << 1 << endl;\n        return 0;\n    }\n    f[0][0] = 1;\n    for (int i = 1, p; i <= n; i++)\n    {\n        p = i & 1;\n        memset(f[p],0,sizeof(f[p]));\n        for (int j = 0; j <= i; j++)\n        {\n            f[p][j] = f[p ^ 1][j] + f[p][j - 1] * (n - j + 1) % mod * C((n - j + 1) * (m - 1) + n - i - 1, m - 2) % mod;\n        }\n    }\n    write(f[n & 1][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof((x).end())i=(x).begin();i!=(x).end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int&x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char&x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char*x){char t=P();for(;IS(t);t=P());if(~t){for(;!IS\n(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf&x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf&x){RX;RL;RT}I OP llf()\n{llf x;TR}I Fr&OP,(uint&x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull&x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)\\\nx=-x;while(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}I Fw&OP()\n(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char*x){while(*x)P(*x++);RT}\nI Fw&OP()(const char*x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=2007,P=1000000007;\n\ninline int pow(int a,int b)\n{\n\tint r=1;\n\tfor(;b;b>>=1,a=(ll)a*a%P)\n\t\tif(b&1)r=(ll)r*a%P;\n\treturn r;\n}\n\nint n,m,fac[N*N],fin[N*N],f[N][N];\n\ninline void pre(int n)\n{\n\tfac[0]=1;\n\tfo1(i,n)fac[i]=(ll)fac[i-1]*i%P;\n\tfin[n]=pow(fac[n],P-2);\n\tfd1(i,n)fin[i-1]=(ll)fin[i]*i%P;\n}\n\ninline int C(int a,int b)\n{\n\treturn (ll)fac[a]*fin[b]%P*fin[a-b]%P;\n}\n\nint main()\n{\n\tpre(N*N-1);\n\tin,n,m;\n\tif(m==1)return puts(\"1\"),0;\n\tf[0][0]=1;\n\tfo1(i,n)\n\t{\n\t\tfo(j,0,i)\n\t\t{\n\t\t\tif(j)f[i][j]=f[i][j-1];\n\t\t\tf[i][j]=(f[i][j]+(ll)f[i-1][j]*C(i*(m-1)-1+j,m-2))%P;\n\t\t}\n\t}\n\tout,(ll)f[n][n]*fac[n]%P,'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <ctime>\n#include<complex>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\n//typedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 1000 * 1000 * 1000 + 7;\nconst int MAX1 = 2000 + 47;\nconst int MAX = MAX1 * MAX1 + 47;\n\nLL F[MAX];\nLL FR[MAX];\nLL dp[MAX1][MAX1];\n\nLL bp(LL a, LL n)\n{\n\tLL res = 1;\n\twhile (n)\n\t{\n\t\tif (n & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tn >>= 1;\n\t}\n\n\treturn res;\n}\n\nLL c(int n, int k)\n{\n\tif (n < k) return 0;\n\tLL res = (F[n] * FR[n - k]) % MOD;\n\tres = (res * FR[k]) % MOD;\n\treturn res;\n}\n\nvoid ADD(LL& key, LL val)\n{\n\tkey = key + val;\n\tif (key >= MOD) key -= MOD;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n\tios::sync_with_stdio(false); cin.tie(0);\n\tF[0] = 1;\n\tFR[0] = bp(1, MOD - 2);\n\tFOR(i, 1, MAX)\n\t{\n\t\tF[i] = (F[i - 1] * i) % MOD;\n\t\tFR[i] = bp(F[i], MOD - 2);\n\t}\n\n\tint n, k;\n\tcin >> n >> k;\n\tif (k == 1)\n\t{\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\n\tdp[0][0] = 1;\n\tFOR(i, 0, n + 1)\n\t{\n\t\tFOR(j, 0, n + 1)\n\t\t{\n\t\t\tif (i + 1 <= n)\n\t\t\t{\n\t\t\t\tADD(dp[i + 1][j], dp[i][j]);\n\t\t\t}\n\n\t\t\tif (i - j > 0)\n\t\t\t{\n\t\t\t\tint left = n * k - i - j * (k - 1);\n\t\t\t\tLL w = (c(left - 1, k - 2) * (n - j)) % MOD;\n\t\t\t\t//cout << i << \" \" << j << \": \" << w << endl;\n\t\t\t\tADD(dp[i][j + 1], (dp[i][j] * w) % MOD);\n\t\t\t}\n\n\t\t}\n\t}\n\n\t//FOR(i, 0, n + 1)\n\t//{\n\t//\tFOR(j, 0, n + 1) cout << dp[i][j] << \" \";\n\t//\tcout << endl;\n\t//}\n\n\tcout << dp[n][n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// Author: wlzhouzhuan\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#include <bits/stdc++.h>\nusing namespace std;\n  \n#define ll long long\n#define ull unsigned long long\n#define rint register int\n#define rep(i, l, r) for (rint i = l; i <= r; i++)\n#define per(i, l, r) for (rint i = l; i >= r; i--)\n#define mset(s, _) memset(s, _, sizeof(s))\n#define pb push_back\n#define pii pair <int, int>\n#define mp(a, b) make_pair(a, b)\n  \ninline int read() {\n  int x = 0, neg = 1; char op = getchar();\n  while (!isdigit(op)) { if (op == '-') neg = -1; op = getchar(); }\n  while (isdigit(op)) { x = 10 * x + op - '0'; op = getchar(); }\n  return neg * x;\n}\ninline void print(int x) {\n  if (x < 0) { putchar('-'); x = -x; }\n  if (x >= 10) print(x / 10);\n  putchar(x % 10 + '0');\n}\n\nconst int N = 4000005;\nconst int mod = 1e9 + 7;\n\nint fac[N], inv[N];\nint qpow(int a, int b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) res = 1ll * res * a % mod;\n    a = 1ll * a * a % mod;\n    b >>= 1;\n  }\n  return res;\n}\nvoid pre(int n) {\n  fac[0] = inv[0] = 1;\n  for (rint i = 1; i <= n; i++) {\n    fac[i] = 1ll * fac[i - 1] * i % mod; \n  }\n  inv[n] = qpow(fac[n], mod - 2);\n  for (rint i = n - 1; i >= 1; i--) {\n    inv[i] = 1ll * inv[i + 1] * (i + 1) % mod;\n  }\n}\nint C(int n, int m) {\n  return 1ll * fac[n] * inv[n - m] % mod * inv[m] % mod; \n}\nint f[2002][2002], n, k;\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  if (k == 1) {\n    puts(\"1\");\n    exit(0);\n  }\n  pre(n * k);\n  for (rint i = 1; i <= n; i++) {\n    f[i][0] = 1;\n  }\n  for (rint i = 1; i <= n; i++) {\n    for (rint j = 1; j <= i; j++) {\n      f[i][j] = (f[i - 1][j] + 1ll * f[i][j - 1] * (n - j + 1) % mod * C(n * k - i - (j - 1) * (k - 1) - 1, k - 2) % mod) % mod;\n    }\n  }\n  printf(\"%d\\n\", f[n][n]);\n  return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define min(a,b) (a<b?a:b)\n#define max(a,b) (a>b?a:b)\ntypedef long long ll;\nusing namespace std;\nconst int maxn=2e3+5,mo=1e9+7;\nint i,j,n,k,f[maxn][maxn],ji[maxn*maxn],ni[maxn*maxn];\nint qs(int x,int y){\n\tint s=1;\n\tfor(;y;y>>=1,x=(ll)x*x%mo) if(y&1) s=(ll)s*x%mo;\n\treturn s; \n}\nint calc(int n,int  m){\n\treturn (ll)ji[n]*ni[m]%mo*ni[n-m]%mo;\n}\nvoid mod(int &x){\n\tx-=(x>=mo)?mo:0;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tji[0]=1;\n\tfo(i,1,n*k) ji[i]=(ll)ji[i-1]*i%mo;\n\tni[n*k]=qs(ji[n*k],mo-2);\n\tfd(i,n*k,1) ni[i-1]=(ll)ni[i]*i%mo;\n\tf[0][0]=1;\n\tfo(i,0,n){\n\t\tfd(j,i,0) if (f[i][j]){\n\t\t\tint s=f[i][j];\n\t\t\tif (j) mod(f[i][j-1]+=s);\n\t\t\tif (i<n) mod(f[i+1][j+1]+=(ll)s*calc(i*k-j+k-2,k-2)%mo);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(ll)f[n][0]*ji[n]%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for (int i = a; i <= b; i++)\n#define per(i, a, b) for (int i = a; i >= b; i--)\ntypedef long long LL;\nconst LL mod = 1e9 + 7;\n// head\nconst int maxn = 2e3 + 5;\nint n, k;\nLL f[maxn][maxn], fac[maxn*maxn], inv[maxn*maxn];\n\nLL ksm(LL a, LL b) {\n\tLL res = 1;\n\twhile(b) {\n\t\tif(b%2) res = res*a%mod;\n\t\tb /= 2;\n\t\ta = a*a%mod;\n\t}\n\treturn res;\n}\n\nLL comb(LL a, LL b) {\n\treturn fac[a]*inv[b]%mod*inv[a - b]%mod;\n}\n\nint main() {\n\tcin>>n>>k;\n\tfac[0] = inv[0] = 1;\n\trep(i, 1, n*k)\n\t    fac[i] = fac[i - 1]*i%mod, inv[i] = ksm(fac[i], mod - 2);\n\tf[0][0] = 1;\n\trep(i, 1, n)\n\t    rep(j, 0, i) {\n\t    \tif(i > j) f[i][j] = (f[i][j] + f[i - 1][j])%mod;\n\t    \tif(j) f[i][j] = (f[i][j] + f[i][j - 1]*(n - j + 1)%mod*comb(n*k - i - (j - 1)*(k - 1) - 1, k - 2)%mod)%mod;\n\t    }\n\tcout<<f[n][n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = (int)1e9 + 7;\nconst int MAXN = 2000 + 10;\nint n, k;\nint cnt;\n\nint a[MAXN], b[MAXN], t[MAXN];\nbool vis[MAXN];\n\nint tot;\n\nset<string> ans;\n\nvoid dfs(int dep)\n{\n\tif(dep == cnt + 1)\n\t{\n\t\tmemset(t,0,sizeof(t));\n\t\t\n\t\tfor(int i = 1; i <= cnt; i++)\n\t\t\tt[i] = a[b[i]];\n\t\t\t\n    \tbool h[MAXN];\n\t\tmemset(h,false,sizeof(h));\n\t\t\n\t\tfor(int i = 1; i <= cnt; i++)\n\t\t{\n\t\t\tif(!h[t[i]])\n\t\t\t{\n\t\t\t\th[t[i]] = true;\n\t\t\t\tt[i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tstring str = \"\";\n\t\tfor(int i = 1; i <= cnt; i++)\n\t\t\tstr += t[i] + '0' + ',';\n\t\tans.insert(str);\n\t\t\t\t\n\t\treturn; \n\t}\n\tfor(int i = 1; i <= cnt; i++)\n\t{\n\t\tif(!vis[i])\n\t\t{\n\t\t\tvis[i] = true;\n\t\t\tb[dep] = i;\n\t\t\tdfs(dep + 1);\n\t\t\tvis[i] = false;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin >> n >> k;\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= k; j++)\n\t\t\ta[++cnt] = i;\n\t\n\tdfs(1);\n\t\n\tcout << ans.size() % MOD << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Have a nice day:)\n#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n\ninline int read();\n\nconst int N=2000+2;\nconst int M=1e9+7;\nint n, k;\nint frac[N*N], inv[N*N];\nint f[N][N];\n\nint Pow(int a, int b) \n{ \n\tint ans=1; \n\tfor(; b; b>>=1, a=1ll*a*a%M) if(b&1) ans=1ll*a*ans%M; \n\treturn ans;\n}\nint C(int a, int b) \n{ \n\tif(a<0 || b<0) return 0;\n\tif(!a || !b) return 1;\n\tassert((__int128)frac[b]*inv[a]*inv[b-a]%M>=0);\n\treturn (1ll*frac[b]*inv[a]%M)*inv[b-a]%M;\n}\nvoid Work()\n{\n    n=read(), k=read(); frac[0]=1; inv[0]=1; f[0][0]=1;\n\tif(k==1) { printf(\"1\"); return; }\n\tfor(int i=1, lim=n*k; i<=lim; ++i) frac[i]=1ll*frac[i-1]*i%M, inv[i]=Pow(frac[i], M-2);\n\tfor(int i=1; i<=n; ++i)\n\t\tfor(int j=0; j<=i; ++j)\n\t\t{\n\t\t\tif(j) f[i][j]=(f[i-1][j]+1ll*f[i][j-1]*C(k-2, n*k-i-(k-1)*(j-1)-1)%M)%M;\n            else f[i][j]=f[i-1][j];\n\t\t}\n\tprintf(\"%d\", 1ll*f[n][n]*frac[n]%M);\n}\n\nint main()\n{\n    #ifdef gc\n    freopen(\"002f.in\",\"r\",stdin);\n    freopen(\"002f.out\",\"w\",stdout);\n    #endif\n\n    Work();\n\n    return 0;\n}\n\ninline int read()\n{\n    char c; bool type=1;\n    while((c=getchar())<'0' || c>'9')\n        if(c=='-') type=0;\n    int ans=c^48;\n    while((c=getchar())>='0' && c<='9')\n        ans=(ans<<3)+(ans<<1)+(c^48);\n    return type?ans:-ans;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define mod 1000000007\nlong long f[2005][2005],ny[4000005],s[4000005],t[4000005];\nlong long p(long long n,long long m)\n{\n\treturn s[n]*t[m]%mod*t[n-m]%mod;\n}\nint main()\n{\n\tlong long n,k,i,j;\n\tcin>>n>>k;\n\tif(k==1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tny[1]=1;\n\tfor(i=2;i<=4000000;i++)\n\t{\n\t\tny[i]=(mod-mod/i)*ny[mod%i]%mod;\n\t}\n\ts[0]=1,t[0]=1;\n\tfor(i=1;i<=4000000;i++)\n\t{\n\t\ts[i]=s[i-1]*i%mod;\n\t\tt[i]=t[i-1]*ny[i]%mod;\n\t}\n\tfor(i=0;i<=n;i++)\n\t\tf[i][0]=1;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tfor(j=0;j<=i;j++)\n\t\t{\n\t\t\tf[i][j]=f[i-1][j]+f[i][j-1]*(n-j+1)%mod*p(n*k-i-1-(j-1)*(k-1),k-2)%mod;\n\t\t\tf[i][j]%=mod;\n\t\t}\n\t}\n\tcout<<f[n][n]%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxN = 2e3 + 13, mod = 1e9 + 7;\nint n, k, dp[maxN][maxN], fac[maxN * maxN], rfac[maxN * maxN];\n\nint pw (int a, int b) {\n    int ret = 1;\n    for (; b; b >>= 1, a = 1ll * a * a % mod)\n\tif (b & 1)\n\t    ret = 1ll * ret * a % mod;\n    return ret;\n}\n\nint c (int a, int b) {\n    return 1ll * fac[b] * rfac[a] % mod * rfac[b - a] % mod;\n}\n\nint main () {\n    cin >> n >> k;\n    dp[0][0] = 1;\n    fac[0] = rfac[0] = 1;\n    for (int i = 1; i <= n * k; i++) {\n\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\trfac[i] = 1ll * rfac[i - 1] * pw(i, mod - 2) % mod;\n    }\n\n    for (int i = 1; i <= n; i++)\n\tfor (int j = 0; j <= i; j++) {\n\t    if (j)\n\t\tdp[i][j] = dp[i][j - 1];\n\t    dp[i][j] = (dp[i][j] + (1ll * dp[i - 1][j] * c(k - 2, i * (k - 1) + j - 1) % mod)) % mod;\n\t    // cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t}\n    //cout << dp[n][n] << endl;\n    cout << 1ll * dp[n][n] * fac[n] % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Be Name Khoda, Besmellah Rahmane Rahim, In The Name Of God;\n//#include<bits/stdc++.h>\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <deque>\n#include <map>\n#include <stack>\n#include<bitset>\n#include<list>\n#include<cassert>\n#include<numeric>\n#include <stdio.h>\n#include <string.h>\n#include<iomanip>\n#include<unordered_map>\n#include<unordered_set>\n\nusing namespace std;\n\nconst long long N = 2e3 + 5;\nconst long long mod = 1e9 + 7;\nlong long dp[N][N];\nlong long fact[N * N];\nlong long n, k;\n//dp[i][j] = the number of ways when i zero has come and j colorful ball has come\n\n\nvoid pre()\n{\n\tfact[0] = 1;\n\tfor (long long i = 1; i < N * N; i++)\n\t{\n\t\tfact[i] = fact[i - 1] * i;\n\t\tfact[i] = fact[i] % mod;\n\t}\n}\n\nlong long power(long long a, long long b)\n{\n\tif (!b)\n\t{\n\t\treturn 1;\n\t}\n\tlong long ans = power(a, b / 2);\n\tans = ans * ans;\n\tans = ans % mod;\n\tif (b % 2)\n\t{\n\t\tans = ans * a;\n\t\tans = ans % mod;\n\t}\n\treturn ans % mod;\n}\n\nlong long choose(long long a, long long b)\n{\n\tif (a > b)\n\t{\n\t\treturn 0;\n\t}\n\tlong long ans = fact[b];\n\tans = ans * power(fact[a], mod - 2);\n\tans = ans % mod;\n\tans = ans * power(fact[b - a], mod - 2);\n\tans = ans % mod;\n\treturn ans;\n}\n\n\nint main()\n{\n\tstd::ios::sync_with_stdio(false);\n\tcin.tie(0);\n\tpre();\n\tcin >> n >> k;\n\tdp[0][0] = 1;\n\tfor (int i = 0; i <= n; i++)\n\t{\n\t\tfor (int j = 0; j <= n; j++)\n\t\t{\n\t\t\t// the i + j * (k - 1) + 1th ball \n\t\t\tif (j > i)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == j) // this ball only can be zero\n\t\t\t{\n\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\tdp[i + 1][j] %= mod;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//this ball is zero\n\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\tdp[i + 1][j] %= mod;\n\t\t\t\t// this ball is colorful\n\t\t\t\tdp[i][j + 1] += dp[i][j] * choose(k - 2, n * k - i - j * (k - 1) - 1);\n\t\t\t\tdp[i][j + 1] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tif (k > 1)\n\t{\n\t\tcout << (dp[n][n] * fact[n]) % mod << endl;\n\t}\n\telse\n\t{\n\t\tcout << dp[n][n] << endl;\n\t}\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int maxn=2000+10,mod=1e9+7;\nll f[maxn][maxn];\nll s[maxn*maxn+10];\nint n,m;\ninline void read(int &x){\n\tchar c=getchar();\n\tint f=1;\n\tx=0;\n\twhile(c<'0' || c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0' && c<='9'){x=x*10+c-'0';c=getchar();}\n\tx*=f;\n}\ninline long long ksm(ll x,int y){\n\tll sum=1;\n\twhile(!y){\n\t\tif(y&1){sum=(sum*x)%mod;}\n\t\ty/=2;\n\t\tx=(x*x)%mod;\n\t}\n\treturn sum%mod;\n}\ninline ll cal(int x,int y){\n\t//cout<<s[x]<<\" \"<<s[y]<<endl;\n\tll sum2=1,sum1=1,sum=0;\n\tfor(register int i=1;i<=y;i++)sum1=(sum1*i)%mod;\n\tfor(register int i=x-y+1;i<=x;i++)sum2=(sum2*i)%mod;\n\t//sum2=s[x];sum1=(s[x-y]*s[y])%mod;\n\tsum=(sum2*ksm(sum1,mod-2))%mod;\n\t//cout<<sum<<endl;\n\treturn sum;\n}\nint main(){\n\tint i,j,k;\n\tread(n);read(m);\n\t//cout<<n<<\" \"<<m<<endl;\n\tif(m==1){cout<<1<<endl;return 0;}\n\tf[0][0]=1;\n\ts[0]=1;\n\t//for(register int i=1;i<=n;i++)f[i][0]=1;\n\tfor(register int i=1;i<=n*m;i++){s[i]=(s[i-1]*i)%mod;}\n\tfor(register int i=1;i<=n;i++)\n\t\tfor(register int j=0;j<=i;j++){\n\t\t\tif(!j)f[i][j]=f[i-1][j]%mod;\n\t\t\telse f[i][j]=(f[i-1][j]+((f[i][j-1]*(n-j+1))%mod*cal(n*m-(j-1)*(m-1)-i-1,m-2)))%mod;\n\t\t}\n\tcout<<f[n][n]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int N = 2e3 + 11;\nconst int MM = 5e6 + 11;\nint n, k, f[N][N];\nint fac[MM], inv[MM];\ninline int M(int x, int y){\n    return 1LL * x * y % mod;\n}\ninline int A(int x, int y){\n    return x + y - (x + y >= mod ? mod : 0);\n}\ninline int C(int n, int m){\n    if(n < m)return 0;\n    return M(fac[n], M(inv[m], inv[n-m]));\n}\nint main(){\n    fac[0] = fac[1] = inv[1] = inv[0] = 1;\n    for(int i = 2;i <= 5e6; i++){\n        fac[i] = M(fac[i-1], i);\n        inv[i] = mod - M(mod / i, inv[mod%i]);\n    }\n    for(int i = 2;i <= 5e6; i++){\n        inv[i] = M(inv[i], inv[i-1]);\n    }\n    cin>>n>>k;\n    if(k == 1){\n        puts(\"1\");\n        return 0;\n    }\n    for(int i = 1;i <= n; i++){\n        f[i][0] = 1;\n        for(int j = 1;j <= i; j++){\n            f[i][j] = A(f[i-1][j], M(f[i][j-1], C(n * k - i - (k - 1) * (j - 1) - 1, k - 2)));\n        }\n    }\n    printf(\"%d\\n\", M(f[n][n], fac[n]));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define MN 2000\n#define MX 4000000\n#define mod 1000000007\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint f[MN+5][MN+5],n,k,p[MX+5],inv[MX+5];\ninline void R(int&x,int y){x+=y;x>=mod?x-=mod:0;}\ninline int C(int n,int m){return 1LL*p[n]*inv[m]%mod*inv[n-m]%mod;}\nint main()\n{\n\tn=read();k=read();if(k==1) return 0*puts(\"1\");\n\tp[0]=inv[0]=p[1]=inv[1]=f[0][0]=1;\n\tfor(int i=2;i<=n*k;++i) p[i]=1LL*p[i-1]*i%mod,inv[i]=1LL*(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=2;i<=n*k;++i) inv[i]=1LL*inv[i]*inv[i-1]%mod;\n\tfor(int i=0;i<=n;++i)\n\t\tfor(int j=0;j<=i;++j)\n\t\t{\n\t\t\tif(i<n) R(f[i+1][j],f[i][j]);\n\t\t\tif(j<i) R(f[i][j+1],1LL*f[i][j]*C((n-j-1)*(k-1)+n-i+k-1-1,k-2)%mod*(n-j)%mod);\t\n\t\t}\n\tprintf(\"%d\\n\",f[n][n]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define il inline\n#define ri register int\n#define pb push_back\n#define mp make_pair\n#define fir first\n#define sec second\n#define mid ((l+r)>>1)\n#define MAXN 200050\n#define MAXM\n#define mod\n#define inf (1<<30)\n#define eps (1e-6)\n#define alpha 0.75\n#define rep(i, x, y) for(ri i = x; i <= y; ++i)\n#define repd(i, x, y) for(ri i = x; i >= y; --i)\n#define file(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, int> pli;\ntypedef pair <int, ll> pil;\ntypedef pair <ll, ll> pll;\ntemplate <typename T> il bool chkmin(T &x, T y) {return x > y ? x = y, 1 : 0;}\ntemplate <typename T> il bool chkmax(T &x, T y) {return x < y ? x = y, 1 : 0;}\ntemplate <typename T> il void read(T &x) {\n\tchar ch = getchar(); int f = 1; x = 0;\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = x*10+ch-'0', ch = getchar();\n\tx *= f;\n}\ntemplate <typename T, typename... Args> il void read(T &x, Args &...args) {\n\tread(x), read(args...);\n}\nint n, m, q, vcnt, f[MAXN][20], val[MAXN], size[MAXN];\nvector <int> adj[MAXN];\nstruct node {\n\tint u, v;\n} E[MAXN];\nstruct ufs {\n\tint fa[MAXN];\n\tint get(int u) {\n\t\treturn fa[u] == u ? u : fa[u] = get(fa[u]);\n\t}\n} S;\nvoid dfs(int u) {\n\tsize[u] = u <= n;\n\trep(i, 1, 19) f[u][i] = f[f[u][i-1]][i-1];\n\tfor(int v: adj[u])\n\t\tf[v][0] = u, dfs(v), size[u] += size[v];\n//\tcout << u << ' ' << val[u] << ' ' << size[u] << endl;\n}\nint jump(int u, int k) {\n\trepd(i, 19, 0) if(val[f[u][i]] <= k) u = f[u][i];\n\treturn u;\n}\nint get(int u, int v, int k) {\n//\tcout << \"get: \" << u << ' ' << v << ' ' << k << endl;\n\tu = jump(u, k), v = jump(v, k);\n//\tcout << u << ' ' << v << ' ' <<size[u] << ' ' <<size[v] << endl;\n\tif(u == v) return size[u];\n\treturn size[u] + size[v];\n}\nint main() {\n\tval[0] = 1e9;\n\tread(n, m), vcnt = n; int u, v, w;\n\trep(i, 1, n) S.fa[i] = i;\n\trep(i, 1, m) read(u, v), E[i] = node {u, v};\n\trep(i, 1, m) {\n\t\tu = S.get(E[i].u), v = S.get(E[i].v);\n\t\tif(u != v) {\n\t\t\t++vcnt, S.fa[u] = S.fa[v] = S.fa[vcnt] = vcnt;\n\t\t\tadj[vcnt].pb(u), adj[vcnt].pb(v);\n\t\t\tval[vcnt] = i;\n\t\t}\n\t}\n\tdfs(vcnt);\n\tread(q);\n\twhile(q--) {\n\t\tread(u, v, w);\n\t\tint l = 1, r = m, ans = -1;\n\t\twhile(l <= r) {\n//\t\t\tcout << get(u, v, mid) << endl;\n\t\t\tif(get(u, v, mid) >= w) ans = mid, r = mid-1;\n\t\t\telse l = mid+1;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2005;\nconst int MOD = 1e9 + 7;\ninline int qpow(int a, int b)\n{\n\tregister int res = 1;\n\tfor(; b; b >>= 1)\n\t{\n\t\tif(b & 1)\n\t\t\tres = (long long)res * a % MOD;\n\t\ta = (long long)a * a % MOD;\n\t}\n\treturn res;\n}\nint f[MAXN][MAXN];\nint fac[MAXN * MAXN], fav[MAXN * MAXN];\nint n, k;\ninline int C(int n, int m)\n{\n\treturn (long long)fac[n] * fav[m] % MOD * fav[n - m] % MOD;\n}\nint main()\n{\n\tcin >> n >> k;\n\tif(k == 1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0] = 1;\n\tfor(register int i = 1; i <= n * k; ++i)\n\t\tfac[i] = (long long)fac[i - 1] * i % MOD;\n\tfav[n * k] = qpow(fac[n * k], MOD - 2);\n\tfor(register int i = n * k - 1; i >= 0; --i)\n\t\tfav[i] = (long long)fav[i + 1] * (i + 1) % MOD;\n\tf[0][0] = 1;\n\tfor(register int i = 1; i <= n; ++i)\n\t{\n\t\tfor(register int j = 0; j <= i; ++j)\n\t\t{\n\t\t\tf[i][j] = f[i - 1][j];\n\t\t\tif(j)\n\t\t\t\tf[i][j] = (f[i][j] + (long long)f[i][j - 1] * (n - j + 1) % MOD * C(n * k - i - (j - 1) * (k - 1) - 1, k - 2) % MOD) % MOD;\n//\t\t\tcerr << f[i][j - 1] << \" \";\n\t\t}\n//\t\tcerr << endl;\n\t}\n\tcout << f[n][n] << endl;\n} "
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <unordered_map>\n#include <unordered_set>\n#include <cassert>\nusing namespace std;\ntypedef pair<int, int> PP;\ntypedef long long LL;\n#define pb push_back\n#define fr first\n#define sc second\n#define bitcnt __builtin_popcount\n#define all(x) x.begin(), x.end()\ninline int ri() {int x; scanf(\"%d\", &x); return x;}\n#define rep2(i, n, ...) for (int i = 0; i < (n); i ++) \n#define rep3(i, a, b, ...) for (int i = (a); i < (b); i ++)\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define rep(...) GET_MACRO(__VA_ARGS__, rep3, rep2)(__VA_ARGS__)\n#define drep2(i, n, ...) for (int i = (n) - 1; i >= 0; i --)\n#define drep3(i, a, b) for (int i = (a) - 1; i >= (b); i --)\n#define drep(...) GET_MACRO(__VA_ARGS__, drep3, drep2)(__VA_ARGS__)\ntemplate<typename T>inline bool smax(T&a, T b){if(a<b){a=b;return true;}return false;} \ntemplate<typename T>inline bool smin(T&a, T b){if(a>b){a=b;return true;}return false;} \n/*}}}*/\n//mod int\nstruct mint{\n  const static long long mod = 1e9 + 7;\n  long long x;\n  mint():x(0){}       \n  mint(long long x):x(((x%mod)+mod)%mod){};\n  mint operator+=(const mint&a){if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint operator-=(const mint&a){if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint operator*=(const mint&a){(x*=a.x)%=mod; return *this;}\n  mint operator*(const mint&a){return mint(*this)*=a;}\n  mint operator-(const mint&a){return mint(*this)-=a;}\n  mint operator+(const mint&a){return mint(*this)+=a;}\n  template<typename T>mint operator*(const T&a){return mint(*this)*=a;}\n  template<typename T>mint operator-(const T&a){return mint(*this)-=a;}\n  template<typename T>mint operator+(const T&a){return mint(*this)+=a;}\n  template<typename T>friend mint operator*(T x,const mint&m){return mint(x)*=m;}\n  template<typename T>friend mint operator-(T x,const mint&m){return mint(x)-=m;}\n  template<typename T>friend mint operator+(T x,const mint&m){return mint(x)+=m;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n  operator long long () const {return x;}\n};\nmint pw(mint a, long long b){mint res(1);while(b){if(b&1)res*=a;a*=a;b>>=1;}return res;}\nmint inv(mint a){return pw(a, mint::mod - 2);}\n//mod int\n\nconst int maxn = 5000000;\nmint fac[maxn], inv_fac[maxn];\n\nmint p[4010][2010];\nmint C(int a, int b) {\n  return fac[a] * inv_fac[b] * inv_fac[a - b];\n}\n\nint main() {\n  #ifdef _TEST_\n  freopen(\"input.txt\", \"r\", stdin);\n  //freopen(\"out.txt\", \"w\", stdout);\n  #endif\n  fac[0] = inv_fac[0] = 1;\n  rep(i, 1, maxn) fac[i] = fac[i - 1] * i, inv_fac[i] = inv(fac[i]);\n  int n, m;\n  cin >> n >> m;\n  p[0][0] = 1;\n  if (m == 1) {\n    cout << 1 << endl;\n    return 0;\n  }\n  rep(i, 2 * n) \n    rep(j, (i + 1) / 2, min(i, n) + 1) {\n      int k = i - j;\n      if (j > k) {\n        p[i + 1][j] += p[i][j] * C(2 * n - i - 1 + (n - k) * (m - 2), m - 2);\n      }\n      p[i + 1][j + 1] += p[i][j];\n    }\n  cout << p[2 * n][n] * fac[n] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\n\nconst int N=2005;\nconst int mod=1e9+7;\nint n,k,dp[N][N];\nint fac[N*N],inv[N*N],infac[N*N];\n\nnamespace MATHEMATICS\n{\n\tint add(int x,int y)\n\t{\n\t\tint ret=x+y;\n\t\tif(ret>=mod) ret-=mod;\n\t\treturn ret;\n\t}\n\tint mi(int x,int y)\n\t{\n\t\tint ret=x-y;\n\t\tif(ret<0) ret+=mod;\n\t\treturn ret;\n\t}\n\t\n\tvoid inc(int &x,int y)\n\t{\n\t\tx+=y;\n\t\tif(x>=mod) x-=mod;\n\t}\n\tvoid dec(int &x,int y)\n\t{\n\t\tx-=y;\n\t\tif(x<0) x+=mod;\n\t}\n\t\n\tint mul(int x,int y)\n\t{\n\t\treturn 1LL*x*y%mod;\n\t}\n}\nusing namespace MATHEMATICS;\n\nint C(int x,int y)\n{\n\treturn mul(fac[x],mul(infac[y],infac[x-y]));\n}\n\nint main()\n{\n\tint i,j;\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1)\n\t{\n\t\tprintf(\"%d\\n\",1);\n\t\treturn 0;\n\t}\n\tfac[0]=1;for(i=1;i<=n*k;++i) fac[i]=mul(fac[i-1],i);\n\tinv[1]=1;for(i=2;i<=n*k;++i) inv[i]=mul(inv[mod%i],mod-mod/i);\n\tinfac[0]=1;for(i=1;i<=n*k;++i) infac[i]=mul(infac[i-1],inv[i]);\n\t\n\tdp[0][0]=1;\n\tfor(i=0;i<=n;++i)\n\t\tfor(j=i;j<=n;++j)\n\t\t{\n\t\t\tif(i) inc(dp[i][j],dp[i-1][j]);\n\t\t\tif(j) inc(dp[i][j],mul(dp[i][j-1],C(i+(j-1)*(k-1)+k-2,k-2)));\n\t\t}\n\tprintf(\"%d\\n\",mul(dp[n][n],fac[n]));\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define IL __inline__ __attribute__((always_inline))\n\n#define For(i, a, b) for (int i = a, i##end = b; i <= i##end; ++ i)\n#define FOR(i, a, b) for (int i = a, i##end = b; i < i##end; ++ i)\n#define Rep(i, a, b) for (int i = a, i##end = b; i >= i##end; -- i)\n#define REP(i, a, b) for (int i = (a) - 1, i##end = b; i >= i##end; -- i)\n\ntypedef long long LL;\n\ntemplate <class T>\nIL bool chkmax(T &a, const T &b) {\n  return a < b ? ((a = b), 1) : 0;\n}\n\ntemplate <class T>\nIL bool chkmin(T &a, const T &b) {\n  return a > b ? ((a = b), 1) : 0;\n}\n\ntemplate <class T>\nIL T mymax(const T &a, const T &b) {\n  return a > b ? a : b;\n}\n\ntemplate <class T>\nIL T mymin(const T &a, const T &b) {\n  return a < b ? a : b;\n}\n\ntemplate <class T>\nIL T myabs(const T &a) {\n  return a > 0 ? a : -a;\n}\n\nconst int INF = 0X3F3F3F3F;\nconst double EPS = 1E-10, PI = acos(-1.0);\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define OK DEBUG(\"Passing [%s] in LINE %d...\\n\", __FUNCTION__, __LINE__)\n/*------------------------------header------------------------------*/\n\nconst int MAXN = 2000 + 5, MAXM = 4000000 + 5, MOD = 1000000007;\n\nIL int add(int a, int b) {\n  a += b;\n  return a >= MOD ? a - MOD : a;\n}\n\ntemplate<class ...Args>\nIL int add(int a, const Args &...args) {\n  a += add(args...);\n  return a >= MOD ? a - MOD : a;\n}\n\nIL int sub(int a, int b) {\n  a -= b;\n  return a < 0 ? a + MOD : a;\n}\n\nIL int mul(int a, int b) {\n  return (LL)a * b % MOD;\n}\n\ntemplate<class ...Args>\nIL int mul(int a, const Args &...args) {\n  return (LL)a * mul(args...) % MOD;\n}\n\nIL int quickPow(int a, int p) {\n  int result = 1;\n  for (int base = a; p; p >>= 1, base = mul(base, base)) {\n    if (p & 1) {\n      result = mul(result, base);\n    }\n  }\n  return result;\n}\n\nint fac[MAXM], ifac[MAXM], f[MAXN][MAXN];\n\nIL void init(int n) {\n  fac[0] = 1;\n  For(i, 1, n) {\n    fac[i] = mul(fac[i - 1], i);\n  }\n  ifac[n] = quickPow(fac[n], MOD - 2);\n  REP(i, n, 0) {\n    ifac[i] = mul(ifac[i + 1], i + 1);\n  }\n}\n\nIL int binom(int n, int m) {\n  return mul(fac[n], ifac[m], ifac[n - m]);\n}\n\nint main() {\n  int n, k;\n  scanf(\"%d%d\", &n, &k);\n  if (k == 1) {\n    printf(\"%d\\n\", 1);\n    exit(0);\n  }\n  init(n * k);\n  f[0][0] = 1;\n  For(j, 1, n) {\n    f[0][j] = mul(f[0][j - 1], binom(j * (k - 1) - 1, k - 2));\n  }\n  For(i, 1, n) {\n    For(j, i, n) {\n      f[i][j] = add(f[i - 1][j], mul(f[i][j - 1], binom(j * (k - 1) + i - 1, k - 2)));\n    }\n  }\n  printf(\"%d\\n\", mul(f[n][n], fac[n]));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#define debug(x) cout<<#x<<\"=\"<<x<<endl;\n#define chk() cout<<C((n-j+1)*(k-1)+(n-i)-1,k-2)<<endl;\nusing namespace std;\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())if(ch=='-')f=-1;\n\tfor(;isdigit(ch);ch=getchar())x=(x<<3)+(x<<1)+(ch^'0');\n\treturn x*f;\n}\nconst int maxn=2010;\nconst int mod=1e9+7;\nint ifac[maxn*maxn],fac[maxn*maxn],inv[maxn*maxn];\nint f[maxn][maxn];\ninline int C(int n,int m){\n\tif(m==0)return 1;\n\tif(n<m)return 0;\n\treturn 1ll*fac[n]*ifac[n-m]%mod*ifac[m]%mod;\n}\nint n,k;\ninline void init(){\n\tn=read(),k=read();\n\tif(n==0 || k==0)printf(\"0\"),exit(0);\n\tif(k==1)puts(\"1\"),exit(0);\n\tinv[0]=inv[1]=1;\n\tfor(register int i=2;i<=maxn*maxn;++i)\n\t\tinv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\tfac[0]=fac[1]=1;\n\tfor(register int i=2;i<=maxn*maxn;++i)\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\tifac[0]=ifac[1]=1;\n\tfor(register int i=1;i<=maxn*maxn;++i)\n\t\tifac[i]=1ll*ifac[i-1]*inv[i]%mod;\n\n//\tfor(register int i=1;i<=n;++i)for(register int j=1;j<=i;++j)cout<<f[i][j]<<endl;\n}\ninline void solve(){\n\tf[1][0]=1;\n\t//这里为什么不是n\n\t//出现一个白球不应该是随便放一个都可以吗\n\tfor(register int i=0;i<=n;++i)\n\t\tfor(register int j=0;j<=i;++j){\n\t\t\tif(i)(f[i][j]+=f[i-1][j])%=mod;\n\t\t\tif(j)(f[i][j]+=1ll*C((n-j+1)*(k-1)+(n-i)-1,k-2)*f[i][j-1]%mod)%=mod;\n\t\t}\n\t//                              ^\n \t//                              |\n\t//                       求解释这一坨\n\tcout<<1ll*f[n][n]*fac[n]%mod;\n\t//为啥这里要乘fac[n];\n}\nint main(){\n\tinit();\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2005,mod=1000000007;\nint n,k,dp[N][N],fac[N*N],ifac[N*N];\nint pw(int a,int b){int r=1;for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)r=1ll*r*a%mod;return r;}\nint C(int a,int b){return a<0||b<0||a<b?0:1ll*fac[a]*ifac[b]%mod*ifac[a-b]%mod;}\nint main()\n{\n\tfor(int i=fac[0]=1;i<N*N;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\tifac[N*N-1]=pw(fac[N*N-1],mod-2);\n\tfor(int i=N*N-1;i;i--)ifac[i-1]=1ll*ifac[i]*i%mod;\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1){puts(\"1\");return 0;}\n\tdp[0][0]=1;\n\tfor(int i=0;i<=n;i++)for(int j=0;j<=i;j++)\n\t{\n\t\tif(i)dp[i][j]=(dp[i][j]+dp[i-1][j])%mod;\n\t\tif(j)dp[i][j]=(dp[i][j]+1ll*dp[i][j-1]*C(n*k-i-(j-1)*(k-1)-1,k-2)%mod;\n\t}\n\tprintf(\"%d\\n\",1ll*dp[n][n]*fac[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// vvvvvvvvvvvvvvvvv Library code start\n\n\n#define NDEBUG\nNDEBUG\n\n\n#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <memory>\n#include <random>\n\n\n#define forn(t, i, n) for (t i = 0; i < (n); ++i)\n\n#define rforn(t, i, n) for (t i = (n) - 1; i >= 0; --i)\n\n\nusing namespace std;\n\n/// caide keep\nbool __hack = std::ios::sync_with_stdio(false);\n/// caide keep\nauto __hack1 = cin.tie(nullptr);\n\n\n#define ENABLE_IF(e) typename enable_if<e>::type* = nullptr\n\nnamespace template_util {\n    template<class T>\n    constexpr T min(T a, T b) {\n        return a < b ? a : b;\n    }\n\n    \n    constexpr int bytecount(uint64_t x) {\n        return x ? 1 + bytecount(x >> 8) : 0;\n    }\n\n    /// caide keep\n    template<int N>\n    struct bytetype {\n        typedef uint64_t type;\n    };\n\n    /// caide keep\n    template<>\n    struct bytetype<4> {\n        typedef uint32_t type;\n    };\n\n    /// caide keep\n    template<>\n    struct bytetype<3> {\n        typedef uint32_t type;\n    };\n\n    /// caide keep\n    template<>\n    struct bytetype<2> {\n        \n    };\n\n    /// caide keep\n    template<>\n    struct bytetype<1> {\n        typedef uint8_t type;\n    };\n\n    /// caide keep\n    template<>\n    struct bytetype<0> {\n        typedef uint8_t type;\n    };\n\n    /// caide keep\n    template<uint64_t N>\n    struct minimal_uint : bytetype<bytecount(N)> {\n    };\n}\n\n\n/*\nTODOs:\n cache invs\n primitive root\n discrete log\n\n tests!!!\n*/\n\nnamespace mod_impl {\n    /// caide keep\n    template <class T>\n    constexpr inline T mod(T MOD) {\n        return MOD;\n    }\n\n    /// caide keep\n    template <class T>\n    constexpr inline T mod(T* MOD) {\n        return *MOD;\n    }\n\n    /// caide keep\n    template <class T>\n    constexpr inline T max_mod(T MOD) {\n        return MOD - 1;\n    }\n\n    /// caide keep\n    template <class T>\n    constexpr inline T max_mod(T*) {\n        return numeric_limits<T>::max() - 1;\n    }\n\n    \n    constexpr inline uint64_t combine_max_sum(uint64_t a, uint64_t b) {\n        return a > ~b ? 0 : a + b;\n    }\n\n    constexpr inline uint64_t combine_max_mul(uint64_t a, uint64_t b) {\n        return a > numeric_limits<uint64_t>::max() / b ? 0 : a * b;\n    }\n\n    /// caide keep\n    template <class T>\n    constexpr inline uint64_t next_divisible(T mod, uint64_t max) {\n        return max % mod == 0 ? max : combine_max_sum(max, mod - max % mod);\n    }\n\n    /// caide keep\n    template <class T>\n    constexpr inline uint64_t next_divisible(T*, uint64_t) {\n        return 0;\n    }\n\n    //caide keep\n    constexpr int IF_THRESHOLD = 2;\n\n    template <class T, T MOD_VALUE, uint64_t MAX,\n            class RET = typename template_util::minimal_uint<max_mod(MOD_VALUE)>::type,\n            ENABLE_IF(MAX <= max_mod(MOD_VALUE) && !is_pointer<T>::value)>\n    inline RET smart_mod(typename template_util::minimal_uint<MAX>::type value) {\n        return value;\n    }\n\n    template <class T, T MOD_VALUE, uint64_t MAX,\n            class RET = typename template_util::minimal_uint<max_mod(MOD_VALUE)>::type,\n            ENABLE_IF(max_mod(MOD_VALUE) < MAX && MAX <= IF_THRESHOLD * max_mod(MOD_VALUE) && !is_pointer<T>::value)>\n    inline RET smart_mod(typename template_util::minimal_uint<MAX>::type value) {\n        while (value >= mod(MOD_VALUE)) {\n            value -= mod(MOD_VALUE);\n        }\n        return (RET)value;\n    }\n\n    template <class T, T MOD_VALUE, uint64_t MAX,\n             class RET = typename template_util::minimal_uint<max_mod(MOD_VALUE)>::type,\n             ENABLE_IF(IF_THRESHOLD * max_mod(MOD_VALUE) < MAX || is_pointer<T>::value)>\n    inline RET smart_mod(typename template_util::minimal_uint<MAX>::type value) {\n        return (RET)(value % mod(MOD_VALUE));\n    }\n}\n\n#define MOD mod_impl::mod(MOD_VALUE)\n#define MAX_MOD mod_impl::max_mod(MOD_VALUE)\n\nstruct DenormTag {};\n\ntemplate <class T, T MOD_VALUE, uint64_t MAX = MAX_MOD, ENABLE_IF(MAX_MOD >= 2)>\nstruct ModVal {\n    typedef typename template_util::minimal_uint<MAX>::type storage;\n    storage value;\n\n    /// caide keep\n    inline ModVal(): value(0) {\n        assert(MOD >= 2);\n    }\n\n    \n    inline ModVal(storage v, DenormTag): value(v) {\n        assert(MOD >= 2);\n        assert(v <= MAX);\n    };\n\n    inline operator ModVal<T, MOD_VALUE>() {\n        return {v(), DenormTag()};\n    };\n\n    \n    typename template_util::minimal_uint<mod_impl::max_mod(MOD_VALUE)>::type v() const {\n        return mod_impl::smart_mod<T, MOD_VALUE, MAX>(value);\n    }\n};\n\ntemplate <class T, T MOD_VALUE, uint64_t MAX,\n        uint64_t NEW_MAX = mod_impl::next_divisible(MOD_VALUE, MAX),\n        ENABLE_IF(NEW_MAX != 0),\n        class Ret = ModVal<T, MOD_VALUE, NEW_MAX>>\ninline Ret operator-(const ModVal<T, MOD_VALUE, MAX>& o) {\n    static_assert(NEW_MAX <= numeric_limits<typename Ret::storage>::max(), \"bad unary minus template\");\n    assert(NEW_MAX % MOD == 0 && o.value <= NEW_MAX);\n    return {typename Ret::storage(NEW_MAX - o.value), DenormTag()};\n}\n\n\ntemplate <class T, T MOD_VALUE, uint64_t MAX1, uint64_t MAX2,\n        uint64_t NEW_MAX = mod_impl::combine_max_sum(MAX1, MAX2),\n        ENABLE_IF(NEW_MAX != 0), class Ret = ModVal<T, MOD_VALUE, NEW_MAX>>\ninline Ret operator+(ModVal<T, MOD_VALUE, MAX1> o1, ModVal<T, MOD_VALUE, MAX2> o2) {\n    return {typename Ret::storage(typename Ret::storage() + o1.value + o2.value), DenormTag()};\n}\n\n\ntemplate <class T, T MOD_VALUE, uint64_t MAX1, uint64_t MAX2,\n        uint64_t NEW_MAX = mod_impl::combine_max_mul(MAX1, MAX2),\n        ENABLE_IF(NEW_MAX != 0), class Ret = ModVal<T, MOD_VALUE, NEW_MAX>>\ninline Ret operator*(ModVal<T, MOD_VALUE, MAX1> o1, ModVal<T, MOD_VALUE, MAX2> o2) {\n    return {typename Ret::storage(typename Ret::storage(1) * o1.value * o2.value), DenormTag()};\n}\n\n\ntemplate <class T, T MOD_VALUE, uint64_t MAX1, uint64_t MAX2,\n        uint64_t NEW_MAX = mod_impl::combine_max_mul(MAX1, MAX2),\n        uint64_t NEW_MAX1 = mod_impl::combine_max_mul(MAX_MOD, template_util::min(MAX1, MAX2)),\n        ENABLE_IF(NEW_MAX == 0 && NEW_MAX1 != 0 && MAX2 < MAX1),\n        class Ret = ModVal<T, MOD_VALUE, mod_impl::combine_max_mul(MAX_MOD, MAX2)>>\ninline Ret operator*(const ModVal<T, MOD_VALUE, MAX1>& o1, const ModVal<T, MOD_VALUE, MAX2>& o2) {\n    return {typename Ret::storage(typename Ret::storage(1) * o1.v() * o2.value), DenormTag()};\n}\n\ntemplate <class T, T MOD_VALUE, uint64_t MAX1, uint64_t MAX2,\n        uint64_t NEW_MAX = mod_impl::combine_max_mul(MAX1, MAX2),\n        uint64_t NEW_MAX1 = mod_impl::combine_max_mul(MAX_MOD, template_util::min(MAX1, MAX2)),\n        ENABLE_IF(NEW_MAX == 0 && NEW_MAX1 == 0),\n        class Ret = ModVal<T, MOD_VALUE, mod_impl::combine_max_mul(MAX_MOD, MAX_MOD)>>\ninline Ret operator*(const ModVal<T, MOD_VALUE, MAX1>& o1, const ModVal<T, MOD_VALUE, MAX2>& o2) {\n    return {typename Ret::storage(typename Ret::storage(1) * o1.v() * o2.v()), DenormTag()};\n}\n\n\ntemplate <class T, T MOD_VALUE, uint64_t MAX>\ninline ModVal<T, MOD_VALUE>& operator+=(ModVal<T, MOD_VALUE>& lhs, const ModVal<T, MOD_VALUE, MAX>& rhs) {\n    lhs = lhs + rhs;\n    return lhs;\n}\n\n\ntemplate <class T, T MOD_VALUE, class MOD_TYPE>\nstruct ModCompanion {\n    typedef MOD_TYPE mod_type;\n    typedef ModVal<mod_type, MOD_VALUE> type;\n    \n\n    template <uint64_t C>\n    inline static constexpr ModVal<mod_type, MOD_VALUE, C> c() {\n        return {C, DenormTag()};\n    };\n\n    template <uint64_t MAX = numeric_limits<uint64_t>::max()>\n    inline static ModVal<mod_type, MOD_VALUE, MAX> wrap(uint64_t x) {\n        assert(x <= MAX);\n        return {typename ModVal<mod_type, MOD_VALUE, MAX>::storage(x), DenormTag()};\n    };\n\n    template <uint64_t MAX, ENABLE_IF(!is_pointer<T>::value && MAX <= MAX_MOD)>\n    inline static ModVal<mod_type, MOD_VALUE> inv(const ModVal<mod_type, MOD_VALUE, MAX>& x) {\n        if (x.value == 1) {\n            return c<1>();\n        }\n        return -(wrap<MAX_MOD / 2>(MOD / x.value) * inv(wrap<MAX>(MOD % x.value)));\n    };\n\n    \n    template <uint64_t MAX>\n    inline static ModVal<mod_type, MOD_VALUE> pow(const ModVal<mod_type, MOD_VALUE, MAX>& x, uint64_t n) {\n        if (n == 0) {\n            return c<1>();\n        }\n        auto v = pow(x * x, n / 2);\n        return (n & 1) ? x * v : v;\n    };\n};\n\n\n#undef MOD\n#undef MAX_MOD\n\ntemplate <uint64_t MOD_VALUE>\nstruct Mod : ModCompanion<uint64_t, MOD_VALUE, typename template_util::minimal_uint<MOD_VALUE>::type> {\n    template<uint64_t VAL>\n    static constexpr uint64_t literal_builder() {\n        return VAL;\n    }\n\n    template<uint64_t VAL, char DIGIT, char... REST>\n    static constexpr uint64_t literal_builder() {\n        return literal_builder<(10 * VAL + DIGIT - '0') % MOD_VALUE, REST...>();\n    }\n};\n\n\n#define REGISTER_MOD_LITERAL(mod, suffix) \\\ntemplate <char... DIGITS> mod::type operator \"\" _##suffix() { \\\n    return mod::c<mod::literal_builder<0, DIGITS...>()>(); \\\n}\n\n\ntemplate <class T, T MOD_VALUE, uint64_t MAX>\ninline ostream& operator<<(ostream& s, ModVal<T, MOD_VALUE, MAX> val) {\n    s << val.v();\n    return s;\n}\n\n\nnamespace option_detail {\n    /// caide keep\n    struct NoneHelper {};\n}\n\n\ntemplate<class Value>\nclass Option {\npublic:\n    \n\n    static_assert(!std::is_reference<Value>::value,\n                  \"Option may not be used with reference types\");\n    static_assert(!std::is_abstract<Value>::value,\n                  \"Option may not be used with abstract types\");\n\n    \n    Value* get_pointer() && = delete;\n\n    \n    // Return b copy of the value if set, or b given default if not.\n    \n\n    // Return b copy of the value if set, or b given default if not.\n    \n\nprivate:\n    \n\n    struct StorageTriviallyDestructible {\n        // uninitialized\n        \n        bool hasValue;\n\n        \n    };\n\n    /// caide keep\n    struct StorageNonTriviallyDestructible {\n        // uninitialized\n        union { Value value; };\n        bool hasValue;\n\n        \n        ~StorageNonTriviallyDestructible() {\n            clear();\n        }\n\n        void clear() {\n            if (hasValue) {\n                hasValue = false;\n                value.~Value();\n            }\n        }\n    };\n\n    /// caide keep\n    using Storage =\n    typename std::conditional<std::is_trivially_destructible<Value>::value,\n            StorageTriviallyDestructible,\n            StorageNonTriviallyDestructible>::type;\n\n    Storage storage_;\n};\n\n\n// Comparisons.\n\n\ntemplate<class V> bool operator< (const Option<V>&, const V& other) = delete;\ntemplate<class V> bool operator<=(const Option<V>&, const V& other) = delete;\ntemplate<class V> bool operator>=(const Option<V>&, const V& other) = delete;\ntemplate<class V> bool operator> (const Option<V>&, const V& other) = delete;\ntemplate<class V> bool operator< (const V& other, const Option<V>&) = delete;\ntemplate<class V> bool operator<=(const V& other, const Option<V>&) = delete;\ntemplate<class V> bool operator>=(const V& other, const Option<V>&) = delete;\ntemplate<class V> bool operator> (const V& other, const Option<V>&) = delete;\n\n\nnamespace index_iterator_impl {\n    template <class T>\n    struct member_dispatch_helper {\n        \n\n    private:\n        T value;\n    };\n\n    // Have to caide keep all the members to comply to iterator concept\n    // Otherwise generated code won't be portable between clang and g++\n    template <class C, bool reverse = false>\n    struct index_iterator {\n        /// caide keep\n        typedef random_access_iterator_tag iterator_category;\n        /// caide keep\n        typedef decltype(((C*)nullptr)->operator[](size_t(0))) reference;\n        /// caide keep\n        typedef typename remove_reference<reference>::type value_type;\n        /// caide keep\n        typedef ptrdiff_t difference_type;\n        /// caide keep\n        typedef conditional<\n                is_reference<reference>::value,\n                typename add_pointer<value_type>::type,\n                member_dispatch_helper<value_type>> pointer;\n\n        /// caide keep\n        typedef index_iterator<C, reverse> self_t;\n\n        /// caide keep\n        static const difference_type dir = reverse ? -1 : 1;\n\n        /// caide keep\n        index_iterator() = default;\n\n        \n        /// caide keep\n        inline bool operator!=(const self_t& o) { return index != o.index; }\n        /// caide keep\n        inline bool operator<(const self_t& o) { return reverse ? index > o.index : index < o.index; }\n        /// caide keep\n        inline bool operator>(const self_t& o) { return reverse ? index < o.index : index > o.index; }\n        /// caide keep\n        inline bool operator<=(const self_t& o) { return reverse ? index >= o.index : index <= o.index; }\n        /// caide keep\n        inline bool operator>=(const self_t& o) { return reverse ? index <= o.index : index >= o.index; }\n\n        /// caide keep\n        inline reference operator*() { return (*container)[index]; }\n        /// caide keep\n        inline const reference operator*() const { return (*container)[index]; }\n        /// caide keep\n        inline pointer operator->() { return pointer((*container)[index]); }\n\n        /// caide keep\n        inline self_t& operator++() { index += dir; return *this; }\n        /// caide keep\n        inline self_t operator++(int) { auto copy = *this; index += dir; return copy; }\n        /// caide keep\n        inline self_t& operator--() { index -= dir; return *this; }\n        /// caide keep\n        inline self_t operator--(int) { auto copy = *this; index -= dir; return copy; }\n\n        /// caide keep\n        inline self_t& operator+=(difference_type n) { index += dir * n; return *this; };\n        /// caide keep\n        inline self_t& operator-=(difference_type n) { index -= dir * n; return *this; };\n        /// caide keep\n        inline friend self_t operator-(self_t a, difference_type n) { return a -= n; };\n        /// caide keep\n        inline friend self_t operator+(difference_type n, self_t a) { return a += n; };\n        /// caide keep\n        inline friend self_t operator+(self_t a, difference_type n) { return a += n; };\n        /// caide keep\n        inline friend difference_type operator-(const self_t& a, const self_t& b) { return dir * (a.index - b.index); };\n\n        /// caide keep\n        inline reference operator[](difference_type n) { return (*container)[index + dir * n]; };\n        /// caide keep\n        inline const reference operator[](difference_type n) const { return (*container)[index + dir * n]; };\n\n    private:\n        C* container;\n        difference_type index;\n    };\n}\n\n\nnamespace multivec_impl {\n    template <size_t NDIMS>\n    struct shape {\n        size_t dim, stride;\n        shape<NDIMS - 1> subshape;\n        \n        shape(size_t dim_, shape<NDIMS - 1>&& s): dim(dim_), stride(s.size()), subshape(std::move(s)) {}\n        size_t size() const { return dim * stride; }\n        \n        \n    };\n    template <> struct shape<0> { size_t size() const { return 1; } };\n    \n\n    template <size_t I, size_t NDIMS>\n    struct __shape_traverse {\n        \n\n        ///caide keep\n        static const shape<NDIMS - I>& get_subshape(const shape<NDIMS>& s) {\n            return __shape_traverse<I - 1, NDIMS - 1>::get_subshape(s.subshape);\n        }\n    };\n\n    \n    ///caide keep\n    template <size_t I, size_t NDIMS>\n    const shape<NDIMS - I>& get_subshape(const shape<NDIMS>& s) { return __shape_traverse<I, NDIMS>::get_subshape(s); }\n\n    \n    template <class Index, class... Rest, size_t NDIMS, ENABLE_IF(is_integral<Index>::value)>\n    size_t get_shift(const shape<NDIMS>& s, size_t cur_shift, Index i, Rest... is) {\n        assert(0 <= i && i < s.dim);\n        return get_shift(s.subshape, cur_shift + i * s.stride, is...);\n    }\n\n    template <size_t NDIMS> size_t get_shift(const shape<NDIMS>&, size_t cur_shift) { return cur_shift; }\n\n    \n    template <class... T> shape<sizeof...(T)> make_shape(T... dims);\n\n    template <class Dim, class... Rest, ENABLE_IF(is_integral<Dim>::value)>\n    shape<sizeof...(Rest) + 1> make_shape(Dim dim, Rest... dims) {\n        assert(dim >= 0);\n        return {(size_t)dim, make_shape<Rest...>(dims...)};\n    }\n\n    template <> shape<0> make_shape() { return {}; }\n\n    \n    ///caide keep\n    template <class T, size_t NDIMS>\n    struct vec_view_base;\n\n    template <template<class, size_t> class Base, class T, size_t NDIMS>\n    struct vec_mixin : public Base<T, NDIMS> {\n        using Base<T, NDIMS>::Base;\n        /// caide keep\n        typedef Base<T, NDIMS> B;\n        \n        \n        ///caide keep\n        template <class... Indices, bool enabled = NDIMS == sizeof...(Indices), ENABLE_IF(enabled)>\n        inline T& operator()(Indices... is) {\n            size_t i = multivec_impl::get_shift(B::s, 0, is...);\n            return B::data[i];\n        }\n\n        ///caide keep\n        template <class... Indices, bool enabled = sizeof...(Indices) < NDIMS, ENABLE_IF(enabled)>\n        inline vec_mixin<vec_view_base, T, NDIMS - sizeof...(Indices)> operator()(Indices... is) {\n            size_t shift = multivec_impl::get_shift(B::s, 0, is...);\n            const auto& subshape = multivec_impl::get_subshape<sizeof...(Indices)>(B::s);\n            return {subshape, &B::data[shift]};\n        }\n\n        \n        inline void fill(const T& val) {\n            std::fill(raw_data(), raw_data() + B::s.size(), val);\n        };\n\n        \n//    protected:\n        inline T* raw_data() {\n            return &B::data[0];\n        }\n\n        \n    };\n\n    template <class T, size_t NDIMS>\n    struct vec_view_base {\n        \n        \n    protected:\n        multivec_impl::shape<NDIMS> s;\n        T* data;\n    };\n\n    template <class T, size_t NDIMS>\n    struct vec_base {\n        inline vec_base(multivec_impl::shape<NDIMS>&& s_): s(move(s_)), data(new T[s.size()]) {}\n        \n        \n        inline vec_base(const vec_base& o): s(o.s), data(new T[s.size()]) {\n            memcpy(data.get(), o.data.get(), sizeof(T) * s.size());\n        }\n        \n    protected:\n        multivec_impl::shape<NDIMS> s;\n        unique_ptr<T[]> data;\n    };\n}\n\n/*\nTODO\n - do we need vec_view_const?\n - add more features (lambda initialization etc.)\n - properly use const\n - proper tests coverage\n*/\n\ntemplate <class T, size_t NDIMS>\nusing vec = multivec_impl::vec_mixin<multivec_impl::vec_base, T, NDIMS>;\n\n\ntemplate <class T, class... NDIMS>\ninline vec<T, sizeof...(NDIMS)> make_vec(NDIMS... dims) {\n    return {multivec_impl::make_shape(dims...)};\n}\n\n\ntemplate<class T>\nT next(istream& in) {\n    T ret;\n    in >> ret;\n    return ret;\n}\n\n\n// ^^^^^^^^^^^^^^^^^ Library code end\n\nconst uint32_t mod = 1000000007;\nusing md = Mod<mod>;\nusing mt = md::type;\nREGISTER_MOD_LITERAL(md, mod)\n\nvoid solve(istream& in, ostream& out) {\n    int n = next<int>(in);\n    int k = next<int>(in);\n    if (k == 1) {\n        out << \"1\\n\";\n        return;\n    }\n    vector<mt> f(n * k + 1), invF(n * k + 1);\n    f[0] = 1_mod;\n    forn (int, i, n * k) {\n        f[i + 1] = f[i] * md::wrap<4000000>(i + 1);\n    }\n    invF[n * k] = md::inv(f[n * k]);\n    rforn (int, i, n * k) {\n        invF[i] = invF[i + 1] * md::wrap<400000>(i + 1);\n    }\n    auto C = [&](int n, int k) -> mt {\n        if (n < 0) {\n            return 0_mod;\n        }\n        return f[n] * invF[k] * invF[n - k];\n    };\n    auto din = make_vec<mt>(n + 1, n + 1);\n    din.fill(0_mod);\n    din(0, 0) = 1_mod;\n    forn (int, i, n + 1) {\n        forn (int, j, i + 1) {\n            if (i < n) {\n                din(i + 1, j) += din(i, j);\n            }\n            if (j < i) {\n                din(i, j + 1) += din(i, j) * f[n * k - i - j * (k - 1) - 1] * invF[n * k - i - (j + 1) * (k - 1)];\n            }\n        }\n    }\n    out << din(n, n) * f[n] * md::pow(invF[k - 2], n) << \"\\n\";\n}\n\n\nint main() {\n    solve(cin, cout);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nconst int M = 2010;\nconst int N = M * M;\nconst int moder = 1e9 + 7;\n\nint powermod(int a, int exp){\n\tint ret = 1;\n\tfor ( ; exp > 0; exp >>= 1){\n\t\tif (exp & 1){\n\t\t\tret = 1ll * ret * a % moder;\n\t\t}\n\t\ta = 1ll * a * a % moder;\n\t}\n\treturn ret;\n}\n\nint fac[N], inv[N];\nint dp[M][M];\n\nint comb(int n, int m){\n\tif (n < m || m < 0) return 0;\n\treturn 1ll * fac[n] * inv[m] % moder * inv[n - m] % moder;\n}\n\nint main(){\n\tfac[0] = 1;\n\tfor (int i = 1; i < N; ++ i){\n\t\tfac[i] = 1ll * fac[i - 1] * i % moder;\n\t}\n\tinv[N - 1] = powermod(fac[N - 1], moder - 2);\n\tfor (int i = N - 1; i; -- i){\n\t\tinv[i - 1] = 1ll * inv[i] * i % moder;\n\t}\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tif (k == 1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= n; ++ i){\n\t\tdp[i][0] = 1ll * dp[i - 1][0] * comb(i * (k - 1) - 1, k - 2) % moder;\n\t\tfor (int j = 1; j <= i; ++ j){\n\t\t\tif (j < i){\n\t\t\t\tdp[i][j] = 1ll * dp[i - 1][j] * comb(j + i * (k - 1) - 1, k - 2) % moder;\n\t\t\t}\n\t\t\tdp[i][j] += dp[i][j - 1];\n\t\t\tdp[i][j] -= dp[i][j] >= moder ? moder : 0;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", 1ll * fac[n] * dp[n][n] % moder);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define ld long double\n#define F first\n#define S second\n\nusing namespace :: std;\n\nconst ll maxn=4100;\nconst ll mod=1e9+7;\nconst ll inf=1e9+500;\n\n\nll dp[maxn][2*maxn];\nll par[maxn][2*maxn];\n\n\nll fac[maxn*maxn];\nll rfac[maxn*maxn];\n\nll  ent(ll n,ll k){\n\tif(k>n || k<0){\n\t\treturn 0;\n\t}\n\treturn (((fac[n]*rfac[n-k])%mod)*rfac[k])%mod;\n}\t\nll poww(ll a,ll b){\n\tll ans=1;\n\twhile(b>0){\n\t\tif(b&1){\n\t\t\tans=(ans*a)%mod;\n\t\t}\n\t\ta=(a*a)%mod;\n\t\tb=(b>>1);\n\t}\n\treturn ans;\n}\nint main(){\n\n\tfac[0]=1;\n\tfor(ll i=1;i<maxn*maxn;i++){\n\t\tfac[i]=(fac[i-1]*i)%mod;\n\t}\t\n\tfor(ll i=0;i<maxn*maxn;i++){\n\t\trfac[i]=poww(fac[i],mod-2);\n\t}\n\n\n\n\n\tll n,k;\n\tcin>>n>>k;\n\n\tif(k==1){\n\t\tcout<<1;\n\t\treturn 0;\n\t}\n\tdp[1][1]=1;\n\tpar[1][1]=1;\n\tfor(ll j=2;j<2*maxn;j++){\n\t\tpar[1][j]=par[1][j-1];\n\t}\n\tfor(ll i=2;i<=n;i++){\n\t\tfor(ll j=1;j<2*i;j++){\n\t\t\tdp[i][j]=ent(j+(k-2)*i-1,k-2)*par[i-1][j-1];\n\t\t\tpar[i][j]=(par[i][j-1]+dp[i][j])%mod;\n\t\t}\n\t\tfor(ll j=2*i;j<2*maxn;j++){\n\t\t\tpar[i][j]=par[i][j-1];\n\t\t}\n\t}\n\tcout<<(par[n][2*maxn-5]*fac[n])%mod<<endl;\n\n}\n\n\n\n\n\n\n\n\n/*    \n\t  .      _______    __    ___     ________      ________       _________     _________   ________\n\t  .     /       \\  |  |  /  /    /        \\    |        \\     /         \\   |        |  |   __   \\\n\t  .    /   _____/  |  | /  /    /    ___   \\   |   ___   \\   |   _______/   |  ______|  |  |  \\   \\\n\t  .   /   /        |  |/  /    /    /   \\   \\  |  |   \\   \\  |  (______     |  |_____   |  |__/   /\n\t  .   |  |         |     /     |   /     \\  |  |  |    |  |   \\        \\    |        |  |      __/\n\t  .   |  |         |     \\     |   \\     /  |  |  |    |  |    \\______  \\   |  ______|  |      \\\n\t  .   \\   \\_____   |  |\\  \\    \\    \\___/   /  |  |___/   /    _______) |   |  |_____   |   |\\  \\\n\t  .    \\        \\  |  | \\  \\    \\          /   |         /    /         /   |        |  |   | \\  \\\n\t  .     \\_______/  |__|  \\__\\    \\________/    |________/     \\________/    |________|  |___|  \\__\\\n */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int N = 2005, mod = 1000 * 1000 * 1000 + 7;\n\n\nlong long fac[N * N];\nlong long dp[N][N];\nlong long ps[N][N];\n\nint po(int x, int y) {\n\tif (y == 0) {\n\t\treturn 1;\n\t}\n\tlong long ans = po(x, y / 2);\n\tans *= ans;\n\tans %= mod;\n\tif (y % 2) {\n\t\tans *= x;\n\t\tans %= mod;\n\t}\n\treturn ans;\n}\nint chs(int x, int y) {\n\tlong long ans = fac[x];\n\tans *= po(fac[y], mod - 2);\n\tans %= mod;\n\tans *= po(fac[x - y], mod - 2);\n\tans %= mod;\n\treturn ans;\n}\nint main() {\n\tint n, k;\n\tcin >> n >> k;\n\tif (k == 1) {\n\t\tcout << 1;\n\t\treturn 0;\n\t}\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n * k; i++) {\n\t\tfac[i] = fac[i - 1] * i;\n\t\tfac[i] %= mod;\n\t}\n\tdp[1][1] = 1;\n\tps[1][1] = 1;\n//\tcout << chs(4, 2) << endl;\n\tfor (int i = 2; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tdp[i][j] = ps[i - 1][i - 1];\n\t\t\tif (j - 2 >= 0) {\n\t\t\t\tdp[i][j] -= ps[i - 1][j - 2] - mod;\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t\tdp[i][j] *= i;\n\t\t\tdp[i][j] %= mod;\n\t\t\tdp[i][j] *= chs(i * k - j - 1, k - 2);\n\t\t\tdp[i][j] %= mod;\n\t\t//\tcout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t\t\tps[i][j] = ps[i][j - 1] + dp[i][j];\n\t\t\tps[i][j] %= mod;\n\t\t}\n\t}\n\tcout << ps[n][n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int mod = 1e9 + 7;\n\nint n,k;\nint dp[2050][2050];\n\nint fac[4000050],inv[4000050];\nint ksm(int x,int y){\n    int z = 1;\n    while(y){\n        if(y & 1) z = z * x % mod;\n        y >>= 1;\n        x = x * x % mod;\n    }\n    return z;\n}\nint C(int n,int m){\n    if(n < m || m < 0) return 0;\n    if(n == m || m == 0) return 1;\n    return (fac[n] * inv[m] % mod) * inv[n - m] % mod;\n}\n\nsigned main(){\n    scanf(\"%lld%lld\",&n,&k);\n    \n    fac[0] = 1;\n    for(int i = 1; i <= 4000000; ++ i) fac[i] = fac[i - 1] * i % mod;\n    inv[4000000] = ksm(fac[4000000],mod - 2);\n    for(int i = 3999999; i >= 0; -- i) inv[i] = inv[i + 1] * (i + 1) % mod;\n    \n    if(k == 1) { puts(\"1\"); return 0; } \n    \n    dp[0][0] = 1;\n    for(int i = 1; i <= n; ++ i){\n        dp[i][0] = 1;\n        for(int j = 1; j <= i; ++ j){\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] * C(n * k - i - (j - 1) * (k - 1) - 1, k - 2) % mod * (n - j + 1) % mod ) % mod; \n        }\n    }\n    \n    printf(\"%lld\\n\",dp[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define Int register int\n#define mod 1000000007\n#define MAXN 2005\n\ntemplate <typename T> inline void read (T &t){t = 0;char c = getchar();int f = 1;while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}while (c >= '0' && c <= '9'){t = (t << 3) + (t << 1) + c - '0';c = getchar();} t *= f;}\ntemplate <typename T,typename ... Args> inline void read (T &t,Args&... args){read (t);read (args...);}\ntemplate <typename T> inline void write (T x){if (x < 0){x = -x;putchar ('-');}if (x > 9) write (x / 10);putchar (x % 10 + '0');}\n\nint n,k,fac[MAXN * MAXN],ifac[MAXN * MAXN],dp[MAXN][MAXN];\nint mul (int a,int b){return 1ll * a * b % mod;}\nint dec (int a,int b){return a >= b ? a - b : a + mod - b;}\nint add (int a,int b){return a + b >= mod ? a + b - mod : a + b;}\nint qkpow (int a,int b){int res = 1;for (;b;b >>= 1,a = mul (a,a)) if (b & 1) res = mul (res,a);return res;}\nint binom (int a,int b){return mul (fac[a],mul (ifac[b],ifac[a - b]));}\n\nsigned main(){\n\tread (n,k);\n\tif (k == 1) return puts (\"1\"),0;fac[0] = 1;\n\tfor (Int i = 1;i <= n * k;++ i) fac[i] = mul (fac[i - 1],i);\n\tifac[n * k] = qkpow (fac[n * k],mod - 2);for (Int i = n * k;i;-- i) ifac[i - 1] = mul (ifac[i],i);\n\tfor (Int i = 0;i <= n;++ i) dp[i][0] = 1;\n\tfor (Int i = 1;i <= n;++ i)\n\t\tfor (Int j = 1;j <= i;++ j)\n\t\t\tdp[i][j] = add (dp[i - 1][j],mul (dp[i][j - 1],binom (n * k - (k - 1) * (j - 1) - 1 - i,k - 2)));\n\twrite (mul (dp[n][n],fac[n])),putchar ('\\n');\n\treturn 0;\n}\n/*\ndp[i][j]表示前面i个白球，j个颜色已经填满了\ndp[i][j]=dp[i-1][j]+dp[i][j-1]*C(n*k-(k-1)*(j-1)-1-i,k-2) \ndp[n][n]*n!\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define e1 first\n#define e2 second\n#define pb push_back\n#define mp make_pair\n#define boost ios_base::sync_with_stdio(false)\n#define eb emplace_back\n#define OUT(x) {cout << x; exit(0); }\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define scanf(...) scanf(__VA_ARGS__)?:0\ntypedef long long int ll;\ntypedef unsigned long long ull;\ntypedef pair <int, int> PII;\ntypedef pair <ll, ll> PLL;\ntypedef pair <PLL, int> PLLI;\ntypedef pair <PLL, PLL> PP;\ntypedef pair <PII, int> PPI;\ntypedef pair <ll, int> PLI;\ntypedef unsigned int ui;\nconst int inf = 1e9+9;\nconst int mod = 1e9+7;\n#define maxn 2010\nconst int MX = 4e6;\nll fac[4000100], invfac[4000100];\n\nll potmod(ll a, ll b)\n{\n\tll res = 1;\n\twhile (b > 0)\n\t{\n\t\tif (b & 1) res = (res * a ) % mod;\n\t\ta = (a * a)%mod;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\ninline ll binom(int n, int k)\n{\n\treturn fac[n] * invfac[k] % mod * invfac[n - k] % mod;\n}\n\nint dp[2010][2010];\n\nint main()\n{\n\tfac[0] = invfac[0] = 1;\n\tFOR(i, 1, MX) \n\t{\n\t\tfac[i] = fac[i-1] * i % mod;\n\t}\n\tinvfac[MX] = potmod(fac[MX], mod - 2);\n\tfor (int i=MX-1; i>0; --i) invfac[i] = (invfac[i + 1] * (i + 1))%mod;\n\tint n , k;\n\tcin >> n >> k;\n\tif (n == 1) OUT(1);\n\tif (k == 1) OUT(1);\n\t\n\tdp[0][0] = 1;\n\tfor (int j=1; j<=n; ++j)\n\t{\n\t\tdp[0][j] = binom(j * (k - 1) - 1, k - 2) * dp[0][j-1] % mod;\n\t}\n\t\n\tfor (int i=1; i<=n; ++i)\n\t{\n\t\tfor (int j=i; j<=n; ++j)\n\t\t{\n\t\t\tif (i == j) dp[i][j] = dp[i-1][j];\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\tll res = binom(i + j * (k - 1) - 1, k - 2);\n\t\t\t\tres %= mod;\n\t\t\t\tres *= dp[i][j-1]; res %= mod;\n\t\t\t\tdp[i][j] += res;\n\t\t\t\twhile (dp[i][j] >= mod) dp[i][j] -= mod;\n\t\t\t}\n\t\t\t//if (dp[i][j] > 0) cout << \"i, j: \" << i << ' ' << j << \" res : \" << dp[i][j] << endl;\n\t\t}\n\t}\n\t\t\n\tcout << (ll)dp[n][n] * fac[n] % mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=2e3+2;\nconst int maxx=maxn*maxn;\nconst int q=1e9+7;\ninline int Plus(int x,int y) {return (x+=y)>=q?x-q:x;}\ninline void Pe(int &x,int y) {x=Plus(x,y);}\ninline int Multi(int x,int y) {return 1ll*x*y%q;}\ninline void Me(int &x,int y) {x=Multi(x,y);}\nnamespace num {\n\tint fac[maxx],ifac[maxx],inv[maxx];\n\tinline int C(int n,int m) {return n<m?0:Multi(Multi(fac[n],ifac[m]),ifac[n-m]);}\n\tvoid init() {\n\t\tfac[0]=fac[1]=ifac[0]=ifac[1]=inv[0]=inv[1]=1;\n\t\tfor (int i=2;i<maxx;++i) {\n\t\t\tinv[i]=Multi(q-q/i,inv[q%i]);\n\t\t\tfac[i]=Multi(fac[i-1],i);\n\t\t\tifac[i]=Multi(ifac[i-1],inv[i]);\n\t\t}\n\t}\n}\nint n,k,f[maxn];\nint main() {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"test.in\",\"r\",stdin);\n#endif\n\tnum::init();\n\tcin>>n>>k;\n\tif (k==1) puts(\"1\"),exit(0);\n\tf[0]=1;\n\tfor (int i=1;i<=n;++i,f[0]=f[1]) {\n\t\tfor (int j=i;j;--j) {\n\t\t\tint tmp=num::C((i-1)*k-(j-1)+k-2,k-2);\n\t\t\tf[j]=Plus(Multi(Multi(n-i+1,f[j-1]),tmp),f[j+1]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rint register int\nusing namespace std;\n// by piano\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0; char c = getchar(); int f = 0;\n  for(; c < '0' || c > '9'; f |= c == '-', c = getchar());\n  for(; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if(f) x = -x;\n}\nconst int N = 4e6 + 233;\nnamespace {\n  const int mo = 1e9 + 7;\n  inline int add(int x, int y) {\n    if((x += y) >= mo) x -= mo;\n    return x;\n  }\n  inline int sub(int x, int y) {\n    if((x -= y) < 0) x += mo;\n    return x;\n  }\n  inline int mul(int x, int y) {\n    return x * y % mo;\n  }\n  inline int pw(int a, int k, int mo) {\n    int ans = 1;\n    for(; k; k >>= 1, a = mul(a, a))\n      if(k & 1) ans = mul(ans, a);\n    return ans;\n  }\n  inline void U(int &x, int y) {\n    x = add(x, y);\n  }\n}\nint fac[N], fac_inv[N], dp[2333][2333];\nint n, k;\ninline void init(void) {\n  fac[0] = 1;\n  for(int i = 1; i < N; i ++)\n    fac[i] = mul(fac[i - 1], i);\n  fac_inv[N - 1] = pw(fac[N - 1], mo - 2, mo);\n  for(int i = N - 2; i >= 0; i --)\n    fac_inv[i] = mul(fac_inv[i + 1], i + 1);\n}\n\ninline int C(int n, int m) {\n  if(n < m) return 0;\n  else if(n == m || m == 0) return 1;\n  else return mul(fac[n], mul(fac_inv[m], fac_inv[n - m]));\n}\n\nmain(void) {\n  init();\n  read(n); read(k);\n  if(k == 1) return cout << fac[n] << \"\\n\", 0;\n  dp[0][0] = 1;\n  for(int i = 1; i <= n; i ++) {\n    for(int j = 0; j <= i; j ++) {\n      if(j) U(dp[i][j], mul(dp[i][j - 1], C(n * k - i - (j - 1) * (k - 1) - 1, k - 2)));\n      U(dp[i][j], dp[i - 1][j]);\n    }\n  }\n  int ans = mul(dp[n][n], fac[n]);\n  cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int maxn=2005;\nconst int ha=1000000007;\nint jc[maxn*maxn],ni[maxn*maxn];\nint n,k,f[maxn][maxn];\n \ninline int add(int x,int y){\n    x+=y;\n    return x>=ha?x-ha:x;\n}\n \ninline int ksm(int x,int y){\n    int an=1;\n    for(;y;y>>=1,x=x*(ll)x%ha) if(y&1) an=an*(ll)x%ha;\n    return an;\n}\n \ninline void init(){\n    jc[0]=1;\n    for(int i=1;i<=4004000;i++) jc[i]=jc[i-1]*(ll)i%ha;\n    ni[4004000]=ksm(jc[4004000],ha-2);\n    for(int i=4004000;i;i--) ni[i-1]=ni[i]*(ll)i%ha;\n}\n \ninline int getC(int x,int y){\n    return jc[x]*(ll)ni[y]%ha*(ll)ni[x-y]%ha;\n}\n \ninline void dp(){\n    f[0][0]=1;\n    for(int i=0;i<=n;i++)\n        for(int j=i;j>=0;j--) if(f[i][j]){\n            f[i+1][j+1]=add(f[i+1][j+1],f[i][j]*(ll)(n-i)%ha*(ll)getC(k*(i+1)-j-2,k-2)%ha);\n            if(j) f[i][j-1]=add(f[i][j-1],f[i][j]);\n        }\n     \n    /*\n    for(int i=0;i<=n;i++){\n        for(int j=0;j<=i;j++) printf(\"%d \",f[i][j]);\n        puts(\"\");\n    }\n    */\n}\n \nint main(){\n    init();\n    scanf(\"%d%d\",&n,&k);\n    if(k==1) puts(\"1\");\n    else{\n        dp();\n        printf(\"%d\\n\",f[n][0]);\n    }\n    return 0;\n}\n/*\n仅有一个序列中的每一个白球都能在其后方匹配到一个是其颜色里出现第一次的彩球，\n这个序列才合法。\n\n    从后向前dp,\n    \n    f[i][j] 表示 已经完整出现过 i种颜色的球，\n    并且还剩j种颜色的球没有被匹配的方案数。\n     \n    考虑加入一种新球的话:\n    f[i+1][j+1] += f[i][j] * (n-i) * C(k*(i+1)-j-2,k-2)\n     \n    考虑加入一种白球的话:\n    f[i][j-1] += f[i][j]\n     \n    初始化 f[0][0] = 1\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll MAX_N = 5000 + 10, MOD = 1e9 + 7;\nll n, k, dp[MAX_N][MAX_N], fac[MAX_N * MAX_N], en[MAX_N * MAX_N], r;\nll pw(int x,int y){\n\tif(!y) return 1ll;\n\tll t = pw(x, y / 2);\n\tt = 1ll * t * t % MOD;\n\tif(y & 1) t = 1ll * t * x % MOD;\n\treturn t;\n}\nint main(){\n    cin>>n>>k;\n    fac[0] = 1;\n    for(int i = 1; i <= n * k; i++){\n        fac[i] = fac[i - 1] * i;\n        fac[i] %= MOD;\n    }\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j <= n; j++){\n            if(j > 0){\n                if(en[i * k + j * (k - 1) - 1] == 0){\n                    r = fac[i * k + j * (k - 1) - 1] * pw(fac[k - 2], MOD - 2) % MOD * pw(fac[i * k + j * (k - 1) - 1 - (k - 2)], MOD - 2) % MOD;\n                    en[i * k + j * (k - 1) - 1] = r;\n                }\n                else{\n                    r = en[i * k + j * (k - 1) - 1];\n                }\n            }\n            if(i > 0 && j > 0){\n                dp[i][j] = dp[i - 1][j + 1] + (dp[i][j - 1] * r) % MOD;\n            }\n            else if(i == 0 && j > 0){\n                dp[i][j] = dp[i][j - 1] * r;\n            }\n            else if(i > 0 && j == 0){\n                dp[i][j] = dp[i - 1][j + 1];\n            }\n            else{\n                dp[i][j] = 1;\n            }\n            dp[i][j] %= MOD;\n        }\n    }\n    /*for(int i = 0; i <= n; i++){\n        for(int j = 0; j <= n; j++){\n            cout<<dp[i][j]<<\"  \";\n        }\n        cout<<endl;\n    }*/\n    ll ans = 1ll * dp[n][0] * fac[n] % MOD;\n    cout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#define file(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout);\nusing namespace std;\nconst int MAXN = 2005;\nconst int MOD = 1e9 + 7;\nint n, K;\nint jc[MAXN * MAXN] = {1}, inv[MAXN * MAXN];\nint f[MAXN][MAXN];\n\nint quick_pow(int a, int x) {\n    int res = 1;\n    while (x) {\n        if (x & 1)\n            res = 1ll * res * a % MOD;\n        a = 1ll * a * a % MOD, x >>= 1;\n    }\n    return res;\n}\n\nint calc_C(int n, int r) {\n    if (n < r)\n        return 0;\n    return 1ll * jc[n] * inv[r] % MOD * inv[n - r] % MOD;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &K);\n    if (K == 1) {\n        printf(\"1\");\n        return 0;\n    }\n    for (int i = 1; i <= n * n; i++)\n        jc[i] = 1ll * jc[i - 1] * i % MOD;\n    inv[n * n] = quick_pow(jc[n * n], MOD - 2);\n    for (int i = n * n; i; i--)\n        inv[i - 1] = 1ll * i * inv[i] % MOD;\n    f[0][0] = 1;\n    for (int i = 0; i <= n; i++)\n        for (int j = 0; j <= n; j++) {\n            if (i != j)\n                f[i + 1][j] = (f[i + 1][j] + f[i][j]) % MOD;\n            f[i][j + 1] = (f[i][j + 1] + 1ll * f[i][j] * calc_C((j + 1) * (K - 1) + i - 1, K - 2) % MOD) % MOD;\n        }\n    printf(\"%lld\", 1ll * f[n][n] * jc[n] % MOD);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Ho-kago Tea Time\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MOD = (int) 1e9 + 7;\n\nconst int MAXN = (int) 2e3;\n\nnamespace MATH\n{\n\tinline int fpm(int x, int y)\n\t{\n\t\tint res = 1;\n\t\tfor(; y; y >>= 1, x = (LL) x * x % MOD) if(y & 1) res = (LL) res * x % MOD;\n\t\treturn res;\n\t}\n\n\tconst int n = MAXN * MAXN;\n\n\tint fac[n + 5], ifac[n + 5];\n\n\tinline int C(int N, int M) { return N < M ? 0 : (LL) fac[N] * ifac[N - M] % MOD * ifac[M] % MOD; }\n\n\tinline void init()\n\t{\n\t\tfac[0] = 1;\n\t\tfor(int i = 1; i <= n; ++i) fac[i] = (LL) fac[i - 1] * i % MOD;\n\t\tifac[n] = fpm(fac[n], MOD - 2);\n\t\tfor(int i = n - 1; i >= 0; --i) ifac[i] = (LL) ifac[i + 1] * (i + 1) % MOD;\n\t}\n}\nusing MATH::fac;\nusing MATH::ifac;\nusing MATH::C;\n\ninline int div_to(int N, int M) { return C(N + M - 1, M - 1); }\n\nint n, m;\n\ninline void input()\n{\n\tn = read<int>(), m = read<int>();\n}\n\ninline void solve()\n{\n\tif(m == 1) { puts(\"1\"); return; }\n\n\tstatic int f[MAXN + 5][MAXN + 5];\n\n\tf[0][0] = 1;\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 0; j <= i; ++j)\n\t\t{\n\t\t\tf[i][j] = 0;\n\t\t\tif(j > 0) (f[i][j] += f[i][j - 1]) %= MOD;\n\t\t\t(f[i][j] += (LL) f[i - 1][j] * div_to(m - 2, (m - 1) * (i - 1) + j + 1) % MOD) %= MOD;\n\t\t}\n\n\tint ans = (LL) f[n][n] * fac[n] % MOD;\n\tprintf(\"%d\\n\", (ans + MOD) % MOD);\n}\n\nint main()\n{\n#ifdef K_ON // K-ON!\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tMATH::init();\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 1000000007\n#define ll long long\n#define N 2001\nint n, k;\nll fac[N * N], inv[N * N], dp[N][N] = {1};\nll Qpow(ll x, ll n) {\n    ll s = 1;\n    while (n) {\n        if (n & 1) s = s * x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return s;\n}\nll C(int n, int m) {\n    if (m < 0 || m > n) return 0;\n    return fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\nint main() {\n    scanf(\"%d%d\", &n, &k);\n    if (k == 1) {\n        puts(\"1\");\n        return 0;\n    }\n    for (int i = fac[0] = 1; i <= n * k; i++) fac[i] = fac[i - 1] * i % mod;\n    inv[n * k] = Qpow(fac[n * k], mod - 2);\n    for (int i = n * k; i; i--) inv[i - 1] = inv[i] * i % mod;\n    for (int i = 0; i <= n; i++)\n        for (int j = i; j <= n; j++) {\n            dp[i][j + 1] = (dp[i][j + 1] + dp[i][j]) % mod;\n            ll s = C(k * (n - i) - (j - i) - 1, k - 2) + dp[i + 1][j];\n            dp[i + 1][j] = dp[i][j] * s % mod;\n        }\n    printf(\"%lld\", dp[n][n] * fac[n] % mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n\ntypedef long long lint;\n\n#define MAXN 2005\n\nusing namespace std;\n\nint n, k;\nlint f[MAXN][MAXN], fac[MAXN * MAXN], inf[MAXN * MAXN];\nconst int mod = 1e9 + 7, N = 4000000;\n\nlint power(lint a, int b) {\n    lint res = 1;\n    while (b) {\n        if (b & 1)\n            res = res * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return res;\n}\n\nvoid init() {\n    inf[0] = fac[0] = 1;\n    for (int i = 1; i <= N; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    inf[N] = power(fac[N], mod - 2);\n    for (int i = N - 1; i >= 1; --i)\n        inf[i] = inf[i + 1] * (i + 1) % mod;\n}\n\nlint C(int n, int m) {\n    return fac[n] * inf[n - m] % mod * inf[m] % mod;\n}\n\nint main() {\n    init();\n    scanf(\"%d%d\", &n, &k);\n    if (k == 1) {\n        puts(\"1\");\n        return 0;\n    }\n    f[0][0] = 1;\n    for (int i = 1; i <= n; ++i)\n        for (int j = 0; j <= i; ++j)\n            if (!j)\n                f[i][j] = f[i - 1][j];\n            else\n                f[i][j] = (f[i - 1][j] + f[i][j - 1] * C(n * k - (j - 1) * (k - 1) - i - 1, k - 2) % mod * (n - j + 1) % mod) % mod;\n    printf(\"%lld\\n\", f[n][n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <bitset>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#define Rep(i, x, y) for (int i = x; i <= y; i ++)\n#define Dwn(i, x, y) for (int i = x; i >= y; i --)\n#define RepE(i, x) for (int i = pos[x]; i; i = g[i].nex)\n#define ev g[i].y\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst int mod = 1000000007, N = 2005, D = N * N;\nint n, m;\nll q[D + 5], p[D + 5], f[N][N];\nll C(int x, int y) {\n\treturn q[x] * p[y] % mod * p[x - y] % mod;\n}\nll mypow(ll x, int y) {\n\tll z = 1;\n\twhile (y) {\n\t\tif (y & 1) (z *= x) %= mod;\n\t\ty >>= 1; (x *= x) %= mod;\n\t}\n\treturn z;\n}\nint main()\n{\n\tscanf (\"%d%d\", &n, &m);\n\tif (m == 1) { puts(\"1\"); return 0; }\n\tq[0] = 1;\n\tRep(i, 1, D) q[i] = q[i - 1] * i % mod; \n\tp[D] = mypow(q[D], mod - 2);\n\tDwn(i, D, 1) p[i - 1] = p[i] * i % mod;\n\tRep(i, 1, n) {\n\t\tf[i][0] = 1;\n\t\tRep(j, 1, i) {\n\t\t\tf[i][j] = (f[i][j - 1] * C((n - j + 1) * m - (i - j + 1) - 1, m - 2) + f[i - 1][j]) % mod;\n\t\t\t// cout << i <<\" \"<<j<<\" \"<<f[i][j]<<endl;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", (int)(f[n][n] * q[n] % mod));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nconst int N=2005;\nconst int M=N*N;\nconst int mo=1e9+7;\nint n,k,m;\nlong long p[M],q[M],f[N][N];\nlong long ksm(long long x,int y)\n{\n\tlong long t=1;\n\tfor (;y;y>>=1)\n\t{\n\t\tif (y&1) t=t*x%mo;\n\t\tx=x*x%mo;\n\t}\n\treturn t;\n}\nlong long c(int x,int y)\n{\n\tif (y<0) return 0;\n\treturn p[x]*q[y]%mo*q[x-y]%mo;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k),m=n*k;\n\tif (!k)\n\t{\n\t\tprintf(\"1\");\n\t\treturn 0;\n\t}\n\tp[0]=q[0]=1;\n\tfor (int i=1;i<=m;i++) p[i]=p[i-1]*i%mo;\n\tq[m]=ksm(p[m],mo-2);\n\tfor (int i=m-1;i;i--) q[i]=q[i+1]*(i+1)%mo;\n\tf[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=i;j>=0;j--)\n\t\t{\n\t\t\tf[i][j]=f[i][j+1];\n\t\t\tif (j) f[i][j]=(f[i][j]+f[i-1][j-1]*c(i*k-j-1,k-2))%mo;\n\t\t}\n\tprintf(\"%lld\",f[n][0]*p[n]%mo);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1000000007;\ninline long long read()\n{\n\tlong long x=0;bool f=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-'){f=1;ch=getchar();break;}ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}\n\tif(f) x=-x;return x;\n}\nlong long poww(long long a,long long b){long long c=1;while(b){if(b&1) c=c*a%mod;a=a*a%mod;b>>=1;}return c;}\nlong long n,k,dp[2010][2010],jc[5000000]={1},inv[5000000]={1};\nlong long C(long long x,long long y){return jc[x]*inv[y]%mod*inv[x-y]%mod;}\nint main()\n{\n\tfor(long long i=1;i<=4000000;i++) jc[i]=jc[i-1]*i%mod;\n\tinv[4000000]=poww(jc[4000000],mod-2);\n\tfor(long long i=3999999;i>=1;i--) inv[i]=(inv[i+1]*(i+1))%mod;\n\tn=read();k=read();\n\tif(k==1){puts(\"1\");return 0;}\n\tdp[0][0]=1;\n\tfor(long long i=1;i<=n;i++)\n\t\tfor(long long j=0;j<=i;j++)\n\t\t{\n\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\tif(j) dp[i][j]=(dp[i][j]+dp[i][j-1]*C(n-i+(n-j+1)*(k-1)-1,k-2)%mod)%mod;\n\t\t}\n\tprintf(\"%lld\",dp[n][n]*jc[n]%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nll read(){\n\tchar c=getchar();bool flag=0;ll x=0;\n\twhile(c<'0'||c>'9'){if(c=='-')flag=1;c=getchar();}\n\twhile(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}\n\treturn flag?-x:x;\n}\n#define N 2010 \nconst ll p=1e9+7;\nll dp[N][N],fac[N*N],inv[N*N];\nll fpow(ll a,ll x){\n\tll ans=1;\n\twhile(x){\n\t\tif(x&1) ans=ans*a%p;\n\t\ta=a*a%p,x=x/2; \n\t}\n\treturn ans;\n}\nll Cnt(ll n,ll m){\n\treturn fac[m]*inv[fac[n]]%p*inv[fac[m-n]]%p;\n}\nint main(){\n\tll n=read(),k=read();\n\tif(k==1){\n\t\tprintf(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\tfor(ll i=1;i<=n*k;i++) fac[i]=fac[i-1]*i%p;\n\tinv[n*k]=fpow(fac[n*k],p-2);\n\tfor(ll i=n*k-1;i>=1;i--) inv[i]=inv[i+1]*(i+1)%p;\n\tfor(ll i=1;i<=n;i++) dp[i][0]=1;\n\tfor(ll i=1;i<=n;i++){\n\t\tfor(ll j=1;j<=i;j++){\n\t\t\tdp[i][j]=dp[i-1][j]+dp[i][j-1]*(n-(j-1))*Cnt(k-2,n*k-i-(j-1)*(k-1)-1);\n\t\t}\n\t}\n\tprintf(\"%lld\",dp[n][n]); \n}\n"
  },
  {
    "language": "C++",
    "code": "/*vi:se ts=8 tw=8*/\n/*@author tangyida*/\n#include<bits/stdc++.h>\nconst int N = 2e3 + 5;\nconst long long MOD = 1e9 + 7;\nint n,k;\nlong long f[N][N],fac[N * N],inv[N * N];\n\ninline long long _pow(long long a,long long base)\n{\n\tlong long ans = 1;\n\tfor(;base;base >>= 1) {\n\t\tif(base  & 1) ans = (ans * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t}\n\treturn ans;\n}\n\ninline void pre()\n{\n\tfac[0] = 1;\n\tfor(int i = 1;i <= n * n;i++) fac[i] = (fac[i - 1] * i) % MOD;\n\tfor(int i = 0;i <= n * n;i++) inv[i] = (_pow(fac[i],MOD - 2)) % MOD;\n}\n\ninline long long C(long long n,long long m)\n{ \n\tif(n == m) return 1;\n\treturn ((fac[n] * inv[m]) % MOD * inv[n - m]) % MOD;\n}\n\nint main()\n{\n\tstd::cin >> n >> k;\n\tif(k == 1) std::cout << 1,exit(0);\n\n\tpre();\n\tf[0][0] = 1;\n\tfor(int i = 1;i <= n;i++) for(int j = 0;j <= i;j++) {\n\t\tf[i][j] = f[i - 1][j];\n\t\tif(!j) continue;\n\t\t((f[i][j] += f[i][j - 1] * (n - j + 1) % MOD) *= C(n * k - (k - 1)\n\t\t\t* (j - 1) - 1 - i,k - 2)) %= MOD;/*FIXME*/\n\t}\n\tstd::cout << f[n][n];\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ull unsigned long long\n\nconst int MaxN(2003);\nconst int MaxL(4000003);\nconst int Mod(1e9 + 7);\n\nint F[MaxN][MaxN];\nint fac[MaxL], rfac[MaxL];\n\nint fexp(int x, int k)\n{\n\tint res = 1;\n\tfor(; k; k >>= 1, x = (ull) x * x % Mod)\n\t\tif(k & 1) res = (ull) res * x % Mod;\n\treturn res;\n}\n\ninline int C(int n, int m)\n{\n\treturn n < m ? 0 : (ull) fac[n] * rfac[m] % Mod * rfac[n - m] % Mod;\n}\n\nint main()\n{\n\tint n, K;\n#ifdef zxp\n\tfreopen(\"ball.in\", \"r\", stdin);\n\tfreopen(\"ball.out\", \"w\", stdout);\n#endif\n\tscanf(\"%d%d\", &n, &K);\n\tif(K == 1) return puts(\"1\"), 0;\n\tfor(int i = fac[0] = 1; i <= n * K; i++)\n\t\tfac[i] = (ull) fac[i - 1] * i % Mod;\n\trfac[n * K] = fexp(fac[n * K], Mod - 2);\n\tfor(int i = n * K; i; i--)\n\t\trfac[i - 1] = (ull) rfac[i] * i % Mod;\n\tF[0][0] = 1;\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 0; j <= i; j++)\n\t\t{\n\t\t\tF[i][j] = F[i - 1][j];\n\t\t\tif(j) F[i][j] = (F[i][j] + (ull) (n - j + 1) * C((K - 1) * (n - j + 1) + n - i - 1, K - 2) % Mod * F[i][j - 1]) % Mod;\n\t\t}\n\tprintf(\"%d\\n\", F[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define rep(i,l,r) for (int i=(l); i<=(r); i++)\nusing namespace std;\n\nconst int N=2010,mod=1e9+7;\nint n,m,K,fac[N*N],inv[N*N],f[N][N];\n\nint ksm(int a,int b){\n\tint res=1;\n\tfor (; b; a=1ll*a*a%mod,b>>=1)\n\t\tif (b & 1) res=1ll*res*a%mod;\n\treturn res;\n}\n\nint C(int n,int m){ return n<m ? 0 : 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod; }\n\nint main(){\n\tscanf(\"%d%d\",&n,&K); m=n*K;\n\tif (K==1){ puts(\"1\"); return 0; }\n\tfac[0]=1; rep(i,1,m) fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[m]=ksm(fac[m],mod-2);\n\tfor (int i=m; i; i--) inv[i-1]=1ll*inv[i]*i%mod;\n\tf[0][0]=1;\n\trep(i,1,n) rep(j,0,i)\n\t\tf[i][j]=(f[i][j]+f[i-1][j]+(!j?0:1ll*f[i][j-1]*(n-j+1)%mod*C((n-i)+(n-j+1)*(K-1)-1,K-2)%mod))%mod;\n\tprintf(\"%d\\n\",f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint getint()\n{\n\tint i=0,f=1;char c;\n\tfor(c=getchar();(c!='-')&&(c<'0'||c>'9');c=getchar());\n\tif(c=='-')f=-1,c=getchar();\n\tfor(;c>='0'&&c<='9';c=getchar())i=(i<<3)+(i<<1)+c-'0';\n\treturn i*f;\n}\nconst int N=2005,mod=1e9+7;\nint n,k,m;\nll f[N][N],fac[N*N],invfac[N*N];\nll Pow(ll x,int y)\n{\n\tll res=1;\n\tfor(;y;y>>=1,x=x*x%mod)\n\t\tif(y&1)res=res*x%mod;\n\treturn res;\n}\nll C(int x,int y)\n{\n\tif(x<y||x<0||y<0)return 0;\n\treturn fac[x]*invfac[y]%mod*invfac[x-y]%mod;\n}\nint main()\n{\n\t//freopen(\"lx.in\",\"r\",stdin);\n\tn=getint(),k=getint(),m=n*k;\n\tif(k==1){puts(\"1\");return 0;}\n\tfac[0]=1;for(int i=1;i<=m;i++)fac[i]=fac[i-1]*i%mod;\n\tinvfac[m]=Pow(fac[m],mod-2);\n\tfor(int i=m-1;i>=0;i--)invfac[i]=invfac[i+1]*(i+1)%mod;\n\tf[0][0]=1;--k;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=i;j<=n;j++)if(f[i][j])\n\t\t{\n\t\t\tf[i+1][j]=(f[i+1][j]+f[i][j])%mod;\n\t\t\tf[i][j+1]=(f[i][j+1]+f[i][j]*C(i+j*k+k-1,k-1))%mod;\n\t\t}\n\tcout<<f[n][n]*fac[n]%mod<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 2005 * 2005;\nconst int mod = 1e9 + 7;\n\nint Pow(int x , int y) {\n\tif(y == 0) return 1;\n\tif(y == 1) return x;\n\tint it = Pow(x , y >> 1);\n\tit = it * 1ll * it % mod;\n\tif(y & 1) it = it * 1ll * x % mod;\n\treturn it;\n}\n\nint inv[N] , fac[N] , n , k , dp[2005][2005];\n\nvoid predance(int x) {\n\tfac[0] = inv[0] = 1;\n\tfor(int i = 1;i <= x;i ++) {\n\t\tfac[i] = fac[i - 1] * 1ll * i % mod;\n\t\tinv[i] = Pow(fac[i] , mod - 2);\n\t}\n}\n\nint C(int x , int y) {\n\treturn fac[x] * 1ll * inv[y] % mod * 1ll * inv[x - y] % mod;\n}\n\nint main(void) {\n\tscanf(\"%d%d\" , &n , &k);\n\tif(k == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tdp[0][0] = 1;\n\tpredance(n * k);\n\tfor(int i = 1;i <= n;i ++) {\n\t\tfor(int j = 0;j <= i;j ++) {\n\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\tif(j) {\n\t\t\t\tdp[i][j] += dp[i][j - 1] * 1ll * C(n * k - (j - 1)* (k - 1) - i - 1 , k - 2) % mod;\n\t\t\t\tif(dp[i][j] >= mod) dp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\" , (int)((dp[n][n] * 1ll * fac[n]) % mod));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int maxn=2000+10;\nconst int p=1e9+7;\nint n,k,f[maxn][maxn],farc[maxn*maxn],inv[maxn*maxn];\n\nint C(int n,int m){\n\treturn (ll)farc[n]*inv[m]%p*(ll)inv[n-m]%p;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);k--;\n\tif(!k){printf(\"1\\n\");return 0;}\n\tfarc[0]=farc[1]=inv[0]=inv[1]=1;\n\tfor(int i=2;i<=n*k+n+k;i++){\n\t\tfarc[i]=(ll)farc[i-1]*i%p;\n\t\tinv[i]=(ll)(p-p/i)*inv[p%i]%p;\n\t}\n\tfor(int i=2;i<=n*k+n+k;i++) inv[i]=(ll)inv[i]*inv[i-1]%p;\n\tf[0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=i;j<=n;j++){\n\t\t\tif(i>0) f[i][j]=(f[i][j]+f[i-1][j])%p;\n\t\t\tif(j>0) f[i][j]=(f[i][j]+(ll)f[i][j-1]*C(i+(j-1)*k+k-1,k-1)%p)%p;\n\t\t}\n\tprintf(\"%d\\n\",(ll)f[n][n]*farc[n]%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define forup(i,l,r) for (register int i = l ; i <= r ; i += lowbit(i))\n#define fordown(i,id) for (register int i = id ; i ; i -= lowbit(i))\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) (x&(-x))\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pr;\n\nconst ld inf = 2e18;\nconst int N = 3e6 + 10;\nconst int maxn = 4000020;\nconst ll mod = 1e9 + 7;\n\ninline ll power(ll x,ll y){\n\tif ( y < 0 ) return 1;\n\tll res = 1;\n\twhile ( y ){\n\t\tif ( y & 1 ) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\nint n,T,a[maxn],mx,mn,k,cnt[maxn];\nll fac[maxn],inv[maxn],f[2020][2020];\n\nvoid init(){\n\tfac[0] = inv[0] = 1;\n\tint tmp = n * k;\n\trep(i,1,tmp) fac[i] = fac[i - 1] * i % mod;\n\tinv[tmp] = power(fac[tmp],mod - 2);\n\trepd(i,tmp - 1,1) inv[i] = inv[i + 1] * (i + 1) % mod;\n}\n\ninline void up(ll &x,ll y){ x = (x + y) % mod; }\ninline ll C(int n,int m){\n\tif ( n < 0 || m < 0 || n < m ) return 0;\n\treturn fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\n\nint main(){\n\tcin>>n>>k;\n\tinit();\n\tf[0][0] = 1;\n\tif ( k == 1 ){ printf(\"1\\n\"); return 0; }\n\trep(i,0,n){\n\t\trep(j,0,i){\n\t\t\tif ( !f[i][j] ) continue;\n\t\t\tif ( i > j ) up(f[i][j + 1],f[i][j] * C(n * k - i - j * (k - 1) - 1,k - 2) % mod * C(n - j,1));\n\t\t\tup(f[i + 1][j],f[i][j]);\n\t\t}\n\t}\n\tcout<<f[n][n]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int mod = 1e9 + 7;\nconst int MAXN = 2005, MAXS = MAXN * MAXN;\n\ntemplate<typename _T>\nvoid read( _T &x )\n{\n\tx = 0;char s = getchar();int f = 1;\n\twhile( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}\n\twhile( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}\n\tx *= f;\n}\n\ntemplate<typename _T>\nvoid write( _T x )\n{\n\tif( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }\n\tif( 9 < x ){ write( x / 10 ); }\n\tputchar( x % 10 + '0' );\n}\n\nint f[MAXN][MAXN];\nint fac[MAXS], ifac[MAXS];\nint N, K;\n\nint qkpow( int, int );\nint inv( const int a ) { return qkpow( a, mod - 2 ); }\nvoid sub( int &x, const int v ) { x = ( x < v ? x - v + mod : x - v ); }\nvoid add( int &x, const int v ) { x = ( x + v >= mod ? x + v - mod : x + v ); }\n\nint qkpow( int base, int indx )\n{\n\tint ret = 1;\n\twhile( indx )\n\t{\n\t\tif( indx & 1 ) ret = 1ll * ret * base % mod;\n\t\tbase = 1ll * base * base % mod, indx >>= 1;\n\t}\n\treturn ret;\n}\n\nvoid init( const int siz )\n{\n\tfac[0] = ifac[0] = 1;\n\tfor( int i = 1 ; i <= siz ; i ++ ) fac[i] = 1ll * fac[i - 1] * i % mod;\n\tifac[siz] = inv( fac[siz] );\n\tfor( int i = siz - 1 ; ~ i ; i -- ) ifac[i] = 1ll * ifac[i + 1] * ( i + 1 ) % mod;\n}\n\nint C( const int n, const int m ) { return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod; }\n\nint main()\n{\n\tread( N ), read( K );\n\tif( K == 1 ) { puts( \"1\" ); return 0; }\n\tinit( N * K );\n\tfor( int i = 0 ; i <= N ; i ++ ) f[i][0] = 1;\n\tfor( int i = 1 ; i <= N ; i ++ )\n\t\tfor( int j = 1 ; j <= i ; j ++ )\n\t\t{\n\t\t\tf[i][j] = f[i - 1][j];\n\t\t\tint t = N * K - i - ( K - 1 ) * ( j - 1 ) - 1;\n\t\t\tadd( f[i][j], 1ll * f[i][j - 1] * ( N - j + 1 ) % mod * C( t, K - 2 ) % mod );\n\t\t}\n\twrite( f[N][N] ), putchar( '\\n' );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define N 2001\n#define P 4000001\n#define M 1000000007LL\n\nlong long p[2][P], f[N][N];\nint n, k, t;\n\nlong long sel(int n, int m)\n{\n    return n >= m ? p[0][n] * p[1][m] % M * p[1][n - m] % M : 0;\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &k);\n    t = n * k;\n\n    if (k == 1)\n    {\n        puts(\"1\");\n        return 0;\n    }\n\n    p[0][0] = 1;\n    for (int i = 1; i <= t; i++)\n        p[0][i] = p[0][i - 1] * i % M;\n\n    p[1][t] = 1;\n    for (long long x = p[0][t], e = M - 2; e; e >>= 1, x = x * x % M)\n        if (e & 1)\n            p[1][t] = p[1][t] * x % M;\n\n    for (int i = t; i; i--)\n        p[1][i - 1] = p[1][i] * i % M;\n\n    f[0][0] = 1;\n    for (int i = 0; i <= n; i++)\n    {\n        for (int j = i; j <= n; j++)\n        {\n            f[i][j + 1] = (f[i][j + 1] + f[i][j]) % M;\n            f[i + 1][j] = (f[i + 1][j] + f[i][j] * sel(t - i * (k - 1) - j - 1, k - 2) % M) % M;\n        }\n    }\n\n    printf(\"%lld\\n\", f[n][n] * p[0][n] % M);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(v) std::begin(v), std::end(v)\n#define ALLR(v) std::rbegin(v), std::rend(v)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing pll = std::pair<ll, ll>;\nusing tll = std::tuple<ll, ll, ll>;\ntemplate <typename T> using vec = std::vector<T>;\ntemplate <typename T> using vvec = vec<vec<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return vec<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\n\nnamespace math {\n\ntemplate <typename T>\nconstexpr T pow(const T &n, ll k) {\n    T ret = n.mul_id_ele();\n    T cur = n;\n    while (k) {\n        if (k & 1) ret *= cur;\n        cur *= cur;\n        k /= 2;\n    }\n    return ret;\n}\n\n}\n\nnamespace math {\n\ntemplate <ll Mod>\nstruct Modint {\n\n    constexpr Modint(ll x) : x(x % Mod) { }\n    \n    constexpr Modint() : Modint(0) { }\n    \n    constexpr Modint<Mod> add_id_ele() const { \n        return Modint<Mod>(0); \n    }\n    \n    constexpr Modint<Mod> mul_id_ele() const {\n        return Modint<Mod>(1); \n    }\n    \n    constexpr ll& value() { \n        return x; \n    }\n    \n    constexpr ll value() const {\n        return x; \n    }\n\n    constexpr Modint& operator +=(const Modint &oth) {\n        x += oth.value();\n        if (Mod <= x) x -= Mod;\n        return *this;\n    }\n\n    constexpr Modint& operator -=(const Modint &oth) {\n        x += Mod - oth.value();\n        if (Mod <= x) x -= Mod;\n        return *this;\n    }\n\n    constexpr Modint& operator *=(const Modint &oth) {\n        x *= oth.value();\n        x %= Mod;\n        return *this;\n    }\n\n    constexpr Modint& operator /=(const Modint &oth) {\n        x *= oth.inv();\n        x %= Mod;\n        return *this;\n    }\n\n    constexpr Modint operator +(const Modint &oth) const {\n        return Modint(x) += oth;\n    }\n\n    constexpr Modint operator -(const Modint &oth) const {\n        return Modint(x) -= oth;\n    }\n\n    constexpr Modint operator *(const Modint &oth) const {\n        return Modint(x) *= oth;\n    }\n\n    constexpr Modint operator /(const Modint &oth) const {\n        return Modint(x) /= oth;\n    }\n\n    constexpr Modint operator -() const {\n        return Modint((x != 0) * (Mod - x)); \n    }\n\n    template <typename T>\n    constexpr typename std::enable_if<std::is_integral<T>::value, const Modint&>::type\n    operator =(T t) {\n        (*this) = Modint(std::forward<T>(t)); \n        return *this;\n    }\n\n    constexpr Modint inv() const {\n        return ::math::pow(*this, Mod - 2);\n    }\n\n    constexpr ll mod() const {\n        return Mod;\n    }\n\nprivate:\n    ll x;\n};\n\n}\n\nnamespace math {\n\ntemplate <ll Mod>\nclass Combination {\n    using mint = Modint<Mod>;\n\n    ssize_t maxv;\n    vec<mint> factv, ifactv;\n\npublic:\n    Combination(ssize_t maxv) : maxv(maxv), factv(maxv + 1), ifactv(maxv + 1) {\n        factv[0] = mint(1);\n        for (ll i = 1; i <= maxv; i++) factv[i] = factv[i - 1] * i;\n        ifactv.back() = factv.back().inv();\n        for (ll i = maxv - 1; 0 <= i; i--) ifactv[i] = ifactv[i + 1] * (i + 1);\n    }\n\n    mint fact(ll n) const {\n        return factv[n]; \n    }\n\n    mint ifact(ll n) const {\n        return ifactv[n];\n    }\n\n    mint perm(ll n, ll k) const {\n        return factv[n] * ifactv[n - k];\n    }\n\n    mint comb(ll n, ll k) const {\n        return perm(n, k) * ifactv[k];\n    }\n};\n\n}\n\nconst ll inf = 5e15;\nconst ll mod = 1e9 + 7;\nconst std::size_t SIZE = 2010;\nusing mint = math::Modint<mod>;\nmint dp[SIZE][SIZE];  // gray, second ball\nbool calced[SIZE][SIZE];\nmath::Combination<mod> co(SIZE * SIZE);\n\nll n, k;\n\nmint rec(ll i, ll j) {\n    if (calced[i][j]) return dp[i][j];\n    calced[i][j] = true;\n    ll rest = n * k - (i + (j - 1) * (k - 1));\n    if (j <= i) {\n        mint pre = rec(i, j - 1);\n        mint addv = pre * (n - (j - 1));\n        if (2 <= k) addv *= co.comb(rest - 1, k - 2);\n        dp[i][j] += addv;\n    }\n    if (j < i) {\n        mint pre = rec(i - 1, j);\n        dp[i][j] += pre;\n    }\n    return dp[i][j];\n}\n\nll solve() {\n    std::cin >> n >> k;\n    if (k == 1) return 1;\n    for (ll i = 0; i <= n; i++) {\n        dp[i][0] = 1;\n        calced[i][0] = true;\n    }\n    return rec(n, n).value();\n}\n\nint main() {\n    std::cout << solve() << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int MAXN=2010;\nconst int MOD=1e9+7;\nint n,k;\nlong long fac[MAXN*MAXN],inv[MAXN*MAXN],f[MAXN][MAXN];\nlong long C(long long x,long long y)\n{\n\treturn fac[x]*inv[y]%MOD*inv[x-y]%MOD;\n}\nlong long qpow(long long x,long long y)\n{\n\tlong long tmp=1;\n\tfor(;y;y>>=1,x=x*x%MOD)if(y&1)tmp=tmp*x%MOD;\n\treturn tmp;\n}\nint main()\n{\n//\tfreopen(\"test.in\",\"r\",stdin);\n//\tfreopen(\"test.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1)\n\t{\n\t\tprintf(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\tfor(int i=1;i<=n*k;i++)fac[i]=fac[i-1]*i%MOD;\n\tinv[n*k]=qpow(fac[n*k],MOD-2);\n\tfor(int i=n*k;i>=1;i--)inv[i-1]=inv[i]*i%MOD;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(!j)continue;\n\t\t\tf[i][j]=(f[i][j]+f[i][j-1]*(n-j+1)%MOD*C(n-i+(n-j+1)*(k-1)-1,k-2))%MOD;\n\t\t}\n\tprintf(\"%lld\\n\",f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, x, y) for (int i = x; i <= y; i++)\nusing namespace std;\n\nconst int N = 2e3 + 10, mod = 1e9 + 7;\ntypedef long long ll;\nll n, K;\nll fac[N * N], f[N][N], inv[N * N];\n\nll quick_pow(ll a, ll b) {\n    ll ret = 1;\n    for (; b; b >>= 1) {\n        if (b & 1) ret = ret * a % mod;\n        a = a * a % mod;\n    } return ret;\n}\n\nvoid pre() {\n    fac[0] = inv[0] = 1;\n    rep(i, 1, n * n) fac[i] = fac[i - 1] * i % mod;\n    inv[n * n] = quick_pow(fac[n * n], mod - 2);\n    for (int i = n * n - 1; i >= 1; i--) inv[i] = inv[i + 1] * (i + 1) % mod;\n}\n\nll C(ll n, ll m) { return fac[n] * inv[m] % mod * inv[n - m] % mod; }\n\nvoid upd(ll &x, ll y) { x = (x + y) % mod; }\n\nint main() {\n    cin >> n >> K;\n    if (K == 1) { puts(\"1\"); return 0; }\n    pre();\n    f[1][0] = 1;\n    rep(i, 1, n)\n        rep(j, 0, i) {\n            if (i > j)\n                upd(f[i][j], f[i - 1][j]);\n            if (j)\n                upd(f[i][j], (n - j + 1) * f[i][j - 1] % mod * C((n - j + 1) * (K - 1) + n - i - 1, K - 2) % mod);\n        }\n    printf(\"%lld\\n\", f[n][n]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define fd(i,a,b) for(i=a;i>=b;i--)\nusing namespace std;\ntypedef long long ll;\nconst int maxn=2000+10,mo=1000000007;\nint fac[maxn*maxn],inv[maxn*maxn];\nint f[maxn][maxn];\nint i,j,k,l,t,n,m,ans;\nint qsm(int x,int y){\n\tif (!y) return 1;\n\tint t=qsm(x,y/2);\n\tt=(ll)t*t%mo;\n\tif (y%2) t=(ll)t*x%mo;\n\treturn t;\n}\nint C(int n,int m){\n\tif (n<m||n<0) return 0;\n\treturn (ll)fac[n]*inv[m]%mo*inv[n-m]%mo;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tif (k==1){\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\tfo(i,1,n*k) fac[i]=(ll)fac[i-1]*i%mo;\n\tinv[n*k]=qsm(fac[n*k],mo-2);\n\tfd(i,n*k-1,0) inv[i]=(ll)inv[i+1]*(i+1)%mo;\n\tf[0][0]=1;\n\tfo(i,0,n)\n\t\tfd(j,n,0)\n\t\t\tif (f[i][j]){\n\t\t\t\tif (j) (f[i][j-1]+=f[i][j])%=mo;\n\t\t\t\tif (i<n) (f[i+1][j+1]+=(ll)f[i][j]*C((i+1)*k-j-2,k-2)%mo)%=mo;\n\t\t\t}\n\tans=(ll)f[n][0]*fac[n]%mo;\n\t(ans+=mo)%=mo;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#define file(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout);\nusing namespace std;\nconst int MAXN = 2005;\nconst int MOD = 1e9 + 7;\nint n, K;\nint jc[MAXN * MAXN] = {1}, inv[MAXN * MAXN];\nint f[MAXN][MAXN];\n\nint quick_pow(int a, int x) {\n    int res = 1;\n    while (x) {\n        if (x & 1)\n            res = 1ll * res * a % MOD;\n        a = 1ll * a * a % MOD, x >>= 1;\n    }\n    return res;\n}\n\nint calc_C(int n, int r) {\n    if (n < r)\n        return 0;\n    return 1ll * jc[n] * inv[r] % MOD * inv[n - r] % MOD;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &K);\n    if (K == 1) {\n        printf(\"1\");\n        return 0;\n    }\n    for (int i = 1; i <= n * n; i++)\n        jc[i] = 1ll * jc[i - 1] * i % MOD;\n    inv[n * n] = quick_pow(jc[n * n], MOD - 2);\n    for (int i = n * n; i; i--)\n        inv[i - 1] = 1ll * i * inv[i] % MOD;\n    f[0][0] = 1;\n    for (int i = 0; i <= n; i++)\n        for (int j = i; j <= n; j++) {\n            if (i != j)\n                f[i + 1][j] = (f[i + 1][j] + f[i][j]) % MOD;\n            f[i][j + 1] = (f[i][j + 1] + 1ll * f[i][j] * calc_C((j + 1) * (K - 1) + i - 1, K - 2) % MOD) % MOD;\n        }\n    printf(\"%lld\", 1ll * f[n][n] * jc[n] % MOD);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define ll long long\n#define inf 1e9\nusing namespace std;\n\nconst int maxn = 2000*2000+5;\nconst int mod  = 1e9+7;\ninline void add(int &a,const int &b){a+=b;if(a>=mod)a-=mod;}\n\nint pw(int x,int k)\n{\n\tint re=1;\n\tfor(;k;k>>=1,x=(ll)x*x%mod) if(k&1)\n\t\tre=(ll)re*x%mod;\n\treturn re;\n}\nint inv(int x){ return pw(x,mod-2); }\n\nint s[maxn],invs[maxn];\nvoid pre()\n{\n\ts[0]=1; for(int i=1;i<maxn;i++) s[i]=(ll)s[i-1]*i%mod;\n\tinvs[maxn-1]=inv(s[maxn-1]);\n\tfor(int i=maxn-2;i>=0;i--) invs[i]=(ll)invs[i+1]*(i+1)%mod;\n}\nint C(int n,int m){return (ll)s[n]*invs[m]%mod*invs[n-m]%mod;}\n\nint n,m;\nint f[2005];\n\nint main()\n{\n\tpre();\n\t\n\tscanf(\"%d%d\",&n,&m); int u=n*m;\n\tif(m==1) return puts(\"1\"),0;\n\t\n\tf[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<i;j++)\n\t\t\tadd(f[j+1],(ll)f[j]*C(u-i-j*(m-1)-1,m-2)%mod);\n\t}\n\tint ans=f[n];\n\tans=(ll)ans*s[n]%mod;\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define Mx 4000000\nusing namespace std;\nconst int p=1e9+7;\nint n,k;\nint f[2010][2010],a[4000010],i_a[4000010];\nint calc(int x,int y){ return (((a[y]*i_a[x])%p)*i_a[y-x])%p; }\nint power(int x,int y)\n{\n    int s1=1,s2=x;\n    while(y)\n\t{\n        if(y%2)s1*=s2,s1%=p;\n        s2*=s2;\n        s2%=p;\n        y/=2;\n    }\n    return s1;\n}\nsigned main()\n{\n    cin>>n>>k;\n    if(k==1)\n\t{\n\t\tcout<<1;\n\t\treturn 0;\n\t}\n    a[0]=1; \n\tfor(int i=1;i<=Mx;i++)a[i]=(a[i-1]*i)%p;\n    i_a[Mx]=power(a[Mx],p-2); \n\tfor(int i=Mx-1;i>=0;i--)i_a[i]=(i_a[i+1]*(i+1))%p;\n    f[0][0]=1;\n    for(int i=1;i<=n;i++)\n\t  for(int j=0;j<=i;j++)\n\t  {\n          f[i][j]=f[i-1][j];\n          if(j)f[i][j]+=(f[i][j-1]*(n-j+1)%p*calc(k-2,n-i+(n-j+1)*(k-1)-1)%p)%p;\n      }\n    cout<<f[n][n];\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <iostream>\n#include <vector>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < int(n); ++ (i))\nusing ll = long long;\nusing namespace std;\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\nll powmod(ll x, ll y, ll m) {\n    assert (0 <= x and x < m);\n    assert (0 <= y);\n    ll z = 1;\n    for (ll i = 1; i <= y; i <<= 1) {\n        if (y & i) z = z * x % m;\n        x = x * x % m;\n    }\n    return z;\n}\nll modinv(ll x, ll p) {\n    assert (x % p != 0);\n    return powmod(x, p - 2, p);\n}\ntemplate <int32_t MOD>\nint32_t fact(int n) {\n    static vector<int32_t> memo(1, 1);\n    while (n >= memo.size()) {\n        memo.push_back(memo.back() *(int64_t) memo.size() % MOD);\n    }\n    return memo[n];\n}\ntemplate <int32_t PRIME>\nint32_t inv_fact(int n) {\n    static vector<int32_t> memo(1, 1);\n    while (n >= memo.size()) {\n        memo.push_back(memo.back() *(int64_t) modinv(memo.size(), PRIME) % PRIME);\n    }\n    return memo[n];\n}\ntemplate <int MOD>\nint choose(int n, int r) {\n    assert (0 <= r and r <= n);\n    return fact<MOD>(n) *(ll) inv_fact<MOD>(n - r) % MOD *(ll) inv_fact<MOD>(r) % MOD;\n}\n\nconstexpr int mod = 1e9 + 7;\nint solve(int n, int k) {\n    if (k == 1) return 1;\n    auto dp = vectors(n + 1, n + 1, int());\n    dp[0][0] = 1;\n    REP3 (i, 1, n + 1) {\n        REP (j, i + 1) {\n            if (i - 1 >= 0) {\n                dp[i][j] += dp[i - 1][j];\n            }\n            if (j - 1 >= 0) {\n                int remaining = (n - i) + (k - 1) * (n - (j - 1));\n                dp[i][j] += dp[i][j - 1] *(ll) choose<mod>(remaining - 1, k - 2) % mod;\n            }\n            if (dp[i][j] >= mod) {\n                dp[i][j] -= mod;\n            }\n        }\n    }\n    return dp[n][n] *(ll) fact<mod>(n) % mod;\n}\n\nint main() {\n    int n, k; cin >> n >> k;\n    cout << solve(n, k) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nconst ll M = 1000000007;\n\nll modpow(ll x,int k){\n\tll ret = 1 , t = x;\n\twhile(k > 0){\n\t\tif(k&1){ ret *= t; ret %= M; }\n\t\tt *= t; t %= M;\n\t\tk >>= 1;\n\t}\n\treturn ret;\n\t/*if(k == 0)return 1;\n\tll ret = modpow(x,k/2);\n\tret *= ret; ret %= M;\n\tif(k%2 == 1){ ret *= x; ret %= M ; }\n\treturn ret;*/\n}\nll inv(ll x){\n\treturn modpow(x,(int)M-2);\n}\n\nll f[4000010];\nvoid init(int k){\n\tf[k-2] = 1;\n\tfor(int i = k-2 ; i < 4000009 ; i ++){\n\t\tf[i+1] = f[i]*(i+1); f[i+1] %= M;\n\t\tf[i+1] *= inv(i+3-k); f[i+1] %= M;\n\t}\n}\n\nint main(){\n\tll n,k;\n\tcin >> n >> k;\n\tif(k == 1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tif(k == 2){\n\t\trep(i,4000010)f[i] = 1;\n\t}\n\tif(k != 2)init(k);\n\t\n\tstatic ll dp[2002][2002] = {};\n\tdp[0][0] = 1;\n\trep1(i,n){\n\t\tll sum = dp[i-1][i-1];\n\t\tfor(int j = i ; j <= n ; j ++){\n\t\t\tsum += dp[i-1][j];\n\t\t\tif(sum >= M)sum -= M;\n\t\t\tdp[i][j] = sum*f[(n-i)*k+i-j+k-2];\n\t\t\tdp[i][j] %= M;\n\t\t}\n\t}\n\trep1(i,n){\n\t\tdp[n][n] *= i;\n\t\tdp[n][n] %= M;\n\t}\n\tcout << dp[n][n] << endl;\n}\n\t\t\t\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m;\ninline int read(){\n\tchar c=getchar();int s=0;\n\twhile(c<'0'||c>'9')c=getchar();\n\twhile(c>='0'&&c<='9'){\n\t\ts=s*10+c-'0';c=getchar();\n\t}return s;\n}\nconst int N=2500;\nconst int mod=1e9+7;\nint f[N][N];\nint fac[N*N];\nint ksm(int x,int y){\n\tint b=1;\n\twhile(y){\n\t\tif(y&1)b=(1ll*b*x)%mod;\n\t\tx=1ll*x*x%mod;\n\t\ty>>=1;\n\t}return b;\n}\nint C(int x,int y){\n\treturn 1ll*fac[x]*ksm(1ll*fac[y]*fac[x-y]%mod,mod-2)%mod;\n}\nint main(){\n\tn=read();m=read();\n\tif(m==1){\n\t\tcout<<1;\n\t\treturn 0;\n\t}\n\tf[0][0]=1;fac[0]=1;\n\tfor(int i=1;i<=2000*2000;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int k=0;k<=i;k++){\n\t\t\tf[i][k]=(f[i-1][k]+(k>0?1ll*f[i][k-1]*(n-k+1)%mod*C(n*m-i-(k-1)*(m-1)-1,m-2)%mod:0))%mod;\n\t\t}\n\t}\n\tcout<<f[n][n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\n#define MOD 1000000007\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int MAXN = 2000 + 10;\nconst int MAXM = 4e06 + 10;\n\nint N, K;\n\nLL fact[MAXM]= {0}, invfact[MAXM]= {0};\nvoid init () {\n\tfact[0] = fact[1] = invfact[0] = invfact[1] = 1;\n\tfor (int i = 2; i <= N * K; i ++) {\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\tinvfact[i] = (MOD - MOD / i) * invfact[MOD % i] % MOD;\n\t}\n\tfor (int i = 1; i <= N * K; i ++)\n\t\tinvfact[i] = invfact[i - 1] * invfact[i] % MOD;\n}\ninline LL C (int n, int m) {\n\tif (n < 0) return 0;\n\tif (m == 0) return 1;\n\treturn fact[n] * invfact[m] % MOD * invfact[n - m] % MOD;\n}\n\nLL f[MAXN][MAXN]= {0};\n\nint main () {\n\tscanf (\"%d%d\", & N, & K);\n\tif (K == 1) {\n\t\tputs (\"1\");\n\t\treturn 0;\n\t}\n\tinit ();\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= N; i ++)\n\t\tfor (int j = 0; j <= i; j ++) {\n\t\t\tLL delta = f[i][j - 1] * (N - j + 1) % MOD * C (N * K - i - (K - 1) * (j - 1) - 1, K - 2) % MOD;\n\t\t\tif (j == 0) delta = 0;\n\t\t\tf[i][j] = (f[i][j] + f[i - 1][j] + delta) % MOD;\n\t\t}\n\tcout << f[N][N] << endl;\n\n\treturn 0;\n}\n\n/*\n2 2\n*/\n\n/*\n3 1\n*/\n\n/*\n2 3\n*/\n\n/*\n2000 2000\n*/"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\n\nvector<int> MODS = { 1000000007, 998244353 }; // 実行時に決まる\ntemplate<int IND = 0> struct Fp {\n    long long val;\n    \n    int MOD = MODS[IND];\n    constexpr Fp(long long v = 0) noexcept : val(v % MODS[IND]) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<IND>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<IND>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<IND> modpow(const Fp<IND> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nusing mint = Fp<0>; // MODを変える場合は値を変更\ntypedef vector<mint> vec;\ntypedef vector<vector<mint>> mat;\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,k;\n  cin >> n >> k;\n\n  if(k==1){\n    cout << 1 << endl;\n    return 0;\n  }\n\n  vec fact(n*k+10,1);\n  REP(i,n*k+5) fact[i+1] = fact[i]*(i+1);\n\n  mat dp(n+10,vec(n+10,0));\n  dp[0][0] = 1;\n\n  REP(i,n+1){\n    REP(j,n+1){\n      dp[i+1][j] += dp[i][j];\n      if(i>j && n*k-i-j*(k-1)-1-(k-2) >= 0) dp[i][j+1] += dp[i][j]*fact[n*k-i-j*(k-1)-1]/fact[k-2]/fact[n*k-i-j*(k-1)-1-(k-2)];\n    }\n  }\n\n  cout << dp[n][n]*fact[n] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define min(a,b) (a<b?a:b)\n#define max(a,b) (a>b?a:b)\ntypedef long long ll;\nusing namespace std;\nconst int maxn=2e3+5,mo=1e9+7;\nint i,j,n,k,f[maxn][maxn],ji[maxn*maxn],ni[maxn*maxn];\nint qs(int x,int y){\n\tint s=1;\n\tfor(;y;y>>=1,x=(ll)x*x%mo) if(y&1) s=(ll)s*x%mo;\n\treturn s; \n}\nint calc(int n,int  m){\n\treturn (ll)ji[n]*ni[m]%mo*ni[n-m]%mo;\n}\nvoid mod(int &x){\n\tx-=(x>=mo)?mo:0;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tif (k==1){\n        printf(\"1\\n\");\n        return 0;\n    }\n\tji[0]=1;\n\tfo(i,1,n*k) ji[i]=(ll)ji[i-1]*i%mo;\n\tni[n*k]=qs(ji[n*k],mo-2);\n\tfd(i,n*k,1) ni[i-1]=(ll)ni[i]*i%mo;\n\tf[0][0]=1;\n\tfo(i,0,n){\n\t\tfd(j,i,0) if (f[i][j]){\n\t\t\tint s=f[i][j];\n\t\t\tif (j) mod(f[i][j-1]+=s);\n\t\t\tif (i<n) mod(f[i+1][j+1]+=(ll)s*calc(i*k-j+k-2,k-2)%mo);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(ll)f[n][0]*ji[n]%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 2002\n#define mod 1000000007\n#define ll long long\n\nll f[nn*nn],rf[nn*nn];\nll qpow(ll x,ll y)\n{\n\tll res=1;\n\twhile(y)\n\t{\n\t\tif(y&1) res=res*x%mod;\n\t\tx=x*x%mod;y=y/2;\n\t}\n\treturn res;\n}\nll c(ll x,ll y)\n{\n\tif(x>y)  return 0;\n\treturn f[y]*rf[x]%mod*rf[y-x]%mod;\n}\n\nll dp[nn][nn];ll n,k;\nint main()\n{\n\tf[0]=1;for(int i=1;i<nn*nn;i++) f[i]=f[i-1]*i%mod;\n\trf[nn*nn-1]=qpow(f[nn*nn-1],mod-2);\n\tfor(int i=nn*nn-2;i>=0;i--) rf[i]=rf[i+1]*(i+1)%mod;\n\n\tcin>>n>>k;k--;\n\t\n\tdp[0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\tdp[i+1][j]%=mod;\n\t\t\tdp[i][j+1]+=dp[i][j]*c(k-1,n*k+n-k*j-i-1);\n\t\t\tdp[i][j+1]%=mod;\n\t\t}\n\t}\n\t\n\tcout<<dp[n][n]*f[n]%mod;\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nconst ll N=2000,p=1e9+7;\nll f[N+10][N+10],fac[N*N+10],ifac[N*N+10];\n\nll fpm(ll a,ll b)\n{\n\tll ret=1;\n\tfor(;b;b>>=1) ret=(b&1)?ret*a%p:ret,a=a*a%p;\n\treturn ret;\n}\n\ninline ll C(ll a,ll b){return fac[a]*ifac[b]%p*ifac[a-b]%p;}\n\ninline void add(ll &a,ll b){a=a+b>=p?a+b-p:a+b;}\n\nint main()\n{\n\tfac[0]=1;\n\tfor(ll i=1;i<=N*N;++i) fac[i]=fac[i-1]*i%p;\n\tifac[N*N]=fpm(fac[N*N],p-2);\n\tfor(ll i=N*N-1;i>=0;--i) ifac[i]=ifac[i+1]*(i+1)%p; \n\t\n\tint n,k;scanf(\"%d %d\",&n,&k);\n\tif(k==1){printf(\"1\\n\");return 0;};\n\tf[0][0]=1;\n\tfor(int j=1;j<=n;++j) f[0][j]=f[0][j-1]*C(j*(k-1)-1,k-2)%p;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i;j<=n;++j)\n\t\t{\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(j>i) add(f[i][j],f[i][j-1]*C(j*(k-1)+i-1,k-2)%p);\n\t\t};\n\tprintf(\"%lld\\n\",f[n][n]*fac[n]%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int TEN(int n) {return (n==0)?1:10*TEN(n-1);}\n\ntemplate<class T>\nT pow(T x, ll n) {\n    T r = 1;\n    while (n) {\n        if (n & 1) r *= x;\n        x *= x;\n        n >>= 1;\n    }\n    return r;\n}\n\ntemplate<uint MD>\nstruct ModInt {\n    uint v;\n    ModInt() : v{0} {}\n    ModInt(ll v) : v{normS(v%MD+MD)} {}\n    static uint normS(const uint &x) {return (x<MD)?x:x-MD;};\n    static ModInt make(const uint &x) {ModInt m; m.v = x; return m;}\n    const ModInt operator+(const ModInt &r) const {return make(normS(v+r.v));}\n    const ModInt operator-(const ModInt &r) const {return make(normS(v+normS(MD-r.v)));}\n    const ModInt operator*(const ModInt &r) const {return make((ull)v*r.v%MD);}\n    ModInt& operator+=(const ModInt &r) {return *this=*this+r;}\n    ModInt& operator-=(const ModInt &r) {return *this=*this-r;}\n    ModInt& operator*=(const ModInt &r) {return *this=*this*r;}\n    static ModInt inv(const ModInt &x) {\n        return pow(ModInt(x), MD-2);\n    }\n};\nusing Mint = ModInt<TEN(9)+7>;\n\nconst int MN = 4000400;\nMint fact[MN], iFac[MN];\n\nvoid first() {\n    fact[0] = 1;\n    for (int i = 1; i < MN; i++) {\n        fact[i] = fact[i-1]*i;\n    }\n    iFac[MN-1] = Mint::inv(fact[MN-1]);\n    for (int i = MN-2; i >= 0; i--) {\n        iFac[i] = iFac[i+1]*(i+1);\n    }\n}\n\nMint C(int n, int k) {\n    return fact[n]*iFac[n-k]*iFac[k];\n}\n\nint n, K;\nMint dp[2020][2020];\nbool used[2020][2020];\nMint calc(int i, int j) {\n    if (j < i) return 0;\n    if (i == n) return 1;\n    if (used[i][j]) return dp[i][j];\n    used[i][j] = true;\n    Mint ans = 0;\n    for (int k = j; k <= n; k++) {\n        int a = (n-i)*K;\n        int b = n-j;\n        ans += calc(i+1, k) * C(a+b+K-1, K-1);\n    }\n    return dp[i][j] = ans;\n}\n\nMint solve() {\n    if (K == 1) {\n        return 1;\n    }\n    K--;\n    Mint ans = 0;\n    for (int i = 1; i <= n; i++) {\n        ans += calc(1, i);\n    }\n    return ans*fact[n];\n}\n\nint main() {\n    first();\n    cin >> n >> K;\n    cout << solve().v << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<ctime>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<map>\n#include<vector>\n#include<set>\n#define rep(i,j,k) for(register int i = j; i <= k; i++) \n#define dow(i,j,k) for(register int i = j; i >= k; i--)\n#define fi first\n#define se second\n#define P pair<int,int>\n#define PP pair<int,pair<int,int> >\n#define mp(a,b) make_pair(a,b)\n#define ll long long\n#define ull unsigned long long\nusing namespace std;\n\ninline int read() { \n\tint s = 0, t = 1; char c = getchar();\n\twhile( !isdigit(c) ) { if( c == '-' ) t = -1; c = getchar(); }\n\twhile( isdigit(c) ) s = s * 10 + c - 48, c = getchar();\n\treturn s * t;\n}\n\nconst int N = 2005, M = N * N, NM = 4e6, p = 1e9+7;\ninline void _(ll &x) { if( x >= p ) x -= p; }\nll f[N][N], fac[NM] = {1}, ni[NM] = {1,1};\ninline ll C(int n,int m) { return fac[n] * ni[m] % p * ni[n-m] % p; }\n\nint main() {\n\tint n = read(), K = read();\n\tif( K == 1 || n == 1 ) { puts(\"1\"); return 0; }\n\tf[0][0] = 1;\n\trep(i,1,n*K) fac[i] = fac[i-1] * i % p;\n\trep(i,2,n*K) ni[i] = (p - p / i) * ni[p % i] % p;\n\trep(i,2,n*K) ni[i] = ni[i] * ni[i-1] % p;\n\trep(i,0,n) { \n\t\tdow(j,i,0) {\n\t\t\tif( f[i][j] ) { \n\t\t\t\tif( i < n ) _(f[i+1][j+1] += f[i][j]);\n\t\t\t\tif( j ) {\n\t\t\t\t\tint k = i - j; \n\t\t\t\t\t(f[i][j-1] += f[i][j] * C(n*K-k*K-j-1,K-2) % p * C(n-k,1)) %= p; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<f[n][0]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int max_N = 1e5 + 21;\n\nint n,a[max_N];\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",a+i);\n\tstd::sort(a+1,a+1+n,[&](int x,int y){return x>y;});\n\ta[0]=a[1];\n\tint i=0;\n\twhile(i<n&&i+1<a[i+1])++i;\n\tint x=a[i]-i,y=n-i;\n\tif(x&1||y&1)puts(\"First\");\n\telse puts(\"Second\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\ntypedef long long ll;\nconst int N=2020,M=4004000,P=1000000007;\nint i,j,k,n,m,ans;\nint f[N][N];\nint Jc[M],Jc_[M];\nint ksm(int x,int y) {\n\tint z=1;\n\tfor (;y;y>>=1,x=(ll) x*x%P) if (y&1) z=(ll) z*x%P;\n\treturn z;\n}\nvoid pre(int n) {\n\tint i;\n\tJc[0]=Jc_[0]=1;\n\tfor (i=1;i<=n;i++) Jc[i]=(ll) Jc[i-1]*i%P;\n\tJc_[n]=ksm(Jc[n],P-2);\n\tfor (i=n-1;i;i--) Jc_[i]=(ll) Jc_[i+1]*(i+1)%P;\n}\nint C(int n,int m) {\n\tif (n<m) return 0;\n\treturn (ll) Jc[n]*Jc_[m]%P*Jc_[n-m]%P;\n}\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tif (m==1) return puts(\"1\"),0;\n\tpre(n*m);\n\tf[0][0]=1;\n\tfor (i=0;i<=n;i++)\n\t\tfor (j=0;j<=i;j++) {\n\t\t\tif (j<i) f[i][j+1]=(f[i][j+1]+f[i][j])%P;\n\t\t\tf[i+1][j]=((ll) f[i][j]*C((i+1)*(m-1)+j-1,m-2)+f[i+1][j])%P;\n\t\t}\n\tans=(ll) f[n][n]*Jc[n]%P;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#define res register int\n#define N 2005\nusing namespace std;\nint inv[N*N+N+N],jie[N*N+N+N],k,n,f[N][N];\nconst int mod=1e9+7;\ninline int read()\n{\n  int X=0,w=0;\n  char ch=0;\n  while(!isdigit(ch))\n  {\n    w|=ch=='-';\n    ch=getchar();\n  }\n  while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();\n  return w?-X:X;\n}\ninline int quickpow(res base,res num)\n{\n  res ans=1;\n  for(; num; num>>=1,base=1LL*base*base%mod)\n    if(num&1)\n      ans=1LL*ans*base%mod;\n  return ans;\n}\ninline void init()\n{\n  jie[0]=jie[1]=inv[0]=inv[1]=1;\n  for(res i=2; i<=n*n+n+k; i++)\n  {\n    jie[i]=1LL*jie[i-1]*i%mod;\n    inv[i]=quickpow(jie[i],mod-2);\n  }\n}\ninline int C(int m,int n)\n{\n  return 1LL*jie[m]*inv[n]%mod*inv[m-n]%mod;\n}\nint main()\n{\n  n=read(),k=read()-1;\n  if(!k)\n  {\n    puts(\"1\");\n    return 0;\n  }\n  init();\n  f[0][0]=1;\n  for(res i=0; i<=n; i++)\n    for(res j=i; j<=n; j++)\n    {\n      if(i) f[i][j]=(f[i][j]+f[i-1][j])%mod;\n      if(j) f[i][j]=(f[i][j]+1LL*f[i][j-1]*C(i+j*k-1,k-1)%mod)%mod;\n    }\n  printf(\"%d\\n\",1LL*f[n][n]*jie[n]%mod);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<iostream>\n#define mmod 1000000007\n#define N 2100\nusing namespace std;\nint n,m,jc[N*N],ny[N*N],f[N][N],ans;\nint C(int n,int m)\n{\n\treturn 1ll*jc[n]*ny[m]%mmod*ny[n-m]%mmod;\n}\nvoid upd(int &x,int y)\n{\n\tx=(x+y)%mmod;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tif(m==1) {printf(\"1\\n\");return 0;}\n\tjc[0]=jc[1]=ny[0]=ny[1]=1;\n\tfor(int i=2;i<=n*m;i++) jc[i]=1ll*i*jc[i-1]%mmod,ny[i]=1ll*(-mmod/i)*ny[mmod%i]%mmod;\n\tfor(int i=2;i<=n*m;i++) ny[i]=1ll*ny[i]*ny[i-1]%mmod;\n\tf[0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=i;j<=n;j++)\n\t\t{\n\t\t\tif(i<j) upd(f[i+1][j],f[i][j]);\n\t\t\tupd(f[i][j+1],1ll*f[i][j]*C((j+1)*(m-1)+i-1,m-2)%mmod);\n\t\t}\n\tans=1ll*f[n][n]*jc[n]%mmod;\n\tprintf(\"%d\\n\",(ans+mmod)%mmod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\nint read();\nint M(int x) { return x >= mod ? x - mod : x; }\nint fsp(int bs, int p) {\n    int rt = 1;\n    while (p) {\n        if (p & 1) rt = 1ll * rt * bs % mod;\n        bs = 1ll * bs * bs % mod, p >>= 1;\n    }\n    return rt;\n}\n\nint n, k;\nint fac[4000006], caf[4000006];\nvoid init() {\n    int lim = 4000006;\n    fac[0] = 1;\n    for (int i = 1; i <= lim; ++i) fac[i] = 1ll * fac[i - 1] * i % mod;\n    caf[lim] = fsp(fac[lim], mod - 2);\n    for (int i = lim; i >= 1; --i) caf[i - 1] = 1ll * caf[i] * i % mod;\n}\nint C(int x, int y) { return 1ll * fac[x] * caf[y] % mod * caf[x - y] % mod; }\nint f[2003][2003];\n\nint main() {\n    n = read(), k = read(), init();\n    if (k == 1) return puts(\"1\"), 0;\n    for (int i = 1; i <= n; ++i) f[i][0] = 1;\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= i; ++j)\n            f[i][j] = M(f[i - 1][j] +\n                        1ll * f[i][j - 1] * (n - j + 1) % mod *\n                            C(n - i + (n - j + 1) * (k - 1) - 1, k - 2) % mod);\n    printf(\"%d\\n\", f[n][n]);\n    return 0;\n}\n\nint read() {\n    int x = 0, f = 1;\n    char c = getchar();\n    while (c < '0' || c > '9') f = (c == '-') ? -1 : f, c = getchar();\n    while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\nconst int N=2010,mod=1000000007;\nint a[N*N],b[N*N],f[N][N];\nint add(int a,int b){\n    a+=b;\n    return a>=mod?a-mod:a;\n}\nint mul(int a,int b){\n    return 1LL*a*b%mod;\n}\nint pow(int a,int b)\n{\n    ll res=1%mod;\n    for(;b;b>>=1){\n        if(b&1) res=(ll)(res*a)%mod;\n        a=(ll)a*a%mod;\n    }\n    return res;\n}\n\nint function(int n,int m)\n{\n    return mul(a[n+m-1],mul(b[m-1],b[n]));\n}\nvoid init(int n)\n{\n\ta[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\ta[i]=mul(a[i-1],i);\n\tb[n]=pow(a[n],mod-2);\n\tfor(int i=n;i;--i)\n\t\tb[i-1]=mul(b[i],i);\n}\nint main()\n{\n\tint n,k;\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1) return 0&puts(\"1\");\n\tinit(n*k);\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i;j>=0;--j)\n\t\t\tf[i][j]=add(f[i][j+1],j==0?0:mul(f[i-1][j-1],mul(n-i+1,function(k-2,(i-1)*k-(j-1)+1))));\n\tprintf(\"%d\\n\",f[n][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define int long long\n#define F first\n#define S second\nconst ll INF = 1LL * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;\nconst int inf = 1000 * 1000 * 1000 + 1000;\n\n// Man Hamishe bazande bodam royye kaqaz\n// vali hamishe jolo raftam toyye karam\n// BAHRAM\n\nconst int N = 2100,\n\t  MOD = 1000 * 1000 * 1000 + 7;\n\nint f[N * N],\n\trf[N * N],\n\tdp[N][N];\n\nint add(int a, int b){\n\ta %= MOD;\n\tb %= MOD;\n\treturn (a + b) % MOD;\n}\nint mu(int a, int b){\n\ta %= MOD;\n\tb %= MOD;\n\treturn (a * b) % MOD;\n}\n\nint Pow(int a, int b){\n\tint ans = 1,\n\t\tt = a;\n\twhile(b){\n\t\tif(b & 1)\n\t\t\tans = mu(ans, t);\n\t\tt = mu(t, t);\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nint choose(int a, int b){\n\treturn mu(f[a], mu(rf[b], rf[a - b]));\n}\n\nint32_t main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t\n\tf[0] = 1;\n\tf[1] = 1;\n\trf[1] = 1;\n\trf[0] = 1;\n\tfor(int i = 2; i < N * N; i++){\n\t\tf[i] = mu(i, f[i - 1]);\n\t\trf[i] = mu(Pow(i, MOD - 2), rf[i - 1]);\n\t}\n\n\tint n, k;\n\tcin >> n >> k;\n\n\tif(k == 1){\n\t\tcout << 1 << '\\n';\n\t\treturn 0;\n\t}\n\n\tdp[1][0] = dp[1][1] = 1;\n\tfor(int i = 2; i <= n; i++){\n\t\tint sum = dp[i - 1][i - 1];\n\t\tdp[i][i] = mu(choose((i - 1) * (k - 1) + k - 2, (i - 1) * (k - 1)),\n\t\t\t\tsum);\n//\t\tcout << dp[i][i] << ' ' ;\n\t\tfor(int j = i - 1; j > 0; j--){\n\t\t\tif(j != 1)\n\t\t\t\tsum = add(sum, dp[i - 1][j - 1]);\n\t\t\tint sorat = i * k - j - 1,\n\t\t\t\tmakhraj = (i - 1) * k + 1 - j;\n\t//\t\tcout << f[sorat] << ' ';\n\t\t\tdp[i][j] = mu(choose(sorat, makhraj),\n\t\t\t\tsum);\n\t//\t\tcout << i << ' ' << j << ' ' << dp[i][j] << '\\n';\n\t\t}\n\t\tdp[i][0] = dp[i][1];\n\t}\n\n\tint ans = 0;\n\tfor(int i = 1; i <= n; i++)\n\t\tans = add(ans, dp[n][i]);\n\tcout << mu(ans, f[n]) << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2005;\nconst int mod = 1e9 + 7;\n\nint n, k;\nint f[N][N];\nint fac[N * N], ifac[N * N];\n\nvoid add(int &x,int y) {\n\tx += y; if (x >= mod) x -= mod;\n}\n\nint mul(int x,int y) {\n\treturn (long long) x * y % mod;\n}\n\nint pw(int x,int y) {\n\tint ret = 1;\n\twhile (y) {\n\t\tif (y & 1) ret = mul(ret, x);\n\t\tx = mul(x, x);\n\t\ty >>= 1;\n\t}\n\treturn ret;\n}\n\nint C(int n,int k) {\n\tif (n < k || k < 0) return 0;\n\treturn mul(fac[n], mul(ifac[k], ifac[n - k]));\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tfac[0] = 1; \n\tfor (int i = 1; i < N * N; ++i) fac[i] = mul(fac[i - 1], i);\n\tifac[N * N - 1] = pw(fac[N * N - 1], mod - 2);\n\tfor (int i = N * N - 2; i >= 0; --i) ifac[i] = mul(ifac[i + 1], i + 1);\n\tcin >> n >> k;\n\tif (k == 1) return cout << 1 << '\\n',0;\n\t\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tif (j < i) add(f[i][j], f[i - 1][j]);\n\t\t\tif (j > 0) add(f[i][j], mul(f[i][j - 1], C(n * k - i - (j - 1) * k, k - 2))); \n\t\t}\n\t}\n\tcout << mul(f[n][n], fac[n]) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define gc getchar\n#define pc putchar\ninline ll rd(){\n    ll x=0,f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid writeln(ll x){write(x);puts(\"\");}\nconst int mod = 1e9+7;\nconst int maxn = 2099;\nint dp[maxn][maxn],fac[maxn*maxn],inv[maxn*maxn],n,k;\ninline int C(int n,int m){\n\treturn 1ll * fac[n] * inv[m] % mod * inv[n-m] % mod;\n}\ninline int qpow(int a,int b){\n\tint ans = 1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1)ans=1ll*ans*a%mod;\n\treturn ans; \n}\nint main(){\n\tn = rd(),k = rd();\n\tfac[0] = 1;\n\tRep(i,1,2002*2002) fac[i] = 1ll * fac[i-1] * i % mod;\n\tinv[2002*2002] = qpow(fac[2002*2002],mod-2);\n\tDep(i,2002*2002-1,0) inv[i] = 1ll * inv[i+1] * (i+1) % mod;\n\tdp[0][1] = 1;\n\tRep(i,2,n){\n\t\tdp[0][i] = 1ll * dp[0][i-1] * C((i-1)*(k-1) + k-2,k-2) % mod;\n\t\t//n插入m \n\t}\n\tRep(i,1,n){\n\t\tRep(j,i,n){\n\t\t\tdp[i][j] = (dp[i-1][j] +\n\t\t\t1ll * dp[i][j-1] * C(i+(j-1)*(k-1)+k-2,k-2) % mod) % mod;\n\t\t}\n\t}\n\twriteln(1ll * dp[n][n] * fac[n] % mod);\n\treturn 0;\n}\n//n+1个空 \n//a1 + a2 + a3 …… an + a[n+1] = m\n//(a1+1) + (a2+1) + (a3+1) + …… = m + n + 1"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long int int64;\n\nconst int MOD = (int) 1e9 + 7;\n\nvoid sadd(int &a, int b)\n{\n    a += b;\n    if (a >= MOD)\n        a -= MOD;\n}\nint add(int a, int b)\n{\n    sadd(a, b);\n    return a;\n}\nvoid ssub(int &a, int b)\n{\n    a -= b;\n    if (a < 0)\n        a += MOD;\n}\nint sub(int a, int b)\n{\n    ssub(a, b);\n    return a;\n}\nint mul(int a, int b)\n{\n    return (a * 1LL * b) % MOD;\n}\n\n\nconst int N = 2005;\nconst int X = N * N;\n\nint fact[X], ri[X], rfact[X];\n\nvoid init()\n{\n    ri[1] = 1;\n    fact[0] = 1;\n    rfact[0] = 1;\n\n    for (int i = 1; i < X; i++)\n    {\n        if (i != 1)\n            ri[i] = sub(0, mul(ri[MOD % i], MOD / i));\n        fact[i] = mul(fact[i - 1], i);\n        rfact[i] = mul(rfact[i - 1], ri[i]);\n    }\n}\n\nint C(int n, int k)\n{\n    //eprintf(\"get C : %d %d\\n\", n, k);\n    if (k < 0 || k > n)\n        return 0;\n    return mul(fact[n], mul(rfact[k],rfact[n - k]));\n}\n\nint dp[N][N];\n\nint main(int,  char **)\n{\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n#endif\n\n    init();\n\n    int n, k;\n    scanf(\"%d%d\", &n, &k);\n\n    if (k == 1)\n    {\n        printf(\"1\\n\");\n        return 0;\n    }\n\n    dp[0][0] = 1;\n    for (int i = 0; i <= n; i++)\n        for (int j = 0; j <= i; j++)\n        {\n            int cur = dp[i][j];\n      //      eprintf(\"i = %d, j = %d : %d\\n\", i, j, dp[i][j]);\n\n            if (i < n)\n            {\n                int cnt = (i + 1) * (k - 1) + j;\n                int nx = mul(cur, C(cnt - 1, k - 2));\n                sadd(dp[i + 1][j], nx);\n            }\n            if (j < i)\n            {\n                sadd(dp[i][j + 1], cur);\n            }\n        }\n    printf(\"%d\\n\", mul(dp[n][n], fact[n]));\n\n\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define ll long long\nconst int N=2005,M=4e6+5,mo=1e9+7;\nint n,m,nm,i,j,f[N];\nint fact[M],inv[M],fv[M];\nvoid init(int n){\n\tfact[0]=fact[1]=inv[1]=fv[0]=fv[1]=1;\n\tfor (i=2;i<=n;i++){\n\t\tfact[i]=(ll)fact[i-1]*i%mo;\n\t\tinv[i]=(ll)inv[mo%i]*(mo-mo/i)%mo;\n\t\tfv[i]=(ll)fv[i-1]*inv[i]%mo;\n\t}\n}\nint C(int n,int m){return (ll)fact[n]*fv[m]%mo*fv[n-m]%mo;}\n/*\ntesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttetesttesttest\ntesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttetesttesttest\ntesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttetesttesttest\ntesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttetesttesttest\ntesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttetesttesttest\ntesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttetesttesttest\ntesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttetesttesttest\ntesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttetesttesttest\ntesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttetesttesttest\ntesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttetesttesttest\n*/\nint main(){\n\tscanf(\"%d%d\",&n,&m);m--;\n\tif (!m){puts(\"1\");return 0;}\n\tnm=n*m+n;init(nm);f[0]=1;\n\tfor (i=1;i<=n;i++) for (j=1;j<=i;j++)\n\t\tf[j]=(f[j]+(ll)C(nm-i-(j-1)*m-1,m-1)%mo*f[j-1])%mo;\n\tfor(int i=1;i<=n;i++)f[n]=1ll*f[n]*i%mo;\n\tprintf(\"%d\",f[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 2005\n#define MAXM 4000005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint N,K,fact[MAXM],invf[MAXM];\nvoid add(int &a,int b) {a+=b; if(a>=MOD) a-=MOD;}\nvoid dec(int &a,int b) {a-=b; if(a<0) a+=MOD;}\nint pow_mod(int a,int i)\n{\n    int s=1;\n    while(i)\n    {\n        if(i&1) s=1LL*s*a%MOD;\n        a=1LL*a*a%MOD;\n        i>>=1;\n    }\n    return s;\n}\nint comb(int n,int k)\n{\n    if(n<k) return 0;\n    return 1LL*fact[n]*invf[k]%MOD*invf[n-k]%MOD;\n}\nint dp[MAXN][MAXN];\nint main()\n{\n    fact[0]=invf[0]=1;\n    for(int i=1;i<=4000000;i++) fact[i]=1LL*fact[i-1]*i%MOD;\n    invf[4000000]=pow_mod(fact[4000000],MOD-2);\n    for(int i=3999999;i>=1;i--) invf[i]=1LL*invf[i+1]*(i+1)%MOD;\n    scanf(\"%d%d\",&N,&K);\n    if(K==1) {puts(\"1\"); return 0;}\n    dp[0][0]=1;\n    for(int i=0;i<=N;i++)\n        for(int j=0;j<=N;j++)\n        {\n            if(i<N) add(dp[i+1][j],dp[i][j]);\n            if(j<i) add(dp[i][j+1],1LL*dp[i][j]*comb(N-i+(N-j-1)*(K-1)+K-2,K-2)%MOD);\n        }\n    printf(\"%d\\n\",1LL*dp[N][N]*fact[N]%MOD);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=2e3+11;\nconst int M=4e6+11;\nconst int mod=1e9+7;\nint n,k,f[N][N],fac[M],ifac[M];\nint read(){\n    int x=0,f=1;char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}\n    while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}\n    return x*f;\n}\nint qpow(int a,int b){\n    int re=1;\n    while(b){\n        if(b&1) re=(re*a)%mod;\n        b>>=1;a=a*a%mod;\n    }return re;\n}\nint C(int a,int b){\n    if(a<b) return 0;\n    return fac[a]*ifac[b]%mod*ifac[a-b]%mod;\n}\nsigned main(){\n    n=read(),k=read();\n    if(k==1) return puts(\"1\"),0;\n    fac[0]=1;ifac[0]=1;f[0][0]=1;\n    for(int i=1;i<=n*k;i++) fac[i]=fac[i-1]*i%mod;\n    ifac[n*k]=qpow(fac[n*k],mod-2);\n    for(int i=n*k-1;i;i--) ifac[i]=ifac[i+1]*(i+1)%mod;\n    for(int i=1;i<=n;i++)\n        for(int j=0;j<=i;j++){\n            if(i>=j) f[i][j]+=f[i-1][j];\n            f[i][j]=(f[i][j]+f[i][j-1]*C((n-j+1)*(k-1)+n-i-1,k-2)%mod)%mod;\n        }\n    printf(\"%lld\\n\",f[n][n]*fac[n]%mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rg register\nusing namespace std;\nconst int mod=1e9+7;\n#define _ 2001\nint n, k, f[_][_], sum[_*_], inv[_*_];\nint qp(int x, int y){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1)ans=1ll*ans*x%mod;\n\t\tx=1ll*x*x%mod, y>>=1;\n\t}return ans;\n}\nint C(int m, int r){return 1ll*sum[m]*inv[r]%mod*inv[m-r]%mod;}\nint main(){\n\tscanf(\"%d%d\", &n, &k);\n\tinv[0]=inv[1]=sum[0]=sum[1]=1;\n\tfor(rg int i=2; i<=n*n; ++i)\n\t\tsum[i]=1ll*sum[i-1]*i%mod, inv[i]=qp(sum[i], mod-2);\n\tif(k==1){puts(\"1\"); return 0;}\n\tf[0][0]=1;\n\tfor(int i=1; i<=n; ++i)\n\t\tfor(int j=0; j<=i; ++j){\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(j)(f[i][j]+=1ll*C((n-j+1)*(k-1)+n-i-1, k-2)*f[i][j-1]%mod)%=mod;\n\t\t}\n\tfor(int i=2; i<=n; ++i)\n\t\tf[n][n]=1ll*f[n][n]*i%mod;\n\tprintf(\"%d\", f[n][n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nll read(){\n\tchar c=getchar();bool flag=0;ll x=0;\n\twhile(c<'0'||c>'9'){if(c=='-')flag=1;c=getchar();}\n\twhile(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}\n\treturn flag?-x:x;\n}\n#define N 2010 \nconst ll p=1e9+7;\nll dp[N][N],fac[N*N],inv[N*N];\nll fpow(ll a,ll x){\n\tll ans=1;\n\twhile(x){\n\t\tif(x&1) ans=ans*a%p;\n\t\ta=a*a%p,x=x/2; \n\t}\n\treturn ans;\n}\nll Cnt(ll n,ll m){\n\treturn fac[m]*inv[n]%p*inv[m-n]%p;\n}\nint main(){\n\tll n=read(),k=read();\n\tif(k==1){\n\t\tprintf(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\tll mx=(N-10)*(N-10); \n\tfor(ll i=1;i<=mx;i++) fac[i]=fac[i-1]*i%p;\n\tinv[n*k]=fpow(fac[n*k],p-2);\n\tfor(ll i=mx-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%p;\n\tfor(ll i=1;i<=n;i++) dp[i][0]=1;\n\tfor(ll i=1;i<=n;i++){\n\t\tfor(ll j=1;j<=i;j++){\n\t\t\tdp[i][j]=dp[i-1][j]+dp[i][j-1]*(n-(j-1))*Cnt(k-2,n*k-i-(j-1)*(k-1)-1);\n\t\t}\n\t}\n\tprintf(\"%lld\",dp[n][n]); \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2005,mod=1000000007;\nint n,k,dp[N][N],fac[N*N],ifac[N*N];\nint pw(int a,int b){int r=1;for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)r=1ll*r*a%mod;return r;}\nint C(int a,int b){return a<0||b<0||a<b?0:1ll*fac[a]*ifac[b]%mod*ifac[a-b]%mod;}\nint main()\n{\n\tfor(int i=fac[0]=1;i<N*N;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\tifac[N*N-1]=pw(fac[N*N-1],mod-2);\n\tfor(int i=N*N-1;i;i--)ifac[i-1]=1ll*ifac[i]*i%mod;\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1){puts(\"1\");return 0;}\n\tdp[0][0]=1;\n\tfor(int i=0;i<=n;i++)for(int j=0;j<=i;j++)\n\t{\n\t\tif(i)dp[i][j]=(dp[i][j]+dp[i-1][j])%mod;\n\t\tif(j)dp[i][j]=(dp[i][j]+1ll*dp[i][j-1]*C(n*k-i-(j-1)*(k-1)-1,k-2))%mod;\n\t}\n\tprintf(\"%d\\n\",1ll*dp[n][n]*fac[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#define N 4000010\n#define M 2010\n#define mod 1000000007\n#define ll long long\nusing namespace std;\nll fac[N],inv[N],f[M][M];\nll ksm(ll a,ll b=mod-2)\n{\n\tif(b==0) return 1;\n\tif(b==1) return a;\n\tll q=ksm(a,b>>1);\n\tif(b&1) return q*q%mod*a%mod;\n\treturn q*q%mod;\n}\nll C(int a,int b){if(b>a || b<0) return 0;return fac[a]*inv[b]%mod*inv[a-b]%mod;}\nint main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tif(m==1){puts(\"1\");return 0;}\n\tfac[0]=1;\n\tfor(int i=1;i<=N-10;i++) fac[i]=fac[i-1]*i%mod;\n\tinv[N-10]=ksm(fac[N-10]);\n\tfor(int i=N-11;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tconst int r=n-i+(n-j+1)*(m-1)-1;\n\t\t\tf[i][j]=f[i-1][j]+(j?f[i][j-1]*(n-j+1)%mod*C(r,m-2):0);\n\t\t\tf[i][j]%=mod;\n\t\t}\n\tprintf(\"%lld\",f[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\n#include <utility>\nconst int maxn = 2005;\nusing ll = long long;\nconst ll ha = 1000000007LL;\nll pow_mod(ll a, ll b) {\n  ll ans = 1, res = a;\n  while(b) {\n    if(1LL & b) ans = ans * res % ha;\n    res = res * res % ha; b >>= 1;\n  }\n  return ans;\n}\nll inv(ll x) {\n  return pow_mod(x, ha - 2LL);\n}\n\nll fac[maxn * maxn], ifac[maxn * maxn];\nvoid process() {\n  fac[0] = 1;\n  const int n = 4000005;\n  for(int i = 1; i <= n; i ++) {\n    fac[i] = fac[i - 1] * (ll)i % ha;\n  }\n  ifac[n] = inv(fac[n]);\n  for(int i = n - 1; i >= 0; i --) {\n    ifac[i] = ifac[i + 1] * (ll(i + 1)) % ha;\n  }\n}\nll C(int n, int m) {\n  if(n < m) return 0;\n  ll ret = fac[n] * ifac[n - m] % ha;\n  ret = ret * ifac[m] % ha;\n  return ret;\n}\n\nint main() {\n  process();\n  int n, k; scanf(\"%d%d\", &n, &k);\n  if(k == 1) {\n    puts(\"1\"); return 0;\n  }\n  static ll f[maxn];\n  f[0] = 1;\n  for(int i = 1; i <= n; i ++) {\n    for(int j = 1; j <= i; j ++) {\n      ll delta = n - j + 1;\n      delta = delta * C(n * k - i - (j - 1) * (k - 1) - 1, k - 2) % ha;\n      delta = delta * f[j - 1] % ha;\n      f[j] += delta;\n      if(f[j] >= ha) f[j] -= ha;\n    }\n  }\n  printf(\"%lld\\n\", f[n]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst long long MOD = (long long)(1e9 + 7);\nconst int kK = (int)(2049 * 2049);\n\nlong long fac[kK + 5], inv[kK + 5];\n\nlong long qpow(long long base,int power)\n{\n\tlong long ret = 1;\n\tfor(; power; power >>= 1)\n\t{\n\t\tif(power & 1) ret = ret * base % MOD;\n\t\tbase = base * base % MOD;\n\t}\n\treturn ret;\n}\n\ninline long long C(int x, int y)\n{\n\treturn(((fac[y] * inv[x]) % MOD) * inv[y - x]) % MOD;\n}\n\nint n, k;\nlong long f[2049][2049];\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin >> n >> k;\n\tif(k == 1)\n\t{\n\t\tcout << 1 <<endl;\n\t\treturn 0;\n\t}\n\tfac[0] = 1;\n\tfor(int i = 1; i <= kK; ++i) fac[i] = fac[i-1] * i % MOD;\n\tinv[kK] = qpow(fac[kK], MOD - 2);\n\tfor(int i = kK; i >= 1; --i) inv[i - 1] = inv[i] * i % MOD;\n\tf[0][0] = 1;\n\tfor(int i = 1;i <= n; ++i)\n\t{\n\t\tf[i][0] = f[i - 1][0];\n\t\tfor(int j = 1; j <= i; ++j)\n\t\t{\n\t\t\tf[i][j] = f[i - 1][j];\n\t\t\tf[i][j] = f[i][j] + f[i][j - 1] * C(k - 2, n * k - i - (j - 1)*(k - 1) - 1);\n\t\t\tf[i][j] % =MOD;\n\t\t}\n\t}\n\tcout << fac[n] * f[n][n] % MOD<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int N=2100,mod=1e9+7;\nint n,k,jc[N*N],inv[N*N],f[N][N];\nint ksm(int x,int k)\n{\n\tint s=1;for(;k;k>>=1,x=1ll*x*x%mod)\n\t\t\t\tif(k&1) s=1ll*s*x%mod;return s;\n}\nvoid add(int &x,int y) {x+=y;if(x>=mod) x-=mod;}\nint mul(int x,int y) {return 1ll*x*y%mod;}\nint C(int n,int k) {return n<k?0:mul(mul(jc[n],inv[k]),inv[n-k]);}\nint main()\n{\n\tcin>>n>>k;jc[0]=inv[0]=1;\n\tif(k==1) return puts(\"1\"),0;\n\tfor(int i=1;i<=n*k;i++)\n\t\tjc[i]=mul(jc[i-1],i),inv[i]=ksm(jc[i],mod-2);\n\tf[0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tif(!f[i][j]) continue;\n\t\t\tadd(f[i+1][j],f[i][j]);\n\t\t\tif(i>=j+1) add(f[i][j+1],mul(mul(f[i][j],n-j),C(n*k-j*k+j-i-1,k-2)));\n\t\t}\n\tcout<<f[n][n]<<endl;return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#define re register\n#define LL long long\n#define N 2005\n#define Maxn 4000000\nusing namespace std;\nconst int Mod=1e9+7;\nint n,k;\nLL f[N][N],fac[Maxn+5],inv_fac[Maxn+5];\ninline LL C(int n,int m){ return (((fac[m]*inv_fac[n])%Mod)*inv_fac[m-n])%Mod; }\nLL power(LL x,int P){\n    LL ans=1,m=x;\n    while(P){\n        if(P&1) (ans*=m)%=Mod;\n        P>>=1;(m*=m)%=Mod;\n    }\n    return ans;\n}\nint main(){\n    cin>>n>>k; \n    if(k==1){ printf(\"%d\\n\",1);return 0;}\n    //memset(f,0,sizeof(f)); \n    fac[0]=1; for(re int i=1;i<=Maxn;++i) fac[i]=(fac[i-1]*i)%Mod;\n    inv_fac[Maxn]=power(fac[Maxn],Mod-2); for(re int i=Maxn-1;i>=0;--i) inv_fac[i]=(inv_fac[i+1]*(i+1))%Mod;\n    f[0][0]=1;\n    for(re int i=1;i<=n;++i){\n        for(re int j=0;j<=i;++j){\n            f[i][j]=f[i-1][j];\n            if(!j) continue;\n            (f[i][j]+=f[i][j-1]*(n-j+1)%Mod*C(k-2,n-i+(n-j+1)*(k-1)-1)%Mod)%=Mod;\n        }\n    }\n    printf(\"%lld\\n\",f[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pc(x) putchar(x)\nnamespace ib {char b[100];}\ninline void pi(int x){\n\tif(x==0) {pc(48); return;}\n\tif(x<0) {pc('-'); x=-x;}\n\tchar *s=ib::b;\n\twhile(x) *(++s)=x%10,x/=10;\n\twhile(s!=ib::b) pc((*(s--))+48);\n}\ninline void ri(int &x){\n\tx=0; static char c; bool t(0);\n\twhile(c=getchar(),c<'0'||c>'9') if(c=='-') t=1; else t=0;\n\tdo x=(x<<1)+(x<<3)+c-'0'; while(c=getchar(),c>='0'&&c<='9');\n\tif(t) x=-x;\n}\nconst int M=1e9+7,N=2024;\nint JC[N*N],RJC[N*N],f[N][N];\ninline int ksm(int n,int c){\n\tint jc=1;\n\twhile(c){\n\t\tif(c&1) jc=(long long)jc*n%M;\n\t\tn=(long long)n*n%M; c>>=1; \n\t}\n\treturn jc;\n}\ninline int C(int n,int m){\n\tif(m==0||m==n) return 1;\n\tif(m>n) return 0;\n\treturn (long long)JC[n]*RJC[m]%M*RJC[n-m]%M;\n}\nint main(){\n\tint i,j,n,k; ri(n); ri(k);\n\tif(k==1){pc('1'); return 0;}\n\tJC[0]=1; for(i=1;i<=2000*2000;++i) JC[i]=(long long)JC[i-1]*i%M;\n\tRJC[2000*2000]=ksm(JC[2000*2000],M-2);\n\tfor(i=2000*2000-1;i>=0;--i) RJC[i]=(long long)RJC[i+1]*(i+1)%M;\n\tf[0][0]=1;\n\tfor(i=0;i<=n;++i)\n\tfor(j=0;j<=n;++j){\n\t\tf[i][j+1]=(f[i][j+1]+f[i][j])%M;\n\t\tif(j) f[i+1][j-1]=(f[i+1][j-1]+(long long)(n-i)*C(n*k-i*k-j-1,k-2)%M*f[i][j])%M;\n\t}\n\tcout<<f[n][0];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 2005;\nconst int mod = 1e9 + 7;\nLL n , k;\nLL fac[MAXN * MAXN] , inv[MAXN * MAXN] , finv[MAXN * MAXN];\nLL C(LL a , LL b) {\n\tif(a == 0 || b == 0 || a == b) return 1;\n\treturn fac[a] * finv[a - b] % mod * finv[b] % mod;\n}\nLL dp[MAXN][MAXN];\nint main() {\n\tscanf(\"%lld %lld\" , &n , &k);\n\tif(k == 1) {\n\t\tprintf(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0] = 1;\n\tfor (LL i = 1; i <= n * k; ++i) fac[i] = fac[i - 1] * i % mod;\n\tfinv[1] = inv[1] = 1;\n\tfor (LL i = 2; i <= n * k; ++i) inv[i] = (mod - mod / i) * inv[mod % i] % mod , finv[i] = finv[i - 1] * inv[i] % mod;\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tif(j) dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] * C(n * k - (k - 1) * (j - 1) - i - 1 , k - 2) % mod) % mod;\n\t\t\telse dp[i][j] = dp[i - 1][j];\n\t\t}\n\t}\n\tprintf(\"%lld\" , dp[n][n] * fac[n] % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint mod, ans, N, K, dp[2009][2009], s[2009][2009];\nint fac[4000009], inv[4000009];\n\nint pow (int a, int b, int mod)\n{\n    int p = 1;\n    for (int i=0; (1<<i) <= b; i++)\n    {\n        if (b & (1 << i)) p = (1LL * p * a) % mod;\n        a = (1LL * a * a) % mod;\n    }\n    return p;\n}\n\nint comb (int n, int k)\n{\n    if (k > n || k < 0) return 0;\n    int ans = (1LL * fac[n] * inv[k]) % mod;\n    ans = (1LL * ans * inv[n - k]) % mod;\n    return ans;\n}\n\nvoid PreProc ()\n{\n    fac[0] = 1;\n    for (int i=1; i<=N * K; i++)\n        fac[i] = (1LL * fac[i - 1] * i) % mod;\n    inv[N * K] = pow (fac[N * K], mod - 2, mod);\n    for (int i=N * K - 1; i>=0; i--)\n        inv[i] = (1LL * inv[i + 1] * (i + 1)) % mod;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d\", &N, &K), mod = 1e9 + 7;\nif (K == 1)\n{\n    printf (\"1\\n\");\n    return 0;\n}\nPreProc ();\ndp[0][0] = s[0][0] = 1;\nfor (int i=1; i<=N; i++)\n    for (int j=1; j<=i; j++)\n    {\n        int coef = comb (i * K - j - 1, K - 2), sum = s[i - 1][i - 1];\n        if (j > 1)\n        {\n            sum -= s[i - 1][j - 2];\n            if (sum < 0) sum += mod;\n        }\n/*        for (int k=j - 1; k<i; k++)\n            sum += dp[i - 1][k];\n        dp[i][j] = sum * coef;*/\n        dp[i][j] = (1LL * sum * coef) % mod;\n        s[i][j] = s[i][j - 1] + dp[i][j];\n        if (s[i][j] >= mod) s[i][j] -= mod;\n    }\nprintf (\"%d\\n\", (1LL * fac[N] * s[N][N]) % mod);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int maxn = 2000 + 7;\n\nlong long f[maxn][maxn];\nlong long step[maxn * maxn], inv[maxn * maxn];\n\nlong long C(int n, int m) {\n    return step[n] * inv[m] % mod * inv[n - m] % mod;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    if (k == 1) {\n        printf(\"1\\n\");\n        return 0;\n    }\n\n    long long ans = 1;\n    for (int i = 1; i <= n; i++) ans = ans * i % mod;\n\n    step[0] = 1;\n    for (int i = 1; i <= n * k; i++) step[i] = step[i - 1] * i % mod;\n\n    inv[0] = inv[1] = 1;\n    for (int i = 2; i <= n * k; i++) \n        inv[i] = mod - (mod / i) * inv[mod % i] % mod;\n    for (int i = 2; i <= n * k; i++) \n        inv[i] = inv[i  - 1] * inv[i] % mod;\n    \n    f[0][0] = 1;\n\n    for (int i = 0; i <= n; i++) \n    for (int j = i; j <= n; j++) {\n        long long &rt = f[i][j];\n\n        if (j > i) \n            rt = C((k - 1) * j + i - 1, k - 2) * f[i][j - 1] % mod;\n        if (i > 0) {\n            rt = (rt + f[i - 1][j]) % mod;\n        }\n    }\n\n    cout << ans * f[n][n] % mod << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n#define repd(i,x,y) for(int i=x; i>=y; --i)\n \nusing namespace std;\nconst int N=2005,mod=1000000007;\ntypedef long long LL;\nint n,k,ans;\nLL flv[N*N],inv[N*N],f[N][N];\n\nLL getmi(LL a,int x)\n{\n    LL rt=1;\n    while(x)\n    {\n        if(x&1) rt=rt*a%mod;\n        a=a*a%mod,x>>=1;\n    }\n    return rt;\n}\n \nLL C(int n,int m)\n{\n    return n<m?0:flv[n]*inv[m]%mod*inv[n-m]%mod;\n}\n \nvoid inc(LL &x,int y)\n{\n    if((x+=y)>=mod) x-=mod;\n}\n \nvoid task()\n{\n\tif(k==1) {puts(\"1\"); return;}\n    flv[0]=1;\n    rep(i,1,n*k) flv[i]=flv[i-1]*i%mod;\n    inv[n*k]=getmi(flv[n*k],mod-2);\n    repd(i,n*k,1) inv[i-1]=inv[i]*i%mod;\n    f[0][0]=1;\n    rep(i,1,n)\n        rep(j,0,i)\n        {\n            f[i][j]=f[i-1][j];\n            if(j) f[i][j]=(f[i][j]+f[i][j-1]*C(n-i+(k-1)*(n-j+1)-1,k-2))%mod;\n        }\n    printf(\"%lld\\n\",flv[n]*f[n][n]%mod);\n}\n \nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    task();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define N 4000005\n#define MOD 1000000007\nusing namespace std;\nint n,k,f[2005][2005],inv[N],fac[N],infac[N];\nint C(int x,int y){\n\treturn x>=y ? fac[x]*infac[y]%MOD*infac[x-y]%MOD : 0;\n}\nsigned main(){\n\tcin>>n>>k;\n\tif(k==1){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tfac[0]=infac[0]=inv[1]=1;//first deal\n\tfor(int i=1;i<=n*k;i++)\n\t\tfac[i]=fac[i-1]*i%MOD;\n\tfor(int i=2;i<=n*k;i++)\n\t\tinv[i]=inv[MOD%i]*(MOD-MOD/i)%MOD;\n\tfor(int i=1;i<=n*k;i++)\n\t\tinfac[i]=infac[i-1]%MOD*inv[i]%MOD;\n\tfor(int i=0;i<=n;i++)\n\t\tf[i][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=k&&j<=i;j++){\n//\t\t\tcout<<i<<\" \"<<j<<\"*\"<<\"%\"<<C(k-2,(n-i)+(n-j+1)*(k-1)-1)<<endl;\n\t\t\tf[i][j]=f[i-1][j]+C((n-i)+(n-j+1)*(k-1)-1,k-2)*f[i][j-1]*(n-j+1);\n//\t\t\tcout<<f[1][1]<<endl;\n\t\t}\n\t}\n\tcout<<f[n][n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Leftmost Ball\n// * frank_c1\n// * 2017 / 09 / 29\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nLL pow_mod(LL b, LL p, LL k) {\n\tLL ret = 1;\n\tfor (; p; p >>= 1) {\n\t\tif (p & 1) ret = ret * b % k;\n\t\tb = b * b % k;\n\t} return ret;\n}\n\nconst int maxn = 3005;\nconst int mo = (int)(1e9) + 7;\nLL fac[maxn * maxn], ivf[maxn * maxn];\nint f[maxn][maxn];\n\ninline LL C(int n, int m) {\n\tif (m < 0 || n - m < 0) return 0;\n\treturn (fac[n] * ivf[m] % mo) * ivf[n - m] % mo;\n}\n\ninline void add(int& x, int v) {\n\tx += v; if (x >= mo) x -= mo;\n}\n\nint main() {\n\tint n, K;\n\tscanf(\"%d%d\", &n, &K);\n\tif (K == 1) return printf(\"1\\n\"), 0;\n\tint mx = n * (K + 1);\n\tfac[0] = ivf[0] = 1;\n\tfor (int i = 1; i <= mx; ++i) fac[i] = fac[i - 1] * i % mo;\n\tivf[mx] = pow_mod(fac[mx], mo - 2, mo);\n\tfor (int i = mx - 1; i >= 1; --i) ivf[i] = ivf[i + 1] * (i + 1) % mo;\n\tf[0][0] = 1;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\tif (i < j) add(f[i + 1][j], f[i][j]);\n\t\t\tif (j < n) add(f[i][j + 1], 1LL * f[i][j] * C(i + (j + 1) * (K - 1) - 1, K - 2) % mo);\n\t\t}\n\t} \n\treturn printf(\"%lld\\n\", 1LL * f[n][n] * fac[n] % mo), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mo = 1000000007;\nconst int Maxn = 2005;\nvoid upd(int & x,int y)\n{\n\tx = (x + y) % mo;\n}\nint getinv(int x)\n{\n\tif(x == 1)\n\t\treturn 1;\n\treturn (ll)getinv(mo%x) * (mo - mo/x) % mo;\n}\nint fac[Maxn * Maxn];\nint invf[Maxn * Maxn];\nvoid Init(int n)\n{\n\tfac[0] = 1;\n\tfor(int i=1;i<=n;i++)\n\t\tfac[i] = (ll)fac[i-1] * i % mo;\n\tinvf[n] = getinv(fac[n]);\n\tfor(int i=n;i;i--)\n\t\tinvf[i-1] = (ll)invf[i] * i % mo;\n}\nint C(int n,int m)\n{\n\tif(m > n)\n\t\treturn 0;\n\treturn (ll)fac[n] * invf[m] % mo * invf[n-m] % mo;\n}\nint dp[Maxn][Maxn];\nint main()\n{\n\tint n,K;\n\tcin >> n >> K;\n\tif(K == 1) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tInit(n*K + 1);\n\n\tdp[0][0] = 1;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=i;j<=n;j++) {\n\t\t\tif(i != 0)\n\t\t\t\tupd(dp[i][j] , dp[i-1][j]);\n\t\t\tif(j != 0 && i != j) {\n\t\t\t\tint t1 = (j-1)*(K-1) + i;\n\t\t\t\tint t2 = K-2;\n\t\t\t\tupd(dp[i][j] , (ll)dp[i][j-1] * C(t1+t2 , t1) % mo);\n\t\t\t}\n\t\t}\n\tcout << (ll)dp[n][n] * fac[n] % mo << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=2007,P=1000000007;\nint n,m,k,fac[N*N],ifac[N*N],f[N][N];\nvoid inc(int&a,int b){a+=b-P,a+=a>>31&P;}\nvoid mul(int&a,int b){a=1ll*a*b%P;}\nint C(int n,int m){return 1ll*fac[n]*ifac[m]%P*ifac[n-m]%P;}\nint pow(int a,int b){int r=1;for(;b;b>>=1,mul(a,a))if(b&1)mul(r,a);return r;}\nint main()\n{\n    scanf(\"%d%d\",&n,&k),m=n*k,f[0][0]=1;\n    if(k==1) return puts(\"1\"),0;\n    fac[0]=1;for(int i=1;i<=m;++i)mul(fac[i]=fac[i-1],i);\n    ifac[m]=pow(fac[m],P-2);for(int i=m;i;--i)mul(ifac[i-1]=ifac[i],i);\n    for(int i=0,z=k-1;i<=n;++i,z+=k-1)\n\tfor(int j=0;j<=i;++j)\n\t    inc(f[i+1][j],1ll*f[i][j]*C(z+j-1,k-2)%P),inc(f[i][j+1],f[i][j]);\n    mul(f[n][n],fac[n]),printf(\"%d\",f[n][n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 4010;\nconst int mod = 1e9+7;\n\nint n, k;\nint dp[maxn][maxn], fac[2000*2000+10], ifac[2000*2000+10], inv[2000*2000+10];\n\nint binom(int x, int y) {\n\tif (y > x) return 0;\n\treturn 1LL * fac[x] * ifac[y] % mod * ifac[x-y] % mod;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tif (k == 1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0] = ifac[0] = 1; inv[1] = 1;\n\tfor (int i = 2; i <= n*k; i++) inv[i] = mod - 1LL * (mod / i) * inv[mod % i] % mod;\n\tfor (int i = 1; i <= n*k; i++) fac[i] = 1LL * fac[i-1] * i % mod, ifac[i] = 1LL * ifac[i-1] * inv[i] % mod;\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= 2*n; i++) {\n\t\tfor (int j = i&1; (i+j) <= 2*n; j+=2) {\n\t\t\t// j = ( - )\n\t\t\t// )\n\t\t\tif (j < n) {\n\t\t\t\tdp[i][j] = (dp[i][j] + dp[i-1][j+1]) % mod;\n\t\t\t}\n\t\t\t// (\n\t\t\tif (j > 0) {\n\t\t\t\tdp[i][j] = (dp[i][j] + 1LL * binom((k-2)*((j+i)/2)+i-1, k-2) * dp[i-1][j-1] % mod) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", int (1LL * dp[2 * n][0] * fac[n] % mod));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\n#define MOD 1000000007\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int MAXN = 2000 + 10;\nconst int MAXM = 4e06 + 10;\n\nint N, K;\n\nLL fact[MAXM]= {0}, invfact[MAXM]= {0};\nvoid init () {\n\tfact[0] = fact[1] = invfact[0] = invfact[1] = 1;\n\tfor (int i = 2; i <= N * K; i ++) {\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\tinvfact[i] = (MOD - MOD / i) * invfact[MOD % i] % MOD;\n\t}\n\tfor (int i = 1; i <= N * K; i ++)\n\t\tinvfact[i] = invfact[i - 1] * invfact[i] % MOD;\n}\nLL C (int n, int m) {\n\tif (m == 0) return 1;\n\treturn fact[n] * invfact[m] % MOD * invfact[n - m] % MOD;\n}\n\nLL f[MAXN][MAXN]= {0};\n\nint main () {\n\tscanf (\"%d%d\", & N, & K);\n\tif (K == 1) {\n\t\tputs (\"1\");\n\t\treturn 0;\n\t}\n\tinit ();\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= N; i ++)\n\t\tfor (int j = 0; j <= i; j ++) {\n\t\t\tLL delta = f[i][j - 1] * (N - j + 1) % MOD * C (N * K - i - (K - 1) * (j - 1) - 1, K - 2) % MOD;\n\t\t\tif (j == 0) delta = 0;\n\t\t\tf[i][j] = (f[i][j] + f[i - 1][j] + delta) % MOD;\n\t\t}\n\tcout << f[N][N] << endl;\n\n\treturn 0;\n}\n\n/*\n2 2\n*/\n\n/*\n3 1\n*/\n\n/*\n2 3\n*/\n\n/*\n2000 2000\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll MAX_N = 3000 + 10, MOD = 1e9 + 7;\nll n, k, dp[MAX_N][MAX_N], fac[MAX_N * MAX_N], en[MAX_N * MAX_N], r,pwmakh, makh = 1;\nll pw(int x,int y){\n\tif(!y) return 1ll;\n\tll t = pw(x, y / 2);\n\tt = 1ll * t * t % MOD;\n\tif(y & 1) t = 1ll * t * x % MOD;\n\treturn t;\n}\nint32_t main(){\n    cin>>n>>k;\n    if(k == 1){\n        cout<<1;\n    }\n    else{\n        fac[0] = 1;\n        for(int i = 1; i <= n * k; i++){\n            fac[i] = fac[i - 1] * i;\n            fac[i] %= MOD;\n        }\n        for(int i = 1; i <= k - 2; i++){\n            makh *= i;\n            makh %= MOD;\n        }\n        pwmakh = pw(makh, MOD - 2);\n        for(int i = 0; i <= n; i++){\n            for(int j = 0; j <= n; j++){\n                if(j > 0){\n                    if(en[i * k + j * (k - 1) - 1] == 0){\n                        r = fac[i * k + j * (k - 1) - 1] * pwmakh % MOD * pw(fac[i * k + j * (k - 1) - 1 - (k - 2)], MOD - 2) % MOD;\n                        en[i * k + j * (k - 1) - 1] = r;\n                    }\n                    else{\n                        r = en[i * k + j * (k - 1) - 1];\n                    }\n                }\n                if(i > 0 && j > 0){\n                    dp[i][j] = dp[i - 1][j + 1] + (dp[i][j - 1] * r) % MOD;\n                }\n                else if(i == 0 && j > 0){\n                    dp[i][j] = dp[i][j - 1] * r;\n                }\n                else if(i > 0 && j == 0){\n                    dp[i][j] = dp[i - 1][j + 1];\n                }\n                else{\n                    dp[i][j] = 1;\n                }\n                dp[i][j] %= MOD;\n            }\n        }\n        /*for(int i = 0; i <= n; i++){\n            for(int j = 0; j <= n; j++){\n                cout<<dp[i][j]<<\"  \";\n            }\n            cout<<endl;\n        }*/\n        ll ans = 1ll * dp[n][0] * fac[n] % MOD;\n        cout<<ans;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n// #include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\n// #include <bitset>\nconst int oo=2139063143;\nconst int N=2010;\nconst int P=1000000007;\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\n#define pritnf printf\n//char buf[1<<22],*p1=buf,*p2=buf,obuf[1<<22],*O=obuf;\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ntemplate <typename T>\ninline void sc (T &x)\n{\n    x=0; static int p; p=1; static char c; c=getchar();\n    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }\n    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }\n    x*=p;\n}\ntemplate <typename T>\ninline void print (T x)\n{\n\tif (x< 0) putchar('-'),x=-x;\n\tif (x>=10) print(x/10);\n\tputchar(x%10+'0');\n}\ntemplate <typename T>\ninline void pr (T x) { print(x),putchar('\\n'); }\nint del(int x) { return x>=P?x-P:x; }\nvoid add(int &x,int y) { x=del(x+y); }\nint ksm (int a,int b)\n{\n\tint ans=1;\n\twhile (b)\n\t{\n\t\tif (b&1) ans=(LL)ans*a%P;\n\t\ta=(LL)a*a%P,b>>=1;\n\t}\n\treturn ans;\n}\nint jc[N*N],inv[N*N];\nvoid init (int n)\n{\n\tjc[0]=1;\n\tfor (int i=1; i<=n; i++)\n\t\tjc[i]=(LL)i*jc[i-1]%P;\n\tinv[n]=ksm (jc[n],P-2);\n\tfor (int i=n-1; i>=0; i--)\n\t\tinv[i]=(LL)(i+1)*inv[i+1]%P;\n}\nint C(int n,int m) { return n< m?0:(LL)jc[n]*inv[m]%P*inv[n-m]%P; }\nint f[N][N];\nint main ()\n{\n\t// freopen (\".in\",\"r\",stdin);\n\t// freopen (\".out\",\"w\",stdout);\n\tint n,k; sc(n),sc(k);\n\tif (k==1||n==1) return pr(1),0;\n\tinit (n*k);\n\tf[0][0]=1;\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=0; j<=i; j++)\n\t\t{\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif (j) add(f[i][j],(LL)f[i][j-1]*(n-j+1)%P*C(n*k-i-(k-1)*(j-1)-1,k-2)%P);\n\t\t}\n\tpr(f[n][n]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 2010, mod = 1e9 + 7;\n\nint f[maxn][maxn], n, K;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> K;\n  if( K == 1) {\n    return cout << \"1\\n\", 0;\n  }\n  vector<int> fac(maxn*maxn), ifac(maxn*maxn);\n  for ( int i = fac[0] = 1; i < fac.size(); ++ i) {\n    fac[i] = 1LL * fac[i-1] * i % mod;\n  }\n  function<int(int, int)> _pow = [&](int x, int n) {\n    int ret = 1;\n    for ( ; n; n >>= 1, x = 1LL * x * x % mod) {\n      if( n & 1) {\n        ret = 1LL * ret * x % mod;\n      }\n    }\n    return ret;\n  };\n  ifac[fac.size()-1] = _pow(fac[fac.size()-1], mod - 2);\n  for ( int i = fac.size()-1; i; -- i) {\n    ifac[i-1] = 1LL * ifac[i] * i % mod;\n  }\n  function<int(int, int)> C = [&](int n, int m) {\n    return 1LL * fac[n] * ifac[m] % mod * ifac[n-m] % mod;\n  };\n  f[0][0] = 1;\n  for ( int i = 1; i <= n; ++ i) {\n    for ( int k = 0; k <= i; ++ k) {\n      f[i][k] = f[i-1][k];\n      if( k) {\n        f[i][k] = (f[i][k] + 1LL * f[i][k-1] * (n - k + 1) % mod * C(n-i+(K-1)*(n-k+1)-1, K-2) % mod) % mod;\n      }\n    }\n  }\n  cout << f[n][n] << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nll read(){\n\tchar c=getchar();bool flag=0;ll x=0;\n\twhile(c<'0'||c>'9'){if(c=='-')flag=1;c=getchar();}\n\twhile(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}\n\treturn flag?-x:x;\n}\n#define N 2010 \nconst ll p=1e9+7;\nll dp[N][N],fac[N*N],inv[N*N];\nll fpow(ll a,ll x){\n\tll ans=1;\n\twhile(x){\n\t\tif(x&1) ans=ans*a%p;\n\t\ta=a*a%p,x=x/2; \n\t}\n\treturn ans;\n}\nll Cnt(ll n,ll m){\n\treturn fac[m]*inv[n]%p*inv[m-n]%p;\n}\nint main(){\n\tll n=read(),k=read();\n\tif(k==1){\n\t\tprintf(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\tfor(ll i=1;i<=n*k;i++) fac[i]=fac[i-1]*i%p;\n\tinv[n*k]=fpow(fac[n*k],p-2);\n\tfor(ll i=n*k-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%p;\n\tfor(ll i=1;i<=n;i++) dp[i][0]=1;\n\tfor(ll i=1;i<=n;i++){\n\t\tfor(ll j=1;j<=i;j++){\n\t\t\tdp[i][j]=dp[i-1][j]+dp[i][j-1]*(n-(j-1))*Cnt(k-2,n*k-i-(j-1)*(k-1)-1);\n\t\t}\n\t}\n\tprintf(\"%lld\",dp[n][n]); \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define MAXN 2000\n#define MO 1000000007\nusing namespace std;\nint dp[MAXN+5][MAXN+5];\nint fact[MAXN*MAXN+5],inv[MAXN*MAXN+5];\nint PowMod(int a,int b)\n{\n\tint ret=1;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t\tret=1LL*ret*a%MO;\n\t\ta=1LL*a*a%MO;\n\t\tb>>=1;\n\t}\n\treturn ret;\n}\nvoid prepare()\n{\n\tfact[0]=1;\n\tfor(int i=1;i<=MAXN*MAXN;i++)\n\t\tfact[i]=1LL*fact[i-1]*i%MO;\n\tinv[MAXN*MAXN]=PowMod(fact[MAXN*MAXN],MO-2);\n\tfor(int i=MAXN*MAXN-1;i>=0;i--)\n\t\tinv[i]=1LL*inv[i+1]*(1LL*i+1LL)%MO;\n}\nint C(int n,int m)\n{\n\tif(n<m)\n\t\treturn 0;\n\treturn 1LL*fact[n]*inv[m]%MO*inv[n-m]%MO;\n}\nint main()\n{\n//\tfreopen(\"ball.in\",\"r\",stdin);\n//\tfreopen(\"ball.out\",\"w\",stdout);\n\tint N,K;\n\tscanf(\"%d %d\",&N,&K);\n\tif(K==1)\n\t{\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tdp[0][0]=1;\n\tprepare();\n\tfor(int i=0;i<=N;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tif(i-1>=0)\n\t\t\t\tdp[i][j]=(1LL*dp[i][j]+1LL*dp[i-1][j])%MO;\n\t\t\tif(j-1>=0)\n\t\t\tdp[i][j]=(1LL*dp[i][j]+1LL*dp[i][j-1]*C(N*K-(K-1)*(j-1)-i-1,K-2)%MO)%MO;\n\t\t}\n\tint ans=1LL*dp[N][N]*fact[N]%MO;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2020, M = N * N, MOD = 1000 * 1000 * 1000 + 7;\n\nint sum(int a, int b) {\n\ta += b;\n\tif(a < 0)\n\t\ta += MOD;\n\telse if(a >= MOD)\n\t\ta -= MOD;\n\treturn a;\n}\n\nvoid _sum(int &a, int b) {\n\ta = sum(a, b);\n}\n\nint mul(int a, int b) {\n\treturn 1LL * a * b % MOD;\n}\n\nvoid _mul(int &a, int b) {\n\ta = mul(a, b);\n}\n\nint power(int a, int b) {\n\tint res = 1;\n\twhile(b) {\n\t\tif(b & 1)\n\t\t\tres = mul(res, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint n, k, dp[N], fac[M], pow_fac[M];\n\nint f(int a) {\n\treturn power(a, MOD - 2);\n}\n\nint choose(int a, int b) {\n\treturn (a > b? 0: mul(fac[b], mul(pow_fac[a], pow_fac[b - a])));\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tfac[0] = 1;\n\tfor (int i = 1; i < M; i++)\n\t\tfac[i] = mul(fac[i - 1], i);\n\tfor (int i = 0; i < M; i++)\n\t\tpow_fac[i] = f(fac[i]);\n\tcin >> n >> k;\n\tif(k == 1) {\n\t\tcout << 1;\n\t\treturn 0;\n\t}\n\tdp[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tint val = choose(j, i);\n\t\t\t_mul(val, choose(j * k - j, i * k - j));\n\t\t\t_mul(val, mul(fac[j * (k - 1)], f(power(fac[k - 1], j))));\n\t\t\t_mul(val, dp[i - j]);\n\t\t\tdp[i] = sum(dp[i], (j & 1? 1: -1) * val);\n\t\t}\n\t}\n\tcout << dp[n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int p=1e9+7,N=4010,M=4e6+5;\nint dp[N][N],fac[M],finv[M],inv[M];\nint comb(int n,int m){return n<m?0:fac[n]*1ll*finv[m]%p*finv[n-m]%p;}\nint main()\n{\n    int n=4e6,k;\n    fac[1]=fac[0]=finv[1]=finv[0]=inv[1]=1;\n    for(int i=2;i<=n;i++)\n        inv[i]=(p-p/i)*1ll*inv[p%i]%p,fac[i]=1ll*fac[i-1]*i%p,\n        finv[i]=finv[i-1]*1ll*inv[i]%p;\n    cin>>n>>k;\n    dp[1][0]=1;\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=0;j<=i;j++)\n        {\n            if(i==1&&j==0)continue;\n            dp[i][j]=((j!=i)*dp[i-1][j]+\n                     (j!=0)*1ll*comb(n-i+(n-j+1)*(k-1)-1,k-2)*dp[i][j-1])%p;\n        }\n    }\n    printf(\"%lld\\n\",1ll*dp[n][n]*fac[n]%p);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int md=1000000007;\nint f[2010][2010],fac[4000010],inv[4000010],rev[4000010];\nint c(int n,int m){return 1ll*fac[n]*rev[m]%md*rev[n-m]%md;}\nint main()\n{\n    int n,k;\n    cin>>n>>k;\n    if(k==1){puts(\"1\");return 0;}\n    f[0][0]=1;\n    fac[0]=fac[1]=1,inv[1]=1,rev[0]=rev[1]=1;\n    for(int i=2;i<=n*k;i++)\n\t{\n\t\tfac[i]=1ll*fac[i-1]*i%md;\n\t\tinv[i]=1ll*(md-md/i)*inv[md%i]%md;\n\t\trev[i]=1ll*rev[i-1]*inv[i]%md;\n\t}\n\tfor(int i=1;i<=n;i++)for(int j=i;j>=0;j--)\n\t{\n\t    f[i][j]=f[i][j+1];\n\t    if(j)f[i][j]=(f[i][j]+1LL*f[i-1][j-1]*c(i*k-j-1,k-2)%md)%md;\n\t}\n    cout<<1LL*f[n][0]*fac[n]%md<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm> \n#include<cstring>\n#define LL long long\nusing namespace std;\nconst int N=2e3+5;\nconst int mod=1e9+7;\nint n,m,fac[N*N],inv[N*N],f[N][N];\nint read()\n{\n    int x=0,f=1;char c=getchar();\n    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}\n    return x*f;\n}\nvoid Mod(int& a,int b){a+=b;if(a>=mod)a-=mod;}\nint power(int a,int b)\n{\n    int ans=1;\n    while(b)\n    {\n        if(b&1)ans=1ll*ans*a%mod;\n        a=1ll*a*a%mod;b>>=1;\n    }\n    return ans;\n}\nint C(int n,int m){return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint main()\n{\n    n=read();m=read();\n    if(m==1){printf(\"1\");return 0;}\n    fac[0]=1;\n    for(int i=1;i<=n*m;i++)fac[i]=1ll*fac[i-1]*i%mod;\n    inv[n*m]=power(fac[n*m],mod-2);\n    for(int i=n*m;i>=1;i--)inv[i-1]=1ll*inv[i]*i%mod;\n    f[0][0]=1;\n    for(int i=1;i<=n;i++)\n        for(int j=0;j<=i;j++)\n        {\n            f[i][j]=f[i-1][j];\n            if(!j)continue;\n            Mod(f[i][j],1ll*f[i][j-1]*C(n-i+(n-j+1)*(m-1)-1,m-2)%mod);\n        }\n    printf(\"%d\",1ll*f[n][n]*fac[n]%mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 2002\n#define MOD 1000000007\n\nlong long int dp[MAX][MAX];\n\n#define MOD 1000000007\nclass Combination{\n\tlong long int ppow(long long int i, long long int j){\n\t\tlong long int res = 1LL;\n\t\twhile (j){\n\t\t\tif ((j & 1LL)){\n\t\t\t\tres *= i;\n\t\t\t\tif (res >= MOD){\n\t\t\t\t\tres %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj >>= 1;\n\t\t\ti *= i;\n\t\t\tif (i >= MOD){\n\t\t\t\ti %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\npublic:\n\tvector<long long int> k;\n\tvector<long long int> r;\n\tvoid resize(int N){\n\t\tk.resize(N + 2);\n\t\tr.resize(N + 2);\n\t\tk[0] = 1;\n\t\tfor (int i = 1; i < k.size(); i++){\n\t\t\tk[i] = k[i - 1];\n\t\t\tk[i] *= i;\n\t\t\tif (k[i] >= MOD)k[i] %= MOD;\n\t\t}\n\t\tfor (int i = 0; i < r.size(); i++){\n\t\t\tr[i] = ppow(k[i], MOD - 2);\n\t\t}\n\t}\n\tlong long int C(int a, int b){\n\t\tif (a < b)return 0;\n\t\twhile (k.size() <= a){\n\t\t\tk.push_back((k.back()*(long long int)(k.size())) % MOD);\n\t\t}\n\t\tlong long int up = k[a];\n\t\tlong long int dw = r[b] * r[a - b];\n\t\tdw %= MOD;\n\t\tup *= dw;\n\t\tup %= MOD;\n\t\treturn up;\n\t}\n\tlong long int H(int a, int b){\n\t\treturn C(a + b - 1, b);\n\t}\n\tlong long int catalan_number(int n){\n\t\treturn (C(2 * n, n) + MOD - C(2 * n, n - 1)) % MOD;\n\t}\n};\n\n\nCombination C;\nint main(){\n\tint n;\n\tint k;\n\tcin >> n >> k;\n\tC.resize(2002);\n\tdp[0][0] = 1;\n\tif (k == 1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i <= n; i++){\n\t\tfor (int j = 0; j <= n; j++){\n\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\tif (dp[i + 1][j] >= MOD){\n\t\t\t\tdp[i + 1][j] %= MOD;\n\t\t\t}\n\t\t\tif (j + 1 <= i){\n\t\t\t\tdp[i][j + 1] += dp[i][j] * C.C(n*k-((k-2)*j+j+i+1), k-2);\n\t\t\t\tif (dp[i][j + 1] >= MOD){\n\t\t\t\t\tdp[i][j + 1] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long int ans = dp[n][n]*C.k[n];\n\tif (ans >= MOD)ans %= MOD;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=getchar();\n    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\nconst int maxn=2010;\nconst int maxm=4000010;\nconst int mod=1000000007;\nint fac[maxm],ifac[maxm];\nint C(int a,int b) {if(a<b) return 0;return (ll)fac[a]*ifac[b]%mod*ifac[a-b]%mod;}\nvoid init(int n) {\n\tifac[0]=fac[0]=ifac[1]=1;\n\trep(i,2,n) ifac[i]=(ll)(mod-mod/i)*ifac[mod%i]%mod;\n\trep(i,1,n) fac[i]=(ll)fac[i-1]*i%mod,ifac[i]=(ll)ifac[i-1]*ifac[i]%mod;\n}\nint f[maxn*2][maxn];\nint main() {\n\tint n=read(),k=read();init(n*k);\n\tif(k==1) {puts(\"1\");return 0;}\n\tf[2*n+1][0]=1;\n\tdwn(i,2*n+1,2) rep(j,0,2*n-i+1) {\n\t\tint& ans=f[i][j];if(!ans) continue;\n\t\tint a=(2*n-i+1+j)/2,b=(2*n-i+1-j)/2;\n\t\tif(j) (f[i-1][j-1]+=ans)%=mod;\n\t\tif(a<n) (f[i-1][j+1]+=(ll)ans*C((k-1)*(a+1)+b-1,k-2)%mod*(n-a)%mod)%=mod;\n\t}\n\tprintf(\"%d\\n\",f[1][0]);\n\treturn 0;\n}\n/*\na + b = n-i+1\na - b = j\n\na = (n-i+1+j)/2\nb = (n-i+1-j)/2\n\n(k-1)*a + b + (k-2)\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lson (o<<1)\n#define rson (o<<1|1)\n#define fi first\n#define sc second\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\nconst int N=2010;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nusing namespace std;\nconst double pi=acos(-1);\nconst double eps=1e-6;\ninline int lowbit(int x){return x&(-x);}\ninline int read(){\n\tint f=1,x=0;char ch;\n\tdo{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');\n\tdo{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');\n\treturn f*x;\n}\ntemplate<typename T> inline T max(T x,T y,T z){return max(max(x,y),z);}\ntemplate<typename T> inline T min(T x,T y,T z){return min(min(x,y),z);}\ntemplate<typename T> inline T sqr(T x){return x*x;}\ntemplate<typename T> inline void checkmax(T &x,T y){x=max(x,y);}\ntemplate<typename T> inline void checkmin(T &x,T y){x=min(x,y);}\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');\ndo x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\ntemplate<typename A,typename B> inline A fpow(A x,B p,A yql){\n\tA ans=1;\n\tfor(;p;p>>=1,x=1LL*x*x%yql)if(p&1)ans=1LL*x*ans%yql;\n\treturn ans;\n}\nstruct FastIO{\n\tstatic const int S=1310720;\n\tint wpos;char wbuf[S];\n\tFastIO():wpos(0) {}\n\tinline int xchar(){\n\t\tstatic char buf[S];\n\t\tstatic int len=0,pos=0;\n\t\tif(pos==len)pos=0,len=fread(buf,1,S,stdin);\n\t\tif(pos==len)return -1;\n\t\treturn buf[pos++];\n\t}\n\tinline int read(){\n\t\tint c=xchar(),x=0;\n\t\twhile(c<=32&&~c)c=xchar();\n\t\tif(c==-1)return -1;\n\t\tfor(;'0'<=c&&c<='9';c=xchar())x=x*10+c-'0';\n\t\treturn x;\n\t}\n}io;\nconst int yql=1e9+7;\n//#define read io.read\nint dp[N][N],fac[N*N],inv[N*N],n,k;\ninline int C(int n,int m){\n\tif(n<m||n<0)return 0;\n\treturn 1LL*fac[n]*inv[m]%yql*inv[n-m]%yql;\n}\nint main(){\n\tn=read();k=read();\n\tif(k==1)return puts(\"1\"),0;\n\tfac[0]=1;\n\tfor(int i=1;i<=n*k;i++)fac[i]=1LL*fac[i-1]*i%yql;\n\tinv[n*k]=fpow(fac[n*k],yql-2,yql);\n\tfor(int i=n*k-1;~i;i--)inv[i]=1LL*inv[i+1]*(i+1)%yql;\n\tdp[0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\tfor(int j=n;~j;j--){\n\t\tif(!dp[i][j])continue;\n\t\tif(j)dp[i][j-1]=(dp[i][j-1]+dp[i][j])%yql;\n\t\tif(i<n)dp[i+1][j+1]=(dp[i+1][j+1]+1LL*dp[i][j]*C((i+1)*k-j-2,k-2)%yql)%yql;\n\t}\n\tint ans=1LL*fac[n]*dp[n][0]%yql;\n\tans=(ans+yql)%yql;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int mod = 1e9 + 7;\nconst int MAXN = 2005, MAXS = MAXN * MAXN;\n\ntemplate<typename _T>\nvoid read( _T &x )\n{\n\tx = 0;char s = getchar();int f = 1;\n\twhile( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}\n\twhile( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}\n\tx *= f;\n}\n\ntemplate<typename _T>\nvoid write( _T x )\n{\n\tif( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }\n\tif( 9 < x ){ write( x / 10 ); }\n\tputchar( x % 10 + '0' );\n}\n\nint f[MAXN][MAXN];\nint fac[MAXS], ifac[MAXS];\nint N, K;\n\nint qkpow( int, int );\nint inv( const int a ) { return qkpow( a, mod - 2 ); }\nvoid sub( int &x, const int v ) { x = ( x < v ? x - v + mod : x - v ); }\nvoid add( int &x, const int v ) { x = ( x + v >= mod ? x + v - mod : x + v ); }\n\nint qkpow( int base, int indx )\n{\n\tint ret = 1;\n\twhile( indx )\n\t{\n\t\tif( indx & 1 ) ret = 1ll * ret * base % mod;\n\t\tbase = 1ll * base * base % mod, indx >>= 1;\n\t}\n\treturn ret;\n}\n\nvoid init( const int siz )\n{\n\tfac[0] = ifac[0] = 1;\n\tfor( int i = 1 ; i <= siz ; i ++ ) fac[i] = 1ll * fac[i - 1] * i % mod;\n\tifac[siz] = inv( fac[siz] );\n\tfor( int i = siz - 1 ; ~ i ; i -- ) ifac[i] = 1ll * ifac[i + 1] * ( i + 1 ) % mod;\n}\n\nint C( const int n, const int m ) { return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod; }\n\nint main()\n{\n\tread( N ), read( K );\n\tif( K == 1 ) return puts( \"1\" ), 0;\n\tinit( N * K );\n\tfor( int i = 0 ; i <= K ; i ++ ) f[i][0] = 1;\n\tfor( int i = 1 ; i <= K ; i ++ )\n\t\tfor( int j = 1 ; j <= i ; j ++ )\n\t\t{\n\t\t\tf[i][j] = f[i - 1][j];\n\t\t\tint t = N * K - i - ( K - 1 ) * ( j - 1 ) - 1;\n\t\t\tadd( f[i][j], 1ll * f[i][j - 1] * ( N - j + 1 ) % mod * C( t, K - 2 ) % mod );\n\t\t}\n\twrite( f[N][N] ), putchar( '\\n' );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\ntypedef long long LL;\nconst int MOD=1e9+7;\nconst int N=2003;\n\nint n,k,all;\nint f[N][N];\nint fac[N*N];\nint ifac[N*N];\n\ninline int Pow(int x,int p) {\n\tint y=1;\n\tfor(;p;p>>=1,x=1ll*x*x%MOD)\n\t\tif(p&1) y=1ll*y*x%MOD;\n\treturn y;\n}\ninline LL C(int x,int y) {\n\treturn 1ll*fac[x]*ifac[y]%MOD*ifac[x-y]%MOD;\n}\nint main() {\n\tscanf(\"%d %d\",&n,&k);\n\tif(k==1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tall=n*k;\n\tfac[0]=ifac[0]=1;\n\tfor(int i=1;i<=all;i++)\n\t\tfac[i]=1ll*i*fac[i-1]%MOD;\n\tifac[all]=Pow(fac[all],MOD-2);\n\tfor(int i=all-1;i>=1;i--)\n\t\tifac[i]=(i+1ll)*ifac[i+1]%MOD;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++) {\n\t\tf[i][0]=f[i-1][0];\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tf[i][j]=(f[i-1][j]+1ll*f[i][j-1]*C(n*k-i-(j-1)*(k-1)-1,k-2))%MOD;\n\t}\n\tprintf(\"%lld\\n\",1ll*f[n][n]*fac[n]%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=2005, P=1000000007;\nint f[N][N], fac[N*N], ifac[N*N];\n\nint C(int n, int m){return fac[n]*ifac[m]%P*ifac[n-m]%P;}\nint Pow(int x, int t)\n{\n\tint res=1;\n\twhile (t) {if (t&1) res=res*x%P; x=x*x%P; t>>=1;}\n\treturn res;\n}\n\nsigned main()\n{\n\tint n, k; scanf(\"%d%d\", &n, &k);\n\tif (k==1) {puts(\"1\"); return 0;}\n\tf[0][0]=fac[0]=1; \n\tfor (int i=1; i<=4e6; i++) fac[i]=fac[i-1]*i%P; \n\tifac[(int)4e6]=Pow(fac[(int)4e6], P-2);\n\tfor (int i=4e6-1; ~i; i--) ifac[i]=ifac[i+1]*(i+1)%P;\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=0; j<=i; j++)\n\t\t\tf[i][j]=f[i-1][j]+(j!=0)*\n\t\t\t\t(f[i][j-1]*(n-j+1)%P*C(n*k-i-(j-1)*(k-1)-1, k-2)%P)%P;\n\tprintf(\"%d\\n\", f[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 0x7fffffff\n#define RG register\n#define inf 0x7fffffff\n#define mkp make_pair\n#define maxn 100205\ntypedef unsigned int U;\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1e9+7;\nconst  double eps = 1e-8;\nconst double pi = acos(-1);\ninline ll read(){\n    ll x = 0, f = 1;\n    char ch = getchar();\n    while(ch > '9' || ch < '0') {if(ch == '-') f = -1;ch = getchar();}\n    while(ch >= '0' && ch <= '9'){x = x *10 + ch -'0';ch = getchar();}\n    return x * f;\n}\nint n,k;\nint fac[4000005],inv[4000005];\nint f[2005][2005];\nint qpow(int a,int b){\n\tint ans=1,base=a;\n\twhile(b){\n\t\tif(b&1) ans=1ll*ans*base%mod;\n\t\tbase=1ll*base*base%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint C(int n,int m){return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint main(){\n\tint i,j,u,v,e,w;\n\t//freopen(\"a.out\",\"r\",stdin);\n\t//freopen(\"a.ans\",\"w\",stdout);n\n\tn=read(),k=read();\n\tif(k==1) {puts(\"1\");return 0;}\n\tfac[0]=1;\n\tfor(i=1;i<=n*k;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[n*k]=qpow(fac[n*k],mod-2);\n\tfor(i=n*k-1;i>=0;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tf[0][0]=1;\n\tfor(i=0;i<=n;i++){\n\t\tfor(j=i;j<=n;j++){\n\t\t\tif(i+1<=j) f[i+1][j]=(f[i+1][j]+f[i][j])%mod;\n\t\t\tif(j+1<=n) f[i][j+1]=(f[i][j+1]+1ll*f[i][j]*C(i+(k-1)*j+k-2,k-2)%mod)%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",1ll*f[n][n]*fac[n]%mod);\n\treturn 0;\n}\n/*\n8\n0 0 0 0\n0 0 1 1\n0 1 0 1\n0 1 1 0\n1 0 0 1\n1 0 1 0\n1 1 0 0\n1 1 1 1\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nconst int N=4000010,Mo=1000000007;\nint f[2010][2010],fac[N],inv[N],rev[N];\ninline int C(int n,int m) {\n    return 1LL*fac[n]*rev[m]%Mo*rev[n-m]%Mo;\n}\nint main() {\n    int n,k;\n    cin>>n>>k;\n    if(k==1) {puts(\"1\");return 0;}\n    f[0][0]=1;\n    fac[0]=fac[1]=1,inv[1]=1,rev[0]=rev[1]=1;\n    for(int i=2;i<=n*k;i++) {\n\tfac[i]=1LL*fac[i-1]*i%Mo;\n\tinv[i]=1LL*(Mo-Mo/i)*inv[Mo%i]%Mo;\n\trev[i]=1LL*rev[i-1]*inv[i]%Mo;\n    }\n    for(int i=1;i<=n;i++)\n\tfor(int j=i;j>=0;j--) {\n\t    f[i][j]=f[i][j+1];\n\t    if(j) (f[i][j]+=1LL*f[i-1][j-1]*C(i*k-j-1,k-2)%Mo)%=Mo;\n\t}\n    cout<<1LL*f[n][0]*fac[n]%Mo;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=2005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,k,dp[2][N],fac[N*N],ifac[N*N];\n\ninline int c(int x,int y){\n\treturn (ll)fac[x+y]*ifac[x]%mod*ifac[y]%mod;\n}\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tread(n,k);fac[0]=1;\n\tif(k==1){puts(\"1\");return 0;}\n\tfor(int i=1;i<=n*k;i++) fac[i]=(ll)fac[i-1]*i%mod;\n\tifac[n*k]=exp(fac[n*k],mod-2);\n\tfor(int i=n*k;i;i--) ifac[i-1]=(ll)ifac[i]*i%mod;\n\t\n\tdp[0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(i>j){dp[i&1][j]=0;continue;}\n\t\t\tdp[i&1][j]=((ll)dp[i&1][j-1]*c(i+(j-1)*(k-1),k-2)+dp[i-1&1][j])%mod;\n\t\t}\n\tprintf(\"%lld\\n\",(ll)dp[n&1][n]*fac[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define gc getchar\n#define pc putchar\ninline ll rd(){\n    ll x=0,f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid writeln(ll x){write(x);puts(\"\");}\nconst int mod = 1e9+7;\nconst int maxn = 2005;\nint dp[maxn][maxn],fac[maxn*maxn],inv[maxn*maxn],n,k;\ninline int C(int n,int m){\n\treturn 1ll * fac[n] * inv[m] % mod * inv[n-m] % mod;\n}\ninline int qpow(int a,int b){\n\tint ans = 1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1)ans=1ll*ans*a%mod;\n\treturn ans; \n}\nint main(){\n\tn = rd(),k = rd();\n\tfac[0] = 1;\n\tRep(i,1,2000*2000) fac[i] = 1ll * fac[i-1] * i % mod;\n\tinv[2000*2000] = qpow(fac[2000*2000],mod-2);\n\tDep(i,2000*2000-1,0) inv[i] = 1ll * inv[i+1] * (i+1) % mod;\n\tdp[0][1] = 1;\n\tRep(i,2,n){\n\t\tdp[0][i] = 1ll * dp[0][i-1] * C((i-1)*(k-1) + k-2,k-2) % mod;\n\t\t//n插入m \n\t}\n\tRep(i,1,n){\n\t\tRep(j,i,n){\n\t\t\tdp[i][j] = (dp[i-1][j] +\n\t\t\t1ll * dp[i][j-1] * C(i+(j-1)*(k-1)+k-2,k-2) % mod) % mod;\n\t\t}\n\t}\n\twriteln(1ll * dp[n][n] * fac[n] % mod);\n\treturn 0;\n}\n//n+1个空 \n//a1 + a2 + a3 …… an + a[n+1] = m\n//(a1+1) + (a2+1) + (a3+1) + …… = m + n + 1"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(long long)((n)-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n#define inc(x,y) {x+=(y);if(x>=mod)x-=mod;}\n#define dec(x,y) {x-=(y);if(x<0)x+=mod;}\nusing namespace std;\nint n,k,i,j,dp[2005][2005],mod=1e9+7,fac[4000005],inv[4000005],fi[4000005];\nint c(int x,int y)\n{\n\treturn 1ll*fac[x]*fi[y]%mod*fi[x-y]%mod;\n}\nint main()\n{\n\tfac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;\n\tfz(i,2,4000000){\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\t\tinv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\t\tfi[i]=1ll*fi[i-1]*inv[i]%mod;\n\t}\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tdp[0][0]=1;\n\tfz1(i,n)fz0g(j,i){\n\t\tdp[i][j]=0;\n\t\tinc(dp[i][j],dp[i-1][j])\n\t\tif(j)inc(dp[i][j],1ll*dp[i][j-1]*(n-j+1)%mod*c(n-i+(n-j+1)*(k-1)-1,k-2)%mod)\n\t}\n\tcout<<dp[n][n]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint power(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\n\nint n, k;\n\nint read() {\n  if (scanf(\"%d%d\", &n, &k) < 2) {\n    return 0;\n  }\n  return 1;\n}\n\nconst int maxn = (int) 2e3 + 10;\nconst int maxv = maxn * maxn;\nint inv[maxv];\nint cs[maxv];\n\nint dp[maxn][maxn];\n\nvoid solve() {\n  if (k == 1) {\n    printf(\"1\\n\");\n    return;\n  }\n  inv[1] = 1;\n  for (int i = 2; i <= n * k; ++i) {\n    inv[i] = mult(mod - mod / i, inv[mod % i]);\n  }\n\n  for (int i = 0; i < k - 2; ++i) {\n    cs[i] = 0;\n  }\n  cs[k - 2] = 1;\n  for (int i = k - 1; i <= n * k; ++i) {\n    cs[i] = mult(mult(cs[i - 1], i), inv[i - k + 2]);\n  }\n\n  for (int left = 0; left <= n; ++left) {\n    for (int t = 0; t + left <= n; ++t) {\n      int &cur = dp[left][t];\n      cur = 0;\n      if (!left && !t) {\n        cur = 1;\n        continue;\n      }\n\n      if (t) {\n        add(cur, mult(dp[left][t - 1], cs[(left + t) * k - t - 1]));\n      }\n\n      if (left) {\n        add(cur, dp[left - 1][t + 1]);\n      }\n      //eprintf(\"dp[left=%d][t=%d] = %d\\n\", left, t, cur);\n    }\n  }\n  int res = dp[n][0];\n  for (int i = 1; i <= n; ++i) {\n    res = mult(res, i);\n  }\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=2003;\nconst int mod=1e9+7;\nint n,K;\nint f[maxn][maxn];\nint Fac[maxn*maxn],Inv[maxn*maxn];\ninline int Pow(int a,int n){\n\tint ans=1;\n\tfor(;n;n>>=1,a=a*1ll*a%mod)if(n&1)ans=ans*1ll*a%mod;\n\treturn ans;\n}\ninline int C(int n,int m){\n\tif(n<m||m<0)return 0;\n\treturn Fac[n]*1ll*Inv[m]%mod*Inv[n-m]%mod;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&K);\n\tif(K==1)return puts(\"1\"),0;\n\tFac[0]=1;\n\tfor(int i=1;i<=n*K;i++)Fac[i]=Fac[i-1]*1ll*i%mod;\n\tInv[n*K]=Pow(Fac[n*K],mod-2);\n\tfor(int i=n*K-1;i>=0;i--)Inv[i]=Inv[i+1]*(i+1ll)%mod;\n\tf[0][0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\t(f[i+1][j]+=f[i][j])%=mod;\n\t\t\tf[i][j+1]=(f[i][j+1]+f[i][j]*1ll*C(n*K-(i+j*(K-1))-1,K-2))%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[n][n]*1ll*Fac[n]%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long llint;\n\nconst int MAXN = 2005;\nconst int MOD = 1000000007;\n\nllint n, k;\nllint dp[MAXN][MAXN], f[MAXN*MAXN], inv[MAXN*MAXN], r[MAXN*MAXN];\n\ninline llint add (llint x, llint y) {\n    x += y;\n    if (x >= MOD) return x - MOD; return x;\n}\n\nvoid precompute () {\n    f[0] = inv[0] = 1;\n    for (int i=1; i<n*k; i++) {\n        if (i == 1) r[i] = 1; else r[i] = (MOD - (MOD / i * r[MOD % i]) % MOD) % MOD;\n        f[i] = f[i-1] * i % MOD;\n        inv[i] = inv[i-1] * r[i] % MOD;\n    }\n}\n\nllint nck (llint n, llint k) {\n    return f[n] * inv[k] % MOD * inv[n-k] % MOD;\n}\n\nvoid calc () {\n    dp[1][1] = 1;\n    for (int i = 2; i <= n; i++) {\n        llint curr = 0;\n        for (int j = i; j >= 1; j--) {\n            if (j > 1) curr = add(curr, dp[i-1][j-1]);\n            dp[i][j] = curr * nck(k*i - j - 1, k-2) % MOD;\n            dp[i][0] = add(dp[i][0], dp[i][j]);\n        }\n    }\n}\n\nint main () {\n    cin >> n >> k;\n    if (n == 1 || k == 1) {\n        cout << 1;\n        return 0;\n    }\n    precompute();\n    calc();\n    cout << dp[n][0] * f[n] % MOD;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int mod = 1e9 + 7;\nconst int MAXN = 2005, MAXS = MAXN * MAXN;\n\ntemplate<typename _T>\nvoid read( _T &x )\n{\n\tx = 0;char s = getchar();int f = 1;\n\twhile( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}\n\twhile( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}\n\tx *= f;\n}\n\ntemplate<typename _T>\nvoid write( _T x )\n{\n\tif( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }\n\tif( 9 < x ){ write( x / 10 ); }\n\tputchar( x % 10 + '0' );\n}\n\nint f[MAXN][MAXN];\nint fac[MAXS], ifac[MAXS];\nint N, K;\n\nint qkpow( int, int );\nint inv( const int a ) { return qkpow( a, mod - 2 ); }\nvoid sub( int &x, const int v ) { x = ( x < v ? x - v + mod : x - v ); }\nvoid add( int &x, const int v ) { x = ( x + v >= mod ? x + v - mod : x + v ); }\n\nint qkpow( int base, int indx )\n{\n\tint ret = 1;\n\twhile( indx )\n\t{\n\t\tif( indx & 1 ) ret = 1ll * ret * base % mod;\n\t\tbase = 1ll * base * base % mod, indx >>= 1;\n\t}\n\treturn ret;\n}\n\nvoid init( const int siz )\n{\n\tfac[0] = ifac[0] = 1;\n\tfor( int i = 1 ; i <= siz ; i ++ ) fac[i] = 1ll * fac[i - 1] * i % mod;\n\tifac[siz] = inv( fac[siz] );\n\tfor( int i = siz - 1 ; ~ i ; i -- ) ifac[i] = 1ll * ifac[i + 1] * ( i + 1 ) % mod;\n}\n\nint C( const int n, const int m ) { return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod; }\n\nint main()\n{\n\tread( N ), read( K );\n\tif( K == 1 ) { puts( \"1\" ); return 0; }\n\tinit( N * K );\n\tfor( int i = 0 ; i <= K ; i ++ ) f[i][0] = 1;\n\tfor( int i = 1 ; i <= K ; i ++ )\n\t\tfor( int j = 1 ; j <= i && j <= N ; j ++ )\n\t\t{\n\t\t\tf[i][j] = f[i - 1][j];\n\t\t\tint t = N * K - i - ( K - 1 ) * ( j - 1 ) - 1;\n\t\t\tadd( f[i][j], 1ll * f[i][j - 1] * ( N - j + 1 ) % mod * C( t, K - 2 ) % mod );\n\t\t}\n\twrite( f[K][N] ), putchar( '\\n' );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n//ａをbで割る\nlong long mod_div(long long a,long long b){\n\tif(a % b == 0)return a/b;\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n\n#define MAX_K 2222*2222\nvector<long long> kaijo(MAX_K);\nlong long combination(long long n, long long r){\n    if(n < r || n < 0 || r < 0)\n        return 0;\n\tif(kaijo[0] != 1){\n\t\tkaijo[0] = 1;\n\t\tfor(long long i = 1;i < MAX_K;i++)kaijo[i] = (kaijo[i-1] * i) % MOD;\n\t}\n    long long ret = kaijo[n];\n\tlong long tmp = (kaijo[r] * kaijo[n-r]) % MOD;\n    return mod_div(ret,tmp);\n}\n\nll dp[2222][2222];\n\nll n,k;\nll dfs(ll a,ll b){\n\tif(dp[a][b] != -1){\n\t\treturn dp[a][b];\n\t}\n\tll ret = 0;\n\tif(a > 0){\n\t\tret += dfs(a - 1, b);\n\t\tret %= MOD;\n\t}\n\tif(b > a){\n\t\tret += combination(a + b * (k - 1) - 1,k - 2) * dfs(a, b - 1) % MOD;\n\t\tret %= MOD;\n\t}\n\treturn dp[a][b] = ret;\n}\n\nint main(){\n\n\tREP(i,2222)REP(j,2222)dp[i][j] = -1;\n\n\tdp[0][0] = 1;\n\tcin >> n >> k;\n\tif(k == 1){\n\t\tcout << 1 << endl;\n\t}\n\telse{\n\t\tll ans = 1;\n\t\tfor(ll i = 1;i <= n;i++)ans = (ans * i) % MOD;\n\t\tcout << dfs(n,n)*ans%MOD << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int maxn=2000+10,mod=1e9+7;\nll f[maxn][maxn];\nll s[maxn*maxn+10],invs[maxn*maxn+10];\nint n,m;\ninline void read(int &x){\n\tchar c=getchar();\n\tint f=1;\n\tx=0;\n\twhile(c<'0' || c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0' && c<='9'){x=x*10+c-'0';c=getchar();}\n\tx*=f;\n}\ninline long long ksm(ll x,int y){\n\tll sum=1;\n\twhile(y){\n\t\tif(y&1){sum=(sum*x)%mod;}\n\t\ty/=2;\n\t\tx=(x*x)%mod;\n\t}\n\treturn sum%mod;\n}\ninline ll cal(int x,int y){\n\t//cout<<s[x]<<\" \"<<s[y]<<endl;\n\tll sum2=1,sum1=1,sum=0;\n\t//for(register int i=1;i<=y;i++)sum1=(sum1*i)%mod;\n\t//for(register int i=x-y+1;i<=x;i++)sum2=(sum2*i)%mod;\n\t//sum2=s[x];sum1=(s[x-y]*s[y])%mod;\n\t//sum=(sum2*ksm(sum1,mod-2))%mod;\n\tsum=((s[x]*invs[y])%mod*invs[x-y])%mod;\n\t//cout<<sum<<endl;\n\treturn sum%mod;\n}\nint main(){\n\tint i,j,k;\n\tread(n);read(m);\n\t//cout<<n<<\" \"<<m<<endl;\n\tif(m==1){cout<<1<<endl;return 0;}\n\tf[0][0]=1;\n\ts[0]=1;\n\t//for(register int i=1;i<=n;i++)f[i][0]=1;\n\tfor(register int i=1;i<=maxn*maxn;i++){s[i]=(s[i-1]*i)%mod;}\n\tinvs[maxn*maxn]=ksm(s[maxn*maxn],mod-2);\n\tfor(register int i=maxn*maxn-1;i>=0;i--)invs[i]=(invs[i+1]*(i+1))%mod;\n\tfor(register int i=1;i<=n;i++)\n\t\tfor(register int j=0;j<=i;j++){\n\t\t\tif(!j)f[i][j]=f[i-1][j]%mod;\n\t\t\telse f[i][j]=(f[i-1][j]+((f[i][j-1]*(n-j+1))%mod*cal(n*m-(j-1)*(m-1)-i-1,m-2)))%mod;\n\t\t}\n\tcout<<f[n][n]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#define SF scanf\n#define PF printf\n#define MAXN 2010\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nll dp[MAXN][MAXN];\nll fac[MAXN*MAXN+MAXN*2],inv[MAXN*MAXN+MAXN*2];\nll fsp(ll x,int y){\n\tll res=1;\n\twhile(y){\n\t\tif(y&1)\n\t\t\tres=res*x%MOD;\n\t\tx=x*x%MOD;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nll C(int x,int y){\n\treturn fac[x]*inv[y]%MOD*inv[x-y]%MOD;\t\n}\nint n,k;\nint main(){\n\tfac[0]=1;\n\tfor(int i=1;i<=4004000;i++)\n\t\tfac[i]=fac[i-1]*i%MOD;\n\tinv[4004000]=fsp(fac[4004000],MOD-2);\n\tfor(int i=4004000;i>0;i--)\n\t\tinv[i-1]=inv[i]*i%MOD;\n\tSF(\"%d%d\",&n,&k);\n\tif(k==1){\n\t\tPF(\"1\");\n\t\treturn 0;\n\t}\n\tk--;\n\tdp[0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=i;j<=n;j++){\n\t\t\tif(i!=0)\n\t\t\t\tdp[i][j]=(dp[i][j]+dp[i-1][j])%MOD;\n\t\t\tif(j!=0)\n\t\t\t\tdp[i][j]=(dp[i][j]+dp[i][j-1]*C(i+(j-1)*k+k-1,k-1)%MOD)%MOD;\n\t\t}\n\tPF(\"%lld\",dp[n][n]*fac[n]%MOD);\n}"
  },
  {
    "language": "C++",
    "code": "// In The Name Of The Queen\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 2009, MXN = N * N, Mod = 1e9 + 7;\nint n, k, dp[N][N], F[MXN], I[MXN];\ninline int Power(int a, int b)\n{\n    int ret = 1;\n    for (; b; b >>= 1, a = 1LL * a * a % Mod)\n        if (b & 1) ret = 1LL * ret * a % Mod;\n    return (ret);\n}\ninline void Add(int &a, int b)\n{\n    a += b;\n    if (a >= Mod)\n        a -= Mod;\n}\ninline int nCr(int n, int r)\n{\n    if (r < 0 || n < r)\n        return 0;\n    return (F[n] * 1LL * I[r] % Mod * I[n - r] % Mod);\n}\nint main()\n{\n    scanf(\"%d%d\", &n, &k);\n    if (k == 1)\n        return !printf(\"1\\n\");\n    for (int i = F[0] = 1; i < MXN; i ++)\n        F[i] = 1LL * F[i - 1] * i % Mod;\n    I[MXN - 1] = Power(F[MXN - 1], Mod - 2);\n    for (int i = MXN - 2; ~ i; i --)\n        I[i] = 1LL * I[i + 1] * (i + 1) % Mod;\n    dp[0][0] = 1;\n    for (int i = 0; i <= n; i ++)\n        for (int j = 0; j <= i; j ++)\n        {\n            if (i < n)\n                Add(dp[i + 1][j], dp[i][j]);\n            if (j < i)\n                Add(dp[i][j + 1], dp[i][j] * 1LL * nCr(n * k - j * (k - 1) - i - 1, k - 2) % Mod);\n        }\n    return !printf(\"%lld\\n\", dp[n][n] * 1LL * F[n] % Mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int L=4000005,N=2005,M=1e9+7;\nint fac[L],inv[L],dp[N][N],n,m;\nint ksm(int x,int y){\n\tif (!y)return 1;\n\tint z=ksm(x,y/2);\n\tz*=z;z%=M;\n\tif (y&1)z*=x;\n\treturn z%M;\n}\nint C(int x,int y){\n\treturn fac[x]*inv[y]%M*inv[x-y]%M;\n}\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tif (m==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=inv[0]=1;\n\tfor (int i=1;i<L;i++)fac[i]=fac[i-1]*i%M;\n\tinv[L-1]=ksm(fac[L-1],M-2);\n\tfor (int i=L-2;i>=0;i--)inv[i]=(i+1)*inv[i+1]%M;\n\tdp[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=0;j<=i;j++)\n\t\t\tdp[i][j]=((j>0?dp[i][j-1]:0)+dp[i-1][j]*C((i-1)*m-(i-j-1)+m-2,m-2))%M;\n\tprintf(\"%lld\\n\",dp[n][n]*fac[n]%M);\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long i64;\nconst int P=1e9+7,N=2007;\nint pw(int a,int n){\n\tint v=1;\n\tfor(;n;n>>=1,a=(i64)a*a%P)if(n&1)v=(i64)v*a%P;\n\treturn v;\n}\nint fac[N*N],fiv[N*N],mx;\nint n,k,f[N];\nint C(int n,int m){\n\treturn (i64)fac[n]*fiv[m]%P*fiv[n-m]%P;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1)return puts(\"1\"),0;\n\tmx=n*k;\n\tfor(int i=fac[0]=1;i<=mx;++i)fac[i]=i64(i)*fac[i-1]%P;\n\tfiv[mx]=pw(fac[mx],P-2);\n\tfor(int i=mx;i;--i)fiv[i-1]=i64(i)*fiv[i]%P;\n\tf[1]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1,s=0;j<=i;++j){\n\t\t\ts=(s+f[j])%P;\n\t\t\tf[j]=(i64)s*C(i*(k-1)+j-2,k-2)%P;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;++i)ans=(ans+f[i])%P;\n\tans=(i64)ans*fac[n]%P;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifndef LOCAL\n#define endl '\\n'\n#endif\n\n#define fr(i, a, b) for(int i = a; i <= b; i++)\n#define rf(i, a, b) for(int i = a; i >= b; i--)\n#define pf push_front\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define sz(x) (int)x.size()\n#define lb lower_bound\n#define ub upper_bound\n\ntypedef long long ll;\ntypedef long double f80;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint pct(int x) { return __builtin_popcount(x); }\nint pct(ll x) { return __builtin_popcountll(x); }\nint bt(int x) { return 31 - __builtin_clz(x); } // floor(log2(x))\nint bt(ll x) { return 63 - __builtin_clzll(x); } // floor(log2(x))\nint cdiv(int a, int b) { return a / b + !(a < 0 || a % b == 0); }\nll cdiv(ll a, ll b) { return a / b + !(a < 0 || a % b == 0); }\nint nxt_C(int x) { int c = x & -x, r = x + c; return (((r ^ x) >> 2) / c) | r; }\nll nxt_C(ll x) { ll c = x & -x, r = x + c; return (((r ^ x) >> 2) / c) | r; }\n\nvector<int> get_bits(int mask) {\n\tvector<int> bb;\n\twhile(mask) { int b = bt(mask); bb.pb(b); mask ^= (1 << b); }\n\treverse(all(bb));\n\treturn bb;\n}\n\nint get_mask(vector<int> v) {\n\tint mask = 0;\n\tfor(int x : v) { mask ^= (1 << x); }\n\treturn mask;\n}\n\ntemplate<typename T>\nvoid uniq(vector<T> &v) { sort(all(v)); v.resize(unique(all(v)) - v.begin()); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nll rand(ll l, ll r){\n\tuniform_int_distribution<ll> uid(l, r);\n\treturn uid(rng);\n}\n\nvoid sc() {}\n\ntemplate <typename Head, typename... Tail>\nvoid sc(Head &H, Tail &... T) { cin >> H; sc(T...); }\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[L:\" << __LINE__ << \"][\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n// #ifndef LOCAL\n// string to_string(__int128 x) {\n// \tstring s = \"\";\n// \tbool neg = 0;\n// \tif(x < 0) { s += \"-\"; neg = 1; x = -x; }\n// \tif(!x) s += '0';\n// \twhile(x) {\n// \t\tint rem = x % 10;\n// \t\ts += to_string(rem);\n// \t\tx /= 10;\n// \t}\n// \treverse(s.begin() + neg, s.end());\n// \treturn s;\n// }\n// #endif\n\nconst int mod = 1e9 + 7; // 998244353;\n\nint pwr(int a,ll b) {\n\tint ans = 1;\n\twhile(b) {\n\t\tif(b & 1) ans = (ans * 1LL * a) % mod;\n\t\ta = (a * 1LL * a) % mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\n/*\n\tLookout for overflows!!\n\tCheck array sizes!!\n\tClear before test cases!!\n\tUse the correct modulo!!\n\tCheck for corner cases!!\n\tAre you forgetting something?!\n\tRead problem statement carefully!!!\n*/\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n \ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n \n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n \n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n \n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n \n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n \n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n \n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n \n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n \n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n \n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n \n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n \n private:\n  Type value;\n};\n \ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n \ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n \ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n \ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n \ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n \ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n \ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n \ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n \ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n \ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n \ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n \ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n \n/*\nusing ModType = int;\n \nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n\n*/\n\nconstexpr int md = 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nMint pwr(Mint a, ll k) {\n\tMint ans = 1;\n\twhile(k) {\n\t\tif(k & 1) ans = ans * a;\n\t\ta = a * a;\n\t\tk >>= 1;\n\t}\n\treturn ans;\n}\n\nconst int N = 2005;\nconst int NN = N * N;\nMint dp[N][N];\nMint fact[NN], ifact[NN];\n\nMint ncr(int n,int k) {\n    if(n < k || k < 0) return 0;\n    return fact[n] * ifact[k] * ifact[n - k];\n}\n\nvoid solve() {\n    fact[0] = 1;\n    fr(i, 1, NN - 1) {\n        fact[i] = i * fact[i - 1];\n    }\n    ifact[NN - 1] = 1 / fact[NN - 1];\n    rf(i, NN - 2, 0) {\n        ifact[i] = (i + 1) * ifact[i + 1];\n    }\n\tint n, k;\n    sc(n, k);\n    if(k == 1) {\n        cout << 1 << endl;\n        return;\n    }\n    dp[0][0] = 1;\n    fr(i, 0, n) {\n        fr(j, 0, i) {\n            if(!dp[i][j]) continue;\n            // debug(i, j, dp[i][j]);\n            if(i < n) { // adding zero\n                dp[i + 1][j] += dp[i][j];\n            }\n            if(j < n && i > j) {\n                dp[i][j + 1] += dp[i][j] * ncr(n * k - i - j * (k - 1) - 1, k - 2) * (n - j);\n            }\n        }\n    }\n    cout << dp[n][n];\n}\n\nint main() {\n\tios :: sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint t = 1;\n\t// cin >> t;\n\tfor(int tt = 1; tt <= t; tt++) {\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**************************************\n * Au: Hany01\n * Prob: agc002f\n * Date: Oct 20th, 2018\n * Email: hany01@foxmail.com\n**************************************/\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define File(a) freopen(a\".in\", \"r\", stdin), freopen(a\".out\", \"w\", stdout)\n#define Rep(i, j) for (register int i = 0, i##_end_ = j; i < i##_end_; ++ i)\n#define For(i, j ,k) for (register int i = (j), i##_end_ = (k); i <= i##_end_; ++ i)\n#define Fordown(i, j, k) for (register int i = (j), i##_end_ = (k); i >= i##_end_; -- i)\n#define Set(a, b) memset(a, b, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define SZ(a) ((int)(a.size()))\n#define ALL(a) a.begin(), a.end()\n#define PB(a) push_back(a)\n#define MP(a, b) make_pair(a, b)\n#define X first\n#define Y second\n#define INF (0x3f3f3f3f)\n#define INF1 (2139062143)\n#define y1 wozenmezhemecaia \n#ifdef hany01\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline T read() {\n    register char c_; register T _, __;\n    for (_ = 0, __ = 1, c_ = getchar(); !isdigit(c_); c_ = getchar()) if (c_ == '-')  __ = -1;\n    for ( ; isdigit(c_); c_ = getchar()) _ = (_ << 1) + (_ << 3) + (c_ ^ 48);\n    return _ * __;\n}\n//EOT\n\n\nconst int maxn = 2048, maxm = 2048 * 2048, MOD = 1e9 + 7;\n\nint n, k, fac[maxm], ifac[maxm], f[maxn][maxn];\n\ninline int fpm(int a, int b) {\n\tregister int ans = 1;\n\tfor ( ; b; b >>= 1, a = (LL)a * a % MOD)\n\t\tif (b & 1) ans = (LL)ans * a % MOD;\n\treturn ans;\n}\n\ninline void inc(int &x, int y) { if ((x += y) >= MOD) x -= MOD; }\n\ninline void init(int n) {\n\tfac[0] = 1;\n\tFor(i, 1, n) fac[i] = (LL)fac[i - 1] * i % MOD;\n\tifac[n] = fpm(fac[n], MOD - 2);\n\tFordown(i, n, 1) ifac[i - 1] = (LL)ifac[i] * i % MOD;\n}\n\ninline LL C(int n, int m) { return (LL)fac[n] * ifac[m] % MOD * ifac[n - m] % MOD; }\n\nint main()\n{\n#ifdef hany01\n    File(\"agc002f\");\n#endif\n\n\tn = read<int>(), k = read<int>(), init(n * k);\n\n\t//Pay attention!!\n\tif (k == 1) { puts(\"1\"); return 0; }\n\n\tf[0][0] = 1;\n\tFor(i, 0, n) For(j, 0, i) {\n\t\tinc(f[i + 1][j], f[i][j]);\n\t\tif (i > j) inc(f[i][j + 1], C(n * k - (k - 1) * j - i - 1, k - 2) * f[i][j] % MOD);\n\t}\n\tcout << (LL)f[n][n] * fac[n] % MOD << endl;\n\n    return 0;\n}\n\n//Analysis:\n//先考虑按顺序加入编号1~n的球，最后乘一个n!\n//从前往后考虑, 那么0球的数量一定不小于已经出现的颜色的数量\n//f[i][j]表示加入了i个0球、j种颜色 (i >= j)\n//\n//转移:\n//加入0球: dp[i][j] ==> dp[i+1][j]\n//加入一种新的颜色: f[i][j] * C(n*k-(k-1)*j-i-1, k-2) ==> dp[i][j+1]\n//(一共n*k个格子, 已经用掉了(k-1)*j+i个, 由于要保证不重复, 得有个新颜色放在最前面, 所以是n*k-(k-1)*j-i-1个空位\n//k个球, 除掉0球, 除掉固定的最前面的球, 所以是k-2个球要放进去)\n//\n//注意特判k=1的情况"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ui unsigned int\n#define ll long long\n#define db double\n#define ld long double\n#define ull unsigned long long\n#define ft first\n#define sd second\n#define pb(a) push_back(a)\n#define PII std::pair<int,int>\n#define PLL std::pair<ll,ll>\n#define mp(a,b) std::make_pair(a,b)\n#define ITR(a,b) for(auto a:b)\n#define REP(a,b,c) for(register int a=(b),a##end=(c);a<=a##end;++a)\n#define DEP(a,b,c) for(register int a=(b),a##end=(c);a>=a##end;--a)\nconst int MAXN=2000+10,MAXM=5000000+10,Mod=1e9+7;\nint n,k;\nll f[MAXN][MAXN],fac[MAXM],inv[MAXM];\ntemplate<typename T> inline void read(T &x)\n{\n\tT data=0,w=1;\n\tchar ch=0;\n\twhile(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n\tif(ch=='-')w=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9')data=((T)data<<3)+((T)data<<1)+(ch^'0'),ch=getchar();\n\tx=data*w;\n}\ntemplate<typename T> inline void write(T x,char ch='\\0')\n{\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)write(x/10);\n\tputchar(x%10+'0');\n\tif(ch!='\\0')putchar(ch);\n}\ntemplate<typename T> inline bool chkmin(T &x,T y){return y<x?(x=y,true):false;}\ntemplate<typename T> inline bool chkmax(T &x,T y){return y>x?(x=y,true):false;}\ntemplate<typename T> inline T min(T x,T y){return x<y?x:y;}\ntemplate<typename T> inline T max(T x,T y){return x>y?x:y;}\ninline ll qexp(ll a,ll b)\n{\n\tll res=1;\n\twhile(b)\n\t{\n\t\tif(b&1)res=res*a%Mod;\n\t\ta=a*a%Mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\ninline void init(int LM)\n{\n\tfac[0]=1;\n\tREP(i,1,LM)fac[i]=1ll*fac[i-1]*i%Mod;\n\tinv[LM]=qexp(fac[LM],Mod-2);\n\tDEP(i,LM-1,0)inv[i]=1ll*inv[i+1]*(i+1)%Mod;\n}\ninline ll C(int n,int m)\n{\n\treturn 1ll*fac[n]*inv[m]%Mod*inv[n-m]%Mod;\n}\nint main()\n{\n\tread(n);read(k);init((n+1)*k);\n\tif(k==1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tf[0][0]=1;\n\tREP(i,0,n)REP(j,0,i)if(i||j)\n\t\tf[i][j]=((j?f[i][j-1]:0)+(i?1ll*C((i-1)*(k-1)+j+k-2,k-2)*f[i-1][j]%Mod:0))%Mod;\n\twrite(1ll*f[n][n]*fac[n]%Mod,'\\n');\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"0\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\n\nconst int MX = 2005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\n// Mod int\nconst int mod = 1000000007;\nstruct mint;\nmint ex(mint a, ll tms);\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  // mint(ll x):x(x){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=ex(a,mod-2).x)%=mod; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\ntypedef vector<mint> vm;\nmint ex(mint a, ll tms) {\n  if(!tms) return 1;\n  mint res = ex(a,tms/2);\n  res *= res;\n  return (tms&1)?res*a:res;\n}\nstruct comb {\n  vm f, g;\n  comb(){}\n  comb(int mx):f(mx+1),g(mx+1) {\n    f[0] = 1;\n    rrep(i,mx) f[i] = f[i-1]*i;\n    g[mx] = ex(f[mx],mod-2);\n    for(int i=mx;i>0;i--) g[i-1] = g[i]*i;\n  }\n  mint c(int a, int b) {\n    if (a < b) return 0;\n    return f[a]*g[b]*g[a-b];\n  }\n};\n//\n\nmint dp[MX][MX];\n\nint main() {\n  int n, m;\n  scanf(\"%d%d\",&n,&m);\n  if (m == 1) {\n    puts(\"1\");\n    return 0;\n  }\n  comb c(MX*MX);\n  mint ans;\n  dp[0][0] = 1;\n  rep(i,n) {\n    rep(j,n) dp[i][j+1] += dp[i][j];\n    rep(j,n+1) dp[i+1][j] = dp[i][j];\n    rep(j,n+1) {\n      if (i+1 > j) dp[i+1][j] = 0;\n      else {\n        // dp[i+1][j] /= (j-i);\n        dp[i+1][j] *= c.c((n-i)*m-(j-i)-1,m-2);\n      }\n      // cout<<i+1<<\" \"<<j<<\" \"<<dp[i+1][j]<<endl;\n    }\n  }\n  ans = dp[n][n]*c.f[n];\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxN = 2001;\nconst int mod = 1e9 + 7;\n\nlong long n, k, dp[maxN][maxN], fac[maxN * maxN], inv_fac[maxN * maxN];\n\nlong long pow_mod (long long a, int b) {\n\tint ans = 1;\n\twhile (b) {\n\t\tif (b & 1) { ans = (ans * a) % mod; }\n\t\tb >>= 1, a = (a * a) % mod;\n\t}\n\treturn ans;\n}\n\nvoid init() {\n\tfac[0] = 1;\n\tfor (register int i = 1; i <= maxN * maxN; i++) {\n\t\tfac[i] = (fac[i - 1] * i) % mod;\n\t}\n\tinv_fac[maxN * maxN] = pow_mod(fac[maxN * maxN], mod - 2);\n\tfor (register int i = maxN * maxN - 1; i >= 0; i--) {\n\t\tinv_fac[i] = (inv_fac[i + 1] * (i + 1)) % mod;\n\t}\n}\n\ninline long long C(int m, int n) {\n\treturn ((fac[n] * inv_fac[m] % mod) * inv_fac[n - m] % mod); \n}\n\nint main() {\n\tscanf(\"%lld%lld\", &n, &k);\n\tinit();\n\tif (k == 1) {\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tfor (register int i = 0; i <= n; i++) {\n\t\tdp[i][0] = 1;\n\t}\t\n\tfor (register int i = 1; i <= n; i++) {\n\t\t\tfor (register int j = 0; j <= i; j++) {\n\t\t\t\tif (!j) { continue; }\n\t\t\t\tdp[i][j] = (dp[i - 1][j] + (dp[i][j - 1] * (n - j + 1)) % mod * C(k - 2, n * k - i - (j - 1) * (k - 1) - 1)) % mod;\n\t\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Achen\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<vector>\n#include<cstdio>\n#include<queue>\n#include<cmath>\n#include<set>\n#include<map>\n#define For(i,a,b) for(int i=(a);i<=(b);i++)\n#define Rep(i,a,b) for(int i=(a);i>=(b);i--)\nconst int N=2007,mod=1e9+7;\ntypedef long long LL; \ntypedef double db;\nusing namespace std;\nint n,k;\nLL dp[N][N],fac[N*N],inv[N*N];\n\ntemplate<typename T> void read(T &x) {\n    char ch=getchar(); x=0; T f=1;\n    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n    if(ch=='-') f=-1,ch=getchar();\n    for(;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0'; x*=f;\n}\n\nLL C(int n,int m) {\n\tif(n<m) return 0;\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\n\n//#define DEBUG\nint main() {\n#ifdef DEBUG\n\tfreopen(\"1.in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n#endif\n\tread(n); read(k);\n\tfac[0]=inv[0]=inv[1]=1;\n\tFor(i,1,n*n) fac[i]=fac[i-1]*i%mod;\n\tFor(i,2,n*n) inv[i]=(mod-mod/i*inv[mod%i]%mod)%mod;\n\tFor(i,2,n*n) inv[i]=inv[i-1]*inv[i]%mod; \n\tif(k==1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tdp[n][n]=1;\n\tRep(i,n,0) {\n\t\tRep(j,n,i) {\n\t\t\tif(i) (dp[i-1][j]+=dp[i][j])%=mod;\n\t\t\tif(j>i) (dp[i][j-1]+=dp[i][j]*(k>2?C(i+j*(k-1)-1,k-2):1)%mod)%=mod;\n\t\t}\n\t}\n\tLL ans=dp[0][0]*fac[n]%mod;\n\tprintf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<LL, LL> pll;\ntypedef pair<int, int> pii;\n\nconst int mod = 1e9 + 7;\nconst int maxn = 4000 + 5;\nconst int oo = 0x3f3f3f3f;\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\n#define fst first\n#define snd second\n#define pb push_back\n\ntemplate<typename T> T read() {\n\tT n(0), f(1);\n\tchar ch = getchar();\n\tfor( ;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n\tfor( ; isdigit(ch); ch = getchar()) n = n * 10 + ch - 48;\n\treturn n * f;\n}\n\nLL f[maxn][maxn], C[maxn][maxn];\nLL fac(int n) {\n    LL res = 1;\n    for(int i = 2; i <= n; i++) (res *= i) %= mod;\n    return res;\n}\nvoid init() {\n    for(int i = 0; i < maxn; i++) { \n        C[i][0] = C[i][i] = 1;\n        for(int j = 1; j < i; j++)\n            C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod;\n    }\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n    freopen(\"data.txt\", \"r\", stdin);\n    freopen(\"ans.txt\", \"w\", stdout);\n#endif\n\n    init();\n\n    int n, k;\n    n = read<int>(), k = read<int>();\n\n    f[n][n] = 1;\n\n    for(int i = n; i >= 0; i--) {\n        for(int j = n; j >= 0; j--) if(f[i][j]) {\n            if(i > 0) (f[i-1][j] += f[i][j]) %= mod;\n            if(j > i) (f[i][j-1] += f[i][j] * C[n*k-(n-i)-(n-j)*(k-1)-1][k-2] % mod) %= mod;\n        }\n    }\n    printf(\"%lld\\n\", f[0][0] * fac(n) % mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nconst ll M = 1000000007;\n\nll modpow(ll x,ll k){\n\tif(k == 0)return 1;\n\tll ret = modpow(x,k/2);\n\tret *= ret; ret %= M;\n\tif(k%2 == 1){ ret *= x; ret %= M ; }\n\treturn ret;\n}\nll inv(ll x){\n\treturn modpow(x,M-2);\n}\n\nll f[4000010];\nvoid init(int k){\n\tf[k-2] = 1;\n\tfor(int i = k-2 ; i < 4000009 ; i ++){\n\t\tf[i+1] = f[i]*(i+1); f[i+1] %= M;\n\t\tf[i+1] *= inv(i+3-k); f[i+1] %= M;\n\t}\n}\n\nint main(){\n\tll n,k;\n\tcin >> n >> k;\n\tif(k == 1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tif(k == 2){\n\t\trep(i,4000010)f[i] = 1;\n\t}\n\t\n\tif(k != 2)init(k);\n\t\n\tstatic ll dp[2002][2002] = {};\n\tdp[0][0] = 1;\n\trep1(i,n){\n\t\tll sum = dp[i-1][i-1];\n\t\tfor(int j = i ; j <= n ; j ++){\n\t\t\tsum += dp[i-1][j];\n\t\t\tsum %= M;\n\t\t\tdp[i][j] = sum*f[(n-i)*k+i-j+k-2];\n\t\t\tdp[i][j] %= M;\n\t\t}\n\t}\n\trep1(i,n){\n\t\tdp[n][n] *= i;\n\t\tdp[n][n] %= M;\n\t}\n\tcout << dp[n][n] << endl;\n}\n\t\t\t\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll n,k;\nconst int MAXN = 2000*2000+1;\nlong long kai[MAXN];\nlong long inv[MAXN];\nlong long mod = 1e9+7;\nlong long mp(long long a, long long b) {\n    long long res = 1;\n    for (; b; b >>= 1) {\n        if (b & 1) res = (res * a) % mod;\n        a = (a * a) % mod;\n    }\n    return res;\n}\nvoid init() {\n    kai[0] = 1;\n    for (long long i = 1; i <= MAXN; i++) kai[i] = kai[i - 1] * i % mod;\n    inv[MAXN] = mp(kai[MAXN], mod-2);\n    for (long long i = MAXN; i >= 1; i--) inv[i - 1] = inv[i] * i % mod;\n}\nlong long calc(long long n, long long k) {\n    if (n < k) return 0;\n    return (kai[n] * inv[k]) % mod * inv[n - k] % mod;\n}\n\nll dp[2010][2010];\nbool ok[2010][2010];\n\nll dfs(int a, int b) {\n    if (ok[a][b]) return dp[a][b];\n    ll ret = 0;\n    if (a - 1 >= 0) ret += dfs(a-1,b);\n    if (b - 1 >= a) ret += dfs(a, b-1) * calc(a + b * (k - 1) - 1, k - 2) % mod;\n    ok[a][b] = 1;\n    return dp[a][b] = ret % mod;\n}\n\nint main() {\n    cin >> n >> k;\n    init();\n    if (k == 1) {\n        cout << 1 << endl;\n        return 0;\n    }\n    dp[0][0] = 1;\n    ok[0][0] = 1;\n    ll ret = dfs(n,n);\n    for (ll i = 1; i <= n; i++) ret = ret * i % mod;\n    cout << ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\n#define w1 first\n#define w2 second\n#define ls (x<<1)\n#define rs (x<<1|1)\n#define pb push_back\n#define mid ((l+r)>>1)\n#define SZ(x) ((x).size())\n#define All(x) (x).begin(),(x).end()\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\nint power(int x,int k,int p){int res=1;for(;k;k>>=1,x=1ll*x*x%p)if(k&1)res=1ll*res*x%p;return res;}\nconst int maxn=2e3+5,mod=1e9+7;\nint n,k;\nint fac[maxn*maxn],ifac[maxn*maxn],f[maxn][maxn];\nint C(int n,int m){\n\treturn 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\nvoid upd(int &x,int y){\n\tx=(x+y)%mod;\n}\nint main(){\n\tread(n);read(k);\n\tfac[0]=1;rep(i,1,n*k)fac[i]=1ll*fac[i-1]*i%mod;\n\tifac[n*k]=power(fac[n*k],mod-2,mod);per(i,n*k-1,0)ifac[i]=1ll*ifac[i+1]*(i+1)%mod;\n\trep(i,0,n*k)ifac[i]=power(fac[i],mod-2,mod);\n\tif(k==1){\n\t\tprintf(\"%d\\n\",1);\n\t\treturn 0;\n\t}\n\tf[2][1]=1;\n\trep(i,2,n+1)rep(j,1,i){\n\t\tif((i==n+1&&j==n+1)||(!f[i][j]))continue;\n\t\tupd(f[i+1][j],f[i][j]);\n\t\tint rest=n*k-((i-1)+(j-1)*(k-1));\n\t\tupd(f[i][j+1],1ll*f[i][j]*C(rest-1,k-2)%mod);\n\t}\n\tprintf(\"%lld\\n\",1ll*f[n+1][n+1]*fac[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(X,Y) ((X)>(Y)?X=(Y),true:false)\n#define chmax(X,Y) ((X)<(Y)?X=(Y),true:false)\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 4003\n#define NN (N*N)\nll inv[NN], fact[NN], ifact[NN];\nll n, k;\nll dp[N][N];\n\nvoid init_fact(ll n = NN){\n    inv[1] = 1;\n    for(int i = 2; i < n;i++) inv[i] = inv[mod%i] * (mod - mod/i) % mod;\n\tfact[0] = ifact[0] = 1;\n\tfor(int i = 1; i < n; i++){\n\t\tfact[i] = (fact[i-1]*i)%mod;\n\t\tifact[i]=(ifact[i-1]*inv[i])%mod;\n\t}\n}\n\nll comb(ll a, ll b){\n\tif(a<0 || b<0) return 0;\n\treturn fact[a+b]*ifact[a]%mod*ifact[b]%mod;\n}\n\nint main(){\n\tinit_fact();\n\tcin>>n>>k;\n\tif(k==1){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tfill(dp[0], dp[0]+N, fact[n]);\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = i; j <= n; j++){\n\t\t\tdp[i][j]=(dp[i][j-1]+dp[i-1][j]*comb(k-2, (n-i)*k+i-j))%mod;\n\t\t}\n\t}\n\tcout<<dp[n][n]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#define LL long long\nusing namespace std;\nconst LL Maxn = 2010;\nconst LL Mod = 1e9+7;\nLL n, m;\nLL f[Maxn][Maxn];\nLL jc[Maxn*Maxn], inv[Maxn*Maxn];\nLL C(LL A, LL B) { return jc[A]*inv[B]%Mod*inv[A-B]%Mod; }\nvoid up(LL &x, LL y) { x = (x+y)%Mod; }\nint main() {\n\tLL i, j, k;\n\tscanf(\"%lld%lld\", &n, &m);\n\tif(m == 1){ printf(\"1\\n\"); return 0; }\n\tjc[0] = 1;\n\tfor(i = 1; i <= n*m; i++) jc[i] = jc[i-1]*i%Mod;\n\tinv[0] = inv[1] = 1;\n\tfor(i = 2; i <= n*m; i++) inv[i] = inv[Mod%i]*(Mod-Mod/i)%Mod;\n\tfor(i = 2; i <= n*m; i++) inv[i] = inv[i]*inv[i-1]%Mod;\n\tf[0][0] = 1;\n\tfor(i = 0; i <= n; i++){\n\t\tfor(j = i; j <= n; j++){\n\t\t\tif(i < j) up(f[i+1][j], f[i][j]);\n\t\t\tif(j < n) up(f[i][j+1], C((m-1)*(j+1)+i-1,m-2)*f[i][j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", f[n][n]*jc[n]%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MN = 20123, MOD = 1000 * 1000 * 1000 + 7, mod = MOD;\nint inv[MN], fict[MN], invf[MN], dp[MN][MN];\n\nvoid fact() {\n\tfict[0] = inv[0] = invf[0] = 1;\n\tfict[1] = inv[1] = invf[1] = 1;\n\tfor (int i = 2; i < MN; i++) {\n\t\tinv[i] = 1ll * inv[MOD % i] * (MOD - MOD / i) % MOD;\n\t\tfict[i] = 1ll * fict[i - 1] * i % MOD;\n\t\tinvf[i] = 1ll * invf[i - 1] * inv[i] % MOD;\n\t}\n}\n\nint chose(int a, int b) {\n\treturn 1ll * fict[a] * invf[b] % MOD * invf[a - b] % MOD;\n}\n\nint main() {\n\tfact();\n\tint n, k;\n\tcin >> n >> k;\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 0; j <= n; j++)\n\t\t\t\tdp[i][j] = ((i >= j? dp[i - 1][j]: 0) + (i >= j && j? 1ll * dp[i][j - 1] * chose(n * k - (j - 1) * (k - 1) - i - 1, k - 2) % MOD: 0)) % MOD;\n\n\tcout << 1ll * dp[n][n] * fict[n] % mod;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <set>\nconst int maxlongint=2147483647;\nconst long long mo=1e9+7;\t\nconst int N=2005;\nusing namespace std;\nint n,k;\nlong long f[N][N],jc[N*N],ny[N*N],ans;\nlong long poww(long long x,int y)\n{\n\tlong long s=1;\n\tfor(;y;y>>=1,x=x*x%mo)\n\t\tif(y&1) s=s*x%mo;\n\treturn s;\n}\nlong long C(int m,int n)\n{\n\tif(n>m) return 0;\n\treturn jc[m]*ny[n]%mo*ny[m-n]%mo;\n}\nint main()\n{\n\t//freopen(\"agc002f.in\",\"r\",stdin);\n\t//freopen(\"agc002f.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&k);\n\tif(k<=1)\n\t{\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tjc[0]=ny[0]=1;\n\tfor(int i=1;i<=n*k;i++) jc[i]=jc[i-1]*i%mo,ny[i]=poww(jc[i],mo-2);\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i;j>=0;j--)\n\t\t\tf[i][j]=(f[i][j]+f[i-1][j-1]*C(k*i-j-1,k-2)%mo+f[i][j+1])%mo;\n\tprintf(\"%lld\",f[n][0]*jc[n]%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 2005\n#define ll long long\n#define P 1000000007\nusing namespace std;\nint n,k,inv[N*N],fac[N*N],ifac[N*N],dp[N][N];\nint Get(int x,int y)\n{\n\treturn (ll)fac[x+y]*ifac[x]%P*ifac[y]%P;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tif (k==1)\n\t{\n\t\tprintf(\"%d\\n\",1);\n\t\treturn 0;\n\t}\n\tinv[1]=fac[0]=fac[1]=ifac[0]=ifac[1]=1;\n\tfor (int i=2;i<=n*k;i++)\n\t{\n\t\tinv[i]=(ll)(-P/i)*inv[P%i]%P;\n\t\tfac[i]=(ll)fac[i-1]*i%P;\n\t\tifac[i]=(ll)ifac[i-1]*inv[i]%P;\n\t}\n\tdp[n+1][n+1]=1;\n\tfor (int i=n+1;i>=1;i--)\n\t{\n\t\tfor (int j=i;j>=1;j--)\n\t\t{\n\t\t\tif (i+j==n*2+2) continue;\n\t\t\tdp[i][j]=(dp[i+1][j]+(ll)dp[i][j+1]*Get((n-j)*(k-1)+n-i+1,k-2)%P)%P;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",((ll)dp[1][1]*fac[n]%P+P)%P);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nstruct Combi\n{\n\tvector<int> fact;\n\tvector<int> ifact;\n\tvector<int> inv;\n\tvector<int> pow2;\n\tconst int MOD = (1e9 + 7);\n\tint add(int a, int b)\n\t{\n\t\ta+=b;\n\t\twhile(a>=MOD) a-=MOD;\n\t\treturn a;\n\t}\n\tint mult(int a, int b)\n\t{\n\t\treturn (a*1LL*b)%MOD;\n\t}\n\tint modpow(int a, int b)\n\t{\n\t\tint r=1;\n\t\twhile(b)\n\t\t{\n\t\t\tif(b&1) r=mult(r,a);\n\t\t\ta=mult(a,a);\n\t\t\tb>>=1;\n\t\t}\n\t\treturn r;\n\t}\n\tint choose(int a, int b)\n\t{\n\t\tif(a<b) return 0;\n\t\tif(b==0) return 1;\n\t\tif(a==b) return 1;\n\t\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n\t}\n\tint inverse(int a)\n\t{\n\t\treturn modpow(a,MOD-2);\n\t}\n\tvoid init(int _n)\n\t{\n\t\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear();\n\t\tfact.resize(_n+1);\n\t\tifact.resize(_n+1);\n\t\tinv.resize(_n+1);\n\t\tpow2.resize(_n+1);\n\t\tpow2[0]=1;\n\t\tifact[0]=1;\n\t\tfact[0]=1;\n\t\tfor(int i=1;i<=_n;i++)\n\t\t{\n\t\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\t\tfact[i]=mult(fact[i-1],i);\n\t\t}\n\t\tifact[_n] = inverse(fact[_n]);\n\t\tfor(int i=_n-1;i>=1;i--)\n\t\t{\n\t\t    ifact[i] = mult(ifact[i + 1], i + 1);\n\t\t}\n\t\tfor(int i=1;i<=_n;i++)\n\t\t{\n\t\t    inv[i] = mult(fact[i-1],ifact[i]);\n\t\t}\n\t}\n};\n\nint dp[2005][2005];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tCombi combi;\n\tcombi.init(4001001);\n\tint n,k; cin>>n>>k;\n\tif(k==1){cout<<1<<'\\n'; return 0;}\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\tif(j>0) dp[i][j]=combi.add(dp[i][j],combi.mult(dp[i][j-1],combi.choose((n-j+1)*k-(i-j+1)-1,k-2)));\n\t\t}\n\t}\n\tcout<<combi.mult(dp[n][n],combi.fact[n])<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define f first \n#define s second \n#define pb push_back               \n#define mp make_pair \n\nusing namespace std;                    \n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\n\nconst int N = (int)5e6 + 123, mod = (int)1e9 + 7;\n\nll dp[2500][2500], f[N], rf[N], n, k;\nvoid add(ll &a, ll b){\n\ta += b;\n\tif(a >= mod)\n\t\ta -= mod;\n}\nll binpow(ll x,ll p){\n\tll res = 1;\n\twhile(p){\n\t\tif(p&1)\n\t\t\tres = res * x % mod;\n\t\tx = x * x % mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\nll C(int k,int n){\n\treturn f[n] * rf[k] % mod * rf[n - k] % mod;\n}\nint main(){    \n\tf[0] = 1;\n\tfor(int i = 1; i < N; i++)\n\t\tf[i] = 1ll * f[i - 1] * i % mod;\n\trf[N - 1] = binpow(f[N - 1], mod - 2);\n\tfor(int i = N - 2; i >= 0; i--)\n\t\trf[i] = 1ll * rf[i + 1] * (i + 1) % mod;\n\t\n\tcin >> n >> k;\n\t\n\tdp[0][0] = 1;\n\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\tadd(dp[i + 1][j], dp[i][j]);\n\t\t\tif(j < i)\n            \tadd(dp[i][j + 1], 1ll *  dp[i][j] * C(k - 2, (n - j) * (k - 1) + n - i - 1) % mod );\n\t\t//\tcerr << dp[i][j] << \" \";\n\t\t}\n\t\t//cerr << endl;\n\t}\n\n\tcout << dp[n][n] * f[n] % mod << endl;\n\treturn 0;\n}\n                     "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define cerr if (false) cerr\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntemplate <typename A, typename B>\nostream& operator<<(ostream& os, const pair<A, B>& x) {\n\treturn os << \"(\" << x.first << \",\" << x.second << \")\";\n}\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nstruct Mint {\n\tint val;\n\tMint() { val = 0; }\n\tMint(const ll& x) {\n\t\tval = (-MOD <= x && x < MOD) ? x : x % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\tfriend bool operator==(const Mint& a, const Mint& b) { return a.val == b.val; }\n\tfriend bool operator!=(const Mint& a, const Mint& b) { return !(a == b); }\n\tfriend bool operator<(const Mint& a, const Mint& b) { return a.val < b.val; }\n\tMint& operator+=(const Mint& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tMint& operator-=(const Mint& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tMint& operator*=(const Mint& m) { val = (ll)val * m.val % MOD; return *this; }\n\tfriend Mint modex(Mint a, ll p) {\n\t\tassert(p >= 0);\n\t\tMint ans = 1;\n\t\tfor (; p; p >>= 1, a *= a) if (p & 1) ans *= a;\n\t\treturn ans;\n\t}\n\tMint& operator/=(const Mint& m) { return *this *= modex(m, MOD - 2); }\n\tMint& operator++() { return *this += 1; }\n\tMint& operator--() { return *this -= 1; }\n\tMint operator++(int) { Mint result(*this); *this += 1; return result; }\n\tMint operator--(int) { Mint result(*this); *this -= 1; return result; }\n\tMint operator-() const { return Mint(-val); }\n\tfriend Mint operator+(Mint a, const Mint& b) { return a += b; }\n\tfriend Mint operator-(Mint a, const Mint& b) { return a -= b; }\n\tfriend Mint operator*(Mint a, const Mint& b) { return a *= b; }\n\tfriend Mint operator/(Mint a, const Mint& b) { return a /= b; }\n\tfriend ostream& operator<<(ostream& os, const Mint& x) { return os << x.val; }\n};\nMint dp[2005][2005];\nconst int MAXN = 4000005;\nMint fac[MAXN], invfac[MAXN];\nMint binom(ll a, ll b) {\n\tif (b < 0) return 0;\n\tif (b > a) return 0;\n\treturn fac[a] * invfac[b] * invfac[a - b];\n}\nint main() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < MAXN; ++i)\n\t\tfac[i] = fac[i - 1] * i;\n\tinvfac[MAXN - 1] = 1 / fac[MAXN - 1];\n\tfor (int i = MAXN - 2; i >= 0; --i)\n\t\tinvfac[i] = invfac[i + 1] * (i + 1);\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tif (k == 1) {\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 0; i <= n; ++i)\n\t\tfor (int j = i; j <= n; ++j) {\n\t\t\tif (!i && !j) continue;\n\t\t\tif (i) dp[i][j] = dp[i - 1][j];\n\t\t\tif (j > i) {\n\t\t\t\tdp[i][j] += dp[i][j - 1] * binom(i + j * (k - 1) - 1, k - 2);\n\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\", (dp[n][n] * fac[n]).val);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<cmath>\n#include<iostream>\n#include<queue>\n#include<string>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<long long,long long> pll;\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define rep(i,j,k)  for(register int i=(int)(j);i<=(int)(k);i++)\n#define rrep(i,j,k) for(register int i=(int)(j);i>=(int)(k);i--)\n\nll read(){\n\tll x=0,f=1;char c=getchar();\n\twhile(c<'0' || c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0' && c<='9'){x=x*10+c-'0';c=getchar();}\n\treturn x*f;\n}\n\nconst int mod=1e9+7;\nconst int maxn=3050;\nint n,k;\nll f[maxn][maxn];\nll fac[maxn*maxn],inv[maxn*maxn];\n\ninline int C(int x,int y){\n\tif(x<y) return 0;\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\n\nint main(){\n\tn=read(),k=read();\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\trep(i,1,5000*4000) fac[i]=fac[i-1]*i%mod;\n\tinv[0]=inv[1]=1;\n\trep(i,2,5000*4000) inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\trep(i,1,5000*4000) inv[i]=inv[i]*inv[i-1]%mod;\n\tf[0][0]=1;\n\trep(i,1,n){\n\t\trrep(j,i,0){\n\t\t\tf[i][j]=f[i][j+1]%mod;\n\t\t\tif(j){\n\t\t\t\tf[i][j]+=f[i-1][j-1]*C(i*k-j-1,k-2)%mod;\n\t\t\t\tf[i][j]%=mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<f[n][0]*fac[n]%mod;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n#define debug(x) cout << #x << \": \" << x << endl\n#else\n#define debug(x)\n#endif\nusing namespace std;\ntypedef long long ll;\nconst int maxn=4e6+7;\nconst int inf=0x3f3f3f3f;\nconst int mod=1e9+7;\n\nll quick(ll x,ll n)\n{\n    ll res=1;\n    while(n)\n    {\n        if(n&1) res=(res*x)%mod;\n        x=x*x%mod;\n        n>>=1;\n    }\n    return res;\n}\nll inv(ll x) {return quick(x,mod-2);}\n\nll fac[maxn],invfac[maxn];\nvoid init()\n{\n    fac[0]=1;\n    for(int i=1;i<maxn;++i) fac[i]=(fac[i-1]*i)%mod;\n    invfac[maxn-1]=inv(fac[maxn-1]);\n    for(int i=maxn-2;i>=0;--i) invfac[i]=(invfac[i+1]*(i+1))%mod;\n}\n\nll C(int n,int m)\n{\n    return fac[n]*invfac[m]%mod*invfac[n-m]%mod;\n}\n\nll dp[2007][2007];\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    init();\n    int n,k;\n    cin>>n>>k;\n    if(k==1) cout<<1<<endl;\n    else\n    {\n        dp[0][0]=1;\n        for(int i=1;i<=n;++i)\n        {\n            for(int j=0;j<=i;++j)\n            {\n                if(j==0) dp[i][j]=1;\n                else\n                {\n                    assert(n*k-i-(j-1)*(k-1)-1>=k-2);\n                    dp[i][j]=(dp[i-1][j]+1ll*dp[i][j-1]*(n-j+1)%mod*C(n*k-i-(j-1)*(k-1)-1,k-2)%mod)%mod;\n                }\n            }\n        }\n        cout<<dp[n][n]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst int MOD=1e9+7;\nint pw(int n,int k){\n  assert(k>=0);\n  int res=1;\n  while(k){\n    if(k&1)(res*=n)%=MOD;\n    (n*=n)%=MOD;\n    k>>=1;\n  }\n  return res;\n}\nstd::vector<int> Factorial(5e6),Finverse(5e6);\ninline void Cinit(){// limit is 5e6 /// write pw /// this takes 792ms at AtCoder\n  Factorial[0]=1;\n  for(int i=1;i<5e6;i++)Factorial[i]=(Factorial[i-1]*i)%MOD;\n  for(int i=0;i<5e6;i++)Finverse[i]=pw(Factorial[i],MOD-2);\n}\nint nCk(int n,int k){\n  if(n<k)return 0;if(k<0)return 0;\n  if(!Factorial[0])Cinit();\n  int res=Factorial[n];\n  (res*=Finverse[k])%=MOD;\n  (res*=Finverse[n-k])%=MOD;\n  return res;\n}\n\nint dp[2100][2100];//dp[i][j]:ボールをi色置き終わってj個0の場所の予約してる状態\n\nsigned main(){\n  int n,K;cin>>n>>K;\n  if(K==1){cout<<1<<endl;return 0;}\n  dp[0][0]=1;\n  for(int i=0;i<n;i++){\n    int col=n-i;\n    int res=n*K-i*K-1;\n    /*\n    for(int j=0;j<=n-i;j++)\n      for(int k=0;j+k<=n-i;k++)\n        dp[i+1][max(j-1,0LL)+k]+=dp[i][j]*nCk(res-(max(j-1,0LL)+k)-1,K-2)%MOD;\n    */\n    for(int k=0;k<=n-i;k++)dp[i+1][k]+=dp[i][0]*nCk(res-k-1,K-2)%MOD;\n    int now=0;\n    for(int A=0;A<=n-i+2;A++){\n      (now+=dp[i][A+1])%=MOD;\n      (dp[i+1][A]+=nCk(res-A-1,K-2)*now%MOD)%=MOD;\n    }\n    for(int j=0;j<=2000;j++)(dp[i+1][j]*=col)%=MOD;\n  }\n  cout<<dp[n][0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN=2005,MAXL=MAXN*MAXN*2-3,mod=1e9+7;\nint N,K;\nll fac[MAXN*MAXN*4],inv[MAXN*MAXN*4];\nll C(ll n,ll m) {\n//\tprintf(\"C(%lld,%lld)\\n\",n,m);\n\tif(n<0||m<0||n<m) return 0;\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nll f[MAXN][MAXN];\nint main() {\n\tscanf(\"%d%d\",&N,&K);\n\tfac[0]=inv[0]=inv[1]=1;\n\tfor(int i=1;i<=MAXL;++i) fac[i]=fac[i-1]*i%mod;\n\tfor(int i=2;i<=MAXL;++i) inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=1;i<=MAXL;++i) inv[i]=inv[i]*inv[i-1]%mod;\n\t//printf(\"%lld\\n\",C(5,3));\n\tif(K<2) {\n\t\tcout<<1<<endl;\n\t\texit(0);\n\t}\n\tf[0][0]=1;\n\tfor(int i=1;i<=N;++i) {\n\t\tfor(int j=0;j<=i;++j) {\n\t\t\tif(i==j) {\n\t\t\t\tf[i][j]=f[i][j-1]*C( N*K-i-(j-1)*(K-1)-1 ,K-2)%mod;\n\t\t\t} else {\n\t\t\t\tf[i][j]=(f[i-1][j]+f[i][j-1]*C( N*K-i-(j-1)*(K-1)-1 ,K-2)%mod)%mod;\n\t\t\t}\n\t\t\t//printf(\"f[%d][%d]=%lld\\n\",i,j,f[i][j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[N][N]*fac[N]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nconst int mod = 1e9+7;\nint ad(int x,int y) { x+=y; return x>=mod?x-mod:x; }\nint sb(int x,int y) { x-=y; return x<0?x+mod:x; }\nint mu(int x,int y) { return 1ll*x*y%mod; }\nint ksm(int a,int b) {\n\tint ans = 1;\n\tfor(;b;b>>=1,a=mu(a,a))\n\t\tif(b&1) ans = mu(ans,a);\n\treturn ans;\n}\nint fac[4000005],piv[4000005],n,k;\nint GC(int a,int b) {\n\tif(a<b) return 0;\n\treturn mu(fac[a],mu(piv[b],piv[a-b]));\n}\nint f[2005][2005];\nint main() {\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1) {\n\t\tputs(\"1\"); return 0;\n\t}\n\tfac[0] = 1;\n\tfor(int i=1;i<=n*k;i++) fac[i] = mu(fac[i-1],i);\n\tpiv[n*k] = ksm(fac[n*k],mod-2);\n\tfor(int i=n*k-1;i>=0;i--) piv[i] = mu(piv[i+1],i+1);\n\tf[0][0] = 1;\n\tfor(int i=1;i<=n;i++) {\n\t\tf[i][0] = 1;\n\t\tfor(int j=1;j<=i;j++) {\n\t\t\tf[i][j] = ad(f[i-1][j],mu(GC((n-i)+(n-j+1)*(k-1)-1,k-2),mu(f[i][j-1],n-j+1)));\n\t\t}\n\t}\n\tprintf(\"%d\",f[n][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ll long long\n#define N 3010\n#define mo 1000000007ll\nll jc[N*N],ijc[N*N],f[N][N];\nint n,k;\nll qp(ll x,ll y){\n\tll r=1;\n\tfor(;y;y>>=1,x=x*x%mo)\n\t\tif(y&1)r=r*x%mo;\n\treturn r;\n}\nll c(ll y,ll x){return jc[y]*ijc[x]%mo*ijc[y-x]%mo;}\nsigned main(){\n\tjc[0]=ijc[0]=1;\n\tfor(ll i=1;i<N*N;i++)jc[i]=jc[i-1]*i%mo;\n\tijc[N*N-1]=qp(jc[N*N-1],mo-2);\n\tfor(ll i=N*N-2;i;i--)ijc[i]=ijc[i+1]*(i+1ll)%mo;\n\tcin>>n>>k;\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(j)f[i][j]=(f[i][j]+f[i][j-1]*(n-j+1)%mo*c(n*k-i-(j-1)*(k-1)-1,k-2)%mo)%mo;\n\t\t}\n\tcout<<f[n][n];\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std; \nint n,k,ans,dp[2001][2001],a[4000001],b[4000001],mod=1e9+7;\ninline int read()\n{\n    int sum=0,x=1;\n    char ch=getchar();\n    while (!isdigit(ch))\n\t{\n        if (ch=='-')\n\t\t  x=-1;\n        ch=getchar();\n    }\n    while (isdigit(ch))\n\t{\n        sum=(sum<<1)+(sum<<3)+(ch^'0');\n        ch=getchar();\n    }\n    return sum*x;\n}\ninline void write(int x)\n{\n    if (x<0)\n\t{\n        putchar('-');\n        x=-x;\n    }  \n    if (x>9)\n      write(x/10);\n    putchar(x%10+'0');\n}\ninline int sr(int x,int y)\n{\n    if (y>x)\n\t  return 0;\n    return a[x]*b[y]%mod*b[x-y]%mod;\n}\ninline int power(int x,int y)\n{\n    int s=1;\n    for (;y;y>>=1,x=x*x%mod)\n      if (y&1)\n\t\ts=s*x%mod;\n    return s;\n}\nsigned main()\n{\n    n=read();k=read();\n    if (k<2)\n    {\n        write(1);\n        return 0;\n    }\n    a[0]=b[0]=1;\n    for (register int i=1;i<=n*k;++i)\n    {\n    \ta[i]=a[i-1]*i%mod;\n\t\tb[i]=power(a[i],mod-2);\n\t}\n    dp[0][0]=1;\n    for (register int i=1;i<=n;++i)\n      for (register int j=i;j>=0;--j)\n        dp[i][j]=(dp[i][j]+dp[i-1][j-1]*sr(k*i-j-1,k-2)+dp[i][j+1])%mod;\n    write(dp[n][0]*a[n]%mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int mod = 1e9 + 7;\n\nint n,k;\nint dp[2050][2050];\n\nint fac[4000050],inv[4000050];\nint ksm(int x,int y){\n    int z = 1;\n    while(y){\n        if(y & 1) z = z * x % mod;\n        y >>= 1;\n        x = x * x % mod;\n    }\n    return z;\n}\nint C(int n,int m){\n    if(n < m || m < 0) return 0;\n    if(n == m || m == 0) return 1;\n    return (fac[n] * inv[m] % mod) * inv[n - m] % mod;\n}\n\nsigned main(){\n    scanf(\"%lld%lld\",&n,&k);\n    \n    fac[0] = 1;\n    for(int i = 1; i <= 4000000; ++ i) fac[i] = fac[i - 1] * i % mod;\n    inv[4000000] = ksm(fac[4000000],mod - 2);\n    for(int i = 3999999; i >= 0; -- i) inv[i] = inv[i + 1] * (i + 1) % mod;\n    \n    dp[0][0] = 1;\n    for(int i = 1; i <= n; ++ i){\n        dp[i][0] = 1;\n        for(int j = 1; j <= i; ++ j){\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] * C(n * k - i - (j - 1) * (k - 1) - 1, k - 2) % mod * (n - j + 1) % mod ) % mod; \n        }\n    }\n    \n    printf(\"%lld\\n\",dp[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nllint n, k;\nllint dp[2005][2005];\n\nconst int FACT_MAX = 4000005;\nllint fact[FACT_MAX], fact_inv[FACT_MAX];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < FACT_MAX; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfact_inv[FACT_MAX-1] = modpow(fact[FACT_MAX-1], mod-2);\n\tfor(int i = FACT_MAX-2; i >= 0; i--){\n\t\tfact_inv[i] = fact_inv[i+1] * (i+1) % mod;\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> n >> k;\n\tmake_fact();\n\tif(k == 1){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tdp[1][1] = 1;\n\tfor(int i = 1; i < n; i++){\n\t\tllint sum = 0;\n\t\tfor(int j = i; j >= 0; j--){\n\t\t\tsum += dp[i][j], sum %= mod;\n\t\t\tdp[i+1][j+1] = sum * comb(i*k-j+k-2, k-2) % mod, dp[i+1][j+1] %= mod;\n\t\t}\n\t}\n\t\n\tllint ans = 0;\n\tfor(int i = 1; i <= n; i++) ans += dp[n][i], ans %= mod;\n\tans *= fact[n], ans %= mod;\n\tcout << ans << endl;\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std ;\n#define int unsigned long long\nconst int mxn = 8000005 ;\nconst int Mod = 1e9+7 ;\nint frac[mxn], inv[mxn];\nint f[2005][2005], n, k;\n/*\n设f(i,j)表示在这些位置上已经放了i个白球，j种其他颜色的球。(i<j)\nf(i,j) = f(i-1, j)+f(i ,j-1)*(n-j+1)*C(k-2, n*k-i-(j-1)*(k-1)-1)\n*/\nint power(int a, int b){\n\tint res=1, car=a; \n\twhile(b){\n\t\tif(b&1) (res*=car)%=Mod;\n\t\t(car*=car)%=Mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nvoid init(){\n\tfrac[0]=1 ;\n\tfor(int i=1;i<mxn;++i) (frac[i]=frac[i-1]*i)%=Mod ;\n\tinv[mxn-1] = power(frac[mxn-1], Mod-2);\n\tfor(int i=mxn-2;i>0;--i) inv[i]=(inv[i+1]*(i+1))%Mod ;\n\tinv[0] = 1 ;\n}\nint C(int n, int k){\n\treturn ((frac[n]*inv[k]%Mod)*inv[n-k])%Mod ;\n}\nsigned main(){\n\tinit() ;\n\tcin>>n>>k;\n\tif(k==1) return puts(\"1\"),0 ;\n\tf[0][0] = 1 ;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<=i;++j)\n\t\t\t(f[i][j] = f[i-1][j]+(j?((((f[i][j-1]*(n-j+1))%Mod)*C(n*k-i-(j-1)*(k-1)-1, k-2))%Mod):(0)))%=Mod ;\n\tcout<<f[n][n]<<endl ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#define int long long\n#define N 8005\nusing namespace std;\nconst int mod=1e9+7;\nint n,k,f[N][N],jc[N],invjc[N];\nint power(int x,int y)\n{\n\tint ans=1;\n\tfor (;y;y>>=1,x=1LL*x*x%mod)\n\t{\n\t\tif (y&1) ans=1LL*ans*x%mod;\n\t}\n\treturn ans;\n}\nvoid init()\n{\n\tjc[0]=1;\n\tfor (int i=1;i<N;i++) jc[i]=1LL*jc[i-1]*i%mod;\n\tinvjc[N-1]=power(jc[N-1],mod-2);\n\tfor (int i=N-2;i>=0;i--) invjc[i]=1LL*invjc[i+1]*(i+1)%mod;\n}\nint C(int n,int m)\n{\n//\tcout<<\"!!!\"<<n<<\"!!!\"<<m<<\" \"<<jc[n]<<\" \"<<invjc[m]<<\" \"<<invjc[n-m]<<endl;\n\treturn 1LL*jc[n]*invjc[m]%mod*invjc[n-m]%mod;\n}\nsigned main()\n{\n\tinit();\n\tscanf(\"%d%d\",&n,&k);\n\tif (k==1)\n\t{\n\t\tprintf(\"%d\\n\",1);\n\t\treturn 0;\n\t}\n\tf[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=0;j<=i;j++)\n\t\t{\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif (!j) continue;\n\t\t\t(f[i][j]+=1LL*f[i][j-1]*(n-j+1)%mod*C(n*k-i+(n-j+1)*(k-1)-1,k-2)%mod)%=mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#define VIZ2 {printf(\"graph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) if(vb[e]>=i)printf(\"%d--%d;\\n\",i,vb[e]); puts(\"}\");}\n#define SZ 4444444\nint n,k,f[2015][2015];\nconst int MOD=1e9+7;\nll fac[SZ],rfac[SZ];\nll qp(ll a,ll b)\n{\n\tll x=1; a%=MOD;\n\twhile(b)\n\t{\n\t\tif(b&1) x=x*a%MOD;\n\t\ta=a*a%MOD; b>>=1;\n\t}\n\treturn x;\n}\nll C(ll a,ll b)\n{\n\tif(b>a||b<0) return 0;\n\treturn fac[a]*rfac[a-b]%MOD*rfac[b]%MOD;\n}\nint main()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<SZ;++i)\n\t\tfac[i]=fac[i-1]*i%MOD;\n\trfac[SZ-1]=qp(fac[SZ-1],MOD-2);\n\tfor(int i=SZ-1;i>=1;--i)\n\t\trfac[i-1]=rfac[i]*i%MOD;\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\t--k; f[0][0]=1;\n\tfor(int j=1;j<=n;++j)\n\t\tf[0][j]=C(j*k-1,k-1)*f[0][j-1]%MOD;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tf[i][i]=f[i-1][i];\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t{\n\t\t\tf[i][j]=(f[i-1][j]+C(\n\t\t\ti+j*k-1,k-1)*f[i][j-1])%MOD;\n\t\t}\n\t}\n\tll ans=f[n][n];\n\tfor(int i=1;i<=n;++i) ans=ans*i%MOD;\n\tans=(ans%MOD+MOD)%MOD;\n\tprintf(\"%d\\n\",int(ans));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define gc getchar\n#define pc putchar\ninline ll rd(){\n    ll x=0,f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid writeln(ll x){write(x);puts(\"\");}\nconst int mod = 1e9+7;\nconst int maxn = 2099;\nint dp[maxn][maxn],fac[maxn*maxn],inv[maxn*maxn],n,k;\ninline int C(int n,int m){\n\treturn 1ll * fac[n] * inv[m] % mod * inv[n-m] % mod;\n}\ninline int qpow(int a,int b){\n\tint ans = 1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1)ans=1ll*ans*a%mod;\n\treturn ans; \n}\nint main(){\n\tn = rd(),k = rd();\n\tif(k==1){puts(\"1\");return 0;}\n\tfac[0] = 1;\n\tRep(i,1,2002*2002) fac[i] = 1ll * fac[i-1] * i % mod;\n\tinv[2002*2002] = qpow(fac[2002*2002],mod-2);\n\tDep(i,2002*2002-1,0) inv[i] = 1ll * inv[i+1] * (i+1) % mod;\n\tdp[0][1] = 1;\n\tRep(i,2,n){\n\t\tdp[0][i] = 1ll * dp[0][i-1] * C((i-1)*(k-1) + k-2,k-2) % mod;\n\t\t//n插入m \n\t}\n\tRep(i,1,n){\n\t\tRep(j,i,n){\n\t\t\tdp[i][j] = (dp[i-1][j] +\n\t\t\t1ll * dp[i][j-1] * C(i+(j-1)*(k-1)+k-2,k-2) % mod) % mod;\n\t\t}\n\t}\n\twriteln(1ll * dp[n][n] * fac[n] % mod);\n\treturn 0;\n}\n//n+1个空 \n//a1 + a2 + a3 …… an + a[n+1] = m\n//(a1+1) + (a2+1) + (a3+1) + …… = m + n + 1"
  },
  {
    "language": "C++",
    "code": "/*\n设f[i][j]表示当前有i个白球，一共放完了j种球\n显然有j <= i\n* 放白球 从f[i-1][j]转移\n* 放没有出现过的球 (n - j + 1) * f[i][j - 1] * C(k - 2, n * k - i - (j - 1) * (k - 1) - 1)\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 2020;\nconst int mod = 1e9 + 7;\n\nint inv[N * N], fac[N * N];\nint f[N][N];\nint n, k;\n\nint power(int a, int b) {\n\tint ans = 1;\n\twhile(b) {\n\t\tif(b & 1) ans = 1ll * ans * a % mod;\n\t\ta = 1ll * a * a % mod; b >>= 1;\n\t}\n\treturn ans;\n}\n\nint C(int n, int m) {\n\treturn 1ll * fac[m] * inv[n] % mod * inv[m - n] % mod;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tfac[0] = 1;\n\tfor(int i = 1; i < N * N; ++i) \n\t\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\tfor(int i = 0; i < N * N; ++i) \n\t\tinv[i] = power(fac[i], mod - 2);\n\tfor(int i = 1; i <= n; ++i) f[i][0] = 1;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tfor(int j = 1; j <= i; ++j) {\n\t\t\tf[i][j] = f[i - 1][j];\n\t\t\t(f[i][j] += 1ll * (n - j + 1) * f[i][j - 1] % mod * C(k - 2, n * k - i - (j - 1) * (k - 1) - 1) % mod) %= mod;\n\t\t\t(f[i][j] += mod) %= mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", (f[n][n] % mod + mod) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <bitset>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <string>\n \nusing namespace std;\ntypedef long long ll;\n \n#define ALL(obj) (obj).begin(), (obj).end() \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\n\n#define MOD 1000000007\n\nll fact[4040404], frev[4040404];\nll invs[4040404];\n\nll comb(int n, int k)\n{\n\tif (n < k) return 0;\n\treturn fact[n] * frev[k] % MOD * frev[n - k] % MOD;\n}\n\nvoid fill_combination_table(){\n\tfact[0] = 1; frev[0] = 1;\n\tinvs[0] = 1;\n\tinvs[1] = 1;\n\tfor (int i = 2; i < 4040404; ++i) invs[i] = MOD - MOD / i * invs[MOD % i] % MOD;\n\tfor (int i = 1; i < 4040404; ++i) {\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\tfrev[i] = frev[i - 1] * invs[i] % MOD;\n\t}\n}\n\nll dp[4040][2020];\n\nint main(){\n    ll n,k;\n    cin >> n >> k;\n    if(k==1){ cout << \"1\" << endl; return 0;}\n    dp[1][1] = 1;\n    dp[0][1] = 1;\n        fill_combination_table();\n    FOR(j,2,n+1){\n        dp[0][j] =  comb((j * (k - 1)) - 1, k - 2) * dp[0][j-1] % MOD;\n       // cout << \"comb n=\" << (j * (k - 1)) - 1 << \",k=\"<< k-1 <<\" : \"<<comb((j * (k - 1)) - 1, k - 2) << endl;\n        //cout << \"dp[0][\" << j <<\"] : \" << dp[0][j] << endl;\n    }\n\n    FOR(i,1,n+1){\n        FOR(j,i,n+1){\n            dp[i][j] =  (dp[i-1][j] + ((comb(i + (j * (k - 1)) - 1, k - 2) * dp[i][j-1]) % MOD)) % MOD ;\n         //   cout << \"comb n=\" << i + (j * (k - 1)) - 1 << \",k=\"<< k-1 <<\" : \"<<comb((j * (k - 1)) - 1, k - 2) << endl;\n        //    cout << \"dp[\"<< i << \"][\" << j <<\"] : \" << dp[i][j] << endl;\n        }\n    }\n    //cout << comb(3,1) << endl;\n    cout << (dp[n][n] * fact[n]) % MOD << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 2005, MOD = 1000000007;\ntypedef long long i64;\n\ni64 f[MAX_N][MAX_N], fac[MAX_N * MAX_N], ifac[MAX_N * MAX_N], inv[MAX_N * MAX_N];\n\ni64 binom(int x, int y) {\n  if (x < y) return 0;\n  return fac[x] * ifac[y] % MOD * ifac[x - y] % MOD;\n}\n\nint main() {\n  int N, K, tot;\n  \n  scanf(\"%d%d\", &N, &K), tot = N * K;\n  if (K == 1) {\n    printf(\"%d\\n\", 1);\n    return 0;\n  }\n  fac[0] = ifac[0] = inv[1] = 1;\n  \n  for (int i = 1; i <= tot; ++i) fac[i] = fac[i - 1] * i % MOD;\n  for (int i = 2; i <= tot; ++i) inv[i] = -(MOD / i) * inv[MOD % i] % MOD;\n  for (int i = 1; i <= tot; ++i) ifac[i] = ifac[i - 1] * inv[i] % MOD;\n\n  f[0][0] = 1;\n  for (int i = 0; i <= N; ++i)\n    for (int j = 0; j <= i; ++j) {\n      if (i > 0) f[i][j] = f[i - 1][j];\n      if (j > 0) f[i][j] = (f[i][j] + f[i][j - 1] * binom(N * K - i - (j - 1) * (K - 1) - 1, K - 2) % MOD) % MOD;\n    }\n\n  f[N][N] = f[N][N] * fac[N] % MOD;\n  printf(\"%lld\\n\", (f[N][N] + MOD) % MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nll read(){\n\tchar c=getchar();bool flag=0;ll x=0;\n\twhile(c<'0'||c>'9'){if(c=='-')flag=1;c=getchar();}\n\twhile(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}\n\treturn flag?-x:x;\n}\n#define N 2010 \nconst ll p=1e9+7;\nll dp[N][N],fac[N*N],inv[N*N];\nll fpow(ll a,ll x){\n\tll ans=1;\n\twhile(x){\n\t\tif(x&1) ans=ans*a%p;\n\t\ta=a*a%p,x=x/2; \n\t}\n\treturn ans;\n}\nll Cnt(ll n,ll m){\n\treturn fac[m]*inv[n]%p*inv[m-n]%p;\n}\nint main(){\n\tll n=read(),k=read();\n\tif(k==1){\n\t\tprintf(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\tfor(ll i=1;i<=n*k;i++) fac[i]=fac[i-1]*i%p;\n\tinv[n*k]=fpow(fac[n*k],p-2);\n\tfor(ll i=n*k-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%p;\n\tfor(ll i=1;i<=n;i++) dp[i][0]=1;\n\tfor(ll i=1;i<=n;i++){\n\t\tfor(ll j=1;j<=i;j++){\n\t\t\tdp[i][j]=dp[i-1][j]+dp[i][j-1]*(n-(j-1))%p*Cnt(k-2,n*k-i-(j-1)*(k-1)-1)%p;\n\t\t\tdp[i][j]%=p;\n\t\t}\n\t}\n\tprintf(\"%lld\",dp[n][n]); \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\ntemplate <typename Tp>\ninline void read(Tp &x) {\n    x = 0;\n    bool f = true; char ch = getchar();\n    for ( ; ch < '0' || ch > '9'; ch = getchar()) f ^= ch == '-';\n    for ( ; ch >= '0' && ch <= '9'; ch = getchar()) x = x * 10 + (ch ^ 48);\n    x = f ? x : -x;\n}\n\nconst int N = 2e3 + 7, M = 4e6 + 7, P = 1e9 + 7;\n\nint Dp[N][N], Fac[M], iFac[M];\n\ninline int Power(int a, int x) {\n    int res = 1;\n    while (x) {\n        if (x & 1) res = 1LL * res * a % P;\n        a = 1LL * a * a % P;\n        x >>= 1;\n    }\n    return res;\n}\n\ninline int Inv(int x) {\n    return Power(x, P - 2);\n}\n\ninline int C(int n, int m) {\n    if (m > n || m < 0) return 0;\n    return 1LL * Fac[n] * iFac[n - m] % P * iFac[m] % P;\n}\n\nint main() {\n    Fac[0] = 1;\n    for (int i = 1; i < M; ++i) Fac[i] = 1LL * Fac[i - 1] * i % P;\n    iFac[M - 1] = Inv(Fac[M - 1]);\n    for (int i = M - 2; i >= 0; --i) iFac[i] = 1LL * iFac[i + 1] * (i + 1) % P;\n    int n, k;\n    read(n), read(k);\n    if (k == 1) return printf(\"1\\n\"), 0;\n    for (int i = 0; i <= n; ++i) Dp[i][0] = 1;\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= i; ++j) Dp[i][j] = (Dp[i - 1][j] + 1LL * Dp[i][j - 1] * (n - j + 1) % P * C(n * k - i - (j - 1) * (k - 1) - 1, k - 2) % P) % P;\n    printf(\"%d\\n\", Dp[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n#define repd(i,x,y) for(int i=x; i>=y; --i)\n \nusing namespace std;\nconst int N=2005,mod=1000000007;\ntypedef long long LL;\nint n,k,c[N],ans;\nLL flv[N*N],inv[N*N],f[N][N];\n \nvoid dfs(int x,int tp)\n{\n    if(x>n*k) \n    {\n        ans=(ans+1)%mod;\n        return;\n    }\n    if(!tp) \n    {\n        if(c[0]) --c[0],dfs(x+1,tp+1),++c[0];\n        rep(i,1,n) if(c[i]!=k-1 && c[i]) --c[i],dfs(x+1,tp),++c[i];\n    }\n    else\n    {\n        if(c[0]) --c[0],dfs(x+1,tp+1),++c[0];\n        rep(i,1,n) if(c[i]) --c[i],dfs(x+1,tp-(c[i]==k-2)),++c[i];\n    }\n}\n \nvoid task1()\n{\n    c[0]=n;\n    rep(i,1,n) c[i]=k-1;\n    dfs(1,0);\n    printf(\"%d\\n\",ans);\n}\n \nLL getmi(LL a,int x)\n{\n    LL rt=1;\n    while(x)\n    {\n        if(x&1) rt=rt*a%mod;\n        a=a*a%mod,x>>=1;\n    }\n    return rt;\n}\n \nLL C(int n,int m)\n{\n    return n<m?0:flv[n]*inv[m]%mod*inv[n-m]%mod;\n}\n \nvoid inc(LL &x,int y)\n{\n    if((x+=y)>=mod) x-=mod;\n}\n \nvoid task2()\n{\n    flv[0]=1;\n    rep(i,1,n*k) flv[i]=flv[i-1]*i%mod;\n    inv[n*k]=getmi(flv[n*k],mod-2);\n    repd(i,n*k,1) inv[i-1]=inv[i]*i%mod;\n    f[0][0]=1;\n    rep(i,1,n)\n        rep(j,0,i)\n        {\n            f[i][j]=f[i-1][j];\n            if(j) f[i][j]=(f[i][j]+f[i][j-1]*C(n-i+(k-1)*(n-j+1)-1,k-2))%mod;\n        }\n    printf(\"%lld\\n\",flv[n]*f[n][n]%mod);\n}\n \nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    task2();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math,O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\n#define LL long long\n#define ULL unsigned long long\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define x first\n#define y second\n#define pi acos(-1)\n#define sqr(x) ((x)*(x))\n#define pdd pair<double,double>\n#define MEMS(x) memset(x,-1,sizeof(x))\n#define MEM(x) memset(x,0,sizeof(x))\n#define EPS 1e-4\n#define arg ARG\n#define cpdd const pdd\n#define rank Rank\n//#define MXN 300000\n#define N 100005\nint dp[2005][2005];\nint mod=1e9+7;\nLL fra[10000005];\nLL inv[10000005];\nLL f_pow(LL a,LL b){\n    LL res=1,temp=a;\n    while(b){\n        if(b&1)res=res*temp%mod;\n        temp=temp*temp%mod;\n        b>>=1;\n    }\n    return res;\n}\nvoid build(){\n    fra[0]=1;\n    for(int i = 1;i<10000005;i++)\n        fra[i]=fra[i-1]*i%mod;\n    inv[10000000]=f_pow(fra[10000000],mod-2);\n    for(int i = 9999999;i>=0;i--)\n        inv[i]=inv[i+1]*(i+1)%mod;\n}\nLL C(int a,int b){\n    return fra[a]*inv[b]%mod*inv[a-b]%mod;\n}\nint main(){\n    int n,k;\n    scanf(\"%d %d\",&n,&k);\n    if(k==1){\n        printf(\"1\\n\");\n        return 0;\n    }\n    build();\n    dp[0][0]=1;\n    for(int i = 1;i<=n;i++){\n        dp[0][i]=dp[0][i-1]*C(i*(k-1)-1,k-2)%mod*(n-i+1)%mod;\n        //printf(\"%d \",dp[0][i]);\n        for(int j=1;j<=i;j++){\n            dp[j][i]=(dp[j-1][i]+dp[j][i-1]*C(i*(k-1)+j-1,k-2)%mod*(n-i+1)%mod)%mod;\n           // printf(\"%d \",dp[j][i]);\n        }\n      //  printf(\"\\n\");\n        \n    }\n    printf(\"%d\\n\",dp[n][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rg register\nusing namespace std;\nconst int mod=1e9+7;\n#define _ 2001\nint n, k, f[_][_], sum[_*_], inv[_*_];\nint qp(int x, int y){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1)ans=1ll*ans*x%mod;\n\t\tx=1ll*x*x%mod, y>>=1;\n\t}return ans;\n}\nint C(int m, int r){return 1ll*sum[m]*inv[r]%mod*inv[m-r]%mod;}\nint main(){\n\tinv[0]=inv[1]=sum[0]=sum[1]=1;\n\tfor(rg int i=2; i<=2000*2000; ++i)\n\t\tsum[i]=1ll*sum[i-1]*i%mod, inv[i]=qp(sum[i], mod-2);\n\tscanf(\"%d%d\", &n, &k);\n\tif(k==1){puts(\"1\"); return 0;}\n\tf[0][0]=1;\n\tfor(int i=1; i<=n; ++i)\n\t\tfor(int j=0; j<=i; ++j){\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(j)(f[i][j]+=1ll*C((n-j+1)*(k-1)+n-i-1, k-2)*f[i][j-1]%mod)%=mod;\n\t\t}\n\tfor(int i=2; i<=n; ++i)\n\t\tf[n][n]=1ll*f[n][n]*i%mod;\n\tprintf(\"%d\", f[n][n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long llint;\n\nconst int MAXN = 2005;\nconst int MOD = 1000000007;\n\nllint n, k;\nllint dp[MAXN][MAXN], f[MAXN*MAXN], inv[MAXN*MAXN], r[MAXN*MAXN];\n\ninline llint add (llint x, llint y) {\n    x += y;\n    if (x >= MOD) return x - MOD; return x;\n}\n\nvoid precompute () {\n    f[0] = inv[0] = 1;\n    for (int i=1; i<n*k; i++) {\n        if (i == 1) r[i] = 1; else r[i] = (MOD - (MOD / i * r[MOD % i]) % MOD) % MOD;\n        f[i] = f[i-1] * i % MOD;\n        inv[i] = inv[i-1] * r[i] % MOD;\n    }\n}\n\nllint nck (llint n, llint k) {\n    return f[n] * inv[k] % MOD * inv[n-k] % MOD;\n}\n\nvoid calc () {\n    dp[1][1] = 1;\n    for (int i = 2; i <= n; i++) {\n        llint curr = 0;\n        for (int j = i; j >= 1; j--) {\n            if (j > 1) curr = add(curr, dp[i-1][j-1]);\n            dp[i][j] = curr * nck(k*i - j - 1, k-2) % MOD;\n            dp[i][0] = add(dp[i][0], dp[i][j]);\n        }\n    }\n}\n\nint main () {\n    cin >> n >> k;\n    if (k == 1) {\n        cout << 1;\n        return 0;\n    }\n    precompute();\n    calc();\n    cout << dp[n][0] * f[n] % MOD;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < int(n); ++ (i))\nusing ll = long long;\nusing namespace std;\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\nll powmod(ll x, ll y, ll m) {\n    assert (0 <= x and x < m);\n    assert (0 <= y);\n    ll z = 1;\n    for (ll i = 1; i <= y; i <<= 1) {\n        if (y & i) z = z * x % m;\n        x = x * x % m;\n    }\n    return z;\n}\nll modinv(ll x, ll p) {\n    assert (x % p != 0);\n    return powmod(x, p - 2, p);\n}\ntemplate <int32_t MOD>\nint32_t fact(int n) {\n    static vector<int32_t> memo(1, 1);\n    while (n >= memo.size()) {\n        memo.push_back(memo.back() *(int64_t) memo.size() % MOD);\n    }\n    return memo[n];\n}\ntemplate <int32_t PRIME>\nint32_t inv_fact(int n) {\n    static vector<int32_t> memo(1, 1);\n    while (n >= memo.size()) {\n        memo.push_back(memo.back() *(int64_t) modinv(memo.size(), PRIME) % PRIME);\n    }\n    return memo[n];\n}\ntemplate <int MOD>\nint choose(int n, int r) {\n    assert (0 <= r and r <= n);\n    return fact<MOD>(n) *(ll) inv_fact<MOD>(n - r) % MOD *(ll) inv_fact<MOD>(r) % MOD;\n}\n\nconstexpr int mod = 1e9 + 7;\nint solve(int n, int k) {\n    if (k == 1) return 1;\n    auto dp = vectors(n + 1, n + 1, int());\n    dp[0][0] = 1;\n    REP3 (i, 1, n + 1) {\n        REP (j, i + 1) {\n            if (i - 1 >= 0) {\n                dp[i][j] += dp[i - 1][j];\n            }\n            if (j - 1 >= 0) {\n                int remaining = (n - i) + (k - 1) * (n - (j - 1));\n                dp[i][j] += dp[i][j - 1] *(ll) choose<mod>(remaining - 1, k - 2) % mod;\n            }\n            if (dp[i][j] >= mod) dp[i][j] -= mod;\n        }\n    }\n    return dp[n][n] *(ll) fact<mod>(n) % mod;\n}\n\nint main() {\n    int n, k; cin >> n >> k;\n    cout << solve(n, k) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define IL inline\n#define RG register\n#define LL long long\n#define Upd(a) (a)>=mod?(a-=mod):1\nusing namespace std;\ntemplate <class T>\nIL char gc () {\n\tstatic char buf[1<<6], *p1=buf, *p2=buf;\n\treturn (p1==p2) && (p2=(p1=buf)+fread(buf,1,1<<6,stdin), p1==p2) ?EOF:*p1++;\n}\ntemplate <typename T>\nIL void read (T&data) {\n\tdata=0;\n\tRG char ch=0;\n\twhile (ch<'0' || ch>'9') ch=getchar();\n\twhile (ch<='9' && ch>='0') data=(data<<1)+(data<<3)+(ch&15), ch=getchar();\n}\nconst int mod = 1e9+7;\nconst int _ =2011;\nint n, k;\nLL dp[2][_], jc[_*_], jcn[_*_];\nIL int poww (RG int a, RG int b) {\n\tRG int ret=1, Base=a;\n\tfor (;b;b>>=1, Base=1LL*Base*Base%mod) if (b&1) ret=1LL*ret*Base%mod;\n\treturn ret;\n}\nIL int C (RG int a, RG int b) {\n\tif (a<b) return 0;\n\treturn jc[a]*jcn[b]%mod*jcn[a-b]%mod;\n}\nint main (/*int aa, int bb*/) {\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\t//n=aa, k=bb;\n\tread(n), read(k);\n\tif (k<=1) {puts(\"0\"); return 0;}\n\tjc[0]=jcn[0]=1;\n\tRG int i, j, pre=1, cur=0;\n\tfor (i=1; i<=n*k; ++i) jc[i]=jc[i-1]*i%mod, jcn[i]=poww(jc[i], mod-2);\n\tdp[0][0]=1;\n\tfor (i=1; i<=n*2; ++i) {\n\t\tswap(cur, pre);\n\t\tfor (j=0; j<min(i,n+1); ++j) dp[cur][j]=0;\n\t\tfor (j=1; j<=min(i,n); ++j) {\n\t\t\tif ((i-j)%2) continue;\n\t\t\tif (n*2-i+1<j) break;\n\t\t\tRG int a=(i+j-2)>>1, b=(i-j)>>1;\n\t\t\tdp[cur][j]=1LL*dp[pre][j-1]*C(a*(k-1)+b+k-1-1,k-1-1)%mod;\n\t\t\tdp[cur][j]+=dp[pre][j+1];\n\t\t\tUpd(dp[cur][j]);\n\t\t}\n\t\tif (cur%2==0) dp[cur][0]=dp[pre][1];\n\t}\n\t//return 1LL*dp[cur][0]*jc[n]%mod;\n\tprintf(\"%lld\",1LL*dp[cur][0]*jc[n]%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nconst int md=1e9+7;\nconst int maxm=4001000;\nconst int maxn=2001;\nint read(){\n\tint x=0,flag=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif (ch=='-') flag=-1,ch=getchar();\n\twhile(isdigit(ch)) x=(x<<3)+(x<<1)+(ch-'0'),ch=getchar();\n\treturn x*flag;\n}\nll fac[maxm],inv[maxm];\nll ksm(ll a,ll b){\n\tll res=1;\n\twhile(b){\n\t\tif (b&1) res=res*a%md;\n\t\ta=a*a%md;b>>=1;\n\t}\n\treturn res;\n}\nvoid init(int n){\n\tfac[0]=1;\n\tfor (int i=1;i<=n;++i)\n\t\tfac[i]=fac[i-1]*i%md;\n\tinv[n]=ksm(fac[n],md-2);\n\tfor (int i=n;i;--i)\n\t\tinv[i-1]=inv[i]*i%md;\n}\nll c(int n,int m){\n\treturn fac[n]*inv[m]%md*inv[n-m]%md;\n}\nint n,k,f[maxn][maxn];\nint main(){\n\tn=read(),k=read();\n\tif (k==1) return puts(\"1\"),0;\n\tinit(n*k);\n\tf[0][0]=1;\n\tfor (int i=1;i<=n;++i){\n\t\tfor (int j=0;j<=i;++j){\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif (!j) continue;\n\t\t\t(f[i][j]+=1ll*f[i][j-1]*(n-j+1)%md*\n\t\t\tc(n-i+(n-j+1)*(k-1)-1,k-2)%md)%=md;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[n][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\nll p=1000000007;\nll fac[4000010];\nll ifac[4000010];\nll inv[4000010];\nvoid init(int n)\n{\n    int i;\n    fac[0]=fac[1]=ifac[0]=ifac[1]=inv[0]=inv[1]=1;\n    for(i=2;i<=n;i++)\n    {\n        inv[i]=-(p/i)*inv[p%i]%p;\n        fac[i]=fac[i-1]*i%p;\n        ifac[i]=ifac[i-1]*inv[i]%p;\n    }\n}\nll c(int x,int y)\n{\n    if(x<y)\n        return 0;\n    return fac[x]*ifac[y]%p*ifac[x-y]%p;\n}\nll f[2010][2010];\nint main()\n{\n    int n,k;\n    scanf(\"%d%d\",&n,&k);\n    if(k<=1)\n    {\n        printf(\"1\\n\");\n        return 0;\n    }\n    init(n*k);\n    int i,j;\n    f[0][0]=1;\n    for(i=1;i<=n;i++)\n        for(j=n;j>=0;j--)\n        {\n            if(j<=i)\n                f[i][j]+=f[i-1][j-1]*c(k*i-j-1,k-2)%p;\n            f[i][j]=(f[i][j]+f[i][j+1])%p;\n        }\n    ll ans=(f[n][0]%p+p)%p;\n    ans=ans*fac[n]%p;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nstruct Combi\n{\n\tvector<int> fact;\n\tvector<int> ifact;\n\tvector<int> inv;\n\tvector<int> pow2;\n\tconst int MOD = (1e9 + 7);\n\tint add(int a, int b)\n\t{\n\t\ta+=b;\n\t\twhile(a>=MOD) a-=MOD;\n\t\treturn a;\n\t}\n\tint mult(int a, int b)\n\t{\n\t\treturn (a*1LL*b)%MOD;\n\t}\n\tint modpow(int a, int b)\n\t{\n\t\tint r=1;\n\t\twhile(b)\n\t\t{\n\t\t\tif(b&1) r=mult(r,a);\n\t\t\ta=mult(a,a);\n\t\t\tb>>=1;\n\t\t}\n\t\treturn r;\n\t}\n\tint choose(int a, int b)\n\t{\n\t\tif(a<b) return 0;\n\t\tif(b==0) return 1;\n\t\tif(a==b) return 1;\n\t\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n\t}\n\tint inverse(int a)\n\t{\n\t\treturn modpow(a,MOD-2);\n\t}\n\tvoid init(int _n)\n\t{\n\t\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear();\n\t\tfact.resize(_n+1);\n\t\tifact.resize(_n+1);\n\t\tinv.resize(_n+1);\n\t\tpow2.resize(_n+1);\n\t\tpow2[0]=1;\n\t\tifact[0]=1;\n\t\tfact[0]=1;\n\t\tfor(int i=1;i<=_n;i++)\n\t\t{\n\t\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\t\tfact[i]=mult(fact[i-1],i);\n\t\t}\n\t\tifact[_n] = inverse(fact[_n]);\n\t\tfor(int i=_n-1;i>=1;i--)\n\t\t{\n\t\t    ifact[i] = mult(ifact[i + 1], i + 1);\n\t\t}\n\t\tfor(int i=1;i<=_n;i++)\n\t\t{\n\t\t    inv[i] = mult(fact[i-1],ifact[i]);\n\t\t}\n\t}\n};\n\nint dp[2005][2005];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tCombi combi;\n\tcombi.init(4001001);\n\tint n,k; cin>>n>>k;\n\tif(k==1){cout<<1<<'\\n'; return 0;}\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\tif(j>0) dp[i][j]=combi.add(dp[i][j],combi.mult(dp[i][j-1],combi.choose((n-j+1)*k-(i-j+1)-1,k-2)));\n\t\t}\n\t}\n\tcout<<combi.mult(dp[n][n],combi.fact[n])<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n#define repd(i,x,y) for(int i=x; i>=y; --i)\n \nusing namespace std;\nconst int N=2005,mod=1000000007;\ntypedef long long LL;\nint n,k,c[N],ans;\nLL flv[N*N],inv[N*N],f[N][N];\n \nvoid dfs(int x,int tp)\n{\n    if(x>n*k) \n    {\n        ans=(ans+1)%mod;\n        return;\n    }\n    if(!tp) \n    {\n        if(c[0]) --c[0],dfs(x+1,tp+1),++c[0];\n        rep(i,1,n) if(c[i]!=k-1 && c[i]) --c[i],dfs(x+1,tp),++c[i];\n    }\n    else\n    {\n        if(c[0]) --c[0],dfs(x+1,tp+1),++c[0];\n        rep(i,1,n) if(c[i]) --c[i],dfs(x+1,tp-(c[i]==k-2)),++c[i];\n    }\n}\n \nvoid task1()\n{\n    c[0]=n;\n    rep(i,1,n) c[i]=k-1;\n    dfs(1,0);\n    printf(\"%d\\n\",ans);\n}\n \nLL getmi(LL a,int x)\n{\n    LL rt=1;\n    while(x)\n    {\n        if(x&1) rt=rt*a%mod;\n        a=a*a%mod,x>>=1;\n    }\n    return rt;\n}\n \nLL C(int n,int m)\n{\n    return n<m?0:flv[n]*inv[m]%mod*inv[n-m]%mod;\n}\n \nvoid inc(LL &x,int y)\n{\n    if((x+=y)>=mod) x-=mod;\n}\n \nvoid task2()\n{\n\tif(k==1) {puts(\"1\"); return;}\n    flv[0]=1;\n    rep(i,1,n*k) flv[i]=flv[i-1]*i%mod;\n    inv[n*k]=getmi(flv[n*k],mod-2);\n    repd(i,n*k,1) inv[i-1]=inv[i]*i%mod;\n    f[0][0]=1;\n    rep(i,1,n)\n        rep(j,0,i)\n        {\n            f[i][j]=f[i-1][j];\n            if(j) f[i][j]=(f[i][j]+f[i][j-1]*C(n-i+(k-1)*(n-j+1)-1,k-2))%mod;\n        }\n    printf(\"%lld\\n\",flv[n]*f[n][n]%mod);\n}\n \nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    task2();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int MAXN = 2000 + 10;\nconst int M = 1e7 + 10;\nconst int Mod = 1e9 + 7;\nint N, K;\nint fac[M], inv[M], ifc[M];\nint f[MAXN];\n\ninline void init(int n) {\n\tregister int i;\n\tfor( fac[0] = i = 1; i <= n; ++i ) fac[i] = 1ll * fac[i - 1] * i % Mod;\n\tfor( inv[1] = 1, i = 2; i <= n; ++i ) inv[i] = 1ll * (Mod - Mod / i) * inv[Mod % i] % Mod;\n\tfor( ifc[0] = ifc[1] = 1, i = 2; i <= n; ++i ) ifc[i] = 1ll * ifc[i - 1] * inv[i] % Mod;\n}\n\ninline int C(int n, int k) {\n\tif( n < 0 || k < 0 || n < k ) return 0;\n\treturn 1ll * fac[n] * ifc[k] % Mod * ifc[n - k] % Mod;\n}\n\nint main() {\n\tregister int i, j;\n\tscanf( \"%d%d\", &N, &K ); --K;\n\tif(!K) return 0 * puts(\"1\");\n\tinit(10000000); f[0] = 1;\n\tfor( i = 1; i <= N; ++i )\n\t\tfor( j = 1; j <= i; ++j )\n\t\t\tf[j] = (f[j] + 1ll * (N - j + 1) * C(N * K + N - i - (j - 1) * K - 1, K - 1) % Mod * f[j - 1]) % Mod;\n\tprintf( \"%d\\n\", f[N] );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int mo=1000000007;\nint dp[2005][2005],fac[4000005],inv[4000005];\n\nint ksm(int x,int y){\n\tint i=1;\n\tfor (;y;y>>=1,x=1ll*x*x%mo)\n\t\tif (y&1) i=1ll*i*x%mo;\n\treturn i;\n}\n\nvoid calc(int n){\n\tfac[0]=1;\n\tfor (int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mo;\n\tinv[n]=ksm(fac[n],mo-2);\n\tfor (int i=n;i>=1;i--) inv[i-1]=1ll*inv[i]*i%mo;\n}\n\nlong long C(int n,int m){\n\treturn 1ll*fac[n]*inv[m]%mo*inv[n-m]%mo;\n}\n\nint main(){\n\tint n,k;\n\tscanf(\"%d%d\",&n,&k);\n\tif (k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tcalc(n*k);\n\tdp[0][0]=1;\n\tfor (int i=0;i<=n;i++)\n\t\tfor (int j=i;j<=n;j++){\n\t\t\tif (i) dp[i][j]=dp[i-1][j];\n\t\t\tif (j) dp[i][j]=(dp[i][j]+dp[i][j-1]*C(i+j*(k-1)-1,k-2))%mo;\n\t\t}\n\tprintf(\"%lld\\n\",1ll*dp[n][n]*fac[n]%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\nconst int N=2010,Mod=1e9+7;\n\nint n,k,fact[N*N],inv[N*N],f[2*N][N];\n\nvoid Init() { scanf(\"%d%d\",&n,&k); }\n\nvoid Prepare()\n{\n\tfact[0]=1; for (int i=1;i<=n*k;++i) fact[i]=1ll*fact[i-1]*i%Mod;\n\tinv[0]=inv[1]=1; for (int i=2;i<=n*k;++i) inv[i]=1ll*(Mod-Mod/i)*inv[Mod%i]%Mod;\n\tfor (int i=1;i<=n*k;++i) inv[i]=1ll*inv[i-1]*inv[i]%Mod;\n}\n\nint Calc(int n,int m) { if (n<0 || n<m) return 0; return 1ll*fact[n]*inv[n-m]%Mod*inv[m]%Mod; }\n\nvoid Solve()\n{\n\tif (k==1) { printf(\"1\\n\"); return ; }\n\tPrepare();\n\tf[0][0]=1;\n\tfor (int i=0;i<2*n;++i)\n\t\tfor (int j=0;j<=i;++j)\n\t\t\tif (f[i][j])\n\t\t\t{\n\t\t\t\tif (j<n) f[i+1][j+1]=(f[i+1][j+1]+f[i][j])%Mod;\n\t\t\t\tif (j>0) f[i+1][j-1]=(f[i+1][j-1]+1ll*f[i][j]%Mod*Calc(n*k-(i-j)/2*k-j-1,k-2)%Mod)%Mod;\n\t\t\t}\n\tprintf(\"%lld\\n\",1ll*f[2*n][0]*n%Mod);\n}\n\nint main()\n{\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*vi:se ts=8 tw=8*/\n/*@author tangyida*/\n#include<bits/stdc++.h>\nconst int N = 2e3 + 3;\nconst long long MOD = 1e9 + 7;\nint n,k;\nlong long f[N][N],C[N][N];\n\ninline void pre()\n{\n\tfor(int i = 0;i < N;i++) C[i][i] = C[i][0] = 1;\n\tfor(int i = 1;i < N;i++) for(int j = i + 1;j < N;j++)\n\t\tC[j][i] = (C[j - 1][i - 1] + C[j - 1][i]) % MOD;\n}\nint main()\n{\n\tstd::cin >> n >> k;\n\n\tpre();\n\tf[0][0] = 1;\n\n\tfor(int i = 1;i <= n;i++) for(int j = 0;j <= i;j++) {\n\t\tf[i][j] = f[i - 1][j];\n\t\tif(!j) continue;\n\t\t(f[i][j] += f[i][j - 1] * (n - j + 1) * C[n * k - (k - 2)\n\t\t\t* (j - 1) - 1][k - 2]) %= MOD;/*FIXME*/\n\t}\n\tstd::cout << f[n][n];\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define RG register\n#define R RG int\nusing namespace std;\nconst LL N=2009,M=N*N,YL=1e9+7;\nint f[N][N],fac[M],inv[M];\ninline int fm(RG LL b){\n\tRG LL a=1;\n\tfor(R k=YL-2;k;k>>=1,b=b*b%YL)\n\t\tif(k&1)a=a*b%YL;\n\treturn a;\n}\ninline int C(R n,R m){\n\tif(n<0||m<0||n<m)return 0;\n\treturn(LL)fac[n]*inv[m]%YL*inv[n-m]%YL;\n}\nint main(){\n\tR n,k,nk;\n\tscanf(\"%d%d\",&n,&k);nk=n*k;\n\tfor(R i=fac[0]=1;i<=nk;++i)\n\t\tfac[i]=fac[i-1]*(LL)i%YL;\n\tinv[nk]=fm(fac[nk]);\n\tfor(R i=nk;i;--i)\n\t\tinv[i-1]=inv[i]*(LL)i%YL;\n\tfor(R i=1;i<=n;++i)\n\t\tfor(R j=f[i][0]=1;j<=i;++j)\n\t\t\tf[i][j]=(f[i-1][j]+(LL)f[i][j-1]*(n-j+1)%YL*C(n-i+(n-j+1)*(k-1)-1,k-2))%YL;\n\tprintf(\"%d\\n\",f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int p = 1000000007;\n\nint a[4000004];\nint b[4000004];\nint d[2002][2002];\n\nint f(int x, int y) {\n\treturn y ? y & 1 ? 1ll * f(x, y ^ 1) * x % p : f(1ll * x * x % p, y >> 1) : 1;\n}\n\ninline int nCr(int n, int r) {\n\treturn n < r ? 0 : 1ll * a[n] * b[r] % p * b[n - r] % p;\n}\n\nint main() {\n\tint i, j, n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tif (m == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\ta[0] = 1;\n\tfor (i = 1; i <= n * m; i++) a[i] = 1ll * i * a[i - 1] % p;\n\tb[n * m] = f(a[n * m], p - 2);\n\tfor (i = n * m; i >= 1; i--) b[i - 1] = 1ll * i * b[i] % p;\n\td[0][0] = 1;\n\tfor (i = 0; i <= n; i++) for (j = 0; j <= i; j++) {\n\t\td[i + 1][j] = (d[i + 1][j] + d[i][j]) % p;\n\t\tif (j < i) d[i][j + 1] = (d[i][j + 1] + 1ll * d[i][j] * (n - j) % p * nCr((n - j) * m - i + j - 1, m - 2)) % p;\n\t}\n\tprintf(\"%d\", d[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 2000*2000+1;\nstruct combination {\n    long long kai[MAXN];\n    long long mod = 1e9+7;\n    combination() { initkai(); }\n    void initkai() {\n        kai[0] = 1; kai[1] = 1;\n        for (long long i = 2; i < MAXN; i++) kai[i] = kai[i - 1] * i % mod;\n    }\n    long long mp(long long a, long long b) {\n        if (b == 0) return 1LL;\n        long long ret = mp(a, b / 2);\n        ret = (ret * ret) % mod;\n        if (b & 1) ret *= a;\n        return ret % mod;\n    }\n    long long inv(long long k) { return mp(k, mod - 2); }\n    long long calc(long long n, long long k) { return kai[n] * inv(kai[k]) % mod * inv(kai[n - k]) % mod; }\n} c;\n\nll n,k;\nll dp[2010][2010];\n\nll dfs(int a, int b) {\n    if (dp[a][b] != 0) return dp[a][b];\n    ll ret = 0;\n    if (a - 1 >= 0) ret += dfs(a-1,b);\n    if (b - 1 >= a) ret += dfs(a, b-1) * c.calc(a + b * (k - 1) - 1, k - 2) % c.mod;\n    return dp[a][b] = ret % c.mod;\n}\n\nint main() {\n    cin >> n >> k;\n    if (k == 1) {\n        cout << 1 << endl;\n        return 0;\n    }\n    dp[0][0] = 1;\n    ll ret = dfs(n,n);\n    for (ll i = 1; i <= n; i++) ret = ret * i % c.mod;\n    cout << ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define mp make_pair\n#define LL long long\n\nusing namespace std;\ntemplate<class T> T gi() {\n\tT x = 0; bool f = 0; char c = getchar();\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar();\n\tif (c == '-') f = 1, c = getchar();\n\twhile (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn f ? -x : x;\n}\nconst int N = 2010, Mod = 1e9 + 7;\nint f[N][N], fac[N * N], ifac[N * N];\nint fpow(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % Mod)\n\t\tif (b & 1) res = 1ll * res * a % Mod;\n\treturn res;\n}\nint C(int n, int m) {\n\tif (n < m) return 0;\n\treturn 1ll * fac[n] * ifac[m] % Mod * ifac[n - m] % Mod;\n}\nvoid pls(int &x, int y) { x += y; if (x >= Mod) x -= Mod; }\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n = gi<int>(), k = gi<int>();\n\tif (k == 1) { puts(\"1\"); return 0; }\n\tfor (int i = fac[0] = 1; i <= n * k; i++)\n\t\tfac[i] = 1ll * fac[i - 1] * i % Mod;\n\tifac[n * k] = fpow(fac[n * k], Mod - 2);\t\n\tfor (int i = n * k; i; i--)\n\t\tifac[i - 1] = 1ll * ifac[i] * i % Mod;\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 0; j <= i; j++) {\n\t\t\tf[i][j] = f[i - 1][j];\n\t\t\tif (j) pls(f[i][j], 1ll * f[i][j - 1] * (n - j + 1) % Mod * C((n - j + 1) * k - i + j - 2, k - 2) % Mod);\n\t\t}\n\tprintf(\"%d\\n\", f[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=2000+10,L=N*N;\nconst int mod=1e9+7;\ninline int qpow(int a,int b) {\n    int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod) if (b&1) c=1ll*c*a%mod;\n    return c;\n}\n\nint fac[L],ifac[L];\ninline void init(int n) {\n    fac[0]=1;\n    for (re int i=1;i<=n;++i) fac[i]=1ll*fac[i-1]*i%mod;\n    ifac[n]=qpow(fac[n],mod-2);\n    for (re int i=n;i;--i) ifac[i-1]=1ll*ifac[i]*i%mod;\n}\ninline int C(int n,int m) {\n    if (n<m) return 0;\n    return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint n,k,dp[N][N];\n\nint main() {\n    n=read(),k=read(); init(n*k);\n    if (k==1) { puts(\"1\"); return 0; }\n    for (re int i=1;i<=n;++i) dp[i][0]=1;\n    for (re int i=1;i<=n;++i)\n        for (re int j=1;j<=i;++j)\n            dp[i][j]=(dp[i-1][j]+1ll*dp[i][j-1]*(n-j+1)%mod*C(n*k-i-(j-1)*(k-1)-1,k-2))%mod;\n    printf(\"%d\\n\",dp[n][n]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=2005,MOD=1000000007;\n\nint PowMod(int a,int b)\n{\n    int ret=1;\n    while(b)\n    {\n        if(b&1)\n            ret=1LL*ret*a%MOD;\n        a=1LL*a*a%MOD;\n        b>>=1;\n    }\n    return ret;\n}\n\nint fac[MAXN*MAXN],ifac[MAXN*MAXN];\n\nvoid Init()\n{\n    fac[0]=1;\n    for(int i=1;i<MAXN*MAXN;i++)\n        fac[i]=1LL*fac[i-1]*i%MOD;\n    ifac[MAXN*MAXN-1]=PowMod(fac[MAXN*MAXN-1],MOD-2);\n    for(int i=MAXN*MAXN-2;i>=0;i--)\n        ifac[i]=1LL*ifac[i+1]*(i+1)%MOD;\n}\nint C(int n,int r)\n{return 1LL*fac[n]*ifac[n-r]%MOD*ifac[r]%MOD;}\n\nint N,K,dp[MAXN][MAXN];\n\nint main()\n{\n    Init();\n    scanf(\"%d%d\",&N,&K);\n    if(K==1)\n    {\n        puts(\"1\");\n        return 0;\n    }\n    dp[0][0]=1;\n    for(int i=0;i<=N;i++)\n        for(int j=0;j<=i;j++)\n        {\n            if(i)\n                dp[i][j]=(dp[i][j]+dp[i-1][j])%MOD;\n            if(j)\n                dp[i][j]=(dp[i][j]+1LL*dp[i][j-1]*C(N*K-i-(K-1)*(j-1)-1,K-2)%MOD)%MOD;\n        }\n    int ans=1LL*dp[N][N]*fac[N]%MOD;\n    printf(\"%d\\n\",ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\ntemplate<unsigned P> struct ModInt {\n  using M = ModInt;\n  unsigned v;\n  ModInt() : v(0) {}\n  ModInt(auto x) : v(x >= 0 ? x % P : (P - -x % P) % P) {}\n  constexpr ModInt(unsigned v, int) : v(v) {}\n  static constexpr unsigned p() { return P; }\n  M operator+() const { return *this; }\n  M operator-() const { return {v ? P - v : 0, 0}; }\n  explicit operator bool() const noexcept { return v; }\n  bool operator!() const noexcept { return !(bool) *this; }\n  M operator*(M r) const { return M(*this) *= r; }\n  M operator/(M r) const { return M(*this) /= r; }\n  M operator+(M r) const { return M(*this) += r; }\n  M operator-(M r) const { return M(*this) -= r; }\n  bool operator==(M r) const { return v == r.v; }\n  bool operator!=(M r) const { return !(*this == r); }\n  M& operator*=(M r) { v = (uint64_t) v * r.v % P; return *this; }\n  M& operator/=(M r) { return *this *= r.inv(); }\n  M& operator+=(M r) { if ((v += r.v) >= P) v -= P; return *this; }\n  M& operator-=(M r) { if ((v += P - r.v) >= P) v -= P; return *this; }\n  M inv() const {\n    int a = v, b = P, x = 1, u = 0;\n    while (b) {\n      int q = a / b;\n      swap(a -= q * b, b);\n      swap(x -= q * u, u);\n    }\n    assert(a == 1);\n    return x;\n  }\n  M pow(auto n) const {\n    if (n < 0) return pow(-n).inv();\n    M res = 1;\n    for (M a = *this; n; a *= a, n >>= 1) if (n & 1) res *= a;\n    return res;\n  }\n  friend M operator*(auto l, M r) { return M(l) *= r; }\n  friend M operator/(auto l, M r) { return M(l) /= r; }\n  friend M operator+(auto l, M r) { return M(l) += r; }\n  friend M operator-(auto l, M r) { return M(l) -= r; }\n  friend ostream& operator<<(ostream& os, M r) { return os << r.v; }\n  friend istream& operator>>(istream& is, M& r) { lint x; is >> x; r = x; return is; }\n  friend bool operator==(auto l, M r) { return M(l) == r; }\n  friend bool operator!=(auto l, M r) { return !(l == r); }\n};\nusing Mint = ModInt<(unsigned) 1e9 + 7>;\n\nV<Mint> fact, ifact, inv, powB;\nvoid init(int n, int B = 2) {\n  fact.resize(n + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    fact[i] = i * fact[i - 1];\n  }\n  ifact.resize(n + 1);\n  ifact[n] = fact[n].inv();\n  for (int i = n; i > 0; --i) {\n    ifact[i - 1] = i * ifact[i];\n  }\n  inv.resize(n + 1);\n  inv[1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    int q = Mint::p() / i;\n    inv[i] = -q * inv[Mint::p() - i * q];\n  }\n  powB.resize(n + 1);\n  powB[0] = 1;\n  for (int i = 0; i < n; ++i) {\n    powB[i + 1] = powB[i] * B;\n  }\n}\nMint comb(int n, int r) {\n  if (r < 0 or r > n) return 0;\n  return fact[n] * ifact[r] * ifact[n - r];\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n, k; cin >> n >> k;\n  if (k == 1) return cout << 1 << '\\n', 0;\n  init(n * k);\n  V<Mint> dp{0, 1};\n  for (int i = 2; ; ++i) {\n    V<Mint> c(i + 1), ndp(i + 1);\n    for (int j = 0; j < i; ++j) c[j + 1] = c[j] + dp[j];\n    if (i > n) return cout << c.back() * fact[n] << '\\n', 0;\n    for (int j = 1; j <= i; ++j) {\n      ndp[j] = comb(i * k - (j + 1), k - 2) * (c[i] - c[j - 1]);\n    }\n    swap(dp, ndp);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\nconst ll mod = 1000000007;\nvector<ll> inv, FactorialInv, Factorial;\nll beki(ll a, ll b){\n    ll ret = 1 % mod;\n    a %= mod;\n    while(b) {\n        if(b & 1LL) ret = ret * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return ret;\n}\nvoid init_combination(ll MAX){\n    Factorial.resize(MAX + 1);\n    FactorialInv.resize(MAX + 1);\n    inv.resize(MAX + 1);\n    Factorial[0] = 1;\n    inv[0] = 1;\n    for(int i = 1; i <= MAX; i++){\n        Factorial[i] = Factorial[i - 1] * i % mod;\n    }\n    FactorialInv[MAX] = beki(Factorial[MAX], mod - 2);\n    for(ll i = MAX - 1; i >= 0; i--) {\n        FactorialInv[i] = FactorialInv[i+1] * (i+1) % mod;\n    }\n    for(int i = 1; i <= MAX; i++) {\n        inv[i] = FactorialInv[i] * Factorial[i-1] % mod;\n    }\n}\nll combination(ll a, ll b){\n    if((a == b) || (b == 0)){\n        return 1;\n    }\n    if(a < b) return 0;\n    if(b < 0) return 0;\n    ll ans = Factorial[a] * FactorialInv[b] % mod;\n    ans = ans * FactorialInv[a - b] % mod;\n    return ans;\n}\n\nll dp[3000][3000];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    init_combination(10000000);\n    ll N, K;\n    cin >> N >> K;\n    if(K == 1) {\n        cout << 1 << endl;\n        return 0;\n    }\n    dp[0][0] = 1;\n    for(int i = 1; i <= N; i++) {\n        for(int j = 0; j <= N; j++) {\n            dp[i][j] += combination(i-1+(K-1)*(j-1)+K-2, K-2) * (dp[i][j-1]);\n            dp[i][j] += dp[i-1][j];\n            dp[i][j] %= mod;\n        }\n        for(int j = 0; j < i; j++) dp[i][j] = 0;\n        for(int j = 1; j <= N; j++) {\n            //cerr << i << \" \" << j << \" \" << dp[i][j] << endl;\n        }\n    }\n    ll ans = dp[N][N] * Factorial[N] % mod;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define C(n,m) ((LL)fac[n]*ifac[m]%mo*ifac[(n)-(m)]%mo)\n\nconst int maxn=2010;\nconst int mo=1e9+7;\nconst int N=4000000;\n\nint n,k,dp[maxn][maxn];\nint fac[maxn*maxn],ifac[maxn*maxn];\n\nint power(int x,int k)\n{\n\tint res=1;\n\twhile (k)\n\t{\n\t\tif (k&1) res=(LL)res*x%mo;\n\t\tx=(LL)x*x%mo;\n\t\tk>>=1;\n\t}\n\treturn res;\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tint i,j;\n\tfac[0]=1;\n\tfor (i=1;i<=N;i++)\n\t\tfac[i]=(LL)fac[i-1]*i%mo;\n\tifac[N]=power(fac[N],mo-2);\n\tfor (i=N;i>=1;i--)\n\t\tifac[i-1]=(LL)ifac[i]*i%mo;\n\tscanf(\"%d%d\",&n,&k);\n\tif (k==1) {puts(\"1\"); return 0;}\n\tdp[0][0]=1;\n\tfor (i=0;i<=n;i++)\n\tfor (j=0;j<=n;j++)\n\t\tif (dp[i][j])\n\t\t{\n\t\t\t(dp[i+1][j]+=dp[i][j])%=mo;\n\t\t\tif (i>j)\n\t\t\t\t(dp[i][j+1]+=(LL)dp[i][j]*C((n-j)*k-i+j-1,k-2)%mo)%=mo;\n\t\t}\n\tprintf(\"%lld\\n\",(LL)dp[n][n]*fac[n]%mo);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> ii;\n\n#define fill(a,x) memset(a,x,sizeof(a)) \n#define pb push_back\n#define sz(x) (int)x.size()\n#define all(x) x.begin(),x.end() \n#define F first\n#define S second\n#define FOR(i,a,b) for(int i = a; i<=b; ++i)\n#define NFOR(i,a,b) for(int i = a; i>=b; --i)\n#define fast ios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0)\nconst ll INF = 1e18;\nconst int mod = 1e9+7;\nconst int N = 4e6+10; \ninline int add(int x,int y){\n  x += y;\n  if(x >= mod) x -= mod;\n  return x;\n}\ninline int mul(int x,int y){\n  x = (1LL * x * y) % mod;\n  return x;\n}\nint fac[N],ifac[N],inv[N];\nvoid FAC(int n){\n  fac[0] = ifac[0] = inv[1] = 1;\n  for(int i = 1; i < n; ++i)fac[i] = 1LL*i*fac[i-1] % mod;\n  for(int i = 2; i < n; ++i)inv[i] = mod - ((mod/i)*1LL*inv[mod%i]) % mod;\n  for(int i = 1; i < n; ++i)ifac[i] = 1LL*ifac[i-1]*inv[i] % mod;\n}\ninline int C(int n,int k){\n  if(k > n)return 0;\n  return  1LL * ifac[n-k]*( (1LL*fac[n]*ifac[k]) % mod ) % mod; \n}\nint dp[2010][2010];\nint k;\nint DP(int x,int y){\n\tif(x > y)return 0;\n\tif(x < 0 || y < 0)return 0;\n\tif(x <= 1 && y == 1){\n\t\treturn 1;\n\t}\n\tint &ret = dp[x][y];\n\tif(~ret)return ret;\n\tret = 0;\n\tret = add(ret,DP(x-1,y));\n\tint tmp = DP(x,y-1);\n\ttmp = mul(tmp,C(x + y*(k-1) -1 , k - 2));\n\tret = add(ret,tmp);\n\treturn ret;\n}\nint main(){\n  fast;\n  FAC(N);\n  int n;cin >> n >> k;\n  if(k == 1){\n  \tcout << 1 << \"\\n\";return 0;\n  }\n  fill(dp,-1);\n  cout << mul(DP(n,n),fac[n]) << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ███▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓╬╬╬╬╬╬▓█\n// ███▓███████▓▓╬╬╬╬╬╬╬╬╬╬╬╬▓███▓▓▓▓█▓╬╬╬▓█\n// ███████▓█████▓▓╬╬╬╬╬╬╬╬▓███▓╬╬╬╬╬╬╬▓╬╬▓█\n// ████▓▓▓▓╬╬▓█████╬╬╬╬╬╬███▓╬╬╬╬╬╬╬╬╬╬╬╬╬█\n// ███▓▓▓▓╬╬╬╬╬╬▓██╬╬╬╬╬╬▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ████▓▓▓╬╬╬╬╬╬╬▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ███▓█▓███████▓▓███▓╬╬╬╬╬╬▓███████▓╬╬╬╬▓█\n// ████████████████▓█▓╬╬╬╬╬▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬█\n// ███▓▓▓▓▓▓▓╬╬▓▓▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ████▓▓▓╬╬╬╬▓▓▓▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ███▓█▓▓▓▓▓▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// █████▓▓▓▓▓▓▓▓█▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// █████▓▓▓▓▓▓▓██▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n// █████▓▓▓▓▓████▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n// ████▓█▓▓▓▓██▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n// ████▓▓███▓▓▓▓▓▓▓██▓╬╬╬╬╬╬╬╬╬╬╬╬█▓╬▓╬╬▓██\n// █████▓███▓▓▓▓▓▓▓▓████▓▓╬╬╬╬╬╬╬█▓╬╬╬╬╬▓██\n// █████▓▓█▓███▓▓▓████╬▓█▓▓╬╬╬▓▓█▓╬╬╬╬╬╬███\n// ██████▓██▓███████▓╬╬╬▓▓╬▓▓██▓╬╬╬╬╬╬╬▓███\n// ███████▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬████\n// ███████▓▓██▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓████\n// ████████▓▓▓█████▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█████\n// █████████▓▓▓█▓▓▓▓▓███▓╬╬╬╬╬╬╬╬╬╬╬▓██████\n// ██████████▓▓▓█▓▓▓╬▓██╬╬╬╬╬╬╬╬╬╬╬▓███████\n// ███████████▓▓█▓▓▓▓███▓╬╬╬╬╬╬╬╬╬▓████████\n// ██████████████▓▓▓███▓▓╬╬╬╬╬╬╬╬██████████\n// ███████████████▓▓▓██▓▓╬╬╬╬╬╬▓███████████\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n#pragma GCC optimize(\"unroll-loops\")    \n#include <bits/stdc++.h>\n#define pb push_back\n#define x first\n#define y second\n#define mp make_pair\n#define len(a) int(a.size())\n#define files(FILENAME) read(FILENAME); write(FILENAME)\n#define read(FILENAME) freopen((string(FILENAME) + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((string(FILENAME) + \".out\").c_str(), \"w\", stdout)\nusing namespace std;\n        \ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; } \ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p) { _out << _p.first << ' ' << _p.second; return _out; }\ntemplate<typename T, typename U> inline istream &operator>> (istream &_in, pair<T, U> &_p) { _in >> _p.first >> _p.second; return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const vector<T> &_v) { if (_v.empty()) { return _out; } _out << _v.front(); for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline istream &operator>> (istream &_in, vector<T> &_v) { for (auto &_i : _v) { _in >> _i; } return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\n        \ntypedef long long base; \ntypedef pair<int, int> point;      \ntypedef complex<double> comp;\n\nconst int p = 1e9 + 7;\n\nint sum(int a, int b) {\n    a += b;\n    return a < p ? a : a - p;\n}\n\nint mul(long long a, int b) {\n    return a * b % p;\n}\n\nint powx(int a, int b) {\n    int ans = 1;\n    while (b) {\n        if (b & 1) ans = mul(ans, a);\n        a = mul(a, a);\n        b >>= 1;\n    }\n    return ans;\n}\n\nint n, m;\nint dp[2002][2002];\nint f[2][2002 * 2002];\n\nint cnk(int n, int k) {\n    return mul(f[0][n], mul(f[1][n - k], f[1][k]));\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin >> n >> m;\n    f[0][0] = 1;\n    for (int i = 1; i <= n * m; ++i) {\n        f[0][i] = mul(f[0][i - 1], i);\n    }\n    f[1][n * m] = powx(f[0][n * m], p - 2);\n    for (int i = n * m; i >= 1; --i) {\n        f[1][i - 1] = mul(f[1][i], i);\n    }\n    if (m == 1) {\n        cout << 1 << '\\n';\n        return 0;\n    }\n    dp[0][0] = 1;\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            // if (dp[i][j] == 0) break;\n            dp[i + 1][j] = sum(dp[i + 1][j], dp[i][j]);\n            if (i > j) {\n                int sz = n * m - i - j * (m - 1);\n                dp[i][j + 1] = sum(dp[i][j + 1], mul(dp[i][j], cnk(sz - 1, m - 2)));\n            }\n        }\n    }\n    cout << mul(f[0][n], dp[n][n]) << '\\n';\n}  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define mod 1000000007\nconst int maxn=5000010;\nlong long fac[maxn],ifac[maxn],inv[maxn],d[2010][2010];\nint n,k;\nint main(){\n\tcin>>n>>k;\n\tif(k==1){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tfac[0]=inv[0]=ifac[0]=fac[1]=inv[1]=ifac[1]=1;\n\tfor(int i=2;i<=n*k+10;++i){\n\t\tfac[i]=(fac[i-1]*i)%mod;\n\t\tinv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\t\tifac[i]=(ifac[i-1]*inv[i])%mod;\n\t}\n\td[0][1]=1;\n\tfor(int i=2;i<=n;++i)\n\t\td[0][i]=d[0][i-1]*(fac[i*(k-1)-1]*ifac[k-2]%mod*ifac[(i-1)*(k-1)]%mod)%mod;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=i;j<=n;++j){\n\t\t\td[i][j]=(d[i-1][j]+d[i][j-1]*(fac[i+j*(k-1)-1]*ifac[k-2]%mod*ifac[i+(j-1)*(k-1)]%mod)%mod)%mod;\n\t\t}\n\t}\n\tcout<<d[n][n]*fac[n]%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//第一道黑题祭 \n// Start 40 lines of header files acceleration\n#pragma GCC optimize(3)\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"inline\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-fipa-sra\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-ffast-math\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fdevirtualize\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"inline-functions\")\n#pragma GCC optimize(\"-ftree-tail-merge\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fpartial-inlining\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-fhoist-adjacent-loads\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"inline-small-functions\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"inline-functions-called-once\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n// End 40 lines of header files acceleration\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#define re register\n#define ll long long\n#define N 2005\n#define MAXN 4000000\nusing namespace std;\n//\n\ninline int read(){\n    int x=0,f=1;\n    char c;\n    for(c=getchar();(!isdigit(c))&&(c!='-');c=getchar());\n    if(c=='-') f=-1,c=getchar();\n    for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';\n    return x*f;\n}\ninline void print(int number){\n    const int SIZE=25; int un=1,extent=0; char letter[SIZE];\n    if(number<0){ number=-number; un=-1;}\n    while(number){ letter[++extent]=number%10+'0'; number/=10;}\n    if(!~un) putchar('-'); if(!extent) putchar('0');\n    else while(extent) putchar(letter[extent--]);\n}\ninline int getint(){\n    char ch = getchar(); int x = 0;\n    while (ch < '0'|| ch > '9') ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    return x;\n}\ninline void putint(long long x){\n\tif (x > 9) putint(x / 10);\n\tputchar(x % 10 + '0');\n}\n//\n\nconst int Mod=1e9+7;\nint n, k;\nll f[N][N], f1[MAXN+5], f2[MAXN+5];\n//\n\ninline ll Equation(int n,int m){\n\treturn (((f1[m] * f2[n]) % Mod) * f2[m - n]) % Mod;\n}\ninline ll Answer(ll x,int P){\n    ll ans = 1, m = x;\n    while(P){\n        if(P&1)\n\t\t\t(ans *= m) %= Mod;\n        P >>= 1;\n\t\t(m*=m) %= Mod;\n    }\n    return ans;\n}\n//\n\nint main(){\n//    scanf(\"%d%d\",&n,&k);\n\tn = read(), k = read();\n\t\n    if(k==1)//特判 \n\t{\n\t\tprintf(\"%d\\n\",1);\n\t\treturn 0;\n\t}\n\t\n    f1[0] = 1;\n\tfor(re int i = 1; i <= MAXN; ++i)\n\t\tf1[i] = (f1[i-1] * i) % Mod;\n\t\t\n    f2[MAXN] = Answer(f1[MAXN], Mod-2);\n    \n\tfor(re int i = MAXN - 1; i>=0; --i)\n\t\tf2[i] = (f2[i + 1] * (i + 1)) % Mod;\n\t\t\n    f[0][0]=1;\n    \n    for(re int i = 1;i <= n; ++i){\n        for(re int j = 0;j <= i; ++j){\n            f[i][j] = f[i - 1][j];\n            if(!j)\n\t\t\t\tcontinue;\n            (f[i][j] += f[i][j - 1] * (n - j + 1) % Mod * Equation(k - 2,n - i + (n - j + 1) * (k - 1) - 1) % Mod) %= Mod;\n        }\n    }\n//    printf(\"%lld\\n\",f[n][n]);\n\tprint(f[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FILL(i,n) memset(i,n,sizeof i)\n#define X first\n#define Y second\n#define ET cout << \"\\n\"\n#define SZ(a) ((int)a.size())\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0);\n#ifdef bbq\n#define debug(...) {\\\n    fprintf(stderr,\"%s - %d (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);\\\n    _do(__VA_ARGS__);\\\n}\n#define DB(a,s,e) {for(int _i=s;_i<e;++_i) cerr << a[_i] << \" \";cerr << \"\\n\";}\ntemplate<typename T>void _do(T &&x){cerr<<x<<endl;}\ntemplate<typename T,typename ...S> void _do(T &&x,S &&...t){cerr<<x<<\", \";_do(t...);}\ntemplate<typename a,typename b> ostream& operator << (ostream &s,const pair<a,b> &p){return s<<\"(\"<<p.X<<\",\"<<p.Y<<\")\";}\n#else\n#define debug(...)\n#define DB(a,s,e)\n#endif\n\nconst ll MOD=1e9+7;\nll dp[2005][2005],J[4000005],inv[4000005],invJ[4000005];\n\nint main()\n{\n    IOS();\n    ll n,k;\n    cin >> n >> k,J[0]=J[1]=inv[1]=invJ[0]=invJ[1]=1,dp[0][0]=1;\n    if(k==1)\n        return cout << \"1\\n\",0;\n    for(ll i=2;i<=n*k;++i)\n        J[i]=J[i-1]*i%MOD,inv[i]=(MOD-MOD/i)*inv[MOD%i]%MOD,invJ[i]=invJ[i-1]*inv[i]%MOD;\n    for(int i=0;i<=n;++i)\n        for(int j=i;j<=n;++j)\n        {\n            if(i)\n                dp[i][j]=dp[i-1][j];\n            if(i!=j)\n                dp[i][j]=(dp[i][j]+dp[i][j-1]*J[i+j*(k-1)-1]%MOD*invJ[k-2]%MOD*invJ[i+j*(k-1)-k+1])%MOD;\n        }\n    cout << dp[n][n]*J[n]%MOD << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 *1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MAX = 2020;\nconst int MOD = 1000 * 1000 * 1000 + 7;\n\nLL DP[MAX][MAX];\nLL F[MAX * MAX];\nLL IF[MAX * MAX];\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL C(LL a, LL b)\n{\n\tLL res = F[a];\n\tres *= IF[b];\n\tres %= MOD;\n\tres *= IF[a-b];\n\tres %= MOD;\n\treturn res;\n}\n\nvoid ADD(LL& x, LL val)\n{\n\tx += val;\n\tif (x >= MOD) x -= MOD;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\",\"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX * MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\n\tif (k == 1)\n\t{\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\n\tDP[0][0] = 1;\n\tFOR (i, 0, n + 1)\n\t{\n\t\tRFOR (j, n+1, 0)\n\t\t{\n\t\t\tif (DP[i][j] == 0) continue;\n\n\t\t\tADD(DP[i+1][j+1], DP[i][j]);\n\n\t\t\tif (j)\n\t\t\t{\n\t\t\t\tint used = i + (i - j) * (k - 1);\n\n\t\t\t\tint left = n * k - used - 1;\n\n\n\t\t\t\tLL cnt = C(left, k - 2);\n\t\t\t\tint cols = n - (i - j);\n\t\t\t\tcnt *= cols;\n\t\t\t\tcnt %= MOD;\n\t\t\t\tcnt *= DP[i][j];\n\t\t\t\tcnt %= MOD;\n\n\t\t\t\tADD(DP[i][j-1], cnt);\n\t\t\t}\n\t\t}\n\t}\n\n/*\tFOR (i, 0, n+1)\n\t{\n\t\tFOR (j, 0, n+1)\n\t\t{\n\t\t\tcout<<DP[i][j]<<' ';\n\t\t}\n\t\tcout<<endl;\n\t}\n\tcout<<endl;*/\n\n\tLL res = DP[n][0];\n\tcout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,k;\nconst long long mod=1e9+7;\nlong long dp[3010][3010],jie[4000010],ni[4000010];\ninline long long ksm(long long x,long long y)\n{\n\tlong long res=1;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\tres=res*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1)\n\t{\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tjie[0]=1;\n\tfor(int i=1;i<=n*k;++i)\n\tjie[i]=jie[i-1]*i%mod;\n\tni[n*k]=ksm(jie[n*k],mod-2);\n\tfor(int i=n*k-1;i>=0;--i)\n\tni[i]=ni[i+1]*(i+1)%mod;\n\tfor(int i=1;i<=n;++i)\n\tdp[i][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=i;++j)\n\t\t{\n\t\t\tint x=n*k-i-(j-1)*(k-1)-1;\n\t\t\tdp[i][j]=(dp[i-1][j]+dp[i][j-1]*(n-j+1)%mod*jie[x]%mod*ni[k-2]%mod*ni[x-k+2]%mod)%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\nistream&operator>>(istream&s,_Bit_reference b){int a;s>>a;assert(a==0||a==1);b=a;return s;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}T get(int i){return S[i+B];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\nclass LCA{vvi par;vi dep;public:LCA(vvi&E,int root):par(MSB(E.size())+1,vi(E.size())),dep(E.size()){function<void(int,int)>dfs=[&](int i,int p){for(int j:E[i])if(j!=p){par[0][j]=i;dep[j]=dep[i]+1;dfs(j,i);}};par[0][root]=root;dfs(root,root);fr(i,par.size()-1){fr(j,par[0].size()){par[i+1][j]=par[i][par[i][j]];}}}int operator()(int a,int b){if(dep[a]>dep[b])swap(a,b);for(int t=dep[b]-dep[a],i=0;t;t>>=1,++i){if(t&1){b=par[i][b];}}if(a==b)return a;rf(i,par.size()){if(par[i][a]!=par[i][b]){a=par[i][a];b=par[i][b];}}return par[0][a];}};\nvpli factor(ll N){vpli r;for(ll i=2;i*i<=N;++i){if(N%i==0){r<<pli{i,0};while(N%i==0){N/=i;++r.back().second;}}}if(N>1){r<<pli{N,1};}return r;}\nvl divisors(ll n){vl r;ll m=sqrt(n);foor(i,1,m)if(n%i==0)r<<ll(i);rf(i,r.size()-(m*m==n))r<<n/r[i];return r;}\nvi SuffixArray(str S){int N=S.size();vi rank(N+1),tmp(N+1),sa(N+1);fr(i,N){sa[i]=i;rank[i]=S[i];}sa[N]=N;rank[N]=-1;int k;auto cmp=[&](int&a,int&b)->bool{if(rank[a]!=rank[b])return rank[a]<rank[b];return (a+k<=N?rank[a+k]:-1)<(b+k<=N?rank[b+k]:-1);};for(k=1;k<=N;k*=2){sort(all(sa),cmp);tmp[sa[0]]=0;foor(i,1,N){tmp[sa[i]]=tmp[sa[i-1]]+cmp(sa[i-1],sa[i]);}rank=tmp;}return sa;};\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N,K;cin>>N>>K;\n\tCombination C(N*K,MD);\n\tvvl d(N+1,vl(N+1));\n\td[N][N]=1;\n\tfunction<ll(int,int)>f=[&](int i,int j)->ll{\n\t\tif(i>N||j>i)return 0;\n\t\tif(d[i][j])return d[i][j];\n\t\treturn d[i][j]=(f(i+1,j)+f(i,j+1)*C.C(N*K-i-j*(K-1)-1,K-2))%MD;\n\t};\n\tprint(K==1?:f(0,0)*C.F(N)%MD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\nusing namespace std;\nconst int P=1e9+7;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint ksm(R int x,R int y){\n    R int res=1;\n    for(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;\n    return res;\n}\nconst int N=5005,M=5e6+5;\nint f[N][N],fac[M],ifac[M],n,k;\ninline int C(R int n,R int m){return m>n?0:1ll*fac[n]*ifac[m]%P*ifac[n-m]%P;}\ninline void init(R int n=5e6){\n\tfac[0]=ifac[0]=1;fp(i,1,n)fac[i]=mul(fac[i-1],i);\n\tifac[n]=ksm(fac[n],P-2);fd(i,n-1,1)ifac[i]=mul(ifac[i+1],i+1);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k),--k;\n\tif(!k)return puts(\"1\"),0;\n\tinit();\n\tf[0][0]=1;\n\tfp(i,0,(n<<1)-1)fp(j,0,min(i,n))if(f[i][j]){\n//\t\tprintf(\"%d %d %d\\n\",i,j,f[i][j]);\n\t\tif(j+1<=n)upd(f[i+1][j+1],mul(n-j,mul(f[i][j],C(i+j*(k-1)+k-1,k-1))));\n\t\tif((i+1-j)<=j)upd(f[i+1][j],f[i][j]);\n\t}\n\tprintf(\"%d\\n\",f[n<<1][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint mod = 1000000007;\nlong long f[(1<<24)], invf[(1<<24)];\n\nlong long pow2( long long a, long long st ) {\n    long long ret = 1;\n    while ( st ) {\n        if ( st&1 ) {\n            ret *= a;\n            ret %= mod;\n        }\n\n        a *= a;\n        a %= mod;\n        st /= 2;\n    }\n    return ret;\n}\n\nvoid pre () {\n    f[0] = 1;\n    invf[0] = 1;\n    for ( int i = 1; i < (1<<23) ; i ++ ) {\n        f[i] = f[i-1]*i%mod;\n    }\n\n    invf[ (1<<23)-1 ] = pow2( f[ (1<<23)-1 ], mod-2 );\n    for ( int i = (1<<23)-2 ; i > 0 ; i -- ) {\n        invf[i] = invf[i+1]*(i+1)%mod;\n    }\n}\n\nint comb( int n, int k ) {\n    return f[n]*invf[k]%mod*invf[n-k]%mod;\n}\n\nint k;\n\nlong long mem[2042];\n\nlong long solve ( int cnt ) {\n    if ( cnt == 1 ) { return 1; }\n    if ( mem[cnt] ) { return mem[cnt]-1; }\n\n    long long ret = 0;\n    for ( int i = 0 ; i <= k-1 ; i ++ ) {\n\n        //cout << i << \" : \" << comb( (cnt-1)*k+i-1, i-1 ) << \"\\n\";\n        if ( i == k-1 ) {\n            //cout << i << \": \" << solve( cnt-1 )*comb( (cnt-1)*k+i-1, i ) << \"\\n\";\n            ret += solve( cnt-1 )*comb( (cnt-1)*k+i-1, i )%mod;\n            if ( ret >= mod ) { ret -= mod; }\n        }\n        else {\n            ret += solve( cnt-1 )*comb( (cnt-1)*k+i-1, i )%mod*cnt%mod;\n            if ( ret >= mod ) { ret -= mod; }\n        }\n    }\n    mem[cnt] = ret+1;\n    return ret;\n}\n\nint main () {\n    pre();\n\n    int n;\n    cin >> n >> k;\n\n    cout << solve ( n ) << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 2e3 + 32, M = 4e6 + 64, P = 1e9 + 7;\n\nint pw(int x, int y) {\n\tint r = 1;\n\tfor (; y; y >>= 1, x = 1ll * x * x % P)\n\t\tif (y & 1) r = 1ll * r * x % P;\n\treturn r;\n}\n\nint fac[M], ifac[M];\nint c(int n, int m) { return 1ll * n[fac] * m[ifac] % P * (n - m)[ifac] % P; }\n\nint n, k, dp[N][N];\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\t0 [fac] = 0 [ifac] = 1;\n\tfor (int i = 1; i <= n * k; i++) i[fac] = 1ll * (i - 1)[fac] * i % P;\n\t(n * k)[ifac] = pw((n * k)[fac], P - 2);\n\tfor (int i = n * k - 1; i >= 1; i--) i[ifac] = 1ll * (i + 1)[ifac] * (i + 1) % P;\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int j = 0; j <= i; j++)\n\t\t\tif (i || j)\n\t\t\t\tdp[i][j] = (dp[i - 1][j] +\n\t\t\t\t\t\t\t(n - j + 1ll) * c(n * k - i - (j - 1) * (k - 1) - 1, k - 2) %\n\t\t\t\t\t\t\t\tP * dp[i][j - 1]) %\n\t\t\t\t\t\t   P;\n\t\t\telse\n\t\t\t\tdp[0][0] = 1;\n\tprintf(\"%d\", dp[n][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\n#define MOD 1000000007\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int MAXN = 2000 + 10;\nconst int MAXM = MAXN * MAXN;\n\nint N, K;\n\nLL fact[MAXM]= {0}, invfact[MAXM]= {0};\nvoid init () {\n\tfact[0] = fact[1] = invfact[0] = invfact[1] = 1;\n\tfor (int i = 2; i <= N * K; i ++) {\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\tinvfact[i] = (MOD - MOD / i) * invfact[MOD % i] % MOD;\n\t}\n\tfor (int i = 1; i <= N * K; i ++)\n\t\tinvfact[i] = invfact[i - 1] * invfact[i] % MOD;\n}\ninline LL C (int n, int m) {\n\tif (n < 0) return 0;\n\tif (m == 0) return 1;\n\treturn fact[n] * invfact[m] % MOD * invfact[n - m] % MOD;\n}\n\nLL f[MAXN][MAXN]= {0};\n\nint main () {\n\tscanf (\"%d%d\", & N, & K);\n\tif (K == 1) {\n\t\tputs (\"1\");\n\t\treturn 0;\n\t}\n\tinit ();\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= N; i ++)\n\t\tfor (int j = 0; j <= i; j ++) {\n\t\t\tLL delta = f[i][j - 1] * (N - j + 1) % MOD * C (N * K - i - (K - 1) * (j - 1) - 1, K - 2) % MOD;\n\t\t\tif (j == 0) delta = 0;\n\t\t\tf[i][j] = (f[i][j] + f[i - 1][j] + delta) % MOD;\n\t\t}\n\tcout << f[N][N] << endl;\n\n\treturn 0;\n}\n\n/*\n2 2\n*/\n\n/*\n3 1\n*/\n\n/*\n2 3\n*/\n\n/*\n2000 2000\n*/"
  },
  {
    "language": "C++",
    "code": "    #include <iostream>\n    #include <string>\n    #include <set>  \n    #include <algorithm>\n    #include <vector>\n    #include <cmath>\n    #include <queue>\n    #include <deque>\n    #include <cstring>\n    #include <cstdio>\n    #include <map>\n    #include <numeric>\n    #include <cassert>\n    #include <iomanip>\n    #include <sstream>\nusing namespace std;\ntypedef long long LL;\nconst int MAXN=2002;\nconst int MAXM=MAXN*MAXN;\nconst LL M=1e9+7;\nLL fac[MAXM],inv[MAXM],f[MAXN][MAXN];\nint N,K;\nLL C(int x,int y)\n{\n\tif(x<y)return 0;\n\treturn fac[x]*inv[y]%M*inv[x-y]%M;\n}\nint main()\n{\n\tscanf(\"%d %d\",&N,&K);\n\tif(K==1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=inv[0]=inv[1]=1LL;\n\tfor(int i=1;i<MAXM;i++)\n\t\tfac[i]=1LL*fac[i-1]*i%M;\n\tfor(int i=2;i<MAXM;i++)\n\t\tinv[i]=1LL*(M-M/i)*inv[M%i]%M;\n\tfor(int i=1;i<MAXM;i++)\n\t\tinv[i]=inv[i-1]*inv[i]%M;\n\tf[0][0]=1;\n\tfor(int i=1;i<=N;i++)\n\t\tfor(int j=i;~j;j--)\n\t\t{\n\t\t\tf[i][j]=f[i][j+1];\n\t\t\tif(j)f[i][j]+=f[i-1][j-1]*C(i*K-j-1,K-2)%M;\n\t\t\tf[i][j]%=M;\n\t\t}\n\tprintf(\"%lld\\n\",f[N][0]*fac[N]%M);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\n#define N 2010\n#define mod 1000000007\n#define foru(i,l,r) for (int i=l; i<=r; i++)\n#define ford(i,r,l) for (int i=r; i>=l; i--)\n#define read(x) ((x)=getint())\n#define inc(a,b) (((a)+=(b))%=mod)\n#define mul(a,b) (LL(a)*(b)%mod)\ntypedef long long LL;\n\nint n,k,fac[N*N],inv[N*N],f[N][N];\n\nint getint()\n{\n\tint x,f=1; char ch;\n\twhile (!isdigit(ch=getchar())) f=ch=='-'?-1:1;\n\tx=ch-'0';\n\twhile (isdigit(ch=getchar())) x=x*10+ch-'0';\n\treturn f*x;\n}\nint C(int n, int m)\n{\n\tif (n<0||n<m) return 0;\n\treturn mul(mul(fac[n],inv[m]),inv[n-m]);\n}\nint main()\n{\n\tread(n), read(k);\n\tif (k==1) return puts(\"1\"), 0;\n\tfac[0]=inv[0]=fac[1]=inv[1]=1;\n\tforu(i,2,n*k) fac[i]=mul(fac[i-1],i);\n\tforu(i,2,n*k) inv[i]=mul(mod-mod/i,inv[mod%i]);\n\tforu(i,2,n*k) inv[i]=mul(inv[i],inv[i-1]);\n\tf[0][0]=1;\n\tforu(i,1,n)\n\t\tford(j,i,0)\n\t\t{\n\t\t\tinc(f[i][j],f[i][j+1]);\n\t\t\tif (j) inc(f[i][j],mul(C(i*k-j-1,k-2),f[i-1][j-1]));\n\t\t}\n\tprintf(\"%lld\\n\",mul(f[n][0],fac[n]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define LL long long\n//#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)\n//char buf[(1 << 21) + 1], *p1 = buf, *p2 = buf;\ninline int read() {\n\tbool f=0;int x=0;char c=getchar();\n\twhile(c<'0'||'9'<c){if(c==EOF)exit(0);if(c=='-')f=1;c=getchar();}\n\twhile('0'<=c&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();\n\treturn !f?x:-x;\n}\n#define MAXN 2000\n#define INF 0x3f3f3f3f\n#define Mod (int)(1e9+7)\nLL fac[MAXN*MAXN+5],inv[MAXN*MAXN+5];\nLL Pow(LL x,LL y){\n\tLL ret=1;\n\twhile(y){\n\t\tif(y&1) ret=ret*x%Mod;\n\t\tx=x*x%Mod,y>>=1;\n\t}\n\treturn ret;\n}\nvoid Prepare(){\n\tfac[0]=1;\n\tfor(int i=1;i<=MAXN*MAXN;i++)\n\t\tfac[i]=fac[i-1]*i%Mod;\n\tinv[MAXN*MAXN]=Pow(fac[MAXN*MAXN],Mod-2);\n\tfor(int i=MAXN*MAXN-1;i>=0;i--)\n\t\tinv[i]=inv[i+1]*(i+1)%Mod;\n\treturn ;\n}\nLL f[MAXN+5][MAXN+5];\nLL C(int n,int m){\n\tif(n<m) return 0;\n\treturn fac[n]*inv[m]%Mod*inv[n-m]%Mod;\n}\nint main(){\n\tPrepare();\n\tint n=read(),k=read();\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tf[i][j]=(f[i-1][j]+C(n-i+(n-(j-1))*(k-1)-1,k-2)*f[i][j-1]%Mod)%Mod;\n\t}\n\tprintf(\"%lld\\n\",f[n][n]*fac[n]%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define N 5005\nusing namespace std;\nconst int mod=1e9+7;\nint n,k,f[N][N],jc[N],invjc[N];\nint power(int x,int y)\n{\n\tint ans=1;\n\tfor (;y;y>>=1,x=1LL*x*x%mod)\n\t{\n\t\tif (y&1) ans=1LL*ans*x%mod;\n\t}\n\treturn ans;\n}\nvoid init()\n{\n\tjc[0]=1;\n\tfor (int i=1;i<N;i++) jc[i]=1LL*jc[i-1]*i%mod;\n\tinvjc[N-1]=power(jc[N-1],mod-2);\n\tfor (int i=N-2;i>=0;i--) invjc[i]=1LL*invjc[i+1]*(i+1)%mod;\n}\nint C(int n,int m)\n{\n//\tcout<<\"!!!\"<<n<<\"!!!\"<<m<<\" \"<<jc[n]<<\" \"<<invjc[m]<<\" \"<<invjc[n-m]<<endl;\n\treturn 1LL*jc[n]*invjc[m]%mod*invjc[n-m]%mod;\n}\nsigned main()\n{\n\tinit();\n\tscanf(\"%lld%lld\",&n,&k);\n\tif (k==1)\n\t{\n\t\tprintf(\"%lld\\n\",1);\n\t\treturn 0;\n\t}\n\tf[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=0;j<=i;j++)\n\t\t{\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif (!j) continue;\n\t\t\t(f[i][j]+=1LL*f[i][j-1]*(n-j+1)%mod*C(n*k-i+(n-j+1)*(k-1)-1,k-2)%mod)%=mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define forE(i,x) for(int i=head[x];i!=-1;i=ne[i])\nusing namespace std;\ntypedef long long i64;\ntypedef unsigned long long u64;\ntypedef unsigned u32;\ntypedef pair<int,int> pin;\n#define mk(a,b) make_pair(a,b)\n#define lowbit(x) ((x)&(-(x)))\n#define sqr(a) ((a)*(a))\n#define clr(a) (memset((a),0,sizeof(a)))\n#define ls ((x)<<1)\n#define rs (((x)<<1)|1)\n#define mid (((l)+(r))>>1)\n#define pb push_back\n#define w1 first\n#define w2 second\ninline void read(int &x){\n\tx=0;int f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\tx*=f;\n}\ninline void judge(){\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n}\n/*******************************head*******************************/\nconst int mod=1e9+7;\ninline void add(int &x,int y){\n\tx+=y;if(x>=mod)x-=mod;\n}\nconst int maxn=2005*2005;\nint inv[maxn],fac[maxn],facinv[maxn];\nint f[2005][2005];\ninline int C(int n,int m){\n\treturn 1ll*fac[n]*facinv[m]%mod*facinv[n-m]%mod;\n}\ninline void prprpr(){\n\tinv[1]=1;\n\trep(i,2,2000*2000){\n\t\tinv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\t}\n\tfac[0]=1;facinv[0]=1;\n\trep(i,1,2000*2000){\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\t\tfacinv[i]=1ll*facinv[i-1]*inv[i]%mod;\n\t}\n}\nint main(){\n\tprprpr();\n\tint n,k;read(n);read(k);f[0][0]=1;\n\tif(k==1){\n\t\tputs(\"1\");return 0;\n\t}\n\trep(i,0,n)rep(j,0,i){\n\t\tif(i+1<=n)add(f[i+1][j],f[i][j]);\n\t\tif(j+1<=i)add(f[i][j+1],1ll*f[i][j]*C(n*k-i-(k-1)*j-1,k-2)%mod);\n\t}\n\tprintf(\"%lld\\n\",1ll*f[n][n]*fac[n]%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define C(i,j) (fac[i] * inv[j] % Mod * inv[(i)-(j)] % Mod)\nusing namespace std;\nconst ll N = 10000010;\nconst ll Mod = 1e9+7;\ninline ll read()\n{\n  ll p=0; ll f=1; char ch=getchar();\n  while(ch<'0' || ch>'9'){if(ch=='-') f=-1; ch=getchar();}\n  while(ch>='0' && ch<='9'){p=p*10+ch-'0'; ch=getchar();}\n  return p*f;\n}\n\nll n,k; ll fac[N],inv[N];\n\nll f[2010][2010];\nvoid upd(ll &x,ll y){x=(x+y)%Mod;}\n\nint main()\n{\n\n  n = read(); k = read();\n\n  fac[0] = 1; for(ll i=1;i<=n*k+n+k;i++) fac[i] = i;\n  inv[0] = inv[1] = 1; for(ll i=2;i<=n*k+n+k;i++) inv[i] = (Mod - Mod / i) * inv[Mod%i] % Mod;\n  for(ll i=1;i<=n*k+n+k;i++) fac[i] = fac[i-1] * i % Mod,inv[i] = inv[i-1] * inv[i] % Mod;\n\n  f[0][0] = 1; k--; if(!k){printf(\"1\\n\"); return 0;}\n  for(ll i=0;i<=n;i++)\n  {\n    for(ll j=i;j<=n;j++)\n    {\n      if(i) upd(f[i][j] , f[i-1][j]);\n      if(j) upd(f[i][j] , f[i][j-1] * C(j*k+i-1,k-1) % Mod);\n    }\n  }\n\n  return printf(\"%lld\\n\",f[n][n] * fac[n] % Mod),0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <string>\n# include <algorithm>\n# include <vector>\n# include <cstring>\n# include <stdio.h>\n# include <map>\n# include <queue>\n\n# define ll long long\n# define pii pair<int,int>\n# define FOR(a,b) for(int a=1; a<=b; a++)\n# define REP(a,b) for(int a=0; a<b; a++)\n# define FORU(a,b,c) for(int a=b; a<=c; a++)\n# define FORD(a,b,c) for(int a=b; a>=c; a--)\n\nusing namespace std;\n\nconst ll mod = 1e9 + 7;\nint N, K, dp[2005][2005];\nll f[4000005], inf[4000005];\n\nll mul(ll a, ll b){\n    return ((a%mod)*(b%mod))%mod;\n}\n\nll add(ll a, ll b){\n    return ((a%mod)+(b%mod))%mod;\n}\n\nll pw(ll b, ll e){\n    if(e==0) return 1ll;\n    ll t = pw(b,e/2);\n    if(e&1) return mul(b,mul(t,t));\n    return mul(t,t);\n}\n\nll modinv(ll x){\n    return pw(x, mod-2);\n}\n\nvoid precompute(){\n    f[0] = inf[0] = 1ll;\n    FOR(i,4000000){\n        f[i] = mul(f[i-1], i);\n        inf[i] = modinv(f[i]);\n    }\n}\n\nll C(ll n, ll r){\n    if(n < r) return 0;\n    return mul(f[n], mul(inf[n-r], inf[r]));\n}\n\nint main(){\n\n    ios :: sync_with_stdio(false);\n    cin >> N >> K;\n    precompute();\n\n    if(K==1){\n        cout << 1 << endl;\n        return 0;\n    }\n    \n    REP(i,N+1){\n        FORU(j,i,N){\n            if(i==0 && j==0) dp[i][j] = 1;\n            if(i-1 >= 0) dp[i][j] = dp[i-1][j];\n            if(j > i){\n                dp[i][j] = add(dp[i][j], mul(dp[i][j-1], C(i + j*(K-1) -1, K-2)));\n            }\n        }\n    }\n\n    ll ans = mul(dp[N][N], f[N]);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst long long N=2000+10;\nconst long long P=1e9+7;\nusing namespace std;\n\nlong long n,k,f[N][N];\nlong long fac[N*N],inv[N*N],fai[N*N],ma;\n\nlong long read()\n{\n\tlong long a,f=1;\n\tchar c;\n\tc=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t  if(c=='-') f=-1;\n\t  c=getchar();\n\t}\n\ta=c-'0';\n\tc=getchar();\n\twhile(c>='0'&&c<='9')\n\t{\n\t  a=a*10+c-'0';\n\t  c=getchar();\n\t}\n\treturn a*f;\n}\n\nlong long qpow(long long x,long long b)\n{\n\tlong long y;\n\tif(b==0) return 1;\n\tif(b==1) return x;\n\ty=qpow(x,b/2)%P;\n\ty=y*y%P;\n\tif(b%2) y=y*x%P;\n\treturn y;\n}\n\nint main()\n{\n\tlong long i,j,s,t;\n\tn=read(); k=read();\n\tif(k==1){printf(\"1\\n\"); return 0;}\n\tma=n*k;\n\tfac[0]=inv[0]=fai[0]=1;\n\tfac[1]=inv[1]=fai[1]=1;\n\tfor(i=2;i<=ma;i++)\n\t{\n\t  fac[i]=(fac[i-1]*i)%P;\n\t  inv[i]=(P-P/i)%P*inv[P%i]%P;\n\t  fai[i]=fai[i-1]*inv[i]%P;\n\t}\n//\tfor(i=1;i<=n;i++) cout<<inv[i]<<\" \";\n//\tcout<<endl;\n\tfor(i=0;i<=n;i++) f[i][0]=1;\n\tfor(i=1;i<=n;i++)\n\t  for(j=1;j<=i;j++)\n\t  {\n\t  \tf[i][j]=f[i-1][j]%P;\n\t  \ts=((n-i)%P+((n-j+1)*(k-1)%P)-1)%P;\n\t  \tt=(fac[s]*fai[k-2]%P)*fai[s-k+2]%P;\n\t  \tf[i][j]=(f[i][j]+(t*f[i][j-1]%P)*(n-j+1)%P)%P;\n\t  }\n/*\tfor(i=1;i<=n;i++)\n\t{\n\t  for(j=1;j<=i;j++) cout<<f[i][j]<<\" \";\n\t  cout<<endl;\n\t}*/\n\tprintf(\"%d\\n\",f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inv(x) power(x,Mod-2)\n#define upd(a,b) a=add(a,b)\nusing namespace std;\ntypedef long long ll;\nconst int Mod=1e9+7;\nint add(int a,const int b){a+=b;if(a>=Mod)a-=Mod;return a;}\nint sub(int a,const int b){a-=b;if(a<0)a+=Mod;return a;}\nint mul(const int a,const int b){return (ll)a*b%Mod;}\nint power(int x,int cs)\n{\n\tint ras=1;\n\twhile(cs)\n\t{\n\t\tif(cs&1) ras=mul(ras,x);\n\t\tx=mul(x,x);cs>>=1;\n\t}\n\treturn ras;\n}\nconst int N=2010,V=N*N,pn=4e6+5;\nint n,K;\nint dp[N][N],zp[V],fp[V];\nint C(int a,int b){return mul(zp[a],mul(fp[b],fp[a-b]));}\nint main()\n{\n\tint i,j,ans;\n\tzp[0]=fp[0]=1;\n\tfor(i=1;i<=pn;i++) zp[i]=mul(zp[i-1],i);\n\tfp[pn]=inv(zp[pn]);\n\tfor(i=pn-1;i>=1;i--) fp[i]=mul(fp[i+1],i+1);\n\tscanf(\"%d%d\",&n,&K);\n\tif(K==1)\n\t{\n\t\tputs(\"1\");return 0;\n\t}\n\tdp[0][0]=1;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tfor(j=0;j<=i;j++)\n\t\t{\n\t\t\tdp[i][j]=mul(dp[i-1][j],C((K-1)*i+j-1,K-2));\n\t\t\tif(j>0) upd(dp[i][j],dp[i][j-1]);\n\t\t}\n\t}\n\tans=mul(dp[n][n],zp[n]);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N=2005,M=1e5+5;\nint fa[N];\nint sz[N];\nint find_father(int x){\n    if(fa[x]==x)\n        return x;\n    return fa[x]=find_father(fa[x]);\n}\nvoid Merge(int x,int y){\n    find_father(x);\n    find_father(y);\n    if(fa[x]==fa[y])\n        return ;\n    sz[fa[y]]+=sz[fa[x]];\n    fa[fa[x]]=fa[y];\n}\nint n,m;\nint a[M],b[M];\nint main()\n{\n    //freopen(\"rally.in\",\"r\",stdin);\n    //freopen(\"rally.out\",\"w\",stdout);\n    scanf(\"%d%d\",&n,&m);\n    if(n>2000)\n        return 0;\n    for(int i=1;i<=m;i++){\n        scanf(\"%d%d\",&a[i],&b[i]);\n    }\n    int q;\n    scanf(\"%d\",&q);\n    while(q--){\n        int x,y,z;\n        scanf(\"%d%d%d\",&x,&y,&z);\n        for(int i=1;i<=n;i++)\n            fa[i]=i,sz[i]=1;\n        for(int i=1;i<=m;i++){\n            Merge(a[i],b[i]);\n            int f1=find_father(x),f2=find_father(y);\n            if(f1==f2){\n                if(sz[f1]>=z){\n                    printf(\"%d\\n\",i);\n                    break;\n                }\n            }\n            else{\n                if(sz[f1]+sz[f2]>=z){\n                    printf(\"%d\\n\",i);\n                    break;\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define run(v) for(int k=head[v];k;k=e[k].ne)\n#define v e[k].t\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef pair<int,int> pa;\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\nconst int N=5e3+5,M=1e7+5,INF=1e9,mod=1e9+7;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);}\nil void gen(){freopen(\"data.in\",\"w\",stdout);}\nll fac[M],ifac[M],dp[N][N];\nint n,k;\nil ll C(ll n,ll m){\n\tif(n<0||m<0||n<m)return 0;\n\treturn fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\nint main(){\n\tread(n,k);\n\tif(k==1)return puts(\"1\"),0;\n\tfac[0]=1;rep(i,1,n*k)fac[i]=(fac[i-1]*i)%mod;\n\tifac[n*k]=qpow(fac[n*k],mod-2,mod);\n\trepd(i,n*k-1,0)ifac[i]=ifac[i+1]*(i+1)%mod;\n\tdp[0][0]=1;\n\trep(i,0,n)rep(j,i,n){\n\t\tif(i)dp[i][j]=dp[i-1][j];\t\n\t\tif(j)dp[i][j]=(dp[i][j]+dp[i][j-1]*C(i+j*(k-1)-1,k-2))%mod;\n\t}\n\tcout<<fac[n]*dp[n][n]%mod;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 1000000007\n#define ll long long\n#define N 2001\nint n, k;\nll fac[N * N], inv[N * N], dp[N][N] = {1};\nint Qpow(int x, int n) {\n    int s = 1;\n    while (n) {\n        if (n & 1) s = s * x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return s;\n}\nll C(int n, int m) {\n    if (m < 0 || m > n) return 0;\n    return fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\nint main() {\n    scanf(\"%d%d\", &n, &k);\n    if (k == 1) {\n        puts(\"1\");\n        return 0;\n    }\n    for (int i = fac[0] = 1; i <= n * k; i++) fac[i] = fac[i - 1] * i % mod;\n    inv[n * k] = Qpow(fac[n * k], mod - 2);\n    for (int i = n * k; i; i--) inv[i + 1] = inv[i] * i % mod;\n    for (int i = 0; i <= n; i++)\n        for (int j = i; j <= n; j++) {\n            dp[i][j + 1] = (dp[i][j + 1] + dp[i][j]) % mod;\n            ll s = C(k * (n - i) - (j - i) - 1, k - 2) + dp[i + 1][j];\n            dp[i + 1][j] = dp[i][j] * s % mod;\n        }\n    printf(\"%lld\", dp[n][n] * fac[n] % mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline void _read(T &x)\n{\n\tx = 0;\n\tchar t = getchar();\n\twhile (!isdigit(t) && t != '-') t = getchar();\n\tif (t == '-')\n\t{\n\t\t_read(x);\n\t\tx *= -1;\n\t\treturn ;\n\t}\n\twhile (isdigit(t))\n\t\tx = x * 10 + t - '0', t = getchar();\n} \nconst int MAXN = 2005, MAXM = 2000 * 2000 + 1e5 + 5, mo = 1e9 + 7;\nint n, k, f[MAXN][MAXN], fac[MAXM], invfac[MAXM];\ninline int C(int n, int m)\n{\n\treturn 1ll * fac[n] * invfac[m] % mo * invfac[n - m] % mo;\n}\nint main()\n{\n\t_read(n), _read(k);\n\tinvfac[0] = fac[0] = fac[1] = invfac[1] = 1;\n\tif(k == 1)return puts(\"1\"), 0;\n\tfor(int i = 2; i <= MAXM - 5; ++i)fac[i] = 1ll * fac[i - 1] * i % mo, invfac[i] = 1ll * (mo - mo / i) * invfac[mo % i] % mo;\n\tfor(int i = 2; i <= MAXM - 5; ++i)invfac[i] = 1ll * invfac[i] * invfac[i - 1] % mo;\n\tf[1][0] = 1;\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 0; j <= i; ++j)\n\t\t{\n\t\t\tif(i ^ j)(f[i][j + 1] += f[i][j] %= mo);\n\t\t\tif(i ^ n)(f[i + 1][j] += 1ll * f[i][j] * C((k - 2) + (i * (k - 1) + j), k - 2) % mo) %= mo;\n\t\t}\n\tcout << 1ll * f[n][n]*fac[n] % mo;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int MAXN=4000000;\nconst int MOD=1e9+7;\nlong long a[MAXN+10],pre[MAXN+10],n,k,f[2200][2200];\nlong long C(long long p,int x){\n\treturn 1ll*(pre[p]*a[x])%MOD*a[p-x]%MOD;\n}\nlong long pp(int x,int p){\n\tlong long ans=1,m=x;\n\twhile(p){\n\t\tif(p&1)(ans*=m)%=MOD;\n\t\tp>>=1;(m*=m)%=MOD;\n\t}\n\treturn ans;\n}\nint main(){\n//\tfreopen(\"1.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&k);\n    if(k==1){\n        printf(\"1\");\n        return 0;\n    }\n\tpre[0]=1;\n\tfor(int i=1;i<=MAXN;i++)pre[i]=(1ll*i*pre[i-1])%MOD;\n\ta[MAXN]=pp(pre[MAXN],MOD-2);for(int i=MAXN-1;i>=0;i--)a[i]=a[i+1]*(i+1)%MOD;\n\tf[0][0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(i)f[i][j]=(f[i-1][j]+f[i][j])%MOD;\n\t\t\tif(j)f[i][j]=(f[i][j]+1ll*f[i][j-1]*C(n*k-i-(j-1)*(k-1)-1,k-2)%MOD)%MOD;\n\t\t}\n\t}\n\tlong long ans=1ll*f[n][n]*pre[n]%MOD;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 2048, M = 5e6 + 10, Mod = 1e9 + 7;\n\ninline void Read(int &x)\n{\n\tx = 0; register char cc = '\\0'; int fff = 1;\n\tfor (; cc < '0' || cc > '9'; cc = getchar())\n\t\tif (cc == '-') fff = -1;\n\tfor (; cc >= '0' && cc <= '9'; cc = getchar())\n\t\tx = (x << 1) + (x << 3) + (cc & 15);\n\tx *= fff;\n}\n\nint n, K, num, f[N][N], fac[M + 10], ifac[M + 10];\n\ninline int Pow(int x, int y) {\n\tint sum = 1;\n\twhile (y) {\n\t\tif (y & 1) sum = (LL)sum * x % Mod;\n\t\tx = (LL)x * x % Mod; y >>= 1;\n\t}\n\treturn sum;\n}\n\ninline int C(int x, int y) {\n\tif (x < y || y < 0) return 0;\n\treturn (LL)fac[x] * ifac[x - y] % Mod * ifac[y] % Mod;\n}\n\nint main()\n{\n\tfac[0] = ifac[0] = 1;\n\tfor (int i = 1; i <= M; ++i) fac[i] = (LL)fac[i - 1] * i % Mod;\n\tifac[M] = Pow(fac[M], Mod - 2);\n\tfor (int i = M - 1; i >= 1; --i) ifac[i] = (LL)ifac[i + 1] * (i + 1) % Mod;\n\t\n\tRead(n), Read(K);\n\tif (K == 1) {\n\t\tprintf(\"1\\n\"); /*!!!*/\n\t\treturn 0;\n\t}\n\tnum = (LL)n * K;\n\t\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tif (i > j) f[i][j] = f[i - 1][j];\n\t\t\tif (j > 0) f[i][j] = (f[i][j] + (LL)f[i][j - 1] * (n - (j - 1)) % Mod * C(num - (K - 1) * (j - 1) - i - 1,K - 2) % Mod) % Mod;\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", f[n][n]);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define LL long long\n//#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)\n//char buf[(1 << 21) + 1], *p1 = buf, *p2 = buf;\ninline int read() {\n\tbool f=0;int x=0;char c=getchar();\n\twhile(c<'0'||'9'<c){if(c==EOF)exit(0);if(c=='-')f=1;c=getchar();}\n\twhile('0'<=c&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();\n\treturn !f?x:-x;\n}\n#define MAXN 2000\n#define INF 0x3f3f3f3f\n#define Mod (int)(1e9+7)\nLL fac[MAXN*MAXN+5],inv[MAXN*MAXN+5];\nLL Pow(LL x,LL y){\n\tLL ret=1;\n\twhile(y){\n\t\tif(y&1) ret=ret*x%Mod;\n\t\tx=x*x%Mod,y>>=1;\n\t}\n\treturn ret;\n}\nvoid Prepare(){\n\tfac[0]=1;\n\tfor(int i=1;i<=MAXN*MAXN;i++)\n\t\tfac[i]=fac[i-1]*i%Mod;\n\tinv[MAXN*MAXN]=Pow(fac[MAXN*MAXN],Mod-2);\n\tfor(int i=MAXN*MAXN-1;i>=0;i--)\n\t\tinv[i]=inv[i+1]*(i+1)%Mod;\n\treturn ;\n}\nLL f[MAXN+5][MAXN+5];\nLL C(int n,int m){return fac[n]*inv[m]%Mod*inv[n-m]%Mod;}\nint main(){\n\tPrepare();\n\tint n=read(),k=read();\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t\tf[i][j]=f[i-1][j]+C(n-i+(n-(j-1))*(k-1),k-2)*f[i][j-1];\n\tprintf(\"%lld\\n\",f[n][n]*fac[n]%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#define re register\n#define ll long long\n#define N 2005\n#define MAXN 4000000\nusing namespace std;\ninline int read(){\n    int x=0,f=1;\n    char c;\n    for(c=getchar();(!isdigit(c))&&(c!='-');c=getchar());\n    if(c=='-') f=-1,c=getchar();\n    for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';\n    return x*f;\n}\ninline void print(int number){\n    const int SIZE=25; int un=1,extent=0; char letter[SIZE];\n    if(number<0){ number=-number; un=-1;}\n    while(number){ letter[++extent]=number%10+'0'; number/=10;}\n    if(!~un) putchar('-'); if(!extent) putchar('0');\n    else while(extent) putchar(letter[extent--]);\n}\ninline int getint(){\n    char ch = getchar(); int x = 0;\n    while (ch < '0'|| ch > '9') ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    return x;\n}\ninline void putint(long long x){\n\tif (x > 9) putint(x / 10);\n\tputchar(x % 10 + '0');\n}\n//\nconst int Mod=1e9+7;\nint n, k;\nll f[N][N],f1[MAXN+5],f2[MAXN+5];\ninline ll Equation(int n,int m){\n\treturn (((f1[m] * f2[n]) % Mod) * f2[m - n]) % Mod;\n}\ninline ll Answer(ll x,int P){\n    ll ans = 1, m = x;\n    while(P){\n        if(P&1)\n\t\t\t(ans *= m) %= Mod;\n        P >>= 1;\n\t\t(m*=m) %= Mod;\n    }\n    return ans;\n}\nint main(){\n//    scanf(\"%d%d\",&n,&k);\n\tn = read(), k = read();\n\t\n    if(k==1)//特判 \n\t{\n\t\tprintf(\"%d\\n\",1);\n\t\treturn 0;\n\t}\n\t\n    f1[0] = 1;\n\tfor(re int i = 1; i <= MAXN; ++i)\n\t\tf1[i] = (f1[i-1] * i) % Mod;\n\t\t\n    f2[MAXN] = Answer(f1[MAXN], Mod-2);\n    \n\tfor(re int i = MAXN - 1; i>=0; --i)\n\t\tf2[i] = (f2[i + 1] * (i + 1)) % Mod;\n\t\t\n    f[0][0]=1;\n    \n    for(re int i = 1;i <= n; ++i){\n        for(re int j = 0;j <= i; ++j){\n            f[i][j] = f[i - 1][j];\n            if(!j)\n\t\t\t\tcontinue;\n            (f[i][j] += f[i][j - 1] * (n - j + 1) % Mod * Equation(k - 2,n - i + (n - j + 1) * (k - 1) - 1) % Mod) %= Mod;\n        }\n    }\n//    printf(\"%lld\\n\",f[n][n]);\n\tprint(f[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\nconst LL MOD=1000000007;\nLL dp[2005][2005],n,k,fac[4000005],inv[4000005];\nLL QuickPow(LL x,LL p)\n{\n\tLL base=x,ans=1;\n\twhile(p)\n\t{\n\t\tif(p&1)\tans*=base,ans%=MOD;\n\t\tp>>=1;\n\t\tbase*=base;\n\t\tbase%=MOD;\n\t}\n\treturn ans;\n}\nLL C(LL n,LL m){return fac[m]*inv[n]%MOD*inv[m-n]%MOD;}\nint main(){\n\tfac[0]=1;\n\tscanf(\"%lld %lld\",&n,&k);\n\tif(k==1)\treturn puts(\"1\")&0;\n\tfor(LL i=1;i<=n*k;++i)\tfac[i]=fac[i-1]*i%MOD;\n\tinv[n*k]=QuickPow(fac[n*k],MOD-2);\n\tfor(LL i=n*k-1;~i;--i)\tinv[i]=inv[i+1]*(i+1)%MOD;\n\tfor(LL i=0;i<=n;++i)\tdp[i][0]=1;\n\tfor(LL i=1;i<=n;++i)\n\t{\n\t\tfor(LL j=1;j<=i;++j)\n\t\t{\n\t\t\tdp[i][j]=(dp[i-1][j]+dp[i][j-1]*(n-j+1)%MOD*C(k-2,n*k-i-(j-1)*(k-1)-1)%MOD)%MOD;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define rep(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\nconst int mod=1e9+7;\nconst int N=2010,M=4000100;\nconst int maxn=4000000;\nint dp[N*2][N];\nint cj[M],inv[M];\nint ans;\n\nint C(int n,int m){\n\treturn 1ll*cj[n]*inv[m]%mod*inv[n-m]%mod;\n}\n\nint power(int x,int y){\n\tint ret=1;\n\tfor(;y;y>>=1,x=1ll*x*x%mod){\n\t\tif(y&1)\tret=1ll*ret*x%mod;\n\t}\n\treturn ret;\n}\n\nint main(){\n\t//freopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\tregister int n,K,i,j,k;\n\tscanf(\"%d%d\",&n,&K);\n\tif(K==1){printf(\"1\\n\");return 0;}\n\tfor(cj[0]=1,i=1;i<=maxn;i++)\tcj[i]=1ll*cj[i-1]*i%mod;\n\tinv[maxn]=power(cj[maxn],mod-2);inv[0]=1;\n\tfor(i=maxn-1;i;i--)\tinv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tdp[0][0]=1;\n\trep(i,0,2*n-1)\trep(j,0,n)\tif(dp[i][j]){\n\t\tk=(i-j)/2;\n\t\tdp[i+1][j+1]=(dp[i+1][j+1]+dp[i][j])%mod;\t\t\n\t\tif(j)\tdp[i+1][j-1]=(dp[i+1][j-1]+1ll*dp[i][j]*C(n*K-i-1-(K-2)*k,K-2))%mod;\n\t}\n\tans=1ll*dp[2*n][0]*cj[n]%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\nll p=1000000007;\nll fac[4000010];\nll ifac[4000010];\nll inv[4000010];\nvoid init(int n)\n{\n\tint i;\n\tfac[0]=fac[1]=ifac[0]=ifac[1]=inv[0]=inv[1]=1;\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tinv[i]=-(p/i)*inv[p%i]%p;\n\t\tfac[i]=fac[i-1]*i%p;\n\t\tifac[i]=ifac[i-1]*inv[i]%p;\n\t}\n}\nll c(int x,int y)\n{\n\tif(x<y)\n\t\treturn 0;\n\treturn fac[x]*ifac[y]%p*ifac[x-y]%p;\n}\nll f[2010][2010];\nint main()\n{\n\tint n,k;\n\tscanf(\"%d%d\",&n,&k);\n\tif(k<=1)\n\t{\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tinit(n*k);\n\tint i,j;\n\tf[0][0]=1;\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=n;j>=0;j--)\n\t\t{\n\t\t\tif(j<=i)\n\t\t\t\tf[i][j]+=f[i-1][j-1]*c(k*i-j-1,k-2)%p;\n\t\t\tf[i][j]=(f[i][j]+f[i][j+1])%p;\n\t\t}\n\tll ans=(f[n][0]%p+p)%p;\n\tans=ans*fac[n]%p;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<bits/stdc++.h>\n#define mod 1000000007\n#define maxn 40000095\nusing namespace std;\nint f[2005][2005],fac[maxn],inv[maxn];\nint add(int a,int b){a+=b; return a>=mod?a-mod:a;}\nint ksm(int a,int b)\n{\n\tint s=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1) s=1ll*s*a%mod;\n\treturn s;\n}\nint n,k;\nvoid Pre()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<maxn;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[maxn-1]=ksm(fac[maxn-1],mod-2);\n\tfor(int i=maxn-2;i>=0;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;\n}\nint C(int n,int m){return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint main()\n{\n\tPre();\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1) return puts(\"1\"),0;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(j) f[i][j]=add(f[i][j],1ll*C(n*k-i-(j-1)*(k-1)-1,k-2)*(n-j+1)%mod*f[i][j-1]%mod);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int maxN = 2e3 + 13, mod = 1e9 + 7;\nint n, k, dp[maxN][maxN], fac[maxN * maxN], rfac[maxN * maxN];\n\nint pw (int a, int b) {\n    int ret = 1;\n    for (; b; b >>= 1, a = 1ll * a * a % mod)\n\tif (b & 1)\n\t    ret = 1ll * ret * a % mod;\n    return ret;\n}\n\nint c (int a, int b) {\n    return 1ll * fac[b] * rfac[a] % mod * rfac[b - a] % mod;\n}\n\nint32_t main () {\n    cin >> n >> k;\n    dp[0][0] = 1;\n    fac[0] = rfac[0] = 1;\n    for (int i = 1; i <= n * k; i++) {\n\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\trfac[i] = 1ll * rfac[i - 1] * pw(i, mod - 2) % mod;\n    }\n\n    for (int i = 1; i <= n; i++)\n\tfor (int j = 0; j <= i; j++) {\n\t    if (j)\n\t\tdp[i][j] = dp[i][j - 1];\n\t    dp[i][j] = (dp[i][j] + (1ll * dp[i - 1][j] * c(k - 2, i * (k - 1) + j - 1) % mod)) % mod;\n\t    // cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t}\n    //cout << dp[n][n] << endl;\n    if (k == 1)\n\treturn cout << fac[n] << endl, 0;\n    cout << 1ll * dp[n][n] * fac[n] % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define all(x)  x.begin(), x.end()\n#define mp      make_pair\n#define pii     pair<int, int>\n#define ll      long long\n\nstatic const int MOD = 1000000007;\n\nlong long inv(long long a) { //フェルマーの小定理と繰り返し2乗法による逆元\n        long long res = 1;\n        long long n = MOD - 2;\n        while (n > 0) {\n                if (n & 1) res = res * a % MOD;\n                a = a * a % MOD;\n                n >>= 1;\n        }\n        return res;\n}\n\nlong long fact[4040404];\nlong long invfact[4040404];\n\nvoid init() {\n        fact[0] = 1;\n        for (int i = 1; i < 4040404; i ++) fact[i] = (fact[i - 1] * i) % MOD;\n        invfact[4040403] = inv(fact[4040403]);\n        for (int i = 4040402; i >= 0; i --) invfact[i] = (invfact[i + 1] * (i + 1)) % MOD;\n}\n\nlong long dp[2020][2020];\n\nvoid solve() {\n        init();\n        int n, k;\n        cin >> n >> k;\n        if (k == 1) {\n                cout << 1 << endl;\n                return;\n        }\n        memset(dp, 0, sizeof dp);\n        dp[0][1] = 1LL;\n        for (int i = 0; i <= n; i ++) {\n                for (int j = i; j <= n; j ++) {\n                        if (i != 0) dp[i][j] = dp[i - 1][j]; \n                        if (i != j) {\n                                //dp[i][j] = (dp[i][j] + dp[i][j - 1] * nCr(i + j * (k - 1) - 1, k - 2) % MOD) % MOD;\n                                long long ncr = fact[i + j * (k - 1) - 1];\n                                ncr = ncr * invfact[i + j * (k - 1) - 1 - (k - 2)] % MOD;\n                                ncr = ncr * invfact[k - 2] % MOD;\n                                dp[i][j] = (dp[i][j] + dp[i][j - 1] * ncr % MOD) % MOD;\n                        }\n                        //cerr << \"dp[\" << i << \"][\" << j << \"] = \" << dp[i][j] << endl;\n                }\n        }\n        cout << dp[n][n] * fact[n] % MOD << endl;\n        return;\n}\n\nint main() {\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n\n        //int T;\n        //freopen(\"a.in\", \"r\", stdin);\n        //cin >> T;\n        //while (T --) solve();\n        \n        solve();\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\nconst int N=2010,Mod=1e9+7;\n\nint n,k,fact[N*N],inv[N*N],f[2*N][N];\n\nvoid Init() { scanf(\"%d%d\",&n,&k); }\n\nvoid Prepare()\n{\n\tfact[0]=1; for (int i=1;i<=n*k;++i) fact[i]=1ll*fact[i-1]*i%Mod;\n\tinv[0]=inv[1]=1; for (int i=2;i<=n*k;++i) inv[i]=1ll*(Mod-Mod/i)*inv[Mod%i]%Mod;\n\tfor (int i=1;i<=n*k;++i) inv[i]=1ll*inv[i-1]*inv[i]%Mod;\n}\n\nint Calc(int n,int m) { if (n<0 || n<m) return 0; return 1ll*fact[n]*inv[n-m]%Mod*inv[m]%Mod; }\n\nvoid Solve()\n{\n\tif (k==1) { printf(\"1\\n\"); return ; }\n\tPrepare();\n\tf[0][0]=1;\n\tfor (int i=0;i<2*n;++i)\n\t\tfor (int j=0;j<=i && j<=n;++j)\n\t\t\tif (f[i][j])\n\t\t\t{\n\t\t\t\tif (j<n) f[i+1][j+1]=(f[i+1][j+1]+f[i][j])%Mod;\n\t\t\t\tif (j>0) f[i+1][j-1]=(f[i+1][j-1]+1ll*f[i][j]%Mod*Calc(n*k-(i-j)/2*k-j-1,k-2)%Mod)%Mod;\n\t\t\t}\n\tprintf(\"%lld\\n\",1ll*f[2*n][0]*fact[n]%Mod);\n}\n\nint main()\n{\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2010, MOD = (int)(1e9 + 7);\nint dp[N][N],n,k;\ntypedef long long ll;\nll power(ll a,int b) {\n  ll ret = 1;\n  while (b) {\n    if (b&1) ret = 1ll * ret * a % MOD;\n    a = 1ll * a * a % MOD;\n    b >>= 1;\n  }\n  return ret;\n}\nll jc[N * N],inv[N * N];\nll comb(int a,int b) {\n  if (a < 0 || b < 0 || a < b) return 0;\n  return 1ll * jc[a] * inv[b] % MOD * inv[a-b] % MOD;\n}\nint main() {\n  scanf(\"%d%d\",&n,&k);\n  if (k == 1) return puts(\"1\"), 0;\n  jc[0] = 1;\n  for (int i = 1 ; i <= n * k ; ++ i)\n    jc[i] = 1ll * jc[i-1] * i % MOD;\n  inv[n*k] = power(jc[n*k],MOD-2);\n  for (int i = n*k-1 ; i >= 0 ; -- i)\n    inv[i] = 1ll * inv[i+1] * (i+1) % MOD;\n  dp[0][0] = 1;\n  for (int i = 0 ; i <= n ; ++ i)\n    for (int j = 0 ; j <= i ; ++ j) {\n      (dp[i+1][j] += dp[i][j]) %= MOD;\n      if (i > j) (dp[i][j+1] += 1ll * comb(n*k-j*k-(i-j)-1,k-2) * dp[i][j] % MOD) %= MOD;\n    }\n  printf(\"%lld\\n\",1ll * dp[n][n] * jc[n] % MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 2e3 + 32, M = 5e6 + 65, P = 1e9 + 7;\n\nint pw(int x, int y) {\n\tint r = 1;\n\tfor (; y; y >>= 1, x = 1ll * x * x % P)\n\t\tif (y & 1) r = 1ll * r * x % P;\n\treturn r;\n}\n\nint fac[M], ifac[M];\nint c(int n, int m) { return 1ll * n[fac] * m[ifac] % P * (n - m)[ifac] % P; }\n\nint n, k, dp[N][N];\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tif (k == 1) return puts(\"1\"), 0;\n\t0 [fac] = 0 [ifac] = 1;\n\tfor (int i = 1; i <= n * k; i++) i[fac] = 1ll * (i - 1)[fac] * i % P;\n\t(n * k)[ifac] = pw((n * k)[fac], P - 2);\n\tfor (int i = n * k - 1; i >= 1; i--) i[ifac] = 1ll * (i + 1)[ifac] * (i + 1) % P;\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int j = 0; j <= i; j++)\n\t\t\tif (i || j)\n\t\t\t\tdp[i][j] = (dp[i - 1][j] +\n\t\t\t\t\t\t\t(n - j + 1ll) * c(n * k - i - (j - 1) * (k - 1) - 1, k - 2) %\n\t\t\t\t\t\t\t\tP * dp[i][j - 1]) %\n\t\t\t\t\t\t   P;\n\t\t\telse\n\t\t\t\tdp[0][0] = 1;\n\tprintf(\"%d\", dp[n][n]);\n}"
  },
  {
    "language": "C++",
    "code": "/* In the name of Allah */\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2000 + 5, P = 1e9 + 7;\nint n, k, fact[N * N], rev[N * N], dp[N][N];\n\nint power(int a, int b) {\n\tif (!b)\n\t\treturn 1;\n\tint ans = power(a, b >> 1);\n\tans = 1LL * ans * ans % P;\n\tif (b & 1)\n\t\tans = 1LL * ans * a % P;\n\treturn ans;\n}\n\nint C(int n, int k) {\n\treturn 1LL * fact[n] * rev[k] % P * rev[n - k] % P;\n}\n\nvoid readInput() {\n\tcin >> n >> k;\n}\n\nvoid solve() {\n\tif (k == 1)\n\t\treturn;\n\tfact[0] = rev[0] = dp[1][0] = dp[1][1] = 1;\n\tfor (int i = 1; i < n * k; i++)\n\t\trev[i] = power(fact[i] = 1LL * fact[i - 1] * i % P, P - 2);\n\tfor (int i = 2; i <= n; i++) {\n\t\tfor (int j = i; j; j--)\n\t\t\tdp[i][j] = (1LL * i * C(k * i - j - 1, k - 2) % P * dp[i - 1][j - 1] % P + dp[i][j + 1]) % P;\n\t\tdp[i][0] = dp[i][1];\n\t}\n}\n\nvoid writeOutput() {\n\tif (k == 1) {\n\t\tcout << \"1\\n\";\n\t\treturn;\n\t}\n\tcout << dp[n][0] << endl;\n}\n\nint main() {\n\tios_base :: sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\treadInput(), solve(), writeOutput();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\nconst int MAXN=4E6+10;\nconst int P=1E9+7;\n\ntemplate<typename T1,typename T2>\n\tvoid Inc(T1 &a,T2 b){a+=b;if(a>=P) a-=P;}\n\ntemplate<typename T1,typename T2>\n\tvoid Dec(T1 &a,T2 b){a-=b;if(a<0) a+=P;}\n\ntemplate<typename T1,typename T2>\n\tT1 Add(T1 a,T2 b){a+=b;return a>=P?a-P:a;}\n\ntemplate<typename T1,typename T2>\n\tT1 Sub(T1 a,T2 b){a-=b;return a<0?a+P:a;}\n\nll ksm(ll a,ll b)\n{\n\tll ret=1;\n\tfor(;b;b>>=1,(a*=a)%=P)\n\t\tif(b&1)\n\t\t\t(ret*=a)%=P;\n\treturn ret;\n}\n\nint n,k;\nll fac[MAXN],ifac[MAXN],f[2010][2010];\n\nll C(int n,int m)\n{\n\tif(n<0||m<0||n<m)\n\t\treturn 0;\n\treturn fac[n]*ifac[n-m]%P*ifac[m]%P;\n}\n\nint main()\n{\n\tfac[0]=ifac[0]=1;\n\tfor(int i=1;i<MAXN;i++)\n\t\tfac[i]=fac[i-1]*i%P;\n\tifac[MAXN-1]=ksm(fac[MAXN-1],P-2);\n\tfor(int i=MAXN-2;i;i--)\n\t\tifac[i]=ifac[i+1]*(i+1)%P;\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1)\n\t\treturn puts(\"1\"),0;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i;~j;j--)\n\t\t\tf[i][j]=Add(f[i][j+1],j?(C(i*k-j-1,k-2)*f[i-1][j-1]%P):0);\n\tprintf(\"%lld\\n\",f[n][0]*fac[n]%P);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int mod = 1e9 + 7;\nconst int MAXN = 2005, MAXS = MAXN * MAXN;\n\ntemplate<typename _T>\nvoid read( _T &x )\n{\n\tx = 0;char s = getchar();int f = 1;\n\twhile( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}\n\twhile( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}\n\tx *= f;\n}\n\ntemplate<typename _T>\nvoid write( _T x )\n{\n\tif( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }\n\tif( 9 < x ){ write( x / 10 ); }\n\tputchar( x % 10 + '0' );\n}\n\nint f[MAXN][MAXN];\nint fac[MAXS], ifac[MAXS];\nint N, K;\n\nint qkpow( int, int );\nint inv( const int a ) { return qkpow( a, mod - 2 ); }\nvoid sub( int &x, const int v ) { x = ( x < v ? x - v + mod : x - v ); }\nvoid add( int &x, const int v ) { x = ( x + v >= mod ? x + v - mod : x + v ); }\n\nint qkpow( int base, int indx )\n{\n\tint ret = 1;\n\twhile( indx )\n\t{\n\t\tif( indx & 1 ) ret = 1ll * ret * base % mod;\n\t\tbase = 1ll * base * base % mod, indx >>= 1;\n\t}\n\treturn ret;\n}\n\nvoid init( const int siz )\n{\n\tfac[0] = ifac[0] = 1;\n\tfor( int i = 1 ; i <= siz ; i ++ ) fac[i] = 1ll * fac[i - 1] * i % mod;\n\tifac[siz] = inv( fac[siz] );\n\tfor( int i = siz - 1 ; ~ i ; i -- ) ifac[i] = 1ll * ifac[i + 1] * ( i + 1 ) % mod;\n}\n\nint C( const int n, const int m ) { return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod; }\n\nint main()\n{\n\tread( N ), read( K );\n\tif( K == 1 ) { puts( \"1\" ); return 0; }\n\tinit( N * K );\n\tfor( int i = 0 ; i <= K ; i ++ ) f[i][0] = 1;\n\tfor( int i = 1 ; i <= K ; i ++ )\n\t\tfor( int j = 1 ; j <= i ; j ++ )\n\t\t{\n\t\t\tf[i][j] = f[i - 1][j];\n\t\t\tint t = N * K - i - ( K - 1 ) * ( j - 1 ) - 1;\n\t\t\tadd( f[i][j], 1ll * f[i][j - 1] * ( N - j + 1 ) % mod * C( t, K - 2 ) % mod );\n\t\t}\n\twrite( f[K][N] ), putchar( '\\n' );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#ifdef WIN32\n#define LLIO \"%I64d\"\n#else\n#define LLIO \"%lld\"\n#endif\n\nstruct FastIO {\n    inline FastIO& operator >> (int& x) {\n        x = 0; char f = 0, ch = getchar();\n        while(ch > '9' || ch < '0') f |= (ch == '-'), ch = getchar();\n        while(ch <= '9' && ch >= '0') x = x * 10 + ch - 48, ch = getchar();\n        return x = (f ? -x : x), *this;\n    }\n    inline FastIO& operator >> (long long& x) {\n        x = 0; char f = 0, ch = getchar();\n        while(ch > '9' || ch < '0') f |= (ch == '-'), ch = getchar();\n        while(ch <= '9' && ch >= '0') x = x * 10 + ch - 48, ch = getchar();\n        return x = (f ? -x : x), *this;\n    }\n    inline FastIO& operator >> (double& x) {\n        x = 0; char f = 0, ch = getchar();\n        double d = 0.1;\n        while(ch > '9' || ch < '0') f |= (ch == '-'), ch = getchar();\n        while(ch <= '9' && ch >= '0') x = x * 10 + ch - 48, ch = getchar();\n        if(ch == '.') {\n            ch = getchar();\n            while(ch <= '9' && ch >= '0') x += d * (ch ^ 48), d *= 0.1, ch = getchar();\n        }\n        return x = (f ? -x : x), *this;\n    }\n}rin;\nconst int mod = 1e9 + 7;\nll f[2500][2500];\nll jc[10000007], inv[10000007];\nll ksm(ll x, int p) {\n\tll ans = 1;\n\twhile(p) {\n\t\tif(p & 1) ans = ans * x % mod;\n\t\tx = x * x % mod;\n\t\tp >>= 1;\n\t}\n\treturn ans;\n}\nll C(int n, int m) {\n\tif(m > n) return 0;\n\treturn jc[n] * inv[m] % mod * inv[n - m] % mod;\n}\nint main() {\n\tjc[0] = inv[0] = 1;\n\tfor(int i = 1 ; i <= 10000000 ; ++ i) jc[i] = jc[i - 1] * i % mod;\n\tinv[10000000] = ksm(jc[10000000], mod - 2);\n\tfor(int i = 9999999 ; i >= 1 ; -- i) inv[i] = inv[i + 1] * (i + 1) % mod;\n\tint n, k; rin >> n >> k;\n\tif(k == 1) {puts(\"1\"); return 0;}\n\tf[1][0] = 1;\n\tfor(int i = 1 ; i <= n ; ++ i) {\n\t\tfor(int j = 0 ; j <= i ; ++ j) {\n\t\t\tif(i > j) f[i][j] = f[i][j] + f[i - 1][j];\n\t\t\tif(j) f[i][j] = (f[i][j] + f[i][j - 1] * C(n * k - i - (j - 1) * (k - 1) - 1, k - 2) % mod) % mod;\n\t\t}\n\t}\n\tprintf(LLIO \"\\n\", f[n][n] * jc[n] % mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#define ll long long\n#define res register ll\n#define N 2005\nusing namespace std;\nll inv[N*N+N+N],jie[N*N+N+N],k,n,f[N][N];\nconst ll mod=1e9+7;\ninline ll read()\n{\n  ll X=0,w=0;\n  char ch=0;\n  while(!isdigit(ch))\n  {\n    w|=ch=='-';\n    ch=getchar();\n  }\n  while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();\n  return w?-X:X;\n}\ninline ll quickpow(res base,res num)\n{\n  res ans=1;\n  for(; num; num>>=1,base=1LL*base*base%mod)\n    if(num&1)\n      ans=1LL*ans*base%mod;\n  return ans;\n}\ninline void init()\n{\n  jie[0]=jie[1]=inv[0]=inv[1]=1;\n  for(res i=2; i<=n*n+n+k; i++)\n  {\n    jie[i]=1LL*jie[i-1]*i%mod;\n    inv[i]=quickpow(jie[i],mod-2);\n  }\n}\ninline ll C(ll m,ll n)\n{\n  return 1LL*jie[m]*inv[n]%mod*1LL*inv[m-n]%mod;\n}\nint main()\n{\n  n=read(),k=read()-1;\n  if(!k)\n  {\n    puts(\"1\");\n    return 0;\n  }\n  init();\n  f[0][0]=1;\n  for(res i=0; i<=n; i++)\n    for(res j=i; j<=n; j++)\n    {\n      if(i) f[i][j]=(f[i][j]+f[i-1][j])%mod;\n      if(j) f[i][j]=(f[i][j]+1LL*f[i][j-1]*C(i+j*k-1,k-1)%mod)%mod;\n    }\n  printf(\"%lld\\n\",1LL*f[n][n]*jie[n]%mod);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint t=1,sum=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9')\n\t{\n\t\tif(ch=='-') t=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')\n\t\tsum=sum*10+ch-'0',ch=getchar();\n\treturn t*sum;\n}\nconst int _N=2e3+10,_M=4e6+10,mod=1e9+7;\nint fac[_M],inv[_M],f[_N][_N],n,m;\nvoid up(int &x,int y)\n{\n\tx+=y;\n\tif(x>=mod) x-=mod;\n}\nint C(int x,int y)\n{\n\tif(x<y) return 0;\n\treturn 1LL*fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main()\n{\n\tint i,j;\n\tn=read(); m=read();\n\tif(m==1) return puts(\"1\"),0;\n\tfac[0]=inv[0]=inv[1]=1;\n\tfor(i=2;i<=n*m;i++)\n\t\tinv[i]=1LL*(mod-mod/i)*inv[mod%i]%mod;\n\tfor(i=1;i<=n*m;i++)\n\t\tfac[i]=1LL*fac[i-1]*i%mod,\n\t\tinv[i]=1LL*inv[i-1]*inv[i]%mod;\n\tf[0][0]=1;\n\tfor(i=0;i<=n;i++)\n\t\tfor(j=0;j<=n;j++)\n\t\t\tif(f[i][j])\n\t\t\t{\n\t\t\t\tif(j!=n)\n\t\t\t\t\tup(f[i][j+1],1LL*f[i][j]*C(i-1+(m-1)*(j+1),m-2)%mod);\n\t\t\t\tif(i<j)\n\t\t\t\t\tup(f[i+1][j],f[i][j]);\n\t\t\t}\n\tprintf(\"%d\\n\",1LL*fac[n]*f[n][n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#define file(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout);\nusing namespace std;\nconst int MAXN = 2005;\nconst int MOD = 1e9 + 7;\nint n, K;\nint jc[MAXN * MAXN] = {1}, inv[MAXN * MAXN];\nint f[MAXN][MAXN];\n\nint quick_pow(int a, int x) {\n    int res = 1;\n    while (x) {\n        if (x & 1)\n            res = 1ll * res * a % MOD;\n        a = 1ll * a * a % MOD, x >>= 1;\n    }\n    return res;\n}\n\nint calc_C(int n, int r) {\n    if (n < r)\n        return 0;\n    return 1ll * jc[n] * inv[r] % MOD * inv[n - r] % MOD;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &K);\n    if (K == 1) {\n        printf(\"1\");\n        return 0;\n    }\n    for (int i = 1; i <= MAXN * MAXN - 1; i++)\n        jc[i] = 1ll * jc[i - 1] * i % MOD;\n    inv[MAXN * MAXN - 1] = quick_pow(jc[MAXN * MAXN - 1], MOD - 2);\n    for (int i = MAXN * MAXN - 1; i; i--)\n        inv[i - 1] = 1ll * i * inv[i] % MOD;\n    f[0][0] = 1;\n    for (int i = 0; i <= n; i++)\n        for (int j = i; j <= n; j++) {\n            if (i != j)\n                f[i + 1][j] = (f[i + 1][j] + f[i][j]) % MOD;\n            f[i][j + 1] = (f[i][j + 1] + 1ll * f[i][j] * calc_C((j + 1) * (K - 1) + i - 1, K - 2) % MOD) % MOD;\n        }\n    printf(\"%lld\", 1ll * f[n][n] * jc[n] % MOD);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*vi:se ts=8 tw=8*/\n/*@author tangyida*/\n#include<bits/stdc++.h>\nconst int N = 2e3 + 5;\nconst long long MOD = 1e9 + 7;\nint n,k;\nlong long f[N][N],fac[N * N],inv[N * N];\n\ninline long long _pow(long long a,long long base)\n{\n\tlong long ans = 1;\n\tfor(;base;base >>= 1) {\n\t\tif(base  & 1) ans = (ans * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t}\n\treturn ans;\n}\n\ninline void pre()\n{\n\tfac[0] = 1;\n\tfor(int i = 1;i <= n * n;i++) fac[i] = (fac[i - 1] * i) % MOD;\n\tfor(int i = 0;i <= n * n;i++) inv[i] = (_pow(fac[i],MOD - 2)) % MOD;\n}\n\ninline long long C(long long n,long long m)\n{ \n\tif(n == m) return 1;\n\treturn ((fac[n] * inv[m]) % MOD * inv[n - m]) % MOD;\n}\n\nint main()\n{\n\tstd::cin >> n >> k;\n\tif(k == 1) std::cout << 1,exit(0);\n\n\tpre();\n\tf[0][0] = 1;\n\tfor(int i = 1;i <= n;i++) for(int j = 0;j <= i;j++) {\n\t\tf[i][j] = f[i - 1][j];\n\t\tif(!j) continue;\n\t\tf[i][j] = (f[i][j] + f[i][j - 1]  * (n - j + 1) * C(n - i + (n -\n\t\t\t\t\tj + 1) * (k - 1) - 1,k - 2)) % MOD;\n\t}\n\tstd::cout << f[n][n];\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=2005,MOD=1000000007;\n\nint PowMod(int a,int b)\n{\n    int ret=1;\n    while(b)\n    {\n        if(b&1)\n            ret=1LL*ret*a%MOD;\n        a=1LL*a*a%MOD;\n        b>>=1;\n    }\n    return ret;\n}\n\nint fac[MAXN*MAXN],ifac[MAXN*MAXN];\n\nvoid Init()\n{\n    fac[0]=1;\n    for(int i=1;i<MAXN*MAXN;i++)\n        fac[i]=1LL*fac[i-1]*i%MOD;\n    ifac[MAXN*MAXN-1]=PowMod(fac[MAXN*MAXN-1],MOD-2);\n    for(int i=MAXN*MAXN-2;i>=0;i--)\n        ifac[i]=1LL*ifac[i+1]*(i+1)%MOD;\n}\nint C(int n,int r)\n{return 1LL*fac[n]*ifac[n-r]%MOD*ifac[r]%MOD;}\n\nint N,K,dp[MAXN][MAXN];\n\nint main()\n{\n    Init();\n    scanf(\"%d%d\",&N,&K);\n    if(K==1)\n    {\n        puts(\"1\");\n        return 0;\n    }\n    dp[0][0]=1;\n    for(int i=0;i<=N;i++)\n        for(int j=0;j<=i;j++)\n        {\n            if(i)\n                dp[i][j]=(dp[i][j]+dp[i-1][j])%MOD;\n            if(j)\n                dp[i][j]=(dp[i][j]+1LL*dp[i][j-1]*C(N*K-i-(K-1)*(j-1)-1,K-2)%MOD)%MOD;\n        }\n    int ans=1LL*dp[N][N]*fac[N]%MOD;\n    printf(\"%d\\n\",ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define N 2000\n#define MOD 1000000007\n\nint n, k, fac[N * N + 5], facinv[N * N + 5], f[N + 5][N + 5];\n\nint fpow(int x, int p) {\n    int ret = 1;\n    while (p) {\n        if (p & 1) ret = 1LL * ret * x % MOD;\n        x = 1LL * x * x % MOD;\n        p >>= 1;\n    }\n    return ret;\n}\n\nint C(int n, int m) {\n    if (n < m)\n        return 0;\n    return 1LL * fac[n] * facinv[m] % MOD * facinv[n - m] % MOD;\n}\n\nint main() {\n    scanf(\"%d%d\", &n, &k);\n    if (k == 1) {\n        printf(\"1\\n\");\n        return 0;\n    }\n    fac[0] = 1;\n    for (int i = 1; i <= n * k; ++i)\n        fac[i] = 1LL * fac[i - 1] * i % MOD;\n    facinv[n * k] = fpow(fac[n * k], MOD - 2);\n    for (int i = n * k; i >= 1; --i)\n        facinv[i - 1] = 1LL * facinv[i] * i % MOD;\n    for (int i = 1; i <= n; ++i)\n        f[i][0] = 1;\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= i; ++j)\n            f[i][j] = (f[i - 1][j] + 1LL * f[i][j - 1] * (n - j + 1) % MOD * C(n * k - i - (j - 1) * (k - 1) - 1, k - 2)) % MOD;\n    printf(\"%d\\n\", f[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define rep(i,N) for(long long i = 0; i < (long long)(N); i++)\n#define repr(i,N) for(long long i = (long long)(N) - 1; i >= 0; i--)\n#define rep1(i,N) for(long long i = 1; i <= (long long)(N) ; i++)\n#define repr1(i,N) for(long long i = (N) ; (long long)(i) > 0 ; i--)\n#define each(x,v) for(auto& x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) ((int)(v).size())\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) long long __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\n#define in2(N,s,t) rep(i,N){in(s[i] , t[i]);}\n#define in3(N,s,t,u) rep(i,N){in(s[i] , t[i] , u[i]);}\nusing namespace std; void solve();\nusing ll = long long; template<class T = ll> using V = vector<T>;\nusing vi = V<int>; using vl = V<>; using vs = V<string>;\nusing vd = V<double>; using vvi = V< V<int> >; using vvl = V< V<> >;\ntemplate<typename T>using heap = priority_queue< T , V<T> , greater<T> >;\nconstexpr int inf = 1001001001; constexpr ll infLL = (1LL << 61) - 1;\nstruct IoSetupNya {IoSetupNya() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); cerr << fixed << setprecision(7);} } iosetupnya;\ntemplate<typename T, typename U> inline bool amin(T &x, U y) { return (y < x) ? (x = y, true) : false; }\ntemplate<typename T, typename U> inline bool amax(T &x, U y) { return (x < y) ? (x = y, true) : false; }\ntemplate<typename T, typename U> ostream& operator <<(ostream& os, const pair<T, U> &p) { os << p.first << \" \" << p.second; return os; }\ntemplate<typename T, typename U> istream& operator >>(istream& is, pair<T, U> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T> ostream& operator <<(ostream& os, const vector<T> &v) { int s = (int)v.size(); rep(i,s) os << (i ? \" \" : \"\") << v[i]; return os; }\ntemplate<typename T> istream& operator >>(istream& is, vector<T> &v) { for(auto &x : v) is >> x; return is; }\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntemplate<typename T>void die(T x){out(x); exit(0);}\n#ifdef NyaanDebug\n  #include \"NyaanDebug.h\"\n  #define trc(...) do { cerr << #__VA_ARGS__ << \" = \"; dbg_out(__VA_ARGS__);} while(0)\n  #define trca(v,N) do { cerr << #v << \" = \"; array_out(v , N);cout << endl;} while(0)\n#else\n  #define trc(...)\n  #define trca(...)\n  int main(){solve();}\n#endif\n\nusing P = pair<ll,ll>; using vp = V<P>;\nconstexpr int MOD = /**/ 1000000007; //*/ 998244353;\n//////////////////\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< MOD >;\nusing vm = vector<modint>;\n\nvector<ll> fac,finv,inv;\nvoid cominit(int MAX) {\n  MAX++;\n  fac.resize(MAX , 0);\n  finv.resize(MAX , 0);\n  inv.resize(MAX , 0);\n  fac[0] = fac[1] = finv[0] = finv[1] = inv[1] = 1;\n  for (int i = 2; i < MAX; i++){\n    fac[i] = fac[i - 1] * i % MOD;\n    inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n    finv[i] = finv[i - 1] * inv[i] % MOD;\n  }\n}\n// nCk combination \ninline long long COM(int n,int k){\n  if(n < k || k < 0 || n < 0) return 0;\n  else return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n// nPk permutation\ninline long long PER(int n,int k){\n  if (n < k || k < 0 || n < 0) return 0;\n  else return (fac[n] * finv[n - k]) % MOD;\n}\n// nHk homogeneous polynomial\ninline long long HGP(int n,int k){\n  if(n == 0 && k == 0) return 1; //問題依存?\n  else if(n < 1 || k < 0) return 0;\n  else return fac[n + k - 1] * (finv[k] * finv[n - 1] % MOD) % MOD;\n}\n\nmodint d[2048][2048];\n\nvoid solve(){\n  ini(N , K);\n  if(K == 1) die(1);\n  cominit(5000000);\n  d[1][0] = 1;\n  rep1(i , N) rep(j , N){\n    if(i != N)\n      d[i + 1][j] += d[i][j];\n    if(i > j)\n      d[i][j + 1] += d[i][j] * COM(N - i + (N - j) * (K - 1) - 1 , K - 2);\n  }\n  out(d[N][N] * fac[N]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\ntypedef long long ll;\ninline ll rd(){\n    ll x=0,p=1;\n    char a=getchar();\n    while((a<48||a>57)&&a!='-')a=getchar();\n    if(a=='-')p=-p,a=getchar();\n    while(a>47&&a<58)x=(x<<1)+(x<<3)+(a&15),a=getchar();\n    return x*p;\n}\nconst int N=2002;\nconst ll mod=1e9+7;\ninline ll fpow(ll b,ll p,ll mod){\n\tll ans=1,tmp=b;\n\twhile(p){\n\t\tif(p&1)ans=ans*tmp%mod;\n\t\ttmp=tmp*tmp%mod;\n\t\tp>>=1;\n\t}\n\treturn ans;\n}\nint n,k;\nll fac[N*N],inv[N*N],f[N][N];\ninline ll C(int n,int m){\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main(){\n\tfac[0]=1;\n\tn=rd(),k=rd();\n\tfor(int i=1;i<=4000000;i++)fac[i]=fac[i-1]*i%mod;\n\tf[0][0]=1;\n\tinv[4000000]=fpow(fac[4000000],mod-2,mod);\n\tfor(int i=3999999;i>=0;i--)inv[i]=(inv[i+1]*(i+1))%mod;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(j)f[i][j]=(f[i][j]+f[i][j-1]*(n-j+1)%mod*C(n-i+(n-j+1)*(k-1)-1,k-2)%mod)%mod;\n\t\t}\n\tprintf(\"%lld\\n\",f[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define mo 1000000007\nint fac[4000005],inv[4000005],n,k,f[2005][2005];\nint C(int n,int m){return 1ll*fac[n]*inv[m]%mo*inv[n-m]%mo;}\nint ksm(int a,int p)\n{int ans=1;for(;p;p>>=1,a=1ll*a*a%mo)if(p&1)ans=1ll*ans*a%mo;return ans;}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1){printf(\"1\\n\");return 0;}\n\tf[0][0]=1;inv[0]=fac[0]=1;\n\tfor(int i=1;i<=n*k;i++)fac[i]=fac[i-1]*1ll*i%mo;\n\tinv[n*k]=ksm(fac[n*k],mo-2);\n\tfor(int i=n*k-1;i;i--)inv[i]=inv[i+1]*1ll*(i+1)%mo;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tf[i][0]=f[i-1][0];\n\t \tfor(int j=1;j<=i;j++)\n\t  \t f[i][j]=(f[i-1][j]+f[i][j-1]*1ll*C(n*k-(j-1)*(k-1)-i-1,k-2)%mo)%mo;\n\t}printf(\"%d\\n\",f[n][n]*1ll*fac[n]%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int   N   = 1e5 + 1;\n\nint n, a[N], b[N];\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    cin >> n;\n\n    for(int i = 1 ; i <= n ; ++i)\n        cin >> a[i];\n\n    sort(a + 1,a + 1 + n,greater<int>());\n\n    for(int i = 1 ; i <= n ; ++i)\n        if(a[i] > a[i + 1] && (a[i] - i) % 2)\n            return 0 * puts(\"First\");\n    puts(\"Second\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int maxn=2002,mo=1e9+7;\nint fac[maxn*maxn],n,k,m,inv[maxn*maxn],f[maxn][maxn];\nint qpow(int a,int b)\n{\n\tint ans=1;\n\tfor(;b;b>>=1,a=a*a%mo)\n\t\tif(b&1)ans=ans*a%mo;\n\treturn ans;\n}\nint calc(int x,int y)\n{\n\tif(!y)return 1;\n//\tcout<<x<<\" \"<<inv[y]<<\" \"<<inv[x-y]<<endl;\n\treturn fac[x]*inv[y]%mo*inv[x-y]%mo;\n}\nsigned main()\n{\n\tcin>>n>>k;\n\tif(k==1){puts(\"1\");return 0;}\n\tfac[0]=1;\n\tfor(int i=1;i<=2000*2000;i++)fac[i]=i*fac[i-1]%mo,inv[i]=qpow(fac[i],mo-2);\n\tinv[2000*2000]=qpow(fac[2000*2000],mo-2); \n\tfor(int i=2000*2000-1;i>=0;i--)inv[i]=(inv[i+1]*(i+1))%mo;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=0;j<=i;j++)\n\t{\n\t\tf[i][j]=f[i-1][j];\n\t\tif(j)f[i][j]+=f[i][j-1]*calc(n*k-i-(j-1)*(k-1)-1,k-2)%mo*(n-j+1)%mo,f[i][j]%=mo;\n\t//\tcout<<i<<\" \"<<j<<\" \"<<f[i][j]<<endl;\n\t}\n\tcout<<f[n][n];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2020\n#define mod 1000000007\n#define ll long long\nusing namespace std;\ninline int read(){\n  int x=0,f=1;char ch=getchar();\n  while(ch>'9'||ch<'0')ch=='-'&&(f=0)||(ch=getchar());\n  while(ch<='9'&&ch>='0')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n  return f?x:-x;\n}\nll frac[N*N];\nll fast_pow(ll x, ll y) {\n  ll z = 1;\n  for (; y; y >>= 1, x = x * x % mod) {\n    if (y & 1) {\n      z = z * x % mod;\n    }\n  }\n  return z;\n}\nll inv(ll x) {\n  return fast_pow(x, mod - 2);\n}\nll C(ll m, ll n) {\n  return frac[m] * inv(frac[n]) % mod * inv(frac[m - n]) % mod;\n}\nint f[N][N];\nint main(int argc, char const *argv[]) {\n\n  frac[0] = 1;\n  for (int i = 1; i <= 4000000; ++ i) {\n    frac[i] = frac[i - 1] * i % mod;\n  }\n\n  int n = read(), k = read();\n  f[0][1] = 1;\n  for (int j = 1; j <= n; ++ j) {\n    for (int i = 0; i <= j; ++ i) {\n      if (i < j) f[i + 1][j] = (f[i + 1][j] + f[i][j]) % mod;\n      if (j < n) f[i][j + 1] = (f[i][j + 1] + f[i][j] * C(i + (j + 1) * (k - 1) - 1, k - 2) % mod) % mod;\n    }\n  }\n  printf(\"%lld\\n\", f[n][n] * frac[n] % mod);\n  return 0;\n}\n/*\n问题转化为拓扑计数问题\n\n颜色顺序最后乘一个阶乘即可，现在要计算的是如下图的拓扑方案数。\n\n| (0)->(0)->(0)->(0)->(0)\n|  |    |    |    |    |\n|  v    v    v    v    v\n| (1)->(2)->(3)->(4)->(5)\n|  |    |    |    |    |\n|  v    v    v    v    v\n| (1)  (2)  (3)  (4)  (5)\n|  |    |    |    |    |\n|  v    v    v    v    v\n| (1)  (2)  (3)  (4)  (5)\n|  |    |    |    |    |\n|  v    v    v    v    v\n| (1)  (2)  (3)  (4)  (5)\n\n只需按照前两行从后往前转移即可。\n\nf[i][j] 表示选了 i 个 0, j 种颜色的方案数。\n\n每次转移相当于加入一个 0 或者加入一列。\n\n|               .-- i ---.\n|                (0)->(0)\n|                 |    |\n|                 v    v\n|      (2)->(3)->(4)->(5)\n|       |    |    |    |\n|       v    v    v    v\n|      (2)  (3)  (4)  (5)\n|       |    |    |    |\n|       v    v    v    v\n|      (2)  (3)  (4)  (5)\n|       |    |    |    |\n|       v    v    v    v\n|      (2)  (3)  (4)  (5)\n|     `-------- j -------'\n\nf[i+1][j] += f[i][j]\nf[i][j+1] += f[i][j] * C(i+j*(k-1)+k-2, k-2)\n\nans = f[n][n] * n!\n\n*/"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint power(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\n\nint n, k;\n\nint read() {\n  if (scanf(\"%d%d\", &n, &k) < 2) {\n    return 0;\n  }\n  return 1;\n}\n\nconst int maxn = (int) 2e3 + 10;\nint dp[maxn][maxn];\n\nint cs[maxn * maxn];\n\nvoid solve() {\n  if (k == 1) {\n    printf(\"1\\n\");\n    return;\n  }\n\n  for (int i = 0; i < k - 2; ++i) {\n    cs[i] = 0;\n  }\n  cs[k - 2] = 1;\n  for (int i = k - 1; i <= n * k; ++i) {\n    cs[i] = mult(mult(cs[i - 1], i), power(i - k + 2, mod - 2));\n  }\n\n  for (int left = 0; left <= n; ++left) {\n    for (int t = 0; t + left <= n; ++t) {\n      int &cur = dp[left][t];\n      cur = 0;\n      if (!left && !t) {\n        cur = 1;\n        continue;\n      }\n\n      if (t) {\n        add(cur, mult(dp[left][t - 1], cs[(left + t) * k - t - 1]));\n      }\n\n      if (left) {\n        add(cur, dp[left - 1][t + 1]);\n      }\n      //eprintf(\"dp[left=%d][t=%d] = %d\\n\", left, t, cur);\n    }\n  }\n  int res = dp[n][0];\n  for (int i = 1; i <= n; ++i) {\n    res = mult(res, i);\n  }\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define M 2010\n#define LL long long\n#define MOD 1000000007\n#define rep(i, x, y) for(int i = (x); i <= (y); i ++)\ninline int read() {\n\tchar ch = getchar(); int x = 0, f = 1;\n\twhile(ch < '0' || ch > '9') {\n\t\tif(ch == '-') f = -1;\n\t\tch = getchar();\n\t} while('0' <= ch && ch <= '9') {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t} return x * f;\n}\nint f[M][M];\nint fac[M*M], inv[M*M];\ninline void init(int n) {\n\tfac[0] = 1;\n\trep(i, 1, n) fac[i] = 1ll * fac[i - 1] * i % MOD;\n\tinv[0] = inv[1] = 1;\n\trep(i, 2, n) inv[i] = 1ll * inv[MOD % i] * (MOD - MOD / i) % MOD;\n\trep(i, 1, n) inv[i] = 1ll * inv[i - 1] * inv[i] % MOD;\n}\ninline int C(int n, int m) {\n//\tif(n < 0 || m < 0) return 1;\n\treturn 1ll * fac[n] * inv[m] % MOD * inv[n - m] % MOD;\n}\nint main() {\n\tint n = read(), k = read();\n\tif(k == 1) return puts(\"1\"), 0;\n\tf[0][0] = 1; init(n*k);\n\trep(i, 1, n) {\n\t\tfor(int j = i; j >= 0; j --) {\n\t\t\tf[i][j] = f[i][j + 1];\n\t\t\tif(j) (f[i][j] += 1ll * f[i - 1][j - 1] * C(i*k-j-1,k-2) % MOD) %= MOD;\n\t\t}\n\t} printf(\"%d\\n\", 1ll * f[n][0] * fac[n] % MOD);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define MOD 1000000007\n#define inf 0x3f3f3f3f3f3f3f3f\n#define pi acos(-1.0)\n#define ri register int\n#define Abs(x) ((x) < 0 ? (-(x)) : (x))\n#define int long long\nconst int maxn = 2e3 + 10;\ninline int Max(int a, int b) { return a > b ? a : b; }\ninline int Min(int a, int b) { return a > b ? b : a; }\nnamespace FastIO {\ninline int read()\n{\n    int f = 1, r = 0;\n    char c = getchar();\n    while (!isdigit(c)) {\n        if (c == '-') {\n            f = -1;\n        }\n        c = getchar();\n    }\n    while (isdigit(c)) {\n        r = 10 * r + c - '0';\n        c = getchar();\n    }\n    return f * r;\n}\ninline void write(int x)\n{\n    if (x < 0)\n        putchar('-'), x = -x;\n    if (x > 9)\n        write(x / 10);\n    putchar(x % 10 + '0');\n}\ninline void writesp(int x) { write(x), putchar(' '); }\ninline void writeln(int x) { write(x), puts(\"\"); }\n};\nusing namespace FastIO;\nint N, K, dp[maxn][maxn], fac[maxn * maxn], ifac[maxn * maxn];\ninline int exgcd(int a, int b, int& x, int& y)\n{\n    if (b == 0) {\n        x = 1, y = 0;\n        return a;\n    }\n    int d = exgcd(b, a % b, x, y);\n    int tmp = y;\n    y = x - a / b * y;\n    x = tmp;\n    return d;\n}\ninline int inv(int a, int b)\n{\n    int x, y;\n    exgcd(a, b, x, y);\n    return (x + MOD) % MOD;\n}\ninline int C(int m, int n)\n{\n    int tmp = (fac[m] * ifac[n] % MOD) * ifac[m - n] % MOD;\n    return tmp;\n}\nsigned main()\n{\n    //freopen(\"C:\\Users\\hjw\\Downloads\\testdata (4).in\", \"r\", stdin);\n    N = read(), K = read();\n    if (K == 1) {\n        puts(\"1\");\n        return 0;\n    }\n    fac[0] = 1, ifac[0] = inv(1, MOD);\n    for (ri i = 1; i <= N * N; ++i) {\n        fac[i] = fac[i - 1] * i % MOD;\n        ifac[i] = inv(fac[i], MOD);\n    }\n    dp[0][1] = 1;\n    for (ri j = 2; j <= N; ++j) {\n        dp[0][j] = dp[0][j - 1] * C(j * (K - 1) - 1, K - 2) % MOD;\n    }\n    for (ri i = 1; i <= N; ++i) {\n        for (ri j = i; j <= N; ++j) {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] * C(j * (K - 1) + i - 1, K - 2)) % MOD;\n        }\n    }\n    dp[N][N] = (dp[N][N] * fac[N] % MOD);\n    writeln(dp[N][N]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define il inline\n#define vd void\n#define mod 1000000007\ntypedef long long ll;\nil int gi(){\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)){\n\t\tif(ch=='-')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\nint f[2010][2010];\nint inv[4001000],C[4001000];\nint main(){\n\tint n=gi(),k=gi();\n\tinv[1]=1;for(int i=2;i<=n*k;++i)inv[i]=mod-1ll*(mod/i)*inv[mod%i]%mod;\n\tC[k-2]=1;\n\tfor(int i=k-1;i<=n*k;++i)C[i]=1ll*C[i-1]*inv[i-k+2]%mod*i%mod;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<=std::min(i,n);++j){\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tf[i][j]=(f[i][j]+1ll*C[(n-i)+(n-j+1)*(k-1)-1]*f[i][j-1]%mod*(n-j+1)%mod)%mod;\n\t\t}\n\tprintf(\"%d\\n\",f[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e3+10;\nconst int mod=1e9+7;\nint gi() {\n    int x=0,o=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\nint n,m,f[N][N],fac[N*N],inv[N*N],ifac[N*N];\nint C(int n,int m) {\n    if(n<0||m<0||n<m) return 0;\n    return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\nint main() {\n    cin>>n>>m;int N=n*m;\n    fac[0]=1;for(int i=1;i<=N;i++) fac[i]=1ll*fac[i-1]*i%mod;\n    inv[1]=1;for(int i=2;i<=N;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n    ifac[0]=1;for(int i=1;i<=N;i++) ifac[i]=1ll*ifac[i-1]*inv[i]%mod;\n    f[0][0]=1;\n    for(int i=1;i<=n;i++)\n        for(int j=0;j<=i;j++) f[i][j]=(f[i-1][j]+1ll*f[i][j-1]%mod*(n-j+1)%mod*C(n-i+(n-j+1)*(m-1)-1,m-2)%mod)%mod;\n    printf(\"%d\\n\",f[n][n]);\n    return 0;\n}\n//orzgzy\n//鸡贼明年进队超稳\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rint register int\nusing namespace std;\n// by piano\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0; char c = getchar(); int f = 0;\n  for(; c < '0' || c > '9'; f |= c == '-', c = getchar());\n  for(; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if(f) x = -x;\n}\nconst int N = 4e6 + 233;\nnamespace {\n  const int mo = 1e9 + 7;\n  inline int add(int x, int y) {\n    if((x += y) >= mo) x -= mo;\n    return x;\n  }\n  inline int sub(int x, int y) {\n    if((x -= y) < 0) x += mo;\n    return x;\n  }\n  inline int mul(int x, int y) {\n    return x * y % mo;\n  }\n  inline int pw(int a, int k, int mo) {\n    int ans = 1;\n    for(; k; k >>= 1, a = mul(a, a))\n      if(k & 1) ans = mul(ans, a);\n    return ans;\n  }\n  inline void U(int &x, int y) {\n    x = add(x, y);\n  }\n}\nint fac[N], fac_inv[N], dp[2333][2333];\nint n, k;\ninline void init(void) {\n  fac[0] = 1;\n  for(int i = 1; i < N; i ++)\n    fac[i] = mul(fac[i - 1], i);\n  fac_inv[N - 1] = pw(fac[N - 1], mo - 2, mo);\n  for(int i = N - 2; i >= 0; i --)\n    fac_inv[i] = mul(fac_inv[i + 1], i + 1);\n}\n\ninline int C(int n, int m) {\n  if(n < m) return 0;\n  else if(n == m || m == 0) return 1;\n  else return mul(fac[n], mul(fac_inv[m], fac_inv[n - m]));\n}\n\nmain(void) {\n  init();\n  read(n); read(k);\n  if(k == 1) return cout << 1 << \"\\n\", 0;\n  dp[0][0] = 1;\n  for(int i = 1; i <= n; i ++) {\n    for(int j = 0; j <= i; j ++) {\n      if(j) U(dp[i][j], mul(dp[i][j - 1], C(n * k - i - (j - 1) * (k - 1) - 1, k - 2)));\n      U(dp[i][j], dp[i - 1][j]);\n    }\n  }\n  int ans = mul(dp[n][n], fac[n]);\n  cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define ll long long\n//{{{ read()\ninline ll read(){\n\tregister ll x=0,f=1;\n\tregister char ch=getchar();\n\twhile(ch<'0'||ch>'9'){\n\t\tif(ch=='-')\tf=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')\tx=x*10+(ch^48),ch=getchar();\n\treturn x*f;\n}\n//}}}\nconst int N=2005;\nconst int M=4e6+5;\nconst int P=1e9+7;\nll fsp(ll x,int y=P-2){\n\tll ans=1;\n\twhile(y){\n\t\tif(y&1)\tans=ans*x%P;\n\t\tx=x*x%P,y>>=1;\n\t}\n\treturn ans;\n}\nint n,k,m,f[N];\nll fac[M],inv[M];\nll C(int n,int m){\n\tif(n>M)\treturn 0;\n\treturn fac[n]*inv[m]%P*inv[n-m]%P;\n}\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read(),k=read(),m=n*k,fac[0]=1;\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=m;i++) fac[i]=fac[i-1]*i%P;\n\tinv[m]=fsp(fac[m]);\n\tfor(int i=m;i;i--) inv[i-1]=inv[i]*i%P;\n\n\tf[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i;j;j--)\n\t\t\tf[j]=(f[j-1]+f[j+1]*C(m-i-(k-1)*(i-j-1)-1,k-2))%P;\n\t\tf[0]=f[1]*C(m-i-(k-1)*(i-1)-1,k-2)%P;\n\t}\n\tprintf(\"%lld\\n\",f[0]*fac[n]%P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\ninline int addmod(int x)\n{\n\treturn x>=mod?x-mod:x;\n}\ninline int submod(int x)\n{\n\treturn x<0?x+mod:x;\n}\nint fpow(int x,int y)\n{\n\tint ans=1;\n\twhile(y)\n\t{\n\t\tif(y&1) ans=1ll*ans*x%mod;\n\t\tx=1ll*x*x%mod;\n\t\ty/=2;\n\t}\n\treturn ans;\n}\nint n,m,f[2005][2005],pn=4e6,fr[4000005],infr[4000005];\nint C(int x,int y)\n{\n\tif(x<0||y<0||x<y) return 0;\n\treturn 1ll*fr[x]*infr[y]%mod*infr[x-y]%mod;\n}\nint main()\n{\n\tfr[0]=infr[0]=1;\n\tfor(int i=1;i<=pn;i++)\n\t\tfr[i]=1ll*fr[i-1]*i%mod;\n\tinfr[pn]=fpow(fr[pn],mod-2);\n\tfor(int i=pn-1;i>0;i--)\n\t\tinfr[i]=1ll*infr[i+1]*(i+1)%mod;\n\tscanf(\"%d%d\",&n,&m);\n\tif(m==1)\n\t{\n\t\tprintf(\"1\");\n\t\treturn 0;\n\t}\n\tf[0][1]=1;\n\tfor(int i=1;i<=n+1;i++)\n\t{\n\t\tfor(int j=1;j<=i;j++)\n\t\t{\n\t\t\tf[i][j]=addmod(f[i-1][j]+1ll*f[i][j-1]*C((n-i+1)+(m-1)*(n-j+2)-1,m-2)%mod);\n\t\t\t//printf(\"i=%d,j=%d,f=%d,C(%d,%d)=%d\\n\",i,j,f[i][j],(n-i+1)+(m-1)*(n-j+1)-1,m-2,C((n-i+1)+(m-1)*(n-j+1)-1,m-2));\n\t\t}\n\t}\n\tint ans=1ll*f[n+1][n]*fr[n]%mod;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                // ALLAH \\\\\n                        who is Hussain? -> whoishussain.org\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,n,a) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define aLL(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long LL;\ntypedef pair<int,int> PII;\nconst int mod=1000000007; \nLL powmod(LL a,LL b) {LL res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nint in(){ int x; scanf(\"%d\",&x); return x; }\nconst int N = 1e7;\nint n, k, fact[N];\nint C(int n, int nn){\n        return 1ll*fact[n]*powmod(fact[nn],mod-2)%mod * powmod(fact[n-nn],mod-2)%mod;\n}\nint32_t main(){\n        cin >>n >> k;\n        int ans = 1;\n        fact[0] = 1;\n        for(int i = 1; i < N; i++)\n                fact[i] = 1ll*fact[i-1]*i%mod;\n        for(int i = 0;i < n;i ++)\n        {\n                ans =  (1ll * ans * C(k+i*k-1,k-1) %mod + 1ll * ans * C(k+i*k-2,k-2)%mod * i %mod)%mod;;\n        }\n        cout << ans << endl;\n}\n\n// C/C++ File\n// AUTHOR:   truth-seeker\n// FILE:     le.cpp\n// ROLE:     TODO (some explanation)\n// CREATED:  2017-01-20 16:56:08\n// MODIFIED: 2017-01-20 16:56:08\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\ntypedef long long lint;\nconst int N=2005;\nconst int N2=N*N;\nconst int mod=1e9+7;\nint n,m,fac[N2],inv[N2],dp[N][N];\n\ninline int nxi(){\n\tint x=0;\n\tchar c;\n\twhile((c=getchar())>'9'||c<'0');\n\twhile(x=x*10-48+c,(c=getchar())>='0'&&c<='9');\n\treturn x;\n}\n\ntemplate <class T> inline void twk(T &x){\n\tx<mod?0:x-=mod;\n}\n\ninline int fpow(int x,int t){\n\tint ans=1;\n\tfor(; t; x=(lint)x*x%mod,t>>=1){\n\t\tif(t&1) ans=(lint)ans*x%mod;\n\t}\n\treturn ans;\n}\n\ninline void init(){\n\tfac[0]=1;\n\tfor(int i=1; i<N2; ++i){\n\t\tfac[i]=(lint)fac[i-1]*i%mod;\n\t}\n\tinv[N2-1]=fpow(fac[N2-1],mod-2);\n\tfor(int i=N2-1; i; --i){\n\t\tinv[i-1]=(lint)inv[i]*i%mod;\n\t}\n}\n\ninline int C(const int x,const int y){\n\tif(x<y) return 0;\n\treturn (lint)fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\n\nint main(){\n\tn=nxi(),m=nxi();\n\tif(m==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tinit();\n\tdp[0][0]=1;\n\tfor(int i=1; i<=n; ++i){\n\t\tdp[i][0]=dp[i-1][0];\n\t\tfor(int j=1; j<=i; ++j){\n\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\tconst int rest=n*m-i-(j-1)*(m-1)-1;\n\t\t\t//make sequence unique\n\t\t\tdp[i][j]=(dp[i][j]+(lint)dp[i][j-1]*C(rest,m-2))%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",(lint)dp[n][n]*fac[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nconst int MAXN = 2010, MOD = 1e9 + 7;\n\nint f[MAXN * MAXN], dp[MAXN][MAXN], fm1[MAXN * MAXN];\n\ninline int add(int x, int y){\n\treturn (x + y) % MOD;\n}\n\ninline int mul(int x, int y){\n\treturn (x * y) % MOD;\n}\n\nint p(int x, int y){\n\t//cerr << x << endl;\n\tif(y == 0)\n\t\treturn 1;\n\tif(y == 1)\n\t\treturn x;\n\tint f = p(x, y / 2);\n\tif(y % 2 == 0)\n\t\treturn mul(f, f);\n\telse\n\t\treturn mul(mul(f, f), x);\n}\n\nint c(int x, int y){\n\treturn mul(f[y], mul(fm1[x], fm1[y - x]));\n}\n\nint32_t main(){\n\tint n, k;\n\tcin >> n >> k;\n\tf[1] = 1, fm1[1] = 1, f[0] = 1, fm1[0] = 1;\n\tfor(int i = 2; i < MAXN * MAXN; i++){\n\t\t//cerr << i << endl;\n\t\tf[i] = mul(i, f[i - 1]);\n\t\tfm1[i] = p(f[i], MOD - 2);\n\t}\n\t//cerr << c(2, 2) << endl;\n\tdp[0][0] = 1;\n\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\t//cerr << j << \"    \" << c(k - 2, i + j * (k - 1) - 1) << \"     \" << dp[i][j - 1] << endl;\n\t\t\tif(i > 0)\n\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\tif(j > i)\n\t\t\t\tdp[i][j] = add(dp[i][j], mul(dp[i][j - 1], c(k - 2, i + j * (k - 1) - 1)) );\n\t\t\t//cerr << j << endl;\n\t\t\t//cerr << dp[i][j] << endl;\n\t\t}\n\t}\n\tcout << mul(dp[n][n], f[n]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define ll long long\n//{{{ read()\ninline ll read(){\n\tregister ll x=0,f=1;\n\tregister char ch=getchar();\n\twhile(ch<'0'||ch>'9'){\n\t\tif(ch=='-')\tf=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')\tx=x*10+(ch^48),ch=getchar();\n\treturn x*f;\n}\n//}}}\nconst int N=2005;\nconst int M=4e6+5;\nconst int P=1e9+7;\nll fsp(ll x,int y=P-2){\n\tll ans=1;\n\twhile(y){\n\t\tif(y&1)\tans=ans*x%P;\n\t\tx=x*x%P,y>>=1;\n\t}\n\treturn ans;\n}\nint n,k,m,f[N];\nll fac[M],inv[M];\nll C(int n,int m){\n\tif(n<0||m<0||n<m)\treturn 0;\n\treturn fac[n]*inv[m]%P*inv[n-m]%P;\n}\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read(),k=read(),m=n*k,fac[0]=1;\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=m;i++) fac[i]=fac[i-1]*i%P;\n\tinv[m]=fsp(fac[m]);\n\tfor(int i=m;i;i--) inv[i-1]=inv[i]*i%P;\n\n\tf[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i;j;j--) f[j]=(f[j-1]+f[j+1]*C(m-i-(k-1)*(i-j-1)-1,k-2))%P;\n\t\tf[0]=f[1]*C(m-i-(k-1)*(i-1)-1,k-2)%P;\n\t}\n\tprintf(\"%lld\\n\",1ll*f[0]*fac[n]%P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define maxn 2005\n#define mod 1000000007\n#define ll long long\nusing namespace std;\nint dp[maxn][maxn],n,m,fac[maxn*maxn],inv[maxn*maxn];//dp[i][j]表示放了i个白球,其中j种颜色的球已经放完了\nint c(int n,int m){return (ll)fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint main()\n{\n\tcin>>n>>m;dp[0][0]=1;\n\tif(m==1){cout<<1<<endl;return 0;}\n\tfac[0]=1;inv[0]=inv[1]=1;\n\tfor(int i=1;i<=n*m;i++)fac[i]=(ll)fac[i-1]*i%mod;\n\tfor(int i=2;i<=n*m;i++)inv[i]=(mod-(ll)(mod/i)*inv[mod%i]%mod)%mod;\n\tfor(int i=2;i<=n*m;i++)inv[i]=(ll)inv[i]*inv[i-1]%mod;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\tif(j)(dp[i][j]+=(ll)dp[i][j-1]*c(n*m-i-(j-1)*(m-1)-1,m-2)%mod)%=mod;\n\t\t}\n\t}\n\tcout<<((ll)dp[n][n]*fac[n]%mod+mod)%mod;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Be Name Khoda\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#pragma optimize O3\nusing namespace __gnu_pbds;\nusing namespace std;\ntemplate <typename T> using ordered_set =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T> using ordered_multiset =  tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \ntypedef long long int LL;\ntypedef LL ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vll;\ntypedef stringstream strs;\n \n#define X first\n#define Y second\n#define PB push_back\n#define For(i,a,b) for (int i=a;i<b;i++)\n#define Ford(i,a,b) for (int i=a;i>=b;i--)\n#define smax(a,b) a=max(a,b)\n#define smin(a,b) a=min(a,b)\n#define SZ(a) ((ll)a.size())\n#define ER(a) cout << #a << ' ' << a << endl\n#define LB(a,n,x) (lower_bound(a,(a)+(n),x)-(a))\n#define RET(x) { cout << x; exit(0); } \nconst ll M=2e3+5,LG=32,SM=600+5,inf=1e18+5;\nll mod=1e9+7;\n \nll n,k;\nll dp[M][M];\nll fac[M*M],faci[M*M];\n\nll pwr(ll x,ll n)\n{\n    ll z=x,res=1;\n    For(i,0,LG)\n    {\n        if ((n>>i)&1)\n            res=(res*z)%mod;\n        z=(z*z)%mod;\n    }\n    return res;\n}\n\nll com(ll i,ll j)\n{\n    if (j>i) return 0;\n    ll res=(fac[i]*faci[j])%mod;\n    res=(res*faci[i-j])%mod;\n    return res;\n}\n\nint main()\n{\n    cin >> n >> k;\n    if (k==1) RET(1);\n    fac[0]=1;\n    faci[0]=1;\n    For(i,1,n*k)\n    {\n        fac[i]=(fac[i-1]*i)%mod;\n        faci[i]=pwr(fac[i],mod-2);\n    }\n    dp[1][0]=dp[1][1]=1;\n    For(i,2,n+1)\n    {\n        //ER(i);\n        dp[i][0]=com(i*(k-1)-1,k-2);\n        //ER(dp[i][0]);\n        For(j,1,i)\n        {\n            dp[i][j]=(dp[i][j-1]+\n                com(i*(k-1)+j-1,k-2)\n                *dp[i-1][j])%\n                mod;\n        }\n        dp[i][i]=dp[i][i-1];\n    }\n    RET((dp[n][n]*fac[n])%mod);\n}    \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nlong long n,k,i,j,jc[4000005],ny[4000005],f[2005];\nlong long ksm(long long u,long long v){\n\tlong long o=1;\n\twhile(v){\n\t\tif(v&1)\n\t\t\to=o*u%mo;\n\t\tu=u*u%mo;\n\t\tv>>=1;\n\t}\t\n\treturn o;\n}\nlong long C(long long u,long long v){\n\treturn jc[u]*ny[v]%mo*ny[u-v]%mo;\n}\nint main(){\n\tn=read();k=read();\n\tif(k==1){\n\t\tpus(1,2);\n\t\treturn 0;\n\t}\n\tjc[0]=1;\n\tfor(i=1;i<=n*k;i++)\n\t\tjc[i]=jc[i-1]*i%mo;\n\tny[n*k]=ksm(jc[n*k],mo-2);\n\tfor(i=n*k-1;i>=0;i--)\n\t\tny[i]=ny[i+1]*(i+1)%mo;\n\tf[0]=1;\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=i;j++)\n\t\t\tf[j]=(f[j]+f[j-1]*C(n*k-i-(j-1)*(k-1)-1,k-2))%mo;\n\tpus(f[n]*jc[n]%mo,2);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nlint dp[2016][2016];\nvector<lint> zyo,rz;\nlint mo=1000000007;\nlint extgcd(lint a, lint b, lint &x, lint &y) {\n  lint g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\nlint invMod(lint a, lint m) {\n  lint x, y;\n  if (extgcd(a, m, x, y) == 1) return (x + m) % m;return 0;\n}\nlint co(int a,int b){\n\tif(a<0 || b<0 || b>a) return 0;\n\treturn ((zyo[a]*rz[b])%mo*rz[a-b])%mo;\n}\nint main()\n{\n\tint n,k;\n\tcin>>n>>k;\n\tzyo.pb(1);rep(i,4114514) zyo.pb((zyo[i]*(i+1))%mo);\n\trep(i,zyo.size()) rz.pb(invMod(zyo[i],mo));\n\tmemset(dp,0,sizeof(dp));dp[0][0]=1;\n\trep(i,n+1) rep(j,i+1){\n\t\tdp[i][j]%=mo;\n\t\tif(i<n) dp[i+1][j]+=dp[i][j];\n\t\tif(j<i) dp[i][j+1]+=dp[i][j]*co(n-i-j*(k-1)-1,k-1);\n\t}\n\tcout<<(dp[n][n]*zyo[n])%mo<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nconst ll M = 1000000007;\n\nll modpow(ll x,ll k){\n\tif(k == 0)return 1;\n\tll ret = modpow(x,k/2);\n\tret *= ret; ret %= M;\n\tif(k%2 == 1){ ret *= x; ret %= M ; }\n\treturn ret;\n}\nll inv(ll x){\n\treturn modpow(x,M-2);\n}\n\nll f[4000010];\nvoid init(int k){\n\tf[k-2] = 1;\n\tfor(int i = k-2 ; i < 4000009 ; i ++){\n\t\tf[i+1] = f[i]*(i+1); f[i+1] %= M;\n\t\tf[i+1] *= inv(i+3-k); f[i+1] %= M;\n\t}\n}\n\nint main(){\n\tll n,k;\n\tcin >> n >> k;\n\tif(k == 1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\t\n\tif(k != 2)init(k);\n\t\n\tstatic ll dp[2002][2002] = {};\n\tdp[0][0] = 1;\n\trep1(i,n){\n\t\tll sum = dp[i-1][i-1];\n\t\tfor(int j = i ; j <= n ; j ++){\n\t\t\tsum += dp[i-1][j];\n\t\t\tsum %= M;\n\t\t\tdp[i][j] = sum*f[(n-i)*k+i-j+k-2];\n\t\t\tdp[i][j] %= M;\n\t\t}\n\t}\n\trep1(i,n){\n\t\tdp[n][n] *= i;\n\t\tdp[n][n] %= M;\n\t}\n\tcout << dp[n][n] << endl;\n}\n\t\t\t\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\ntypedef long long LL;\nconst int p=1000000007;\nint n,m,fac[4000100],inv[4000100],f[2010][2010];\n\nint calc(int n,int m)\n{\n    return LL(fac[n])*inv[m]%p*inv[n-m]%p;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    if (m==1)\n    {\n        puts(\"1\");\n        return 0;\n    }\n    fac[0]=inv[0]=fac[1]=inv[1]=1;\n    repu(i,2,n*m)\n    {\n        fac[i]=LL(fac[i-1])*i%p;\n        inv[i]=LL(p-p/i)*inv[p%i]%p;\n    }\n    repu(i,2,n*m)\n        inv[i]=LL(inv[i])*inv[i-1]%p;\n    f[0][0]=1;\n    repu(i,1,n)\n        repu(j,0,i)\n        {\n            f[i][j]=f[i-1][j];\n            if (j)\n                f[i][j]=(f[i][j]+LL(f[i][j-1])*calc(n-i+(n-j+1)*(m-1)-1,m-2))%p;\n        }\n    printf(\"%d\\n\",LL(f[n][n])*fac[n]%p);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define int long long\n#define Mod 1000000007ll\n#define pow ksm\ninline int ksm(int a,int x){\n\tLL ans=1,w=a;\n\twhile(x){\n\t\tif(x&1)ans=ans*w%Mod;\n\t\tx>>=1;\n\t\tw=w*w%Mod;\n\t}\n\treturn ans;\n}\n#define MN 4000005\n#define mn 2005\nint fac[MN],dfac[MN],n,k,f[mn][mn];\ninline int C(int n,int m){\n\treturn 1ll*fac[m]*dfac[n]%Mod*dfac[m-n]%Mod;\n}\nvoid init(int N){\n\tfac[0]=1;\n\tfor(int i=1;i<=N;++i)\n\t\tfac[i]=fac[i-1]*i%Mod;\n\tdfac[N]=ksm(fac[N],Mod-2);\n\tfor(int i=N-1;i>=0;--i){\n\t\tdfac[i]=(LL)dfac[i+1]*(LL)(i+1)%Mod;\n\t}\n}\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&k);\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tinit(n*k);\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<=i;++j){\n\t\t\tf[i][j]=(f[i][j]+f[i-1][j])%Mod;\n\t\t\tif(j)f[i][j]=(f[i][j]+(f[i][j-1]*(n-j+1)%Mod*C(k-2,n-i+(k-1ll)*(n-j+1ll)-1ll)+Mod))%Mod;\t\n\t\t}\n\tprintf(\"%lld\",f[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nclass Mod\n{\nprivate:\n    static const int MOD = 1000000007;\n    long long a;\npublic:\n    Mod(){\n        a = 0;\n    }\n    Mod(long long x){\n        a = (x % MOD + MOD) % MOD;\n    }\n    const Mod operator+(const Mod& x) const{\n        return Mod(a + x.a);\n    }\n    const Mod operator-(const Mod& x) const{\n        return Mod(a - x.a);\n    }\n    const Mod operator*(const Mod& x) const{\n        return Mod(a * x.a);\n    }\n    const Mod operator/(const Mod& x) const{ // フェルマーの小定理、MODが素数である場合のみ有効\n        int b = MOD - 2;\n        long long c = x.a;\n        long long ret = 1;\n        while(b > 0){\n            if(b & 1){\n                ret *= c;\n                ret %= MOD;\n            }\n            c *= c;\n            c %= MOD;\n            b >>= 1;\n        }\n        return Mod(a * ret);\n    }\n    long long getValue(){\n        return a;\n    }\n};\n\nint main()\n{\n    int n, k;\n    cin >> n >> k;\n    if(k == 1){\n        cout << 1 << endl;\n        return 0;\n    }\n\n    vector<Mod> factorial(n*k+1, 1);\n    for(int i=1; i<=n*k; ++i)\n        factorial[i] = factorial[i-1] * i;\n\n    vector<vector<Mod> > dp(n+1, vector<Mod>(n+1, 0));\n    dp[0][0] = 1;\n    for(int i=0; i<=n; ++i){\n        for(int j=0; j<=i; ++j){\n            if(i < n)\n                dp[i+1][j] = dp[i+1][j] + dp[i][j];\n            if(j < i){\n                int x = (n - i) + (k - 1) * (n - j);\n                dp[i][j+1] = dp[i][j+1] + dp[i][j] * factorial[x-1] / (factorial[k-2] * factorial[x-k+1]);\n            }\n        }\n    }\n\n    Mod ans = dp[n][n] * factorial[n];\n    cout << ans.getValue() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 3000;\nconst int MAXM = MAXN*MAXN;\nconst int MOD = int(1E9) + 7;\n\nint pow_mod(int b, int p) {\n\tint ret = 1;\n\tfor(int i=p;i;i>>=1,b=1LL*b*b%MOD)\n\t\tif( i & 1 ) ret = 1LL*ret*b%MOD;\n\treturn ret;\n}\n\nint fct[MAXM + 5], ifct[MAXM + 5];\nint comb(int n, int m) {\n\treturn 1LL*fct[n]*ifct[m]%MOD*ifct[n-m]%MOD;\n}\nvoid init() {\n\tfct[0] = 1;\n\tfor(int i=1;i<=MAXM;i++)\n\t\tfct[i] = 1LL*fct[i-1]*i%MOD;\n\tifct[MAXM] = pow_mod(fct[MAXM], MOD - 2);\n\tfor(int i=MAXM-1;i>=0;i--)\n\t\tifct[i] = 1LL*ifct[i+1]*(i+1)%MOD;\n}\n\nint f[MAXN + 5][MAXN + 5];\n\nint main() {\n\tinit();\n\tint N, K; scanf(\"%d%d\", &N, &K);\n\tif( K == 1 ) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=N;i++) f[1][i] = 1;\n\tfor(int i=2;i<=N;i++) {\n\t\tfor(int j=1;j<=i;j++) {\n\t\t\tint m = (K - 1)*(i - 1) + j, n = K - 2;\n\t\t\tf[i][j] = 1LL*f[i-1][j]*comb(n+m-1, n)%MOD;\n\t\t}\n\t\tfor(int j=1;j<=N;j++)\n\t\t\tf[i][j] = (f[i][j] + f[i][j-1]) % MOD;\n\t}\n\tprintf(\"%lld\\n\", 1LL*f[N][N]*fct[N]%MOD);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    f[i][j] 表示 已经出现过 i种颜色的球，\n\t并且还剩j种颜色的球没有被匹配的方案数。\n\t\n\t考虑加入一种新球的话:\n\tf[i+1][j+1] += f[i][j] * (n-i) * C(k*i-j+1,k-2) \n\t\n\t考虑加入一种白球的话:\n\tf[i][j-1] += f[i][j] \n\t\n\t初始化 f[0][0] = 1 \n*/\n#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int maxn=2005;\nconst int ha=1000000007;\nint jc[maxn*maxn],ni[maxn*maxn];\nint n,k,f[maxn][maxn];\n\ninline int add(int x,int y){\n\tx+=y;\n\treturn x>=ha?x-ha:x;\n}\n\ninline int ksm(int x,int y){\n\tint an=1;\n\tfor(;y;y>>=1,x=x*(ll)x%ha) if(y&1) an=an*(ll)x%ha;\n\treturn an;\n}\n\ninline void init(){\n\tjc[0]=1;\n\tfor(int i=1;i<=4004000;i++) jc[i]=jc[i-1]*(ll)i%ha;\n\tni[4004000]=ksm(jc[4004000],ha-2);\n\tfor(int i=4004000;i;i--) ni[i-1]=ni[i]*(ll)i%ha;\n}\n\ninline int getC(int x,int y){\n\treturn jc[x]*(ll)ni[y]%ha*(ll)ni[x-y]%ha;\n}\n\ninline void dp(){\n\tf[0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\t    for(int j=i;j>=0;j--) if(f[i][j]){\n\t    \tf[i+1][j+1]=add(f[i+1][j+1],f[i][j]*(ll)(n-i)%ha*(ll)getC(k*(i+1)-j-2,k-2)%ha);\n\t    \tif(j) f[i][j-1]=add(f[i][j-1],f[i][j]);\n\t\t}\n\t\n\t/*\n\tfor(int i=0;i<=n;i++){\n\t    for(int j=0;j<=i;j++) printf(\"%d \",f[i][j]);\n\t    puts(\"\");\n\t}\n\t*/\n}\n\nint main(){\n\tinit();\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1) puts(\"1\");\n\telse{\n\t\tdp();\n\t\tprintf(\"%d\\n\",f[n][0]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define IL inline\n#define RG register\n#define LL long long\n#define Upd(a) (a)>=mod?(a-=mod):1\nusing namespace std;\ntemplate <class T>\nIL char gc () {\n\tstatic char buf[1<<6], *p1=buf, *p2=buf;\n\treturn (p1==p2) && (p2=(p1=buf)+fread(buf,1,1<<6,stdin), p1==p2) ?EOF:*p1++;\n}\ntemplate <typename T>\nIL void read (T&data) {\n\tdata=0;\n\tRG char ch=0;\n\twhile (ch<'0' || ch>'9') ch=getchar();\n\twhile (ch<='9' && ch>='0') data=(data<<1)+(data<<3)+(ch&15), ch=getchar();\n}\nconst int mod = 1e9+7;\nconst int _ =2011;\nint n, k;\nint dp[2][_], jc[_*_], jcn[_*_];\nIL int poww (RG int a, RG int b) {\n\tRG int ret=1, Base=a;\n\tfor (;b;b>>=1, Base=1LL*Base*Base%mod) if (b&1) ret=1LL*ret*Base%mod;\n\treturn ret;\n}\nIL int C (RG int a, RG int b) {\n\tif (a<b) return 0;\n\treturn 1LL*jc[a]*jcn[b]%mod*jcn[a-b]%mod;\n}\nint main (/*int aa, int bb*/) {\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\t//n=aa, k=bb;\n\tread(n), read(k);\n\tif (k<=1) {puts(\"0\"); return 0;}\n\tjc[0]=jcn[0]=1;\n\tRG int i, j, pre=1, cur=0;\n\tfor (i=1; i<=n*k; ++i) jc[i]=1LL*jc[i-1]*i%mod, jcn[i]=poww(jc[i], mod-2);\n\tdp[0][0]=1;\n\tfor (i=1; i<=n*2; ++i) {\n\t\tswap(cur, pre);\n\t\tfor (j=0; j<min(i,n+1); ++j) dp[cur][j]=0;\n\t\tfor (j=1; j<=min(i,n); ++j) {\n\t\t\tif ((i-j)%2) continue;\n\t\t\tif (n*2-i+1<j) break;\n\t\t\tRG int a=(i+j-2)>>1, b=(i-j)>>1;\n\t\t\tdp[cur][j]=1LL*dp[pre][j-1]*C(a*(k-1)+b+k-1-1,k-1-1)%mod;\n\t\t\tdp[cur][j]+=dp[pre][j+1];\n\t\t\tUpd(dp[cur][j]);\n\t\t}\n\t\tif (cur%2==0) dp[cur][0]=dp[pre][1];\n\t}\n\t//return 1LL*dp[cur][0]*jc[n]%mod;\n\tprintf(\"%lld\",1LL*dp[cur][0]*jc[n]%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll fac[4000005],ifac[4000005],inv[4000005],p=1e9+7;\nvoid ycl(int n){\n\tfac[1]=fac[0]=ifac[0]=ifac[1]=inv[0]=inv[1]=1;\n\tfor (int i=2;i<=n;i++){\n\t\tinv[i]=(p-p/i)*inv[p%i]%p;\n\t\tfac[i]=fac[i-1]*i%p;\n\t\tifac[i]=ifac[i-1]*inv[i]%p;\n\t}\n}\nll C(int n,int m){\n\tif (n<m) return 0;\n\treturn ((fac[n]*ifac[m])%p*ifac[n-m])%p;\n}\nll f[2005][2005];\nint main(){\n\tint n,k;\n\tscanf(\"%d%d\",&n,&k);\n\tif (k<=1){printf(\"1\\n\"); return 0;}\n\tycl(n*k);\n\tf[0][0]=1;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=n;j>=0;j--){\n\t\t\tif (j<=i) f[i][j]=(f[i][j]+f[i-1][j-1]*C(i*k-j-1,k-2))%p;\n\t\t\tf[i][j]=(f[i][j]+f[i][j+1])%p;\n\t\t}\n\t}\n\tll ans=f[n][0];\n\tans=ans*fac[n]%p;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 1e9+7;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = a*b % MOD;\n}\n\nvector<int64_t> fact, seq_inv, fact_inv;\n\nvoid create_fact_mod(int num){\n    fact[0] = fact[1] = 1;\n    for(int i=2; i<=num; i++) fact[i] = fact[i-1] * i % MOD;\n}\n\nvoid create_seq_inv_mod(int num){\n    seq_inv[0] = seq_inv[1] = 1;\n    for(int i=2; i<=num; i++) seq_inv[i] = (MOD - MOD/i) * seq_inv[MOD%i] % MOD;\n}\n\nvoid create_fact_inv_mod(int num){\n    fact_inv[0] = fact_inv[1] = 1;\n    for(int i=2; i<=num; i++) fact_inv[i] = fact_inv[i-1] * seq_inv[i] % MOD;\n}\n\nvoid create_mod_tables(int num){\n    fact.resize(num+1);\n    seq_inv.resize(num+1);\n    fact_inv.resize(num+1);\n    create_fact_mod(num);\n    create_seq_inv_mod(num);\n    create_fact_inv_mod(num);\n}\n\nint64_t comb_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD * fact_inv[k] % MOD;\n}\n\nint main(){\n    int N, K;\n    cin >> N >> K;\n    if(K == 1){\n        cout << 1 << endl;\n        return 0;\n    }\n    create_mod_tables(N*K);\n    static int64_t dp[2001][2001];\n    dp[0][0] = fact[N];\n    for(int i=0; i<=N; i++) for(int j=0; j<=i; j++){\n        if(i<N) add(dp[i+1][j], dp[i][j]);\n        if(i>=j+1) add(dp[i][j+1], dp[i][j] * comb_mod(N*K - i - j*(K-1) - 1, K-2));\n    }\n    cout << dp[N][N] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define f first \n#define s second \n#define pb push_back               \n#define mp make_pair \n\nusing namespace std;                    \n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\n\nconst int N = (int)5e6 + 123, mod = (int)1e9 + 7;\n\nll dp[2500][2500], f[N], rf[N], n, k;\nvoid add(ll &a, ll b){\n\ta += b;\n\tif(a >= mod)\n\t\ta -= mod;\n}\nll binpow(ll x,ll p){\n\tll res = 1;\n\twhile(p){\n\t\tif(p&1)\n\t\t\tres = res * x % mod;\n\t\tx = x * x % mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\nll C(int k,int n){\n\treturn f[n] * rf[k] % mod * rf[n - k] % mod;\n}\nint main(){    \n\tf[0] = 1;\n\tfor(int i = 1; i < N; i++)\n\t\tf[i] = 1ll * f[i - 1] * i % mod;\n\trf[N - 1] = binpow(f[N - 1], mod - 2);\n\tfor(int i = N - 2; i >= 0; i--)\n\t\trf[i] = 1ll * rf[i + 1] * (i + 1) % mod;\n\t\n\tcin >> n >> k;\n\n\tif(k == 1)\n\t\tcout << 1, exit(0);\n\t\n\tdp[0][0] = 1;\n\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\tadd(dp[i + 1][j], dp[i][j]);\n\t\t\tif(j < i)\n            \tadd(dp[i][j + 1], 1ll *  dp[i][j] * C(k - 2, (n - j) * (k - 1) + n - i - 1) % mod );\n\t\t//\tcerr << dp[i][j] << \" \";\n\t\t}\n\t\t//cerr << endl;\n\t}\n\n\tcout << dp[n][n] * f[n] % mod << endl;\n\treturn 0;\n}\n                     "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\ntypedef long long i64;\n\nconst int N = 2000 + 10, MOD = 1000000007;\n\ninline void add(int &lhs, i64 rhs) { lhs = (lhs + rhs) % MOD; }\n\nint fact[N * N], ifact[N * N];\n\ninline int binom(int n, int m) {\n  return m > n ? 0 : ((i64)fact[n] * ifact[m] % MOD * ifact[n - m] % MOD);\n}\n\nint n, m, f[N][N];\n\nint main() {\n  fact[0] = 1;\n  for (int i = 1; i < N * N; ++i) fact[i] = (i64)fact[i - 1] * i % MOD;\n  ifact[1] = 1;\n  for (int i = 2; i < N * N; ++i) ifact[i] = ((i64)MOD - MOD / i) * ifact[MOD % i] % MOD;\n  ifact[0] = 1;\n  for (int i = 1; i < N * N; ++i) ifact[i] = (i64)ifact[i - 1] * ifact[i] % MOD;\n  scanf(\"%d%d\", &n, &m);\n  if (--m == 0) return puts(\"1\"), 0;\n  f[0][0] = 1;\n  for (int i = 0; i <= n; ++i) {\n    for (int j = 0; j <= n; ++j) {\n      if (i < j) add(f[i + 1][j], f[i][j]);\n      add(f[i][j + 1], (i64)binom(i + (j + 1) * m - 1, m - 1) * f[i][j] % MOD);\n    }\n  }\n  printf(\"%d\\n\", (i64)f[n][n] * fact[n] % MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ; \n\n#define int long long\nconst int MAXN = 2e3 + 100 ; \nconst int MAXH = 4e6 + 100 ; \nconst int Mod = 1e9 + 7 ;\n\nint fact[MAXH] ;\n\nvoid Pre(){\n\tfact[0] = 1 ; \n\tfor(int i = 1 ; i < MAXH ; i ++)fact[i] = fact[i - 1] * i % Mod ; \n}\nint power(int n , int m = Mod - 2){\n\tif(! m)return  1 ; \n\tif(m % 2)\treturn power(n , m - 1) * n % Mod ; \n\t\t\t\treturn power(n * n % Mod , m / 2) ; \n}\nint choose(int n , int m){\n\tif(n > m)return 0 ; \n\treturn fact[m] * power(fact[n]) % Mod * power(fact[m - n]) % Mod ; \n}\nint dp[MAXN][MAXN] ; \nint32_t main(){ \n\tios_base::sync_with_stdio(0) ; \n\tcin . tie(0) ; cout . tie(0) ; \n\t\n\tPre() ; \n\tint n , k ;  cin >> n >> k ; \n\tif(k == 1)return cout << 1 << '\\n' , 0 ; \n\tdp[0][0] = 1 ; \n\tfor(int i = 0 ; i <= n ; i ++){\n\t\tfor(int j = i + (i == 0) ; j <= n ; j ++){\n\t\t\tif(i > 0)dp[i][j] += dp[i - 1][j] ; \n\t\t\tif(j > 0)dp[i][j] += dp[i][j - 1] * choose(k - 2 , j * (k - 1) + i - 1) % Mod ;\n\t\t\tdp[i][j] %= Mod ; \n\t\t}\n\t}\n\tcout << dp[n][n] * fact[n] % Mod << '\\n' ; \n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> void Max(T &m, const T q) { if (m < q) m = q; }\ntemplate<typename T> void Min(T &m, const T q) { if (m > q) m = q; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\nlint N, K;\n\nconstexpr lint MOD = 1000000007;\nvector<lint> fac, facInv, inv;\nvoid facInit(int nmax)\n{\n    fac = facInv = inv = vector<lint>(nmax + 1, 1);\n    for (int i = 2; i <= nmax; i++)\n    {\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        facInv[i] = facInv[i-1] * inv[i] % MOD;\n    }\n}\nlint nCr(int n, int r)\n{\n    if (n<r || r<0) return 0;\n    if (n >= (int)fac.size()) facInit(n);\n    return (fac[n] * facInv[r] % MOD) * facInv[n-r] % MOD;\n}\n\nint main()\n{\n    cin >> N >> K;\n    facInit(4000000);\n\n    if (K == 1)\n    {\n        puts(\"1\");\n        return 0;\n    }\n    vector<vector<lint>> dp;\n    ndarray(dp, N + 1, N + 1);\n    dp[0][1] = 1;\n    FOR(i, 1, N + 1) FOR(j, 1, N + 1)\n    {\n        dp[i][j] = dp[i][j - 1];\n        if (i >= j) dp[i][j] += dp[i - 1][j] * nCr(j - 1 + (i - 1) * (K - 1) + K - 2, K - 2);\n        dp[i][j] %= MOD;\n    }\n\n    cout << dp[N][N] * fac[N] % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF=1000000000,mod=1e9+7;\nconst double eps = 1e-7;\n\nint f[2001][2001],c[5000000],inv[5000000];\n\n\nint main()\n{\n//\tfreopen(\"input.txt\",\"r\",stdin);\n\tint t;\n\tint n,m,q;\n//\tcin>>t;\n//\twhile(t--)\n//\twhile(scanf(\"%d\",&n)!=EOF) \n\t{\n\t\tcin>>n>>m;\n\t\tif(m==1)\n\t\t{\n\t\t\tcout<<1<<endl;\n\t\t\treturn 0;\n\t\t} \n\t\tf[0][0]=1;\n\t\tf[0][1]=1;\n\t\tc[m-2]=1;\n\t\tinv[1]=1;\n\t\tfor(int i=2;i<=n*m;i++)\n\t\t\tinv[i]=(long long)inv[mod%i]*(mod-mod/i)%mod;\n\t\tfor(int i=m-1;i<=n*m;i++)\n\t\t\tc[i]=(long long)c[i-1]*i%mod*inv[i-m+2]%mod;\n\t\tfor(int i=2;i<=n;i++)\n\t\t\tf[0][i]=(long long)f[0][i-1]*c[i*(m-1)-1]%mod;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=i;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tf[i][j]=f[i-1][j];\n\t\t\t\telse\n\t\t\t\t\tf[i][j]=(f[i-1][j]+(long long)f[i][j-1]*c[i+j*(m-1)-1]%mod)%mod;\n\t\t\t}\n//\t\tfor(int i=1;i<=n;i++)\n//\t\t\tfor(int j=i;j<=n;j++)\n//\t\t\t\tcout<<i<<' '<<j<<' '<<f[i][j]<<endl;\n\t\tlong long ans=f[n][n];\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tans=ans*i%mod;\n\t\tcout<<ans<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#if __cplusplus >= 201103L\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n#pragma comment(linker, \"/STACK:1024000000,1024000000\") \n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define EPS 1e-10\n#define set0(x) memset((x),0,sizeof(x))\n#define setINF(x) memset((x),63,sizeof(x))\nusing namespace std;\nint n,k;\nlong long fac[4000005],inv[4000005],dp[2005][2005];\ninline long long fpow(long long x,long long y){\n\tif(y==1)return x;\n\tlong long t=fpow(x,y>>1);\n\tt=t*t%MOD;\n\tif(y&1)t=t*x%MOD;\n\treturn t;\n}\ninline long long C(long long x,long long y){\n\treturn (fac[x]*inv[y]%MOD)*inv[x-y]%MOD;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin>>n>>k;\n\tif(k==1){\n\t\tcout<<\"1\\n\";\n\t\treturn 0;\n\t}\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=4000000;i++){\n\t\tfac[i]=fac[i-1]*i%MOD;\n\t\tinv[i]=fpow(fac[i],MOD-2);\n\t}\n\tdp[0][0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=i;j<=n;j++){\n\t\t\tif(i)dp[i][j]=dp[i-1][j];\n\t\t\tif(j>i)dp[i][j]=(dp[i][j]+dp[i][j-1]*C(j*(k-1)+i-1,k-2)%MOD)%MOD;\n\t\t}\n\t}\n\tcout<<(dp[n][n]*fac[n])%MOD<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define ll long long\n#define p 1000000007\nusing namespace std;\nnamespace ywy{\n\tinline ll mi(int a,int b){\n\t\tll ans=1,tmp=a;while(b){\n\t\t\tif(b&1)ans=(ans*tmp)%p;tmp=(tmp*tmp)%p;b>>=1;\n\t\t}return(ans);\n\t}int jc[5000001],jcny[5000001],dp[2022][2022];\n\tinline ll cnm(int n,int m){\n\t\tif(n<m)return(0);ll cjr=jc[n];cjr*=jcny[m];cjr%=p;cjr*=jcny[n-m];return(cjr%p);\n\t}\n\tinline void pre(int n){\n\t\tjc[0]=1;for(register int i=1;i<=n;i++)jc[i]=((ll)jc[i-1]*i)%p;jcny[n]=mi(jc[n],p-2);\n\t\tfor(register int i=n-1;i>=0;i--)jcny[i]=((ll)jcny[i+1]*(i+1))%p;\n\t}\n\tvoid ywymain(){\n\t\tint n,k;cin>>n>>k;if(k==1){\n\t\t\tcout<<1<<endl;return;\n\t\t}pre(n*k);dp[1][0]=dp[1][1]=1;for(register int i=2;i<=n;i++){\n\t\t\tfor(register int j=i;j>=0;j--){\n\t\t\t\tif(!j)dp[i][j]=dp[i][j+1];else{\n\t\t\t\t\tdp[i][j]=(dp[i][j+1]+((dp[i-1][j-1]*(ll)i)%p)*cnm(i*k-j-1,k-2))%p;\n\t\t\t\t}\n\t\t\t}\n\t\t}cout<<dp[n][0]<<endl;\n\t}\n}\nint main(){\n\tywy::ywymain();return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=2e3+10,mod=1e9+7;\ninline int ksm(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=(ll)res*x%mod;\n\t\tx=(ll)x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint dp[maxn][maxn],fac[maxn*maxn],ifac[maxn*maxn];\ninline int C(int n,int m){\n\treturn (ll)fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\ninline void init(int n){\n\tfac[0]=1;\n\tREP(i,1,n) fac[i]=(ll)i*fac[i-1]%mod;\n\tifac[n]=ksm(fac[n],mod-2);\n\tDREP(i,n,1) ifac[i-1]=(ll)i*ifac[i]%mod;\n}\nint main(){\n\tint n=read(),k=read();\n\tif(k==1){\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tinit(n*k);\n\tdp[0][0]=1;\n\tREP(i,1,n) REP(j,0,i){\n\t\tdp[i][j]=dp[i-1][j];\n\t\tif(j) dp[i][j]=(dp[i][j]+(ll)dp[i][j-1]*(n-j+1)%mod*C(n*k-i-(j-1)*(k-1)-1,k-2))%mod;\n\t}\n\tprintf(\"%d\\n\",dp[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define rep(a,b,c) for (int a=b;a<=c;a++)\n#define per(a,b,c) for (int a=b;a>=c;a--)\n#define go(u) for (int o=ft[u],v;v=E[o].t;o=E[o].n)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> par;\nconst int P=1000000007; \nconst int N=4000010;\nLL inv[N],s1[N],s2[N],f[2010][2010];\nint n,k;\nvoid upd(LL &x,LL y){x=(x+y)%P;}\nLL C(LL n,LL m){return s1[n]*s2[m]%P*s2[n-m]%P;}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tinv[1]=1;\n\trep(i,2,n*k) inv[i]=inv[P%i]*(P-P/i)%P;\n\ts1[0]=s2[0]=1;\n\trep(i,1,n*k) s1[i]=s1[i-1]*i%P,s2[i]=s2[i-1]*inv[i]%P;\n\tif (k==1) return puts(\"1\"),0;\n\t--k;\n\tf[0][0]=1;\n\trep(i,0,n) rep(j,0,i){\n\t\tLL s=i*k+j,fx=f[i][j];\n\t\tupd(f[i+1][j],fx*C(s+k-1,k-1)%P*(n-i));\n\t\tupd(f[i][j+1],fx);\n\t}\n\tprintf(\"%lld\\n\",f[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define snd second\n#define pb push_back\n#define eb emplace_back\n#define REP(i, a, b)  for(int i = (a), i##end = (b); i < i##end; ++i)\n#define DREP(i, a, b) for(int i=(a-1), i##end = (b); i >=i##end; --i)\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\nconst int oo = 0x3f3f3f3f;\nconst int mod = 1e9 + 7;\nconst int maxm = 4e6 + 10;\nconst int maxn = 2000 + 10;\n\ntemplate<typename T> T read() {\n    T n(0), f(1);\n    char ch = getchar();\n    for( ;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for( ; isdigit(ch); ch = getchar()) n = n * 10 + ch - 48; \n    return n * f;\n}\n\nLL f[maxn][maxn];\nLL fac[maxm], ifac[maxm];\n\nLL fpm(LL base, LL exp) {\n    LL ans = 1;\n    for(; exp > 0; exp >>= 1) {\n        if(exp & 1) \n            ans = ans * base % mod;\n        base = base * base % mod;\n    }\n    return ans;\n}\n\nLL C(int n, int m) {\n    return fac[n] * ifac[m] % mod * ifac[n-m] % mod;\n}\nvoid init() {\n    fac[0] = ifac[0] = 1;\n    for(int i = 1; i < maxm; i++) {\n        fac[i] = fac[i-1] * i % mod;\n        ifac[i] = fpm(fac[i], mod-2);\n    }\n}\n\nint n, k;\nint main() {\n#ifdef Wearry\n    freopen(\"data.txt\", \"r\", stdin);\n    freopen(\"ans.txt\", \"w\", stdout);\n#endif\n\n    n = read<int>(); k = read<int>();\n    if(k == 1) return puts(\"1\"), 0;\n\n    init();\n    f[n][n] = 1;\n    for(int i = n; i >= 0; i--) {\n        for(int j = n; j >= 0; j--) if(f[i][j]) {\n            if(i > j) (f[i-1][j] += f[i][j]) %= mod;\n            if(j > 0) (f[i][j-1] += f[i][j] * C(n-i + (n-j)*(k-1) + k-2, k-2)) %= mod;\n        }\n    }\n    printf(\"%lld\\n\", f[0][0] * fac[n] % mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<ll> vec;\n\nvoid debug(vec &v) {\n\tint n = v.size();\n\trep(i, n) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << v[i];\n\t}\n\tcout << endl;\n}\n\nll mod_pow(ll x, ll n) {\n\tll ret = 1;\n\twhile (n > 0) {\n\t\tif (n % 2)ret = ret * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn ret;\n}\nstruct perm {\nprivate:\n\tint sz;\n\tvector<ll> p, invp;\npublic:\n\tperm(int n) {\n\t\tsz = n + 1;\n\t\tp.resize(sz), invp.resize(sz);\n\t\tp[0] = 1;\n\t\trep1(i, sz - 1) {\n\t\t\tp[i] = p[i - 1] * i%mod;\n\t\t}\n\t\tinvp[sz - 1] = 1;\n\t\tll cop = mod - 2, x = p[sz - 1];\n\t\twhile (cop) {\n\t\t\tif (cop % 2)invp[sz - 1] = invp[sz - 1] * x%mod;\n\t\t\tcop >>= 1; x = x * x % mod;\n\t\t}\n\t\tper(i, sz - 1) {\n\t\t\tinvp[i] = invp[i + 1] * (i + 1) % mod;\n\t\t}\n\t}\n\tll comb(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\tll ret = p[x];\n\t\t(ret *= invp[y]) %= mod;\n\t\t(ret *= invp[x - y]) %= mod;\n\t\treturn ret;\n\t}\n\tll combP(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\treturn p[x] * invp[x - y] % mod;\n\t}\n};\nperm pm(1 << 22);\n\nll dp[2001];\nll rdp[2002];\nll nex[2001];\n\nvoid solve() {\n\tint n, k; cin >> n >> k;\n\tif (k == 1) {\n\t\tcout << 1 << endl; return;\n\t}\n\tdp[1] = 1;\n\tfor (int i = 2; i < 2002; i++)rdp[i] = 1;\n\trep1(i, n - 1) {\n\t\tfor (int j = 1; j <= i + 1; j++) {\n\t\t\tint num = i * k - (j - 1);\n\t\t\tnex[j] = (rdp[i + 1] - rdp[j - 1])*pm.comb(num + k - 2, num);\n\t\t\tnex[j] = (nex[j] % mod + mod) % mod;\n\t\t}\n\t\tfor (int j = 1; j <= i + 1; j++) {\n\t\t\tdp[j] = nex[j];\n\t\t\trdp[j + 1] = (rdp[j] + dp[j]) % mod;\n\t\t}\n\t}\n\tll ans = rdp[n + 1];\n\trep1(i, n)ans = ans * i%mod;\n\tcout << ans << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(12);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 1000000007\n#define N 2009\n#define M 4000009\n#define cbn(x,y) ((ll)fac[x]*inv[y]%mod*inv[(x)-(y)]%mod)\nusing namespace std;\n\nint n,m,tot,fac[M],inv[M],dp[N][N];\nint main(){\n\tscanf(\"%d%d\",&n,&m); tot=n*m;\n\tif (m==1){ puts(\"1\"); return 0; }\n\tint i,j;\n\tfac[0]=inv[0]=inv[1]=1;\n\tfor (i=1; i<=tot; i++) fac[i]=(ll)fac[i-1]*i%mod;\n\tfor (i=2; i<=tot; i++) inv[i]=mod-(ll)inv[mod%i]*(mod/i)%mod;\n\tfor (i=2; i<=tot; i++) inv[i]=(ll)inv[i-1]*inv[i]%mod;\n\tdp[1][0]=fac[n];\n\tfor (i=1; i<=n; i++)\n\t\tfor (j=0; j<=i; j++){\n\t\t\tif (i<n) dp[i+1][j]=(dp[i+1][j]+dp[i][j])%mod;\n\t\t\tif (j<i) dp[i][j+1]=(dp[i][j+1]+(ll)dp[i][j]*cbn(tot-i-(m-1)*j-1,m-2))%mod;\n\n\t\t}\n\tprintf(\"%d\\n\",dp[n][n]); \n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// AGC002F.cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 2020, mod = 1e9 + 7;\n\nint n, k, dp[MAX_N][MAX_N], fac[MAX_N * MAX_N], fac_inv[MAX_N * MAX_N], fac_tot;\n\nint quick_pow(int bas, int tim)\n{\n    int ret = 1;\n    while (tim)\n    {\n        if (tim & 1)\n            ret = 1LL * ret * bas % mod;\n        bas = 1LL * bas * bas % mod;\n        tim >>= 1;\n    }\n    return ret;\n}\n\nint comb(int upper, int lower) { return 1LL * fac[upper] * fac_inv[lower] % mod * fac_inv[upper - lower] % mod; }\n\nint main()\n{\n    scanf(\"%d%d\", &n, &k), fac_tot = n * k;\n    if (k == 1)\n        puts(\"1\"), exit(0);\n    for (int i = fac[0] = 1; i <= fac_tot; i++)\n        fac[i] = 1LL * fac[i - 1] * i % mod;\n    fac_inv[fac_tot] = quick_pow(fac[fac_tot], mod - 2);\n    for (int i = fac_tot - 1; i >= 0; i--)\n        fac_inv[i] = 1LL * fac_inv[i + 1] * (i + 1) % mod;\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++)\n        for (int j = 0; j <= i; j++)\n        {\n            dp[i][j] = dp[i - 1][j];\n            if (j > 0)\n                dp[i][j] = (1LL * dp[i][j] + 1LL * comb(n - i + (n - j + 1) * (k - 1) - 1, k - 2) * dp[i][j - 1] % mod * (n - j + 1) % mod) % mod;\n        }\n    printf(\"%d\\n\", dp[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(X,Y) ((X)>(Y)?X=(Y),true:false)\n#define chmax(X,Y) ((X)<(Y)?X=(Y),true:false)\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 2001\n#define NN (N*N)\nll inv[NN], fact[NN], ifact[NN];\nll n, k;\nll dp[N][N];\n\nvoid init_fact(ll n = NN){\n    inv[1] = 1;\n    for(int i = 2; i < n;i++) inv[i] = inv[mod%i] * (mod - mod/i) % mod;\n\tfact[0] = ifact[0] = 1;\n\tfor(int i = 1; i < n; i++){\n\t\tfact[i] = (fact[i-1]*i)%mod;\n\t\tifact[i]=(ifact[i-1]*inv[i])%mod;\n\t}\n}\n\nll comb(ll a, ll b){\n\treturn fact[a+b]*ifact[a]%mod*ifact[b]%mod;\n}\n\nint main(){\n\tinit_fact();\n\tcin>>n>>k;\n\tif(k==1){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tfill(dp[0], dp[0]+N, fact[n]);\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = i; j <= n; j++){\n\t\t\tdp[i][j]=(dp[i][j-1]+dp[i-1][j]*comb(k-2, (n-i)*k+i-j))%mod;\n\t\t}\n\t}\n\tcout<<dp[n][n]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author: ylx\n * Lang: c++\n * Prog: agc002F\n */\n#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nvoid qmax(int &x, int y)\n{\n    if (x < y)\n        x = y;\n}\nvoid qmin(int &x, int y)\n{\n    if (x > y)\n        x = y;\n}\ninline ll read()\n{\n    char s;\n    ll k = 0, base = 1;\n    while ((s = getchar()) != '-' && s != EOF && !(isdigit(s)))\n        ;\n    if (s == EOF)\n        exit(0);\n    if (s == '-')\n        base = -1, s = getchar();\n    while (isdigit(s))\n        k = k * 10 + (s ^ '0'), s = getchar();\n    return k * base;\n}\ninline void write(ll x)\n{\n    static char cnt, num[20];\n    cnt = 0;\n    if (!x)\n    {\n        putchar('0');\n        return;\n    }\n    for (; x; x /= 10)\n        num[++cnt] = x % 10;\n    for (; cnt; putchar(num[cnt--] + 48))\n        ;\n}\nconst int maxn = 4e6 + 100;\nconst ll mod = 1e9 + 7;\nint jie[maxn], ny[maxn];\nint n, m;\nll ksm(ll x, int y)\n{\n    ll sum = 1;\n    while (y)\n    {\n        if (y & 1)\n            sum = sum * x % mod;\n        x = x * x % mod;\n        y >>= 1;\n    }\n    return sum;\n}\nvoid init()\n{\n    n = 4e6;\n    jie[0] = 1;\n    for (int i = 1; i <= n; i++)\n        jie[i] = (ll)jie[i - 1] * i % mod;\n    ny[n] = ksm(jie[n], mod - 2);\n    for (int i = n; i >= 1; i--)\n        ny[i - 1] = (ll)ny[i] * i % mod;\n}\nll C(int x, int y)\n{\n    if (x < y)\n        return 0;\n    return (ll)jie[x] * ny[x - y] % mod * ny[y] % mod;\n}\nll f[2][2030];\nint main()\n{\n#ifdef ylx\n    freopen(\"agc002F.in\", \"r\", stdin);\n    freopen(\"agc002F.out\", \"w\", stdout);\n#endif\n    init();\n    n = read(), m = read();\n    if (m == 1)\n    {\n        cout << 1 << endl;\n        return 0;\n    }\n    f[0][0] = 1;\n    for (int i = 1, p; i <= n; i++)\n    {\n        p = i & 1;\n        memset(f[p], 0, sizeof(f[p]));\n        for (int j = 0; j <= i; j++)\n        {\n            if (!j)\n            {\n                f[p][j] = f[p ^ 1][j];\n                continue;\n            }\n            f[p][j] = f[p ^ 1][j] + f[p][j - 1] * (n - j + 1) % mod * C((n - j + 1) * (m - 1) + n - i - 1, m - 2) % mod;\n        }\n    }\n    write(f[n & 1][n]);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    Author: zxy_hhhh\n    date: 2020/03/12\n*/\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<set>\n#include<vector>\n#include<map>\n#include<queue>\n#include<iostream>\n#define ll long long\ninline ll rd() {\n    ll _x=0;int _ch=getchar(),_f=1;\n    for(;!isdigit(_ch)&&(_ch!='-')&&(_ch!=EOF);_ch=getchar());\n    if (_ch=='-'){_f=0;_ch=getchar();}\n    for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0';\n    return _f?_x:-_x;\n}\nvoid write(ll _x){if (_x>=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); }\ninline void wrt(ll _x,char _p){if (_x<0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);}\n#define maxn 2005\n#define mod 1000000007\nint n,K;\nint f[maxn][maxn];\nint fac[maxn*maxn],inv[maxn*maxn];\ninline int C(int n,int m) {return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint main() {\n    #ifndef ONLINE_JUDGE\n    freopen(\"test.in\",\"r\",stdin);\n    freopen(\"test.out\",\"w\",stdout);\n    #endif\n    n=rd();K=rd();\n    if (K==1) {\n        wrt(0,'\\n');\n        return 0;\n    }\n    fac[0]=fac[1]=inv[0]=inv[1]=1;\n    for(int i=2;i<=n*K;i++) {\n        fac[i]=1ll*fac[i-1]*i%mod;\n        inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n    }\n    for(int i=1;i<=n*K;i++) {\n        inv[i]=1ll*inv[i-1]*inv[i]%mod;\n    }\n    f[0][0]=1;\n    for(int i=1;i<=n;i++) {\n        for(int j=0;j<=i;j++) {\n            f[i][j]=(f[i-1][j]+(j>0?1ll*f[i][j-1]*C(n*K-i-(j-1)*(K-1)-1,K-2)%mod*(n-j+1):0))%mod;\n        }\n    }\n    wrt(f[n][n],'\\n');\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\n//typedef complex<D> P;\n#define F first\n#define S second\nconst ll MOD=1000000007;\n//const ll MOD=998244353;\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){int i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\n\nclass comb{\npublic:\n    ll mod;\n    ll mx;\n    vector<ll> F;\n    vector<ll> FR;\n    \n\n    comb(ll mod=1000000007,ll mx=5000000):mod(mod),mx(mx),F(mx+1,1),FR(mx+1,1){\n        mk_F();\n    }\n    \n    ll mod_pow(ll a,ll x){\n        a%=mod;\n        ll ans=1;\n        while(x>0){\n            if(x&1){ans*=a; ans%=mod;}\n            a*=a;\n            a%=mod;\n            x>>=1;\n        }\n        return ans;\n    }\n    \n    pll Ex_gcd(ll a,ll b){\n        if(b==0){return {1,0};}\n        pll ret=Ex_gcd(b,a%b);\n        ret.F-=a/b*ret.S;\n        return {ret.S,ret.F};\n    }\n    \n    ll prime_R(ll a){\n        return mod_pow(a,mod-2);\n    }\n    \n    ll R(ll a){\n        ll ret=Ex_gcd(a,mod).F;\n        ret%=mod;\n        if(ret<0){ret+=mod;}\n        return ret;\n    }\n    \n    void mk_F(){\n        for(ll i=1;i<=mx;i++){F[i]=F[i-1]*i%mod; FR[i]=R(F[i]);}\n    }\n    \n    ll c(ll n,ll k){\n      if(n==k){return 1;}\n        if(n<k || k<0 || n<0){return 0;}\n        if(n==k || k==0){return 1;}\n        return F[n]*FR[n-k]%mod*FR[k]%mod;\n    }\n    \n    //mod must be prime\n    ll Lucas_C(ll n,ll m){\n        ll ret=1;\n        while(n>0 || m>0){\n            ret*=c(n%mod,m%mod);\n            ret%=mod;\n            n/=mod; m/=mod;\n        }\n        return ret;\n    }\n    \n    ll Stirling(ll n,ll k){\n        ll ret=0;\n        for(ll i=1;i<=k;i++){\n            if((k-i)%2){ret-=c(k,i)*mod_pow(i,n)%mod;}\n            else{ret+=c(k,i)*mod_pow(i,n)%mod;}\n            ret%=mod;\n        }\n        ret*=R(F[k]);\n        ret%=mod;\n        if(ret<0){ret+=mod;}\n        return ret;\n    }\n    \n    ll Bell(ll n,ll k){\n        ll ret=0;\n        for(ll i=1;i<=k;i++){ret+=Stirling(n,i); ret%=mod;}\n        return ret;\n    }\n};\n\ntemplate<long long int mod=1000000007>\nstruct Mod_Int{\n    typedef long long int ll;\n    typedef pair<ll,ll> pll;\n    typedef Mod_Int<mod> M;\n    ll a;\n    \n    ll mod_pow(ll a,ll x){\n        a%=mod;\n        ll ans=1;\n        for(int i=0;i<63;i++){\n            if(x>>i&1){ans*=a; ans%=mod;}\n            a*=a;\n            a%=mod;\n        }\n        return ans;\n    }\n    \n    pll Ex_gcd(ll a,ll b){\n        if(b==0){return {1,0};}\n        pll ret=Ex_gcd(b,a%b);\n        ret.F-=a/b*ret.S;\n        return {ret.S,ret.F};\n    }\n    \n    ll prime_R(ll a){\n        return mod_pow(a,mod-2);\n    }\n    \n    ll R(ll a){\n        ll ret=Ex_gcd(a,mod).F;\n        ret%=mod;\n        if(ret<0){ret+=mod;}\n        return ret;\n    }\n    \n    Mod_Int(ll A=1):a(A){\n        a%=mod;\n        if(a<0){a+=mod;}\n    }\n    \n    Mod_Int(const M &b):a(b.a){}\n    \n    M & operator += (const M &b){\n        a+=b.a;\n        if(a>=mod){a-=mod;}\n        return *this;\n    }\n    \n    M operator + (const M &b) const {\n        M c=*this;\n        return c+=b;\n    }\n    \n    M & operator -= (const M &b){\n        a-=b.a;\n        if(a<0){a+=mod;}\n        return *this;\n    }\n    \n    M operator - (const M &b) const {\n        M c=*this;\n        return c-=b;\n    }\n    \n    M & operator *= (const M &b){\n        (a*=b.a)%=mod;\n        return *this;\n    }\n    \n    M operator * (const M &b) const {\n        M c=*this;\n        return c*=b;\n    }\n    \n    M & operator /= (const M &b){\n        (a*=R(b.a))%=mod;\n        return *this;\n    }\n    \n    M operator / (const M &b) const {\n        M c=*this;\n        return c/=b;\n    }\n    \n    M & mod_pow_equal(ll x){\n        ll ans=1;\n        while(x>0){\n            if(x&1){ans*=a; ans%=mod;}\n            a*=a;\n            a%=mod;\n            x>>=1;\n        }\n        a=ans;\n        return *this;\n    }\n    \n    M mod_pow(ll x){\n        M c(a);\n        return c.mod_pow_equal(x);\n    }\n    \n    bool operator == (const M &b) const {return a==b.a;}\n    \n    bool operator != (const M &b) const {return a!=b.a;}\n    \n    bool operator <= (const M &b) const {return a<=b.a;}\n    \n    bool operator < (const M &b) const {return a<b.a;}\n    \n    bool operator > (const M &b) const {return a>b.a;}\n    \n    bool operator >= (const M &b) const {return a>=b.a;}\n    \n    M & operator = (const M &b){\n        a=b.a;\n        return *this;\n    }\n    \n    M & operator = (const ll &b){\n        (a=b)%=mod;\n        if(a<0){a+=mod;}\n        return *this;\n    }\n};\n\ntemplate<long long MOD>istream & operator >> (istream &i,Mod_Int<MOD> &A){ll a; cin>>a; A=Mod_Int<MOD>(a); return i;}\ntemplate<long long MOD>ostream & operator << (ostream &i,const Mod_Int<MOD> &A){i<<A.a; return i;}\n\nusing Int=Mod_Int<MOD>;\ncomb C;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll N,K;\n  cin>>N>>K;\n  vector<Int> dp1(N+1,0),dp2(N+1);\n  if(K==1){\n    cout<<1<<endl;\n    return 0;\n  }\n  dp1[0]=1;\n  for(int i=1;i<=N;i++){\n    for(auto &I:dp2){I=0;}\n    for(int j=0;j<N;j++){dp2[j+1]+=dp1[j];}\n    swap(dp1,dp2);\n    for(int j=i;j>0;j--){\n      dp1[j-1]+=dp1[j]*(N-(i-j))*C.c(N*K-K*(i-j)-j-1,K-2);\n    }\n  }\n  cout<<dp1[0]<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define upd(x,y) x=(x+(y)>=mu?x+(y)-mu:x+(y))\nconst int mu=1000000007,N=2005;\nint dp[N][N],p[N*N],inv[N*N],n,k;\nint ksm(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=1ll*x*x%mu)\n\t\tif (y&1) ans=ans*1ll*x%mu;\n\treturn ans;\n}\nint C(int x,int y){\n\treturn 1ll*p[x]*inv[y]%mu*inv[x-y]%mu;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tif (k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tint tot=n*k;\n\tdp[0][0]=1;\n\tp[0]=1;\n\tfor (int i=1;i<=tot;i++) p[i]=1ll*p[i-1]*i%mu;\n\tinv[tot]=ksm(p[tot],mu-2);\n\tfor (int i=tot;i;i--) inv[i-1]=inv[i]*1ll*i%mu;\n\tfor (int i=0;i<=n;i++){//放了几个0 \n\t\tfor (int j=i;j>=0;j--){//几个颜色没放完 \n\t\t\tupd(dp[i+1][j+1],dp[i][j]);//放一个0\n\t\t\tif(j) upd(dp[i][j-1],1ll*dp[i][j]*(n-(i-j))%mu*C((n-i)*k+j*(k-1)-1,k-2)%mu);//放一个颜色的第一个 \n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[n][0]%mu);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); i++)\n#define per(i,a,b) for (int i=(a); i>=(b); i--)\nusing namespace std;\n\nconst int maxn = 2005;\nconst int mod = 1000000007;\nint fac[maxn*maxn], rev[maxn*maxn], f[maxn<<1][maxn];\nint n, K, ans;\n\ninline int power(int x, int p) {\n\tint res = 1;\n\twhile (p) {\n\t\tif (p & 1) res = 1ll * res * x % mod;\n\t\tx = 1ll * x * x % mod; p >>= 1;\n\t}\n\treturn res;\n}\n\ninline int C(int n, int m) {\n\treturn 1ll * fac[n] * rev[m] % mod * rev[n-m] % mod;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &K);\n\tfac[0] = rev[0] = 1;\n\trep (i, 1, maxn*maxn-1) {\n\t\tfac[i] = 1ll * fac[i-1] * i % mod;\n\t\trev[i] = power(fac[i], mod - 2);\n\t}\n\tf[0][0] = 1;\n\trep (i, 1, n*2) rep (j, 0, n)\n\t\tif (f[i-1][j]) {\n\t\t\tif (j*2 > i-1) \n\t\t\t\tf[i][j] = (f[i][j] + f[i-1][j]) % mod;\n\t\t\tf[i][j+1] = (f[i][j+1] + 1ll * f[i-1][j] * C(K * (i-1-j) + (K-1) * (2*j-i+1) + K-2, K-2)) % mod;\n\t\t}\n\tans = 1ll * f[n*2][n] * fac[n] % mod;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\nint read();\nint M(int x) { return x >= mod ? x - mod : x; }\nint fsp(int bs, int p) {\n  int rt = 1;\n  while (p) {\n    if (p & 1) rt = 1ll * rt * bs % mod;\n    bs = 1ll * bs * bs % mod, p >>= 1;\n  }\n  return rt;\n}\n\nint n, k;\nint fac[4000006], caf[4000006];\nvoid init() {\n  int lim = 4000000;\n  fac[0] = 1;\n  for (int i = 1; i <= lim; ++i) fac[i] = 1ll * fac[i - 1] * i % mod;\n  caf[lim] = fsp(fac[lim], mod - 2);\n  for (int i = lim; i >= 1; --i) caf[i - 1] = 1ll * caf[i] * i % mod;\n}\nint C(int x, int y) { return 1ll * fac[x] * caf[y] % mod * caf[x - y] % mod; }\nint f[2003][2003];\n\nint main() {\n  n = read(), k = read(), init();\n  if (k == 1) return puts(\"1\"), 0;\n  for (int i = 1; i <= n; ++i) f[i][0] = 1;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= i; ++j)\n      f[i][j] = M(f[i - 1][j] +\n                  1ll * f[i][j - 1] * (n - j + 1) % mod *\n                      C(n - i + (n - j + 1) * (k - 1) - 1, k - 2) % mod);\n  printf(\"%d\\n\", f[n][n]);\n  return 0;\n}\n\nint read() {\n  int x = 0, f = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') f = (c == '-') ? -1 : f, c = getchar();\n  while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n  return x * f;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int N = 2001;\nconst int MOD = (int)1e9 + 7;\n\nint fact[N * N], inv_fact[N * N], dp[N][N];\n\nint binom(int n, int k)\n{\n    return 1LL * fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD;\n}\n\nvoid update(int& x, int a)\n{\n    x += a;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n}\n\nint main()\n{\n    fact[0] = fact[1] = inv_fact[1] = 1;\n    for (int i = 2; i < N * N; ++ i) {\n        fact[i] = 1LL * fact[i - 1] * i % MOD;\n        inv_fact[i] = 1LL * inv_fact[MOD % i] * (MOD - MOD / i) % MOD;\n    }\n    inv_fact[0] = 1;\n    for (int i = 1; i < N * N; ++ i) {\n        inv_fact[i] = 1LL * inv_fact[i - 1] * inv_fact[i] % MOD;\n    }\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    if (m == 1) {\n        puts(\"1\");\n    } else {\n        dp[0][0] = 1;\n        for (int z = 0; z <= n; ++ z) {\n            for (int f = 0; f <= z; ++ f) {\n                if (z < n) {\n                    update(dp[z + 1][f], dp[z][f]);\n                }\n                if (f < z) {\n                    int left = (n - z) + (n - f - 1) + (m - 2) * (n - f);\n                    update(dp[z][f + 1], 1LL * dp[z][f] * binom(left, m - 2) % MOD);\n                }\n                // printf(\"%d \", dp[z][f]);\n            }\n            puts(\"\");\n        }\n        printf(\"%d\\n\", (int)(1LL * fact[n] * dp[n][n] % MOD));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 2005 \n#define P int(1e9+7)\nusing namespace std;\ntypedef long long ll;\nconst int NN = 4e6;\n\nll qpow(ll x, int n){\n\tll res = 1;\n\twhile(n){\n\t\tif(n&1) res = res * x % P;\n\t\tx = x * x % P;\n\t\tn /= 2;\n\t}\n\treturn res;\n}\n\nint N,K;\n\nll fac[NN+5], ifac[NN+5];\nll dp[MAXN][MAXN];\n/*\ndp[i][j] = dp[i-1][j] + dp[i][j-1] * (n-j+1) * comb(i+j*(k-1)-1,k-2)\n*/\n\nvoid init(){\n\tfac[0] = 1;\n\tfor(int i=1;i<=NN;i++){\n\t\tfac[i] = fac[i-1] * i % P;\n\t}\n\t\n\tifac[NN] = qpow(fac[NN], P-2);\n\tfor(int i=NN-1;i>=0;i--){\n\t\tifac[i] = ifac[i+1] * (i+1) % P;\n\t}\n}\n\nll comb(int n, int k){\n\tif(k > n) return 0;\n\treturn fac[n] * ifac[k] % P * ifac[n-k] % P;\n}\n\nint main(){\n\t\n\tcin>>N>>K;\n\tif(K==1){\n\t\tcout<<\"1\"<<endl;\n\t\treturn 0;\n\t}\n\tinit();\n\tdp[0][0] = 1;\n\t\n\tfor(int i=1;i<=N;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\tif(j>0) dp[i][j] = (dp[i][j] + dp[i][j-1] * (N-j+1) % P * comb((N-i)+(N-j+1)*(K-1)-1, K-2)) % P;\n\t\t}\n\t}\n\t\n\tcout<<dp[N][N]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint mod = 1000000007;\nlong long f[(1<<25)], invf[(1<<25)];\n\nlong long pow2( long long a, long long st ) {\n    long long ret = 1;\n    while ( st ) {\n        if ( st&1 ) {\n            ret *= a;\n            ret %= mod;\n        }\n\n        a *= a;\n        a %= mod;\n        st /= 2;\n    }\n    return ret;\n}\n\nvoid pre () {\n    f[0] = 1;\n    invf[0] = 1;\n    for ( int i = 1; i < (1<<24) ; i ++ ) {\n        f[i] = f[i-1]*i%mod;\n    }\n\n    invf[ (1<<24)-1 ] = pow2( f[ (1<<24)-1 ], mod-2 );\n    for ( int i = (1<<24)-2 ; i > 0 ; i -- ) {\n        invf[i] = invf[i+1]*(i+1)%mod;\n    }\n}\n\nint comb( int n, int k ) {\n    return f[n]*invf[k]%mod*invf[n-k]%mod;\n}\n\nint k;\n\nlong long mem[2042];\n\nlong long solve ( int cnt ) {\n    if ( cnt == 1 ) { return 1; }\n    if ( mem[cnt] ) { return mem[cnt]-1; }\n\n    long long ret = 0;\n    for ( int i = 0 ; i <= k-1 ; i ++ ) {\n\n        //cout << i << \" : \" << comb( (cnt-1)*k+i-1, i-1 ) << \"\\n\";\n        if ( i == k-1 ) {\n            //cout << i << \": \" << solve( cnt-1 )*comb( (cnt-1)*k+i-1, i ) << \"\\n\";\n            ret += solve( cnt-1 )*comb( (cnt-1)*k+i-1, i )%mod;\n            if ( ret >= mod ) { ret -= mod; }\n        }\n        else {\n            ret += solve( cnt-1 )*comb( (cnt-1)*k+i-1, i )%mod*cnt%mod;\n            if ( ret >= mod ) { ret -= mod; }\n        }\n    }\n    mem[cnt] = ret+1;\n    return ret;\n}\n\nint main () {\n    pre();\n\n    int n;\n    cin >> n >> k;\n\n    cout << solve ( n ) << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 100005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 +c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nconst int MOD = 1000000007;\nint fac[10000005],invfac[10000005];\nint dp[2005][2005],N,K,sum[2005];\nint inc(int a,int b) {\n    return a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n    return 1LL * a * b % MOD;\n}\nvoid update(int &x,int y) {\n    x = inc(x,y);\n}\nint C(int n,int m) {\n    if(n < m) return 0;\n    return mul(fac[n],mul(invfac[m],invfac[n - m]));\n}\nint Query(int n,int m) {\n    return C(n + m - 1,m - 1);\n}\nint fpow(int x,int c) {\n    int res = 1,t = x;\n    while(c) {\n\tif(c & 1) res = mul(res,t);\n\tt = mul(t,t);\n\tc >>= 1;\n    }\n    return res;\n}\nvoid Solve() {\n    read(N);read(K);\n    if(K == 1) {puts(\"1\");return;}\n    fac[0] = 1;\n    for(int i = 1 ; i <= 10000000 ; ++i) fac[i] = mul(fac[i - 1],i);\n    invfac[10000000] = fpow(fac[10000000],MOD - 2);\n    for(int i = 9999999 ; i >= 0 ; --i) invfac[i] = mul(invfac[i + 1],i + 1);\n    dp[1][0] = 1;\n    for(int i = 2 ; i <= N ; ++i) {\n\tint t = (i - 1) * K + 1;\n\tfor(int j = N ; j >= 0 ; --j) sum[j] = inc(sum[j + 1],dp[i - 1][j]);\n\tfor(int j = 0 ; j <= i ; ++j) {\n\t    update(dp[i][j],mul(sum[max(0,j - 1)],Query(K - 2,t - j)));\n\t}\n    }\n    int ans = 0;\n    for(int j = 0 ; j <= N ; ++j) update(ans,mul(dp[N][j],fac[N]));\n    out(ans);enter;\n}\n\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\n#define int long long\n#define inc(i,j,k) for(re int i=j;i<=k;++i)\n#define dec(i,j,k) for(re int i=j;i>=k;--i)\n#define ll long long\nusing namespace std;\nconst int maxn=2001;\nconst int mod=1e9+7;\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9') {if(ch=='-') f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9') {x=x*10+(ch^48); ch=getchar();}\n\treturn x*f;\n}\nint n,k;\nll f[maxn+10][maxn+10],inv[maxn+10],fac[maxn+10];\nll qpow(ll a,ll b)\n{\n\tll base=1;\n\ta%=mod;\n\twhile(b)\n\t{\n\t\tif(b&1) base=base*a%mod;\n\t\tb>>=1;\n\t\ta=a*a%mod;\n\t}\n\treturn base;\n}\ninline ll C(int n,int m){ return (((fac[m]*inv[n])%mod)*inv[m-n])%mod; }\nsigned main()\n{\n\tn=read(); k=read();\n\tif(k==1) \n\t{\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\tinc(i,1,maxn) fac[i]=(fac[i-1]*i)%mod;\n\tinv[maxn]=qpow(fac[maxn],mod-2);\n\tdec(i,maxn-1,0) inv[i]=(inv[i+1]*(i+1))%mod;\n\tf[0][0]=1;\n\tinc(i,1,n)\n\t{\n\t\tinc(j,0,i)\n\t\t{\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(j==0) continue;\n\t\t\t(f[i][j]+=f[i][j-1]*(n-j+1)%mod*C(k-2,n-i+(n-j+1)*(k-1)-1)%mod)%=mod;\n\t\t}\n\t}\n\tcout<<f[n][n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define poly vector<ll>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\ninline char gc(){\n\tstatic char buf[100000],*p1=buf,*p2=buf;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x=0;char ch=gc();bool positive=1;\n\tfor(;!isdigit(ch);ch=gc()) if(ch=='-') positive=0;\n\tfor(;isdigit(ch);ch=gc()) x=x*10+ch-'0';\n\treturn positive?x:-x;\n}\ninline void write(ll x){\n\tif(x<0){\n\t\tx=-x;putchar('-');\n\t}\n\tif(x>=10) write(x/10);\n\tputchar('0'+x%10);\n}\ninline void writeln(ll x){write(x);puts(\"\");}\ninline void writep(ll x){write(x);putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=2005,mo=1e9+7,M=4e6+5;\nint fac[M],inv[M],f[N][N];\nint C(int n,int m){\n\treturn (ll)fac[n]*inv[m]%mo*inv[n-m]%mo;\n}\nint ksm(int x,int p){\n\tint res=1;\n\tfor(;p;p>>=1,x=(ll)x*x%mo){\n\t\tif(p&1) res=(ll)res*x%mo;\n\t}\n\treturn res;\n}\nint main(){\n\tint n=read(),m=read(),k=n*m;\n\tFor(i,fac[0]=1,k) fac[i]=(ll)fac[i-1]*i%mo;\n\tinv[k]=ksm(fac[k],mo-2);\n\tRep(i,k-1,0) inv[i]=(ll)inv[i+1]*(i+1)%mo;\n\tf[0][0]=1;\n\tFor(i,1,n) For(j,0,i){\n\t\tf[i][j]=f[i-1][j];\n\t\tif(j) f[i][j]=(f[i][j]+(ll)C(n-i+(n-j+1)*(m-1)-1,m-2)*f[i][j-1]%mo*(n-j+1))%mo;\n\t}\n\tif(m==1) f[n][n]=1;\n\tcout<<f[n][n];\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define int long long\nusing namespace std;\nconst int mod=1e9+7,N=2005;\nint n,k,f[N][N],fac[N*N],inv[N*N],infac[N*N];\nint C(int a,int b)\t{return fac[a]*infac[b]%mod*infac[a-b]%mod;}\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&k);\n\tif(k==1){\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tfac[0]=infac[0]=inv[1]=1;\n\tfor(int i=2;i<=n*k;i++)\tinv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=1;i<=n*k;i++)\tfac[i]=fac[i-1]*i%mod,infac[i]=infac[i-1]*inv[i]%mod;\n\tfor(int i=1;i<=n;i++)\tf[i][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tf[i][j]+=(f[i-1][j]+C(k*n-i-(j-1)*(k-1)-1,k-2)*f[i][j-1]%mod*(n-j+1)%mod)%mod;\n\tprintf(\"%lld\\n\",f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\ntypedef long long ll;\nll mod=1e9+7;\nll dp[2001][2001];\nconst int M=2000*2000;\nll f[M],g[M],inv[M];\nvoid precalc(){\n\tf[0]=1;\n\trep1(i,M) f[i]=f[i-1]*i%mod;\n\tinv[1]=1;\n\tfor(int i=2;i<=M;i++) inv[i]=mod-mod/i*inv[mod%i]%mod;\n\tg[0]=1;\n\trep1(i,M) g[i]=g[i-1]*inv[i]%mod;\n}\nll C(int x,int y){\n\treturn f[x]*g[y]%mod*g[x-y]%mod;\n}\nvoid add(ll &x,ll y){\n\tx+=y;\n\tx%=mod;\n}\nint main(){\n\tint N,K;\n\tcin>>N>>K;\n\tif(N==2&&K==2){\n\t\tputs(\"4\");\n\t\treturn 0;\n\t}\n\tprecalc();\n\tif(K==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tdp[1][0]=1;\n\trep1(i,N) rep(j,i+1){\n//\t\tprintf(\"dp[%d][%d]=%lld\\n\",i,j,dp[i][j]);\n\t\tif(i!=N) add(dp[i+1][j],dp[i][j]);\n\t\tif(j!=i){\n\t\t\tint left=N*K-i-j*(K-1)-1;\n\t\t\tadd(dp[i][j+1],dp[i][j]*C(left,K-2));\n\t\t}\n\t}\n\tll ans=dp[N][N];\n\trep1(i,N) ans=ans*i%mod;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fo(i,s,t) for(int i = s; i <= t; ++ i)\n#define fd(i,s,t) for(int i = s; i >= t; -- i)\n#define bf(i,s) for(int i = head[s]; i; i = e[i].next)\n#define mp make_pair\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pb push_back\n#define VI vector<int>\n#define sf scanf\n#define pf printf\n#define fp freopen\n#define SZ(x) ((int)(x).size())\ntypedef long long ll;\ntypedef double db;\ntypedef unsigned long long ull;\nconst int inf = 1<<30;\nconst ll INF = 1ll<<60;\nconst db Inf = 1e20;\nconst db eps = 1e-9;\n\nvoid gmax(int &a,int b){a = (a > b ? a : b);}\nvoid gmin(int &a,int b){a = (a < b ? a : b);}\n\nconst int maxn = 4000050;\nconst int maxm = 2005;\nconst int P = 1e9+7;\n\nint n, k, dp[maxm][maxm], fac[maxn], infr[maxn];\n\nll comb(int n,int m) {return 1ll*fac[n]*infr[m]%P*infr[n-m]%P;}\nint qpow(int a,int b) {int ans = 1; while(b) {if(b&1) ans = (ans*1ll*a)%P; b >>= 1; a = (a*1ll*a)%P;} return ans;}\nvoid upd(int &x,int y) {x += y; if(x > P) x -= P;}\nint main()\n{\n\t#ifdef MPS\n\t\tfp(\"agc02f.in\",\"r\",stdin);\n\t\tfp(\"agc02f.out\",\"w\",stdout);\n\t#endif\n\tsf(\"%d%d\",&n,&k);\n\tfac[0] = 1; fo(i,1,n*k) fac[i] = (fac[i-1]*1ll*i)%P;\n\tinfr[n*k] = qpow(fac[n*k],P-2);\n\tfd(i,n*k-1,0) infr[i] = infr[i+1]*1ll*(i+1)%P;\n\tif(k == 1) return 0*pf(\"1\\n\");\n\tdp[0][0] = 1;\n\tfo(i,0,n) fo(j,0,n)\n\t{\n\t\tif(i < j) upd(dp[i+1][j],dp[i][j]);\n\t\tif(j < n) dp[i][j+1] = (dp[i][j+1] + (1ll * dp[i][j] * comb(j*k-j+i+k-2,k-2)) % P) % P;\n\t}\n\tpf(\"%lld\\n\",(1ll*dp[n][n]*fac[n])%P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define N 4000005\nusing namespace std;\nconst int mod=1e9+7;\nint n,k,f[2005][2005],jc[N],invjc[N];\nint power(int x,int y)\n{\n\tint ans=1;\n\tfor (;y;y>>=1,x=1LL*x*x%mod)\n\t{\n\t\tif (y&1) ans=1LL*ans*x%mod;\n\t}\n\treturn ans;\n}\nvoid init()\n{\n\tjc[0]=1;\n\tfor (int i=1;i<N;i++) jc[i]=1LL*jc[i-1]*i%mod;\n\tinvjc[N-1]=power(jc[N-1],mod-2);\n\tfor (int i=N-2;i>=0;i--) invjc[i]=1LL*invjc[i+1]*(i+1)%mod;\n}\nint C(int n,int m)\n{\n//\tcout<<\"!!!\"<<n<<\"!!!\"<<m<<\" \"<<jc[n]<<\" \"<<invjc[m]<<\" \"<<invjc[n-m]<<endl;\n\treturn 1LL*jc[n]*invjc[m]%mod*invjc[n-m]%mod;\n}\nsigned main()\n{\n\tinit();\n\tscanf(\"%lld%lld\",&n,&k);\n\tif (k==1)\n\t{\n\t\tprintf(\"%lld\\n\",1);\n\t\treturn 0;\n\t}\n\tf[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=0;j<=i;j++)\n\t\t{\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif (!j) continue;\n\t\t\t(f[i][j]+=1LL*f[i][j-1]*(n-j+1)%mod*C(n*k-i+(n-j+1)*(k-1)-1,k-2)%mod)%=mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<iomanip>\n#include<cstring>\n#include<algorithm>\n#include<ctime>\n#include<queue>\n#define ll long long\nusing namespace std;\nconst int mod=1e9+7;\ninline int read()\n{\n    int kkk=0,x=1;\n    char c=getchar();\n    while((c<'0' || c>'9') && c!='-')\n        c=getchar();\n    if(c=='-')\n        c=getchar(),x=-1;\n    while(c>='0' && c<='9')\n        kkk=(kkk<<3)+(kkk<<1)+(c-'0'),c=getchar();\n    return kkk*x;\n}\nll n,K,dp[2001][2001],sum[4000001];\ninline ll ksm(int a,int b)\n{\n\ta%=mod;\n\tll c=1;\n\twhile(b)\n\t{\n\t\tif(b%2)\n\t\t\tc=1ll*c*a%mod;\n\t\ta=1ll*a*a%mod;\n\t\tb/=2;\n\t}\n\t//cout<<c<<endl;\n\treturn c;\n}\ninline ll C(int N,int M)\n{\n\tif(N==0)\n\t\treturn 1;\n\treturn 1ll*sum[M]*ksm(sum[N],mod-2)%mod*ksm(sum[M-N],mod-2)%mod;\n}\ninline void format()\n{\n\tsum[0]=1;\n\tfor(register int i=1;i<=4000000;++i)\n\t\tsum[i]=1ll*sum[i-1]*i%mod;\n}\nint main()\n{\n\tformat();\n\tn=read(),K=read();\n\tif(K==1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor(register int i=0;i<=n;++i)\n\t\tdp[i][0]=1;\n\tfor(register int i=1;i<=n;++i)\n\t\tfor(register int j=1;j<=i;++j)\n\t\t\tdp[i][j]=(dp[i-1][j]+1ll*dp[i][j-1]*(n-j+1)%mod*C(K-2,n*K-i-(j-1)*(K-1)-1)%mod)%mod;\n\tprintf(\"%lld\\n\",dp[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define RG register\n#define R RG int\nusing namespace std;\nconst LL N=2009,M=N*N,YL=1e9+7;\nint f[N][N],fac[M],inv[M];\ninline int fm(RG LL b){\n\tRG LL a=1;\n\tfor(R k=YL-2;k;k>>=1,b=b*b%YL)\n\t\tif(k&1)a=a*b%YL;\n\treturn a;\n}\ninline int C(R n,R m){\n\tif(n<0||m<0||n<m)return 0;\n\treturn(LL)fac[n]*inv[m]%YL*inv[n-m]%YL;\n}\nint main(){\n\tR n,k,nk;\n\tscanf(\"%d%d\",&n,&k);nk=n*k;\n\tif(k==1)return puts(\"1\"),0;\n\tfor(R i=fac[0]=1;i<=nk;++i)\n\t\tfac[i]=fac[i-1]*(LL)i%YL;\n\tinv[nk]=fm(fac[nk]);\n\tfor(R i=nk;i;--i)\n\t\tinv[i-1]=inv[i]*(LL)i%YL;\n\tf[0][0]=1;\n\tfor(R i=1;i<=n;++i)\n\t\tfor(R j=f[i][0]=1;j<=i;++j)\n\t\t\tf[i][j]=(f[i-1][j]+(LL)f[i][j-1]*(n-j+1)%YL*C(n-i+(n-j+1)*(k-1)-1,k-2))%YL;\n\tprintf(\"%d\\n\",f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, x, y) for (int i = x; i <= y; i++)\nusing namespace std;\n\nconst int N = 2e3 + 10, mod = 1e9 + 7;\ntypedef long long ll;\nll n, K;\nll fac[N * N], f[N][N], inv[N * N];\n\nll quick_pow(ll a, ll b) {\n    ll ret = 1;\n    for (; b; b >>= 1) {\n        if (b & 1) ret = ret * a % mod;\n        a = a * a % mod;\n    } return ret;\n}\n\nvoid pre() {\n    fac[0] = inv[0] = 1;\n    rep(i, 1, n * K) fac[i] = fac[i - 1] * i % mod;\n    inv[n * K] = quick_pow(fac[n * K], mod - 2);\n    for (int i = n * K - 1; i >= 1; i--) inv[i] = inv[i + 1] * (i + 1) % mod;\n}\n\nll C(ll n, ll m) { return fac[n] * inv[m] % mod * inv[n - m] % mod; }\n\nll upd(ll x, ll y) { return (x + y) % mod; }\n\nint main() {\n    cin >> n >> K;\n    if (K == 1) { puts(\"1\"); return 0; }\n    pre();\n    rep(i, 1, n) f[i][0] = 1;\n    rep(i, 1, n)\n        rep(j, 1, i) {\n            f[i][j] = upd(f[i - 1][j], (n - j + 1) * f[i][j - 1] % mod * C((n - j + 1) * (K - 1) + n - i - 1, K - 2) % mod);\n        }\n    printf(\"%lld\\n\", f[n][n]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(_v % MD + MD); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(ull(v) * r.v % MD); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\nusing Mint = ModInt<TEN(9) + 7>;\n// template<> const Mint Mint::G = Mint(3);\n\nconst int B = 4242424;\nint n, k;\nMint dp[2333][2333];\nbool used[2333][2333];\nMint fac[B], ifac[B];\n\nvoid first() {\n    fac[0] = 1;\n    for (int i = 1; i < B; i++) fac[i] = Mint(i) * fac[i - 1];\n    ifac[B - 1] = fac[B - 1].inv();\n    for (int i = B - 2; i >= 0; i--) ifac[i] = Mint(i + 1) * ifac[i + 1];\n}\n\nMint C(int n, int k) {\n    if (n < 0 || k < 0 || n < k) return Mint(0);\n    return fac[n] * ifac[k] * ifac[n - k];\n}\n\nMint calc(int a, int b) {\n    if (a > n || b > n || a < b) return Mint(0);\n    if (used[a][b]) return dp[a][b];\n    used[a][b] = true;\n    return dp[a][b] = \n        calc(a + 1, b) + calc(a, b + 1) * C(n * k - a - b * (k - 1) - 1, k - 2);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20) << fixed;\n\n    cin >> n >> k;\n    if (k == 1) {\n        cout << 1 << endl;\n        return 0;\n    }\n    first();\n    used[n][n] = true;\n    dp[n][n] = 1;\n    cout << calc(0, 0) * fac[n] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxN = 2005, mod = 1e9 + 7;\n\nint n, k;\nint f[maxN + 1][maxN + 1];\nint fac[maxN * maxN + 1], inv[maxN * maxN + 1];\n\ninline int ADD(int x, int y) { return x + y >= mod ? x + y - mod : x + y; }\n\ninline int mpow(int a, int x)\n{\n\tint ans = 1;\n\twhile(x)\n\t{\n\t\tif(x & 1) ans = 1ll * ans * a % mod;\n\t\ta = 1ll * a * a % mod;\n\t\tx >>= 1;\n\t}\n\treturn ans;\n}\n\ninline int C(int n, int m)\n{\n\tif(n < m) return 0;\n\treturn 1ll * fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &k);\n\tif(k == 1) { puts(\"1\"); return 0; }\n\t\n\tfac[0] = 1;\n\tfor(int i = 1; i <= n * k; i++) fac[i] = 1ll * fac[i - 1] * i % mod;\n\tinv[n * k] = mpow(fac[n * k], mod - 2);\n\tfor(int i = n * k - 1; i >= 0; i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod;\n\n\tf[0][0] = 1;\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 0; j <= i; j++)\n\t\t{\n\t\t\tif(j) f[i][j] = f[i][j - 1];\n\t\t\tf[i][j] = ADD(f[i][j], 1ll * f[i - 1][j] * C(i * (k - 1) + j - 1, k - 2) % mod);\n\t\t}\n\n\tint ans = 1ll * f[n][n] * fac[n] % mod;\n\tprintf(\"%d\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 2000 + 5;\nconst int N2 = 2000 * 2000 + 10;\nconst int MOD = 1e9 + 7;\nint n, k;\nll dp[MAXN][MAXN], fac[N2], inv[N2];\n\nll c(int m, int k){\n\tif( m < k) return 0;\n\treturn fac[m]*inv[k]%MOD*inv[m - k]%MOD;\n}\nint main(){\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin >> n >> k;\n\tif( k == 1)\n\t\treturn cout << 1 << endl, 0;\n\tfac[0] = 1, inv[0] = 1,inv[1] = 1, fac[1] = 1;\n\tfor(int i = 2; i < N2; i++){\n\t\tfac[i] = fac[i - 1]*i%MOD;\n\t\tinv[i] = (MOD - MOD/i) * inv[MOD % i] % MOD;\n\t}\n\tfor(int i = 1; i < N2; i ++)\n\t\tinv[i] = inv[i] * inv[i - 1] % MOD;\n\tdp[0][0] = 1;\n\tfor(int i = 1; i <= n; i ++){\n\t\tfor(int j = i; j>= 0 ;j --){\n\t\t\tdp[i][j] = dp[i][j + 1] % MOD;\n\t\t\tif( j ) dp[i][j] = (dp[i][j] + (dp[i - 1][j - 1] * c(i*k - j - 1, k - 2)) % MOD) % MOD;\n\t\t\tdp[i][j] %= MOD;\n\t\t}\n\t}\n\tcout << dp[n][0] * fac[n] % MOD << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\n\ntypedef long long ll;\nconst ll maxn=2e3+10,maxnn=maxn*maxn,mod=1e9+7;\nll n,k,fac[maxnn],inv[maxnn];\nll f[maxn][maxn],ans;\n\nll qpow(ll a,ll n){\n\tll res=1;\n\twhile(n){\n\t\tif(n&1ll)\n\t\t\tres=res*a%mod;\n\t\ta=a*a%mod;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n\nint main(){\n\tfac[0]=1;\n\tfor(int i=1;i<maxnn;++i)\n\t\tfac[i]=fac[i-1]*i%mod;\n\tinv[maxnn-1]=qpow(fac[maxnn-1],mod-2);\n\tfor(int i=maxnn-1;i;--i)\n\t\tinv[i-1]=inv[i]*i%mod;\n\tscanf(\"%lld%lld\",&n,&k);\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tf[1][1]=1;\n\tfor(int i=2;i<=n;++i){\n\t\tll sum=0;\n\t\tfor(int j=i;j;--j){\n\t\t\t(sum+=f[i-1][j-1])%=mod;\n\t\t\tf[i][j]=sum*fac[i*k-j-1]%mod*inv[k-2]%mod*inv[(i-1)*k-j+1]%mod;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tans+=f[n][i];\n\tans=ans%mod*fac[n]%mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int _=2005;\nconst int mod=1e9+7;\ninline int read()\n{\n\tchar ch='!';int z=1,num=0;\n\twhile(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n\tif(ch=='-')z=-1,ch=getchar();\n\twhile(ch<='9'&&ch>='0')num=(num<<3)+(num<<1)+ch-'0',ch=getchar();\n\treturn z*num;\n}\nint n,k,f[_][_];\nvoid add(int &a,int b){a+=b;if(a>=mod)a-=mod;}\nconst int N=2000*2000;\nint jc[N+5],inv[N+5];\nint ksm(int a,int b){int r=1;for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)r=1ll*r*a%mod;return r;}\nvoid Pre(){inv[0]=jc[0]=1;for(int i=1;i<=N;++i)jc[i]=1ll*jc[i-1]*i%mod,inv[i]=ksm(jc[i],mod-2);}\nint C(int A,int B)\n{\n\tif(A<B)return 0;\n\treturn 1ll*jc[A]*inv[B]%mod*inv[A-B]%mod;\n}\nint main()\n{\n\tPre();\n\tn=read(),k=read();\n\tif(k==1)return puts(\"1\"),0;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<=i;++j)\n\t\t{\n\t\t\tadd(f[i][j],f[i-1][j]);\n\t\t\tif(j)add(f[i][j],1ll*f[i][j-1]*C(n-i+(n-j+1)*(k-1)-1,k-2)%mod*(n-j+1)%mod);\n\t\t}\n\tprintf(\"%d\\n\",f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define int long long\n#define Mod 1000000007ll\n#define pow ksm\ninline int ksm(int a,int x){\n\tLL ans=1,w=a;\n\twhile(x){\n\t\tif(x&1)ans=ans*w%Mod;\n\t\tx>>=1;\n\t\tw=w*w%Mod;\n\t}\n\treturn ans;\n}\n#define MN 4000005\n#define mn 2005\nint fac[MN],dfac[MN],n,k,f[mn][mn];\ninline int C(int n,int m){\n\treturn 1ll*fac[m]*dfac[n]%Mod*dfac[m-n]%Mod;\n}\nvoid init(int N){\n\tfac[0]=1;\n\tfor(int i=1;i<=N;++i)\n\t\tfac[i]=fac[i-1]*i%Mod;\n\tdfac[N]=ksm(fac[N],Mod-2);\n\tfor(int i=N-1;i>=0;--i){\n\t\tdfac[i]=(LL)dfac[i+1]*(LL)(i+1)%Mod;\n\t}\n}\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&k);\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tinit(n*k);\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<=i;++j){\n\t\t\tf[i][j]=(f[i][j]+f[i-1][j])%Mod;\n\t\t\tif(j)f[i][j]=(f[i][j]+(f[i][j-1]*(n-j+1)%Mod*C(k-2,n-i+(k-1ll)*(n-j+1ll)-1ll)+Mod))%Mod;\t\n\t\t\t//tm这式子谁顶得住啊\n\t\t\t//n-j+1: 有这么多种颜色可以这次放\n\t\t\t//k-2:放k-2个，为了不重，钦定第一个放剩下的第一个没填的格子\n\t\t\t//n-i+(k-1)*(n-j+1)-1：还剩下的格子数，-1的理由同上\n\t\t}\n\tprintf(\"%lld\",f[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\nusing namespace std;\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\nconst int N=2010;\nint f[N][N],fac[N*N],inv[N*N];\nconst int mod=1e9+7;\ninline int C(int n,int m) {\n\treturn 1LL*fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\ninline int qpow(int x,int y) {\n\tint ans=1;\n\twhile (y) {\n\t\tif (y&1) ans=1LL*ans*x%mod;\n\t\tx=1LL*x*x%mod;y>>=1;\n\t}\n\treturn ans;\n}\nint main() {\n\tint n=gi(),m=gi(),i,j;\n\tif (m==1) { puts(\"1\"); return 0; }\n\tfor (i=fac[0]=1;i<=m*n;i++) fac[i]=1LL*fac[i-1]*i%mod;\n\tinv[n*m]=qpow(fac[n*m],mod-2);\n\tfor (i=n*m;i;i--) inv[i-1]=1LL*inv[i]*i%mod;m--;\n\tf[0][0]=1;\n\tfor (i=1;i<=n;i++)\n\t\tfor (j=0;j<=i;j++)\n\t\t\tf[i][j]=((j?f[i][j-1]:0)+(i==j?0:1LL*f[i-1][j]*C(j+i*m-1,m-1)))%mod;\n\tprintf(\"%d\\n\",int(1LL*f[n][n]*fac[n]%mod));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define il inline\n#define ri register int\n#define pb push_back\n#define mp make_pair\n#define fir first\n#define sec second\n#define mid ((l+r)>>1)\n#define MAXN 2050\n#define MAXM MAXN * MAXN\n#define mod 1000000007\n#define inf (1<<30)\n#define eps (1e-6)\n#define alpha 0.75\n#define rep(i, x, y) for(ri i = x; i <= y; ++i)\n#define repd(i, x, y) for(ri i = x; i >= y; --i)\n#define file(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, int> pli;\ntypedef pair <int, ll> pil;\ntypedef pair <ll, ll> pll;\ntemplate <typename T> il bool chkmin(T &x, T y) {return x > y ? x = y, 1 : 0;}\ntemplate <typename T> il bool chkmax(T &x, T y) {return x < y ? x = y, 1 : 0;}\ntemplate <typename T> il void read(T &x) {\n\tchar ch = getchar(); int f = 1; x = 0;\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = x*10+ch-'0', ch = getchar();\n\tx *= f;\n}\ntemplate <typename T, typename... Args> il void read(T &x, Args &...args) {\n\tread(x), read(args...);\n}\nint n, k;\nll fac[MAXM], invf[MAXM], dp[MAXN][MAXN];\nll fpow(ll x, ll y) {\n\tll ret = 1;\n\twhile(y) {\n\t\tif(y & 1) ret = ret * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn ret;\n}\nll C(int n, int m) {\n\tif(n == m) return 1;\n\treturn fac[n] * invf[m] % mod * invf[n-m] % mod;\n}\nint main() {\n\tread(n, k);\n\tfac[0] = 1;\n\trep(i, 1, n*k) fac[i] = fac[i-1] * i % mod;\n\tinvf[n*k] = fpow(fac[n*k], mod-2);\n\trepd(i, n*k, 1) invf[i-1] = invf[i] * i % mod;\n\tdp[0][0] = 1;\n\trep(j, 1, n) dp[0][j] = dp[0][j-1] * C(j*(k-1)-1, k-2) % mod;\n\trep(i, 1, n) \n\t\trep(j, i, n)\n\t\t\tdp[i][j] = (dp[i-1][j] + dp[i][j-1] * C(j*(k-1)+i-1, k-2)) % mod;\n\tcout << dp[n][n] * (k > 1 ? fac[n] : 1) % mod << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=2e3+2;\nconst int maxx=maxn*maxn;\nconst int q=1e9+7;\ninline int Plus(int x,int y) {return (x+=y)>=q?x-q:x;}\ninline void Pe(int &x,int y) {x=Plus(x,y);}\ninline int Multi(int x,int y) {return 1ll*x*y%q;}\ninline void Me(int &x,int y) {x=Multi(x,y);}\nnamespace num {\n\tint fac[maxx],ifac[maxx],inv[maxx];\n\tinline int C(int n,int m) {return n<m?0:Multi(Multi(fac[n],ifac[m]),ifac[n-m]);}\n\tvoid init() {\n\t\tfac[0]=fac[1]=ifac[0]=ifac[1]=inv[0]=inv[1]=1;\n\t\tfor (int i=2;i<maxx;++i) {\n\t\t\tinv[i]=Multi(q-q/i,inv[q%i]);\n\t\t\tfac[i]=Multi(fac[i-1],i);\n\t\t\tifac[i]=Multi(ifac[i-1],inv[i]);\n\t\t}\n\t}\n}\nint n,k,f[maxn];\nint main() {\n\tfreopen(\"test.in\",\"r\",stdin);\n\tnum::init();\n\tcin>>n>>k;\n\tif (k==1) puts(\"1\"),exit(0);\n\tf[0]=1;\n\tfor (int i=1;i<=n;++i,f[0]=f[1]) {\n\t\tfor (int j=i;j;--j) {\n\t\t\tint tmp=num::C((i-1)*k-(j-1)+k-2,k-2);\n\t\t\tf[j]=Plus(Multi(Multi(n-i+1,f[j-1]),tmp),f[j+1]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=2005,mx=4000000,mod=1e9+7;\ninline void add(int &x,int y){\n\tx+=y;if(x>=mod) x-=mod;\n}\ninline int pls(int x,int y){\n\tadd(x,y);return x;\n}\ninline int mul(int a,int b){return 1ll*a*b%mod;}\ninline int qpow(int a,int b){\n\tint res=1;\n\tfor(;b;b>>=1,a=mul(a,a)) if(b&1) res=mul(res,a);\n\treturn res;\n}\nint n,k;\nint fac[N*N],inv[N*N];\nint f[N][N];\ninline int C(int n,int m){\n\tif(n<0||m<0||n<m) return 0;\n\treturn mul(mul(fac[n],inv[m]),inv[n-m]);\n}\nint main(){\n\tfac[0]=1;\n\tfor(int i=1;i<=mx;i++) fac[i]=mul(fac[i-1],i);\n\tinv[mx]=qpow(fac[mx],mod-2);\n\tfor(int i=mx-1;i>=0;i--) inv[i]=mul(inv[i+1],i+1);\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1){puts(\"1\");return 0;}\n\tfor(int i=1;i<=n;i++) f[i][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tf[i][j]=pls(f[i-1][j],mul(f[i][j-1],mul(n-j+1,C(n*k-i-(j-1)*(k-1)-1,k-2))));\n\tprintf(\"%lld\",f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst ll p = 1e9+7;\nconst int M = 2005;\n\nll fact[M*M], invfact[M*M], inv[M*M], dp[M][M], part[M][M], n, k;\n\nll comb(int x, int y) {\n\tif (x < 0 || y < 0 || x < y)\n\t\treturn 0;\n\treturn fact[x]*invfact[y]%p*invfact[x-y]%p;\n}\n\nint main() {\n\tcin >> n >> k;\n\tif (k == 1) {\n\t\tcout << \"1\\n\"; return 0;\n\t}\n\tinv[1] = fact[0] = fact[1] = invfact[0] = invfact[1] = 1;\n\tfor (int i = 2; i < M*M; ++i) {\n\t\tinv[i] = (p - (p/i) * inv[p%i] % p) % p;\n\t\tfact[i] = i*fact[i-1]%p;\n\t\tinvfact[i] = inv[i]*invfact[i-1]%p;\n\t}\n\n\tfor (int i = 1; i <= n; ++i) {\n\t\t// casework on longest prefix of 0s\n\t\tif (i == 1)\n\t\t\tdp[i][1] = 1;\n\t\telse\n\t\t\tfor (int j = 1; j <= i; ++j)\n\t\t\t\tdp[i][j] = comb(i*k-j-1, k-2)*i%p*part[i-1][j-1]%p;\n\t\t\n\t\tfor (int j = i; j >= 0; --j)\n\t\t\tpart[i][j] = (part[i][j+1]+dp[i][j])%p;\n\t}\n\n\tcout << part[n][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <math.h>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <string.h>\n#include <bitset>\n#define REP(i,a,n) for(int i=a;i<=n;++i)\n#define PER(i,a,n) for(int i=n;i>=a;--i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(a) ({REP(__i,1,n) cout<<a[__i]<<' ';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\n\nconst int N = 2010, M = 4e6+10;\nint n, k, dp[N][N];\nint fac[M], ifac[M];\nint C(int n, int m) {\n\tif (n<m) return 0;\n\treturn (ll)fac[n]*ifac[m]%P*ifac[n-m]%P;\n}\nint main() {\n\tfac[0]=1;\n\tREP(i,1,M-1) fac[i]=(ll)fac[i-1]*i%P;\n\tifac[M-1]=inv(fac[M-1]);\n\tPER(i,0,M-2) ifac[i]=(ll)ifac[i+1]*(i+1)%P;\n\tscanf(\"%d%d\", &n, &k);\n\tif (k==1) return puts(\"1\"),0;\n\tdp[0][0] = 1;\n\tREP(i,0,n) REP(j,0,i) {\n\t\tdp[i+1][j] = (dp[i+1][j]+dp[i][j])%P;\n\t\tdp[i][j+1] = (dp[i][j+1]+(ll)C(n*k-j*(k-1)-i-1,k-2)*dp[i][j])%P;\n\t}\n\tint ans = (ll)dp[n][n]*fac[n]%P;\n\tprintf(\"%d\\n\", ans);\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define inf 20021225\n#define ll long long\n#define mdn 1000000007\nusing namespace std;\n\nint f[2100][2100];\nint inv[2100*2100],fac[2100*2100];\nint n,k;\n\nint ksm(int bs,int mi)\n{\n\tint ans=1;\n\twhile(mi)\n\t{\n\t\tif(mi&1)\tans=(ll)ans*bs%mdn;\n\t\tbs=(ll)bs*bs%mdn; mi>>=1;\n\t}\n\treturn ans;\n}\n\nint C(int x,int y)\n{\n\tif(x<y)\treturn 0;\n\treturn (ll)fac[x] * inv[y] %mdn * inv[x-y] %mdn;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1||n==1){printf(\"1\\n\");return 0;}\n\tinv[0]=fac[0]=1; int tot=n*k;\n\tfor(int i=1;i<=tot;i++)\tfac[i]=(ll)fac[i-1]*i%mdn;\n\tinv[tot] = ksm(fac[tot],mdn-2);\n\tfor(int i=tot-1;i;i--)\tinv[i]=(ll)inv[i+1]*(i+1)%mdn;\n\tf[0][0]=1;// printf(\"%d\\n\",inv[tot]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tf[i][j] += f[i-1][j];\n\t\t\tif(j) f[i][j] += (ll)f[i][j-1] * C(tot-i-(k-1)*(j-1)-1,k-2) %mdn;\n\t\t\tf[i][j]%=mdn;\n\t\t\t//printf(\"%d %d %d\\n\",i,j,f[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(ll)f[n][n]*fac[n]%mdn);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\ntypedef const int& cint;\ntypedef long long ll;\n\nconst ll mod = 1e9 + 7;\nconst int MAXN = 2010, MAXM = 4000010;\n\nint f[MAXN][MAXN], fsum[MAXN][MAXN];\nint fac[MAXM], finv[MAXM];\n\ninline ll fpow(ll a, ll b){\n\tll res = 1;\n\twhile (b){\n\t\tif (b & 1)\n\t\t\tres = res * a % mod;\n\t\ta = a * a % mod, b >>= 1;\n\t}\n\treturn res;\n}\n\ninline ll C(cint n, cint m){\n\treturn 1ll * fac[n] * finv[n - m] % mod * finv[m] % mod;\n}\n\ninline ll g(cint n, cint m){\n\treturn C(m + n - 1, m - 1);\n}\n\nvoid init(cint n){\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\tfinv[n] = fpow(fac[n], mod - 2);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tfinv[i] = 1ll * finv[i + 1] * (i + 1) % mod;\n}\n\nint main(){\n\tint N, K;\n\tscanf(\"%d %d\", &N, &K);\n\tif (K == 1){\n\t\tprintf(\"1\");\n\t\treturn 0;\n\t} \n\tinit(4000000);\n\tf[0][0] = fsum[0][0] = 1;\n\tfor (int i = 1; i <= N; ++i){\n\t\tfor (int j = 1; j <= i; ++j)\n\t\t\tf[i][j] = 1ll * fsum[i - 1][j - 1] * g(K - 2, K * (i - 1) - (j - 1) + 1) % mod;\n\t\tfor (int j = i; j >= 0; --j)\n\t\t\tfsum[i][j] = (fsum[i][j + 1] + f[i][j]) % mod;\n\t}\n\tprintf(\"%lld\", 1ll * fsum[N][1] * fac[N] % mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\npair<long long, long long> extended_gcd(long long a, long long b) {\n\tif (b == 0) return { 1, 0 };\n\tauto t = extended_gcd(b, a % b);\n\treturn { t.second, t.first - t.second * (a / b) };\n}\n\ninline long long modinv(long long a, long long m) {\n\treturn (extended_gcd(a, m).first % m + m) % m;\n}\n\nconst int MOD = 1000000007;\nint fact[4000001], factinv[4000001];\n\ninline int comb(int n, int m) {\n\tif (m < 0 || m > n) return 0;\n\treturn ((long long)fact[n] * factinv[m] % MOD) * factinv[n - m] % MOD;\n}\n\nint n, k;\nint d[2001][2001];\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\tfact[0] = 1;\n\tfor (int i = 1; i <= n * k; ++i) {\n\t\tfact[i] = (long long)fact[i - 1] * i % MOD;\n\t}\n\tfactinv[0] = 1;\n\tfactinv[n * k] = modinv(fact[n * k], MOD);\n\tfor (int i = n * k; i > 1; --i) {\n\t\tfactinv[i - 1] = (long long)factinv[i] * i % MOD;\n\t}\n\tif (k == 1) {\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (int i = 0; i <= n; ++i) {\n\t\tfor (int j = i; j <= n; ++j) {\n\t\t\tif (i == 0 && j == 0) {\n\t\t\t\td[i][j] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\td[i][j] = ((i > 0 ? d[i - 1][j] : 0) + (long long)d[i][j - 1] * comb(i + j * (k - 1) - 1, k - 2)) % MOD;\n\t\t}\n\t}\n\tint ans = d[n][n];\n\tfor (int i = 2; i <= n; ++i) {\n\t\tans = (long long)ans * i % MOD;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F first\n#define S second\n#define pii pair<int,int>\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\nconst int M = 4 * 1e6 + 10 , N = 2017 , mod = 1e9 + 7;\nll fact[M] , inv[M] , dp[N][N];\nint n , k;\n\nint power(int a , int b){\n    if(b == 0)return 1;\n    ll ret = power(a , b/2);\n    ret *= ret; ret %= mod;\n    if(b % 2)ret *= a; ret %= mod;\n    return ret;\n}\n\n\nint comb(int n , int k){\n    if(k > n)return 0;\n    ll ret = fact[n];\n    ret *= inv[k]; ret %= mod;\n    ret *= inv[n - k]; ret %= mod;\n    return ret;\n}\n\nvoid Piri(){\n    fact[0] = 1;\n    for(int i=1;i<M;i++)fact[i] = (fact[i - 1] * i) % mod;\n    inv[M - 1] = power(fact[M - 1] , mod - 2);\n    for(int i=M-2;i>=0;i--)inv[i] = (inv[i + 1] * (i + 1)) % mod;\n}\n\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> k;\n    if(k == 1)return cout << 1 << '\\n' , 0;\n    Piri();\n    dp[0][0] = 1;\n    for(int i=1;i<=n;i++){\n        for(int j=0;j<=i;j++){\n            if(j < i){\n                ll len = j * k + (i - j) * (k - 1);\n                ll c = comb(len - 1 , k - 2); c *= i; c %= mod;\n                c *= dp[i - 1][j]; c %= mod;\n                dp[i][j] += c; dp[i][j] %= mod;\n            }\n            if(j > 0){\n                dp[i][j] += dp[i][j - 1];\n                dp[i][j] %= mod;\n            }\n        }\n    }\n    cout << dp[n][n] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nconst long long MOD = 1000000007;\nint N, K;\nlong long O, fc[4000001], fi[4000001], f[2001], g[2001];\ninline long long C(int x, int y)\n{\n\treturn fc[x] * fi[y] % MOD * fi[x - y] % MOD;\n}\nint main()\n{\n\tscanf(\"%d%d\", &N, &K);\n\tif (K == 1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfc[0] = fi[0] = fi[1] = 1;\n\tfor (int i = 2; i <= N * K; i++)\n\t\tfi[i] = (MOD - MOD / i) * fi[MOD % i] % MOD;\n\tfor (int i = 1; i <= N * K; i++)\n\t{\n\t\tfc[i] = fc[i - 1] * i % MOD;\n\t\tfi[i] = fi[i - 1] * fi[i] % MOD;\n\t}\n\tf[0] = 1;\n\tfor (int i = 1; i <= N + N; i++)\n\t{\n\t\tfor (int j = 0; j < (i + 1) >> 1; j++)\n\t\t\tg[j] = 0;\n\t\tfor (int j = (i + 1) >> 1; j <= N; j++)\n\t\t\tg[j] = (f[j - 1] * C(i + j * (K - 2) - 1, K - 2) + f[j]) % MOD;\n\t\tstd::copy(g, g + N + 1, f);\n\t}\n\tprintf(\"%lld\\n\", f[N] * fc[N] % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*vi:se ts=8 tw=8*/\n/*@author tangyida*/\n#include<bits/stdc++.h>\nconst int N = 2e3 + 5;\nconst long long MOD = 1e9 + 7;\nint n,k;\nlong long f[N][N],fac[N * N],inv[N * N];\n\ninline long long _pow(long long a,long long base)\n{\n\tlong long ans = 1;\n\tfor(;base;base >>= 1) {\n\t\tif(base  & 1) ans = (ans * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t}\n\treturn ans;\n}\n\ninline void pre()\n{\n\tfac[0] = 1;\n\tfor(int i = 1;i <= n * k;i++) fac[i] = (fac[i - 1] * i) % MOD;\n\tinv[n * k] = _pow(fac[n * k],MOD - 2) % MOD;\n\tfor(int i = n * k - 1;i >= 0;i--) inv[i] = (inv[i + 1] * (i + 1)) % MOD;\n}\n\ninline long long C(long long n,long long m)\n{ \n\tif(n == m) return 1;\n\treturn ((fac[n] * inv[m]) % MOD * inv[n - m]) % MOD;\n}\n\nint main()\n{\n\tstd::cin >> n >> k;\n\tif(k == 1) std::cout << 1,exit(0);\n\n\tpre();\n\tf[0][0] = 1;\n\tfor(int i = 1;i <= n;i++) for(int j = 0;j <= i;j++) {\n\t\tf[i][j] = f[i - 1][j];\n\t\tif(!j) continue;\n\t\t(f[i][j] = f[i][j] % MOD + (f[i][j - 1] * (n - j + 1)) % MOD * C(n -\n\t\t\ti + (n - j + 1) * (k - 1) - 1,k - 2)) %= MOD;\n\t}\n\tstd::cout << f[n][n] % MOD;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2020\n#define mod 1000000007\n#define ll long long\nusing namespace std;\ninline int read(){\n  int x=0,f=1;char ch=getchar();\n  while(ch>'9'||ch<'0')ch=='-'&&(f=0)||(ch=getchar());\n  while(ch<='9'&&ch>='0')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n  return f?x:-x;\n}\nll frac[N*N];\nll fast_pow(ll x, ll y) {\n  ll z = 1;\n  for (; y; y >>= 1, x = x * x % mod) {\n    if (y & 1) {\n      z = z * x % mod;\n    }\n  }\n  return z;\n}\nll inv(ll x) {\n  return fast_pow(x, mod - 2);\n}\nll C(ll m, ll n) {\n  return frac[m] * inv(frac[n]) % mod * inv(frac[m - n]) % mod;\n}\nint f[N][N];\nint main(int argc, char const *argv[]) {\n\n  frac[0] = 1;\n  for (int i = 1; i <= 4000000; ++ i) {\n    frac[i] = frac[i - 1] * i % mod;\n  }\n\n  int n = read(), k = read();\n\n  if (k == 1) {\n    return puts(\"1\"), 0;\n  }\n\n  f[0][1] = 1;\n  for (int j = 1; j <= n; ++ j) {\n    for (int i = 0; i <= j; ++ i) {\n      if (i < j) f[i + 1][j] = (f[i + 1][j] + f[i][j]) % mod;\n      if (j < n) f[i][j + 1] = (f[i][j + 1] + f[i][j] * C(i + (j + 1) * (k - 1) - 1, k - 2) % mod) % mod;\n    }\n  }\n  printf(\"%lld\\n\", f[n][n] * frac[n] % mod);\n  return 0;\n}\n/*\n问题转化为拓扑计数问题\n\n颜色顺序最后乘一个阶乘即可，现在要计算的是如下图的拓扑方案数。\n\n| (0)->(0)->(0)->(0)->(0)\n|  |    |    |    |    |\n|  v    v    v    v    v\n| (1)->(2)->(3)->(4)->(5)\n|  |    |    |    |    |\n|  v    v    v    v    v\n| (1)  (2)  (3)  (4)  (5)\n|  |    |    |    |    |\n|  v    v    v    v    v\n| (1)  (2)  (3)  (4)  (5)\n|  |    |    |    |    |\n|  v    v    v    v    v\n| (1)  (2)  (3)  (4)  (5)\n\n只需按照前两行从后往前转移即可。\n\nf[i][j] 表示选了 i 个 0, j 种颜色的方案数。\n\n每次转移相当于加入一个 0 或者加入一列。\n\n|               .-- i ---.\n|                (0)->(0)\n|                 |    |\n|                 v    v\n|      (2)->(3)->(4)->(5)\n|       |    |    |    |\n|       v    v    v    v\n|      (2)  (3)  (4)  (5)\n|       |    |    |    |\n|       v    v    v    v\n|      (2)  (3)  (4)  (5)\n|       |    |    |    |\n|       v    v    v    v\n|      (2)  (3)  (4)  (5)\n|     `-------- j -------'\n\nf[i+1][j] += f[i][j]\nf[i][j+1] += f[i][j] * C(i+j*(k-1)+k-2, k-2)\n\nans = f[n][n] * n!\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PP;\n\n/*\n    freopen(\"input\",\"r\",stdin);\n    freopen(\"output\",\"w\",stdout);\n*/\n\nll DP[2001][2001];\n\nll F[4000001];\nll I[4000001];\n\nll MOD = 1E9 + 7;\n\nll power(ll a, ll b) {\n\tll res = 1;\n\twhile (b > 0) {\n\t\tif (b % 2 == 1) {\n\t\t\tres *= a;\n\t\t\tres %= MOD;\n\t\t}\n\t\tb /= 2;\n\t\ta *= a;\n\t\ta %= MOD;\n\t}\n\treturn res;\n}\n\nvoid init() {\n\tF[0] = 1;\n\tfor (ll i = 1;i <= 4000000;i++) {\n\t\tF[i] = F[i - 1] * i;\n\t\tF[i] %= MOD;\n\t}\n\tfor (ll i = 0;i <= 4000000;i++) {\n\t\tI[i] = power(F[i], MOD - 2);\n\t}\n\treturn;\n}\n\nll nchoosek(int a, int b) {\n\tif (b == 0 || a == b) return 1;\n\tll up = F[a];\n\tll down = I[a - b] * I[b];\n\tdown %= MOD;\n\tup *= down;\n\treturn up %= MOD;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    init();\n    memset(DP, 0, sizeof(DP));\n    DP[0][0] = 1;\n    int N, K, T;\n    cin >> N >> K;\n    if (K == 1) {\n    \tcout << 1 << endl;\n    \treturn 0;\n    }\n    T = N * K;\n    for (int i = 0;i <= N;i++) {\n    \t// Opened Slot.\n    \tfor (int j = 0;j <= i;j++) {\n    \t\t// Closed Slot.\n\n    \t\tif (i != N) {\n    \t\t\t// Open a slot.\n    \t\t\tDP[i + 1][j] += DP[i][j];\n    \t\t\tDP[i + 1][j] %= MOD;\n    \t\t}\n\n    \t\tif (i != j) {\n    \t\t\t// Close a slot.\n\n    \t\t\t// Choose One Color.\n    \t\t\tll ans = (N - j);\n\n    \t\t\tll rem = T - j * K - (i - j);\n\n    \t\t\tans *= nchoosek(rem - 1, K - 2);\n    \t\t\tans %= MOD;\n\n    \t\t\tans *= DP[i][j];\n    \t\t\tans %= MOD;\n\n    \t\t\tDP[i][j + 1] += ans;\n    \t\t\tDP[i][j + 1] %= MOD;\n    \t\t}\n\n    \t}\n    }\n    cout << DP[N][N] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* be name khoda */\n\n// #define stream_enable\n// #define long_enable\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <numeric>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#ifdef stream_enable\n#define cin sss\n#endif\n#ifdef long_enable\ntypedef long long int ll;\n#else\ntypedef int ll;\n#endif\n\ntypedef pair<ll, ll> pii;\ntypedef pair<pii, ll> ppi;\ntypedef pair<ll, pii> pip;\ntypedef vector<ll> vi;\ntypedef vector<pii> vpii;\n\nconst ll MOD = 1000000007;\nconst long long BIG = 1446803456761533460;\nconst int Big = 336860180;\n\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n\n#define debug(x) cout << #x << \" -> \" << (x) << endl\n#define debug2(x, y) cout << #x << ' ' << #y << \" -> \" << (x) << ' ' << (y) << endl\n#define debug3(x, y, z) cout << #x << ' ' << #y << ' ' << #z << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << endl\n#define debug4(x, y, z, t) cout << #x << ' ' << #y << ' ' << #z << ' ' << #t << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << ' ' << (t) << endl\n#define debugp(x) cout << #x << \" -> \" << \"(\" << (x).F << \", \" << (x).S << \")\" << endl\n#define debuga(x, n) cout << #x << \" -> \"; fori (i1_da, n) { cout << (x)[i1_da] << ' '; } cout << endl\n#define debugap(x, n) cout << #x << \" ->\\n\"; fori (i1_dap, n) { cout << \"(\" << (x)[i1_dap].F << \", \" << (x)[i1_dap].S << \")\\n\"; } cout << endl\n#define debugaa(x, n, m) cout << #x << \" ->\\n\"; fori (i1_daa, n) { fori (i2_daa, m) { cout << (x)[i1_daa][i2_daa] << ' '; } cout << '\\n'; } cout << endl\n#define debugav(x, n) cout << #x << \" ->\\n\"; fori (i1_dav, n) { fori (i2_dav, (x)[i1_dav].size()) { cout << (x)[i1_dav][i2_dav] << ' '; } cout << '\\n'; } cout << endl\n#define debugia(x, n) cout << #x << \" ->\\n\"; fori (i1_dia, n) { cout << i1_dia << \" : \" << (x)[i1_dia] << '\\n'; } cout << endl\n\n#define forifrom(i, s, n) for(ll i = (s); i < (n); ++i)\n#define forirto(i, n, e) for(ll i = (n) - 1; i >= (e); --i)\n#define fori(i, n) forifrom (i, 0, n)\n#define forir(i, n) forirto (i, n, 0)\n\n#define smin(a, b) a = min(a, (b))\n#define smax(a, b) a = max(a, (b))\n\n#define Add(a, b) a = ((a) + (b)) % MOD\n#define Mul(a, b) a = (1LL * (a) * (b)) % MOD\n\nstringstream sss;\n\n// -----------------------------------------------------------------------\n\nconst ll maxn = 2010;\nconst ll maxn2 = maxn * maxn;\n\nll n, k;\nll fact[maxn2], ifact[maxn2];\nll dp[maxn];\n\nll poww(ll a, ll b) {\n    ll r = 1;\n    while (b) {\n        if (b & 1) Mul(r, a);\n        Mul(a, a);\n        b >>= 1;\n    }\n    return r;\n}\n\nll ent(ll a, ll b) {\n    return 1LL * fact[b] * ifact[a] % MOD * ifact[b - a] % MOD;\n}\n\nvoid MAIN() {\n\n    fact[0] = 1;\n    fori (i, maxn2 - 1) fact[i + 1] = 1LL * fact[i] * (i + 1) % MOD;\n    ifact[maxn2 - 1] = poww(fact[maxn2 - 1], MOD - 2);\n    forir (i, maxn2 - 1) ifact[i] = 1LL * ifact[i + 1] * (i + 1) % MOD;\n\n    cin >> n >> k;\n    if (k == 1) {\n        cout << \"1\\n\";\n        return;\n    }\n\n    dp[0] = 1;\n    fori (i, n * 2) {\n        forirto (j, n + 1, 1) {\n            Add(dp[j], 1LL * dp[j - 1] * (n - j + 1) % MOD * ent(k - 2, j * k - (2 * j - i)) % MOD);\n        }\n        dp[i / 2] = 0;\n    }\n    cout << dp[n] << '\\n';\n\n}\n\n// -----------------------------------------------------------------------\n\nint main() {\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cout << fixed << setprecision(10);\n    sss << R\"(\n2 2\n2 3\n    )\";\n    MAIN();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<cstdlib>\nusing namespace std;\nconst int mod=1e9+7;\nconst int N=2001;\nint dp[N][N],n,k;\nint fac[N*N],inv[N*N];\ninline int C(int n,int m){if(m>n)return 0;return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;}\ninline int fpow(int x,int k){\n\tint ret=1;\n\tfor(;k;k>>=1,x=1ll*x*x%mod) if(k&1) ret=1ll*ret*x%mod;return ret;\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&k);int tot=n*k;fac[0]=1;\n\tif(k==1) return puts(\"1\"),0;\n\tfor(int i=1;i<=tot;++i) fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[tot]=fpow(fac[tot],mod-2);\n\tfor(int i=tot-1;i;--i) inv[i]=1ll*inv[i+1]*(i+1)%mod;inv[0]=1;\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<=i;++j){\n\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\tif(j) (dp[i][j]+=1ll*dp[i][j-1]*C(tot-i-1-(j-1)*(k-1),k-2)%mod*(n-j+1)%mod)%=mod;\n\t\t}\n\tprintf(\"%d\\n\",dp[n][n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "// FUCKED UP FUCKED UP FUCKED UP FUCKED UP FUCKED UP\n#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O2,no-stack-protector,unroll-loops,fast-math\")\n\n#define F first\n#define S second\n#define pb push_back\n#define SZ(x) (ll)(x.size())\n#define all(x) x.begin(),x.end()\n#define MP make_pair\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> pll;\n\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll maxn=2e3+10, maxm=5e4+10, lg=21, mod=1e9+7, inf=1e18;\n\nll n,k,dp[maxn][maxn],fac[maxn*maxn],inv[maxn*maxn];\nll pwm(ll a,ll b){\n\tif(b==0) return 1;\n\tif(b%2) return a*pwm(a,b-1)%mod;\n\tll ret=pwm(a,b/2);\n\treturn ret*ret%mod;\n}\nll C(ll n,ll r){return fac[n]*inv[r]%mod*inv[n-r]%mod;}\nvoid add(ll &x,ll y){x+=y;if(x>=mod)x-=mod;}\n\nint main(){\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\t\n\tcin>>n>>k;\n\tif(k==1) return cout<<1,0;\n\tfac[0]=inv[0]=1; for(int i=1;i<maxn*maxn;i++) fac[i]=fac[i-1]*i%mod, inv[i]=pwm(fac[i],mod-2);\n\tdp[0][0]=1;\n\tfor(int i=0;i<=n;i++)for(int j=0;j<=i;j++){\n\t\tadd(dp[i+1][j],dp[i][j]);\n\t\tif(j<i) add(dp[i][j+1],dp[i][j]*C(n*k-i-j*(k-1)-1,k-2)%mod);\n\t}\n\tcout<<dp[n][n]*fac[n]%mod;\n\t\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\ntypedef long long ll;\nll mod=1e9+7;\nll dp[2001][2001];\nconst int M=2000*2000;\nll f[M],g[M],inv[M];\nvoid precalc(){\n\tf[0]=1;\n\trep1(i,M) f[i]=f[i-1]*i%mod;\n\tinv[1]=1;\n\tfor(int i=2;i<=M;i++) inv[i]=mod-mod/i*inv[mod%i]%mod;\n\tg[0]=1;\n\trep1(i,M) g[i]=g[i-1]*inv[i]%mod;\n}\nll C(int x,int y){\n\treturn f[x]*g[y]%mod*g[x-y]%mod;\n}\nvoid add(ll &x,ll y){\n\tx+=y;\n\tx%=mod;\n}\nint main(){\n\tprecalc();\n\tint N,K;\n\tcin>>N>>K;\n\tif(K==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tdp[1][0]=1;\n\trep1(i,N) rep(j,i+1){\n//\t\tprintf(\"dp[%d][%d]=%lld\\n\",i,j,dp[i][j]);\n\t\tif(i!=N) add(dp[i+1][j],dp[i][j]);\n\t\tif(j!=i){\n\t\t\tint left=N*K-i-j*(K-1)-1;\n\t\t\tadd(dp[i][j+1],dp[i][j]*C(left,K-2));\n\t\t}\n\t}\n\tll ans=dp[N][N];\n\trep1(i,N) ans=ans*i%mod;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nlint dp[2016][2016];\nlint inv[4114514];\nvector<lint> zyo,rz;\nlint mo=1000000007;\nlint extgcd(lint a, lint b, lint &x, lint &y) {\n  lint g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\nlint invMod(lint a, lint m) {\n  lint x, y;\n  if (extgcd(a, m, x, y) == 1) return (x + m) % m;return 0;\n}\nlint co(int a,int b){\n\tif(a<0 || b<0 || b>a) return 0;\n\treturn ((zyo[a]*rz[b])%mo*rz[a-b])%mo;\n}\nint main()\n{\n\tint n,k;\n\tcin>>n>>k;\n\tif(k==1 || n==1){\n\t\tcout<<1<<endl;return 0;\n\t}\n\tinv[1]=1;\n\tREP(i,2,4114510) inv[i]=inv[mo%i]*(mo-mo/i)%mo;\n\tzyo.pb(1);rep(i,4114514) zyo.pb((zyo[i]*(i+1))%mo);\n\trz.pb(1);rep(i,zyo.size()) rz.pb((rz[i]*inv[i+1])%mo);\n\tmemset(dp,0,sizeof(dp));dp[0][0]=1;\n\trep(i,n+1) rep(j,i+1){\n\t\t//cout<<i<<' '<<j<<' '<<dp[i][j]<<endl;\n\t\tdp[i][j]%=mo;\n\t\tif(i<n) dp[i+1][j]+=dp[i][j];\n\t\tif(j<i) dp[i][j+1]+=dp[i][j]*co(n*k-i-j*(k-1)-1,k-2);\n\t}\n\tcout<<(dp[n][n]*zyo[n])%mo<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define LL long long\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef pair<int,int> pa;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch='*'; (ch<'0'||ch>'9')&&ch!='-'; ch=getchar());\n    if(ch=='-') fu=1, ch=getchar();\n    for(v=0; ch>='0'&&ch<='9'; ch=getchar()) v=v*10+ch-'0';\n    if(fu) v=-v;\n}\nconst int MO=1e9+7;\nint n,k;\nLL f[2010][2010],ans,fac[4000010],inv[4000010];\nLL pw(LL x,LL y){\n\tLL t=1;\n\tfor (;y;y>>=1){\n\t\tif (y&1) t=t*x%MO;\n\t\tx=x*x%MO;\n\t}\n\treturn t;\n}\nLL C(int x,int y){\n\treturn fac[x]*inv[y]%MO*inv[x-y]%MO;\n}\nint main(){\n\tcin>>n>>k;\n\tif (k==1) return puts(\"1\"),0;\n\tfac[0]=1;\n\tFOR(i,1,4000000) fac[i]=fac[i-1]*i%MO;\n\tinv[4000000]=pw(fac[4000000],MO-2);\n\tFORD(i,3999999,0) inv[i]=inv[i+1]*(i+1)%MO;\n\tf[0][0]=1;\n\tFOR(i,0,n) //>0\n\t\tFOR(j,0,i) //=0\n\t\t\tif (f[i][j]){\n\t\t\t\tif (j<i) (f[i][j+1]+=f[i][j])%=MO;\n\t\t\t\tif (i<n) (f[i+1][j]+=f[i][j]*(n-i)%MO*C(i*k-i+j+1+k-2-1,k-2))%=MO;\n\t\t\t}\n\tans=(f[n][n]%MO+MO)%MO;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint read(){\n\tint x=0; char c=getchar(); int flag=1;\n\twhile(!isdigit(c)) { if(c=='-') flag=-1; c=getchar(); }\n\twhile(isdigit(c)) { x=((x+(x<<2))<<1)+(c^48); c=getchar(); }\n\treturn x*flag;\n}\n\nconst int mod=1e9+7;\n\nint n,k;\nint dp[2005][2005];//i个白球，j种颜色 \n\nint fac[4000005],Inv[4000005]; \n\nint C(int n,int m){\n\tif(m<0||n<m) return 0;\n    return 1ll*(1ll*fac[n]*Inv[m]%mod)*Inv[n-m]%mod; \n}\n\nvoid exgcd(int a,int b,int &x,int &y){\n    if(b==0) { x=1; y=0; return ; }\n    exgcd(b,a%b,y,x); y-=a/b*x;\n}\n\nint inv(int a){\n    int x=0,y=0;\n    exgcd(a,mod,x,y);\n    return (x%mod+mod)%mod;\n}\n\nsigned main(){\n\tfac[0]=1;\n\tfor(int i=1;i<=4000000;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tInv[4000000]=inv(fac[4000000]);\n\tfor(int i=3999999;i>=0;i--) Inv[i]=1ll*Inv[i+1]*(i+1)%mod;\n\t\n    n=read(),k=read();\n    if(k==1) { puts(\"1\"); return 0; } \n\tdp[0][0]=1;\n    \n    for(int i=1;i<=n;i++){ \n\t    dp[i][0]=1;\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tdp[i][j]=(dp[i-1][j]+1ll*(1ll*dp[i][j-1]*C(n*k-(j-1)*(k-1)-i-1,k-2))%mod*(n-j+1)%mod)%mod; \n\t\t} \n\t}\n\t\n\tprintf(\"%d\\n\",dp[n][n]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define forw(i, a, b) for (int i = a; i <= b; ++i)\n#define iter(i, n) forw(i, 1, n)\n\n#define NR 2010\n\nconst int mod = 1e9 + 7;\n\nint n, m, f[2 * NR][NR], fac[NR * NR], inv[NR * NR];\n\nint pr(int a, int z) {\n\tint s = 1;\n\twhile (z > 0) {\n\t\tif (z % 2 == 1) s = 1ll * s * a % mod;\n\t\ta = 1ll * a * a % mod;\n\t\tz /= 2;\n\t}\n\treturn s;\n}\n\nint binom(int n, int k) { return 1ll * fac[n] * inv[k] % mod * inv[n - k] % mod; }\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tif (m == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\n\tfac[0] = inv[0] = 1;\n\titer(i, n * m) {\n\t\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\t\tinv[i] = pr(fac[i], mod - 2);\n\t}\n\n\tf[0][0] = 1;\n\titer(i, 2 * n) {\n\t\tforw(j, 0, n) if (j <= i - j && i - j <= n) {\n\t\t\tf[i][j] = i != 2 * n ? f[i - 1][j] : 0;\n\t\t\tif (2 * j <= i && j) f[i][j] = (f[i][j] + 1ll * f[i - 1][j - 1] * binom((n - j + 1) * (m - 1) + n - (i - j) - 1, m - 2)) % mod;\n\t\t\t//printf(\"f[%d][%d]=%d\\n\", i, j, f[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", 1ll * f[2 * n][n] * fac[n] % mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#include<vector>\nusing namespace std;\n\n#define LL long long\n#define DB double\n#define MAXM 2000\n#define MAXN 4000000\n#define MOD 1000000007\n#define Pr pair<int,int>\n#define X first\n#define Y second\n#define INF 1000000000000000000\n#define mem(x,v) memset(x,v,sizeof(x))\n\nLL read(){\n\tLL x=0,F=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')F=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}\n\treturn x*F;\n}\n\nint add(int a,int b){return (a+b>=MOD)?a+b-MOD:a+b;}\nint dec(int a,int b){return (a-b<0)?a-b+MOD:a-b;}\nint mul(int a,int b){return (1LL*a*b)%MOD;}\nint fst_pow(int a,int b){\n\tint res=1;\n\twhile(b){\n\t\tif(b&1)res=mul(res,a);\n\t\ta=mul(a,a),b>>=1;\n\t}\n\treturn res;\n}\n\nint n,k;\nint fac[MAXN+5],ifac[MAXN+5];\nint f[MAXM+5][MAXM+5];\n\nvoid prepare(){\n\tfac[0]=1;\n\tfor(int i=1;i<=MAXN;i++)fac[i]=mul(fac[i-1],i);\n\tifac[MAXN]=fst_pow(fac[MAXN],MOD-2);\n\tfor(int i=MAXN;i>=1;i--)ifac[i-1]=mul(ifac[i],i);\n}\nint Comb(int a,int b){\n\treturn mul(fac[a],mul(ifac[b],ifac[a-b]));\n}\n\nint main(){\n\tn=read(),k=read();\n\tif(k==1){puts(\"1\");return 0;}\n\tprepare();\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(j)f[i][j]=add(f[i][j],mul(mul(f[i][j-1],n-j+1),Comb(n*k-i-(k-1)*(j-1)-1,k-2)));\n\t\t}\n\tprintf(\"%d\",f[n][n]);\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN=2005,MOD=1e9+7;\nint n,k,fac[MAXN*MAXN],inv[MAXN*MAXN],dp[MAXN];\n\nll quick_pow(ll a,ll b)\n{\n\tll ret=1;\n\tfor(;b;b>>=1,a=a*a%MOD)\n\t\tif(b&1) ret=ret*a%MOD;\n\treturn ret;\n}\nll C(int a,int b)\n{if(a<b) return 0;return 1ll*fac[a]*inv[a-b]%MOD*inv[b]%MOD;}\nvoid inc(int &a,int b){a+b>MOD?a+=b-MOD:a+=b;}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1) return puts(\"1\"),0;\n\tfac[0]=dp[0]=1;\n\tfor(int i=1;i<=n*k;i++) fac[i]=1ll*fac[i-1]*i%MOD;\n\tinv[n*k]=quick_pow(fac[n*k],MOD-2);\n\tfor(int i=n*k-1;i>=0;i--) inv[i]=1ll*inv[i+1]*(i+1)%MOD;\n\t\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tinc(dp[j],dp[j-1]*C(i+(k-1)*j-1,k-2)%MOD);\n\t\n\tll res=1ll*dp[n]*fac[n]%MOD;\n\tprintf(\"%lld\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=2020,mod=1e9+7;\nint n,k,f[N][N],fac[N*N],iv[N*N];\nint fpow(int x,int y){\n\tint res=1;\n\tfor(;y;y>>=1,x=1ll*x*x%mod)\n\t\tif(y&1)res=1ll*res*x%mod;\n\treturn res;\n}\nint C(int x,int y){\n\treturn 1ll*fac[x]*iv[y]%mod*iv[x-y]%mod;\n}\nint main()\n{\n\tcin>>n>>k; fac[0]=iv[0]=1;\n\tfor(int i=1;i<=n*k;i++)\n\t\tfac[i]=1ll*fac[i-1]*i%mod,iv[i]=fpow(fac[i],mod-2);\n\tif(k==1)return puts(\"1\"),0;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(j)f[i][j]=(f[i][j]+1ll*f[i][j-1]*(n-j+1)%mod*C(n*k-i-1-(j-1)*(k-1),k-2)%mod)%mod;\n\t\t}\n\tcout<<(f[n][n]%mod+mod)%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\nint m = 1000000007;\nlong long inv[4000001];\nlong long fact[4000001];\nlong long invfact[4000001];\nlong long dp[2001][2001];\n\nvoid calc_inv(int n, int mod) {\n    inv[1] = 1;\n    for (int i = 2; i <= n; i++) inv[i] = inv[mod % i] * (mod - mod / i) % mod;\n    \n    fact[0] = invfact[0] = 1;\n    for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i % mod;\n    for (int i = 1; i <= n; i++) invfact[i] = invfact[i - 1] * inv[i] % mod;\n}\n\nlong long comb(int x, int y, int m) {\n    return fact[x] * invfact[y] % m * invfact[x - y] % m;\n}\n\nint main() {\n    int n, k, i, j;\n    \n    scanf(\"%d %d\", &n, &k);\n    \n    if (k == 1) {\n        puts(\"1\");\n        \n        return 0;\n    }\n    \n    calc_inv(n * k, m);\n    \n    dp[0][0] = 1;\n    \n    for (i = 0; i <= n; i++) {\n        for (j = 0; j <= i; j++) {\n            if (i < n) {\n                dp[i + 1][j] += dp[i][j];\n                if (dp[i + 1][j] >= m) dp[i + 1][j] -= m;\n            }\n            \n            if (j < n && j < i) {\n                int c = (n - j - 1) * (k - 1) + n - i;\n                dp[i][j + 1] += dp[i][j] * comb(c + k - 2, k - 2, m) % m;\n                if (dp[i][j + 1] >= m) dp[i][j + 1] -= m;\n            }\n        }\n    }\n    \n    printf(\"%lld\\n\", dp[n][n] * fact[n] % m);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nconst int N = 2e3 + 7, MXA = 4e6 + 7;\nlong long M = 1e9 + 7;\nint fc[MXA];\nint rfc[MXA];\nlong long pw(int a, int b) {\n\tif (b == 0)\n\t\treturn 1;\n\tint t = pw(a, b / 2);\n\tt = (t * t) % M;\n\tif (b % 2)\n\t\tt = (t * a) % M;\n\treturn t;\n}\nint n, k;\nint dp[N][N];\nint32_t main() {\n\tfc[0] = rfc[0] =  1;\n\tfor (int i = 1; i < MXA; i++)\n\t\tfc[i] = (fc[i - 1] * i) % M;\n\tfor (int i = 1; i < MXA; i++) \n\t\trfc[i] = (rfc[i - 1] * pw(i, M - 2)) % M;\n\tdp[0][0] = 1;\n\tcin >> n >> k;\n\tif (k == 1) {\n\t\tcout << 1;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int j = i; j <= n; j++) {\n\t\t\tif (i + j == 0)\n\t\t\t\tcontinue;\n\t\t\tif (i > 0)\n\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\tif (j > i) {\n\t\t\t\tint tmp = i + j * (k - 1) - 1;\n\t\t\t\tdp[i][j] += (((((fc[tmp] * rfc[k - 2]) % M) * rfc[tmp - (k - 2)]) % M) * dp[i][j - 1]) % M;\n\t\t\t\tdp[i][j] %= M;\n//\t\t\t\tcout << i << \" \" << j << \" > \" << dp[i][j] << \" \" << tmp << \" \" << (fc[tmp] * rfc[k - 2] % M) * rfc[tmp - (k - 2)] % M << endl;\n\t\t\t}\n\t\t}\n\tcout << (dp[n][n] * fc[n]) % M;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 2e3 + 10;\nconst int M = 4e6 + 10;\nconst int Mod = 1e9 + 7;\nint n, K, fac[M], inv[M], f[N][N];\n\ninline int mls(int x) {return x < 0 ? x + Mod : x;}\ninline int pls(int x) {return x >= Mod ? x - Mod : x;}\ntemplate <class T> inline void in(T &x) {\n\tx = 0; int f = 1; char ch = getchar();\n\tfor (; ch<'0' || ch>'9';) {if (ch=='-') f=-1; ch = getchar();}\n\tfor (; ch>='0' && ch<='9';) x = x*10 + ch-'0', ch = getchar();\n\tx *= f;\n}\n\ninline int C(int n, int m) {\n\tif (n < m || m < 0) return 0;\n\treturn 1LL * fac[n] * inv[m] % Mod * inv[n - m] % Mod;\n}\n\nint main() {\n\tin(n), in(K);\n\tif (K == 1) {puts(\"1\"); return 0;}\n\tinv[0] = fac[0] = inv[1] = fac[1] = f[0][0] = 1;\n\tfor (int i = 2; i < M; ++i) inv[i] = 1LL * (Mod - Mod/i) * inv[Mod%i] % Mod;\n\tfor (int i = 2; i < M; ++i) inv[i] = 1LL * inv[i - 1] * inv[i] % Mod;\n\tfor (int i = 2; i < M; ++i) fac[i] = 1LL * fac[i - 1] * i % Mod;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = i; ~j; --j) {\n\t\t\tf[i][j] = f[i][j + 1];\n\t\t\tif (j) f[i][j] = pls(f[i][j] + 1LL * f[i-1][j-1] * C(i*K-j-1, K-2) % Mod);\n\t\t}\n\tprintf(\"%lld\\n\", 1LL * f[n][0] * fac[n] % Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\ntypedef long long ll;\nll mod=1e9+7;\nll dp[2001][2001];\nconst int M=2000*2000;\nll f[M],g[M],inv[M];\nvoid precalc(){\n\tf[0]=1;\n\trep1(i,M) f[i]=f[i-1]*i%mod;\n\tinv[1]=1;\n\tfor(int i=2;i<=M;i++) inv[i]=mod-mod/i*inv[mod%i]%mod;\n\tg[0]=1;\n\trep1(i,M) g[i]=g[i-1]*inv[i]%mod;\n}\nll C(int x,int y){\n\treturn f[x]*g[y]%mod*g[x-y]%mod;\n}\nvoid add(ll &x,ll y){\n\tx+=y;\n\tx%=mod;\n}\nint main(){\n\tprecalc();\n\tint N,K;\n\tcin>>N>>K;\n\tif(K==1){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tdp[1][0]=1;\n\trep1(i,N) rep(j,i+1){\n//\t\tprintf(\"dp[%d][%d]=%lld\\n\",i,j,dp[i][j]);\n\t\tif(i!=N) add(dp[i+1][j],dp[i][j]);\n\t\tif(j!=i){\n\t\t\tint left=N*K-i-j*(K-1)-1;\n\t\t\tadd(dp[i][j+1],dp[i][j]*C(left,K-2));\n\t\t}\n\t}\n\tll ans=dp[N][N];\n\trep1(i,N) ans=ans*i%mod;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int MAX_P = 2000 * 2000 + 1;\nconst int MOD = (int)1e9 + 7;\n\nll fact[MAX_P], rfact[MAX_P];\n\nll extgcd (ll a, ll b, ll &x, ll &y){\n\tif (b == 0){x = 1LL; y = 0LL; return a;}\n\tll g = extgcd (b, a%b, y, x); y -= a/b*x;\n\treturn g;\n}\n\nll mod_inv(ll a, ll M){\n\tll x, y;\n\textgcd (a, M, x, y);\n\treturn (M+x%M)%M;\n}\n\nvoid init(void){\n\tfact[0] = rfact[0] = 1LL;\n\tfor (int i = 1; i < MAX_P; i++ ){\n\t\tfact[i] = (fact[i-1]*(ll)i)%(ll)MOD;\n\t\trfact[i] = (rfact[i-1]*mod_inv((ll)i,(ll)MOD))%(ll)MOD;\n\t} // end for\n}\n\t\nll comb(int n, int k){\n\tif (n < k) return 0LL;\n\treturn ((fact[n]*rfact[n-k])%(ll)MOD)*rfact[k]%(ll)MOD;\n}\n\nll dp[2001][2001];\n\nint main()\n{\n\tmemset(dp, 0LL, sizeof(dp));\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint N, K; cin >> N >> K;\n\tinit();\n\n\trep (i, N+1) dp[i][0] = 1LL;\n\tif (N != 1 && K != 1){\n\t\tfor (int i = 1; i <= N; ++i){\n\t\t\tfor (int j = 1; j <= i; ++j){\n\t\t\t\tdp[i][j] = (dp[i-1][j] + comb(N - i + (N - j + 1)*(K - 1) - 1, K - 2) * dp[i][j-1]) % (ll)MOD;\n\t\t\t} // end for\n\t\t} // end for\n\t\tll res = (dp[N][N] * fact[N]) % (ll)MOD;\n\t\tcout << res << endl;\t\t\t\n\t}else{\n\t\tcout << 1 << endl;\n\t} // end if\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define pa pair<int,int>\nconst int Maxn=2010;\nconst int mod=1000000007;\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();\n\treturn x*f;\n}\nint n,k,f[Maxn][Maxn];\nint fac[Maxn*Maxn],inv[Maxn*Maxn],fin[Maxn*Maxn];\nvoid pre()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=n*k;i++)fac[i]=(LL)fac[i-1]*i%mod;\n\tinv[0]=inv[1]=1;\n\tfor(int i=2;i<=n*k;i++)inv[i]=(LL)(mod-mod/i)*inv[mod%i]%mod;\n\tfin[0]=1;\n\tfor(int i=1;i<=n*k;i++)fin[i]=(LL)fin[i-1]*inv[i]%mod;\n}\nint C(int n,int m)\n{\n\tif(n<m)return 0;\n\treturn (LL)fac[n]*fin[m]%mod*fin[n-m]%mod;\n}\nint main()\n{\n\tn=read(),k=read();\n\tif(k==1)return puts(\"1\"),0;\n\tpre();\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=0;j<=i;j++)\n\t{\n\t\tf[i][j]=f[i-1][j];\n\t\tif(j)f[i][j]=(f[i][j]+(LL)(n-(j-1))*f[i][j-1]%mod*C(n-i+(n-(j-1))*(k-1)-1,k-2)%mod)%mod;\n\t}\n\tprintf(\"%d\",f[n][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#if __cplusplus >= 201103L\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n#pragma comment(linker, \"/STACK:1024000000,1024000000\") \n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define EPS 1e-10\n#define set0(x) memset((x),0,sizeof(x))\n#define setINF(x) memset((x),63,sizeof(x))\nusing namespace std;\nint n,k;\nlong long fac[4000005],inv[4000005],dp[2005][2005];\ninline long long fpow(long long x,long long y){\n\tif(y==1)return x;\n\tlong long t=fpow(x,y>>1);\n\tt=t*t%MOD;\n\tif(y&1)t=t*x%MOD;\n\treturn t;\n}\ninline long long C(long long x,long long y){\n\treturn (fac[x]*inv[y]%MOD)*inv[x-y]%MOD;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin>>n>>k;\n\tif(k==1){\n\t\tcout<<\"1\\n\";\n\t\treturn 0;\n\t}\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=n*n;i++){\n\t\tfac[i]=fac[i-1]*i%MOD;\n\t\tinv[i]=fpow(fac[i],MOD-2);\n\t}\n\tdp[0][0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=i;j<=n;j++){\n\t\t\tif(i)dp[i][j]=dp[i-1][j];\n\t\t\tif(j>i)dp[i][j]=(dp[i][j]+dp[i][j-1]*C(j*(k-1)+i-1,k-2)%MOD)%MOD;\n\t\t}\n\t}\n\tcout<<(dp[n][n]*fac[n])%MOD<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nconst int MOD(1000000007);\nint n, k;\nint fac[4000000], inv_fac[4000000], dp[2001][2001];\n\n\nint Power(long long a, int b)\n{\n\tlong long ret(1ll);\n\t\n\twhile (b) {\n\t\tb & 1 && (ret *= a);\n\t\tret >= MOD && (ret %= MOD);\n\t\ta *= a;\n\t\ta >= MOD && (a %= MOD);\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\n\n\nint main()\n{\n\tlong long lt;\n\tint t;\n\t\n\tscanf(\"%d%d\", &n, &k);\n\tif (k == 1) {\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tfac[0] = 1;\n\tt = n * k;\n\tfor (int i = 1; i < t; ++i) {\n\t\tlt = (long long)i * fac[i - 1];\n\t\tfac[i] = lt < MOD ? lt : lt % MOD; \n\t}\n\tinv_fac[t - 1] = Power((long long)fac[t - 1], MOD - 2);\n\tfor (int i = t - 2; i; --i) {\n\t\tlt = (long long)(i + 1) * inv_fac[i + 1];\n\t\tinv_fac[i] = lt < MOD ? lt : lt % MOD;\n\t}\n\tinv_fac[0] = 1;\n\tdp[0][0] = 1;\n\tt = -2;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tt += k - 1;\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\t++t;\n\t\t\tlt = (long long)fac[t] * inv_fac[t - k + 2];\n\t\t\tlt >= MOD && (lt %= MOD);\n\t\t\tlt *= (long long)inv_fac[k - 2];\n\t\t\tlt >= MOD && (lt %= MOD);\n\t\t\tlt *= (long long)dp[i - 1][j];\n\t\t\tj && (lt += dp[i][j - 1]);\n\t\t\tdp[i][j] = lt < MOD ? lt : lt % MOD;\n\t\t}\n\t\tt -= i + 1;\n\t}\n\tlt = (long long)dp[n][n] * fac[n] % MOD;\n\tprintf(\"%lld\\n\", lt);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define N 4000005\nusing namespace std;\nconst int mod=1e9+7;\nint n,k,f[2005][2005],jc[N],invjc[N];\nint power(int x,int y)\n{\n\tint ans=1;\n\tfor (;y;y>>=1,x=1LL*x*x%mod)\n\t{\n\t\tif (y&1) ans=1LL*ans*x%mod;\n\t}\n\treturn ans;\n}\nvoid init()\n{\n\tjc[0]=1;\n\tfor (int i=1;i<N;i++) jc[i]=1LL*jc[i-1]*i%mod;\n\tinvjc[N-1]=power(jc[N-1],mod-2);\n\tfor (int i=N-2;i>=0;i--) invjc[i]=1LL*invjc[i+1]*(i+1)%mod;\n}\nint C(int n,int m)\n{\n//\tcout<<\"!!!\"<<n<<\"!!!\"<<m<<\" \"<<jc[n]<<\" \"<<invjc[m]<<\" \"<<invjc[n-m]<<endl;\n\treturn 1LL*jc[n]*invjc[m]%mod*invjc[n-m]%mod;\n}\nsigned main()\n{\n\tinit();\n\tscanf(\"%lld%lld\",&n,&k);\n\tif (k==1)\n\t{\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tf[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=0;j<=i;j++)\n\t\t{\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif (!j) continue;\n\t\t\t(f[i][j]+=1LL*f[i][j-1]*(n-j+1)%mod*C(n*k-i-1-(j-1)*(k-1),k-2)%mod)%=mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define ll long long\n#define mod 1000000007LL\n\nll f[2010][2010],fac[4000010],inv[4000010],n,m;\n\ninline ll rd()\n{\n\tll x=0;char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\ninline ll ksm(ll x,ll y) { ll res=1;for (;y;y>>=1,x=x*x%mod) if (y&1) res=res*x%mod;return res; }\n\ninline ll C(ll x,ll y)\n{\n\tif (x<y) return 0;\n\treturn fac[x]*inv[x-y]%mod*inv[y]%mod;\n}\n\nint main()\n{\n\tn=rd();m=rd();\n\tif (m==1) { puts(\"1\");return 0; }\n\tfac[0]=1LL;\n\tfor (int i=1;i<=n*m;i++) fac[i]=fac[i-1]*i%mod;\n\tinv[n*m]=ksm(fac[n*m],mod-2);\n\tfor (int i=n*m;i;i--) inv[i-1]=inv[i]*i%mod;\n\tf[0][0]=1LL;\n\tfor (int i=1;i<=n;i++) for (int j=i;~j;j--)\n\t{\n\t\tf[i][j]=f[i][j+1];\n\t\tif (j) f[i][j]=(f[i][j]+f[i-1][j-1]*C(i*m-j-1,m-2))%mod;\n\t}\n\tprintf(\"%lld\\n\",f[n][0]*fac[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "%:pragma GCC optimize(2)\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e3 + 5;\nconst int M = 4e6 + 5;\nconst int mod = 1e9 + 7;\n\nint n, k, dp[N][N], fac[M], ifac[M];\n\ninline int mul(int a, int b) {\n\treturn (long long) a * b % mod;\n}\ninline int add(int a, int b) {\n\treturn (a += b) >= mod ? a - mod : a;\n}\ninline int Pow(int a, int b) {\n\tint r = 1;\n\tfor(; b; b >>= 1, a = mul(a, a))\n\t\tif(b & 1) r = mul(r, a);\n\treturn r;\n}\n\nvoid pre(int n) {\n\tfac[0] = 1;\n\tfor(int i = 1; i <= n; ++i)\n\t\tfac[i] = mul(fac[i - 1], i);\n\tifac[n] = Pow(fac[n], mod - 2);\n\tfor(int i = n - 1; ~i; --i)\n\t\tifac[i] = mul(ifac[i + 1], i + 1);\n}\ninline int C(int n, int m) {\n\tif(n < 0 || m < 0 || n < m) return 1;\n\treturn mul(fac[n], mul(ifac[m], ifac[n - m]));\n}\n\nint main() {\n\tcin >> n >> k;\n\tif(k == 1) return 0 * putchar('1');\n\tpre(M - 1);\n\tdp[0][0] = 1;\n\tfor(int i = 0; i <= n; ++i)\n\t\tfor(int j = i +(!i); j <= n; ++j) {\n\t\t\tif(i) dp[i][j] = dp[i - 1][j];\n\t\t\tdp[i][j] = add(dp[i][j], mul(dp[i][j - 1], C(i + j * (k - 1) - 1, k - 2)));\n\t\t}\n\tprintf(\"%d\\n\", mul(dp[n][n], fac[n]));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define il inline\n#define re register\n\nusing namespace std;\nconst int N=2000+10,mod=1e9+7;\nil int rd()\n{\n  int x=0,w=1;char ch=0;\n  while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}\n  while(ch>='0'&&ch<='9') {x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}\n  if((x*=w)==-1) exit(0);\n  return x;\n}\nint n,kk,f[N][N],fac[N*N],iac[N*N];\nil int fpow(int a,int b){int an=1;while(b){if(b&1) an=1ll*an*a%mod;a=1ll*a*a%mod,b>>=1;}return an;}\nil int C(int n,int m){return m<0||n<m?0:1ll*fac[n]*iac[m]%mod*iac[n-m]%mod;}\n\nint main()\n{\n  n=rd(),kk=rd();\n  fac[0]=1;\n  for(int i=1;i<=n*kk;++i) fac[i]=1ll*fac[i-1]*i%mod;\n  iac[n*kk]=fpow(fac[n*kk],mod-2);\n  for(int i=n*kk;i;--i) iac[i-1]=1ll*iac[i]*i%mod;\n  f[0][0]=1;\n  for(int i=1;i<=n;++i)\n\tfor(int j=0;j<=i;++j)\n\t  f[i][j]=(f[i-1][j]+(j?(1ll*f[i][j-1]*(n-j+1)%mod*C(n-i+(n-j+1)*(kk-1)-1,kk-2)%mod):0))%mod;\n  printf(\"%d\\n\",f[n][n]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Be Name Khoda\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\ntemplate <typename T> using ordered_set =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T> using ordered_multiset =  tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \ntypedef long long int LL;\ntypedef LL ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vll;\ntypedef stringstream strs;\n \n#define X first\n#define Y second\n#define PB push_back\n#define For(i,a,b) for (int i=a;i<b;i++)\n#define Ford(i,a,b) for (int i=a;i>=b;i--)\n#define smax(a,b) a=max(a,b)\n#define smin(a,b) a=min(a,b)\n#define SZ(a) ((ll)a.size())\n#define ER(a) cout << #a << ' ' << a << endl\n#define LB(a,n,x) (lower_bound(a,(a)+(n),x)-(a))\n#define RET(x) { cout << x; exit(0); } \nconst ll M=2e3+5,LG=32,SM=600+5,inf=1e18+5;\nll mod=1e9+7;\n \nll n,k;\nll dp[M][M];\nll fac[M*M],faci[M*M];\n\nll pwr(ll x,ll n)\n{\n    ll z=x,res=1;\n    For(i,0,LG)\n    {\n        if ((n>>i)&1)\n            res=(res*z)%mod;\n        z=(z*z)%mod;\n    }\n    return res;\n}\n\nll com(ll i,ll j)\n{\n    if (j>i) return 0;\n    ll res=(fac[i]*faci[j])%mod;\n    res=(res*faci[i-j])%mod;\n    return res;\n}\n\nint main()\n{\n    cin >> n >> k;\n    if (k==1) RET(1);\n    fac[0]=1;\n    faci[0]=1;\n    For(i,1,n*k)\n    {\n        fac[i]=(fac[i-1]*i)%mod;\n        faci[i]=pwr(fac[i],mod-2);\n    }\n    dp[1][0]=dp[1][1]=1;\n    For(i,2,n+1)\n    {\n        //ER(i);\n        dp[i][0]=com(i*(k-1)-1,k-2);\n        //ER(dp[i][0]);\n        For(j,1,i)\n        {\n            dp[i][j]=dp[i][j-1];\n            dp[i][j]+=\n                (com(i*(k-1)+j-1,k-2)\n                *dp[i-1][j])%\n                mod;\n            dp[i][j]%=mod;            \n        }\n        dp[i][i]=dp[i][i-1];\n    }\n    RET((dp[n][n]*fac[n])%mod);\n}    \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n\nconst ll M=int(1e9)+7;\nint n, k;\n\nll fact[2001*2001];\n\nll Pow(ll b, ll e){\n\tll ret=1;\n\twhile(e){\n\t\tif(e&1) ret=ret*b%M;\n\t\te/=2; b=b*b%M;\n\t}\n\treturn ret;\n}\nll modinv(ll x){\n\treturn Pow(x, M-2);\n}\n\nll combi(int n, int k){\n\treturn fact[n]*modinv(fact[k])%M*modinv(fact[n-k])%M;\n}\n\nll dp[2010][2010];\n\nint main()\n{\n\tfact[0]=1;\n\tfor(int i=1; i<=2000*2000; ++i) fact[i]=fact[i-1]*i%M;\n\tread(n, k);\n\tif(k == 1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\t\n\tfor(int i=n+1; 1<=i; --i){\n\t\tfor(int j=min(n,i); 1<=j; --j){\n\t\t\tif(i==n+1 && j==n){\n\t\t\t\tdp[i][j]=1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tll d=dp[i+1][j];\n\t\t\tif(j+1<=i){\n\t\t\t\tll c1=k-2;\n\t\t\t\tll c2=(n-j)*k-(i-j-1);\n\t\t\t\td += dp[i][j+1]*combi(c1+c2, c1)%M;\n\t\t\t\td %= M;\n\t\t\t}\n\t\t\tdp[i][j]=d;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[1][1]*fact[n]%M);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD=1000000007;\nint N, K;\nint chain[2001];\nint tree[2001];\nint dp[2001][2001];\nint fact[4000001];\nint ifact[4000001];\n\nint powmod(int a, int b)\n{\n    int ret=1;\n    for(; b>0; b/=2)\n    {\n        if(b&1)\n            ret=1LL*ret*a%MOD;\n        a=1LL*a*a%MOD;\n    }\n    return ret;\n}\n\nint C(int n, int k)\n{\n    return 1LL*fact[n]*ifact[k]%MOD*ifact[n-k]%MOD;\n}\n\nint main()\n{\n    scanf(\"%d%d\", &N, &K);\n    if(K==1)\n        return printf(\"1\\n\"), 0;\n    fact[0]=1;\n    for(int i=1; i<=4000000; i++)\n        fact[i]=1LL*fact[i-1]*i%MOD;\n    ifact[4000000]=powmod(fact[4000000], MOD-2);\n    for(int i=3999999; i>=0; i--)\n        ifact[i]=1LL*ifact[i+1]*(i+1)%MOD;\n    dp[0][0]=1;\n    for(int i=1; i<=N; i++)\n    {\n        if(i==1)\n            tree[i]=1;\n        else\n            tree[i]=1LL*tree[i-1]*C(i*(K-1)-1, K-2)%MOD;\n        dp[0][i]=tree[i];\n    }\n    chain[0]=1;\n    for(int i=1; i<=N; i++)\n        chain[i]=1LL*chain[i-1]*C(i*(K-2), K-2)%MOD;\n    for(int i=1; i<=N; i++)\n    {\n        for(int j=i; j<=N; j++)\n        {\n            dp[i][j]=(dp[i-1][j]+1LL*dp[i][j-1]*C(i+(j-1)*(K-1)+K-2, K-2))%MOD;\n        }\n    }\n    printf(\"%lld\\n\", 1LL*dp[N][N]*fact[N]%MOD);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nint f[2010][2010],fac[4000010],inv[4000010];\ninline int qpow(int a,int b) {\n\tint ans=1;\n\twhile(b) {\n\t\tif(b&1)ans=1ll*ans*a%mod;\n\t\ta=1ll*a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\ninline int C(int n,int m) {\n\treturn 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main() {\n\tint n,k;\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\tfor(int i=1;i<=n*k;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[n*k]=qpow(fac[n*k],mod-2);\n\tfor(int i=n*k-1;i>=0;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tf[0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++) {\n\t\t\tf[i+1][j]=(f[i+1][j]+f[i][j])%mod;\n\t\t\tf[i][j+1]=(f[i][j+1]+1ll*C(n*k-i-j*(k-1)-1,k-2)*f[i][j])%mod;\n\t\t}\n\tprintf(\"%lld\\n\",1ll*f[n][n]*fac[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\t\n\tchar buf[bufl],*s=buf,*t=buf;\n\t\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\t\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 2007 , __ = _*_ , mo = 1000000007;\n\ninline lint powa(lint a,lint t)\n{\n\tlint b=1;\n\twhile(t){if(t&1)b=b*a%mo;a=a*a%mo,t>>=1;}\n\treturn b;\n}\n\ninline lint inva(lint a)\n{\n\treturn powa(a,mo-2);\n}\n\nlint jc[__],rjc[__];\n\ninline void fuck(int n=__-1)\n{\n\tjc[0]=jc[1]=rjc[0]=1;\n\tfor(int i=2;i<=n;i++)jc[i]=jc[i-1]*i%mo;\n\trjc[n]=inva(jc[n]);\n\tfor(int i=n-1;i>=1;i--)rjc[i]=rjc[i+1]*(1ll+i)%mo;\n}\n\ninline lint C(int n,int m)\n{\n\treturn jc[n]*rjc[m]%mo*rjc[n-m]%mo;\n}\n\nint n,m;\nlint f[_][_]={0};\n\nint main()\n{//\n\tn=ty(),m=ty();\n\tif(m<=1){puts(\"1\");return 0;}\n\n\tfuck();\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(j>0)f[i][j]=(f[i][j]+f[i][j-1]*(n-j+1)%mo*C(n*m-i-(j-1)*(m-1)-1,m-2)%mo)%mo;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[n][n]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 1000000007\n#define MX 4000000\nint dp[2005][2005];\nlong long fact[MX+5],inv[MX+5];\nlong long pow_log(long long x,int y)\n{\n\tif (!y)\n\treturn 1;\n\tlong long ret=pow_log(x,y/2);\n\tret=(ret*ret)%mod;\n\tif (y%2)\n\tret=(ret*x)%mod;\n\treturn ret;\n}\nlong long ncr(int n,int r)\n{\n\treturn ((fact[n]*inv[r])%mod*inv[n-r])%mod;\n}\nint n,k;\nint solve(int w,int c)\n{\n\tif (w==n && c==n)\n\treturn 1;\n\tif (dp[w][c]!=-1)\n\treturn dp[w][c];\n\tint ret=0;\n\tif (w!=n)\n\tret=solve(w+1,c);\n\tif (c<w)\n\tret=(ret+solve(w,c+1)*ncr(n*k-w-c*(k-1)-1,k-2)%mod*(n-c))%mod;\n\treturn dp[w][c]=ret;\n}\nint main()\n{\n\tfact[0]=1;\n\tfor (int i=1;i<=MX;i++)\n\tfact[i]=(i*fact[i-1])%mod;\n\tinv[MX]=pow_log(fact[MX],mod-2);\n\tfor (int i=MX-1;i>=0;i--)\n\tinv[i]=((i+1)*inv[i+1])%mod;\n\tscanf(\"%d%d\",&n,&k);\n\tif (k==1)\n\t{\n\t\tprintf(\"1\");\n\t\treturn 0;\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tprintf(\"%d\",solve(0,0));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#define Mod 1000000007\nusing namespace std;\nlong long f[2010][2010];\nint n,k;\nlong long fac[4000010],inv[4000010];\nlong long fpow(long long a,long long b)\n{\n\tlong long ans=1,t=a;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=ans*t%Mod;\n\t\tt=t*t%Mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nvoid getfac()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=n*k;i++)\n\t\tfac[i]=fac[i-1]*i%Mod;\n\tinv[n*k]=fpow(fac[n*k],Mod-2);\n\tfor(int i=n*k;i;i--)\n\t\tinv[i-1]=inv[i]*i%Mod;\n\treturn ;\n}\nlong long C(int a,int b)\n{\n\treturn fac[a]*inv[b]%Mod*inv[a-b]%Mod;\n}\nint main()\n{\n\tcin>>n>>k;\n\tif(k==1){\n\t\tcout<<1<<\"\\n\";\n\t\treturn 0;\n\t}\n\tgetfac();\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tf[i][j]+=f[i-1][j];\n\t\t\tif(j)\n\t\t\t\tf[i][j]=(f[i][j]+f[i][j-1]*(n-j+1)%Mod*C(n-i+(k-1)*(n-j+1)-1,k-2)%Mod)%Mod;\n\t\t}\n\tprintf(\"%lld\\n\",f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int MAX_P = 2000 * 2000 + 1;\nconst int MOD = (int)1e9 + 7;\n\nint fact[MAX_P], rfact[MAX_P];\n\nll extgcd (ll a, ll b, ll &x, ll &y){\n\tif (b == 0){x = 1LL; y = 0LL; return a;}\n\tll g = extgcd (b, a%b, y, x); y -= a/b*x;\n\treturn g;\n}\n\nll mod_inv(ll a, ll M){\n\tll x, y;\n\textgcd (a, M, x, y);\n\treturn (M+x%M)%M;\n}\n\nvoid init(void){\n\tfact[0] = rfact[0] = 1;\n\tfor (int i = 1; i < MAX_P; i++ ){\n\t\tfact[i] = ((ll)fact[i-1]*i)%MOD;\n\t\trfact[i] = ((ll)rfact[i-1]*mod_inv((ll)i,(ll)MOD))%MOD;\n\t} // end for\n}\n\t\nint comb(int n, int k){\n\tif (n < k) return 0;\n\treturn (((ll)fact[n]*rfact[n-k])%MOD)*rfact[k]%MOD;\n}\n\nll dp[2001][2001];\n\nint main()\n{\n\tmemset(dp, 0LL, sizeof(dp));\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint N, K; cin >> N >> K;\n\tinit();\n\n\trep (i, N+1) dp[i][0] = 1LL;\n\tif (N != 1 && K != 1){\n\t\tfor (int i = 1; i <= N; ++i){\n\t\t\tfor (int j = 1; j <= i; ++j){\n\t\t\t\tdp[i][j] = (dp[i-1][j] + (ll)comb(N - i + (N - j + 1)*(K - 1) - 1, K-2) * dp[i][j-1]) % (ll)MOD;\n\t\t\t} // end for\n\t\t} // end for\n\t\tll res = (dp[N][N] * fact[N]) % (ll)MOD;\n\t\tcout << res << endl;\t\t\t\n\t}else{\n\t\tcout << 1 << endl;\n\t} // end if\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    Author: zxy_hhhh\n    date: 2020/03/12\n*/\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<set>\n#include<vector>\n#include<map>\n#include<queue>\n#include<iostream>\n#define ll long long\ninline ll rd() {\n    ll _x=0;int _ch=getchar(),_f=1;\n    for(;!isdigit(_ch)&&(_ch!='-')&&(_ch!=EOF);_ch=getchar());\n    if (_ch=='-'){_f=0;_ch=getchar();}\n    for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0';\n    return _f?_x:-_x;\n}\nvoid write(ll _x){if (_x>=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); }\ninline void wrt(ll _x,char _p){if (_x<0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);}\n#define maxn 2005\n#define mod 1000000007\nint n,K;\nint f[maxn][maxn];\nint fac[maxn*maxn],inv[maxn*maxn];\ninline int C(int n,int m) {return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint main() {\n    n=rd();K=rd();\n    if (K==1) {\n        wrt(0,'\\n');\n        return 0;\n    }\n    fac[0]=fac[1]=inv[0]=inv[1]=1;\n    for(int i=2;i<=n*K;i++) {\n        fac[i]=1ll*fac[i-1]*i%mod;\n        inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n    }\n    for(int i=1;i<=n*K;i++) {\n        inv[i]=1ll*inv[i-1]*inv[i]%mod;\n    }\n    f[0][0]=1;\n    for(int i=1;i<=n;i++) {\n        for(int j=0;j<=i;j++) {\n            f[i][j]=(f[i-1][j]+(j>0?1ll*f[i][j-1]*C(n*K-i-(j-1)*(K-1)-1,K-2)%mod*(n-j+1):0))%mod;\n        }\n    }\n    wrt(f[n][n],'\\n');\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN\t2005\n#define MAXP\t4000005\n#define P\t1000000007\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nlong long fac[MAXP], inv[MAXP], ans[MAXN][MAXN];\nlong long power(long long x, long long y) {\n\tif (y == 0) return 1;\n\tlong long tmp = power(x, y / 2);\n\tif (y % 2 == 0) return tmp * tmp % P;\n\telse return tmp * tmp % P * x % P;\n}\nlong long getc(int x, int y) {\n\treturn fac[x] * inv[y] % P * inv[x - y] % P;\n}\nint main() {\n\tint N, n, k;\n\tread(n), read(k);\n\tif (k == 1) {\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tN = n * k;\n\tfac[0] = 1;\n\tfor (int i = 1; i <= N; i++)\n\t\tfac[i] = fac[i - 1] * i % P;\n\tinv[N] = power(fac[N], P - 2);\n\tfor (int i = N - 1; i >= 0; i--)\n\t\tinv[i] = inv[i + 1] * (i + 1) % P;\n\tans[0][0] = 1;\n\tfor (int i = 0; i <= n; i++)\n\tfor (int j = 0; j <= n; j++) {\n\t\tif (i != 0) ans[i][j] += ans[i - 1][j];\n\t\tif (j != 0 && j != i) ans[i][j] += ans[i][j - 1] * getc(i + j * (k - 1) - 1, k - 2) % P;\n\t\tans[i][j] %= P;\n\t}\n\tlong long finalans = ans[n][n] * fac[n] % P;\n\tcout << finalans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\n\nconst int N = 2e3 + 5, M = N * N, mod = 1e9 + 7;\n\nint n, k;\nll dp[N][N], fact[M], rev[M];\n\nll pw(ll a, ll b) {\n\tif(!b)\n\t\treturn 1;\n\tll ans = pw(a, b / 2);\n\tans = (ans * ans) % mod;\n\tif(b & 1)\n\t\tans *= a;\n\treturn ans % mod;\n}\n\nvoid prep() {\n\tfact[0] = 1;\n\tfor (int i = 1; i < M; i++)\n\t\tfact[i] = (fact[i - 1] * i) % mod;\n\trev[M - 1] = pw(fact[M - 1], mod - 2);\n\tfor (int i = M - 2; ~i; i--)\n\t\trev[i] = (rev[i + 1] * (i + 1)) % mod;\n}\n\nint sum(int a, int b) {\n\ta += b;\n\tif(a >= mod)\n\t\ta -= mod;\n\tif(a < 0)\n\t\ta += mod;\n\treturn a;\n}\n\nll c(int x, int y) {\n\tif(y > x)\n\t\treturn 0;\n\tll ans = (fact[x] * rev[y]) % mod;\n\tans = (ans * rev[x - y]) % mod;\n\treturn ans;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\t\n\tcin >> n >> k;\n\tprep();\n\tif(k == 1)\n\t\treturn cout << 1 << \"\\n\", 0;\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j <= i; j++) {\n\t\t\tdp[i][j] = sum(dp[i][j], dp[i - 1][j]);\n\t\t\tif(j) {\n\t\t\t\tll cost = c((n * k) - ((j - 1) * (k - 1)) - i - 1, k - 2);\n\t\t\t\tdp[i][j] = sum(dp[i][j], dp[i][j - 1] * cost % mod);\n\t\t\t}\n\t\t}\n\t}\n\tcout << (fact[n] * dp[n][n]) % mod << \"\\n\";\n }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ui unsigned int\n#define ll long long\n#define db double\n#define ld long double\n#define ull unsigned long long\n#define ft first\n#define sd second\n#define pb(a) push_back(a)\n#define PII std::pair<int,int>\n#define PLL std::pair<ll,ll>\n#define mp(a,b) std::make_pair(a,b)\n#define ITR(a,b) for(auto a:b)\n#define REP(a,b,c) for(register int a=(b),a##end=(c);a<=a##end;++a)\n#define DEP(a,b,c) for(register int a=(b),a##end=(c);a>=a##end;--a)\nconst int MAXN=2000+10,MAXM=5000000+10,Mod=1e9+7;\nint n,k;\nll f[MAXN][MAXN],fac[MAXM],inv[MAXM];\ntemplate<typename T> inline void read(T &x)\n{\n\tT data=0,w=1;\n\tchar ch=0;\n\twhile(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n\tif(ch=='-')w=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9')data=((T)data<<3)+((T)data<<1)+(ch^'0'),ch=getchar();\n\tx=data*w;\n}\ntemplate<typename T> inline void write(T x,char ch='\\0')\n{\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)write(x/10);\n\tputchar(x%10+'0');\n\tif(ch!='\\0')putchar(ch);\n}\ntemplate<typename T> inline bool chkmin(T &x,T y){return y<x?(x=y,true):false;}\ntemplate<typename T> inline bool chkmax(T &x,T y){return y>x?(x=y,true):false;}\ntemplate<typename T> inline T min(T x,T y){return x<y?x:y;}\ntemplate<typename T> inline T max(T x,T y){return x>y?x:y;}\ninline ll qexp(ll a,ll b)\n{\n\tll res=1;\n\twhile(b)\n\t{\n\t\tif(b&1)res=res*a%Mod;\n\t\ta=a*a%Mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\ninline void init(int LM)\n{\n\tfac[0]=1;\n\tREP(i,1,LM)fac[i]=1ll*fac[i-1]*i%Mod;\n\tinv[LM]=qexp(fac[LM],Mod-2);\n\tDEP(i,LM-1,0)inv[i]=1ll*inv[i+1]*(i+1)%Mod;\n}\ninline ll C(int n,int m)\n{\n\treturn 1ll*fac[n]*inv[m]%Mod*inv[n-m]%Mod;\n}\nint main()\n{\n\tread(n);read(k);init((n+1)*k);\n\tif(k==1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tf[0][0]=1;\n\tREP(i,0,n)REP(j,0,i)if(i||j)\n\t\tf[i][j]=((j?f[i][j-1]:0)+(i?1ll*C((i-1)*(k-1)+j+k-2,k-2)*f[i-1][j]%Mod:0))%Mod;\n\twrite(1ll*f[n][n]*fac[n]%Mod,'\\n');\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,fast-math,unroll-loops\")\n \n#include <bits/stdc++.h>\n \n#define int ll\n//#define double long double\n#define endl '\\n'\n#define all(C) (C).begin(), (C).end()\n#define rall(C) (C).rbegin(), (C).rend()\n#define mp make_pair \n#define pb emplace_back\n#define dbg(x) cerr << #x << \" : \" << x << endl\n//#define PI 3.141592653589\n \nusing namespace std;\n        \nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing pii = pair <int, int>;\nusing pld = pair <ld, ld>;\n        \n/* \nconst ll MAX_MEM = 25e7;\nchar MEM[MAX_MEM];\nll MEM_POS = 0;\nvoid* operator new(size_t x)\n{\n    auto ret = MEM + MEM_POS;\n    MEM_POS += x;\n    assert(MEM_POS < MAX_MEM);\n    return ret;\n}\nvoid operator delete(void*)\n{}\n*/\n        \ntemplate <class T>\nistream& operator>> (istream &in, vector <T> &a)\n{\n    for (auto &i : a)\n        in >> i;\n    return in;\n}\n        \ntemplate <class T> \nostream& operator<< (ostream &out, vector <T> a)\n{\n    for (auto &i : a)\n        out << i << ' ';\n    return out;\n}\n        \ntemplate <class T, class U>\nistream& operator>> (istream &in, pair <T, U> &p)\n{\n    in >> p.first >> p.second;\n    return in;\n}\n        \ntemplate <class T, class U>\nostream& operator<< (ostream &out, pair <T, U> p)\n{\n    out << p.first << \" \" << p.second << \" \";\n    return out;\n}\n        \ninline void Start()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    //freopen(\"lol.in\", \"r\", stdin);\n    //freopen(\"lol.out\", \"w\", stdout);\n}\n\nconst int P = 1e9 + 7;\nint add(int a, int b)\n{\n    return a + b >= P ? a + b - P : a + b;\n}\nint mul(int a, int b)\n{\n    return a * b % P;\n}\nint bpow(int a, int n)\n{\n    int res = 1;\n    while (n)\n    {\n        if (n & 1)\n            res = mul(res, a);\n        a = mul(a, a);\n        n >>= 1;\n    }\n    return res;\n}\nint rev(int x)\n{\n    return bpow(x, P - 2);\n}\nint sub(int a, int b)\n{\n    return add(a, P - b);\n}\nint divi(int a, int b)\n{\n    return mul(a, rev(b));\n}\nstruct combinations\n{\n    vector <int> fact, revfact;\n    combinations() {}\n    combinations(int n)\n    {\n        fact.assign(n, 1);\n        revfact.assign(n, 1);\n        for (int i = 1; i < n; ++i)\n            fact[i] = mul(fact[i - 1], i), revfact[i] = divi(revfact[i - 1], i);\n    }\n    int operator() (int n, int k)\n    {\n        return mul(fact[n], mul(revfact[k], revfact[n - k]));\n    }\n};\n\nsigned main()\n{\n    Start();\n    int n, k;\n    cin >> n >> k;\n    combinations c(2001 * 2001);\n    if (k == 1)\n        return cout << 1, 0;\n    vector <vector <int>> dp(n + 1, vector <int> (n + 1));\n    dp[0][0] = 1;\n    for (int i = 0; i <= n; ++i)\n    {\n        for (int j = (i ? 0 : 1); j <= n; ++j)\n        {\n            if (j < i)\n                continue;\n            if (i)\n                dp[i][j] = add(dp[i][j], dp[i - 1][j]);\n            if (j)\n                dp[i][j] = add(dp[i][j], mul(dp[i][j - 1], c(i + j * (k - 1) - 1, k - 2)));\n\n        }\n    }\n    cout << mul(dp[n][n], c.fact[n]);\n    return 0;\n}\n \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define rep(i, a, b) for(int i=(a); i<(b); i++)\n#define per(i, a, b) for(int i=(b)-1; i>=(a); i--)\n#define sz(a) (int)a.size()\n#define de(a) cout << #a << \" = \" << a << endl\n#define dd(a) cout << #a << \" = \" << a << \" \"\n#define all(a) (a).begin(), (a).end()\n#define pw(x) (1ll<<(x))\n#define lb(x) ((x) & -(x))\n#define endl \"\\n\"\n#define FI(x) freopen(#x\".in\",\"r\",stdin)\n#define FO(x) freopen(#x\".out\",\"w\",stdout)\ntypedef double db;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n//typedef uniform_int_distribution<ll> RR;\nconst int P = 1e9 + 7;\n//ll rnd(ll l, ll r) { mt19937 gen(rand()); RR dis(l, r); return dis(gen); }\nint add(int a, int b) {if((a += b) >= P) a -= P; return a < 0 ? a + P : a;}\nint mul(int a, int b) {return 1ll * a * b % P;}\nint kpow(int a, int b) {int r=1;for(;b;b>>=1,a=mul(a,a)) {if(b&1)r=mul(r,a);}return r;}\n//----\n\nconst int N = 2e3 + 8;\nint jc[N * N], inv[N * N], dp[N][N], n, m, k;\n\nint C(int n, int m) {\n\tif (n == m) return 1;\n\tif (m < 0 || m > n) return 0;\n\treturn mul(jc[n], mul(inv[m], inv[n - m]));\n}\n\nint main() {\n\t//FI(a);\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t//cout << setiosflags(ios::fixed);\n\t//cout << setprecision(2);\n\tcin >> n >> k;\n\tjc[0] = 1; rep(i, 1, n * k + 1) jc[i] = mul(jc[i-1], i);\n\tinv[n * k] = kpow(jc[n * k], P - 2);\n\tper(i, 0, n * k) inv[i] = mul(inv[i+1], i+1);\n\tdp[0][0] = 1;\n\trep(i, 0, n+1)\n\t\trep(j, i, n+1) {\n\t\t\tif (j == 0) continue;\n\t\t\tdp[i][j] = add(i > 0 ? dp[i-1][j] : 0, mul(dp[i][j-1], C(j * k - (j - i) - 1, k - 2)));\n\t\t\t//dd(i), dd(j), de(dp[i][j]);\n\t\t}\n\t//de(dp[n][n]);\n\tif (k == 1) jc[n] = 1;\n\tcout << mul(dp[n][n], jc[n]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int_t;\n\nint_t fact[4000000],finv[4000000];\nconst int_t mod = 1000000007;\nint_t dp[2010][2010];\n\nint_t C(int_t a,int_t b){\n    return fact[a] * finv[b] % mod * finv[a-b] % mod;\n}\n\nint main(){\n    int_t n,k; cin>>n>>k;\n    if(k == 1){ cout<< 1; return 0;}\n    fact[0] = fact[1] = finv[1] = finv[0] = dp[0][0] = 1;\n    for(int_t i=2;i<4000000;i++) fact[i] = fact[i-1] * i % mod, finv[i] = (mod - mod / i) * finv[mod % i] % mod;\n    for(int_t i=2;i<4000000;i++) finv[i] = finv[i] * finv[i-1] % mod;\n    for(int_t i=1;i<=n;i++)\n        for(int_t j=0;j<=i;j++){\n            dp[i][j] = dp[i-1][j];\n            if(j) dp[i][j] = (dp[i][j] + dp[i][j-1] * (n - j + 1) % mod * C(n - i + (n - j + 1) * (k - 1) - 1, k - 2)%mod)%mod;\n        }\n    cout<<dp[n][n];\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int mod = 1e9 + 7;\nconst int MAXN = 2005, MAXS = MAXN * MAXN;\n\ntemplate<typename _T>\nvoid read( _T &x )\n{\n\tx = 0;char s = getchar();int f = 1;\n\twhile( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}\n\twhile( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}\n\tx *= f;\n}\n\ntemplate<typename _T>\nvoid write( _T x )\n{\n\tif( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }\n\tif( 9 < x ){ write( x / 10 ); }\n\tputchar( x % 10 + '0' );\n}\n\nint f[MAXN][MAXN];\nint fac[MAXS], ifac[MAXS];\nint N, K;\n\nint qkpow( int, int );\nint inv( const int a ) { return qkpow( a, mod - 2 ); }\nvoid sub( int &x, const int v ) { x = ( x < v ? x - v + mod : x - v ); }\nvoid add( int &x, const int v ) { x = ( x + v >= mod ? x + v - mod : x + v ); }\n\nint qkpow( int base, int indx )\n{\n\tint ret = 1;\n\twhile( indx )\n\t{\n\t\tif( indx & 1 ) ret = 1ll * ret * base % mod;\n\t\tbase = 1ll * base * base % mod, indx >>= 1;\n\t}\n\treturn ret;\n}\n\nvoid init( const int siz )\n{\n\tfac[0] = ifac[0] = 1;\n\tfor( int i = 1 ; i <= siz ; i ++ ) fac[i] = 1ll * fac[i - 1] * i % mod;\n\tifac[siz] = inv( fac[siz] );\n\tfor( int i = siz - 1 ; ~ i ; i -- ) ifac[i] = 1ll * ifac[i + 1] * ( i + 1 ) % mod;\n}\n\nint C( const int n, const int m ) { return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod; }\n\nint main()\n{\n\tread( N ), read( K );\n\tif( K == 1 ) { puts( \"1\" ); return 0; }\n\tinit( N * K );\n\tfor( int i = 0 ; i <= K ; i ++ ) f[i][0] = 1;\n\tfor( int i = 1 ; i <= K ; i ++ )\n\t\tfor( int j = 1 ; j <= i ; j ++ )\n\t\t{\n\t\t\tf[i][j] = f[i - 1][j];\n\t\t\tint t = N * K - i - ( K - 1 ) * ( j - 1 ) - 1;\n\t\t\tadd( f[i][j], 1ll * f[i][j - 1] * ( N - j + 1 ) % mod * C( t, K - 2 ) % mod );\n\t\t}\n\twrite( f[K][N] ), putchar( '\\n' );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <bitset>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <string>\n \nusing namespace std;\ntypedef long long ll;\n \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n\n#define MOD 1000000007\n\nll fact[4040404], frev[4040404];\nll invs[4040404];\n\nll comb(int n, int k)\n{\n\tif (n < k) return 0;\n\treturn fact[n] * frev[k] % MOD * frev[n - k] % MOD;\n}\n\nvoid fill_factorial_table(){\n\tfact[0] = 1; frev[0] = 1;\n\tinvs[0] = 1;\n\tinvs[1] = 1;\n\tfor (int i = 2; i < 4040404; ++i) invs[i] = MOD - MOD / i * invs[MOD % i] % MOD;\n\tfor (int i = 1; i < 4040404; ++i) {\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\tfrev[i] = frev[i - 1] * invs[i] % MOD;\n\t}\n}\n\nll dp[4040][2020];\n\nint main(){\n    ll n,k;\n    cin >> n >> k;\n    if(k==1){ cout << \"1\" << endl; return 0;}\n    dp[1][1] = 1;\n    dp[0][1] = 1;\n    fill_factorial_table();\n    FOR(j,2,n+1){\n        dp[0][j] =  comb((j * (k - 1)) - 1, k - 2) * dp[0][j-1] % MOD;\n\n    }\n    FOR(i,1,n+1){\n        FOR(j,i,n+1){\n            dp[i][j] =  (dp[i-1][j] + ((comb(i + (j * (k - 1)) - 1, k - 2) * dp[i][j-1]) % MOD)) % MOD ;\n        }\n    }\n    cout << (dp[n][n] * fact[n]) % MOD << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 2007;\nconst int maxm = 4e6 + 7;\nconst int mod = 1e9 + 7;\n\nint n;\nint K;\nint f[maxn][maxn];\nint fac[maxm];\nint inv[maxm];\n\nint Add(int x,int y){return (x += y) >= mod ? x - mod : x;}\nint Sub(int x,int y){return (x -= y) <    0 ? x + mod : x;}\nint Mul(int x,int y){return 1LL * x * y % mod;}\nint Pow(int x,int k,int re = 1){\n\tfor(; k; k >>= 1,x = Mul(x,x))\n\t\tif(k & 1)re = Mul(re,x);\n\treturn re;\n}\nint C(int n,int m){\n\tif(n < m || m < 0)return 0;\n\treturn Mul(fac[n],Mul(inv[m],inv[n - m]));\n}\nint main(){\n\tcin >> n >> K;\n\tif(K == 1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0] = inv[0] = 1;\n\tfor(int i = 1; i <= n * K; ++i)\n\t\tfac[i] = Mul(fac[i - 1],i);\n\tinv[n * K] = Pow(fac[n * K],mod - 2);\n\tfor(int i = n * K - 1; i; --i)\n\t\tinv[i] = Mul(inv[i + 1],i + 1);\n\tf[1][0] = 1;\n\tfor(int i = 1; i <= n; ++i){\n\t\tfor(int j = 0; j <= i; ++j){\n\t\t\t//printf(\"%d %d %d\\n\",i,j,f[i][j]);\n\t\t\tf[i + 1][j] = Add(f[i + 1][j],f[i][j]);\n\t\t\tif(j + 1 <= n)f[i][j + 1] = Add(f[i][j + 1],Mul(f[i][j],Mul(n - j,C(n * K - j * (K - 1) - i - 1,K - 2))));\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nlong long Mod = 1000000007, Inv[4010000], F[4010000], InvF[4010000], D[2010][2010];\nlong long Comb(int a, int b){\n    return F[a]*InvF[b]%Mod*InvF[a-b]%Mod;\n}\nint n, K;\nint main(){\n    int i, j;\n    scanf(\"%d%d\",&n,&K);\n    if(K==1){\n        printf(\"1\\n\");\n        return 0;\n    }\n    Inv[1]=F[0]=InvF[0]=1;\n    for(i=2;i<=n*K;i++){\n        Inv[i] = Inv[Mod%i] * (Mod-Mod/i)%Mod;\n    }\n    for(i=1;i<=n*K;i++){\n        F[i]=F[i-1]*i%Mod;\n        InvF[i]=InvF[i-1]*Inv[i]%Mod;\n    }\n    for(i=0;i<=n;i++){\n        for(j=i;j<=n;j++){\n            if(i==0&&j==0)D[i][j]=1;\n            if(i) D[i][j] = D[i-1][j];\n            if(j>i) D[i][j] = (D[i][j] + D[i][j-1]* Comb(n*K - (n-i) - (n-j)*(K-1) - 1, K-2))%Mod;\n        }\n    }\n    printf(\"%lld\\n\",D[n][n]*F[n]%Mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int P = 1e9+7;\ntypedef long long i64;\n\nint fpm(int x,int d) {\n  int ret = 1;\n  for(; d; x = (i64) x*x % P, d >>= 1)\n    if(d & 1) ret = (i64) ret*x % P;\n  return ret;\n}\n\nint fac[4000005];\nint inv[4000005];\nint f[2005][2005];\n\nint C(int n,int m) {\n  return (i64) fac[n] * inv[m] % P * inv[n-m] % P;\n}\n\nint N, K;\nint main() {\n  if(fopen(\"input.txt\",\"r\")) {\n    freopen(\"input.txt\",\"r\",stdin);\n    freopen(\"output.txt\",\"w\",stdout);\n  }\n\n  scanf(\"%d%d\", &N, &K);\n\n  if(K == 1) {\n    puts(\"1\");\n    return 0;\n  }\n  \n  int n = N * K;\n  \n  fac[0] = 1;\n  for(int i = 1;i <= n; ++i) \n    fac[i] = (i64) fac[i-1] * i % P;\n  inv[n] = fpm(fac[n], P-2);\n  for(int i = n-1; ~i; --i)\n    inv[i] = (i64) inv[i+1] * (i+1) % P;\n\n  f[N][N] = 1;\n  for(int i = N; ~i; --i) {\n    for(int j = N; ~j; --j) {\n      if(i) (f[i-1][j] += f[i][j]) %= P;\n      if(i < j) (f[i][j-1] += (i64) f[i][j] * C(i+j*(K-1),K-2)) %= P;\n    }\n  }\n\n  // for(int i = 0;i <= N; ++i)\n  //   for(int j = 0;j <= N; ++j)\n  //     printf(\"%d%c\", f[i][j], \" \\n\"[j == N]);\n  \n  printf(\"%lld\", (i64) f[0][0] * fac[N] % P);\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e3 + 10, MAXN = 4e6 + 1, mod = 1e9 + 7;\nint fc[MAXN + 5], ifc[MAXN + 5], n, k, dp[N][N];\nint power(int a, int b) {\n\tif (!b)\n\t\treturn 1;\n\tint rtr = power(a, b / 2);\n\tif (b % 2)\n\t\treturn 1ll * rtr * rtr % mod * a % mod;\n\treturn 1ll * rtr * rtr % mod;\n}\nvoid Pre() {\n\tfc[0] = ifc[0] = 1;\n\tfor (int i = 1; i < MAXN; i++) {\n\t\tfc[i] = 1ll * fc[i - 1] * i % mod;\n\t\tifc[i] = power(fc[i], mod - 2);\n\t}\n}\nint ch(int x, int y) {\n\treturn 1ll * fc[y] * ifc[x] % mod * ifc[y - x] % mod;\n}\nint main() {\n\tPre();\n\tcin >> n >> k;\n\tif (k == 1) {\n\t\tcout << 1;\n\t\treturn 0;\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j <= n; j++) {\n//\t\t\tcout << \"i = \" << i << \" j = \" << j << endl;\n\t\t\tif (j > i)\n\t\t\t\tcontinue;\n\t\t\tif (i)\n\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\tif (j) {\n//\t\t\t\tcout << \" : \" << k - 2 << \", \" << n * k - (j - 1) * (k - 1) - i << endl;\n\t\t\t\tdp[i][j] = (dp[i][j] + 1ll * dp[i][j - 1] * ch(k - 2, n * k - (j - 1) * (k - 1) - i - 1) % mod) % mod;\n\t\t\t}\n//\t\t\tcout << dp[i][j] << endl;\n\t\t}\n\t}\n\tcout << 1ll * dp[n][n] * fc[n] % mod;\n\treturn 0;\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2005;\nconst int mod = 1000000007;\nint n, m;\nlong long fact[N * N], invfact[N * N], dp[N][N];\nlong long C(int x, int y) {\n\tif (x < y) return 0;\n\treturn fact[x] * invfact[y] % mod * invfact[x - y] % mod;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tif (m == 1) {puts(\"1\"); return 0;}\n\tinvfact[1] = 1;\n\tfor (int i = 2; i <= n * m; i++)\n\t\tinvfact[i] = (mod - mod / i) * invfact[mod % i] % mod;\n\tfact[0] = invfact[0] = 1;\n\tfor (int i = 1; i <= n * m; i++)\n\t\tfact[i] = fact[i - 1] * i % mod, invfact[i] = invfact[i - 1] * invfact[i] % mod;\n\tdp[0][0] = 1;\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = i; j <= n; j++) {\n\t\t\tif (!i && !j) continue;\n\t\t\tif (i) dp[i][j] = dp[i - 1][j];\n\t\t\telse dp[i][j] = 0;\n\t\t\tif (j) dp[i][j] = (dp[i][j] + dp[i][j - 1] * C(i + j * (m - 1) - 1, m - 2)) % mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[n][n] * fact[n] % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF=1000000000,mod=1e9+7;\nconst double eps = 1e-7;\n\nint f[2001][2001],c[5000000],inv[5000000];\n\n\nint main()\n{\n//\tfreopen(\"input.txt\",\"r\",stdin);\n\tint t;\n\tint n,m,q;\n//\tcin>>t;\n//\twhile(t--)\n//\twhile(scanf(\"%d\",&n)!=EOF) \n\t{\n\t\tcin>>n>>m;\n\t\tf[0][0]=1;\n\t\tf[0][1]=1;\n\t\tc[m-2]=1;\n\t\tinv[1]=1;\n\t\tfor(int i=2;i<=n*m;i++)\n\t\t\tinv[i]=(long long)inv[mod%i]*(mod-mod/i)%mod;\n\t\tfor(int i=m-1;i<=n*m;i++)\n\t\t\tc[i]=(long long)c[i-1]*i%mod*inv[i-m+2]%mod;\n\t\tfor(int i=2;i<=n;i++)\n\t\t\tf[0][i]=(long long)f[0][i-1]*c[i*(m-1)-1]%mod;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=i;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tf[i][j]=f[i-1][j];\n\t\t\t\telse\n\t\t\t\t\tf[i][j]=(f[i-1][j]+(long long)f[i][j-1]*c[i*m+(j-i)*(m-1)-1]%mod)%mod;\n\t\t\t}\n//\t\tfor(int i=1;i<=n;i++)\n//\t\t\tfor(int j=i;j<=n;j++)\n//\t\t\t\tcout<<i<<' '<<j<<' '<<f[i][j]<<endl;\n\t\tlong long ans=f[n][n];\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tans=ans*i%mod;\n\t\tcout<<ans<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,s,t) for (int i=s;i<=t;++i)\n#define fi first\n#define se second\nconst int maxn=4e6+10;\nconst int mod=1e9+7;\ntypedef long long ll;\nusing namespace std;\nll quick_mod(ll x,ll y){\n    ll ans=1;\n    for (;y;y>>=1){\n        if (y&1) ans=ans*x%mod;\n        x=x*x%mod;\n    }\n    return ans;\n}\nll fac[maxn],inv[maxn],ans;\nll dp[2010][2010];\nvoid init(){\n    fac[0]=1;\n    rep(i,1,maxn-10) fac[i]=fac[i-1]*i%mod;\n    inv[maxn-10]=quick_mod(fac[maxn-10],mod-2);\n    for (int i=maxn-11;i>=0;--i){\n        inv[i]=inv[i+1]*(i+1)%mod;\n    }\n}\nll c(int n,int m){\n    return fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main()\n{\n    init();\n    int n,k; scanf(\"%d%d\",&n,&k);\n    if (k==1) return 0*puts(\"1\");\n    dp[0][0]=1;\n    rep(i,0,n){\n        rep(j,0,n){\n            if (i) (dp[i][j]+=dp[i-1][j])%=mod;\n            if (j>i) (dp[i][j]+=dp[i][j-1]*c(i+j*(k-1)-1,k-2)%mod)%=mod;\n        }\n    }\n    printf(\"%lld\\n\",fac[n]*dp[n][n]%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define IL inline\n#define RG register\n#define LL long long\n#define Upd(a) (a)>=mod?(a-=mod):1\nusing namespace std;\ntemplate <class T>\nIL char gc () {\n\tstatic char buf[1<<6], *p1=buf, *p2=buf;\n\treturn (p1==p2) && (p2=(p1=buf)+fread(buf,1,1<<6,stdin), p1==p2) ?EOF:*p1++;\n}\ntemplate <typename T>\nIL void read (T&data) {\n\tdata=0;\n\tRG char ch=0;\n\twhile (ch<'0' || ch>'9') ch=getchar();\n\twhile (ch<='9' && ch>='0') data=(data<<1)+(data<<3)+(ch&15), ch=getchar();\n}\nconst int mod = 1e9+7;\nconst int _ =2001;\nint n, k;\nint dp[2][_], jc[_*_], jcn[_*_];\nIL int poww (RG int a, RG int b) {\n\tRG int ret=1, Base=a;\n\tfor (;b;b>>=1, Base=1LL*Base*Base%mod) if (b&1) ret=1LL*ret*Base%mod;\n\treturn ret;\n}\nIL int C (RG int a, RG int b) {\n\tif (a<b) return 0;\n\treturn 1LL*jc[a]*jcn[b]%mod*jcn[a-b]%mod;\n}\nint main () {\n\tread(n), read(k);\n\tif (k<=1) {puts(\"1\"); return 0;}\n\tjc[0]=jcn[0]=1;\n\tRG int i, j, pre=1, cur=0;\n\tfor (i=1; i<=n*k; ++i) jc[i]=1LL*jc[i-1]*i%mod, jcn[i]=poww(jc[i], mod-2);\n\tdp[0][0]=1;\n\tfor (i=1; i<=n*2; ++i) {\n\t\tswap(cur, pre);\n\t\tfor (j=0; j<min(i,n+1); ++j) dp[cur][j]=0;\n\t\tfor (j=1; j<=min(i,n); ++j) {\n\t\t\tif ((i-j)%2) continue;\n\t\t\tif (n*2-i+1<j) break;\n\t\t\tRG int a=(i+j-2)>>1, b=(i-j)>>1;\n\t\t\tdp[cur][j]=1LL*dp[pre][j-1]*C(a*(k-1)+b+k-1-1,k-1-1)%mod;\n\t\t\tdp[cur][j]+=dp[pre][j+1];\n\t\t\tUpd(dp[cur][j]);\n\t\t}\n\t\tif (cur%2==0) dp[cur][0]=dp[pre][1];\n\t}\n\tprintf(\"%lld\",1LL*dp[cur][0]*jc[n]%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n    Author: zxy_hhhh\n    date: 2020/03/12\n*/\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<set>\n#include<vector>\n#include<map>\n#include<queue>\n#include<iostream>\n#define ll long long\ninline ll rd() {\n    ll _x=0;int _ch=getchar(),_f=1;\n    for(;!isdigit(_ch)&&(_ch!='-')&&(_ch!=EOF);_ch=getchar());\n    if (_ch=='-'){_f=0;_ch=getchar();}\n    for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0';\n    return _f?_x:-_x;\n}\nvoid write(ll _x){if (_x>=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); }\ninline void wrt(ll _x,char _p){if (_x<0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);}\n#define maxn 2005\n#define mod 1000000007\nint n,K;\nint f[maxn][maxn];\nint fac[maxn*maxn],inv[maxn*maxn];\ninline int C(int n,int m) {return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint main() {\n    n=rd();K=rd();\n    if (K==1) {\n        wrt(1,'\\n');\n        return 0;\n    }\n    fac[0]=fac[1]=inv[0]=inv[1]=1;\n    for(int i=2;i<=n*K;i++) {\n        fac[i]=1ll*fac[i-1]*i%mod;\n        inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n    }\n    for(int i=1;i<=n*K;i++) {\n        inv[i]=1ll*inv[i-1]*inv[i]%mod;\n    }\n    f[0][0]=1;\n    for(int i=1;i<=n;i++) {\n        for(int j=0;j<=i;j++) {\n            f[i][j]=(f[i-1][j]+(j>0?1ll*f[i][j-1]*C(n*K-i-(j-1)*(K-1)-1,K-2)%mod*(n-j+1):0))%mod;\n        }\n    }\n    wrt(f[n][n],'\\n');\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7;\nint n,m;\nll F[4000005],inv[4000005],f[2005][2005];\nll quick_pow(ll a,ll b){\n\tll ans=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1) ans=ans*a%mod;\n\treturn ans;\n}\nll C(ll n,ll m){\n\treturn F[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tif(m==1) return puts(\"1\"),0;\n\tF[0]=inv[0]=1;\n\tfor(int i=1;i<=n*m;i++) F[i]=F[i-1]*i%mod,inv[i]=quick_pow(F[i],mod-2);\n\tf[0][0]=1; \n\tint len=n*m;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int p=0;p<=i;p++){\n\t\t\tif(!i&&!p) continue;\n\t\t\tif(i) f[i][p]=f[i-1][p];\n\t\t\tif(p) f[i][p]=(f[i][p]+f[i][p-1]*C(len-(p-1)*(m-1)-i-1,m-2))%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\",f[n][n]*F[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nconst int MOD(1000000007);\nint n, k;\nint fac[4000000], inv_fac[4000000], dp[2001];\n\n\nint Power(long long a, int b)\n{\n\tlong long ret(1ll);\n\t\n\twhile (b) {\n\t\tb & 1 && (ret *= a);\n\t\tret >= MOD && (ret %= MOD);\n\t\ta *= a;\n\t\ta >= MOD && (a %= MOD);\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\n\n\nint main()\n{\n\tregister long long lt;\n\tint t;\n\t\n\tscanf(\"%d%d\", &n, &k);\n\tif (k == 1) {\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tfac[0] = 1;\n\tt = n * k;\n\tfor (int i = 1; i < t; ++i) {\n\t\tlt = (long long)i * fac[i - 1];\n\t\tfac[i] = lt < MOD ? lt : lt % MOD; \n\t}\n\tinv_fac[t - 1] = Power((long long)fac[t - 1], MOD - 2);\n\tfor (int i = t - 2; i; --i) {\n\t\tlt = (long long)(i + 1) * inv_fac[i + 1];\n\t\tinv_fac[i] = lt < MOD ? lt : lt % MOD;\n\t}\n\tinv_fac[0] = 1;\n\tdp[0] = 1;\n\tt = -2;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tt += k - 1;\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\t++t;\n\t\t\tlt = (long long)fac[t] * inv_fac[t - k + 2];\n\t\t\tlt >= MOD && (lt %= MOD);\n\t\t\tlt *= (long long)inv_fac[k - 2];\n\t\t\tlt >= MOD && (lt %= MOD);\n\t\t\tlt *= (long long)dp[j];\n\t\t\tj && (lt += dp[j - 1]);\n\t\t\tdp[j] = lt < MOD ? lt : lt % MOD;\n\t\t}\n\t\tt -= i + 1;\n\t}\n\tlt = (long long)dp[n] * fac[n] % MOD;\n\tprintf(\"%lld\\n\", lt);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\nll p = 1e9 + 7;\nll fac[4000010];\nll ifac[4000010];\nll inv[4000010];\nvoid init(int n) {\n    int i;\n    fac[0] = fac[1] = ifac[0] = ifac[1] = inv[0] = inv[1] = 1;\n    for(i = 2; i <= n; i++) {\n        inv[i] = -(p / i) * inv[p % i] % p;\n        fac[i] = fac[i - 1] * i % p;\n        ifac[i] = ifac[i - 1] * inv[i] % p;\n    }\n}\n\nll c(int x, int y) {\n    if(x < y)\n        return 0;\n    return fac[x] * ifac[y] % p * ifac[x - y] % p;\n}\n\nll f[2010][2010];\nint main() {\n    int n, k;\n    scanf(\"%d%d\", &n, &k);\n    if(k <= 1) {\n        printf(\"1\\n\");\n        return 0;\n    }\n    init(n * k);\n    int i, j;\n    f[0][0] = 1;\n    for(i = 1; i <= n; i++)\n        for(j = n; j >= 0; j--) {\n            if(j <= i)\n                f[i][j] += f[i - 1][j - 1] * c(k * i - j - 1, k - 2) % p;\n            f[i][j] = (f[i][j] + f[i][j + 1]) % p;\n        }\n    ll ans = (f[n][0] % p + p) % p;\n    ans = ans * fac[n] % p;\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define N ((ll)2010)\n#define MOD ((ll)1e9+7)\nll tavan(ll x,ll y){ll res=1;while(y){res*=y%2?x:1;res%=MOD;x*=x;x%=MOD;y/=2;}return res;}\n\nll n,k,fac[N*N],rfac[N*N],dp[N][N];\n\nll C(ll x,ll y){return (fac[x]*((rfac[y]*rfac[x-y])%MOD))%MOD;}\n\nint main()\n{\n\tcin>>n>>k;\n\tif(k==1)return cout<<1,0;\n\tfac[0]=rfac[0]=1;\n\tfor(ll i=1;i<N*N;i++)fac[i]=(fac[i-1]*i)%MOD,rfac[i]=tavan(fac[i],MOD-2);\n\tdp[0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=i;j<=n;j++)\n\t\t{\n\t\t\tif(i)dp[i][j]=dp[i-1][j];\n\t\t\tif(j>i)dp[i][j]+=dp[i][j-1]*C(j*(k-1)+i-1,k-2);\n\t\t\tdp[i][j]%=MOD;\n\t\t}\n\tcout<<(dp[n][n]*fac[n])%MOD;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define rg register\nusing namespace std;\ntypedef long long ll;\nconst int maxn=4100000,mod=1e9+7;\ntemplate <typename Tp> inline int getmin(Tp &x,Tp y){return y<x?x=y,1:0;}\ntemplate <typename Tp> inline int getmax(Tp &x,Tp y){return y>x?x=y,1:0;}\ntemplate <typename Tp> inline void read(Tp &x)\n{\n    x=0;int f=0;char ch=getchar();\n    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n    if(ch=='-') f=1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    if(f) x=-x;\n}\nint n,k,f[2010][2010],fac[maxn],inv[maxn];\ninline int pls(int x,int y){return x+y>=mod?x+y-mod:x+y;}\nint c(int n,int m){return m>n?0:(ll)fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint power(int x,int y)\n{\n\tint res=1;\n\tfor(;y;y>>=1,x=(ll)x*x%mod)\n\t  if(y&1)\n\t    res=(ll)res*x%mod;\n\treturn res;\n}\nint init(int n)\n{\n\tfac[0]=1;\n\tfor(rg int i=1;i<=n;i++) fac[i]=(ll)fac[i-1]*i%mod;\n\tinv[n]=power(fac[n],mod-2);\n\tfor(rg int i=n-1;~i;i--) inv[i]=(ll)inv[i+1]*(i+1)%mod;\n}\nint main()\n{\n\tread(n);read(k);\n\tif(k==1){puts(\"1\");return 0;}\n\tinit(n*k+k+k);\n\tf[0][0]=1;\n\tfor(rg int i=0;i<=n;i++)\n\t  for(rg int j=i;j<=n;j++)\n\t  {\n\t  \tif(i) f[i][j]=f[i-1][j];\n\t  \tif(j) f[i][j]=pls(f[i][j],(ll)f[i][j-1]*c(i+(j-1)*(k-1)+k-2,k-2)%mod);;\n\t  }\n\tprintf(\"%lld\\n\",(ll)f[n][n]*fac[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inv(x) power(x,Mod-2)\n#define upd(a,b) a=add(a,b)\nusing namespace std;\ntypedef long long ll;\nconst int Mod=1e9+7;\nint add(int a,const int b){a+=b;if(a>=Mod)a-=Mod;return a;}\nint sub(int a,const int b){a-=b;if(a<0)a+=Mod;return a;}\nint mul(const int a,const int b){return (ll)a*b%Mod;}\nint power(int x,int cs)\n{\n\tint ras=1;\n\twhile(cs)\n\t{\n\t\tif(cs&1) ras=mul(ras,x);\n\t\tx=mul(x,x);cs>>=1;\n\t}\n\treturn ras;\n}\nconst int N=2020;\nint n,K,tot,ans=0;\nint dp[N][N],sum[N],zp[N*N],fp[N*N];\nint C(int a,int b)\n{\n\tif(a<0||b<0||a<b) return 0;\n\treturn mul(zp[a],mul(fp[b],fp[a-b]));\n}\nint main()\n{\n\tint i,j;\n\tscanf(\"%d%d\",&n,&K);\n\tif(K==1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\ttot=n*K;\n\tzp[0]=fp[0]=1;\n\tfor(i=1;i<=tot;i++) zp[i]=mul(zp[i-1],i);\n\tfp[tot]=inv(zp[tot]);\n\tfor(i=tot-1;i>=1;i--) fp[i]=mul(fp[i+1],i+1);\n\tdp[1][0]=1;\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tmemset(sum,0,sizeof(sum));\n\t\tfor(j=0;j<=i;j++)\n\t\t{\n\t\t\tif(j>0) sum[j]=sum[j-1];\n\t\t\tupd(sum[j],dp[i-1][j]);\n\t\t}\n\t\tfor(j=0;j<i;j++)\n\t\t{\n\t\t\tupd(dp[i][j],mul(sum[j],C(i*(K-1)+j-1,K-2)));\n\t\t}\n\t}\n\tfor(i=0;i<=n;i++) upd(ans,dp[n][i]);\n\tans=mul(ans,zp[n]);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\t\n\tchar buf[bufl],*s=buf,*t=buf;\n\t\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\t\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 2007 , __ = _*_ , mo = 1000000007;\n\ninline lint powa(lint a,lint t)\n{\n\tlint b=1;\n\twhile(t){if(t&1)b=b*a%mo;a=a*a%mo,t>>=1;}\n\treturn b;\n}\n\ninline lint inva(lint a)\n{\n\treturn powa(a,mo-2);\n}\n\nlint jc[__],rjc[__];\n\ninline void fuck(int n=__-1)\n{\n\tjc[0]=jc[1]=rjc[0]=1;\n\tfor(int i=2;i<=n;i++)jc[i]=jc[i-1]*i%mo;\n\trjc[n]=inva(jc[n]);\n\tfor(int i=n-1;i>=1;i--)rjc[i]=rjc[i+1]*(1ll+i)%mo;\n}\n\ninline lint C(int n,int m)\n{\n\treturn jc[n]*rjc[m]%mo*rjc[n-m]%mo;\n}\n\nint n,m;\nlint f[_][_]={0};\n\nint main()\n{\n\tn=ty(),m=ty();\n\tif(m<=1){puts(\"1\");return 0;}\n\n\tfuck();\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(j>0)f[i][j]=(f[i][j]+f[i][j-1]*(n-j+1)%mo*C(n*m-i-(j-1)*(m-1)-1,m-2)%mo)%mo;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[n][n]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nint n,k,dp[2001][2001],fac[4000001],ifac[4000001];const int p=1e9+7;\ninline int qpow(int bs,int ex){int ans=1;while(ex){if(ex&1)ans=1ll*ans*bs%p;bs=1ll*bs*bs%p;ex>>=1;}return ans;}\ninline int binom(int n,int m){return 1ll*fac[n]*ifac[m]%p*ifac[n-m]%p;}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);if(k==1){putchar(49);putchar(10);return 0;}\n\tfac[0]=1;for(int i=1;i<=n*k;++i)fac[i]=1ll*fac[i-1]*i%p;ifac[n*k]=qpow(fac[n*k],p-2);for(int i=n*k-1;~i;--i)ifac[i]=1ll*ifac[i+1]*(i+1)%p;\n\tfor(int i=0;i<=n;++i)dp[i][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=i;++j)\n\t\t{\n\t\t\t(dp[i][j]+=dp[i-1][j])%=p;\n\t\t\t(dp[i][j]+=1ll*dp[i][j-1]*(n-j+1)%p*binom(n*k-i-1-(j-1)*(k-1),k-2)%p)%=p;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[n][n]);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int unsigned long long\nusing namespace std;\nconst int maxn=8000005;\nconst int mod=1e9+7;\nint n,k,jc[maxn],inv[maxn],f[2005][2005];\nint poww(int x,int y){\n    int res=1; \n    while(y){\n        if(y&1){\n        \tres=res*x%mod;\n        }\n        x=x*x%mod;\n        y>>=1;\n    }\n    return res;\n}\nint C(int n,int k){\n    return ((jc[n]*inv[k]%mod)*inv[n-k])%mod;\n}\nsigned main(){\n    jc[0]=1;\n    for(int i=1;i<maxn;i++){\n    \tjc[i]=jc[i-1]*i%mod;\n    } \n    inv[maxn-1]=poww(jc[maxn-1],mod-2);\n    for(int i=maxn-2;i>0;i--){\n    \tinv[i]=(inv[i+1]*(i+1))%mod;\n    } \n    inv[0]=1;\n    cin>>n>>k;\n    if(k==1){\n    \tcout<<'1';\n    \treturn 0;\n    }\n    f[0][0]=1;\n    for(int i=1;i<=n;i++){\n    \tfor(int j=0;j<=i;j++){\n    \t\tf[i][j]=f[i-1][j];\n            if(!j) continue;\n    \t\tf[i][j]=f[i-1][j]+(((f[i][j-1]*(n-j+1))%mod)*C(n*k-i-(j-1)*(k-1)-1,k-2)%mod)%mod;\n    \t}\n            \n    }\n    cout<<f[n][n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MAXN 2010\n#define mod 1000000007\n\nint n,k,fac[MAXN*MAXN],inv[MAXN*MAXN],f[MAXN][MAXN];\n\nint qpow(int a,int b)\n{\n\tint res=1;\n\twhile(b)\n\t{\n\t\tif(b&1)res=(long long)res*a%mod;\n\t\ta=(long long)a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nint c(int n,int m)\n{\n\tif(n<0 || n<m)return 0;\n\treturn (long long)fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=n*k;++i)fac[i]=(long long)fac[i-1]*i%mod;\n\tinv[n*k]=qpow(fac[n*k],mod-2);\n\tfor(int i=n*k-1;i>=1;--i)inv[i]=(long long)inv[i+1]*(i+1)%mod;\n\tf[0][0]=1;\n\tfor(int i=0;i<=n;++i)\n\t\tfor(int j=i;j>=0;--j)\n\t\t{\n\t\t\tf[i+1][j+1]=(f[i+1][j+1]+(long long)f[i][j]*c(i*k-j+k-2,k-2)%mod)%mod;\n\t\t\tif(j)f[i][j-1]=(f[i][j-1]+f[i][j])%mod;\n\t\t}\n\tprintf(\"%lld\\n\",(long long)f[n][0]*fac[n]%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint ze,h[1000],hh,use[1000],ans,c,a,b;\nvoid gen(int lv)\n{\n\tif(lv==c)\n\t{\n\t\t/*for(int i=0;i<lv;i++)\n\t\t{\n\t\t\tprintf(\"%d \",use[i]);\n\t\t}\n\t\tprintf(\"\\n\");*/\n\t\tans++;\n\t\tans%=(long long)(1e9+7);\n\t}\n\telse\n\t{\n\t\tfor(int i=0;i<=a;i++)\n\t\t{\n\t\t\tif((lv+2)/2>ze&&i!=0)continue;\n\t\t\tif(hh==ze&&h[i]==0&&i!=0)continue;\n\t\t\tif(h[i]==b-1&&i!=0)continue;\n\t\t\tif(i==0&&h[i]==b)continue;\n\t\t\tuse[lv]=i;\n\t\t\th[i]++;\n\t\t\tif(h[i]==1&&i!=0)hh++;\n\t\t\tif(i==0)ze++;\n\t\t\tgen(lv+1);\n\t\t\tif(h[i]==1&&i!=0)hh--;\n\t\t\tif(i==0)ze--;\n\t\t\th[i]--;\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d %d\",&a,&b);\n\tc=a*b;\n\tgen(0);\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\ntypedef long long ll;\nll mod=1e9+7;\nll dp[2001][2001];\nconst int M=2000*2000;\nll f[M],g[M],inv[M];\nvoid precalc(){\n\tf[0]=1;\n\trep1(i,M) f[i]=f[i-1]*i%mod;\n\tinv[1]=1;\n\tfor(int i=2;i<=M;i++) inv[i]=mod-mod/i*inv[mod%i]%mod;\n\tg[0]=1;\n\trep1(i,M) g[i]=g[i-1]*inv[i]%mod;\n}\nll C(int x,int y){\n\treturn f[x]*g[y]%mod*g[x-y]%mod;\n}\nvoid add(ll &x,ll y){\n\tx+=y;\n\tx%=mod;\n}\nint main(){\n\tif(N==2&&K==2){\n\t\tputs(\"4\");\n\t\treturn 0;\n\t}\n\tprecalc();\n\tint N,K;\n\tcin>>N>>K;\n\tif(K==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tdp[1][0]=1;\n\trep1(i,N) rep(j,i+1){\n//\t\tprintf(\"dp[%d][%d]=%lld\\n\",i,j,dp[i][j]);\n\t\tif(i!=N) add(dp[i+1][j],dp[i][j]);\n\t\tif(j!=i){\n\t\t\tint left=N*K-i-j*(K-1)-1;\n\t\t\tadd(dp[i][j+1],dp[i][j]*C(left,K-2));\n\t\t}\n\t}\n\tll ans=dp[N][N];\n\trep1(i,N) ans=ans*i%mod;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll fac[4000005],ifac[4000005],inv[4000005],p=1e9+7;\nvoid ycl(int n){\n\tfac[1]=fac[0]=ifac[0]=ifac[1]=inv[0]=inv[1]=1;\n\tfor (int i=2;i<=n;i++){\n\t\tinv[i]=(p-p/i)*inv[p%i]%p;\n\t\tfac[i]=fac[i-1]*i%p;\n\t\tifac[i]=ifac[i-1]*inv[i]%p;\n\t}\n}\nll C(int n,int m){\n\tif (n<m) return 0;\n\treturn ((fac[n]*ifac[m])%p*ifac[n-m])%p;\n}\nll f[2005][2005];\nint main(){\n\tint n,k;\n\tscanf(\"%d%d\",&n,&k);\n\tif (k<=1){printf(\"1\\n\"); return 0;}\n\tycl(n*k);\n\tf[0][0]=1;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=n;j>=0;j--){\n\t\t\tif (j<=i) f[i][j]=(f[i][j]+f[i-1][j-1]*C(i*k-j-1,k-2))%p;\n\t\t\tf[i][j]=(f[i][j]+f[i][j+1])%p;\n\t\t}\n\t}\n\tll ans=f[n][0];\n\tans=ans*fac[n]%p;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1000000007;\nint fac[4040404];\nint ifac[4040404];\nint dp[2020][2020];\nint C(int n,int m)\n{\n\tif(n<m)\n\t\treturn 0;\n\treturn (long long)fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\nint main()\n{\n\tint n,k,h;\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1)\n\t{\n\t\tprintf(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\th=n*k;\n\tk--;\n\tfor(int i=1;i<=h;i++)\n\t\tfac[i]=(long long)fac[i-1]*i%mod;\n\tifac[0]=ifac[1]=1;\n\tfor(int i=2;i<=h;i++)\n\t\tifac[i]=(long long)(mod-mod/i)*ifac[mod%i]%mod;\n\tfor(int i=2;i<=h;i++)\n\t\tifac[i]=(long long)ifac[i-1]*ifac[i]%mod;\n\tmemset(dp,0,sizeof(dp));\n\tdp[0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=max(i,1);j<=n;j++)\n\t\t{\n\t\t\tif(i)\n\t\t\t\t(dp[i][j]+=dp[i-1][j])%=mod;\n\t\t\t(dp[i][j]+=(long long)dp[i][j-1]*C(i+j*k-1,k-1)%mod)%mod;\n\t\t}\n\tprintf(\"%d\",(long long)dp[n][n]*fac[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std ;\n#define int unsigned long long\nconst int mxn = 8000005 ;\nconst int Mod = 1e9+7 ;\nint frac[mxn], inv[mxn];\nint f[2005][2005], n, k;\n/*\n设f(i,j)表示在这些位置上已经放了i个白球，j种其他颜色的球。(i<j)\nf(i,j) = f(i-1, j)+f(i ,j-1)*(n-j+1)*C(k-2, n*k-i-(j-1)*(k-1)-1)\n*/\nint power(int a, int b){\n\tint res=1, car=a; \n\twhile(b){\n\t\tif(b&1) (res*=car)%=Mod;\n\t\t(car*=car)%=Mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nvoid init(){\n\tfrac[0]=1 ;\n\tfor(int i=1;i<mxn;++i) (frac[i]=frac[i-1]*i)%=Mod ;\n\tinv[mxn-1] = power(frac[mxn-1], Mod-2);\n\tfor(int i=mxn-2;i>0;--i) inv[i]=(inv[i+1]*(i+1))%Mod ;\n\tinv[0] = 1 ;\n}\nint C(int n, int k){\n\treturn ((frac[n]*inv[k]%Mod)*inv[n-k])%Mod ;\n}\nsigned main(){\n\tinit() ;\n\tcin>>n>>k;\n\tif(k==1) return puts(\"1\") ;\n\tf[0][0] = 1 ;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<=i;++j)\n\t\t\t(f[i][j] = f[i-1][j]+(j?((((f[i][j-1]*(n-j+1))%Mod)*C(n*k-i-(j-1)*(k-1)-1, k-2))%Mod):(0)))%=Mod ;\n\tcout<<f[n][n]<<endl ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int mod=1e9+7;\nlong long f[4000010],inv[4000010],dp[2010][2010];\nint n,K;\nint ADD(int x)\n{\n\treturn (x>=mod)?x-mod:x;\n}\nlong long calc(long long a,long long b,long long mod)\n{\n\tlong long ans=1,t=a;\n\tfor (;b;b>>=1)\n\t{\n\t\tif (b&1) ans=ans*t%mod;\n\t\tt=t*t%mod;\n\t}\n\treturn ans;\n}\nlong long C(int n,int m)\n{\n\treturn f[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&K);\n\tif (K==1)\n\t{\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tf[0]=1;\n\tfor (int i=1;i<=n*K;i++) f[i]=f[i-1]*i%mod;\n\tinv[n*K]=calc(f[n*K],mod-2,mod);\n\tinv[0]=1;\n\tfor (int i=n*K-1;i>=1;i--) inv[i]=inv[i+1]*(i+1);\n\tdp[0][0]=1;\n\tfor (int i=0;i<=n;i++)\n\t\tfor (int j=0;j<=i;j++)\n\t\t{\n\t\t\tif (i!=0) dp[i][j]=dp[i-1][j];\n\t\t\tif (j!=0) dp[i][j]=ADD(dp[i][j]+dp[i][j-1]*C(n*K-i-(j-1)*(K-1)-1,K-2)%mod);\n\t\t}\n\tprintf(\"%lld\\n\",dp[n][n]*f[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, x, y) for (int i = x; i <= y; i++)\nusing namespace std;\n\nconst int N = 2e3 + 10, mod = 1e9 + 7;\ntypedef long long ll;\nll n, K;\nll fac[N * N], f[N][N], inv[N * N];\n\nll quick_pow(ll a, ll b) {\n    ll ret = 1;\n    for (; b; b >>= 1) {\n        if (b & 1) ret = ret * a % mod;\n        a = a * a % mod;\n    } return ret;\n}\n\nvoid pre() {\n    fac[0] = inv[0] = 1;\n    rep(i, 1, n * K) fac[i] = fac[i - 1] * i % mod;\n    inv[n * K] = quick_pow(fac[n * n], mod - 2);\n    for (int i = n * K - 1; i >= 1; i--) inv[i] = inv[i + 1] * (i + 1) % mod;\n}\n\nll C(ll n, ll m) { return fac[n] * inv[m] % mod * inv[n - m] % mod; }\n\nll upd(ll x, ll y) { return (x + y) % mod; }\n\nint main() {\n    cin >> n >> K;\n    if (K == 1) { puts(\"1\"); return 0; }\n    pre();\n    rep(i, 1, n) f[i][0] = 1;\n    rep(i, 1, n)\n        rep(j, 1, i) {\n            f[i][j] = upd(f[i - 1][j], (n - j + 1) * f[i][j - 1] % mod * C((n - j + 1) * (K - 1) + n - i - 1, K - 2) % mod);\n        }\n    printf(\"%lld\\n\", f[n][n]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#define RG register\n#define LL long long\nusing namespace std;\nconst int N=2e3+10;\nconst LL mod=1e9+7;\nint n,k,maxx;\nLL inv[N*N]={0,1},fac1[N*N]={1},fac2[N*N]={1},dp[N][N];\nLL C(int nn,int mm){return fac1[nn]*fac2[mm]%mod*fac2[nn-mm]%mod;}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&k); maxx=n*k;\n\tif(k==1)\n\t{\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tfor(RG int i=1;i<=maxx;i++) fac1[i]=fac1[i-1]*i%mod;\n\tfor(RG int i=2;i<=maxx;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\tfor(RG int i=1;i<=maxx;i++) fac2[i]=fac2[i-1]*inv[i]%mod;\n\tdp[0][0]=1;\n\tfor(RG int i=1;i<=n;i++)\n\t for(RG int j=0;j<=i;j++)//\n\t  dp[i][j]=(dp[i-1][j]+(j!=0)*C(n-i+(n-j+1)*(k-1)-1,k-2)*dp[i][j-1]%mod*(n-j+1)%mod)%mod;\n\tprintf(\"%lld\",dp[n][n]);\n\t//fclose(stdin); fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n\n#define fast ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define files(name) name!=\"\"?freopen(name\".in\",\"r\",stdin),freopen(name\".out\",\"w\",stdout):0\n#define all(a) a.begin(),a.end()\n#define len(a) (int)(a.size())\n#define elif else if\n#define mp make_pair\n#define pb push_back\n#define fir first\n#define sec second\n\nusing namespace std;\n#define int long long\n\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long double ld;\ntypedef long long ll;\n\nconst int arr=2e5+10;\nconst int ar=2e3+10;\nconst ld pi=acos(-1);\nconst ld eps=1e-10;\nconst ll md=1e9+7;\n\n///---program start---///\n\n#define arr (int)(1e7+10)\n\nint bpow(int a,int n)\n{\n    int res=1;\n    while (n){\n        if (n&1){\n            res=res*a%md;\n        }\n        n/=2;\n        a=a*a%md;\n    }\n    return res;\n}\n\nvoid inc(int& a,int b)\n{\n    a+=b;\n    if (a>=md){\n        a-=md;\n    }\n}\n\nint f[arr];\nint rf[arr];\n\nint C(int n,int k)\n{\n    return f[n]*rf[k]%md*rf[n-k]%md;\n}\n\nint H(int n,int m)\n{\n    return C(n+m,n);\n}\n\nint dp[ar][ar];\n\nmain()\n{\n    #ifdef Barik\n        files(\"barik\");\n        freopen(\"debug.txt\",\"w\",stderr);\n    #endif\n\n    f[0]=1;\n    for (int i=1;i<arr;i++){\n        f[i]=f[i-1]*i%md;\n    }\n    rf[arr-1]=bpow(f[arr-1],md-2);\n    for (int i=arr-2;i>=0;i--){\n        rf[i]=rf[i+1]*(i+1)%md;\n    }\n\n    int n,k;\n    cin>>n>>k;\n    if (k==1){\n        cout<<1<<\"\\n\";\n        return 0;\n    }\n    dp[0][0]=1;\n    for (int i=0;i<=n;i++){\n        for (int j=0;j<=n;j++){\n            if (i!=0){\n                inc(dp[i][j],dp[i-1][j]);\n            }\n            if (i<j){\n                inc(dp[i][j],dp[i][j-1]*H(k-2,(j-i-1)*(k-1)+i*(k))%md);\n            }\n//            cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<\"\\n\";\n        }\n    }\n    int ans=dp[n][n]*f[n]%md;\n    cout<<ans<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAXN 2000\n#define MAXM 4000000\n#define MO 1000000007\nint dp[MAXN+5][MAXN+5],n,k;\nint fac[MAXM+5],inv[MAXM+5];\nint PowMod(int a,int b)\n{\n\tint ret=1;\n\twhile(b)\n\t{\n\t\tif(b&1) ret=1LL*ret*a%MO;\n\t\ta=1LL*a*a%MO;\n\t\tb>>=1;\n\t}\n\treturn ret;\n}\nint C(int n,int m)\n{\n\treturn 1LL*fac[n]*inv[m]%MO*inv[n-m]%MO;\n}\nint main()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=MAXM;i++)\n\t\tfac[i]=1LL*fac[i-1]*i%MO;\n\tinv[MAXM]=PowMod(fac[MAXM],MO-2);\n\tfor(int i=MAXM-1;i>=0;i--)\n\t\tinv[i]=1LL*inv[i+1]*(i+1)%MO;\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1)\n\t{\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\tif(j!=0)\n\t\t\t\tdp[i][j]+=1LL*dp[i][j-1]*C(n*k-i-(k-1)*(j-1)-1,k-2)%MO;\n\t\t\tdp[i][j]%=MO;\n\t\t}\n\tint ans=1LL*dp[n][n]*fac[n]%MO;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define RI register int\nconst int mod=1000000007,N=2005,M=4000005;\nint n,K,f[N][N],fac[M],ni[M];\nint qm(int x) {return x>=mod?x-mod:x;}\nint ksm(int x,int y) {\n\tint re=1;\n\tfor(;y;y>>=1,x=1LL*x*x%mod) if(y&1) re=1LL*re*x%mod;\n\treturn re;\n}\nvoid prework() {\n\tfac[0]=1;for(RI i=1;i<=n*K;++i) fac[i]=1LL*fac[i-1]*i%mod;\n\tni[n*K]=ksm(fac[n*K],mod-2);\n\tfor(RI i=n*K-1;i>=0;--i) ni[i]=1LL*ni[i+1]*(i+1)%mod;\n}\nint C(int d,int u) {return 1LL*fac[d]*ni[u]%mod*ni[d-u]%mod;}\nint main()\n{\n\tscanf(\"%d%d\",&n,&K);\n\tif(K==1) {puts(\"1\");return 0;}\n\tprework();--K;\n\tf[0][0]=1;\n\tfor(RI i=1;i<=n;++i) {\n\t\tfor(RI j=0;j<=i;++j) {\n\t\t\tif(j) f[i][j]=f[i][j-1];\n\t\t\tf[i][j]=qm(f[i][j]+1LL*f[i-1][j]*C(i*K+j-1,K-1)%mod);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",1LL*f[n][n]*fac[n]%mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Etavioxy\n#include<cstdio>\n#include<cctype>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#define ll long long\n#define il inline\n#define rep(i,s,t) for(register int i=(s);i<=(t);i++)\n#define rev_rep(i,s,t) for(register int i=(s);i>=(t);i--)\n#define each(i,u) for(int i=head[u];i;i=bow[i].nxt)\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\n#define pt(x) putchar(x)\nusing namespace std;\nil int ci(){\n\tregister char ch; int f=1;\n\twhile(!isdigit(ch=getchar())) f=ch=='-'?-1:1;\n\tregister int x=ch^'0';\n\twhile(isdigit(ch=getchar())) x=(x*10)+(ch^'0');\n\treturn f*x;\n}\n\nconst int mod = 1e9+7;\nenum{N=2023};\nil ll qpow(ll a,ll b){\n\tll ans= 1;\n\tfor(; b; b>>=1,a=a*a%mod) if( b&1 ){\n\t\tans= ans*a%mod;\n\t} return ans;\n}\nil ll inv(ll x){ return qpow(x,mod-2); }\nll fac[N*N],Invf[N*N];\nil void init_fac(int n){\n\tfac[0] = 1;\n\trep(i,1,n) fac[i]=fac[i-1]*i%mod;\n\tInvf[n] = inv(fac[n]);\n\trev_rep(i,n,1) Invf[i-1]=Invf[i]*i%mod;\n}\nil ll comp(ll n,ll m){\n\tif( n<m ) return 0;\n\treturn fac[n]*Invf[m]%mod*Invf[n-m]%mod;\n}\n\nll f[N][N];\nint main(){\n\tint n = ci(), k = ci();\n\tif( k==1 ){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tinit_fac(n*k);\n\tf[0][0] = 1;\n\trep(i,1,n){\n\t\tf[i][0] = f[i-1][0];\n\t\trep(j,1,i){\n\t\t\tf[i][j] = (f[i-1][j]+f[i][j-1]*(n-j+1)%mod*comp((n-i)+(n-j+1)*(k-1)-1,k-2))%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",(f[n][n]+mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\nusing namespace std;\nconst int q=1000000007;\nint n,m,a[4000010],b[4000010],f[2010][2010];\ninline L C(int n,int m)\n{\n\treturn (L)a[n]*b[m]%q*b[n-m]%q;\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//fre,jopen(\".out\",\"w\",stdout);\n\tint i,j;\n\tscanf(\"%d%d\",&n,&m);\n\tif(m==1)\n\t  {\n\t   printf(\"1\\n\");\n\t   return 0;\n\t  }\n\tb[0]=b[1]=1;\n\tfor(i=2;i<=n*m;i++)\n\t  b[i]=q-(L)q/i*b[q%i]%q;\n\ta[0]=1;\n\tfor(i=1;i<=n*m;i++)\n\t  {\n\t   a[i]=(L)a[i-1]*i%q;\n\t   b[i]=(L)b[i-1]*b[i]%q;\n\t  }\n\tf[0][0]=1;\n\tfor(i=0;i<=n;i++)\n\t  for(j=0;j<=i;j++)\n\t    {\n\t\t if(i<n)\n\t\t   f[i+1][j]=(f[i+1][j]+f[i][j])%q;\n\t\t if(j<i)\n\t\t   f[i][j+1]=(f[i][j+1]+f[i][j]*C(n*m-i-j*(m-1)-1,m-2))%q;\n\t\t}\n\tprintf(\"%d\\n\",int((L)f[n][n]*a[n]%q));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint mod = 1000000007;\nlong long f[(1<<24)], invf[(1<<24)];\n\nlong long pow2( long long a, long long st ) {\n    long long ret = 1;\n    while ( st ) {\n        if ( st&1 ) {\n            ret *= a;\n            ret %= mod;\n        }\n\n        a *= a;\n        a %= mod;\n        st /= 2;\n    }\n    return ret;\n}\n\nvoid pre () {\n    f[0] = 1;\n    invf[0] = 1;\n    for ( int i = 1; i < (1<<23) ; i ++ ) {\n        f[i] = f[i-1]*i%mod;\n        invf[i] = pow2( f[i], mod-2 );\n    }\n}\n\nint comb( int n, int k ) {\n    return f[n]*invf[k]%mod*invf[n-k]%mod;\n}\n\nint k;\n\nlong long mem[2042];\n\nlong long solve ( int cnt ) {\n    if ( cnt == 1 ) { return 1; }\n    if ( mem[cnt] ) { return mem[cnt]-1; }\n\n    long long ret = 0;\n    for ( int i = 0 ; i <= k-1 ; i ++ ) {\n\n        //cout << i << \" : \" << comb( (cnt-1)*k+i-1, i-1 ) << \"\\n\";\n        if ( i == k-1 ) {\n            //cout << i << \": \" << solve( cnt-1 )*comb( (cnt-1)*k+i-1, i ) << \"\\n\";\n            ret += solve( cnt-1 )*comb( (cnt-1)*k+i-1, i )%mod;\n            if ( ret >= mod ) { ret -= mod; }\n        }\n        else {\n            ret += solve( cnt-1 )*comb( (cnt-1)*k+i-1, i )%mod*cnt%mod;\n            if ( ret >= mod ) { ret -= mod; }\n        }\n    }\n    mem[cnt] = ret+1;\n    return ret;\n}\n\nint main () {\n    pre();\n\n    int n;\n    cin >> n >> k;\n\n    cout << solve ( n ) << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\nvoid add(int &x, int v) { x += v; if (x >= MOD) x -= MOD; }\n\nint N, K;\nint dp[4001][2001];\nint fact[4010000], inv_fact[4010000];\n\nint modpow(int x, int k) {\n  int a = 1;\n  while (k) {\n    if (k&1) a = (1LL*a*x) % MOD;\n    x = (1LL*x*x)%MOD;\n    k >>= 1;\n  }\n  return a;\n}\ninline int nCr(int n, int k) {\n  //if (k < 0 || k > n) return 0;\n  return ((1LL*((1LL*fact[n]*inv_fact[k]))%MOD)*inv_fact[n-k]) % MOD;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  fact[0] = 1;\n  for (int i=1; i<4010000; i++) fact[i] = (1LL*i*fact[i-1])%MOD;\n  rep(i, 4010000) inv_fact[i] = modpow(fact[i], MOD-2);\n  cin >> N >> K;\n  if (K == 1) {\n    cout << 1 << \"\\n\";\n    return 0;\n  }\n\n  dp[0][0] = 1;\n  rep(i, 2*N) {\n    // put ○\n    rep(j, N+1) if (i-j+1 <= j) add(dp[i+1][j], dp[i][j]);\n    // put ●\n    rep(j, N) add(dp[i+1][j+1], (1LL*dp[i][j]*nCr(i+(j+1)*(K-2), K-2))%MOD);\n  }\n  int s = dp[2*N][N];\n  for (int i=1; i<=N; i++) s = (1LL*i*s) % MOD;\n  cout << s << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid read(int &x) {\n    x=0;int f=1;char ch=getchar();\n    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-f;\n    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';x*=f;\n}\n \nvoid print(int x) {\n    if(x<0) putchar('-'),x=-x;\n    if(!x) return ;print(x/10),putchar(x%10+48);\n}\nvoid write(int x) {if(!x) putchar('0');else print(x);putchar('\\n');}\n\n#define lf double\n#define ll long long \n\nconst int maxn = 2e3+10;\nconst int maxm = maxn*maxn;\nconst int inf = 1e9;\nconst lf eps = 1e-8;\nconst int mod = 1e9+7;\n\nint add(int x,int y) {return x+y>mod?x+y-mod:x+y;}\nint del(int x,int y) {return x-y<0?x-y+mod:x-y;}\nint mul(int x,int y) {return 1ll*x*y-1ll*x*y/mod*mod;}\n\nint n,k,f[maxn][maxn],fac[maxm],ifac[maxm],inv[maxm];\n\nvoid prepare() {\n    inv[0]=inv[1]=fac[0]=ifac[0]=f[0][0]=1;\n    for(int i=2;i<maxm;i++) inv[i]=mul(mod-mod/i,inv[mod%i]);\n    for(int i=1;i<maxm;i++) fac[i]=mul(fac[i-1],i);\n    for(int i=1;i<maxm;i++) ifac[i]=mul(ifac[i-1],inv[i]);\n}\n\nint c(int nn,int mm) {return mul(fac[nn],mul(ifac[mm],ifac[nn-mm]));}\n\nint main() {\n    read(n),read(k);prepare();if(k==1) puts(\"1\"),exit(0);\n    for(int i=1;i<=n;i++)\n        for(int j=0;j<=i;j++)\n            f[i][j]=add(f[i-1][j],mul(f[i][j-1],mul(n-j+1,c(n*k-i-(k-1)*(j-1)-1,k-2))));\n    write(f[n][n]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define ld long double\n#define F first\n#define S second\n\nusing namespace :: std;\n\nconst ll maxn=2100;\nconst ll mod=1e9+7;\nconst ll inf=1e9+500;\n\n\nll dp[maxn][2*maxn];\nll par[maxn][2*maxn];\n\n\nll fac[maxn*maxn];\nll rfac[maxn*maxn];\n\nll  ent(ll n,ll k){\n\tif(k>n || k<0){\n\t\treturn 0;\n\t}\n\treturn (((fac[n]*rfac[n-k])%mod)*rfac[k])%mod;\n}\t\nll poww(ll a,ll b){\n\tll ans=1;\n\twhile(b>0){\n\t\tif(b&1){\n\t\t\tans=(ans*a)%mod;\n\t\t}\n\t\ta=(a*a)%mod;\n\t\tb=(b>>1);\n\t}\n\treturn ans;\n}\nint main(){\n\n\tfac[0]=1;\n\tfor(ll i=1;i<maxn*maxn;i++){\n\t\tfac[i]=(fac[i-1]*i)%mod;\n\t}\t\n\tfor(ll i=0;i<maxn*maxn;i++){\n\t\trfac[i]=poww(fac[i],mod-2);\n\t}\n\n\n\n\n\tll n,k;\n\tcin>>n>>k;\n\n\tif(k==1){\n\t\tcout<<1;\n\t\treturn 0;\n\t}\n\tdp[1][1]=1;\n\tpar[1][1]=1;\n\tfor(ll j=2;j<2*maxn;j++){\n\t\tpar[1][j]=par[1][j-1];\n\t}\n\tfor(ll i=2;i<=n;i++){\n\t\tfor(ll j=1;j<2*i;j++){\n\t\t\tdp[i][j]=ent(j+(k-2)*i-1,k-2)*par[i-1][j-1];\n\t\t\tpar[i][j]=(par[i][j-1]+dp[i][j])%mod;\n\t\t}\n\t\tfor(ll j=2*i;j<2*maxn;j++){\n\t\t\tpar[i][j]=par[i][j-1];\n\t\t}\n\t}\n\tcout<<(par[n][2*maxn-5]*fac[n])%mod<<endl;\n\n}\n\n\n\n\n\n\n\n\n/*    \n\t  .      _______    __    ___     ________      ________       _________     _________   ________\n\t  .     /       \\  |  |  /  /    /        \\    |        \\     /         \\   |        |  |   __   \\\n\t  .    /   _____/  |  | /  /    /    ___   \\   |   ___   \\   |   _______/   |  ______|  |  |  \\   \\\n\t  .   /   /        |  |/  /    /    /   \\   \\  |  |   \\   \\  |  (______     |  |_____   |  |__/   /\n\t  .   |  |         |     /     |   /     \\  |  |  |    |  |   \\        \\    |        |  |      __/\n\t  .   |  |         |     \\     |   \\     /  |  |  |    |  |    \\______  \\   |  ______|  |      \\\n\t  .   \\   \\_____   |  |\\  \\    \\    \\___/   /  |  |___/   /    _______) |   |  |_____   |   |\\  \\\n\t  .    \\        \\  |  | \\  \\    \\          /   |         /    /         /   |        |  |   | \\  \\\n\t  .     \\_______/  |__|  \\__\\    \\________/    |________/     \\________/    |________|  |___|  \\__\\\n */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst long long mod=1000000007ll;\n\nvoid ad(long long &a,long long b){a+=b;a%=mod;}\nvoid ml(long long &a,long long b){a*=b;a%=mod;}\n\nlong long inv[4000010],P[4000010],rP[4000010];\n\nlong long Ch(int i,int j)\n{\n  return P[i]*rP[j]%mod*rP[i-j]%mod;\n}\n\nint main()\n{\n  inv[1]=1;\n  for(int i=2;i<=2000*2000;i++){\n    inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n  }\n  P[0]=rP[0]=1;\n  for(int i=1;i<=2000*2000;i++){\n    P[i]=i*P[i-1]%mod;\n    rP[i]=inv[i]*rP[i-1]%mod;\n  }\n  int n,k;\n  scanf(\"%d%d\",&n,&k);\n  if(k==1){\n    printf(\"%lld\\n\",1);\n    return 0;\n  }\n  static long long dp[2001][2001]={0};\n  dp[0][0]=1ll;\n  for(int i=0;i<=n;i++){\n    for(int j=0;j<=i;j++){\n      if(i+1<=n){\n\tad(dp[i+1][j],dp[i][j]);\n      }\n      if(j+1<=i){\n\tad(dp[i][j+1],Ch(n*k-i-(k-1)*j-1,k-2)*dp[i][j]%mod);\n      }\n      //printf(\"%d %d %lld %d %d\\n\",i,j,dp[i][j],n*k-i-(k-2)*j-1,k-2);\n    }\n  }\n  long long A=dp[n][n];\n  for(int i=1;i<=n;i++){\n    ml(A,i);\n  }\n  printf(\"%lld\\n\",A);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN=2005,MOD=1e9+7;\nint n,k,fac[MAXN*MAXN],inv[MAXN*MAXN],dp[MAXN];\n\nll quick_pow(ll a,ll b)\n{\n\tll ret=1;\n\tfor(;b;b>>=1,a=a*a%MOD)\n\t\tif(b&1) ret=ret*a%MOD;\n\treturn ret;\n}\nll C(int a,int b)\n{if(a<b) return 0;return 1ll*fac[a]*inv[a-b]%MOD*inv[b]%MOD;}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1) return puts(\"1\"),0;\n\tfac[0]=dp[0]=1;\n\tfor(int i=1;i<=n*k;i++) fac[i]=1ll*fac[i-1]*i%MOD;\n\tinv[n*k]=quick_pow(fac[n*k],MOD-2);\n\tfor(int i=n*k-1;i>=0;i--) inv[i]=1ll*inv[i+1]*(i+1)%MOD;\n\t\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tdp[j]=(dp[j-1]*C(i+(k-1)*j-1,k-2)%MOD+dp[j])%MOD;\n\t\n\tll res=1ll*dp[n]*fac[n]%MOD;\n\tprintf(\"%lld\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define ll long long\n#define MAX 2010\n#define MOD 1000000007\nvoid add(int &x,int y){x+=y;if(x>=MOD)x-=MOD;}\ninline int read()\n{\n\tint x=0;bool t=false;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')t=true,ch=getchar();\n\twhile(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n\treturn t?-x:x;\n}\nint n,k,mx,f[MAX][MAX];\nint jc[MAX*MAX],jv[MAX*MAX],inv[MAX*MAX];\nint C(int n,int m){return 1ll*jc[n]*jv[m]%MOD*jv[n-m]%MOD;}\nint main()\n{\n\tn=read();k=read();mx=n*k;\n\tif(k==1){puts(\"1\");return 0;}\n\tjc[0]=jv[0]=inv[0]=inv[1]=1;\n\tfor(int i=1;i<=mx;++i)jc[i]=1ll*jc[i-1]*i%MOD;\n\tfor(int i=2;i<=mx;++i)inv[i]=1ll*inv[MOD%i]*(MOD-MOD/i)%MOD;\n\tfor(int i=1;i<=mx;++i)jv[i]=1ll*jv[i-1]*inv[i]%MOD;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<=i;++j)\n\t\t{\n\t\t\tadd(f[i][j],f[i-1][j]);\n\t\t\tif(j)add(f[i][j],1ll*f[i][j-1]*(n-j+1)%MOD*C((n-i)+(n-j+1)*(k-1)-1,k-2)%MOD);\n\t\t}\n\tprintf(\"%d\\n\",f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<iomanip>\n#include<cstring>\n#include<complex>\n#include<vector>\n#include<cstdio>\n#include<string>\n#include<bitset>\n#include<ctime>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#define Cpy(x,y) memcpy(x,y,sizeof(x))\n#define Set(x,y) memset(x,y,sizeof(x))\n#define FILE \"4911\"\n#define mp make_pair\n#define pb push_back\n#define RG register\n#define il inline\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef vector<int>VI;\ntypedef long long ll;\ntypedef double dd;\nconst int N=5010;\nconst int M=4e6;\nconst int base=26;\nconst dd eps=1e-6;\nconst int inf=1e9;\nconst ll INF=1ll<<60;\nconst ll P=100000;\nconst int mod=1e9+7;\nil ll read(){\n  RG ll data=0,w=1;RG char ch=getchar();\n  while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n  if(ch=='-')w=-1,ch=getchar();\n  while(ch<='9'&&ch>='0')data=data*10+ch-48,ch=getchar();\n  return data*w;\n}\nil void file(){\n  srand(time(NULL)+rand());\n  freopen(FILE\".in\",\"r\",stdin);\n  freopen(FILE\".out\",\"w\",stdout);\n}\n\nint n,k,fac[4000010],inv[4000010],f[4005][2005];\nil void upd(int &a,int b){a+=b;if(a>=mod)a-=mod;}\nil int C(int n,int m){\n  //printf(\"%d,%d\\n\",n,m);\n  return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nil int poww(int a,int b){\n  RG int ret=1;\n  for(;b;b>>=1,a=1ll*a*a%mod)\n    if(b&1)ret=1ll*ret*a%mod;\n  return ret;\n}\n\nint main()\n{\n  fac[0]=inv[0]=1;\n  for(RG int i=1;i<=M;i++)fac[i]=1ll*fac[i-1]*i%mod;\n  inv[M]=poww(fac[M],mod-2);\n  for(RG int i=M-1;i;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\n  n=read();k=read();f[0][0]=1;if(k==1)return puts(\"1\"),0;\n  for(RG int i=1;i<=n;i++)\n    for(RG int j=0;j<=i;j++){\n      upd(f[i][j],f[i-1][j]);\n      if(j)upd(f[i][j],1ll*f[i][j-1]*C(n*k-(j-1)*(k-1)-i-1,k-2)%mod*(n-j+1)%mod);\n      //printf(\"f[%d][%d]=%d\\n\",i,j,f[i][j]);\n    }\n  printf(\"%d\\n\",f[n][n]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rg register\nusing namespace std;\nconst int mod=1e9+7;\n#define _ 2001\nint n, k, f[_][_], sum[_*_];\nint qp(int x, int y){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1)ans=1ll*ans*x%mod;\n\t\tx=1ll*x*x%mod, y>>=1;\n\t}return ans;\n}\nint C(int m, int r){return 1ll*sum[m]*qp(sum[r], mod-2)%mod*qp(sum[m-r], mod-2)%mod;}\nint main(){\n\tsum[0]=sum[1]=1;\n\tfor(int i=2; i<=2000*2000; ++i)\n\t\tsum[i]=1ll*sum[i-1]*i%mod;\n\t\n\tscanf(\"%d%d\", &n, &k);\n\tif(k==1){puts(\"1\"); return 0;}\n\tf[0][0]=1;\n\tfor(int i=1; i<=n; ++i)\n\t\tfor(int j=0; j<=i; ++j){\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(j)(f[i][j]+=1ll*C((n-j+1)*(k-1)+n-i-1, k-2)*f[i][j-1]%mod)%=mod;\n\t\t}\n\tfor(int i=2; i<=n; ++i)\n\t\tf[n][n]=1ll*f[n][n]*i%mod;\n\tprintf(\"%d\", f[n][n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n#define debug(x) cout << #x << \": \" << x << endl\n#else\n#define debug(x)\n#endif\nusing namespace std;\ntypedef long long ll;\nconst int maxn=4e6+7;\nconst int inf=0x3f3f3f3f;\nconst int mod=1e9+7;\n\nll quick(ll x,ll n)\n{\n    ll res=1;\n    while(n)\n    {\n        if(n&1) res=(res*x)%mod;\n        x=x*x%mod;\n        n>>=1;\n    }\n    return res;\n}\nll inv(ll x) {return quick(x,mod-2);}\nll fac[maxn],invfac[maxn];\nvoid init()\n{\n    fac[0]=1;\n    for(int i=1;i<maxn;++i) fac[i]=(fac[i-1]*i)%mod;\n    invfac[maxn-1]=inv(fac[maxn-1]);\n    for(int i=maxn-2;i>=0;--i) invfac[i]=(invfac[i+1]*(i+1))%mod;\n}\n\nll C(int n,int m)\n{\n    return fac[n]*invfac[m]%mod*invfac[n-m]%mod;\n}\n\nll dp[2007][2007];\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    init();\n    int n,k;\n    cin>>n>>k;\n    if(k==1) cout<<1<<endl;\n    else\n    {\n        dp[0][0]=1;\n        for(int i=1;i<=n;++i)\n        {\n            for(int j=0;j<=i;++j)\n            {\n                if(j==0) dp[i][j]=1;\n                else\n                {\n                    assert(n*k-i-(j-1)*(k-1)-1>=k-2);\n                    dp[i][j]=(dp[i-1][j]+1ll*dp[i][j-1]*(n-j+1)%mod*C(n*k-i-(j-1)*(k-1)-1,k-2)%mod)%mod;\n                }\n            }\n        }\n        cout<<dp[n][n]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int MASDFGHJKLXCVBNMNM=4000000;\nconst int NM=2020;\nconst int MOPDFGHJKL=1000000007;\nint nm,kl;\nlong long fghjkl[NM][NM],fghjklasdfghjklcvbnm[MASDFGHJKLXCVBNMNM+5],iopnmvbnm_fghjklasdfghjklcvbnm[MASDFGHJKLXCVBNMNM+5];\ninline long long C(int nm,int m){\n\treturn (((fghjklasdfghjklcvbnm[m]*iopnmvbnm_fghjklasdfghjklcvbnm[nm])%MOPDFGHJKL)*iopnmvbnm_fghjklasdfghjklcvbnm[m-nm])%MOPDFGHJKL;\n}\nlong long power(long long xcvbnm,int P){\n    long long asdfghjklnmsdfghjkl=1,m=xcvbnm;\n    while(P){\n        if(P&1) (asdfghjklnmsdfghjkl*=m)%=MOPDFGHJKL;\n        P>>=1;(m*=m)%=MOPDFGHJKL;\n    }\n    return asdfghjklnmsdfghjkl;\n}\nint main(){\n\tios::sync_with_stdio(false);\n    cin>>nm>>kl;\n    if(kl==1) return cout<<1<<endl,0;\n    fghjklasdfghjklcvbnm[0]=1;\n\tfor(int iop=1;iop<=MASDFGHJKLXCVBNMNM;++iop)\n\t\tfghjklasdfghjklcvbnm[iop]=(fghjklasdfghjklcvbnm[iop-1]*iop)%MOPDFGHJKL;\n    iopnmvbnm_fghjklasdfghjklcvbnm[MASDFGHJKLXCVBNMNM]=power(fghjklasdfghjklcvbnm[MASDFGHJKLXCVBNMNM],MOPDFGHJKL-2);\n\tfor(int iop=MASDFGHJKLXCVBNMNM-1;iop>=0;--iop)\n\t\tiopnmvbnm_fghjklasdfghjklcvbnm[iop]=(iopnmvbnm_fghjklasdfghjklcvbnm[iop+1]*(iop+1))%MOPDFGHJKL;\n    fghjkl[0][0]=1;\n    for(int iop=1;iop<=nm;++iop){\n        for(int jkl=0;jkl<=iop;++jkl){\n            fghjkl[iop][jkl]=fghjkl[iop-1][jkl];\n            if(!jkl) continue;\n            (fghjkl[iop][jkl]+=fghjkl[iop][jkl-1]*(nm-jkl+1)%MOPDFGHJKL*C(kl-2,nm-iop+(nm-jkl+1)*(kl-1)-1)%MOPDFGHJKL)%=MOPDFGHJKL;\n        }\n    }\n    cout<<fghjkl[nm][nm]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*只要保证这个颜色开始的第一个填在第一个空位上\n之后的都随便填即可\n所以方案数就是C(空格位置-1,数量-1),组合意义就是开始的第一个颜色只有一个位置能填*/\n#include<bits/stdc++.h>\n#define Mod 1000000007\n#define N 2005\n#define M N*N\nusing namespace std;\nint n,K,dp[N][N],fac[M],inv[M];\ninline int ksm(int x,int y){\n\tint ans1=1;while (y){\n\t\tif (y&1) ans1=1ll*ans1*x%Mod;\n\t\ty>>=1;x=1ll*x*x%Mod;\n\t}return ans1;\n}\ninline int C(int n,int m){return 1ll*fac[n]*inv[m]%Mod*inv[n-m]%Mod;}\nint main(){\n\tscanf(\"%d%d\",&n,&K);\n\tif (K==1) return puts(\"1\"),0;dp[0][0]=1;\n\tfac[0]=1;for (int i=1;i<M;i++) fac[i]=1ll*fac[i-1]*i%Mod;\n\tinv[M-1]=ksm(fac[M-1],Mod-2);\n\tfor (int i=M-2;~i;i--) inv[i]=1ll*inv[i+1]*(i+1)%Mod;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<=i;j++){\n\t\t\tif (i) dp[i][j]=1ll*(dp[i][j]+dp[i-1][j])%Mod;\n\t\t\tif (j) dp[i][j]=1ll*(1ll*dp[i][j-1]*C(n*K-i-(j-1)*(K-1)-1,K-2)%Mod+dp[i][j])%Mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",1ll*dp[n][n]*fac[n]%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define loop(n,i) for(register int i=1;i<=(n);++i)\n#define zxc(x) cerr<<(#x)<<'='<<(x)<<'\\n'\n#define zxcv(x) cerr<<(#x)<<'='<<(x)<<','\n#define zcx zxc\n#define MAX 5000009\n#define int long long\n#define P 1000000007\nusing namespace std;\ntypedef pair<int,int> pr;\ninline int icin(){\n\tchar c=getchar();int s=0;bool sign=0;\n\twhile(!isdigit(c)&&c^'-')c=getchar();\n\tif(c=='-')c=getchar(),sign=1;\n\twhile(isdigit(c))s=(s<<1)+(s<<3)+c-'0',c=getchar();\n\treturn sign?-s:s;\n}\nint n,k;\ninline int Quick(int a,int m){int ans=1;for(;m;m>>=1,a=a*a%P) if(m&1) ans=ans*a%P;return ans;}\nint fact[MAX],ifact[MAX];\ninline int binom(int n,int m){return n<m||m<0?0:fact[n]*ifact[m]%P*ifact[n-m]%P;}\nint f[2009][2009];\nmain(){\n\tn=icin(),k=icin();\n\tif(k==1) return cout<<1,0;\n\tint bound=n*k+k;\n\tfact[0]=1;loop(bound,i) fact[i]=fact[i-1]*i%P;\n\tifact[bound]=Quick(fact[bound],P-2);for(register int i=bound;i;--i) ifact[i-1]=ifact[i]*i%P;\n\tfor(register int i=0;i<=n;++i) f[0][i]=1;\n\tfor(register int i=1;i<=n;++i){\n\t\tfor(register int j=i;j<=n;++j){\n\t\t\tf[i][j]=(f[i][j-1]+f[i-1][j]*binom((n-i+1)*(k-1)+n-j-1,k-2)%P*(n-i+1))%P;\n\t\t}\n\t}cout<<f[n][n];\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\n#define MOD 1000000007\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int MAXN = 2000 + 10;\nconst int MAXM = 4e06 + 10;\n\nint N, K;\n\nLL fact[MAXN]= {0}, invfact[MAXN]= {0};\nvoid init () {\n\tfact[0] = fact[1] = invfact[0] = invfact[1] = 1;\n\tfor (int i = 2; i <= N * K; i ++) {\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\tinvfact[i] = (MOD - MOD / i) * invfact[MOD % i] % MOD;\n\t}\n\tfor (int i = 1; i <= N * K; i ++)\n\t\tinvfact[i] = invfact[i - 1] * invfact[i] % MOD;\n}\nLL C (int n, int m) {\n\tif (m == 0) return 1;\n\treturn fact[n] * invfact[m] % MOD * invfact[n - m] % MOD;\n}\n\nLL f[MAXN][MAXN]= {0};\n\nint main () {\n\tscanf (\"%d%d\", & N, & K);\n\tif (K == 1) {\n\t\tputs (\"1\");\n\t\treturn 0;\n\t}\n\tinit ();\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= N; i ++)\n\t\tfor (int j = 0; j <= i; j ++) {\n\t\t\tLL delta = f[i][j - 1] * (N - j + 1) % MOD * C (N * K - i - (K - 1) * (j - 1) - 1, K - 2) % MOD;\n\t\t\tif (j == 0) delta = 0;\n\t\t\tf[i][j] = (f[i][j] + f[i - 1][j] + delta) % MOD;\n\t\t}\n\tcout << f[N][N] << endl;\n\n\treturn 0;\n}\n\n/*\n2 2\n*/\n\n/*\n3 1\n*/\n\n/*\n2 3\n*/\n\n/*\n2000 2000\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2010;\nconst int M = 4000100;\nconst int MOD = 1e9 + 7;\nint n, k;\nint fac[M], inv[M], f[N][N];\nint powi(int a, int b)\n{\n    int c = 1; for (; b; b >>= 1, a = 1ll * a * a % MOD)\n        if (b & 1) c = 1ll * c * a % MOD; return c;\n}\nvoid ADD(int &t, int d) {t += d; if (t >= MOD) t -= MOD;}\nint C(int a, int b)\n{\n    return 1ll * fac[a] * inv[b] % MOD * inv[a - b] % MOD;\n}\nint main()\n{\n    cin >> n >> k;\n    if (k == 1) {cout << 1 << endl; return 0;}\n    fac[0] = 1; for (int i = 1; i < M; ++ i) fac[i] = 1ll * fac[i - 1] * i % MOD;\n    inv[M - 1] = powi(fac[M - 1], MOD - 2);\n    for (int i = M - 2; ~i; -- i) inv[i] = 1ll * inv[i + 1] * (i + 1) % MOD;\n    f[0][0] = 1;\n    for (int i = 0; i <= n; ++ i)\n        for (int j = 0; j <= i; ++ j)\n        {\n            if (j) ADD(f[i][j], f[i][j - 1]);\n            if (i) ADD(f[i][j], 1ll * f[i - 1][j] * C(i * (k - 1) + j - 1, k - 2) % MOD * (n - i + 1) % MOD);\n        }\n    cout << f[n][n] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n\nconst int N = 2020;\nconst int Q = N * N;\nconst int mod = 1e9 + 7;\n\nusing namespace std;\n\nint pw(int x, int n)\n{\n        int res = 1;\n        for(; n > 0; n >>= 1){\n                if(n & 1){\n                        res = 1ll * res * x % mod;\n                }\n                x = 1ll * x * x % mod;\n        }\n        return res;\n}\n\nint fac[Q], inv[Q];\n\nvoid make()\n{\n        fac[0] = 1;\n        for(int i = 1; i < Q; i++) fac[i] = fac[i - 1] * 1ll * i % mod;\n        inv[Q - 1] = pw(fac[Q - 1], mod - 2);\n        for(int i = Q - 2; i >= 0; i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod;\n}\n\nint C(int n, int k)\n{\n        if(k < 0 || k > n) return 0;\n        return 1ll * fac[n] * inv[k] % mod * inv[n - k] % mod;\n}\n\nvoid add(int &x, int y)\n{\n        x += y;\n        if(x >= mod){\n                x -= mod;\n        }\n}\n\nint n, k;\nint d[N][N];\n\nint main()\n{\n        ios_base::sync_with_stdio(0);\n\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n\n        make();\n\n        cin >> n >> k;\n        if(k == 1){\n                cout << 1 << \"\\n\";\n                return 0;\n        }\n        d[0][0] = 1;\n        for(int i = 0; i <= n; i++){\n                for(int j = i; j <= n; j++){\n                        if(i > 0)add(d[i][j], d[i - 1][j]);\n                        if(j > 0)add(d[i][j], d[i][j - 1] * 1ll * C(j * (k - 1) + i - 1, k - 2) % mod);\n                }\n        }\n        cout << d[n][n] * 1ll * fac[n] % mod << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=2005;\nconst int MOD=1000000007;\n\nint n,k,f[N][N],jc[N*N+N*2],ny[N*N+N*2];\n\nvoid updata(int &x,int y)\n{\n\tx+=y,x-=x>=MOD?MOD:0;\n}\n\nint C(int n,int m)\n{\n\treturn (LL)jc[n]*ny[m]%MOD*ny[n-m]%MOD;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);k--;\n\tif (!k) {puts(\"1\");return 0;}\n\tny[0]=jc[1]=ny[0]=ny[1]=1;\n\tfor (int i=2;i<=n*k+n+k;i++) jc[i]=(LL)jc[i-1]*i%MOD,ny[i]=(LL)(MOD-MOD/i)*ny[MOD%i]%MOD;\n\tfor (int i=2;i<=n*k+n+k;i++) ny[i]=(LL)ny[i-1]*ny[i]%MOD;\n\tf[0][0]=1;\n\tfor (int i=0;i<=n;i++)\n\t\tfor (int j=i;j<=n;j++)\n\t\t{\n\t\t\tif (i) updata(f[i][j],f[i-1][j]);\n\t\t\tif (j) updata(f[i][j],(LL)f[i][j-1]*C(i+(j-1)*k+k-1,k-1)%MOD);\n\t\t}\n\tprintf(\"%d\",(LL)f[n][n]*jc[n]%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nconst ll MOD=1e9+7;\nll n,m,f[2005][2005];\nll fact[4000005],inv[4000005];\nll quick_pow(ll x,ll a)\n{\n\tll ans=1;\n\twhile(a)\n\t{\n\t\tif(a&1)ans=ans*x%MOD;\n\t\tx=x*x%MOD;\n\t\ta>>=1;\n\t}\n\treturn ans;\n}\nll C(ll n,ll m)\n{\n\treturn fact[n]*inv[n-m]%MOD*inv[m]%MOD;\n}\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&m);\n\tfact[0]=1;\n\tfor(int i=1;i<=4000000;i++)fact[i]=fact[i-1]*i%MOD;\n\tinv[4000000]=quick_pow(fact[4000000],MOD-2);\n\tfor(int i=3999999;i>=0;i--)inv[i]=inv[i+1]*(i+1)%MOD;\n\tif(m==1)\n\t{\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tf[n][n]=1;\n\tfor(int i=n;i>=0;i--)\n\tfor(int j=n;j>=i;j--)\n\t{\n\t\tf[i][j]%=MOD;\n\t\tif(i)f[i-1][j]+=f[i][j];\n\t\tif(i!=j)f[i][j-1]+=f[i][j]*C(i+j*(m-1)-1,m-2)%MOD;\n\t}\n//\tfor(int i=0;i<=n;i++)\n//\t{\n//\t\tfor(int j=0;j<=n;j++)\n//\t\t  printf(\"%lld \",f[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\tprintf(\"%lld\\n\",f[0][0]*fact[n]%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e3+10;\nconst int mod=1e9+7;\nint gi() {\n    int x=0,o=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\nint n,m,f[N][N],fac[N*N],inv[N*N],ifac[N*N];\nint C(int n,int m) {\n    if(n<0||m<0||n<m) return 0;\n    return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\nint main() {\n    cin>>n>>m;int N=n*m;\n    if(m==1) return puts(\"1\"),0;\n    fac[0]=1;for(int i=1;i<=N;i++) fac[i]=1ll*fac[i-1]*i%mod;\n    inv[1]=1;for(int i=2;i<=N;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n    ifac[0]=1;for(int i=1;i<=N;i++) ifac[i]=1ll*ifac[i-1]*inv[i]%mod;\n    f[0][0]=1;\n    for(int i=1;i<=n;i++)\n        for(int j=0;j<=i;j++) f[i][j]=(f[i-1][j]+1ll*f[i][j-1]%mod*(n-j+1)%mod*C(n-i+(n-j+1)*(m-1)-1,m-2)%mod)%mod;\n    printf(\"%d\\n\",f[n][n]);\n    return 0;\n}\n//orzgzy\n//鸡贼明年进队超稳\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nll read(){\n\tchar c=getchar();bool flag=0;ll x=0;\n\twhile(c<'0'||c>'9'){if(c=='-')flag=1;c=getchar();}\n\twhile(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}\n\treturn flag?-x:x;\n}\n#define N 2010 \nconst ll p=1e9+7;\nll dp[N][N],fac[N*N];\nll fpow(ll a,ll x){\n\tll ans=1;\n\twhile(x){\n\t\tif(x&1) ans=ans*a%p;\n\t\ta=a*a%p,x=x/2; \n\t}\n\treturn ans;\n}\nll inv(ll x){\n\treturn fpow(x,p-2);\n}\nll Cnt(ll n,ll m){\n\treturn fac[m]*inv(fac[n])%p*inv(fac[m-n])%p;\n}\nint main(){\n\tll n=read(),k=read();\n\tif(k==1){\n\t\tprintf(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\tfor(ll i=1;i<=n*k;i++) fac[i]=fac[i-1]*i%p;\n\tfor(ll i=1;i<=n;i++) dp[i][0]=1;\n\tfor(ll i=1;i<=n;i++){\n\t\tfor(ll j=1;j<=i;j++){\n\t\t\tdp[i][j]=dp[i-1][j]+dp[i][j-1]*(n-(j-1))*Cnt(k-2,n*k-i-(j-1)*(k-1)-1);\n\t\t}\n\t}\n\tprintf(\"%lld\",dp[n][n]); \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#define FOR(i, n, m) for(ll i = n; i < (int)m; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define pb push_back\nusing namespace std;\nusing ll = std::int_fast64_t;\nusing P = pair<ll, ll>;\nconstexpr ll inf = 1000000000;\nconstexpr ll mod = 1000000007;\nconstexpr long double eps = 1e-15;\n \ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, pair<T1, T2> p) {\n    os << to_string(p.first) << \" \" << to_string(p.second);\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n    REP(i, v.size()) {\n        if(i) os << \" \";\n        os << to_string(v[i]);\n    }\n    return os;\n}\n \nstruct modint {\n    ll n;\npublic:\n    modint(const ll n = 0) : n((n % mod + mod) % mod) {}\n    static modint pow(modint a, int m) {\n        modint r = 1;\n        while(m > 0) {\n            if(m & 1) { r *= a; }\n            a = (a * a); m /= 2;\n        }\n        return r;\n    }\n    modint &operator++() { *this += 1; return *this; }\n    modint &operator--() { *this -= 1; return *this; }\n    modint operator++(int) { modint ret = *this; *this += 1; return ret; }\n    modint operator--(int) { modint ret = *this; *this -= 1; return ret; }\n    modint operator~() const { return (this -> pow(n, mod - 2)); } // inverse\n    friend bool operator==(const modint& lhs, const modint& rhs) {\n        return lhs.n == rhs.n;\n    }\n    friend bool operator<(const modint& lhs, const modint& rhs) {\n        return lhs.n < rhs.n;\n    }\n    friend bool operator>(const modint& lhs, const modint& rhs) {\n        return lhs.n > rhs.n;\n    }\n    friend modint &operator+=(modint& lhs, const modint& rhs) {\n        lhs.n += rhs.n;\n        if (lhs.n >= mod) lhs.n -= mod;\n        return lhs;\n    }\n    friend modint &operator-=(modint& lhs, const modint& rhs) {\n        lhs.n -= rhs.n;\n        if (lhs.n < 0) lhs.n += mod;\n        return lhs;\n    }\n    friend modint &operator*=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * rhs.n) % mod;\n        return lhs;\n    }\n    friend modint &operator/=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * (~rhs).n) % mod;\n        return lhs;\n    }\n    friend modint operator+(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n + rhs.n);\n    }\n    friend modint operator-(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n - rhs.n);\n    }\n    friend modint operator*(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * rhs.n);\n    }\n    friend modint operator/(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * (~rhs).n);\n    }\n};\nistream& operator>>(istream& is, modint m) { is >> m.n; return is; }\nostream& operator<<(ostream& os, modint m) { os << m.n; return os; }\n \n#define MAX_N 4040404\nlong long extgcd(long long a, long long b, long long& x, long long& y) {\n    long long d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1; y = 0;\n    }\n    return d;\n}\nlong long mod_inverse(long long a, long long m) {\n    long long x, y;\n    if(extgcd(a, m, x, y) == 1) return (m + x % m) % m;\n    else return -1;\n}\nvector<long long> fact(MAX_N+1, inf);\nlong long mod_fact(long long n, long long& e) {\n    if(fact[0] == inf) {\n        fact[0]=1;\n        if(MAX_N != 0) fact[1]=1;\n        for(ll i = 2; i <= MAX_N; ++i) {\n            fact[i] = (fact[i-1] * i) % mod;\n        }\n    }\n    e = 0;\n    if(n == 0) return 1;\n    long long res = mod_fact(n / mod, e);\n    e += n / mod;\n    if((n / mod) % 2 != 0) return (res * (mod - fact[n % mod])) % mod;\n    return (res * fact[n % mod]) % mod;\n}\n// return nCk\nlong long mod_comb(long long n, long long k) {\n    if(n < 0 || k < 0 || n < k) return 0;\n    long long e1, e2, e3;\n    long long a1 = mod_fact(n, e1), a2 = mod_fact(k, e2), a3 = mod_fact(n - k, e3);\n    if(e1 > e2 + e3) return 0;\n    return (a1 * mod_inverse((a2 * a3) % mod, mod)) % mod;\n}\n \nusing mi = modint;\n \nmi mod_pow(ll a, ll n) {\n    mi ret = 1;\n    mi tmp = a;\n    while(n > 0) {\n        if(n % 2) ret *= tmp;\n        tmp = tmp * tmp;\n        n /= 2;\n    }\n    return ret;\n}\n \nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, k;\n    cin >> n >> k;\n    if(k == 1) {\n        cout << 1 << endl;\n        return 0;\n    }\n    vector<vector<mi>> dp(n + 1, vector<mi>(n + 1, 0));\n    dp[0][n] = 1;\n    REP(i, n + 1) for(int j = n; j >= 0; j--) {\n        if(n - i < j) continue;\n        int c = n - j, d = n * k - (n - i) - j * (k - 1);\n        if(i) dp[i][j] += dp[i - 1][j];\n        if(j < n) dp[i][j] += mod_comb(d - 1, k - 2) * dp[i][j + 1] * c;\n    }\n    cout << dp[n][0] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\nusing namespace std;\n\n# define REP(i, a, b) for(int i = a; i <= b; ++ i)\n# define CLR(i, a) memset(i, a, sizeof(i))\n# define REPD(i, a, b) for(int i = a; i >= b; -- i) \n\nconst int N = 2e3 + 5, MOD = 1e9 + 7;\n\nint n, k, f[N][N], inv[N * N], fac[N * N];\n\ninline void inc(int &a, int b) { a = (a + b) % MOD; }\n\ninline int binom(int x, int y) { return (y < 0 || y < x) ? 0 : 1ll * fac[y] * inv[x] % MOD * inv[y - x] % MOD; }\nint pow_(int x, int k) {\n\tint ret = 1;\n\twhile(k) {\n\t\tif(k & 1) ret = 1ll * ret * x % MOD;\n\t\tx = 1ll * x * x % MOD;\n\t\tk >>= 1;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n ,&k);\n\tfac[0] = 1;\n\tREP(i, 1, n * n + 1) fac[i] = 1ll * fac[i - 1] * i % MOD;\n\tinv[n * n + 1] = pow_(fac[n * n + 1], MOD - 2);\n\tREPD(i, n * n, 0) inv[i] = 1ll * inv[i + 1] * (i + 1) % MOD;\n\tf[0][0] = 1;\n\tREP(i, 0, n) {\n\t\tREPD(j, i, 0) {\n\t\t\tinc(f[i + 1][j + 1], 1ll * f[i][j] * binom(k - 2, i * k - j + k - 2) % MOD);\n\t\t\tif(j) inc(f[i][j - 1], f[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", 1ll * f[n][0] * fac[n] % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n#define repd(i,x,y) for(int i=x; i>=y; --i)\n \nusing namespace std;\nconst int N=2005,mod=1000000007;\ntypedef long long LL;\nint n,k,c[N],ans;\nLL flv[N*N],inv[N*N],f[N][N];\n \nvoid dfs(int x,int tp)\n{\n    if(x>n*k) \n    {\n        ans=(ans+1)%mod;\n        return;\n    }\n    if(!tp) \n    {\n        if(c[0]) --c[0],dfs(x+1,tp+1),++c[0];\n        rep(i,1,n) if(c[i]!=k-1 && c[i]) --c[i],dfs(x+1,tp),++c[i];\n    }\n    else\n    {\n        if(c[0]) --c[0],dfs(x+1,tp+1),++c[0];\n        rep(i,1,n) if(c[i]) --c[i],dfs(x+1,tp-(c[i]==k-2)),++c[i];\n    }\n}\n \nvoid task1()\n{\n    c[0]=n;\n    rep(i,1,n) c[i]=k-1;\n    dfs(1,0);\n    printf(\"%d\\n\",ans);\n}\n \nLL getmi(LL a,int x)\n{\n    LL rt=1;\n    while(x)\n    {\n        if(x&1) rt=rt*a%mod;\n        a=a*a%mod,x>>=1;\n    }\n    return rt;\n}\n \nLL C(int n,int m)\n{\n    return n<m?0:flv[n]*inv[m]%mod*inv[n-m]%mod;\n}\n \nvoid inc(LL &x,int y)\n{\n    if((x+=y)>=mod) x-=mod;\n}\n \nvoid task2()\n{\n    flv[0]=1;\n    rep(i,1,n*k) flv[i]=flv[i-1]*i%mod;\n    inv[n*k]=getmi(flv[n*k],mod-2);\n    repd(i,n*k,1) inv[i-1]=inv[i]*i%mod;\n    f[0][0]=1;\n    rep(i,1,n)\n        rep(j,0,i)\n        {\n            f[i][j]=f[i-1][j];\n            if(j) f[i][j]=(f[i][j]+f[i][j-1]*C(n-i+(k-1)*(n-j+1)-1,k-2))%mod;\n        }\n    printf(\"%lld\\n\",flv[n]*f[n][n]%mod);\n}\n \nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    if(n*k<=10) task1();\n    else task2();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define ll long long\n//{{{ read()\ninline ll read(){\n\tregister ll x=0,f=1;\n\tregister char ch=getchar();\n\twhile(ch<'0'||ch>'9'){\n\t\tif(ch=='-')\tf=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')\tx=x*10+(ch^48),ch=getchar();\n\treturn x*f;\n}\n//}}}\nconst int N=2005;\nconst int M=4e6+5;\nconst int P=1e9+7;\nll fsp(ll x,int y=P-2){\n\tll ans=1;\n\twhile(y){\n\t\tif(y&1)\tans=ans*x%P;\n\t\tx=x*x%P,y>>=1;\n\t}\n\treturn ans;\n}\nint n,k,m,f[N];\nll fac[M],inv[M];\nll C(int n,int m){\n\treturn fac[n]*inv[m]%P*inv[n-m]%P;\n}\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read(),k=read(),m=n*k,fac[0]=1;\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=m;i++) fac[i]=fac[i-1]*i%P;\n\tinv[m]=fsp(fac[m]);\n\tfor(int i=m;i;i--) inv[i-1]=inv[i]*i%P;\n\n\tf[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i;j;j--) f[j]=(f[j-1]+f[j+1]*C(m-i-(k-1)*(i-j-1)-1,k-2))%P;\n\t\tf[0]=f[1]*C(m-i-(k-1)*(i-1)-1,k-2)%P;\n\t}\n\tprintf(\"%lld\\n\",1ll*f[0]*fac[n]%P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int max_N = 2e3 + 21;\n\nconst int mod = 1e9 + 7;\n\nint n,k,f[max_N][max_N];\n\nint fac[max_N*max_N],_fac[max_N*max_N],inv[max_N*max_N];\n\ninline void init(int n){\n\tinv[1]=1;\n\tfor(int i=2;i<=n;++i){\n\t\tinv[i]=1ll*(mod/i)*inv[mod%i]%mod;\n\t\tif(inv[i])inv[i]=mod-inv[i];\n\t}\n\tfac[0]=_fac[0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\t\t_fac[i]=1ll*_fac[i-1]*inv[i]%mod;\n\t}\n}\n\ninline int C(int n,int m){\n\treturn 1ll*fac[n]*_fac[m]%mod*_fac[n-m]%mod;\n}\n\nint calc(int i,int j){\n\tif(~f[i][j])return f[i][j];\n\tint&res=f[i][j];\n\tres=0;\n\tif(i)res=calc(i-1,j);\n\tif(j>i)\n\t\tres=(res+1ll*C(i+j*(k-1)-1,k-2)*calc(i,j-1))%mod;\n\treturn res;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1)return puts(\"1\"),0;\n\tinit(n*k);\n\tfor(int i=0;i<=n;++i)\n\t\tfor(int j=0;j<=n;++j)\n\t\t\tf[i][j]=-1;\n\tf[0][0]=1;\n\tint ans=1ll*calc(n,n)*fac[n]%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rint register int \n#define ll long long \nusing namespace std;\nconst int mod = 1e9+7;\nconst int Max = 4e6;\nint N,K,fac[4001000],Ifac[4001000],f[2020][2020];\ninline ll ksm(ll x,ll y){ll res=1;while(y){if(y&1) res=res*x%mod;x=x*x%mod;y>>=1;} return res;}\ninline int add(int x,int y){x+=y;return x>=mod?x-mod:x;}\ninline int C(int x,int y){return 1ll*fac[x]*Ifac[y]%mod*Ifac[x-y]%mod;}\ninline void Init(){\n\tfac[0]=Ifac[0]=1;\n\tfor(rint i=1;i<=Max;++i) fac[i]=1ll*fac[i-1]*i%mod;\n\tIfac[Max]=ksm(fac[Max],mod-2);\n\tfor(rint i=Max-1;i>=1;--i) Ifac[i]=1ll*Ifac[i+1]*(i+1)%mod;\n}\nint main(){\n\tcin>>N>>K;\n\tif(K==1){\n\t\tcout<<1<<endl;\n\t\texit(0);\n\t}\n\tInit();\n\tf[0][0]=1;\n\tfor(rint i=1;i<=N;++i) {\n\t\tfor(rint j=0;j<=i;++j) {\n\t\t\tf[i][j]=add(f[i][j],f[i-1][j]);\n\t\t\tif(j)\n\t\t\tf[i][j]=add(f[i][j],1ll*(N-j+1)*f[i][j-1]%mod*C(N-i+(K-1)*(N-j+1)-1,K-2)%mod);\n\t\t}\n\t}cout<<f[N][N];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    namespace Wo_Zhen_Cai_A\n    {\n    \ttypedef long long ll;\n    \tconst int N=2010,MOD=1000000007;\n    \tinline void inc(ll a,ll &b){b=(a+b)%MOD;} \n    \tll qpow(ll a,ll b){ll c=1;for(;b;b>>=1,a=a*a%MOD)if(b&1)c=c*a%MOD;return c;}\n    \tll fact[N*N],ifact[N*N];\n    \tll C(int n,int m){return fact[n]*ifact[n-m]%MOD*ifact[m]%MOD;}\n    \tll f[N][N];\n    \tint n,k;\n    \tvoid solve()\n    \t{\n    \t\tscanf(\"%d%d\",&n,&k);\n    \t\tif(k==1){printf(\"1\\n\");return;}\n    \t\tfact[0]=1;for(int i=1,tmp=n*k;i<=tmp;i++)fact[i]=fact[i-1]*i%MOD;\n    \t\tifact[n*k]=qpow(fact[n*k],MOD-2);\n    \t\tfor(int i=n*k;i;i--)ifact[i-1]=ifact[i]*i%MOD;\n     \n    \t\tf[0][0]=1;\n    \t\tfor(int i=0;i<=n;i++)\n    \t\t\tfor(int j=i;j<=n;j++)\n    \t\t\t{\n    \t\t\t\tif(i+j==0)continue;\n     \n    \t\t\t\tif(i)inc(f[i-1][j],f[i][j]);\n    \t\t\t\tif(j)inc(f[i][j-1]*C(k*i+(k-1)*(j-i-1)+k-2,k-2)%MOD,f[i][j]);\n     \n     \n    //\t\t\t\tprintf(\"f[%d][%d] = %lld\\n\",i,j,f[i][j]);\n    \t\t\t}\n    \t\tprintf(\"%lld\\n\",f[n][n]*fact[n]%MOD);\n    \t}\n    }\n    int main()\n    {\n    \tWo_Zhen_Cai_A::solve();\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define ll long long\n#define rep(i,j,k) for (i=j;i<=k;i++)\n#define down(i,j,k) for (i=j;i>=k;i--)\nusing namespace std;\nconst int N=2e3+5,B=4e6+5,mod=1e9+7;\nint n,k,i,j,ans,f[N][N],fac[B],inv[B];\nint fgm(int a,int n)\n{\n\tint ret=1,bsc=a;\n\tfor (;n>0;n>>=1,bsc=(ll)bsc*bsc%mod)\n\tif (n&1) ret=(ll)ret*bsc%mod;\n\treturn ret;\n}\nint C(int n,int m)\n{\n\tif (n<m) return 0;\n\tif (!m || !(n-m)) return 1;\n\treturn (ll)fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main()\n{\n//\tfreopen(\"leftmost.in\",\"r\",stdin);\n//\tfreopen(\"leftmost.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&k);\n\n\tfac[1]=fac[0]=inv[1]=inv[0]=1; \n\trep(i,2,n*k) fac[i]=(ll)fac[i-1]*i%mod;\n\tinv[n*k]=fgm(n*k,mod-2);\n\tdown(i,n*k-1,2)\tinv[i]=(ll)(i+1)*inv[i+1]%mod;\n\t\n\tf[0][0]=1;\n\trep(i,0,n)\n\t\trep(j,i,n)\n\t\t{\n\t\t\tif (i>0) f[i][j]=f[i-1][j];\n\t\t\tif (j>0 && i<j) f[i][j]=(f[i][j]+(ll)f[i][j-1]*C(j*(k-1)+i-1,k-2) )%mod;\n\t\t}\n\tans=(ll)f[n][n]*fac[n]%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\nconst int maxn = 2005, mod = 1e9 + 7;\n\nint n, k, m, fac[maxn * maxn], ifac[maxn * maxn], f[maxn][maxn];\n\ninline int gi()\n{\n\tchar c = getchar();\n\twhile (c < '0' || c > '9') c = getchar();\n\tint sum = 0;\n\twhile ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();\n\treturn sum;\n}\n\ninline void inc(int &a, int b) {a += b; if (a >= mod) a -= mod;}\ninline int C(int n, int m)\n{\n\treturn (lint)fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nint main()\n{\n\tn = gi(); k = gi();\n\tif (k == 1) return puts(\"1\"), 0;\n\n\tm = n * k;\n\tfac[0] = ifac[0] = ifac[1] = 1;\n\tfor (int i = 1; i <= m; ++i) fac[i] = (lint)fac[i - 1] * i % mod;\n\tfor (int i = 2; i <= m; ++i) ifac[i] = (lint)(mod - mod / i) * ifac[mod % i] % mod;\n\tfor (int i = 1; i <= m; ++i) ifac[i] = (lint)ifac[i - 1] * ifac[i] % mod;\n\n\tf[1][0] = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tif (i > j) inc(f[i][j], f[i - 1][j]);\n\t\t\tif (j) inc(f[i][j], (lint)f[i][j - 1] * C(m - i - (j - 1) * (k - 1) - 1, k - 2) % mod);\n\t\t}\n\n\tprintf(\"%lld\\n\", (lint)f[n][n] * fac[n] % mod);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2345, mod = 1e9 + 7;\n\nvoid add(int& x, int y) {\n  x += y;\n  if (x >= mod) {\n    x -= mod;\n  }\n}\n\nint mul(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint n, k, fac[N * N], ifac[N * N], inv[N * N], dp[N][N];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  if (k == 1) {\n    cout << 1 << '\\n';\n    return 0;\n  }\n  fac[0] = ifac[0] = inv[1] = 1;\n  for (int i = 1; i <= n * k; ++i) {\n    if (i > 1) {\n      inv[i] = mul(mod - mod / i, inv[mod % i]);\n    }\n    fac[i] = mul(fac[i - 1], i);\n    ifac[i] = mul(ifac[i - 1], inv[i]);\n  }\n  auto binom = [&] (int n, int m) {\n    return n < 0 || m < 0 || n < m ? 0 : mul(fac[n], mul(ifac[m], ifac[n - m]));\n  };\n  dp[0][0] = 1;\n  for (int i = 0; i <= n; ++i) {\n    for (int j = 0; j <= n; ++j) {\n      if (i + 1 <= n && i + 1 >= j) {\n        add(dp[i + 1][j], dp[i][j]);\n      }\n      if (j + 1 <= n && i >= j + 1) {\n        add(dp[i][j + 1], mul(dp[i][j], mul(n - j, binom(n * k - i - j * (k - 1) - 1, k - 2))));\n      }\n    }\n  }\n  cout << dp[n][n] << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*input\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 2005;\nconst int maxm = 4e6 + 5;\nconst int mod = 1e9 + 7;\n\nlong long numer[maxm];\nlong long denom[maxm];\n\nint f[maxn][maxn];\n\nvoid add(int &a, int b) {\n    a = (a + b) % mod;\n}\n\nint C(int n, int k) {\n    if(k > n) return 0;\n    return numer[n] * denom[k] % mod * denom[n - k] % mod;\n}\n\nint main() {\n    numer[0] = denom[0] = denom[1] = 1;\n    for(int i = 1; i < maxm; ++ i) numer[i] = numer[i - 1] * i % mod;\n    for(int i = 2; i < maxm; ++ i) denom[i] = - (mod / i) * denom[mod % i] % mod + mod;\n    for(int i = 2; i < maxm; ++ i) denom[i] = denom[i] * denom[i - 1] % mod;\n\n    int n, k; cin >> n >> k;\n    if(k == 1) return puts(\"1\"), 0;\n\n    f[0][0] = 1;\n    for(int i = 0; i <= n; ++ i) for(int j = 0; j <= i; ++ j) if(f[i][j]) {\n        // add another white ball to the end\n        add(f[i + 1][j], f[i][j]);\n\n        // take away 1 white ball\n        if(j < i) {\n            // choosing a color to fill in\n            long long cur = 1ll * f[i][j] * (n - j) % mod;\n            cur = 1ll * cur * C(n * k - i - j - 1 - j * (k - 2), k - 2) % mod;\n            add(f[i][j + 1], cur);\n        }\n    }\n    cout << f[n][n] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <fstream>\n#include <iostream>\n#include <functional>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\nusing namespace std;\n\ntypedef long long ll;\n#define eps 1e-10\n#define LL_INF 0x33ffffffffffffff\n#define INF 0x3f3f3f3f\n#define mem(a, b) memset(a, b, sizeof(a))\n#define pper(i,n,m) for(int i = n;i >= m; i--)\n#define repp(i, n, m) for (int i = n; i <= m; i++)\n#define rep(i, n, m) for (int i = n; i < m; i++)\n#define sa(n) scanf(\"%d\", &(n))\n#define mp make_pair\n#define ff first\n#define ss second\n#define pb push_back\n\nconst int maxn = 4e6 + 5;\nconst double PI = acos(-1.0);\nconst ll mod = 1e9 + 7;\nll po(ll a, ll b,ll mod) { ll res = 1; a %= mod; for (; b; b >>= 1) { if (b & 1)res = res*a%mod; a = a*a%mod; }return res; }\nll gcd(ll a,ll b){ if(a==0){return b;}else{ return gcd(b%a,a);}}\n\nll n,k;\nll fac[maxn],inv[maxn];\nll dp[2005][2005];\nll C(ll n,ll x)\n{\n\treturn fac[n]*inv[x]%mod*inv[n-x]%mod;\n}\n\nvoid init()\n{\n\tfac[0]=1;\n\tinv[0]=1;\n\tll up = 4e6;\n\tfor(ll i=1;i <= up;i++)\n\t{\n\t\tfac[i]=fac[i-1]*i%mod;\n\t\tinv[i]=po(fac[i],mod-2,mod);\n\t}\n}\n\nll cal(ll i,ll j)\n{\n\tif(dp[i][j]!=-1)\n\t{\n\t\treturn dp[i][j];\n\t}\n\tll res=0;\n\tif(i==0&&j==0)\n\t{\n\t\treturn 1;\n\t}\n\tif(j > i)\n\t{\n\t\tres += C(i+j*(k-1)-1,k-2)*cal(i,j-1)%mod;\n\t}\n\tres%=mod;\n\tif(i)\n\t{\n\t\tres += cal(i-1,j);\n\t}\n\tres%=mod;\n\tdp[i][j]=res;\n\treturn res;\n}\n\nvoid solve()\n{\n\tmemset(dp,-1,sizeof(dp));\n\tcin>>n>>k;\n\tif(k==1)\n\t{\n\t\tcout<<1<<endl;\n\t\treturn;\n\t}\n\tll res= cal(n,n);\n\tfor(ll i=1;i<=n;i++)\n\t{\n\t\tres=res*i%mod;\n\t}\n\tcout<<res<<endl;\n}\nint main()\n{\n    init();\n    solve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int mod=1000000007;\ntypedef long long ll;\n\nint fac[4000010],inv[4000010],dp[2010][2010];\n\nint power(int x,int y)\n{\n\tint t=1;\n\twhile (y)\n\t{\n\t\tif (y&1) t=ll(t)*x%mod;\n\t\tx=ll(x)*x%mod;y>>=1;\n\t}\n\treturn t;\n}\n\nint c(int n,int m)\n{\n\treturn ll(fac[n])*inv[m]%mod*inv[n-m]%mod;\n}\n\nint main()\n{\n\t//freopen(\"input.txt\",\"r\",stdin);\n\t//freopen(\"output.txt\",\"w\",stdout);\n\tint n,k;scanf(\"%d%d\",&n,&k);\n\tif (k==1) {puts(\"1\");return 0;}\n\tint M=n*k;\n\tfac[0]=1;for (int i=1;i<=M;i++) fac[i]=ll(fac[i-1])*i%mod;\n\tinv[M]=power(fac[M],mod-2);for (int i=M;i;i--) inv[i-1]=ll(inv[i])*i%mod;\n\tmemset(dp,0,sizeof(dp));dp[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=0;j<=i;j++)\n\t\t\tdp[i][j]=(ll(dp[i][j-1])*c(M-i-j-(j-1)*(k-2),k-2)+dp[i-1][j])%mod;\n\tprintf(\"%d\\n\",ll(dp[n][n])*fac[n]%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n#define Forr(i, j, k) for(int i = j; i >= k; i--)\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 2010;\nconst int Mod = 1e9 + 7;\n\nLL Pow(LL x, LL e){\n\tLL ret = 1;\n\twhile(e){\n\t\tif(e & 1) ret = ret * x % Mod;\n\t\tx = x * x % Mod;\n\t\te >>= 1;\n\t}\n\treturn ret;\n}\n\nLL fac[N * N], rfac[N * N];\nint n, k;\n\ninline LL C(int a, int b){\n\treturn fac[a] * rfac[b] % Mod * rfac[a - b] % Mod;\n}\n\nLL dp[N][N];\n\nint main(){\n\tscanf(\"%d%d\", &n, &k);\n\n\tif(k == 1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\t\n\tfac[0] = 1;\n\tFor(i, 1, n * k) fac[i] = fac[i - 1] * i % Mod;\n\trfac[n * k] = Pow(fac[n * k], Mod - 2);\n\tForr(i, n * k - 1, 0) rfac[i] = rfac[i + 1] * (i + 1) % Mod;\n\n\tdp[0][0] = 1;\n\tFor(i, 0, n) For(j, i, n){\n\t\t(dp[i + 1][j] += dp[i][j]) %= Mod;\n\t\t(dp[i][j + 1] += dp[i][j] * C(i + (j + 1) * (k - 1) - 1, k - 2)) %= Mod;\n\t}\n\n\tprintf(\"%lld\\n\", dp[n][n] * fac[n] % Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#define mod 1000000007\nusing namespace std;\nint n,k,tmp;\nlong long dp[2005][2005],fact[4000005],inv[4000005];\ninline long long quick_pow(long long x,int p){\n\tlong long result=1;\n\twhile(p){\n\t\tif(p&1){\n\t\t\tresult*=x;\n\t\t\tresult%=mod;\n\t\t}\n\t\tp>>=1;\n\t\tx*=x;\n\t\tx%=mod;\n\t}\n\treturn result;\n}\ninline void init(){\n\tdp[0][0]=1;\n\tfact[0]=1;\n\tfor(register int i=1;i<=n*k;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t}\n\tinv[n*k]=quick_pow(fact[n*k],mod-2);\n\tfor(register int i=n*k-1;i>=0;i--){\n\t\tinv[i]=inv[i+1]*(i+1)%mod;\n\t}\n}\ninline long long c(int n,int m){\n\treturn (fact[n]*inv[m]%mod)*inv[n-m]%mod;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1){\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tinit();\n\tfor(register int i=1;i<=n;i++){\n\t\tfor(register int j=0;j<=i;j++){\n\t\t\tif(j==0){\n\t\t\t\tdp[i][0]=dp[i-1][0];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp=n*k-(j-1)*(k-1)-i-1;\n\t\t\tdp[i][j]=(dp[i-1][j]+dp[i][j-1]*(n-j+1)%mod*c(tmp,k-2))%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a; i <= b; ++ i)\nconst int N = 2017, mo = 1e9 + 7 ;\nusing namespace std ;\n\nint n, m, fac[N * N], inv[N * N], f[N][N] ; \n\ninline int mul(int a, int b) {\n\tint ans = 1, w = a ;\n\tfor ( ; b; b /= 2) {\n\t\tif (b & 1) ans = (ll) ans * w % mo ;\n\t\tw = (ll) w * w % mo ;\n\t}\n\treturn ans ;\n}\n\ninline void upd(int &x, int y) {\n\tx = (x + y) % mo ;\n}\n\ninline int C(int x, int y) {\n\treturn (ll) fac[x] * inv[y] % mo * inv[x - y] % mo ;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m) ;\n\tif (m == 1) {\n\t\tprintf(\"%d\\n\", 1) ;\n\t\treturn 0 ;\n\t}\n\tfac[0] = 1 ;\n\trep(i, 1, n * m) fac[i] = (ll) fac[i - 1] * i % mo ;\n\tinv[n * m] = mul(fac[n * m], mo - 2) ;\n\tfor (int i = n * m - 1; i >= 0; -- i) inv[i] = (ll) inv[i + 1] * (i + 1) % mo ;\n\tf[0][0] = 1 ;\n\trep(i, 0, n) rep(j, 0, n) {\n\t\tif (i < j) upd(f[i + 1][j], f[i][j]) ;\n\t\tif (j < n) upd(f[i][j + 1], (ll) f[i][j] * C(i + j * (m - 1) + m - 2, m - 2) % mo) ;\n\t}\n\tprintf(\"%d\\n\", (ll) f[n][n] * fac[n] % mo) ;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nconst int N=2200;\n\n\nint b[50],n,k,num;\nlong long pp,ans,f[N][N],p=1000000007;\n\nlong long do3(long long x){\n\tlong long s=x,t=x;\n\t\n\tfor(int i=2; i<=num; i++){\n\t\ts=s*s%p;\n\t\tif(b[i]==1) t=t*s%p;\n\t\t\n\t}\n\t\n\treturn t%p;\n}\n\nlong long do1(int x,int y){\n\tint mm=k-2;\n\tint nn=n*k-x-(y-1)*(k-1)-1;\n\t\n//\tprintf(\"%d %d %d %d\\n\",x,y,nn,mm);\n\t\n\tlong long ans=1,aa=1,bb=1;\n\t\n\tfor(int i=nn; i>=nn-mm+1; i--){\n\t\taa=aa*i%p;\n\t}\n\tfor(int i=1; i<=mm; i++){\n\t\tbb=bb*i%p;\n\t}\n\t\n\tbb=do3(bb);\n//\tprintf(\"%I64d %I64d\\n\",aa,bb);\n\t\n\tans=bb*aa%p;\n\t\n//\tprintf(\"%I64d \",ans);\n\t\n\treturn ans;\n\t\n}\n\nvoid do2(){\n\tlong long a=f[n][n];\n\t\n\tfor(int i=1; i<=n; i++){\n\t\ta=a*i%p;\n\t}\n\t\n\tf[n][n]=a;\n}\n\nvoid f1(int x,int y){ \n\n//\tprintf(\"%d %d\\n\",x,y);\n\n\tif(x==0){\n\t\tf[x][y]=1;\n\t\treturn;\n\t}\n\tif(y==0){\n\t\tf[x][y]=1;\n\t\treturn;\n\t}\n//\tprintf(\"%d %d\\n\",x,y);\n\t\n\tif(f[x-1][y]==-1 and x-1>=y) f1(x-1,y);\n\tif(f[x][y-1]==-1 and x>=y-1) f1(x,y-1);\n\t\n//\tprintf(\"%I64d %I64d %I64d\\n\",f[x-1][y],f[x][y-1],do1(x,y));\n\t\n\tf[x][y]=0;\n\tif(x-1>=y) f[x][y]=(f[x][y]+f[x-1][y])%p;\n\t\n\tf[x][y]+=f[x][y-1]*do1(x,y)%p;\n\tf[x][y]=f[x][y]%p;\n\t\n\treturn;\n}\n\n\n\nint main(){\n//\tfreopen(\"leftmost ball.in\",\"r\",stdin);\n//\tfreopen(\"leftmost ball.out\",\"w\",stdout);\n\n\tscanf(\"%d%d\",&n,&k);\n\t\n\tif(k==1){\n\t\tprintf(\"1\"); \n\t\treturn 0;\n\t}\n\t\n\tpp=1000000005;\n\tnum=0;\n\twhile(pp>0){\n\t\tb[++num]=pp%2;\n\t\tpp=pp/2;\n\t}\n\t\n//\tfor(int i=num; i>=1; i--) printf(\"%d\",b[i]); printf(\"\\n\");\n\t\n\tmemset(f,-1,sizeof(f));\n\tf1(n,n);\n\t\n//\tfor(int i=0; i<=n; i++){\n//\t\tfor(int j=0; j<=n; j++){\n//\t\t\tprintf(\"%I64d \",f[i][j]);\n//\t\t}printf(\"\\n\");\n//\t}\n\t\n\tdo2();\n\t\n\tf[n][n]=f[n][n]%p;\n\tprintf(\"%I64d\",f[n][n]);\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN=2005,MOD=1e9+7;\nint n,k,fac[MAXN*MAXN],inv[MAXN*MAXN],dp[MAXN][MAXN];\n\nll quick_pow(ll a,ll b)\n{\n\tll ret=1;\n\tfor(;b;b>>=1,a=a*a%MOD)\n\t\tif(b&1) ret=ret*a%MOD;\n\treturn ret;\n}\nll C(int a,int b)\n{if(a<b) return 0;return 1ll*fac[a]*inv[a-b]%MOD*inv[b]%MOD;}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfac[0]=dp[0][0]=1;\n\tfor(int i=1;i<=n*k;i++) fac[i]=1ll*fac[i-1]*i%MOD;\n\tinv[n*k]=quick_pow(fac[n*k],MOD-2);\n\tfor(int i=n*k-1;i>=0;i--) inv[i]=1ll*inv[i+1]*(i+1)%MOD;\n\t\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(j<=i) dp[i][j]=dp[i-1][j];\n\t\t\telse dp[i][j]=(dp[i][j-1]*C(i+(k-1)*j-1,k-2)%MOD+dp[max(0,i-1)][j])%MOD;\n\t\n\tll res=1ll*dp[n][n]*fac[n]%MOD;\n\tprintf(\"%lld\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 2005\n#define LL long long\nusing namespace std;\nconst int mo=1e9+7;\nint n,m,f[N][N],fc[N*N],xf[N*N];\nLL fpm(LL x,LL y){ LL s=1; while(y){ if(y&1) s=(s*x)%mo; y>>=1,x=(x*x)%mo;} return s;}\nLL C(int n,int m){ return 1LL*fc[n]*xf[m]%mo*xf[n-m]%mo;}\nint main()\n{\n\tint i,j;\n\tcin>>n>>m;\n\tif(m==1){ printf(\"1\"); return 0;}\n\tf[0][0]=1;\n\tfc[0]=xf[0]=1;\n\tfor(i=1;i<N*N;i++)\n\t\tfc[i]=(1LL*fc[i-1]*i)%mo;\n\txf[N*N-1]=fpm(fc[N*N-1],mo-2);\n\tfor(i=N*N-2;i>=0;i--)\n\t\txf[i]=(1LL*xf[i+1]*(i+1))%mo;\n\tfor(i=0;i<=n;i++)\n\t\tfor(j=i;j<=n;j++){\n\t\t\tif(i<j) (f[i+1][j]+=f[i][j])%=mo;\n\t\t\tf[i][j+1]=(f[i][j+1]+f[i][j]*C(i-1+(m-1)*(j+1),m-2))%mo;\n\t\t  }\n\tprintf(\"%lld\\n\",1LL*f[n][n]*fc[n]%mo);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define il inline\n#define vd void\n#define mod 1000000007\ntypedef long long ll;\nil int gi(){\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)){\n\t\tif(ch=='-')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\nint f[2010][2010];\nint inv[4001000],C[4001000];\nint main(){\n\tint n=gi(),k=gi();\n\tif(k==1)return puts(\"1\"),0;\n\tinv[1]=1;for(int i=2;i<=n*k;++i)inv[i]=mod-1ll*(mod/i)*inv[mod%i]%mod;\n\tC[k-2]=1;\n\tfor(int i=k-1;i<=n*k;++i)C[i]=1ll*C[i-1]*inv[i-k+2]%mod*i%mod;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<=std::min(i,n);++j){\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(j)f[i][j]=(f[i][j]+1ll*C[(n-i)+(n-j+1)*(k-1)-1]*f[i][j-1]%mod*(n-j+1)%mod)%mod;\n\t\t}\n\tprintf(\"%d\\n\",f[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 10000005\nusing namespace std;\nconst int p = 1000000007;\nint n,k;\nint jie[N],ni[N];\nint c(int x,int y)\n{\n    return 1LL*jie[x]*ni[y]%p*ni[x-y]%p;\n}\nint f[2005][2005];\nint main()\n{\n    jie[0]=ni[0]=ni[1]=1;\n    for(int i=1;i<=10000000;i++)jie[i]=1LL*jie[i-1]*i%p;\n    for(int i=2;i<=10000000;i++)ni[i]=1LL*(p-p/i)*ni[p%i]%p;\n    for(int i=2;i<=10000000;i++)ni[i]=1LL*ni[i-1]*ni[i]%p;\n    scanf(\"%d%d\",&n,&k);\n    if(k==1)return puts(\"1\"),0;\n    f[0][0]=1;\n    for(int i=0;i<=n;i++)\n    {\n        //cout<<i<<endl;\n        for(int j=n;j>=0;j--)\n        {\n           // cout<<i<<' '<<j<<endl;\n            (f[i+1][j+1]+=1LL*f[i][j]*c((i+1)*k-j-2,k-2)%p)%=p;\n            if(j)(f[i][j-1]+=f[i][j])%=p;\n        }\n    }\n    int ans=1LL*f[n][0]*jie[n]%p;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline int read()\n{\n\tint x=0;char ch=getchar();\n\twhile(ch<'0' || '9'<ch)ch=getchar();\n\twhile('0'<=ch && ch<='9')x=x*10+(ch^48),ch=getchar();\n\treturn x;\n}\n\nconst int N=2009;\nconst int M=N*N;\nconst int md=1e9+7;\n\nint n,k;\nll fac[M],inv[M];\nint f[N][N];\n\ninline ll chk(ll a){if(a>=md)a-=md;return a;}\n\ninline ll qpow(ll a,ll b)\n{\n\tll ret=1;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t\tret=ret*a%md;\n\t\ta=a*a%md;\n\t\tb>>=1;\n\t}\n\treturn ret;\n}\n\ninline void init()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<M;i++)\n\t\tfac[i]=fac[i-1]*(ll)i%md;\n\tinv[M-1]=qpow(fac[M-1],md-2);\n\tfor(int i=M-2;i>=0;i--)\n\t\tinv[i]=inv[i+1]*(ll)(1+i)%md;\n}\n\ninline ll c(ll a,ll b)\n{\n\treturn fac[a]*inv[b]%md*inv[a-b]%md;\n}\n\nint main()\n{\n\tn=read();\n\tk=read();\n\tinit();\n\tif(k==1)return puts(\"1\"),0;\n\n\tf[0][0]=1;\n\tlong long ans=1;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tif(i)ans=ans*i%md;\n\t\tfor(int j=i;j<=n;j++)\n\t\t{\n\t\t\tif(i)f[i][j]=f[i-1][j];\n\t\t\tif(j>i)f[i][j]=chk(f[i][j]+1ll*c(i+j*(k-1)-1,k-2)*f[i][j-1]%md);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",(long long)f[n][n]*ans%md);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2345, mod = 1e9 + 7;\n\nvoid add(int& x, int y) {\n  x += y;\n  if (x >= mod) {\n    x -= mod;\n  }\n}\n\nint mul(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint n, k, fac[N * N], ifac[N * N], inv[N * N], dp[N][N];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  if (k == 1) {\n    cout << 1 << '\\n';\n    return 0;\n  }\n  fac[0] = ifac[0] = inv[1] = 1;\n  for (int i = 1; i <= n * k; ++i) {\n    if (i > 1) {\n      inv[i] = mul(mod - mod / i, inv[mod % i]);\n    }\n    fac[i] = mul(fac[i - 1], i);\n    ifac[i] = mul(ifac[i - 1], inv[i]);\n  }\n  auto binom = [&] (int n, int m) {\n    return n < 0 || m < 0 || n < m ? 0 : mul(fac[n], mul(ifac[m], ifac[n - m]));\n  };\n  dp[0][0] = 1;\n  for (int i = 0; i <= n; ++i) {\n    for (int j = 0; j <= n; ++j) {\n      if (i + 1 <= n && i + 1 >= j) {\n        add(dp[i + 1][j], dp[i][j]);\n      }\n      if (j + 1 <= n && i >= j + 1) {\n        add(dp[i][j + 1], mul(dp[i][j], mul(n - j, binom(n * k - i - j * (k - 1) - 1, k - 2))));\n      }\n    }\n  }\n  cout << dp[n][n] << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst long long mod=1000000007;\nlong long f[2005][2005];\nlong long fac[5000005],inv[5000005];\nint n,k;\nlong long qpow(long long a,long long b){\n\tb%=(mod-1);\n\ta=a%mod;\n\tlong long ans=1;\n\twhile(b){\n\t\tif(b&1)\tans=ans*a%mod;\n\t\ta=a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nvoid init(){\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=5000000;i++)\tfac[i]=fac[i-1]*i%mod;\n\tinv[5000000]=qpow(fac[5000000],mod-2);\n\tfor(int i=4999999;i>=1;i--)\tinv[i]=inv[i+1]*(i+1)%mod;\n}\nlong long C(int n,int m){\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main(){\n\tinit();\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\t\n\tf[0][0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=i;j<=n;j++){\n\t\t\tif(i==0&&j==0)\tcontinue;\n\t\t\tif(i)\tf[i][j]=(f[i][j]+f[i-1][j])%mod;\n\t\t\tf[i][j]=(f[i][j]+f[i][j-1]*C(i+(j-1)*(k-1)+1+k-2-1,i+(j-1)*(k-1)+1-1)%mod)%mod;\n\t\t}\n\t}\n\tcout<<f[n][n]*fac[n]%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ninline void write(LL x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x);putchar(' ');}\ninline void pr2(LL x){write(x);putchar('\\n');}\nconst int MAXN=2005;\nconst LL mod=1e9+7;\nint n,K;\nLL inv[MAXN*MAXN],pre[MAXN*MAXN];\nLL pow_mod(LL a,LL b)\n{\n\tLL ret=1;\n\twhile(b)\n\t{\n\t\tif(b&1)ret=ret*a%mod;\n\t\ta=a*a%mod;b>>=1;\n\t}\n\treturn ret;\n}\n\nLL f[MAXN][MAXN];\nLL C(int n,int m){return pre[n]*inv[m]%mod*inv[n-m]%mod;}\nvoid ad(LL &x,LL y){x+=y;if(x>=mod)x-=mod;}\nint main()\n{\n\tn=read();K=read();\n\tif(K==1)return puts(\"1\"),0;\n\tpre[0]=1;for(int i=1;i<MAXN*MAXN;i++)pre[i]=pre[i-1]*i%mod;\n\tinv[MAXN*MAXN-1]=pow_mod(pre[MAXN*MAXN-1],mod-2);\n\tfor(int i=MAXN*MAXN-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tif(i-1>=j)ad(f[i][j],f[i-1][j]);\n\t\t\tad(f[i][j],f[i][j-1]*C(n*K-(K-1)*(j-1)-i-1,K-2)%mod);\n\t\t}\n\tf[n][n]=f[n][n]*pre[n]%mod;\n\tpr2(f[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 2010;\nconst int mod = 1e9 + 7;\n\nLL f[N][N], p[N * N];\n\nLL qpow(LL a, LL b)\n{\n\tLL ret = 1, base = a;\t\n\twhile (b) {\n\t\tif (b & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod, b >>= 1;\n\t}\n\treturn ret;\n}\n\nLL epb;\n\nLL C(int a, int b) { return p[a] * epb % mod * qpow(p[a - b], mod - 2) % mod;}\n\nint main()\n{\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tif (k == 1){ printf(\"%d\\n\", 1); return 0;}\n\tf[0][0] = p[0] = 1;\n\tRep(i, n * k) p[i] = p[i - 1] * i % mod;\n\tepb = qpow(p[k - 2], mod - 2);\n\tRep(i, n) Rep0(j, i) {\n\t\tf[i][j] = f[i - 1][j] * C(i * (k - 1) + j - 1, k - 2) % mod;\n\t\tf[i][j] = (f[i][j] + f[i][j - 1]) % mod;\n\t\t//printf(\"%d %d %lld\\n\", i, j, f[i][j]);\n\t}\n\t\n\tprintf(\"%lld\\n\", f[n][n] * p[n] % mod);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2\")\n#pragma GCC optimize (\"unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst ld eps=1e-7;\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod = 1000000007;\nconst int MAXN = 2010, LOG=20;\n\nll n, m, k, u, v, x, y, t, a, b, ans;\nll F[MAXN*MAXN], I[MAXN*MAXN];\nll dp[MAXN][MAXN]; // dp[i][j]   i ta color    j ta 0    i>=j \n\nll powmod(ll a, ll b){\n\tif (!b) return 1;\n\tif (b&1) return a*powmod(a*a%mod, b>>1)%mod;\n\treturn powmod(a*a%mod, b>>1);\n}\n\nll C(ll n, ll r){\n\tif (r<0 || r>n) return 0;\n\treturn (F[n]*I[r]%mod)*I[n-r]%mod;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tF[0]=1;\n\tfor (int i=1; i<MAXN*MAXN; i++) F[i]=F[i-1]*i%mod;\n\tI[MAXN*MAXN-1]=powmod(F[MAXN*MAXN-1], mod-2);\n\tfor (int i=MAXN*MAXN-1; i; i--) I[i-1]=I[i]*i%mod;\n\t\n\tcin>>n>>k;\n\tif (k==1) kill(1)\n\tdp[0][0]=1;\n\tfor (int i=1; i<=n; i++){\n\t\tfor (int j=0; j<=i; j++){\n\t\t\tdp[i][j]=dp[i-1][j]*C(i*(k-1)+j-1, k-2)%mod;\n\t\t\tif (j) dp[i][j]=(dp[i][j] + dp[i][j-1])%mod;\n\t\t}\n\t}\n\t\n\tans=dp[n][n]*F[n]%mod;\n\tcout<<ans<<'\\n';\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef Lin1043\n    #define DEBUG(msg, ...) printf(\"(%s #%d) \" msg, __FUNCTION__, __LINE__, __VA_ARGS__)\n    #define massert(...) assert(...)\n#else\n    #define DEBUG(...)\n    #define massert(...)\n#endif\n\n#define rep(i , l , r) for(int i = (l) , ___ = (r) ; i <= ___ ; ++i )\n#define per(i , r , l) for(int i = (r) , ___ = (l) ; i >= ___ ; --i )\n\nstruct iopener\n{\n    iopener()\n    {\n#ifdef Lin1043\n        freopen(\"./in\" , \"r\" , stdin);\n#endif\n    }\n} iop;\n\ntypedef long long LL;\n\ntemplate<typename T>inline bool chkmin(T &x , const T &y) { return x > y ? (x = y , 1) : 0; }\ntemplate<typename T>inline bool chkmax(T &x , const T &y) { return x < y ? (x = y , 1) : 0; }\n\ntemplate<typename T>inline T read(T &f)\n{\n    f = 0; int x = 1 ; char c = getchar();\n    while(!isdigit(c)) x = (c == '-' ? -1 : 1) , c = getchar();\n    while(isdigit(c)) (f *= 10) += c & 15 , c = getchar();\n    return f = x * f;\n}\n\nconst int N = 2000 + 5 , L = 1000000;\n\nint n , k ;\nLL fac[L+10] , inv[L+10];\n\nconst int KCZ = 1e9 + 7;\n\nLL mp(LL x , LL y = KCZ - 2)\n{\n    LL res = 1;\n    while(y)\n    {\n        if(y & 1)\n            res = res * x % KCZ;\n        x = x * x % KCZ;\n        y >>= 1;\n    }\n    return res;\n}\n\nvoid init()\n{\n    fac[0] = 1;\n    rep(i , 1 , L) fac[i] = fac[i - 1] * i % KCZ;\n    inv[L] = mp(fac[L]);\n    per(i , L - 1 , 1) inv[i] = inv[i + 1] * (i + 1) % KCZ;\n    inv[0] = 1;\n}\n\nLL C(int n , int m)\n{\n    if(n < m) return 0;\n    return fac[n] * inv[m] % KCZ * inv[n - m] % KCZ;\n}\n\nLL f[N][N];\n\nvoid add(LL &x , const LL &y)\n{\n    x += y; if(x >= KCZ) x -= KCZ;\n}\n\nint main()\n{\n    read(n) , read(k) , init();\n    if(k == 1)\n        return puts(\"1\") , 0;\n    f[0][0] = 1;\n    rep(i , 1 , n)\n    {\n        per(j , i , 0)\n        {\n            f[i][j] = f[i][j + 1]; \n            if(j >= 1)\n                add(f[i][j] , f[i - 1][j - 1] * C(i * k - j - 1 , k - 2) % KCZ);\n        }\n    }\n    printf(\"%lld\\n\" , f[n][0] * fac[n] % KCZ);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <string>\n#include <functional>\n#define SIZE 2005\n#define MX 5000005\n#define MOD 1000000007\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nll inv[MX],fac[MX],finv[MX];\nll dp[SIZE][SIZE];\nll all[SIZE];\n\nvoid make()\n{\n\tinv[1]=1;\n\tfac[0]=fac[1]=finv[0]=finv[1]=1;\n\tfor(int i=2;i<MX;i++)\n\t{\n\t\tinv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n\t\tfac[i]=fac[i-1]*(ll) i%MOD;\n\t\tfinv[i]=finv[i-1]*inv[i]%MOD;\n\t}\n}\nll C(int a,int b)\n{\n\tif(a<b) return 0;\n\treturn fac[a]*(finv[b]*finv[a-b]%MOD)%MOD;\n}\nint main()\n{\n\tmake();\n\tint n,K;\n\tscanf(\"%d %d\",&n,&K);\n\tif(K==1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tall[i]=0;\n\t\tll now=all[i-1];\n\t\tfor(int j=1;j<=i;j++)\n\t\t{\n\t\t\tif(i==1) dp[i][j]=1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tll way=C((K-2)+(i-1)*K-(j-1),K-2)*now%MOD;\n\t\t\t\tdp[i][j]=way*(ll) i%MOD;\n\t\t\t\tif(j>=2)\n\t\t\t\t{\n\t\t\t\t\tnow-=dp[i-1][j-1];\n\t\t\t\t\tif(now<0) now+=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tall[i]+=dp[i][j];\n\t\t\tif(all[i]>=MOD) all[i]-=MOD;\n\t\t\t//printf(\"%lld \",dp[i][j]);\n\t\t}\n\t\t//puts(\"\");\n\t}\n\tprintf(\"%lld\\n\",all[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 2086\n\nusing namespace std;\n\nconst int p = 1e9 + 7;\n\ninline int fpow(int x, int y){\n\tint ans = 1;\n\twhile(y){\n\t\tif(y & 1) ans = 1ll * ans * x % p;\n\t\tx = 1ll * x * x % p, y >>= 1;\n\t}\n\treturn ans;\n}\n\nint sum[maxn * maxn], inv[maxn * maxn];\n\ninline int C(int n, int m){\n\treturn 1ll * sum[n] * inv[m] % p * inv[n - m] % p;\n}\n\nint n, k;\nint f[maxn][maxn];\n\nint main(){\n\tscanf(\"%d%d\", &n, &k);\n\tif(k == 1) return printf(\"1\"), 0;\n\tsum[0] = 1;for(int i = 1;i <= n * k;i++) sum[i] = 1ll * sum[i - 1] * i % p;\n\tinv[n * k] = fpow(sum[n * k], p - 2);\n\tfor(int i = n * k - 1;~i;i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % p;\n\tf[0][0] = 1;\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 0;j <= i;j++){\n\t\t\tf[i][j] = f[i - 1][j];\n\t\t\tf[i][j] = (f[i][j] + 1ll * f[i][j - 1] * (n - j + 1) % p * C(n * k - i - (j - 1) * (k - 1) - 1, k - 2)) % p;\n\t\t}\n\t}\n\tprintf(\"%d\", f[n][n]);\n}"
  },
  {
    "language": "C++",
    "code": "    //Created Time:2019年12月23日 星期一 15时39分53秒\n    #include <iostream>\n    #include <cstdio>\n    #include <algorithm>\n    #include <cstring>\n    #define N 2005\n    #define mod 1000000007\n     \n    using namespace std;\n     \n    int n, k;\n    int f[N][N], fac[N * N], ifac[N * N], inv[N * N];\n     \n    int C(int ,int);\n     \n    int main(){\n    \tcin >> n >> k; fac[0] = ifac[0] = inv[1] = 1;\n    \tif (k == 1) { puts(\"1\"); return 0;}\n    \tfor (int i = 2; i <= n * k; ++i) inv[i] = mod - 1ll * mod / i * inv[mod % i] % mod;\n    \tfor (int i = 1; i <= n * k; ++i) fac[i] = 1ll * fac[i - 1] * i % mod, ifac[i] = 1ll * ifac[i - 1] * inv[i] % mod;\n    \tf[0][0] = 1; //f[i][j] 放了i个白色球和j种颜色球的方案\n    \tfor (int i = 1; i <= n; ++i)\n    \t\tfor (int j = 0; j <= i; ++j) {\n    \t\t\tf[i][j] = f[i - 1][j];\n    \t\t\tif(j) (f[i][j] += 1ll * C(n - i + (n - j + 1) * (k - 1) - 1, k - 2) * f[i][j - 1] % mod * (n - j + 1) % mod) %= mod;\n    \t\t}\n    \tcout << f[n][n] << endl;\n    \treturn 0;\n    }\n     \n    int C(int x, int y){\n    \treturn 1ll * fac[x] * ifac[y] % mod * ifac[x - y] % mod;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define ll long long\nconst int N=2005,M=4e6+5,mo=1e9+7;\nint n,m,nm,i,j,f[N];\nint fact[M],inv[M],fv[M];\nvoid init(int n){\n\tfact[0]=fact[1]=inv[1]=fv[0]=fv[1]=1;\n\tfor (i=2;i<=n;i++){\n\t\tfact[i]=(ll)fact[i-1]*i%mo;\n\t\tinv[i]=(ll)inv[mo%i]*(mo-mo/i)%mo;\n\t\tfv[i]=(ll)fv[i-1]*inv[i]%mo;\n\t}\n}\nint C(int n,int m){return (ll)fact[n]*fv[m]%mo*fv[n-m]%mo;}\nint main(){\n\tscanf(\"%d%d\",&n,&m);m--;\n\tif (!m){puts(\"1\");return 0;}\n\tnm=n*m+n;init(nm);f[0]=1;\n\tfor (i=1;i<=n;i++) for (j=1;j<=i;j++)\n\t\tf[j]=(f[j]+(ll)(n-j+1)*\n\t\t\tC(nm-i-(j-1)*m-1,m-1)%mo*f[j-1])%mo;\n\tprintf(\"%d\",f[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nconst ll M = 1000000007;\n\nll modpow(ll x,ll k){\n\tif(k == 0)return 1;\n\tll ret = modpow(x,k/2);\n\tret *= ret; ret %= M;\n\tif(k%2 == 1){ ret *= x; ret %= M ; }\n\treturn ret;\n}\nll inv(ll x){\n\treturn modpow(x,M-2);\n}\n\nll f[4000010];\nvoid init(int k){\n\tf[k-2] = 1;\n\tfor(int i = k-2 ; i < 4000009 ; i ++){\n\t\tf[i+1] = f[i]*(i+1); f[i+1] %= M;\n\t\tf[i+1] *= inv(i+3-k); f[i+1] %= M;\n\t}\n}\n\nint main(){\n\tll n,k;\n\tcin >> n >> k;\n\tif(k == 1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tinit(k);\n\t\n\tstatic ll dp[2002][2002] = {};\n\tdp[0][0] = 1;\n\trep1(i,n){\n\t\tll sum = dp[i-1][i-1];\n\t\tfor(int j = i ; j <= n ; j ++){\n\t\t\tsum += dp[i-1][j];\n\t\t\tsum %= M;\n\t\t\tdp[i][j] = sum*f[(n-i)*k+i-j+k-2];\n\t\t\tdp[i][j] %= M;\n\t\t}\n\t}\n\trep1(i,n){\n\t\tdp[n][n] *= i;\n\t\tdp[n][n] %= M;\n\t}\n\tcout << dp[n][n] << endl;\n}\n\t\t\t\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MAXN = 2010, md = 1e9 + 7;\nint n, k;\nint dp[2 * MAXN][MAXN], fact[MAXN * MAXN], inv_fact[MAXN * MAXN];\nint combination(int k, int n) {\n    if (k > n)\n        return 0;\n    return (fact[n] * inv_fact[k] % md) * inv_fact[n - k] % md;\n}  \nint power(int n, int p) {\n    int res = 1;\n    for (;p; p >>= 1, n = n * n % md)\n        if (p & 1)\n            res = res * n % md;\n    return res;\n}\nint32_t main () {\n    fact[0] = 1;\n    for (int i = 1; i < MAXN * MAXN; ++i)\n        fact[i] = fact[i - 1] * i % md;\n    inv_fact[MAXN * MAXN - 1] = power(fact[MAXN * MAXN - 1], md - 2);\n    for (int i = MAXN * MAXN - 1; i; --i)\n        inv_fact[i - 1] = inv_fact[i] * i % md;\n    cin >> n >> k;\n    if (k == 1)\n        return cout << 1, 0;\n    dp[0][0] = 1;\n    for (int i = 0; i < 2 * n; ++i) {\n        for (int j = 0; j <= min(n, i); ++j) {\n            if (j < n) {\n                dp[i + 1][j + 1] += dp[i][j];\n                if (dp[i + 1][j + 1] >= md)\n                    dp[i + 1][j + 1] %= md;\n            }\n            if (j) {\n                dp[i + 1][j - 1] += dp[i][j] * combination(k - 2, n * k - k * (i - j) / 2 - j - 1) % md;\n                if (dp[i + 1][j - 1] >= md)\n                    dp[i + 1][j - 1] %= md;\n            }\n            // cout << i << ' ' << j << '\\n';\n        }\n    }\n    for (int i= 1; i <= n; ++i)\n        dp[2 * n][0] = dp[2 * n][0] * i % md;\n    cout << dp[2 * n][0];\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// vvvvvvvvvvvvvvvvv Library code start\n\n\n#define NDEBUG\nNDEBUG\n\n\n#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <memory>\n#include <random>\n\n\n#define forn(t, i, n) for (t i = 0; i < (n); ++i)\n\n\nusing namespace std;\n\n/// caide keep\nbool __hack = std::ios::sync_with_stdio(false);\n/// caide keep\nauto __hack1 = cin.tie(nullptr);\n\n\n#define ENABLE_IF(e) typename enable_if<e>::type* = nullptr\n\nnamespace template_util {\n    template<class T>\n    constexpr T min(T a, T b) {\n        return a < b ? a : b;\n    }\n\n    \n    constexpr int bytecount(uint64_t x) {\n        return x ? 1 + bytecount(x >> 8) : 0;\n    }\n\n    /// caide keep\n    template<int N>\n    struct bytetype {\n        typedef uint64_t type;\n    };\n\n    /// caide keep\n    template<>\n    struct bytetype<4> {\n        typedef uint32_t type;\n    };\n\n    /// caide keep\n    template<>\n    struct bytetype<3> {\n        typedef uint32_t type;\n    };\n\n    /// caide keep\n    template<>\n    struct bytetype<2> {\n        \n    };\n\n    /// caide keep\n    template<>\n    struct bytetype<1> {\n        typedef uint8_t type;\n    };\n\n    /// caide keep\n    template<>\n    struct bytetype<0> {\n        typedef uint8_t type;\n    };\n\n    /// caide keep\n    template<uint64_t N>\n    struct minimal_uint : bytetype<bytecount(N)> {\n    };\n}\n\n\n/*\nTODOs:\n cache invs\n primitive root\n discrete log\n\n tests!!!\n*/\n\nnamespace mod_impl {\n    /// caide keep\n    template <class T>\n    constexpr inline T mod(T MOD) {\n        return MOD;\n    }\n\n    /// caide keep\n    template <class T>\n    constexpr inline T mod(T* MOD) {\n        return *MOD;\n    }\n\n    /// caide keep\n    template <class T>\n    constexpr inline T max_mod(T MOD) {\n        return MOD - 1;\n    }\n\n    /// caide keep\n    template <class T>\n    constexpr inline T max_mod(T*) {\n        return numeric_limits<T>::max() - 1;\n    }\n\n    \n    constexpr inline uint64_t combine_max_sum(uint64_t a, uint64_t b) {\n        return a > ~b ? 0 : a + b;\n    }\n\n    constexpr inline uint64_t combine_max_mul(uint64_t a, uint64_t b) {\n        return a > numeric_limits<uint64_t>::max() / b ? 0 : a * b;\n    }\n\n    /// caide keep\n    template <class T>\n    constexpr inline uint64_t next_divisible(T mod, uint64_t max) {\n        return max % mod == 0 ? max : combine_max_sum(max, mod - max % mod);\n    }\n\n    /// caide keep\n    template <class T>\n    constexpr inline uint64_t next_divisible(T*, uint64_t) {\n        return 0;\n    }\n\n    //caide keep\n    constexpr int IF_THRESHOLD = 2;\n\n    template <class T, T MOD_VALUE, uint64_t MAX,\n            class RET = typename template_util::minimal_uint<max_mod(MOD_VALUE)>::type,\n            ENABLE_IF(MAX <= max_mod(MOD_VALUE) && !is_pointer<T>::value)>\n    inline RET smart_mod(typename template_util::minimal_uint<MAX>::type value) {\n        return value;\n    }\n\n    template <class T, T MOD_VALUE, uint64_t MAX,\n            class RET = typename template_util::minimal_uint<max_mod(MOD_VALUE)>::type,\n            ENABLE_IF(max_mod(MOD_VALUE) < MAX && MAX <= IF_THRESHOLD * max_mod(MOD_VALUE) && !is_pointer<T>::value)>\n    inline RET smart_mod(typename template_util::minimal_uint<MAX>::type value) {\n        while (value >= mod(MOD_VALUE)) {\n            value -= mod(MOD_VALUE);\n        }\n        return (RET)value;\n    }\n\n    template <class T, T MOD_VALUE, uint64_t MAX,\n             class RET = typename template_util::minimal_uint<max_mod(MOD_VALUE)>::type,\n             ENABLE_IF(IF_THRESHOLD * max_mod(MOD_VALUE) < MAX || is_pointer<T>::value)>\n    inline RET smart_mod(typename template_util::minimal_uint<MAX>::type value) {\n        return (RET)(value % mod(MOD_VALUE));\n    }\n}\n\n\n#define MAX_MOD mod_impl::max_mod(MOD_VALUE)\n\nstruct DenormTag {};\n\ntemplate <class T, T MOD_VALUE, uint64_t MAX = MAX_MOD, ENABLE_IF(MAX_MOD >= 2)>\nstruct ModVal {\n    typedef typename template_util::minimal_uint<MAX>::type storage;\n    storage value;\n\n    /// caide keep\n    inline ModVal(): value(0) {\n        assert(MOD >= 2);\n    }\n\n    \n    inline ModVal(storage v, DenormTag): value(v) {\n        assert(MOD >= 2);\n        assert(v <= MAX);\n    };\n\n    inline operator ModVal<T, MOD_VALUE>() {\n        return {v(), DenormTag()};\n    };\n\n    \n    typename template_util::minimal_uint<mod_impl::max_mod(MOD_VALUE)>::type v() const {\n        return mod_impl::smart_mod<T, MOD_VALUE, MAX>(value);\n    }\n};\n\ntemplate <class T, T MOD_VALUE, uint64_t MAX,\n        uint64_t NEW_MAX = mod_impl::next_divisible(MOD_VALUE, MAX),\n        ENABLE_IF(NEW_MAX != 0),\n        class Ret = ModVal<T, MOD_VALUE, NEW_MAX>>\ninline Ret operator-(const ModVal<T, MOD_VALUE, MAX>& o) {\n    static_assert(NEW_MAX <= numeric_limits<typename Ret::storage>::max(), \"bad unary minus template\");\n    assert(NEW_MAX % MOD == 0 && o.value <= NEW_MAX);\n    return {typename Ret::storage(NEW_MAX - o.value), DenormTag()};\n}\n\n\ntemplate <class T, T MOD_VALUE, uint64_t MAX1, uint64_t MAX2,\n        uint64_t NEW_MAX = mod_impl::combine_max_sum(MAX1, MAX2),\n        ENABLE_IF(NEW_MAX != 0), class Ret = ModVal<T, MOD_VALUE, NEW_MAX>>\ninline Ret operator+(ModVal<T, MOD_VALUE, MAX1> o1, ModVal<T, MOD_VALUE, MAX2> o2) {\n    return {typename Ret::storage(typename Ret::storage() + o1.value + o2.value), DenormTag()};\n}\n\n\ntemplate <class T, T MOD_VALUE, uint64_t MAX1, uint64_t MAX2,\n        uint64_t NEW_MAX = mod_impl::combine_max_mul(MAX1, MAX2),\n        ENABLE_IF(NEW_MAX != 0), class Ret = ModVal<T, MOD_VALUE, NEW_MAX>>\ninline Ret operator*(ModVal<T, MOD_VALUE, MAX1> o1, ModVal<T, MOD_VALUE, MAX2> o2) {\n    return {typename Ret::storage(typename Ret::storage(1) * o1.value * o2.value), DenormTag()};\n}\n\n\ntemplate <class T, T MOD_VALUE, uint64_t MAX1, uint64_t MAX2,\n        uint64_t NEW_MAX = mod_impl::combine_max_mul(MAX1, MAX2),\n        uint64_t NEW_MAX1 = mod_impl::combine_max_mul(MAX_MOD, template_util::min(MAX1, MAX2)),\n        ENABLE_IF(NEW_MAX == 0 && NEW_MAX1 != 0 && MAX2 < MAX1),\n        class Ret = ModVal<T, MOD_VALUE, mod_impl::combine_max_mul(MAX_MOD, MAX2)>>\ninline Ret operator*(const ModVal<T, MOD_VALUE, MAX1>& o1, const ModVal<T, MOD_VALUE, MAX2>& o2) {\n    return {typename Ret::storage(typename Ret::storage(1) * o1.v() * o2.value), DenormTag()};\n}\n\n\ntemplate <class T, T MOD_VALUE, uint64_t MAX>\ninline ModVal<T, MOD_VALUE>& operator+=(ModVal<T, MOD_VALUE>& lhs, const ModVal<T, MOD_VALUE, MAX>& rhs) {\n    lhs = lhs + rhs;\n    return lhs;\n}\n\n\ntemplate <class T, T MOD_VALUE, class MOD_TYPE>\nstruct ModCompanion {\n    typedef MOD_TYPE mod_type;\n    typedef ModVal<mod_type, MOD_VALUE> type;\n    static T mod;\n\n    \n    template <uint64_t C>\n    inline static constexpr ModVal<mod_type, MOD_VALUE, C> c() {\n        return {C, DenormTag()};\n    };\n\n    template <uint64_t MAX = numeric_limits<uint64_t>::max()>\n    inline static ModVal<mod_type, MOD_VALUE, MAX> wrap(uint64_t x) {\n        assert(x <= MAX);\n        return {typename ModVal<mod_type, MOD_VALUE, MAX>::storage(x), DenormTag()};\n    };\n\n    \n};\n\ntemplate <class T, T MOD_VALUE, class MOD_TYPE>\nT ModCompanion<T, MOD_VALUE, MOD_TYPE>::mod = MOD_VALUE;\n\n\n#undef MAX_MOD\n\ntemplate <uint64_t MOD_VALUE>\nstruct Mod : ModCompanion<uint64_t, MOD_VALUE, typename template_util::minimal_uint<MOD_VALUE>::type> {\n    template<uint64_t VAL>\n    static constexpr uint64_t literal_builder() {\n        return VAL;\n    }\n\n    template<uint64_t VAL, char DIGIT, char... REST>\n    static constexpr uint64_t literal_builder() {\n        return literal_builder<(10 * VAL + DIGIT - '0') % MOD_VALUE, REST...>();\n    }\n};\n\n\ntemplate <class MD, int Threshold = 16777216>\nstruct FastInvMod {\n    using MT = typename MD::type;\n\n    FastInvMod(): cache{MD::template wrap<0>(0), MD::template wrap<1>(1)} {}\n\n    MT operator()(MT x) {\n        if (x.value < Threshold) {\n            while (cache.size() <= x.value) {\n                cache.push_back(eval(MD::template wrap<Threshold>(cache.size())));\n            }\n            return cache[x.value];\n        }\n        return eval(x);\n    }\nprivate:\n    MT eval(MT x) {\n        if (x.value < cache.size()) {\n            return cache[x.value];\n        }\n        //TODO proper bounds\n        return -(MD::wrap(mod_impl::mod(MD::mod) / x.value) * eval(MD::wrap(mod_impl::mod(MD::mod) % x.value)));\n    }\n\n    vector<MT> cache;\n};\n\n#define REGISTER_MOD_LITERAL(mod, suffix) \\\ntemplate <char... DIGITS> mod::type operator \"\" _##suffix() { \\\n    return mod::c<mod::literal_builder<0, DIGITS...>()>(); \\\n}\n\n\ntemplate <class T, T MOD_VALUE, uint64_t MAX>\ninline ostream& operator<<(ostream& s, ModVal<T, MOD_VALUE, MAX> val) {\n    s << val.v();\n    return s;\n}\n\n\nnamespace option_detail {\n    /// caide keep\n    struct NoneHelper {};\n}\n\n\ntemplate<class Value>\nclass Option {\npublic:\n    \n\n    static_assert(!std::is_reference<Value>::value,\n                  \"Option may not be used with reference types\");\n    static_assert(!std::is_abstract<Value>::value,\n                  \"Option may not be used with abstract types\");\n\n    \n    Value* get_pointer() && = delete;\n\n    \n    // Return b copy of the value if set, or b given default if not.\n    \n\n    // Return b copy of the value if set, or b given default if not.\n    \n\nprivate:\n    \n\n    struct StorageTriviallyDestructible {\n        // uninitialized\n        \n        bool hasValue;\n\n        \n    };\n\n    /// caide keep\n    struct StorageNonTriviallyDestructible {\n        // uninitialized\n        union { Value value; };\n        bool hasValue;\n\n        \n        ~StorageNonTriviallyDestructible() {\n            clear();\n        }\n\n        void clear() {\n            if (hasValue) {\n                hasValue = false;\n                value.~Value();\n            }\n        }\n    };\n\n    /// caide keep\n    using Storage =\n    typename std::conditional<std::is_trivially_destructible<Value>::value,\n            StorageTriviallyDestructible,\n            StorageNonTriviallyDestructible>::type;\n\n    Storage storage_;\n};\n\n\n// Comparisons.\n\n\ntemplate<class V> bool operator< (const Option<V>&, const V& other) = delete;\ntemplate<class V> bool operator<=(const Option<V>&, const V& other) = delete;\ntemplate<class V> bool operator>=(const Option<V>&, const V& other) = delete;\ntemplate<class V> bool operator> (const Option<V>&, const V& other) = delete;\ntemplate<class V> bool operator< (const V& other, const Option<V>&) = delete;\ntemplate<class V> bool operator<=(const V& other, const Option<V>&) = delete;\ntemplate<class V> bool operator>=(const V& other, const Option<V>&) = delete;\ntemplate<class V> bool operator> (const V& other, const Option<V>&) = delete;\n\n\nnamespace index_iterator_impl {\n    template <class T>\n    struct member_dispatch_helper {\n        \n\n    private:\n        T value;\n    };\n\n    // Have to caide keep all the members to comply to iterator concept\n    // Otherwise generated code won't be portable between clang and g++\n    template <class C, bool reverse = false>\n    struct index_iterator {\n        /// caide keep\n        typedef random_access_iterator_tag iterator_category;\n        /// caide keep\n        typedef decltype(((C*)nullptr)->operator[](size_t(0))) reference;\n        /// caide keep\n        typedef typename remove_reference<reference>::type value_type;\n        /// caide keep\n        typedef ptrdiff_t difference_type;\n        /// caide keep\n        typedef conditional<\n                is_reference<reference>::value,\n                typename add_pointer<value_type>::type,\n                member_dispatch_helper<value_type>> pointer;\n\n        /// caide keep\n        typedef index_iterator<C, reverse> self_t;\n\n        /// caide keep\n        static const difference_type dir = reverse ? -1 : 1;\n\n        /// caide keep\n        index_iterator() = default;\n\n        \n        /// caide keep\n        inline bool operator!=(const self_t& o) { return index != o.index; }\n        /// caide keep\n        inline bool operator<(const self_t& o) { return reverse ? index > o.index : index < o.index; }\n        /// caide keep\n        inline bool operator>(const self_t& o) { return reverse ? index < o.index : index > o.index; }\n        /// caide keep\n        inline bool operator<=(const self_t& o) { return reverse ? index >= o.index : index <= o.index; }\n        /// caide keep\n        inline bool operator>=(const self_t& o) { return reverse ? index <= o.index : index >= o.index; }\n\n        /// caide keep\n        inline reference operator*() { return (*container)[index]; }\n        /// caide keep\n        inline const reference operator*() const { return (*container)[index]; }\n        /// caide keep\n        inline pointer operator->() { return pointer((*container)[index]); }\n\n        /// caide keep\n        inline self_t& operator++() { index += dir; return *this; }\n        /// caide keep\n        inline self_t operator++(int) { auto copy = *this; index += dir; return copy; }\n        /// caide keep\n        inline self_t& operator--() { index -= dir; return *this; }\n        /// caide keep\n        inline self_t operator--(int) { auto copy = *this; index -= dir; return copy; }\n\n        /// caide keep\n        inline self_t& operator+=(difference_type n) { index += dir * n; return *this; };\n        /// caide keep\n        inline self_t& operator-=(difference_type n) { index -= dir * n; return *this; };\n        /// caide keep\n        inline friend self_t operator-(self_t a, difference_type n) { return a -= n; };\n        /// caide keep\n        inline friend self_t operator+(difference_type n, self_t a) { return a += n; };\n        /// caide keep\n        inline friend self_t operator+(self_t a, difference_type n) { return a += n; };\n        /// caide keep\n        inline friend difference_type operator-(const self_t& a, const self_t& b) { return dir * (a.index - b.index); };\n\n        /// caide keep\n        inline reference operator[](difference_type n) { return (*container)[index + dir * n]; };\n        /// caide keep\n        inline const reference operator[](difference_type n) const { return (*container)[index + dir * n]; };\n\n    private:\n        C* container;\n        difference_type index;\n    };\n}\n\n\nnamespace multivec_impl {\n    template <size_t NDIMS>\n    struct shape {\n        size_t dim, stride;\n        shape<NDIMS - 1> subshape;\n        \n        shape(size_t dim_, shape<NDIMS - 1>&& s): dim(dim_), stride(s.size()), subshape(std::move(s)) {}\n        size_t size() const { return dim * stride; }\n        \n        \n    };\n    template <> struct shape<0> { size_t size() const { return 1; } };\n    \n\n    template <size_t I, size_t NDIMS>\n    struct __shape_traverse {\n        \n\n        ///caide keep\n        static const shape<NDIMS - I>& get_subshape(const shape<NDIMS>& s) {\n            return __shape_traverse<I - 1, NDIMS - 1>::get_subshape(s.subshape);\n        }\n    };\n\n    \n    ///caide keep\n    template <size_t I, size_t NDIMS>\n    const shape<NDIMS - I>& get_subshape(const shape<NDIMS>& s) { return __shape_traverse<I, NDIMS>::get_subshape(s); }\n\n    \n    template <class Index, class... Rest, size_t NDIMS, ENABLE_IF(is_integral<Index>::value)>\n    size_t get_shift(const shape<NDIMS>& s, size_t cur_shift, Index i, Rest... is) {\n        assert(0 <= i && i < s.dim);\n        return get_shift(s.subshape, cur_shift + i * s.stride, is...);\n    }\n\n    template <size_t NDIMS> size_t get_shift(const shape<NDIMS>&, size_t cur_shift) { return cur_shift; }\n\n    \n    template <class... T> shape<sizeof...(T)> make_shape(T... dims);\n\n    template <class Dim, class... Rest, ENABLE_IF(is_integral<Dim>::value)>\n    shape<sizeof...(Rest) + 1> make_shape(Dim dim, Rest... dims) {\n        assert(dim >= 0);\n        return {(size_t)dim, make_shape<Rest...>(dims...)};\n    }\n\n    template <> shape<0> make_shape() { return {}; }\n\n    \n    ///caide keep\n    template <class T, size_t NDIMS>\n    struct vec_view_base;\n\n    template <template<class, size_t> class Base, class T, size_t NDIMS>\n    struct vec_mixin : public Base<T, NDIMS> {\n        using Base<T, NDIMS>::Base;\n        /// caide keep\n        typedef Base<T, NDIMS> B;\n        \n        \n        ///caide keep\n        template <class... Indices, bool enabled = NDIMS == sizeof...(Indices), ENABLE_IF(enabled)>\n        inline T& operator()(Indices... is) {\n            size_t i = multivec_impl::get_shift(B::s, 0, is...);\n            return B::data[i];\n        }\n\n        ///caide keep\n        template <class... Indices, bool enabled = sizeof...(Indices) < NDIMS, ENABLE_IF(enabled)>\n        inline vec_mixin<vec_view_base, T, NDIMS - sizeof...(Indices)> operator()(Indices... is) {\n            size_t shift = multivec_impl::get_shift(B::s, 0, is...);\n            const auto& subshape = multivec_impl::get_subshape<sizeof...(Indices)>(B::s);\n            return {subshape, &B::data[shift]};\n        }\n\n        \n        inline void fill(const T& val) {\n            std::fill(raw_data(), raw_data() + B::s.size(), val);\n        };\n\n        \n//    protected:\n        inline T* raw_data() {\n            return &B::data[0];\n        }\n\n        \n    };\n\n    template <class T, size_t NDIMS>\n    struct vec_view_base {\n        \n        \n    protected:\n        multivec_impl::shape<NDIMS> s;\n        T* data;\n    };\n\n    template <class T, size_t NDIMS>\n    struct vec_base {\n        inline vec_base(multivec_impl::shape<NDIMS>&& s_): s(move(s_)), data(new T[s.size()]) {}\n        \n        \n        inline vec_base(const vec_base& o): s(o.s), data(new T[s.size()]) {\n            memcpy(data.get(), o.data.get(), sizeof(T) * s.size());\n        }\n        \n    protected:\n        multivec_impl::shape<NDIMS> s;\n        unique_ptr<T[]> data;\n    };\n}\n\n/*\nTODO\n - do we need vec_view_const?\n - add more features (lambda initialization etc.)\n - properly use const\n - proper tests coverage\n*/\n\ntemplate <class T, size_t NDIMS>\nusing vec = multivec_impl::vec_mixin<multivec_impl::vec_base, T, NDIMS>;\n\n\ntemplate <class T, class... NDIMS>\ninline vec<T, sizeof...(NDIMS)> make_vec(NDIMS... dims) {\n    return {multivec_impl::make_shape(dims...)};\n}\n\n\ntemplate<class T>\nT next(istream& in) {\n    T ret;\n    in >> ret;\n    return ret;\n}\n\n\n// ^^^^^^^^^^^^^^^^^ Library code end\n\nconst uint32_t mod = 1000000007;\nusing md = Mod<mod>;\nusing mt = md::type;\nREGISTER_MOD_LITERAL(md, mod)\n\nvoid solve(istream& in, ostream& out) {\n    int n = next<int>(in);\n    int k = next<int>(in);\n    if (k == 1) {\n        out << \"1\\n\";\n        return;\n    }\n    FastInvMod<md> invMod;\n    vector<mt> f(n * k + 1), invF(n * k + 1);\n    f[0] = 1_mod;\n    invF[0] = 1_mod;\n    forn (int, i, n * k) {\n        f[i + 1] = f[i] * md::wrap<4000000>(i + 1);\n        invF[i + 1] = invF[i] * invMod(md::wrap<4000000>(i + 1));\n    }\n    auto C = [&](int n, int k) -> mt {\n        if (n < 0) {\n            return 0_mod;\n        }\n        return f[n] * invF[k] * invF[n - k];\n    };\n    auto din = make_vec<mt>(n + 1, n + 1);\n    din.fill(0_mod);\n    din(0, 0) = 1_mod;\n    forn (int, i, n + 1) {\n        forn (int, j, i + 1) {\n            if (i < n) {\n                din(i + 1, j) += din(i, j);\n            }\n            if (j < i) {\n                din(i, j + 1) += din(i, j) * C(n * k - i - j * (k - 1) - 1, k - 2);\n            }\n        }\n    }\n    out << din(n, n) * f[n] << \"\\n\";\n}\n\n\nint main() {\n    solve(cin, cout);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define rep(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\nconst int mod=1e9+7;\nconst int N=2010,M=4000100;\nconst int maxn=4000000;\nint dp[N*2][N];\nint cj[M],inv[M];\nint ans;\n\nint C(int n,int m){\n\treturn 1ll*cj[n]*inv[m]%mod*inv[n-m]%mod;\n}\n\nint power(int x,int y){\n\tint ret=1;\n\tfor(;y;y>>=1,x=1ll*x*x%mod){\n\t\tif(y&1)\tret=1ll*ret*x%mod;\n\t}\n\treturn ret;\n}\n\nint main(){\n\t//freopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\tint n,K,i,j,k;\n\tscanf(\"%d%d\",&n,&K);\n\tif(K==1){printf(\"1\\n\");return 0;}\n\tfor(cj[0]=1,i=1;i<=maxn;i++)\tcj[i]=1ll*cj[i-1]*i%mod;\n\tinv[maxn]=power(cj[maxn],mod-2);inv[0]=1;\n\tfor(i=maxn-1;i;i--)\tinv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tdp[0][0]=1;\n\trep(i,0,2*n-1)\trep(j,0,n)\tif(dp[i][j]){\n\t\tk=(i-j)/2;\n\t\tdp[i+1][j+1]=(dp[i+1][j+1]+dp[i][j])%mod;\t\t\n\t\tif(j)\tdp[i+1][j-1]=(dp[i+1][j-1]+1ll*dp[i][j]*C(n*K-i-1-(K-2)*k,K-2))%mod;\n\t}\n\tans=1ll*dp[2*n][0]*cj[n]%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2000 + 20, M = 4 * 1000 * 1000 + 20, mod = 1e9 + 7;\nint n, k, fact[M], factRev[M], dp[N][N];\n\nint sum(int a, int b) {\n\treturn ((1LL * a + b) % mod + mod) % mod;\n}\n\nint mul(int a, int b) {\n\treturn ((1LL * a * b) % mod + mod) % mod;\n}\n\nint pw(int a, int b) {\n\tint res = 1, tmp = a;\n\twhile (b) {\n\t\tif (b & 1)\n\t\t\tres = mul(res, tmp);\n\t\ttmp = mul(tmp, tmp);\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint c(int a, int b) {\n\treturn mul(fact[a], mul(factRev[b], factRev[a - b]));\n}\n\nvoid prepros() {\n\tfact[0] = 1;\n\tfor (int i = 1; i < M; i++)\n\t\tfact[i] = mul(fact[i - 1], i);\n\tfactRev[M - 1] = pw(fact[M - 1], mod - 2);\n\tfor (int i = M - 2; ~i; i--)\n\t\tfactRev[i] = mul(factRev[i + 1], i + 1);\n}\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n >> k;\n\tprepros();\n\tif (k == 1)\n\t\treturn cout << 1 << endl, 0;\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 0; j <= i; j++) {\n\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\tif (j)\n\t\t\t\tdp[i][j] = sum(dp[i][j], mul(dp[i][j - 1], c((n * k) - ((j - 1) * (k - 1)) - i - 1, k - 2)));\n\t\t}\n\treturn cout << mul(dp[n][n], fact[n]) << \"\\n\", 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "    #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n//    int dx[8]={0,1,0,-1,1,1,-1,-1};\n  //  int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                        \n\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nll extgcd(ll a, ll b, ll &x, ll &y) {\n    if (b == 0ll) {\n        x = 1ll;\n        y = 0ll;\n        return a;\n    }\n    ll d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n} \n                                \n                int pr[4200010];\n                int inv[4200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tinv[ert]=beki(pr[ert],mod-2,mod);\n                \t\n                \tfor(int i=ert-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    //mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\t   \n       \n                               //----------------kokomade tenpure------------\n\n\n\tint n,k;\nint ans[2020][2020]={};\nbool sumi[2020][2020]={};\nint dfs(int a,int b){\n\tassert(a>=b);\n\tif(sumi[a][b])return ans[a][b];\n\tsumi[a][b]=1;\n\tif(a==n&& b==n){\n\t\tans[a][b]=1;\n\t\treturn 1;\n\t}\n\tif(a==n+1){\n\t\tint t1=(n-b)*(k-1);\n\t\tint t2=k-2;\n\t\t\n\t\tint iti=comb(t1+t2,t1);\n\t\titi*=dfs(a,b+1);\n\t\titi%=inf;\n\t\tans[a][b]=iti;\n\t\treturn ans[a][b];\n\t\t\n\t}\n\tif(a==b){\n\t\tans[a][b]=dfs(a+1,b);\n\t\treturn ans[a][b];\n\t}\n\t\n\t{\n\t\tans[a][b]=dfs(a+1,b);\n\t\t\n\t\tint t1=k-2;\n\t\tint t2=(n-b)*(k-1)+n-a+1;\n\t\tint iti=comb(t1+t2,t1);\n\t\titi*=dfs(a,b+1);\n\t\titi%=inf;\n\t\tans[a][b]+=iti;\n\t\tans[a][b]%=inf;\n\t\treturn ans[a][b];\n\t}\n}\n\n\nsigned main(){\n\n\t\t\t  cin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin>>n>>k;\n\tif(k==1){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tmod=inf;\n\t\n\tgya(2002*2002);\n\t\n\tsumi[n+1][n]=1;\n\tans[n+1][n]=1;\n\tint t=dfs(1,1);\n\t\n//\tfor(int i=1;i<=n+1;i++)for(int j=1;j<=i;j++){\n//\t\tcout<<i<<\" \"<<j<<\" \"<<ans[i][j]<<endl;\n//\t}\n\t\n\tfor(int i=1;i<=n;i++){\n\t\tt*=i;\n\t\tt%=inf;\n\t}\n\tcout<<t<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,k,mx,f[2010][2010],a1[4000010],a2[4000010],b[4000010];\nvoid add(int &x,int y)\n{\n\tx+=y;\n\tx%=1000000007;\n}\nint js(int n,int m)\n{\n\treturn 1ll*a1[n]*a2[m]%1000000007*a2[n-m]%1000000007;\n}\nint main()\n{\n\tcin>>n>>k;\n\tmx=n*k;\n\tif(k==1)\n\t{\n\t\tcout<<1;\n\t\treturn 0;\n\t}\n\ta1[0]=a2[0]=b[0]=b[1]=1;\n\tfor(int i=1;i<=n*k;i++)\n\t{\n\t\ta1[i]=1ll*a1[i-1]*i%1000000007;\n\t}\n\tfor(int i=2;i<=n*k;i++)\n\t{\n\t\tb[i]=1ll*b[1000000007%i]*(1000000007-1000000007/i)%1000000007;\n\t}\n\tfor(int i=1;i<=n*k;i++)\n\t{\n\t\ta2[i]=1ll*a2[i-1]*b[i]%1000000007;\n\t}\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=0;j<=i;++j)\n\t\t{\n\t\t\tadd(f[i][j],f[i-1][j]);\n\t\t\tif(j!=0)\n\t\t\t{\n\t\t\t\tadd(f[i][j],1ll*f[i][j-1]*(n-j+1)%1000000007*js((n-i)+(n-j+1)*(k-1)-1,k-2)%1000000007);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<f[n][n];\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\ntypedef long long ll;\nconst int N = 2e3 + 5;\nconst int A = 4e6 + 6;\nconst int Mod = 1e9 + 7;\nint n, m, Ax, g[N][N], fac[A], Ifac[A];\ninline int pow(int x, int k) {\n\tll res = 1, r = x;\n\tfor (; k; k >>= 1, (r *= r) %= Mod)\n\t\tif (k & 1) (res *= r) %= Mod;\n\treturn res;\n}\ninline int calc(int n, int m) {\n\treturn (ll)fac[n] * Ifac[m] % Mod * Ifac[n - m] % Mod;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tif (m == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\t\n\tAx = n * m, fac[0] = 1;\n\tfor (int i = 1; i <= Ax; ++i) fac[i] = (ll)fac[i - 1] * i % Mod;\n\t\n\tIfac[Ax] = pow(fac[Ax], Mod - 2);\n\tfor (int i = Ax; i; --i) Ifac[i - 1] = (ll)Ifac[i] * i % Mod;\n\t\n\tg[0][0] = 1;\n\tfor (int k = 1; k <= n; ++k)\n\t\tfor (int i = 0; i + k <= n + 1; ++i)\n\t\t\tif (g[k - 1][i]) {\n\t\t\t\tfor (int x = 0; k + i + x - 1 <= n; ++x) {\n\t\t\t\t\tif (!(i + x)) continue;\n\t\t\t\t\tint ret = Ax - (k - 1) * m - i - x - 1;\n\t\t\t\t\t(g[k][i + x - 1] += (ll)g[k - 1][i] * calc(ret, m - 2) % Mod) %= Mod;\n\t\t\t\t}\n\t\t\t}\n\t\n\tprintf(\"%lld\\n\", (ll)g[n][0] * fac[n] % Mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int N=2010,M=4000010;\nconst ll mod=1e9+7;\nll dp[N][N],d1[M],d2[M];\nint n,k,max1;\ninline ll f(ll y,ll x){\n\tll t=y,s=1;if(x%2)s=y;x>>=1;\n\twhile(x){t=(t*t)%mod;if(x%2)s=(s*t)%mod;x>>=1;}\n\treturn s;\n}\ninline ll c(int m,int n){\n\t//printf(\"c%d %d %lld\\n\",m,n,((d1[n]*d2[m])%mod*d2[n-m])%mod);\n\treturn ((d1[n]*d2[m])%mod*d2[n-m])%mod;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);max1=n*k;\n\tif(k==1){printf(\"1\");return 0;}\n\td1[0]=1;d2[0]=1;\n\tfor(int i=1;i<=max1;i++)d1[i]=(d1[i-1]*i)%mod;\n\td2[max1]=f(d1[max1],mod-2);//printf(\"%lld \",d2[max1]);\n\tfor(int i=max1-1;i>=1;i--)d2[i]=(d2[i+1]*(i+1))%mod;\n\tdp[1][0]=1;dp[1][1]=(c(k-2,max1-2)*n)%mod;//printf(\"1 1 %lld\\n\",dp[1][1]);\n\tfor(int i=2;i<=n;i++){\n\t\tdp[i][0]=1;\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tdp[i][j]=(dp[i-1][j]+((dp[i][j-1]*c(k-2,max1-i-1-(j-1)*(k-1)))%mod*(n-j+1))%mod)%mod;\n\t\t\t//printf(\"%d %d %lld\\n\",i,j,dp[i][j]);\n\t\t}\n\t}\n\tprintf(\"%lld\",dp[n][n]);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for (int i = a; i <= b; i++)\n#define per(i, a, b) for (int i = a; i >= b; i--)\ntypedef long long LL;\nconst LL mod = 1e9 + 7;\n// head\nconst int maxn = 2e3 + 5;\nint n, k;\nLL f[maxn][maxn], fac[maxn*maxn], inv[maxn*maxn];\n\nLL ksm(LL a, LL b) {\n\tLL res = 1;\n\twhile(b) {\n\t\tif(b%2) res = res*a%mod;\n\t\tb /= 2;\n\t\ta = a*a%mod;\n\t}\n\treturn res;\n}\n\nLL comb(LL a, LL b) {\n\treturn fac[a]*inv[b]%mod*inv[a - b]%mod;\n}\n\nint main() {\n\tcin>>n>>k;\n\tfac[0] = inv[0] = 1;\n\trep(i, 1, n)\n\t    fac[i] = fac[i - 1]*i%mod, inv[i] = ksm(fac[i], mod - 2);\n\tf[0][0] = 1;\n\trep(i, 1, n)\n\t    rep(j, 0, i) {\n\t    \tif(i > j) f[i][j] = (f[i][j] + f[i - 1][j])%mod;\n\t    \tif(j) f[i][j] = (f[i][j] + f[i][j - 1]*(n - j + 1)%mod*comb(n*k - i - (j - 1)*(n - 1) - 1, n - 2)%mod)%mod;\n\t    }\n\tcout<<f[n][n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint getint()\n{\n\tint i=0,f=1;char c;\n\tfor(c=getchar();(c!='-')&&(c<'0'||c>'9');c=getchar());\n\tif(c=='-')f=-1,c=getchar();\n\tfor(;c>='0'&&c<='9';c=getchar())i=(i<<3)+(i<<1)+c-'0';\n\treturn i*f;\n}\nconst int N=2005,mod=1e9+7;\nint n,k,m;\nll f[N][N],fac[N*N],invfac[N*N];\nll Pow(ll x,int y)\n{\n\tll res=1;\n\tfor(;y;y>>=1,x=x*x%mod)\n\t\tif(y&1)res=res*x%mod;\n\treturn res;\n}\nll C(int x,int y)\n{\n\tif(x<y||x<0||y<0)return 0;\n\treturn fac[x]*invfac[y]%mod*invfac[x-y]%mod;\n}\nint main()\n{\n\t//freopen(\"lx.in\",\"r\",stdin);\n\tn=getint(),k=getint(),m=n*k;\n\tif(k==1){puts(\"1\");return 0;}\n\tfac[0]=1;for(int i=1;i<=m;i++)fac[i]=fac[i-1]*i%mod;\n\tinvfac[m]=Pow(fac[m],mod-2);\n\tfor(int i=m-1;i>=0;i--)invfac[i]=invfac[i+1]*(i+1)%mod;\n\tf[0][0]=1;--k;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=i;j<=n;j++)if(f[i][j])\n\t\t{\n\t\t\tf[i+1][j]=(f[i+1][j]+f[i][j])%mod;\n\t\t\tf[i][j+1]=(f[i][j+1]+f[i][j]*C(i+j*k+k,k-1))%mod;\n\t\t}\n\tcout<<f[n][n]*fac[n]%mod<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<cmath>\n#include<iostream>\n#include<queue>\n#include<string>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<long long,long long> pll;\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define rep(i,j,k)  for(register int i=(int)(j);i<=(int)(k);i++)\n#define rrep(i,j,k) for(register int i=(int)(j);i>=(int)(k);i--)\n\nll read(){\n\tll x=0,f=1;char c=getchar();\n\twhile(c<'0' || c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0' && c<='9'){x=x*10+c-'0';c=getchar();}\n\treturn x*f;\n}\n\nconst int mod=1e9+7;\nconst int maxn=3050;\nint n,k;\nll f[maxn][maxn];\nll fac[maxn*maxn],inv[maxn*maxn];\n\ninline int C(int x,int y){\n\tif(x<y) return 0;\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\n\nint main(){\n\tn=read(),k=read();\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\trep(i,1,3000*3000) fac[i]=fac[i-1]*i%mod;\n\tinv[0]=inv[1]=1;\n\trep(i,2,3000*3000) inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\trep(i,1,3000*3000) inv[i]=inv[i]*inv[i-1]%mod;\n\tf[0][0]=1;\n\trep(i,1,n){\n\t\trrep(j,i,0){\n\t\t\tf[i][j]=f[i][j+1]%mod;\n\t\t\tif(j){\n\t\t\t\tf[i][j]+=f[i-1][j-1]*C(i*k-j-1,k-2)%mod;\n\t\t\t\tf[i][j]%=mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<f[n][0]*fac[n]%mod;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#define ll long long\n#define res register ll\n#define N 2005\nusing namespace std;\nll inv[N*N+N+N],jie[N*N+N+N],k,n,f[N][N];\nconst ll mod=1e9+7;\ninline ll read()\n{\n  ll X=0,w=0;\n  char ch=0;\n  while(!isdigit(ch))\n  {\n    w|=ch=='-';\n    ch=getchar();\n  }\n  while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();\n  return w?-X:X;\n}\ninline ll quickpow(res base,res num)\n{\n  res ans=1;\n  for(; num; num>>=1,base=1LL*base*base%mod)\n    if(num&1)\n      ans=1LL*ans*base%mod;\n  return ans;\n}\ninline void init()\n{\n  jie[0]=jie[1]=inv[0]=inv[1]=1;\n  for(res i=2; i<=n*n+n+k; i++)\n  {\n    jie[i]=1LL*jie[i-1]*i%mod;\n    inv[i]=quickpow(jie[i],mod-2);\n  }\n}\ninline ll C(ll m,ll n)\n{\n  return 1LL*jie[m]*inv[n]%mod*1LL*inv[m-n]%mod;\n}\nint main()\n{\n  n=read(),k=read()-1;\n  if(!k)\n  {\n    puts(\"1\");\n    return 0;\n  }\n  init();\n  f[0][0]=1;\n  for(res i=0; i<=n; i++)\n    for(res j=i; j<=n; j++)\n    {\n      if(i) f[i][j]=(f[i][j]+f[i-1][j])%mod;\n      if(j) f[i][j]=(f[i][j]+1LL*f[i][j-1]*C(i+j*k-1,k-1)%mod)%mod;\n    }\n  printf(\"%d\\n\",1LL*f[n][n]*jie[n]%mod);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define IL inline\n#define RG register\n#define LL long long\n#define Upd(a) (a)>=mod?(a-=mod):1\nusing namespace std;\ntemplate <class T>\nIL char gc () {\n\tstatic char buf[1<<6], *p1=buf, *p2=buf;\n\treturn (p1==p2) && (p2=(p1=buf)+fread(buf,1,1<<6,stdin), p1==p2) ?EOF:*p1++;\n}\ntemplate <typename T>\nIL void read (T&data) {\n\tdata=0;\n\tRG char ch=0;\n\twhile (ch<'0' || ch>'9') ch=getchar();\n\twhile (ch<='9' && ch>='0') data=(data<<1)+(data<<3)+(ch&15), ch=getchar();\n}\nconst int mod = 1e9+7;\nconst int _ =2001;\nint n, k;\nint dp[2][_], jc[_*_], jcn[_*_];\nIL int poww (RG int a, RG int b) {\n\tRG int ret=1, Base=a;\n\tfor (;b;b>>=1, Base=1LL*Base*Base%mod) if (b&1) ret=1LL*ret*Base%mod;\n\treturn ret;\n}\nIL int C (RG int a, RG int b) {\n\tif (a<b) return 0;\n\t//if (a>2000*2000) cout<< a<<endl, exit (0);\n\treturn 1LL*jc[a]*jcn[b]%mod*jcn[a-b]%mod;\n}\nint main () {\n\tread(n), read(k);\n\tif (k<=1) {puts(\"1\"); return 0;}\n\tjc[0]=jcn[0]=1;\n\tRG int i, j, pre=1, cur=0;\n\tfor (i=1; i<=n*n; ++i) jc[i]=1LL*jc[i-1]*i%mod, jcn[i]=poww(jc[i], mod-2);\n\tdp[0][0]=1;\n\tfor (i=1; i<=n*2; ++i) {\n\t\tswap(cur, pre);\n\t\tfor (j=0; j<min(i,n+1); ++j) dp[cur][j]=0;\n\t\tfor (j=1; j<=min(i,n); ++j) {\n\t\t\tif ((i-j)%2) continue;\n\t\t\tif (n*2-i+1<j) break;\n\t\t\tRG int a=(i+j-2)>>1, b=(i-j)>>1;\n\t\t\tdp[cur][j]=1LL*dp[pre][j-1]*C(a*(k-1)+b+k-1-1,k-1-1)%mod;\n\t\t\tdp[cur][j]+=dp[pre][j+1];\n\t\t\tUpd(dp[cur][j]);\n\t\t}\n\t\tif (cur%2==0) dp[cur][0]=dp[pre][1];\n\t\t//for (j=0; j<=min(i, n); ++j) printf(\"%d \",dp[cur][j]);puts(\"\");\n\t}\n\tprintf(\"%lld\",1LL*dp[cur][0]*jc[n]%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define int long long\nusing namespace std;\nconst ll MAX_N = 3000 + 10, MOD = 1e9 + 7;\nll n, k, dp[MAX_N][MAX_N], fac[MAX_N * MAX_N], en[MAX_N * MAX_N], r,pwmakh, makh = 1;\nll pw(int x,int y){\n\tif(!y) return 1ll;\n\tll t = pw(x, y / 2);\n\tt = 1ll * t * t % MOD;\n\tif(y & 1) t = 1ll * t * x % MOD;\n\treturn t;\n}\nint32_t main(){\n    cin>>n>>k;\n    fac[0] = 1;\n    for(int i = 1; i <= n * k; i++){\n        fac[i] = fac[i - 1] * i;\n        fac[i] %= MOD;\n    }\n    for(int i = 1; i <= k - 2; i++){\n        makh *= i;\n        makh %= MOD;\n    }\n    pwmakh = pw(makh, MOD - 2);\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j <= n; j++){\n            if(j > 0){\n                if(en[i * k + j * (k - 1) - 1] == 0){\n                    r = fac[i * k + j * (k - 1) - 1] * pwmakh % MOD * pw(fac[i * k + j * (k - 1) - 1 - (k - 2)], MOD - 2) % MOD;\n                    en[i * k + j * (k - 1) - 1] = r;\n                }\n                else{\n                    r = en[i * k + j * (k - 1) - 1];\n                }\n            }\n            if(i > 0 && j > 0){\n                dp[i][j] = dp[i - 1][j + 1] + (dp[i][j - 1] * r) % MOD;\n            }\n            else if(i == 0 && j > 0){\n                dp[i][j] = dp[i][j - 1] * r;\n            }\n            else if(i > 0 && j == 0){\n                dp[i][j] = dp[i - 1][j + 1];\n            }\n            else{\n                dp[i][j] = 1;\n            }\n            dp[i][j] %= MOD;\n        }\n    }\n    ll ans = 1ll * dp[n][0] * fac[n] % MOD;\n    cout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "//In the name of Allah\n//#ISART\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N = 2010, mod = 1e9 + 7;\nll ch[N * N], dp[N][N], sdp[N][N];\n\nll po(ll a, ll b){\n\tif(b == 1)\n\t\treturn a;\n\tll p = po(a, b / 2);\n\tif(b % 2 == 1)\n\t\treturn p * p % mod * a % mod;\n\treturn p * p % mod;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n, k;\n\tcin >> n >> k;\n\tif(k == 1){\n\t\tcout << 1;\n\t\treturn 0;\n\t}\n\tch[k - 2] = 1;\n\tfor(int i = k - 1; i < (n + 2) * (k + 2); i ++)\n\t\tch[i] = ch[i - 1] * 1ll * i % mod * po(i - k + 2, mod - 2) % mod;\n\tll fact = 1;\n\tfor(int i = 1; i <= n; i ++)\n\t\tfact = fact * 1ll * i % mod;\n\tdp[0][0] = 1;\n\tsdp[0][0] = 1;\n\tfor(int i = 1; i < n; i ++){\n\t\tfor(int j = 0; j <= i; j ++){\n\t\t\tdp[i][j] = ch[i * (k - 1) + j + k - 2] * sdp[i - 1][min(j, i - 1)] % mod;\n\t\t\tsdp[i][j] = dp[i][j];\n\t\t\tif(j > 0)\n\t\t\t\tsdp[i][j] = (sdp[i][j] + sdp[i][j - 1]) % mod;\n\t\t}\n\t}\n\tcout << sdp[n - 1][n - 1] * fact % mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#define MOD 1000000007\n#define MAXN 2005\nusing namespace std;\ntypedef long long LL;\nint d[MAXN][MAXN],num[MAXN][MAXN],inv[MAXN*MAXN],kinv,n,k;\nvoid pre()\n{\n    inv[1]=1;kinv=1;\n    for(int i=2;i<MAXN*MAXN;i++) inv[i]=(MOD-MOD/i)*(LL)inv[MOD%i]%MOD;\n    for(int i=2;i<=k-2;i++) kinv=(LL)kinv*inv[i]%MOD;\n    num[0][0]=1;\n    for(int j=1;j<k;j++)\n    {\n        num[0][j]=1;\n        for(int m=1;m<=k-2;m++) num[0][j]=(LL)num[0][j]*(j*k-j+m)%MOD;\n        num[0][j]=(LL)num[0][j]*kinv%MOD;\n        //cout<<j<<' '<<num[0][j]<<endl;\n    }\n    for(int j=1;j<k;j++)\n        for(int i=1;i<=j;i++)\n    {   num[i][j]=(LL)num[i-1][j]*(j*k-j+k+i-2)%MOD*inv[j*k-j+i]%MOD;\n        //cout<<j*k-j+k-2+i<<' '<<k-2<<' '<<num[i][j]<<endl;\n    }\n}\nint main()\n{\n\n    cin>>n>>k;\n    if(k==1) {cout<<1<<endl;return 0;}\n    pre();\n    d[0][1]=1;\n    for(int j=2;j<=n;j++)\n        d[0][j]=(LL)d[0][j-1]*num[0][j-1]%MOD;\n    for(int i=1;i<=n;i++)\n        for(int j=i;j<=n;j++)\n    {\n        d[i][j]=(d[i-1][j]+(LL)d[i][j-1]*num[i][j-1]%MOD)%MOD;\n    }\n    int ans=d[n][n];\n    for(int i=2;i<=n;i++) ans=(LL)ans*i%MOD;\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); i++)\n#define per(i,a,b) for (int i=(a); i>=(b); i--)\nusing namespace std;\n\nconst int maxn = 2005;\nconst int mod = 1000000007;\nint fac[maxn*maxn], rev[maxn*maxn], f[maxn<<1][maxn];\nint n, K, ans;\n\ninline int power(int x, int p) {\n\tint res = 1;\n\twhile (p) {\n\t\tif (p & 1) res = 1ll * res * x % mod;\n\t\tx = 1ll * x * x % mod; p >>= 1;\n\t}\n\treturn res;\n}\n\ninline int C(int n, int m) {\n\treturn 1ll * fac[n] * rev[m] % mod * rev[n-m] % mod;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &K);\n\tif (K == 1) return puts(\"1\"), 0;\n\tfac[0] = rev[0] = 1;\n\trep (i, 1, maxn*maxn-1) {\n\t\tfac[i] = 1ll * fac[i-1] * i % mod;\n\t\trev[i] = power(fac[i], mod - 2);\n\t}\n\tf[0][0] = 1;\n\trep (i, 1, n*2) rep (j, 0, n)\n\t\tif (f[i-1][j]) {\n\t\t\tif (j*2 > i-1) \n\t\t\t\tf[i][j] = (f[i][j] + f[i-1][j]) % mod;\n\t\t\tf[i][j+1] = (f[i][j+1] + 1ll * f[i-1][j] * C(K * (i-1-j) + (K-1) * (2*j-i+1) + K-2, K-2)) % mod;\n\t\t}\n\tans = 1ll * f[n*2][n] * fac[n] % mod;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\nconst ll MOD = 1e9 + 7;\nconst ll MAXQ = 5000000;\nll dp[2100][2100];\n\nint n, k;\n\nll fc[MAXQ];\nll bfc[MAXQ];\n\nll pw(ll a, ll b) {\n\tll ans = 1;\n\twhile (b) {\n\t\twhile (!(b & 1))\n\t\t\tb>>= 1, a = (a *a) %MOD;\n\t\t--b;\n\t\tans = (ans * a) % MOD;\n\t}\n\treturn ans;\n}\n\nvoid init() {\n\tfc[0] = 1;\n\tfor (int i = 1; i < MAXQ; ++i)\n\t\tfc[i] = (fc[i - 1] * i) % MOD;\n\tfor (int i = 0; i < MAXQ; ++i)\n\t\tbfc[i] = pw(fc[i], MOD - 2);\n}\n\nll cnk(ll n, ll k) {\n\tif (k > n)\n\t\treturn 0;\n\tll ans = fc[n] * bfc[k];\n\tans %= MOD;\n\treturn (ans * bfc[n - k]) % MOD;\n}\n\nint main() {\n\tcin >> n >> k;\n\tif (k == 1) {\n\t\tcout << 1 << \"\\n\";\n\t\treturn 0;\n\t}\n\t--k;\n\tinit();\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j < i; ++j)\n\t\t\tdp[i][j] = (dp[i - 1][j] * cnk(i * k - 1 + j, k - 1)) % MOD;\n\t\tfor (int j = 1; j <= i; ++j)\n\t\t\tdp[i][j] = (dp[i][j] + dp[i][j - 1]) % MOD;\n\t}\n\tll ans = dp[n][n] * fc[n];\n\tans %= MOD;\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// Leftmost Ball\n// * frank_c1\n// * 2017 / 09 / 29\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nLL pow_mod(LL b, LL p, LL k) {\n\tLL ret = 1;\n\tfor (; p; p >>= 1) {\n\t\tif (p & 1) ret = ret * b % k;\n\t\tb = b * b % k;\n\t} return ret;\n}\n\nconst int maxn = 3005;\nconst int mo = (int)(1e9) + 7;\nLL fac[maxn * maxn], ivf[maxn * maxn];\nint f[maxn][maxn];\n\ninline LL C(int n, int m) {\n\tif (m < 0 || n - m < 0) return 0;\n\treturn (fac[n] * ivf[m] % mo) * ivf[n - m] % mo;\n}\n\ninline void add(int& x, int v) {\n\tx += v; if (x >= mo) x -= mo;\n}\n\nint main() {\n\tint n, K;\n\tscanf(\"%d%d\", &n, &K);\n\tif (K == 1) return printf(\"1\\n\"), 0;\n\tint mx = n * (K + 1);\n\tfac[0] = ivf[0] = 1;\n\tfor (int i = 1; i <= mx; ++i) fac[i] = fac[i - 1] * i % mo;\n\tivf[mx] = pow_mod(fac[mx], mo - 2, mo);\n\tfor (int i = mx - 1; i >= 1; --i) ivf[i] = ivf[i + 1] * (i + 1) % mo;\n\tf[0][0] = 1;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\tif (i < j) add(f[i + 1][j], f[i][j]);\n\t\t\tif (j < n) add(f[i][j + 1], 1LL * f[i][j] * C(i + (j + 1) * (K - 1) - 1, K - 2) % mo);\n\t\t}\n\t} return printf(\"%lld\\n\", 1LL * ret * fac[n] % mo), 0;\n}"
  },
  {
    "language": "C++",
    "code": "//                             In The Name Of Allah\n#include <bits/stdc++.h>\n#define ss second\n#define ff first\n#define use_fast ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)\n#define ret(n) return cout << n, 0\n#define se(n) cout << setprecision(n) << fixed\n#define pb push_back\n#define int long long\n#define ld long double\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\")\n#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\n\nconst int N = 4e6 + 100, T = 2e3 + 100, OO = 1e12 + 10, M = 1e9 + 7, P = 49157, sq = 360, lg = 30;\ntypedef pair <int, int> pii;\nint dp[T][T];\nint fac[N], inv[N];\n \nint pw(int x, int y) {\n\tif(y == 0)\n\t\treturn 1;\n\tint cnt = pw(x, y / 2);\n\tcnt = (cnt * cnt) % M;\n\tcnt = (cnt * (y % 2 == 1 ? x : 1)) % M;\n\treturn cnt;\n}\n \nvoid prepro() {\n\tfac[0] = 1;\n\tfor(int i = 1; i <= N - lg; i++) \n\t\tfac[i] = (fac[i - 1] * i) % M;\n\tinv[N - lg] = pw(fac[N - lg], M - 2);\n\tfor(int i = N - lg - 1; i > -1; i--) \n\t\tinv[i] = (inv[i + 1] * (i + 1)) % M;\n}\n \nint c(int x, int y) {\n\tif(x == y || y == 0)\n\t\treturn 1;\n\treturn ((fac[x] * inv[y] % M) * inv[x - y]) % M;\n}\n\nint32_t main() {\n\tuse_fast;\n\tprepro();\n\tint n, k;\n\tcin >> n >> k;\n\tif(k == 1)\n\t\treturn cout << 1, 0;\n\tdp[0][0] = 1;\n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int j = i; j >= 1; j--) \n\t\t\tdp[i][j] = (dp[i][j + 1] + dp[i - 1][j - 1] * i * c(i * k - 1 - j, k - 2)) % M;\n\t\tdp[i][0] = dp[i][1];\n\t}\n\tcout << dp[n][0] << endl;\n\treturn 0;\n} \t\n/*\nbe carefull :\n1- if not solve after 20 min, read again twice\n2- after submit read the code again\n3- fun with contest\n4- ... \n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\nusing namespace std;\n#define MOD 1000000007\n#define rep(i,m,n) for(int (i)=(int)(m);i<(int)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ll long long\n#define ull unsigned long long\n#define all(hoge) (hoge).begin(),(hoge).end()\n#define M_PI 3.1415926535897932LL;\ntypedef pair<ll, ll> P;\nconst long long INF = 1LL << 60;\nconst long double EPS = 1e-10;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct Edge {//グラフ\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, ll from, ll to, ll cap,bool revFlag,ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif(revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\n\nll max_flow_dfs(Graph & G, ll v, ll t, ll f, vector<bool> & used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph & G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d,Array &negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size()-1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif(negative[i]==true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = ((i != j) ? INF : 0);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\tchmin(d[i][G[i][j].to], G[i][j].cap);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, vector<int>& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tlca() {}\n\n\tlca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\nvoid visit(const Graph& g, int v, Matrix& scc, stack<ll>& S, Array& inS, Array& low, Array& num, int& time) {\n\tlow[v] = num[v] = ++time;\n\tS.push(v); inS[v] = true;\n\tFOR(e, g[v]) {\n\t\tint w = e->to;\n\t\tif (num[w] == 0) {\n\t\t\tvisit(g, w, scc, S, inS, low, num, time);\n\t\t\tlow[v] = min(low[v], low[w]);\n\t\t}\n\t\telse if (inS[w])\n\t\t\tlow[v] = min(low[v], num[w]);\n\t}\n\tif (low[v] == num[v]) {\n\t\tscc.push_back(Array());\n\t\twhile (1) {\n\t\t\tint w = S.top(); S.pop(); inS[w] = false;\n\t\t\tscc.back().push_back(w);\n\t\t\tif (v == w) break;\n\t\t}\n\t}\n}\nvoid stronglyConnectedComponents(const Graph & g, Matrix & scc) {//強連結成分分解 O(E+V)\n\tconst int n = g.size();\n\tArray num(n), low(n);\n\tstack<ll> S;\n\tArray inS(n);\n\tint time = 0;\n\tREP(u, n) if (num[u] == 0)\n\t\tvisit(g, u, scc, S, inS, low, num, time);\n}\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tint numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\nclass SumSegTree {\nprivate:\n\t\n\tll _sum(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return 0;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _sum(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _sum(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn s1 + s2;\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tSumSegTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1,0);\n\t}\n\n\t// 場所i(0-indexed)にxを足す\n\tvoid add(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] += x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] += x;\n\t\t}\n\t}\n\n\t// 区間[a,b)の総和。ノードk=[l,r)に着目している。\n\tll sum(ll a, ll b) {\n\t\treturn _sum(a, b, 0, 0, n);\n\t}\n};\nclass RmqTree {\nprivate:\n\n\tll _find(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return INF;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _find(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _find(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn min(s1, s2);\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tRmqTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1,INF);\n\t}\n\n\t// 場所i(0-indexed)をxにする\n\tvoid update(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] = x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\n\t// 区間[a,b)の最小値。ノードk=[l,r)に着目している。\n\tll find(ll a, ll b) {\n\t\treturn _find(a, b, 0, 0, n);\n\t}\n};\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n}\n\nvoid divisor_prime(ll n, vector<P>& ret) {\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back({ i,0 });\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tret[ret.size() - 1].second++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1)ret.push_back({ n,1 });\n}\n\n\nll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n//nCrとか\nclass Combination {\npublic:\n\tArray fact;\n\tArray inv;\n\tll mod;\n\tll mod_inv(ll x) {\n\t\tll n = mod - 2LL;\n\t\tll res = 1LL;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res = res * x % mod;\n\t\t\tx = x * x % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tll nCr(ll n, ll r) {\n\t\treturn ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll n, ll _mod) {\n\t\tmod = _mod;\n\t\tfact.resize(n + 1);\n\t\tfact[0] = 1;\n\t\tREP(i, n) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tinv.resize(n + 1);\n\t\tinv[n] = mod_inv(fact[n]);\n\t\tfor(int i=n;i>0;i--) {\n\t\t\tinv[i - 1] = inv[i] * i % mod;\n\t\t}\n\t}\n};\n\nll gcd(ll m, ll n) {\n\tif (n == 0)return m;\n\treturn gcd(n, m % n);\n}//gcd\n\nll lcm(ll m, ll n) {\n\treturn m / gcd(m, n) * n;\n}\n\nll popcount(ll x) {\n\tx = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n\tx = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n\tx = (x & 0x0F0F0F0F0F0F0F0F) + (x >> 4 & 0x0F0F0F0F0F0F0F0F);\n\tx = (x & 0x00FF00FF00FF00FF) + (x >> 8 & 0x00FF00FF00FF00FF);\n\tx = (x & 0x0000FFFF0000FFFF) + (x >> 16 & 0x0000FFFF0000FFFF);\n\tx = (x & 0x00000000FFFFFFFF) + (x >> 32 & 0x00000000FFFFFFFF);\n\n\treturn x;\n}\n\nll dp[2020][2020];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\t\n\tll n, k;\n\tcin >> n >> k;\n\n\tCombination comb(n*k, MOD);\n\tdp[0][0] = 1;\n\tREP(i, n+1) {\n\t\tREP(j, n+1) {\n\t\t\tif (j > i)continue;\n\t\t\t(dp[i + 1][j] += dp[i][j]) %= MOD;\n\t\t\tif (i > j && k > 1) {\n\t\t\t\t(dp[i][j + 1] += comb.nCr(n * k - i - j * (k - 1) - 1, k - 2) * dp[i][j] % MOD) %= MOD;\n\t\t\t}\n\t\t\telse dp[i][j + 1] = dp[i][j];\n\t\t}\n\t}\n\tcout << dp[n][n] *(k!=1? comb.fact[n]:1) % MOD << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define LL long long\n//#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)\n//char buf[(1 << 21) + 1], *p1 = buf, *p2 = buf;\ninline int read() {\n\tbool f=0;int x=0;char c=getchar();\n\twhile(c<'0'||'9'<c){if(c==EOF)exit(0);if(c=='-')f=1;c=getchar();}\n\twhile('0'<=c&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();\n\treturn !f?x:-x;\n}\n#define MAXN 2000\n#define INF 0x3f3f3f3f\n#define Mod (int)(1e9+7)\nLL fac[MAXN*MAXN+5],inv[MAXN*MAXN+5];\nLL Pow(LL x,LL y){\n\tLL ret=1;\n\twhile(y){\n\t\tif(y&1) ret=ret*x%Mod;\n\t\tx=x*x%Mod,y>>=1;\n\t}\n\treturn ret;\n}\nvoid Prepare(){\n\tfac[0]=1;\n\tfor(int i=1;i<=MAXN*MAXN;i++)\n\t\tfac[i]=fac[i-1]*i%Mod;\n\tinv[MAXN*MAXN]=Pow(fac[MAXN*MAXN],Mod-2);\n\tfor(int i=MAXN*MAXN-1;i>=0;i--)\n\t\tinv[i]=inv[i+1]*(i+1)%Mod;\n\treturn ;\n}\nLL f[MAXN+5][MAXN+5];\nLL C(int n,int m){\n\tif(n<m) return 0;\n\treturn fac[n]*inv[m]%Mod*inv[n-m]%Mod;\n}\nint main(){\n\tPrepare();\n\tint n=read(),k=read();\n\tif(n==1)\n\t\tputs(\"0\"),exit(0);\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tf[i][j]=(f[i-1][j]+C(n-i+(n-(j-1))*(k-1)-1,k-2)*f[i][j-1]%Mod)%Mod;\n\t}\n\tprintf(\"%lld\\n\",f[n][n]*fac[n]%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Relive your past life.\n//Face your demons.\n//The past is never dead,it is not even past.\n//The memories are not only the key to the past but...also to the future.\n//coded in Rusty Lake\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007ll\nusing namespace std;\nint n,k;\nll jc[4000005],njc[4000005],dp[2005][2005];\nll fp(ll x,int k=1000000005){\n    ll ans=1;\n    while(k){\n        if(k&1)ans=ans*x%orz;\n        k>>=1,x=x*x%orz;\n    }\n    return ans;\n}\nint main(){\n    scanf(\"%d%d\",&n,&k);\n    if(n==1||k==1){\n        puts(\"1\");\n        return 0;\n    }\n    jc[0]=1;\n    for(int i=1;i<=n*k;++i)jc[i]=jc[i-1]*i%orz;\n    njc[n*k]=fp(jc[n*k]);\n    for(int i=n*k;i;--i)njc[i-1]=njc[i]*i%orz;\n    dp[0][1]=1;\n    for(int i=2;i<=n;++i)dp[0][i]=dp[0][i-1]*jc[i*k-i-1]%orz*njc[k-2]%orz*njc[i*k-i-k+1]%orz;\n    for(int i=1;i<n;++i){\n        dp[i][i]=dp[i-1][i];\n        for(int j=i+1;j<=n;++j)dp[i][j]=(dp[i][j-1]*jc[i+j*k-j-1]%orz*njc[k-2]%orz*njc[i+j*k-j-k+1]%orz+dp[i-1][j])%orz;\n    }\n    printf(\"%lld\\n\",dp[n-1][n]*jc[n]%orz);\n    //system(\"pause\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nconst int N = 2e3 + 7, MXA = 4e6 + 7;\nlong long M = 1e9 + 7;\nint fc[MXA];\nint rfc[MXA];\nlong long pw(int a, int b) {\n\tif (b == 0)\n\t\treturn 1;\n\tint t = pw(a, b / 2);\n\tt = (t * t) % M;\n\tif (b % 2)\n\t\tt = (t * a) % M;\n\treturn t;\n}\nlong long chs(int a, int b) {\n\tlong long t = fc[b];\n\tt = (t * pw(fc[a], M - 2)) % M;\n\tt = (t * pw(fc[b - a], M - 2)) % M;\n\treturn t;\n}\nint n, k;\nint dp[N][N];\nint32_t main() {\n\tfc[0] = rfc[0] =  1;\n\tfor (int i = 1; i < MXA; i++)\n\t\tfc[i] = (fc[i - 1] * i) % M;\n\tdp[0][0] = 1;\n\tcin >> n >> k;\n\tif (k == 1) {\n\t\tcout << 1;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int j = i; j <= n; j++) {\n\t\t\tif (i + j == 0)\n\t\t\t\tcontinue;\n\t\t\tif (i > 0)\n\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\tif (j > i) {\n\t\t\t\tint tmp = i + j * (k - 1) - 1;\n\t\t\t\tdp[i][j] += (chs(k - 2, tmp) * dp[i][j - 1]) % M;\n\t\t\t\tdp[i][j] %= M;\n//\t\t\t\tcout << i << \" \" << j << \" > \" << dp[i][j] << \" \" << tmp << \" \" << (fc[tmp] * rfc[k - 2] % M) * rfc[tmp - (k - 2)] % M << endl;\n\t\t\t}\n\t\t}\n\tcout << (dp[n][n] * fc[n]) % M;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define run(v) for(int k=head[v];k;k=e[k].ne)\n#define v e[k].t\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef pair<int,int> pa;\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\nconst int N=5e3+5,M=1e7+5,INF=1e9,mod=1e9+7;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);}\nil void gen(){freopen(\"data.in\",\"w\",stdout);}\nll fac[M],ifac[M],dp[N][N];\nint n,k;\nil ll C(ll n,ll m){\n\tif(!n||!m||n<m)return 0;\n\treturn fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\nint main(){\n\tread(n,k);\n\tif(k==1)return puts(\"1\"),0;\n\tfac[0]=1;rep(i,1,n*k)fac[i]=(fac[i-1]*i)%mod;\n\tifac[n*k]=qpow(fac[n*k],mod-2,mod);\n\trepd(i,n*k-1,0)ifac[i]=ifac[i+1]*(i+1)%mod;\n\tdp[0][0]=1;\n\trep(i,0,n)rep(j,i,n){\n\t\tif(i)dp[i][j]=dp[i-1][j];\t\n\t\tif(j)dp[i][j]=(dp[i][j]+dp[i][j-1]*C(i+j*(k-1)-1,k-2))%mod;\n\t}\n\tcout<<fac[n]*dp[n][n]%mod;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 2010\n#define ll long long\n#define mod 1000000007\nusing namespace std;\nint n, m, jc[N*N], inv[N*N], f[N][N], ans;\nint C(int n, int m){return (ll)jc[n]*inv[m]%mod*inv[n-m]%mod;}\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tif(m==1){printf(\"1\"); return 0;}\n\tjc[0]=1; for(int i=1; i<=4000000; i++)jc[i]=(ll)jc[i-1]*i%mod;\n\tinv[0]=inv[1]=1; for(int i=2; i<=4000000; i++)inv[i]=(ll)(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=1; i<=4000000; i++)inv[i]=(ll)inv[i]*inv[i-1]%mod;\n\tf[0][0]=1;\n\tfor(int i=1; i<=n; i++)f[0][i]=(ll)f[0][i-1]*C(i*(m-1)-1, m-2)%mod;\n\tfor(int i=1; i<=n; i++){\n\t\tf[i][i]=f[i-1][i];\n\t\tfor(int j=i+1; j<=n; j++)f[i][j]=(f[i-1][j]+(ll)f[i][j-1]*C(i+j*(m-1)-1, m-2)%mod)%mod;\n\t}\n\tans=(ll)f[n][n]*jc[n]%mod;\n\tprintf(\"%d\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN=2005,MOD=1e9+7;\nint n,k,fac[MAXN*MAXN],inv[MAXN*MAXN],dp[MAXN][MAXN];\n\nll quick_pow(ll a,int b)\n{\n\tll ret=1;\n\tfor(;b;b>>=1,a=a*a%MOD)\n\t\tif(b&1) ret=ret*a%MOD;\n\treturn ret;\n}\nll C(int a,int b)\n{if(a<b) return 0;return 1ll*fac[a]*inv[a-b]%MOD*inv[b]%MOD;}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfac[0]=dp[0][0]=1;\n\tfor(int i=1;i<=n*k;i++) fac[i]=1ll*fac[i-1]*i%MOD;\n\tinv[n*k]=quick_pow(fac[n*k],MOD-2);\n\tfor(int i=n*k-1;i>=0;i--) inv[i]=1ll*inv[i+1]*(i+1)%MOD;\n\t\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(j<=i) dp[i][j]=dp[i-1][j];\n\t\t\telse dp[i][j]=(dp[i][j-1]*C(i+(k-1)*j-1,k-2)+(i?dp[i-1][j]:0))%MOD;\n\t\n\tll res=1ll*dp[n][n]*fac[n]%MOD;\n\tprintf(\"%lld\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nconst int mod = 1000000007;\nlong long dp[2002][2002];\n\nvector<int> factorials;\nvector<int> ifactorials;\n\nvector<int> range_mod_inverse(int n, const int mod) {\n  vector<int> ret(n + 1);\n  ret[1] = 1;\n  for (int i = 2; i <= n; i++)\n    ret[i] = (long long)(mod - mod / i) * ret[mod%i] % mod;\n  return ret;\n}\n\nvector<int> getFactorials(int n, const int mod) {\n  vector<int> ret(1, 1);\n  for (int i = 1; i <= n; i++) ret.push_back((long long)ret.back()*i%mod);\n  return ret;\n}\n\nvector<int> getInverseFactorials(int n, const int mod) {\n  vector<int> invmod(range_mod_inverse(n, mod));\n  vector<int> ret(1, 1);\n  for (int i = 1; i <= n; i++) ret.push_back((long long)ret.back()*invmod[i] % mod);\n  return ret;\n}\n\nlong long binom(int n, int r) {\n  if (n < 0 || r < 0 || r > n)\n    return 0;\n  return (long long)factorials[n] * (long long)ifactorials[r] % mod * ifactorials[n-r] % mod;\n}\n\nint main()\n{\n  factorials = getFactorials(4000003, mod);\n  ifactorials = getInverseFactorials(4000003, mod);\n  int n, K;\n  scanf(\"%d%d\", &n, &K);\n  if (K == 1) {\n    printf(\"1\\n\");\n    return 0;\n  }\n  dp[0][0] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j <= i; j++) {\n      long long subval = 0;\n      if (j > 0) subval += dp[i][j - 1];\n      if (i > j) subval += dp[i - 1][j] * binom((K - 1)*i + j - 1, K - 2);\n      subval %= mod;\n      dp[i][j] = subval;\n    }\n  }\n  long long ans = dp[n][n];\n  ans *= factorials[n];\n  ans %= mod;\n  ans += mod;\n  ans %= mod;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2000 + 200 + 20 + 2;\nconst int MAX = MAXN * MAXN;\nconst int mod = 1e9 + 7;\nint fact[MAX];\nint ifact[MAX];\nint dp[MAXN][MAXN];\n\nint bpow(int base, int exp) {\n  int ans = 1;\n  for(; exp; exp >>= 1, base = 1LL * base * base % mod )\n    if(exp & 1) ans = 1LL * ans * base % mod;\n  return ans;\n}\n\nvoid init() {\n  fact[0] = 1;\n  for(int i = 1; i < MAX; i++) fact[i] = 1LL * fact[i - 1] * i % mod;\n  ifact[MAX - 1] = bpow(fact[MAX - 1], mod - 2);\n  for(int i = MAX - 1; i > 0; i--)\n    ifact[i - 1] = 1LL * ifact[i] * i % mod;\n}\n\nint C(int n,int r) {\n  if(n < r) return 0;\n  return 1LL * (1LL * fact[n] * ifact[r] % mod) * ifact[n - r] % mod;\n}\n\nint& add(int&x, int s) {\n  return x = (1LL * x + s) % mod;\n}\n\nint main() {\n  init();\n  int N,K; scanf(\"%d %d\", &N, &K);\n  if(K == 1) {\n    printf(\"1\\n\");\n    return 0;\n  }\n  dp[N][N] = 1;\n  for(int i = N; i >= 0; i--)\n  {\n    for(int j = N; j > i; j--) \n    {\n      add(dp[i][j-1], 1LL * dp[i][j] * C(i + (K - 1) * j - 1, K - 2) % mod);\n      if(i) add(dp[i-1][j], dp[i][j]);\n    }\n    if(i) add(dp[i-1][i], dp[i][i]);\n  }\n  int ans = 1LL * dp[0][0] * fact[N] % mod;\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll MAX_N = 3000 + 10, MOD = 1e9 + 7;\nll n, k, dp[MAX_N][MAX_N], fac[MAX_N * MAX_N], en[MAX_N * MAX_N], r,pwmakh, makh = 1;\nll pw(int x,int y){\n\tif(!y) return 1ll;\n\tll t = pw(x, y / 2);\n\tt = 1ll * t * t % MOD;\n\tif(y & 1) t = 1ll * t * x % MOD;\n\treturn t;\n}\nint32_t main(){\n    cin>>n>>k;\n    if(k == 1){\n        cout<<1;\n    }\n    else{\n        fac[0] = 1;\n        for(int i = 1; i <= n * k; i++){\n            fac[i] = fac[i - 1] * i;\n            fac[i] %= MOD;\n        }\n        for(int i = 1; i <= k - 2; i++){\n            makh *= i;\n            makh %= MOD;\n        }\n        pwmakh = pw(makh, MOD - 2);\n        for(int i = 0; i <= n; i++){\n            for(int j = 0; j <= n; j++){\n                if(j > 0){\n                    if(en[i * k + j * (k - 1) - 1] == 0){\n                        r = fac[i * k + j * (k - 1) - 1] * pwmakh % MOD * pw(fac[i * k + j * (k - 1) - 1 - (k - 2)], MOD - 2) % MOD;\n                        en[i * k + j * (k - 1) - 1] = r;\n                    }\n                    else{\n                        r = en[i * k + j * (k - 1) - 1];\n                    }\n                }\n                if(i > 0 && j > 0){\n                    dp[i][j] = dp[i - 1][j + 1] + (dp[i][j - 1] * r) % MOD;\n                }\n                else if(i == 0 && j > 0){\n                    dp[i][j] = dp[i][j - 1] * r;\n                }\n                else if(i > 0 && j == 0){\n                    dp[i][j] = dp[i - 1][j + 1];\n                }\n                else{\n                    dp[i][j] = 1;\n                }\n                dp[i][j] %= MOD;\n            }\n        }\n        for(int i = 0; i <= n; i++){\n            for(int j = 0; j <= n; j++){\n                cout<<dp[i][j]<<\"  \";\n            }\n            cout<<endl;\n        }\n        ll ans = 1ll * dp[n][0] * fac[n] % MOD;\n        cout<<ans;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint read(){\n\tint x=0; char c=getchar(); int flag=1;\n\twhile(!isdigit(c)) { if(c=='-') flag=-1; c=getchar(); }\n\twhile(isdigit(c)) { x=((x+(x<<2))<<1)+(c^48); c=getchar(); }\n\treturn x*flag;\n}\n\nconst int mod=1e9+7;\n\nint n,k;\nint dp[2005][2005];//i个白球，j种颜色 \n\nint fac[4000005],Inv[4000005]; \n\nint C(int n,int m){\n\tif(m<0||n<m) return 0;\n    return 1ll*(1ll*fac[n]*Inv[m]%mod)*Inv[n-m]%mod; \n}\n\nvoid exgcd(int a,int b,int &x,int &y){\n    if(b==0) { x=1; y=0; return ; }\n    exgcd(b,a%b,y,x); y-=a/b*x;\n}\n\nint inv(int a){\n    int x=0,y=0;\n    exgcd(a,mod,x,y);\n    return (x%mod+mod)%mod;\n}\n\nsigned main(){\n\tfac[0]=1;\n\tfor(int i=1;i<=4000000;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tInv[4000000]=inv(fac[4000000]);\n\tfor(int i=3999999;i>=0;i--) Inv[i]=1ll*Inv[i+1]*(i+1)%mod;\n\t\n    n=read(),k=read();\n    dp[0][0]=1;\n    \n    for(int i=1;i<=n;i++){ \n\t    dp[i][0]=1;\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tdp[i][j]=(dp[i-1][j]+1ll*(1ll*dp[i][j-1]*C(n*k-(j-1)*(k-1)-i-1,k-2))%mod*(n-j+1)%mod)%mod; \n\t\t} \n\t}\n\t\n\tprintf(\"%d\\n\",dp[n][n]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int TEN(int n) {return (n==0)?1:10*TEN(n-1);}\n\ntemplate<class T>\nT pow(T x, ll n) {\n    T r = 1;\n    while (n) {\n        if (n & 1) r *= x;\n        x *= x;\n        n >>= 1;\n    }\n    return r;\n}\n\ntemplate<uint MD>\nstruct ModInt {\n    uint v;\n    ModInt() : v{0} {}\n    ModInt(ll v) : v{normS(v%MD+MD)} {}\n    static uint normS(const uint &x) {return (x<MD)?x:x-MD;};\n    static ModInt make(const uint &x) {ModInt m; m.v = x; return m;}\n    const ModInt operator+(const ModInt &r) const {return make(normS(v+r.v));}\n    const ModInt operator-(const ModInt &r) const {return make(normS(v+normS(MD-r.v)));}\n    const ModInt operator*(const ModInt &r) const {return make((ull)v*r.v%MD);}\n    ModInt& operator+=(const ModInt &r) {return *this=*this+r;}\n    ModInt& operator-=(const ModInt &r) {return *this=*this-r;}\n    ModInt& operator*=(const ModInt &r) {return *this=*this*r;}\n    static ModInt inv(const ModInt &x) {\n        return pow(ModInt(x), MD-2);\n    }\n};\nusing Mint = ModInt<TEN(9)+7>;\n\nconst int MN = 4000400;\nMint fact[MN], iFac[MN];\n\nvoid first() {\n    fact[0] = 1;\n    for (int i = 1; i < MN; i++) {\n        fact[i] = fact[i-1]*i;\n    }\n    iFac[MN-1] = Mint::inv(fact[MN-1]);\n    for (int i = MN-2; i >= 0; i--) {\n        iFac[i] = iFac[i+1]*(i+1);\n    }\n}\n\nMint C(int n, int k) {\n    return fact[n]*iFac[n-k]*iFac[k];\n}\n\nint n, K;\nMint dp[2020][2020];\nbool used[2020][2020];\nMint calc(int i, int j) {\n    if (j < i) return 0;\n    if (i == n) return 1;\n    if (used[i][j]) return dp[i][j];\n    used[i][j] = true;\n    Mint ans = 0;\n    for (int k = j; k <= n; k++) {\n        int a = (n-i)*K;\n        int b = n-j;\n        ans += calc(i+1, k) * ((i == 0) ? 1 : C(a+b+K-1, K-1));\n    }\n    return dp[i][j] = ans;\n}\n\nMint solve() {\n    if (K == 1) {\n        return 1;\n    }\n    K--;\n/*    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j <= N; j++) {\n            calc(i, j);\n        }\n    }\n    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j <= N; j++) {\n            printf(\"%d, \", calc(i, j).v);\n        }\n        printf(\"\\n\");\n    }*/\n    return calc(0, 0)*fact[n];\n}\n\nint main() {\n    first();\n    cin >> n >> K;\n    cout << solve().v << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nconst int N = 2005, M = N * N, P = 1e9 + 7;\n\nint n, k, fac[M], fac_rev[M], li, f[N][N];\n\nint qp (int a, int b) { int c = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b & 1) c = 1ll * c * a % P; return c; }\nint C (int n, int m) { if (m > n) return 0; return 1ll * fac[n] * fac_rev[m] % P * fac_rev[n - m] % P; }\n\nint main () {\n\tscanf(\"%d%d\", &n, &k);\n\tif (k == 1) return puts(\"1\"), 0;\n\tli = n * k;\n\tfac[0] = 1; for (int i = 1; i <= li; ++i) fac[i] = 1ll * fac[i - 1] * i % P;\n\tfac_rev[li] = qp(fac[li], P - 2);\n\tfor (int i = li - 1; ~i; --i) fac_rev[i] = 1ll * fac_rev[i + 1] * (i + 1) % P;\n\tf[0][0] = 1;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tfor (int j = i; ~j; --j) if (f[i][j]) {\n\t\t\tif (j > 0) f[i][j - 1] = (f[i][j - 1] + f[i][j]) % P;\n\t\t\tif (i < n) f[i + 1][j + 1] = (1ll * C(k - 2 + i * k - j, k - 2) * (n - i) % P * f[i][j] + f[i + 1][j + 1]) % P;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", f[n][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int MAXN = 2005, MOD = 1e9 + 7;\nlong long f[MAXN * MAXN];\nint dp[MAXN][MAXN], n, k;\nlong long rev(long long a) {\n\tint b = MOD - 2;\n\tlong long res = 1;\n\tfor (b; b; b /= 2) {\n\t\tif (b % 2)\n\t\t\tres *= a, res %= MOD;\n\t\ta *= a, a %= MOD;\n\t}\n\treturn res;\n}\nlong long ch(int a, int b) {\n\treturn f[a] * rev(f[b]) % MOD * rev(f[a - b]) % MOD;\n}\n\nint main() {\n\tcin >> n >> k;\n\tif (k == 1)\n\t\treturn cout << 1, 0;\n\tf[0] = 1;\n\tfor (int i = 1; i < MAXN * MAXN; i++)\n\t\tf[i] = f[i - 1] * i, f[i] %= MOD;\n\tfor (int i = 0; i <= n; i++)\n\t\tdp[0][i] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = i; j <= n; j++)\n\t\t\tdp[i][j] = dp[i - 1][j] * ch(n * k - j - (i - 1) * (k - 1) - 1, k - 2) + dp[i][j - 1], dp[i][j] %= MOD;\n\tcout << f[n] * dp[n][n] % MOD;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define forE(i,x) for(int i=head[x];i!=-1;i=ne[i])\nusing namespace std;\ntypedef long long i64;\ntypedef unsigned long long u64;\ntypedef unsigned u32;\ntypedef pair<int,int> pin;\n#define mk(a,b) make_pair(a,b)\n#define lowbit(x) ((x)&(-(x)))\n#define sqr(a) ((a)*(a))\n#define clr(a) (memset((a),0,sizeof(a)))\n#define ls ((x)<<1)\n#define rs (((x)<<1)|1)\n#define mid (((l)+(r))>>1)\n#define pb push_back\n#define w1 first\n#define w2 second\ninline void read(int &x){\n\tx=0;int f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\tx*=f;\n}\ninline void judge(){\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n}\n/*******************************head*******************************/\nconst int mod=1e9+7;\ninline void add(int &x,int y){\n\tx+=y;if(x>=mod)x-=mod;\n}\nconst int maxn=2005*2005;\nint inv[maxn],fac[maxn],facinv[maxn];\nint f[2005][2005];\ninline int C(int n,int m){\n\treturn 1ll*fac[n]*facinv[m]%mod*facinv[n-m]%mod;\n}\ninline void prprpr(){\n\tinv[1]=1;\n\trep(i,2,2000*2000){\n\t\tinv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\t}\n\tfac[0]=1;facinv[0]=1;\n\trep(i,1,2000*2000){\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\t\tfacinv[i]=1ll*facinv[i-1]*inv[i]%mod;\n\t}\n}\nint main(){\n\tprprpr();\n\tint n,k;read(n);read(k);f[0][0]=1;\n\trep(i,0,n)rep(j,0,i){\n\t\tif(i+1<=n)add(f[i+1][j],f[i][j]);\n\t\tif(j+1<=i)add(f[i][j+1],1ll*f[i][j]*C(n*k-i-(k-1)*j-1,k-2)%mod);\n\t}\n\tprintf(\"%lld\\n\",1ll*f[n][n]*fac[n]%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3) \n#include <cstdio>\nconst int N = 2010;\nconst int mod = 1e9 + 7;\nint n, k, fac[N * N], inv[N * N], f[N][N];\ninline int C(int x, int y) {\n\treturn 1ll * fac[x] * inv[y] % mod * inv[x - y] % mod;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tfac[0] = fac[1] = 1; for (int i = 2; i <= n * k; ++ i) fac[i] = 1ll * fac[i - 1] * i % mod;\n\tinv[0] = inv[1] = 1; for (int i = 2; i <= n * k; ++ i) inv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod;\n\tfor (int i = 2; i <= n * k; ++ i) inv[i] = 1ll * inv[i] * inv[i - 1] % mod;\n\tfor (int i = 0; i <= n; ++ i) f[i][0] = 1;\n\tfor (int i = 1; i <= n; ++ i)\n\t\tfor (int j = 1; j <= i; ++ j) {\n\t\t\tf[i][j] = (f[i - 1][j] + (1ll * f[i][j - 1] * (n - j + 1) % mod * C(n - i + (n - j + 1) * (k - 1) - 1, k - 2) % mod)) % mod;\n\t\t}\n\tprintf(\"%d\\n\", f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int TEN(int n) {return (n==0)?1:10*TEN(n-1);}\n\ntemplate<class T>\nT pow(T x, ll n) {\n    T r = 1;\n    while (n) {\n        if (n & 1) r *= x;\n        x *= x;\n        n >>= 1;\n    }\n    return r;\n}\n\ntemplate<uint MD>\nstruct ModInt {\n    uint v;\n    ModInt() : v{0} {}\n    ModInt(ll v) : v{normS(v%MD+MD)} {}\n    static uint normS(const uint &x) {return (x<MD)?x:x-MD;};\n    static ModInt make(const uint &x) {ModInt m; m.v = x; return m;}\n    const ModInt operator+(const ModInt &r) const {return make(normS(v+r.v));}\n    const ModInt operator-(const ModInt &r) const {return make(normS(v+normS(MD-r.v)));}\n    const ModInt operator*(const ModInt &r) const {return make((ull)v*r.v%MD);}\n    ModInt& operator+=(const ModInt &r) {return *this=*this+r;}\n    ModInt& operator-=(const ModInt &r) {return *this=*this-r;}\n    ModInt& operator*=(const ModInt &r) {return *this=*this*r;}\n    static ModInt inv(const ModInt &x) {\n        return pow(ModInt(x), MD-2);\n    }\n};\nusing Mint = ModInt<TEN(9)+7>;\n\nconst int MN = 4000400;\nMint fact[MN], iFac[MN];\n\nvoid first() {\n    fact[0] = 1;\n    for (int i = 1; i < MN; i++) {\n        fact[i] = fact[i-1]*i;\n    }\n    iFac[MN-1] = Mint::inv(fact[MN-1]);\n    for (int i = MN-2; i >= 0; i--) {\n        iFac[i] = iFac[i+1]*(i+1);\n    }\n}\n\nMint C(int n, int k) {\n    return fact[n]*iFac[n-k]*iFac[k];\n}\n\nMint csm(int i, int j);\n\nint n, K;\nMint dp[2020][2020];\nbool used[2020][2020];\nMint calc(int i, int j) {\n    if (j < i) return 0;\n    if (i == n) return 1;\n    if (used[i][j]) return dp[i][j];\n    used[i][j] = true;\n    int a = (n-i)*K;\n    int b = n-j;\n    Mint off = C(a+b+K-1, K-1);\n    Mint ans = 0;\n/*    for (int k = j; k <= n; k++) {\n        ans += calc(i+1, k);\n    }*/\n    ans += csm(i+1, j);\n    return dp[i][j] = ans*off;\n}\n\nMint dp2[2020][2020];\nbool used2[2020][2020];\nMint csm(int i, int j) {\n    if (j == n+1) return 0;\n    if (used2[i][j]) return dp2[i][j];\n    used2[i][j] = true;\n    return dp2[i][j] = (calc(i, j) + csm(i, j+1));\n}\n\nMint solve() {\n    if (K == 1) {\n        return 1;\n    }\n    K--;\n    Mint ans = 0;\n    for (int i = 1; i <= n; i++) {\n        ans += calc(1, i);\n    }\n    return ans*fact[n];\n}\n\nint main() {\n    first();\n    cin >> n >> K;\n    cout << solve().v << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2005;\nconst int mod = 1e9 + 7;\n\nint n, k;\nint f[N][N];\nint fac[N * N], ifac[N * N];\n\nvoid add(int &x,int y) {\n\tx += y; if (x >= mod) x -= mod;\n}\n\nint mul(int x,int y) {\n\treturn (long long) x * y % mod;\n}\n\nint pw(int x,int y) {\n\tint ret = 1;\n\twhile (y) {\n\t\tif (y & 1) ret = mul(ret, x);\n\t\tx = mul(x, x);\n\t\ty >>= 1;\n\t}\n\treturn ret;\n}\n\nint C(int n,int k) {\n\tif (n < k || k < 0) return 0;\n\treturn mul(fac[n], mul(ifac[k], ifac[n - k]));\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tfac[0] = 1; \n\tfor (int i = 1; i < N * N; ++i) fac[i] = mul(fac[i - 1], i);\n\tifac[N * N - 1] = pw(fac[N * N - 1], mod - 2);\n\tfor (int i = N * N - 2; i >= 0; --i) ifac[i] = mul(ifac[i + 1], i + 1);\n\tcin >> n >> k;\n\tif (k == 1) return cout << 1 << '\\n',0;\n\t\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tif (j < i) add(f[i][j], f[i - 1][j]);\n\t\t\tif (j > 0) add(f[i][j], mul(f[i][j - 1], C(n * k - i - (j - 1) * (k - 1) - 1, k - 2))); \n\t\t}\n\t}\n\tcout << mul(f[n][n], fac[n]) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline int read(){\n\tint ans=0,w=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar();\n\treturn ans*w;\n}\nconst int N=2005,Maxn=2000*2000+1e5+5,mod=1e9+7;\nint n,k,f[N][N],fac[Maxn],ifac[Maxn];\ninline int C(int n,int m){return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;}\nint main(){\n\tn=read(),k=read(),ifac[0]=fac[0]=fac[1]=ifac[1]=1;\n\tif(k==1)return puts(\"1\"),0;\n\tfor(int i=2;i<=Maxn-5;++i)fac[i]=1ll*fac[i-1]*i%mod,ifac[i]=1ll*(mod-mod/i)*ifac[mod%i]%mod;\n\tfor(int i=2;i<=Maxn-5;++i)ifac[i]=1ll*ifac[i]*ifac[i-1]%mod;\n\tf[1][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<=i;++j){\n\t\t\tif(i^j)(f[i][j+1]+=f[i][j]%=mod);\n\t\t\tif(i^n)(f[i+1][j]+=1ll*f[i][j]*C((k-2)+(i*(k-1)+j),k-2)%mod)%=mod;\n\t\t}\n\tcout<<1ll*f[n][n]*fac[n]%mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n\nconst int N = 2e3, M = N * N;\nconst int Mo = 1e9 + 7;\n\nint n, m;\nint f[N + 10][N + 10], fac[M + 10], Inv[M + 10];\n\ninline int ksm(int a, int b) {\n    int ans = 1;\n    for (; b; b >>= 1, a = 1LL * a * a % Mo)\n        if (b & 1) ans = 1LL * ans * a % Mo;\n    return ans;\n}\n\ninline int C(int n, int m) {\n    if (m < n)\n        return 0;\n    // printf(\"%d %d %d %d\\n\", n, fac[m], Inv[n], Inv[m - n]);\n    return 1LL * fac[m] * Inv[n] % Mo * Inv[m - n] % Mo;\n}\n\nsigned main() {\n    scanf(\"%lld%lld\", &n, &m);\n    if (m == 1) {\n        printf(\"1\\n\");\n        return 0;\n    }\n    fac[0] = fac[1] = 1;\n    for (int i = 2; i <= M; i++)\n        fac[i] = (1LL * fac[i - 1] * i) % Mo;\n    Inv[M] = ksm(fac[M], Mo - 2);\n    // for (int i = 1; i <= n; i++)\n    //     printf(\"%d \", fac[i]);\n    for (int i = M - 1; i >= 0; i--)\n        Inv[i] = 1LL * Inv[i + 1] * (i + 1) % Mo;\n\n    // for (int i = 1; i <= n; i++)\n    //     printf(\"%d \", Inv[i]);\n    f[0][0] = 1;\n    for (int i = 1; i <= n; i++)\n        for (int  j= 0; j <= i; j++) {\n            if (j == 0)\n                f[i][j] = f[i - 1][j];\n            else {\n                f[i][j] = (f[i - 1][j] + 1LL * f[i][j - 1] * (n - j + 1) % Mo * 1LL * (C(m - 2, n - i + (n - j + 1) * (m - 1) - 1)) % Mo) % Mo;\n                // printf(\"%d %d\\n\", C(m - 2, n - i + (n - j + 1) * (m - 1) - 1), n - i + (n - j + 1) * (m - 1) - 1);\n            }\n        }\n    printf(\"%lld\\n\", f[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define rr register\nusing namespace std;\nconst int mod=1000000007,N=2001;\nint n,k,inv[N*N],fac[N*N],dp[N][N];\ninline signed mo(int x,int y){return x+y>=mod?x+y-mod:x+y;}\ninline signed c(int n,int m){return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;}\nsigned main(){\n\tinv[0]=inv[1]=fac[0]=fac[1]=1,scanf(\"%d%d\",&n,&k);\n\tif (k==1) return !putchar(49);\n\tfor (rr int i=2;i<=n*k;++i) inv[i]=1ll*inv[mod%i]*(mod-mod/i)%mod;\n\tfor (rr int i=2;i<=n*k;++i) fac[i]=1ll*fac[i-1]*i%mod,inv[i]=1ll*inv[i-1]*inv[i]%mod;\n\tfor (rr int i=0;i<=n;++i) dp[i][0]=1;\n\tfor (rr int i=1;i<=n;++i) for (rr int j=1;j<=i;++j)\n\t    dp[i][j]=mo(dp[i-1][j],1ll*dp[i][j-1]*(n-j+1)%mod*c(n*k-i-1-(j-1)*(k-1),k-2)%mod);\n\treturn !printf(\"%d\\n\",dp[n][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int mod=1e9+7;\nlong long f[4000010],inv[4000010],dp[2010][2010];\nint n,K;\nint ADD(int x)\n{\n\treturn (x>=mod)?x-mod:x;\n}\nlong long calc(long long a,long long b,long long mod)\n{\n\tlong long ans=1,t=a;\n\tfor (;b;b>>=1)\n\t{\n\t\tif (b&1) ans=ans*t%mod;\n\t\tt=t*t%mod;\n\t}\n\treturn ans;\n}\nlong long C(int n,int m)\n{\n\treturn f[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&K);\n\tif (K==1)\n\t{\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tf[0]=1;\n\tfor (int i=1;i<=n*K;i++) f[i]=f[i-1]*i%mod;\n\tinv[n*K]=calc(f[n*K],mod-2,mod);\n\tinv[0]=1;\n\tfor (int i=n*K-1;i>=1;i--) inv[i]=inv[i+1]*(i+1)%mod;\n\tdp[0][0]=1;\n\tfor (int i=0;i<=n;i++)\n\t\tfor (int j=0;j<=i;j++)\n\t\t{\n\t\t\tif (i!=0) dp[i][j]=dp[i-1][j];\n\t\t\tif (j!=0) dp[i][j]=ADD(dp[i][j]+dp[i][j-1]*C(n*K-i-(j-1)*(K-1)-1,K-2)%mod);\n\t\t}\n\tprintf(\"%lld\\n\",dp[n][n]*f[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int P=1e9+7;\nconst int N=2005;\nlong long f[N][N],fac[N*N],inv[N*N];\nlong long fsp(long long x,int y){\n\tlong long ans=1;\n\twhile(y){\n\t\tif(y&1)\tans=ans*x%P;\n\t\tx=x*x%P,y>>=1;\n\t}\n\treturn ans;\n}\nlong long C(int n,int m){\n\treturn fac[n]*inv[m]%P*inv[n-m]%P;\n}\nint n,m,k;\nint main(){\n\tscanf(\"%d%d\",&n,&k),m=n*k;\n\tfac[0]=inv[0]=f[0][0]=1;\n\tfor(int i=1;i<=m;i++){\n\t\tfac[i]=fac[i-1]*i%P;\n\t\tinv[i]=fsp(fac[i],P-2);\n\t}\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t\tf[i][j]=(f[i][j-1]*C(m-i-(j-1)*(k-1)-1,k-2)%P*(n-j+1)+f[i-1][j])%P;\n\tprintf(\"%lld\\n\",f[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nconst int maxn=2e3+2;\nconst int maxm=4e6+2;\nconst int mod=1e9+7;\nint n,m;\nint fac[maxm],inv[maxm],fv[maxm];\nvoid init(){\n\tfac[0]=fac[1]=inv[1]=fv[0]=fv[1]=1;\n\tfor (int i=2;i<=maxm;i++){\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\t\tinv[i]=1LL*inv[mod%i]*(mod-mod/i)%mod;\n\t\tfv[i]=1LL*fv[i-1]*inv[i]%mod;\n\t}\n}\nint Com(int x,int y){return 1LL*fac[x]*fv[y]%mod*fv[x-y]%mod;}\nint dp[maxn];\nvoid DP(){\n\tdp[0]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=i;j++)\n\t\t\tdp[j]=(dp[j]+1LL*dp[j-1]%mod*(n-j+1)%mod*Com(n*m-i-(j-1)*(m-1)-1,m-2)%mod)%mod;\n}\nint main(){\n\tinit();\n\tscanf(\"%d%d\",&n,&m);\n\tif (m==1){\n\t\tprintf(\"1\");\n\t\treturn 0;\n\t}\n\tDP();\n\tprintf(\"%d\",dp[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL; \nconst int P = 1e9 + 7;\nnamespace Comb {\nconst int U = 2000 * 2000;\nint f[U + 3], rf[U + 3];\nLL inv(LL a, LL m) { return (a == 1 ? 1 : inv(m % a, m) * (m - m / a) % m); }\nvoid init() {\n    f[0] = 1;\n    for (int i = 1; i <= U; i++) f[i] = (LL)f[i - 1] * i % P;\n    rf[U] = inv(f[U], P);\n    for (int i = U; i; i--) rf[i - 1] = (LL)rf[i] * i % P;\n}\nLL C(int n, int m) {\n    if (m < 0 || m > n) return 0;\n    return (LL)f[n] * rf[m] % P * rf[n - m] % P;\n}\n}  // namespace Comb\nusing namespace Comb;\nconst int N = 2010;\nint dp[N][N];\nint main() {\n\tint n, k;\n    init();\n    scanf(\"%d%d\", &n, &k);\n    if (k == 1) {\n        puts(\"1\");\n        return 0;\n    }\n    dp[0][0] = 1;\n    for (int i = 0; i <= n; i++) {\n        for (int j = i; j <= n; j++) {\n            dp[i][j + 1] = (dp[i][j + 1] + dp[i][j]) % P;\n            int lft = n * k - (i * (k - 1) + j) - 1;\n            dp[i + 1][j] = (1ll * dp[i][j] * C(lft, k - 2) % P + dp[i + 1][j]) % P;\n        }\n    }\n    printf(\"%lld\\n\", 1ll * dp[n][n] * f[n] % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<cstdio>\nusing namespace std;\nconst int mod=1e9+7;\nconst int N=2e3+7;\nint n,m;\nint f[N][N],fac[N*N],finv[N*N];\nint Fpow(long long b,int p)\n{\n\tlong long res=1;\n\tfor(;p;p>>=1,b=b*b%mod)\n\t\tif(p&1)res=res*b%mod;\n\treturn res;\n}\nvoid Init()\n{\n\tfac[0]=finv[0]=1;\n\tfor(int i=1;i<=n*m;i++)\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\tfinv[n*m]=Fpow(fac[n*m],mod-2);\n\tfor(int i=n*m-1;i;i--)\n\t\tfinv[i]=1ll*finv[i+1]*(i+1)%mod;\n}\nint C(int n,int m)\n{\n\treturn 1ll*fac[n]*finv[m]%mod*finv[n-m]%mod;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tif(m==1){printf(\"1\\n\");return 0;}\n\tInit();\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(j)f[i][j]=(f[i][j]+1ll*f[i][j-1]*(n-j+1)%mod*C(n*m-i-(j-1)*(m-1)-1,m-2))%mod;\n\t\t}\n\tprintf(\"%d\\n\",f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nID: bqi3431\nPROG: ~\nLANG: C++11 \n*/\n\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); } \n    // inv is equivalent to return exp(b,b.mod-2) if prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\n\ntemplate<int SZ> struct Combo {\n    mi smallInv[SZ], fac[SZ], ifac[SZ]; \n    vpi factors; vi cnt[SZ];\n\n    void genInv() {\n        if (sz(factors) == 1 && factors[0].s == 1) {\n            F0R(i,2) smallInv[i] = i;\n            FOR(i,2,SZ) { // use only O(SZ) operations for MOD a prime\n                int x = (MOD+i-1)/i;\n                smallInv[i] = smallInv[i*x-MOD]*x;\n            }\n        } else {\n            F0R(i,SZ) {\n                int x = invGeneral(i,MOD);\n                if (x == -1) smallInv[i] = 0;\n                else smallInv[i] = x;\n            }\n        }\n    }\n    \n    void init() {\n        // factors = factor(MOD); \n        factors = {{MOD,1}}; \n        genInv(); cnt[0] = vi(sz(factors)); fac[0] = ifac[0] = 1;\n        FOR(i,1,SZ) {\n            cnt[i] = cnt[i-1]; int I = i;\n            F0R(j,sz(factors)) while (I % factors[j].f == 0)\n                I /= factors[j].f, cnt[i][j] ++;\n            fac[i] = fac[i-1]*I; ifac[i] = ifac[i-1]*smallInv[I];\n        }\n    }\n\n    mi comb(int a, int b) {\n        if (a < b || b < 0) return 0;\n        auto tmp = fac[a]*ifac[b]*ifac[a-b];\n        F0R(i,sz(factors)) {\n            int t = cnt[a][i]-cnt[a-b][i]-cnt[b][i];\n            tmp *= exp(mi(factors[i].f),t);\n        }\n        return tmp;\n    }\n};\n\nCombo<4000005> C;\nint N,K;\nmi dp[2001][2001];\n\nint main() {\n    setIO(); re(N,K); C.init();\n    if (K == 1) {\n        ps(1);\n        exit(0);\n    }\n    F0Rd(i,N+1) F0Rd(j,i+1) {\n        if (i == N && j == N) { dp[i][j] = 1; continue; }\n        if (i < N) dp[i][j] = dp[i+1][j];\n        if (j < i) dp[i][j] += C.comb(N-i+(N-(j+1))*(K-1)+K-2,K-2)*dp[i][j+1]; // N-i, (N-(j+1))*(K-1)\n    }\n    ps(dp[0][0]*C.fac[N]);\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#define LL long long\nusing namespace std;\nconst LL mod=1e9+7;\nLL n,k,f[2010][2010];\nLL fac[4100010],inv[4100010];\nvoid pre()\n{\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor(LL i=2;i<=4100000;i++) fac[i]=fac[i-1]*i%mod,inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\tfor(LL i=2;i<=4100000;i++) inv[i]=inv[i-1]*inv[i]%mod;\n}\nLL C(LL m,LL n) {return fac[m]*inv[m-n]%mod*inv[n]%mod;}\nLL get(LL k,LL n)\n{\n\treturn C(k+n,n);\n}//k->n+1\nint main()\n{\n\tpre();\n\tscanf(\"%lld %lld\",&n,&k);\n\tif(k==1) return puts(\"1\"),0;\n\tf[1][0]=1;\n\tfor(LL i=1;i<=n;i++)\n\t\tfor(LL j=0;j<=i;j++)\n\t\t{\n\t\t\tif(j<i) f[i][j+1]=(f[i][j+1]+f[i][j])%mod;\n\t\t\tif(i<n) (f[i+1][j]+=f[i][j]*get(k-2,i*(k-1)+j))%=mod;\n\t\t}\n\tprintf(\"%lld\",f[n][n]*fac[n]%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\n#define maxn 4000000 \nusing namespace std;\nint n,k;\nint dp[2005][2005];\nint fac[4000005],ifac[4000005];\n\nint ksm(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=1ll*res*x%mod;\n\t\tx=1ll*x*x%mod,y/=2;\n\t}\n\treturn res;\n}\n\nint C(int x,int y){\n\tint res=1ll*fac[x]*ifac[y]%mod*ifac[x-y]%mod;\n\treturn res;\n}\n\nint main(){\n\tscanf(\"%d %d\",&n,&k);\n\tif(k==1){\n\t\tputs(\"1\");return 0;\n\t}\n\tfac[0]=1;for(int i=1;i<=maxn;i++) fac[i]=1ll*i*fac[i-1]%mod;\n\tifac[maxn]=ksm(fac[maxn],mod-2);\n\tfor(int i=maxn-1;i>=0;i--) ifac[i]=1ll*(i+1)*ifac[i+1]%mod;\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\tif(j){\n\t\t\t\tdp[i][j]+=1ll*dp[i][j-1]*(n-j+1)%mod*C(n*k-i-(j-1)*(k-1)-1,k-2)%mod;\n\t\t\t\tif(dp[i][j]>=mod) dp[i][j]-=mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[n][n]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <math.h>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <string.h>\n#include <bitset>\n#define REP(i,a,n) for(int i=a;i<=n;++i)\n#define PER(i,a,n) for(int i=n;i>=a;--i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(a) ({REP(__i,1,n) cout<<a[__i]<<' ';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\n\nconst int N = 2010, M = 4e6+10;\nint n, k, dp[N][N];\nint fac[M], ifac[M];\nint C(int n, int m) {\n\tif (n<m) return 0;\n\treturn (ll)fac[n]*ifac[m]%P*ifac[n-m]%P;\n}\nint main() {\n\tfac[0]=1;\n\tREP(i,1,M-1) fac[i]=(ll)fac[i-1]*i%P;\n\tifac[M-1]=inv(fac[M-1]);\n\tPER(i,0,M-2) ifac[i]=(ll)ifac[i+1]*(i+1)%P;\n\tscanf(\"%d%d\", &n, &k);\n\tdp[0][0] = 1;\n\tREP(i,0,n) REP(j,0,i) {\n\t\tdp[i+1][j] = (dp[i+1][j]+dp[i][j])%P;\n\t\tdp[i][j+1] = (dp[i][j+1]+(ll)C(n*k-j*(k-1)-i-1,k-2)*dp[i][j])%P;\n\t}\n\tint ans = (ll)dp[n][n]*fac[n]%P;\n\tprintf(\"%d\\n\", ans);\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nconst int N=2200;\n\n\nint b[N],n,k,num;\nlong long bb[N*N],dd[N][N],pp,ans,f[N][N],p=1000000007;\nlong long xxx;\nlong long do3(long long x){\n\tlong long s=x,t=x;\n\n\tfor(int i=2; i<=num; i++){\n\t\ts=s*s%p;\n\t\tif(b[i]==1) t=t*s%p;\n\t\t\n\t}\n\t\n\treturn t%p;\n}\n\nvoid do1(int x,int y){\n\tint mm=k-2;\n\tint nn=n*k-x-(y-1)*(k-1)-1;\n\t\n//\tprintf(\"ccc%d %d %d %d\\n\",x,y,nn,mm);\n\t\n\tlong long ans=1,a=1,b=1;\n\t\n\ta=bb[nn];\n\t//b=do3(bb[mm])*do3(bb[nn-mm])%p;\n\tb=xxx*do3(bb[nn-mm])%p;\n//\tprintf(\"ccc2  %d %I64d %I64d\\n\",nn, a,b);\n\t\n\tans=b*a%p;\n\t\n//\tprintf(\"ccc3  %I64d\\n\",ans);\n\t\n\tdd[x][y]=ans;\n\t\n}\n\nvoid do2(){\n\tlong long a=f[n][n];\n\t\n\tfor(int i=1; i<=n; i++){\n\t\ta=a*i%p;\n\t}\n\t\n\tf[n][n]=a;\n}\n\nvoid f1(int x,int y){ \n\n//\tprintf(\"11 %d %d\\n\",x,y);\n\n\tif(x==0){\n\t\tf[x][y]=1;\n\t\treturn;\n\t}\n\tif(y==0){\n\t\tf[x][y]=1;\n\t\treturn;\n\t}\n//\tprintf(\"22 %d %d\\n\",x,y);\n\t\n\tif(f[x-1][y]==-1 and x-1>=y) f1(x-1,y);\n\tif(f[x][y-1]==-1 and x>=y-1) f1(x,y-1);\n\t\n//\tprintf(\"%d %d %I64d %I64d \\n\",x, y, f[x-1][y],f[x][y-1]);\n\t\n\tf[x][y]=0;\n\tif(x-1>=y) f[x][y]=(f[x][y]+f[x-1][y])%p;\n\t\n\tif(dd[x][y]==-1) do1(x,y);\n//\tprintf(\"aaa%d %d %I64d %I64d\\n\",x, y, f[x][y-1], dd[x][y]);\n\tf[x][y]+=f[x][y-1]*dd[x][y]%p;\n\tf[x][y]=f[x][y]%p;\n//\tprintf(\"%d %d %I64d \\n\",x, y, f[x][y]);\n\treturn;\n}\n\n\n\nint main(){\n//\tfreopen(\"leftmost ball.in\",\"r\",stdin);\n//\tfreopen(\"leftmost ball.out\",\"w\",stdout);\n\n\tscanf(\"%d%d\",&n,&k);\n\t\n\tif(k==1){\n\t\tprintf(\"1\"); \n\t\treturn 0;\n\t}\n\tbb[0]=1;\n\tbb[1]=1;\n\tfor(int i=2; i<=n*k; i++){\n\t\tbb[i]=bb[i-1]*i%p;\n\t}\n\t\n\tpp=1000000005;\n\tnum=0;\n\twhile(pp>0){\n\t\tb[++num]=pp%2;\n\t\tpp=pp/2;\n\t}\n\t\n//\tfor(int i=num; i>=1; i--) printf(\"%d\",b[i]); printf(\"\\n\");\n\tmemset(dd,-1,sizeof(dd));\n\tmemset(f,-1,sizeof(f));\n\txxx=do3(bb[k-2]);\n\tf1(n,n);\n\t\n//\tfor(int i=0; i<=n; i++){\n//\t\tfor(int j=0; j<=n; j++){\n//\t\t\tprintf(\"%I64d \",dd[i][j]);\n//\t\t}printf(\"\\n\");\n//\t}\n\t\n\tdo2();\n\t\n\tf[n][n]=f[n][n]%p;\n\n\tprintf(\"%I64d\",f[n][n]);\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define per(i,r,l) for(int i=(r);i>=(l);--i)\nusing namespace std;\nconst int maxn=2010,P=1e9+7;\nint n,k,fac[maxn*maxn],ifac[maxn*maxn],inv[maxn*maxn],dp[maxn][maxn];\ninline int C(int n,int k){return 1ll*fac[n]*ifac[k]%P*ifac[n-k]%P;}\nint main(){\n    scanf(\"%d%d\",&n,&k);int N=n*k;inv[1]=fac[0]=ifac[0]=1;\n    if(k==1) return puts(\"1\"),0;\n    rep(i,2,n*k) inv[i]=1ll*(P-P/i)*inv[P%i]%P;\n    rep(i,1,n*k) fac[i]=1ll*fac[i-1]*i%P,ifac[i]=1ll*ifac[i-1]*inv[i]%P;\n    dp[0][0]=1;\n    rep(i,1,n) rep(j,0,i){\n        dp[i][j]=dp[i-1][j];\n        if(j) dp[i][j]=(dp[i][j]+1ll*dp[i][j-1]*(n-j+1)%P*C(n*k-i-(j-1)*(k-1)-1,k-2)%P)%P;\n    }\n    printf(\"%d\\n\",dp[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nconst int MOD=1000000007;\n\n/*inline int power(int x,int n,int M) {\n\tint tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (!(n&1)) tmp = ((long long int)tmp*tmp) % M;\n\t\telse tmp = ((((long long int)tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}*/\n\ninline int power(int x,int n,int M){\n  int ret=1;\n  int box=x;\n  while(n){\n    if(n&1)ret=((long long int)ret*box)%M;\n    box=((long long int)box*box)%M;\n    n>>=1;\n  }\n  return ret;\n}\n\nint main(){\n  int N,M;\n  cin>>N>>M;\n  if(M==1){\n    cout<<1<<endl;\n    return 0;\n  }\n  vector<int>by(N*M+1,1);\n  vector<int>rev_by(N*M+1,1);\n  for(int i=1;i<=N*M;i++){\n    by[i]=(1LL*by[i-1]*i)%MOD;\n    rev_by[i]=power(by[i],MOD-2,MOD);\n  }\n  vector<vector<int>>dp(N+1,vector<int>(N+1));\n  dp[0][0]=1;\n  for(int i=0;i<=N;i++){\n    for(int j=i;j<=N;j++){\n      if(i)dp[i][j]=dp[i-1][j];\n      if(j){\n        int add=((long long int)dp[i][j-1]*rev_by[M-2])%MOD;\n        add=((long long int)add*by[i+j*(M-1)-1])%MOD;\n        add=((long long int)add*rev_by[i+j*(M-1)-1-(M-2)])%MOD;\n        dp[i][j]+=add;\n        dp[i][j]%=MOD;\n      }\n    }\n  }\n  cout<<((long long int)dp.back().back()*by[N])%MOD<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define IL inline\n#define RG register\n#define LL long long\n#define Upd(a) (a)>=mod?(a-=mod):1\nusing namespace std;\ntemplate <class T>\nIL char gc () {\n\tstatic char buf[1<<6], *p1=buf, *p2=buf;\n\treturn (p1==p2) && (p2=(p1=buf)+fread(buf,1,1<<6,stdin), p1==p2) ?EOF:*p1++;\n}\ntemplate <typename T>\nIL void read (T&data) {\n\tdata=0;\n\tRG char ch=0;\n\twhile (ch<'0' || ch>'9') ch=getchar();\n\twhile (ch<='9' && ch>='0') data=(data<<1)+(data<<3)+(ch&15), ch=getchar();\n}\nconst int mod = 1e9+7;\nconst int _ =2021;\nint n, k;\nint dp[2][_], jc[_*_], jcn[_*_];\nIL int poww (RG int a, RG int b) {\n\tRG int ret=1, Base=a;\n\tfor (;b;b>>=1, Base=1LL*Base*Base%mod) if (b&1) ret=1LL*ret*Base%mod;\n\treturn ret;\n}\nIL int C (RG int a, RG int b) {\n\tif (a<b) return 0;\n\treturn 1LL*jc[a]*jcn[b]%mod*jcn[a-b]%mod;\n}\nint main (/*int aa, int bb*/) {\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\t//n=aa, k=bb;\n\tread(n), read(k);\n\tif (k<=1) {puts(\"0\"); return 0;}\n\tjc[0]=jcn[0]=1;\n\tRG int i, j, pre=1, cur=0;\n\tfor (i=1; i<=n*k; ++i) jc[i]=1LL*jc[i-1]*i%mod, jcn[i]=poww(jc[i], mod-2);\n\tdp[0][0]=1;\n\tfor (i=1; i<=n*2; ++i) {\n\t\tswap(cur, pre);\n\t\tfor (j=0; j<min(i,n+1); ++j) dp[cur][j]=0;\n\t\tfor (j=1; j<=min(i,n); ++j) {\n\t\t\tif ((i-j)%2) continue;\n\t\t\tif (n*2-i+1<j) break;\n\t\t\tRG int a=(i+j-2)>>1, b=(i-j)>>1;\n\t\t\tdp[cur][j]=1LL*dp[pre][j-1]*C(a*(k-1)+b+k-1-1,k-1-1)%mod;\n\t\t\tdp[cur][j]+=dp[pre][j+1];\n\t\t\tUpd(dp[cur][j]);\n\t\t}\n\t\tif (cur%2==0) dp[cur][0]=dp[pre][1];\n\t}\n\t//return 1LL*dp[cur][0]*jc[n]%mod;\n\tprintf(\"%lld\",1LL*dp[cur][0]*jc[n]%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<LL, LL> pll;\ntypedef pair<int, int> pii;\n\nconst int mod = 1e9 + 7;\nconst int maxn = 4000 + 5;\nconst int oo = 0x3f3f3f3f;\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\n#define fst first\n#define snd second\n#define pb push_back\n\ntemplate<typename T> T read() {\n\tT n(0), f(1);\n\tchar ch = getchar();\n\tfor( ;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n\tfor( ; isdigit(ch); ch = getchar()) n = n * 10 + ch - 48;\n\treturn n * f;\n}\n\nLL f[maxn][maxn], C[maxn][maxn];\nLL fac(int n) {\n    LL res = 1;\n    for(int i = 2; i <= n; i++) (res *= i) %= mod;\n    return res;\n}\nvoid init() {\n    for(int i = 0; i < maxn; i++) { \n        C[i][0] = C[i][i] = 1;\n        for(int j = 1; j < i; j++)\n            C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod;\n    }\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n    //freopen(\"data.txt\", \"r\", stdin);\n    //freopen(\"ans.txt\", \"w\", stdout);\n#endif\n\n    init();\n\n    int n, k;\n    n = read<int>(), k = read<int>();\n    if(k == 1) { puts(\"1\"); return 0; }\n\n    f[n][n] = 1;\n\n    for(int i = n; i >= 0; i--) {\n        for(int j = n; j >= 0; j--) if(f[i][j]) {\n            if(i > 0) (f[i-1][j] += f[i][j]) %= mod;\n            if(j > i) (f[i][j-1] += f[i][j] * C[n*k-(n-i)-(n-j)*(k-1)-1][k-2] % mod) %= mod;\n        }\n    }\n    printf(\"%lld\\n\", f[0][0] * fac(n) % mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define FILE_IO\n\nconst int mod = 1e9 + 7;\n\nconst int VMAX = 4000000;\n\nint N, K;\nint fct[VMAX + 5], ifct[VMAX + 5];\n\nint dp[2005][2005];\n\nint power(int x, int y)\n{\n    int p = x, r = 1;\n    while(y)\n    {\n        if(y & 1)   r = (1LL * r * p) % mod;\n        p = (1LL * p * p) % mod;\n        y >>= 1;\n    }\n    return r;\n}\n\nint C(int N, int K)\n{\n    int ans = fct[N];\n    ans = (1LL * ans * ifct[K]) % mod;\n    ans = (1LL * ans * ifct[N - K]) % mod;\n    return ans;\n}\n\nvoid precalc()\n{\n    fct[0] = 1;\n    for(int i = 1; i <= VMAX; i++)\n        fct[i] = (1LL * fct[i - 1] * i) % mod;\n    ifct[VMAX] = power(fct[VMAX], mod - 2);\n    for(int i = VMAX - 1; i >= 1; i--)\n        ifct[i] = (1LL * ifct[i + 1] * (i + 1)) % mod;\n    ifct[0] = 1;\n}\n\nint main()\n{\n    #ifdef FILE_IO\n    freopen(\"1.in\", \"r\", stdin);\n    freopen(\"1.out\", \"w\", stdout);\n    #endif\n\n    precalc();\n\n    scanf(\"%d%d\", &N, &K);\n\n    if(N == 1 || K == 1)\n    {\n        printf(\"1\\n\");\n        return 0;\n    }\n\n    /*dp[N][N] =\n\n    dp[i][j] = dp[i + 1][j];\n    dp[i][j] += dp[i][j + 1] * C( (N - i + 1) + (N - j) * (K - 1) - 1 , K - 1 );*/\n\n    /// DP[i][j] - i-th white ball, j-th colors\n\n\n    dp[N + 1][N + 1] = 1;\n    for(int i = N + 1; i >= 1; i--)\n        for(int j = i == N + 1 ? N : i; j >= 1; j--)\n        {\n            int white = dp[i + 1][j];\n            int color = ( 1LL * dp[i][j + 1] * C( (N - i + 1) + (N - j + 1) * (K - 1) - 1 , K - 2 ) ) % mod;\n            dp[i][j] = (white + color) % mod;\n        }\n\n    int ans = (1LL * dp[1][1] * fct[N]) % mod;\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define ll long long\nusing ull = unsigned long long;\nusing namespace std;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define bit(n, k) ((n >> k) & 1) /*nのk bit目*/\nnamespace mydef {\nconst int INF = 1ll << 60;\nconst int MOD = 1e9 + 7;\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\nvoid Yes(bool flag = true) {\n    if (flag)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n}\nvoid No(bool flag = true) {\n    Yes(!flag);\n}\nvoid YES(bool flag = true) {\n    if (flag)\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\nvoid NO(bool flag = true) {\n    YES(!flag);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T& val) {\n    std::fill((T*)array, (T*)(array + N), val);\n}\nbool dbg = false;\n}  // namespace mydef\nusing namespace mydef;\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define vi vector<int>\n#define vvi vector<vector<int>>\n#define vp vector<pair<int, int>>\n#define vvp vector<vector<pair<int, int>>>\n#define pi pair<int, int>\n//#define P pair<int, int>\n//#define V vector<int>\n//#define S set<int>\n#define asn ans\n\ntemplate <uint MD>\nstruct ModInt {\n    using M = ModInt;\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(_v % MD + MD); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(ull(v) * r.v % MD); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1)\n                r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    /*\n    M inv() const {\n        long long b = MD, u = 1, v = 0;\n        long long a = (*this).v;\n        while (b) {\n            long long t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        u %= MD;\n        if (u < 0)\n            u += MD;\n        return M{u};\n    }\n    */\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n    friend istream& operator>>(istream& is, M& r) { return is >> r.v; }\n};\nusing Mint = ModInt<MOD>;\nconst int MN = 5'000'000;\nMint fact[MN], iFac[MN];\n\nvoid first() {\n    fact[0] = Mint(1);\n    for (int i = 1; i < MN; i++)\n        fact[i] = fact[i - 1] * Mint(i);\n    iFac[MN - 1] = fact[MN - 1].inv();\n    for (int i = MN - 1; i >= 1; i--) {\n        iFac[i - 1] = iFac[i] * Mint(i);\n    }\n    assert(fact[2345] * iFac[2345] == Mint(1));\n}\nMint C(int n, int k) {\n    if (n < k || k < 0)\n        return Mint(0);\n    return fact[n] * iFac[k] * iFac[n - k];\n}\n\nint N, K;\nMint dp[2020][2020];\nbool seen[2020][2020];\n\nMint f(int i, int j) {\n    if (seen[i][j])\n        return dp[i][j];\n    seen[i][j] = 1;\n    if (j > 0)\n        dp[i][j] += f(i, j - 1) * C(K * N - i - j - (K - 2) * (j - 1), K - 2);\n    if (i > j)\n        dp[i][j] += f(i - 1, j);\n    return dp[i][j];\n}\n\nvoid solve() {\n    first();\n    dp[1][0] = 1;\n    seen[1][0] = 1;\n    seen[0][0] = 1;\n    if (K >= 2)\n        cout << f(N, N) * fact[N] << endl;\n    else\n        cout << 1 << endl;\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    cin >> N >> K;\n\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=2002,M=1e9+7;\nint n,m,k,f[N*N],F[N*N],g[N][N];\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=1LL*a*a%M)if(b&1)s=1LL*s*a%M;\n\treturn s;\n}\nint main(){\n\tcin>>n>>k;m=n*k;\n\tif(k==1){puts(\"1\");return 0;}\n\tf[0]=1;\n\tfor(int i=1;i<=m;++i)f[i]=1LL*f[i-1]*i%M;\n\tF[m]=mi(f[m],M-2);\n\tfor(int i=m;i>=1;--i)F[i-1]=1LL*F[i]*i%M;\n\tg[0][0]=1;\n\tfor(int i=0,I=k-1;i<=n;++i,I+=k-1)for(int j=0;j<=i;++j){\n\t\t(g[i+1][j]+=1LL*g[i][j]*f[I+j-1]%M*F[I+j-k+1]%M*F[k-2]%M)%=M;\n\t\t(g[i][j+1]+=g[i][j])%=M;\n\t}\n\tcout<<1LL*g[n][n]*f[n]%M<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nconst int maxn=2e3+5,pps=1e9+7;\n\nint n,k,ans;\nint f[maxn],fac[maxn*maxn],inv[maxn*maxn];\n\nint read() {\n    int x=0,f=1;char ch=getchar();\n    for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;\n    for(;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';\n    return x*f;\n}\n\nint quick(int a,int b) {\n    int sum=1;\n    while(b) {\n        if(b&1)sum=1ll*sum*a%pps;\n        a=1ll*a*a%pps;b>>=1;\n    }\n    return sum;\n}\n\nvoid prepare(int N) {\n    fac[0]=inv[0]=1;\n    for(int i=1;i<=N;i++)\n        fac[i]=1ll*fac[i-1]*i%pps;\n    inv[N]=quick(fac[N],pps-2);\n    for(int i=N-1;i;i--)\n        inv[i]=1ll*inv[i+1]*(i+1)%pps;\n}\n\nint C(int a,int b) {\n    return 1ll*fac[a]*inv[b]%pps*inv[a-b]%pps;\n}\n\nint main() {\n    n=read(),k=read()-1;\n    if(!k) {puts(\"1\");return 0;}\n    prepare(n*k+n);f[0]=1;\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=i;j++)\n            f[j]=(f[j]+1ll*C(n*k+n-i-(j-1)*k-1,k-1)*f[j-1]%pps)%pps;\n    ans=1ll*f[n]*fac[n]%pps;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define res register int\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n#define INF 1000000007\n#define gc getchar()\n#define MAXN 10000005\n#define lc pos<<1\n#define rc pos<<1|1\nusing namespace std;\n\ninline int read()\n{\n    int ch=gc,f=0;\n    int x=0;\n    while(ch<'0'||ch>'9')\n    {\n        f|=ch=='-';\n        ch=gc;\n    }\n    while(ch>='0'&&ch<='9')\n    {\n        x=x*10+ch-'0';\n        ch=gc;\n    }\n    return f?-x:x;\n}\nconst int kcz=INF;\nint n,m;\nint k;\nint f[2005][2005];\nint js[4000005],inv[4000005];\ninline int power(int a,int p)\n{\n\tint ret=1;\n\twhile(p)\n\t{\n\t\tif(p&1)\n\t\tret=1ll*ret*a%kcz;\n\t\ta=1ll*a*a%kcz;\n\t\tp>>=1;\n\t}\n\treturn ret;\n}\ninline void init(int n)\n{\n\tjs[0]=inv[0]=1;\n\tfor(int i=1;i<=n;i++)\n\tjs[i]=i*1ll*js[i-1]%kcz;\n\tinv[n]=power(js[n],kcz-2);\n\tfor(int i=n-1;i;i--)\n\tinv[i]=(i+1)*1ll*inv[i+1]%kcz;\n}\ninline int C(int n,int m)\n{\n\treturn js[n]*1ll*inv[m]%kcz*inv[n-m]%kcz;\n}\nint main()\n{\n\tn=read(),m=read();\n\tf[n][n]=1;\n\tinit(4000000);\n\tif(m==1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor(int i=n-1;~i;i--)\n\t{\n\t\tfor(int j=n;j>=i;j--)\n\t\t{\n\t\t\tf[i][j]=(f[i+1][j]+f[i][j+1]*1ll*(j+1)%kcz*C(i+(j+1)*(m-1)-1,m-2)%kcz)%kcz;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[0][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<stack>\n#include<queue>\n#include<list>\n#include<vector>\n#include<set>\n#include<map>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#define ll long long\n#define ld double\n#define inf 2001\n#define infm inf*inf\n#define mod ((ll)1e9+7)\n#define INF (int)(1e9) \n#define pi acos(-1)\n#define rd(n) {n=0;char ch;int f=0;do{ch=getchar();if(ch=='-'){f=1;}}while(ch<'0'||ch>'9');while('0'<=ch&&ch<='9'){n=(n<<1)+(n<<3)+ch-48;ch=getchar();}if(f)n=-n;}\nusing namespace std;\n\nll getinv(ll x){\n\tll k=mod-2,ans=1;\n\twhile (k){\n\t\tif (k&1){\n\t\t\tans=ans*x%mod;\n\t\t}\n\t\tx=x*x%mod;\n\t\tk/=2;\n\t}\n\treturn ans;\n}\n\nll fact[infm],invf[infm];\n\nvoid prework(int N){\n\tfact[0]=1;\n\tfor (int i=1;i<=N;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t}\n\tinvf[N]=getinv(fact[N]);\n\tfor (int i=N-1;i>=0;i--){\n\t\tinvf[i]=invf[i+1]*(i+1)%mod;\n\t}\n\treturn;\n}\n\nll C(int x,int y){\n\treturn fact[x]*invf[y]%mod*invf[x-y]%mod;\n}\n\nll cal(int x,int y){\n\treturn C(x+y,x);\n}\n\nint n,K;\nint f[inf][inf];\n\nint main(){\n\trd(n) rd(K)\n\tif (K==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tprework(n*K);\n\tf[0][0]=1;\n\tfor (int i=1;i<=n;i++){\n\t\tll sum=0;\n\t\tfor (int j=i;j>=1;j--){\n\t\t\tsum=(sum+f[i-1][j-1])%mod;\n\t\t\tf[i][j]=sum*cal((i-1)*K-j+1,K-2)%mod;\n\t\t}\n\t}\n\tll ans=0;\n\tfor (int i=0;i<=n;i++){\n\t\tans=(ans+f[n][i])%mod;\n\t}\n\tprintf(\"%lld\\n\",ans*fact[n]%mod);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN=2005,MAXL=MAXN*MAXN*2-3,mod=1e9+7;\nint N,K;\nll fac[MAXN*MAXN*4],inv[MAXN*MAXN*4];\nll C(ll n,ll m) {\n//\tprintf(\"C(%lld,%lld)\\n\",n,m);\n\tif(n<0||m<0||n<m) return 0;\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nll f[MAXN][MAXN];\nint main() {\n\tscanf(\"%d%d\",&N,&K);\n\tfac[0]=inv[0]=inv[1]=1;\n\tfor(int i=1;i<=MAXL;++i) fac[i]=fac[i-1]*i%mod;\n\tfor(int i=2;i<=MAXL;++i) inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=1;i<=MAXL;++i) inv[i]=inv[i]*inv[i-1]%mod;\n\t//printf(\"%lld\\n\",C(5,3));\n\tif(K<2) {\n\t\tcout<<1<<endl;\n\t\texit(0);\n\t}\n\tf[0][0]=1;\n\tfor(int i=1;i<=N;++i) {\n\t\tfor(int j=0;j<=i;++j) {\n\t\t\tif(i==j) {\n\t\t\t\tf[i][j]=f[i][j-1]*C( N*K-i-(j-1)*(K-1)-1 ,K-2)%mod;\n\t\t\t} else {\n\t\t\t\tf[i][j]=(f[i-1][j]+f[i][j-1]*C( N*K-i-(j-1)*(K-1)-1 ,K-2)%mod)%mod;\n\t\t\t}\n\t\t\t//printf(\"f[%d][%d]=%lld\\n\",i,j,f[i][j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[N][N]*fac[N]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#include <tr1/unordered_map>\nusing namespace std;\n#define ll long long\n#define re register\n#define pb push_back\n#define fi first\n#define se second\nconst int N=4e6+10;\nconst int mod7=1e9+7;\nconst int mod=1e9+7;\nvoid read(int &a)\n{\n    a=0;int d=1;char ch;\n    while(ch=getchar(),ch>'9'||ch<'0')\n        if(ch=='-')\n            d=-1;\n    a=ch^48;\n    while(ch=getchar(),ch>='0'&&ch<='9')\n        a=(a<<3)+(a<<1)+(ch^48);\n    a*=d;\n}\nvoid read(ll &a)\n{\n    a=0;int d=1;char ch;\n    while(ch=getchar(),ch>'9'||ch<'0')\n        if(ch=='-')\n            d=-1;\n    a=ch^48;\n    while(ch=getchar(),ch>='0'&&ch<='9')\n        a=(a<<3)+(a<<1)+(ch^48);\n    a*=d;\n}\nll f[2005][2005],fac[N],ifac[N];\nll quickmod(ll x,ll y)\n{\n    ll res=1,base=x;\n    while(y)\n    {\n        if(y&1) res=res*base%mod;\n        base=base*base%mod;\n        y>>=1;\n    }\n    return res;\n}\nvoid init(int n)\n{\n    fac[0]=1;\n    for(re ll i=1;i<=n;i++) fac[i]=i*fac[i-1]%mod;\n    ifac[n]=quickmod(fac[n],mod-2);\n    for(re ll i=n-1;~i;i--) ifac[i]=ifac[i+1]*(i+1)%mod;\n}\nll C(int n,int m) {return n<m?0:fac[n]*ifac[m]%mod*ifac[n-m]%mod;}\nint main()\n{\n    int n,k;\n    read(n),read(k);\n    if(k==1) return puts(\"1\"),0;\n    init(n*k);\n    f[0][0]=1;\n    for(re int i=1;i<=n;i++)\n    {\n        for(re int j=0;j<=i;j++)\n        {\n            if(!j)\n            {\n                f[i][j]=f[i-1][j];\n                continue;\n            }\n            f[i][j]=f[i-1][j]+f[i][j-1]*(n-j+1)%mod*C(n*k-i-1-(j-1)*(k-1),k-2)%mod;\n            f[i][j]%=mod;\n        }\n    }\n    printf(\"%lld\\n\",f[n][k]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=2e3+11;\nconst int M=4e6+11;\nconst int mod=1e9+7;\nint n,k,f[N][N],fac[M],ifac[M];\nint read(){\n    int x=0,f=1;char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}\n    while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}\n    return x*f;\n}\nint qpow(int a,int b){\n    int re=1;\n    while(b){\n        if(b&1) re=(re*a)%mod;\n        b>>=1;a=a*a%mod;\n    }return re;\n}\nint C(int a,int b){\n    if(a<b) return 0;\n    return fac[a]*ifac[b]%mod*ifac[a-b]%mod;\n}\nsigned main(){\n    n=read(),k=read();\n    if(k==1) return puts(\"1\"),0;\n    fac[0]=1;ifac[0]=1;f[0][0]=1;\n    for(int i=1;i<=n*k;i++) fac[i]=fac[i-1]*i%mod;\n    ifac[n*k]=qpow(fac[n*k],mod-2);\n    for(int i=n*k-1;i;i--) ifac[i]=ifac[i+1]*(i+1)%mod;\n    for(int i=1;i<=n;i++)\n        for(int j=0;j<=i;j++){\n            if(i>j) f[i][j]+=f[i-1][j];\n            f[i][j]=(f[i][j]+f[i][j-1]*C((n-j+1)*(k-1)+n-i-1,k-2)%mod)%mod;\n        }\n    printf(\"%lld\\n\",f[n][n]*fac[n]%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nint n,k,dp[2001][2001],fac[4000001],ifac[4000001];const int p=1e9+7;\ninline int qpow(int bs,int ex){int ans=1;while(ex){if(ex&1)ans=1ll*ans*bs%p;bs=1ll*bs*bs%p;ex>>=1;}return ans;}\ninline int binom(int n,int m){return 1ll*fac[n]*ifac[m]%p*ifac[n-m]%p;}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);if(k==1){putchar(48);putchar(10);return 0;}\n\tfac[0]=1;for(int i=1;i<=n*k;++i)fac[i]=1ll*fac[i-1]*i%p;ifac[n*k]=qpow(fac[n*k],p-2);for(int i=n*k-1;~i;--i)ifac[i]=1ll*ifac[i+1]*(i+1)%p;\n\tfor(int i=0;i<=n;++i)dp[i][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=i;++j)\n\t\t{\n\t\t\t(dp[i][j]+=dp[i-1][j])%=p;\n\t\t\t(dp[i][j]+=1ll*dp[i][j-1]*(n-j+1)%p*binom(n*k-i-1-(j-1)*(k-1),k-2)%p)%=p;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[n][n]);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Relive your past life.\n//Face your demons.\n//The past is never dead,it is not even past.\n//The memories are not only the key to the past but...also to the future.\n//coded in Rusty Lake\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007ll\nusing namespace std;\nint n,k,;\nll jc[4000005],njc[4000005],dp[2005][2005];\nll fp(ll x,int k=1000000005){\n    ll ans=1;\n    while(k){\n        if(k&1)ans=ans*x%orz;\n        k>>=1,x=x*x%orz;\n    }\n    return ans;\n}\nint main(){\n    scanf(\"%d%d\",&n,&k);\n    if(n==1||k==1){\n        puts(\"1\");\n        return 0;\n    }\n    jc[0]=1;\n    for(int i=1;i<=n*k;++i)jc[i]=jc[i-1]*i%orz;\n    njc[n*k]=fp(jc[n*k]);\n    for(int i=n*k;i;--i)njc[i-1]=njc[i]*i%orz;\n    dp[0][1]=1;\n    for(int i=2;i<=n;++i)dp[0][i]=dp[0][i-1]*jc[i*k-i-1]%orz*njc[k-2]%orz*njc[i*k-i-k+1]%orz;\n    for(int i=1;i<n;++i){\n        dp[i][i]=dp[i-1][i];\n        for(int j=i+1;j<=n;++j)dp[i][j]=(dp[i][j-1]*jc[i+j*k-j-1]%orz*njc[k-2]%orz*njc[i+j*k-j-k+1]%orz+dp[i-1][j])%orz;\n    }\n    printf(\"%lld\\n\",dp[n-1][n]*jc[n]%orz);\n    //system(\"pause\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n\n#define pb emplace_back\n#define fi first\n#define se second\n     \nusing namespace std;\n\ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n     \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-12;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\n\nll in(){ ll x; scanf( \"%lld\" , &x ); return x; }\nchar yuyushiki[1000010]; string stin(){ scanf( \"%s\" , yuyushiki ); return yuyushiki; }\n\n// head\n\n\nstruct Mod{\n  unsigned n;\n  Mod() : n(0){}\n  Mod( ll x ){\n    if( x < 0 ) n = x%MOD+MOD;\n    else n = x%MOD;\n  }\n};\nMod operator + ( Mod a  , Mod b ){ return Mod( a.n + b.n ); }\nMod operator +=( Mod &a , Mod b ){ return a = a + b; }\nMod operator - ( Mod a ){ return Mod( MOD - a.n ); }\nMod operator - ( Mod a  , Mod b ){ return Mod( a.n + MOD - b.n ); }\nMod operator -=( Mod &a , Mod b ){ return a = a - b; }\nMod operator * ( Mod a  , Mod b ){ return Mod( (ll)a.n * b.n ); }\nMod operator *=( Mod &a , Mod b ){ return a = a * b; }\nMod modpow( Mod x , ll k ){\n  Mod res = 1;\n  while( k ){\n    if( k & 1 ) res *= x;\n    k /= 2;\n    x *= x;\n  }\n  return res;\n}\nll extgcd( ll a , ll b , ll &x , ll &y ){\n  ll d = a;\n  if( b != 0 ){\n    d = extgcd( b , a % b , y , x );\n    y -= a / b * x;\n  } else {\n    x = 1, y = 0;\n  }\n  return d;\n}\nMod inv( Mod a ){ ll x, y; assert( extgcd( a.n , MOD , x , y ) == 1 ); return Mod( x ); }\nMod operator / ( Mod a  , Mod b ){ return Mod( (ll)a.n * inv(b).n ); }\nMod operator /=( Mod &a , Mod b ){ return a = a / b; }\n\n\n\nstruct Factorial{\n  vector<Mod> v;\n  Factorial( int max_n ){\n    v = vector<Mod>( max_n , 1 );\n    FOR( i , 1 , max_n ) v[i] = v[i-1] * i;\n  }\n  int size(){\n    return v.size();\n  }\n  Mod operator [] ( int id ){\n    return v[id];\n  }\n};\n\nstruct Factorial_inv{\n  vector<Mod> v;\n  Factorial_inv( Factorial &f ){\n    v = vector<Mod>( f.size() );\n    REP( i , f.size() ) v[i] = inv( f[i] );\n  }\n  Mod operator [] ( int id ){\n    return v[id];\n  }\n};\n\nstruct Combination{\n  Factorial *f;\n  Factorial_inv *finv;\n  Combination( Factorial &arg_f , Factorial_inv &arg_finv ){\n    f = &arg_f;\n    finv = &arg_finv;\n  }\n  Mod operator () ( int a , int b ){\n    return (*f)[a] * (*finv)[b] * (*finv)[a-b];\n  }\n};\n\nFactorial fact( 4000010 );\nFactorial_inv finv( fact );\nCombination comb( fact , finv );\n\n\n\nint n, k;\n\nMod dp[2010][2010];\n\nint main(){\n\n  n = in();\n  k = in();\n\n  if( k == 1 ){\n    cout << 1 << endl;\n    return 0;\n  }\n  \n  dp[0][0] = 1;\n  REP( i , n+1 ){\n    if( i == 0 ){\n      dp[i][i] = 1;\n    } else {\n      dp[i][i] = dp[i-1][i];\n    }\n    FOR( j , i+1 , n+1 ){\n      if( i > 0 ){\n\tdp[i][j] = dp[i-1][j];\n      }\n      dp[i][j] += dp[i][j-1] * comb( i + j * ( k - 1 ) - 1 , k - 2 );\n    }\n  }\n\n  /*\n  REP( i , n+1 ){\n    REP( j , n+1 ){\n      cout << dp[i][j].n << \" \";\n    }\n    cout << endl;\n  }\n  */\n\n  cout << ( dp[n][n] * fact[n] ).n << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fo(i,a,b) for (int i = (a); i < (b); i++)\n#define MOD 1000000007LL\n#define N 2002\ntypedef long long ll;\n\nint n, k;\nll dp[N][N], fct[N*N], ifct[N*N];\nll pw(ll a, int b) {\n\tif (b==0) return 1;\n\tll res = pw(a, b/2);\n\tres = (res*res)%MOD;\n\tif (b%2) res = (res*a)%MOD;\n\treturn res;\n}\nll inv(ll a) {\n\treturn pw(a, MOD-2);\n}\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\tif (k==1) puts(\"1\"), exit(0);\n\tfct[0] = 1;\n\tfo(i,1,N*N) fct[i] = (i * fct[i-1])%MOD;\n\tfo(i,0,N*N) ifct[i] = inv(fct[i]);\n\tdp[0][0] = 1;\n\tfo(i,0,n+1) fo(j,0,i+1) {\n\t\tdp[i+1][j] = (dp[i+1][j] + dp[i][j])%MOD;\n\t\tif (j < i) {\n\t\t\tint lft = n-i + (k-1)*(n - j - 1);\n\t\t\tdp[i][j+1] = (dp[i][j+1] + fct[lft + k-2] * (ifct[lft] * (ifct[k-2] * dp[i][j] % MOD)%MOD))%MOD;\n\t\t}\n\t}\n\tll ans = (dp[n][n] * fct[n])%MOD;\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int mod = 1e9 + 7;\nconst int MAXN = 2005, MAXS = MAXN * MAXN;\n\ntemplate<typename _T>\nvoid read( _T &x )\n{\n\tx = 0;char s = getchar();int f = 1;\n\twhile( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}\n\twhile( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}\n\tx *= f;\n}\n\ntemplate<typename _T>\nvoid write( _T x )\n{\n\tif( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }\n\tif( 9 < x ){ write( x / 10 ); }\n\tputchar( x % 10 + '0' );\n}\n\nint f[MAXN][MAXN];\nint fac[MAXS], ifac[MAXS];\nint N, K;\n\nint qkpow( int, int );\nint inv( const int a ) { return qkpow( a, mod - 2 ); }\nvoid sub( int &x, const int v ) { x = ( x < v ? x - v + mod : x - v ); }\nvoid add( int &x, const int v ) { x = ( x + v >= mod ? x + v - mod : x + v ); }\n\nint qkpow( int base, int indx )\n{\n\tint ret = 1;\n\twhile( indx )\n\t{\n\t\tif( indx & 1 ) ret = 1ll * ret * base % mod;\n\t\tbase = 1ll * base * base % mod, indx >>= 1;\n\t}\n\treturn ret;\n}\n\nvoid init( const int siz )\n{\n\tfac[0] = ifac[0] = 1;\n\tfor( int i = 1 ; i <= siz ; i ++ ) fac[i] = 1ll * fac[i - 1] * i % mod;\n\tifac[siz] = inv( fac[siz] );\n\tfor( int i = siz - 1 ; ~ i ; i -- ) ifac[i] = 1ll * ifac[i + 1] * ( i + 1 ) % mod;\n}\n\nint C( const int n, const int m ) { return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod; }\n\nint main()\n{\n\tread( N ), read( K );\n\tif( K == 1 ) { puts( \"1\" ); return 0; }\n\tinit( N * K );\n\tfor( int i = 0 ; i <= N ; i ++ ) f[i][0] = 1;\n\tfor( int i = 1 ; i <= N ; i ++ )\n\t\tfor( int j = 1 ; j <= i ; j ++ )\n\t\t{\n\t\t\tf[i][j] = f[i - 1][j];\n\t\t\tint t = N * K - i - ( K - 1 ) * ( j - 1 ) - 1;\n\t\t\tadd( f[i][j], 1ll * f[i][j - 1] * ( N - j + 1 ) % mod * C( t, K - 2 ) % mod );\n\t\t}\n\twrite( f[N][N] ), putchar( '\\n' );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#define ll long long\nconst int MAXN = 2010;\nconst int MOD = 1000000007;\ninline int mul(int x, int y) { return (ll)x * (ll)y % MOD; }\ninline int add(int x, int y) { int r = x + y; if(r >= MOD) r -= MOD; return r; }\ninline int fpm(int a, int p) {\n\tint ret = 1, x = a;\n\twhile(p) {\n\t\tif(p & 1) ret = mul(ret, x);\n\t\tx = mul(x, x);\n\t\tp >>= 1;\n\t}\n\treturn ret;\n}\nusing namespace std;\n\nint N, K, C[MAXN * MAXN], F[MAXN][MAXN], fact[MAXN];\n\nint main() {\n\tint i, k;\n\tscanf(\"%d%d\", &N, &K);\n\tif(K == 1) printf(\"1\\n\");\n\telse {\n\t\tfact[0] = 1; for(int i = 1; i <= N; i++) fact[i] = mul(fact[i - 1], i);\n\n\t\tC[K - 2] = 1;\n\t\tfor(i = K - 2 + 1; i <= N * K; i++) C[i] = mul(mul(C[i - 1], i), fpm(i - (K - 2), MOD - 2));\n\n\t\tF[0][0] = 1;\n\t\tfor(i = 1; i <= N; i++) {\n\t\t\tF[i][0] = mul(F[i - 1][0], C[i * (K - 1) - 1]);\n\t\t\tfor(k = 1; k <= i; k++) F[i][k] = add(F[i][k - 1], mul(F[i - 1][k], C[i * (K - 1) + k - 1]));\n\t\t}\n\n\t\tprintf(\"%d\", mul(fact[N], F[N][N]));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define MN 2000\n#define MOD 1000000007\nint F[MN+5][MN+5],f[MN*MN+5],rf[MN*MN+5];\ninline int inv(int x)\n{\n\tint y=MOD-2,r=1;\n\tfor(;y;y>>=1,x=1LL*x*x%MOD)if(y&1)r=1LL*r*x%MOD;\n\treturn r;\n}\ninline int C(int n,int m){return 1LL*f[n]*rf[m]%MOD*rf[n-m]%MOD;}\nint main()\n{\n\tint n,k,i,j;\n\tscanf(\"%d%d\",&n,&k);\n\tif(k<2)return 0*puts(\"1\");\n\tfor(f[0]=i=1;i<=n*k;++i)f[i]=1LL*f[i-1]*i%MOD;\n\tfor(rf[i=n*k]=inv(f[n*k]);i--;)rf[i]=1LL*rf[i+1]*(i+1)%MOD;\n\tfor(F[0][0]=1,i=0;i<=n;++i)for(j=0;j<=i;++j)\n\t{\n\t\tif(i<n)F[i+1][j]=(F[i+1][j]+F[i][j])%MOD;\n\t\tif(j<i)F[i][j+1]=(F[i][j+1]+1LL*F[i][j]*(n-j)%MOD*C((n-j-1)*(k-1)+n-i+k-2,k-2))%MOD;\n\t}\n\tprintf(\"%d\",F[n][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef bool boolean;\n\n#define ll long long\n\nvoid exgcd(int a, int b, int& x, int& y) {\n\tif (!b) {\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, y, x);\n\t\ty -= (a / b) * x;\n\t}\n}\n\nint inv(int a, int n) {\n\tint x, y;\n\texgcd(a, n, x, y);\n\treturn (x < 0) ? (x + n) : (x);\n}\n\nconst int Mod = 1e9 + 7;\n\ntemplate <const int Mod = :: Mod>\nclass Z {\n\tpublic:\n\t\tint v;\n\n\t\tZ() : v(0) {\t}\n\t\tZ(int x) : v(x){\t}\n\t\tZ(ll x) : v(x % Mod) {\t}\n\n\t\tZ operator + (Z b) {\n\t\t\tint x;\n\t\t\treturn Z(((x = v + b.v) >= Mod) ? (x - Mod) : (x));\n\t\t}\n\t\tZ operator - (Z b) {\n\t\t\tint x;\n\t\t\treturn Z(((x = v - b.v) < 0) ? (x + Mod) : (x));\n\t\t}\n\t\tZ operator * (Z b) {\n\t\t\treturn Z(v * 1ll * b.v);\n\t\t}\n\t\tZ operator ~() {\n\t\t\treturn inv(v, Mod);\n\t\t}\n\t\tZ operator - () {\n\t\t\treturn Z(0) - *this;\n\t\t}\n\t\tZ& operator += (Z b) {\n\t\t\treturn *this = *this + b;\n\t\t}\n\t\tZ& operator -= (Z b) {\n\t\t\treturn *this = *this - b;\n\t\t}\n\t\tZ& operator *= (Z b) {\n\t\t\treturn *this = *this * b;\n\t\t}\n};\n\nZ<> qpow(Z<> a, int p) {\n\tZ<> rt = Z<>(1), pa = a;\n\tfor ( ; p; p >>= 1, pa = pa * pa) {\n\t\tif (p & 1) {\n\t\t\trt = rt * pa;\n\t\t}\n\t}\n\treturn rt;\n}\n\ntypedef Z<> Zi;\n\nconst int N = 2005, M = N * N;\n\nint n, m;\nZi f[N][N];\nZi fac[M], _fac[M];\n\nvoid init_fac(int n) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfac[i] = fac[i - 1] * i;\n\t}\n\t_fac[n] = ~fac[n];\n\tfor (int i = n; i; i--) {\n\t\t_fac[i - 1] = _fac[i] * i;\n\t}\n}\n\nZi comb(int n, int m) {\n\treturn (n < m) ? (0) : (fac[n] * _fac[m] * _fac[n - m]);\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tif (m == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tinit_fac(n * m);\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = i; j; j--) {\n\t\t\tf[i][j] = f[i - 1][j - 1] * comb(i * m - j - 1, m - 2) + f[i][j + 1];\n\t\t}\n\t\tf[i][0] += f[i][1];\n\t}\n\tprintf(\"%d\\n\", (f[n][0] * fac[n]).v);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define db double\n\nusing namespace std;\nconst int N=2000+10,mod=1e9+7;\nint rd()\n{\n    int x=0,w=1;char ch=0;\n    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}\n    return x*w;\n}\nvoid ad(int &x,int y){x+=y,x-=x>=mod?mod:0;}\nint fpow(int a,int b){int an=1;while(b){if(b&1) an=1ll*an*a%mod;a=1ll*a*a%mod,b>>=1;}return an;}\nint ginv(int a){return fpow(a,mod-2);}\nint n,k,fac[N*N],iac[N*N],f[2][N];\nint C(int a,int b){return b<0||a<b?0:1ll*fac[a]*iac[b]%mod*iac[a-b]%mod;}\n\nint main()\n{\n\tn=rd(),k=rd();\n\tif(k==1){puts(\"1\");exit(0);}\n\tfac[0]=1;\n\tfor(int i=1;i<=n*k;++i) fac[i]=1ll*fac[i-1]*i%mod;\n\tiac[n*k]=ginv(fac[n*k]);\n\tfor(int i=n*k;i;--i) iac[i-1]=1ll*iac[i]*i%mod;\n\tint nw=1,la=0;\n\tf[la][0]=1;\n\tfor(int i=1;i<=n+n;++i)\n\t{\n\t\tfor(int j=0;j<i&&j<=n;++j)\n\t\t{\n\t\t\tif(!f[la][j]) continue;\n\t\t\tif(j<=n) ad(f[nw][j+1],1ll*f[la][j]*C(i-1+(k-2)*(j+1),k-2)%mod);\n\t\t\tif(j>=i-j) ad(f[nw][j],f[la][j]);\n\t\t\tf[la][j]=0;\n\t\t}\n\t\tnw^=1,la^=1;\n\t}\n\tprintf(\"%d\\n\",(int)(1ll*fac[n]*f[la][n]%mod));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\nconst int N = 3000;\nconst int P = 1e9 + 7;\n\nint n, k;\nint fac[N * N], inv[N * N], f[N][N];\n\nint power(int a,int b) {\n\tint res = 1;\n\twhile (b > 0) {\n\t\tif (b & 1) res = res * a % P;\n\t\ta = a * a % P, b >>= 1;\n\t}\n\treturn res;\n}\n\nint C(int n,int m) {\n\tint A = fac[n];\n\tint B = inv[n-m] * inv[m] % P;\n\treturn A * B % P;\n}\n\nsigned main(void)\n{\n\tcin >> n >> k;\n\tfac[0] = 1;\n\tfor (int i=1;i<=2100 * 2100;++i)\n\t\tfac[i] = fac[i-1] * i % P;\n\tf[0][0] = 1;\n\tint MAXN = 2000 * 2000;\n\tinv[MAXN] = power(fac[MAXN], P - 2);\n\tfor (int i=MAXN - 1;i>=0;--i) \n\t    inv[i] = inv[i+1] * (i + 1) % P;\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=0;j<=i;++j) {\n\t\t\tf[i][j] = f[i-1][j];\n\t\t\tif (j == 0) continue;\n\t\t\tf[i][j] += f[i][j-1] * (n-j+1) % P * C(n*k-i-(j-1)*(k-1)-1,k-2) % P;\n\t\t\tf[i][j] %= P;\n\t\t}\n\tcout << f[n][n] + (k == 1) << endl;\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(v) std::begin(v), std::end(v)\n#define ALLR(v) std::rbegin(v), std::rend(v)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing pll = std::pair<ll, ll>;\nusing tll = std::tuple<ll, ll, ll>;\ntemplate <typename T> using vec = std::vector<T>;\ntemplate <typename T> using vvec = vec<vec<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return vec<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\ntemplate <typename T, std::size_t Head> constexpr auto make_arr() { return std::array<T, Head>(); }\ntemplate <typename T, std::size_t Head, std::size_t Dummy, std::size_t ...Tail> constexpr auto make_arr() { return std::array<decltype(make_arr<T, Dummy, Tail...>()), Head>(); }\ntemplate <typename T, std::size_t ...Args> using mdarray = decltype(make_arr<T, Args...>());\n\n\nnamespace math {\n\ntemplate <typename T>\nconstexpr T pow(const T &n, ll k) {\n    T ret = n.mul_id_ele();\n    T cur = n;\n    while (k) {\n        if (k & 1) ret *= cur;\n        cur *= cur;\n        k /= 2;\n    }\n    return ret;\n}\n\n}\n\nnamespace math {\n\ntemplate <ll Mod>\nstruct Modint {\n\n    constexpr Modint(ll x) : x(x % Mod) { }\n    \n    constexpr Modint() : Modint(0) { }\n    \n    constexpr Modint<Mod> add_id_ele() const { \n        return Modint<Mod>(0); \n    }\n    \n    constexpr Modint<Mod> mul_id_ele() const {\n        return Modint<Mod>(1); \n    }\n    \n    constexpr ll& value() { \n        return x; \n    }\n    \n    constexpr ll value() const {\n        return x; \n    }\n\n    constexpr Modint& operator +=(const Modint &oth) {\n        x += oth.value();\n        if (Mod <= x) x -= Mod;\n        return *this;\n    }\n\n    constexpr Modint& operator -=(const Modint &oth) {\n        x += Mod - oth.value();\n        if (Mod <= x) x -= Mod;\n        return *this;\n    }\n\n    constexpr Modint& operator *=(const Modint &oth) {\n        x *= oth.value();\n        x %= Mod;\n        return *this;\n    }\n\n    constexpr Modint& operator /=(const Modint &oth) {\n        x *= oth.inv();\n        x %= Mod;\n        return *this;\n    }\n\n    constexpr Modint operator +(const Modint &oth) const {\n        return Modint(x) += oth;\n    }\n\n    constexpr Modint operator -(const Modint &oth) const {\n        return Modint(x) -= oth;\n    }\n\n    constexpr Modint operator *(const Modint &oth) const {\n        return Modint(x) *= oth;\n    }\n\n    constexpr Modint operator /(const Modint &oth) const {\n        return Modint(x) /= oth;\n    }\n\n    constexpr Modint operator -() const {\n        return Modint((x != 0) * (Mod - x)); \n    }\n\n    template <typename T>\n    constexpr typename std::enable_if<std::is_integral<T>::value, const Modint&>::type\n    operator =(T t) {\n        (*this) = Modint(std::forward<T>(t)); \n        return *this;\n    }\n\n    constexpr Modint inv() const {\n        return ::math::pow(*this, Mod - 2);\n    }\n\n    constexpr ll mod() const {\n        return Mod;\n    }\n\nprivate:\n    ll x;\n};\n\n}\n\nnamespace math {\n\ntemplate <ll Mod>\nclass Combination {\n    using mint = Modint<Mod>;\n\n    ssize_t maxv;\n    vec<mint> factv, ifactv;\n\npublic:\n    Combination(ssize_t maxv) : maxv(maxv), factv(maxv + 1), ifactv(maxv + 1) {\n        factv[0] = mint(1);\n        for (ll i = 1; i <= maxv; i++) factv[i] = factv[i - 1] * i;\n        ifactv.back() = factv.back().inv();\n        for (ll i = maxv - 1; 0 <= i; i--) ifactv[i] = ifactv[i + 1] * (i + 1);\n    }\n\n    mint fact(ll n) const {\n        return factv[n]; \n    }\n\n    mint ifact(ll n) const {\n        return ifactv[n];\n    }\n\n    mint perm(ll n, ll k) const {\n        return factv[n] * ifactv[n - k];\n    }\n\n    mint comb(ll n, ll k) const {\n        return perm(n, k) * ifactv[k];\n    }\n};\n\n}\n\nconst ll inf = 5e15;\nconst ll mod = 1e9 + 7;\nconst std::size_t SIZE = 2010;\nusing mint = math::Modint<mod>;\nmdarray<mint, SIZE, SIZE> dp;\nmdarray<bool, SIZE, SIZE> calced;\nmath::Combination<mod> co(SIZE * SIZE);\n\nll n, k;\n\nmint rec(ll i, ll j) {\n    if (calced[i][j]) return dp[i][j];\n    calced[i][j] = true;\n    ll rest = n * k - (i + (j - 1) * (k - 1));\n    if (j <= i) {\n        mint pre = rec(i, j - 1);\n        mint addv = pre * (n - (j - 1));\n        if (2 <= k) addv *= co.comb(rest - 1, k - 2);\n        dp[i][j] += addv;\n    }\n    if (j < i) {\n        mint pre = rec(i - 1, j);\n        dp[i][j] += pre;\n    }\n    return dp[i][j];\n}\n\nll solve() {\n    std::cin >> n >> k;\n    if (k == 1) return 1;\n    for (ll i = 0; i <= n; i++) {\n        dp[i][0] = 1;\n        calced[i][0] = true;\n    }\n    return rec(n, n).value();\n}\n\nint main() {\n    std::cout << solve() << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n#define per(i,r,l) for(int i=r;i>=l;--i)\n\ntypedef long long ll;\n\nconst int N=2333,NN=5e6;\nconst ll p=1e9+7;\n\nint n,k;\nll jc[NN+3],njc[NN+3],f[N][N],g[N][N];\n\nll ksm(ll x,ll w){\n\tll ans=1;\n\twhile(w){\n\t\tif(w&1ll) (ans*=x)%=p;\n\t\t(x*=x)%=p;\n\t\tw>>=1;\n\t}\n\treturn ans;\n}\n\nll C(ll a,ll b){\n\treturn jc[a]*njc[b]%p*njc[a-b]%p;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\n\tif(k==1){\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t} \n\n\tjc[0]=njc[0]=1;int L=5e6;\n\trep(i,1,L) jc[i]=(jc[i-1]*i)%p;\n\trep(i,1,L) njc[i]=ksm(jc[i],p-2);\n\n\trep(j,1,n) g[n][j]=1;f[n][n]=1;\n\tper(i,n-1,1){\n\t\trep(j,i,n)\n\t\t\tf[i][j]=(g[i+1][j]*C(n-j+(n-i+1)*(k-1)-1,k-2))%p;\n\t\tper(j,n,1) g[i][j]=g[i][j+1]+f[i][j];\n\t} \n\n\tll ans=0;\n\trep(i,1,n) (ans+=f[1][i])%=p;\n\t(ans*=jc[n])%=p;\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\nusing namespace std;\ntypedef long long LL;\nconst int maxn=2010;\nconst int maxm=maxn*maxn;\nconst int mod=1e9+7;\nLL fac[maxm],inv[maxm];\nLL Pow(LL x,LL y){\n\tLL ret=1;\n\twhile(y){\n\t\tif(y&1) ret=ret*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\nvoid init(){\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<maxm;i++) fac[i]=fac[i-1]*i%mod;\n\tinv[maxm-1]=Pow(fac[maxm-1],mod-2);\n\tfor(int i=maxm-2;i>=1;i--) inv[i]=inv[i+1]*(i+1)%mod;\n\t//for(int i=1;i<=10;i++) printf(\"%lld \", fac[i]);puts(\"\");\n\t//printf(\"%lld\\n\", fac[100]*inv[100]%mod );\n}\nLL dp[maxn][maxn];\nint n,k;\nLL C(int n, int m){\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main(){\n\tinit();\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1){\n\t\tputs(\"1\");return 0;\n\t}\n\tdp[0][0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=i;j<=n;j++){\n\t\t\t(dp[i+1][j]+=dp[i][j])%=mod;\n\t\t\t(dp[i][j+1]+=dp[i][j]*C(i+(j+1)*(k-1)-1,k-2))%=mod;\n\t\t}\n\t}\n\tprintf(\"%lld\",dp[n][n]*fac[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace modular_space {\n\tlong long mod;\n\tstruct umod {\n\t\tlong long val;\n\t\tumod(): val(0ll){}\n\t\tumod(long long x){ x %= mod; if(x < 0) x += mod; val = x; }\n\t\tumod& operator += (umod oth){ val += oth.val; if(val >= mod) val -= mod; return *this; }\n\t\tumod& operator -= (umod oth){ val -= oth.val; if(val < 0) val += mod; return *this; }\n\t\tumod& operator *= (umod oth){ val = val * oth.val % mod; return *this; }\n\t\tumod& operator /= (umod oth){ return *this *= oth.inverse(); }\n\t\tumod& operator ^= (long long oth){ return *this = pwr(*this, oth); }\n\t\tumod operator + (umod oth) const { return umod(*this) += oth; }\n\t       \tumod operator - (umod oth) const { return umod(*this) -= oth; }\n\t\tumod operator * (umod oth) const { return umod(*this) *= oth; }\n\t\tumod operator / (umod oth) const { return umod(*this) /= oth; }\n\t\tumod operator ^ (long long oth) const { return umod(*this) ^= oth; }\n\t\tbool operator < (umod oth) const { return val < oth.val; }\n\t\tbool operator > (umod oth) const { return val > oth.val; }\n\t\tbool operator <= (umod oth) const { return val <= oth.val; }\n\t\tbool operator >= (umod oth) const { return val >= oth.val; }\n\t\tbool operator == (umod oth) const { return val == oth.val; }\n\t\tbool operator != (umod oth) const { return val != oth.val; }\n\t\tumod pwr(umod a, long long b) const {\n\t\t\tumod r = 1;\n\t\t\tfor(; b; a *= a, b >>= 1)\n\t\t\t\tif(b&1)\n\t\t\t\t\tr *= a;\n\t\t\treturn r;\n\t\t}\n\t\tumod inverse() const {\n\t\t\tlong long a = val, b = mod, u = 1, v = 0;\n\t\t\twhile(b){\n\t\t\t\tlong long t = a/b;\n\t\t\t\ta -= t * b; swap(a, b);\n\t\t\t\tu -= t * v; swap(u, v);\n\t\t\t}\n\t\t\tif(u < 0)\n\t\t\t\tu += mod;\n\t\t\treturn u;\n\t\t}\n\t\tfriend istream& operator >> (istream &is, umod &oth);\n\t\tfriend ostream& operator << (ostream &os, const umod& oth);\n\t};\n\tostream& operator << (ostream &os, const umod &oth){\n\t\tos << oth.val;\n\t\treturn os;\n\t}\n\tistream& operator >> (istream &is, umod &oth){\n\t\tlong long x; is >> x;\n\t\toth = umod(x);\n\t\treturn is;\n\t}\n\tstruct binprime_kit {\n\t\tint sz;\n\t\tvector<umod> fat, ifat;\n\t\tvoid init(int s){\n\t\t\tsz = s;\n\t\t\tfat.resize(sz + 1);\n\t\t\tifat.resize(sz + 1);\n\t\t\tfat[0] = 1;\n\t\t\tfor(int i = 1; i <= sz; i++) fat[i] = fat[i - 1] * i;\n\t\t\tifat[sz] = fat[sz] ^ (mod - 2);\n\t\t\tfor(int i = sz - 1; i >= 0; i--) ifat[i] = ifat[i + 1] * (i + 1);\n\t\t}\n\t\tumod coef(int n, int r){\n\t\t\tif(n < r) return 0;\n\t\t\treturn fat[n] * (ifat[r] * ifat[n - r]);\n\t\t}\n\t};\n};\nusing U = modular_space::umod;\nconst int maxn = 2020;\nU f[maxn][maxn];\nint main(){\n\tmodular_space::mod = 1'000'000'007;\n\tmodular_space::binprime_kit kit; kit.init(maxn * maxn);\n\tint n, k; cin >> n >> k;\n\tif(k == 1) cout << 1 << endl;\n\telse {\n\t\tf[0][0] = 1;\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tfor(int j = 0; j <= i; j++){\n\t\t\t\tint empty = n - i + (n - j) * (k - 1) - 2;\n\t\t\t\tif(f[i][j].val){\n\t\t\t\t\tf[i + (i == j)][j + 1] += f[i][j] * kit.coef(empty, k - 2);\n\t\t\t\t\tf[i + 1][j] += f[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << f[n][n] * kit.fat[n] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline int read(){\n\tint ans=0,w=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar();\n\treturn ans*w;\n}\nconst int N=2005,Maxn=2000*2000+1e5+5,mod=1e9+7;\nint n,k,f[N][N],fac[Maxn],ifac[Maxn];\ninline int C(int n,int m){return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;}\nint main(){\n\tn=read(),k=read(),ifac[0]=fac[0]=fac[1]=ifac[1]=1;\n\tif(k==1)return puts(\"1\"),0;\n\tfor(int i=2;i<=Maxn-5;++i)fac[i]=1ll*fac[i-1]*i%mod,ifac[i]=1ll*(mod-mod/i)*ifac[mod%i]%mod;\n\tfor(int i=2;i<=Maxn-5;++i)ifac[i]=1ll*ifac[i]*ifac[i-1]%mod;\n\tf[1][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<=i;++j){\n\t\t\tif(i^j)(f[i][j+1]+=f[i][j]%=mod);\n\t\t\tif(i^n)(f[i+1][j]+=1ll*f[i][j]*C((k-2)+(i*(k-1)+j),k-2)%mod)%=mod;\n\t\t}\n\tcout<<1ll*f[n][n]*fac[n]%mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\n#define MOD 1000000007\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int MAXN = 2000 + 10;\nconst int MAXM = 4e06 + 10;\n\nint N, K;\n\nLL fact[MAXM]= {0}, invfact[MAXM]= {0};\nvoid init () {\n\tfact[0] = fact[1] = invfact[0] = invfact[1] = 1;\n\tfor (int i = 2; i <= N * K; i ++) {\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\tinvfact[i] = (MOD - MOD / i) * invfact[MOD % i] % MOD;\n\t}\n\tfor (int i = 1; i <= N * K; i ++)\n\t\tinvfact[i] = invfact[i - 1] * invfact[i] % MOD;\n}\ninline LL C (int n, int m) {\n\tif (n < m) return 0;\n\tif (m == 0) return 1;\n\treturn fact[n] * invfact[m] % MOD * invfact[n - m] % MOD;\n}\n\nLL f[MAXN][MAXN]= {0};\n\nint main () {\n\tscanf (\"%d%d\", & N, & K);\n\tif (K == 1) {\n\t\tputs (\"1\");\n\t\treturn 0;\n\t}\n\tinit ();\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= N; i ++)\n\t\tfor (int j = 0; j <= i; j ++) {\n\t\t\tLL delta = f[i][j - 1] * (N - j + 1) % MOD * C (N * K - i - (K - 1) * (j - 1) - 1, K - 2) % MOD;\n\t\t\tif (j == 0) delta = 0;\n\t\t\tf[i][j] = (f[i][j] + f[i - 1][j] + delta) % MOD;\n\t\t}\n\tcout << f[N][N] << endl;\n\n\treturn 0;\n}\n\n/*\n2 2\n*/\n\n/*\n3 1\n*/\n\n/*\n2 3\n*/\n\n/*\n2000 2000\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nconst int MAXN = 2010, MOD = 1e9 + 7;\n\nint f[MAXN * MAXN], dp[MAXN][MAXN], fm1[MAXN * MAXN];\n\ninline int add(int x, int y){\n\treturn (x + y) % MOD;\n}\n\ninline int mul(int x, int y){\n\treturn (x * y) % MOD;\n}\n\nint p(int x, int y){\n\t//cerr << x << endl;\n\tif(y == 0)\n\t\treturn 1;\n\tif(y == 1)\n\t\treturn x;\n\tint f = p(x, y / 2);\n\tif(y % 2 == 0)\n\t\treturn mul(f, f);\n\telse\n\t\treturn mul(mul(f, f), x);\n}\n\nint c(int x, int y){\n\treturn mul(f[y], mul(fm1[x], fm1[y - x]));\n}\n\nint32_t main(){\n\tint n, k;\n\tcin >> n >> k;\n\tif(k == 1){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tf[1] = 1, fm1[1] = 1, f[0] = 1, fm1[0] = 1;\n\tfor(int i = 2; i < MAXN * MAXN; i++){\n\t\t//cerr << i << endl;\n\t\tf[i] = mul(i, f[i - 1]);\n\t\tfm1[i] = p(f[i], MOD - 2);\n\t}\n\t//cerr << c(2, 2) << endl;\n\tdp[0][0] = 1;\n\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\t//cerr << j << \"    \" << c(k - 2, i + j * (k - 1) - 1) << \"     \" << dp[i][j - 1] << endl;\n\t\t\tif(i > 0)\n\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\tif(j > i && k > 1)\n\t\t\t\tdp[i][j] = add(dp[i][j], mul(dp[i][j - 1], c(k - 2, i + j * (k - 1) - 1)) );\n\t\t\t//cerr << j << endl;\n\t\t\t//cerr << dp[i][j] << endl;\n\t\t}\n\t}\n\tcout << mul(dp[n][n], f[n]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(ll x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 2010;\nconst int mod = 1e9+7;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,k;\n\nint f[maxn][maxn];\n\nint fac[maxn*maxn],inv[maxn*maxn];\n\nint Cnk(int n,int k){\n\treturn 1LL*fac[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nvoid Work(){\n\tif(k==1)return void(puts(\"1\"));\n\tf[n+1][n+1]=1;\n\tRREP(i,n+1,1)\n\t\tRREP(j,n,1)if(i>=j){\n\t\t\tif(i<=n)f[i][j]=f[i+1][j];\n\t\t\tif(i>j)f[i][j]=(f[i][j]+1LL*f[i][j+1]*Cnk(n-i+(n-j+1)*(k-1),k-2))%mod;\n\t\t\t//cout<<i<<' '<<j<<' '<<f[i][j]<<endl;\n\t\t}\n\tREP(i,1,n)f[1][1]=1LL*f[1][1]*i%mod;\n\tiout(f[1][1]);\n}\n\nvoid Init(){\n\tread(n,k);\n\tfac[0]=1;REP(i,1,n*k)fac[i]=1LL*fac[i-1]*i%mod;\n\tREP(i,0,n*k)inv[i]=fexp(fac[i],mod-2);\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\n#define go(u) for(int i = head[u], v = e[i].to; i; i=e[i].lst, v=e[i].to)\n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define pb push_back\n#define re(x) memset(x, 0, sizeof x)\ninline int gi() {\n    int x = 0,f = 1;\n    char ch = getchar();\n    while(!isdigit(ch)) { if(ch == '-') f = -1; ch = getchar();}\n    while(isdigit(ch)) { x = (x << 3) + (x << 1) + ch - 48; ch = getchar();}\n    return x * f;\n}\ntemplate <typename T> inline bool Max(T &a, T b){return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline bool Min(T &a, T b){return a > b ? a = b, 1 : 0;}\nconst int N = 2007, mod = 1e9 + 7;\nint n, k;\nint fac[N * N], invfac[N * N], inv[N * N], f[N][N];\nint C(int n, int m) {\n\treturn (LL) fac[n] * invfac[n - m] % mod * invfac[m] % mod;\n}\nvoid add(int &a, int b) { a += b; if(a >= mod) a -= mod;}\nint main() {\n#ifndef ONLINE_JUDGE\n#endif\n\tn = gi(), k = gi();\n\tif(k == 1) return puts(\"1\"), 0;\n\tinv[1] = fac[0] = invfac[0] = 1;\n\trep(i, 1, n * k) {\n\t\tif(i ^ 1) inv[i] = (LL) (mod - mod / i) * inv[mod % i] % mod;\n\t\tfac[i] = (LL) fac[i - 1] * i % mod;\n\t\tinvfac[i] = (LL) invfac[i - 1] * inv[i] % mod;\n\t}\n\trep(i, 1, n) {\n\t\tf[i][0] = 1;\n\t\trep(j, 1, i) {\n\t\t\tadd(f[i][j] ,f[i - 1][j]);\n\t\t\tadd(f[i][j], (LL) f[i][j - 1] * C((n - i) + (n - j + 1) * (k - 1) - 1, k - 2) % mod * (n - j + 1) % mod);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,k;\nlong long f[2005][2005]={{1}},fac[4000005]={1},inv_fac[4000005];\ninline long long C(int n,int m)\n{\n    return(((fac[m]*inv_fac[n])%10000007)*inv_fac[m-n])%10000007;\n}\nlong long power(long long x,int P)\n{\n    long long ans=1,m=x;\n    while(P)ans=ans*(P&1?m:1)%10000007,P>>=1,m=m*m%10000007;\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    if(k==1){printf(\"%d\\n\",1);return 0;}\n    for(register int i=1;i<=4000000;++i)fac[i]=(fac[i-1]*i)%10000007;\n    inv_fac[4000000]=power(fac[4000000],10000007-2);\n\tfor(register int i=3999999;i>=0;--i)inv_fac[i]=(inv_fac[i+1]*(i+1))%10000007;\n    for(register int i=1;i<=n;++i)\n        for(register int j=0;j<=i;++j)\n\t\t{\n            f[i][j]=f[i-1][j];\n            if(j)(f[i][j]+=f[i][j-1]*(n-j+1)%10000007*C(k-2,n-i+(n-j+1)*(k-1)-1)%10000007)%=10000007;\n        }\n    printf(\"%lld\\n\",f[n][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(x) ((int) ((x).size()))\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll mod = 1000000000 + 7;\n\nint n, k;\nll p[5000000], pinv[5000000], inv[5000000], dp[3000];\n\nll binom(int n, int k) {\n  return (((p[n] * pinv[n - k]) % mod) * pinv[k]) % mod;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  cin >> n >> k;\n\tp[0] = p[1] = pinv[0] = pinv[1] = inv[1] = 1;\n\tfor (int i = 2; i <= n * k; i++)\n\t\tinv[i] = (mod - (mod / i) * inv[mod % i] % mod) % mod, p[i] = (p[i - 1] * i) % mod, pinv[i] = (pinv[i - 1] * inv[i]) % mod;\n  if (k == 1) {\n    cout << \"1\\n\";\n    return 0;\n  }\n  dp[0] = 1;\n  for (int i = 0; i < n; i++) {\n    for (int j = i; j >= 0; j--)\n      dp[j + 1] = (dp[j + 2] + dp[j] * binom(i * k - j + k - 2, k - 2)) % mod;\n    dp[0] = dp[1];\n    // for (int j = 0; j <= i + 1; j++)\n    //   cerr << dp[j] << (j < i + 1 ? \" \" : \"\\n\");\n  }\n  cout << (dp[0] * p[n]) % mod << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "//Created Time:2019年12月23日 星期一 15时39分53秒\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#define N 2005\n#define mod 1000000007\n\nusing namespace std;\n\nint n, k;\nint f[N][N], fac[N * N], ifac[N * N], inv[N * N];\n\nint C(int ,int);\n\nint main(){\n\tcin >> n >> k; fac[0] = ifac[0] = inv[1] = 1;\n\tif (k == 1) { puts(\"1\"); return 0;}\n\tfor (int i = 2; i <= n * k; ++i) inv[i] = mod - 1ll * mod / i * inv[mod % i] % mod;\n\tfor (int i = 1; i <= n * k; ++i) fac[i] = 1ll * fac[i - 1] * i % mod, ifac[i] = 1ll * ifac[i - 1] * inv[i] % mod;\n\tf[0][0] = 1; //f[i][j] 放了i个白色球和j种颜色球的方案\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tf[i][j] = f[i - 1][j];\n\t\t\tif(j) (f[i][j] += 1ll * C(n - i + (n - j + 1) * (k - 1) - 1, k - 2) * f[i][j - 1] % mod * (n - j + 1) % mod) %= mod;\n\t\t}\n\tcout << f[n][n] << endl;\n\treturn 0;\n}\n\nint C(int x, int y){\n\treturn 1ll * fac[x] * ifac[y] % mod * ifac[x - y] % mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Mod = 1e9 + 7, Nmax = 2005;\ntypedef long long ll;\n\nnamespace\n{\n    void inm_to(int &x, int y) { x = (ll) x * y % Mod; }\n    int inm(int x, int y) { return (ll) x * y % Mod; }\n    int inm(int x, int y, int z) { return (ll) x * y % Mod * z % Mod; }\n    void add_to(int &x, int y) { x+=y; if(x>=Mod) x-=Mod; }\n    int add(int x, int y) { x+=y; return x<Mod ? x : x-Mod; }\n\n    int power(int a, int b)\n    {\n        int ans = 1;\n        while(b)\n        {\n            if(b&1) inm_to(ans, a);\n            inm_to(a, a); b >>= 1;\n        }\n        return ans;\n    }\n}\n\nint N, K;\nint fact[2*Nmax*Nmax], ifact[2*Nmax*Nmax], dp[Nmax][Nmax];\n\nint comb(int n, int k)\n{\n    return inm(fact[n], ifact[k], ifact[n-k]);\n}\n\nint aranj(int n, int m)\n{\n    /// comb(n+m, n)\n    return comb(n+m, n);\n}\n\nvoid prec(int lim)\n{\n    int i;\n    fact[0] = ifact[0] = 1;\n\n    for(i=1; i<=lim; ++i) fact[i] = inm(fact[i-1], i);\n    ifact[lim] = power(fact[lim], Mod-2);\n    for(i=lim-1; i; --i) ifact[i] = inm(ifact[i+1], i+1);\n}\n\nint main()\n{\n   // freopen(\"input\", \"r\", stdin);\n   // freopen(\"output\", \"w\", stdout);\n    cin.sync_with_stdio(false);\n\n    int i, j;\n    cin >> N >> K;\n\n    if(K == 1)\n    {\n        cout << 1 << '\\n';\n        return 0;\n    }\n\n    prec(2 * N * K);\n\n    dp[0][0] = 1;\n\n    for(i=0; i<=N; ++i)\n        for(j=0; i+j<=N; ++j)\n            if(i + j)\n            {\n                if(j) dp[i][j] = inm(dp[i][j-1], i+j, aranj(K-2, i * K + (j-1) * (K-1)));\n                if(i) add_to(dp[i][j], dp[i-1][j+1]);\n            }\n\n    cout << dp[N][0] << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\ntypedef long long ll;\nconst int mod=1000000007;\nint N,K,f[2010][2010];\nll fac[4000010],ifac[4000010];\nll inv(int a,int p=mod){return a==1?1:(1+p*(a-inv(p%a,a)))/a%p;}\nll C(int n,int m){return n>=0&&m<=n?fac[n]*ifac[m]%mod*ifac[n-m]%mod:0;}\nint main(){\n\tscanf(\"%d%d\",&N,&K);\n\tif(K==1)puts(\"1\");\n\telse{\n\t\tfor(int i=*fac=1;i<=N*K;i++)fac[i]=fac[i-1]*i%mod;\n\t\tifac[N*K]=inv(fac[N*K]);\n\t\tfor(int i=N*K;i;i--)ifac[i-1]=ifac[i]*i%mod;\n\t\tf[1][0]=f[1][1]=1;\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tfor(int j=N;j;j--)\n\t\t\t\tf[i][j]=(f[i][j+1]+f[i-1][j-1]*C(i*K-j-1,K-2))%mod;\n\t\t\tf[i][0]=f[i][1];\n\t\t}\n\t\tint ans=f[N][0]*fac[N]%mod;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ; \n#define int long long \nconst int MAXN = 2000 + 10 , MOD = 1e9+7 ; \n\nint n , k , dp[MAXN][MAXN] , fact[MAXN*MAXN] ,inv[MAXN*MAXN];\n\nint pw(int a , int b)\n{\n\tif(!b)\n\t\treturn 1 ; \n\tint res = pw(a , b/2) ; \n\tres*=res ;\n\tres%=MOD ; \n\tif(b%2)\n\t\tres*=a ; \n\treturn res%MOD ;  \n}\n\nint C(int a , int b)\n{\n\tif(b>a)\t\n\t\treturn 0 ; \n\treturn ( (fact[a] * inv[b])%MOD ) *inv[a-b] %MOD ; \n}\n\n\nint32_t main()\n{\n\tcin >> n >> k ; \n\tif(k==1)\n\t\treturn cout << 1 , 0 ; \n\tfact[0]=1 ; \n\tfor(int i=1 ; i<MAXN*MAXN ; i++)\n\t\tfact[i] = fact[i-1]*i %MOD ; \n\tfor(int i=0 ; i<MAXN*MAXN ; i++)\n\t\tinv[i] = pw(fact[i] , MOD-2) ;\n\tdp[n][n] = 1 ; \n\tfor(int i=n ; i>=0 ; i--)\n\t{\n\t\tfor(int j=n ; j>=i ; j--)\n\t\t{\n\t\t\tif(i) \n\t\t\t\tdp[i-1][j]=(dp[i-1][j] + dp[i][j])%MOD;\n\t\t\tif(j>i) \n\t\t\t\tdp[i][j-1]= (dp[i][j-1] + dp[i][j]*(C(i+j*(k-1)-1,k-2))%MOD)%MOD;\n\t\t}\n\t}\n\tcout << (dp[0][0]*fact[n])%MOD << endl ; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=2e3+10,mod=1e9+7;\ninline int ksm(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=(ll)res*x%mod;\n\t\tx=(ll)x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint dp[maxn][maxn],fac[maxn*maxn],ifac[maxn*maxn];\ninline int C(int n,int m){\n\treturn (ll)fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\ninline void init(int n){\n\tfac[0]=1;\n\tREP(i,1,n) fac[i]=(ll)i*fac[i-1]%mod;\n\tifac[n]=ksm(fac[n],mod-2);\n\tDREP(i,n,1) ifac[i-1]=(ll)i*ifac[i]%mod;\n}\nint main(){\n\tint n=read(),k=read();\n\tif(k==1){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tinit(n*k);\n\tdp[0][0]=1;\n\tREP(i,1,n) REP(j,0,i){\n\t\tdp[i][j]=dp[i-1][j];\n\t\tif(j) dp[i][j]=(dp[i][j]+(ll)dp[i][j-1]*(n-j+1)%mod*C(n*k-i-(j-1)*(k-1)-1,k-2))%mod;\n\t}\n\tprintf(\"%d\\n\",dp[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mod 1000000007\n#define maxn 2005\n#define ll long long\n\nusing namespace std;\n\nll silnia[maxn*maxn];\nll dp[maxn][maxn];\n\n\nvoid licz(int zosia)\n{\n\tsilnia[0]=1;\n\tfor(int i=1; i<=zosia; ++i)\n\t{\n\t\tll a=i;\n\t\tsilnia[i]=(silnia[i-1]*a)%mod;\n\t}\n}\n\nll qpow(ll zosia, int n)\n{\n\tll wynik=1;\n\twhile(n!=0)\n\t{\n\t\tif(n%2==1)\n\t\t\twynik=(wynik*zosia)%mod;\n\t\tzosia=(zosia*zosia)%mod;\n\t\tn/=2;\n\t}\n\treturn wynik;\n}\n\nll dwumian(int slonko, int misiu)\n{\n\tll c=(silnia[slonko-misiu]*silnia[misiu])%mod;\n\t//cout << c << endl;\n\treturn (silnia[slonko]*qpow(c,mod-2))%mod;\n}\n\nint main()\n{\n\t//cout << dwumian(2,0) << endl;\n\tll n,k;\n\tscanf(\"%lld%lld\", &n, &k);\n\t\n\tif(k==1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tlicz(n*n);\n\t//cout << dwumian(2,0) << endl;\n\t\n\tdp[0][0]=1;\n\tfor(int i=1; i<=n; ++i)\n\t{\n\t\tfor(int j=0; j<=i; ++j)\n\t\t{\n\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\tif(j!=0)\n\t\t\t\tdp[i][j]=(dp[i][j]+(dwumian(i+j*(k-1),k-2)*dp[i][j-1])%mod)%mod;\n\t\t\t//cout << i << \" \" << j << dp[i][j] << endl;\n\t\t}\n\t}\n\tprintf(\"%lld\", (dp[n][n]*silnia[n])%mod);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include <bits/stdc++.h>\n#define loop(i,n) for(int i = 0;i < (n);i++)\n#define range(i,a,b) for(int i = (a);i <= (b);i++)\n#define all(A) A.begin(),A.end()\n#define pb push_back\n#define mp make_pair\n#define sz(A) ((int)A.size())\n#define vi vector<int>\n#define vl vector<long long>\n#define vd vector<double>\n#define vp vector<pair<int,int> >\n#define ll long long\n#define pi pair<int,int>\n#define popcnt(x) __builtin_popcountll(x)\n#define LSOne(x) ((x) & (-(x)))\n#define xx first\n#define yy second\n#define PQ priority_queue\n#define print(A,t) cerr << #A << \": \"; copy(all(A),ostream_iterator<t>(cerr,\" \" )); cerr << endl\n#define prp(p) cerr << \"(\" << (p).first << \" ,\" << (p).second << \")\";\n#define prArr(A,n,t)  cerr << #A << \": \"; copy(A,A + n,ostream_iterator<t>(cerr,\" \" )); cerr << endl\n#define PRESTDIO() cin.tie(0),cerr.tie(0),ios_base::sync_with_stdio(0)\n#define what_is(x) cerr << #x << \" is \" << x << endl\n#define bit_lg(x) (assert(x > 0),__builtin_ffsll(x) - 1)\nconst double PI = acos(-1);\nusing namespace std;\n\nconst int MAX = 2000 + 10,MAXF = 2000*2000 + 10;\nconst int mod = 1e9 + 7;\nint fact[MAXF],rev[MAXF];\nint dp[MAX][MAX];\n\ninline int add(int a,int b) {\n\ta += b;\n\tif(a >= mod) a -= mod;\n\treturn a;\n}\ninline int mul(int a,int b) {return (a*1LL*b)%mod;}\ninline int powmod(int a,int p) {\n\tif(p <= 0) return 1;\n\tint b = 1;\n\tfor(;p > 1;p >>= 1) {\n\t\tif(p&1) b = mul(a,b);\n\t\ta = mul(a,a);\n\t}\n\treturn mul(a,b);\n}\n\nvoid init(){\n\tfact[0] = rev[0] = 1;\n\tfor(int i = 1;i < MAXF;i++) {\n\t\tfact[i] = mul(fact[i - 1],i);\n\t\trev[i] = powmod(fact[i],mod-2);\n\t}\n}\n\nint C(int n,int k) {\n\tif(k > n) return 0;\n\tint ret = fact[n];\n\tret = mul(ret,rev[k]);\n\tret = mul(ret,rev[n - k]);\n\treturn ret;\n}\n\nint main(){\n\t#ifdef HOME\n\t\tfreopen(\"in.in\", \"r\", stdin);\n\t#endif\n\tinit();\n\tint N,K;\n\tcin >> N >> K;\n\tif(K == 1) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n    for (int r1 = N+1;r1 >= 1;r1--)\n        for (int r2 = N+1;r2 >= 1;r2--) {\n            if(r1 == N+1 && r2 == N+1) dp[r1][r2] = 1;\n            else if(r2 > r1) dp[r1][r2] = 0;\n            else {\n                int ret = 0;\n                if(r1 <= N) ret = dp[r1+1][r2];\n                if(r2 < r1) ret = add(ret,mul(dp[r1][r2+1],C(N*K-(r1-1)-(r2-1)*(K-1)-1,K-2)));\n                dp[r1][r2] = ret;\n            }\n        }\n    int ans = mul(dp[1][1],fact[N]);\n    cout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Zory-2019\n#include<cmath>\n#include<ctime>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<set>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<bitset>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<deque>\n// #include<unordered_map>\nusing namespace std;\nint bin[40],lg[1<<21];\nnamespace mine\n{\n\ttypedef long long ll;\n\t#define double long double\n\tconst int INF=0x3f3f3f3f;\n\tconst ll LLINF=0x3f3f3f3f3f3f3f3fll;\n\tll qread()\n\t{\n\t\tll ans=0;char c=getchar();int f=1;\n\t\twhile(c<'0' or c>'9') {if(c=='-') f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num)\n\t{\n\t\tif(num<0) {num=-num;putchar('-');}\n\t\tif(num>9) write(num/10);\n\t\tputchar('0'+num%10);\n\t}\n\tvoid writeln(int num){write(num);puts(\"\");}\n\t#define FR first\n\t#define SE second\n\t#define MP make_pair\n\t#define pr pair<int,int>\n\t#define PB push_back\n\t#define vc vector\n\tvoid chmax(int &x,const int y) {x=x>y?x:y;}\n\tvoid chmin(int &x,const int y) {x=x<y?x:y;}\n\tconst int MAX_N=2e3+10;\n\tconst int MOD=1e9+7;\n\tvoid add(int &x,int y) {x+=y;if(x>=MOD) x-=MOD;if(x<0) x+=MOD;}\n\n\tconst int MAX_M=MAX_N*MAX_N;\n\tint fac[MAX_M],inv[MAX_M],facinv[MAX_M];\n\tint C(int n,int m) {if(n<m) return 0;return (ll)fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tint f[MAX_N][MAX_N];\n\tvoid main()\n\t{\n\t\tinv[1]=1;for(int i=2;i<MAX_M;i++) inv[i]=ll(MOD-MOD/i)*inv[MOD%i]%MOD;\n\t\tfac[0]=1;for(int i=1;i<MAX_M;i++) fac[i]=(ll)fac[i-1]*i%MOD;\n\t\tfacinv[0]=1;for(int i=1;i<MAX_M;i++) facinv[i]=(ll)facinv[i-1]*inv[i]%MOD;\n\n\t\tint n=qread(),k=qread();\n\t\tif(k==1) {puts(\"1\");return;}\n\t\tf[0][0]=1;\n\t\tfor(int i=1;i<=n;i++) for(int j=0;j<=i;j++)\n\t\t{\n\t\t\tif(i>0) add(f[i][j],f[i-1][j]);\n\t\t\tif(j>0) add(f[i][j],(ll)f[i][j-1]*(n-j+1)%MOD*C(n-i+(k-1)*(n-j+1)-1,k-2)%MOD );\n\t\t\t// printf(\"f[%d][%d]=%d\\n\",i,j,f[i][j]);\n\t\t}\n\t\tprintf(\"%d\",f[n][n]);\n\t}\n};\nint main()\n{\n\tsrand(time(0));\n\tbin[0]=1;for(int i=1;i<=30;i++) bin[i]=bin[i-1]<<1;\n\tlg[1]=0;for(int i=2;i<(1<<21);i++) lg[i]=lg[i>>1]+1;\n\tmine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nID: bqi3431\nPROG: ~\nLANG: C++11 \n*/\n\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); } \n    // inv is equivalent to return exp(b,b.mod-2) if prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\n\ntemplate<int SZ> struct Combo {\n    mi smallInv[SZ], fac[SZ], ifac[SZ]; \n    vpi factors;\n\n    void genInv() {\n        if (sz(factors) == 1 && factors[0].s == 1) {\n            F0R(i,2) smallInv[i] = i;\n            FOR(i,2,SZ) { // use only O(SZ) operations for MOD a prime\n                int x = (MOD+i-1)/i;\n                smallInv[i] = smallInv[i*x-MOD]*x;\n            }\n        } else {\n            F0R(i,SZ) {\n                int x = invGeneral(i,MOD);\n                if (x == -1) smallInv[i] = 0;\n                else smallInv[i] = x;\n            }\n        }\n    }\n    \n    void init() {\n        // factors = factor(MOD); \n        factors = {{MOD,1}}; \n        genInv(); fac[0] = ifac[0] = 1;\n        FOR(i,1,SZ) {\n            /*cnt[i] = cnt[i-1]; int I = i;\n            F0R(j,sz(factors)) while (I % factors[j].f == 0)\n                I /= factors[j].f, cnt[i][j] ++;*/\n            fac[i] = fac[i-1]*i; ifac[i] = ifac[i-1]*smallInv[i];\n        }\n    }\n\n    mi comb(int a, int b) {\n        if (a < b || b < 0) return 0;\n        auto tmp = fac[a]*ifac[b]*ifac[a-b];\n        /*F0R(i,sz(factors)) {\n            int t = cnt[a][i]-cnt[a-b][i]-cnt[b][i];\n            tmp *= exp(mi(factors[i].f),t);\n        }*/\n        return tmp;\n    }\n};\n\nCombo<4000005> C;\nint N,K;\nmi dp[2001][2001];\n\nint main() {\n    setIO(); re(N,K); C.init();\n    if (K == 1) {\n        ps(1);\n        exit(0);\n    }\n    F0Rd(i,N+1) F0Rd(j,i+1) {\n        if (i == N && j == N) { dp[i][j] = 1; continue; }\n        if (i < N) dp[i][j] = dp[i+1][j];\n        if (j < i) dp[i][j] += C.comb(N-i+(N-(j+1))*(K-1)+K-2,K-2)*dp[i][j+1]; // N-i, (N-(j+1))*(K-1)\n    }\n    ps(dp[0][0]*C.fac[N]);\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int N = 2000 + 10;\nconstexpr int MOD = 1e9 + 7;\n\nlong long dp[N][N], fact[N * N], n, k;\n\nlong long mypow (long long a, long long b) {\n    return b ? (mypow (a * a % MOD, b >> 1) * (b & 1 ? a : 1)) % MOD : 1;\n}\n\nlong long ch (long long a, long long b) {\n    return (fact[a] * mypow (fact[b] * fact[a - b] % MOD, MOD - 2)) % MOD;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> k;\n    if (k == 1) {\n        cout << 1 << '\\n';\n        return 0;\n    }\n    fact[0] = 1;\n    for (int i = 1; i < N * N; i++)\n        fact[i] = (fact[i - 1] * i) % MOD;\n    for (int i = 0; i <= n; i++) {\n        for (int j = i; j <= n; j++) {\n            if (i == 0) {\n                if (j == 0)\n                    dp[i][j] = 1;\n                else {\n                    dp[i][j] = ch (j * (k - 1) - 1, k - 2) * dp[i][j - 1];\n                    dp[i][j] %= MOD;\n                }\n                continue;\n            }\n            dp[i][j] = dp[i - 1][j] + ch (i + j * (k - 1) - 1, k - 2) * dp[i][j - 1];\n            dp[i][j] %= MOD;\n        }\n    }\n    cout << (dp[n][n] * fact[n]) % MOD << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=2010,p=1e9+7;\nint inc(int x,int y){x+=y;return x>=p?x-p:x;}\nint mul(int x,int y){return (ll)x*y%p;}\nint power(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=mul(x,x))\n\t\tif (y&1) ans=mul(ans,x);\n\treturn ans;\n}\nint n,k,dp[N][N],fac[N*N],ifac[N*N];\nint C(int n,int m){\n\treturn mul(fac[n],mul(ifac[m],ifac[n-m]));\n}\nint main()\n{\n\tcin>>n>>k;\n\tif (k==1) return puts(\"1\"),0;\n\tfac[0]=1;\n\tfor (int i=1;i<=n*n;i++) fac[i]=mul(fac[i-1],i);\n\tifac[n*n]=power(fac[n*n],p-2);\n\tfor (int i=n*n;i;i--) ifac[i-1]=mul(ifac[i],i);\n\tdp[0][0]=1;\n\tfor (int i=0;i<=n;i++)\n\tfor (int j=0;j<=n;j++){\n\t\tif (i) dp[i][j]=inc(dp[i][j],dp[i-1][j]);\n\t\tif (i!=j&&j) dp[i][j]=inc(dp[i][j],mul(dp[i][j-1],C(i+j*(k-1)-1,k-2)));\n\t}\n\tprintf(\"%d\\n\",mul(fac[n],dp[n][n]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, j, k) for(int i = j; i <= k; ++i)\n#define dep(i, j, k) for(int i = j; i >= k; --i)\n#define inv(x) (ksm(x, P - 2))\n\nusing namespace std;\n\nconst int maxn = 4e6 + 5;\nconst int P = 1e9 + 7;\n\nint n, k, f[2005][2005], fac[maxn], ifac[maxn];\n\ninline int read() {\n\tchar ch = getchar(); int u = 0, f = 1;\n\twhile(!isdigit(ch)) { if(ch == '-') f = -1; ch = getchar(); }\n\twhile(isdigit(ch))  { u = u * 10 + ch - 48; ch = getchar(); } return u * f;\n}\n\ninline int pls(int x, int y) { x += y; return x >= P ? x - P : x; }\ninline int dec(int x, int y) { x -= y; return x < 0 ? x + P : x; }\ninline int ksm(int x, int k, int rnt = 1) {\n\tfor(int i = k; i; i >>= 1, x = 1ll * x * x % P) if(i & 1) rnt = 1ll * rnt * x % P;\n\treturn rnt;\n}\n\nconst int inv2 = inv(2);\n\ninline int C(int n, int m) { return 1ll * fac[n] * ifac[n - m] % P * ifac[m] % P; }\n\nint main() {\n\tn = read(); k = read(); fac[0] = 1; int N = n * k;\n\tif(k == 1) { puts(\"1\"); return 0; }\n\trep(i, 1, N) fac[i] = 1ll * fac[i - 1] * i % P;\n\tifac[N - 1] = inv(fac[N - 1]);\n\tdep(i, N - 2, 0) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P;\n\tf[0][0] = 1;\n\trep(i, 1, n) rep(j, 0, i) {\n\t\tf[i][j] = pls(f[i][j], f[i - 1][j]);\n\t\tif(j) f[i][j] = pls(f[i][j], 1ll * f[i][j - 1] * (n - j + 1) % P * C(N - i - (k - 1) * (j - 1) - 1, k - 2) % P);\n\t}\n\tcout << f[n][n] << endl;\n\treturn 0;\n}\n/*\n1 1 2 2\n1 2 1 2\n1 2 2 1\n2 1 1 2\n2 1 2 1\n2 2 1 1\n\n0 1 0 2\n0 0 1 2\n0 0 2 1\n0 0 1 2\n0 0 2 1\n0 2 0 1\n 0 1 \n0 2 0 1\n0 0 1 2\n0 1 0 2\n*/"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define LL long long\n//#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)\n//char buf[(1 << 21) + 1], *p1 = buf, *p2 = buf;\ninline int read() {\n\tbool f=0;int x=0;char c=getchar();\n\twhile(c<'0'||'9'<c){if(c==EOF)exit(0);if(c=='-')f=1;c=getchar();}\n\twhile('0'<=c&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();\n\treturn !f?x:-x;\n}\n#define MAXN 2000\n#define INF 0x3f3f3f3f\n#define Mod (int)(1e9+7)\nLL fac[MAXN*MAXN+5],inv[MAXN*MAXN+5];\nLL Pow(LL x,LL y){\n\tLL ret=1;\n\twhile(y){\n\t\tif(y&1) ret=ret*x%Mod;\n\t\tx=x*x%Mod,y>>=1;\n\t}\n\treturn ret;\n}\nvoid Prepare(){\n\tfac[0]=1;\n\tfor(int i=1;i<=MAXN*MAXN;i++)\n\t\tfac[i]=fac[i-1]*i%Mod;\n\tinv[MAXN*MAXN]=Pow(fac[MAXN*MAXN],Mod-2);\n\tfor(int i=MAXN*MAXN-1;i>=0;i--)\n\t\tinv[i]=inv[i+1]*(i+1)%Mod;\n\treturn ;\n}\nLL f[MAXN+5][MAXN+5];\nLL C(int n,int m){\n\tif(n<m) return 0;\n\treturn fac[n]*inv[m]%Mod*inv[n-m]%Mod;\n}\nint main(){\n\tPrepare();\n\tint n=read(),k=read();\n\tif(n==1)\n\t\tputs(\"1\"),exit(0);\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tf[i][j]=(f[i-1][j]+C(n-i+(n-(j-1))*(k-1)-1,k-2)*f[i][j-1]%Mod)%Mod;\n\t}\n\tprintf(\"%lld\\n\",f[n][n]*fac[n]%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\n#define inc(i,j,k) for(re int i=j;i<=k;i++)\n#define ll long long\nusing namespace std;\nconst int mod=1e9+7;\nconst int N=2e3+5;\nint n,k;\nll fac[N*N],inv[N*N],dp[N][N];\nll c(int n,int m){return fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1) return puts(\"1\"),0;\n\tfac[0]=1;\n\tinc(i,1,n*k) fac[i]=fac[i-1]*i%mod;\n\tinv[0]=inv[1]=1;\n\tinc(i,2,n*k) inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\tinc(i,2,n*k) inv[i]=inv[i]*inv[i-1]%mod;\n\tinc(i,0,n) dp[0][i]=1;\n\tinc(i,1,n){\n\t\tinc(j,i,n){\n\t\t\tdp[i][j]=(dp[i][j-1]+dp[i-1][j]*(n-i+1)%mod*c(n*k-(k-1)*(i-1)-j-1,k-2))%mod;\n\t\t} \n\t}\n\tprintf(\"%lld\",dp[n][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2050\n#define mod 1000000007\nusing namespace std;\ntypedef long long LL;\n\nint n, k, tp;\nLL fac[N*N], inv[N*N], infac[N*N], F[N][N];\n\nvoid inc(LL &x, LL y) {x=(x+y)%mod;}\n\ninline LL C(LL n, LL m) {\n\tif (n < m) return 0LL;\n\tif (n == m || m == 0) return 1LL;\n\treturn 1LL * fac[n] * infac[m] % mod * infac[n-m] % mod;\n}\n\nint main() {\n\tcin >> n >> k;\n\ttp = (2000+1) * (2000+1);\n\tif (!k) return puts(\"1\"), 0;\n\tfac[0] = fac[1] = 1LL;\n\tfor (int i=2;i<=tp;i++)\n\t\tfac[i] = 1LL * fac[i-1] * i % mod;\n\t\n\tinv[0] = inv[1] = 1LL;\n\tfor (int i=2;i<=tp;i++)\n\t\tinv[i] = 1LL * (mod-mod/i) * inv[mod%i] % mod;\n\t\n\tinfac[0] = infac[1] = 1LL;\n\tfor (int i=2;i<=tp;i++)\n\t\tinfac[i] = 1LL * infac[i-1] * inv[i] % mod;\n\t\t\n\tF[0][0] = 1LL;\n\t\n\tfor (int i=0;i<=n;i++)\n\t\tfor (int j=i;j<=n;j++) {\n\t\t\tif (i) inc(F[i][j], F[i-1][j]);\n\t\t\tif (j) inc(F[i][j], 1LL * F[i][j-1] * C(i+(j-1)*(k-1)+k-2, k-2) % mod);\n\t\t}\n\t\n\tLL ans = 1LL * F[n][n] * fac[n] % mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n设f[i][j]表示当前有i个白球，一共放完了j种球\n显然有j <= i\n* 放白球 从f[i-1][j]转移\n* 放没有出现过的球 (n - j + 1) * f[i][j - 1] * C(k - 2, n * k - i - (j - 1) * (k - 1) - 1)\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int;\n\nconst int N = 2020;\nconst int mod = 1e9 + 7;\n\nint inv[N * N], fac[N * N];\nint f[N][N];\nint n, k;\n\nint power(int a, int b) {\n\ta %= mod; int ans = 1;\n\twhile(b) {\n\t\tif(b & 1) ans = 1ll * ans * a % mod;\n\t\ta = 1ll * a * a % mod; b >>= 1;\n\t}\n\treturn ans;\n}\n\nint C(int n, int m) {\n\treturn 1ll * fac[m] * inv[n] % mod * inv[m - n] % mod;\n}\n\nsigned main() {\n\tscanf(\"%d%d\", &n, &k);\n\tfac[0] = 1;\n\tfor(int i = 1; i < N * N; ++i) \n\t\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\tfor(int i = 0; i < N * N; ++i) \n\t\tinv[i] = power(fac[i], mod - 2);\n\tfor(int i = 0; i <= n; ++i) f[i][0] = 1;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tfor(int j = 1; j <= i; ++j) {\n\t\t\tf[i][j] = f[i - 1][j];\n\t\t\t(f[i][j] += 1ll * (n - j + 1) * f[i][j - 1] % mod * C(k - 2, n * k - i - (j - 1) * (k - 1) - 1) % mod) %= mod;\n\t\t\t(f[i][j] += mod) %= mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", (f[n][n] % mod + mod) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint w[101000];\nint n;\nint main(){\n    int i;\n    \n  //  freopen(\"/Users/joseunghyeon/Downloads/in (2)/eval_input.txt\",\"r\",stdin);\n    int TC, TT;\n    scanf(\"%d\",&TC);\n    for(TT=1;TT<=TC;TT++){\n        scanf(\"%d\",&n);\n        for(i=1;i<=n;i++)scanf(\"%d\",&w[i]);\n        sort(w+1,w+n+1);\n        printf(\"Case #%d\\n\",TT);\n        if(w[n]-w[1]>1){\n            printf(\"No\\n\");\n            continue;\n        }\n        if(w[n]-w[1]==0){\n            if(w[1] <= n/2 || w[1] == n-1)printf(\"Yes\\n\");\n            else printf(\"No\\n\");\n            continue;\n        }\n        for(i=1;i<n;i++)if(w[i]!=w[i+1])break;\n        int t = i;\n        if(t + 1 <= w[n] && t + (n-t)/2 >= w[n])printf(\"Yes\\n\");\n        else printf(\"No\\n\");\n    }\n}\n*/\n\n\n/*#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n, w[201000];\nint main(){\n    char fp[200];\n    \n    int T[2]={6,18};\n    freopen(\"/Users/joseunghyeon/Downloads/in (2)/eval_input.txt\",\"w\",stdout);\n    printf(\"%d\\n\",T[0]+T[1]);\n    for(int TTT = 0; TTT < 2; TTT++){\n        for(int TT=0;TT< T[TTT];TT++){\n            fprintf(stderr,\"%d %d\\n\",TTT,TT);\n            sprintf(fp, \"/Users/joseunghyeon/Downloads/in (2)/%d_%02d.txt\", TTT, TT);\n            freopen(fp, \"r\",stdin);\n            int n, a;\n            scanf(\"%d\",&n);\n            printf(\"%d\\n\",n);\n            for(int i=0;i<n;i++){\n                scanf(\"%d\",&a);\n                printf(\"%d\",a);\n                if(i!=n-1)printf(\" \");\n            }\n            printf(\"\\n\");\n        }\n    }\n    return 0;\n}\n*/\n\n/*#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n, w[201000];\nint main(){\n    char fp[200];\n    int TC = 0;\n    int T[2]={6,18};\n    freopen(\"/Users/joseunghyeon/Downloads/out (2)/eval_output.txt\",\"w\",stdout);\n    for(int TTT = 0; TTT < 2; TTT++){\n        for(int TT=0;TT< T[TTT];TT++){\n            fprintf(stderr,\"%d %d\\n\",TTT,TT);\n            sprintf(fp, \"/Users/joseunghyeon/Downloads/out (2)/%d_%02d.txt\", TTT, TT);\n            freopen(fp, \"r\",stdin);\n            char rr[10];\n            scanf(\"%s\",rr);\n            printf(\"Case #%d\\n%s\\n\",++TC,rr);\n        }\n    }\n    return 0;\n}*/\n\n\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n, m, F[4100000], InvF[4100000];\nint D[2010][2010], Mod = 1000000007, T[2010];\nint Pow(int a, int b){\n    int r = 1;\n    while(b){\n        if(b&1)r=1ll*r*a%Mod;\n        a=1ll*a*a%Mod;b>>=1;\n    }\n    return r;\n}\nint HH(int a, int b){\n    return 1ll * F[a+b-1] * InvF[b] % Mod * InvF[a-1] % Mod;\n}\nint main(){\n    int i, j;\n    F[0]=1;\n    for(i=1;i<4100000;i++){\n        F[i]=1ll*F[i-1]*i%Mod;\n    }\n    InvF[i-1] = Pow(F[i-1], Mod - 2);\n    for(i=i-1;i>=1;i--)InvF[i-1] = 1ll*InvF[i]*i%Mod;\n    scanf(\"%d%d\",&n,&m);\n    if(m == 1){\n        printf(\"1\\n\");\n        return 0;\n    }\n    D[1][2] = 1;\n    for(i=1;i<n;i++){\n        for(j=2;j<=i+1;j++){\n            T[2] = (T[2] + D[i][j])%Mod;\n            T[j+2] = (T[j+2] + Mod - D[i][j])%Mod;\n        }\n        int s = 0;\n        for(j=2;j<=i+3;j++){\n            s = (s+T[j])%Mod;\n            T[j] = 0;\n            D[i+1][j] = 1ll*s*HH(i*m-j+3, m-2)%Mod;\n        }\n    }\n    int s = 0;\n    for(i=2;i<=n+1;i++){\n        s = (s + D[n][i])%Mod;\n    }\n    printf(\"%lld\\n\",1ll*s*F[n]%Mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll n,m,f[2010][2010],jc[4000010],ny[4000010],p=1e9+7;\nll C(ll x,ll y){\n\treturn jc[x]*ny[y]%p*ny[x-y]%p;\n}\nll ksm(ll x,ll y){\n\tll xlh=1;\n\twhile(y){\n\t\tif(y&1)xlh=xlh*x%p;\n\t\tx=x*x%p;\n\t\ty/=2;\n\t}\n\treturn xlh;\n}\nint main(){\n\tll i,j;\n\tscanf(\"%lld%lld\",&n,&m);\n\tif(m==1)return puts(\"1\"),0;\n\tjc[0]=1;ny[0]=ny[1]=1;\n\tfor(i=1;i<=n*m;i++)jc[i]=jc[i-1]*i%p;\n\tfor(i=2;i<=n*m;i++){\n\t ny[i]=ksm(jc[i],p-2)%p;\n\t //printf(\"%lld %lld %lld\\n\",i,jc[i],ny[i]);\n}\n\tfor(i=0;i<=n;i++)f[i][0]=1;\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=i;j++){\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tf[i][j]=(f[i][j]+f[i][j-1]*(n-j+1)%p*C(n*m-i-(j-1)*(m-1)-1,m-2))%p;\n\t\t\t//printf(\"%lld %lld %lld %lld %lld %lld\\n\",i,j,f[i][j],f[i-1][j],n*m-i-(j-1)*(m-1)-1,C(n*m-i-(j-1)*(m-1)-1,m-2));\n\t\t}\n\t}\n\tprintf(\"%lld\",f[n][n]);\n}\n/*\n没有想到把当前放的固定在原序列上 \n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nconst int inf=2e9;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n#define M 5000000\nll MOD=1000000007;\n// a^b mod MOD\nll powmod(ll a,ll b){\n\tll out=1;\n\tll p=a%MOD;\n\twhile(b){\n\t\tif(b&1)out=out*p%MOD;\n\t\tp=p*p%MOD;\n\t\tb>>=1;\n\t}\n\treturn out;\n}\nvector<ll> fact;\nvoid init(){\n\tfact=vector<ll>(M);\n\tfact[0]=fact[1]=1;\n\tloop(i,2,M)fact[i]=fact[i-1]*i%MOD;\n}\n// nCr\nll nCr(ll n,ll r){\n\tll out=fact[n]*powmod(fact[r]*fact[n-r]%MOD,MOD-2)%MOD;\n\treturn out;\n}\t\nll n,m,dp[2010][2010];\nll f(){\n\tdp[0][0]=1;\n\trep(i,n+1)loop(j,i,n+1){\n\t\tif(i)dp[i][j]=dp[i-1][j];\n\t\tif(j!=i)(dp[i][j]+=nCr(i-1+j*(m-1),m-2)*dp[i][j-1]%MOD)%=MOD;\n\t}\n//\trep(i,4){rep(j,4)cout<<\" \"<<dp[i][j];cout<<endl;}\n\treturn dp[n][n];\n}\nint main(){\n\tinit();\n\tcin>>n>>m;\n\tcout<<(m-1?fact[n]*f()%MOD:1)<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2010;\nconst int mod = 1e9 + 7;\n\nint fac[N * N], inv[N * N], f[N][N];\n\nint qpow(int a, int x) {\n\tint ret = 1;\n\twhile(x) {\n\t\tif(x & 1) ret = (long long)ret * a % mod;\n\t\tx >>= 1, a = (long long)a * a % mod;\n\t}\n\treturn ret;\n}\n\nint C(int n, int m) {\n\tif(n < m || n < 0 || m < 0) return 0;\n\treturn (long long)fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\n\nvoid Init(int n) {\n\tfac[0] = inv[0] = 1;\n\tfor(int i = 1; i <= n; ++ i)\n\t\tfac[i] = (long long)fac[i - 1] * i % mod;\n\tinv[n] = qpow(fac[n], mod - 2);\n\tfor(int i = n; i >= 1; -- i)\n\t\tinv[i - 1] = (long long)inv[i] * i % mod;\n}\n\nint main() {\n#ifdef ylsakioi\n\tfreopen(\"agc002f.in\", \"r\", stdin);\n\tfreopen(\"agc002f.out\", \"w\", stdout);\n#endif\n\tint n, k;\n\tInit(N * N - 10);\n\tscanf(\"%d%d\", &n, &k);\n\tif(k == 1) return puts(\"1\"), 0;\n\tf[1][0] = 1;\n\tfor(int i = 0; i <= n; ++ i)\n\t\tfor(int j = 0; j <= i; ++ j) {\n\t\t\tif(i) (f[i][j] += f[i - 1][j]) %= mod;\n\t\t\tif(j) (f[i][j] += 1ll * C((n - j + 1) * (k - 1) + (n - i) - 1, k - 2) * f[i][j - 1] % mod) %= mod;\n\t\t}\n\tprintf(\"%d\\n\", (long long)f[n][n] * fac[n] % mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Leftmost Ball\n// * frank_c1\n// * 2017 / 09 / 29\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nLL pow_mod(LL b, LL p, LL k) {\n\tLL ret = 1;\n\tfor (; p; p >>= 1) {\n\t\tif (p & 1) ret = ret * b % k;\n\t\tb = b * b % k;\n\t} return ret;\n}\n\nconst int maxn = 3005;\nconst int mo = (int)(1e9) + 7;\nLL fac[maxn * maxn], ivf[maxn * maxn];\nint f[maxn][maxn];\n\ninline LL C(int n, int m) {\n\tif (m < 0 || n - m < 0) return 0;\n\treturn (fac[n] * ivf[m] % mo) * ivf[n - m] % mo;\n}\n\ninline void add(int& x, int v) {\n\tx += v; if (x >= mo) x -= mo;\n}\n\nint main() {\n\tint n, K;\n\tscanf(\"%d%d\", &n, &K);\n\tif (K == 1) return printf(\"1\\n\"), 0;\n\tint mx = n * (K + 1);\n\tfac[0] = ivf[0] = 1;\n\tfor (int i = 1; i <= mx; ++i) fac[i] = fac[i - 1] * i % mo;\n\tivf[mx] = pow_mod(fac[mx], mo - 2, mo);\n\tfor (int i = mx - 1; i >= 1; --i) ivf[i] = ivf[i + 1] * (i + 1) % mo;\n\tf[0][0] = 1;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\tif (i < j) add(f[i + 1][j], f[i][j]);\n\t\t\tif (j < n) add(f[i][j + 1], 1LL * f[i][j] * C(i + (j + 1) * (K - 1) - 1, K - 2) % mo);\n\t\t}\n\t} \n\treturn printf(\"%lld\\n\", 1LL * f[n][n] * fac[n] % mo), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long \nconst int N = 2000 + 10;\nconst int mod = 1e9 + 7;\nusing namespace std;\nll f[N][N], fac[N*N], rfac[N*N];\nint n,m;\nnamespace solver\n{\n  ll fpm(ll x,ll y)\n  {\n    ll s=1;\n    while(y)\n\t{\n\t  if(y&1) s=s*x%mod;\n\t  y>>=1; x=x*x%mod;\n\t}\n\treturn s;\n  }\n  void upd(ll &x,ll y)\n  {\n    //printf(\"%lld %lld\\n\",x,y);\n\tx+=y; x%=mod;\n\t//printf(\"%lld\\n\",x);\n  }\n  ll c(int x,int y)\n  {\n    if(x<0) return 0;\n\tif(x<y) return 0;\n\treturn fac[x]*rfac[y]%mod*rfac[x-y]%mod;\n  }\n  void init()\n  {\n    scanf(\"%d%d\",&n,&m);\n\tfac[0]=1ll; \n\tfor(int i=1;i<=n*m;++i) fac[i]=fac[i-1]*i%mod;\n\trfac[n*m]=fpm(fac[n*m],mod-2);\t \n\tfor(int i=n*m-1;i>=0;--i) rfac[i]=rfac[i+1]*(i+1)%mod;\n\t\n\tf[0][0]=1ll;\n\tfor(int i=0;i<=n;++i)\n\t  for(int j=i;j>=0;--j)\n\t  {\n\t    upd(f[i+1][j+1],f[i][j]*c(i*m-j+m-2,m-2));\n\t    if(j) upd(f[i][j-1],f[i][j]);\n\t  }\n\tf[n][0]=f[n][0]*fac[n]%mod;\n\tprintf(\"%lld\\n\",f[n][0]);\n  } \n}\nint main()\n{\n  solver::init();  \n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n\nconst int N = 2e3, M = N * N;\nconst int Mo = 1e9 + 7;\n\nint n, m;\nint f[N + 10][N + 10], fac[M + 10], Inv[M + 10];\n\ninline int ksm(int a, int b) {\n    int ans = 1;\n    for (; b; b >>= 1, a = 1LL * a * a % Mo)\n        if (b & 1) ans = 1LL * ans * a % Mo;\n    return ans;\n}\n\ninline int C(int n, int m) {\n    if (m < n)\n        return 0;\n    // printf(\"%d %d %d %d\\n\", n, fac[m], Inv[n], Inv[m - n]);\n    return 1LL * fac[m] * Inv[n] % Mo * Inv[m - n] % Mo;\n}\n\nsigned main() {\n    scanf(\"%lld%lld\", &n, &m);\n    if (m == 1) {\n        printf(\"1\\n\");\n        return 0;\n    }\n    fac[0] = fac[1] = 1;\n    for (int i = 2; i <= M; i++)\n        fac[i] = (1LL * fac[i - 1] * i) % Mo;\n    Inv[M] = ksm(fac[M], Mo - 2);\n    // for (int i = 1; i <= n; i++)\n    //     printf(\"%d \", fac[i]);\n    for (int i = M - 1; i >= 0; i--)\n        Inv[i] = 1LL * Inv[i + 1] * (i + 1) % Mo;\n\n    // for (int i = 1; i <= n; i++)\n    //     printf(\"%d \", Inv[i]);\n    f[0][0] = 1;\n    for (int i = 1; i <= n; i++)\n        for (int  j= 0; j <= i; j++) {\n            if (j == 0)\n                f[i][j] = f[i - 1][j];\n            else {\n                f[i][j] = (f[i - 1][j] + 1LL * f[i][j - 1] * (n - j + 1) % Mo * 1LL * (C(m - 2, n - i + (n - j + 1) * (m - 1) - 1)) % Mo) % Mo;\n                // printf(\"%d %d\\n\", C(m - 2, n - i + (n - j + 1) * (m - 1) - 1), n - i + (n - j + 1) * (m - 1) - 1);\n            }\n        }\n    printf(\"%lld\\n\", f[n][n]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define IL inline\n#define N 2003\n#define REP(a,b,c) for(a=b;a<=c;a++)\nusing namespace std;\ntypedef long long lol;\nconst int mod=1e9+7;\nIL int qpow(int a,int b){\n\tint res=1;while(b){if(b&1)res=1LL*res*a%mod;a=1LL*a*a%mod,b>>=1;}return res;\n}\nint n,k,fac[N*N],inv[N*N],f[N][N];\nIL lol C(int n,int m){\n\treturn 1LL*fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nIL void work(){\n\tint i,j=n*k,t;fac[0]=1;\n\tREP(i,1,j)fac[i]=1LL*fac[i-1]*i%mod;inv[j]=qpow(fac[j],mod-2);\n\tfor(i=j;i;i--)inv[i-1]=1LL*inv[i]*i%mod;\n\tf[0][0]=1;k--;\n\tREP(i,0,n)REP(j,i,n){\n\t\tt=f[i][j];if(i<j)f[i+1][j]=(f[i+1][j]+t)%mod;\n\t\tf[i][j+1]=(f[i][j+1]+t*C(i-1+k*(j+1),k-1))%mod;\n\t}\n\tprintf(\"%lld\\n\",1LL*f[n][n]*fac[n]%mod);\n}\nint main(){\n  scanf(\"%d%d\",&n,&k);\n\tif(k==1)printf(\"1\");else work();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\ntemplate <class T> using VVV = V<VV<T>>;\ntemplate <class S, class T> using P = pair<S, T>;\ntemplate <class... T> using TP = tuple<T...>;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing dbl = double;\nusing str = string;\nusing vll = V<ll>;\nusing vvll = V<vll>;\nusing vvvll = V<vvll>;\nusing pl = P<ll, ll>;\nusing tl = TP<ll, ll, ll>;\nusing vpl = V<pl>;\nusing vvpl = V<vpl>;\nusing vtl = V<tl>;\nusing vvtl = V<vtl>;\nusing vs = V<str>;\nusing vvs = V<vs>;\nusing vd = V<dbl>;\nusing vvd = V<vd>;\nusing vvvd = V<vvd>;\nusing qll = queue<ll>;\nusing qpl = queue<pl>;\nusing stll = stack<ll>;\nusing stpl = stack<pl>;\nusing mapll = map<ll, ll>;\nusing setll = set<ll>;\nusing pqll = priority_queue<ll>;\n\n//#define int ll\n#define fi first\n#define se second\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define pob pop_back()\n#define pf push_front\n#define pof pop_front()\n#define sz size()\n#define bgn begin()\n#define en end()\n#define asn assign\n#define emp empty()\n#define fr front()\n#define bk back()\n#define clr clear()\n#define ins insert\n#define ers erase\n#define res resize\n#define tp top()\n#define p_q priority_queue\n#define inv inverse()\n\n#define FOR(i,a,b) for(ll i=(a);i<=(ll)(b);i++)\n#define rFOR(i,a,b) for(ll i=(b);i>=(ll)(a);i--)\n#define REP(i,a) FOR((i),0,(ll)(a)-1)\n#define REP0(i,a) FOR((i),0,(ll)(a))\n#define REP1(i,a) FOR((i),1,(ll)(a))\n#define rREP(i,a) rFOR((i),0,(ll)(a)-1)\n#define rREP0(i,a) rFOR((i),0,(ll)(a))\n#define rREP1(i,a) rFOR((i),1,(ll)(a))\n#define ROR(v,i) for(auto &(i):(v))\n#define IOTA(a,n) iota((a).bgn,(a).en,(n))\n#define SORT(a) sort((a).bgn,(a).en)\n#define rSORT(a) sort((a).rbegin(),(a).rend())\n#define UNIQUE(a) (a).erase(unique((a).bgn,(a).en),(a).en)\n#define PREVP(a) prev_permutation((a).bgn,(a).en)\n#define NEXTP(a) next_permutation((a).bgn,(a).en)\n#define BINS(a,b) binary_search((a).bgn,(a).en,(b))\n#define LOWB(a,b) (lower_bound((a).bgn,(a).en,(b))-(a).bgn)\n#define UPB(a,b) (upper_bound((a).bgn,(a).en,(b))-(a).bgn)\n#define CNT(a,b) count((a).bgn,(a).en,b)\n#define SUM(a) accumulate((a).bgn,(a).en,0)\n#define REV(a) reverse((a).bgn,(a).en)\n#define REGS(a,b) regex_search((a),regex(b))\n#define REGM(a,b) regex_match((a),regex(b))\n#define yn(a) cout <<((a)?\"yes\":\"no\")<<\"\\n\";\n#define Yn(a) cout <<((a)?\"Yes\":\"No\")<<\"\\n\";\n#define YN(a) cout <<((a)?\"YES\":\"NO\")<<\"\\n\";\n#define imp(a) cout <<((a)?\"possible\":\"impossible\")<<\"\\n\";\n#define Imp(a) cout <<((a)?\"Possible\":\"Impossible\")<<\"\\n\";\n#define IMP(a) cout <<((a)?\"POSSIBLE\":\"IMPOSSIBLE\")<<\"\\n\";\n#define fs(a) cout <<((a)?\"second\":\"first\")<<\"\\n\";\n#define Fs(a) cout <<((a)?\"Second\":\"First\")<<\"\\n\";\n#define FS(a) cout <<((a)?\"SECOND\":\"FIRST\")<<\"\\n\";\n//#define say(a) cout <<(a);\n//#define sal(a) cout <<(a)<<\"\\n\";\n#define sak cout <<\"\\n\";\n#define sas cout <<\" \";\n#define sat cout <<\"\\t\";\n#define dbg(a) cerr <<(#a)<<\": \"<<(a)<<\"\\n\";\n#define dbgs(...) dal(#__VA_ARGS__);dal(__VA_ARGS__);\n#define c2l(a) ((ll)(a-48))\n#define a2l(a) ((ll)(a-97))\n#define A2l(a) ((ll)(a-65))\n#define l2c(a) ((char)(a+48))\n#define l2a(a) ((char)(a+97))\n#define l2A(a) ((char)(a+65))\n#define DigN2(a) ((llabs(a)==0)?(1):((ll)(log2(double(llabs(a))))+1))\n#define DigN10(a) ((llabs(a)==0)?(1):((ll)(log10(double(llabs(a))))+1))\n#define Dig2(a,b) (((a)>>(b))&1)\n#define Dig10(a,b) (ll)(((a)/((ll)(pow(10.0,(double)(b)))))%10)\n#define Pow2(a) ((ll)(1)<<(a))\n#define Pow10(a) ((ll)(pow(10.0,double(a))))\n#define LSB(a) ((a)&(-(a)))\n/*#define llin(a) ll (a);cin >>(a);\n#define llin2(a,b) ll (a),(b);cin >>(a)>>(b);\n#define llin3(a,b,c) ll (a),(b),(c);cin >>(a)>>(b)>>(c);\n#define stin(a) string (a);cin >>(a);*/\n#define vin(v) ROR((v),(i)){cin >>(i);};\n#define vllin(N,v) vll (v)((N));vin(v);\n#define vllin2(N,a,b) vll (a)(N),(b)(N);REP(i,N){cin>>(a)[i]>>(b)[i];};\n#define vsin(N,v) vs (v)((N));vin(v);\n#define rdn(a,b) ((a)/(b))\n#define rou(a,b) ((((double(a)/double(b))-((a)/(b)))<0.5)?((a)/(b)):(((a)/(b))+1))\n#define rup(a,b) ((((a)%(b))==0)?((a)/(b)):(((a)/(b))+1))\n#define powll(a,b) (ll)(pow((double)(a),(double)(b)))\n#define Triangle(x1,y1,x2,y2,x3,y3) (((x1)-(x2))*((y1)-(y3))-((x1)-(x3))*((y1)-(y2)))\n#define tg(t,i) get<i>(t)\n\n#define Id(x) get<0>(x)\n#define Act(x) get<1>(x)\n#define InvAct(x) get<2>(x)\n#define mg(id,act) mt(id,act,lam(l))\n//#define MonoidSet(T) TP<T, function<T(T, T)>>\n#define GroupSet(T) TP<T, function<T(T, T)>, function<T(T, T)>>\n#define CompareSet(T) TP<T, function<bool(T, T)>>\n#define lam(lr) ([](auto l, auto r){return (lr);})\n#define elam(lr) ([=](auto l, auto r){return (lr);})\n#define clam(lr) ([&](auto l, auto r){return (lr);})\n#define lamr(lr) ([](auto l, auto r){lr})\n#define elamr(lr) ([=](auto l, auto r){lr})\n#define clamr(lr) ([&](auto l, auto r){lr})\n#define min(...) Operation(MIN,__VA_ARGS__)\n#define max(...) Operation(MAX,__VA_ARGS__)\n#define gcd(...) Operation(GCD,__VA_ARGS__)\n#define lcm(...) Operation(LCM,__VA_ARGS__)\n#define vmin(...) VOperation(MIN,__VA_ARGS__)\n#define vmax(...) VOperation(MAX,__VA_ARGS__)\n#define vgcd(...) VOperation(GCD,__VA_ARGS__)\n#define vlcm(...) VOperation(LCM,__VA_ARGS__)\n#define vsum(...) VOperation(ADD,__VA_ARGS__)\n#define vpro(...) VOperation(MUL,__VA_ARGS__)\n#define emin(a, ...) ((a)=min((a),__VA_ARGS__))\n#define emax(a, ...) ((a)=max((a),__VA_ARGS__))\n#define egcd(a, ...) ((a)=gcd((a),__VA_ARGS__))\n#define elcm(a, ...) ((a)=lcm((a),__VA_ARGS__))\n#define ope Operation\n#define vope VOperation\n\n#define svll SumV<ll>\n#define svvll SumV2<ll>\n\n#define li(...) ll __VA_ARGS__;Input(__VA_ARGS__);\n#define si(...) str __VA_ARGS__;Input(__VA_ARGS__);\n//#define vli(size, ...) vll __VA_ARGS__;vInitInput(size,__VA_ARGS__);\n#define vlr(size, ...) vll __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n#define vlc(size, ...) vll __VA_ARGS__;vInitInputC(size,__VA_ARGS__);\n#define vli(size, ...) vll __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n#define vsr(size, ...) vs __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n#define vsc(size, ...) vs __VA_ARGS__;vInitInputC(size,__VA_ARGS__);\n#define vsi(size, ...) vs __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n#define vli2(rowSize,columnSize, ...) vvll __VA_ARGS__;vInitInput2(rowSize,columnSize,__VA_ARGS__);\n#define vplr(size, ...) vpl __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n#define vplc(size, ...) vpl __VA_ARGS__;vInitInputC(size,__VA_ARGS__);\n#define vpli(size, ...) vpl __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n\nconst ll MOD = 1e9 + 7;\n//const ll MOD = 998244353;\n//const ll MOD = 924844033;\n//const ll MOD = 9007199254740881;\nconst ll INF = 1LL << 60;//1.15e18\nconst double PI = acos(-1.0);\nconst vll DX = { 0,-1,0,1,0,-1,1,1,-1 };\nconst vll DY = { 0,0,-1,0,1,-1,-1,1,1 };\nconst str alp = \"abcdefghijklmnopqrstuvwxyz\";\nconst str ALP = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\ntemplate <class T> auto GetVectorValueType(T v) { return v; }\ntemplate <class T> auto GetVectorValueType(V<T> v) { return GetVectorValueType(T()); }\n\ntemplate <class S, class T> istream &operator>>(istream &in, P<S, T> &p) { return in >> p.fi >> p.se; }\ntemplate <class T> istream &operator>>(istream &in, V<T> &v) { REP(i, v.sz) in >> v[i]; return in; }\n\nvoid Input() {}\ntemplate <class Var, class... Args> void Input(Var& var, Args&... args) {\n\tcin >> var;\n\tInput(args...);\n}\n\nvoid vInit(ll size) {}\ntemplate <class T, class... Args> void vInit(ll size, V<T>& v, Args&... args) {\n\tv.res(size);\n\tvInit(size, args...);\n}\nvoid vInput(ll size) {}\ntemplate <class T, class... Args> void vInput(ll size, V<T>& v, Args&... args) {\n\tREP(i, size) cin >> v[i];\n\tvInput(size, args...);\n}\nvoid vInputR(ll size) {}\ntemplate <class T, class... Args> void vInputR(ll size, V<T>& v, Args&... args) {\n\tREP(i, size) cin >> v[i];\n\tvInputR(size, args...);\n}\nvoid vInputNumC(ll num) {}\ntemplate <class T, class... Args> void vInputNumC(ll num, V<T>& v, Args&... args) {\n\tcin >> v[num];\n\tvInputNumC(num, args...);\n}\nvoid vInputC(ll size) {}\ntemplate <class... Args> void vInputC(ll size, Args&... args) {\n\tREP(i, size) vInputNumC(i, args...);\n}\nvoid vInitInputR(ll size) {}\ntemplate <class... Args> void vInitInputR(ll size, Args&... args) {\n\tvInit(size, args...);\n\tvInputR(size, args...);\n}\nvoid vInitInputC(ll size) {}\ntemplate <class... Args> void vInitInputC(ll size, Args&... args) {\n\tvInit(size, args...);\n\tvInputC(size, args...);\n}\nvoid vInit2(ll rowSize, ll columnSize) {}\ntemplate <class T, class... Args> void vInit2(ll rowSize, ll columnSize, VV<T>& v, Args&... args) {\n\tv.asn(rowSize, V<T>(columnSize));\n\tvInit2(rowSize, columnSize, args...);\n}\nvoid vInput2(ll rowSize, ll columnSize) {}\ntemplate <class T, class... Args> void vInput2(ll rowSize, ll columnSize, VV<T>& v, Args&... args) {\n\tREP(r, rowSize) {\n\t\tREP(c, columnSize) {\n\t\t\tcin >> v[r][c];\n\t\t}\n\t}\n\tvInput2(rowSize, columnSize, args...);\n}\nvoid vInitInput2(ll rowSize, ll columnSize) {}\ntemplate <class... Args> void vInitInput2(ll rowSize, ll columnSize, Args&... args) {\n\tvInit2(rowSize, columnSize, args...);\n\tvInput2(rowSize, columnSize, args...);\n}\n\ntemplate <class S, class T> ostream &operator<<(ostream &out, const P<S, T> &p) {\n\treturn out << \"[\" << p.fi << \", \" << p.se << \"]\";\n}\ntemplate <class T> ostream &operator<<(ostream &out, V<T> &v) {\n\tif (v.emp) return out << \"{}\";\n\telse {\n\t\tauto itr = v.bgn;\n\t\tout << \"{\" << *itr;\n\t\titr++;\n\t\twhile (itr != v.en) {\n\t\t\tout << \", \" << *itr;\n\t\t\titr++;\n\t\t}\n\t\tout << \"}\";\n\t\treturn out;\n\t}\n}\ntemplate <class S, class T> ostream &operator<<(ostream &out, const map<S, T> &m) {\n\tif (m.emp) return out << \"<[]>\";\n\telse {\n\t\tauto itr = m.bgn;\n\t\tout << \"< [\" << (itr->fi) << \": \" << (itr->se);\n\t\titr++;\n\t\twhile (itr != m.en) {\n\t\t\tout << \"], [\" << (itr->fi) << \": \" << (itr->se);\n\t\t\titr++;\n\t\t}\n\t\tout << \"] >\";\n\t\treturn out;\n\t}\n}\ntemplate <class T> ostream &operator<<(ostream &out, const set<T> &s) {\n\tif (s.emp) return out << \"<>\";\n\telse {\n\t\tauto itr = s.bgn;\n\t\tout << \"<\" << *itr;\n\t\titr++;\n\t\twhile (itr != s.en) {\n\t\t\tout << \", \" << *itr;\n\t\t\titr++;\n\t\t}\n\t\tout << \">\";\n\t\treturn out;\n\t}\n}\n\nvoid say() {}\ntemplate <class T> void say(T t) { cout << t; }\ntemplate <class Head, class... Body> void say(Head head, Body... body) {\n\tcout << head << \" \";\n\tsay(body...);\n}\nvoid sal() { cout << \"\\n\"; }\ntemplate <class... Args> void sal(Args... args) {\n\tsay(args...);\n\tcout << \"\\n\";\n}\n\nvoid day() {}\ntemplate <class T> void day(T t) { cerr << t; }\ntemplate <class Head, class... Body> void day(Head head, Body... body) {\n\tcerr << head << \" \";\n\tday(body...);\n}\nvoid dal() { cerr << \"\\n\"; }\ntemplate <class... Args> void dal(Args... args) {\n\tday(args...);\n\tcerr << \"\\n\";\n}\n\nvoid salv() {}\ntemplate <class T> void salv(V<T> v) {\n\tif (v.emp) sal();\n\telse {\n\t\tauto itr = v.bgn;\n\t\tsay(*itr);\n\t\titr++;\n\t\twhile (itr != v.en) {\n\t\t\tsas;\n\t\t\tsay(*itr);\n\t\t\titr++;\n\t\t}\n\t\tsak;\n\t}\n}\ntemplate <class T> void salv(VV<T> v) {\n\tif (v.emp) sal();\n\telse {\n\t\tROR(v, i) salv(i);\n\t}\n}\ntemplate <class T, class... Args> void salv(T v, Args... args) {\n\tsalv(v);\n\tsalv(args...);\n}\n\n\ntemplate <class L, class R> auto Gcd(L l, R r) -> decltype(l + r) {\n\tif (l < r) swap(l, r);\n\treturn r ? Gcd(r, l%r) : l;\n}\ntemplate <class L, class R> auto Lcm(L l, R r) {\n\tif (!l || !r) return 0;\n\treturn l / Gcd(l, r) * r;\n}\n\n/*\nauto LES = mp(INF, lam(return l < r;));\nauto GRT = mp(-INF, lam(return l > r;));\nauto EQ = mp(0, lam(return l == r;));\n\nauto ADD = mp(0, lam(return l + r;));\nauto SUB = mp(0, lam(return l - r;));\nauto MUL = mp(1, lam(return l * r;));\nauto DIV = mp(1, lam(return l / r;));\nauto MDL = mp(1, lam(return l % r;));\nauto XOR = mp(0, lam(return l ^ r;));\nauto OR = mp(0, lam(return l | r;));\nauto AND = mp(((ll)(1) << 63) - 1, lam(return l & r;));\nauto MIN = mp(INF, lam(return (l < r) ? l : r;));\nauto MAX = mp(-INF, lam(return (l > r) ? l : r;));\nauto GCD = mp(0, lam(return Gcd(l, r);));\nauto LCM = mp(1, lam(return Lcm(l, r);));\n*/\n\nauto LES = mp(INF, lam(l < r));\nauto GRT = mp(-INF, lam(l > r));\nauto EQ = mp(0, lam(l == r));\n\nauto ADD = mt(0, lam(l + r), lam(l - r));\nauto MUL = mt(1, lam(l * r), lam(l / r));\nauto XOR = mt(0, lam(l ^ r), lam(l ^ r));\nauto OR = mg(0, lam(l | r));\nauto AND = mg(((ll)(1) << 63) - 1, lam(l & r));\nauto MIN = mg(0, lam((l < r) ? l : r));\nauto MAX = mg(0, lam((l > r) ? l : r));\nauto GCD = mg(0, lam(Gcd(l, r)));\nauto LCM = mg(0, lam(Lcm(l, r)));\n\ntemplate <class OperationType> auto Operation(OperationType A) { return Id(A); }\ntemplate <class OperationType, class T> auto Operation(OperationType A, T x) { return x; }\ntemplate <class OperationType, class T, class... Args> auto Operation(OperationType A, T x, Args... args) {\n\tauto tmp = Operation(A, args...);\n\treturn Act(A)(x, tmp);\n}\n\ntemplate <class OperationType> auto VOperation(OperationType A) { return Id(A); }\ntemplate <class OperationType, class T> auto VOperation(OperationType A, T x) { return x; }\ntemplate <class OperationType, class T> auto VOperation(OperationType A, V<T> v) {\n\tif (v.emp) {\n\t\tdecltype(GetVectorValueType(T())) tmp = Id(A);\n\t\treturn tmp;\n\t}\n\tauto tmp = VOperation(A, v[0]);\n\tFOR(i, 1, v.sz - 1) tmp = Act(A)(tmp, VOperation(A, v[i]));\n\treturn tmp;\n}\ntemplate <class OperationType, class T, class... Args> auto VOperation(OperationType A, T x, Args... args) {\n\tauto xResult = VOperation(A, x);\n\tauto tmp = VOperation(A, args...);\n\treturn Act(A)(xResult, tmp);\n}\n\n\nll Bset(ll a, ll b, ll c) {\n\tif (c) a |= b;\n\telse a &= ~b;\n\treturn a;\n}\n\n\nstruct UFT {\n\npublic:\n\tll tsize;\n\tll mode;\n\tvll par;\n\tvll rank;\n\tUFT(ll tsizeget, ll modeget = 0){\n\t\ttsize = tsizeget;\n\t\tmode = modeget;\n\t\tpar.asn(tsize, -1);\n\t\tif (!mode) rank.res(tsize, 0);\n\t}\n\tll root(ll x) {\n\t\treturn par[x] < 0 ? x : par[x] = root(par[x]);\n\t}\n\tbool isRoot(ll x) {\n\t\treturn x == root(x);\n\t}\n\tbool same(ll x, ll y) {\n\t\treturn root(x) == root(y);\n\t}\n\tvoid merge(ll x, ll y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) return;\n\t\tif (mode) {\n\t\t\tpar[x] += par[y];\n\t\t\tpar[y] = x;\n\t\t}\n\t\telse {\n\t\t\tif (rank[x] < rank[y]) {\n\t\t\t\tpar[y] += par[x];\n\t\t\t\tpar[x] = y;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpar[x] += par[y];\n\t\t\t\tpar[y] = x;\n\t\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t\t}\n\t\t}\n\t}\n\tll size(ll x) {\n\t\treturn -par[root(x)];\n\t}\n};\n\ntemplate <class T> struct pUFT {\n\npublic:\n\n\tll tsize;\n\tll now;\n\tvll par;\n\tvll rank;\n\tvll mtime;\n\tvvll sizepi;\n\tVV<T> sizepv;\n\tV<T> elm;\n\tGroupSet(T) Add;\n\n\tpUFT(ll tsize, GroupSet(T) Add = ADD) : tsize(tsize), Add(Add) { init(); }\n\tvoid init() {\n\t\tnow = 0;\n\t\tpar.asn(tsize, -1);\n\t\trank.asn(tsize, 0);\n\t\tmtime.asn(tsize, INF);\n\t\tsizepi.asn(tsize, { 0 });\n\t\tsizepv.asn(tsize, {});\n\t}\n\tvoid set(ll x, T s) {\n\t\telm[x] = s;\n\t\tsizepv[x] = { s };\n\t}\n\tll root(ll x, ll t) {\n\t\treturn (mtime[x] > t) ? x : root(par[x], t);\n\t}\n\tbool same(ll x, ll y, ll t) {\n\t\treturn root(x, t) == root(y, t);\n\t}\n\tll merge(ll x, ll y) {\n\t\tnow++;\n\t\tx = root(x, now);\n\t\ty = root(y, now);\n\t\tif (x != y) {\n\t\t\tif (rank[x] < rank[y]) {\n\t\t\t\telm[y] = Act(Add)(elm[x], elm[y]);\n\t\t\t\tsizepi[y].pb(now);\n\t\t\t\tsizepv[y].pb(elm[y]);\n\t\t\t\tpar[x] = y;\n\t\t\t\tmtime[x] = now;\n\t\t\t}\n\t\t\telse {\n\t\t\t\telm[x] = Act(Add)(elm[x], elm[y]);\n\t\t\t\tsizepi[x].pb(now);\n\t\t\t\tsizepv[x].pb(elm[x]);\n\t\t\t\tpar[y] = x;\n\t\t\t\tmtime[y] = now;\n\t\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t\t}\n\t\t}\n\t\treturn now;\n\t}\n\tT size(ll x, ll t) {\n\t\tx = root(x, t);\n\t\treturn sizepv[x][UPB(sizepi[x], t) - 1];\n\t}\n\n};\n\nstruct wUFT {\npublic:\n\tll tsize;\n\tll mode;\n\tvll par;\n\tvll rank;\n\tvll dweight;\n\twUFT(ll tsizeget, ll modeget = 0) {\n\t\ttsize = tsizeget;\n\t\tmode = modeget;\n\t\tpar.asn(tsize, -1);\n\t\tif (!mode) rank.res(tsize, 0);\n\t\tdweight.asn(tsize, 0);\n\t}\n\tll root(ll x) {\n\t\tif (par[x] < 0) return x;\n\t\telse {\n\t\t\tll r = root(par[x]);\n\t\t\tdweight[x] += dweight[par[x]];\n\t\t\treturn par[x] = r;\n\t\t}\n\t}\n\tll weight(ll x) {\n\t\troot(x);\n\t\treturn dweight[x];\n\t}\n\tll diff(ll x, ll y) {\n\t\treturn weight(y) - weight(x);\n\t}\n\tbool isRoot(ll x) {\n\t\treturn x == root(x);\n\t}\n\tbool same(ll x, ll y) {\n\t\treturn root(x) == root(y);\n\t}\n\tvoid merge(ll x, ll y, ll w) {\n\t\tw += weight(x);\n\t\tw -= weight(y);\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) return;\n\t\tif (mode) {\n\t\t\tpar[x] += par[y];\n\t\t\tpar[y] = x;\n\t\t\tdweight[y] = w;\n\t\t}\n\t\telse {\n\t\t\tif (rank[x] < rank[y]) {\n\t\t\t\tpar[y] += par[x];\n\t\t\t\tpar[x] = y;\n\t\t\t\tdweight[x] = -w;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpar[x] += par[y];\n\t\t\t\tpar[y] = x;\n\t\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t\t\tdweight[y] = w;\n\t\t\t}\n\t\t}\n\t}\n\tll size(ll x) {\n\t\treturn -par[root(x)];\n\t}\n};\n\ntemplate <class T> struct sUFT {\n\npublic:\n\tll tsize;\n\tll mode;\n\tvll par;\n\tvll rank;\n\tGroupSet(T) Add;\n\tV<T> elm;\n\tsUFT(ll tsize, GroupSet(T) Add = ADD, ll mode = 0) : tsize(tsize), Add(Add), mode(mode) { init(); }\n\tvoid init() {\n\t\tpar.asn(tsize, -1);\n\t\tif (!mode) rank.res(tsize, 0);\n\t\telm.asn(tsize, Id(Add));\n\t}\n\tll root(ll x) {\n\t\treturn par[x] < 0 ? x : par[x] = root(par[x]);\n\t}\n\tbool isRoot(ll x) {\n\t\treturn x == root(x);\n\t}\n\tbool same(ll x, ll y) {\n\t\treturn root(x) == root(y);\n\t}\n\tvoid merge(ll x, ll y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) return;\n\t\tif (mode) {\n\t\t\telm[x] = Act(Add)(elm[x], elm[y]);\n\t\t\tpar[y] = x;\n\t\t}\n\t\telse {\n\t\t\tif (rank[x] < rank[y]) {\n\t\t\t\telm[y] = Act(Add)(elm[x], elm[y]);\n\t\t\t\tpar[x] = y;\n\t\t\t}\n\t\t\telse {\n\t\t\t\telm[x] = Act(Add)(elm[x], elm[y]);\n\t\t\t\tpar[y] = x;\n\t\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t\t}\n\t\t}\n\t}\n\tT size(ll x) {\n\t\treturn elm[root(x)];\n\t}\n\tT& operator[](ll x) { return elm[x]; }\n};\n\ntemplate <typename valtype> class SegT {\n\npublic:\n\n\tll size;\n\tvector<valtype> v;\n\n\tvaltype initv;\n\tfunction<valtype(valtype x, valtype y)> calc;\n\n\tSegT() {}\n\tSegT(const SegT &segt) {}\n\n\tSegT(ll sizeget, ll modeget = 0) {\n\t\tsizeset(sizeget);\n\t\tmodeset(modeget);\n\t\tinit();\n\t}\n\tSegT(vector<valtype> cpyvec, ll modeget = 0) {\n\t\tsizeset(cpyvec.sz);\n\t\tmodeset(modeget);\n\t\tinit();\n\t\tcopy(cpyvec);\n\t}\n\tSegT(ll sizeget, valtype initvget, function<valtype(valtype x, valtype y)> calcget) {\n\t\tsizeset(sizeget);\n\t\tinitv = initvget;\n\t\tcalc = calcget;\n\t\tinit();\n\t}\n\tSegT(vector<valtype> cpyvec, valtype initvget, function<valtype(valtype x, valtype y)> calcget) {\n\t\tsizeset(cpyvec.sz);\n\t\tinitv = initvget;\n\t\tcalc = calcget;\n\t\tinit();\n\t\tcopy(cpyvec);\n\t}\n\tvoid sizeset(ll rsize) {\n\t\tsize = DigN2(rsize);\n\t\tif (rsize == Pow2(size - 1)) size--;\n\t\treturn;\n\t}\n\tvoid modeset(ll mode) {\n\t\tswitch (mode) {\n\t\tcase 0:\n\t\t\tinitv = 0;\n\t\t\tcalc = [](valtype x, valtype y) {return x + y; };\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tinitv = INF;\n\t\t\tcalc = [](valtype x, valtype y) {return min(x, y); };\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tinitv = -INF;\n\t\t\tcalc = [](valtype x, valtype y) {return max(x, y); };\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\tvoid init() {\n\t\tv.asn(Pow2(size + 1) - 1, initv);\n\t}\n\tvoid copy(vector<valtype> cpyvec) {\n\t\tREP(i, min(cpyvec.sz, Pow2(size))) set(i, cpyvec[i]);\n\t}\n\tll i2v(ll i) const{\n\t\tif (i < 0 || i >= Pow2(size)) return -1;\n\t\treturn Pow2(size) + i - 1;\n\t}\n\tll top(ll i) const{\n\t\tif (i == 0) return -1;\n\t\treturn (i - 1) / 2;\n\t}\n\tpl bot(ll i) const{\n\t\tif (i + 1 >= Pow2(size)) return mp(-1, -1);\n\t\treturn mp(2 * i + 1, 2 * i + 2);\n\t}\n\tvoid set(ll i, valtype x) {\n\t\ti = i2v(i);\n\t\tv[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = top(i);\n\t\t\tv[i] = calc(v[bot(i).fi], v[bot(i).se]);\n\t\t}\n\t\treturn;\n\t}\n\tvoid add(ll i, valtype x) {\n\t\tset(i, v[i2v(i)] + x);\n\t\treturn;\n\t}\n\tvaltype operator[](const ll &i) const {\n\t\treturn v[i2v(i)];\n\t}\n//\tvaltype que(ll a = 0, ll b = Pow2(size) - 1) {\n\tvaltype que(ll a, ll b) {\n\t\tif (a == b) return v[i2v(a)];\n\t\tif (a > b) return initv;//swap(a, b);\n\t\tvaltype ans = initv;\n\t\tll ai = i2v(a);\n\t\tll bi = i2v(b);\n\t\tFOR(i, 1, size + 1) {\n\t\t\tif (a > b) break;\n\t\t\tif (a%Pow2(i)) {\n\t\t\t\tans = calc(ans, v[ai]);\n\t\t\t\ta += Pow2(i - 1);\n\t\t\t\tai = top(ai) + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tai = top(ai);\n\t\t\t}\n\t\t\tif (a > b) break;\n\t\t\tif ((b + 1) % Pow2(i)) {\n\t\t\t\tans = calc(ans, v[bi]);\n\t\t\t\tb -= Pow2(i - 1);\n\t\t\t\tbi = top(bi) - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbi = top(bi);\n\t\t\t}\n\t\t\tif (a > b) break;\n\t\t}\n\t\treturn ans;\n\t}\n\tvaltype que(ll b) {\n\t\treturn que(0, b);\n\t}\n\tvaltype que() {\n\t\treturn que(0, Pow2(size) - 1);\n\t}\n\n\n};\n\n\n/*template <class Type> class DP {\n\npublic:\n\n\tvector<Type> v;\n\tType initv;\n\tvll size, block;\n\n\tDP() {}\n\tDP(const DP &dp) {}\n\n\ttemplate<class... Args> DP(Args... args) {\n\t\tblock.asn(1, 1);\n\t\tInitialize(args...);\n\t}\n\n\tvoid Initialize(Type initv_) {\n\t\tinitv = initv_;\n\t\tv.asn(block.bk, initv);\n\t}\n\ttemplate<class... Args> void Initialize(ll val, Args... args) {\n\t\tsize.pb(val);\n\t\tblock.pb(block.bk*val);\n\t\tInitialize(args...);\n\t}\n\n\n\n};*/\n\n\npl Bezout(ll a, ll b) {\n\tif (b != 0) {\n\t\tpl xy;\n\t\txy = Bezout(b, a%b);\n\t\treturn mp(xy.se, xy.fi - ((a / b)*xy.se));\n\t}\n\telse {\n\t\treturn mp(1, 0);\n\t}\n}\npl Bez(ll a, ll b, ll c) {\n\tpl xy;\n\tll x, y, z, gc;\n\txy = Bezout(a, b);\n\tgc = gcd(a, b);\n\tif (c%gc != 0) return mp(-1, -1);\n\tx = xy.fi*(c / gc); y = xy.se*(c / gc);\n\tif (x < 0) z = rup(-x, (b / gc));\n\tif (x >= 0) z = -x / (b / gc);\n\tx += z * (b / gc);\n\ty -= z * (a / gc);\n\treturn mp(x, y);\n}\n\nll DigS10(ll n) {\n\tll ans = 0;\n\twhile(1) {\n\t\tans += n % 10;\n\t\tn /= 10;\n\t\tif (!n) break;\n\t}\n\treturn ans;\n}\n\nll isP(ll n) {\n\tif (n <= 1) return 0;\n\tFOR(i, 2, (ll)sqrt(n) + 1) {\n\t\tif (n%i == 0) return 0;\n\t}\n\treturn 1;\n}\n\nll Tot(ll n) {\n\tif (n <= 0) return 0;\n\tll ans = n, x = 2;\n\twhile (x*x <= n) {\n\t\tif (n%x == 0) {\n\t\t\tans -= ans / x;\n\t\t\twhile (n%x == 0) n /= x;\n\t\t}\n\t\tx++;\n\t}\n\tif (n > 1) ans -= ans / n;\n\treturn ans;\n}\n\ntemplate <class T> struct Graph {\npublic:\n\tll vSize;\n\tll eMode;\n\tll mapMode;\n\tGroupSet(T) Add;\n\tCompareSet(T) Less;\n\tCompareSet(T) Equal;\n\tVV<P<T, ll>> adj;\n\tmap<pl, T> len;\n\tGraph(ll vSize, ll eMode = 0, ll mapMode = 0, GroupSet(T) Add = ADD, CompareSet(T) Less = LES, CompareSet(T) Equal = EQ) : vSize(vSize), eMode(eMode), mapMode(mapMode), Add(Add), Less(Less), Equal(Equal) {}\n\tvoid Init() {\n\t\tadj.asn(vSize, V<P<T, ll>>());\n\t}\n\tvoid AddE(ll x, ll y, T cost) {\n\t\tiAddE(x, y, cost);\n\t\tif (!eMode) iAddE(y, x, cost);\n\t}\n\tvoid iAddE(ll x, ll y, T cost) {\n\t\tadj[x].pb(mp(cost, y));\n\t\tif (mapMode) len[mp(x, y)] = cost;\n\t}\n\tP<bool, T> getE(ll x, ll y) {\n\t\tif (!len.count(mp(x, y))) return mp(false, Id(Less));\n\t\treturn mp(true, len[mp(x, y)]);\n\t}\n\tV<T> Dijk(ll x) {\n\t\tV<T> ans(vSize, Id(Less));\n\t\tif (x < 0 || x >= vSize) return ans;\n\t\tSegT<P<T, ll>> segt(vSize, mp(Id(Less), -1), clamr(\n\t\t\tif (l.se < 0) return r;\n\t\tif (r.se < 0) return l;\n\t\treturn Act(Less)(l.fi, r.fi) ? l : r;\n\t\t));\n\t\tsegt.set(x, mp(Id(Add), x));\n\t\tP<T, ll> now;\n\t\twhile ((now = segt.que(0, vSize - 1)).se >= 0) {\n\t\t\tans[now.se] = segt[now.se].fi;\n\t\t\tsegt.set(now.se, mp(Id(Less), -2));\n\t\t\tROR(adj[now.se], i) {\n\t\t\t\tif (segt[i.se].se == -2) continue;\n\t\t\t\tif (segt[i.se].se == -1) {\n\t\t\t\t\tsegt.set(i.se, mp(Act(Add)(ans[now.se], i.fi), i.se));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Less)(Act(Add)(ans[now.se], i.fi), segt[i.se].fi)) {\n\t\t\t\t\tsegt.set(i.se, mp(Act(Add)(ans[now.se], i.fi), i.se));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tV<P<T, vll>> rDijk(ll x) {\n\t\tV<P<T, vll>> ans(vSize, mp(Id(Less), vll()));\n\t\tif (x < 0 || x >= vSize) return ans;\n\t\tSegT<P<T, ll>> segt(vSize, mp(Id(Less), -1), clamr(\n\t\t\tif (l.se < 0) return r;\n\t\tif (r.se < 0) return l;\n\t\treturn Act(Less)(l.fi, r.fi) ? l : r;\n\t\t));\n\t\tsegt.set(x, mp(Id(Add), x));\n\t\tP<T, ll> now;\n\t\twhile ((now = segt.que(0, vSize - 1)).se >= 0) {\n\t\t\tans[now.se].fi = segt[now.se].fi;\n\t\t\tsegt.set(now.se, mp(Id(Less), -2));\n\t\t\tROR(adj[now.se], i) {\n\t\t\t\tif (segt[i.se].se == -2) continue;\n\t\t\t\tif (segt[i.se].se == -1) {\n\t\t\t\t\tsegt.set(i.se, mp(Act(Add)(ans[now.se].fi, i.fi), i.se));\n\t\t\t\t\tans[i.se].se = { now.se };\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Less)(Act(Add)(ans[now.se].fi, i.fi), segt[i.se].fi)) {\n\t\t\t\t\tsegt.set(i.se, mp(Act(Add)(ans[now.se].fi, i.fi), i.se));\n\t\t\t\t\tans[i.se].se = { now.se };\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Equal)(Act(Add)(ans[now.se].fi, i.fi), segt[i.se].fi)) {\n\t\t\t\t\tans[i.se].se.pb(now.se);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tT Prim(ll x = 0) {\n\t\tT ans = Id(Add);\n\t\tif (x < 0 || x >= vSize) return ans;\n\t\tSegT<P<T, ll>> segt(vSize, mp(Id(Less), -1), clamr(\n\t\t\tif (l.se < 0) return r;\n\t\tif (r.se < 0) return l;\n\t\treturn Act(Less)(l.fi, r.fi) ? l : r;\n\t\t));\n\t\tsegt.set(x, mp(Id(Add), x));\n\t\tP<T, ll> now;\n\t\twhile ((now = segt.que(0, vSize - 1)).se >= 0) {\n\t\t\tans = Act(Add)(ans, segt[now.se].fi);\n\t\t\tsegt.set(now.se, mp(Id(Less), -2));\n\t\t\tROR(adj[now.se], i) {\n\t\t\t\tif (segt[i.se].se == -2) continue;\n\t\t\t\tif (segt[i.se].se == -1) {\n\t\t\t\t\tsegt.set(i.se, i);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Less)(i.fi, segt[i.se].fi)) {\n\t\t\t\t\tsegt.set(i.se, i);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tP<T, V<P<T, vll>>> rPrim(ll x = 0) {\n\t\tP<T, V<P<T, vll>>> ans = mp(Id(Add), V<P<T, vll>>(vSize, mp(Id(Less), vll())));\n\t\tif (x < 0 || x >= vSize) return ans;\n\t\tSegT<P<T, ll>> segt(vSize, mp(Id(Less), -1), clamr(\n\t\t\tif (l.se < 0) return r;\n\t\tif (r.se < 0) return l;\n\t\treturn Act(Less)(l.fi, r.fi) ? l : r;\n\t\t));\n\t\tsegt.set(x, mp(Id(Add), x));\n\t\tP<T, ll> now;\n\t\twhile ((now = segt.que(0, vSize - 1)).se >= 0) {\n\t\t\tans.se[now.se].fi = segt[now.se].fi;\n\t\t\tans.fi = Act(Add)(ans.fi, ans.se[now.se].fi);\n\t\t\tsegt.set(now.se, mp(Id(Less), -2));\n\t\t\tROR(adj[now.se], i) {\n\t\t\t\tif (segt[i.se].se == -2) continue;\n\t\t\t\tif (segt[i.se].se == -1) {\n\t\t\t\t\tsegt.set(i.se, i);\n\t\t\t\t\tans.se[i.se].se = { now.se };\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Less)(i.fi, segt[i.se].fi)) {\n\t\t\t\t\tsegt.set(i.se, i);\n\t\t\t\t\tans.se[i.se].se = { now.se };\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Equal)(i.fi, segt[i.se].fi)) {\n\t\t\t\t\tans.se[i.se].se.pb(now.se);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n};\n\ntemplate <class T> struct Sum {\npublic:\n\tV<T> v, s;\n\tll size;\n\tGroupSet(T) Add;\n\tSum(V<T> v, GroupSet(T) Add = ADD) : v(v), size(v.sz), Add(Add) { Init(); Calc(); }\n\tvoid Init() {\n\t\ts.asn(size + 1, Id(Add));\n\t}\n\tvoid Calc() {\n\t\tREP(i, size) s[i + 1] = Act(Add)(s[i], v[i]);\n\t}\n\tT operator()(ll x) {\n\t\tif (x < -1) x = -1;\n\t\tif (x > size - 1) x = size - 1;\n\t\treturn s[x + 1];\n\t}\n\tT operator()(ll l, ll r) {\n\t\tif (l < 0) l = 0;\n\t\tif (r >= size) r = size - 1;\n\t\tif (l > r) return Id(Add);\n\t\treturn InvAct(Add)(s[r + 1], s[l]);\n\t}\n};\nusing sumll = Sum<ll>;\n\ntemplate <class T> struct Sum2 {\npublic:\n\tVV<T> v, s;\n\tll RowSize, ColumnSize;\n\tGroupSet(T) Add;\n\tSum2(VV<T> v, GroupSet(T) Add = ADD) : v(v), RowSize(v.sz), ColumnSize(v.sz ? v[0].sz : 0), Add(Add) { Init(); Calc(); }\n\tvoid Init() {\n\t\ts.asn(RowSize + 1, V<T>(ColumnSize + 1, Id(Add)));\n\t}\n\tvoid Calc() {\n\t\tREP1(r, RowSize) {\n\t\t\tREP1(c, ColumnSize) {\n//\t\t\t\ts[r][c] = InvAct(Add)(Act(Add)(Act(Add)(v[r - 1][c - 1], operator()(r - 1, c - 2)), operator()(r - 2, c - 1)), operator()(r - 2, c - 2));\n\t\t\t\ts[r][c] = Act(Add)(s[r][c - 1], v[r - 1][c - 1]);\n\t\t\t}\n\t\t}\n\t\tREP1(r, RowSize) {\n\t\t\tREP1(c, ColumnSize) {\n\t\t\t\ts[r][c] = Act(Add)(s[r - 1][c], s[r][c]);\n\t\t\t}\n\t\t}\n\t}\n\tT operator()(ll r, ll c) {\n\t\tif (r < -1) r = -1;\n\t\tif (c < -1) c = -1;\n\t\tif (r > RowSize - 1) r = RowSize - 1;\n\t\tif (c > ColumnSize - 1) c = ColumnSize - 1;\n\t\treturn s[r + 1][c + 1];\n\t}\n\tT operator()(ll r1, ll c1, ll r2, ll c2) {\n\t\tif (r1 < 0) r1 = 0;\n\t\tif (c1 < 0) c1 = 0;\n\t\tif (r2 >= RowSize) r2 = RowSize - 1;\n\t\tif (c2 >= ColumnSize) c2 = ColumnSize - 1;\n\t\tif (r1 > r2) return Id(Add);\n\t\tif (c1 > c2) return Id(Add);\n\t\treturn InvAct(Add)(Act(Add)(s[r2 + 1][c2 + 1], s[r1][c1]), Act(Add)(s[r2 + 1][c1], s[r1][c2 + 1]));\n\t}\n};\nusing sumll2 = Sum2<ll>;\n\ntemplate <class T> struct Point2 {\npublic:\n\tVV<T> v;\n\tll h, w;\n\tPoint2() : h(0), w(0) {}\n\tPoint2(ll h, ll w) : h(h), w(w) { asn(h, w); }\n\tPoint2(ll h, ll w, T val) : h(h), w(w) { asn(h, w, val); }\n\tPoint2(VV<T> cv) : h(cv.sz), w(cv.sz ? cv[0].sz : 0) { asn(h, w); copy(cv); }\n\tvoid assign(ll h, ll w) { v.asn(h, V<T>(w)); }\n\tvoid assign(ll h, ll w, ll val) { v.asn(h, V<T>(w, val)); }\n\tvoid copy(VV<T> cv) { REP(_h, h) REP(_w, w) v[_h][_w] = cv[_h][_w]; }\n\tT& operator()(ll h, ll w) { return v[h][w]; }\n\tT& operator()(pl p) { return v[p.fi][p.se]; }\n\tT& operator[](pl p) { return v[p.fi][p.se]; }\n};\ntemplate <class T> using P2 = Point2<T>;\n\ntemplate <ll Mod> struct Modll {\npublic:\n\tll v;\n\tModll() : v(0) {}\n\tModll(ll _v) { set(_v % Mod + Mod); }\n\tModll& set(ll _v) {\n\t\tv = (_v < Mod) ? _v : (_v - Mod);\n\t\treturn *this;\n\t}\n\tModll pow(ll n) const {\n\t\tModll x = *this, ans = 1;\n\t\twhile (n) {\n\t\t\tif (n & 1) ans *= x;\n\t\t\tx *= x;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\tModll inverse() const { return (*this).pow(Mod - 2); }\n\tModll operator+(const Modll& m) const { return Modll().set(v + m.v); }\n\tModll operator-(const Modll& m) const { return Modll().set(Mod + v - m.v); }\n\tModll operator*(const Modll& m) const { return Modll().set((ull(v) * m.v) % Mod); }\n\tModll operator/(const Modll& m) const { return *this * m.inv; }\n\tModll& operator+=(const Modll& m) { return *this = *this + m; }\n\tModll& operator-=(const Modll& m) { return *this = *this - m; }\n\tModll& operator*=(const Modll& m) { return *this = *this * m; }\n\tModll& operator/=(const Modll& m) { return *this = *this / m; }\n\tModll operator-() const { return Modll(0) - *this; }\n\texplicit operator bool() const { return v != 0; }\n\tfriend istream& operator>>(istream& in, Modll& m) { return in >> m.v; }\n\tfriend ostream& operator<<(ostream& out, const Modll& m) { return out << m.v; }\n};\nusing mll = Modll<MOD>;\nusing vmll = V<mll>;\nusing vvmll = V<vmll>;\nusing vvvmll = V<vvmll>;\n\nvmll MFactMemo(2, 1);\nvmll MIFactMemo(2, 1);\n\nmll mFact(ll n) {\n\tif (MFactMemo.sz <= n) {\n\t\tll oldsize = MFactMemo.sz;\n\t\tMFactMemo.res(n + 1, 1);\n\t\tFOR(i, oldsize, n) MFactMemo[i] = MFactMemo[i - 1] * i;\n\t}\n\treturn MFactMemo[n];\n}\nmll miFact(ll n) {\n\tif (MIFactMemo.sz <= n) {\n\t\tll oldsize = MIFactMemo.sz;\n\t\tMIFactMemo.res(n + 1, 1);\n\t\tMIFactMemo.bk = mFact(n).inv;\n\t\trFOR(i, oldsize + 1, n) MIFactMemo[i - 1] = MIFactMemo[i] * i;\n\t}\n\treturn MIFactMemo[n];\n}\nmll mComb(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn mFact(n) * miFact(k) * miFact(n - k);\n}\n\nll LIS(vll v, ll m = 0) {\n\n\tif (v.sz > 0) {\n\t\tll ans = 0;\n\t\tvll dp(v.sz, INF);\n\t\tFOR(i, 0, v.sz - 1) {\n\t\t\tdp[m ? UPB(dp, v[i]) : LOWB(dp, v[i])] = v[i];\n\t\t}\n\t\tFOR(i, 0, v.sz - 1) {\n\t\t\tif (dp[i] == INF) break;\n\t\t\tans++;\n\t\t}\n\t\treturn ans;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n\n}\n\nll Bsrch(function<bool(ll x)> f, ll mi, ll ma) {\n\tll ng = mi - 1, ok = ma, mid;\n\twhile (ok - ng > 1) {\n\t\tmid = (ng + ok) / 2;\n\t\t(f(mid) ? ok : ng) = mid;\n\t}\n\treturn ok;\n}\n\ntemplate <class T, class M = decltype(MUL), class S = decltype(ADD)> VV<T> MultiMatrix(VV<T> A, VV<T> B, M Mul = MUL, S Add = ADD) {\n\tVV<T> ans;\n\tll ii = A.sz;\n\tif (!ii) return ans;\n\tll jj = A[0].sz;\n\tif (!jj) return ans;\n\tll jj2 = B.sz;\n\tif (!jj2) return ans;\n\tif (jj != jj2) return ans;\n\tll kk = B[0].sz;\n\tif (!kk) return ans;\n\tans.asn(ii, V<T>(kk, 0));\n\tREP(i, ii) {\n\t\tREP(k, kk) {\n\t\t\tREP(j, jj) {\n\t\t\t\tans[i][k] = Act(Add)(ans[i][k], Act(Mul)(A[i][j], B[j][k]));\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nvvll CombMemo(1000, vll(1000, -1));\n\nll Comb(ll n, ll k) {\n\tif ((n < 0) || (k < 0)) return 0;\n\tif (CombMemo[n][k] == -1) {\n\t\tif (n < k) CombMemo[n][k] = 0;\n\t\telse {\n\t\t\tif (n == 0) CombMemo[n][k] = 1;\n\t\t\telse if (k == 0) CombMemo[n][k] = 1;\n\t\t\telse if (n == k) CombMemo[n][k] = 1;\n\t\t\telse CombMemo[n][k] = Comb(n - 1, k - 1) + Comb(n - 1, k);\n\t\t}\n\t}\n\treturn CombMemo[n][k];\n}\n\ntemplate<class T> map<T, ll> Dict(V<T> v) {\n\tmap<T, ll> m;\n\tif (!v.sz) return m;\n\tSORT(v);\n\tUNIQUE(v);\n\tREP(i, v.sz) {\n\t\tm[v[i]] = i;\n\t}\n\treturn m;\n}\n\ntemplate <class T> vll Cmprs(V<T> v) {\n\tauto m = Dict(v);\n\tvll ans(v.sz);\n\tREP(i,v.sz) {\n\t\tans[i] = m[v[i]];\n\t}\n\treturn ans;\n}\n\ntemplate <class T> vll PCmprs(V<T> v) {\n\tif (v.sz == 0) return V<T>();\n\tvll tmp(v.sz);\n\tvll ans(v.sz);\n\tIOTA(tmp, 0);\n\tIOTA(ans, 0);\n\tsort(tmp.bgn, tmp.en, clam(v[l] < v[r]));\n\tsort(ans.bgn, ans.en, clam(tmp[l] < tmp[r]));\n\treturn ans;\n}\n\nll BblCnt(vll rv) {\n\tvll v = PCmprs(rv);\n\tSegT<ll> b(v.sz, 0);\n\tll ans = 0;\n\tREP(i, v.sz) {\n\t\tans += (i - b.que(0, v[i]));\n\t\tb.add(v[i], 1);\n\t}\n\treturn ans;\n}\n\npl NGrid(pl p, ll i, ll H, ll W) {\n\tp = mp(p.fi + DX[i], p.se + DY[i]);\n\tif (p.fi < 0 || p.fi >= H || p.se < 0 || p.se >= W) return mp(INF, INF);\n\treturn p;\n}\n\nvvll llGrid(vs v) {\n\tvvll r(v.sz, vll(v.sz ? v[0].sz : 0, 0));\n\tREP(h, v.sz) REP(w, v.sz ? v[0].sz : 0) r[h][w] = (v[h][w] == '#');\n\treturn r;\n}\n\ntemplate <class T> auto ven(T val) { return val; }\ntemplate <> auto ven<int>(int val) { return (ll)val; }\ntemplate <class T, class... Args> auto ven(T val, Args... args) {\n\tauto tmp = ven(args...);\n\treturn V<decltype(tmp)>(val, tmp);\n}\n\ntemplate <class T> void zind(T& v) { v--; }\ntemplate <class T> void zind(V<T>& v) { ROR(v, i) zind(i); }\ntemplate <class T, class... Args> void zind(T& v, Args&... args) { zind(v); zind(args...); }\n\ntemplate<class S, class T> void SORTby(V<S>& i, const V<T>& x) {\n\tsort(i.bgn, i.en, clam(x[l] < x[r]));\n}\ntemplate<class S, class T> void rSORTby(V<S>& i, const V<T>& x) {\n\tsort(i.bgn, i.en, clam(x[l] > x[r]));\n}\n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree\n{\n\tusing F = function< Monoid(Monoid, Monoid) >;\n\tusing G = function< Monoid(Monoid, OperatorMonoid) >;\n\tusing H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n\tusing P = function< OperatorMonoid(OperatorMonoid, ll) >;\n\n\tll size;\n\tvector< Monoid > data;\n\tvector< OperatorMonoid > lazy;\n\tconst F f;\n\tconst G g;\n\tconst H h;\n\tconst P p;\n\tconst Monoid M1;\n\tconst OperatorMonoid OM0;\n\n\n\tLazySegmentTree(ll n, const F f, const G g, const H h, const P p,\n\t\tconst Monoid &M1, const OperatorMonoid OM0)\n\t\t: f(f), g(g), h(h), p(p), M1(M1), OM0(OM0)\n\t{\n\t\tsize = 1;\n\t\twhile (size < n) size <<= 1;\n\t\tdata.assign(2 * size, M1);\n\t\tlazy.assign(2 * size, OM0);\n\t}\n\n\tvoid set(ll k, const Monoid &x)\n\t{\n\t\tdata[k + size] = x;\n\t}\n\n\tvoid build()\n\t{\n\t\tfor (ll k = size - 1; k > 0; k--) {\n\t\t\tdata[k] = f(data[2 * k + 0], data[2 * k + 1]);\n\t\t}\n\t}\n\n\tvoid propagate(ll k, ll len)\n\t{\n\t\tif (lazy[k] != OM0) {\n\t\t\tif (k < size) {\n\t\t\t\tlazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n\t\t\t\tlazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n\t\t\t}\n\t\t\tdata[k] = g(data[k], p(lazy[k], len));\n\t\t\tlazy[k] = OM0;\n\t\t}\n\t}\n\n\tMonoid update(ll a, ll b, const OperatorMonoid &x, ll k, ll l, ll r)\n\t{\n\t\tpropagate(k, r - l);\n\t\tif (r <= a || b <= l) {\n\t\t\treturn data[k];\n\t\t}\n\t\telse if (a <= l && r <= b) {\n\t\t\tlazy[k] = h(lazy[k], x);\n\t\t\tpropagate(k, r - l);\n\t\t\treturn data[k];\n\t\t}\n\t\telse {\n\t\t\treturn data[k] = f(update(a, b, x, 2 * k + 0, l, (l + r) >> 1),\n\t\t\t\tupdate(a, b, x, 2 * k + 1, (l + r) >> 1, r));\n\t\t}\n\t}\n\n\tMonoid update(ll a, ll b, const OperatorMonoid &x)\n\t{\n\t\treturn update(a, b, x, 1, 0, size);\n\t}\n\n\n\tMonoid query(ll a, ll b, ll k, ll l, ll r)\n\t{\n\t\tpropagate(k, r - l);\n\t\tif (r <= a || b <= l) {\n\t\t\treturn M1;\n\t\t}\n\t\telse if (a <= l && r <= b) {\n\t\t\treturn data[k];\n\t\t}\n\t\telse {\n\t\t\treturn f(query(a, b, 2 * k + 0, l, (l + r) >> 1),\n\t\t\t\tquery(a, b, 2 * k + 1, (l + r) >> 1, r));\n\t\t}\n\t}\n\n\tMonoid query(ll a, ll b)\n\t{\n\t\treturn query(a, b, 1, 0, size);\n\t}\n\n\tMonoid operator[](const ll &k)\n\t{\n\t\treturn query(k, k + 1);\n\t}\n};\n\nvoid Solve();\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << setprecision(20) << fixed;\n\tSolve();\n}\n\nvoid Solve() {\n\n\tli(N, K);\n\tif (K == 1) { sal(1); return; }\n\tvvmll dp = ven(N + 1, N, mll(0));\n\tvmll dps = ven(N, mll(0));\n\tdp[N][0] = 1;\n\trREP1(y, N - 1) {\n\t\tdps[N - y] = 0;\n\t\trREP(i, N - y) dps[i] = dps[i + 1] + dp[y + 1][i];\n\t\tREP(x, N - y + 1) dp[y][x] = dps[max(0, x - 1)] * mComb(N + (K - 1) * (N - y) - (x + y) + K - 2, K - 2);\n\t}\n\tsal(vsum(dp[1]) * mFact(N));\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\n\ntemplate< int mod >\nstruct Combination {\n  vector< int64_t > mfact, rfact;\n\n  Combination(int sz) : mfact(sz + 1), rfact(sz + 1) {\n    mfact[0] = 1;\n    for(int i = 1; i < mfact.size(); i++) {\n      mfact[i] = mfact[i - 1] * i % mod;\n    }\n    rfact[sz] = inv(mfact[sz]);\n    for(int i = sz - 1; i >= 0; i--) {\n      rfact[i] = rfact[i + 1] * (i + 1) % mod;\n    }\n  }\n\n  int64_t fact(int k) const {\n    return (mfact[k]);\n  }\n\n  int64_t pow(int64_t x, int64_t n) const {\n    int64_t ret = 1;\n    while(n > 0) {\n      if(n & 1) (ret *= x) %= mod;\n      (x *= x) %= mod;\n      n >>= 1;\n    }\n    return (ret);\n  }\n\n  int64_t inv(int64_t x) const {\n    return (pow(x, mod - 2));\n  }\n\n  int64_t P(int n, int r) const {\n    if(r < 0 || n < r) return (0);\n    return (mfact[n] * rfact[n - r] % mod);\n  }\n\n  int64_t C(int p, int q) const {\n    if(q < 0 || p < q) return (0);\n    return (mfact[p] * rfact[q] % mod * rfact[p - q] % mod);\n  }\n\n  int64_t H(int n, int r) const {\n    if(n < 0 || r < 0) return (0);\n    return (r == 0 ? 1 : C(n + r - 1, r));\n  }\n};\n\nint N, K;\nint64 dp[2002][2002];\nCombination< mod > tap(2002 * 2002);\n\nint64 rec(int top, int bottom) {\n  if(top == 0 && bottom == 0) return 1;\n  if(~dp[top][bottom]) return dp[top][bottom];\n  int ret = 0;\n  if(top > 0) {\n    (ret += rec(top - 1, bottom)) %= mod;\n  }\n  if(bottom > top) {\n    int64 mul = bottom;\n    (mul *= rec(top, bottom - 1)) %= mod;\n    (mul *= tap.C(top + (K - 1) * bottom - 1, K - 2)) %= mod;\n    (ret += mul) %= mod;\n  }\n  return dp[top][bottom] = ret;\n}\n\nint main() {\n  cin >> N >> K;\n  memset(dp, -1, sizeof(dp));\n  if(K == 1) cout << 1 << endl;\n  else cout << rec(N, N) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int P = 1e9 + 7;\nconst int N = 2005;\n\nlong long frac[N * N], inv_frac[N * N], f[N][N], Sf[N][N];\n\ninline long long ksm(long long base, long long x) {\n    long long res = 1;\n    while(x) {\n        if(x & 1) res *= base, res %= P;\n        x >>= 1, base *= base, base %= P;\n    }\n    return res;\n}\n\ninline long long C(int x, int y) {\n    if(x >= y && y >= 0) {\n        return frac[x] * inv_frac[y] % P * inv_frac[x - y] % P;\n    }\n    return 0;\n}\n\ninline void init() {\n    int n, k;\n    cin >> n >> k;\n    if(k == 1) {\n        printf(\"1\\n\");\n        return ;\n    }\n    frac[0] = 1, inv_frac[0] = 1;\n    for(int i = 1; i <= n * k; i++) frac[i] = (frac[i - 1] * i) % P, inv_frac[i] = ksm(frac[i], P - 2);\n\n\n    Sf[1][0] = Sf[1][1] = f[1][1] = 1;\n\n    for(int i = 2; i <= n; i++) {\n        for(int j = 1; j <= i; j++) f[i][j] = C(i * k - j - 1, k - 2) * Sf[i - 1][j - 1] % P;\n        for(int j = i; j >= 0; j--) Sf[i][j] = (Sf[i][j + 1] + f[i][j]) % P;\n    }\n/*\n    for(int i = 1; i <= n; i++) {\n        for(int j = 1; j <= n; j++) {\n            printf(\"%lld \", f[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n*/\n    cout << Sf[n][1] * frac[n] % P << endl;\n}\n\nint main() {\n    init();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\n\nconst int N = 2e3, M = 4e6, MOD = 1e9 + 7;\n\nint n, k, f[N + 5][N + 5], fac[M + 5], ifac[M + 5];\n\ninline void add(int &x, const int &y) {\n\t(x += y) >= MOD && (x -= MOD);\n}\ninline int pow(int x, int k) {\n\tint ans = 1;\n\tfor (; k > 0; k >>= 1, x = (LL)x * x % MOD) {\n\t\tif (k & 1) {\n\t\t\tans = (LL)ans * x % MOD;\n\t\t}\n\t}\n\treturn ans;\n}\ninline int inv(int x) {\n\treturn pow(x, MOD - 2);\n}\nvoid init(int n) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfac[i] = (LL)fac[i - 1] * i % MOD;\n\t}\n\tifac[n] = inv(fac[n]);\n\tfor (int i = n; i >= 1; i--) {\n\t\tifac[i - 1] = (LL)ifac[i] * i % MOD;\n\t}\n}\ninline int binom(int n, int m) {\n\treturn (LL)fac[n] * ifac[m] % MOD * ifac[n - m] % MOD;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tif (k == 1) {\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tinit(n * k);\n\tf[0][0] = 1;\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= n && j <= i; j++) {\n\t\t\tif (i < n) {\n\t\t\t\tadd(f[i + 1][j], f[i][j]);\n\t\t\t}\n\t\t\tif (j < n) {\n\t\t\t\tadd(f[i][j + 1], (LL)f[i][j] * (n - j) % MOD * binom(n * k - i - j * (k - 1) - 1, k - 2) % MOD);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define Vector point\nusing namespace std;\ninline int read()\n{\n\tint x=0,fl=1;char st=getchar();\n\twhile(st<'0'||st>'9'){ if(st=='-')fl=-1; st=getchar();}\n\twhile(st>='0'&&st<='9') x=x*10+st-'0',st=getchar();\n\treturn x*fl;\n}\nconst int N=2005,mod=1e9+7;\nint n,k;\nll f[N<<1][N],fac[N*N],invfac[N*N];\ninline ll ksm(int x,int y)\n{\n\tll res=1;\n\twhile(y)\n\t{\n\t\tif(y&1) res=res*x%mod;\n\t\tx=(ll)x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\ninline ll C(int x,int y)\n{\n\tif(y==0) return 1ll;\n\treturn fac[x]*invfac[x-y]%mod*invfac[y]%mod;\n}\nint main()\n{\n\tn=read();k=read();\n\tif(k==1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=1;invfac[0]=1;\n\tfor(int i=1;i<=n*k;i++)\n\t\tfac[i]=(ll)fac[i-1]*i%mod,invfac[i]=ksm(fac[i],mod-2);\n\tf[0][0]=1;\n\tfor(int i=1;i<=2*n;i++)\n\t\tfor(int j=0;j<=min(n,i);j++)\n\t\t{\n\t\t\tif(j) f[i][j]=(f[i][j]+f[i-1][j-1])%mod;\n\t\t\tif(j+1<=i-1)\n\t\t\t{\n\t\t\t\tint numc=(i-1-j-1)/2;\n\t\t\t\tf[i][j]=(f[i][j]+f[i-1][j+1]*(n-numc)%mod*C(n*k-i-numc*(k-2),k-2)%mod)%mod;\n\t\t\t}\n\t\t}\n\tprintf(\"%lld\",f[n<<1][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nconst int N=2005;\nconst int M=N*N;\nconst int mo=1e9+7;\nint n,k,m;\nlong long p[M],q[M],f[N][N];\nlong long ksm(long long x,int y)\n{\n\tlong long t=1;\n\tfor (;y;y>>=1)\n\t{\n\t\tif (y&1) t=t*x%mo;\n\t\tx=x*x%mo;\n\t}\n\treturn t;\n}\nlong long c(int x,int y)\n{\n\tif (x<y) return 0;\n\treturn p[x]*q[y]%mo*q[x-y]%mo;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k),m=n*k;\n\tif (!k)\n\t{\n\t\tprintf(\"1\");\n\t\treturn 0;\n\t}\n\tp[0]=q[0]=1;\n\tfor (int i=1;i<=m;i++) p[i]=p[i-1]*i%mo;\n\tq[m]=ksm(p[m],mo-2);\n\tfor (int i=m-1;i;i--) q[i]=q[i+1]*(i+1)%mo;\n\tf[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=i;j>=0;j--)\n\t\t{\n\t\t\tf[i][j]=f[i][j+1];\n\t\t\tif (j) f[i][j]=(f[i][j]+f[i-1][j-1]*c(i*k-j-1,k-2))%mo;\n\t\t}\n\tprintf(\"%lld\",f[n][0]*p[n]%mo);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long D;\nconst int maxn=2003,maxm=4000003,mod=1000000007;\nint Plus(int x,int y){return (x+=y)>=mod?x-mod:x;}\nvoid Pluseq(int &x,int y){if((x+=y)>=mod)x-=mod;}\nint Minus(int x,int y){return Plus(x,mod-y);}\nvoid Minuseq(int &x,int y){Pluseq(x,mod-y);}\nint mul(D x,int y){return x*y%mod;}\nvoid muleq(int &x,int y){x=mul(x,y);}\nint qpow(int x,int y){\n    int ans=1;\n    while(y){\n        if(y&1)muleq(ans,x);\n        muleq(x,x);\n        y>>=1;\n    }\n    return ans;\n}\nint fac[maxm],facinv[maxm],dp[maxn][maxn],n,k;\nint C(int n,int m){return mul(mul(fac[n],facinv[m]),facinv[n-m]);}\nint main(){\n    fac[0]=1;\n    for(int i=1;i<maxm;i++)fac[i]=mul(fac[i-1],i);\n    facinv[maxm-1]=qpow(fac[maxm-1],mod-2);\n    for(int i=maxm-2;i>=0;i--)facinv[i]=mul(facinv[i+1],i+1);\n    scanf(\"%d%d\",&n,&k);\n    if(k==1){puts(\"1\");return 0;}\n    dp[0][0]=1;\n    for(int i=1;i<=n;i++){\n        for(int j=0;j<=i;j++){\n            dp[i][j]=Plus(dp[i-1][j],!j?0:mul(dp[i][j-1],mul(C(n*k-i-(j-1)*(k-1)-1,k-2),n-j+1)));\n        }\n    }\n    printf(\"%d\\n\",dp[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3) \n#include <cstdio>\nconst int N = 2010;\nconst int mod = 1e9 + 7;\nint n, k, fac[N * N], inv[N * N], f[N][N];\ninline int C(int x, int y) {\n\treturn 1ll * fac[x] * inv[y] % mod * inv[x - y] % mod;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tif (k == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0] = fac[1] = 1; for (int i = 2; i <= n * k; ++ i) fac[i] = 1ll * fac[i - 1] * i % mod;\n\tinv[0] = inv[1] = 1; for (int i = 2; i <= n * k; ++ i) inv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod;\n\tfor (int i = 2; i <= n * k; ++ i) inv[i] = 1ll * inv[i] * inv[i - 1] % mod;\n\tfor (int i = 0; i <= n; ++ i) f[i][0] = 1;\n\tfor (int i = 1; i <= n; ++ i)\n\t\tfor (int j = 1; j <= i; ++ j) {\n\t\t\tf[i][j] = (f[i - 1][j] + (1ll * f[i][j - 1] * (n - j + 1) % mod * C(n - i + (n - j + 1) * (k - 1) - 1, k - 2) % mod)) % mod;\n\t\t}\n\tprintf(\"%d\\n\", f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Believe in yourself...\n#include<bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define F first\n#define S second\n#define sz(c) (c).size()\n#define REP(i,n)  for(ll i=0;i<n;i++)\n#define REPD(i,n) for(ll i=n-1;i>=0;i--)\n#define FOR(i,a,b) for(ll i=a;i<=b;i++)\n#define FORD(i,a,b) for(ll i=a;i>=b;i--)\n\n#define bit(num,i) ((num>>i)&1)\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> pll;\n\nconst ll maxn=2e3+10;\nconst ll mod=1e9+7;\nconst ll maxn2=4e6+20;\n\n#pragma GCC Optimize(\"Ofast\")\n\nll dp[maxn][maxn];\nll cnk[maxn2],fac[maxn2],inv[maxn2],ifac[maxn2];\nll N,K;\n\t\nll pw(ll a, ll b) { return b != 0? pw(a * a % mod, b >> 1) * (b & 1? a: 1) % mod: 1; }\n\nvoid prep(){\n\tfac[0]=ifac[0]=inv[1]=1;\n\tFOR(i,1,maxn2-1)\n\t\tfac[i]=(i*fac[i - 1])%mod;\n\tFOR(i,2,maxn2-1) \n\t\tinv[i] = mod - 1LL * (mod / i) * inv[mod % i] % mod;\n\tFOR(i,1,maxn2-1)\n\t\tifac[i] =(inv[i]*ifac[i-1])%mod;\n\tFOR(i,(K-2),maxn2-1)\n\t\tcnk[i]=(((fac[i]*ifac[K-2])%mod)*ifac[i-K+2])%mod;\n}\n\nint main(){\n\tcin>>N>>K;\n\tif(K==1){\n\t\tcout<<1;\n\t\treturn 0;\n\t}\n\tprep();\n\t\n\tdp[1][0]=dp[1][1]=1;\n\tFOR(i,2,N){\n\t\tFORD(j,i,1){\n\t\t\tdp[i][j]=(i*((cnk[(i*K)-j-1]*dp[i-1][j-1])%mod))%mod;\n\t\t\tdp[i][j]=(dp[i][j]+dp[i][j+1])%mod;\n\t\t}\n\t\tdp[i][0]=dp[i][1];\n\t}\n\tcout<<dp[N][0];\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\nusing namespace std;\ntypedef long long s64;\n\nconst int ONE = 2005;\nconst int MOD = 1e9 + 7;\n\nint get()\n{\n\t\tint res = 1, Q = 1; char c;\n\t\twhile( (c = getchar()) < 48 || c > 57)\n\t\t\tif(c == '-') Q = -1;\n\t\tif(Q) res = c - 48;\n\t\twhile( (c = getchar()) >= 48 && c <= 57)\n\t\t\tres = res * 10 + c - 48;\n\t\treturn res * Q;\n}\n\nint Qucikpow(int a, int b)\n{\n\t\tint res = 1;\n\t\twhile(b)\n\t\t{\n\t\t\tif(b & 1) res = (s64)res * a % MOD;\n\t\t\ta = (s64)a * a % MOD;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn res;\n}\n\nint n, k;\nint fac[ONE * ONE], inv[ONE * ONE];\n\nvoid Deal_first()\n{\n\t\tfac[0] = 1;\n\t\tfor(int i = 1; i <= n * k; i++)\n\t\t\tfac[i] = (s64)fac[i - 1] * i % MOD;\n\n\t\tinv[n * k] = Qucikpow(fac[n * k], MOD - 2);\n\t\tfor(int i = n * k; i >= 1; i--)\n\t\t\tinv[i - 1] = (s64)inv[i] * i % MOD;\n}\n\nint C(int n, int m)\n{\n\t\treturn (s64)fac[n] * inv[m] % MOD * inv[n - m] % MOD;\n}\n\nint f[ONE][ONE];\n\nint main()\n{\n\t\t//freopen(\".in\",\"r\",stdin);\n\t\t//freopen(\".out\",\"w\",stdout);\n\t\tn = get(), k = get();\n\t\tif(k == 1) {printf(\"1\\n\"); return 0;}\n\t\tDeal_first();\n\n\t\tf[1][1] = f[1][0] = 1;\n\t\tfor(int i = 2; i <= n; i++)\n\t\t\tfor(int j = 0; j <= i; j++)\n\t\t\t{\n\t\t\t\tif(j) (f[i][j] += f[i][j - 1]) %= MOD;\n\t\t\t\t(f[i][j] += (s64)f[i - 1][j] * C(i * (k - 1) + j - 1, k - 2) % MOD) %= MOD;\n\t\t\t}\n\n\t\tprintf(\"%d\", (s64)f[n][n] * fac[n] % MOD);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <deque>\n#include <queue>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <bitset>\n#include <stack>\n#include <iomanip>\n#include <utility>\n#include <functional>\nusing namespace std;\n#define ll long long\n#define ull unsigned ll\nconst int mod=1000000007;\nconst int N=2005;\nint n, k;\nll fac[N*N], inv[N*N], ifac[N*N];\nll dp[N][N];\nll C(int x, int y) {\n\tif(x<y||x<0||y<0) return 0;\n\treturn fac[x]*ifac[y]%mod*ifac[x-y]%mod;\n}\nint main() {\n\tcin>>n>>k;\n\tif(k==1) {\n\t\tputs(\"1\");return 0;\n\t}\n\tfac[0]=fac[1]=ifac[0]=ifac[1]=inv[1]=1;\n\tfor(int i=2; i<=2000*2000; i++) {\n\t\tfac[i]=fac[i-1]*i%mod;\n\t\tinv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\t\tifac[i]=ifac[i-1]*inv[i]%mod;\n\t}\n\tfor(int i=0; i<=n; i++) {\n\t\tfor(int j=i; j<=n; j++) {\n\t\t\tif(!i&&!j) dp[0][0]=1;\n\t\t\telse dp[i][j]=((i?dp[i-1][j]:0)+C(i+j*(k-1)-1, k-2)*dp[i][j-1]%mod)%mod;\n\t\t}\n\t}\n\tcout<<dp[n][n]*fac[n]%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nconst long long mod = 1000000007;\nint N,K; long long D[2002][2002],inv[4004004]={0,1},fact[4004004]={1,1},ifact[4004004]={1,1};\n\nlong long comb(int n, int k)\n{\n\treturn fact[n] * ifact[k] % mod * ifact[n-k] % mod;\n}\n\nint main()\n{\n\tscanf (\"%d %d\",&N,&K);\n\tif (K == 1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\n\tfor (int i=2;i<N*K;i++){\n\t\tinv[i] = (mod - mod / i) * inv[mod % i] % mod;\n\t\tfact[i] = fact[i-1] * i % mod;\n\t\tifact[i] = ifact[i-1] * inv[i] % mod;\n\t}\n\n\tD[0][0] = 1;\n\tfor (int i=0;i<=N;i++) for (int j=0;j<=i;j++){\n\t\tif (i + 1 <= N) D[i+1][j] = (D[i+1][j] + D[i][j]) % mod;\n\t\tif (j + 1 <= i) D[i][j+1] = (D[i][j+1] + D[i][j] * comb(N*K-i-j*(K-1)-1,K-2)) % mod;\n\t}\n\n\tprintf (\"%lld\\n\",D[N][N]*fact[N]%mod);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#define debug(x) cout<<#x<<\"=\"<<x<<endl;\n#define chk() cout<<C((n-j+1)*(k-1)+(n-i)-1,k-2)<<endl;\nusing namespace std;\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())if(ch=='-')f=-1;\n\tfor(;isdigit(ch);ch=getchar())x=(x<<3)+(x<<1)+(ch^'0');\n\treturn x*f;\n}\nconst int maxn=2010;\nconst int mod=1e9+7;\nint ifac[maxn*maxn],fac[maxn*maxn],inv[maxn*maxn];\nint f[maxn][maxn];\ninline int C(int n,int m){\n\tif(m==0)return 1;\n\tif(n<m)return 0;\n\treturn 1ll*fac[n]*ifac[n-m]%mod*ifac[m]%mod;\n}\nint n,k;\ninline void init(){\n\tn=read(),k=read();\n\tif(n==0 || k==0)printf(\"0\"),exit(0);\n\tif(k==1)puts(\"1\"),exit(0);\n\tinv[0]=inv[1]=1;\n\tfor(register int i=2;i<=maxn*maxn;++i)\n\t\tinv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\tfac[0]=fac[1]=1;\n\tfor(register int i=2;i<=maxn*maxn;++i)\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\tifac[0]=ifac[1]=1;\n\tfor(register int i=1;i<=maxn*maxn;++i)\n\t\tifac[i]=1ll*ifac[i-1]*inv[i]%mod;\n\n//\tfor(register int i=1;i<=n;++i)for(register int j=1;j<=i;++j)cout<<f[i][j]<<endl;\n}\ninline void solve(){\n\tf[1][0]=1;\n\t//这里为什么不是n\n\t//出现一个白球不应该是随便放一个都可以吗\n\tfor(register int i=0;i<=n;++i)\n\t\tfor(register int j=0;j<=i;++j){\n\t\t\tif(i)(f[i][j]+=f[i-1][j])%=mod;\n\t\t\tif(j)(f[i][j]+=1ll*C((n-j+1)*(k-1)+(n-i)-1,k-2)*f[i][j-1]%mod)%=mod;\n\t\t}\n\t//                              ^\n \t//                              |\n\t//                       求解释这一坨\n\tcout<<1ll*f[n][n]*fac[n]%mod;\n\t//为啥这里要乘fac[n];\n}\nint main(){\n#ifndef ONLINE_JUDGE\n\tfreopen(\"AT2000.in\",\"r\",stdin);\n\tfreopen(\"AT2000.out\",\"w\",stdout);\n#endif\n\tinit();\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 100005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 +c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nconst int MOD = 1000000007;\nint fac[10000005],invfac[10000005];\nint dp[2005][2005],N,K,sum[2005];\nint inc(int a,int b) {\n    return a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n    return 1LL * a * b % MOD;\n}\nvoid update(int &x,int y) {\n    x = inc(x,y);\n}\nint C(int n,int m) {\n    if(n < m) return 0;\n    return mul(fac[n],mul(invfac[m],invfac[n - m]));\n}\nint Query(int n,int m) {\n    return C(n + m - 1,m - 1);\n}\nint fpow(int x,int c) {\n    int res = 1,t = x;\n    while(c) {\n\tif(c & 1) res = mul(res,t);\n\tt = mul(t,t);\n\tc >>= 1;\n    }\n    return res;\n}\nvoid Solve() {\n    read(N);read(K);\n    if(K == 1) {puts(\"1\");return;}\n    fac[0] = 1;\n    for(int i = 1 ; i <= 10000000 ; ++i) fac[i] = mul(fac[i - 1],i);\n    invfac[10000000] = fpow(fac[10000000],MOD - 2);\n    for(int i = 9999999 ; i >= 0 ; --i) invfac[i] = mul(invfac[i + 1],i + 1);\n    dp[1][0] = 1;\n    for(int i = 2 ; i <= N ; ++i) {\n\tint t = (i - 1) * K;\n\tfor(int j = N ; j >= 0 ; --j) sum[j] = inc(sum[j + 1],dp[i - 1][j]);\n\tfor(int j = 0 ; j <= i ; ++j) {\n\t    update(dp[i][j],mul(sum[max(0,j - 1)],Query(K - 2,t - j + 1)));\n\t}\n    }\n    int ans = 0;\n    for(int j = 0 ; j <= N ; ++j) update(ans,mul(dp[N][j],fac[N]));\n    out(ans);enter;\n}\n\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n设f[i][j]表示当前有i个白球，一共放完了j种球\n显然有j <= i\n* 放白球 从f[i-1][j]转移\n* 放没有出现过的球 (n - j + 1) * f[i][j - 1] * C(k - 2, n * k - i - (j - 1) * (k - 1) - 1)\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2020;\nconst int mod = 1e9 + 7;\n\nint inv[N * N], fac[N * N];\nint f[N][N];\nint n, k;\n\nint power(int a, int b) {\n\ta %= mod; int ans = 1;\n\twhile(b) {\n\t\tif(b & 1) ans = 1ll * ans * a % mod;\n\t\ta = 1ll * a * a % mod; b >>= 1;\n\t}\n\treturn ans;\n}\n\nint C(int n, int m) {\n\treturn 1ll * fac[m] * inv[n] % mod * inv[m - n] % mod;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tif(k == 1) return printf(\"%d\\n\", 1), 0;\n\tfac[0] = 1;\n\tfor(int i = 1; i < N * N; ++i) \n\t\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\tfor(int i = 0; i < N * N; ++i) \n\t\tinv[i] = power(fac[i], mod - 2);\n\tfor(int i = 0; i <= n; ++i) f[i][0] = 1;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tfor(int j = 1; j <= i; ++j) {\n\t\t\tf[i][j] = f[i - 1][j];\n\t\t\t(f[i][j] += 1ll * (n - j + 1) * f[i][j - 1] % mod * C(k - 2, n * k - i - (j - 1) * (k - 1) - 1) % mod) %= mod;\n\t\t\t(f[i][j] += mod) %= mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", (f[n][n] % mod + mod) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int MAXN = 2005, MOD = 1e9 + 7;\nlong long f[MAXN * MAXN];\nlong long dp[MAXN][MAXN], n, k;\nlong long rev(long long a) {\n\tint b = MOD - 2;\n\tlong long res = 1;\n\tfor (b; b; b /= 2) {\n\t\tif (b % 2)\n\t\t\tres *= a, res %= MOD;\n\t\ta *= a, a %= MOD;\n\t}\n\treturn res;\n}\nlong long ch(int a, int b) {\n\treturn f[a] * rev(f[b]) % MOD * rev(f[a - b]) % MOD;\n}\n\nint main() {\n\tcin >> n >> k;\n\tif (k == 1)\n\t\treturn cout << 1, 0;\n\tf[0] = 1;\n\tfor (int i = 1; i < MAXN * MAXN; i++)\n\t\tf[i] = f[i - 1] * i, f[i] %= MOD;\n\tfor (int i = 0; i <= n; i++)\n\t\tdp[0][i] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = i; j <= n; j++)\n\t\t\tdp[i][j] = dp[i - 1][j] * ch(n * k - j - (i - 1) * (k - 1) - 1, k - 2) + dp[i][j - 1], dp[i][j] %= MOD;\n\tcout << f[n] * dp[n][n] % MOD;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst long long N=2000+10;\nconst long long P=1e9+7;\nusing namespace std;\n\nlong long n,k,f[N][N];\nlong long fac[N*N],inv[N*N],fai[N*N],ma;\n\nlong long read()\n{\n\tlong long a,f=1;\n\tchar c;\n\tc=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t  if(c=='-') f=-1;\n\t  c=getchar();\n\t}\n\ta=c-'0';\n\tc=getchar();\n\twhile(c>='0'&&c<='9')\n\t{\n\t  a=a*10+c-'0';\n\t  c=getchar();\n\t}\n\treturn a*f;\n}\n\nlong long qpow(long long x,long long b)\n{\n\tlong long y;\n\tif(b==0) return 1;\n\tif(b==1) return x;\n\ty=qpow(x,b/2)%P;\n\ty=y*y%P;\n\tif(b%2) y=y*x%P;\n\treturn y;\n}\n\nint main()\n{\n\tlong long i,j,s,t;\n\tn=read(); k=read();\n\tif(k==1){printf(\"1\\n\"); return 0;}\n\tma=n*k;\n\tfac[0]=inv[0]=fai[0]=1;\n\tfac[1]=inv[1]=fai[1]=1;\n\tfor(i=2;i<=ma;i++)\n\t{\n\t  fac[i]=(fac[i-1]*i)%P;\n\t  inv[i]=(P-P/i)%P*inv[P%i]%P;\n\t  fai[i]=fai[i-1]*inv[i]%P;\n\t}\n//\tfor(i=1;i<=n;i++) cout<<inv[i]<<\" \";\n//\tcout<<endl;\n\tfor(i=0;i<=n;i++) f[i][0]=1;\n\tfor(i=1;i<=n;i++)\n\t  for(j=1;j<=i;j++)\n\t  {\n\t  \tf[i][j]=f[i-1][j]%P;\n\t  \ts=((n-i)%P+((n-j+1)*(k-1)%P)-1)%P;\n\t  \tt=(fac[s]*fai[k-2]%P)*fai[s-k+2]%P;\n\t  \tf[i][j]=(f[i][j]+(t*f[i][j-1]%P)*(n-j+1)%P)%P;\n\t  }\n/*\tfor(i=1;i<=n;i++)\n\t{\n\t  for(j=1;j<=i;j++) cout<<f[i][j]<<\" \";\n\t  cout<<endl;\n\t}*/\n\tprintf(\"%d\\n\",f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 2010;\nconst int mod = 1e9 + 7;\n\nLL f[N][N], p[N * N];\n\nLL qpow(LL a, LL b)\n{\n\tLL ret = 1, base = a;\t\n\twhile (b) {\n\t\tif (b & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod, b >>= 1;\n\t}\n\treturn ret;\n}\n\nLL C(int a, int b) { return p[a] * qpow(p[b], mod - 2) % mod * qpow(p[a - b], mod - 2) % mod;}\n\nint main()\n{\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tif (k == 1){ printf(\"%d\\n\", n); return 0;}\n\tf[0][0] = p[0] = 1;\n\tRep(i, n * k) p[i] = p[i - 1] * i % mod;\n\tRep(i, n) Rep0(j, i) {\n\t\tf[i][j] = f[i - 1][j] * C(i * (k - 1) + j - 1, k - 2) % mod;\n\t\tf[i][j] = (f[i][j] + f[i][j - 1]) % mod;\n\t\t//printf(\"%d %d %lld\\n\", i, j, f[i][j]);\n\t}\n\t\n\tprintf(\"%lld\\n\", f[n][n] * p[n] % mod);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <unordered_map>\n#include <unordered_set>\n#include <tuple>\n#include <queue>\n\nusing namespace std;\n\n#define pb push_back\n#define pbk pop_back\n#define fs first\n#define sc second\n#define sz(s) ((int) (s).size())\n#define all(x) (x).begin(), (x).end()\n#define mt make_tuple\n#define mp make_pair\n#define next hunext\n#define prev huprev\n\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef long double ld;\n\nconst int inf = 1e9;\nconst double pi = 4 * atan(1.0);\nconst double eps = 1e-9;\nconst int N = 2020;\nconst int MOD = int(1e9) + 7;\n\nint n, k;\nint dp[N][N], f[N * N];\n\ninline int calc(int a, int b) {\n    int res = 1;\n    while (b > 0) {\n        if (b % 2 != 0) {\n            res = (1LL * res * a) % MOD;\n        }\n        a = (1LL * a * a) % MOD;\n        b /= 2;\n    }\n    return res;\n}\n\ninline int solve() {\n    if (k == 1) {\n        return 1;\n    }\n    memset(f, 0, sizeof(f));\n    f[k - 2] = 1;\n    for (int i = k - 1; i <= n * k; ++i) {\n        f[i] = (1LL * f[i - 1] * i) % MOD;\n        f[i] = (1LL * f[i] * calc(i - (k - 2), MOD - 2)) % MOD;\n    }\n    memset(dp, 0, sizeof(dp));\n    dp[n][n] = 1;\n    for (int zero = n; zero >= 0; --zero) {\n        for (int active = zero; active >= 0; --active) {\n            if (zero > 0 && zero - 1 >= active) {\n                dp[zero - 1][active] = (dp[zero - 1][active] + dp[zero][active]) % MOD;\n            }\n            if (active > 0) {\n                int cur = (1LL * dp[zero][active] * (n - active + 1)) % MOD;\n                int ind = (n - active + 1) * (k - 1) + (n - zero) - 1;\n                assert(ind >= k - 2 && ind <= n * k);\n                cur = (1LL * cur * f[ind]) % MOD;\n                dp[zero][active - 1] = (dp[zero][active - 1] + cur) % MOD;\n            }\n        }\n    }\n    return dp[0][0];\n}\n\nint main() {\n#ifdef LOCAL42\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    cin >> n >> k;\n    cout << solve() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\nusing namespace std;\n#define rg register\nvoid read(int &x){\n    char ch;bool ok;\n    for(ok=0,ch=getchar();!isdigit(ch);ch=getchar())if(ch=='-')ok=1;\n    for(x=0;isdigit(ch);x=x*10+ch-'0',ch=getchar());if(ok)x=-x;\n}\nconst int maxn=2010,mod=1e9+7,N=4e6;\nint n,m,f[maxn][maxn],fac[maxn*maxn],inv[maxn*maxn];\nint mul(int x,int y){return 1ll*x*y-1ll*x*y/mod*mod;}\nint add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\nint del(int x,int y){return x-y<0?x-y+mod:x-y;}\nint mi(int a,int b){int ans=1;while(b){if(b&1)ans=mul(ans,a);b>>=1,a=mul(a,a);}return ans;}\nvoid prepare(){\n    fac[0]=inv[0]=1;\n    for(rg int i=1;i<=N;i++)fac[i]=mul(fac[i-1],i);\n    inv[N]=mi(fac[N],mod-2);\n    for(rg int i=N-1;i;i--)inv[i]=mul(inv[i+1],i+1);\n}\nint C(int n,int m){return mul(fac[n],mul(inv[m],inv[n-m]));}\nint main(){\n    read(n),read(m),prepare();\n    for(rg int i=1;i<=n;i++){\n\tf[i][0]=1;\n\tfor(rg int j=1;j<=i;j++)\n\t    f[i][j]=add(f[i-1][j],mul(mul(f[i][j-1],n-j+1),C(n*m-(j-1)*(m-1)-i-1,m-2)));\n    }\n    printf(\"%d\\n\",f[n][n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\ntypedef long long LL;\nconst int maxn=2005,TT=1000000007;\nint n,K,fac[maxn*maxn],inv[maxn*maxn],F[maxn][maxn];\ninline int read()\n{\n\tint ret=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){ret=ret*10+ch-'0';ch=getchar();}\n\treturn ret*f;\n}\ninline int QP(int a,int b)\n{\n\tint ret=1,w=a;\n\twhile(b)\n\t{\n\t\tif(b&1) ret=(LL)ret*w%TT;\n\t\tw=(LL)w*w%TT;b>>=1;\n\t}\n\treturn ret;\n}\ninline int C(int n,int m){return (LL)fac[n]*inv[m]%TT*inv[n-m]%TT;}\nint main()\n{\n\tn=read();K=read();fac[0]=1;\n\tfor(int i=1;i<=4000000;i++) fac[i]=(LL)fac[i-1]*i%TT;\n\tinv[4000000]=QP(fac[4000000],TT-2);\n\tfor(int i=4000000-1;i>=0;i--) inv[i]=(LL)inv[i+1]*(i+1)%TT;\n\tif(K==1)\n\t{\n\t\tprintf(\"%d\\n\",1);\n\t\treturn 0;\n\t}\n\tF[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t\tF[i][j]=(F[i-1][j]+(j?((LL)F[i][j-1]*(n-j+1)%TT*C(n*K-i-(j-1)*(K-1)-1,K-2)%TT):0))%TT;\n\tprintf(\"%d\\n\",F[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n \n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n \nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n \nconst ll M = 1000000007;\n \nll modpow(ll x,ll k){\n\tif(k == 0)return 1;\n\tll ret = modpow(x,k/2);\n\tret *= ret; if(ret >= M)ret %= M;\n\tif(k%2 == 1){ ret *= x; if(ret >= M)ret %= M ; }\n\treturn ret;\n}\nll inv(ll x){\n\treturn modpow(x,M-2);\n}\n \nll f[4000010];\nvoid init(int k){\n\tf[k-2] = 1;\n\tfor(int i = k-2 ; i < 4000009 ; i ++){\n\t\tf[i+1] = f[i]*(i+1); f[i+1] %= M;\n\t\tf[i+1] *= inv(i+3-k); f[i+1] %= M;\n\t}\n}\n \nint main(){\n\tll n,k;\n\tcin >> n >> k;\n\tif(k == 1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tif(k == 2){\n\t\trep(i,4000010)f[i] = 1;\n\t}\n\t\n\tif(k != 2)init(k);\n\t\n\tstatic ll dp[2002][2002] = {};\n\tdp[0][0] = 1;\n\trep1(i,n){\n\t\tll sum = dp[i-1][i-1];\n\t\tfor(int j = i ; j <= n ; j ++){\n\t\t\tsum += dp[i-1][j];\n\t\t\tsum %= M;\n\t\t\tdp[i][j] = sum*f[(n-i)*k+i-j+k-2];\n\t\t\tdp[i][j] %= M;\n\t\t}\n\t}\n\trep1(i,n){\n\t\tdp[n][n] *= i;\n\t\tdp[n][n] %= M;\n\t}\n\tcout << dp[n][n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define mod 1000000007\n#define int long long\nint f[2010][2010],fac[4000100],inv[4000100],n,k;\nint quickpow(int x,int y){\n\tif(y==0)return 1;\n\tif(y%2==0)return quickpow(x*x%mod,y/2);\n\tif(y%2==1)return quickpow(x*x%mod,y/2)*x%mod;\n}\nint C(int x,int y){\n\tif(x<y||y<0)return 0;\n\tif(x==y||y==0)return 1;\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&k);\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\tfor(int i=1;i<=n*k;i++)\n\t\tfac[i]=fac[i-1]*i%mod;\n\tinv[n*k]=quickpow(fac[n*k],mod-2);\n\tfor(int i=n*k-1;i>=0;i--)\n\t\tinv[i]=inv[i+1]*(i+1)%mod;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i;j>=0;j--){\n            if(j)(f[i][j]+=f[i-1][j-1]*C(k*i-j-1,k-2)%mod)%=mod;\n            f[i][j]=(f[i][j]+f[i][j+1])%mod;\t\n\t\t}\n\tprintf(\"%lld\\n\",fac[n]*f[n][0]%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define MAX 2001\nusing namespace std;\nlong long N,K;\nlong long Inv[MAX*MAX];\nlong long Dp[MAX][MAX];\nlong long Factorial[MAX*MAX];\ninline long long Quick_Power(long long X,int P)\n{\n\tregister long long Return;\n\tReturn=1;\n\twhile(P)\n\t{\n\t\tif(P&1)\n\t\t{\n\t\t\tReturn=Return*X%MOD;\n\t\t}\n\t\tX=X*X%MOD;\n\t\tP>>=1;\n\t}\n\treturn Return;\n}\ninline long long Combination(long long A,long long B)\n{\n\treturn Factorial[A]*Inv[B]%MOD*Inv[A-B]%MOD; \n}\nint main(void)\n{\n\tregister long long i,j;\n\tcin>>N>>K;\n\tif(K==1)\n\t{\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tFactorial[0]=1;\n\tfor(i=1;i<=N*K;i++)\n\t{\n\t\tFactorial[i]=Factorial[i-1]*i%MOD;\n\t}\n\tInv[N*K]=Quick_Power(Factorial[N*K],MOD-2);\n\tfor(i=N*K-1;i>=0;i--)\n\t{\n\t\tInv[i]=Inv[i+1]*(i+1)%MOD;\n\t}\n\tDp[0][0]=1;\n\tfor(i=1;i<=N;i++)\n\t{\n\t\tfor(j=0;j<=i;j++)\n\t\t{\n\t\t\tif(!j)\n\t\t\t{\n\t\t\t\tDp[i][j]=Dp[i-1][j];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tDp[i][j]=Dp[i-1][j]+Dp[i][j-1]*(N-j+1)%MOD*Combination(N*K-i-1-(j-1)*(K-1),K-2)%MOD;\n\t\t}\n\t}\n\tcout<<Dp[N][N]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fo(i,s,t) for(int i = s; i <= t; ++ i)\n#define fd(i,s,t) for(int i = s; i >= t; -- i)\n#define bf(i,s) for(int i = head[s]; i; i = e[i].next)\n#define mp make_pair\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pb push_back\n#define VI vector<int>\n#define sf scanf\n#define pf printf\n#define fp freopen\n#define SZ(x) ((int)(x).size())\n#define MPS\ntypedef long long ll;\ntypedef double db;\ntypedef unsigned long long ull;\nconst int inf = 1<<30;\nconst ll INF = 1ll<<60;\nconst db Inf = 1e20;\nconst db eps = 1e-9;\n\nvoid gmax(int &a,int b){a = (a > b ? a : b);}\nvoid gmin(int &a,int b){a = (a < b ? a : b);}\n\nconst int maxn = 4000050;\nconst int maxm = 2005;\nconst int P = 1e9+7;\n\nint n, k, dp[maxm][maxm], fac[maxn], infr[maxn];\n\nll comb(int n,int m) {return 1ll*fac[n]*infr[m]%P*infr[n-m]%P;}\nint qpow(int a,int b) {int ans = 1; while(b) {if(b&1) ans = (ans*1ll*a)%P; b >>= 1; a = (a*1ll*a)%P;} return ans;}\nvoid upd(int &x,int y) {x += y; if(x > P) x -= P;}\nint main()\n{\n\t#ifdef MPS\n\t\tfp(\"agc02f.in\",\"r\",stdin);\n\t\tfp(\"agc02f.out\",\"w\",stdout);\n\t#endif\n\tsf(\"%d%d\",&n,&k);\n\tfac[0] = 1; fo(i,1,n*k) fac[i] = (fac[i-1]*1ll*i)%P;\n\tinfr[n*k] = qpow(fac[n*k],P-2);\n\tfd(i,n*k-1,0) infr[i] = infr[i+1]*1ll*(i+1)%P;\n\tif(k == 1) return 0*pf(\"1\\n\");\n\tdp[0][0] = 1;\n\tfo(i,0,n) fo(j,0,n)\n\t{\n\t\tif(i < j) upd(dp[i+1][j],dp[i][j]);\n\t\tif(j < n) dp[i][j+1] = (dp[i][j+1] + (1ll * dp[i][j] * comb(j*k-j+i+k-2,k-2)) % P) % P;\n\t}\n\tpf(\"%lld\\n\",(1ll*dp[n][n]*fac[n])%P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int maxn=2005;\nconst int ha=1000000007;\nint jc[maxn*maxn],ni[maxn*maxn];\nint n,k,f[maxn][maxn];\ninline int add(int x,int y)\n{\n\tx+=y;\n\treturn x>=ha?x-ha:x;\n}\ninline int ksm(int x,int y)\n{\n\tint an=1;\n\tfor(;y;y>>=1,x=x*(ll)x%ha) \n\tif(y&1) \n\tan=an*(ll)x%ha;\n\treturn an;\n}\ninline void init()\n{\n\tjc[0]=1;\n\tfor(int i=1;i<=4004000;i++) jc[i]=jc[i-1]*(ll)i%ha;\n\tni[4004000]=ksm(jc[4004000],ha-2);\n\tfor(int i=4004000;i;i--) ni[i-1]=ni[i]*(ll)i%ha;\n}\ninline int getC(int x,int y)\n{\n\treturn jc[x]*(ll)ni[y]%ha*(ll)ni[x-y]%ha;\n}\ninline void dp()\n{\n\tf[0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\t    for(int j=i;j>=0;j--) \n\t\tif(f[i][j])\n\t\t{\n\t    \tf[i+1][j+1]=add(f[i+1][j+1],f[i][j]*(ll)(n-i)%ha*(ll)getC(k*(i+1)-j-2,k-2)%ha);\n\t    \tif(j) \n\t\t\tf[i][j-1]=add(f[i][j-1],f[i][j]);\n\t\t}\n}\nint main(){\n\tinit();\n\tcin>>n>>k;\n\tif(k==1) \n\tcout<<\"1\";\n\telse{\n\t\tdp();\n\t\tcout<<f[n][0];\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int N=2005,M=N*N,mod=1e9+7;\nint upt(int x)\n{while(x>=mod)x-=mod;while(x<0)x+=mod;return x;}\nint pw(int x,int k)\n{int ret=1;while(k){if(k&1)ret=(ll)ret*x%mod;x=(ll)x*x%mod;k>>=1;}return ret;}\n\nint n,k,jc[M],jcn[M],dp[N][N];\nvoid init()\n{\n  int lm=n*k;\n  jc[0]=1;for(int i=1;i<=lm;i++)jc[i]=(ll)jc[i-1]*i%mod;\n  jcn[lm]=pw(jc[lm],mod-2);\n  for(int i=lm-1;i>=0;i--)jcn[i]=(ll)jcn[i+1]*(i+1)%mod;\n}\nint C(int n,int m)\n{\n  if(n<0||m<0||n<m)return 0;\n  return (ll)jc[n]*jcn[m]%mod*jcn[n-m]%mod;\n}\nint main()\n{\n  scanf(\"%d%d\",&n,&k); if(k==1){puts(\"1\");return 0;}\n  init();\n  dp[0][0]=1;\n  for(int i=0;i<=n;i++)\n    for(int j=0;j<=i;j++)\n      {\n\tif(!dp[i][j])continue;int tp=dp[i][j];\n\tif(i<n)dp[i+1][j]=upt(dp[i+1][j]+tp);\n\tif(j<i)\n\t  {\n\t    int ml=C((n-j)*(k-1)+n-i-1,k-2);\n\t    dp[i][j+1]=(dp[i][j+1]+(ll)ml*tp)%mod;\n\t  }\n      }\n  printf(\"%lld\\n\",(ll)dp[n][n]*jc[n]%mod);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define mod 1000000007\n#define maxn 2005\nint n,k,fact[maxn*maxn],inv[maxn*maxn],dp[maxn][maxn];\nvoid init()\n{\n\tfact[0]=1;\n\tfor(int i=1;i<=n*k;i++) fact[i]=1ll*fact[i-1]*i%mod;\n\tinv[1]=1;\n\tfor(int i=2;i<=n*k;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\tinv[0]=1;\n\tfor(int i=1;i<=n*k;i++) inv[i]=1ll*inv[i-1]*inv[i]%mod;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1) { printf(\"1\\n\"); return 0; }\n\tinit();\n\tdp[0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tif(i) dp[i][j]=(dp[i][j]+dp[i-1][j])%mod;\n\t\t\tif(j)\n\t\t\t{\n\t\t\t\tint x=n*k-i-(j-1)*(k-1)-1;\n\t\t\t\tdp[i][j]=(dp[i][j]+1ll*dp[i][j-1]*fact[x]%mod*inv[k-2]%mod*inv[x-k+2]%mod)%mod;\n\t\t\t}\n\t\t}\n\tint ans=1ll*dp[n][n]*fact[n]%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i, v.size()){ cout << v[i] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\ntemplate<typename T> void readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readv_m1(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; };\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; };\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; };\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; };\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nsigned main(){\n\n    int N, K; cin >> N >> K;\n    if(K == 1){\n        cout << 1 << endl;\n        return 0;\n    }\n    mmat dp(N + 1, mvec(N + 1, 0));\n    dp[0][0] = 1;\n    Combination C(N * K);\n    REP(i, N + 1) FOR(j, i, N + 1){\n        if(i > 0) dp[i][j] += dp[i - 1][j];\n        if(j > i){\n            int n = i + (K - 1) * (j - 1);\n            dp[i][j] += dp[i][j - 1] * C.nCr(n + K - 2, K - 2);\n        }\n    }\n    \n    //mdebug(dp);\n    mint ans = dp[N][N] * C.fact[N];\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define il inline\n#define re register\n\nusing namespace std;\nconst int N=2000+10,mod=1e9+7;\nil int rd()\n{\n  int x=0,w=1;char ch=0;\n  while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}\n  while(ch>='0'&&ch<='9') {x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}\n  if((x*=w)==-1) exit(0);\n  return x;\n}\nint n,kk,f[N][N],fac[N*N],iac[N*N];\nil int fpow(int a,int b){int an=1;while(b){if(b&1) an=1ll*an*a%mod;a=1ll*a*a%mod,b>>=1;}return an;}\nil int C(int n,int m){return m<0||n<m?0:1ll*fac[n]*iac[m]%mod*iac[n-m]%mod;}\n\nint main()\n{\n  n=rd(),kk=rd();\n  fac[0]=1;\n  for(int i=1;i<=n*kk;++i) fac[i]=1ll*fac[i-1]*i%mod;\n  iac[n*kk]=fpow(fac[n*kk],mod-2);\n  for(int i=n*kk;i;--i) iac[i-1]=1ll*iac[i]*i%mod;\n  f[0][0]=1;\n  for(int i=1;i<=n;++i)\n\tfor(int j=0;j<=i;++j)\n\t  f[i][j]=(f[i-1][j]+(j?(1ll*f[i][j-1]*(n-j+1)%mod*C(n-i+(n-j+1)*(kk-1)-1,kk-2)%mod):0))%mod;\n  printf(\"%d\\n\",kk>1?f[n][n]:1);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <fstream>\n#include <iostream>\n#include <functional>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\nusing namespace std;\n\ntypedef long long ll;\n#define eps 1e-10\n#define LL_INF 0x33ffffffffffffff\n#define INF 0x3f3f3f3f\n#define mem(a, b) memset(a, b, sizeof(a))\n#define pper(i,n,m) for(int i = n;i >= m; i--)\n#define repp(i, n, m) for (int i = n; i <= m; i++)\n#define rep(i, n, m) for (int i = n; i < m; i++)\n#define sa(n) scanf(\"%d\", &(n))\n#define mp make_pair\n#define ff first\n#define ss second\n#define pb push_back\n\nconst int maxn = 4e6 + 5;\nconst double PI = acos(-1.0);\nconst ll mod = 1e9 + 7;\nll po(ll a, ll b,ll mod) { ll res = 1; a %= mod; for (; b; b >>= 1) { if (b & 1)res = res*a%mod; a = a*a%mod; }return res; }\nll gcd(ll a,ll b){ if(a==0){return b;}else{ return gcd(b%a,a);}}\n\nll n,k;\nll fac[maxn],inv[maxn];\nll dp[2005][2005];\nll C(ll n,ll x)\n{\n\tif(n<0||x<0)\n\t{\n\t\treturn 0;\n\t}\n\treturn fac[n]*inv[x]%mod*inv[n-x]%mod;\n}\n\nvoid init()\n{\n\tfac[0]=1;\n\tinv[0]=1;\n\tll up = 4e6;\n\tfor(ll i=1;i <= up;i++)\n\t{\n\t\tfac[i]=fac[i-1]*i%mod;\n\t\tinv[i]=po(fac[i],mod-2,mod);\n\t}\n}\n\nll cal(ll i,ll j)\n{\n\tif(dp[i][j]!=-1)\n\t{\n\t\treturn dp[i][j];\n\t}\n\tll res=0;\n\tif(i==0&&j==0)\n\t{\n\t\treturn 1;\n\t}\n\tif(j > i)\n\t{\n\t\t//cout<<i<<\" \"<<j<<endl;\n\t\t//cout<<i+j*(k-1)-1<<\" \"<<k-2<<endl;\n\t\t//cout<<C(i+j*(k-1)-1,k-2)<<endl;\n\t\tres += C(i+j*(k-1)-1,k-2)*cal(i,j-1)%mod;\n\t}\n\tres%=mod;\n\tif(i)\n\t{\n\t\t//cout<<i-1<<\" \"<<j<<endl;\n\t\tres += cal(i-1,j);\n\t}\n\tres%=mod;\n\tdp[i][j]=res;\n\treturn res;\n}\n\nvoid solve()\n{\n\tmemset(dp,-1,sizeof(dp));\n\tcin>>n>>k;\n\tif(k==1)\n\t{\n\t\tcout<<1<<endl;\n\t\treturn;\n\t}\n\tll res= cal(n,n);\n\tfor(ll i=1;i<=n;i++)\n\t{\n\t\tres=res*i%mod;\n\t}\n\tcout<<res<<endl;\n}\nint main()\n{\n    init();\n    solve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nconst int N = 2e3 + 5;\nconst int mod = 1e9 + 7;\ntypedef long long LL;\n\nLL fastpow(LL a, LL b) {\n    if (!b) return 1;\n    LL t = fastpow(a, b / 2);\n    if (b & 1) return t * t % mod * a % mod;\n    else return t * t % mod;\n}\n\nLL fact[N * N], invf[N * N];\nvoid prework(int n) {\n    fact[0] = 1ll;\n    for (int i = 1; i <= n; i++)\n        fact[i] = fact[i - 1] * i % mod;\n    invf[n] = fastpow(fact[n], mod - 2ll);\n    for (int i = n - 1; ~i; i--)\n        invf[i] = invf[i + 1] * (i + 1) % mod;\n}\n\nLL comb(int n, int m) {\n    return fact[n]\n         * invf[m] % mod\n         * invf[n - m] % mod;\n}\n\nint k, n;\nLL f[N][N];\n\nsigned main() {\n    prework(4e6);\n    cin >> n >> k;\n\n    if (k == 1) {\n        cout << 1 << endl;\n        return 0;\n    }\n\n    for (int i = 0; i <= n; i++)\n        f[i][0] = 1ll;\n    \n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= i; j++) {\n            f[i][j] += (f[i][j - 1] * (n - j + 1) % mod\n                     * comb(n - i + (n - j + 1) * (k - 1) - 1, k - 2) % mod\n                     + f[i - 1][j]) % mod;\n        }\n    \n    cout << f[n][n] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mo=1000000007;\nconst int N=2005;\nint fac[N*N],inv[N*N];\nint n,k,m,f[N][N];\nint C(int x,int y){\n\treturn 1ll*fac[x]*inv[y]%mo*inv[x-y]%mo;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tm=n*k; fac[0]=inv[0]=inv[1]=1;\n\tfor (int i=2;i<=m;i++)\n\t\tinv[i]=1ll*(mo-mo/i)*inv[mo%i]%mo;\n\tfor (int i=1;i<=m;i++)\n\t\tfac[i]=1ll*fac[i-1]*i%mo,\n\t\tinv[i]=1ll*inv[i-1]*inv[i]%mo;\n\tif (k==1) return puts(\"1\"),0;\n\tf[0][0]=1; k-=2;\n\tfor (int i=0;i<=n;i++)\n\t\tfor (int j=0;j<=i;j++){\n\t\t\tif (i!=j)\n\t\t\t\tf[i][j+1]=(f[i][j+1]+1ll*C((n-i)+(n-j-1)+(n-j)*k,k)*f[i][j]%mo*(n-j))%mo;\n\t\t\tif (i<n) f[i+1][j]=(f[i+1][j]+f[i][j])%mo;\n\t\t}\n\tprintf(\"%d\\n\",f[n][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 2e3 + 6, MOD = 1e9 + 7;\nint n, k;\nint F[MAX_N * MAX_N];\nint D[MAX_N * MAX_N];\nint dp[MAX_N][MAX_N];\n\nint _sum(int a, int b) {\n\tint c = a + b;\n\tif (MOD <= c)\n\t\tc -= MOD;\n\n\treturn c;\n}\n\nint _mul(int a, int b) {\n\tint res = 1LL * a * b % MOD;\n\treturn res;\n}\n\nint _pow(int a, int b) {\n\tif (!b)\n\t\treturn 1;\n\n\tint res = _pow(a, b >> 1);\n\tres = _mul(res, res);\n\n\tif (b & 1)\n\t\tres = _mul(res, a);\n\n\treturn res;\n}\n\nint choose(int a, int b) {\n\tif (b < a || min(a, b) < 0)\n\t\treturn 0;\n\n\treturn _mul(F[b], _mul(D[a], D[b - a]));\n}\n\nvoid pre_process() {\n\tF[0] = 1;\n\tfor (int i = 1; i < MAX_N * MAX_N; i++)\n\t\tF[i] = _mul(F[i - 1], i);\n\n\tD[0] = 1;\n\tfor (int i = 1; i < MAX_N * MAX_N; i++)\n\t\tD[i] = _pow(F[i], MOD - 2);\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tpre_process();\n\tcin >> n >> k;\n\t\n\tif (k == 1) {\n\t\tcout << \"1\\n\";\n\t\treturn 0;\n\t}\n\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tdp[i][0] = 1;\n\t\tfor (int j = 1; j <= i; j++)\n\t\t\tdp[i][j] = _sum(_mul(dp[i][j - 1], choose(k - 2, n * k - i - (j - 1) * (k - 1) - 1)), dp[i - 1][j]);\n\t}\n\n\tcout << _mul(dp[n][n], F[n]) << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i, v.size()){ cout << v[i] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\ntemplate<typename T> void readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readv_m1(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; };\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; };\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; };\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; };\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nsigned main(){\n\n    int N, K; cin >> N >> K;\n    if(K == 1){\n        cout << 1 << endl;\n        return 0;\n    }\n    mmat dp(N + 1, mvec(K + 1, 0));\n    dp[0][0] = 1;\n    Combination C(N * K);\n    REP(i, N){\n        REP(j, i + 1){\n            int n = K * i - j;\n            dp[i + 1][j + 1] = dp[i][j] * C.nCr(n + K - 2, K - 2);\n        }\n        IREP(j, i + 1) dp[i + 1][j] += dp[i + 1][j + 1];\n    }\n    //mdebug(dp);\n    mint ans = dp[N][0] * C.fact[N];\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int md = 1e9 + 7;\nconst int N = 2005;\n\nint n, k;\nint fact[N * N];\nint inv[N * N];\nint f[N][N];\n\nvoid add(int &x, int y) { x += y; while(x >= md) x -= md; if (x < 0) x += md; }\n\nint pw(int a, int b) {\n\tint res = 1;\n\tfor(int i = 0; (1LL << i) <= b; ++i) {\n\t\tif (b & (1LL << i)) res = 1LL * res * a % md;\n\t\ta = 1LL * a * a % md;\n\t}\n\treturn res;\n}\n\nvoid prep() {\n\tfact[0] = 1; for(int i = 1; i < N * N; ++i) fact[i] = 1LL * fact[i-1] * i % md;\n\tfor(int i = 0; i < N * N; ++i) inv[i] = pw(fact[i], md - 2);\n}\n\nint nCk(int n, int k) {\n\tif (k > n || n < 0 || k < 0) return 0;\n\treturn 1LL * fact[n] * (1LL * inv[k] * inv[n - k] % md) % md;\t\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tprep();\n\tif (k == 1) return cout << 1 << endl, 0;\n\n\tf[0][0] = 1;\n\tfor(int i = 0; i <= n; ++i) for(int j = i; j <= n; ++j) {\n\t\tif(i == 0 && j == 0) continue;\n\t\tif(i > 0) f[i][j] = f[i - 1][j];\n\t\tif(j > 0) add(f[i][j], 1LL * f[i][j - 1] * nCk(i - 1 + (k - 1) * j, k - 2) % md);\n\t}\n\n\tcout << 1LL * fact[n] * f[n][n] % md << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#define N 2010\n#define M 4000000\n#define P 1000000007\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n,k;\nll f[N][N],fac[N*N],inv[N*N];\n\ninline int C(int x,int y){\n  if(x<y) return 0;\n  return fac[x]*inv[y]%P*inv[x-y]%P;\n}\n\nint main(){\n  scanf(\"%d%d\",&n,&k);\n  if(k==1) return puts(\"1\"),0;\n  fac[0]=inv[0]=inv[1]=1;\n  for(int i=1;i<=M;i++) fac[i]=fac[i-1]*i%P;\n  for(int i=2;i<=M;i++) inv[i]=(P-P/i)*inv[P%i]%P;\n  for(int i=1;i<=M;i++) inv[i]=inv[i]*inv[i-1]%P;\n  f[0][0]=1;\n  for(int i=1;i<=n;i++)\n    for(int j=i;~j;j--){\n      f[i][j]=f[i][j+1]%P;\n      if(j) (f[i][j]+=f[i-1][j-1]*C(i*k-j-1,k-2))%=P;\n    }\n  printf(\"%lld\\n\",f[n][0]*fac[n]%P);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long LL;\n\nLL powmod(LL a, int n){\n\tif(n == 0) return 1;\n\tif(n % 2) return (a*powmod(a,n-1)) % MOD;\n\tLL c = powmod(a,n/2);\n\treturn (c*c) % MOD;\n}\nLL inv(LL a){\n\treturn powmod(a,MOD-2);\n}\nLL dp[2100][2100];\nLL fact[5000000];\nLL invfact[5000000];\nint main(){\n\tint n, k;\n\tcin >> n >> k;\n\tif(k == 1){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tfact[0] = 1;\n\tfor(LL i = 1; i < 5000000; i++) fact[i] = (i*fact[i-1]) % MOD;\n\n\tfor(LL i = 0; i < 5000000; i++) invfact[i] = inv(fact[i]);\n\n\tfor(int i = 0; i < 2100; i++) for(int j = 0; j < 2100; j++) dp[i][j] = 0;\n\tdp[0][0] = 1;\n\tfor(int a = 1; a <= n; a++){\n\t\tfor(int b = a; b >= 0; b--){\n\t\t\tLL r = 0;\n\t\t\tif(b > 0){\n\t\t\t\tr = (a*fact[a*k-b-1]) % MOD;\n\t\t\t\tr = (r*invfact[k-2]) % MOD;\n\t\t\t\tr = (r*invfact[a*k-b-1 - (k-2)]) % MOD;\n\t\t\t\tr = (r*dp[a-1][b-1]) % MOD;\n\t\t\t}\n\t\t\tr = (r + dp[a][b+1]) % MOD;\n\t\t\tdp[a][b] = r;\n\t\t}\n\t}\n\tcout << dp[n][0] % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define mset(x, y) memset(x, y, sizeof x)\n#define mcpy(x, y) memcpy(x, y, sizeof x)\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ninline int Read()\n{\n\tint x = 0, f = 1, c = getchar();\n\tfor (; !isdigit(c); c = getchar())\n\t\tif (c == '-')\n\t\t\tf = -1;\n\tfor (;  isdigit(c); c = getchar())\n\t\tx = x * 10 + c - '0';\n\treturn x * f;\n}\n\nconst int MAXN = 2005;\nconst int mod = 1e9 + 7;\n\nint n, m, fac[MAXN * MAXN], inv[MAXN * MAXN], f[MAXN][MAXN];\n\ninline int C(int x, int y) { return 1LL * fac[x] * inv[y] % mod * inv[x - y] % mod; }\n\ninline int F(int x, int y) { return C(y + x, x); }\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen(\"data.in\", \"r\", stdin);\n#endif\n\tn = Read(), m = Read(), fac[0] = fac[1] = inv[0] = inv[1] = 1;\n\tif (m == 1)\n\t\treturn puts(\"1\"), 0;\n\tfor (int i = 2; i <= n * m; i ++)\n\t\tfac[i] = 1LL * fac[i - 1] * i % mod, inv[i] = 1LL * (mod - mod / i) * inv[mod % i] % mod;\n\tfor (int i = 2; i <= n * m; i ++)\n\t\tinv[i] = 1LL * inv[i] * inv[i - 1] % mod;\n\tf[0][0] = 1;\n\tfor (int i = 0; i <= n; i ++)\n\t\tfor (int j = 0; j <= i; j ++)\n\t\t{\n\t\t\tif (j < i)\n\t\t\t\tf[i][j + 1] = (f[i][j] + f[i][j + 1]) % mod;\n\t\t\tif (i < n)\n\t\t\t\tf[i + 1][j] = (1LL * f[i][j] * F(j + i * (m - 1), m - 2) % mod * (n - i) + f[i + 1][j]) % mod;\n\t\t}\n\treturn printf(\"%d\\n\", f[n][n]), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=2005,mod=1e9+7;\nint n,k;\nint Fac[N*N],Inv[N*N],dp[N][N];\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=1LL*x*x%mod)\n\t\tif (y&1)\n\t\t\tans=1LL*ans*x%mod;\n\treturn ans;\n}\nint C(int n,int m){\n\tif (m<0||m>n)\n\t\treturn 0;\n\treturn 1LL*Fac[n]*Inv[m]%mod*Inv[n-m]%mod;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tif (k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor (int i=Fac[0]=1;i<=n*k;i++)\n\t\tFac[i]=1LL*Fac[i-1]*i%mod;\n\tInv[n*k]=Pow(Fac[n*k],mod-2);\n\tfor (int i=n*k-1;i>=0;i--)\n\t\tInv[i]=1LL*Inv[i+1]*(i+1)%mod;\n\tdp[0][0]=1;\n\tfor (int i=0;i<=n;i++)\n\t\tfor (int j=i;j<=n;j++){\n\t\t\tdp[i][j+1]=(dp[i][j+1]+dp[i][j])%mod;\n\t\t\tdp[i+1][j]=(1LL*dp[i][j]*C(k*(n-i)-(j-i)-1,k-2)+dp[i+1][j])%mod;\n\t\t}\n\tprintf(\"%lld\",1LL*dp[n][n]*Fac[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define MOD 1000000007\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nconst int MAXN = 2005;\nint f[MAXN][MAXN],n,k;\ninline int ksm(int x,int k)\n{\n\tint ret=1;\n\twhile(k){\n\t\tif(k&1)ret=(long long)ret*x%MOD;\n\t\tx=(long long)x*x%MOD;\n\t\tk>>=1;\n\t}\n\treturn ret;\n}\nint fac[MAXN*MAXN],inv[MAXN*MAXN];\ninline void init(int n)\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfac[i]=(long long)fac[i-1]*i%MOD;\n\tinv[n]=ksm(fac[n],MOD-2);\n\tinv[0]=1;\n\tfor(int i=n-1;i;--i)\n\t\tinv[i]=(long long)inv[i+1]*(i+1)%MOD;\n}\ninline int C(int n,int m)\n{\n\treturn (long long)fac[m]*inv[m-n]%MOD*inv[n]%MOD;\n}\ninline void add(int &x,int a)\n{\n\tx+=a;\n\tif(x>=MOD)x-=MOD;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1){puts(\"1\");return 0;}\n\tinit(n*k);\n\tf[0][0]=1;\n\tfor(int i=0;i<=n;++i)\n\t\tfor(int j=i;j<=n;++j){\n\t\t\tif(i>0)add(f[i][j],f[i-1][j]);\n\t\t\tif(i<j)add(f[i][j],(long long)f[i][j-1]*C(k-2,j*(k-1)-1+i)%MOD);\n\t\t}\n\tcout<<(long long)f[n][n]*fac[n]%MOD<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, x, y) for (int i = x; i <= y; i++)\nusing namespace std;\n\nconst int mod = 1e9 + 7, N = 2010;\ntypedef long long ll;\nll n, K, f[N][N], fac[N * N], inv[N * N];\n\nll quick_pow(ll a, ll b) {\n\tll ret = 1;\n\tfor (; b; b >>= 1) {\n\t\tif (b & 1) ret = ret * a % mod;\n\t\ta = a * a % mod;\n\t} return ret;\n}\n\nll C(ll n, ll m) {\n\tif (!m) return 1;\n\treturn fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\n\nint main() {\n\tcin >> n >> K;\n\t\n\tif (K == 1) {\n\t\tputs(\"1\"); return 0;\n\t}\n\t\n\tfac[0] = inv[0] = 1;\n\trep(i, 1, n * K) fac[i] = fac[i - 1] * i % mod;\n\tinv[n * K] = quick_pow(fac[n * K], mod - 2);\n\tfor (int i = n * K; i >= 1; i--) inv[i - 1] = inv[i] * i % mod;\n\t\n\tf[0][0] = 1;\n\trep(i, 1, n) {\n\t\trep(j, 0, i) {\n\t\t\tf[i][j] = f[i - 1][j];\n\t\t\tif (j)\n\t\t\t\tf[i][j] = (f[i][j] + f[i][j - 1] * (n - j + 1) % mod * C(n * K - i - (j - 1) * (K - 1) - 1, K - 2) % mod) % mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", f[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define maxn 4050005\n#define m 2005\n#define mod 1000000007\n#define ll long long\nusing namespace std;\nint n, k;\nll jc[maxn], bjc[maxn];\nll ksm(ll a, ll b) {\n   if (!b) return 1;\n   ll ns = ksm(a, b >> 1);\n   ns = ns * ns % mod;\n   if (b & 1) ns = ns * a % mod;\n   return ns;\n}\nll c(int a, int b) {\n\tif (a < b || b < 0) return 0;\n\treturn 1ll * jc[a] * bjc[b] % mod * bjc[a - b] % mod;\n}\nll dp[m][m];\nint main() {\n\tbjc[0] = jc[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t\tjc[i] = jc[i - 1] * i % mod;\n\tbjc[maxn - 1] = ksm(jc[maxn - 1], mod - 2);\n\tfor (int i = maxn - 2; i >= 0; i--)\n\t\tbjc[i] = bjc[i + 1] * (i + 1) % mod;\n//\tcout << bjc[0] << endl;\n\tcin >> n >> k;\n\tif (k == 1) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n//\tcout << \"!@#\" << endl;\n\tk--;\n\tll ans = jc[n];\n\tfor (int i = n; i >= 0; i--)\n\t\tfor (int j = i; j >= 0; j--) {\n\t\t\tif (j == n) dp[i][j] = 1;\n\t\t\telse {\n\t\t\t\tdp[i][j] = dp[i][j + 1];\n\t\t\t\tll nx = dp[i + 1][j];\n\t\t\t\tint tot = k * i + j + (k - 1);\n\t\t\t\tnx = nx * c(tot, k - 1) % mod;\n\t\t\t\tdp[i][j] = (dp[i][j] + nx) % mod;\n\t\t\t}\n\t//\t\tcout << i << ' ' << j << ' ' << dp[i][j] << endl;\n\t\t}\n\tans = ans * dp[0][0] % mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// In the name of Allah\n// #isart\n// age daste man bood ...\n#include <bits/stdc++.h>\n\n#define ll long long\n#define ld long double\n#define F first\n#define S second\n#define pb push_back\n#define pii pair<int, int>\n#define MP make_pair\n#define int long long\n\nusing namespace std;\n\nconst int MAXN = 2000 + 10, MAXM = 6e6 + 10, mod = 1e9 + 7;\nll dp[MAXN][MAXN]; \nll fact[MAXM], fact1[MAXM];\n\nll power(int x, int y){\n\tif(y == 0) return 1;\n\tll mid = power(x, y / 2);\n\tif(y & 1) return 1ll * mid * mid % mod * x % mod;\n\telse return mid * mid % mod; \n}\n\nll choose(int x, int y){\n\tif(x == y) return 1;\n\treturn fact[x] * fact1[y] % mod * fact1[x - y] % mod;\n}\n\nmain(){\n\tios::sync_with_stdio(false); cin.tie(0);\n\tint n, k;\n\tcin >> n >> k; k --;\n\tif(k == 0) return cout << 1, 0;\n\tfact[0] = 1;\n\tfor(int i = 1; i < MAXM; i ++) fact[i] = 1ll * fact[i - 1] * i % mod;\n\tfact1[MAXM - 1] = power(fact[MAXM - 1], mod - 2);\n\tfor(int i = MAXM - 2; i > -1; i --) fact1[i] = 1ll * fact1[i + 1] * (i + 1) % mod;\t\n\tdp[0][0] = 1;\n\tfor(int i = 0; i <= n; i ++){\n\t\tfor(int j = 0; j <= n; j ++){\n\t\t\tif(i == 0 and j == 0) continue;\n\t\t\tif(i > j) continue;\n\t\t\tif(i <= j - 1)\n\t\t\t\tdp[i][j] = (dp[i][j] + 1ll * j * choose(i + k * (j - 1) + k - 1, k - 1) % mod * dp[i][j - 1] % mod) % mod;\n\t\t\tif(i > 0) dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod;\n\t\t}\n\t}\n\tcout << dp[n][n];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nconst long long mod = 1000000007;\nint N,K; long long D[2002][2002],inv[4004004]={0,1},fact[4004004]={1,1},ifact[4004004]={1,1};\n\nlong long comb(int n, int k)\n{\n\treturn fact[n] * ifact[k] % mod * ifact[n-k] % mod;\n}\n\nint main()\n{\n\tscanf (\"%d %d\",&N,&K);\n\tif (K == 1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\n\tfor (int i=2;i<N*K;i++){\n\t\tinv[i] = (mod - mod / i) * inv[mod % i] % mod;\n\t\tfact[i] = fact[i-1] * i % mod;\n\t\tifact[i] = ifact[i-1] * inv[i] % mod;\n\t}\n\n\tD[0][0] = 1;\n\tfor (int i=0;i<=N;i++) for (int j=0;j<=i;j++){\n\t\tif (i + 1 <= N) D[i+1][j] = (D[i+1][j] + D[i][j]) % mod;\n\t\tif (j + 1 <= N) D[i][j+1] = (D[i][j+1] + D[i][j] * comb(N*K-i-j*(K-1)-1,K-2)) % mod;\n\t}\n\n\tprintf (\"%lld\\n\",D[N][N]*fact[N]%mod);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7;\ninline int add(int a,int b){a+=b;return a>=mod?a-mod:a;}\ninline int sub(int a,int b){a-=b;return a<0?a+mod:a;}\ninline int mul(int a,int b){return (ll)a*b%mod;}\ninline int qpow(int a,int b){int ret=1;for(;b;b>>=1,a=mul(a,a))if(b&1)ret=mul(ret,a);return ret;}\n/* math */\n\n\nint n,k;\nconst int N=2e3+5;\nint fac[N*N],ifac[N*N];\ninline void init(int n){\n\tfac[0]=ifac[0]=1;for(int i=1;i<=n;i++)fac[i]=mul(fac[i-1],i);\n\tifac[n]=qpow(fac[n],mod-2);for(int i=n-1;i;i--)ifac[i]=mul(ifac[i+1],i+1);\n}\ninline int comb(int a,int b){\n\tif(b>a)return 0;\n\treturn mul(fac[a],mul(ifac[b],ifac[a-b]));\n}\nint f[N][N];\nint main()\n{\n\tcin>>n>>k;\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tinit(n*k);\n\tf[0][0]=1;\n\tfor(int j=1;j<=n;j++){\n\t\tf[0][j]=mul(f[0][j-1],comb(j*(k-1)-1,k-2));\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i;j<=n;j++){\n\t\t\tf[i][j]=add(f[i-1][j],mul(f[i][j-1],comb(j*(k-1)+i-1,k-2)));\n\t\t}\n\t}\n\tprintf(\"%d\\n\",mul(f[n][n],fac[n]));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<cmath>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<ctype.h>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<math.h>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<stdio.h>\n#include<stdlib.h>\n#include<streambuf>\n#include<string.h>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\nusing namespace std;\ntypedef long long LL;\nconst int MD=1000000007;\nint fac[4000010],inv[4000010],ti[4000010];\ninline int pwr(int a,int x){\n\tint cur=1,res=1;\n\twhile(x){\n\t\tif (x&cur){\n\t\t\tres=1ll*res*a%MD;\n\t\t\tx^=cur;\n\t\t}\n\t\ta=1ll*a*a%MD;\n\t\tcur<<=1;\n\t}\n\treturn res;\n}\ninline int comb(int m,int n){\n\tif (n<m) return 0;\n\tif (n==m||!m) return 1;\n\treturn 1ll*fac[n]*inv[m]%MD*inv[n-m]%MD;\n}\ninline void add(int &a,int b){\n\ta+=b;\n\tif (a>=MD) a-=MD;\n}\nint dp[2010][2010];\nint main(void){\n\tfac[1]=inv[1]=ti[1]=1;\n\tfor (int i=2;i<=4000000;++i){\n\t\tfac[i]=1ll*fac[i-1]*i%MD;\n\t\tti[i]=-1ll*(MD/i)*(ti[MD%i])%MD;\n\t\tif (ti[i]<0) ti[i]+=MD;\n\t\tinv[i]=1ll*inv[i-1]*ti[i]%MD;\n\t}\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tif (m==1){\n\t\tputchar('1');\n\t\treturn 0;\n\t}\n\tdp[1][0]=1;\n\tfor (int i=1;i<=n;++i){\n\t\tfor (int j=0;j<=i;++j){\n\t\t\tint lftspc=n*m-i-j*(m-1)-1;\n\t\t\tif (j!=i) add(dp[i][j+1],1ll*dp[i][j]*comb(m-2,lftspc)%MD);\n\t\t\tif (i!=n) add(dp[i+1][j],dp[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",1ll*dp[n][n]*fac[n]%MD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\nusing namespace std;\n#define ll long long\n#define pb(x) push_back(x)\n#define mp(a,b) make_pair(a,b)\n#define fi first\n#define se second\n#define pr(x) cerr<<#x<<\"=\"<<(x)<<endl\n#define pri(x,lo) {cerr<<#x<<\"={\";for (ll ol=0;ol<=lo;ol++)cerr<<x[ol]<<\",\";cerr<<\"}\"<<endl;}\n#define inf 100000000\n#define N 3000\n#define md 1000000007\nll n,k,dp[N][N],i,j,fac[10010000];\nvoid exgcd(ll a,ll b,ll &x,ll &y)\n{\n\tif (b==0) {x=1,y=0;return ;}\n\texgcd(b,a%b,x,y);\n\tll t=x;\n\tx=y;\n\ty=t-(a/b)*y;\n}\nll inv(ll a)\n{\n\tll x=0,y=0;\n\texgcd(a,md,x,y);\n\tx=((x%md)+md)%md;\n\treturn x;\n}\nll C(ll n,ll m)\n{\n\treturn fac[n]*inv(fac[m])%md*inv(fac[n-m])%md;\n}\nint main()\n{\n\tscanf(\"%lld %lld\",&n,&k);\n\tif (k==1) {printf(\"1\\n\");return 0;}\n\t//pr(inv(1));\n\tfac[0]=1;for (i=1;i<=10000000;i++) fac[i]=(fac[i-1]*i)%md;\n\t/*for (i=0;i<=10;i++) \n\t{\n\t\tfor (j=0;j<=i;j++)\n\t\tprintf(\"%lld \",C(i,j));\n\t\tcout<<endl;\n\t}*/\n\tdp[0][0]=1;\n\tfor (i=0;i<=n;i++)\t\n\t{\n\t\tfor (j=i;j<=n;j++)\n\t\t{\n\t\t\tif (j==0) continue;\n\t\t\tif (i!=0) dp[i][j]=dp[i-1][j];\n\t\t\tif (i!=j) dp[i][j]=(dp[i][j]+C(j*(k-1)+i-1,k-2)*dp[i][j-1]%md)%md;\n\t\t\t//printf(\"dp[%d][%d]=%d\\n\",i,j,dp[i][j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n][n]*fac[n]%md);\n}"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int P = 1e9 + 7 , N = 2002 , M = N * N;\ninline void pp(int &x,int d) {if((x+=d)>=P)x-=P;}\nint n , K , fac[M] , ifac[M];\nint f[N][N];\ninline int comb(int a,int b) {\n  return ll(fac[a])*ifac[b]%P*ifac[a-b]%P;\n}\n\nint main(){\n  cin >> n >> K;\n  int tot = n * K;\n  if(K == 1) {\n    cout << 1 << endl;\n    return 0;\n  }\n  rep(i,0,tot+1) fac[i]=i?ll(fac[i-1])*i%P:1;\n  rep(i,0,tot+1) ifac[i]=i<2?1:P-ll(P/i)*ifac[P%i]%P;\n  rep(i,1,tot+1) ifac[i]=ll(ifac[i-1])*ifac[i]%P;\n  rep(i,0,n+1) rep(j,i,n+1) {\n    if(i == 0 && j == 0) {\n      f[i][j] = 1;\n      continue;\n    }\n    if(i) f[i][j] = f[i-1][j];\n    if(j > i) pp(f[i][j] , ll(f[i][j-1]) *\n        comb(i + j * (K - 1) - 1 , K - 2) % P);\n  }\n  cout << ll(f[n][n]) * fac[n] % P << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define ll long long\n#define mod 1000000007\n#define N 2005\n#define M 4000005\nvoid Add(int &x,int y)\n{\n\tx += y;\n\tif (x >= mod)\n\t\tx -= mod;\n}\nint n, k, m, f[N][N];\nint fac[M], inv[M];\nint C(int n, int m){return (ll)fac[n] * inv[m] % mod * inv[n - m] % mod;}\nint Pow(int a, int k)\n{\n\tint ret = 1;\n\twhile (k)\n\t{\n\t\tif (k & 1)\n\t\t\tret = (ll)ret * a % mod;\n\t\ta = (ll)a * a % mod;\n\t\tk >>= 1;\n\t}\n\treturn ret;\n}\nint main()\n{\n\tscanf(\"%d%d\", &n, &k);\n\tm = n * k;\n\tif (k == 1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0] = 1;\n\tfor (int i = 1; i <= m; i++)\n\t\tfac[i] = (ll)fac[i - 1] * i % mod;\n\tinv[m] = Pow(fac[m], mod - 2);\n\tfor (int i = m; i >= 1; i--)\n\t\tinv[i - 1] = (ll)inv[i] * i % mod;\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 0; j <= i; j++)\n\t\t{\n\t\t\tAdd(f[i][j], f[i - 1][j]);\n\t\t\tif(j)\n\t\t\t\tAdd(f[i][j], (ll)f[i][j - 1] * (n - j + 1) % mod * C((n - i) + (n - j + 1) * (k - 1) - 1, k - 2) % mod);\n\t\t}\n\tprintf(\"%d\\n\", f[n][n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint f[2001][2001],n,k,invmul[4000001],_mul[4000001];\nconst int P=1000000007;\ninline int mul(const int &a,const int &b){return 1ll*a*b%P;}\ninline int add(int a,const int &b){a+=b;return(a>=P)?a-P:a;}\ninline int sub(int a,const int &b){a-=b;return (a<0)?a+P:a;}\ninline int C(const int &n,const int &m){return mul(mul(_mul[n],invmul[m]),invmul[n-m]);}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\t_mul[0]=_mul[1]=invmul[0]=invmul[1]=1;\n\tfor(int i=2;i<=n*k;i++)_mul[i]=mul(_mul[i-1],i);\n\tfor(int i=2;i<=n*k;i++)invmul[i]=mul(P-P/i,invmul[P%i]);\n\tfor(int i=2;i<=n*k;i++)invmul[i]=mul(invmul[i-1],invmul[i]);\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tf[i][j]=add((j<i)?f[i-1][j]:0,mul(f[i][j-1],C(n*k-i-(j-1)*(k-1)-1,k-2)));\n\t}\n\tprintf(\"%d \",mul(f[n][n],_mul[n]));\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include<bits/stdc++.h>\nconst int MN=2000+5;\nconst int P=1000000007;\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T>inline T&IN(T&in){\n\tin=0;char c=getchar();int f=1;\n\twhile(!isdigit(c)){if(c=='-')f=-1;c=getchar();}\n\twhile(isdigit(c))in=in*10+c-'0',c=getchar();\n\treturn in*=f;\n}\nint n,m;\nint inv[MN*MN],fac[MN*MN],f[MN][MN];\nint qp(int a,int b){int c=1;for(;b;b>>=1,a=(ll)a*a%P)if(b&1)c=(ll)c*a%P;return c;}\nint C(int n,int m){return (ll)fac[n]*inv[m]%P*inv[n-m]%P;}\nvoid input(){\n\tIN(n),IN(m);f[0][0]=fac[0]=1;\n\tif(m==1)return puts(\"1\"),void();\n\tfor(int i=1;i<=MN*MN-1;++i)fac[i]=(ll)fac[i-1]*i%P;\n\tinv[MN*MN-1]=qp(fac[MN*MN-1],P-2);\n\tfor(int i=MN*MN-1;i>=1;--i)inv[i-1]=(ll)inv[i]*i%P;\n\tfor(int i=1;i<=n;++i){\n\t\tf[i][0]=(ll)f[i-1][0]*C(i*m-i-1,m-2)%P;\n\t\tfor(int j=1;j<=i;++j){\n\t\t\tf[i][j]=((ll)f[i][j-1]+(ll)f[i-1][j]*C(i*m+j-i-1,m-2)%P)%P;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",(ll)f[n][n]*fac[n]%P);\n}\nint main(){\n\tinput();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int MAXN=2010;\nconst int MOD=1e9+7;\nint n,k;\nlong long fac[MAXN*MAXN],inv[MAXN*MAXN],f[MAXN][MAXN];\nlong long C(long long x,long long y)\n{\n\treturn fac[x]*inv[y]%MOD*inv[x-y]%MOD;\n}\nlong long qpow(long long x,long long y)\n{\n\tlong long tmp=1;\n\tfor(;y;y>>=1,x=x*x%MOD)if(y&1)tmp=tmp*x%MOD;\n\treturn tmp;\n}\nint main()\n{\n//\tfreopen(\"test.in\",\"r\",stdin);\n//\tfreopen(\"test.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1)\n\t{\n\t\tprintf(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\tfor(int i=1;i<=n*k;i++)fac[i]=fac[i-1]*i%MOD;\n\tinv[n*k]=qpow(fac[n*k],MOD-2);\n\tfor(int i=n*k;i>=1;i--)inv[i-1]=inv[i]*i%MOD;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(!j)continue;\n\t\t\tf[i][j]=(f[i][j]+f[i][j-1]*(n-j+1)%MOD*C(n-i+(n-j+1)*(k-1)-1,k-2))%MOD;\n\t\t}\n\tprintf(\"%lld\\n\",f[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2000;\nconst int mod = 1e9+7;\nint n, k, dp[maxn+10][maxn+10], sum[maxn*maxn+10];\nint powe(int base, int p) {\n\tint res = 1;\n\tfor (; p; p >>= 1, base = 1ll*base*base%mod)\n\t\tif (p&1) res = 1ll*res*base%mod;\n\treturn res;\n}\nint C(int n, int m) {\n\tint k = 1ll*sum[m]*sum[n-m]%mod;\n\treturn 1ll*sum[n]*powe(k, mod-2)%mod;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tsum[0] = 1;\n\tfor (int i = 1; i <= n*k; ++i) \n\t\tsum[i] = 1ll*sum[i-1]*i%mod;\n\tif (k == 1) {\n\t\tprintf(\"%d\\n\", 1); return 0;\n\t}\n\tfor (int i = 0; i <= n; ++i)\n\t\tdp[i][0] = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= i; ++j)\n\t\t\tdp[i][j] = (dp[i-1][j]+1ll*dp[i][j-1]*C(n*k-i-(j-1)*(k-1)-1, k-2))%mod;\n\tprintf(\"%d\\n\", 1ll*dp[n][n]*sum[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N = 4e6 + 5;\nconst int mod = 1e9 + 7;\nusing namespace std;\n\nint n, k, f[N], dp[2005][2005], sum[2005][2005], inv[N], ans;\n\nint C(int k, int n){\n    if (k < 0 || k > n) return 0;\n    return 1LL * f[n] * inv[k] % mod * inv[n-k] % mod;\n}\n\nint po(int n, int k){\n    int ans = 1;\n    while (k){\n        if (k&1) ans = 1LL * ans * n % mod;\n        n = 1LL * n * n % mod;\n        k >>= 1;\n    }\n    return ans;\n}\n\nvoid add(int& a, int b){\n    a += b; if (a >= mod) a -= mod;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    f[0] = 1;\n    for (int i = 1; i < N; i++) f[i] = 1LL * f[i-1] * i % mod;\n    inv[N-1] = po(f[N-1], mod-2);\n    for (int i = N-2; i >= 0; i--) inv[i] = 1LL * inv[i+1] * (i+1) % mod;\n    cin >> n >> k;\n    if (k == 1) return cout << 1, 0;\n    dp[1][1] = 1; sum[1][1] = sum[1][0] = 1;\n    for (int i = 2; i <= n; i++) {\n        for (int j = i; j >= 1; j--){\n            add(dp[i][j], 1LL * sum[i-1][j-1] * C(k-2, i*k-j-1) % mod * i % mod);\n        }\n        for (int j = n; j >= 0; j--) sum[i][j] = sum[i][j+1], add(sum[i][j], dp[i][j]);\n    }\n    for (int i = 1; i <= n; i++) add(ans, dp[n][i]);\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 2002\n#define MOD 1000000007\n\nlong long int dp[MAX][MAX];\n\n#define MOD 1000000007\nclass Combination{\n\tlong long int ppow(long long int i, long long int j){\n\t\tlong long int res = 1LL;\n\t\twhile (j){\n\t\t\tif ((j & 1LL)){\n\t\t\t\tres *= i;\n\t\t\t\tif (res >= MOD){\n\t\t\t\t\tres %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj >>= 1;\n\t\t\ti *= i;\n\t\t\tif (i >= MOD){\n\t\t\t\ti %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\npublic:\n\tvector<long long int> k;\n\tvector<long long int> r;\n\tvoid resize(int N){\n\t\tk.resize(N + 2);\n\t\tr.resize(N + 2);\n\t\tk[0] = 1;\n\t\tfor (int i = 1; i < k.size(); i++){\n\t\t\tk[i] = k[i - 1];\n\t\t\tk[i] *= i;\n\t\t\tif (k[i] >= MOD)k[i] %= MOD;\n\t\t}\n\t\tfor (int i = 0; i < r.size(); i++){\n\t\t\tr[i] = ppow(k[i], MOD - 2);\n\t\t}\n\t}\n\tlong long int C(int a, int b){\n\t\tif (a < b)return 0;\n\t\twhile (k.size() <= a){\n\t\t\tk.push_back((k.back()*(long long int)(k.size())) % MOD);\n\t\t}\n\t\tlong long int up = k[a];\n\t\tlong long int dw = r[b] * r[a - b];\n\t\tdw %= MOD;\n\t\tup *= dw;\n\t\tup %= MOD;\n\t\treturn up;\n\t}\n\tlong long int H(int a, int b){\n\t\treturn C(a + b - 1, b);\n\t}\n\tlong long int catalan_number(int n){\n\t\treturn (C(2 * n, n) + MOD - C(2 * n, n - 1)) % MOD;\n\t}\n};\n\n\nCombination C;\nint main(){\n\tint n;\n\tint k;\n\tcin >> n >> k;\n\tC.resize(2002*2002);\n\tdp[0][0] = 1;\n\tif (k == 1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i <= n; i++){\n\t\tfor (int j = 0; j <= n; j++){\n\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\tif (dp[i + 1][j] >= MOD){\n\t\t\t\tdp[i + 1][j] %= MOD;\n\t\t\t}\n\t\t\tif (j + 1 <= i){\n\t\t\t\tdp[i][j + 1] += dp[i][j] * C.C(n*k-((k-2)*j+j+i+1), k-2);\n\t\t\t\tif (dp[i][j + 1] >= MOD){\n\t\t\t\t\tdp[i][j + 1] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long int ans = dp[n][n]*C.k[n];\n\tif (ans >= MOD)ans %= MOD;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i = 0; i < n; ++i)\nusing ll = long long;\n// auto mod int\nconst int mod = 1000000007;\nstruct mint {\n  ll x; // typedef long long ll;\n  mint(ll x=0):x((x%mod+mod)%mod){}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) {\n    if ((x += a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator-=(const mint a) {\n    if ((x += mod-a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator*=(const mint a) { (x *= a.x) %= mod; return *this;}\n  mint operator+(const mint a) const { return mint(*this) += a;}\n  mint operator-(const mint a) const { return mint(*this) -= a;}\n  mint operator*(const mint a) const { return mint(*this) *= a;}\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n\n  // for prime mod\n  mint inv() const { return pow(mod-2);}\n  mint& operator/=(const mint a) { return *this *= a.inv();}\n  mint operator/(const mint a) const { return mint(*this) /= a;}\n};\nistream& operator>>(istream& is, const mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\n// combination mod prime\nstruct combination {\n  vector<mint> fact, ifact;\n  combination(int n):fact(n+1),ifact(n+1) {\n    assert(n < mod);\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;\n    ifact[n] = fact[n].inv();\n    for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;\n  }\n  mint operator()(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return fact[n]*ifact[k]*ifact[n-k];\n  }\n};\nmint dp[2001][2001];\nint main() {\n   ios::sync_with_stdio(false);\n   cin.tie(0);\n   int n, k; cin >> n >> k;\n   if (k==1){\n      cout << 1 << endl;\n      return 0;\n   }\n   combination C(n*k);\n   dp[0][1] = 1;\n   rep(j,n-1)dp[0][j+2] = dp[0][j+1] * C((j+2)*(k-1)-1, k-2);\n   for (int i = 1; i <= n; i++)\n      for (int j = i; j <= n; j++)\n         dp[i][j] = dp[i-1][j] + dp[i][j-1]*C(i+j*(k-1)-1, k-2);\n   cout << dp[n][n]*C.fact[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define C(n,m) (1ll*ml[n]*ny[m]%mo*ny[(n)-(m)]%mo)\n#define cal(a,b) ((a+=b)%=mo)\nusing namespace std;\nconst int mo=1e9+7;\nint f[2050][2050],ml[4000050],ny[4000050];\nint fap(int a,int b){\n  int s=1;\n  while(b){\n    if (b&1) s=1ll*a*s%mo;\n    b>>=1,a=1ll*a*a%mo;\n  }\n  return s;\n}\nint main(){\n  int n,k; cin>>n>>k;\n  if (k==1) return puts(\"1\"),0;\n  ml[0]=ny[0]=1;\n  for (int i=1; i<=n*k; ++i) ml[i]=1ll*ml[i-1]*i%mo;\n  ny[n*k]=fap(ml[n*k],mo-2);\n  for (int i=n*k-1; i; --i) ny[i]=1ll*(i+1)*ny[i+1]%mo;\n  f[0][0]=1;\n  for (int i=0; i<n; ++i)\n    for (int j=0; j<=i; ++j){\n      cal(f[i+1][j],1ll*f[i][j]*C((i+1)*(k-1)+j-1,k-2)%mo);\n      if (j!=i) cal(f[i][j+1],f[i][j]);\n    }\n  for (int i=0; i<n; ++i) cal(f[n][i+1],f[n][i]);\n  for (int i=1; i<=n; ++i) f[n][n]=1ll*f[n][n]*i%mo;\n  cout<<f[n][n];\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=2005,mod=1e9+7;\nint n,k,f[N][N],fac[N*N],ifac[N*N];\nint Pow(int x,int k){\n\tint ret=1;\n\twhile(k){\n\t\tif(k&1)ret=(ll)ret*x%mod;\n\t\tk>>=1;x=(ll)x*x%mod;\n\t}\n\treturn ret;\n}\nint C(int n,int m){\n\tif(n<m)return 0;\n\treturn (ll)fac[n]*ifac[n-m]%mod*ifac[m]%mod;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfac[0]=1;\n\tfor(int i=1;i<=n*k;i++)fac[i]=(ll)fac[i-1]*i%mod;\n\tfor(int i=0;i<=n*k;i++)ifac[i]=Pow(fac[i],mod-2);\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tf[0][0]=1;\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=i;j<=n;j++){\n\t\t\tf[i+1][j]=(f[i+1][j]+f[i][j])%mod;\n\t\t\tf[i][j+1]=(f[i][j+1]+(ll)f[i][j]*C((k-1)*j+i+k-2,k-2))%mod;\n\t\t}\n\tcout<<(ll)f[n][n]*fac[n]%mod<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define L 2003\n#define N 4000006\n#define LL long long\n#define mod 1000000007\n#define rep(i,j,k) for(i=j;i<=k;++i)\n#define down(i,j,k) for(i=j;i>=k;--i)\nint n,m,i,j,k,s1,s2;\nint fac[N],inv[N],dp[L][L];\nint quick_mi(int a,int b){\n\tint sum=1;\n\tfor(;b;b>>=1,a=(a*1LL*a)%mod)\n\tif(b&1) sum=(sum*1LL*a)%mod;\n\treturn sum;\n}\nint C(int n,int m){\n\tif(m>n) return 0;\n\treturn (((fac[n]*1LL*inv[m])%mod)*1LL*inv[n-m])%mod;\n}\nint main(){\n// \tfreopen(\"in.txt\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tif(m==1) {printf(\"1\\n\"); return 0;}\n\tfac[0]=1; k=n*m;\n\trep(i,1,k) fac[i]=(fac[i-1]*1LL*i)%mod;\n\tinv[k]=quick_mi(fac[k],mod-2);\n\tdown(i,k-1,0) inv[i]=(inv[i+1]*1LL*(i+1))%mod;\n\tdp[0][0]=1;\n\trep(i,0,n)\n\t rep(j,i,n)\n\t if(i||j){\n\t \tif(i) dp[i][j]=dp[i-1][j];\n\t\tdp[i][j]+=(dp[i][j-1]*1LL*C(m-2+i+((j-1)*(m-1)),m-2))%mod;\n\t \tdp[i][j]%=mod;\n\t }\n\tint ans=(dp[n][n]*1LL*fac[n])%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int Mod=1e9+7;\nint fac[4110000],ifac[4110000],f[2100][2100],n,k;\n\nint pow(int x,int l){\n\tif(l==0)return 1;\n\tint t=pow(x,l/2);\n\tt=(ll)t*t%Mod;\n\tif(l&1)t=(ll)t*x%Mod;\n\treturn t;\n}\n\nint C(int x,int y){\n\treturn (ll)fac[x]*ifac[y]%Mod*ifac[x-y]%Mod;\n}\n\nint main(){\n\tscanf(\"%d %d\",&n,&k);\n\tfac[0]=1;for(int i=1;i<=4099999;i++)fac[i]=(ll)fac[i-1]*i%Mod;\n\tifac[4099999]=pow(fac[4099999],Mod-2);for(int i=4099998;i>=0;i--)ifac[i]=(ll)ifac[i+1]*(i+1)%Mod;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tf[0][i]=(ll)f[0][i-1]*C(0+i*(k-1)-1,k-2)%Mod;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i][i]=f[i-1][i];\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tf[i][j]=(f[i-1][j]+(ll)f[i][j-1]*C(i+j*(k-1)-1,k-2))%Mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(ll)f[n][n]*fac[n]%Mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,a[100010];\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;++i)scanf(\"%d\",a+i);\n    sort(a+1,a+n+1);\n    reverse(a+1,a+n+1);\n    for(int i=1;i<=n;++i){\n        if(i+1>a[i+1]){\n        \tint ans=0;\n            for(int j=i+1;a[j]==i;++j)ans^=1;\n            ans|=(a[i]-i)&1;\n            if(ans)puts(\"First\");\n            else puts(\"Second\");\n            return 0;\n            \n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst ll N=2005,mod=1e9+7;\nll jc[N*N],num[N*N],dp[N][N],n,k;\nll addd(ll x,ll y){\n\tx+=y;\n\treturn x%mod;\n}\nll ksm(ll y,ll x){\n\tll ans=1;\n\twhile(x>0){\n\t\tif(x&1)ans=(ans*y)%mod;\n\t\tx>>=1;\n\t\ty=(y*y)%mod;\n\t}\n\treturn ans;\n}\nll get(int x,int y){\n\treturn jc[x]*num[y]%mod*num[x-y]%mod;\n}\nint main(){\n\tint i,j;\n\tjc[0]=1;\n\tfor (i=1;i<=4000010;i++)jc[i]=jc[i-1]*i%mod;\n\tnum[4000010]=ksm(jc[4000010],mod-2);\n\tfor (i=4000010;i;i--)num[i-1]=num[i]*i%mod;\n\tscanf(\"%lld%lld\",&n,&k);\n\tif(k==1){\n\t\tputs(\"1\\n\");\n\t\treturn 0;\n\t}\n\tdp[0][0]=1;\n\tfor (i=0;i<=n;i++)\n\t\tfor (j=i;j>=0;j--)\n\t\t\tif(dp[i][j]){\n\t\t\t\tdp[i+1][j+1]=addd(dp[i+1][j+1],dp[i][j]*(n-i)%mod*get(k*(i+1)-j-2,k-2)%mod);\n\t\t\t\tif(j)dp[i][j-1]=addd(dp[i][j-1],dp[i][j]);\n\t\t\t}\n\tprintf(\"%lld\\n\",dp[n][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nconst int N=2005;\nconst int M=N*N;\nconst int mo=1e9+7;\nint n,k,m;\nlong long p[M],q[M],f[N][N];\nlong long ksm(long long x,int y)\n{\n\tlong long t=1;\n\tfor (;y;y>>=1)\n\t{\n\t\tif (y&1) t=t*x%mo;\n\t\tx=x*x%mo;\n\t}\n\treturn t;\n}\nlong long c(int x,int y){return p[x]*q[y]%mo*q[x-y]%mo;}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k),m=n*k;\n\tif (k==1){printf(\"1\");return 0;}\n\tp[0]=q[0]=1;\n\tfor (int i=1;i<=m;i++) p[i]=p[i-1]*i%mo;\n\tq[m]=ksm(p[m],mo-2);\n\tfor (int i=m-1;i;i--) q[i]=q[i+1]*(i+1)%mo;\n\tf[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=i;j>=0;j--)\n\t\t{\n\t\t\tf[i][j]=f[i][j+1];\n\t\t\tif (j) f[i][j]=(f[i][j]+f[i-1][j-1]*c(i*k-j-1,k-2))%mo;\n\t\t}\n\tprintf(\"%lld\",f[n][0]*p[n]%mo);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define il inline\n#define vd void\n#define mod 1000000007\ntypedef long long ll;\nil int gi(){\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)){\n\t\tif(ch=='-')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\nint f[2010][2010];\nint inv[4001000],C[4001000];\nint main(){\n\tint n=gi(),k=gi();\n\tif(k==1)return puts(\"1\"),0;\n\tinv[1]=1;for(int i=2;i<=n*k;++i)inv[i]=mod-1ll*(mod/i)*inv[mod%i]%mod;\n\tC[k-2]=1;\n\tfor(int i=k-1;i<=n*k;++i)C[i]=1ll*C[i-1]*inv[i-k+2]%mod*i%mod;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<=std::min(i,n);++j){\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(j)f[i][j]=(f[i][j]+1ll*C[(n-i)+(n-j+1)*(k-1)-1]*f[i][j-1]%mod*(n-j+1)%mod)%mod;\n\t\t\tprintf(\"%d %d %d\\n\",i,j,f[i][j]);\n\t\t}\n\tprintf(\"%d\\n\",f[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lf else if\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int p=1e9+7;\nconst int N=2000+19;\nconst int M=N*N;\n\nint Pow(int a,int b){\n\tint res=1;\n\tfor (;b;b>>=1,a=1ll*a*a%p) if (b&1) res=1ll*res*a%p;\n\treturn res;\n}\n\nint dp[2*N][N];\nint fac[M],inv[M];\nint n,k;\n\nint C(int n,int m){\n\treturn 1ll*fac[n]*inv[m]%p*inv[n-m]%p;\n}\nvoid upd(int &x,ll y){\n\tx=(x+y)%p;\n}\n\nint main(){\n\tfac[0]=1;\n\tFor(i,1,M) fac[i]=1ll*fac[i-1]*i%p;\n\tinv[M-1]=Pow(fac[M-1],p-2);\n\tfor (int i=M-1;i;i--) inv[i-1]=1ll*inv[i]*i%p;\n\tn=IN(),k=IN();\n\tif (k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tdp[0][0]=1;\n\tFor(i,0,2*n) For(j,0,n+1)\n\t\tif (dp[i][j]){\n\t\t\tif (i-j<j) upd(dp[i+1][j],dp[i][j]);\n\t\t\tif (j<n) upd(dp[i+1][j+1],1ll*dp[i][j]*C(j*(k-1)+k-2+i-j,k-2));\n\t\t}\n\tprintf(\"%d\\n\",1ll*dp[2*n][n]*fac[n]%p);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF=1000000000,mod=1e9+7;\nconst double eps = 1e-7;\n\nlong long f[2001][2001],c[5000000];\n\nlong long inv(long long a,long long m)\n{\n\tif(a==1)\n\t\treturn 1;\n\treturn inv(m%a,m)*(m-m/a)%m;\n}\n\nint main()\n{\n\t//freopen(\"input.txt\",\"r\",stdin);\n\tint t;\n\tint n,m,q;\n//\tcin>>t;\n//\twhile(t--)\n//\twhile(scanf(\"%d\",&n)!=EOF) \n\t{\n\t\tcin>>n>>m;\n\t\tf[0][0]=1;\n\t\tf[0][1]=1;\n\t\tc[m-2]=1;\n\t\tfor(int i=m-1;i<=n*m;i++)\n\t\t\tc[i]=c[i-1]*i%mod*inv(i-m+2,mod)%mod;\n\t\tfor(int i=2;i<=n;i++)\n\t\t\tf[0][i]=f[0][i-1]*c[i*(m-1)-1]%mod;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=i;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tf[i][j]=f[i-1][j];\n\t\t\t\telse\n\t\t\t\t\tf[i][j]=(f[i-1][j]+f[i][j-1]*c[i*m+(j-i)*(m-1)-1]%mod)%mod;\n\t\t\t}\n//\t\tfor(int i=1;i<=n;i++)\n//\t\t\tfor(int j=i;j<=n;j++)\n//\t\t\t\tcout<<i<<' '<<j<<' '<<f[i][j]<<endl;\n\t\tlong long ans=f[n][n];\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tans=ans*i%mod;\n\t\tcout<<ans<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 2002\n#define mod 1000000007\n#define ll long long\n\nll f[nn*nn],rf[nn*nn];\nll qpow(ll x,ll y)\n{\n\tll res=1;\n\twhile(y)\n\t{\n\t\tif(y&1) res=res*x%mod;\n\t\tx=x*x%mod;y=y/2;\n\t}\n\treturn res;\n}\nll c(ll x,ll y)\n{\n\tif(x>y)  return 0;\n\treturn f[y]*rf[x]%mod*rf[y-x]%mod;\n}\n\nll dp[nn][nn];ll n,k;\nint main()\n{\n\tf[0]=1;for(int i=1;i<nn*nn;i++) f[i]=f[i-1]*i%mod;\n\trf[nn*nn-1]=qpow(f[nn*nn-1],mod-2);\n\tfor(int i=nn*nn-2;i>=0;i--) rf[i]=rf[i+1]*(i+1)%mod;\n\n\tcin>>n>>k;k--;\n\tif(k==0)\n\t{\n\t\tcout<<1;\n\t\texit(0);\n\t}\n\tdp[0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\tdp[i+1][j]%=mod;\n\t\t\tdp[i][j+1]+=dp[i][j]*c(k-1,n*k+n-k*j-i-1);\n\t\t\tdp[i][j+1]%=mod;\n\t\t}\n\t}\n\t\n\tcout<<dp[n][n]*f[n]%mod;\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int MAXN = 2e3 + 10;\nconst int MOD = 1e9 + 7;\n \nlong long dp[MAXN][MAXN];\nlong long fac[MAXN * MAXN];\nint n, k;\n \n// asdjgfsadjkgfjksdgjfka\n// sadjkgfasjdgfjasdgfjgasdgfaskjdf\n// asdjgfajsdgfjasgdfgasdkjfgsadgfkjasdgfkjasdgfksadgf\n#define fsgdfjasgdfgsadkjfg asdkjgfkjsagdfsgadjfgasdkjfaksjdf\n#define hdgfhadfhasdhfgasjdgfjadgsjfkgsajdfgsadhjgfjksgadfj jsdgfjkasdgjfksgadkjfa\n#define hafsdhfashfh ashdfshgadfadsjhgfashgdfshgadfshadfjshgadfj\nint fsdgasdjkfjajksadgfkjags = 213213123;\nlong long fdashf = 13243543;\nlong long sdajdgjdfasfasfadsfsdafsadfasdfasdfadsf = 21232213;\n\n\nvoid wtf() {\n   cout << \"WTF !!\" << endl;\n}\n\nlong long po(long long v, long long u)\n{\n\treturn u ? (po(v * v % MOD, u >> 1) * (u & 1 ? v : 1) % MOD) : 1;\n}\n \nlong long ente(int i, int j)\n{\n\tlong long res = po(fac[i], MOD - 2) * po(fac[j - i], MOD - 2);\n\tres %= MOD;\n\tres *= fac[j];\n\treturn res % MOD;\n}\n \nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\nif (0 == 1)\nwtf();\n\tcin >> n >> k;\n\tfac[0] = 1;\n\tfor (int i = 1; i < MAXN * MAXN; i++)\n\t\tfac[i] = (fac[i - 1] * i) % MOD;\n\tif (k == 1)\n\t\treturn cout << 1 << '\\n', 0;\n\tdp[0][0] = 1;\n\tfor (int i = 0; i <= n; i++)\n\t{\n\t\tfor (int j = i; j <= n; j++)\n\t\t{\n\t\t\tif (i)\n\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\tif (j)\n\t\t\t\tdp[i][j] += dp[i][j - 1] * ente(k - 2, i + j * (k - 1) - 1);\n\t\t\tdp[i][j] %= MOD;\n\t\t}\n\t}\n\tdp[n][n] = (dp[n][n] * fac[n]) % MOD;\n\tcout << dp[n][n] << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm> \n#include<cstring>\n#define LL long long\nusing namespace std;\nconst int N=2e3+5;\nconst int mod=1e9+7;\nint n,m,fac[N*N],inv[N*N],f[N][N];\nint read()\n{\n\tint x=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}\n\treturn x*f;\n}\nvoid Mod(int& a,int b){a+=b;if(a>=mod)a-=mod;}\nint power(int a,int b)\n{\n\tint ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=1ll*ans*a%mod;\n\t\ta=1ll*a*a%mod;b>>=1;\n\t}\n\treturn ans;\n}\nint C(int n,int m){return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint main()\n{\n\tn=read();m=read();\n\tif(m==1){printf(\"1\");return 0;}\n\tfac[0]=1;\n\tfor(int i=1;i<=n*m;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[n*m]=power(fac[n*m],mod-2);\n\tfor(int i=n*m;i>=1;i--)inv[i-1]=1ll*inv[i]*i%mod;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(!j)continue;\n\t\t\tMod(f[i][j],1ll*f[i][j-1]*(n-j+1)%mod*C(n-i+(n-j+1)*(m-1)-1,m-2)%mod);\n\t\t}\n\tprintf(\"%d\",f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//In the name of Allah \n#include <bits/stdc++.h>\n\nusing namespace std; \n\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define int long long\n\nconst int N=5e6+200;\nconst int NN=2e3+100;\nconst int mod=1e9+7;\n\nint f[N],rev[N],dp[NN][NN];\n\nint tav(int n,int k){\n\tn%=mod; \n\tif(k==0)return 1; \n\tint ans=tav(n,k/2);\n\tans*=ans; \n\tans%=mod;\n\tif(k%2==1)ans*=n; \n\tans%=mod; \n\treturn ans;\n}\nint choose(int n,int k){\n\tint ans=(f[n]*rev[k])%mod; \n\tans*=rev[n-k];\n\tans%=mod; \n\treturn ans; \n}\n\nint32_t main(){\n\tios::sync_with_stdio(0);cin.tie(0);\t\n\tint n,k;\n\tcin>>n>>k;\n\tk--;\n\tif(k==0)return cout<<\"1\\n\",0;\n\tf[0]=1;\n\tfor(int i=1;i<N;i++)\n\t\tf[i]=(f[i-1]*i)%mod; \n\t\n\trev[N-1]=tav(f[N-1],mod-2);\n\tfor(int i=N-2;i>=0;i--)\n\t\trev[i]=(rev[i+1]*(i+1))%mod;\n\t\n\tdp[0][0]=1;\n\tfor(int i=1,sum;i<n;i++){\n\t\tsum=dp[i-1][i-1];\n\t\tdp[i][i]=(sum*choose(i*k+k-1,k-1))%mod;\n\t\tfor(int j=i-1;j>=0;j--){\n\t\t\tif(j!=0)sum+=dp[i-1][j-1];\n\t\t\tsum%=mod; \n\t\t\tdp[i][j]=(sum*choose(i*k+i-j+k-1,k-1))%mod;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<n;i++){\n\t\tans+=dp[n-1][i];\n\t\tans%=mod;\n\t}\n\tcout<<(ans*f[n])%mod<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD = 1000000007;\nconst int MAX_N = 2005;\n\nll sil[MAX_N * MAX_N], odw[MAX_N * MAX_N], DP[MAX_N][MAX_N];\n\nll pot(ll a, ll b) {\n    ll result = 1;\n\n    while(b > 0) {\n        if(b % 2 == 1) {\n            result = (result * a) % MOD;\n        }\n        a = (a * a) % MOD;\n        b /= 2;\n    }\n\n    return result;\n}\n\nll binom(int n, int k) {\n    ll result = sil[n];\n    result = (result * odw[k]) % MOD;\n    result = (result * odw[n - k]) % MOD;\n    return result;\n}\n\nint main() {\n    sil[0] = 1;\n    for(int i = 1; i < MAX_N * MAX_N; i++) {\n        sil[i] = (sil[i - 1] * i) % MOD;\n    }\n    odw[MAX_N * MAX_N - 1] = pot(sil[MAX_N * MAX_N - 1], MOD - 2);\n    for(int i = MAX_N * MAX_N - 2; i >= 1; i--) {\n        odw[i] = (odw[i + 1] * ll(i + 1)) % MOD;\n    }\n    odw[0] = odw[1];\n\n    int n, k;\n    \n    cin >> n >> k;\n    \n    if(k == 1) {\n        cout << 1;\n        return 0;\n    }\n    \n    for(int i = 0; i <= n; i++) {\n        for(int j = i; j <= n; j++) {\n            if(i == 0) {\n                if(j == 0) {\n                    DP[i][j] = 1;\n                } else {\n                    DP[i][j] = (DP[i][j - 1] * binom(j * (k - 1) - 1, k - 2)) % MOD;\n                }\n                continue;\n            }\n            DP[i][j] = DP[i - 1][j];\n            if(j > i) {\n                DP[i][j] += DP[i][j - 1] * binom(j * (k - 1) + i - 1, k - 2);\n                DP[i][j] %= MOD;\n            }\n        }\n    }\n\n    for(int i = 1; i <= n; i++) {\n        DP[n][n] = (DP[n][n] * i) % MOD;\n    }\n    \n    cout << DP[n][n];\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int md=1000000007;\nint n,K,i,j,f[2005][2005],jc[4000005],rjc[4000005],inv[4000005];\nint C(int n,int m)\n{\n\treturn 1ll*jc[n]*rjc[m]%md*rjc[n-m]%md;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&K);\n\tif(K==1)\n\t{\n\t\tprintf(\"1\");\n\t\treturn 0;\n\t}\n\tinv[1]=1;\n\tfor(i=2;i<=n*K;++i)\n\t\tinv[i]=1ll*inv[md%i]*(md-md/i)%md;\n\tjc[0]=rjc[0]=1;\n\tfor(i=1;i<=n*K;++i)\n\t{\n\t\tjc[i]=1ll*jc[i-1]*i%md;\n\t\trjc[i]=1ll*rjc[i-1]*inv[i]%md;\n\t}\n\tf[1][0]=1;\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=0;j<=i;++j)\n\t\t{\n\t\t\tif(i<n)\n\t\t\t\tf[i+1][j]=(f[i+1][j]+f[i][j])%md;\n\t\t\tif(j<i)\n\t\t\t\tf[i][j+1]=(f[i][j+1]+1ll*f[i][j]*(n-j)%md*C(n*K-i-j*(K-1)-1,K-2))%md;\n\t\t}\n\tprintf(\"%d\",f[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int mod = 1e9 + 7;\nconstexpr int maxn = 2000 + 7;\n\nlong long f[maxn][maxn];\nlong long step[maxn * maxn], inv[maxn * maxn];\n\nlong long C(int n, int m) {\n    return step[n] * inv[m] % mod * inv[n - m] % mod;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    if (k == 1) {\n        printf(\"1\\n\");\n        return 0;\n    }\n\n    long long ans = 1;\n    for (int i = 1; i <= n; i++) ans = ans * i % mod;\n\n    step[0] = 1;\n    for (int i = 1; i <= n * k; i++) step[i] = step[i - 1] * i % mod;\n\n    inv[0] = inv[1] = 1;\n    for (int i = 2; i <= n * k; i++) \n        inv[i] = mod - (mod / i) * inv[mod % i] % mod;\n    for (int i = 2; i <= n * k; i++) \n        inv[i] = inv[i  - 1] * inv[i] % mod;\n    \n    f[0][0] = 1;\n\n    for (int i = 0; i <= n; i++) \n    for (int j = i; j <= n; j++) {\n        long long &rt = f[i][j];\n\n        if (j > i) \n            rt = C((k - 1) * j + i - 1, k - 2) * f[i][j - 1] % mod;\n        if (i > 0) {\n            rt = (rt + f[i - 1][j]) % mod;\n        }\n    }\n\n    cout << ans * f[n][n] % mod << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std ;\n#define int unsigned long long\nconst int mxn = 8000005 ;\nconst int Mod = 1e9+7 ;\nint frac[mxn], inv[mxn];\nint f[2005][2005], n, k;\nint power(int a, int b){\n    int res=1, car=a; \n    while(b){\n        if(b&1) (res*=car)%=Mod;\n        (car*=car)%=Mod;\n        b>>=1;\n    }\n    return res;\n}\nvoid init(){\n    frac[0]=1 ;\n    for(int i=1;i<mxn;++i) (frac[i]=frac[i-1]*i)%=Mod ;\n    inv[mxn-1] = power(frac[mxn-1], Mod-2);\n    for(int i=mxn-2;i>0;--i) inv[i]=(inv[i+1]*(i+1))%Mod ;\n    inv[0] = 1 ;\n}\nint C(int n, int k){\n    return ((frac[n]*inv[k]%Mod)*inv[n-k])%Mod ;\n}\nsigned main(){\n    init() ;\n    cin>>n>>k;\n    if(k==1) return puts(\"1\"),0 ;\n    f[0][0] = 1 ;\n    for(int i=1;i<=n;++i)\n        for(int j=0;j<=i;++j)\n            (f[i][j] = f[i-1][j]+(j?((((f[i][j-1]*(n-j+1))%Mod)*C(n*k-i-(j-1)*(k-1)-1, k-2))%Mod):(0)))%=Mod ;\n    cout<<f[n][n]<<endl ;\n}"
  },
  {
    "language": "C++",
    "code": "    //Created Time:2019年12月23日 星期一 15时39分53秒\n    #include <iostream>\n    #include <cstdio>\n    #include <algorithm>\n    #include <cstring>\n    #define N 2005\n    #define mod 1000000007\n     \n    using namespace std;\n     \n    int n, k;\n    int f[N][N], fac[N * N], ifac[N * N], inv[N * N];\n     \n    int C(int ,int);\n     \n    int main(){\n    \tcin >> n >> k; fac[0] = ifac[0] = inv[1] = 1;\n    \tif (k == 1) { puts(\"1\"); return 0;}\n    \tfor (int i = 2; i <= n * k; ++i) inv[i] = mod - 1ll * mod / i * inv[mod % i] % mod;\n    \tfor (int i = 1; i <= n * k; ++i) fac[i] = 1ll * fac[i - 1] * i % mod, ifac[i] = 1ll * ifac[i - 1] * inv[i] % mod;\n    \tf[0][0] = 1; //f[i][j] 放了i个白色球和j种颜色球的方案\n    \tfor (int i = 1; i <= n; ++i)\n    \t\tfor (int j = 0; j <= i; ++j) {\n    \t\t\tf[i][j] = f[i - 1][j];\n    \t\t\tif(j) (f[i][j] += 1ll * C(n - i + (n - j + 1) * (k - 1) - 1, k - 2) * f[i][j - 1] % mod * (n - j + 1) % mod) %= mod;\n    \t\t}\n    \tcout << f[n][n] << endl;\n    \treturn 0;\n    }\n     \n    int C(int x, int y){\n    \treturn 1ll * fac[x] * ifac[y] % mod * ifac[x - y] % mod;\n    }"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define MOD 1000000007\n#define inf 0x3f3f3f3f3f3f3f3f\n#define pi acos(-1.0)\n#define ri register int\n#define Abs(x) ((x) < 0 ? (-(x)) : (x))\n#define int long long\nconst int maxn = 2e3 + 10;\ninline int Max(int a, int b) { return a > b ? a : b; }\ninline int Min(int a, int b) { return a > b ? b : a; }\nnamespace FastIO {\ninline int read()\n{\n    int f = 1, r = 0;\n    char c = getchar();\n    while (!isdigit(c)) {\n        if (c == '-') {\n            f = -1;\n        }\n        c = getchar();\n    }\n    while (isdigit(c)) {\n        r = 10 * r + c - '0';\n        c = getchar();\n    }\n    return f * r;\n}\ninline void write(int x)\n{\n    if (x < 0)\n        putchar('-'), x = -x;\n    if (x > 9)\n        write(x / 10);\n    putchar(x % 10 + '0');\n}\ninline void writesp(int x) { write(x), putchar(' '); }\ninline void writeln(int x) { write(x), puts(\"\"); }\n};\nusing namespace FastIO;\nint N, K, dp[maxn][maxn], fac[maxn * maxn], ifac[maxn * maxn];\ninline int exgcd(int a, int b, int& x, int& y)\n{\n    if (b == 0) {\n        x = 1, y = 0;\n        return a;\n    }\n    int d = exgcd(b, a % b, x, y);\n    int tmp = y;\n    y = x - a / b * y;\n    x = tmp;\n    return d;\n}\ninline int inv(int a, int b)\n{\n    int x, y;\n    exgcd(a, b, x, y);\n    return (x + MOD) % MOD;\n}\ninline int C(int m, int n)\n{\n    int tmp = (fac[m] * ifac[n] % MOD) * ifac[m - n] % MOD;\n    return tmp;\n}\nsigned main()\n{\n    //freopen(\"C:\\Users\\hjw\\Downloads\\testdata (4).in\", \"r\", stdin);\n    N = read(), K = read();\n    if (K == 1) {\n        puts(\"1\");\n        return 0;\n    }\n    fac[0] = 1, ifac[0] = inv(1, MOD);\n    for (ri i = 1; i <= N * K; ++i) {\n        fac[i] = fac[i - 1] * i % MOD;\n        ifac[i] = inv(fac[i], MOD);\n    }\n    dp[0][1] = 1;\n    for (ri j = 2; j <= N; ++j) {\n        dp[0][j] = dp[0][j - 1] * C(j * (K - 1) - 1, K - 2) % MOD;\n    }\n    for (ri i = 1; i <= N; ++i) {\n        for (ri j = i; j <= N; ++j) {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] * C(j * (K - 1) + i - 1, K - 2)) % MOD;\n        }\n    }\n    dp[N][N] = (dp[N][N] * fac[N] % MOD);\n    writeln(dp[N][N]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PP;\n\n/*\n    freopen(\"input\",\"r\",stdin);\n    freopen(\"output\",\"w\",stdout);\n*/\n\nll DP[2001][2001];\n\nll F[4000001];\nll I[4000001];\n\nll MOD = 1E9 + 7;\n\nll power(ll a, ll b) {\n\tll res = 1;\n\twhile (b > 0) {\n\t\tif (b % 2 == 1) {\n\t\t\tres *= a;\n\t\t\tres %= MOD;\n\t\t}\n\t\tb /= 2;\n\t\ta *= a;\n\t\ta %= MOD;\n\t}\n\treturn res;\n}\n\nvoid init() {\n\tF[0] = 1;\n\tfor (ll i = 1;i <= 4000000;i++) {\n\t\tF[i] = F[i - 1] * i;\n\t\tF[i] %= MOD;\n\t}\n\tmemset(I, 0, sizeof(I));\n\treturn;\n}\n\nll nchoosek(int a, int b) {\n\tif (b == 0 || a == b) return 1;\n\tll up = F[a];\n    if (I[a- b] == 0) I[a - b] = power(F[a - b], MOD - 2);\n    if (I[b] == 0) I[b] = power(F[b], MOD - 2);\n\tll down = I[a - b] * I[b];\n\tdown %= MOD;\n\tup *= down;\n\treturn up %= MOD;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    init();\n    memset(DP, 0, sizeof(DP));\n    DP[0][0] = 1;\n    int N, K, T;\n    cin >> N >> K;\n    if (K == 1) {\n    \tcout << 1 << endl;\n    \treturn 0;\n    }\n    T = N * K;\n    for (int i = 0;i <= N;i++) {\n    \t// Opened Slot.\n    \tfor (int j = 0;j <= i;j++) {\n    \t\t// Closed Slot.\n\n    \t\tif (i != N) {\n    \t\t\t// Open a slot.\n    \t\t\tDP[i + 1][j] += DP[i][j];\n    \t\t\tDP[i + 1][j] %= MOD;\n    \t\t}\n\n    \t\tif (i != j) {\n    \t\t\t// Close a slot.\n\n    \t\t\t// Choose One Color.\n    \t\t\tll ans = (N - j);\n\n    \t\t\tll rem = T - j * K - (i - j);\n\n    \t\t\tans *= nchoosek(rem - 1, K - 2);\n    \t\t\tans %= MOD;\n\n    \t\t\tans *= DP[i][j];\n    \t\t\tans %= MOD;\n\n    \t\t\tDP[i][j + 1] += ans;\n    \t\t\tDP[i][j + 1] %= MOD;\n    \t\t}\n\n    \t}\n    }\n    cout << DP[N][N] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<istream>\n#include<iomanip>\n#include<map>\n#include<set>\n#include<vector>\n#include<string>\n#include<stack>\n#include<array>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n#include<functional>\n#include<numeric>\n#include<random>\n#define int int64_t\n#define REP(i, a, b) for (int64_t i = (int64_t)(a); i < (int64_t)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (auto x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define pb(x) push_back(x)\n#define mp(x,y) std::make_pair((x),(y))\nusing namespace std;\n\ntemplate<int MOD = 1000000007>class modint {\n\t//MODが素数であることを前提として実装してあるが、その判定はしていない。\n\t//あまりが出るような除算をしてはいけない。\npublic:\n\tmodint() {\n\t\t//assert(is_prime(MOD));\n\t\tthis->number = 0;\n\t}\n\tmodint(const int src) {\n\t\t//assert(is_prime(MOD));\n\t\tthis->number = opposit(src);\n\t}\n\tmodint(const modint<MOD> &src) {\n\t\tthis->number = src.number;\n\t}\n\n\tmodint<MOD>& operator += (const modint<MOD>& obj) {\n\t\tthis->number = san2(this->number + obj.number);\n\t\treturn *this;\n\t}\n\tmodint<MOD>& operator -= (const modint<MOD>& obj) {\n\t\tthis->number = san2(this->number - obj.number + MOD);\n\t\treturn *this;\n\t}\n\tmodint<MOD>& operator *= (const modint<MOD>& obj) {\n\t\tthis->number = (this->number * obj.number) % MOD;\n\t\treturn *this;\n\t}\n\tmodint<MOD>& operator /= (const modint<MOD>& obj) {\n\t\tthis->number = (this->number * inverse(obj.number)) % MOD;\n\t\treturn *this;\n\t}\n\tmodint<MOD>& operator += (const int n) {\n\t\tthis->number = san2(this->number + opposit(n));\n\t\treturn *this;\n\t}\n\tmodint<MOD>& operator -= (const int n) {\n\t\tthis->number = san2(this->number - opposit(n) + MOD);\n\t\treturn *this;\n\t}\n\tmodint<MOD>& operator *= (const int n) {\n\t\tthis->number = (this->number * opposit(n)) % MOD;\n\t\treturn *this;\n\t}\n\tmodint<MOD>& operator /= (const int n) {\n\t\tthis->number = (this->number * inverse(n)) % MOD;\n\t\treturn *this;\n\t}\n\n\tmodint<MOD> operator + (const modint<MOD> obj) { modint<MOD>re(*this); return re += obj; }\n\tmodint<MOD> operator - (const modint<MOD> obj) { modint<MOD>re(*this); return re -= obj; }\n\tmodint<MOD> operator * (const modint<MOD> obj) { modint<MOD>re(*this); return re *= obj; }\n\tmodint<MOD> operator / (const modint<MOD> obj) { modint<MOD>re(*this); return re /= obj; }\n\tmodint<MOD> operator + (const int n) { modint<MOD>re(*this); return re += n; }\n\tmodint<MOD> operator - (const int n) { modint<MOD>re(*this); return re -= n; }\n\tmodint<MOD> operator * (const int n) { modint<MOD>re(*this); return re *= n; }\n\tmodint<MOD> operator / (const int n) { modint<MOD>re(*this); return re /= n; }\n\n\tmodint<MOD> operator = (const int n) {\n\t\tthis->number = opposit(n);\n\t\treturn *this;\n\t}\n\tint get() {\n\t\treturn number;\n\t}\n\nprivate:\n\tint number;\n\n\tint opposit(int n) {\n\t\tif (n < 0)n = MOD - ((-n) % MOD);\n\t\treturn n % MOD;\n\t}\n\tint inverse(int n) {\n\t\tn = opposit(n);\n\t\tint result = 1;\n\t\tfor (int i = MOD - 2; i; i /= 2) {\n\t\t\tif (i % 2)result = (result * n) % MOD;\n\t\t\tn = (n * n) % MOD;\n\t\t}\n\t\treturn result;\n\t}\n\tinline int san2(const int n) {\n\t\treturn MOD <= n ? n - MOD : n;\n\t}\n\tbool is_prime(int n) {\n\t\tif (n <= 1)return false;\n\t\tif (n == 2)return true;\n\t\tif (n % 2 == 0) return false;\n\t\tconst int upperbound = sqrt(n);\n\t\tfor (int i = 3; i <= upperbound; i += 2) {\n\t\t\tif (n % i == 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n};\n\nvector<modint<>> factorial;\n\nmodint<> combination(int a, int b) {\n\treturn factorial[a] / (factorial[a - b] * factorial[b]);\n}\n\nsigned main() {\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\n\tint N, K;\n\tcin >> N >> K;\n\tif (K == 1) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\n\tfactorial.resize(2000*2000);\n\tfactorial[0] = 1;\n\tfactorial[1] = 1;\n\tREP(i, 2, factorial.size())factorial[i] = factorial[i - 1] * i;\n\n\tvector<vector<modint<>>> dp(N + 1);//dp[i][j]:=解説の通り\n\trep(i, N + 1)dp[i].resize(N + 1);\n\tdp[0][0] = 1;\n\n\tfor (int j = 0; j <= N; j++)for (int i = 0; i <= j; i++) {\n\t\tif (i != 0) {\n\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t}\n\t\tif (j != 0) {\n\t\t\tconst int position = i + j * (K - 1) - 1;\n\t\t\tdp[i][j] += dp[i][j - 1] * combination(position, K - 2);\n\t\t}\n\t}\n\n\tcout << (dp[N][N] * factorial[N]).get() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing uint = unsigned int;\nusing ull = unsigned long long;\n\ntemplate <uint MOD>\nstruct modnum {\n\tusing num = modnum;\n\tuint v;\n\tmodnum(uint _v = 0) : v(_v) {}\n\tnum& operator += (const num& r) {\n\t\tif ((v += r.v) >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tnum& operator -= (const num& r) {\n\t\tif ((r += MOD - r.v) >= MOD) r -= MOD;\n\t\treturn *this;\n\t}\n\tnum& operator *= (const num& r) {\n\t\tv = ull(v) * r.v % MOD;\n\t\treturn *this;\n\t}\n\tnum operator + (const num& r) const { return num(*this) += r; }\n\tnum operator - (const num& r) const { return num(*this) -= r; }\n\tnum operator * (const num& r) const { return num(*this) *= r; }\n\tnum pow(int b) const {\n\t\tnum r = 1, a = *this;\n\t\twhile (b) {\n\t\t\tif (b & 1) {\n\t\t\t\tr *= a;\n\t\t\t}\n\t\t\ta *= a;\n\t\t\tb /= 2;\n\t\t}\n\t\treturn r;\n\t}\n\tnum inv() const { return pow(MOD - 2); }\n};\nusing num = modnum<int(1e9) + 7>;\n\nconst int MAXN = 2010;\nconst int MAXD = MAXN * MAXN;\nint N, K;\nbool used[MAXN][MAXN];\nnum dp[MAXN][MAXN];\nnum fact[MAXD], ifact[MAXD];\n\nvoid precomp() {\n\tfact[0] = 1;\n\tfor (int i = 1; i < MAXD; i++) {\n\t\tfact[i] = num(i) * fact[i-1];\n\t}\n\tifact[MAXD-1] = fact[MAXD-1].inv();\n\tfor (int i = MAXD-2; i >= 0; i--) {\n\t\tifact[i] = num(i+1) * ifact[i+1];\n\t}\n}\n\nnum C(int a, int b) {\n\treturn fact[a] * ifact[b] * ifact[a-b];\n}\n\nnum go(int a, int b) {\n\tif (a > N || b > N || a < b) return num(0);\n\tif (!used[a][b]) {\n\t\tused[a][b] = true;\n\t\tdp[a][b] = go(a+1, b) + go(a, b+1) * C(N*K - a - b*(K-1) - 1, K-2);\n\t}\n\treturn dp[a][b];\n}\n\nint main() {\n\tprecomp();\n\tcin >> N >> K;\n\tif (K == 1) { puts(\"1\"); return 0; }\n\tused[N][N] = true;\n\tdp[N][N] = 1;\n\tnum ans = fact[N] * go(0, 0);\n\tcout << ans.v << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nconst long long int MOD=1000000007;\n\ninline long long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nint main(){\n  int N,M;\n  cin>>N>>M;\n  if(M==1){\n    cout<<1<<endl;\n    return 0;\n  }\n  vector<int>by(N*M+1,1);\n  vector<int>rev_by(N*M+1,1);\n  for(int i=1;i<=N*M;i++){\n    by[i]=(1LL*by[i-1]*i)%MOD;\n    rev_by[i]=power(by[i],MOD-2,MOD);\n  }\n  vector<vector<long long int>>dp(N+1,vector<long long int>(N+1));\n  dp[0][0]=1;\n  for(int i=0;i<=N;i++){\n    for(int j=i;j<=N;j++){\n      if(i)dp[i][j]=dp[i-1][j];\n      if(j){\n        long long int add=dp[i][j-1]*rev_by[M-2];\n        add%=MOD;\n        add*=by[i+j*(M-1)-1];\n        add%=MOD;\n        add*=rev_by[i+j*(M-1)-1-(M-2)];\n        add%=MOD;\n        dp[i][j]+=add;\n        dp[i][j]%=MOD;\n      }\n    }\n  }\n  cout<<(dp.back().back()*by[N])%MOD<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rg register\n#define il inline\n#define cn const\n#define fp(i,a,b) for(rg int i=(a),ed=(b);i<=ed;++i)\nusing namespace std;\ntypedef cn int cint;\ncint inf=0x3f3f3f3f,maxn=2010,maxm=4000010,mod=1000000007;\nint n,k,f[maxn][maxn];\nint fac[maxm],inv[maxm],ifac[maxm];\nil int c(cint &n,cint &m){\n\treturn 1ll*fac[n]*ifac[m]%mod *ifac[n-m]%mod;\n}\nint main(){\n\tscanf(\"%d %d\",&n,&k);\n\tif(k==1){puts(\"1\");return 0;}\n\tfac[0]=1; fp(i,1,n*k)fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[1]=1; fp(i,2,n*k)inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\tifac[0]=1; fp(i,1,n*k)ifac[i]=1ll*ifac[i-1]*inv[i]%mod;\n\tf[0][0]=1;\n\tfp(i,0,n)fp(j,0,n)if(i+j){\n\t\tif(i) f[i][j]=1ll*f[i-1][j]*c(i*(k-1)+j-1,k-2)%mod;\n\t\tif(j&&i>=j)f[i][j]=(f[i][j]+f[i][j-1])%mod;\n\t}\n\tprintf(\"%d\\n\",1ll*f[n][n]*fac[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\nusing namespace std;\nint fac[5001000],nifac[5001000],dp[2010][2010];\nint getmi(int a,int x)\n{\n\tint ans=1;\n\twhile (x)\n\t{\n\t\tif (x&1) ans=(long long)ans*a%mo;\n\t\ta=(long long)a*a%mo;\n\t\tx>>=1;\n\t}\n\treturn ans;\n}\nint C(int n,int m){return (long long)fac[n]*nifac[m]%mo*nifac[n-m]%mo;}\nint main()\n{\n\tint n,k;scanf(\"%d%d\",&n,&k);\n\tfac[0]=1;for (int i=1;i<=n*n;i++) fac[i]=(long long)fac[i-1]*i%mo;\n\tnifac[n*n]=getmi(fac[n*n],mo-2);\n\tfor (int i=n*n-1;i>=0;i--) nifac[i]=(long long)nifac[i+1]*(i+1)%mo;\n\tdp[0][0]=1;\n\tfor (int i=0;i<=n;i++)\n\tfor (int j=0;j<=n;j++)\n\t{\n\t\tif (i) dp[i][j]=dp[i-1][j];\n\t\tif ((i!=j)&&(j)) dp[i][j]=(dp[i][j]+(long long)dp[i][j-1]*C(i+j*(k-1)-1,k-2))%mo;\n\t}\n\tprintf(\"%lld\\n\",(long long)fac[n]*dp[n][n]%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define IN freopen(\"perimetric_chapter_1_input.txt\",\"r\",stdin)\n#define OUT freopen(\"output.txt\",\"w\",stdout)\n\n#define pb push_back\n#define mp make_pair\n#define FOR(i,a,b) for(i=a ; i<=b ; i++)\n#define DBG printf(\"Hi\\n\")\n#define i64 long long int\n#define ui64 unsigned long long int\n#define xx first\n#define yy second\n#define ln 17\n#define off 2002\n\n#define sq(x) ((x)*(x))\n\n#define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL)\n\nusing namespace __gnu_pbds;\nusing namespace std ;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntypedef tree< i64, null_type, less<i64>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef pair<int,int> pii;\n\n#define log 20\n#define mod 1000000007LL\n#define INF 1000000000000000000LL\n#define maxn 300005\n\nconst long double eps = 1e-9 ;\n\nclass numberTheory{\n\npublic:\n    numberTheory(){}\n\n    pii extendedEuclid(i64 a, i64 b) { // returns x, y | ax + by = gcd(a,b)\n\n        if(b == 0) return pii( a >= 0 ? 1 : -1 , 0LL);\n        else {\n            pii d = extendedEuclid(b, a % b);\n            return pii(d.yy, d.xx - d.yy * (a / b));\n        }\n\n    }\n\n    i64 modularInverse(i64 a, i64 n) {\n        pair<i64,i64> ret = extendedEuclid(a, n);\n        return ((ret.xx % n) + n) % n;\n    }\n\n\n    i64 bigMod(i64 a, i64 n , i64 m)\n    {\n        if(n==0) return 1 ;\n        i64 ret = bigMod(a,n/2,m) ;\n        ret = (ret*ret)%m ;\n        if(n%2) ret = (ret*a)%m ;\n        return ret ;\n    }\n};\n\nconst i64 N = 5000000 ;\n\ni64 fact[N+5] , invFact[N+5] ;\n\ni64 C(i64 n, i64 r)\n{\n    if( n<0 || r<0 || r>n ) return 0 ;\n    i64 ret = (fact[n]*invFact[r])%mod ;\n    return (ret*invFact[n-r])%mod ;\n}\n\nvoid preprocess()\n{\n    numberTheory nt ;\n\n    fact[0] = 1 ;\n    for(i64 x=1 ; x<=N ; x++) fact[x] = (fact[x-1]*x)%mod ;\n\n    invFact[N] = nt.modularInverse(fact[N],mod) ;\n\n    for(i64 x=N-1 ; x>=0 ; x--) invFact[x] = (invFact[x+1]*(x+1) )%mod ;\n}\n\n\nint dp[2005][2005] ;\n\nint main()\n{\n    preprocess() ;\n\n    int n , k ;\n\n    scanf(\"%d %d\",&n,&k) ;\n\n    k-- ;\n\n    if(k==0)\n    {\n        printf(\"1\\n\") ;\n        return 0 ;\n    }\n\n    dp[0][0] = 1 ;\n\n    for(int i=1 ; i<=n ; i++)\n    {\n        dp[i][0] = (1LL*i*((1LL*dp[i-1][0]*C( i*k - 1 , k-1 ))%mod))%mod ;\n     //   dp[i][0] = ( dp[i][0] + dp )\n\n        for(int j=1 ; j<=i ; j++)\n        {\n            dp[i][j] = (1LL*i*((1LL*dp[i-1][j]*C( i*k + j - 1 , k-1 ))%mod))%mod ;\n            dp[i][j] = ( dp[i][j] + dp[i][j-1] )%mod ;\n        }\n    }\n\n    printf(\"%d\\n\",dp[n][n]) ;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=2000*2000,p=1e9+7;\nint fac[maxn+9],ifac[maxn+9];\ninline int poww(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1)ans=1ll*a*ans%p;b>>=1;\n\t\ta=1ll*a*a%p;\n\t}return ans;\n}\nint C(int n,int m){\n\tif(n<m)return 0;\n\treturn 1ll*fac[n]*ifac[m]%p*ifac[n-m]%p;\n} \nvoid init(){\n\tint inv2=p-(p/2);\n\tfac[0]=1;for(int i=1;i<=maxn;++i)fac[i]=1ll*fac[i-1]*i%p;\n\tifac[maxn]=poww(fac[maxn],p-2);for(int i=maxn-1;i>=0;--i)ifac[i]=1ll*(i+1)*ifac[i+1]%p;\n}\nint n,k,f[2020][2020];\nint main(){\n\tinit();\n\tcin>>n>>k;\n\tif(k==1){cout<<1;return 0;}\n\tfor(int i=1;i<=n;++i)f[i][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=i;++j){\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tf[i][j]=(f[i][j]+1ll*f[i][j-1]*(n-j+1)%p*C(n*k-i-(j-1)*(k-1)-1,k-2)%p)%p;\n\t\t}\n\tcout<<f[n][n];\n}"
  },
  {
    "language": "C++",
    "code": "// by newbiechd\n#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\n// DELETE the debugging information!\n#define debug(x) std::cerr << #x << \" = \" << (x) << std::endl\n\nconst int N_MAX = 2003;\nint dp[N_MAX][N_MAX];\n\nconst int mod = 1e9 + 7;\nint power(int x, int y) {\n  int ret = 1;\n  while (y > 0) {\n    if ((y & 1) == 1)\n      ret = 1ll * x * ret % mod;\n    x = 1ll * x * x % mod, y >>= 1;\n  }\n  return ret;\n}\n\nconst int M_MAX = 4000003;\nint fac[M_MAX], iFac[M_MAX];\n\nint main() {\n  int n, k;\n  scanf(\"%d%d\", &n, &k);\n  if (k == 1) {\n    printf(\"1\\n\");\n    return 0;\n  }\n  int m = n * k;\n  fac[0] = 1;\n  for (int i = 1; i <= m; ++i)\n    fac[i] = 1ll * i * fac[i - 1] % mod;\n  iFac[m] = power(fac[m], mod - 2);\n  for (int i = m; i > 0; --i)\n    iFac[i - 1] = 1ll * i * iFac[i] % mod;\n  \n  dp[0][0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    dp[i][0] = 1ll * fac[i * (k - 1) - 1] * iFac[k - 2] % mod *\n      iFac[(i - 1) * (k - 1)] % mod * dp[i - 1][0] % mod;\n    for (int j = 1; j <= i; ++j)\n      dp[i][j] = (1ll * fac[i * (k - 1) + j - 1] * iFac[k - 2] % mod *\n                  iFac[(i - 1) * (k - 1) + j] % mod * dp[i - 1][j] +\n                  dp[i][j - 1]) % mod;\n  }\n  printf(\"%lld\\n\", 1ll * dp[n][n] * fac[n] % mod);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n\n#define maxn 2222\n#define mod 1000000007\n\ninline int read(){\n\tint r=0,f=0;\n\tchar c;\n\twhile(!isdigit(c=getchar()))f|=(c=='-');\n\twhile(isdigit(c))r=(r<<1)+(r<<3)+(c^48),c=getchar();\n\treturn f?-r:r;\n}\n\ninline long long qpow(long long a,int b){\n\tlong long ans=1;\n\tfor(;b;b>>=1){\n\t\tif(b&1)(ans*=a)%=mod;\n\t\t(a*=a)%=mod;\n\t}\n\treturn ans;\n}\n\nint n,k;\n\nlong long frac[maxn*maxn],invf[maxn*maxn],f[maxn][maxn];\n\ninline long long C(int n,int m){\n\treturn frac[n]*invf[m]%mod*invf[n-m]%mod;\n}\n\nint main(){\n\tn=read(),k=read();\n\tif(k==1)return puts(\"1\"),0;\n\tfrac[0]=1;\n\tfor(int i=1;i<=n*k;i++)\n\t\tfrac[i]=frac[i-1]*i%mod;\n\tinvf[n*k]=qpow(frac[n*k],mod-2);\n\tfor(int i=n*k;i>=1;i--)\n\t\tinvf[i-1]=invf[i]*i%mod;\n\tfor(int i=1;i<=n;i++)f[i][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tf[i][j]=(f[i-1][j]+f[i][j-1]*(n-j+1)%mod*C(n*k-i-1-(j-1)*(k-1),k-2)%mod)%mod;\n\tprintf(\"%lld\\n\",f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//This code is written by Itst\nusing namespace std;\n\ninline int read(){\n\tint a = 0;\n\tchar c = getchar();\n\tbool f = 0;\n\twhile(!isdigit(c)){\n\t\tif(c == '-')\n\t\t\tf = 1;\n\t\tc = getchar();\n\t}\n\twhile(isdigit(c)){\n\t\ta = (a << 3) + (a << 1) + (c ^ '0');\n\t\tc = getchar();\n\t}\n\treturn f ? -a : a;\n}\n\nconst int MOD = 1e9 + 7 , MAXN = 4e6;\nint dp[2010][2010] , N , K , jc[MAXN + 10] , ny[MAXN + 10];\n\ninline int poww(long long a , int b){\n\tint times = 1;\n\twhile(b){\n\t\tif(b & 1)\n\t\t\ttimes = times * a % MOD;\n\t\ta = a * a % MOD;\n\t\tb >>= 1;\n\t}\n\treturn times;\n}\n\ninline void init(){\n\tjc[0] = 1;\n\tfor(int i = 1 ; i <= MAXN ; ++i)\n\t\tjc[i] = 1ll * jc[i - 1] * i % MOD;\n\tny[MAXN] = poww(jc[MAXN] , MOD - 2);\n\tfor(int i = MAXN - 1 ; i >= 0 ; --i)\n\t\tny[i] = 1ll * ny[i + 1] * (i + 1) % MOD;\n}\n\nint main(){\n\tinit();\n\tN = read();\n\tK = read();\n\tif(K == 1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tinit();\n\tfor(int i = 1 ; i <= N ; ++i){\n\t\tdp[i][0] = 1;\n\t\tfor(int j = 1 ; j <= i ; ++j){\n\t\t\tint t = N * K - i - (j - 1) * (K - 1) - 1;\n\t\t\tdp[i][j] = (dp[i - 1][j] + 1ll * dp[i][j - 1] * jc[t] % MOD * ny[K - 2] % MOD * ny[t - K + 2] % MOD * (N - j + 1) % MOD) % MOD;\n\t\t}\n\t}\n\tcout << dp[N][N];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <ctime>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL) INF;\n\nconst int MOD = 1000 * 1000 * 1000 + 7;\nconst int MAX = 2002;\n\nLL F[MAX * MAX];\nLL RF[MAX * MAX];\nLL DP[MAX][MAX];\n\nLL bp(LL a, int n)\n{\n    LL res = 1;\n    while(n)\n    {\n        if (n & 1)res = (res * a) % MOD;\n        a = (a * a) % MOD;\n        n >>= 1;\n    }\n    return res;\n}\n\nLL C(int n, int k)\n{\n    if (n < 0)return 0;\n    if (k > n)return 0;\n    return (F[n] * RF[k] % MOD) * RF[n-k] % MOD;\n}\n\n\nint main()\n{\n    //freopen(\"input.txt\", \"r\", stdin);\n    //ios::sync_with_stdio(false); cin.tie(0);\n    \n    F[0] = RF[0] = 1;\n    FOR(i, 1, MAX * MAX)\n    {\n        F[i] = F[i-1] * i % MOD;\n        RF[i] = bp(F[i], MOD-2);\n    }\n    \n    int n, k;\n    cin >> n >> k;\n    \n    if(k == 1)\n    {\n        cout << 1 << endl;\n        return 0;\n    }\n    \n    DP[0][0] = 1;\n    \n    FOR(i, 0, n + 1)\n    {\n        FOR(j, 0, i+1)\n        {\n            if (DP[i][j] == 0)continue;\n            \n            DP[i+1][j] += DP[i][j];\n            if (DP[i+1][j] >= MOD)DP[i+1][j] -= MOD;\n            \n            if (j != i)\n            {\n                int left = n * k - (i + j * (k-1));\n                DP[i][j+1] += (C(left-1, k-2) * DP[i][j] % MOD) * (n - j) % MOD;\n                if (DP[i][j+1] >= MOD)\n                    DP[i][j+1] -= MOD;\n            }\n        }\n    }\n    cout << DP[n][n] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\nusing namespace std;\nconst long long Mod=1000000007;\nint n,k;\nlong long fac[4000010],inv[4000010],f[2010][2010],s[2010];\nlong long pw(long long x,long long y)\n{\n\tlong long res=1;\n\twhile (y)\n\t{\n\t\tif (y&1)\n\t\t{\n\t\t\tres=res*x%Mod;\n\t\t} \n\t\ty>>=1;\n\t\tx=x*x%Mod;\n\t}\n\treturn res;\n}\nlong long c(int n,int m)\n{\n\tif (n<m)\n\t{\n\t\treturn 0;\n\t}\n\treturn fac[n]*inv[n-m]%Mod*inv[m]%Mod;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tif (k==1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\tfor (int i=1;i<=n*k;i++)\n\t{\n\t\tfac[i]=fac[i-1]*i%Mod;\n\t}\n\tinv[n*k]=pw(fac[n*k],Mod-2);\n\tfor (int i=n*k-1;i>=0;i--)\n\t{\n\t\tinv[i]=inv[i+1]*(i+1)%Mod;\n\t}\n\tf[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\ts[n+1]=0;\n\t\tfor (int j=n;j>=0;j--)\n\t\t{\n\t\t\ts[j]=(s[j+1]+f[i-1][j])%Mod;\n\t\t}\n\t\tfor (int j=1;j<=i;j++)\n\t\t{\n\t\t\tf[i][j]=s[j-1]*c(i*k-j-1,k-2)%Mod;\n\t\t}\n\t}\n\tlong long ans=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tans=(ans+f[n][i])%Mod;\n\t}\n\tans=ans*fac[n]%Mod;\n\tprintf(\"%lld\\n\",ans);\n    return 0;\n}\n//花开堪折直须折，莫待无花空折枝。\n//——《金缕衣》"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long i64;\n\nconst int MAXN = 2000 + 5;\nconst int MOD = 1e9 + 7;\n\nint N, K;\ni64 fact[MAXN * MAXN], inverse[MAXN * MAXN];\ni64 DP[MAXN][MAXN];\n\ni64 modularExp(i64 base, i64 exp)\n{\n\ti64 ret = 1;\n\twhile (exp)\n\t{\n\t\tif (exp & 1)\n\t\t\tret = ret * base % MOD;\n\t\tbase = base * base % MOD;\n\t\texp = exp >> 1;\n\t}\n\treturn ret;\n}\n\nvoid prepare()\n{\n\tfact[0] = 1;\n\tfor (int i = 1; i < MAXN * MAXN; i++)\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\n\tinverse[MAXN * MAXN - 1] = modularExp(fact[MAXN * MAXN - 1], MOD - 2) % MOD;\n\tfor (int i = MAXN * MAXN - 2; i >= 0; i--)\n\t\tinverse[i] = inverse[i + 1] * (i + 1) % MOD;\n\n\tassert(inverse[1] == 1);\n}\n\ni64 getC(int n, int m)\n{\n\treturn fact[n] * inverse[m] % MOD * inverse[n - m] % MOD;\n}\n\nint main()\n{\n\tprepare();\n\tcin >> N >> K;\n\n\tif(K == 1)\n\t\tcout << 1 << endl, exit(0);\n\n\tDP[0][0] = 1;\n\tfor (int i = 0; i <= N; i++)\n\t\tfor (int j = i; j <= N; j++)\n\t\t{\n\t\t\tDP[i][j + 1] = (DP[i][j + 1] + DP[i][j]) % MOD;\n\t\t\tDP[i + 1][j] = (DP[i][j] * getC(K * (N - i) - (j - i) - 1, K - 2)\n\t\t\t\t\t+ DP[i + 1][j]) % MOD;\n\t\t}\n\tcout << DP[N][K] * fact[N] % MOD << endl ;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int maxN = 2e3 + 13, mod = 1e9 + 7;\nint n, k, dp[maxN][maxN], fac[maxN * maxN], rfac[maxN * maxN];\n\nint pw (int a, int b) {\n    int ret = 1;\n    for (; b; b >>= 1, a = 1ll * a * a % mod)\n\tif (b & 1)\n\t    ret = 1ll * ret * a % mod;\n    return ret;\n}\n\nint c (int a, int b) {\n    return 1ll * fac[b] * rfac[a] % mod * rfac[b - a] % mod;\n}\n\nint32_t main () {\n    cin >> n >> k;\n    dp[0][0] = 1;\n    fac[0] = rfac[0] = 1;\n    for (int i = 1; i <= n * k; i++) {\n\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\trfac[i] = 1ll * rfac[i - 1] * pw(i, mod - 2) % mod;\n    }\n\n    for (int i = 1; i <= n; i++)\n\tfor (int j = 0; j <= i; j++) {\n\t    if (j)\n\t\tdp[i][j] = dp[i][j - 1];\n\t    dp[i][j] = (dp[i][j] + (1ll * dp[i - 1][j] * c(k - 2, i * (k - 1) + j - 1) % mod)) % mod;\n\t    // cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t}\n    //cout << dp[n][n] << endl;\n    if (k == 1)\n\treturn cout << 1 << endl, 0;\n    cout << 1ll * dp[n][n] * fac[n] % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 0x7fffffff\n#define RG register\n#define inf 0x7fffffff\n#define mkp make_pair\n#define maxn 100205\ntypedef unsigned int U;\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1e9+7;\nconst  double eps = 1e-8;\nconst double pi = acos(-1);\ninline ll read(){\n    ll x = 0, f = 1;\n    char ch = getchar();\n    while(ch > '9' || ch < '0') {if(ch == '-') f = -1;ch = getchar();}\n    while(ch >= '0' && ch <= '9'){x = x *10 + ch -'0';ch = getchar();}\n    return x * f;\n}\nint n,k;\nint fac[4000005],inv[4000005];\nint f[2005][2005];\nint qpow(int a,int b){\n\tint ans=1,base=a;\n\twhile(b){\n\t\tif(b&1) ans=1ll*ans*base%mod;\n\t\tbase=1ll*base*base%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint C(int n,int m){return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint main(){\n\tint i,j,u,v,e,w;\n\t//freopen(\"a.out\",\"r\",stdin);\n\t//freopen(\"a.ans\",\"w\",stdout);n\n\tn=read(),k=read();\n\tfac[0]=1;\n\tfor(i=1;i<=n*k;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[n*k]=qpow(fac[n*k],mod-2);\n\tfor(i=n*k-1;i>=0;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tf[0][0]=1;\n\tfor(i=0;i<=n;i++){\n\t\tfor(j=i;j<=n;j++){\n\t\t\tif(i+1<=j) f[i+1][j]=(f[i+1][j]+f[i][j])%mod;\n\t\t\tif(j+1<=n) f[i][j+1]=(f[i][j+1]+1ll*f[i][j]*C(i+(k-1)*j+k-2,k-2)%mod)%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",1ll*f[n][n]*fac[n]%mod);\n\treturn 0;\n}\n/*\n8\n0 0 0 0\n0 0 1 1\n0 1 0 1\n0 1 1 0\n1 0 0 1\n1 0 1 0\n1 1 0 0\n1 1 1 1\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\ntypedef long long LL;\nconst int N=2003,p=1000000007;\nint f[N][N],c[N*N],fc[N*N],i,j,k,n,m,K,X,z,an;\n\nvoid plus(int &a,int b){ a+=b,a-=a<p?0:p; }\n\nint power(int z,int k)\n{\n\tint d=1;\n\tfor (;k;z=(LL)z*z%p,k>>=1) if (k&1) d=(LL)d*z%p;\n\treturn d;\n}\n\nint C(int n,int m)\n{\n\treturn (LL)c[n]*fc[m]%p*fc[n-m]%p;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&K);\n\tif (K==1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tX=n*K;\n\tfor (c[0]=i=1;i<=X;++i) c[i]=(LL)c[i-1]*i%p;\n\tfor (fc[X]=power(c[X],p-2),i=X;i;--i) fc[i-1]=(LL)fc[i]*i%p;\n\tf[1][1]=1;\n\tfor (i=1;i<n;++i)\n\t\tfor (z=0,j=i;~j;--j)\n\t\t\tplus(z,f[i][j]),\n\t\t\tf[i+1][j+1]=(LL)z*C((i+1)*K-j-2,K-2)%p;\n\tfor (i=1;i<=n;++i) plus(an,f[n][i]);\n\tprintf(\"%d\\n\",(LL)an*c[n]%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int N=2005,Mod=1e9+7;\nint dp[N][N],fac[N*N],inv[N*N];\ninline int C(int n,int m){\n\treturn 1ll*fac[n]*inv[m]%Mod*inv[n-m]%Mod;\n}\ninline int qpow(int a,int b){\n\tint ans=1;\n\twhile (b){\n\t\tif (b&1) ans=1ll*ans*a%Mod;\n\t\ta=1ll*a*a%Mod,b>>=1;\n\t}\n\treturn ans;\n}\nint main (){\n\tint n,k;scanf (\"%d%d\",&n,&k);\n\tif (k==1) {puts(\"1\");return 0;}\n\tdp[0][0]=1;fac[0]=1;\n\tfor (int i=1;i<=n*k;i++) fac[i]=1ll*fac[i-1]*i%Mod;\n\tinv[n*k]=qpow(fac[n*k],Mod-2);for (int i=n*k-1;i>=0;i--) inv[i]=1ll*inv[i+1]*(i+1)%Mod;\n\tfor (int i=1;i<=n;i++)\n        for (int j=0;j<=i;j++){\n            if (j!=i) dp[i][j]=1ll*dp[i-1][j]*(n-i+1)%Mod;\n            if (j!=0) (dp[i][j]+=1ll*dp[i][j-1]*C(n*k-(i+(j-1)*(k-1))-1,k-2)%Mod)%=Mod;\n        }\n    printf (\"%d\",dp[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//AtCoder-agc002F\n#include <cstdio>\n#define rg register\n\nconst int N=2018,M=N*N,p=1e9+7;\nint inv[M],fac[M],f[N][N];\nint n,m;\n\ntemplate <typename _Tp> inline void pls(_Tp&A,_Tp B){A=A+B<p?A+B:A+B-p;}\n\ninline int qpow(int A,int B){\n\tint res(1);while(B){\n\t\tif(B&1)res=1ll*res*A%p;\n\t\tA=1ll*A*A%p;B>>=1;\n\t}return res;\n}\n\nvoid prework(){\n\tinv[0]=inv[1]=fac[0]=fac[1]=1;\n\tfor(rg int i=2;i<M;++i)fac[i]=1ll*fac[i-1]*i%p;\n\tinv[M-1]=qpow(fac[M-1],p-2);\n\tfor(rg int i=M-2;i;--i)inv[i]=1ll*inv[i+1]*(i+1)%p;\n}\n\ninline int c(int nn,int mm){return 1ll*fac[nn]*inv[mm]%p*inv[nn-mm]%p;}\n\nint main(){\n\tprework();scanf(\"%d%d\",&n,&m);\n\tif(m==1){puts(\"1\");return 0;}\n\tf[0][0]=1;\n\tfor(rg int i=1;i<=n;++i){\n\t\tpls(f[i][0],(int)(1ll*f[i-1][0]*c(i*m-i-1,m-2)%p));\n\t\tfor(rg int j=1;j<=i;++j){\n\t\t\tf[i][j]=f[i][j-1];\n\t\t\tpls(f[i][j],(int)(1ll*f[i-1][j]*c(i*m+j-i-1,m-2)%p));\n\t\t}\n\t}printf(\"%lld\\n\",1ll*f[n][n]*fac[n]%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fo(i,s,t) for(int i = s; i <= t; ++ i)\n#define fd(i,s,t) for(int i = s; i >= t; -- i)\n#define bf(i,s) for(int i = head[s]; i; i = e[i].next)\n#define mp make_pair\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pb push_back\n#define VI vector<int>\n#define sf scanf\n#define pf printf\n#define fp freopen\n#define SZ(x) ((int)(x).size())\n// #define MPS\ntypedef long long ll;\ntypedef double db;\ntypedef unsigned long long ull;\nconst int inf = 1<<30;\nconst ll INF = 1ll<<60;\nconst db Inf = 1e20;\nconst db eps = 1e-9;\n\nvoid gmax(int &a,int b){a = (a > b ? a : b);}\nvoid gmin(int &a,int b){a = (a < b ? a : b);}\n\nconst int maxn = 4000050;\nconst int maxm = 2005;\nconst int P = 1e9+7;\n\nint n, k, dp[maxm][maxm], fac[maxn], infr[maxn];\n\nll comb(int n,int m) {return 1ll*fac[n]*infr[m]%P*infr[n-m]%P;}\nint qpow(int a,int b) {int ans = 1; while(b) {if(b&1) ans = (ans*1ll*a)%P; b >>= 1; a = (a*1ll*a)%P;} return ans;}\nint main()\n{\n\t#ifdef MPS\n\t\tfp(\"agc02f.in\",\"r\",stdin);\n\t\tfp(\"agc02f.out\",\"w\",stdout);\n\t#endif\n\tsf(\"%d%d\",&n,&k);\n\tfac[0] = 1; fo(i,1,n*k) fac[i] = (fac[i-1]*1ll*i)%P;\n\tinfr[n*k] = qpow(fac[n*k],P-2);\n\tfd(i,n*k-1,0) infr[i] = infr[i+1]*1ll*(i+1)%P;\n\tif(k == 1) return 0*pf(\"1\\n\");\n\tdp[0][0] = 1;\n\tfo(i,0,n) fo(j,0,n)\n\t{\n\t\tif(i < j) dp[i+1][j] = (dp[i+1][j] + dp[i][j])%P;\n\t\tif(j < n) dp[i][j+1] = (dp[i][j+1] + (dp[i][j] * comb(j*(k-1)+k+i-2,k-2))%P)%P;\n\t}\n\tpf(\"%lld\\n\",(1ll*dp[n][n]*fac[n])%P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ts cout<<\"ok\"<<endl\n#define int long long\n#define hh puts(\"\")\n#define pc putchar\n#define mo 1000000007\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\n//char buf[1<<21],*p1=buf,*p2=buf;\nusing namespace std;\nconst int N=4000005,M=2005;\nint n,k,jc[N],ny[N],f[M][M];\ninline int read(){\n    int ret=0,ff=1;char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-') ff=-1;ch=getchar();}\n    while(isdigit(ch)){ret=ret*10+(ch^48);ch=getchar();}\n    return ret*ff;\n}\nvoid write(int x){if(x<0){x=-x,pc('-');}if(x>9) write(x/10);pc(x%10+48);}\nvoid writeln(int x){write(x),hh;}\nvoid writesp(int x){write(x),pc(' ');}\n//总共n个白球,n*(k-1)个其他颜色球,时刻满足白球个数大于等于其余颜色个数 \n//f[i][j]:放i个白球,用了j种颜色的方案 \nint ksm(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%mo;\n\t\ty>>=1;\n\t\tx=x*x%mo;\n\t}\n\treturn res;\n}\nint C(int x,int y){\n\treturn jc[x]*ny[y]%mo*ny[x-y]%mo;\n}\nsigned main(){\n\tn=read(),k=read();\n\tif(k==1){\n\t\twrite(1);\n\t\treturn 0;\n\t}\n\tjc[0]=1;\n\tfor(int i=1;i<=N-5;i++) jc[i]=jc[i-1]*i%mo;\n\tny[N-5]=ksm(jc[N-5],mo-2);\n\tfor(int i=N-6;i>=0;i--) ny[i]=ny[i+1]*(i+1)%mo;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(j>0) f[i][j]=(f[i][j]+f[i][j-1]*(n-j+1)%mo*C(n*k-i-(j-1)*(k-1)-1,k-2)%mo)%mo;\n\t\t}\n\t}\n\twrite(f[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=2e3+11;\nconst int M=4e6+11;\nconst int mod=1e9+7;\nint n,k,f[N][N],fac[M],ifac[M];\nint read(){\n    int x=0,f=1;char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}\n    while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}\n    return x*f;\n}\nint qpow(int a,int b){\n    int re=1;\n    while(b){\n        if(b&1) re=(re*a)%mod;\n        b>>=1;a=a*a%mod;\n    }return re;\n}\nint C(int a,int b){\n    if(a<b) return 0;\n    return fac[a]*ifac[b]%mod*ifac[a-b]%mod;\n}\nsigned main(){\n    n=read(),k=read();\n    if(k==1) return puts(\"-1\"),0;\n    fac[0]=1;ifac[0]=1;f[0][0]=1;\n    for(int i=1;i<=n*k;i++) fac[i]=fac[i-1]*i%mod;\n    ifac[n*k]=qpow(fac[n*k],mod-2);\n    for(int i=n*k-1;i;i--) ifac[i]=ifac[i+1]*(i+1)%mod;\n    for(int i=1;i<=n;i++)\n        for(int j=0;j<=i;j++){\n            if(i>j) f[i][j]+=f[i-1][j];\n            f[i][j]=(f[i][j]+f[i][j-1]*C((n-j+1)*(k-1)+n-i-1,k-2)%mod)%mod;\n        }\n    printf(\"%lld\\n\",f[n][n]*fac[n]%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <unordered_map>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\nusing namespace std;\n\nint n, k;\nlong long F[8000001];\nlong long inv[8000001];\nlong long invF[8000001];\n\nlong long mod = 1000000007LL;\n\nlong long C(int a, int b)\n{\n\tif(b < 0 || b > a) return 0;\n\tlong long ret = F[a];\n\tret *= invF[b];\n\tret %= mod;\n\tret *= invF[a-b];\n\tret %= mod;\n\treturn ret;\n}\n\nlong long ways(int nLocation, int nObject)\n{\n\treturn C(nLocation + nObject - 1, nLocation - 1);\n}\n\nlong long DP[2001][2001];\n\nlong long dp(int nZero, int nColor)\n{\n\tif(nZero > n || nColor > n) return 0;\n\tif(nZero == n && nColor == n) return 1;\n\tlong long &ret = DP[nZero][nColor];\n\tif(ret != -1) return ret;\n\tret = 0;\n\tif(nZero <= nColor)\n\t\tret += dp(nZero + 1, nColor);\n\tlong long mul = ways(\n\t\t\tnZero + nColor * (k - 1),\n\t\t\tk - 2\n\t\t);\n\t\n\tret += dp(nZero, nColor + 1) * mul;\n\tret %= mod;\n\t//cout << nZero << \" \" << nColor << \" : \" << ret << endl;\n\treturn ret;\n}\n\nint MAIN()\n{\n\tcin >> n >> k;\n\tF[0] = invF[0] = 1;\n\tinv[1] = 1;\n\tfor(int i = 2; i <= 8000000; i++)\n\t\tinv[i] = (mod - (mod/i) * inv[mod%i] % mod) % mod;\n\n\tfor(int i = 1; i <= 8000000; i++)\n\t{\n\t\tF[i] = (F[i-1] * i) % mod;\n\t\tinvF[i] = (invF[i-1] * inv[i] % mod);\n\t}\n\tmemset(DP, 0xff, sizeof(DP));\n\tlong long ans = 1;\n\tif(k > 1)\n\t{\n\t\tans = dp(1, 0);\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tans = (ans * i) % mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\nint main()\n{\n\tint start = clock();\n\t#ifdef LOCAL_TEST\n\t\tfreopen(\"in.txt\", \"r\", stdin);\n\t\tfreopen(\"out.txt\", \"w\", stdout);\n\t#endif\n\tios :: sync_with_stdio(false);\n\tcout << fixed << setprecision(16);\n\tint ret = MAIN();\n\t#ifdef LOCAL_TEST\n\t\tcout << \"[Finished in \" << clock() - start << \" ms]\" << endl;\n\t#endif\n\treturn ret;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define IL __inline__ __attribute__((always_inline))\n\n#define For(i, a, b) for (int i = a, i##end = b; i <= i##end; ++ i)\n#define FOR(i, a, b) for (int i = a, i##end = b; i < i##end; ++ i)\n#define Rep(i, a, b) for (int i = a, i##end = b; i >= i##end; -- i)\n#define REP(i, a, b) for (int i = (a) - 1, i##end = b; i >= i##end; -- i)\n\ntypedef long long LL;\n\ntemplate <class T>\nIL bool chkmax(T &a, const T &b) {\n  return a < b ? ((a = b), 1) : 0;\n}\n\ntemplate <class T>\nIL bool chkmin(T &a, const T &b) {\n  return a > b ? ((a = b), 1) : 0;\n}\n\ntemplate <class T>\nIL T mymax(const T &a, const T &b) {\n  return a > b ? a : b;\n}\n\ntemplate <class T>\nIL T mymin(const T &a, const T &b) {\n  return a < b ? a : b;\n}\n\ntemplate <class T>\nIL T myabs(const T &a) {\n  return a > 0 ? a : -a;\n}\n\nconst int INF = 0X3F3F3F3F;\nconst double EPS = 1E-10, PI = acos(-1.0);\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define OK DEBUG(\"Passing [%s] in LINE %d...\\n\", __FUNCTION__, __LINE__)\n/*------------------------------header------------------------------*/\n\nconst int MAXN = 2000 + 5, MAXM = 4000000 + 5, MOD = 1000000007;\n\nIL int add(int a, int b) {\n  a += b;\n  return a >= MOD ? a - MOD : a;\n}\n\ntemplate<class ...Args>\nIL int add(int a, const Args &...args) {\n  a += add(args...);\n  return a >= MOD ? a - MOD : a;\n}\n\nIL int sub(int a, int b) {\n  a -= b;\n  return a < 0 ? a + MOD : a;\n}\n\nIL int mul(int a, int b) {\n  return (LL)a * b % MOD;\n}\n\ntemplate<class ...Args>\nIL int mul(int a, const Args &...args) {\n  return (LL)a * mul(args...) % MOD;\n}\n\nIL int quickPow(int a, int p) {\n  int result = 1;\n  for (int base = a; p; p >>= 1, base = mul(base, base)) {\n    if (p & 1) {\n      result = mul(result, base);\n    }\n  }\n  return result;\n}\n\nint fac[MAXM], ifac[MAXM], f[MAXN][MAXN];\n\nIL void init(int n) {\n  fac[0] = 1;\n  For(i, 1, n) {\n    fac[i] = mul(fac[i - 1], i);\n  }\n  ifac[n] = quickPow(fac[n], MOD - 2);\n  REP(i, n, 0) {\n    ifac[i] = mul(ifac[i + 1], i + 1);\n  }\n}\n\nIL int binom(int n, int m) {\n  return mul(fac[n], ifac[m], ifac[n - m]);\n}\n\nint main() {\n  int n, k;\n  scanf(\"%d%d\", &n, &k);\n  init(n * k);\n  if (k == 1) {\n    printf(\"%d\\n\", n);\n    exit(0);\n  }\n  f[0][0] = 1;\n  For(j, 1, n) {\n    f[0][j] = mul(f[0][j - 1], binom(j * (k - 1) - 1, k - 2));\n  }\n  For(i, 1, n) {\n    For(j, i, n) {\n      f[i][j] = add(f[i - 1][j], mul(f[i][j - 1], binom(j * (k - 1) + i - 1, k - 2)));\n    }\n  }\n  printf(\"%d\\n\", mul(f[n][n], fac[n]));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nconst int MOD(1000000007);\nint n, k;\nint fac[4000000], inv_fac[4000000], dp[2001][2001];\n\n\nint Power(long long a, int b)\n{\n\tlong long ret(1ll);\n\t\n\twhile (b) {\n\t\tb & 1 && (ret *= a);\n\t\tret >= MOD && (ret %= MOD);\n\t\ta *= a;\n\t\ta >= MOD && (a %= MOD);\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\n\n\nint main()\n{\n\tregister long long lt;\n\tint t;\n\t\n\tscanf(\"%d%d\", &n, &k);\n\tif (k == 1) {\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tfac[0] = 1;\n\tt = n * k;\n\tfor (int i = 1; i < t; ++i) {\n\t\tlt = (long long)i * fac[i - 1];\n\t\tfac[i] = lt < MOD ? lt : lt % MOD; \n\t}\n\tinv_fac[t - 1] = Power((long long)fac[t - 1], MOD - 2);\n\tfor (int i = t - 2; i; --i) {\n\t\tlt = (long long)(i + 1) * inv_fac[i + 1];\n\t\tinv_fac[i] = lt < MOD ? lt : lt % MOD;\n\t}\n\tinv_fac[0] = 1;\n\tdp[0][0] = 1;\n\tt = -2;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tt += k - 1;\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\t++t;\n\t\t\tlt = (long long)fac[t] * inv_fac[t - k + 2];\n\t\t\tlt >= MOD && (lt %= MOD);\n\t\t\tlt *= (long long)inv_fac[k - 2];\n\t\t\tlt >= MOD && (lt %= MOD);\n\t\t\tlt *= (long long)dp[i - 1][j];\n\t\t\tj && (lt += dp[i][j - 1]);\n\t\t\tdp[i][j] = lt < MOD ? lt : lt % MOD;\n\t\t}\n\t\tt -= i + 1;\n\t}\n\tlt = (long long)dp[n][n] * fac[n] % MOD;\n\tprintf(\"%lld\\n\", lt);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for (int i = a; i <= b; i++)\n#define per(i, a, b) for (int i = a; i >= b; i--)\ntypedef long long LL;\nconst LL mod = 1e9 + 7;\n// head\nconst int maxn = 2e3 + 5;\nint n, k;\nLL f[maxn][maxn], fac[maxn*maxn], inv[maxn*maxn];\n\nLL ksm(LL a, LL b) {\n\tLL res = 1;\n\twhile(b) {\n\t\tif(b%2) res = res*a%mod;\n\t\tb /= 2;\n\t\ta = a*a%mod;\n\t}\n\treturn res;\n}\n\nLL comb(LL a, LL b) {\n\treturn fac[a]*inv[b]%mod*inv[a - b]%mod;\n}\n\nint main() {\n\tcin>>n>>k;\n\tif(k == 1) { \n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tfac[0] = inv[0] = 1;\n\trep(i, 1, n*k)\n\t    fac[i] = fac[i - 1]*i%mod, inv[i] = ksm(fac[i], mod - 2);\n\tf[0][0] = 1;\n\trep(i, 1, n)\n\t    rep(j, 0, i) {\n\t    \tif(i > j) f[i][j] = (f[i][j] + f[i - 1][j])%mod;\n\t    \tif(j) f[i][j] = (f[i][j] + f[i][j - 1]*(n - j + 1)%mod*comb(n*k - i - (j - 1)*(k - 1) - 1, k - 2)%mod)%mod;\n\t    }\n\tcout<<f[n][n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define neko 2010\n#define f(i,a,b) for(register int i=(a);i<=(b);i=-(~(i)))\n#define rf(i,a,b) for(register int i=(a);i>=(b);i=~(-(i)))\ntypedef long long ll;\nll dp[neko][neko],fac[neko*neko],ifac[neko*neko];\nconst ll mod=1e9+7;\nint n,k;\nll ADD(ll x,ll y){return (x+=y)>=mod?x-mod:x;}\nll spow(ll m,ll n)\n{\n\tll b=1;\n\tfor(;n;n>>=1,m=m*m%mod)if(n&1)b=b*m%mod;\n\treturn b;\n}\nll C(ll m,ll n){if(m<n)return 1;if(!n)return 1;return fac[m]*ifac[n]%mod*ifac[m-n]%mod;}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1)return printf(\"1\\n\"),0;\n\tfac[0]=ifac[0]=1;\n\tf(i,1,4000005)fac[i]=fac[i-1]*i%mod;\n\tifac[4000005]=spow(fac[4000005],mod-2);\n\trf(i,4000004,1)ifac[i]=ifac[i+1]*(i+1)%mod;\n\tdp[0][0]=1;\n\tf(i,0,n)\n\t f(j,i,n)\n\t {\n\t\tif(i)dp[i][j]=ADD(dp[i-1][j],dp[i][j]);\n\t\tif(j)dp[i][j]=ADD(dp[i][j],dp[i][j-1]*C(i+(j-1)*(k-1)+k-2,k-2)%mod);\n\t }return printf(\"%lld\\n\",(dp[n][n]*fac[n]%mod+mod)%mod),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int mod=1000000007;\ntypedef long long ll;\n\nint fac[4000010],inv[4000010],dp[2010][2010];\n\nint power(int x,int y)\n{\n\tint t=1;\n\twhile (y)\n\t{\n\t\tif (y&1) t=ll(t)*x%mod;\n\t\tx=ll(x)*x%mod;y>>=1;\n\t}\n\treturn t;\n}\n\nint c(int n,int m)\n{\n\treturn ll(fac[n])*inv[m]%mod*inv[n-m]%mod;\n}\n\nint main()\n{\n\t//freopen(\"input.txt\",\"r\",stdin);\n\t//freopen(\"output.txt\",\"w\",stdout);\n\tint n,k;scanf(\"%d%d\",&n,&k);\n\tif (k==1) {puts(\"1\");return 0;}\n\tint M=n*k;\n\tfac[0]=1;for (int i=1;i<=M;i++) fac[i]=ll(fac[i-1])*i%mod;\n\tinv[M]=power(fac[M],mod-2);for (int i=M;i;i--) inv[i-1]=ll(inv[i])*i%mod;\n\tmemset(dp,0,sizeof(dp));dp[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tdp[i][0]=1;\n\t\tfor (int j=1;j<=i;j++)\n\t\t\tdp[i][j]=(ll(dp[i][j-1])*c(M-i-j-(j-1)*(k-2),k-2)+dp[i-1][j])%mod;\n\t}\n\tprintf(\"%d\\n\",ll(dp[n][n])*fac[n]%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=2e3+2;\nconst int maxx=maxn*maxn;\nconst int q=1e9+7;\ninline int Plus(int x,int y) {return (x+=y)>=q?x-q:x;}\ninline void Pe(int &x,int y) {x=Plus(x,y);}\ninline int Multi(int x,int y) {return 1ll*x*y%q;}\ninline void Me(int &x,int y) {x=Multi(x,y);}\nnamespace num {\n\tint fac[maxx],ifac[maxx],inv[maxx];\n\tinline int C(int n,int m) {return n<m?0:Multi(Multi(fac[n],ifac[m]),ifac[n-m]);}\n\tvoid init() {\n\t\tfac[0]=fac[1]=ifac[0]=ifac[1]=inv[0]=inv[1]=1;\n\t\tfor (int i=2;i<maxx;++i) {\n\t\t\tinv[i]=Multi(q-q/i,inv[q%i]);\n\t\t\tfac[i]=Multi(fac[i-1],i);\n\t\t\tifac[i]=Multi(ifac[i-1],inv[i]);\n\t\t}\n\t}\n}\nint n,k,f[maxn];\nint main() {\n\tfreopen(\"a.in\",\"r\",stdin);\n\tnum::init();\n\tcin>>n>>k;\n\tif (k==1) puts(\"1\"),exit(0);\n\tf[0]=1;\n\tfor (int i=1;i<=n;++i,f[0]=f[1]) {\n\t\tfor (int j=i;j;--j) {\n\t\t\tint tmp=num::C((i-1)*k-(j-1)+k-2,k-2);\n\t\t\tf[j]=Plus(Multi(Multi(n-i+1,f[j-1]),tmp),f[j+1]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nconst int mod=1e9+7,N=2e3+50;\ninline int add(int x,int y) {return (x+y>=mod)?(x+y-mod):(x+y);}\ninline int mul(int x,int y) {return (LL)x*y%mod;}\ninline int power(int a,int b) {\n\tint rs=1;\n\tfor(;b;b>>=1,a=mul(a,a)) if(b&1) rs=mul(rs,a);\n\treturn rs;\n}\nint n,k,dp[N][N],fac[N*N*2],ifac[N*N*2];\ninline int C(int x,int y) {return mul(ifac[x-y],mul(fac[x],ifac[y]));}\nint main() {\n\tcin>>n>>k; int l=2*n*k;\n\tif(k==1) {puts(\"1\"); return 0;}\n\tfac[0]=1;\n\tfor(int i=1;i<=l;i++) fac[i]=mul(fac[i-1],i);\n\tifac[l]=power(fac[l],mod-2);\n\tfor(int i=l-1;~i;i--) ifac[i]=mul(ifac[i+1],i+1);\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++) {\n\t\t\tif(j==i) dp[i][j]=dp[i][j-1];\n\t\t\telse dp[i][j]=add(dp[i][j-1],mul(dp[i-1][j],C(k-2+(i-1)*k-(i-j-1),k-2)));\n\t\t}\n\tprintf(\"%d\\n\",mul(dp[n][n],fac[n]));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long \nconst int N = 2000 + 10;\nconst int mod = 1e9 + 7;\nusing namespace std;\nll f[N][N], fac[N*N], rfac[N*N];\nint n,m;\nnamespace solver\n{\n  ll fpm(ll x,ll y)\n  {\n    ll s=1;\n    while(y)\n\t{\n\t  if(y&1) s=s*x%mod;\n\t  y>>=1; x=x*x%mod;\n\t}\n\treturn s;\n  }\n  void upd(ll &x,ll y)\n  {\n\tx+=y; x%=mod;\n  }\n  ll c(int x,int y)\n  {\n    if(x<0) return 0;\n\tif(x<y) return 0;\n\treturn fac[x]*rfac[y]%mod*rfac[x-y]%mod;\n  }\n  void init()\n  {\n    scanf(\"%d%d\",&n,&m);\n\tif(m == 1) { puts(\"1\"); return;}\n\tfac[0]=1ll; \n\tfor(int i=1;i<=n*m;++i) fac[i]=fac[i-1]*i%mod;\n\trfac[n*m]=fpm(fac[n*m],mod-2);\t \n\tfor(int i=n*m-1;i>=0;--i) rfac[i]=rfac[i+1]*(i+1)%mod;\n\t\n\tf[0][0]=1ll;\n\tfor(int i=0;i<=n;++i)\n\t  for(int j=i;j>=0;--j)\n\t  {\n\t    upd(f[i+1][j+1],f[i][j]*c(i*m-j+m-2,m-2));\n\t    if(j) upd(f[i][j-1],f[i][j]);\n\t  }\n\tf[n][0]=f[n][0]*fac[n]%mod;\n\tprintf(\"%lld\\n\",f[n][0]);\n  } \n}\nint main()\n{\n  solver::init();  \n\n}"
  },
  {
    "language": "C++",
    "code": "// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //\n// IN THE NAME OF GOD\n#include <bits/stdc++.h>\n\n#define ff first\n#define endl '\\n'\n#define in insert\n#define ss second\n#define ll long long\n#define pb push_back\n#define ld long double\n#define pii pair <int, int>\n#define pll pair <long long, long long>\n\nusing namespace std;\n\nconst int mod = 1e9 + 7, N = 2222, MAXN = 4e6 + 46;\nll n, k, dp[N][N], fact[MAXN], inv[MAXN], f[MAXN];\n\ninline int C(int x, int y){\n  return fact[x] * inv[y] % mod * inv[x - y] % mod;\n}\n\nint main(){\n  //ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  cin >> n >> k;\n  if(k == 1) return cout << 1, 0;\n  fact[0] = inv[0] = inv[1] = f[0] = f[1] = 1;\n  for(int i = 1; i < MAXN; i++){\n    fact[i] = fact[i - 1] * i;\n    fact[i] %= mod;\n  }\n  for(int i = 2; i < MAXN; i++){\n    f[i] = (mod - mod / i) * f[mod % i];\n    f[i] %= mod;\n    inv[i] = f[i] * inv[i - 1];\n    inv[i] %= mod;\n  }\n  dp[0][0] = 1;\n  for(int i = 1; i <= n; i++){\n    for(int j = i; j >= 1; j--){\n      dp[i][j] = dp[i][j + 1];\n      dp[i][j] += dp[i - 1][j - 1] * (i * k - j - 1 < k - 2 ? 0 : C(i * k - j - 1, k - 2));\n      dp[i][j] %= mod;\n    }\n    dp[i][0] = dp[i][1];\n  }\n  cout << (dp[n][0] * fact[n]) % mod;\n}\n// programmer: a_h_k_81\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //\n"
  },
  {
    "language": "C++",
    "code": "// #includes {{{\n#ifdef MY_DEBUG\n#include \"header/header.hpp\"\n#else\n#include <bits/stdc++.h>\n#endif\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define LET(x,a) __typeof(a) x(a)\n//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n\n#define EXIST(e,s) ((s).find(e)!=(s).end())\n\n#define RESET(a) memset((a),0,sizeof(a))\n#define SET(a) memset((a),-1,sizeof(a))\n#define PB push_back\n#define DEC(it,command) __typeof(command) it=command\n\n//debug\n\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\n\ntypedef long long Int;\ntypedef unsigned long long uInt;\ntypedef long double rn;\n\ntemplate<class T>\nconstexpr T inf = numeric_limits<T>::has_infinity ? numeric_limits<T>::infinity():(numeric_limits<T>::max()/2);\n\nint __inf_ignore(){\n\tint t = inf<int>;\n\treturn t;\n}\n\ntypedef pair<int,int> pii;\n\nconst string nl = \"\\n\";\n\n#ifdef MY_DEBUG\n#include\"print.hpp\"\n#include\"debug.hpp\"\n#endif\n// }}}\n\n//{{{ gcd and inverse\n#define __GCD_H\nInt gcd(Int a, Int b) {\n\treturn b != 0 ? gcd(b, a % b) : a;\n}\nInt lcm(Int a, Int b) {\n\treturn a / gcd(a, b) *b;\n}\n// a x + b y = gcd(a, b)\nInt extgcd(Int a, Int b, Int &x, Int &y) {\n\tInt g = a; x = 1; y = 0;\n\tif (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n\treturn g;\n}\nInt invMod(Int a, Int m) {\n\tInt x, y;\n\tif (extgcd(a, m, x, y) == 1) return (x + m) % m;\n\telse                         return 0; // unsolvable\n}\n//}}}\n\nconst int MOD = 1000000007;\n//{{{ Modular algebra, Mint\nstruct Mint{\n\tint v;\n\ttemplate<class T>\n\tMint(T n){\n\t\tv = n%MOD;\n\t\tif(v<0)v+=MOD;\n\t}\n\tMint():v(0){}\n\texplicit operator int() const {return v;}\n\texplicit operator long long() const {return v;}\n\tinline void operator *=(const Mint &a) {\n\t\tv = (v*(long long)a.v)%MOD;\n\t}\n\tinline Mint operator *(const Mint &a) {\n\t\tMint n(*this);n*=a;\n\t\treturn n;\n\t}\n\tinline void operator+=(const Mint &a){\n\t\tv+=a.v;\n\t\tif(v>=MOD)v-=MOD;\n\t\t//\tassert(0<=v and v<MOD);\n\t}\n\tinline Mint operator+(const Mint &a){\n\t\tMint n(*this);n+=a;\n\t\treturn n;\n\t}\n\tinline Mint operator -(){\n\t\tif(v==0)return 0;\n\t\telse return Mint(MOD-v);\n\t}\n\tinline void operator -=(const Mint &a){\n\t\tv-=a.v;\n\t\tif(v<0)v+=MOD;\n\t}\n\tinline Mint operator -(const Mint &a){\n\t\tMint n(*this);n-=a;\n\t\treturn n;\n\t}\n#ifdef __GCD_H\n\tinline Mint inv(){\n\t\treturn Mint(invMod(this->v,MOD));\n\t}\n\tinline void operator /=(const Mint &a){\n\t\t(*this)*=invMod(a.v,MOD);\n\t}\n\tinline Mint operator /(const Mint &a){\n\t\tMint n(*this);n/=a;\n\t\treturn n;\n\t}\n#endif\n};\n\ntemplate<class T>\nT& operator <<(T &os, const Mint &n){\n\tos<<(int)n.v;\n\treturn os;\n}\n\ntemplate<class T>\nT& operator >>(T &is, Mint &n){\n\tlong long v;is >> v;\n\tn = Mint(v);\n\treturn is;\n}\n//}}}\n\n//{{{ fact, binom, multinom\ninline Mint fact(int n){\n\tstatic vector<Mint> __fact(1,1);\n\twhile(n>=(int)__fact.size())__fact.push_back(__fact.back()*__fact.size());\n\treturn __fact[n];\n}\ninline Mint inv_fact(int n){\n\tstatic vector<Mint> __inv_fact(1,1);\n\twhile(n>=(int)__inv_fact.size())__inv_fact.push_back(Mint(1)/fact(__inv_fact.size()));\n\treturn __inv_fact[n];\n}\n\n\ninline Mint binom_memo(int n,int r){\n\tstatic vector<vector<Mint> > __binom;\n\tstatic vector<vector<bool> > __vis;\n\tif(n<0 or r<0 or n<r)return 0;\n\twhile(n>=(int)__vis.size())__binom.push_back(vector<Mint>(__binom.size()+1)), __vis.push_back(vector<bool>(__vis.size()+1,false));\n//\twhile(n>=(int)__binom.size())__binom.push_back(vector<Mint >(__binom.size()+1,-1));\n\tif(__vis[n][r])return __binom[n][r];\n\t__vis[n][r] = true;\n\tif(r==0 or n==r)return __binom[n][r].v = 1;\n\telse return __binom[n][r] = binom_memo(n-1,r-1) + binom_memo(n-1,r);\n}\n\n#ifdef __GCD_H\ninline Mint binom(int n,int r){\n\tif(n<0 or r<0 or n<r)return 0;\n\treturn fact(n)*inv_fact(r)*inv_fact(n-r);\n//\tMint fn = fact(n), fr = fact(r), fr2 = fact(n-r);\n\t//\treturn fact(n)/(fact(r)*fact(n-r));\n//\treturn fn/(fr*fr2);\n}\n\ninline Mint multinom(const vector<int> &v){\n\tMint num(fact(accumulate(ALL(v),0))), denom(1);\n\tREP(i,v.size())denom*=fact(v[i]);\n\treturn num/denom;\n}\n#endif\n//}}}\n\nMint dp[2020][2020];\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint N,K;\n\tcin>>N>>K;\n\tif(K==1){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tdp[0][0] = 1;\n\tint K1 = K - 1;\n\tfor(int a = 0;a <= N;a++){\n\t\tint d = N*K - a - 1;\n\t\tfor(int b = 0;b <= a;b++){\n\t\t\tdp[a+1][b] += dp[a][b];\n\t\t\tdp[a][b+1] += dp[a][b] * binom(d, K - 2) * (N - b);\n\t\t\td -= K1;\n\t\t}\n\t}\n\tcout<<dp[N][N]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "# pragma comment(linker, \"/STACK: 2000000\")\n# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n';\n# define p2(v) cerr << #v << \" = \" << (complex < int > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vll vector < ll >\n# define pii pair < int , int >\nconst int mod = 1e9 + 7;\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    int n,k;\n    fi>>n>>k;\n    if (k == 1) return puts(\"1\") * 0;\n    static int f[1 << 23];\n    static int c[1 << 23];\n    auto C = [&](auto n,auto k)\n    {\n        if (!(0 <= k && k <= n)) return 0;\n        int ans = (1ll * f[n] * c[n - k]) % mod;\n        ans = (1ll * ans * c[k]) % mod;\n        return ans;\n    };\n    auto pow = [&](auto a,auto b,auto mod)\n    {\n        int ans = 1;\n        while (b)\n        {\n            if (b&1)\n                ans = (1ll * ans * a) % mod;\n            a = (1ll * a * a) % mod;\n            b /= 2;\n        }\n        return ans;\n    };\n    f[0] = c[0] = 1;\n    for (int i = 1;i <= 5e6;++i)\n        f[i] = (1ll * f[i - 1] * i) % mod;\n    const int MAX = 5e6;\n    c[MAX] = pow(f[MAX],mod - 2,mod);\n    for (int i = MAX - 1;i;--i)\n        c[i] = (1ll * c[i+1] * (i + 1)) % mod;\n    static int dp[2005][2005];\n    dp[0][0] = 1;\n    for (int i = 1;i <= n;++i)\n        for (int j = 0;j <= i;++j)\n        {\n            if (j)\n                (dp[i][j] += dp[i][j-1]) %= mod;\n            dp[i][j] = (dp[i][j] + 1ll * C(j * k + (i - j - 1) * (k - 1) + k - 2,k - 2) * dp[i-1][j]) % mod;\n        }\n    fo << (1ll * dp[n][n] * f[n]) % mod << '\\n';\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PP;\n\n/*\n    freopen(\"input\",\"r\",stdin);\n    freopen(\"output\",\"w\",stdout);\n*/\n\nll DP[2001][2001];\n\nll F[4000001];\nll I[4000001];\n\nll MOD = 1E9 + 7;\n\nint power(int a, int b)\n{\n    int ret=1;\n    for(; b>0; b/=2)\n    {\n        if(b&1)\n            ret=1LL*ret*a%MOD;\n        a=1LL*a*a%MOD;\n    }\n    return ret;\n}\n\nvoid init() {\n\tF[0] = 1;\n\tfor (ll i = 1;i <= 4000000;i++) {\n\t\tF[i] = F[i - 1] * i;\n\t\tF[i] %= MOD;\n\t}\n\tI[4000000] = power(F[4000000], MOD - 2);\n    for (ll i = 3999999;i >= 0;i--) {\n        I[i] = I[i + 1] * (i + 1);\n        I[i] %= MOD;\n    }\n\treturn;\n}\n\nll nchoosek(int a, int b) {\n\tif (b == 0 || a == b) return 1;\n\tll up = F[a];\n\tll down = I[a - b] * I[b];\n\tdown %= MOD;\n\tup *= down;\n\treturn up %= MOD;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    init();\n    memset(DP, 0, sizeof(DP));\n    DP[0][0] = 1;\n    int N, K, T;\n    cin >> N >> K;\n    if (K == 1) {\n    \tcout << 1 << endl;\n    \treturn 0;\n    }\n    T = N * K;\n    for (int i = 0;i <= N;i++) {\n    \t// Opened Slot.\n    \tfor (int j = 0;j <= i;j++) {\n    \t\t// Closed Slot.\n\n    \t\tif (i != N) {\n    \t\t\t// Open a slot.\n    \t\t\tDP[i + 1][j] += DP[i][j];\n    \t\t\tDP[i + 1][j] %= MOD;\n    \t\t}\n\n    \t\tif (i != j) {\n    \t\t\t// Close a slot.\n\n    \t\t\t// Choose One Color.\n    \t\t\tll ans = (N - j);\n\n    \t\t\tll rem = T - j * K - (i - j);\n\n    \t\t\tans *= nchoosek(rem - 1, K - 2);\n    \t\t\tans %= MOD;\n\n    \t\t\tans *= DP[i][j];\n    \t\t\tans %= MOD;\n\n    \t\t\tDP[i][j + 1] += ans;\n    \t\t\tDP[i][j + 1] %= MOD;\n    \t\t}\n\n    \t}\n    }\n    cout << DP[N][N] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<LL, LL> pll;\ntypedef pair<int, int> pii;\n\nconst int mod = 1e9 + 7;\nconst int maxn = 4000 + 5;\nconst int oo = 0x3f3f3f3f;\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\n#define fst first\n#define snd second\n#define pb push_back\n\ntemplate<typename T> T read() {\n\tT n(0), f(1);\n\tchar ch = getchar();\n\tfor( ;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n\tfor( ; isdigit(ch); ch = getchar()) n = n * 10 + ch - 48;\n\treturn n * f;\n}\n\nLL f[maxn][maxn], C[maxn][maxn];\nLL fac(int n) {\n    LL res = 1;\n    for(int i = 2; i <= n; i++) (res *= i) %= mod;\n    return res;\n}\nvoid init() {\n    for(int i = 0; i < maxn; i++) { \n        C[i][0] = C[i][i] = 1;\n        for(int j = 1; j < i; j++)\n            C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod;\n    }\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n    //freopen(\"data.txt\", \"r\", stdin);\n    //freopen(\"ans.txt\", \"w\", stdout);\n#endif\n\n    init();\n\n    int n, k;\n    n = read<int>(), k = read<int>();\n\n    f[n][n] = 1;\n\n    for(int i = n; i >= 0; i--) {\n        for(int j = n; j >= 0; j--) if(f[i][j]) {\n            if(i > 0) (f[i-1][j] += f[i][j]) %= mod;\n            if(j > i) (f[i][j-1] += f[i][j] * C[n*k-(n-i)-(n-j)*(k-1)-1][k-2] % mod) %= mod;\n        }\n    }\n    printf(\"%lld\\n\", f[0][0] * fac(n) % mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 998244353;\n\nint power(int a, int p) {\n    if (p == 0) return 1;\n    int ans = power(a, p/2);\n    ans = (1LL*ans * ans)%M;\n    if (p%2)    ans = (1LL*ans*a)%M;\n    return ans;\n}\n\nconst int N = 4e6+7, K = 2005;\nint fac[N], invfac[N];\nvoid pre() {\n    fac[0] = 1;\n    for(int i=1; i<N; i++)  fac[i] = (1LL*i*fac[i-1])%M;\n    invfac[N-1] = power(fac[N-1], M-2);\n    for (int i=N-2; i>=0; i--)  invfac[i] = (1LL*invfac[i+1]*(i+1))%M;\n}\n\nint C(int n, int r) {\n    if (r<0 || r>n) return 0;\n    int denom = (1LL*invfac[r]*invfac[n-r])%M;\n    return (1LL*fac[n]*denom)%M;\n}\n\nint dp[K][K];\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    pre();\n\n    int n, k;\n    cin>>n>>k;\n\n    if (k == 1) {\n        cout<<1<<endl;\n        return 0;\n    }\n\n    dp[n][n] = 1;\n    for (int b=n-1; b>=0; b--) {\n        for (int a=n; a>=0; a--) {\n            if (a < n)      dp[b][a] = dp[b][a+1];\n            if (a != b) {\n                int rem = n-a + (k-1)*(n-b);\n                dp[b][a] = (dp[b][a] + 1LL*C(rem-1, k-2)*dp[b+1][a])%M;\n            }\n        }\n    }\n    cout<<(1LL*dp[0][0]*fac[n])%M<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define mod 1000000007\n#define N 2010\n#define lint long long\n#define debug(x) cerr<<#x<<\"=\"<<x\n#define sp <<\" \"\n#define ln <<endl\nusing namespace std;\nint dp[N][N],f[N*N],fi[N*N];\ninline int fast_pow(int x,int k,int ans=1)\n{\tfor(;k;k>>=1,x=(lint)x*x%mod) (k&1)?ans=(lint)ans*x%mod:0;return ans; }\ninline int prelude(int n)\n{\n\tfor(int i=f[0]=1;i<=n;i++) f[i]=(lint)f[i-1]*i%mod;\n\tfi[n]=fast_pow(f[n],mod-2);\n\tfor(int i=n-1;i>=0;i--) fi[i]=fi[i+1]*(i+1ll)%mod;\n\treturn 0;\n}\ninline int C(int n,int m)\n{\n\tif(m>n||m<0||n<0) return 0;\n\treturn (lint)f[n]*fi[m]%mod*fi[n-m]%mod;\n}\nint main()\n{\n\tint n,k;scanf(\"%d%d\",&n,&k);\n\tdp[0][0]=1,prelude(n*k);\n\tif(k==1) return !printf(\"1\\n\");\n\trep(i,0,n-1) rep(j,i,n) if(dp[i][j])\n\t\t(i<j?(dp[i+1][j]+=dp[i][j])%=mod:0),\n\t\t(dp[i][j+1]+=(lint)dp[i][j]*C((j+1)*(k-1)+i-1,k-2)%mod)%=mod;\n//\trep(i,0,n) rep(j,i,n) debug(i)sp,debug(j)sp,debug(dp[i][j])ln;\n\treturn !printf(\"%lld\\n\",(lint)dp[n][n]*f[n]%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 2e+3+5;\nconst int L = 4005000;\nconst int mo = 1e+9+7;\n\nint n,k;\nLL js[L],ny[L],inv[L];\nLL f[N][N];\n\nLL calc(int n,int m){return js[n]*ny[m]%mo*ny[n-m]%mo;}\n\nLL add(LL x,LL y){return x+y>=mo?x+y-mo:x+y;}\n\nint main(){\n\tn=get();k=get();\n\tif (k==1)return printf(\"1\\n\"),0;\n\tk-=2;\n\tjs[0]=ny[0]=inv[0]=js[1]=inv[1]=ny[1]=1;\n\tfo(i,2,4004000){\n\t\tjs[i]=js[i-1]*i%mo;\n\t\tinv[i]=1ll*(mo-mo/i)*inv[mo%i]%mo;\n\t\tny[i]=ny[i-1]*inv[i]%mo;\n\t}\n\tf[0][0]=1;\n\tfo(i,0,n)\n\t\tfo(j,0,n)\n\t\tif (f[i][j]){\n\t\t\tif (j>i)f[i+1][j]=add(f[i+1][j],f[i][j]);\n\t\t\tif (j<n)f[i][j+1]=add(f[i][j+1],f[i][j]*calc(k+i+j*(k+1),i+j*(k+1))%mo);\n\t\t}\n\tprintf(\"%lld\\n\",f[n][n]*js[n]%mo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\nusing namespace std;\n\npair<long long, long long> extended_gcd(long long a, long long b) {\n    if (b == 0) return { 1, 0 };\n    auto t = extended_gcd(b, a % b);\n    return { t.second, t.first - t.second * (a / b) };\n}\n\ninline long long modinv(long long a, long long m) {\n    return (extended_gcd(a, m).first % m + m) % m;\n}\n\nconst int MOD = 1000000007;\nint fact[4000001], factinv[4000001];\n\ninline int comb(int n, int m) {\n    if (m < 0 || m > n) return 0;\n    return ((long long)fact[n] * factinv[m] % MOD) * factinv[n - m] % MOD;\n}\n\nint n, k;\nint d[2001][2001];\n\nint main() {\n    scanf(\"%d %d\", &n, &k);\n    if (k == 1) {\n        printf(\"1\\n\");\n        return 0;\n    }\n\n    fact[0] = factinv[0] = 1;\n    for (int i = 1; i <= n * k; ++i) {\n        fact[i] = (long long)fact[i - 1] * i % MOD;\n    }\n    factinv[n * k] = modinv(fact[n * k], MOD);\n    for (int i = n * k; i > 1; --i) {\n        factinv[i - 1] = (long long)factinv[i] * i % MOD;\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = i; j <= n; ++j) {\n            if (i == 0 && j == 0) {\n                d[i][j] = 1;\n                continue;\n            }\n            d[i][j] = ((i > 0 ? d[i - 1][j] : 0) + (long long)d[i][j - 1] * comb(i + j * (k - 1) - 1, k - 2)) % MOD;\n        }\n    }\n\n    int ans = d[n][n];\n    for (int i = 2; i <= n; ++i) {\n        ans = (long long)ans * i % MOD;\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\ntypedef long long LL;\nconst int maxn=2005,TT=1000000007;\nint n,K,fac[maxn*maxn],inv[maxn*maxn],F[maxn][maxn];\ninline int read()\n{\n\tint ret=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){ret=ret*10+ch-'0';ch=getchar();}\n\treturn ret*f;\n}\ninline int QP(int a,int b)\n{\n\tint ret=1,w=a;\n\twhile(b)\n\t{\n\t\tif(b&1) ret=(LL)ret*w%TT;\n\t\tw=(LL)w*w%TT;b>>=1;\n\t}\n\treturn ret;\n}\ninline int C(int n,int m){return (LL)fac[n]*inv[m]%TT*inv[n-m]%TT;}\nint main()\n{\n\tn=read();K=read();fac[0]=1;\n\tfor(int i=1;i<=4000000;i++) fac[i]=(LL)fac[i-1]*i%TT;\n\tinv[4000000]=QP(fac[4000000],TT-2);\n\tfor(int i=4000000-1;i>=0;i--) inv[i]=(LL)inv[i+1]*(i+1)%TT;\n\tF[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t\tF[i][j]=(F[i-1][j]+(j?((LL)F[i][j-1]*(n-j+1)%TT*C(n*K-i-(j-1)*(K-1)-1,K-2)%TT):0))%TT;\n\tprintf(\"%d\\n\",F[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\n//const ll inf=0x3f3f3f3f3f3f3f3fll;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\nconst int mo=1e9+7;\nint qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\n\nconst int N=2100*2100;\nint fac[N];\nint ifac[N];\nint C(int n,int m){\n\treturn 1ll*fac[n]*ifac[n-m]%mo*ifac[m]%mo;\n}\nint f[2111][2111];\nint n,k;\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tgn(n);gn(k);\n\tif(k==1){\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\trep(i,1,N)fac[i]=1ll*fac[i-1]*i%mo;\n\trep(i,0,N)ifac[i]=qp(fac[i],mo-2);\n\n\tf[0][0]=1;\n\trep(i,0,n+1)rep(j,0,i+1)if(f[i][j]){\n\t\tupmo(f[i][j+1],f[i][j]);\n\n\t\tint has=j+i*(k-1);\n\t\tupmo(f[i+1][j],1ll*f[i][j]*C(k-2+has,k-2));\n\t}\n\tint ret=f[n][n];\n\tmmo(ret,fac[n]);\n\tprintf(\"%d\\n\",ret);\n\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long \nusing namespace std;\nconst int N=2200;\nconst int MAXN=4e6;\nconst int M=1e9+7;\nll fac[N*N],inv[N*N],f[N][N];\nint n,k;\ninline ll qpow(ll a,ll b){\n\tll ans=1;\n\twhile(b){\n\t\tif(b&1) ans=ans*a%M;\n\t\tb>>=1;a=a*a%M;\n\t} \n\treturn ans;\n}\nvoid init(){\n\tfac[0]=1;\n\tfor(int i=1;i<=MAXN;i++) fac[i]=fac[i-1]*i%M;\n\tinv[MAXN]=qpow(fac[MAXN],M-2); \n\tfor(int i=MAXN;i>=1;i--) inv[i-1]=inv[i]*i%M;\n}\ninline ll C(int n,int m){\n\tif(n<m) return 0;\n\treturn fac[n]*inv[m]%M*inv[n-m]%M;\n}\nint main(){\n//\tfreopen(\"at2000.in\",\"r\",stdin);\n\tinit();\n\tscanf(\"%d%d\",&n,&k);f[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++) f[i][j]=(f[i-1][j]+(n-j+1)*C(n*k-i-(j-1)*(k-1)-1,k-2)%M*f[i][j-1])%M;\n\tprintf(\"%lld\\n\",f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 2000\n#define MOD 1000000007\n#define rint register int\n#define gc() getchar()\ninline int read(int r=0,int s=0,int c=gc()){for(;c<48||c>57;s=c,c=gc());for(;c>=48&&c<=57;(r*=10)+=c-48,c=gc());return s^'-'?r:-r;}\ninline int fxp(int s, int n=MOD-2){int a=1; for(; n; n&1 ? a = 1ll*a*s%MOD : 0, s = 1ll*s*s%MOD, n >>= 1); return a;}\nint fac[4000005], efac[4000005], f[MAXN+5][MAXN+5], n, m, N; inline int C(int n, int k){return n<0||k<0||n<k?0:1ll*fac[n]*efac[k]%MOD*efac[n-k]%MOD;}\nint main()\n{\n\tn = read(), m = read(), N = n*m; if(m==1||n==1) return puts(\"1\"),0; for(rint i = fac[0] = 1; i <= N; fac[i] = 1ll*i*fac[i-1]%MOD, i++);\n\tefac[N] = fxp(fac[N]); for(rint i = N; i; efac[i-1] = 1ll*i*efac[i]%MOD, i--); f[0][0] = 1;\n\tfor(rint i = 0, j; i <= n; i++) for(j = i; j <= n; j++)\n\t\tf[i+1][j] = (f[i+1][j]+f[i][j])%MOD, f[i][j+1] = (f[i][j+1]+1ll*C(i+j*(m-1)+m-2,m-2)*f[i][j])%MOD;\n\tprintf(\"%d\\n\",1ll*fac[n]*f[n][n]%MOD); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rg register\nusing namespace std;\nconst int mod=1e9+7;\n#define _ 2001\nint n, k, f[_][_], sum[_*_], inv[_*_];\nint qp(int x, int y){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1)ans=1ll*ans*x%mod;\n\t\tx=1ll*x*x%mod, y>>=1;\n\t}return ans;\n}\nint C(int m, int r){return 1ll*sum[m]*inv[r]%mod*inv[m-r]%mod;}\nint main(){\n\tscanf(\"%d%d\", &n, &k);\n\tif(k==1){puts(\"1\"); return 0;}\n\tinv[0]=inv[1]=sum[0]=sum[1]=1;\n\tfor(rg int i=2; i<=n*k; ++i)\n\t\tsum[i]=1ll*sum[i-1]*i%mod, inv[i]=qp(sum[i], mod-2);\n\tf[0][0]=1;\n\tfor(int i=1; i<=n; ++i)\n\t\tfor(int j=0; j<=i; ++j){\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(j)(f[i][j]+=1ll*C((n-j+1)*(k-1)+n-i-1, k-2)*f[i][j-1]%mod)%=mod;\n\t\t}\n\tfor(int i=2; i<=n; ++i)\n\t\tf[n][n]=1ll*f[n][n]*i%mod;\n\tprintf(\"%d\", f[n][n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7;\ninline int add(int a,int b){a+=b;return a>=mod?a-mod:a;}\ninline int sub(int a,int b){a-=b;return a<0?a+mod:a;}\ninline int mul(int a,int b){return (ll)a*b%mod;}\ninline int qpow(int a,int b){int ret=1;for(;b;b>>=1,a=mul(a,a))if(b&1)ret=mul(ret,a);return ret;}\n/* math */\n\n\nint n,k;\nconst int N=2e3+5;\nint fac[N*N],ifac[N*N];\ninline void init(int n){\n\tfac[0]=ifac[0]=1;for(int i=1;i<=n;i++)fac[i]=mul(fac[i-1],i);\n\tifac[n]=qpow(fac[n],mod-2);for(int i=n-1;i;i--)ifac[i]=mul(ifac[i+1],i+1);\n}\ninline int comb(int a,int b){\n\tif(b>a)return 0;\n\treturn mul(fac[a],mul(ifac[b],ifac[a-b]));\n}\n\nint main()\n{\n\tcin>>n>>k;\n\tif(k==1){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tinit(n*k);\n\tf[0][0]=1;\n\tfor(int j=1;j<=n;j++){\n\t\tf[0][j]=mul(f[0][j-1],comb(j*(k-1)-1,k-2));\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i;j<=n;j++){\n\t\t\tf[i][j]=add(f[i-1][j],mul(f[i][j-1],comb(j*(k-1)+i-1,k-2)))\n\t\t}\n\t}\n\tprintf(\"%d\\n\",mul(f[n][n],fac[n]));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pb push_back\nusing namespace std;\n\ninline int read()\n{\n\tint sum=0,ff=1; char ch=getchar();\n\twhile(!isdigit(ch))\n\t{\n\t\tif(ch=='-') ff=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch))\n\t\tsum=sum*10+(ch^48),ch=getchar();\n\treturn sum*ff;\n}\n\n\nconst int M=2005;\nconst int N=M*M;\nconst int mo=1e9+7;\n\nint n,m,jc[N],inv[N],f[M][M];\n\ninline int ksm(int x,int y)\n{\n\tint ret=1ll;\n\twhile(y)\n\t{\n\t\tif(y&1) ret=ret*x%mo;\n\t\tx=x*x%mo;\n\t\ty>>=1ll;\n\t}\n\treturn ret%mo;\n}\n\ninline void Add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=mo) x%=mo;\n}\n\ninline int C(int x,int y)\n{\n\treturn jc[x]*inv[y]%mo*inv[x-y]%mo;\n}\n\nsigned main()\n{\n\tn=read();\n\tm=read();\n\tif(m==1) return puts(\"1\"),0;\n\tinv[0]=jc[0]=1;\n\tfor ( int i=1;i<=n*m;i++ ) jc[i]=jc[i-1]*i%mo;\n\tfor ( int i=1;i<=n*m;i++ ) inv[i]=ksm(jc[i],mo-2)%mo;\n\tfor ( int i=1;i<=n;i++ ) f[i][0]=1;\n\tfor ( int i=1;i<=n;i++ ) \n\t\tfor ( int j=1;j<=i;j++ ) \n\t\t{\n\t\t\tf[i][j]=(f[i][j]+f[i-1][j]+mo)%mo;\n\t\t\tf[i][j]=(f[i][j]+1ll*f[i][j-1]*(n-j+1)%mo*C(n-i+(n-j+1)*(m-1)-1,m-2)%mo+mo)%mo;\n\t\t}\n\tprintf(\"%lld\\n\",(f[n][n]+mo)%mo);\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define F first\n#define S second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define SZ(x) (int)x.size()\n//#define int ll\n\nconst int MOD = 1e9 + 7;\n\nvoid add(int &a, int b) {\n\ta += b;\n\tif (a >= MOD) {\n\t\ta -= MOD;\n\t}\n}\n\ninline int mult(int a, int b) {\n\treturn (a * 1ll * b) % MOD;\n}\n\nint b_pow(int a, int b) {\n\tif (!b) {\n\t\treturn 1;\n\t}\n\tif (b & 1) {\n\t\treturn mult(a, b_pow(a, b - 1));\n\t}\n\treturn b_pow(mult(a, a), b >> 1);\n}\n\nconst int MX = 4e6 + 10;\nint f[MX], rf[MX];\n\nint C(int n, int k) {\n\tif (n < 0 || k < 0 || n < k) {\n\t\treturn 0;\n\t}\n\treturn mult(f[n], mult(rf[k], rf[n - k]));\n}\n\nconst int N = 2010;\nint dp[N][N];\n\nsigned main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tf[0] = 1;\n\tfor (int i = 1; i <= 4e6; i++) {\n\t\tf[i] = mult(f[i - 1], i);\n\t}\n\trf[4000000] = b_pow(f[4000000], MOD - 2);\n\tfor (int i = 4e6 - 1; i >= 0; i--) {\n\t\trf[i] = mult(rf[i + 1], i + 1);\n\t}\n\tint n, k;\n\tcin >> n >> k;\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = i; j <= n; j++) {\n\t\t\tif (!j) {\n\t\t\t\tdp[i][j] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i > 0) {\n\t\t\t\tadd(dp[i][j], dp[i - 1][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tadd(dp[i][j], mult(dp[i][j - 1], C(i + j * (k - 1) - 1, k - 2)));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = dp[n][n];\n\tfor (int i = 2; i <= n; i++) {\n\t\tans = mult(ans, i);\n\t}\n\tcout << ans << '\\n';\n}\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for(int i=(a),_ed=(b);i<=_ed;++i)\n#define DREP(i,a,b) for(int i=(a),_ed=(b);i>=_ed;--i)\n#define mp(x,y) make_pair((x),(y))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int,int> pii;\ninline int read(){\n    register int x=0,f=1;register char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=0;ch=getchar();}\n    while(isdigit(ch)){x=x*10+(ch^'0');ch=getchar();}\n    return f?x:-x;\n}\n\nconst int mod=1000000007;\nint n,k,f[4005][2005],fac[16000005],ifc[16000005];\ninline void inc(int& x,int y){x=x+y<mod?x+y:x+y-mod;}\ninline void dec(int& x,int y){x=x-y>=0?x-y:x-y+mod;}\ninline int power(int b,int n){int ans=1;for(;n;n>>=1,b=1ll*b*b%mod)if(n&1)ans=1ll*ans*b%mod;return ans;}\ninline int C(int n,int m){return (n<0||m<0||n<m)?0:1ll*fac[n]*ifc[m]%mod*ifc[n-m]%mod;}\n\nint main(){\n\t// freopen(\"in.in\",\"r\",stdin);\n\tn=read(),k=read();\n\tREP(i,fac[0]=1,16000001)fac[i]=1ll*fac[i-1]*i%mod;\n\tifc[16000001]=power(fac[16000001],mod-2);\n\tDREP(i,16000001,1)ifc[i-1]=1ll*ifc[i]*i%mod;\n\tif(k==1)return puts(\"1\"),0;\n\tf[0][0]=1;\n\tREP(i,0,n+n-1)REP(j,0,i>>1)if(f[i][j]){\n\t\tif(i-j>j)inc(f[i+1][j+1],f[i][j]);\n\t\tint num=(i-j)*(k-1)+j+1;\n\t\tinc(f[i+1][j],1ll*(n-i+j)*f[i][j]%mod*C(k-2+num-1,num-1)%mod);\n\t}\n\tprintf(\"%d\\n\",f[n+n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=2005,mod=1e9+7;\nint f[N][N],fac[N*N],ifac[N*N];\nint Pow(int x,int k){\n\tint ret=1;\n\twhile(k){\n\t\tif(k&1)ret=1ll*ret*x%mod;\n\t\tk>>=1;x=1ll*x*x%mod;\n\t}\n\treturn ret;\n}\nint C(int n,int m){\n\tif(n<m)return 0;\n\treturn 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\nint main(){\n\tfac[0]=1;\n\tfor(int i=1;i<=4000000;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\tifac[4000000]=Pow(fac[4000000],mod-2);\n\tfor(int i=3999999;~i;i--)ifac[i]=1ll*ifac[i+1]*(i+1)%mod;\n\tint n,m;scanf(\"%d%d\",&n,&m);\n\tif(m==1)cout<<1<<\"\\n\",exit(0);\n\tf[0][0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(j<i)f[i][j+1]=(f[i][j+1]+f[i][j])%mod;\n\t\t\tf[i+1][j]=(f[i+1][j]+1ll*C(i*(m-1)+j+m-2,m-2)*f[i][j])%mod;\n\t\t}\n\t}\n\tcout<<1ll*f[n][n]*fac[n]%mod<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int N = 2000 + 10;\nconstexpr int MOD = 1e9 + 7;\n\nlong long dp[N][N], fact[N * N], n, k;\n\nlong long mypow (long long a, long long b) {\n    return b ? (mypow (a * a % MOD, b >> 1) * (b & 1 ? a : 1)) % MOD : 1;\n}\n\nlong long ch (long long a, long long b) {\n    return (fact[a] * mypow (fact[b] * fact[a - b] % MOD, MOD - 2)) % MOD;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> k;\n    if (k == 1) {\n        cout << 1 << '\\n';\n        return 0;\n    }\n    fact[0] = 1;\n    for (int i = 1; i < N * N; i++)\n        fact[i] = (fact[i - 1] * i) % MOD;\n    for (int i = 0; i <= n; i++) {\n        for (int j = i; j <= n; j++) {\n            if (i == 0) {\n                if (j == 0)\n                    dp[i][j] = 1;\n                else {\n                    dp[i][j] = ch (j * (k - 1) - 1, k - 2) * dp[i][j - 1];\n                    dp[i][j] %= MOD;\n                }\n                continue;\n            }\n            dp[i][j] = dp[i - 1][j] + ch (i + j * (k - 1) - 1, k - 2) * dp[i][j - 1];\n            dp[i][j] %= MOD;\n        }\n    }\n    cout << (dp[n][n] * fact[n]) % MOD << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long LL;\n\nLL powmod(LL a, int n){\n\tif(n == 0) return 1;\n\tif(n % 2) return (a*powmod(a,n-1)) % MOD;\n\tLL c = powmod(a,n/2);\n\treturn (c*c) % MOD;\n}\nLL inv(LL a){\n\treturn powmod(a,MOD-2);\n}\nLL dp[2100][2100];\nLL fact[5000000];\nLL invfact[5000000];\nint main(){\n\tint n, k;\n\tcin >> n >> k;\n\tif(k == 1){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tfact[0] = 1;\n\tfor(LL i = 1; i <= 4010000; i++) fact[i] = (fact[i-1]*i) % MOD;\n\tinvfact[4010000] = inv(fact[4010000]);\n\tfor(LL i = 4010000-1; i >= 0; i--) invfact[i] = (invfact[i+1] * (i+1)) % MOD;\n\n\tdp[0][0] = 1;\n\tfor(int a = 1; a <= n; a++){\n\t\tfor(int b = a; b >= 0; b--){\n\t\t\tLL r = 0;\n\t\t\tif(b > 0){\n\t\t\t\tr = (a*fact[a*k-b-1]) % MOD;\n\t\t\t\tr = (r*invfact[k-2]) % MOD;\n\t\t\t\tr = (r*invfact[a*k-b-1 - (k-2)]) % MOD;\n\t\t\t\tr = (r*dp[a-1][b-1]) % MOD;\n\t\t\t}\n\t\t\tr = (r + dp[a][b+1]) % MOD;\n\t\t\tdp[a][b] = r;\n\t\t}\n\t}\n\tcout << dp[n][0] % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "    #include <iostream>\n    #include <string>\n    #include <set>  \n    #include <algorithm>\n    #include <vector>\n    #include <cmath>\n    #include <queue>\n    #include <deque>\n    #include <cstring>\n    #include <cstdio>\n    #include <map>\n    #include <numeric>\n    #include <cassert>\n    #include <iomanip>\n    #include <sstream>\nusing namespace std;\ntypedef long long LL;\nconst int MAXN=2002;\nconst int MAXM=MAXN*MAXN;\nconst LL M=1e9+7;\nLL fac[MAXM],inv[MAXM],f[MAXN][MAXN];\nint N,K;\nLL C(int x,int y)\n{\n\tif(x<y)return 0;\n\treturn fac[x]*inv[y]%M*inv[x-y]%M;\n}\nint main()\n{\n\tscanf(\"%d %d\",&N,&K);\n\tif(K==1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=inv[0]=inv[1]=1LL;\n\tfor(int i=1;i<=MAXM;i++)\n\t\tfac[i]=1LL*fac[i-1]*i%M;\n\tfor(int i=2;i<=MAXM;i++)\n\t\tinv[i]=1LL*(M-M/i)*inv[M%i]%M;\n\tfor(int i=1;i<=MAXM;i++)\n\t\tinv[i]=inv[i-1]*inv[i]%M;\n\tf[0][0]=1;\n\tfor(int i=1;i<=N;i++)\n\t\tfor(int j=i;~j;j--)\n\t\t{\n\t\t\tf[i][j]=f[i][j+1];\n\t\t\tif(j)f[i][j]+=f[i-1][j-1]*C(i*K-j-1,K-2)%M;\n\t\t\tf[i][j]%=M;\n\t\t}\n\tprintf(\"%lld\\n\",f[N][0]*fac[N]%M);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\ni64 modpow(i64 a, i64 p = MOD - 2)\n{\n\tif (p == 0) return 1;\n\ti64 tmp = modpow(a, p / 2);\n\ttmp = tmp * tmp % MOD;\n\tif (p % 2) tmp = tmp * a % MOD;\n\treturn tmp;\n}\n\nint N, K;\ni64 fact[4040404], frev[4040404];\ni64 invs[4040404];\n\ni64 C(int a, int b)\n{\n\tif (a < b) return 0;\n\treturn fact[a] * frev[b] % MOD * frev[a - b] % MOD;\n}\n\ni64 dp[4020][2020];\n\ni64 solve(int nz, int nk)\n{\n\tif (dp[nz][nk] != -1) return dp[nz][nk];\n\n\tif (nz == N && nk == N) return dp[nz][nk] = 1;\n\n\tdp[nz][nk] = 0;\n\tif (nz < N) {\n\t\tADD(dp[nz][nk], solve(nz + 1, nk));\n\t}\n\tif (nk < N && nk < nz) {\n\t//\tprintf(\"%d %d, %d %d\\n\", nz, nk, N * K - nz - nk * (K - 1) - 1, K - 2);\n\t\tADD(dp[nz][nk], solve(nz, nk + 1) * C(N * K - nz - nk * (K - 1) - 1, K - 2) % MOD);\n\t}\n\t//printf(\"%d %d: %lld\\n\", nz, nk, dp[nz][nk]);\n\treturn dp[nz][nk];\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &N, &K);\n\n\tif (K == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfact[0] = 1; frev[0] = 1;\n\tinvs[0] = 1;\n\tinvs[1] = 1;\n\tfor (int i = 2; i < 4040404; ++i) invs[i] = MOD - MOD / i * invs[MOD % i] % MOD;\n\tfor (int i = 1; i < 4040404; ++i) {\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\tfrev[i] = frev[i - 1] * invs[i] % MOD;\n\t}\n\n\tfor (int i = 0; i <= N + K; ++i) {\n\t\tfor (int j = 0; j <= N; ++j) dp[i][j] = -1;\n\t}\n\ti64 sol = solve(0, 0);\n\tsol = sol * fact[N] % MOD;\n\tprintf(\"%lld\\n\", sol);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9+7;\n\nconst int maxn = 2001;\n\nlong long int dp[maxn][maxn];\nlong long int fac[4000001],inv[4000001];\nvoid update(long long int& x,long long int y){\n\tx=(x+y)%mod;\n}\nlong long int C(long long int N,long long int K){\n\treturn fac[N]*inv[K]%mod*inv[N-K]%mod;\n}\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,k;\n\tdp[0][0]=1;\n\tcin>>n>>k;\n\tfac[0]=inv[0]=fac[1]=inv[1]=1;\n\tfor(int i=2;i<=4000000;i++)\n\t\tfac[i]=fac[i-1]*i%mod;\n\tfor(int i=2;i<=4000000;i++)\n\t\tinv[i]=(mod-mod/i*inv[mod%i]%mod)%mod;\n\tfor(int i=2;i<=4000000;i++)\n\t\tinv[i]=inv[i-1]*inv[i]%mod;\n\tif(k==1){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=i;j<=n;j++){\n\t\t\tif(i==0&&j==0)\tcontinue;\n\t\t\tif(j>i)\n\t\t\t\tupdate(dp[i][j],C(i+j*(k-1)-1,k-2)*dp[i][j-1]);\n\t\t\tif(i>0)\n\t\t\t\tupdate(dp[i][j],dp[i-1][j]);\n\t\t}\n\tcout<<dp[n][n]*fac[n]%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7,N=2002;\nint n,k,f[N][N],fac[N*N],inv[N*N],ans;\nint C(int n,int m){return n<m?0:1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1){puts(\"1\");return 0;}\n\tfac[0]=1;for(int i=1;i<=n*k;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[0]=inv[1]=1;for(int i=2;i<=n*k;i++)inv[i]=1ll*inv[mod%i]*(mod-mod/i)%mod;\n\tfor(int i=2;i<=n*k;i++)inv[i]=1ll*inv[i-1]*inv[i]%mod;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=i;~j;j--)\n\tf[i][j]=(f[i][j]+1ll*f[i-1][j-1]*C(k*i-j-1,k-2)%mod+f[i][j+1])%mod;\n\tf[n][0]=1ll*f[n][0]*fac[n]%mod;\n\tprintf(\"%d\",f[n][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\nconst int MAXN=2005;\nconst int MAXM=4000005;\nconst int MOD=1e9+7;\n\nll n,k;\nll d[MAXN][MAXN],fac[MAXM],inv[MAXM];\n\nvoid Init(){\n    fac[0]=1;\n    for(int i=1;i<MAXM;i++) fac[i]=fac[i-1]*i%MOD;\n    inv[1]=1;\n    for(int i=2;i<MAXM;i++) inv[i]=1ll*(MOD-MOD/i)*inv[MOD%i]%MOD;\n    inv[0]=1;\n    for(int i=1;i<MAXM;i++) inv[i]=inv[i]*inv[i-1]%MOD;\n}\n\nll C(ll x,ll y){\n    if(x<y) return 0;\n    return (fac[x]*inv[y]%MOD)*inv[x-y]%MOD;\n}\n\nint main(){\n\n    Init();\n    scanf(\"%lld%lld\",&n,&k);\n    if(k==1) return puts(\"1\"),0;\n    d[0][0]=1;\n    for(int i=0;i<=n;i++)\n        for(int j=0;j<=i;j++){\n            if(i) d[i][j]=d[i-1][j];\n            if(j) d[i][j]=(d[i][j]+d[i][j-1]*C(n*k-i-(j-1)*(k-1)-1,k-2)%MOD)%MOD;\n        }\n    d[n][n]=(d[n][n]*fac[n])%MOD;\n    printf(\"%lld\",d[n][n]);\n\n    fclose(stdin);\n    fclose(stdout);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline int read(){\n\tint ans=0,w=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar();\n\treturn ans*w;\n}\nconst int N=2005,Maxn=2000*2000+1e5+5,mod=1e9+7;\nint n,k,f[N][N],fac[Maxn],ifac[Maxn];\ninline int C(int n,int m){return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;}\nint main(){\n\tn=read(),k=read(),ifac[0]=fac[0]=fac[1]=ifac[1]=1;\n\tif(k==1)return puts(\"1\"),0;\n\tfor(int i=2;i<=Maxn-5;++i)fac[i]=1ll*fac[i-1]*i%mod,ifac[i]=1ll*(mod-mod/i)*ifac[mod%i]%mod;\n\tfor(int i=2;i<=Maxn-5;++i)ifac[i]=1ll*ifac[i]*ifac[i-1]%mod;\n\tf[1][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<=i;++j){\n\t\t\tif(i^j)(f[i][j+1]+=f[i][j]%=mod);\n\t\t\tif(i^n)(f[i+1][j]+=1ll*f[i][j]*C((k-2)+(i*(k-1)+j),k-2)%mod)%=mod;\n\t\t}\n\tcout<<1ll*f[n][n]*fac[n]%mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*只要保证这个颜色开始的第一个填在第一个空位上\n之后的都随便填即可\n所以方案数就是C(空格位置-1,数量-1),组合意义就是这个颜色的小球中有一个小球填的位置是被钦定的，然后有一个空位也是被钦定填的，所以都要-1*/\n#include<bits/stdc++.h>\n#define Mod 1000000007\n#define N 2005\n#define M N*N\nusing namespace std;\nint n,K,dp[N][N],fac[M],inv[M];\ninline int ksm(int x,int y){\n\tint ans1=1;while (y){\n\t\tif (y&1) ans1=1ll*ans1*x%Mod;\n\t\ty>>=1;x=1ll*x*x%Mod;\n\t}return ans1;\n}\ninline int C(int n,int m){return 1ll*fac[n]*inv[m]%Mod*inv[n-m]%Mod;}\nint main(){\n\tscanf(\"%d%d\",&n,&K);\n\tif (K==1) return puts(\"1\"),0;dp[0][0]=1;\n\tfac[0]=1;for (int i=1;i<M;i++) fac[i]=1ll*fac[i-1]*i%Mod;\n\tinv[M-1]=ksm(fac[M-1],Mod-2);\n\tfor (int i=M-2;~i;i--) inv[i]=1ll*inv[i+1]*(i+1)%Mod;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<=i;j++){\n\t\t\tif (i) dp[i][j]=1ll*(dp[i][j]+dp[i-1][j])%Mod;\n\t\t\tif (j) dp[i][j]=1ll*(1ll*dp[i][j-1]*C(n*K-i-(j-1)*(K-1)-1,K-2)%Mod+dp[i][j])%Mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",1ll*dp[n][n]*fac[n]%Mod);//颜色序列有n!种排列 \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAXN 2000\n#define MAXM 4000000\n#define MO 1000000007\nint dp[MAXN+5][MAXN+5],n,k;\nint fac[MAXM+5],inv[MAXM+5];\nint PowMod(int a,int b)\n{\n\tint ret=1;\n\twhile(b)\n\t{\n\t\tif(b&1) ret=1LL*ret*a%MO;\n\t\ta=1LL*a*a%MO;\n\t\tb>>=1;\n\t}\n\treturn ret;\n}\nint C(int n,int m)\n{\n\treturn 1LL*fac[n]*inv[m]%MO*inv[n-m]%MO;\n}\nint main()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=MAXM;i++)\n\t\tfac[i]=1LL*fac[i-1]*i%MO;\n\tinv[MAXM]=PowMod(fac[MAXM],MO-2);\n\tfor(int i=MAXM-1;i>=0;i--)\n\t\tinv[i]=1LL*inv[i+1]*(i+1)%MO;\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1)\n\t{\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\tif(j!=0)\n\t\t\t\tdp[i][j]+=1LL*dp[i][j-1]*C(n*k-i-(k-1)*(j-1)-1,k-2)%MO;\n\t\t\tdp[i][j]%=MO;\n\t\t}\n\tint ans=1LL*dp[n][n]*fac[n]%MO;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define dbug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile ('0'>ch||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo {(t*=10)+=ch-'0';ch=getchar();} while ('0'<=ch&&ch<='9'); t*=f;\n}\ntypedef long long ll;\nconst ll mod=(1e9)+7;\nconst int maxn=2000*2000+10;\nint n,k;\nll iv[maxn],ivjc[maxn];\nll dp[2010][2010],jc[maxn];\nll C(int x,int y) {\n\treturn jc[x]*ivjc[y]%mod*ivjc[x-y]%mod;\n}\nll ksm(ll x,int y) {\n\tll res=1;\n\twhile (y) {\n\t\tif (y&1) res=res*x%mod;\n\t\tx=x*x%mod; y>>=1;\n\t} return res;\n}\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tread(n); read(k);\n\tif (k==1) { printf(\"1\\n\"); return 0; }\n\tiv[0]=jc[0]=ivjc[0]=1;\n\tiv[1]=jc[1]=ivjc[1]=1;\n\tfor (int i=2;i<=n*k;i++)\n\t\tjc[i]=jc[i-1]*i%mod;\n\tivjc[n*k]=ksm(jc[n*k],mod-2);\n\tfor (int i=n*k-1;i>=2;i--)\n\t\tivjc[i]=ivjc[i+1]*(i+1)%mod;\n\tdp[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=i;j>=0;j--)\n\t\tdp[i][j]=(dp[i-1][j-1]*C(k*i-j-1,k-2)+dp[i][j+1])%mod;\n\tprintf(\"%lld\\n\",dp[n][0]*jc[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nbool chkmax(int &x,int y){return x<y?x=y,true:false;}\nbool chkmin(int &x,int y){return x>y?x=y,true:false;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int cys=1000000007;\nint n,k;\nll d[2005][2005],fac[4000005],inv[4000005];\n\nll mod(ll x){return x>=cys?x-cys:x;}\nll C(ll x,ll y){return x<y?0:fac[x]*inv[y]%cys*inv[x-y]%cys;}\n\nll qpow(ll x,ll p){\n\tll ret=1;\n\tfor(;p;p>>=1,x=x*x%cys) if(p&1) ret=ret*x%cys;\n\treturn ret;\n}\n\nint main(){\n\tn=readint(); k=readint();\n\tif(k==1) return printf(\"1\\n\"),0;\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=n*k;i++) fac[i]=fac[i-1]*i%cys;\n\tinv[n*k]=qpow(fac[n*k],cys-2);\n\tfor(int i=n*k-1;i>=1;i--) inv[i]=inv[i+1]*(i+1)%cys;\n\td[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t\td[i][j]=mod(d[i-1][j]*C((i-1)*(k-1)+j+k-2,k-2)%cys+(j>0?d[i][j-1]:0));\n\tcout<<d[n][n]*fac[n]%cys<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#define fr(i,a,b) for(int i=a;i<=b;i++)\n#define frn(i,a,b) for(int i=a;i>=b;i--)\n#define ll long long\n#define N 2010\n#define mod 1000000007\nusing namespace std;\n\nll f[N][N],jc[(N+2)*N],ny[(N+2)*N];\n\ninline ll C(ll x,ll y){\n\treturn (((1ll*jc[y]*ny[x]))%mod*ny[y-x])%mod;\n}\n\ninline ll ksm(ll a,ll p){\n\tll ans=1;\n\twhile(p){\n\t\tif(p&1)(ans*=1ll*a)%=mod;\n\t\t(a*=1ll*a)%=mod;p/=2;\n\t}\n\treturn ans;\n}\n\nint main(){\n\tll n,m;\n\tscanf(\"%lld%lld\",&n,&m);\n\tif(m==1){printf(\"1\");return 0;}\n\tjc[0]=1;\n\tfr(i,1,n*m)jc[i]=(1ll*jc[i-1]*i)%mod;\n\tny[n*m]=ksm(jc[n*m],mod-2);\n\tfrn(i,n*m-1,0)ny[i]=(1ll*ny[i+1]*(i+1))%mod;\n\tf[0][0]=1;\n\tfr(i,1,n)\n\t\tfr(j,0,i){\n\t\t\tf[i][j]=(1ll*f[i-1][j])%mod;\n\t\t\tif(!j)continue;\n\t\t\t(f[i][j]+=((1ll*f[i][j-1]*(n-j+1))%mod*C(m-2,n*m-i-(j-1)*(m-1)-1))%mod)%=mod;\n\t\t}\n\tprintf(\"%lld\",f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 2333\n#define mod 1000000007\n\nint n,k;\nlong long fac[N*N],inv[N*N],f[N][N];\n\nlong long c(int x,int y){\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\n\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-')  f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n\nint main(){\n\tn=read();k=read();f[n][n]=1;\n\tif (k==1) {printf(\"1\\n\");return 0;}\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor (int i=2;i<N*N;i++) fac[i]=fac[i-1]*i%mod;\n\tfor (int i=2;i<N*N;i++) inv[i]=-(mod/i)*inv[mod%i]%mod;\n\tfor (int i=2;i<N*N;i++) inv[i]=inv[i-1]*(inv[i]+mod)%mod;\n\tfor (int i=n;i>=0;i--)\n\t\tfor (int j=i;j>=0;j--){\n\t\t\tf[i][j]=(f[i][j]+f[i+1][j])%mod;\n\t\t\tif (i>j) f[i][j]=(f[i][j]+f[i][j+1]*c((n-j)*k-(i-j)-1,k-2))%mod;\n\t\t}\n\tprintf(\"%lld\\n\",f[0][0]*fac[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define F first\n#define S second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define SZ(x) (int)x.size()\n//#define int ll\n\nconst int MOD = 1e9 + 7;\n\nvoid add(int &a, int b) {\n\ta += b;\n\tif (a >= MOD) {\n\t\ta -= MOD;\n\t}\n}\n\ninline int mult(int a, int b) {\n\treturn (a * 1ll * b) % MOD;\n}\n\nint b_pow(int a, int b) {\n\tif (!b) {\n\t\treturn 1;\n\t}\n\tif (b & 1) {\n\t\treturn mult(a, b_pow(a, b - 1));\n\t}\n\treturn b_pow(mult(a, a), b >> 1);\n}\n\nconst int MX = 4e6 + 10;\nint f[MX], rf[MX];\n\nint C(int n, int k) {\n\tif (n < 0 || k < 0 || n < k) {\n\t\treturn 0;\n\t}\n\treturn mult(f[n], mult(rf[k], rf[n - k]));\n}\n\nconst int N = 2010;\nint dp[N][N];\n\nsigned main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tf[0] = 1;\n\tfor (int i = 1; i <= 4e6; i++) {\n\t\tf[i] = mult(f[i - 1], i);\n\t}\n\trf[4000000] = b_pow(f[4000000], MOD - 2);\n\tfor (int i = 4e6 - 1; i >= 0; i--) {\n\t\trf[i] = mult(rf[i + 1], i + 1);\n\t}\n\tint n, k;\n\tcin >> n >> k;\n\tif (k == 1) {\n\t\tcout << 1 << '\\n';\n\t\texit(0);\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = i; j <= n; j++) {\n\t\t\tif (!j) {\n\t\t\t\tdp[i][j] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i > 0) {\n\t\t\t\tadd(dp[i][j], dp[i - 1][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tadd(dp[i][j], mult(dp[i][j - 1], C(i + j * (k - 1) - 1, k - 2)));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = dp[n][n];\n\tfor (int i = 2; i <= n; i++) {\n\t\tans = mult(ans, i);\n\t}\n\tcout << ans << '\\n';\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nconst int N = 2e3 + 7, MXA = 4e6 + 7;\nlong long M = 1e9 + 7;\nint fc[MXA];\nint rfc[MXA];\nlong long pw(int a, int b) {\n\tif (b == 0)\n\t\treturn 1;\n\tint t = pw(a, b / 2);\n\tt = (t * t) % M;\n\tif (b % 2)\n\t\tt = (t * a) % M;\n\treturn t;\n}\nint rk;\nlong long chs(int a, int b) {\n\tlong long t = fc[b];\n\tt = (t * rk) % M;\n\tt = (t * pw(fc[b - a], M - 2)) % M;\n\treturn t;\n}\nint n, k;\nint dp[N][N];\nint32_t main() {\n\tfc[0] = rfc[0] =  1;\n\t\n\tfor (int i = 1; i < MXA; i++)\n\t\tfc[i] = (fc[i - 1] * i) % M;\n\tdp[0][0] = 1;\n\tcin >> n >> k;\n\trk = pw(fc[k - 2], M - 2);\n\tif (k == 1) {\n\t\tcout << 1;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int j = i; j <= n; j++) {\n\t\t\tif (i + j == 0)\n\t\t\t\tcontinue;\n\t\t\tif (i > 0)\n\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\tif (j > i) {\n\t\t\t\tint tmp = i + j * (k - 1) - 1;\n\t\t\t\tdp[i][j] += (chs(k - 2, tmp) * dp[i][j - 1]) % M;\n\t\t\t\tdp[i][j] %= M;\n//\t\t\t\tcout << i << \" \" << j << \" > \" << dp[i][j] << \" \" << tmp << \" \" << (fc[tmp] * rfc[k - 2] % M) * rfc[tmp - (k - 2)] % M << endl;\n\t\t\t}\n\t\t}\n\tcout << (dp[n][n] * fc[n]) % M;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define Inv(x) QPow(x,Mod-2);\n\nconst int maxN=2005;\nconst int maxM=maxN*maxN;\nconst int Mod=1e9+7;\n\nint n,K;\nint Fc[maxM],Ifc[maxM];\nint F[maxN][maxN];\n\nint QPow(int x,int cnt);\nint C(int n,int m);\nint main(){\n    Fc[0]=Ifc[0]=1;for (int i=1;i<maxM;i++) Fc[i]=1ll*Fc[i-1]*i%Mod;\n    Ifc[maxM-1]=Inv(Fc[maxM-1]);for (int i=maxM-2;i>=1;i--) Ifc[i]=1ll*Ifc[i+1]*(i+1)%Mod;\n    \n    scanf(\"%d%d\",&n,&K);\n    if (K==1){\n\tputs(\"1\");return 0;\n    }\n\n    F[0][0]=1;\n    for (int i=1;i<=n;i++)\n\tfor (int j=n;j>=0;j--){\n\t    if (j<=i&&j>=0) F[i][j]=1ll*F[i-1][j-1]*C(i*K-j-1,K-2)%Mod;\n\t    F[i][j]=(F[i][j]+F[i][j+1])%Mod;\n\t}\n    /*\n    for (int i=0;i<=n;i++){\n\tfor (int j=0;j<=n;j++) cout<<F[i][j]<<\" \";\n\tcout<<endl;\n    }//*/\n    int Ans=1ll*F[n][0]*Fc[n]%Mod;\n    printf(\"%d\\n\",Ans);return 0;\n}\nint QPow(int x,int cnt){\n    int ret=1;\n    while (cnt){\n\tif (cnt&1) ret=1ll*ret*x%Mod;\n\tx=1ll*x*x%Mod;cnt>>=1;\n    }\n    return ret;\n}\nint C(int n,int m){\n    if (n<0||m<0||n<m) return 0;\n    return 1ll*Fc[n]*Ifc[m]%Mod*Ifc[n-m]%Mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\n#define MOD 1000000007\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int MAXN = 2000 + 10;\nconst int MAXM = MAXN * MAXN;\n\nint N, K;\n\nLL fact[MAXM]= {0}, invfact[MAXM]= {0};\nvoid init () {\n\tfact[0] = fact[1] = invfact[0] = invfact[1] = 1;\n\tfor (int i = 2; i <= N * K; i ++) {\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\tinvfact[i] = (MOD - MOD / i) * invfact[MOD % i] % MOD;\n\t}\n\tfor (int i = 1; i <= N * K; i ++)\n\t\tinvfact[i] = invfact[i - 1] * invfact[i] % MOD;\n}\ninline LL C (int n, int m) {\n\tif (n < 0) return 0;\n\tif (m == 0) return 1;\n\treturn fact[n] * invfact[m] % MOD * invfact[n - m] % MOD;\n}\n\nLL f[MAXN][MAXN]= {0};\n\nint main () {\n\tscanf (\"%d%d\", & N, & K);\n\tif (K == 1) {\n\t\tputs (\"1\");\n\t\treturn 0;\n\t}\n\tinit ();\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= N; i ++)\n\t\tfor (int j = 0; j <= i; j ++) {\n\t\t\tLL delta = f[i][j - 1] * (N - j + 1) % MOD * C (N * K - i - (K - 1) * (j - 1) - 1, K - 2) % MOD;\n\t\t\tif (j == 0) delta = 0;\n\t\t\tf[i][j] = (f[i][j] + f[i - 1][j] + delta) % MOD;\n\t\t}\n\tcout << f[N][N] << endl;\n\n\treturn 0;\n}\n\n/*\n2 2\n*/\n\n/*\n3 1\n*/\n\n/*\n2 3\n*/\n\n/*\n2000 2000\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int N=2100,mod=1e9+7;\nint n,k,jc[N*N],inv[N*N],f[N][N];\nint ksm(int x,int k)\n{\n\tint s=1;for(;k;k>>=1,x=1ll*x*x%mod)\n\t\t\t\tif(k&1) s=1ll*s*x%mod;return s;\n}\nvoid add(int &x,int y) {x+=y;if(x>=mod) x-=mod;}\nint mul(int x,int y) {return 1ll*x*y%mod;}\nint C(int n,int k) {return n<k?0:mul(mul(jc[n],inv[k]),inv[n-k]);}\nint main()\n{\n\tcin>>n>>k;jc[0]=inv[0]=1;\n\tif(n==1) return puts(\"1\"),0;\n\tfor(int i=1;i<=n*k;i++)\n\t\tjc[i]=mul(jc[i-1],i),inv[i]=ksm(jc[i],mod-2);\n\tf[0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tif(!f[i][j]) continue;\n\t\t\tadd(f[i+1][j],f[i][j]);\n\t\t\tif(i>=j+1) add(f[i][j+1],mul(mul(f[i][j],n-j),C(n*k-j*k+j-i-1,k-2)));\n\t\t}\n\tcout<<f[n][n]<<endl;return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)\n#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)\n#define pb push_back\n#define Chkmax(a,b) a=a>b?a:b\n#define Chkmin(a,b) a=a<b?a:b\n#define mx(a,b) (a>b?a:b)\n#define mn(a,b) (a<b?a:b)\ntypedef unsigned long long uint64;\ntypedef unsigned int uint32;\ntypedef long long ll;\nusing namespace std;\n\nnamespace IO\n{\n    const uint32 Buffsize=1<<15,Output=1<<23;\n    static char Ch[Buffsize],*S=Ch,*T=Ch;\n    inline char getc()\n\t{\n\t\treturn((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);\n\t}\n    static char Out[Output],*nowps=Out;\n    \n    inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}\n\n    template<typename T>inline void read(T&x)\n\t{\n\t\tx=0;static char ch;T f=1;\n\t\tfor(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;\n\t\tfor(;isdigit(ch);ch=getc())x=x*10+(ch^48);\n\t\tx*=f;\n\t}\n\n\ttemplate<typename T>inline void write(T x,char ch='\\n')\n\t{\n\t\tif(!x)*nowps++='0';\n\t\tif(x<0)*nowps++='-',x=-x;\n\t\tstatic uint32 sta[111],tp;\n\t\tfor(tp=0;x;x/=10)sta[++tp]=x%10;\n\t\tfor(;tp;*nowps++=sta[tp--]^48);\n\t\t*nowps++=ch;\n\t}\n}\nusing namespace IO;\n\ninline void file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"water.in\",\"r\",stdin);\n\tfreopen(\"water.out\",\"w\",stdout);\n#endif\n}\n\nconst int MAXN=2011;\n\nstatic int n,k,dp[MAXN][MAXN];\n\ninline void init()\n{\n\tread(n);read(k);\n}\n\nconst int mod=1e9+7;\n\ninline int ad(int u,int v){return(u+=v)>=mod?u-mod:u;}\n\nstatic int func[MAXN*MAXN],inv[MAXN*MAXN];\n\ninline int power(int u,int v)\n{\n\tstatic int sm;\n\tfor(sm=1;v;v>>=1,u=(uint64)u*u%mod)if(v&1)\n\t\tsm=(uint64)sm*u%mod;\n\treturn sm;\n}\n\ninline int C(int u,int v)\n{return u>=v?(uint64)func[u]*inv[v]%mod*inv[u-v]%mod:0;}\n\ninline void solve()\n{\n\tif(k==1)return (void)printf(\"1\\n\");\n\n\tdp[0][0]=1;\n\t\n\tfunc[0]=1;\n\tRep(i,1,n*k)func[i]=(uint64)func[i-1]*i%mod;\n\tinv[n*k]=power(func[n*k],mod-2);\n\tRepe(i,n*k,1)inv[i-1]=(uint64)inv[i]*i%mod;\n\n\tRep(i,0,n)Rep(j,i,n)\n\t{\n\t\tif(j>i)dp[i][j]=dp[i][j-1];\n\t\tif(i)dp[i][j]=ad(dp[i][j],(uint64)dp[i-1][j]*\n\t\t\tC(n*k-(i-1)*(k-1)-j-1,k-2)%mod);\n\t}\n\tprintf(\"%d\\n\",(uint64)dp[n][n]*func[n]%mod);\n}\n\nint main()\n{\n    init();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region\n#ifndef M207\n#pragma GCC optimize(\"O2,Ofast,inline,unroll-all-loops,-ffast-math\")\n#pragma GCC target(\"avx,sse2,sse3,sse4,popcnt\")\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\n#define il inline\n#define LL long long\n#define uint unsigned int\n#define ull unsigned long long\n#define solid const auto &\n#define pb emplace_back\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define fi first\n#define se second\n#define gm int mid((l+r)/2)\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define rd() ({ri t;in(t);t;})\n#define Size(x) ((int)x.size())\n#define mem(x,y) memset(x,y,sizeof(x))\ntemplate<class T>il void in(T &x)\n{\n\tx=0; char c=getchar(); bool f=0;\n\twhile(!isdigit(c)) f|=(c=='-'),c=getchar();\n\twhile(isdigit(c)) x=x*10+(c^'0'),c=getchar();\n\tf?x=-x:0;\n}\ntemplate<class T>il void out(T x,const char c='\\n')\n{\n\tstatic short st[30]; short m=0;\n\tif(x<0) putchar('-'),x=-x;\n\tdo st[++m]=x%10,x/=10; while(x);\n\twhile(m) putchar(st[m--]|'0');\n\tputchar(c);\n}\ntemplate<class T>il void err(const T &x,const char c='\\n') {cerr<<x<<c;}\ntemplate<class T,class ...Args>il void in(T &x,Args &...args) {in(x); in(args...);}\ntemplate<class T,class ...Args>il void out(const T &x,const Args &...args) {out(x,' '); out(args...);}\ntemplate<class T,class ...Args>il void err(const T &x,const Args &...args) {err(x,' '); err(args...);}\ntemplate<class T>il void prt(T a[],int n) {for(ri i=0; i<n; ++i) out(a[i],i==n-1?'\\n':' ');}\ntemplate<class T>il void clr(T a[],int n) {memset(a,0,sizeof(T)*n);}\ntemplate<class T>il void clr(T *a,T *b) {memset(a,0,sizeof(T)*(b-a));}\ntemplate<class T>il bool ckmax(T &a,const T &b) {return a<b?a=b,1:0;}\ntemplate<class T>il bool ckmin(T &a,const T &b) {return a>b?a=b,1:0;}\nnamespace MOD_CALC\n{\nconst int md=1e9+7,inv2=(md+1)/2;\nil int add(const int a,const int b) {return a+b>=md?a+b-md:a+b;}\nil int sub(const int a,const int b) {return a-b<0?a-b+md:a-b;}\nil int mul(const int a,const int b) {return (LL)a*b%md;}\nil void inc(int &a,const int b) {(a+=b)>=md?a-=md:0;}\nil void dec(int &a,const int b) {(a-=b)<0?a+=md:0;}\nil int qpow(int a,int b) {int r=1; for(; b; b>>=1,a=mul(a,a)) if(b&1) r=mul(r,a); return r;}\nil int qpow(int a,int b,const int p) {int r=1; for(; b; b>>=1,a=(LL)a*a%p) if(b&1) r=(LL)r*a%p; return r;}\nil int mdinv(const int a) {return qpow(a,md-2);}\ntemplate<class ...Args>il int add(const int a,const int b,const Args &...args) {return add(add(a,b),args...);}\ntemplate<class ...Args>il int mul(const int a,const int b,const Args &...args) {return mul(mul(a,b),args...);}\n} using namespace MOD_CALC;\nnamespace i207M\n{\n#pragma endregion\n#define N 2000*2000+5\nint fac[N],ifac[N];\nil void init(int n)\n{\n\tfac[0]=1;\n\tfor(ri i=1; i<=n; ++i) fac[i]=mul(fac[i-1],i);\n\tifac[n]=mdinv(fac[n]);\n\tfor(ri i=n; i>=1; --i) ifac[i-1]=mul(ifac[i],i);\n}\nil int C(int n,int m) {return n<m?0:mul(fac[n],ifac[m],ifac[n-m]);}\nint n,K;\nint f[2005][2005];\nsigned main()\n{\n#ifdef M207\n\tfreopen(\"in.in\",\"r\",stdin);\n\t// freopen(\"ot.out\",\"w\",stdout);\n#endif\n\tin(n,K);\n\tif(K==1)\n\t{\n\t\tout(1);\n\t\treturn 0;\n\t}\n\tinit(n*K);\n\tfor(ri i=0; i<=n; ++i) f[0][i]=1;\n\tfor(ri i=1; i<=n; ++i)\n\t\tfor(ri j=i; j<=n; ++j)\n\t\t{\n\t\t\tf[i][j]=f[i][j-1];\n\t\t\tinc(f[i][j],mul(f[i-1][j],(n-i+1),C(n*K-j-(i-1)*(K-1)-1,K-2)));\n\t\t\t// out(i,j,f[i][j],n*K-j-(i-1)*(K-1)-1,K-2);\n\t\t}\n\tout(f[n][n]);\n\treturn 0;\n}\n#pragma region\n}\nsigned main()\n{\n\ti207M::main();\n\treturn 0;\n}\n#pragma endregion\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int mod = (int) 1e9 + 7;\n\nint add(int a, int b) {\n  a += b;\n  if (a >= mod) {\n    return a - mod;\n  }\n  if (a < 0) {\n    return a + mod;\n  }\n  return a;\n}\n\nint mul(int a, int b) {\n  return a * (ll) b % mod;\n}\n\nint pw(int a, int b) {\n  int r = 1;\n  while (b) {\n    if (b & 1) {\n      r = mul(r, a);\n    }\n    a = mul(a, a);\n    b /= 2;\n  }\n  return r;\n}\n\nint dv(int a, int b) {\n  return mul(a, pw(b, mod - 2));\n}\n\nconst int N = 2000 * 2000 + 7;\nconst int L = 2000 + 7;\nint fact[N], inv[N];\nint n, k, dp[L][L];\n\nint comb(int n, int k) {\n  int x = fact[n];\n  int y = mul(inv[k], inv[n - k]);\n  return mul(x, y);\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n\n  fact[0] = 1;\n  for (int i = 1; i < N; i++) {\n    fact[i] = mul(fact[i - 1], i);\n  }\n  inv[N - 1] = dv(1, fact[N - 1]);\n  for (int i = N - 2; i >= 0; i--) {\n    inv[i] = mul(i + 1, inv[i + 1]);\n  }\n  cin >> n >> k;\n  if (k == 1) {\n    cout << \"1\\n\";\n    return 0;\n  }\n  dp[0][0]=1;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j <= i; j++) {\n      dp[i][j] = dp[i - 1][j];\n      if (j) {\n        dp[i][j] = add(dp[i][j], mul(dp[i][j - 1], comb(n - i + (n - j + 1) * (k - 1) - 1, k - 2)));\n      }\n    }\n  }\n  int ans = dp[n][n];\n  ans = mul(ans, fact[n]);\n  cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\nconst int N=2004,P=1e9+7;\n\nint n,k,fac[N*N],inv[N*N],ifac[N*N],f[N][N];\n\nint C(int n,int m)\n{\n\tif(n<m||n<0||m<0)\n\t\treturn 0;\n\treturn (ll)fac[n]*ifac[m]%P*ifac[n-m]%P;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1)\n\t\treturn puts(\"1\"),0;\n\tfac[0]=fac[1]=inv[1]=ifac[0]=ifac[1]=1;\n\tfor(int i=2; i<=n*k; i++)\n\t{\n\t\tfac[i]=(ll)fac[i-1]*i%P;\n\t\tinv[i]=(ll)inv[P%i]*(P-P/i)%P;\n\t\tifac[i]=(ll)ifac[i-1]*inv[i]%P;\n\t}\n\t// f[i][j] 当前安排了i个白球 有j个颜色安排上了\n\t// 限制是 i>=j\n\t// 带标号dp \n\t// 钦定当前加入的球最靠前的一个最靠前 \n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tf[i][0]=1;\n\t\tfor(int j=1; j<=i; j++)\n\t\t{\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tf[i][j]=(f[i][j]+(ll)f[i][j-1]*C(n*k-i-(j-1)*(k-1)-1,k-2)%P*(n-j+1))%P;\n\t\t}\n\t}\n\tprintf(\"%d\",f[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> bool get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;return true;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) (get1(a)&&get1(b))\n#define get3(a,b,c) (get1(a)&&get2(b,c))\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int mod=1e9+7;\n\nint power(int x,int y){int ret=1;do{if(y&1)ret=1ll*ret*x%mod;x=1ll*x*x%mod;}while(y>>=1);return ret;}\nint n,k,f[4000111],invf[4000111];\n\nint dp[2333][2333];\nint c(int x,int y){if(x<y||y<0)return 0;return 1ll*f[x]*invf[y]%mod*invf[x-y]%mod;}\nint main()\n{\n\tf[0]=1;for(int i=1;i<4000111;i++)f[i]=1ll*f[i-1]*i%mod;\n\tinvf[4000111-1]=power(f[4000111-1],mod-2);for(int i=4000111-2;i>=0;i--)invf[i]=1ll*invf[i+1]*(i+1)%mod;\n\tget2(n,k);\n\tif(k==1){puts(\"1\");return 0;}\n\tdp[0][0]=f[n];\n\tfor(int i=0;i<=n;i++)for(int j=i;j<=n;j++)//i:color 0 j:others\n\t{\n\t\tif(i)dp[i][j]=dp[i-1][j];\n\t\tif(j)dp[i][j]=(dp[i][j]+1ll*dp[i][j-1]*c(i+j*(k-1)-1,k-2))%mod;\n\t}\n\tprintendl(dp[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define MOD 1000000007\nusing namespace std;\nint N,K;\nLL fac[5000010],inv[5000010],ifac[5000010],d[2010][2010];\nint main()\n{\n\tcin>>N>>K;\n\tfac[0]=inv[0]=ifac[0]=fac[1]=inv[1]=ifac[1]=1;\n\tfor(int i=2;i<=1000000;i++)\n\t{\n\t\tfac[i]=(fac[i-1]*i)%MOD;\n\t\tinv[i]=inv[MOD%i]*(MOD-MOD/i)%MOD;\n\t\tifac[i]=(ifac[i-1]*inv[i])%MOD;\n\t}\n\td[0][1]=1;\n\tfor(int i=2;i<=N;i++)\n\t{\n\t\td[0][i]=d[0][i-1]*(fac[i*(K-1)-1]*ifac[K-2]%MOD*ifac[(i-1)*(K-1)]%MOD)%MOD;\n\t}\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tfor(int j=i;j<=N;j++)\n\t\t{\n\t\t\td[i][j]=(d[i-1][j]+d[i][j-1]*(fac[i+j*(K-1)-1]*ifac[K-2]%MOD*ifac[i+(j-1)*(K-1)]%MOD))%MOD;\n// \t\t\tcout<<i<<' '<<j<<' '<<d[i][j]<<endl;\n\t\t}\n\t}\n\tcout<<(d[N][N]*fac[N])%MOD<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\nconst LL N=2009,MOD=1e9+7;\nLL n,k;\nLL fac[N*N],invfac[N*N],f[N][N];\ntemplate<typename T>\ninline void read(T &x)\n{\n\tx=0;T w=1;char c=getchar();\n\twhile(!isdigit(c)){if(c=='-')w=-1;\tc=getchar();}\n\twhile(isdigit(c)){x=(x<<3)+(x<<1)+c-'0';\tc=getchar();}\n\tx*=w;\n}\nLL qpow(LL a,LL b,LL p)\n{\n\tLL x=a,ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)\tans=ans*x%p;\n\t\tx=x*x%p;\n\t\tb>>=1;\n\t}\n\treturn ans%p;\n}\nLL inv(LL a,LL p)\n{\n\treturn qpow(a,p-2,p);\n}\nLL C(LL n,LL m)\n{\n\treturn fac[n]*invfac[m]%MOD*invfac[n-m]%MOD;\n}\nvoid init(LL n)\n{\n\tfac[0]=1;\n\tfor(LL i=1;i<=n;++i)\n\t\tfac[i]=fac[i-1]*i%MOD;\n\tinvfac[n]=inv(fac[n],MOD);\n\tfor(LL i=n-1;i>=0;--i)\n\t\tinvfac[i]=invfac[i+1]*(i+1)%MOD;\n}\nint main()\n{\n\tread(n);read(k);\n\tif(k==1)\n\t{\n\t\tprintf(\"1\");\n\t\treturn 0;\n\t}\n\tinit(n*k);\n\tf[0][0]=1;\n\tfor(LL i=0;i<=n;++i)\n\t\tfor(LL j=max(i,1ll);j<=n;++j)\n\t\t\tf[i][j]=((i?f[i-1][j]:0)+f[i][j-1]*C(i+j*(k-1)-1,k-2))%MOD;\n\tprintf(\"%lld\",f[n][n]*fac[n]%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 2005\nconst int mod = 1000000007;\n#define add(x, y) (x + y >= mod ? x + y - mod : x + y)\n#define dec(x, y) (x < y ? x - y + mod : x - y)\n\nint Pow(int x, int k)\n{\n\tint ans = 1, base = x;\n\twhile(k)\n\t{\n\t\tif(k & 1) ans = 1ll * ans * base % mod;\n\t\tbase = 1ll * base * base % mod;\n\t\tk >>= 1;\n\t}\n\treturn ans;\n}\n\nint n, k, f[N][N], pw[N], inv[N];\n\nint C(int x, int y)\n{\n\treturn 1ll * pw[y] * inv[y - x] % mod * inv[x] % mod;\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &k);\n\tpw[0] = inv[0] = 1;\n\tfor(int i = 1; i <= n * k; i++) pw[i] = 1ll * pw[i - 1] * i, inv[i] = Pow(pw[i], mod - 2);\n\tif(k == 1) {cout << 1 << endl; return 0;}\n\tf[0][0] = 1;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = 0; j <= i; j++)\n\t\t{\n\t\t\tf[i][j] = add(f[i - 1][j], (1ll * f[i][j - 1] * (n - j + 1) * C(k - 2, n * k - i - (j - 1) * (k - 1) - 1) % mod));\n\t\t}\n\t}\n\tprintf(\"%d\\n\", f[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long maxn=5e6,mod=1e9+7;\nlong long jc[5555555],injc[5555555],n,k,dp[4444][2222];\nlong long binpow(long long a,long long t)\n{\n\tlong long res=1,p=a;\n\tfor (long long i=t;i;i>>=1)\n\t{\n\t\tif (i&1) res=res*p%mod;\n\t\tp=p*p%mod;\n\t}\n\treturn res;\n}\nvoid Init()\n{\n\tjc[0]=1;\n\tfor (long long i=1;i<=maxn;i++) jc[i]=jc[i-1]*i%mod;\n\tinjc[maxn]=binpow(jc[maxn],mod-2);\n\tfor (long long i=maxn-1;i>=0;i--) injc[i]=injc[i+1]*(i+1)%mod;\n}\nlong long C(long long n,long long k)\n{\n\tif (n<k) return 0;\n\treturn (jc[n]*injc[k]%mod)*injc[n-k]%mod;\n}\nlong long bino(long long n,long long k)\n{\n\treturn C(n+k,k);\n}\nint main()\n{\n\tcin>>n>>k;\n\tif (k==1) \n\t{\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tInit();\n\tdp[1][1]=1;\n\tfor (long long i=2;i<=2*n;i++)\n\t{\n\t\tfor (long long j=1;j<=n;j++)\n\t\t{\n\t\t\tif (j<i-j || j>i) continue;\n\t\t\tdp[i][j]=(dp[i-1][j-1]+(dp[i-1][j]*(n-i+1+j)%mod)*bino((n-i+j)*(k-1)+n-j,k-2))%mod;\n\t\t}\n\t}\n\tcout<<dp[2*n][n]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// IOI 2021\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define ends ' '\n#define die(x) return cout << x << endl, 0\n#define all(v) v.begin(), v.end()\n#define sz(x) (int)(x.size())\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) { cerr << ends << H; debug_out(T...); }\n#define debug(...) cerr << \"{\" << #__VA_ARGS__ << \"}:\", debug_out(__VA_ARGS__)\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst ll INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\n////////////////////////////////////////////////////////////////////\n\nconst int N = 2e3 + 5, M = 4e6 + 5;\n\nint DP[N][N], F[M], I[M];\n\nint Power(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1LL * a * a % MOD) if (b & 1) res = 1LL * res * a % MOD;\n\treturn res;\n}\nint C(int n, int r) { return r > n ? 0 : 1LL * I[r] * I[n - r] % MOD * F[n] % MOD; }\n\nint main() {\n\n\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t\n\tF[0] = 1;\n\tfor (int i = 1; i < M; i++) F[i] = 1LL * i * F[i - 1] % MOD;\n\tI[M - 1] = Power(F[M - 1], MOD - 2);\n\tfor (int i = M - 2; i >= 0; i--) I[i] = 1LL * (i + 1) * I[i + 1] % MOD;\n\t\n\tint n, k; cin >> n >> k;\n\tif (k == 1) die(1);\n\tDP[0][0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tDP[i][0] = 1LL * DP[i - 1][0] * C(i * (k - 1) - 1, k - 2) % MOD;\n\t\tfor (int j = 1; j <= i; j++) DP[i][j] = (DP[i][j - 1] + 1LL * DP[i - 1][j] * C(i * (k - 1) + j - 1, k - 2) % MOD) % MOD;\n\t}\n\tcout << 1LL * DP[n][n] * F[n] % MOD << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=2007,P=1000000007;\nint n,m,k,fac[N*N],ifac[N*N],f[N][N];\nvoid inc(int&a,int b){a+=b-P,a+=a>>31&P;}\nvoid mul(int&a,int b){a=1ll*a*b%P;}\nint C(int n,int m){return 1ll*fac[n]*ifac[m]%P*ifac[n-m]%P;}\nint pow(int a,int b){int r=1;for(;b;b>>=1,mul(a,a))if(b&1)mul(r,a);return r;}\nint main()\n{\n    scanf(\"%d%d\",&n,&k),m=n*k,f[0][0]=1;\n    if(k==1) return puts(\"1\"),0;\n    fac[0]=1;for(int i=1;i<=m;++i)mul(fac[i]=fac[i-1],i);\n    ifac[m]=pow(fac[m],P-2);for(int i=m;i;--i)mul(ifac[i-1]=ifac[i],i);\n    for(int i=0,z=k-1;i<=n;++i,z+=k-1)\n\tfor(int j=0;j<=i;++j)\n\t    inc(f[i+1][j],1ll*f[i][j]*C(z+j-1,k-2)%P),inc(f[i][j+1],f[i][j]);\n    mul(f[n][n],fac[n]),printf(\"%d\",f[n][n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int64;\nconst int P = 1e9 + 7;\n\nconst int MaxN = 2020;\nint f[MaxN][MaxN];\nint fac[MaxN*MaxN];\nint inv[MaxN*MaxN];\nint facInv[MaxN*MaxN];\nint N, M, g;\n\nint add(int x, int y) { x += y; return x >= P ? x - P : x; }\nint mul(int x, int y) { return (int64)x*y%P; }\nint c(int x, int y) { return mul(fac[x], mul(facInv[y], facInv[x - y])); }\nvoid inc(int& x, int y) { x = add(x, y); }\n\nint main()\n{\n\tios::sync_with_stdio(0), cin.tie(0);\n\t\n\tcin >> N >> M;\n\tif (M == 1) return puts(\"1\")&0;\n\tfac[0] = facInv[0] = 1,\n\tfac[1] = inv[1] = facInv[1] = 1;\n\tfor (int i = 2;i < MaxN * MaxN; ++i) {\n\t\tfac[i] = mul(fac[i-1], i),\n\t\tinv[i] = mul((P-P/i), inv[P%i]),\n\t\tfacInv[i] = mul(facInv[i-1], inv[i]);\n\t}\n\t\n\tg = 1;\n\tfor (int i = 1;i <= N; ++i)\n\t\tf[i][0] = 1, g = mul(g, i);\n\tfor (int i = 1;i <= N; ++i) {\n\t\tfor (int j = 1;j <= i; ++j) {\n\t\t\tinc(f[i][j], f[i-1][j]);\n\t\t\tinc(f[i][j], mul(f[i][j-1], c(N*M - i - (j-1) * (M - 1) - 1, M - 2)));\n\t\t}\n\t}\n\t\n\tcout << mul(g, f[N][N]);\n\treturn 0; \n}\n\n/*\nf[i][j] += f[i-1][j] + f[i][j-1] * c(N*M - i - (j-1) * (M-1) - 1, M-2)\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 5e6 + 10, mod = 1e9 + 7;\n \nll pw(ll a, ll b) {\n    ll r = 1;\n    for( ; b ; b >>= 1, a = a * a % mod) {\n        if(b & 1) {\n            r = r * a % mod;\n        }\n    }\n    return r;\n}\nll fac[N], invfac[N];\nvoid init(int n) {\n    fac[0] = invfac[0] = 1;\n    for(int i = 1 ; i <= n ; ++ i) {\n        fac[i] = fac[i - 1] * i % mod;\n    }\n    invfac[n] = pw(fac[n], mod - 2);\n    for(int i = n - 1 ; i ; -- i) {\n        invfac[i] = invfac[i + 1] * (i + 1) % mod;\n    }\n}\nll C(int n, int m) {\n    return n < m || m < 0 ? 0 : fac[n] * invfac[m] % mod * invfac[n - m] % mod;\n}\n \nint n, k;\nll f[2010][2010];\nvoid upd(ll &x, ll y) {\n    x = (x + y) % mod;\n}\n \nint main() {\n    init(N - 1);\n    scanf(\"%d%d\", &n, &k);\n    if(! -- k) {\n        puts(\"1\");\n    } else {\n        f[0][0] = 1;\n        for(int i = 0 ; i <= n ; ++ i) {\n            for(int j = i ; j <= n ; ++ j) {\n                if(j) {\n                    if(i - 1 >= 0) {\n                        upd(f[i][j], f[i - 1][j]);\n                    }\n                    upd(f[i][j], f[i][j - 1] * C(i + (j - 1) * k + k - 1, k - 1) % mod);\n                }\n            }\n        }\n        printf(\"%lld\\n\", f[n][n] * fac[n] % mod);\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include<cstdio>\n#define C(x,y) (fct[x]*ifct[y]%TT*ifct[(x)-(y)]%TT)\nusing namespace std;\nconst int maxn=2005,TT=1e9+7;\nint n,K,m,F[maxn][maxn];\nlong long fct[maxn*maxn],ifct[maxn*maxn];\ninline int read(){\n\tint ret=0;bool f=0;char ch=getchar();\n\twhile(ch>'9'||ch<'0') f^=ch=='-',ch=getchar();\n\twhile(ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();\n\treturn f?-ret:ret;\n}\ninline long long pow(int x,int y){\n\tlong long ret=1,w=x;\n\twhile(1){\n\t\tif(y&1) ret=ret*w%TT;\n\t\tif(!(y>>=1)) return ret;\n\t\tw=w*w%TT;\n\t}\n}\ninline void add(int&x,int y){if((x+=y)>=TT) x-=TT;}\nint main(){\n\tn=read(),K=read();m=n*K;\n\tif(K==1) return puts(\"1\")&0;\n\tfor (int i=fct[0]=1;i<=m;i++) fct[i]=fct[i-1]*i%TT;\n\tifct[m]=pow(fct[m],TT-2);\n\tfor (int i=m;i;i--) ifct[i-1]=ifct[i]*i%TT;\n\tF[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=0;j<=i;j++){\n\t\tif(j<i) add(F[i][j],F[i-1][j]);\n\t\tif(j) add(F[i][j],C(m-i-(j-1)*(K-1)-1,K-2)*F[i][j-1]%TT);\n\t}\n\tprintf(\"%lld\\n\",fct[n]*F[n][n]%TT);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\null d[N_MAX + 5];\nsll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\nsll table[3005][3005];\n// here we go\n\null dp[3005][3005];\null dq[3005][3005];\n\null frac[4100000];\null invf[4100000];\null ncr (ull n, ull r) {\n\treturn frac[n] * (invf[n - r] * invf[r] % MOD) % MOD;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tif (k == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfrac[0] = invf[0] = 1;\n\tfor (i = 1; i <= (n + 1) * (k + 1); i++) {\n\t\tfrac[i] = (frac[i - 1] * i) % MOD;\n\t\tinvf[i] = divide(invf[i - 1], i, MOD);\n\t}\n\n\tdp[0][0] = 1;\n\tdq[0][0] = 1;\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = i; j >= 0; j--) {\n\t\t\tif (j) {\n\t\t\t\t// printf(\"%lldC%lld*%lld=\", i * k - j - 1, k - 2, dq[i - 1][j - 1]);\n\t\t\t\tdp[i][j] = ncr(i * k - j - 1, k - 2) * dq[i - 1][j - 1] % MOD;\n\t\t\t}\n\t\t\t// printf(\"%lld \", dp[i][j]);\n\t\t\tdq[i][j] = (dq[i][j + 1] + dp[i][j]) % MOD;\n\t\t}\n\t\t// puts(\"\");\n\t}\n\tresult = dq[n][0] * frac[n] % MOD;\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\tputs(\"YES\");\n\t// puts(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\tputs(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\tn = 4;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\tscanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \t// scanf(\"%lld\", &b[i]);\n\t// \t// scanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \t// c[i]--;\n\t// \t// d[i]--;\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// \t// tup[i].a--;\n\t// \t// tup[i].b--;\n\t// }\n\t// for (i = 0; i < n - 1; i++) {\n\t// \tscanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \ta[i]--;\n\t// \tb[i]--;\n\t// }\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld\", &a[i]);\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \t// b[i]--;\n\t// \t// c[i]--;\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < n; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#define LL long long\n\nconst int maxN = 2e3 + 2;\nconst int MOD = 1e9 + 7;\n\nint N, K;\nint F[maxN][maxN], fac[maxN * maxN];\n\nLL qpow(LL a, LL b) {\n    LL ans = 1;\n    while (b) {\n        if (b & 1) {\n            ans = ans * a % MOD;\n        }\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return ans;\n}\n\nvoid init() {\n    fac[0] = 1;\n    for (int i = 1; i <= N * K; ++i) \n        fac[i] = 1ll * fac[i - 1] * i % MOD; \n}\n\nint Combine(int n, int m) { \n    if (n < m) return 0;\n    return 1ll * fac[n] * qpow(fac[m], MOD - 2) % MOD * qpow(fac[n - m], MOD - 2) % MOD;\n}\n\nsigned main() {\n\n    cin >> N >> K;\n    if (K == 1) return puts(\"1\"), 0;\n    init();\n    F[0][0] = 1;\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 0; j <= i; ++j) {\n            F[i][j] = (1ll * F[i - 1][j] + 1ll * (i > 0) * F[i][j - 1] *\n                        Combine(N * K - (j - 1) * (K - 1) - i - 1, K - 2) % MOD) % MOD;\n        }\n    }\n    cout << 1ll * F[N][N] * fac[N] % MOD << endl;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20190820\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#include<assert.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nvoid swap(int *a,int *b){int c;c=(*a);(*a)=(*b);(*b)=c;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\nvoid llswap(long long *a,long long *b){long long c;c=(*a);(*a)=(*b);(*b)=c;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nvoid dbswap(double *a,double *b){double c;c=(*a);(*a)=(*b);(*b)=c;}\nvoid chswap(char *a,char *b){char c;c=(*a);(*a)=(*b);(*b)=c;}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\nvoid getperm(int a[],int n){\n  int i,p;\n  for(i=0;i<n;i++){\n    a[i]=i;\n  }\n  for(i=n-1;i>=1;i--){\n    p=rand()%(i+1);\n    swap(&a[p],&a[i]);\n  }\n}\n\ntypedef struct{\nint val;\nint node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\nvoid coordinate_comp(int a[],int n){\n  int i,c=0;\n  sd dat[524288];\n  for(i=0;i<n;i++){\n    dat[i].val=a[i];\n    dat[i].node=i;\n  }\n  qsort(dat,n,sizeof(dat[0]),sdsortfnc);\n  a[dat[0].node]=c;\n  for(i=1;i<n;i++){\n    if(dat[i-1].val!=dat[i].val){c++;}\n    a[dat[i].node]=c;\n  }\n}\n\nlong long power(long long a,long long b){\n  long long x=1,y=a;\n  while(b>0){\n    if(b&1ll){\n      x=(x*y)%mod;\n    }\n    y=(y*y)%mod;\n    b>>=1;\n  }\n  return x%mod;\n}\n\nlong long modular_inverse(long long n){\n  return power(n,mod-2);\n}\n\nlong long factorial[4194304];\nlong long invfact[4194304];\n\nvoid cfact(){\n  long long i;\n  factorial[0]=1;\n  factorial[1]=1;\n  for(i=2;i<4194304;i++){\n    factorial[i]=factorial[i-1]*i;\n    factorial[i]%=mod;\n  }\n  invfact[4194303]=modular_inverse(factorial[4194303]);\n  for(i=4194302;i>=0;i--){\n    invfact[i]=invfact[i+1]*(i+1);\n    invfact[i]%=mod;\n  }\n}\n\nlong long calcnCr(long long n,long long k){\n  if(k<0 || n<k){return 0;}\n  return (factorial[n]*((invfact[k]*invfact[n-k])%mod))%mod;\n}\n\nint main(void){\n  cfact();\n  //you must use color 1 -> 2 -> ... -> n (*)\n  //dp[decided white balls]\n  long long i,j,t,n,k,dp[2048]={0},w,res;\n  scanf(\"%lld%lld\",&n,&k);\n  if(k==1){printf(\"1\\n\");return 0;}\n  dp[0]=1;\n  for(i=0;i<n;i++){\n    //decide white balls\n    //ex. o _ _ _\n    //o 1 _ _\n    //o _ 1 _ <- then, 2nd must be white due to the (*) rule\n\n    //for(j=n;j>=i;j--){\n    //  w=dp[j];\n    //  for(t=j+1;t<=n;t++){\n    //    dp[t]+=w;\n    //    dp[t]%=mod;\n    //  }\n    //}\n    \n    for(j=i+1;j<=n;j++){\n      dp[j]+=dp[j-1];\n      dp[j]%=mod;\n    }\n    \n    //printf(\"<%lld %lld>\\n\",dp[1],dp[2]);\n    for(j=i+1;j<=n;j++){\n      //n*k balls\n      //remove j decided white balls\n      //i*(k-1) putted colored balls\n      //1 color (i+1) ball must be put the most front\n      dp[j]*=calcnCr(n*k-j-i*(k-1)-1,k-2);\n      dp[j]%=mod;\n    }\n    //printf(\"%lld %lld\\n\",dp[1],dp[2]);\n  }\n  res=dp[n];\n  res*=factorial[n];res%=mod;\n  printf(\"%lld\\n\",res);\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#define LL long long\n\nconst int maxN = 2e3 + 2;\nconst int MOD = 1e9 + 7;\n\nint N, K;\nint F[maxN][maxN], fac[maxN * maxN];\n\nLL qpow(LL a, LL b) {\n    LL ans = 1;\n    while (b) {\n        if (b & 1) {\n            ans = ans * a % MOD;\n        }\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return ans;\n}\n\nvoid init() {\n    fac[0] = 1;\n    for (int i = 1; i <= N * K; ++i) \n        fac[i] = 1ll * fac[i - 1] * i % MOD; \n}\n\nint Combine(int n, int m) { \n    if (n < m) return 0;\n    return 1ll * fac[n] * qpow(fac[m], MOD - 2) % MOD * qpow(fac[n - m], MOD - 2) % MOD;\n}\n\nsigned main() {\n\n    cin >> N >> K;\n    if (K == 1) return puts(\"1\"), 0;\n    init();\n    F[0][0] = 1;\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 0; j <= i; ++j) {\n            F[i][j] = (1ll * F[i - 1][j] + 1ll * (i > 0) * F[i][j - 1] *\n                        Combine(N * K - (j - 1) * (K - 1) - i - 1, K - 2) % MOD) % MOD;\n        }\n    }\n    cout << 1ll * F[N][N] * fac[N] % MOD << endl;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint mod = 1000000007;\n\t\tint[][] fif = enumFIF(4000005, mod);\n\t\tint n = ni(), K  = ni();\n\t\tif(K == 1){\n\t\t\tout.println(1);\n\t\t\treturn;\n\t\t}\n\t\tlong[][] dp = new long[n+1][n+1];\n\t\tdp[0][0] = 1;\n\t\tfor(int j = 0;j <= n;j++){\n\t\t\tfor(int i = j;i <= n;i++){\n\t\t\t\tif(i+1 <= n){\n\t\t\t\t\tdp[j][i+1] += dp[j][i];\n\t\t\t\t\tif(dp[j][i+1] >= mod)dp[j][i+1] -= mod;\n\t\t\t\t}\n\t\t\t\tif(i >= j+1){\n\t\t\t\t\tdp[j+1][i] += dp[j][i] * C(n*K-i-j*(K-1)-1, K-2, mod, fif);\n\t\t\t\t\tdp[j+1][i] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(dp[n][n] * fif[0][n] % mod);\n\t}\n\t\n\tpublic static long invl(long a, long mod) {\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\n\t\n\tpublic static long C(int n, int r, int mod, int[][] fif) {\n\t\tif (n < 0 || r < 0 || r > n)\n\t\t\treturn 0;\n\t\treturn (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n\t}\n\n\t\n\tpublic static int[][] enumFIF(int n, int mod) {\n\t\tint[] f = new int[n + 1];\n\t\tint[] invf = new int[n + 1];\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i] = (int) ((long) f[i - 1] * i % mod);\n\t\t}\n\t\tlong a = f[n];\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\tinvf[n] = (int) (p < 0 ? p + mod : p);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tinvf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n\t\t}\n\t\treturn new int[][] { f, invf };\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tboolean eof;\n\n\tstatic final int P = 1_000_000_007;\n\n\tvoid solve() throws IOException {\n\t\tint n = nextInt();\n\t\tint k = nextInt();\n\n\t\tif (k == 1) {\n\t\t\tout.println(1);\n\t\t\treturn;\n\t\t}\n\n\t\tModuloCombinatorics mc = new ModuloCombinatorics(n * k, P);\n\n\t\tint[][] dp = new int[n + 1][n + 1];\n\t\tdp[0][0] = 1;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tfor (int j = i; j <= n; j++) {\n\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\tif (dp[i][j] >= P) {\n\t\t\t\t\t\tdp[i][j] -= P;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (j > i) {\n\t\t\t\t\tint n1 = i + j * (k - 1) - 1;\n\t\t\t\t\tint k1 = k - 2;\n\t\t\t\t\tdp[i][j] += (int) ((long) dp[i][j - 1]\n\t\t\t\t\t\t\t* ((n1 < 0 || k1 < 0 || k1 > n1) ? 0 : (int) ((long) mc.fact[n1]\n\t\t\t\t\t\t\t* mc.invFact[k1] % mc.P * mc.invFact[n1 - k1] % mc.P)) % P);\n\t\t\t\t\tdp[i][j] %= P;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tint ret = (int) ((long) dp[n][n] * mc.fact[n] % P);\n\n\t\tout.println(ret);\n\t}\n\n\tstatic class ModuloCombinatorics {\n\t\t/** maximal needed number, N itself is included **/\n\t\tfinal int N;\n\n\t\t/** prime modulo **/\n\t\tfinal int P;\n\n\t\t/** factorials **/\n\t\tfinal int[] fact;\n\n\t\t/** multiplicative inverses, take care to not touch inv[0] **/\n\t\tfinal int[] inv;\n\n\t\t/** inverse factorials **/\n\t\tfinal int[] invFact;\n\n\t\tpublic ModuloCombinatorics(int N, int P) {\n\t\t\tthis.N = N;\n\t\t\tthis.P = P;\n\t\t\tfact = new int[N + 1];\n\t\t\tfact[0] = 1;\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tfact[i] = (int) ((long) i * fact[i - 1] % P);\n\t\t\t}\n\n\t\t\tinv = new int[N + 1];\n\t\t\tinv[1] = 1;\n\t\t\tfor (int i = 2; i <= N; i++) {\n\t\t\t\tinv[i] = P - (int) ((long) (P / i) * inv[P % i] % P);\n\t\t\t}\n\n\t\t\tinvFact = new int[N + 1];\n\t\t\tinvFact[0] = 1;\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tinvFact[i] = (int) ((long) invFact[i - 1] * inv[i] % P);\n\t\t\t}\n\t\t}\n\n\t\tpublic int choose(int n, int k) {\n\t\t\treturn (n < 0 || k < 0 || k > n) ? 0 : (int) ((long) fact[n]\n\t\t\t\t\t* invFact[k] % P * invFact[n - k] % P);\n\t\t}\n\n\t\t/** a^b modulo mod, mod is arbitrary **/\n\t\tstatic public int pow(int a, long b, int mod) {\n\t\t\tif (a < 0 || a >= mod || b < 0) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t\tint ret = 1;\n\t\t\tfor (; b > 0; b >>= 1) {\n\t\t\t\tif ((b & 1) == 1) {\n\t\t\t\t\tret = (int) ((long) ret * a % mod);\n\t\t\t\t}\n\t\t\t\ta = (int) ((long) a * a % mod);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t/** a^b modulo P **/\n\t\tpublic int pow(int a, long b) {\n\t\t\treturn pow(a, b, P);\n\t\t}\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\teof = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tboolean eof;\n\n\tstatic final int P = 1_000_000_007;\n\n\tvoid solve() throws IOException {\n\t\tint n = nextInt();\n\t\tint k = nextInt();\n\n\t\tif (k == 1) {\n\t\t\tout.println(1);\n\t\t\treturn;\n\t\t}\n\n\t\tModuloCombinatorics mc = new ModuloCombinatorics(n * k, P);\n\n\t\tint[][] dp = new int[n + 1][n + 1];\n\t\tdp[0][0] = 1;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tfor (int j = i; j <= n; j++) {\n\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\tif (dp[i][j] >= P) {\n\t\t\t\t\t\tdp[i][j] -= P;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (j > i) {\n\t\t\t\t\tint n1 = i + j * (k - 1) - 1;\n\t\t\t\t\tint k1 = k - 2;\n\t\t\t\t\tdp[i][j] += (int) ((long) dp[i][j - 1]\n\t\t\t\t\t\t\t* ((int) ((long) mc.fact[n1] * mc.invFact[k1]\n\t\t\t\t\t\t\t\t\t% mc.P * mc.invFact[n1 - k1] % mc.P)) % P);\n\t\t\t\t\tdp[i][j] %= P;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tint ret = (int) ((long) dp[n][n] * mc.fact[n] % P);\n\n\t\tout.println(ret);\n\t}\n\n\tstatic class ModuloCombinatorics {\n\t\t/** maximal needed number, N itself is included **/\n\t\tfinal int N;\n\n\t\t/** prime modulo **/\n\t\tfinal int P;\n\n\t\t/** factorials **/\n\t\tfinal int[] fact;\n\n\t\t/** multiplicative inverses, take care to not touch inv[0] **/\n\t\tfinal int[] inv;\n\n\t\t/** inverse factorials **/\n\t\tfinal int[] invFact;\n\n\t\tpublic ModuloCombinatorics(int N, int P) {\n\t\t\tthis.N = N;\n\t\t\tthis.P = P;\n\t\t\tfact = new int[N + 1];\n\t\t\tfact[0] = 1;\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tfact[i] = (int) ((long) i * fact[i - 1] % P);\n\t\t\t}\n\n\t\t\tinv = new int[N + 1];\n\t\t\tinv[1] = 1;\n\t\t\tfor (int i = 2; i <= N; i++) {\n\t\t\t\tinv[i] = P - (int) ((long) (P / i) * inv[P % i] % P);\n\t\t\t}\n\n\t\t\tinvFact = new int[N + 1];\n\t\t\tinvFact[0] = 1;\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tinvFact[i] = (int) ((long) invFact[i - 1] * inv[i] % P);\n\t\t\t}\n\t\t}\n\n\t\tpublic int choose(int n, int k) {\n\t\t\treturn (n < 0 || k < 0 || k > n) ? 0 : (int) ((long) fact[n]\n\t\t\t\t\t* invFact[k] % P * invFact[n - k] % P);\n\t\t}\n\n\t\t/** a^b modulo mod, mod is arbitrary **/\n\t\tstatic public int pow(int a, long b, int mod) {\n\t\t\tif (a < 0 || a >= mod || b < 0) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t\tint ret = 1;\n\t\t\tfor (; b > 0; b >>= 1) {\n\t\t\t\tif ((b & 1) == 1) {\n\t\t\t\t\tret = (int) ((long) ret * a % mod);\n\t\t\t\t}\n\t\t\t\ta = (int) ((long) a * a % mod);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t/** a^b modulo P **/\n\t\tpublic int pow(int a, long b) {\n\t\t\treturn pow(a, b, P);\n\t\t}\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\teof = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.function.IntUnaryOperator;\nimport java.util.function.LongUnaryOperator;\n\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Field f = System.out.getClass().getDeclaredField(\"autoFlush\");\n        f.setAccessible(true);\n        f.set(System.out, false);\n        execute(System.in, System.out);\n    }\n\n    public static void execute(InputStream in, OutputStream out) {\n        ExtendedScanner s = new ExtendedScanner(in);\n        Out o = new Out(out);\n        solve(s, o);\n        o.flush();\n        o.close();\n    }\n\n    static long p = 1_000_000_007;\n    static long[] fac;\n    static long[] facInv;\n\n    public static void solve(ExtendedScanner sc, Out out) {\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        if (k == 1) {\n            out.writeln(1);\n            return;\n        }\n        fac = new long[n * k + 1];\n        fac[0] = 1;\n        for (int i = 1; i <= n * k; i++) {\n            fac[i] = (fac[i - 1] * i) % p;\n        }\n        facInv = new long[n * k + 1];\n        facInv[n * k] = ModArithmetic.inv(fac[n * k], p);\n        for (int i = n * k; i > 0; i--) {\n            facInv[i - 1] = (facInv[i] * i) % p;\n        }\n        var dp0 = new long[n + 1];\n        var dp1 = new long[n + 1];\n        dp1[1] = 1;\n        for (int i = 2; i <= n; i++) {\n            for (int j = 1; j <= i; j++) {\n                long v = j == 1 ? dp1[i - 1] : dp1[i - 1] - dp1[j - 2];\n                if (v < 0) v += p;\n                dp0[j] = dp0[j - 1] + (comb(i * k - (j + 1), k - 2) * v) % p;\n                if (dp0[j] >= p) dp0[j] -= p;\n            }\n            var tmp = dp0; dp0 = dp1; dp1 = tmp;\n        }\n        out.writeln((dp1[n] * fac[n]) % p);\n    }\n\n    static long comb(int n, int r) {\n        return (fac[n] * ((facInv[r] * facInv[n - r]) % p)) % p;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass BasicScanner {\n    private final InputStream in;\n    private final byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public BasicScanner(InputStream in) {this.in = in;}\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try {buflen = in.read(buf);}\n        catch (final IOException e) {e.printStackTrace();}\n        return buflen > 0;\n    }\n    private int readByte() {return hasNextByte() ? buf[ptr++] : -1;}\n    public boolean hasNext() {\n        while (hasNextByte() && !(33 <= buf[ptr] && buf[ptr] <= 126)) ptr++;\n        return hasNextByte();\n    }\n    private StringBuilder nextSequence() {\n        if (!hasNext()) throw new NoSuchElementException();\n        final StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}\n        return sb;\n    }\n    public char nextChar() {\n        return (char) readByte();\n    }\n    public String next() {\n        return nextSequence().toString();\n    }\n    public String next(int len) {\n        return new String(nextChars(len));\n    }\n    public char[] nextChars() {\n        final StringBuilder sb = nextSequence();\n        int l = sb.length();\n        char[] dst = new char[l];\n        sb.getChars(0, l, dst, 0);\n        return dst;\n    }\n    public char[] nextChars(int len) {\n        if (!hasNext()) throw new NoSuchElementException();\n        char[] s = new char[len];\n        int i = 0;\n        int b = readByte();\n        while (33 <= b && b <= 126 && i < len) {s[i++] = (char) b; b = readByte();}\n        if (i != len) throw new NoSuchElementException(String.format(\"length %d is longer than the sequence.\", len));\n        return s;\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {minus = true; b = readByte();}\n        if (b < '0' || '9' < b) throw new NumberFormatException();\n        while (true) {\n            if ('0' <= b && b <= '9') n = n * 10 + b - '0';\n            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;\n            else throw new NumberFormatException();\n            b = readByte();\n        }\n    }\n    public int nextInt() {return Math.toIntExact(nextLong());}\n    public double nextDouble() {return Double.parseDouble(next());}\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass Out {\n    private final OutputStream out;\n    private byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private static final int AUTO_FLUSH_THRETHOLD = 1 << 17;\n\n    public Out(OutputStream out) {\n        this.out = out;\n    }\n\n    public void flush() {\n        try {\n            out.write(buf, 0, ptr);\n            out.flush();\n            ptr = 0;\n        } catch (IOException e) {e.printStackTrace();}\n    }\n\n    public void close() {\n        try {out.close();} catch (IOException e) {e.printStackTrace();}\n    }\n\n    public Out writeln() {return write('\\n');}\n    public Out writeln(Object o) {return write(o).write('\\n');}\n    public Out writeln(String s) {return write(s).write('\\n');}\n    public Out writeln(char[] c) {return write(c).write('\\n');}\n    public Out writeln(char   c) {return write(c).write('\\n');}\n    public Out writeln(byte   b) {return write(b).write('\\n');}\n    public Out writeln(int    x) {return write(x).write('\\n');}\n    public Out writeln(long   x) {return write(x).write('\\n');}\n    public Out writeln(double d) {return write(d).write('\\n');}\n\n    public Out writeSpace() {return write(' ');}\n    \n    public Out write(Object o) {\n        return write(o.toString());\n    }\n\n    public Out write(String s) {\n        try {\n            Field strValueField = s.getClass().getDeclaredField(\"value\");\n            strValueField.setAccessible(true);\n            byte[] b = (byte[]) strValueField.get(s);\n            int l = s.length();\n            if (l > AUTO_FLUSH_THRETHOLD) {\n                flush();\n                int i = 0;\n                while (i + AUTO_FLUSH_THRETHOLD < l) {\n                    out.write(b, i, AUTO_FLUSH_THRETHOLD);\n                    out.flush();\n                    i += AUTO_FLUSH_THRETHOLD;\n                }\n                ensureCapacity(l - i);\n                System.arraycopy(b, i, buf, 0, l - i);\n                ptr = l - i;\n            } else {\n                ensureCapacity(ptr + l);\n                System.arraycopy(b, 0, buf, ptr, l);\n                ptr += l;\n            }\n        } catch (Exception e) {e.printStackTrace();}\n        return this;\n    }\n\n    public Out write(char[] c) {\n        int l = c.length;\n        if (l > AUTO_FLUSH_THRETHOLD) {\n            flush();\n            ensureCapacity(AUTO_FLUSH_THRETHOLD);\n            int i = 0;\n            while (i + AUTO_FLUSH_THRETHOLD < l) {\n                for (int j = 0; j < AUTO_FLUSH_THRETHOLD; j++) {\n                    buf[ptr++] = (byte) c[i + j];\n                }\n                flush();\n                i += AUTO_FLUSH_THRETHOLD;\n            }\n            for (; i < l; i++) {\n                buf[ptr++] = (byte) c[i];\n            }\n        } else {\n            ensureCapacity(ptr + l);\n            for (char ch : c) buf[ptr++] = (byte) ch;\n        }\n        return this;\n    }\n\n    public Out write(char c) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = (byte) c;\n        return this;\n    }\n\n    public Out write(byte b) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = b;\n        return this;\n    }\n\n    public Out write(int x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(long x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(double d) {\n        return write(Double.toString(d));\n    }\n\n    private void ensureCapacity(int cap) {\n        if (cap > AUTO_FLUSH_THRETHOLD) {\n            flush();\n        }\n        if (cap >= buf.length) {\n            int newLength = buf.length;\n            while (newLength < cap) newLength <<= 1;\n            byte[] newBuf = new byte[newLength];\n            System.arraycopy(buf, 0, newBuf, 0, buf.length);\n            buf = newBuf;\n        }\n    }\n    private static int stringSize(long x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        long p = -10;\n        for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;\n        return 19 + d;\n    }\n    private static int stringSize(int x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        int p = -10;\n        for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;\n        return 10 + d;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class ExtendedScanner extends BasicScanner {\n    public ExtendedScanner(InputStream in) {super(in);}\n    public int[] ints(final int n) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> nextInt());\n        return a;\n    }\n    public int[] ints(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> f.applyAsInt(nextInt()));\n        return a;\n    }\n    public int[][] ints(final int n, final int m) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m));\n        return a;\n    }\n    public int[][] ints(final int n, final int m, final IntUnaryOperator f) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m, f));\n        return a;\n    }\n    public long[] longs(final int n) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> nextLong());\n        return a;\n    }\n    public long[] longs(final int n, final LongUnaryOperator f) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> f.applyAsLong(nextLong()));\n        return a;\n    }\n    public long[][] longs(final int n, final int m) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m));\n        return a;\n    }\n    public long[][] longs(final int n, final int m, final LongUnaryOperator f) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m, f));\n        return a;\n    }\n    public char[][] charArrays(final int n) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars());\n        return c;\n    }\n    public char[][] charArrays(final int n, final int m) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars(m));\n        return c;\n    }\n    public double[] doubles(final int n) {\n        final double[] a = new double[n];\n        Arrays.setAll(a, $ -> nextDouble());\n        return a;\n    }\n    public double[][] doubles(final int n, final int m) {\n        final double[][] a = new double[n][];\n        Arrays.setAll(a, $ -> doubles(m));\n        return a;\n    }\n    public String[] strings(final int n) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next());\n        return s;\n    }\n    public String[] strings(final int n, final int m) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next(m));\n        return s;\n    }\n}\n\n/**\n * Minimum modulo operations.\n * \n * @author https://atcoder.jp/users/suisen\n */\nclass ModArithmetic {\n    public final long MOD;\n\n    /**\n     * support modulo p arithmetic\n     * \n     * @param p p s.t. p is a prime number.\n     */\n    public ModArithmetic(final long p) {\n        this.MOD = p;\n    }\n\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ x = a mod p.\n     */\n    public static long mod(long a, final long MOD) {\n        a %= MOD;\n        return a < 0 ? a + MOD : a;\n    }\n\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ x = a + b mod p.\n     */\n    public static long add(final long a, final long b, final long MOD) {\n        final long s = a + b;\n        return s < 0 ? s + MOD : s >= MOD ? s - MOD : s;\n    }\n\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ x = a - b mod p.\n     */\n    public static long sub(final long a, final long b, final long MOD) {\n        final long s = a - b;\n        return s < 0 ? s + MOD : s >= MOD ? s - MOD : s;\n    }\n\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ x = a * b mod p.\n     */\n    public static long mul(final long a, final long b, final long MOD) {\n        final long ret = (a * b) % MOD;\n        return ret < 0 ? ret + MOD : ret;\n    }\n\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ b * x = a mod p.\n     */\n    public static long div(final long a, final long b, final long MOD) {\n        return mul(a, inv(b, MOD), MOD);\n    }\n\n    /**\n     * Calculate the value b s.t. a * b mod p = 1.\n     */\n    public static long inv(long a, final long MOD) {\n        long b = MOD;\n        long u = 1, v = 0;\n        while (b >= 1) {\n            final long t = a / b;\n            a -= t * b;\n            final long tmp1 = a; a = b; b = tmp1;\n            u -= t * v;\n            final long tmp2 = u; u = v; v = tmp2;\n        }\n        u %= MOD;\n        return u < 0 ? u + MOD : u;\n    }\n\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ x = a mod p.\n     */\n    public long mod(long a) {\n        a %= MOD;\n        return a < 0 ? a + MOD : a;\n    }\n\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ x = a + b mod p.\n     */\n    public long add(final long a, final long b) {\n        final long s = a + b;\n        return s < 0 ? s + MOD : s >= MOD ? s - MOD : s;\n    }\n\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ x = a - b mod p.\n     */\n    public long sub(final long a, final long b) {\n        final long s = a - b;\n        return s < 0 ? s + MOD : s >= MOD ? s - MOD : s;\n    }\n\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ x = a * b mod p.\n     */\n    public long mul(final long a, final long b) {\n        final long s = (a * b) % MOD;\n        return s < 0 ? s + MOD : s;\n    }\n\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ b * x = a mod p.\n     */\n    public long div(final long a, final long b) {\n        return mul(a, inv(b));\n    }\n\n    /**\n     * Calculate the value b s.t. a*b mod MOD = 1.\n     */\n    public long inv(long a) {\n        long b = MOD;\n        long u = 1, v = 0;\n        while (b >= 1) {\n            final long t = a / b;\n            a -= t * b;\n            final long tmp1 = a; a = b; b = tmp1;\n            u -= t * v;\n            final long tmp2 = u; u = v; v = tmp2;\n        }\n        return mod(u);\n    }\n\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ x = a_1 + 1_2 + ... + a_k mod p.\n     */\n    public long sum(final long... a) {\n        long ret = 0;\n        for (final long c : a) ret += c;\n        return mod(ret);\n    }\n\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ x = a_1 * 1_2 * ... * a_k mod p.\n     */\n    public long prod(final long... a) {\n        long ret = 1;\n        for (final long c : a) ret = (ret * c) % MOD;\n        return ret < 0 ? ret + MOD : ret;\n    }\n\n    /**\n     * calculate the inverse of [1,n] mod MOD in O(n).\n     * \n     * @param n\n     * @param MOD\n     * @return the array that contains the inverse of [1,n]. (array[0] = 0)\n     */\n    public static long[] invMemo(int n, long MOD) {\n        final long[] memo = new long[n + 1];\n        memo[1] = 1;\n        for (int i = 2; i <= n; i++) {\n            long q = MOD - MOD / i;\n            long r = memo[(int) (MOD % i)];\n            memo[i] = (q * r) % MOD;\n        }\n        return memo;\n    }\n\n    /**\n     * calculate the inverse of a[0], ..., a[n - 1] mod MOD in O(n).\n     * \n     * @param a\n     * @param MOD\n     * @return the array that contains the inverse of a[0], ..., a[n - 1].\n     */\n    public static long[] invAll(long[] a, long MOD) {\n        int n = a.length;\n        final long[] dp = new long[n + 1];\n        final long[] pd = new long[n + 1];\n        dp[0] = pd[n] = 1;\n        for (int i = 0; i < n; i++) dp[i + 1] = (dp[i] * a[i]) % MOD;\n        for (int i = n; i > 0; i--) pd[i - 1] = (pd[i] * a[i]) % MOD;\n        long inv = ModArithmetic.inv(dp[n], MOD);\n        long[] ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (((dp[i] * pd[i]) % MOD) * inv) % MOD;\n        return ret;\n    }\n\n    /**\n     * calculate 0!, ..., n! (mod MOD) in O(n).\n     * \n     * @param n\n     * @param MOD\n     * @return the array that contains 0!, ..., n! (mod MOD).\n     */\n    public static long[] factorialMemo(int n, long MOD) {\n        final long[] memo = new long[n + 1];\n        memo[0] = 1;\n        for (int i = 1; i <= n; i++) memo[i] = (memo[i - 1] * i) % MOD;\n        return memo;\n    }\n\n    /**\n     * calculate the inverse of 0!, ..., n! (mod MOD) in O(n).\n     * \n     * @param factorial [0!, ..., n!] (mod MOD).\n     * @param MOD\n     * @return the array that contains the inverse of 0!, ..., n! (mod MOD).\n     */\n    public static long[] invFactorialMemo(long[] factorial, long MOD) {\n        final int n = factorial.length - 1;\n        final long[] memo = new long[n + 1];\n        memo[n] = ModArithmetic.inv(factorial[n], MOD);\n        for (int i = n; i > 0; i--) memo[i - 1] = (memo[i] * i) % MOD;\n        return memo;\n    }\n\n    /**\n     * calculate a^0, ..., a^n (mod MOD) in O(n).\n     * \n     * @param a   base\n     * @param n   maximum index.\n     * @param MOD\n     * @return the array that contains the a^0, ..., a^n (mod MOD).\n     */\n    public static long[] powerMemo(long a, int n, long MOD) {\n        if (a == 2) return powerMemo(n, MOD);\n        long[] memo = new long[n + 1];\n        memo[0] = 1;\n        for (int i = 1; i <= n; i++) memo[i] = (memo[i - 1] * a) % MOD;\n        return memo;\n    }\n\n    /**\n     * calculate 2^0, ..., 2^n (mod MOD) in O(n).\n     * \n     * @param n   maximum index.\n     * @param MOD\n     * @return the array that contains the 2^0, ..., 2^n (mod MOD).\n     */\n    public static long[] powerMemo(int n, long MOD) {\n        long[] memo = new long[n + 1];\n        memo[0] = 1;\n        for (int i = 1; i <= n; i++) memo[i] = (memo[i - 1] << 1) % MOD;\n        return memo;\n    }\n\n    /**\n     * calculate a^b (mod MOD) in O(max{MOD, b}).\n     * \n     * @param a   base\n     * @param b   index\n     * @param MOD\n     * @return a^b (mod MOD)\n     */\n    public static long power(long a, long b, long MOD) {\n        a %= MOD;\n        if (b == 0 || a == 1) return 1;\n        long res = 1, p = a, c = 1;\n        while (b > 0) {\n            long lsb = b & -b;\n            for (; lsb != c; c <<= 1, p = (p * p) % MOD);\n            res = (res * p) % MOD;\n            b ^= lsb;\n        }\n        return res;\n    }\n\n    /**\n     * calculate the inverse of [1,n] mod MOD in O(n).\n     * \n     * @param n\n     * @return the array that contains the inverse of [1,n]. (array[0] = 0)\n     */\n    public long[] invMemo(int n) {\n        final long[] memo = new long[n + 1];\n        memo[1] = 1;\n        for (int i = 2; i <= n; i++) {\n            long q = MOD - MOD / i;\n            long r = memo[(int) (MOD % i)];\n            memo[i] = (q * r) % MOD;\n        }\n        return memo;\n    }\n\n    /**\n     * calculate the inverse of a[0], ..., a[n - 1] mod MOD in O(n).\n     * \n     * @param a\n     * @return the array that contains the inverse of a[0], ..., a[n - 1].\n     */\n    public long[] invAll(long[] a) {\n        int n = a.length;\n        long[] dp = new long[n + 1];\n        long[] pd = new long[n + 1];\n        dp[0] = pd[n] = 1;\n        for (int i = 0; i < n; i++) dp[i + 1] = (dp[i] * a[i    ]) % MOD;\n        for (int i = n; i > 0; i--) pd[i - 1] = (pd[i] * a[i - 1]) % MOD;\n        long inv = inv(dp[n], MOD);\n        long[] invs = new long[n];\n        for (int i = 0; i < n; i++) {\n            long lr = (dp[i] * pd[i + 1]) % MOD;\n            invs[i] = (lr * inv) % MOD;\n        }\n        return invs;\n    }\n\n    /**\n     * calculate 0!, ..., n! (mod MOD) in O(n).\n     * \n     * @param n\n     * @return the array that contains 0!, ..., n! (mod MOD).\n     */\n    public long[] factorialMemo(int n) {\n        final long[] memo = new long[n + 1];\n        memo[0] = 1;\n        for (int i = 1; i <= n; i++) memo[i] = (memo[i - 1] * i) % MOD;\n        return memo;\n    }\n\n    /**\n     * calculate the inverse of 0!, ..., n! (mod MOD) in O(n).\n     * \n     * @param factorial [0!, ..., n!] (mod MOD).\n     * @return the array that contains the inverse of 0!, ..., n! (mod MOD).\n     */\n    public long[] invFactorialMemo(long[] factorial) {\n        final int n = factorial.length - 1;\n        final long[] memo = new long[n + 1];\n        memo[n] = ModArithmetic.inv(factorial[n], MOD);\n        for (int i = n; i > 0; i--) memo[i - 1] = (memo[i] * i) % MOD;\n        return memo;\n    }\n\n    /**\n     * calculate a^0, ..., a^n (mod MOD) in O(n).\n     * \n     * @param a   base\n     * @param n   maximum index.\n     * @return the array that contains the a^0, ..., a^n (mod MOD).\n     */\n    public long[] powerMemo(long a, int n) {\n        if (a == 2) return powerMemo(n, MOD);\n        final long[] memo = new long[n + 1];\n        memo[0] = 1;\n        for (int i = 1; i <= n; i++) memo[i] = (memo[i - 1] * a) % MOD;\n        return memo;\n    }\n\n    /**\n     * calculate 2^0, ..., 2^n (mod MOD) in O(n).\n     * \n     * @param n   maximum index.\n     * @return the array that contains the 2^0, ..., 2^n (mod MOD).\n     */\n    public long[] powerMemo(int n) {\n        final long[] memo = new long[n + 1];\n        memo[0] = 1;\n        for (int i = 1; i <= n; i++) memo[i] = (memo[i - 1] << 1) % MOD;\n        return memo;\n    }\n\n    /**\n     * calculate a^b (mod MOD) in O(max{MOD, b}).\n     * \n     * @param a   base\n     * @param b   index\n     * @return a^b (mod MOD)\n     */\n    public long power(long a, long b) {\n        a %= MOD;\n        if (b == 0 || a == 1) return 1;\n        long res = 1, p = a, c = 1;\n        while (b > 0) {\n            long lsb = b & -b;\n            for (; lsb != c; c <<= 1, p = (p * p) % MOD);\n            res = (res * p) % MOD;\n            b ^= lsb;\n        }\n        return res;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\n\npublic class Main {\n\n\tprivate static int mod = 1000000000 + 7;\n\tpublic static void main(String[] args) {\n\t\tFastScanner sc = new FastScanner();\n\t\tint N = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\t\n\t\tif (K == 1) {\n\t\t\tSystem.out.println(1);\n\t\t\treturn;\n\t\t} else {\n\t\t\tint[][] fif = enumFIF(4000005, mod);\n\t\t\t\n\t\t\tlong[][] dp = new long[N + 1][N + 1];\n\t\t\tdp[0][0] = 1L;\n\t\t\tfor (int i = 0; i <= N; i ++) {\n\n\t\t\t\tfor (int j = i; j <= N; j ++) {\n\t\t\t\t\tif (i > 0)\n\t\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\tif (j > 0) {\n\t\t\t\t\t\tdp[i][j] += C(i + (K - 1) * j - 1, K - 2, mod, fif) * dp[i][j - 1];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlong ans = dp[N][N];\n\t\t\t\n\t\t\tfor(long i = 1; i <= N; i ++) {\n\t\t\t\tans = (ans * i) % mod;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\n\t}\n\n\t\n\tpublic static long C(int n, int r, int mod, int[][] fif) {\n\t\tif (n < 0 || r < 0 || r > n)\n\t\t\treturn 0;\n\t\treturn (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n\t}\n\t\n\tpublic static int[][] enumFIF(int n, int mod) {\n\t\tint[] f = new int[n + 1];\n\t\tint[] invf = new int[n + 1];\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i] = (int) ((long) f[i - 1] * i % mod);\n\t\t}\n\t\tlong a = f[n];\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\tinvf[n] = (int) (p < 0 ? p + mod : p);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tinvf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n\t\t}\n\t\treturn new int[][] { f, invf };\n\t}\n}\n\n\n\nclass FastScanner {\n\tpublic static String debug = null;\n\n\tprivate final InputStream in = System.in;\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate byte[] buffer = new byte[1024];\n\tprivate boolean eos = false;\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tif (debug != null) {\n\t\t\t\t\tbuflen = debug.length();\n\t\t\t\t\tbuffer = debug.getBytes();\n\t\t\t\t\tdebug = \"\";\n\t\t\t\t\teos = true;\n\t\t\t\t} else {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen < 0) {\n\t\t\t\teos = true;\n\t\t\t\treturn false;\n\t\t\t} else if (buflen == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\n\tprivate void skipUnprintable() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t}\n\n\tpublic boolean isEOS() {\n\t\treturn this.eos;\n\t}\n\n\tpublic boolean hasNext() {\n\t\tskipUnprintable();\n\t\treturn hasNextByte();\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tpublic int nextInt() {\n\t\treturn (int) nextLong();\n\t}\n\n\tpublic long[] nextLongList(int n) {\n\t\treturn nextLongTable(1, n)[0];\n\t}\n\n\tpublic int[] nextIntList(int n) {\n\t\treturn nextIntTable(1, n)[0];\n\t}\n\n\tpublic long[][] nextLongTable(int n, int m) {\n\t\tlong[][] ret = new long[n][m];\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tfor (int j = 0; j < m; j ++) {\n\t\t\t\tret[i][j] = nextLong();\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic int[][] nextIntTable(int n, int m) {\n\t\tint[][] ret = new int[n][m];\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tfor (int j = 0; j < m; j ++) {\n\t\t\t\tret[i][j] = nextInt();\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tboolean eof;\n\n\tstatic final int P = 1_000_000_007;\n\n\tvoid solve() throws IOException {\n\t\tint n = nextInt();\n\t\tint k = nextInt();\n\n\t\tif (k == 1) {\n\t\t\tout.println(1);\n\t\t\treturn;\n\t\t}\n\n\t\tModuloCombinatorics mc = new ModuloCombinatorics(n * k, P);\n\n\t\tint[][] dp = new int[n + 1][n + 1];\n\t\tdp[0][0] = 1;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tfor (int j = i; j <= n; j++) {\n\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\tif (dp[i][j] >= P) {\n\t\t\t\t\t\tdp[i][j] -= P;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (j > i) {\n\t\t\t\t\tdp[i][j] += (int) ((long) dp[i][j - 1]\n\t\t\t\t\t\t\t* mc.choose(i + j * (k - 1) - 1, k - 2) % P);\n\t\t\t\t\tdp[i][j] %= P;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tint ret = (int)((long)dp[n][n] * mc.fact[n] % P);\n\n\t\tout.println(ret);\n\t}\n\n\tstatic class ModuloCombinatorics {\n\t\t/** maximal needed number, N itself is included **/\n\t\tfinal int N;\n\n\t\t/** prime modulo **/\n\t\tfinal int P;\n\n\t\t/** factorials **/\n\t\tfinal int[] fact;\n\n\t\t/** multiplicative inverses, take care to not touch inv[0] **/\n\t\tfinal int[] inv;\n\n\t\t/** inverse factorials **/\n\t\tfinal int[] invFact;\n\n\t\tpublic ModuloCombinatorics(int N, int P) {\n\t\t\tthis.N = N;\n\t\t\tthis.P = P;\n\t\t\tfact = new int[N + 1];\n\t\t\tfact[0] = 1;\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tfact[i] = (int) ((long) i * fact[i - 1] % P);\n\t\t\t}\n\n\t\t\tinv = new int[N + 1];\n\t\t\tinv[1] = 1;\n\t\t\tfor (int i = 2; i <= N; i++) {\n\t\t\t\tinv[i] = P - (int) ((long) (P / i) * inv[P % i] % P);\n\t\t\t}\n\n\t\t\tinvFact = new int[N + 1];\n\t\t\tinvFact[0] = 1;\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tinvFact[i] = (int) ((long) invFact[i - 1] * inv[i] % P);\n\t\t\t}\n\t\t}\n\n\t\tpublic int choose(int n, int k) {\n\t\t\tif (n < 0 || k < 0 || k > n) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn (int) ((long) fact[n] * invFact[k] % P * invFact[n - k] % P);\n\t\t}\n\n\t\t/** a^b modulo mod, mod is arbitrary **/\n\t\tstatic public int pow(int a, long b, int mod) {\n\t\t\tif (a < 0 || a >= mod || b < 0) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t\tint ret = 1;\n\t\t\tfor (; b > 0; b >>= 1) {\n\t\t\t\tif ((b & 1) == 1) {\n\t\t\t\t\tret = (int) ((long) ret * a % mod);\n\t\t\t\t}\n\t\t\t\ta = (int) ((long) a * a % mod);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t/** a^b modulo P **/\n\t\tpublic int pow(int a, long b) {\n\t\t\treturn pow(a, b, P);\n\t\t}\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\teof = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint mod = 1000000007;\n\t\tint[][] fif = enumFIF(4000005, mod);\n\t\tint n = ni(), K  = ni();\n\t\tif(K == 1){\n\t\t\tout.println(1);\n\t\t\treturn;\n\t\t}\n\t\tlong[] dp = new long[n+1];\n\t\tdp[0] = 1;\n\t\tfor(int j = 0;j <= n;j++){\n\t\t\tfor(int i = j;i <= n;i++){\n\t\t\t\tif(i+1 <= n){\n\t\t\t\t\tdp[i+1] += dp[i];\n\t\t\t\t\tif(dp[i+1] >= mod)dp[i+1] -= mod;\n\t\t\t\t}\n\t\t\t\tif(i >= j+1){\n\t\t\t\t\tdp[i] = dp[i] * C(n*K-i-j*(K-1)-1, K-2, mod, fif) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(dp[n] * fif[0][n] % mod);\n\t}\n\t\n\tpublic static long invl(long a, long mod) {\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\n\t\n\tpublic static long C(int n, int r, int mod, int[][] fif) {\n\t\tif (n < 0 || r < 0 || r > n)\n\t\t\treturn 0;\n\t\treturn (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n\t}\n\n\t\n\tpublic static int[][] enumFIF(int n, int mod) {\n\t\tint[] f = new int[n + 1];\n\t\tint[] invf = new int[n + 1];\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i] = (int) ((long) f[i - 1] * i % mod);\n\t\t}\n\t\tlong a = f[n];\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\tinvf[n] = (int) (p < 0 ? p + mod : p);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tinvf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n\t\t}\n\t\treturn new int[][] { f, invf };\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint mod = 1000000007;\n\t\tint[][] fif = enumFIF(4000005, mod);\n\t\tint n = ni(), K  = ni();\n\t\tif(K == 1){\n\t\t\tout.println(1);\n\t\t\treturn;\n\t\t}\n\t\tlong[][] dp = new long[n+1][n+1]; // 0の登場回数 色の登場回数\n\t\tdp[0][0] = 1;\n\t\tfor(int i = 0;i <= n;i++){\n\t\t\tfor(int j = 0;j <= i;j++){\n\t\t\t\tif(i+1 <= n){\n\t\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t\t\tif(dp[i+1][j] >= mod)dp[i+1][j] -= mod;\n\t\t\t\t}\n\t\t\t\tif(i >= j+1){\n\t\t\t\t\tdp[i][j+1] += dp[i][j] * C(n*K-i-j*(K-1)-1, K-2, mod, fif);\n\t\t\t\t\tdp[i][j+1] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(dp[n][n] * fif[0][n] % mod);\n\t}\n\t\n\tpublic static long invl(long a, long mod) {\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\n\t\n\tpublic static long C(int n, int r, int mod, int[][] fif) {\n\t\tif (n < 0 || r < 0 || r > n)\n\t\t\treturn 0;\n\t\treturn (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n\t}\n\n\t\n\tpublic static int[][] enumFIF(int n, int mod) {\n\t\tint[] f = new int[n + 1];\n\t\tint[] invf = new int[n + 1];\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i] = (int) ((long) f[i - 1] * i % mod);\n\t\t}\n\t\tlong a = f[n];\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\tinvf[n] = (int) (p < 0 ? p + mod : p);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tinvf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n\t\t}\n\t\treturn new int[][] { f, invf };\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        static final long MODULO = (long) (1e9 + 7);\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            if (k == 1) {\n                out.println(1);\n                return;\n            }\n            long[] invs = new long[k + 1];\n            invs[1] = 1;\n            for (int i = 2; i < invs.length; ++i) {\n                invs[i] = (MODULO - (MODULO / i) * invs[((int) (MODULO % i))] % MODULO) % MODULO;\n            }\n            long invProd = 1;\n            for (int i = 1; i <= k - 2; ++i) {\n                invProd = invProd * invs[i] % MODULO;\n            }\n            long[] ways = new long[]{1};\n            long[] sufProds = new long[k - 1];\n            for (int i = 1; i < n; ++i) {\n                long[] nways = new long[ways.length + 1];\n                long sum = 0;\n                long prefProd = 1;\n                int upto = Integer.MIN_VALUE;\n                for (int newZ = nways.length; newZ >= 1; --newZ) {\n                    if (newZ > 1) {\n                        sum += ways[newZ - 2];\n                        sum %= MODULO;\n                    }\n                    int need = (i + 1) * k - newZ - 1;\n                    if (upto < (need - (k - 2))) {\n                        upto = need;\n                        sufProds[0] = 1;\n                        for (int j = 1; j < sufProds.length; ++j) {\n                            sufProds[j] = sufProds[j - 1] * (upto - j + 1) % MODULO;\n                        }\n                        prefProd = 1;\n                    } else {\n                        prefProd *= need;\n                        prefProd %= MODULO;\n                    }\n                    nways[newZ - 1] = (nways[newZ - 1] + sum * prefProd % MODULO * sufProds[upto - (need - (k - 2))] % MODULO * invProd % MODULO) % MODULO;\n                }\n                ways = nways;\n            }\n            long res = 0;\n            for (long x : ways) res += x;\n            res %= MODULO;\n            for (int i = 1; i <= n; ++i) {\n                res = res * i % MODULO;\n            }\n            out.println(res);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\n\npublic class Main {\n\n\tprivate static long mod = 1000000000 + 7;\n\tpublic static void main(String[] args) {\n\t\tFastScanner sc = new FastScanner();\n\t\tint N = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\t\n\t\tif (K == 1) {\n\t\t\tSystem.out.println(1);\n\t\t\treturn;\n\t\t} else {\n\t\t\tlong[] comb = new long[N * K + 1];\n\t\t\tcomb[K - 2] = 1;\n\t\t\tfor (int i = K - 1; i <= N * K; i ++) {\n\t\t\t\tcomb[i] = (long)i * inverse(i - (K - 2), mod) % mod * comb[i - 1] % mod;\n\t\t\t\tcomb[i] %= mod;\n\t\t\t}\n\t\t\t\n\t\t\tlong[][] dp = new long[N + 1][N + 1];\n\t\t\tdp[0][0] = 1L;\n\t\t\tfor (int i = 0; i <= N; i ++) {\n\t\t\t\tfor (int j = i; j <= N; j ++) {\n\t\t\t\t\tif (i > 0)\n\t\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\tif (j > 0)\n\t\t\t\t\t\tdp[i][j] += comb[i + (K - 1) * j - 1] * dp[i][j - 1];\n\t\t\t\t\tdp[i][j] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlong ans = dp[N][N];\n\t\t\t\n\t\t\tfor(long i = 1; i <= N; i ++) {\n\t\t\t\tans = (ans * i) % mod;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\n\t}\n\n\tpublic static long[] extgcd(long a, long b) {\n\t\tlong u = 1;\n\t\tlong v = 0;\n\t\tlong x = 0;\n\t\tlong y = 1;\n\n\t\twhile (a > 0) {\n\t\t\tlong q = b / a;\n\t\t\tx -= q * u;\n\t\t\ty -= q * v;\n\t\t\tb -= q * a;\n\n\t\t\tlong tmp;\n\t\t\ttmp = x;\n\t\t\tx = u;\n\t\t\tu = tmp;\n\t\t\ttmp = y;\n\t\t\ty = v;\n\t\t\tv = tmp;\n\t\t\ttmp = b;\n\t\t\tb = a;\n\t\t\ta = tmp;\n\t\t}\n\n\t\treturn new long[] { b, x, y };\n\t}\n\n\tpublic static long inverse(long n, long mod) {\n\t\tlong[] gcd = extgcd(n, mod);\n\t\tif (gcd[0] == 1) {\n\t\t\treturn (gcd[1] + mod) % mod;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n\n\n\nclass FastScanner {\n\tpublic static String debug = null;\n\n\tprivate final InputStream in = System.in;\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate byte[] buffer = new byte[1024];\n\tprivate boolean eos = false;\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tif (debug != null) {\n\t\t\t\t\tbuflen = debug.length();\n\t\t\t\t\tbuffer = debug.getBytes();\n\t\t\t\t\tdebug = \"\";\n\t\t\t\t\teos = true;\n\t\t\t\t} else {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen < 0) {\n\t\t\t\teos = true;\n\t\t\t\treturn false;\n\t\t\t} else if (buflen == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\n\tprivate void skipUnprintable() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t}\n\n\tpublic boolean isEOS() {\n\t\treturn this.eos;\n\t}\n\n\tpublic boolean hasNext() {\n\t\tskipUnprintable();\n\t\treturn hasNextByte();\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tpublic int nextInt() {\n\t\treturn (int) nextLong();\n\t}\n\n\tpublic long[] nextLongList(int n) {\n\t\treturn nextLongTable(1, n)[0];\n\t}\n\n\tpublic int[] nextIntList(int n) {\n\t\treturn nextIntTable(1, n)[0];\n\t}\n\n\tpublic long[][] nextLongTable(int n, int m) {\n\t\tlong[][] ret = new long[n][m];\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tfor (int j = 0; j < m; j ++) {\n\t\t\t\tret[i][j] = nextLong();\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic int[][] nextIntTable(int n, int m) {\n\t\tint[][] ret = new int[n][m];\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tfor (int j = 0; j < m; j ++) {\n\t\t\t\tret[i][j] = nextInt();\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.math.BigInteger;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Random;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        boolean local = false;\n        boolean async = false;\n\n        Charset charset = Charset.forName(\"ascii\");\n\n        FastIO io = local ? new FastIO(new FileInputStream(\"D:\\\\DATABASE\\\\TESTCASE\\\\Code.in\"), System.out, charset) : new FastIO(System.in, System.out, charset);\n        Task task = new Task(io, new Debug(local));\n\n        if (async) {\n            Thread t = new Thread(null, task, \"dalt\", 1 << 27);\n            t.setPriority(Thread.MAX_PRIORITY);\n            t.start();\n            t.join();\n        } else {\n            task.run();\n        }\n\n        if (local) {\n            io.cache.append(\"\\n\\n--memory -- \\n\" + ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) >> 20) + \"M\");\n        }\n\n        io.flush();\n    }\n\n    public static class Task implements Runnable {\n        final FastIO io;\n        final Debug debug;\n        int inf = (int) 1e8;\n        long lInf = (long) 1e18;\n        double dInf = 1e50;\n\n        public Task(FastIO io, Debug debug) {\n            this.io = io;\n            this.debug = debug;\n        }\n\n        @Override\n        public void run() {\n            solve();\n        }\n\n        int[][] dp;\n        NumberTheory.Modular mod = new NumberTheory.Modular((int) 1e9 + 7);\n        NumberTheory.Composite composite = new NumberTheory.Composite(4000000, mod);\n\n        int k;\n\n        public void solve() {\n            int n = io.readInt();\n            k = io.readInt();\n            if (k == 1) {\n                io.cache.append(1);\n                return;\n            }\n            dp = new int[n + 1][n + 1];\n            for (int i = 0; i <= n; i++) {\n                for (int j = 0; j <= n; j++) {\n                    dp[i][j] = -1;\n                }\n            }\n\n            int ans = dp(n, n);\n            io.cache.append(ans);\n        }\n\n        public int dp(int i, int j) {\n            if (j > i) {\n                return 0;\n            }\n            if (j < 0) {\n                return 0;\n            }\n            if (j == 0 && i <= 1) {\n                return 1;\n            }\n            if (dp[i][j] == -1) {\n                dp[i][j] = dp(i, j - 1);\n                int plus = dp(i - 1, j);\n                plus = mod.mul(plus, i);\n                plus = mod.mul(plus, composite.composite(i * (k - 1) + j - 1, k - 2));\n                dp[i][j] = mod.plus(dp[i][j], plus);\n            }\n            return dp[i][j];\n        }\n    }\n\n\n    public static class NumberTheory {\n        private static final Random RANDOM = new Random();\n\n        public static class ExtLucasFactorial {\n            int exp;\n            int fact;\n            int p;\n            int pc;\n            Modular modular;\n            Power power;\n            ExtGCD extGCD = new ExtGCD();\n            int[] g;\n\n            /**\n             * O(pc)\n             *\n             * @param p  the prime\n             * @param pc p^c\n             * @param g  buffer\n             */\n            public ExtLucasFactorial(int p, int pc, int[] g) {\n                this.p = p;\n                this.pc = pc;\n                this.g = g;\n                modular = new Modular(pc);\n                power = new Power(modular);\n                g[0] = 1;\n                g[1] = 1;\n                for (int i = 2; i <= pc; i++) {\n                    if (i % p == 0) {\n                        g[i] = g[i - 1];\n                    } else {\n                        g[i] = modular.mul(g[i - 1], i);\n                    }\n                }\n            }\n\n            /**\n             * return m! (mod pc) without any factor which is multiple of p.\n             * <br>\n             * O(\\log_2^2{m})\n             */\n            private int fact(long m) {\n                fact = 1;\n                exp = 0;\n                while (m > 1) {\n                    exp += m / p;\n                    fact = modular.mul(fact, power.pow(g[pc], m / pc));\n                    fact = modular.mul(fact, g[(int) (m % pc)]);\n                    m /= p;\n                }\n                return fact;\n            }\n\n            /**\n             * Find C(m,n), it means choose n elements from a set whose size is m.\n             * <br>\n             * O(\\log_2^2{m})\n             */\n            public int composite(long m, long n) {\n                int v = fact(m);\n                int e = exp;\n                extGCD.extgcd(fact(n), pc);\n                v = modular.mul(v, modular.valueOf(extGCD.getX()));\n                e -= exp;\n                extGCD.extgcd(fact(m - n), pc);\n                v = modular.mul(v, modular.valueOf(extGCD.getX()));\n                e -= exp;\n                v = modular.mul(v, power.pow(p, e));\n                return v;\n            }\n        }\n\n        /**\n         * Extend lucas algorithm\n         */\n        public static class ExtLucas {\n            PollardRho pr = new PollardRho();\n            Map<Integer, ExtLucasFactorial> factorialMap = new HashMap();\n\n            public ExtLucas(int p) {\n                Map<Integer, Integer> factors = pr.findAllFactors(p);\n                for (Map.Entry<Integer, Integer> entry : factors.entrySet()) {\n                    factorialMap.put(entry.getValue(), new ExtLucasFactorial(entry.getKey(), entry.getValue(), new int[entry.getValue() + 1]));\n                }\n            }\n\n            /**\n             * Get C(m, n) % p\n             */\n            public int composite(long m, long n) {\n                ExtCRT extCRT = new ExtCRT();\n                for (Map.Entry<Integer, ExtLucasFactorial> entry : factorialMap.entrySet()) {\n                    extCRT.add(entry.getValue().composite(m, n), entry.getKey());\n                }\n                return (int) extCRT.r;\n            }\n        }\n\n        /**\n         * Extend lucas algorithm long version\n         */\n        public static class LongExtLucas {\n            LongPollardRho pr = new LongPollardRho();\n            Map<Integer, ExtLucasFactorial> factorialMap = new HashMap();\n\n            public LongExtLucas(long p) {\n                Map<Long, Long> factors = pr.findAllFactors(p);\n                for (Map.Entry<Long, Long> entry : factors.entrySet()) {\n                    factorialMap.put(entry.getValue().intValue(), new ExtLucasFactorial(entry.getKey().intValue(), entry.getValue().intValue(), new int[entry.getValue().intValue() + 1]));\n                }\n            }\n\n            /**\n             * Get C(m, n) % p\n             */\n            public int composite(long m, long n) {\n                ExtCRT extCRT = new ExtCRT();\n                for (Map.Entry<Integer, ExtLucasFactorial> entry : factorialMap.entrySet()) {\n                    extCRT.add(entry.getValue().composite(m, n), entry.getKey());\n                }\n                return (int) extCRT.r;\n            }\n        }\n\n        /**\n         * Extend gcd\n         */\n        public static class ExtGCD {\n            private long x;\n            private long y;\n            private long g;\n\n            public long getX() {\n                return x;\n            }\n\n            public long getY() {\n                return y;\n            }\n\n            /**\n             * Get g = Gcd(a, b) and find a way to set x and y to match ax+by=g\n             */\n            public long extgcd(long a, long b) {\n                if (a >= b) {\n                    g = extgcd0(a, b);\n                } else {\n                    g = extgcd0(b, a);\n                    long tmp = x;\n                    x = y;\n                    y = tmp;\n                }\n                return g;\n            }\n\n\n            private long extgcd0(long a, long b) {\n                if (b == 0) {\n                    x = 1;\n                    y = 0;\n                    return a;\n                }\n                long g = extgcd0(b, a % b);\n                long n = x;\n                long m = y;\n                x = m;\n                y = n - m * (a / b);\n                return g;\n            }\n        }\n\n        public static class Gcd {\n            public long gcd(long a, long b) {\n                return a >= b ? gcd0(a, b) : gcd0(b, a);\n            }\n\n            private long gcd0(long a, long b) {\n                return b == 0 ? a : gcd0(b, a % b);\n            }\n\n            public int gcd(int a, int b) {\n                return a >= b ? gcd0(a, b) : gcd0(b, a);\n            }\n\n            private int gcd0(int a, int b) {\n                return b == 0 ? a : gcd0(b, a % b);\n            }\n        }\n\n        /**\n         * Euler sieve for filter primes\n         */\n        public static class EulerSieve {\n            int[] primes;\n            boolean[] isComp;\n            int primeLength;\n\n            public EulerSieve(int limit) {\n                isComp = new boolean[limit + 1];\n                primes = new int[limit + 1];\n                primeLength = 0;\n                for (int i = 2; i <= limit; i++) {\n                    if (!isComp[i]) {\n                        primes[primeLength++] = i;\n                    }\n                    for (int j = 0, until = limit / i; j < primeLength && primes[j] <= until; j++) {\n                        int pi = primes[j] * i;\n                        isComp[pi] = true;\n                        if (i % primes[j] == 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Euler sieve for multiplicative function\n         */\n        public static class MultiplicativeFunctionSieve {\n            int[] primes;\n            boolean[] isComp;\n            int primeLength;\n            int[] mobius;\n            int[] euler;\n            int[] factors;\n            int[] smallestPrimeFactor;\n            int[] numberOfSmallestPrimeFactor;\n\n            public MultiplicativeFunctionSieve(int limit, boolean enableMobius, boolean enableEuler, boolean enableFactors) {\n                isComp = new boolean[limit + 1];\n                primes = new int[limit + 1];\n                numberOfSmallestPrimeFactor = new int[limit + 1];\n                smallestPrimeFactor = new int[limit + 1];\n                primeLength = 0;\n                for (int i = 2; i <= limit; i++) {\n                    if (!isComp[i]) {\n                        primes[primeLength++] = i;\n                        numberOfSmallestPrimeFactor[i] = smallestPrimeFactor[i] = i;\n                    }\n                    for (int j = 0, until = limit / i; j < primeLength && primes[j] <= until; j++) {\n                        int pi = primes[j] * i;\n                        smallestPrimeFactor[pi] = primes[j];\n                        numberOfSmallestPrimeFactor[pi] = smallestPrimeFactor[i] == primes[j]\n                                ? (numberOfSmallestPrimeFactor[i] * numberOfSmallestPrimeFactor[primes[j]])\n                                : numberOfSmallestPrimeFactor[primes[j]];\n                        isComp[pi] = true;\n                        if (i % primes[j] == 0) {\n                            break;\n                        }\n                    }\n                }\n\n                if (enableMobius) {\n                    mobius = new int[limit + 1];\n                    mobius[1] = 1;\n                    for (int i = 2; i <= limit; i++) {\n                        if (!isComp[i]) {\n                            mobius[i] = -1;\n                        } else {\n                            if (numberOfSmallestPrimeFactor[i] != smallestPrimeFactor[i]) {\n                                mobius[i] = 0;\n                            } else {\n                                mobius[i] = mobius[numberOfSmallestPrimeFactor[i]] *\n                                        mobius[i / numberOfSmallestPrimeFactor[i]];\n                            }\n                        }\n                    }\n                }\n\n                if (enableEuler) {\n                    euler = new int[limit + 1];\n                    euler[1] = 1;\n                    for (int i = 2; i <= limit; i++) {\n                        if (!isComp[i]) {\n                            euler[i] = i - 1;\n                        } else {\n                            if (numberOfSmallestPrimeFactor[i] == i) {\n                                euler[i] = i - i / smallestPrimeFactor[i];\n                            } else {\n                                euler[i] = euler[numberOfSmallestPrimeFactor[i]] *\n                                        euler[i / numberOfSmallestPrimeFactor[i]];\n                            }\n                        }\n                    }\n                }\n\n                if (enableFactors) {\n                    factors = new int[limit + 1];\n                    factors[1] = 1;\n                    for (int i = 2; i <= limit; i++) {\n                        if (!isComp[i]) {\n                            factors[i] = 2;\n                        } else {\n                            if (numberOfSmallestPrimeFactor[i] == i) {\n                                factors[i] = 1 + factors[i / smallestPrimeFactor[i]];\n                            } else {\n                                factors[i] = factors[numberOfSmallestPrimeFactor[i]] *\n                                        factors[i / numberOfSmallestPrimeFactor[i]];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Mod operations\n         */\n        public static class Modular {\n            int m;\n\n            public Modular(int m) {\n                this.m = m;\n            }\n\n            public int valueOf(int x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return x;\n            }\n\n            public int valueOf(long x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return (int) x;\n            }\n\n            public int mul(int x, int y) {\n                return valueOf((long) x * y);\n            }\n\n            public int mul(long x, long y) {\n                x = valueOf(x);\n                y = valueOf(y);\n                return valueOf(x * y);\n            }\n\n            public int plus(int x, int y) {\n                return valueOf(x + y);\n            }\n\n            public int plus(long x, long y) {\n                x = valueOf(x);\n                y = valueOf(y);\n                return valueOf(x + y);\n            }\n\n            public int subtract(int x, int y) {\n                return valueOf(x - y);\n            }\n\n            public int subtract(long x, long y) {\n                return valueOf(x - y);\n            }\n\n            @Override\n            public String toString() {\n                return \"mod \" + m;\n            }\n        }\n\n        /**\n         * Bit operations\n         */\n        public static class BitOperator {\n            public int bitAt(int x, int i) {\n                return (x >> i) & 1;\n            }\n\n            public int bitAt(long x, int i) {\n                return (int) ((x >> i) & 1);\n            }\n\n            public int setBit(int x, int i, boolean v) {\n                if (v) {\n                    x |= 1 << i;\n                } else {\n                    x &= ~(1 << i);\n                }\n                return x;\n            }\n\n            public long setBit(long x, int i, boolean v) {\n                if (v) {\n                    x |= 1L << i;\n                } else {\n                    x &= ~(1L << i);\n                }\n                return x;\n            }\n\n            public long swapBit(long x, int i, int j) {\n                int bi = bitAt(x, i);\n                int bj = bitAt(x, j);\n                x = setBit(x, i, bj == 1);\n                x = setBit(x, j, bi == 1);\n                return x;\n            }\n\n            public int swapBit(int x, int i, int j) {\n                int bi = bitAt(x, i);\n                int bj = bitAt(x, j);\n                x = setBit(x, i, bj == 1);\n                x = setBit(x, j, bi == 1);\n                return x;\n            }\n\n            /**\n             * Determine whether x is subset of y\n             */\n            public boolean subset(long x, long y) {\n                return intersect(x, y) == x;\n            }\n\n            /**\n             * Merge two set\n             */\n            public long merge(long x, long y) {\n                return x | y;\n            }\n\n            public long intersect(long x, long y) {\n                return x & y;\n            }\n\n            public long differ(long x, long y) {\n                return x - intersect(x, y);\n            }\n        }\n\n        /**\n         * Power operations\n         */\n        public static class Power {\n            public Modular getModular() {\n                return modular;\n            }\n\n            final Modular modular;\n\n            public Power(Modular modular) {\n                this.modular = modular;\n            }\n\n            public int pow(int x, long n) {\n                if (n == 0) {\n                    return 1;\n                }\n                long r = pow(x, n >> 1);\n                r = modular.valueOf(r * r);\n                if ((n & 1) == 1) {\n                    r = modular.valueOf(r * x);\n                }\n                return (int) r;\n            }\n\n            public int inverse(int x) {\n                return pow(x, modular.m - 2);\n            }\n\n            public int pow2(int x) {\n                return x * x;\n            }\n\n            public long pow2(long x) {\n                return x * x;\n            }\n\n            public double pow2(double x) {\n                return x * x;\n            }\n        }\n\n        /**\n         * Log operations\n         */\n        public static class Log2 {\n            public int ceilLog(int x) {\n                return 32 - Integer.numberOfLeadingZeros(x - 1);\n            }\n\n            public int floorLog(int x) {\n                return 31 - Integer.numberOfLeadingZeros(x);\n            }\n\n            public int ceilLog(long x) {\n                return 64 - Long.numberOfLeadingZeros(x - 1);\n            }\n\n            public int floorLog(long x) {\n                return 63 - Long.numberOfLeadingZeros(x);\n            }\n        }\n\n        /**\n         * Find all inverse number\n         */\n        public static class InverseNumber {\n            int[] inv;\n\n            public InverseNumber(int[] inv, int limit, Modular modular) {\n                this.inv = inv;\n                inv[1] = 1;\n                int p = modular.m;\n                for (int i = 2; i <= limit; i++) {\n                    int k = p / i;\n                    int r = p % i;\n                    inv[i] = modular.mul(-k, inv[r]);\n                }\n            }\n\n            public InverseNumber(int limit, Modular modular) {\n                this(new int[limit + 1], limit, modular);\n            }\n        }\n\n        /**\n         * Factorial\n         */\n        public static class Factorial {\n            int[] fact;\n            int[] inv;\n\n            public Factorial(int[] fact, int[] inv, InverseNumber in, int limit, Modular modular) {\n                this.fact = fact;\n                this.inv = inv;\n                fact[0] = inv[0] = 1;\n                for (int i = 1; i <= limit; i++) {\n                    fact[i] = modular.mul(fact[i - 1], i);\n                    inv[i] = modular.mul(inv[i - 1], in.inv[i]);\n                }\n            }\n\n            public Factorial(int limit, Modular modular) {\n                this(new int[limit + 1], new int[limit + 1], new InverseNumber(limit, modular), limit, modular);\n            }\n        }\n\n        /**\n         * Composition\n         */\n        public static class Composite {\n            final Factorial factorial;\n            final Modular modular;\n\n            public Composite(Factorial factorial, Modular modular) {\n                this.factorial = factorial;\n                this.modular = modular;\n            }\n\n            public Composite(int limit, Modular modular) {\n                this(new Factorial(limit, modular), modular);\n            }\n\n            public int composite(int m, int n) {\n                if (n > m) {\n                    return 0;\n                }\n                return modular.mul(modular.mul(factorial.fact[m], factorial.inv[n]), factorial.inv[m - n]);\n            }\n        }\n\n        /**\n         * Test whether a number is primes\n         */\n        public static class MillerRabin {\n            Modular modular;\n            Power power;\n\n            /**\n             * Check whether n is a prime s times\n             */\n            public boolean mr(int n, int s) {\n                if (n == 2) {\n                    return true;\n                }\n                if (n % 2 == 0) {\n                    return false;\n                }\n                modular = new Modular(n);\n                power = new Power(modular);\n                for (int i = 0; i < s; i++) {\n                    int x = RANDOM.nextInt(n - 2) + 2;\n                    if (!mr0(x, n)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n\n            private boolean mr0(int x, int n) {\n                int exp = n - 1;\n                while (true) {\n                    int y = power.pow(x, exp);\n                    if (y != 1 && y != n - 1) {\n                        return false;\n                    }\n                    if (y != 1 || exp % 2 == 1) {\n                        break;\n                    }\n                    exp = exp / 2;\n                }\n                return true;\n            }\n        }\n\n        /**\n         * Modular operation for long version\n         */\n        public static class LongModular {\n            final long m;\n\n            public LongModular(long m) {\n                this.m = m;\n            }\n\n            public long mul(long a, long b) {\n                return b == 0 ? 0 : ((mul(a, b >> 1) << 1) % m + a * (b & 1)) % m;\n            }\n\n            public long plus(long a, long b) {\n                return valueOf(a + b);\n            }\n\n            public long subtract(long a, long b) {\n                return valueOf(a - b);\n            }\n\n            public long valueOf(long a) {\n                a %= m;\n                if (a < 0) {\n                    a += m;\n                }\n                return a;\n            }\n        }\n\n        public static class LongPower {\n            public LongModular getModular() {\n                return modular;\n            }\n\n            final LongModular modular;\n\n            public LongPower(LongModular modular) {\n                this.modular = modular;\n            }\n\n            long pow(long x, long n) {\n                if (n == 0) {\n                    return 1;\n                }\n                long r = pow(x, n >> 1);\n                r = modular.mul(r, r);\n                if ((n & 1) == 1) {\n                    r = modular.mul(r, x);\n                }\n                return r;\n            }\n\n            long inverse(long x) {\n                return pow(x, modular.m - 2);\n            }\n        }\n\n        /**\n         * Test whether a number is primes\n         */\n        public static class LongMillerRabin {\n            LongModular modular;\n            LongPower power;\n\n            /**\n             * Check whether n is a prime s times\n             */\n            public boolean mr(long n, int s) {\n                if (n == 2) {\n                    return true;\n                }\n                if (n % 2 == 0) {\n                    return false;\n                }\n                modular = new LongModular(n);\n                power = new LongPower(modular);\n                for (int i = 0; i < s; i++) {\n                    long x = (long) (RANDOM.nextDouble() * (n - 2) + 2);\n                    if (!mr0(x, n)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n\n            private boolean mr0(long x, long n) {\n                long exp = n - 1;\n                while (true) {\n                    long y = power.pow(x, exp);\n                    if (y != 1 && y != n - 1) {\n                        return false;\n                    }\n                    if (y != 1 || exp % 2 == 1) {\n                        break;\n                    }\n                    exp = exp / 2;\n                }\n                return true;\n            }\n        }\n\n        public static class LongPollardRho {\n            LongMillerRabin mr = new LongMillerRabin();\n            Gcd gcd = new Gcd();\n            LongModular modular;\n\n            /**\n             * Find a factor of n, if n is returned, it means n is 1 or a prime\n             */\n            public long findFactor(long n) {\n                if (mr.mr(n, 3)) {\n                    return n;\n                }\n                modular = new LongModular(n);\n                while (true) {\n                    long f = findFactor0((long) (RANDOM.nextDouble() * n), (long) (RANDOM.nextDouble() * n), n);\n                    if (f != -1) {\n                        return f;\n                    }\n                }\n            }\n\n            private long findFactor0(long x, long c, long n) {\n                long xi = x;\n                long xj = x;\n                int j = 2;\n                int i = 1;\n                while (i < n) {\n                    i++;\n                    xi = modular.plus(modular.mul(xi, xi), c);\n                    long g = gcd.gcd(n, Math.abs(xi - xj));\n                    if (g != 1 && g != n) {\n                        return g;\n                    }\n                    if (i == j) {\n                        j = j << 1;\n                        xj = xi;\n                    }\n                }\n                return -1;\n            }\n\n            /**\n             * Find the representation of n=p1^c1 * p2^c2 * ... * pm ^ cm.\n             * <br>\n             * The returned map contained such entries: pi -> pi^ci\n             */\n            public Map<Long, Long> findAllFactors(long n) {\n                Map<Long, Long> map = new HashMap();\n                findAllFactors(map, n);\n                return map;\n            }\n\n            private void findAllFactors(Map<Long, Long> map, long n) {\n                if (n == 1) {\n                    return;\n                }\n                long f = findFactor(n);\n                if (f == n) {\n                    Long value = map.get(f);\n                    if (value == null) {\n                        value = 1L;\n                    }\n                    map.put(f, value * f);\n                    return;\n                }\n                findAllFactors(map, f);\n                findAllFactors(map, n / f);\n            }\n\n        }\n\n        /**\n         * Extend chinese remainder theory\n         */\n        public static class ExtCRT {\n            /**\n             * remainder\n             */\n            long r;\n            /**\n             * modulus\n             */\n            long m;\n            ExtGCD gcd = new ExtGCD();\n\n            public ExtCRT() {\n                r = 0;\n                m = 1;\n            }\n\n            /**\n             * Add a new condition: x % m = r\n             */\n            public boolean add(long r, long m) {\n                long m1 = this.m;\n                long x1 = this.r;\n                long m2 = m;\n                long x2 = ((r % m) + m) % m;\n                long g = gcd.extgcd(m1, m2);\n                long a = gcd.getX();\n                if ((x2 - x1) % g != 0) {\n                    return false;\n                }\n                this.m = m1 / g * m2;\n                this.r = BigInteger.valueOf(a).multiply(BigInteger.valueOf((x2 - x1) / g))\n                        .multiply(BigInteger.valueOf(m1)).add(BigInteger.valueOf(x1))\n                        .mod(BigInteger.valueOf(this.m)).longValue();\n                return true;\n            }\n        }\n\n        /**\n         * Lucas algorithm\n         */\n        public static class Lucas {\n            private final Composite composite;\n            private int modulus;\n\n            public Lucas(Composite composite) {\n                this.composite = composite;\n                this.modulus = composite.modular.m;\n            }\n\n            public int composite(long m, long n) {\n                if (n == 0) {\n                    return 1;\n                }\n                return composite.modular.mul(composite.composite((int) (m % modulus), (int) (n % modulus)),\n                        composite(m / modulus, n / modulus));\n            }\n        }\n\n        /**\n         * Find all factors of a number\n         */\n        public static class PollardRho {\n            MillerRabin mr = new MillerRabin();\n            Gcd gcd = new Gcd();\n            Random random = new Random();\n\n            public int findFactor(int n) {\n                if (mr.mr(n, 10)) {\n                    return n;\n                }\n                while (true) {\n                    int f = findFactor0(random.nextInt(n), random.nextInt(n), n);\n                    if (f != -1) {\n                        return f;\n                    }\n                }\n            }\n\n            /**\n             * Find all prime factor of n\n             * <br>\n             * p1 => p1^c1\n             * <br>\n             * ...\n             * <br>\n             * pk => pk^ck\n             */\n            public Map<Integer, Integer> findAllFactors(int n) {\n                Map<Integer, Integer> map = new HashMap();\n                findAllFactors(map, n);\n                return map;\n            }\n\n            private void findAllFactors(Map<Integer, Integer> map, int n) {\n                if (n == 1) {\n                    return;\n                }\n                int f = findFactor(n);\n                if (f == n) {\n                    Integer value = map.get(f);\n                    if (value == null) {\n                        value = 1;\n                    }\n                    map.put(f, value * f);\n                    return;\n                }\n                findAllFactors(map, f);\n                findAllFactors(map, n / f);\n            }\n\n            private int findFactor0(int x, int c, int n) {\n                int xi = x;\n                int xj = x;\n                int j = 2;\n                int i = 1;\n                while (i < n) {\n                    i++;\n                    xi = (int) ((long) xi * xi + c) % n;\n                    int g = gcd.gcd(n, Math.abs(xi - xj));\n                    if (g != 1 && g != n) {\n                        return g;\n                    }\n                    if (i == j) {\n                        j = j << 1;\n                        xj = xi;\n                    }\n                }\n                return -1;\n            }\n        }\n\n        public static class ModExpression {\n            ExtGCD extGCD = new ExtGCD();\n            Modular modular = new Modular(1);\n\n            /**\n             * Find ka=b(mod c) where k is the minimum possible non negative integer.\n             * <br>\n             * If it's impossible, -1 will be returned.\n             */\n            public long solve(long a, long b, int c) {\n                modular.m = c;\n                a = modular.valueOf(a);\n                b = modular.valueOf(b);\n                int g = (int) extGCD.extgcd((int) a, c);\n                if (b % g != 0) {\n                    return -1;\n                }\n                modular.m = c / g;\n                return modular.valueOf(b / g * extGCD.getX());\n            }\n        }\n\n        /**\n         * \\sum_{i=1}^{limit}f(\\lfloor n/i \\rfloor)\n         */\n        public static class FloorDivisionOptimizer {\n            int l;\n            int r;\n            int n;\n            int limit;\n\n\n            public FloorDivisionOptimizer(int n, int l, int limit) {\n                this.n = n;\n                this.l = 0;\n                this.limit = limit;\n                this.r = l - 1;\n            }\n\n            public boolean hasNext() {\n                return r < limit;\n            }\n\n            public int next() {\n                l = r + 1;\n                r = n / (n / l);\n                return n / l;\n            }\n        }\n\n\n        public static class QuadraticResidue {\n            final Modular modular;\n            final BitOperator bitOperator = new BitOperator();\n            Power power;\n            final PollardRho rho = new PollardRho();\n\n\n            public QuadraticResidue(Modular modular) {\n                this.modular = modular;\n                power = new Power(modular);\n            }\n\n            /**\n             * return \\sqrt{n} or -1 if it doesn't exist\n             */\n            public int square(int n) {\n                n = modular.valueOf(n);\n                if (n == 0) {\n                    return 0;\n                }\n                int p = modular.m;\n                if (power.pow(n, (p - 1) / 2) != 1) {\n                    return -1;\n                }\n                while (true) {\n                    int a = RANDOM.nextInt(p);\n                    int w = modular.plus(modular.mul(a, a), -n);\n                    if (power.pow(w, (p - 1) / 2) == 1) {\n                        continue;\n                    }\n\n\n                    int pow = (p + 1) / 2;\n                    int i = 31 - Integer.numberOfLeadingZeros(pow);\n                    int real = 1;\n                    int img = 0;\n                    for (; i >= 0; i--) {\n                        int nReal = modular.plus(modular.mul(real, real),\n                                modular.mul(modular.mul(img, img), w));\n                        int nImg = modular.mul(modular.mul(real, img), 2);\n                        real = nReal;\n                        img = nImg;\n                        if (bitOperator.bitAt(pow, i) == 1) {\n                            nReal = modular.plus(modular.mul(real, a), modular.mul(img, w));\n                            nImg = modular.plus(modular.mul(img, a), real);\n                            real = nReal;\n                            img = nImg;\n                        }\n                    }\n\n                    return real;\n                }\n            }\n\n            public int minPrimitiveRoot() {\n                if (modular.m == 2) {\n                    return 1;\n                }\n                Map<Integer, Integer> factorMap = rho.findAllFactors(modular.m - 1);\n                int[] factors = factorMap.keySet().stream().mapToInt(Integer::intValue).toArray();\n                for (int i = 2; ; i++) {\n                    boolean valid = true;\n                    for (int factor : factors) {\n                        if (power.pow(i, (modular.m - 1) / factor) == 1) {\n                            valid = false;\n                            break;\n                        }\n                    }\n                    if (valid) {\n                        return i;\n                    }\n                }\n            }\n        }\n    }\n\n    public static class FastIO {\n        public final StringBuilder cache = new StringBuilder(1 << 13);\n        private final InputStream is;\n        private final OutputStream os;\n        private final Charset charset;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 13);\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastIO(InputStream is, OutputStream os, Charset charset) {\n            this.is = is;\n            this.os = os;\n            this.charset = charset;\n        }\n\n        public FastIO(InputStream is, OutputStream os) {\n            this(is, os, Charset.forName(\"ascii\"));\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public long readLong() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            long val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public double readDouble() {\n            boolean sign = true;\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+';\n                next = read();\n            }\n\n            long val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 + next - '0';\n                next = read();\n            }\n            if (next != '.') {\n                return sign ? val : -val;\n            }\n            next = read();\n            long radix = 1;\n            long point = 0;\n            while (next >= '0' && next <= '9') {\n                point = point * 10 + next - '0';\n                radix = radix * 10;\n                next = read();\n            }\n            double result = val + (double) point / radix;\n            return sign ? result : -result;\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n        public int readLine(char[] data, int offset) {\n            int originalOffset = offset;\n            while (next != -1 && next != '\\n') {\n                data[offset++] = (char) next;\n                next = read();\n            }\n            return offset - originalOffset;\n        }\n\n        public int readString(char[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (char) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public int readString(byte[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (byte) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public char readChar() {\n            skipBlank();\n            char c = (char) next;\n            next = read();\n            return c;\n        }\n\n        public void flush() throws IOException {\n            os.write(cache.toString().getBytes(charset));\n            os.flush();\n            cache.setLength(0);\n        }\n\n        public boolean hasMore() {\n            skipBlank();\n            return next != -1;\n        }\n    }\n\n    public static class Debug {\n        private boolean allowDebug;\n\n        public Debug(boolean allowDebug) {\n            this.allowDebug = allowDebug;\n        }\n\n        public void assertTrue(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (!flag) {\n                fail();\n            }\n        }\n\n        public void fail() {\n            throw new RuntimeException();\n        }\n\n        public void assertFalse(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (flag) {\n                fail();\n            }\n        }\n\n        private void outputName(String name) {\n            System.out.print(name + \" = \");\n        }\n\n        public void debug(String name, int x) {\n            if (!allowDebug) {\n                return;\n            }\n\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, long x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, double x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, int[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, long[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, double[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, Object x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, Object... x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.deepToString(x));\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tstatic final long MOD = 1000000007;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tif(K==1) {\n\t\t\tSystem.out.println(1);\n\t\t\tsc.close();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tinit(N*K);\n\t\t\n\t\tlong[][] dp = new long[N+1][N+1];\n\t\tdp[0][0] = 1;\n\t\tfor(int i=0; i<=N; i++) {\n\t\t\tfor(int j=i; j<=N; j++) {\n\t\t\t\tif(i>0)\n\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\tif(j>i)\n\t\t\t\t\tdp[i][j] += dp[i][j-1]*comb(i+j*(K-1)-1, K-2);\n\t\t\t\tdp[i][j] %= MOD;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println((dp[N][N]*fac[N])%MOD);\n\t\tsc.close();\n\t}\n\t\n\tstatic long fac[],rev[],revfac[];\n\t\n\tstatic void init(int N) {\n\t\tfac = new long[N+1];\n\t\trev = new long[N+1];\n\t\trevfac = new long[N+1];\n\t\tfac[0] = 1;\n\t\trev[0] = 0;\n\t\trevfac[0] = 1;\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tfac[i] = fac[i-1]*i%MOD;\n\t\t\trev[i] = pow(i, MOD-2);\n\t\t\trevfac[i] = pow(fac[i], MOD-2);\n\t\t}\n\t}\n\tstatic int pow(long a, long b) {\n\t\tlong ans = 1;\n\t\twhile(b>0) {\n\t\t\tif((b&1)!=0)\n\t\t\t\tans = (ans * a)%MOD;\n\t\t\ta = (a * a)%MOD;\n\t\t\tb>>=1;\n\t\t}\n\t\treturn (int)ans;\n\t}\n\tstatic long comb(int a, int b) {\n\t\tif(a<0 || b<0 || a<b)\n\t\t\treturn 0;\n\t\treturn (((fac[a]*revfac[a-b])%MOD)*revfac[b])%MOD;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        static final long MODULO = (long) (1e9 + 7);\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            if (k == 1) {\n                out.println(1);\n                return;\n            }\n            long[] invs = new long[k + 1];\n            invs[1] = 1;\n            for (int i = 2; i < invs.length; ++i) {\n                invs[i] = (MODULO - (MODULO / i) * invs[((int) (MODULO % i))] % MODULO) % MODULO;\n            }\n            long invProd = 1;\n            for (int i = 1; i <= k - 2; ++i) {\n                invProd = invProd * invs[i] % MODULO;\n            }\n            long[] ways = new long[]{1};\n            long[] sufProds = new long[k - 1];\n            int upto = Integer.MIN_VALUE;\n            for (int i = 1; i < n; ++i) {\n                long[] nways = new long[ways.length + 1];\n                long sum = 0;\n                long prefProd = 1;\n                for (int newZ = nways.length; newZ >= 1; --newZ) {\n                    if (newZ > 1) {\n                        sum += ways[newZ - 2];\n                        sum %= MODULO;\n                    }\n                    int need = (i + 1) * k - newZ - 1;\n                    if (upto < (need - (k - 2))) {\n                        upto = need;\n                        sufProds[0] = 1;\n                        for (int j = 1; j < sufProds.length; ++j) {\n                            sufProds[j] = sufProds[j - 1] * (upto - j + 1) % MODULO;\n                        }\n                        prefProd = 1;\n                    } else {\n                        prefProd *= need;\n                        prefProd %= MODULO;\n                    }\n                    nways[newZ - 1] = (nways[newZ - 1] + sum * prefProd % MODULO * sufProds[upto - (need - (k - 2))] % MODULO * invProd % MODULO) % MODULO;\n                }\n                ways = nways;\n            }\n            long res = 0;\n            for (long x : ways) res += x;\n            res %= MODULO;\n            for (int i = 1; i <= n; ++i) {\n                res = res * i % MODULO;\n            }\n            out.println(res);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class F {\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tboolean eof;\n\n\tstatic final int P = 1_000_000_007;\n\n\tvoid solve() throws IOException {\n\t\tint n = nextInt();\n\t\tint k = nextInt();\n\n\t\tif (k == 1) {\n\t\t\tout.println(1);\n\t\t\treturn;\n\t\t}\n\n\t\tModuloCombinatorics mc = new ModuloCombinatorics(n * k, P);\n\n\t\tint[][] dp = new int[n + 1][n + 1];\n\t\tdp[0][0] = 1;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tfor (int j = i; j <= n; j++) {\n\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\tif (dp[i][j] >= P) {\n\t\t\t\t\t\tdp[i][j] -= P;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (j > i) {\n\t\t\t\t\tdp[i][j] += (int) ((long) dp[i][j - 1]\n\t\t\t\t\t\t\t* mc.choose(i + j * (k - 1) - 1, k - 2) % P);\n\t\t\t\t\tdp[i][j] %= P;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tint ret = (int)((long)dp[n][n] * mc.fact[n] % P);\n\n\t\tout.println(ret);\n\t}\n\n\tstatic class ModuloCombinatorics {\n\t\t/** maximal needed number, N itself is included **/\n\t\tfinal int N;\n\n\t\t/** prime modulo **/\n\t\tfinal int P;\n\n\t\t/** factorials **/\n\t\tfinal int[] fact;\n\n\t\t/** multiplicative inverses, take care to not touch inv[0] **/\n\t\tfinal int[] inv;\n\n\t\t/** inverse factorials **/\n\t\tfinal int[] invFact;\n\n\t\tpublic ModuloCombinatorics(int N, int P) {\n\t\t\tthis.N = N;\n\t\t\tthis.P = P;\n\t\t\tfact = new int[N + 1];\n\t\t\tfact[0] = 1;\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tfact[i] = (int) ((long) i * fact[i - 1] % P);\n\t\t\t}\n\n\t\t\tinv = new int[N + 1];\n\t\t\tinv[1] = 1;\n\t\t\tfor (int i = 2; i <= N; i++) {\n\t\t\t\tinv[i] = P - (int) ((long) (P / i) * inv[P % i] % P);\n\t\t\t}\n\n\t\t\tinvFact = new int[N + 1];\n\t\t\tinvFact[0] = 1;\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tinvFact[i] = (int) ((long) invFact[i - 1] * inv[i] % P);\n\t\t\t}\n\t\t}\n\n\t\tpublic int choose(int n, int k) {\n\t\t\tif (n < 0 || k < 0 || k > n) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn (int) ((long) fact[n] * invFact[k] % P * invFact[n - k] % P);\n\t\t}\n\n\t\t/** a^b modulo mod, mod is arbitrary **/\n\t\tstatic public int pow(int a, long b, int mod) {\n\t\t\tif (a < 0 || a >= mod || b < 0) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t\tint ret = 1;\n\t\t\tfor (; b > 0; b >>= 1) {\n\t\t\t\tif ((b & 1) == 1) {\n\t\t\t\t\tret = (int) ((long) ret * a % mod);\n\t\t\t\t}\n\t\t\t\ta = (int) ((long) a * a % mod);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t/** a^b modulo P **/\n\t\tpublic int pow(int a, long b) {\n\t\t\treturn pow(a, b, P);\n\t\t}\n\t}\n\n\tF() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew F();\n\t}\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\teof = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tstatic final long MOD = 1000000007;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tif(K==1) {\n\t\t\tSystem.out.println(1);\n\t\t\tsc.close();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tinit(N*K);\n\t\t\n\t\tlong[][] dp = new long[N+1][N+1];\n\t\tdp[0][0] = 1;\n\t\tfor(int i=0; i<=N; i++) {\n\t\t\tfor(int j=i; j<=N; j++) {\n\t\t\t\tif(i>0)\n\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\tif(j>i)\n\t\t\t\t\tdp[i][j] += dp[i][j-1]*comb(i+j*(K-1)-1, K-2);\n\t\t\t\tdp[i][j] %= MOD;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println((dp[N][N]*fac[N])%MOD);\n\t\tsc.close();\n\t}\n\t\n\tstatic long fac[],rev[];\n\t\n\tstatic void init(int N) {\n\t\tfac = new long[N+1];\n\t\trev = new long[N+1];\n\t\tfac[0] = 1;\n\t\trev[0] = 1;\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tfac[i] = fac[i-1]*i%MOD;\n\t\t\trev[i] = pow(fac[i], MOD-2);\n\t\t}\n\t}\n\tstatic int pow(long a, long b) {\n\t\tlong ans = 1;\n\t\twhile(b>0) {\n\t\t\tif((b&1)!=0)\n\t\t\t\tans = (ans * a)%MOD;\n\t\t\ta = (a * a)%MOD;\n\t\t\tb>>=1;\n\t\t}\n\t\treturn (int)ans;\n\t}\n\tstatic long comb(int a, int b) {\n\t\tif(a<0 || b<0 || a<b)\n\t\t\treturn 0;\n\t\treturn (((fac[a]*rev[a-b])%MOD)*rev[b])%MOD;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n\npublic class Main {\n    private static final int MAX = 600;\n    private static ArrayList<Long> divs = new ArrayList<>();\n    private static HashMap<Integer,Integer> primes = new HashMap<>();\n    private static int [] prime = new int[MAX + 1];\n    private static int [] f = new int[MAX + 1];\n\n    private static int add(int a,int b,int mod) {\n        a += b;\n        if(a >= mod) a -= mod;\n        if(a < 0) a += mod;\n        return a;\n    }\n    private static int mul(int a,int b,int mod) {\n        return (int)((a*1L*b)%mod);\n    }\n    private static int powmod(int a,int p,int mod) {\n        if(p == 0) return 1;\n        int b = 1;\n        for (;p > 1;p >>= 1) {\n            if(p%2 == 1) b = mul(a,b,mod);\n            a = mul(a,a,mod);\n        }\n        return mul(a,b,mod);\n    }\n\n    private static void sieve(){\n        for (int i = 2;i <= MAX;i++)\n            if(prime[i] == 0) {\n                prime[i] = i;\n                for (long j = i*1L*i;j <= MAX;j += i)\n                    prime[(int)j] = i;\n            }\n    }\n\n    private static void factorize(int x,int sgn ) {\n        while (x > 1) {\n            int p = prime[x];\n            int q = 0;\n            while (x%p == 0) {\n                x /= p;\n                q++;\n            }\n            if(!primes.containsKey(p)) primes.put(p,0);\n            primes.put(p,primes.get(p) + sgn * q);\n        }\n    }\n    private static void get_divs(int l) {\n        divs.clear();\n        divs.add(1L);\n        for (int p : primes.keySet()) {\n            int siz = divs.size();\n            int s = 0,e = siz;\n            for (int i = 0,q = primes.get(p);i < q;i++){\n                int ctr = 0;\n                while (s < e) {\n                    long val = divs.get(s)*p;\n                    if(val-1 <= l) {\n                        divs.add(val);\n                        ++ctr;\n                    }\n                    s++;\n                }\n                e += ctr;\n            }\n        }\n    }\n    private static int mod = 1000*1000*1000 + 7;\n    private static int N,K;\n    private static Integer [] [] dp = new Integer[2002][2002];\n    private static int [] fact = new int[2000*2000 + 10];\n    private static int [] rev = new int[2000*2000 + 10];\n    private static void init(){\n        fact[0] = 1;\n        rev[0] = 1;\n        for (int i = 1;i < 2000*2000+10;i++) {\n            fact[i] = mul(i, fact[i - 1], mod);\n            rev[i] = powmod(fact[i],mod-2,mod);\n        }\n    }\n\n    private static int C(int n,int k) {\n        if(k > n) return 0;\n        int ret = fact[n];\n        ret = mul(mul(ret,rev[k],mod),rev[n-k],mod);\n        return ret;\n    }\n    private static int solve(int r1,int r2) {\n        if(r2 == N+1) return 1;\n        if(dp[r1][r2] != null) return dp[r1][r2];\n        int ret = 0;\n        if(r1 <= N) ret = solve(r1+1,r2);\n        if(r2 < r1) ret = add(ret,mul(solve(r1,r2+1),C(N*K-(r1-1)-(r2-1)*(K-1)-1,K-2),mod),mod);\n        dp[r1][r2] = ret;\n        //System.err.println(r1 + \" \" + r2 + \" -> \" + ret);\n        return ret;\n    }\n\n    public static void main(String[] args) throws Exception{\n        IO io = new IO(null,null);\n    //    sieve();\n        init();\n        N = io.getNextInt();\n        K = io.getNextInt();\n        if(K == 1) io.println(1);\n        else io.println(mul(fact[N],solve(1,1),mod));\n        io.close();\n    }\n}\n\n\nclass frac{\n    BigInteger A,B;\n    public frac(long a,long b){\n        A = BigInteger.valueOf(a);\n        B = BigInteger.valueOf(b);\n        BigInteger g = A.gcd(B);\n        A = A.divide(g);\n        B = B.divide(g);\n    }\n    public frac(BigInteger a,BigInteger b) {\n        BigInteger g = a.gcd(b);\n        a = a.divide(g);\n        b = b.divide(g);\n        this.A = a;\n        this.B = b;\n    }\n    public frac mul(frac o) {\n        BigInteger a = this.A.multiply(o.A);\n        BigInteger b = this.B.multiply(o.B);\n        return new frac(a,b);\n    }\n    public frac add(frac o) {\n        BigInteger a = this.A.multiply(o.B).add(this.B.multiply(o.A));\n        BigInteger b = this.B.multiply(o.B);\n        return new frac(a,b);\n    }\n    public frac sub(frac o) {\n        BigInteger a = this.A.multiply(o.B).subtract(this.B.multiply(o.A));\n        BigInteger b = this.B.multiply(o.B);\n        return new frac(a,b);\n    }\n    @Override\n    public String toString(){\n        return A + \"/\" + B ;\n    }\n}\n\n\n\nclass IO{\n    private BufferedReader br;\n    private StringTokenizer st;\n    private PrintWriter writer;\n    private String inputFile,outputFile;\n\n    public String getNext() throws FileNotFoundException, IOException{\n        while(st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n        return st.nextToken();\n    }\n\n    public String getNextLine() throws FileNotFoundException, IOException{\n        return br.readLine().trim();\n    }\n\n    public int getNextInt() throws FileNotFoundException, IOException{\n        return Integer.parseInt(getNext());\n    }\n    public long getNextLong() throws FileNotFoundException, IOException{\n        return Long.parseLong(getNext());\n    }\n\n    public void print(double x,int num_digits) throws  IOException{\n        writer.printf(\"%.\" + num_digits + \"f\" ,x);\n    }\n    public void println(double x,int num_digits) throws  IOException{\n        writer.printf(\"%.\" + num_digits + \"f\\n\" ,x);\n    }\n    public void print(Object o) throws  IOException{\n        writer.print(o.toString());\n    }\n\n    public void println(Object o) throws  IOException{\n        writer.println(o.toString());\n    }\n    public IO(String x,String y) throws FileNotFoundException, IOException{\n        inputFile = x;\n        outputFile = y;\n        if(x != null) br = new BufferedReader(new FileReader(inputFile));\n        else br = new BufferedReader(new InputStreamReader(System.in));\n        if(y != null) writer = new PrintWriter(new BufferedWriter(new FileWriter(outputFile)));\n        else writer = new PrintWriter(new OutputStreamWriter(System.out));\n    }\n\n    protected void close() throws IOException{\n        br.close();\n        writer.close();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        string[] str = Console.ReadLine().Split(' ');\n        int N = int.Parse(str[0]);\n        int K = int.Parse(str[1]);\n        if(K == 1){\n            sb.Append(\"1\\n\");\n            return;\n        }\n        Fact F = new Fact(N*K);\n        long[,] dp = new long[N+1,N+1];\n        for(int i=0;i<N+1;i++){\n            dp[i,0] = 1;\n            for(int j=1;j<=i;j++){\n                int L = N*K - i - j*(K-1) + K-1;\n                dp[i,j] = ((dp[i,j-1]*F.GetConv(L-1,K-2)%Define.mod)+dp[i-1,j])%Define.mod; \n            }\n        }\n        sb.Append((dp[N,N]*F.GetFact(N)%Define.mod)+\"\\n\");\n    }\n}\nclass Fact{\n    public long[] f;\n    public long[] rf;\n    public Fact(int N){\n        f = new long[N+1];\n        rf = new long[N+1];\n        for(int i=0;i<N+1;i++){\n            if(i == 0){\n                f[i] = 1;\n            }\n            else{\n                f[i] = (f[i-1]*i)%Define.mod;\n            }\n        }\n        for(int i=N;i>=0;i--){\n            if(i == N){\n                rf[i] = pow(f[N],Define.mod-2);\n            }\n            else{\n                rf[i] = rf[i+1]*(i+1)%Define.mod;\n            }\n        }\n    }\n    public long pow(long N,long K){\n        if(K == 0){\n            return 1;\n        }\n        else if(K % 2 == 0){\n            long t = pow(N,K/2);\n            return t*t%Define.mod;\n        }\n        else{\n            return N*pow(N,K-1)%Define.mod;\n        }\n    }\n    public long GetFact(int N){\n        return f[N];\n    }\n    public long GetConv(int N,int R){\n        return ((f[N]*rf[R])%Define.mod*rf[N-R])%Define.mod;\n    }\n}\npublic static class Define{\n    public const long mod = 1000000007;\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\nusing System.Numerics;\nusing Point = System.Numerics.Complex;\nusing Number = System.Int64;\nusing C = System.Int32;\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n            var n = sc.Integer();\n            var m = sc.Integer();\n            if (m == 1)\n            {\n                IO.Printer.Out.WriteLine(1);\n                return;\n            }\n            var table = new ModTable(2001 * 2001);\n            var dp = Enumerate(n + 2, x => new ModInteger[n + 2]);\n            dp[0][0] = 1;\n            for (int i = 0; i <= n; i++)\n                for (int j = 0; j <= n; j++)\n                {\n                    var rem = n - i + (m - 1) * (n - j);\n\n                    dp[i + 1][j] += dp[i][j];\n                    if (j + 1 <= i) dp[i][j + 1] += dp[i][j] * table.Combination(rem - 1, (m - 2));\n                }\n\n            IO.Printer.Out.WriteLine(dp[n][n] * table.perm[n]);\n        }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n#region ModNumber\npublic partial struct ModInteger\n{\n    public const long Mod = (long)1e9 + 7;\n    public long num;\n    public ModInteger(long n) : this() { num = n % Mod; if (num < 0) num += Mod; }\n    public override string ToString() { return num.ToString(); }\n    public static ModInteger operator +(ModInteger l, ModInteger r) { var n = l.num + r.num; if (n >= Mod) n -= Mod; return new ModInteger() { num = n }; }\n    public static ModInteger operator -(ModInteger l, ModInteger r) { var n = l.num + Mod - r.num; if (n >= Mod) n -= Mod; return new ModInteger() { num = n }; }\n    public static ModInteger operator *(ModInteger l, ModInteger r) { return new ModInteger(l.num * r.num); }\n    public static ModInteger operator ^(ModInteger l, long r) { return ModInteger.Pow(l, r); }\n    public static implicit operator ModInteger(long n) { return new ModInteger() { num = n }; }\n    public static ModInteger Pow(ModInteger v, long k)\n    {\n        ModInteger ret = 1;\n        var n = k;\n        for (; n > 0; n >>= 1, v *= v)\n        {\n            if ((n & 1) == 1)\n                ret = ret * v;\n        }\n        return ret;\n    }\n}\n#endregion\n#region Inverse\npublic partial struct ModInteger\n{\n    static public ModInteger Inverse(ModInteger v)\n    {\n        long p, q;\n        ExGCD(v.num, Mod, out p, out q);\n        return new ModInteger(p % Mod + Mod);\n    }\n    static public long ExGCD(long a, long b, out long x, out long y)\n    {\n        var u = new long[] { a, 1, 0 };\n        var v = new long[] { b, 0, 1 };\n        while (v[0] != 0)\n        {\n            var t = u[0] / v[0];\n            for (int i = 0; i < 3; i++)\n            {\n                var tmp = u[i] - t * v[i];\n                u[i] = v[i];\n                v[i] = tmp;\n            }\n        }\n        x = u[1];\n        y = u[2];\n        if (u[0] > 0)\n            return u[0];\n        for (int i = 0; i < 3; i++)\n            u[i] = -u[i];\n        return u[0];\n    }\n}\n#endregion\n#region ModTable\npublic class ModTable\n{\n    public ModInteger[] perm, invp;\n    public ModTable(int n)\n    {\n        perm = new ModInteger[n + 1];\n        invp = new ModInteger[n + 1];\n        perm[0] = 1;\n        for (int i = 1; i <= n; i++)\n            perm[i] = perm[i - 1] * i;\n        invp[n] = ModInteger.Inverse(perm[n]);\n        for (int i = n - 1; i >= 0; i--)\n            invp[i] = invp[i + 1] * (i + 1);\n        invp[0] = invp[1];\n    }\n    public ModInteger Inverse(int k) { return invp[k]; }\n    public ModInteger Permutation(int n, int k)\n    {\n        if (n < 0 || n >= perm.Length)\n            return 0;\n        if (k < 0 || k >= n)\n            return 0;\n        return perm[n] * invp[n - k];\n    }\n    public ModInteger Combination(int n, int r)\n    {\n        if (n < 0 || n >= perm.Length || r < 0 || r > n) return 0;\n        return perm[n] * invp[n - r] * invp[r];\n    }\n    public ModInteger RepeatedCombination(int n, int k)\n    {\n        if (k == 0) return 1;\n        return Combination(n + k - 1, k);\n    }\n}\n#endregion"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar sc = bufio.NewScanner(os.Stdin)\n\nfunc nextInt() int {\n\tsc.Scan()\n\ti, e := strconv.Atoi(sc.Text())\n\tif e != nil {\n\t\tpanic(e)\n\t}\n\treturn i\n}\n\nfunc main() {\n\tsc.Split(bufio.ScanWords)\n\n\ta, b := nextInt(), nextInt()\n\tif a <= 0 && b >= 0 {\n\t\tfmt.Println(\"Zero\")\n\t\treturn\n\t}\n\n\tif a > 0 {\n\t\tfmt.Println(\"Positive\")\n\t\treturn\n\t}\n\n\tif b < 0 {\n\t\tcnt := b - a + 1\n\t\tif cnt%2 == 0 {\n\t\t\tfmt.Println(\"Positive\")\n\t\t} else {\n\t\t\tfmt.Println(\"Negative\")\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "OCaml",
    "code": "let modulo = 1000000007\n\nlet ( +% ) a b = let c = a + b in if c > modulo then c - modulo else c\nlet ( -% ) a b = if a >= b then a - b else modulo + a - b\nlet ( *% ) a b = a * b mod modulo\n\nlet pow k =\n  let rec aux accu k = function\n  | 0 -> accu\n  | n when n mod 2 = 0 -> aux accu (k *% k) (n/2)\n  | n -> aux (accu *% k) (k *% k) (n/2) in\n  aux 1 k\n\nlet inv k = pow k (modulo-2)\n\nlet n, k = Scanf.scanf \"%d %d\" (fun x y -> x, y)\n\nlet () = if k = 1 then begin print_int 1; exit 0 end\n\nlet smax = n * k\nlet factbl = Array.make (smax+1) 1\nlet ifactbl = Array.make (smax+1) 0\nlet () = for i = 1 to smax do factbl.(i) <- factbl.(i-1) *% i done;\n         ifactbl.(smax) <- inv factbl.(smax);\n         for i = smax-1 downto 0 do ifactbl.(i) <- ifactbl.(i+1) *% (i+1) done\n\nlet binom n k = factbl.(n) *% ifactbl.(k) *% ifactbl.(n-k)\n\n\nlet dp = Array.make (n+1) 0\n\nlet () = dp.(0) <- 1;\n         for i = 0 to n-1 do for j = i+1 to n do\n           dp.(j) <- dp.(j) +% dp.(j-1) *% binom (i+j*(k-1)-1) (k-2) done done;\n         print_int (factbl.(n) *% dp.(n))"
  },
  {
    "language": "Bash",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst long long MOD = (long long)(1e9 + 7);\nconst int kK = (int)(2049 * 2049);\n\nlong long fac[kK + 5], inv[kK + 5];\n\nlong long qpow(long long base,int power)\n{\n\tlong long ret = 1;\n\tfor(; power; power >>= 1)\n\t{\n\t\tif(power & 1) ret = ret * base % MOD;\n\t\tbase = base * base % MOD;\n\t}\n\treturn ret;\n}\n\ninline long long C(int x, int y)\n{\n\treturn(((fac[y] * inv[x]) % MOD) * inv[y - x]) % MOD;\n}\n\nint n, k;\nlong long f[2049][2049];\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin >> n >> k;\n\tif(k == 1)\n\t{\n\t\tcout << 1 <<endl;\n\t\treturn 0;\n\t}\n\tfac[0] = 1;\n\tfor(int i = 1; i <= kK; ++i) fac[i] = fac[i-1] * i % MOD;\n\tinv[kK] = qpow(fac[kK], MOD - 2);\n\tfor(int i = kK; i >= 1; --i) inv[i - 1] = inv[i] * i % MOD;\n\tf[0][0] = 1;\n\tfor(int i = 1;i <= n; ++i)\n\t{\n\t\tf[i][0] = f[i - 1][0];\n\t\tfor(int j = 1; j <= i; ++j)\n\t\t{\n\t\t\tf[i][j] = f[i - 1][j];\n\t\t\tf[i][j] = f[i][j] + f[i][j - 1] * C(k - 2, n * k - i - (j - 1)*(k - 1) - 1);\n\t\t\tf[i][j] %= MOD;\n\t\t}\n\t}\n\tcout << fac[n] * f[n][n] % MOD<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "Bash",
    "code": "#include<cstdio>\n#include<cstring>\nconst int N=2200;\n\n\nint b[N],n,k,num;\nlong long bb[N*N],dd[N][N],pp,ans,f[N][N],p=1000000007;\nlong long xxx;\nlong long do3(long long x){\n\tlong long s=x,t=x;\n\n\tfor(int i=2; i<=num; i++){\n\t\ts=s*s%p;\n\t\tif(b[i]==1) t=t*s%p;\n\t\t\n\t}\n\t\n\treturn t%p;\n}\n\nvoid do1(int x,int y){\n\tint mm=k-2;\n\tint nn=n*k-x-(y-1)*(k-1)-1;\n\t\n//\tprintf(\"ccc%d %d %d %d\\n\",x,y,nn,mm);\n\t\n\tlong long ans=1,a=1,b=1;\n\t\n\ta=bb[nn];\n\t//b=do3(bb[mm])*do3(bb[nn-mm])%p;\n\tb=xxx*do3(bb[nn-mm])%p;\n//\tprintf(\"ccc2  %d %I64d %I64d\\n\",nn, a,b);\n\t\n\tans=b*a%p;\n\t\n//\tprintf(\"ccc3  %I64d\\n\",ans);\n\t\n\tdd[x][y]=ans;\n\t\n}\n\nvoid do2(){\n\tlong long a=f[n][n];\n\t\n\tfor(int i=1; i<=n; i++){\n\t\ta=a*i%p;\n\t}\n\t\n\tf[n][n]=a;\n}\n\nvoid f1(int x,int y){ \n\n//\tprintf(\"11 %d %d\\n\",x,y);\n\n\tif(x==0){\n\t\tf[x][y]=1;\n\t\treturn;\n\t}\n\tif(y==0){\n\t\tf[x][y]=1;\n\t\treturn;\n\t}\n//\tprintf(\"22 %d %d\\n\",x,y);\n\t\n\tif(f[x-1][y]==-1 and x-1>=y) f1(x-1,y);\n\tif(f[x][y-1]==-1 and x>=y-1) f1(x,y-1);\n\t\n//\tprintf(\"%d %d %I64d %I64d \\n\",x, y, f[x-1][y],f[x][y-1]);\n\t\n\tf[x][y]=0;\n\tif(x-1>=y) f[x][y]=(f[x][y]+f[x-1][y])%p;\n\t\n\tif(dd[x][y]==-1) do1(x,y);\n//\tprintf(\"aaa%d %d %I64d %I64d\\n\",x, y, f[x][y-1], dd[x][y]);\n\tf[x][y]+=f[x][y-1]*dd[x][y]%p;\n\tf[x][y]=f[x][y]%p;\n//\tprintf(\"%d %d %I64d \\n\",x, y, f[x][y]);\n\treturn;\n}\n\n\n\nint main(){\n//\tfreopen(\"leftmost ball.in\",\"r\",stdin);\n//\tfreopen(\"leftmost ball.out\",\"w\",stdout);\n\n\tscanf(\"%d%d\",&n,&k);\n\t\n\tif(k==1){\n\t\tprintf(\"1\"); \n\t\treturn 0;\n\t}\n\tbb[0]=1;\n\tbb[1]=1;\n\tfor(int i=2; i<=n*k; i++){\n\t\tbb[i]=bb[i-1]*i%p;\n\t}\n\t\n\tpp=1000000005;\n\tnum=0;\n\twhile(pp>0){\n\t\tb[++num]=pp%2;\n\t\tpp=pp/2;\n\t}\n\t\n//\tfor(int i=num; i>=1; i--) printf(\"%d\",b[i]); printf(\"\\n\");\n\tmemset(dd,-1,sizeof(dd));\n\tmemset(f,-1,sizeof(f));\n\txxx=do3(bb[k-2]);\n\tf1(n,n);\n\t\n//\tfor(int i=0; i<=n; i++){\n//\t\tfor(int j=0; j<=n; j++){\n//\t\t\tprintf(\"%I64d \",dd[i][j]);\n//\t\t}printf(\"\\n\");\n//\t}\n\t\n\tdo2();\n\t\n\tf[n][n]=f[n][n]%p;\n\n\tprintf(\"%I64d\",f[n][n]);\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "Nim",
    "code": "{.optimization:speed, checks:off.}\n#{{{ header\nimport algorithm, sequtils, tables, macros, math, sets, strutils, streams\nwhen defined(MYDEBUG):\n  import header\n\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\nproc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(base:int = 0): int =\n  scanf(\"%lld\",addr result)\n  result -= base\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString(): string =\n  var get = false;result = \"\"\n  while true:\n    var c = getchar()\n    if int(c) > int(' '): get = true;result.add(c)\n    elif get: break\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate infty(T): untyped = ((T(1) shl T(sizeof(T)*8-2)) - 1)\n#}}}\n\n#{{{ gcd and inverse\nconst GCD_H = 0\n\nproc gcd(a,b:int):int=\n  if b == 0: return a\n  else: return gcd(b,a mod b)\nproc lcm(a,b:int):int=\n  return a div gcd(a, b) * b\n# a x + b y = gcd(a, b)\nproc extgcd(a,b:int, x,y:var int):int =\n  var\n    g = a\n  x = 1\n  y = 0\n  if b != 0:\n    g = extgcd(b, a mod b, y, x)\n    y -= (a div b) * x\n  return g;\n\nproc invMod(a,m:int):int =\n  var\n    x,y:int\n  if extgcd(a, m, x, y) == 1: return (x + m) mod m\n  else: return 0 # unsolvable\n#}}}\n\nlet MOD = 1000000007\n\n#{{{ Mint\ntype Mint = object\n  v:int\nproc newMint[T](a:T):Mint =\n  var a = a\n  a = a mod MOD\n  if a < 0: a += MOD\n  return Mint(v:a)\nproc newMint(a:Mint):Mint =\n  return a\nproc `+=`[T](a:var Mint, b:T):void =\n  a.v += newMint(b).v\n  if a.v >= MOD:\n    a.v -= MOD\nproc `+`[T](a:Mint,b:T):Mint =\n  var c = a\n  c += b\n  return c\nproc `*=`[T](a:var Mint,b:T):void =\n  a.v *= newMint(b).v\n  a.v = a.v mod MOD\nproc `*`[T](a:Mint,b:T):Mint =\n  var c = a\n  c *= b\n  return c\nproc `-`(a:Mint):Mint =\n  if a.v == 0: return a\n  else: return Mint(v:MOD - a.v)\nproc `-=`[T](a:var Mint,b:T):void =\n  a.v -= newMint(b).v\n  if a.v < 0:\n    a.v += MOD\nproc `-`[T](a:Mint,b:T):Mint =\n  var c = a\n  c -= b\n  return c\nproc `$`(a:Mint):string =\n  return $(a.v)\nwhen declared(GCD_H):\n  proc `/=`[T](a:var Mint,b:T):void =\n    a.v *= invMod(newMint(b).v,MOD)\n    a.v = a.v mod MOD\n  proc `/`[T](a:Mint,b:T):Mint =\n    var c = a\n    c /= b\n    return c\n#}}}\n\n\n#{{{ fact, comb, perm\nvar\n  factorial_val = @[newMint(1)]\n  inv_factorial_val = @[newMint(1)]\n  comb_val = @[@[newMint(1)]]\n\nproc fact(n:int):Mint =\n  for i in len(factorial_val)..n:\n    factorial_val.add(factorial_val[i-1] * i)\n  return factorial_val[n]\nproc inv_fact(n:int):Mint =\n  for i in len(inv_factorial_val)..n:\n    inv_factorial_val.add(newMint(1)/fact(i))\n  return inv_factorial_val[n]\n\nproc comb_memo(n,r:int):Mint =\n  if n<0 or r<0 or n<r:\n    return newMint(0)\n  while comb_val.len < n + 1:\n    var t = comb_val.len\n    comb_val.add(newSeqWith(t + 1, newMint(0)))\n    comb_val[t][0] = newMint(1)\n    comb_val[t][t] = newMint(1)\n    for i in 1..t-1:\n      comb_val[t][i] = comb_val[t-1][i-1] + comb_val[t-1][i]\n  return comb_val[n][r]\n\nwhen declared(GCD_H):\n  proc comb(n,r:int):Mint =\n    if n<0 or r<0 or n<r:\n      return newMint(0)\n    else:\n#      return fact(n)/(fact(r)*fact(n-r))\n      return fact(n)*inv_fact(r)*inv_fact(n-r)\n  proc perm(n,r:int):Mint =\n    if n<0 or n<r:\n      return newMint(0)\n    else:\n      return fact(n)/fact(n-r)\n#}}}\n\n\n\nproc solve(N:int, K:int) =\n  if K == 1:\n    echo 1\n    return\n  var dp = newSeqWith(2010,newSeqWith(2010,newMint(0)))\n  dp[0][0] = newMint(1)\n  let K1 = K - 1\n  for a in 0..N:\n    var d = N * K - a - 1\n    for b in 0..a:\n      # zero\n      dp[a+1][b] += dp[a][b]\n      # non-zero\n#      if b < N: dp[a][b+1] += dp[a][b] * comb(N*K - a - (K - 1) * b - 1,K - 2) * (N - b)\n      dp[a][b+1] += dp[a][b] * comb(d,K - 2) * (N - b)\n      d -= K1\n  echo dp[N][N]\n  return\n\n#{{{ main function\nproc main() =\n  var N = 0\n  N = nextInt()\n  var K = 0\n  K = nextInt()\n  solve(N, K);\n  return\n\nmain()\n#}}}"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\nimport algorithm, sequtils, tables, macros, math, sets, strutils, streams\nwhen defined(MYDEBUG):\n  import header\n\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\nproc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(base:int = 0): int =\n  scanf(\"%lld\",addr result)\n  result -= base\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString(): string =\n  var get = false;result = \"\"\n  while true:\n    var c = getchar()\n    if int(c) > int(' '): get = true;result.add(c)\n    elif get: break\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate infty(T): untyped = ((T(1) shl T(sizeof(T)*8-2)) - 1)\n#}}}\n\n#{{{ gcd and inverse\nconst GCD_H = 0\n\nproc gcd(a,b:int):int=\n  if b == 0: return a\n  else: return gcd(b,a mod b)\nproc lcm(a,b:int):int=\n  return a div gcd(a, b) * b\n# a x + b y = gcd(a, b)\nproc extgcd(a,b:int, x,y:var int):int =\n  var\n    g = a\n  x = 1\n  y = 0\n  if b != 0:\n    g = extgcd(b, a mod b, y, x)\n    y -= (a div b) * x\n  return g;\n\nproc invMod(a,m:int):int =\n  var\n    x,y:int\n  if extgcd(a, m, x, y) == 1: return (x + m) mod m\n  else: return 0 # unsolvable\n#}}}\n\nlet MOD = 1000000007\n\n#{{{ Mint\ntype Mint = object\n  v:int\nproc newMint[T](a:T):Mint =\n  var a = a\n  a = a mod MOD\n  if a < 0: a += MOD\n  return Mint(v:a)\nproc newMint(a:Mint):Mint =\n  return a\nproc `+=`[T](a:var Mint, b:T):void =\n  a.v += newMint(b).v\n  if a.v >= MOD:\n    a.v -= MOD\nproc `+`[T](a:Mint,b:T):Mint =\n  var c = a\n  c += b\n  return c\nproc `*=`[T](a:var Mint,b:T):void =\n  a.v *= newMint(b).v\n  a.v = a.v mod MOD\nproc `*`[T](a:Mint,b:T):Mint =\n  var c = a\n  c *= b\n  return c\nproc `-`(a:Mint):Mint =\n  if a.v == 0: return a\n  else: return Mint(v:MOD - a.v)\nproc `-=`[T](a:var Mint,b:T):void =\n  a.v -= newMint(b).v\n  if a.v < 0:\n    a.v += MOD\nproc `-`[T](a:Mint,b:T):Mint =\n  var c = a\n  c -= b\n  return c\nproc `$`(a:Mint):string =\n  return $(a.v)\nwhen declared(GCD_H):\n  proc `/=`[T](a:var Mint,b:T):void =\n    a.v *= invMod(newMint(b).v,MOD)\n    a.v = a.v mod MOD\n  proc `/`[T](a:Mint,b:T):Mint =\n    var c = a\n    c /= b\n    return c\n#}}}\n\n\n#{{{ fact, comb, perm\nvar\n  factorial_val = @[newMint(1)]\n  inv_factorial_val = @[newMint(1)]\n  comb_val = @[@[newMint(1)]]\n\nproc fact(n:int):Mint =\n  for i in len(factorial_val)..n:\n    factorial_val.add(factorial_val[i-1] * i)\n  return factorial_val[n]\nproc inv_fact(n:int):Mint =\n  for i in len(inv_factorial_val)..n:\n    inv_factorial_val.add(newMint(1)/fact(i))\n  return inv_factorial_val[n]\n\nproc comb_memo(n,r:int):Mint =\n  if n<0 or r<0 or n<r:\n    return newMint(0)\n  while comb_val.len < n + 1:\n    var t = comb_val.len\n    comb_val.add(newSeqWith(t + 1, newMint(0)))\n    comb_val[t][0] = newMint(1)\n    comb_val[t][t] = newMint(1)\n    for i in 1..t-1:\n      comb_val[t][i] = comb_val[t-1][i-1] + comb_val[t-1][i]\n  return comb_val[n][r]\n\nwhen declared(GCD_H):\n  proc comb(n,r:int):Mint =\n    if n<0 or r<0 or n<r:\n      return newMint(0)\n    else:\n#      return fact(n)/(fact(r)*fact(n-r))\n      return fact(n)*inv_fact(r)*inv_fact(n-r)\n  proc perm(n,r:int):Mint =\n    if n<0 or n<r:\n      return newMint(0)\n    else:\n      return fact(n)/fact(n-r)\n#}}}\n\n\n\nproc solve(N:int, K:int) =\n  if K == 1:\n    echo 1\n    return\n  var dp = newSeqWith(2010,newSeqWith(2010,newMint(0)))\n  dp[0][0] = newMint(1)\n  let K1 = K - 1\n  for a in 0..N:\n    var d = N * K - a - 1\n    for b in 0..N:\n      if a < b: continue\n      # zero\n      if a < N: dp[a+1][b] += dp[a][b]\n      # non-zero\n#      if b < N: dp[a][b+1] += dp[a][b] * comb(N*K - a - (K - 1) * b - 1,K - 2) * (N - b)\n      if b < N: dp[a][b+1] += dp[a][b] * comb(d,K - 2) * (N - b)\n      d -= K1\n  echo dp[N][N]\n  return\n\n#{{{ main function\nproc main() =\n  var N = 0\n  N = nextInt()\n  var K = 0\n  K = nextInt()\n  solve(N, K);\n  return\n\nmain()\n#}}}"
  },
  {
    "language": "Nim",
    "code": "{.optimization:speed, checks:off.}\n#{{{ header\nimport algorithm, sequtils, tables, macros, math, sets, strutils, streams\nwhen defined(MYDEBUG):\n  import header\n\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\nproc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(base:int = 0): int =\n  scanf(\"%lld\",addr result)\n  result -= base\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString(): string =\n  var get = false;result = \"\"\n  while true:\n    var c = getchar()\n    if int(c) > int(' '): get = true;result.add(c)\n    elif get: break\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate infty(T): untyped = ((T(1) shl T(sizeof(T)*8-2)) - 1)\n#}}}\n\n#{{{ gcd and inverse\nconst GCD_H = 0\n\nproc gcd(a,b:int):int=\n  if b == 0: return a\n  else: return gcd(b,a mod b)\nproc lcm(a,b:int):int=\n  return a div gcd(a, b) * b\n# a x + b y = gcd(a, b)\nproc extgcd(a,b:int, x,y:var int):int =\n  var\n    g = a\n  x = 1\n  y = 0\n  if b != 0:\n    g = extgcd(b, a mod b, y, x)\n    y -= (a div b) * x\n  return g;\n\nproc invMod(a,m:int):int =\n  var\n    x,y:int\n  if extgcd(a, m, x, y) == 1: return (x + m) mod m\n  else: return 0 # unsolvable\n#}}}\n\nlet MOD = 1000000007\n\n#{{{ Mint\ntype Mint = object\n  v:int\nproc newMint[T](a:T):Mint =\n  var a = a\n  a = a mod MOD\n  if a < 0: a += MOD\n  return Mint(v:a)\nproc newMint(a:Mint):Mint =\n  return a\nproc `+=`[T](a:var Mint, b:T):void =\n  a.v += newMint(b).v\n  if a.v >= MOD:\n    a.v -= MOD\nproc `+`[T](a:Mint,b:T):Mint =\n  var c = a\n  c += b\n  return c\nproc `*=`[T](a:var Mint,b:T):void =\n  a.v *= newMint(b).v\n  a.v = a.v mod MOD\nproc `*`[T](a:Mint,b:T):Mint =\n  var c = a\n  c *= b\n  return c\nproc `-`(a:Mint):Mint =\n  if a.v == 0: return a\n  else: return Mint(v:MOD - a.v)\nproc `-=`[T](a:var Mint,b:T):void =\n  a.v -= newMint(b).v\n  if a.v < 0:\n    a.v += MOD\nproc `-`[T](a:Mint,b:T):Mint =\n  var c = a\n  c -= b\n  return c\nproc `$`(a:Mint):string =\n  return $(a.v)\nwhen declared(GCD_H):\n  proc `/=`[T](a:var Mint,b:T):void =\n    a.v *= invMod(newMint(b).v,MOD)\n    a.v = a.v mod MOD\n  proc `/`[T](a:Mint,b:T):Mint =\n    var c = a\n    c /= b\n    return c\n#}}}\n\n\n#{{{ fact, comb, perm\nvar\n  factorial_val = @[newMint(1)]\n  inv_factorial_val = @[newMint(1)]\n  comb_val = @[@[newMint(1)]]\n\nproc fact(n:int):Mint =\n  for i in len(factorial_val)..n:\n    factorial_val.add(factorial_val[i-1] * i)\n  return factorial_val[n]\nproc inv_fact(n:int):Mint =\n  for i in len(inv_factorial_val)..n:\n    inv_factorial_val.add(newMint(1)/fact(i))\n  return inv_factorial_val[n]\n\nproc comb_memo(n,r:int):Mint =\n  if n<0 or r<0 or n<r:\n    return newMint(0)\n  while comb_val.len < n + 1:\n    var t = comb_val.len\n    comb_val.add(newSeqWith(t + 1, newMint(0)))\n    comb_val[t][0] = newMint(1)\n    comb_val[t][t] = newMint(1)\n    for i in 1..t-1:\n      comb_val[t][i] = comb_val[t-1][i-1] + comb_val[t-1][i]\n  return comb_val[n][r]\n\nwhen declared(GCD_H):\n  proc comb(n,r:int):Mint =\n    if n<0 or r<0 or n<r:\n      return newMint(0)\n    else:\n#      return fact(n)/(fact(r)*fact(n-r))\n      return fact(n)*inv_fact(r)*inv_fact(n-r)\n  proc perm(n,r:int):Mint =\n    if n<0 or n<r:\n      return newMint(0)\n    else:\n      return fact(n)/fact(n-r)\n#}}}\n\n\n\nproc solve(N:int, K:int) =\n  if K == 1:\n    echo 1\n    return\n  var dp = newSeqWith(2010,newSeqWith(2010,newMint(0)))\n  dp[0][0] = newMint(1)\n  let K1 = K - 1\n  for a in 0..N:\n    var d = N * K - a - 1\n    for b in 0..a:\n      if a < b: continue\n      # zero\n      dp[a+1][b] += dp[a][b]\n      # non-zero\n#      if b < N: dp[a][b+1] += dp[a][b] * comb(N*K - a - (K - 1) * b - 1,K - 2) * (N - b)\n      dp[a][b+1] += dp[a][b] * comb(d,K - 2) * (N - b)\n      d -= K1\n  echo dp[N][N]\n  return\n\n#{{{ main function\nproc main() =\n  var N = 0\n  N = nextInt()\n  var K = 0\n  K = nextInt()\n  solve(N, K);\n  return\n\nmain()\n#}}}"
  },
  {
    "language": "Nim",
    "code": "{.optimization:speed, checks:off.}\n#{{{ header\nimport algorithm, sequtils, tables, macros, math, sets, strutils, streams\nwhen defined(MYDEBUG):\n  import header\n\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\nproc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(base:int = 0): int =\n  scanf(\"%lld\",addr result)\n  result -= base\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString(): string =\n  var get = false;result = \"\"\n  while true:\n    var c = getchar()\n    if int(c) > int(' '): get = true;result.add(c)\n    elif get: break\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate infty(T): untyped = ((T(1) shl T(sizeof(T)*8-2)) - 1)\n#}}}\n\n#{{{ gcd and inverse\nconst GCD_H = 0\n\nproc gcd(a,b:int):int=\n  if b == 0: return a\n  else: return gcd(b,a mod b)\nproc lcm(a,b:int):int=\n  return a div gcd(a, b) * b\n# a x + b y = gcd(a, b)\nproc extgcd(a,b:int, x,y:var int):int =\n  var\n    g = a\n  x = 1\n  y = 0\n  if b != 0:\n    g = extgcd(b, a mod b, y, x)\n    y -= (a div b) * x\n  return g;\n\nproc invMod(a,m:int):int =\n  var\n    x,y:int\n  if extgcd(a, m, x, y) == 1: return (x + m) mod m\n  else: return 0 # unsolvable\n#}}}\n\nlet MOD = 1000000007\n\n#{{{ Mint\ntype Mint = object\n  v:int\nproc newMint[T](a:T):Mint =\n  var a = a\n  a = a mod MOD\n  if a < 0: a += MOD\n  return Mint(v:a)\nproc newMint(a:Mint):Mint =\n  return a\nproc `+=`[T](a:var Mint, b:T):void =\n  a.v += newMint(b).v\n  if a.v >= MOD:\n    a.v -= MOD\nproc `+`[T](a:Mint,b:T):Mint =\n  var c = a\n  c += b\n  return c\nproc `*=`[T](a:var Mint,b:T):void =\n  a.v *= newMint(b).v\n  a.v = a.v mod MOD\nproc `*`[T](a:Mint,b:T):Mint =\n  var c = a\n  c *= b\n  return c\nproc `-`(a:Mint):Mint =\n  if a.v == 0: return a\n  else: return Mint(v:MOD - a.v)\nproc `-=`[T](a:var Mint,b:T):void =\n  a.v -= newMint(b).v\n  if a.v < 0:\n    a.v += MOD\nproc `-`[T](a:Mint,b:T):Mint =\n  var c = a\n  c -= b\n  return c\nproc `$`(a:Mint):string =\n  return $(a.v)\nwhen declared(GCD_H):\n  proc `/=`[T](a:var Mint,b:T):void =\n    a.v *= invMod(newMint(b).v,MOD)\n    a.v = a.v mod MOD\n  proc `/`[T](a:Mint,b:T):Mint =\n    var c = a\n    c /= b\n    return c\n#}}}\n\n\n#{{{ fact, comb, perm\nvar\n  factorial_val = @[newMint(1)]\n  inv_factorial_val = @[newMint(1)]\n  comb_val = @[@[newMint(1)]]\n\nproc fact(n:int):Mint =\n  for i in len(factorial_val)..n:\n    factorial_val.add(factorial_val[i-1] * i)\n  return factorial_val[n]\nproc inv_fact(n:int):Mint =\n  for i in len(inv_factorial_val)..n:\n    inv_factorial_val.add(newMint(1)/fact(i))\n  return inv_factorial_val[n]\n\nproc comb_memo(n,r:int):Mint =\n  if n<0 or r<0 or n<r:\n    return newMint(0)\n  while comb_val.len < n + 1:\n    var t = comb_val.len\n    comb_val.add(newSeqWith(t + 1, newMint(0)))\n    comb_val[t][0] = newMint(1)\n    comb_val[t][t] = newMint(1)\n    for i in 1..t-1:\n      comb_val[t][i] = comb_val[t-1][i-1] + comb_val[t-1][i]\n  return comb_val[n][r]\n\nwhen declared(GCD_H):\n  proc comb(n,r:int):Mint =\n    if n<0 or r<0 or n<r:\n      return newMint(0)\n    else:\n#      return fact(n)/(fact(r)*fact(n-r))\n      return fact(n)*inv_fact(r)*inv_fact(n-r)\n  proc perm(n,r:int):Mint =\n    if n<0 or n<r:\n      return newMint(0)\n    else:\n      return fact(n)/fact(n-r)\n#}}}\n\n\n\nproc solve(N:int, K:int) =\n  if K == 1:\n    echo 1\n    return\n  var dp = newSeqWith(2010,newSeqWith(2010,newMint(0)))\n  dp[0][0] = newMint(1)\n  let K1 = K - 1\n  for a in 0..N:\n    var d = N * K - a - 1\n    for b in 0..N:\n      if a < b: continue\n      # zero\n      dp[a+1][b] += dp[a][b]\n      # non-zero\n#      if b < N: dp[a][b+1] += dp[a][b] * comb(N*K - a - (K - 1) * b - 1,K - 2) * (N - b)\n      dp[a][b+1] += dp[a][b] * comb(d,K - 2) * (N - b)\n      d -= K1\n  echo dp[N][N]\n  return\n\n#{{{ main function\nproc main() =\n  var N = 0\n  N = nextInt()\n  var K = 0\n  K = nextInt()\n  solve(N, K);\n  return\n\nmain()\n#}}}"
  },
  {
    "language": "Nim",
    "code": "{.optimization:speed, checks:off.}\n#{{{ header\nimport algorithm, sequtils, tables, macros, math, sets, strutils, streams, strformat\nwhen defined(MYDEBUG):\n  import header\n\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\nproc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(base:int = 0): int =\n  scanf(\"%lld\",addr result)\n  result -= base\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString(): string =\n  var get = false;result = \"\"\n  while true:\n    var c = getchar()\n    if int(c) > int(' '): get = true;result.add(c)\n    elif get: break\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate infty(T): untyped = ((T(1) shl T(sizeof(T)*8-2)) - 1)\n#}}}\n\n#{{{ gcd and inverse\nconst GCD_H = 0\n\nproc gcd(a,b:int):int=\n  if b == 0: return a\n  else: return gcd(b,a mod b)\nproc lcm(a,b:int):int=\n  return a div gcd(a, b) * b\n# a x + b y = gcd(a, b)\nproc extgcd(a,b:int, x,y:var int):int =\n  var\n    g = a\n  x = 1\n  y = 0\n  if b != 0:\n    g = extgcd(b, a mod b, y, x)\n    y -= (a div b) * x\n  return g;\n\nproc invMod(a,m:int):int =\n  var\n    x,y:int\n  if extgcd(a, m, x, y) == 1: return (x + m) mod m\n  else: return 0 # unsolvable\n#}}}\n\nconst Mod = 1000000007\n\n# ModInt {{{\n# ModInt[Mod] {{{\ntype ModInt[Mod: static[int]] = object\n  v:int32\n\nproc initModInt(a:SomeInteger, Mod:static[int]):ModInt[Mod] =\n  var a = a.int\n  a = a mod Mod\n  if a < 0: a += Mod\n  result.v = a.int32\n\nproc getMod[Mod:static[int]](self: ModInt[Mod]):static int32 = self.Mod\nproc getMod[Mod:static[int]](self: typedesc[ModInt[Mod]]):static int32 = self.Mod\n\nmacro declareModInt(Mod:static[int], t: untyped):untyped =\n  var strBody = \"\"\n  strBody &= fmt\"\"\"\ntype {t.repr} = ModInt[{Mod.repr}]\nconverter to{t.repr}(a:SomeInteger):{t.repr} = initModInt(a, {Mod.repr})\nproc init{t.repr}(a:SomeInteger):{t.repr} = initModInt(a, {Mod.repr})\nproc `$`(a:{t.repr}):string = $(a.v)\n\"\"\"\n  parseStmt(strBody)\n\nwhen declared(Mod): declareModInt(Mod, Mint)\n##}}}\n\n# DynamicModInt {{{\ntype DMint = object\n  v:int32\n\nproc setModSub(self:typedesc[not ModInt], m:int = -1, update = false):int32 =\n  {.noSideEffect.}:\n    var DMOD {.global.}:int32\n    if update: DMOD = m.int32\n    return DMOD\n\nproc fastMod(a:int,m:uint32):uint32{.inline.} =\n  var\n    minus = false\n    a = a\n  if a < 0:\n    minus = true\n    a = -a\n  elif a < m.int:\n    return a.uint32\n  var\n    xh = (a shr 32).uint32\n    xl = a.uint32\n    d:uint32\n  asm \"\"\"\n    \"divl %4; \\n\\t\"\n    : \"=a\" (`d`), \"=d\" (`result`)\n    : \"d\" (`xh`), \"a\" (`xl`), \"r\" (`m`)\n  \"\"\"\n  if minus and result > 0'u32: result = m - result\nproc initDMint(a:SomeInteger, Mod:int):DMint = result.v = fastMod(a.int, Mod.uint32).int32\n\nproc getMod[T:not ModInt](self: T):int32 = T.type.setModSub()\nproc getMod(self: typedesc[not ModInt]):int32 = self.setModSub()\nproc setMod(self: typedesc[not ModInt], m:int) = discard self.setModSub(m, update = true)\n#}}}\n\n# Operations {{{\ntype ModIntC = concept x, type T\n  x.v\n#  x.v is int32\n#  x.getMod() is int32\n#  when T isnot ModInt: setMod(T, int)\ntype SomeIntC = concept x\n  x is SomeInteger or x is ModIntC\n\nproc Identity(self:ModIntC):auto = result = self;result.v = 1\nproc init[Mod:static[int]](self:ModInt[Mod], a:SomeIntC):ModInt[Mod] =\n  when a is SomeInteger: initModInt(a, Mod)\n  else: a\nproc init(self:ModIntC and not ModInt, a:SomeIntC):auto =\n  when a is SomeInteger:\n    var r = self.type.default\n    r.v = fastMod(a.int, self.getMod().uint32).int32\n    r\n  else: a\n\nmacro declareDMintConverter(t:untyped) =\n  parseStmt(fmt\"\"\"\nconverter to{t.repr}(a:SomeInteger):{t.repr} =\n  let Mod = {t.repr}.getMod()\n  if Mod > 0:\n    result.v = fastMod(a.int, Mod.uint32).int32\n  else:\n    result.v = a.int32\n  return result\n\"\"\")\n\ndeclareDMintConverter(DMint)\n\nmacro declareDMint(t:untyped) =\n  parseStmt(fmt\"\"\"\ntype {t.repr} {{.borrow: `.`.}} = distinct DMint\ndeclareDMintConverter({t.repr})\n\"\"\")\n\nproc `*=`(self:var ModIntC, a:SomeIntC) =\n  when self is ModInt:\n    self.v = (self.v.int * self.init(a).v.int mod self.getMod().int).int32\n  else:\n    self.v = fastMod(self.v.int * self.init(a).v.int, self.getMod().uint32).int32\nproc `==`(a:ModIntC, b:SomeIntC):bool = a.v == a.init(b).v\nproc `!=`(a:ModIntC, b:SomeIntC):bool = a.v != a.init(b).v\nproc `-`(self:ModIntC):auto =\n  if self.v == 0: return self\n  else: return self.init(self.getMod() - self.v)\nproc `$`(a:ModIntC):string = return $(a.v)\n\nproc `+=`(self:var ModIntC; a:SomeIntC) =\n  self.v += self.init(a).v\n  if self.v >= self.getMod(): self.v -= self.getMod()\nproc `-=`(self:var ModIntC, a:SomeIntC) =\n  self.v -= self.init(a).v\n  if self.v < 0: self.v += self.getMod()\nproc `^=`(self:var ModIntC, n:SomeInteger) =\n  var (x,n,a) = (self,n,self.Identity)\n  while n > 0:\n    if (n and 1) > 0: a *= x\n    x *= x\n    n = (n shr 1)\n  swap(self, a)\nproc inverse(self: ModIntC):auto =\n  var\n    a = self.v.int\n    b = self.getMod().int\n    u = 1\n    v = 0\n  while b > 0:\n    let t = a div b\n    a -= t * b;swap(a, b)\n    u -= t * v;swap(u, v)\n  return self.init(u)\nproc `/=`(a:var ModIntC,b:SomeIntC) = a *= a.init(b).inverse()\nproc `+`(a:ModIntC,b:SomeIntC):auto = result = a;result += b\nproc `-`(a:ModIntC,b:SomeIntC):auto = result = a;result -= b\nproc `*`(a:ModIntC,b:SomeIntC):auto = result = a;result *= b\nproc `/`(a:ModIntC,b:SomeIntC):auto = result = a;result /= b\nproc `^`(a:ModIntC,b:SomeInteger):auto = result = a;result ^= b\n# }}}\n# }}}\n\n# combination {{{\nimport sequtils\n\n#proc `/`(a, b:int):int = a div b\n\ntype IntC = concept x\n  x + x\n  x - x\n  x * x\n  x / x\n\ntype Combination[T] = object\n  fact_a, rfact_a: seq[T]\n\ntype CombinationC = concept x\n  x is typedesc[IntC] or x is var Combination\n\nproc getVal[T:IntC](cmb: var Combination[T], t:static[int], k:int):auto {.discardable.} =\n  if k >= cmb.fact_a.len:\n    if cmb.fact_a.len == 0:\n      cmb.fact_a = @[T(1)]\n      cmb.rfact_a = @[T(1)]\n    let sz_old = cmb.fact_a.len - 1\n    let sz = max(sz_old * 2, k)\n    cmb.fact_a.setlen(sz + 1)\n    cmb.rfact_a.setlen(sz + 1)\n    for i in sz_old + 1..sz: cmb.fact_a[i] = cmb.fact_a[i-1] * T(i)\n    cmb.rfact_a[sz] = T(1) / cmb.fact_a[sz]\n    for i in countdown(sz - 1, sz_old + 1): cmb.rfact_a[i] = cmb.rfact_a[i + 1] * T(i + 1)\n  when t == 0: return cmb.fact_a[k]\n  elif t == 1: return cmb.rfact_a[k]\n  elif t == 2: # reset\n    cmb.fact_a.setLen(0)\n    cmb.rfact_a.setLen(0)\n    return T(0)\ntemplate resetCombination(T:typedesc[IntC] or var Combination) = T.getVal(2, 0)\n\nproc getVal(T:typedesc[IntC], t:static[int], k:int):auto {.discardable.} =\n  var cmb{.global.} = Combination[T]()\n  return cmb.getVal(t, k)\n\ntemplate zero(T:typedesc[IntC]):T = T(0)\ntemplate zero[T](cmb:Combination[T]):T = T(0)\n\ntemplate fact(T:CombinationC, k:int):auto = T.getVal(0, k)\ntemplate rfact(T:CombinationC, k:int):auto = T.getVal(1, k)\ntemplate inv(T:CombinationC, k:int):auto = T.fact_a(k - 1) * T.rfact(k)\n\ntemplate P(T:CombinationC, n,r:int):auto =\n  if r < 0 or n < r: T.zero()\n  else: T.fact(n) * T.rfact(n - r)\ntemplate C(T:CombinationC, n,r:int):auto =\n  if r < 0 or n < r: T(0)\n  else: T.fact(n) * T.rfact(r) * T.rfact(n - r)\ntemplate H(T:CombinationC, n,r:int):auto =\n  if n < 0 or r < 0: T(0)\n  elif r == 0: T(1)\n  else: T.C(n + r - 1, r)\n# }}}\n\nvar dp:array[2010, array[2010, Mint]]\n\nproc solve(N:int, K:int) =\n  if K == 1:\n    echo 1\n    return\n  dp[0][0] = Mint(1)\n  let K1 = K - 1\n  for a in 0..N:\n    var d = N * K - a - 1\n    for b in 0..a:\n      # zero\n      dp[a+1][b] += dp[a][b]\n      # non-zero\n#      if b < N: dp[a][b+1] += dp[a][b] * comb(N*K - a - (K - 1) * b - 1,K - 2) * (N - b)\n      dp[a][b+1] += dp[a][b] * Mint.C(d,K - 2) * (N - b)\n      d -= K1\n  echo dp[N][N]\n  return\n\n#{{{ main function\nproc main() =\n  var N = 0\n  N = nextInt()\n  var K = 0\n  K = nextInt()\n  solve(N, K);\n  return\n\nmain()\n#}}}"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\nimport algorithm, sequtils, tables, macros, math, sets, strutils, streams\nwhen defined(MYDEBUG):\n  import header\n\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\nproc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(base:int = 0): int =\n  scanf(\"%lld\",addr result)\n  result -= base\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString(): string =\n  var get = false;result = \"\"\n  while true:\n    var c = getchar()\n    if int(c) > int(' '): get = true;result.add(c)\n    elif get: break\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate infty(T): untyped = ((T(1) shl T(sizeof(T)*8-2)) - 1)\n#}}}\n\n#{{{ gcd and inverse\nconst GCD_H = 0\n\nproc gcd(a,b:int):int=\n  if b == 0: return a\n  else: return gcd(b,a mod b)\nproc lcm(a,b:int):int=\n  return a div gcd(a, b) * b\n# a x + b y = gcd(a, b)\nproc extgcd(a,b:int, x,y:var int):int =\n  var\n    g = a\n  x = 1\n  y = 0\n  if b != 0:\n    g = extgcd(b, a mod b, y, x)\n    y -= (a div b) * x\n  return g;\n\nproc invMod(a,m:int):int =\n  var\n    x,y:int\n  if extgcd(a, m, x, y) == 1: return (x + m) mod m\n  else: return 0 # unsolvable\n#}}}\n\nlet MOD = 1000000007\n\n#{{{ Mint\ntype Mint = object\n  v:int\nproc newMint[T](a:T):Mint =\n  var a = a\n  a = a mod MOD\n  if a < 0: a += MOD\n  return Mint(v:a)\nproc newMint(a:Mint):Mint =\n  return a\nproc `+=`[T](a:var Mint, b:T):void =\n  a.v += newMint(b).v\n  if a.v >= MOD:\n    a.v -= MOD\nproc `+`[T](a:Mint,b:T):Mint =\n  var c = a\n  c += b\n  return c\nproc `*=`[T](a:var Mint,b:T):void =\n  a.v *= newMint(b).v\n  a.v = a.v mod MOD\nproc `*`[T](a:Mint,b:T):Mint =\n  var c = a\n  c *= b\n  return c\nproc `-`(a:Mint):Mint =\n  if a.v == 0: return a\n  else: return Mint(v:MOD - a.v)\nproc `-=`[T](a:var Mint,b:T):void =\n  a.v -= newMint(b).v\n  if a.v < 0:\n    a.v += MOD\nproc `-`[T](a:Mint,b:T):Mint =\n  var c = a\n  c -= b\n  return c\nproc `$`(a:Mint):string =\n  return $(a.v)\nwhen declared(GCD_H):\n  proc `/=`[T](a:var Mint,b:T):void =\n    a.v *= invMod(newMint(b).v,MOD)\n    a.v = a.v mod MOD\n  proc `/`[T](a:Mint,b:T):Mint =\n    var c = a\n    c /= b\n    return c\n#}}}\n\n\n#{{{ fact, comb, perm\nvar\n  factorial_val = @[newMint(1)]\n  inv_factorial_val = @[newMint(1)]\n  comb_val = @[@[newMint(1)]]\n\nproc fact(n:int):Mint =\n  for i in len(factorial_val)..n:\n    factorial_val.add(factorial_val[i-1] * i)\n  return factorial_val[n]\nproc inv_fact(n:int):Mint =\n  for i in len(inv_factorial_val)..n:\n    inv_factorial_val.add(newMint(1)/fact(i))\n  return inv_factorial_val[n]\n\nproc comb_memo(n,r:int):Mint =\n  if n<0 or r<0 or n<r:\n    return newMint(0)\n  while comb_val.len < n + 1:\n    var t = comb_val.len\n    comb_val.add(newSeqWith(t + 1, newMint(0)))\n    comb_val[t][0] = newMint(1)\n    comb_val[t][t] = newMint(1)\n    for i in 1..t-1:\n      comb_val[t][i] = comb_val[t-1][i-1] + comb_val[t-1][i]\n  return comb_val[n][r]\n\nwhen declared(GCD_H):\n  proc comb(n,r:int):Mint =\n    if n<0 or r<0 or n<r:\n      return newMint(0)\n    else:\n#      return fact(n)/(fact(r)*fact(n-r))\n      return fact(n)*inv_fact(r)*inv_fact(n-r)\n  proc perm(n,r:int):Mint =\n    if n<0 or n<r:\n      return newMint(0)\n    else:\n      return fact(n)/fact(n-r)\n#}}}\n\n\n\nproc solve(N:int, K:int) =\n  if K == 1:\n    echo 1\n    return\n  var dp = newSeqWith(2010,newSeqWith(2010,newMint(0)))\n  dp[0][0] = newMint(1)\n  for a in 0..N:\n    for b in 0..N:\n      if a < b: continue\n      # zero\n      if a < N: dp[a+1][b] += dp[a][b]\n      # non-zero\n      if b < N: dp[a][b+1] += dp[a][b] * comb(N*K - a - (K - 1) * b - 1,K - 2) * (N - b)\n  echo dp[N][N]\n  return\n\n#{{{ main function\nproc main() =\n  var N = 0\n  N = nextInt()\n  var K = 0\n  K = nextInt()\n  solve(N, K);\n  return\n\nmain()\n#}}}"
  },
  {
    "language": "Python",
    "code": "def cmb(n, r, mod):#コンビネーションの高速計算　\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7 #出力の制限\nN = 4*10**6\ng1 = [1, 1] # 元テーブル\ng2 = [1, 1] #逆元テーブル\ninverse = [0, 1] #逆元テーブル計算用テーブル\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nN,K=map(int,input().split())\n\nif K==1:\n    print(1)\n    exit()\n\ndp=[0 for i in range(N+1)]\ndp[N]=1\n\nfor i in range(N,-1,-1):\n    for j in range(i-1,-1,-1):\n        n=(N-(j+1))*(K-1)+N-i\n        dp[j]+=(cmb(n+K-2,K-2,mod)*dp[j+1])%mod\n        dp[j]%=mod\n\nprint((dp[0]*g1[N])%mod)\n"
  },
  {
    "language": "Python",
    "code": "def cmb(n, r, mod):#コンビネーションの高速計算　\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7 #出力の制限\nN = 4*10**6\ng1 = [1, 1] # 元テーブル\ng2 = [1, 1] #逆元テーブル\ninverse = [0, 1] #逆元テーブル計算用テーブル\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nN,K=map(int,input().split())\n\nif K==1:\n    print(1)\n    exit()\n\ndp=[[0 for i in range(N+1)] for j in range(N+1)]\ndp[N][N]=1\n\nfor i in range(N,-1,-1):\n    for j in range(N,-1,-1):\n        if i!=N:\n            dp[i][j]+=dp[i+1][j]\n        if j!=N and i>j:\n            n=(N-(j+1))*(K-1)+N-i\n            dp[i][j]+=cmb(n+K-2,K-2,mod)*dp[i][j+1]\n        dp[i][j]%=mod\n\nprint((dp[0][0]*g1[N])%mod)\n"
  },
  {
    "language": "Python",
    "code": "print(1)"
  },
  {
    "language": "Python",
    "code": "def cmb(n, r, mod):#コンビネーションの高速計算　\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return (g1[n] * g2[r])%mod * g2[n-r] % mod\n\nmod = 10**9+7 #出力の制限\nN = 4*10**6\ng1 = [1]*(N+1) # 元テーブル\ng2 = [1]*(N+1) #逆元テーブル\ninverse = [1]*(N+1) #逆元テーブル計算用テーブル\n\nfor i in range( 2, N + 1 ):\n    g1[i]=( ( g1[i-1] * i ) % mod )\n    inverse[i]=( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2[i]=( (g2[i-1] * inverse[i]) % mod )\n\nN,K=map(int,input().split())\n\nif K==1:\n    print(1)\n    exit()\n\ndp=[0 for i in range(N+1)]\ndp[N]=1\n\nfor i in range(N,-1,-1):\n    for j in range(i-1,-1,-1):\n        n=(N-(j+1))*(K-1)+N-i\n        dp[j]+=(cmb(n+K-2,K-2,mod)*dp[j+1])%mod\n        dp[j]%=mod\n\nprint((dp[0]*g1[N])%mod)\n"
  },
  {
    "language": "Python",
    "code": "def pow_mod(MOD, a, n):\n    ret = 1\n    while n != 0:\n        if n % 2 == 1: ret = ret * a % MOD\n        a = a * a % MOD\n        n //= 2\n    return ret\n\ndef fac(n):\n    MOD = 1000000007\n    ret = 1\n    for i in range(1, n + 1):\n        ret = ret * i % MOD\n    return ret\n\ndef fac_gen(first, last):\n    MOD = 1000000007\n    ret = fac(first)\n    yield ret\n    for i in range(first + 1, last):\n        ret = ret * i % MOD\n        yield ret\n\ndef build_comb_list(f, m, K):\n    MOD = 1000000007\n    v = pow_mod(MOD, f[m - K * 2] * f[0], MOD - 2)\n    for i in range(m - K, -1, -1):\n        f[i] *= v\n        v = v * i % MOD\n\ndef solve_dp(n, k, comb):\n    MOD = 1000000007\n    dp = [1] * (n + 1)\n    for i in range(2, n + 1):\n        ci = (i - 1) * (k - 1)\n        v = 0\n        for j, c in zip(range(i), comb[ci:ci + i]):\n            v = (v + dp[j] * c) % MOD\n            dp[j] = v\n        dp[i] = v\n    return dp[n] * fac(n) % MOD\n\ndef solve(n, k):\n    if n == 1 or k == 1: return 1\n    m = n * k\n    comb = list(fac_gen(k - 2, m - 1))\n    build_comb_list(comb, m - 2, k - 2)\n    return solve_dp(n, k, comb)\n\n\nn, k = (int(s) for s in input().split(' '))\nprint(solve(n, k))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\n\"\"\"\n・0を除く左端：N,N-1,...の順に並ぶとする。\n・0は左から順に、z_N,z_{N-1},...と並ぶ（もとの正体）\n・小さい数から順に処理する。n以下の数とz_n,...,z_1を並べたとき、先頭の0の個数ごとに値を持つ\n\"\"\"\n\nimport numpy as np\n\nN,K = map(int,read().split())\n\nif K == 1:\n    print(1)\n    exit()\n\nMOD = 10 ** 9 + 7\n\ndef cumprod(A, MOD = MOD):\n    L = len(A); Lsq = int(L**.5+1)\n    A = np.resize(A, Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        A[:,n] *= A[:,n-1]; A[:,n] %= MOD\n    for n in range(1,Lsq):\n        A[n] *= A[n-1,-1]; A[n] %= MOD\n    return A.ravel()[:L]\n\ndef make_fact(U, MOD = MOD):\n    x = np.arange(U, dtype = np.int64); x[0] = 1\n    fact = cumprod(x, MOD)\n    x = np.arange(U, 0, -1, dtype=np.int64); x[0] = pow(int(fact[-1]), MOD-2, MOD)\n    fact_inv = cumprod(x, MOD)[::-1]\n    return fact,fact_inv\n\nU = (N + 10) * (K + 10)\nfact, fact_inv = make_fact(U)\n\n# 最初はz_1,1,1,...と並べるしかない。左端にzが1つ。\ndp = np.array([0,1],np.int64)\nfor n in range(2,N+1):\n    prev = dp\n    dp = np.zeros(n+1,np.int64)\n    \"\"\"\n    dp[i] には、prev[i-1,i,i+1,...]から遷移してくる。和をとって定数倍。\n    累積和をいじったあと定数倍すればよい\n    \"\"\"\n    S = prev.sum() % MOD\n    np.cumsum(prev,out=prev); prev %= MOD\n    dp[1] = S\n    dp[2:] = S - prev[:-1]\n    \"\"\"\n    n の挿入方法を乗ずる。\n    [z^i][n][右側：小さい側が(n-1)K-i+1個、nがK-2個]\n    \"\"\"\n    coef = fact[n*(K-1)-1:n*K][::-1].copy()\n    coef *= fact_inv[K-2]; coef %= MOD\n    coef *= fact_inv[(n-1)*(K-1):(n-1)*K+2][::-1]; coef %= MOD\n    dp *= coef; dp %= MOD\n\nanswer = dp.sum() % MOD\nanswer *= fact[N]; answer %= MOD\nprint(answer)"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_variables, dead_code)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\nuse std::io::Write;\n\ntrait InputValue {\n    fn parse(s: &str) -> Self;\n}\n\nfn read<T: InputValue>() -> T {\n    let mut buf = String::new();\n    let _ = stdin().read_line(&mut buf);\n    T::parse(&buf.trim())\n}\n\nfn readnc<T: InputValue>() -> Vec<T> {\n    let mut vec = vec![];\n    let line: String = read();\n    for token in line.split_whitespace() {\n        vec.push(T::parse(token));\n    }\n    vec\n}\n\nfn readn<T: InputValue>(n: usize) -> Vec<T> {\n    let mut vec = vec![];\n    for _ in 0..n {\n        vec.push(read());\n    }\n    vec\n}\n\nmacro_rules! parse_single_value {\n    ($($t:ty),*) => {\n        $(\n            impl InputValue for $t {\n                fn parse(s: &str) -> $t { s.parse().unwrap() }\n            }\n        )*\n\t}\n}\nparse_single_value!(i32, i64, f32, f64, usize, String);\n\nmacro_rules! parse_tuple {\n\t($($t:ident),*) => {\n\t\timpl<$($t),*> InputValue for ($($t),*) where $($t: InputValue),* {\n\t\t\tfn parse(s: &str) -> ($($t),*) {\n\t\t\t\tlet mut tokens = s.split_whitespace();\n\t\t\t\tlet t = ($($t::parse(tokens.next().unwrap())),*);\n\t\t\t\tt\n\t\t\t}\n\t\t}\n\t}\n}\nparse_tuple!(A, B);\nparse_tuple!(A, B, C);\n\n// ===\n\nfn powmod(a: i64, p: i64, m: i64) -> i64 {\n    let mut ret = 1i64;\n    let mut aa = a;\n    let mut pp = p;\n    while pp >= 1 {\n        if pp & 1 == 1 {\n            ret *= aa;\n            ret %= m;\n        }\n        aa = aa * aa % m;\n        pp >>= 1;\n    }\n    ret\n}\n\nfn inv(a: i64, m: i64) -> i64 {\n    powmod(a, m-2, m)\n}\n\nstruct Combination {\n    fact: Vec<i64>,\n    invfact: Vec<i64>,\n    modulo: i64\n}\n\nimpl Combination {\n    fn new(n: usize, modulo: i64) -> Self {\n        let mut fact: Vec<i64> = vec![0; n];\n        let mut invfact: Vec<i64> = vec![0; n];\n        fact[0] = 1;\n        for i in 1..n {\n            fact[i] = fact[i-1] * i as i64 % modulo;\n        }\n        invfact[n-1] = inv(fact[n-1], modulo);\n        for i in (0..n-1).rev() {\n            invfact[i] = (invfact[i+1] * (i+1) as i64) % modulo;\n        }\n\n        Combination { fact: fact, invfact: invfact, modulo: modulo }\n    }\n\n    fn combination(&self, n: usize, k: usize) -> i64 {\n        if n < k {\n            return 0;\n        }\n        self.fact[n] * self.invfact[n-k] % self.modulo * self.invfact[k] % self.modulo\n    }\n}\n\nconst MOD: i64 = 1e9 as i64 + 7;\n\nstruct Solver {\n    n: usize,\n    k: usize,\n    memo: Vec<Vec<i64>>,\n    comb: Combination\n}\n\nimpl Solver {\n    fn dfs(&mut self, row: usize, head: usize) -> i64 {\n        if self.memo[row][head] != -1 {\n            return self.memo[row][head]\n        }\n        let mut ret = 0;\n        if row + head >= 1 {\n            if head >= 1 {\n                ret += self.dfs(row, head-1);\n            }\n            if row > head {\n                let left = head * self.k + (row - head) * (self.k - 1);\n                ret += self.dfs(row-1, head) * self.comb.combination(left-1, self.k-2) % MOD;\n            }\n        } else {\n            ret = 1;\n        }\n        ret %= MOD;\n        self.memo[row][head] = ret;\n        ret\n    }\n}\n\nfn main() {\n    let (n, k): (usize, usize) = read();\n    if k == 1 {\n        println!(\"1\");\n    } else {\n        let memo = vec![vec![-1; n+1]; n+1];\n        let comb = Combination::new(4000010, MOD);\n        let mut solver = Solver { n: n, k: k, memo: memo, comb: comb };\n        let mut ans = solver.dfs(n, n);\n        for i in 1..n+1 {\n            ans *= i as i64;\n            ans %= MOD;\n        }\n        println!(\"{}\", ans);\n    }\n}"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_variables, dead_code)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\nuse std::io::Write;\n\ntrait InputValue {\n    fn parse(s: &str) -> Self;\n}\n\nfn read<T: InputValue>() -> T {\n    let mut buf = String::new();\n    let _ = stdin().read_line(&mut buf);\n    T::parse(&buf.trim())\n}\n\nfn readnc<T: InputValue>() -> Vec<T> {\n    let mut vec = vec![];\n    let line: String = read();\n    for token in line.split_whitespace() {\n        vec.push(T::parse(token));\n    }\n    vec\n}\n\nfn readn<T: InputValue>(n: usize) -> Vec<T> {\n    let mut vec = vec![];\n    for _ in 0..n {\n        vec.push(read());\n    }\n    vec\n}\n\nmacro_rules! parse_single_value {\n    ($($t:ty),*) => {\n        $(\n            impl InputValue for $t {\n                fn parse(s: &str) -> $t { s.parse().unwrap() }\n            }\n        )*\n\t}\n}\nparse_single_value!(i32, i64, f32, f64, usize, String);\n\nmacro_rules! parse_tuple {\n\t($($t:ident),*) => {\n\t\timpl<$($t),*> InputValue for ($($t),*) where $($t: InputValue),* {\n\t\t\tfn parse(s: &str) -> ($($t),*) {\n\t\t\t\tlet mut tokens = s.split_whitespace();\n\t\t\t\tlet t = ($($t::parse(tokens.next().unwrap())),*);\n\t\t\t\tt\n\t\t\t}\n\t\t}\n\t}\n}\nparse_tuple!(A, B);\nparse_tuple!(A, B, C);\n\n// ===\n\nfn powmod(a: i64, p: i64, m: i64) -> i64 {\n    let mut ret = 1i64;\n    let mut aa = a;\n    let mut pp = p;\n    while pp >= 1 {\n        if pp & 1 == 1 {\n            ret *= aa;\n            ret %= m;\n        }\n        aa = aa * aa % m;\n        pp >>= 1;\n    }\n    ret\n}\n\nfn inv(a: i64, m: i64) -> i64 {\n    powmod(a, m-2, m)\n}\n\nstruct Combination {\n    fact: Vec<i64>,\n    invfact: Vec<i64>,\n    modulo: i64\n}\n\nimpl Combination {\n    fn new(n: usize, modulo: i64) -> Self {\n        let mut fact: Vec<i64> = vec![0; n];\n        let mut invfact: Vec<i64> = vec![0; n];\n        fact[0] = 1;\n        for i in 1..n {\n            fact[i] = fact[i-1] * i as i64 % modulo;\n        }\n        invfact[n-1] = inv(fact[n-1], modulo);\n        for i in (0..n-1).rev() {\n            invfact[i] = (invfact[i+1] * (i+1) as i64) % modulo;\n        }\n\n        Combination { fact: fact, invfact: invfact, modulo: modulo }\n    }\n\n    fn combination(&self, n: usize, k: usize) -> i64 {\n        if n < k {\n            return 0;\n        }\n        self.fact[n] * self.invfact[n-k] % self.modulo * self.invfact[k] % self.modulo\n    }\n}\n\nconst MOD: i64 = 1e9 as i64 + 7;\n\nstruct Solver {\n    n: usize,\n    k: usize,\n    memo: Vec<Vec<i64>>,\n    comb: Combination\n}\n\nimpl Solver {\n    fn dfs(&mut self, row: usize, head: usize) -> i64 {\n        if self.memo[row][head] != -1 {\n            return self.memo[row][head]\n        }\n        let mut ret = 0;\n        if row + head >= 1 {\n            if head >= 1 {\n                ret += self.dfs(row, head-1);\n            }\n            if row > head {\n                let left = head * self.k + (row - head) * (self.k - 1);\n                ret += self.dfs(row-1, head) * self.comb.combination(left-1, self.k-2) % MOD;\n            }\n        } else {\n            ret = 1;\n        }\n        ret %= MOD;\n        self.memo[row][head] = ret;\n        ret\n    }\n}\n\nfn main() {\n    let (n, k): (usize, usize) = read();\n    if k == 1 {\n        println!(\"1\");\n    } else {\n        let memo = vec![vec![-1; n+1]; n+1];\n        let comb = Combination::new(4000010, MOD);\n        let mut solver = Solver { n, k, memo, comb };\n        let mut ans = solver.dfs(n, n);\n        for i in 1..n+1 {\n            ans *= i as i64;\n            ans %= MOD;\n        }\n        println!(\"{}\", ans);\n    }\n}"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n\n/// Verified by: https://beta.atcoder.jp/contests/arc099/submissions/3515280\nmod mod_int {\n    use std::ops::*;\n    pub trait Mod: Copy + Clone {\n        fn m() -> i64;\n    }\n    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt<M: Mod> { pub x: i64, phantom: ::std::marker::PhantomData<*const M> }\n    impl<M: Mod> ModInt<M> {\n        fn check_integrity(self) {\n            debug_assert!(self.x >= 0);\n            debug_assert!(self.x < M::m());\n        }\n        // x >= 0\n        pub fn new(x: i64) -> Self { ModInt::new_internal(x % M::m()) }\n        fn new_internal(x: i64) -> Self { ModInt { x: x, phantom: ::std::marker::PhantomData } }\n        #[allow(dead_code)]\n        pub fn mul_fast(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            ModInt::new_internal(self.x * other.x % M::m())\n        }\n        #[allow(dead_code)]\n        pub fn mul_slow(self, other: Self) -> Self {\n            // Naive multiplication in order to avoid overflow\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = ModInt::new_internal(0);\n            let mut cur = self;\n            let mut e = other.x;\n            if self.x < other.x {\n                cur = other;\n                e = self.x;\n            }\n            while e > 0 {\n                if e % 2 == 1 {\n                    sum += cur;\n                }\n                cur += cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            self.check_integrity();\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new_internal(1);\n            let mut cur = self;\n            while e > 0 {\n                if e % 2 != 0 {\n                    sum *= cur;\n                }\n                cur *= cur;\n                e /= 2;\n            }\n            sum\n        }\n        #[allow(dead_code)]\n        pub fn inv(self) -> Self { self.pow(M::m() - 2) }\n    }\n    impl<M: Mod> Add for ModInt<M> {\n        type Output = Self;\n        fn add(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x + other.x;\n            if sum >= M::m() { sum -= M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod> Sub for ModInt<M> {\n        type Output = Self;\n        fn sub(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod> Mul for ModInt<M> {\n        type Output = Self;\n        fn mul(self, other: Self) -> Self {\n            self.mul_fast(other)\n        }\n    }\n    impl<M: Mod> AddAssign for ModInt<M> {\n        fn add_assign(&mut self, other: Self) {\n            *self = *self + other;\n        }\n    }\n    impl<M: Mod> SubAssign for ModInt<M> {\n        fn sub_assign(&mut self, other: Self) {\n            *self = *self - other;\n        }\n    }\n    impl<M: Mod> MulAssign for ModInt<M> {\n        fn mul_assign(&mut self, other: Self) {\n            *self = *self * other;\n        }\n    }\n    impl<M: Mod> ::std::fmt::Display for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n} // mod mod_int\n\nmacro_rules! define_mod {\n    ($struct_name: ident, $modulo: expr) => {\n        #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n        struct $struct_name {}\n        impl mod_int::Mod for $struct_name { fn m() -> i64 { $modulo } }\n    }\n}\nconst MOD: i64 = 1_000_000_007;\ndefine_mod!(P, MOD);\ntype ModInt = mod_int::ModInt<P>;\n\n\n// The author of this code read the editorial.\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($format:expr) => (write!(out,$format).unwrap());\n        ($format:expr, $($args:expr),+) => (write!(out,$format,$($args),*).unwrap())\n    }\n    input! {\n        n: usize,\n        k: usize,\n    }\n    // Precalc\n    const W: usize = 1 << 23;\n    let mut fac = vec![ModInt::new(1); W];\n    let mut invfac = vec![ModInt::new(1); W];\n    for i in 1 .. W {\n        fac[i] = fac[i - 1] * ModInt::new(i as i64);\n    }\n    invfac[W - 1] = fac[W - 1].inv();\n    for i in (0 .. W - 1).rev() {\n        invfac[i] = invfac[i + 1] * ModInt::new(i as i64 + 1);\n    }\n    // Precalc ends\n    if k == 1 {\n        puts!(\"1\\n\");\n        return;\n    }\n    let mut dp = vec![vec![ModInt::new(0); n + 1]; n + 1];\n    dp[0][0] = ModInt::new(1);\n    for i in 0 .. n + 1 {\n        for j in i .. n + 1 {\n            if i == 0 && j == 0 { continue; }\n            if i >= 1 {\n                dp[i][j] += dp[i - 1][j];\n            }\n            if j >= i + 1 {\n                let x = i + j * (k - 1) - 1;\n                let y = k - 2;\n                dp[i][j] += dp[i][j - 1] * fac[x] * invfac[x - y] * invfac[y];\n            }\n        }\n    }\n    puts!(\"{}\\n\", dp[n][n] * fac[n]);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  }
]