[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_H 1000\n#define MAX_W 1000\n\nint H, W;\nchar grid[MAX_H][MAX_W];\nbool visited[MAX_H][MAX_W];\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nvoid dfs(int x, int y) {\n    if (x < 0 || x >= H || y < 0 || y >= W || visited[x][y] || grid[x][y] == '#') \n        return;\n    \n    visited[x][y] = true;\n    \n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        dfs(nx, ny);\n    }\n}\n\nbool can_escape(int x, int y) {\n    memset(visited, 0, sizeof(visited));\n    dfs(x, y);\n    \n    for (int i = 0; i < H; i++) {\n        if (visited[i][0] || visited[i][W-1]) \n            return true;\n    }\n    \n    for (int j = 0; j < W; j++) {\n        if (visited[0][j] || visited[H-1][j]) \n            return true;\n    }\n    \n    return false;\n}\n\nint solve() {\n    int fences = 0;\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == 'G') {\n                if (can_escape(i, j)) {\n                    return -1;  // impossible to fence\n                }\n            }\n        }\n    }\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '.') {\n                grid[i][j] = '#';\n                bool is_safe = true;\n                \n                for (int r = 0; r < H; r++) {\n                    for (int c = 0; c < W; c++) {\n                        if (grid[r][c] == 'G' && can_escape(r, c)) {\n                            is_safe = false;\n                            break;\n                        }\n                    }\n                    if (!is_safe) break;\n                }\n                \n                if (is_safe) {\n                    fences++;\n                } else {\n                    grid[i][j] = '.';\n                }\n            }\n        }\n    }\n    \n    return fences;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    \n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n    \n    printf(\"%d\\n\", solve());\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:33:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_H 100\n#define MAX_W 100\n\nint H, W;\nchar grid[MAX_H][MAX_W + 1];\nbool visited[MAX_H][MAX_W];\nint dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\nbool is_escape(int i, int j) {\n    if (i < 0 || i >= H || j < 0 || j >= W) {\n        return true;\n    }\n    if (grid[i][j] == '#') {\n        return false;\n    }\n    if (visited[i][j]) {\n        return false;\n    }\n    visited[i][j] = true;\n    for (int d = 0; d < 4; d++) {\n        int ni = i + dirs[d][0];\n        int nj = j + dirs[d][1];\n        if (is_escape(ni, nj)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    int fences = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '.') {\n                for (int k = 0; k < H; k++) {\n                    for (int l = 0; l < W; l++) {\n                        visited[k][l] = false;\n                    }\n                }\n                grid[i][j] = '#';\n                bool need_fence = false;\n                for (int k = 0; k < H; k++) {\n                    for (int l = 0; l < W; l++) {\n                        if (grid[k][l] == 'G' && !visited[k][l]) {\n                            if (is_escape(k, l)) {\n                                need_fence = true;\n                                break;\n                            }\n                        }\n                    }\n                    if (need_fence) break;\n                }\n                if (need_fence) {\n                    fences++;\n                } else {\n                    grid[i][j] = '.';\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\", fences);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:34:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> grid(H);\n    for (int i = 0; i < H; ++i) {\n        cin >> grid[i];\n    }\n\n    int fences = 0;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (grid[i][j] == '.') {\n                bool needFence = false;\n                if (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n                    needFence = true;\n                } else {\n                    if (grid[i-1][j] == 'W' || grid[i+1][j] == 'W' || grid[i][j-1] == 'W' || grid[i][j+1] == 'W') {\n                        needFence = true;\n                    }\n                }\n                if (needFence) {\n                    fences++;\n                }\n            }\n        }\n    }\n\n    cout << fences << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:34:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static int H, W;\n    static char[][] grid;\n    static int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        H = sc.nextInt();\n        W = sc.nextInt();\n        grid = new char[H][W];\n        for (int i = 0; i < H; i++) {\n            grid[i] = sc.next().toCharArray();\n        }\n\n        int fences = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (grid[i][j] == '.') {\n                    boolean needFence = false;\n                    for (int[] dir : dirs) {\n                        int ni = i + dir[0];\n                        int nj = j + dir[1];\n                        if (ni >= 0 && ni < H && nj >= 0 && nj < W && grid[ni][nj] == 'G') {\n                            needFence = true;\n                            break;\n                        }\n                    }\n                    if (needFence) {\n                        grid[i][j] = '#';\n                        fences++;\n                    }\n                }\n            }\n        }\n\n        System.out.println(fences);\n    }\n}",
    "timestamp": "2025-08-05 23:34:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    private static final int[] dx = {0, 0, 1, -1};\n    private static final int[] dy = {1, -1, 0, 0};\n\n    public static int minFences(int H, int W, int[][] goats) {\n        boolean[][] grid = new boolean[H][W];\n        for (int[] goat : goats) {\n            grid[goat[0]][goat[1]] = true;\n        }\n\n        Set<String> vulnerable = findVulnerableGoats(H, W, grid);\n        return minimumFencesToBlock(H, W, grid, vulnerable);\n    }\n\n    private static Set<String> findVulnerableGoats(int H, int W, boolean[][] grid) {\n        Set<String> vulnerable = new HashSet<>();\n        \n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (grid[i][j] && (i == 0 || i == H-1 || j == 0 || j == W-1)) {\n                    vulnerable.add(i + \",\" + j);\n                }\n            }\n        }\n        \n        return vulnerable;\n    }\n\n    private static int minimumFencesToBlock(int H, int W, boolean[][] grid, Set<String> vulnerable) {\n        if (vulnerable.isEmpty()) return 0;\n        \n        int minFences = Integer.MAX_VALUE;\n        \n        for (int mask = 0; mask < (1 << (H * W)); mask++) {\n            if (canBlockAllGoats(H, W, grid, vulnerable, mask)) {\n                minFences = Math.min(minFences, Integer.bitCount(mask));\n            }\n        }\n        \n        return minFences;\n    }\n\n    private static boolean canBlockAllGoats(int H, int W, boolean[][] grid, Set<String> vulnerable, int mask) {\n        boolean[][] fences = new boolean[H][W];\n        \n        for (int i = 0; i < H * W; i++) {\n            if ((mask & (1 << i)) != 0) {\n                int r = i / W;\n                int c = i % W;\n                if (grid[r][c]) return false;\n                fences[r][c] = true;\n            }\n        }\n        \n        for (String goat : vulnerable) {\n            String[] pos = goat.split(\",\");\n            int r = Integer.parseInt(pos[0]);\n            int c = Integer.parseInt(pos[1]);\n            \n            if (!canEscape(H, W, grid, fences, r, c)) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n\n    private static boolean canEscape(int H, int W, boolean[][] grid, boolean[][] fences, int r, int c) {\n        boolean[][] visited = new boolean[H][W];\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{r, c});\n        visited[r][c] = true;\n        \n        while (!queue.isEmpty()) {\n            int[] curr = queue.poll();\n            \n            if (curr[0] == 0 || curr[0] == H-1 || curr[1] == 0 || curr[1] == W-1) {\n                return true;\n            }\n            \n            for (int k = 0; k < 4; k++) {\n                int nr = curr[0] + dx[k];\n                int nc = curr[1] + dy[k];\n                \n                if (nr >= 0 && nr < H && nc >= 0 && nc < W && \n                    !grid[nr][nc] && !fences[nr][nc] && !visited[nr][nc]) {\n                    queue.offer(new int[]{nr, nc});\n                    visited[nr][nc] = true;\n                }\n            }\n        }\n        \n        return false;\n    }\n\n    public static void main(String[] args) {\n        int H = 3;\n        int W = 3;\n        int[][] goats = {{0, 0}, {2, 2}};\n        System.out.println(minFences(H, W, goats));\n    }\n}",
    "timestamp": "2025-08-05 23:34:47"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minimumFences(int H, int W, vector<pair<int, int>>& goats) {\n        vector<vector<bool>> grid(H, vector<bool>(W, false));\n        for (auto& goat : goats) {\n            grid[goat.first][goat.second] = true;\n        }\n        \n        vector<vector<bool>> visited(H, vector<bool>(W, false));\n        int fences = 0;\n        \n        vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        \n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (grid[i][j] || visited[i][j]) continue;\n                \n                if (isEscapePossible(grid, visited, i, j, H, W)) {\n                    fences++;\n                    markFence(grid, visited, i, j, H, W);\n                }\n            }\n        }\n        \n        return fences;\n    }\n    \nprivate:\n    bool isEscapePossible(vector<vector<bool>>& grid, vector<vector<bool>>& visited, int x, int y, int H, int W) {\n        queue<pair<int, int>> q;\n        q.push({x, y});\n        visited[x][y] = true;\n        \n        vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        \n        while (!q.empty()) {\n            auto [currX, currY] = q.front();\n            q.pop();\n            \n            if (currX == 0 || currX == H - 1 || currY == 0 || currY == W - 1) {\n                return true;\n            }\n            \n            for (auto& [dx, dy] : directions) {\n                int newX = currX + dx;\n                int newY = currY + dy;\n                \n                if (newX >= 0 && newX < H && newY >= 0 && newY < W && \n                    !grid[newX][newY] && !visited[newX][newY]) {\n                    q.push({newX, newY});\n                    visited[newX][newY] = true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    void markFence(vector<vector<bool>>& grid, vector<vector<bool>>& visited, int x, int y, int H, int W) {\n        queue<pair<int, int>> q;\n        q.push({x, y});\n        grid[x][y] = true;\n        \n        vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        \n        while (!q.empty()) {\n            auto [currX, currY] = q.front();\n            q.pop();\n            \n            for (auto& [dx, dy] : directions) {\n                int newX = currX + dx;\n                int newY = currY + dy;\n                \n                if (newX >= 0 && newX < H && newY >= 0 && newY < W && \n                    !grid[newX][newY] && !visited[newX][newY]) {\n                    q.push({newX, newY});\n                    grid[newX][newY] = true;\n                    visited[newX][newY] = true;\n                }\n            }\n        }\n    }\n};\n\nint main() {\n    Solution sol;\n    int H = 3, W = 4;\n    vector<pair<int, int>> goats = {{0, 1}, {2, 2}};\n    \n    cout << sol.minimumFences(H, W, goats) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:34:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef min_fences_to_place(H, W, grid):\n    def in_bounds(x, y):\n        return 0 <= x < H and 0 <= y < W\n\n    def bfs():\n        queue = deque()\n        visit = [[False] * W for _ in range(H)]\n        \n        # Add all goats on the boundary to the queue\n        for row in range(H):\n            for col in range(W):\n                if grid[row][col] == 'G': # 'G' for goat\n                    if row == 0 or row == H - 1 or col == 0 or col == W - 1:\n                        queue.append((row, col))\n                        visit[row][col] = True\n\n        # Perform BFS to mark all reachable goats\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if in_bounds(nx, ny) and not visit[nx][ny] and grid[nx][ny] == 'G':\n                    visit[nx][ny] = True\n                    queue.append((nx, ny))\n        \n        return visit\n\n    reachable_by_goats = bfs()\n    min_fences_count = 0\n    \n    # Place fences on empty spaces adjacent to reachable goats\n    for row in range(H):\n        for col in range(W):\n            if grid[row][col] == '.' and not any(reachable_by_goats[row][nc] for nc in range(W)):\n                continue\n            if grid[row][col] == '.' and any(reachable_by_goats[nr][col] for nr in range(H)):\n                # Check if adjacent cells (up, down, left, right) are reachable by goats\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nx, ny = row + dx, col + dy\n                    if in_bounds(nx, ny) and reachable_by_goats[nx][ny] and grid[nx][ny] == 'G':\n                        min_fences_count += 1\n                        grid[row][col] = 'F'  # 'F' for fence\n                        break\n\n    return min_fences_count\n\n# Example Usage:\nH, W = 5, 5\ngrid = [\n    ['.', 'G', '.', '.', '.'],\n    ['.', '.', '.', '.', '.'],\n    ['.', '.', 'G', '.', '.'],\n    ['.', '.', '.', '.', 'G'],\n    ['G', '.', '.', '.', '.']\n]\nprint(min_fences_to_place(H, W, grid)) # Should output the minimum number of fences needed",
    "timestamp": "2025-08-13 16:01:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class GoatFence {\n    // Directions for movement\n    private static final int[][] DIRECTIONS = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n    \n    public int minFences(char[][] grid) {\n        int H = grid.length;\n        int W = grid[0].length;\n        Queue<int[]> queue = new LinkedList<>();\n        boolean[][] visited = new boolean[H][W];\n\n        // Add all the goats that can escape initially (on the outer border) to the queue\n        for (int r = 0; r < H; r++) {\n            for (int c = 0; c < W; c++) {\n                if (grid[r][c] == 'G' && (r == 0 || r == H-1 || c == 0 || c == W-1)) {\n                    queue.add(new int[]{r, c});\n                    visited[r][c] = true;\n                }\n            }\n        }\n\n        // Perform BFS to determine which goats can potentially escape\n        while (!queue.isEmpty()) {\n            int[] cur = queue.poll();\n            for (int[] dir : DIRECTIONS) {\n                int nr = cur[0] + dir[0];\n                int nc = cur[1] + dir[1];\n                if (nr >= 0 && nr < H && nc >= 0 && nc < W && !visited[nr][nc] && grid[nr][nc] == 'G') {\n                    queue.add(new int[]{nr, nc});\n                    visited[nr][nc] = true;\n                }\n            }\n        }\n\n        // Count the minimum number of fences\n        int fences = 0;\n        for (int r = 0; r < H; r++) {\n            for (int c = 0; c < W; c++) {\n                if (grid[r][c] == '.' && canBlock(r, c, H, W, grid, visited)) {\n                    fences++;\n                }\n            }\n        }\n        \n        return fences;\n    }\n\n    private boolean canBlock(int r, int c, int H, int W, char[][] grid, boolean[][] visited) {\n        for (int[] dir : DIRECTIONS) {\n            int nr = r + dir[0];\n            int nc = c + dir[1];\n            if (nr >= 0 && nr < H && nc >= 0 && nc < W && grid[nr][nc] == 'G' && visited[nr][nc]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        GoatFence gf = new GoatFence();\n        char[][] grid = {\n            {'.', 'G', '.', '.'},\n            {'.', '.', 'G', '.'},\n            {'G', '.', '.', '.'},\n            {'.', '.', '.', 'G'}\n        };\n        System.out.println(gf.minFences(grid));  // Example usage\n    }\n}",
    "timestamp": "2025-08-13 16:01:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#define MAX 1000\n\nint H, W;\nchar grid[MAX][MAX];\nbool visited[MAX][MAX];\n\nvoid dfs(int x, int y) {\n    if (x < 0 || y < 0 || x >= H || y >= W || visited[x][y] || grid[x][y] == '#') return;\n    visited[x][y] = true;\n    dfs(x + 1, y);\n    dfs(x - 1, y);\n    dfs(x, y + 1);\n    dfs(x, y - 1);\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; ++i) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            visited[i][j] = false;\n        }\n    }\n\n    for (int i = 0; i < H; ++i) {\n        if (grid[i][0] == 'G') dfs(i, 0);\n        if (grid[i][W - 1] == 'G') dfs(i, W - 1);\n    }\n    for (int i = 0; i < W; ++i) {\n        if (grid[0][i] == 'G') dfs(0, i);\n        if (grid[H - 1][i] == 'G') dfs(H - 1, i);\n    }\n\n    int fences_needed = 0;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (grid[i][j] == '.' && !visited[i][j]) {\n                fences_needed++;\n                grid[i][j] = '#';\n            }\n        }\n    }\n\n    printf(\"%d\\n\", fences_needed);\n    return 0;\n}",
    "timestamp": "2025-08-13 16:01:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint H, W;\nvector<vector<char>> grid;\nvector<vector<bool>> visited;\nqueue<pair<int, int>> q;\nint fences;\n\nvector<int> dx = {-1, 1, 0, 0};\nvector<int> dy = {0, 0, -1, 1};\n\nbool isOuterCell(int x, int y) {\n    return x == 0 || x == H-1 || y == 0 || y == W-1;\n}\n\nvoid bfs(int x, int y) {\n    q.push({x, y});\n    visited[x][y] = true;\n    \n    while (!q.empty()) {\n        auto [cx, cy] = q.front();\n        q.pop();\n\n        for (int i = 0; i < 4; ++i) {\n            int nx = cx + dx[i];\n            int ny = cy + dy[i];\n\n            if (nx >= 0 && nx < H && ny >= 0 && ny < W && grid[nx][ny] == '.' && !visited[nx][ny]) {\n                q.push({nx, ny});\n                visited[nx][ny] = true;\n                if (isOuterCell(nx, ny)) fences++;\n            }\n        }\n    }\n}\n\nint main() {\n    cin >> H >> W;\n    grid.resize(H, vector<char>(W));\n    visited.resize(H, vector<bool>(W, false));\n    fences = 0;\n\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            cin >> grid[i][j];\n            if (grid[i][j] == 'G' && isOuterCell(i, j)) {\n                bfs(i, j);\n            }\n        }\n    }\n\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (grid[i][j] == '.' && !visited[i][j] && isOuterCell(i, j)) {\n                fences++;\n            }\n        }\n    }\n\n    cout << fences << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 16:02:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_fences_to_block_goats(grid):\n    H, W = len(grid), len(grid[0])\n    goat_cells = []\n    \n    # Find goat locations\n    for r in range(H):\n        for c in range(W):\n            if grid[r][c] == 'G':\n                goat_cells.append((r, c))\n    \n    # Function to check if a cell is valid\n    def is_valid(r, c):\n        return 0 <= r < H and 0 <= c < W\n    \n    # Directions: up, down, left, right\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    # BFS to track goat escape paths\n    def bfs_escape_path(start):\n        queue = [start]\n        visited = set([start])\n        \n        while queue:\n            r, c = queue.pop(0)\n            \n            # Check if goat can escape from outermost cells\n            if r == 0 or r == H-1 or c == 0 or c == W-1:\n                return True\n            \n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                if is_valid(nr, nc) and grid[nr][nc] != 'F' and (nr, nc) not in visited:\n                    queue.append((nr, nc))\n                    visited.add((nr, nc))\n        \n        return False\n    \n    # Minimum fences to block\n    min_fences = float('inf')\n    \n    # Try all possible fence placements\n    for mask in range(1 << (H * W)):\n        fence_count = bin(mask).count('1')\n        \n        # Skip if fence count is already larger than current minimum\n        if fence_count >= min_fences:\n            continue\n        \n        # Place fences based on mask\n        temp_grid = [row[:] for row in grid]\n        for r in range(H):\n            for c in range(W):\n                if mask & (1 << (r * W + c)) and temp_grid[r][c] != 'G':\n                    temp_grid[r][c] = 'F'\n        \n        # Check if fences block all goats\n        blocked = True\n        for goat in goat_cells:\n            if bfs_escape_path(goat):\n                blocked = False\n                break\n        \n        # Update minimum fences if blocked\n        if blocked:\n            min_fences = min(min_fences, fence_count)\n    \n    return min_fences if min_fences != float('inf') else -1",
    "timestamp": "2025-08-13 16:02:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef solve():\n    H, W = map(int, input().split())\n    grid = [input().strip() for _ in range(H)]\n    \n    # Directions: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Check if a goat can escape\n    def can_escape(i, j, fences):\n        visited = [[False for _ in range(W)] for _ in range(H)]\n        q = deque()\n        q.append((i, j))\n        visited[i][j] = True\n        \n        while q:\n            x, y = q.popleft()\n            if x == 0 or x == H-1 or y == 0 or y == W-1:\n                return True\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < H and 0 <= ny < W:\n                    if not visited[nx][ny] and (nx, ny) not in fences and grid[nx][ny] != 'G':\n                        visited[nx][ny] = True\n                        q.append((nx, ny))\n        return False\n    \n    # Collect all goat positions\n    goats = []\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'G':\n                goats.append((i, j))\n    \n    from itertools import combinations\n    \n    # Try fences from 0 to possible maximum (H*W)\n    max_possible = H * W\n    for k in range(0, max_possible + 1):\n        # Generate all possible combinations of k fences\n        # But this is not feasible for large H and W, so need a better approach\n        # Hence, this brute-force approach is only suitable for very small grids\n        # For larger grids, a more efficient method is needed (e.g., BFS with state compression)\n        # But given the problem constraints are not specified, this is a basic approach\n        all_cells = [(i, j) for i in range(H) for j in range(W) if grid[i][j] != 'G']\n        for fences in combinations(all_cells, k):\n            fence_set = set(fences)\n            blocked = True\n            for (i, j) in goats:\n                if can_escape(i, j, fence_set):\n                    blocked = False\n                    break\n            if blocked:\n                print(k)\n                return\n    print(-1)\n\nsolve()",
    "timestamp": "2025-08-13 16:05:18"
  }
]