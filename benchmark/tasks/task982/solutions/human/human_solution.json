[
  {
    "language": "Scala",
    "code": "/**\n * Created by rasrivastava on 10/17/16.\n */\n\nimport scala.util.control.Breaks._\nobject FencesType {\n  val empty = 0\n  val goat = 1\n  val fence = 2\n}\nclass Fences(val config : Array[Array[Int]]) {\n  val row = config.length\n  val col = config(0).length\n\n  def ifOnTheFence(x : Int,y: Int): Boolean = {\n    x == 0 || x == row-1 || y == 0 || y == col-1\n  }\n\n  def addFence(x : Int,y : Int) : Int = {\n\n    var fenceRequired = 0\n    if (x-1 >= 0 && config(x-1)(y) == FencesType.empty) {\n      config(x-1)(y) = FencesType.fence\n      fenceRequired += 1\n    }\n\n    if (x+1 < row && config(x+1)(y) == FencesType.empty) {\n      config(x+1)(y) = FencesType.fence\n      fenceRequired += 1\n    }\n\n    if (y-1 >=0 && config(x)(y-1) == FencesType.empty) {\n      config(x)(y-1) = FencesType.fence\n      fenceRequired += 1\n    }\n\n    if (y+1 < col && config(x)(y+1) == FencesType.empty) {\n      config(x)(y+1) = FencesType.fence\n      fenceRequired += 1\n    }\n\n\n    fenceRequired\n\n\n\n  }\n\n  def minFence() : Int = {\n    //println(row + \" \" + col)\n    var minFence = 0\n    breakable {\n      for (i <- 0 to row - 1) {\n        for (j <- 0 to col - 1) {\n          if (ifOnTheFence(i,j) && config(i)(j) == FencesType.goat) {\n            minFence = -1\n            break()\n          }\n\n          val value = config(i)(j)\n          value match {\n            case FencesType.goat =>\n              //println(\"Found goat for \" + i + \" \" + j  + \" \" + value)\n              minFence += addFence(i,j)\n            case _ => {\n              //No op\n            }\n          }\n        }\n      }\n    }\n\n    minFence\n  }\n\n}\n\nobject Main extends  App {\n  val line = readLine\n  val lineArr = line.split(\" \")\n  val row = lineArr(0).toInt\n  val col = lineArr(1).toInt\n  val config = Array.ofDim[Int](row,col)\n\n  for (i <- 0 to row-1) {\n    val arr = new Array[Int](col)\n    val lineVal = readLine()\n    for (j <- 0 to lineVal.length-1) {\n      lineVal.charAt(j) match {\n        case '.' => {\n          arr(j) =FencesType.empty\n        }\n        case 'X' => {\n          //println(\"Adding goat for \" + i + \" \" + j)\n          arr(j) = FencesType.goat\n        }\n      }\n\n      config(i) = arr\n    }\n  }\n\n  val fences = new Fences(config)\n\n  println(fences.minFence())\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\n\ntemplate<class T>\nstruct Dinic{\n  const static int N = 10101 * 2 , M = N * 10;\n  int s , t , n , h[N] , cur[N] , level[N] , q[N] , e , ne[M] , to[M];\n  T cap[M] , flow;\n  void liu(int u,int v,T w){ to[e] = v;ne[e] = h[u];cap[e] = w;h[u] = e++;}\n  void link(int u,int v,T w){ liu(u , v , w);liu(v , u , 0);}\n  void ini(int _n = N) { fill(h , h + (n=_n) , -1);e = 0;}\n  bool bfs(){\n    int L = 0 , R = 0;\n    fill(level , level + n , -1);\n    level[q[R++] = s] = 0;\n    while(L < R && level[t] == -1){\n      int c = q[L++];\n      for(int k=h[c];~k;k=ne[k])\n        if(cap[k] > 0 && level[to[k]] == -1)\n          level[q[R++] = to[k]] = level[c] + 1;\n    }\n    return ~level[t];\n  }\n  T dfs(int c,T mx){\n    if(c == t) return mx;\n    T ret = 0;\n    for(int &k = cur[c];~k;k = ne[k]){\n      if(level[to[k]] == level[c] + 1 && cap[k] > 0){\n        T flow = dfs(to[k] , min(mx , cap[k]));\n        ret += flow;cap[k] -= flow , cap[k^1] += flow;mx -= flow;\n        if(!mx) return ret;\n      }\n    }\n    level[c] = -1;\n    return ret;\n  }\n  T run(int _s,int _t){\n    s = _s , t = _t;\n    flow = 0;\n    while(bfs()){\n      copy(h , h + n , cur);\n      flow += dfs(s,~0U>>1);\n    }\n    return flow;\n  }\n};\n\nDinic<int> it;\nconst int N = 110 , inf = N * N;\nint h , w;\nchar s[N][N];\n\nint id(int a,int b,int c) {\n  return (a * w + b) << 1 | c;\n}\n\nint main(){\n  scanf(\"%d%d\",&h,&w);\n  rep(i,0,h) scanf(\"%s\",s[i]);\n  int S = h * w * 2;\n  int T = S + 1;\n  it.ini(T + 1);\n  rep(i,0,h) rep(j,0,w) {\n    if(s[i][j] == 'X') {\n      it.link(S , id(i , j , 1) , inf);\n    } else {\n      it.link(id(i , j , 0) , id(i , j , 1) , 1);\n    }\n    if(i == 0 || i + 1 == h || j == 0 || j + 1 == w)\n      it.link(id(i , j , 1) , T , inf);\n    rep(d,0,4) {\n      int ni = i + (d == 2) - (d == 0);\n      int nj = j + (d == 3) - (d == 1);\n      if(0 <= ni && ni < h && 0 <= nj && nj < w) {\n        it.link(id(i , j , 1) , id(ni , nj , 0) , inf);\n      }\n    }\n  }\n  int flow = it.run(S , T);\n  if(flow >= inf) puts(\"-1\");\n  else printf(\"%d\\n\",flow);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n//Ford-Fulkerson O(FE)\n#include<algorithm>\n#include<utility>\n#include<vector>\n#include<limits>\ntemplate<typename T>\nstruct MF{\n\tstruct edge{\n\t\tint to,rev;\n\t\tT cap;\n\t};\n\tvector<vector<edge> >G;\n\tvector<int>used;\n\tMF(int n_=0):G(n_),used(n_,0){}\n\tvoid add_edge(int from,int to,T cap)\n\t{\n\t\tG[from].push_back({to,(int)G[to].size(),cap});\n\t\tG[to].push_back({from,(int)G[from].size()-1,0});\n\t}\n\tT dfs(int u,int t,T f,int dfstime)\n\t{\n\t\tif(u==t)return f;\n\t\tused[u]=dfstime;\n\t\tfor(edge&e:G[u])\n\t\t{\n\t\t\tif(used[e.to]<dfstime&&e.cap>0)\n\t\t\t{\n\t\t\t\tT d=dfs(e.to,t,min(f,e.cap),dfstime);\n\t\t\t\tif(d>0)\n\t\t\t\t{\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tT max_flow(int s,int t)\n\t{\n\t\tT ret=0;\n\t\tfor(int dfstime=1;;dfstime++)\n\t\t{\n\t\t\tT f=dfs(s,t,numeric_limits<T>::max(),dfstime);\n\t\t\tif(f>0)ret+=f;\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n};\nint H,W;\nstring s[100];\nint d[4]={1,0,-1,0};\nmain()\n{\n\tcin>>H>>W;\n\tfor(int i=0;i<H;i++)cin>>s[i];\n\tMF<int>P(H*W*2+2);\n\tint st=H*W*2,go=H*W*2+1;\n\tfor(int i=0;i<H;i++)for(int j=0;j<W;j++)\n\t{\n\t\tint id=i*W+j;\n\t\tif(i==0||j==0||i==H-1||j==W-1)P.add_edge(id*2+1,go,1e9);\n\t\tif(s[i][j]=='X')P.add_edge(st,id*2+1,1e9);\n\t\tP.add_edge(id*2,id*2+1,1);\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint x=i+d[r],y=j+d[r^1];\n\t\t\tif(x<0||y<0||x>=H||y>=W)continue;\n\t\t\tP.add_edge(id*2+1,2*(x*W+y),1e9);\n\t\t}\n\t}\n\tint ans=P.max_flow(st,go);\n\tif(ans<1e9)cout<<ans<<endl;\n\telse cout<<-1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n//Ford-Fulkerson O(FE)\n#include<algorithm>\n#include<utility>\n#include<vector>\n#include<limits>\ntemplate<typename T>\nstruct MF{\n\tstruct edge{\n\t\tint to,rev;\n\t\tT cap;\n\t};\n\tvector<vector<edge> >G;\n\tvector<int>used;\n\tMF(int n_=0):G(n_),used(n_,0){}\n\tvoid add_edge(int from,int to,T cap)\n\t{\n\t\tG[from].push_back({to,(int)G[to].size(),cap});\n\t\tG[to].push_back({from,(int)G[from].size()-1,0});\n\t}\n\tT dfs(int u,int t,T f,int dfstime)\n\t{\n\t\tif(u==t)return f;\n\t\tused[u]=dfstime;\n\t\tfor(edge&e:G[u])\n\t\t{\n\t\t\tif(used[e.to]<dfstime&&e.cap>0)\n\t\t\t{\n\t\t\t\tT d=dfs(e.to,t,min(f,e.cap),dfstime);\n\t\t\t\tif(d>0)\n\t\t\t\t{\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tT max_flow(int s,int t)\n\t{\n\t\tT ret=0;\n\t\tfor(int dfstime=1;;dfstime++)\n\t\t{\n\t\t\tT f=dfs(s,t,numeric_limits<T>::max(),dfstime);\n\t\t\tif(f>0)ret+=f;\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n};\nint H,W;\nstring s[100];\nint d[4]={1,0,-1,0};\nmain()\n{\n\tcin>>H>>W;\n\tfor(int i=0;i<H;i++)cin>>s[i];\n\tMF<long>P(H*W*2+2);\n\tint st=H*W*2,go=H*W*2+1;\n\tfor(int i=0;i<H;i++)for(int j=0;j<W;j++)\n\t{\n\t\tint id=i*W+j;\n\t\tif(i==0||j==0||i==H-1||j==W-1)P.add_edge(id*2+1,go,1e9);\n\t\tif(s[i][j]=='X')P.add_edge(st,id*2+1,1e9);\n\t\tP.add_edge(id*2,id*2+1,1);\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint x=i+d[r],y=j+d[r^1];\n\t\t\tif(x<0||y<0||x>=H||y>=W)continue;\n\t\t\tP.add_edge(id*2+1,2*(x*W+y),1);\n\t\t}\n\t}\n\tlong ans=P.max_flow(st,go);\n\tif(ans<1e9)cout<<ans<<endl;\n\telse cout<<-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, int> P;\n#define rep(i,n) for(int i=0;i<(n);i++)\nconst int INF = 1e9;\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, 1, 0, -1};\n\nint h, w;\nstring s[110];\nbool used[110][110];\n\nint main(void){\n\tcin >> h >> w;\n\trep(i, h) cin >> s[i];\n\trep(i, 110)rep(j, 110) used[i][j] = false;\n\trep(i, h)rep(j, w){\n\t\tif(s[i][j] == 'X'){\n\t\t\trep(k, 4){\n\t\t\t\tint ny = i + dy[k], nx = j + dx[k];\n\t\t\t\tif(!(0 <= ny && ny < h && 0 <= nx && nx < w)){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t// printf(\"%d %d\\n\", ny, nx);\n\t\t\t\tif(s[ny][nx] == '.'){\n\t\t\t\t\ts[ny][nx] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// rep(i, h) cout << s[i] << endl;\n\tint ans = 0;\n\trep(i, h)rep(j, w){\n\t\tif(s[i][j] == '#'){\n\t\t\trep(k, 4){\n\t\t\t\tint ny = i + dy[k], nx = j + dx[k];\n\t\t\t\tif(!(0 <= ny && ny < h && 0 <= nx && nx < w)){\n\t\t\t\t\tans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(!(s[ny][nx] == '#' || s[ny][nx] == 'X')){\n\t\t\t\t\tans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// rep(i, h)rep(j, w){\n\t\t// if(used[i][j] == false){\n\t\t\t// queue<pair<int, int> > q;\n\t\t\t// q.push(make_pair(0, 0));\n\t\t\t// q.push(make_pair(0, w - 1));\n\t\t\t// q.push(make_pair(h - 1, 0));\n\t\t\t// q.push(make_pair(h - 1, w - 1));\n\n\t/*\n\twhile(!q.empty()){\n\t\tauto tm = q.front(); q.pop();\n\t\tint y = tm.first, x = tm.second;\n\t\trep(i, 4){\n\t\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\t\tif(!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\t\tif(used[ny][nx]) continue;\n\t\t\tif(s[ny][nx] == 'X'){\n\t\t\t\ts[y][x] = '#'; //saku\n\t\t\t\tused[ny][nx] = true;\n\t\t\t}else if(s[ny][nx] == '.'){\n\t\t\t\tused[ny][nx] = true;\n\t\t\t\tq.push(make_pair(ny, nx));\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <iomanip>\n#include <functional>\n\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\ntypedef long long ll;\n\nusing namespace std;\nint dx[4]={0,1,0,-1};\n\nclass FF\n{\npublic:\n  struct edge{int to,cap,rev;};\n  vector<vector<edge>>G;\n  vector<bool> used;\n  FF(int maxv)\n  {\n    G.resize(maxv);\n    used.resize(maxv);\n  }\n  void add_edge(int from,int to,int cap,bool directed=1)\n  {\n    G[from].push_back({to,cap,(int)G[to].size()});\n    G[to].push_back({from,cap*(!directed),(int)G[from].size()-1});\n  }\n  int dfs(int v,int t,int f)\n  {\n    if(v==t)return f;\n    used[v]=1;\n    for(auto &nv:G[v])\n    {\n      if(!used[nv.to] && nv.cap>0)\n      {\n        int d=dfs(nv.to,t,min(f,nv.cap));\n        if(d>0)\n        {\n          nv.cap-=d;\n          G[nv.to][nv.rev].cap+=d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  int solve(int s,int t)\n  {\n    int res=0;\n    while(1)\n    {\n      for(int i=0;i<used.size();i++)used[i]=0;\n      int f=dfs(s,t,(1<<30)-1);\n      if(f==0)break;\n      res+=f;\n    }\n    return res;\n  }\n};\n\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int h,w;\n  cin>>h>>w;\n  vector<string> hw(h);\n  rep(i,h)cin>>hw[i];\n  FF ff(h*w*2+2);\n  int s=h*w*2,t=h*w*2+1;\n  rep(i,h)rep(j,w)rep(k,4)\n  {\n    int y=i+dx[k^1],x=j+dx[k];\n    if(y<0||y>=h||x<0||x>=w)\n    {\n      ff.add_edge((i*w+j)*2+1,t,10000,1);\n      //cout<<h*w+1<<\" \"<<i*w+j<<endl;\n    }\n    else\n    {\n      ff.add_edge((i*w+j)*2+1,(y*w+x)*2,1,1);\n    }\n  }\n  rep(i,h)rep(j,w)\n  {\n    if(hw[i][j]=='X')\n    {\n      if(i==0||i==h-1||j==0||j==w-1)\n      {\n        cout<<-1<<endl;\n        return 0;\n      }\n      ff.add_edge(s,(i*w+j)*2+1,10000,1);\n    }\n    else\n    {\n      ff.add_edge((i*w+j)*2,(i*w+j)*2+1,1,1);\n    }\n  }\n  cout<<ff.solve(s,t)<<endl;\n\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr,Vpr> PQ;\nconst int INF=1<<30;\nstruct Edge{\npublic:\n\tint to,cost,cp;\n\tEdge *rev;\n\tEdge(int t,int c,int cp):to(t),cost(c),cp(cp){\n\t\t\n\t}\n\tvoid add(int x){\n\t\tcp+=x;\n\t}\n\tvoid flow(int amount){\n\t\tadd(-amount);\n\t\trev->add(amount);\n\t}\n\tbool usable(){\n\t\treturn cp>=1;\n\t}\t\n};\nvoid unite(Edge &a,Edge &b){\n\ta.rev=&b;\n\tb.rev=&a;\n}\nclass Graph{\n\tint nodeSize,edgeSize;\n\tvector<int> dist;\n\tvector<vector<Edge> > edges;\npublic: \n\tvoid add(int a,int b,int cost,int cp){\n\t\tedges[a].PB(Edge(b,cost,cp));\n\t\tedges[b].PB(Edge(a,cost,0));\n\t\tunite(edges[a].back(),edges[b].back());\n\t}\n\tGraph(){}\n\tGraph(int x):nodeSize(x){\n\t\t\n\t\tedges=vector<vector<Edge> >(nodeSize);\n\t\tdist=VI(nodeSize);\n\t}\n\tvoid distInit(int s){\n\t\tREP(i,nodeSize){\n\t\t\tdist[i]=INF;\n\t\t}\n\t\tdist[s]=0;\n\t}\n\tint searching(int now,int e,int capacity){\n\t\tif(capacity==0) return 0;\n\t\tif(now==e) return capacity;\n\t\tif(dist[now]>=dist[e]) return 0;\n\t\tint flowed=0;\n\t\tREP(i,edges[now].size()){\n\t\t\tEdge *ed= &edges[now][i];\n\t\t\tif(!ed->usable()) continue;\n\t\t\tif(dist[now]+1 != dist[ed->to]) continue;\n\t\t\tint nflow=searching(ed->to,e,min(capacity-flowed,ed->cp));\n\t\t\tif(nflow){\n\t\t\t\tflowed+=nflow;\n\t\t\t\ted->flow(nflow);\n\t\t\t}\n\t\t\tif(flowed) return flowed;\n\t\t}\n\t\treturn flowed;\n\t}\n\tbool bfs(int s,int e){\n\t\tdistInit(s);\n\t\tqueue<int> qu;\n\t\tqu.push(s);\n\t\twhile(!qu.empty()){\n\t\t\tint now=qu.front();\n\t\t\tif(now==e) return true;\n\t\t\tqu.pop();\n\t\t\tREP(i,edges[now].size()){\n\t\t\t\tEdge *ed= &edges[now][i];\n\t\t\t\tif(!ed->usable()) continue;\n\t\t\t\tif(dist[ed->to]==INF){\n\t\t\t\t\tqu.push(ed->to);\n\t\t\t\t\tdist[ed->to]=dist[now]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint maximumFlow(int s,int e){\n\t\tint ans=0;\n\t\twhile(bfs(s,e)){\n\t\t\tans+=searching(s,e,INF);\n\t\t}\n\t\treturn ans;\n\t}\n};\nconst int SIZE=101;\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\nint H,W;\nint maps[101][101];\nGraph graph;\nint conv(int a,int b,int c){return a*H+b+H*W*c+2;}\nbool isSafe(int y,int x){\n\treturn 0<=y && y<H && 0<=x && x<W;\n}\nint main(){\n\tcin >> H >> W;\n\tgraph=Graph(H*W*3+2);\n\tREP(i,H) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,s.size()){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(maps[i][j] &&(i==0 || j==0 || i==H-1 || j==W-1)){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\t\t\n\t}\n\tREP(i,H) REP(j,W) {\n\t\tgraph.add(conv(i,j,1),conv(i,j,0),0,1);\n//\t\tedges[conv(i,j,1)].PB(edge(conv(i,j,0),0,1));\n\t\tif(maps[i][j]){\n\t\t\t//edges[0].PB(edge(conv(i,j,1),0,1));\n\t\t\tgraph.add(0,conv(i,j,0),0,4);\n\t\t}\n\t\tREP(k,4){\n\t\t\tif(!isSafe(i+dy[k],j+dx[k])){\n\t\t\tgraph.add(conv(i,j,0),1,0,1);\n\t\t\t//\tedges[conv(i,j,0)].PB(edge(1,0,1));\n\t\t\t} \n\t\t\telse if(!maps[i+dy[k]][j+dx[k]]){\n\t\t\t\tgraph.add(conv(i,j,0),conv(i+dy[k],j+dx[k],1),0,1);\n\t\t\t\tgraph.add(conv(i+dy[k],j+dx[k],0),conv(i,j,1),0,1);\n//\t\t\t\tedges[conv(i,j,0)].PB(edge(conv(i+dy[k],j+dx[k],1),0,1));\n//\t\t\t\tedges[conv(i+dy[k],j+dx[k],0)].PB(edge(conv(i,j,1),0,1));\n\t\t\t}\n\t\t}\n\t\n\t}\n\tcout << graph.maximumFlow(0,1) << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n\tint h, w;\n\tcin >> h >> w;\n\tchar s[101][101];\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tcin >> s[i][j];\n\t\t}\n\t}\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tif(s[i][j] == 'X'){\n\t\t\t\tif(i == 0 || j == 0 || i == h - 1 || j == w - 1){\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\ts[i - 1][j] = '#';\n\t\t\t\ts[i][j - 1] = '#';\n\t\t\t\ts[i + 1][j] = '#';\n\t\t\t\ts[i][j + 1] = '#';\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<bool> > ischecked(101, vector<bool>(101, false));\n\tint sx[2] = {0, h - 1};\n\tint sy[2] = {0, w - 1};\n\tint dx[4] = {0, 1, 0, -1};\n\tint dy[4] = {1, 0, -1, 0};\n\tint ans = 0;\n\tfor(int i = 0; i < 2; i++){\n\t\tfor(int j = 0; j < 2; j++){\n\t\t\tif(ischecked[sx[i]][sy[j]]) continue;\n\t\t\tischecked[sx[i]][sy[j]] = true;\n\t\t\tqueue<pair<int, int> > qu;\n\t\t\tqu.push(make_pair(sx[i], sy[j]));\n\t\t\twhile(!qu.empty()){\n\t\t\t\tint x = (qu.front()).first;\n\t\t\t\tint y = (qu.front()).second;\n\t\t\t\tqu.pop();\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tint nx = x + dx[k];\n\t\t\t\t\tint ny = y + dy[k];\n\t\t\t\t\tif(nx < 0 || ny < 0 || nx >= h || ny >= w || ischecked[nx][ny]) continue;\n\t\t\t\t\tischecked[nx][ny] = true;\n\t\t\t\t\tif(s[nx][ny] == '#') ans++;\n\t\t\t\t\telse if(s[nx][ny] == '.') qu.push(make_pair(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 10000000\n#define MAXN 25000\n#define MAXD 200\n\nstruct Edge\n{\n    int t, c, r;\n};\n\nchar grid[MAXD+5][MAXD+5];\nint w, h;\nint prv[MAXN+5], vis[MAXN+5];\nvector<Edge> edge[MAXN+5];\n\nint get(int r, int c)\n{\n    if (r < 0 || r >= h || c < 0 || c >= w) return w*h*2+1;\n    return 2*(r*w+c);\n}\n\nint add(int f, int t, int c)\n{\n    Edge a = { t, c, (int)edge[t].size() };\n    Edge b = { f, 0, (int)edge[f].size() };\n    edge[f].push_back(a);\n    edge[t].push_back(b);\n}\n\nint maxflow(int n, int s, int t)\n{\n    int mf = 0;\n    while (true) {\n        queue<int> Q;\n        Q.push(s);\n        fill(vis, vis+n, false);\n        vis[s] = true;\n        while (!Q.empty()) {\n            int v = Q.front();\n            Q.pop();\n            for (int i = 0; i < edge[v].size(); ++i) {\n                Edge &e = edge[v][i];\n                if (!vis[e.t] && e.c > 0) {\n                    vis[e.t] = true;\n                    prv[e.t] = e.r;\n                    Q.push(e.t);\n                }\n            }\n        }\n        if (!vis[t]) break;\n        int flow = INF;\n        for (int v = t; v != s; v = edge[v][prv[v]].t) {\n            Edge &e = edge[v][prv[v]];\n            Edge &r = edge[e.t][e.r];\n            flow = min(flow, r.c);\n        }\n        for (int v = t; v != s; v = edge[v][prv[v]].t) {\n            Edge &e = edge[v][prv[v]];\n            Edge &r = edge[e.t][e.r];\n            e.c += flow;\n            r.c -= flow;\n        }\n        mf += flow;\n    }\n    return mf;\n}\n\nint main()\n{\n    scanf(\"%d%d\", &h, &w);\n    int s = 2*h*w, t = 2*h*w+1;\n    for (int i = 0; i < h; ++i) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < w; ++j) grid[i][j] = s[j];\n    }\n\n    int dr[] = {1,-1,0,0}, dc[] = {0,0,-1,1};\n    for (int r = 0; r < h; ++r) {\n        for (int c = 0; c < w; ++c) {\n            int idx = get(r,c);\n            if (grid[r][c] == 'X') {\n                add(s, idx, INF);\n                add(idx, idx+1, INF);\n            }\n            else add(idx, idx+1, 1);\n            for (int d = 0; d < 4; ++d) {\n                int nr = r+dr[d], nc = c+dc[d];\n                int nidx = get(nr, nc);\n                add(idx+1, nidx, INF);\n            }\n        }\n    }\n    int f = maxflow(2*h*w+2, s, t);\n    printf(\"%d\\n\", (f == INF) ? -1 : f);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <climits>\n#include <queue>\n#include <cstring>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#include <cstdio>\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#include <set>\n\nusing namespace std;\n\nchar g[128][128];\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\n#include <vector>\n\nstruct Edge{\n  int cap; // capacity\n  int to;\n  int rev; // reverse edge id\n\n  Edge(){}\n  Edge(int c, int t, int r) :\n    cap(c), to(t), rev(r){}\n};\n\ntemplate<class E> // Edge type\nclass Graph{\npublic:\n  typedef std::vector<std::vector<E> > G;\n\nprivate:\n  G g;\n\npublic:\n  Graph(int n) : g(G(n)) {}\n\n  void addEdge(int from, int to, int cap){\n    g[from].push_back(E(cap, to, g[to].size()));\n    g[to].push_back(E(0, from, g[from].size() - 1));\n  }\n\n  void addEdge(int from, int to, int cap, int cost){\n    g[from].push_back(E(cap, to, cost, g[to].size()));\n    g[to].push_back(E(0, from, -cost, g[from].size() - 1));\n  }\n\n  G &getRowGraph(){\n    return g;\n  }\n};\n\ntemplate<class E>\nclass Dinic{\n  typedef typename Graph<E>::G G;\n  G &g;\n  std::size_t n; // size of graph\n\n  std::vector<int> level;\n  std::vector<int> iter;\n\n  // other utilities\n\n  // search length of shortest path from s\n  void bfs(int s){\n    std::queue<int> que;\n    level = std::vector<int>(n, -1);\n\n    level[s] = 0;\n    que.push(s);\n\n    while(!que.empty()){\n      int v = que.front(); que.pop();\n      for(int i = 0; i < (int)g[v].size(); i++){\n        E &e = g[v][i];\n        if(e.cap > 0 && level[e.to] < 0){\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n\n  // search path\n  int dfs(int v, int t, int f){\n    if(v == t) return f;\n    for(int &i = iter[v]; i < (int)g[v].size(); i++){\n      E &e = g[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]){\n        int d = dfs(e.to, t, min(f, e.cap));\n        if(d > 0){\n          e.cap -= d;\n          g[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\npublic:\n  Dinic(Graph<E> &graph) : g(graph.getRowGraph()){\n    n = g.size();\n  }\n\n  // Max flow of the flow from s to t.\n  int solve(int s, int t){\n    int flow = 0;\n    while(true){\n      int f;\n      bfs(s);\n      if(level[t] < 0) return flow;\n      iter  = std::vector<int>(n, 0);\n      while((f = dfs(s, t, INT_MAX)) > 0){\n        flow += f;\n      }\n    }\n  }\n};\n\ntemplate<class E>\nint dinic(Graph<E> &g, int s, int d){\n  return Dinic<E>(g).solve(s, d);\n}\n\nint main(){\n  const int h = getInt();\n  const int w = getInt();\n  REP(i,h) scanf(\"%s\", g[i]);\n\n  bool ok = true;\n  REP(i,h) REP(j,w) if(g[i][j] == 'X'){\n    if(i == 0 || i == h - 1 || j == 0 || j == w - 1) ok = false;\n  }\n\n  if(!ok) {\n    puts(\"-1\");\n    return 0;\n  }\n\n  const int inf = 10000;\n  Graph <Edge> g(2 * h * w + 2);\n  const int src = 2 * h * w;\n  const int dst = src + 1;\n\n  REP(i,h) REP(j,w) {\n    const int p = 2 * (i * w + j);\n\n    g.addEdge(p, p + 1, 1);\n    REP(k,4) {\n      const int x = j + _dx[k];\n      const int y = i + _dy[k];\n\n      if(ISIN(x, y, w, h)) {\n        const int pp = 2 * (y * w + x);\n        g.addEdge(p + 1, pp, inf);\n      } else {\n        g.addEdge(p + 1, dst, inf);\n      }\n    }\n\n    if(::g[i][j] == 'X'){\n      g.addEdge(src, p + 1, inf);\n    }\n  }\n\n  const int ans = dinic(g, src, dst);\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<ut,VI> PQ;\nconst ut INF=1LL<<30;\nconst int SIZE=201;\nint maps[SIZE][SIZE];\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\ncli d[4];\nint solve(){\n\tREP(i,4) d[i]=cli(dy[i],dx[i]);\n\tint H,W;\n\tcin >> H >> W;\n\tqueue<cli> qu;\n\tREP(i,H){\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,W){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(maps[i][j]) qu.push(cli(j,i));\n\t\t}\n\t}\n\n\twhile(!qu.empty()){\n\t\tcli now=qu.front();\n\t\tqu.pop();\n\t\tif(maps[now.imag()][now.real()]==1){\n\t\t\t\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) return -1;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]==0){\n\t\t\t\t\tmaps[next.imag()][next.real()]=-1;\n\t\t\t\t\tqu.push(next);\n\t\t\t\t}\n\t\t\t//\tcout << next << endl;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint around=0;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) continue;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=0) around++;\n\t\t\t}\n\t\t\tif(around>=3){\n\t\t\t\tmaps[now.imag()][now.real()]=1;\n\t\t\t\tqu.push(now);\n\t\t\t}\n\t\t} \n\t\t\n\t}\n\tint ans=0;\n\tREP(i,H)\n\t\tREP(j,W){\n\t\t\tans+=maps[i][j]==-1;\n\t\t}\n\treturn ans;\n}\nint main(){\n\tcout << solve() << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define for(i, a, b) for(ll (i)=a;(i)<(b);++(i))\n#define rep(i, n)    for(i, 0, n)\n#define MAX_V        20004\n\nconst ll inf = 1e15;\nconst ll mod = 1e9+7;\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nstruct edge {\n    ll to, cap, rev;\n    edge(ll t, ll c, ll r): to(t), cap(c), rev(r){}\n};\n\nvector<edge> G[MAX_V];\nll level[MAX_V];\nll iter[MAX_V];\n\nvoid add_edge(ll from, ll to, ll cap) {\n    G[from].push_back(edge(to, cap, G[to].size()));\n    G[to].push_back(edge(from, 0, G[from].size() - 1));\n}\n\nvoid bfs(ll s) {\n    memset(level, -1, sizeof(level));\n    queue<ll> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n        ll v = que.front(); que.pop();\n        rep(i, G[v].size()) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nll dfs(ll v, ll t, ll f) {\n    if (v == t) return f;\n    for(i, iter[v], G[v].size()) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[v] < level[e.to]) {\n            ll d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nll max_flow(ll s, ll t) {\n    ll flow = 0;\n    while (true) {\n        bfs(s);\n        if (level[t] < 0) return flow;\n        memset(iter, 0, sizeof(iter));\n        ll f;\n        while ((f = dfs(s, t, inf)) > 0) {\n            flow += f;\n        }\n    }\n}\n\nint main() {\n    ll H, W; cin >> H >> W;\n    \n    ll S = 2 * H * W;\n    ll T = 2 * H * W + 1;\n    rep(i, H) rep(j, W) {\n        char c; cin >> c;\n        \n        ll in  = i * W + j;\n        ll out = H * W + in;\n        if (c == 'X') add_edge(S, in, inf), add_edge(in, out, inf);\n        else add_edge(in, out, 1);\n        \n        if (i == 0 || i == H-1 || j == 0 || j == W-1) add_edge(out, T, inf);\n        rep(k, 4) {\n            if (i+dy[k] < 0 || H-1 < i+dy[k] || j+dx[k] < 0 || W-1 < j+dx[k]) continue;\n            add_edge(H * W + i * W + j, (i+dy[k]) * W + (j+dx[k]), inf);\n            add_edge(H * W + (i+dy[k]) * W + (j+dx[k]), i * W + j, inf);\n        }\n    }\n    ll f = max_flow(S, T);\n    cout << (f < inf ? f : -1) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Network{\n\tprivate:\n\tint V;\n\tstruct edge{\n\t\tint to,cap,rev;\n\t};\n\tvector<vector<edge> > List;\n\tint DFSplus(int v,int t,int f,vi& iter,vi level){\n\t\tif(v==t) return f;\n\t\tfor(int &i=iter[v];i<List[v].size();i++){\n\t\t\tedge &e=List[v][i];\n\t\t\tif(e.cap>0&&level[v]<level[e.to]){\n\t\t\t\tint d=DFSplus(e.to,t,min(f,e.cap),iter,level);\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tList[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid BFSplus(int s,vi& level){\n\t\tlevel=vi(V,-1);\n\t\tqueue<int> que;\n\t\tlevel[s]=0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<List[v].size();i++){\n\t\t\t\tedge &e=List[v][i];\n\t\t\t\tif(e.cap>0&&level[e.to]<0){\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic:\n\tNetwork(int v){\n\t\tV=v;\n\t\tList=vector<vector<edge> >(v);\n\t}\n\tvoid add_edge(int s,int t,int c){\n\t\tList[s].push_back(edge{t,c,(int)List[t].size()});\n\t\tList[t].push_back(edge{s,0,(int)List[s].size()-1});\n\t}\n\tint MFplus(int s,int t){\n\t\tint ans=0;\n\t\twhile(1){\n\t\t\tvi iter(V),level;\n\t\t\tBFSplus(s,level);\n\t\t\tif(level[t]<0) return ans;\n\t\t\tint f;\n\t\t\twhile((f=DFSplus(s,t,inf,iter,level))>0) ans+=f;\n\t\t}\n\t}\n};\n\nint h,w;\nvvc a;\n\ninline int f(int x,int y){\n\treturn x*w+y;\n}\n\nint main(){\n\tcin>>h>>w;\n\ta=vvc(h,vc(w));\n\tNetwork nt(2*h*w+2);\n\tbool flag=1;\n\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++){\n\t\tcin>>a[i][j];\n\t\tif(a[i][j]=='X') nt.add_edge(2*h*w,h*w+f(i,j),inf);\n\t\telse nt.add_edge(f(i,j),h*w+f(i,j),1);\n\t\tif(!i||i==h-1||!j||j==w-1){\n\t\t\tnt.add_edge(h*w+f(i,j),2*h*w+1,inf);\n\t\t\tif(a[i][j]=='X') flag=0;\n\t\t}\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint x=i+dx[k],y=j+dy[k];\n\t\t\tif(x>=0&&x<h&&y>=0&&y<w) nt.add_edge(h*w+f(i,j),f(x,y),inf);\n\t\t}\n\t}\n\tif(!flag){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tcout<<nt.MFplus(2*h*w,2*h*w+1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr,Vpr> PQ;\nconst int INF=1<<30;\nstruct Edge{\npublic:\n\tint to,cost,cp;\n\tEdge *rev;\n\tEdge(int t,int c,int cp):to(t),cost(c),cp(cp){\n\t\t\n\t}\n\tvoid add(int x){\n\t\tcp+=x;\n\t}\n\tvoid flow(int amount){\n\t\tadd(-amount);\n\t\trev->add(amount);\n\t}\n\tbool usable(){\n\t\treturn cp>=1;\n\t}\t\n};\nvoid unite(Edge &a,Edge &b){\n\ta.rev=&b;\n\tb.rev=&a;\n}\nclass Graph{\n\tint nodeSize,edgeSize;\n\tvector<int> dist;\n\tvector<vector<Edge> > edges;\npublic: \n\tvoid add(int a,int b,int cost,int cp){\n\t\tedges[a].PB(Edge(b,cost,cp));\n\t\tedges[b].PB(Edge(a,cost,0));\n\t\tunite(edges[a].back(),edges[b].back());\n\t}\n\tGraph(int x):nodeSize(x){\n\t\t\n\t\tedges=vector<vector<Edge> >(nodeSize);\n\t\tdist=VI(nodeSize);\n\t}\n\tvoid distInit(int s){\n\t\tREP(i,nodeSize){\n\t\t\tdist[i]=INF;\n\t\t}\n\t\tdist[s]=0;\n\t}\n\tint searching(int now,int e,int capacity){\n\t\tif(now==e) return capacity;\n\t\tif(capacity==0) return 0;\n\t\tif(dist[now]>=dist[e]) return 0;\n\t\tint flowed=0;\n\t\tREP(i,edges[now].size()){\n\t\t\tEdge *ed= &edges[now][i];\n\t\t\tif(dist[now]+1 != dist[ed->to]) continue;\n\t\t\tint nflow=searching(ed->to,e,min(capacity-flowed,ed->cp));\n\t\t\tif(nflow){\n\t\t\t\tflowed+=nflow;\n\t\t\t\ted->flow(nflow);\n\t\t\t}\n\t\t}\n\t\treturn flowed;\n\t}\n\tbool bfs(int s,int e){\n\t\tdistInit(s);\n\t\tqueue<int> qu;\n\t\tqu.push(s);\n\t\twhile(!qu.empty()){\n\t\t\tint now=qu.front();\n\t\t\tif(now==e) return true;\n\t\t\tqu.pop();\n\t\t\tREP(i,edges[now].size()){\n\t\t\t\tEdge *ed= &edges[now][i];\n\t\t\t\tif(!ed->usable()) continue;\n\t\t\t\tif(dist[ed->to]==INF){\n\t\t\t\t\tqu.push(ed->to);\n\t\t\t\t\tdist[ed->to]=dist[now]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint maximumFlow(int s,int e){\n\t\tint ans=0;\n\t\twhile(bfs(s,e)){\n\t\t\tans+=searching(s,e,INF);\n\t\t}\n\t\treturn ans;\n\t}\n};\nconst int SIZE=101;\nint conv(int a,int b,int c){return a*100+b+SIZE*SIZE*c+2;}\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\nint H,W;\nint maps[101][101];\nbool isSafe(int y,int x){\n\treturn 0<=y && y<H && 0<=x && x<W;\n}\nint main(){\n\tGraph graph(SIZE*SIZE*2+2);\n\tcin >> H >> W;\n\tREP(i,H) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,s.size()){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(maps[i][j] &&(i==0 || j==0 || i==H-1 || j==W-1)){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\t\t\n\t}\n\tREP(i,H) REP(j,W) {\n\t\tgraph.add(conv(i,j,1),conv(i,j,0),0,1);\n//\t\tedges[conv(i,j,1)].PB(edge(conv(i,j,0),0,1));\n\t\tif(maps[i][j]){\n\t\t\t//edges[0].PB(edge(conv(i,j,1),0,1));\n\t\t\tgraph.add(0,conv(i,j,0),0,4);\n\t\t}\n\t\tREP(k,4){\n\t\t\tif(!isSafe(i+dy[k],j+dx[k])){\n\t\t\tgraph.add(conv(i,j,0),1,0,1);\n\t\t\t//\tedges[conv(i,j,0)].PB(edge(1,0,1));\n\t\t\t} \n\t\t\telse if(!maps[i+dy[k]][j+dx[k]]){\n\t\t\t\tgraph.add(conv(i,j,0),conv(i+dy[k],j+dx[k],1),0,1);\n\t\t\t\tgraph.add(conv(i+dy[k],j+dx[k],0),conv(i,j,1),0,1);\n//\t\t\t\tedges[conv(i,j,0)].PB(edge(conv(i+dy[k],j+dx[k],1),0,1));\n//\t\t\t\tedges[conv(i+dy[k],j+dx[k],0)].PB(edge(conv(i,j,1),0,1));\n\t\t\t}\n\t\t}\n\t\n\t}\n\tcout << graph.maximumFlow(0,1) << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&b) { if (a > b)a = b; }\ntemplate<class T> void cmax(T &a, const T&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\numap<ti3, ll> memo;\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//速度ではなくメモリ効率を考えるならrankのかわりにsizeを使う\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\nint main() {\n\tvi d = { 0,1,0,-1,0 };\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> s(h);\n\trep(i, h)cin >> s[i];\n\tbool err = 0;\n\tfor (auto a : s.front())if (a == 'X')err = 1;\n\tfor (auto a : s.back())if (a == 'X')err = 1;\n\tfor (auto &a : s) {\n\t\tif (a.back() == 'X' || a.front() == 'X')err = 1;\n\t}\n\tif (err) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tbool up2 = 1;\n\tbool up = 1;\n\twhile (up) {\n\t\tup = 0;\n\t\trep1(i, h - 2)rep1(j, w - 2) {\n\t\t\tif (s[i][j] != 'X') {\n\t\t\t\tint cnt = 0;\n\t\t\t\trep(k, 4)if (s[i + d[k]][j + d[k+1]] != '.' )cnt++;\n\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\tup = 1;\n\t\t\t\t\ts[i][j] = 'X';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[i][j] == 'X') {\n\t\t\t\trep(k, 4)if (s[i + d[k]][j + d[k+1]] == '.') {\n\t\t\t\t\ts[i + d[k]][j + d[k+1]] = '#';\n\t\t\t\t\tup = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0;\n\trep(i, h)rep(j, w)if (s[i][j] == '#')cnt++;\n\tint prev = cnt;\n\twhile (up2) {\n\t\tup2=0;\n\t\trep1(i, h - 2)rep1(j, w - 2) {\n\t\t\tauto s2(s);\n\t\t\tif (s[i][j] == '.') {\n\t\t\t\tint cnt = 0;\n\t\t\t\trep(k, 4)if (s2[i + d[k]][j + d[k + 1]] != '.')cnt++;\n\t\t\t\tif (cnt >= 2) {\n\t\t\t\t\ts2[i][j] = 'X';\n\t\t\t\t}\n\t\t\t\telse if(cnt){\n\t\t\t\t\tif(i<h-2)rep(k,4)if (s2[i + d[k]+1][j + d[k + 1]] != '.')cnt++;\n\t\t\t\t\tif (cnt >= 2)s2[i][j] = s2[i + 1][j] = 'X';\n\t\t\t\t\telse if (j<w - 2)rep(k, 4)if (s2[i + d[k]][j + d[k + 1]+1] != '.')cnt++;\n\t\t\t\t\tif (cnt >= 2)s2[i][j] = s2[i][j+1] = 'X';\n\t\t\t\t}\n\t\t\t\telse continue;\n\t\t\t}\n\t\t\tup = 1;\n\t\t\twhile (up) {\n\t\t\t\tup = 0;\n\t\t\t\trep1(i, h - 2)rep1(j, w - 2) {\n\t\t\t\t\tif (s2[i][j] != 'X') {\n\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\trep(k, 4)if (s2[i + d[k]][j + d[k + 1]] != '.')cnt++;\n\t\t\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\t\t\tup = 1;\n\t\t\t\t\t\t\ts2[i][j] = 'X';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (s2[i][j] == 'X') {\n\t\t\t\t\t\trep(k, 4)if (s2[i + d[k]][j + d[k + 1]] == '.') {\n\t\t\t\t\t\t\ts2[i + d[k]][j + d[k + 1]] = '#';\n\t\t\t\t\t\t\tup = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt = 0;\n\t\t\trep(i, h)rep(j, w)if (s2[i][j] == '#')cnt++;\n\t\t\tif (cnt <= prev)s = s2, prev = cnt, up2 = 1;\n\t\t}\n\t}\n\tcout << prev << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n//#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105],z[105][105];\nbool fr[105][105],vis[105][105],st,ad,f;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\tint a,b;\n\trap(ii,n,1)rap(jj,m,1){\n\t\tif(z[ii][jj]=='X'){\n\t\t\trep(kk,0,3)if(x[ii+dr[kk]][jj+dc[kk]]=='.')x[ii+dr[kk]][jj+dc[kk]] = '#';\n//\t\t\tcout<<ii<<' '<<jj<<endl;\n\t\t}\n\t\telse continue;\n\t\tsolve();\n\t\tans = tmp;\n\t\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\t\tst = 1;\n\t\twhile(st){\n\t\t\tst = 0;\n\t\t\trep(i,1,n)rep(j,1,m){\n\t\t\t\ta = i, b = j;\n\t\t\t\trep(k,1,1){\n\t\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\t\tif(k==1){\n\t\t\t\t\t\tad = 0, f = 1;\n\t\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(f){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t++a,++b;\n\t\t\t\t}\n\t\t\t\ta = i, b = j;\n\t\t\t\trep(k,1,1){\n\t\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\t\tif(k==1){\n\t\t\t\t\t\tad = 0, f = 1;\n\t\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(f){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t++a,--b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tcout<<endl;\n//\t\trep(i,1,n){\n//\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\tcout<<endl;\n//\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nint H, W;\nstring s[110];\n\nconst int MAX_V = 20100; //必要な頂点数\nstruct Flow{\n    struct edge{\n        int to, cap, rev;\n    };\n    vector<edge> G[MAX_V];//隣接リスト\n    bool used[MAX_V];\n \n    void add_edge(int from, int to, int cap){\n        G[from].push_back((edge){to, cap, (int)G[to].size()});//from -> to\n        G[to].push_back((edge){from, 0, (int)G[from].size() - 1});//to -> from\n    }\n    //増加パスを探す\n    int dfs(int v, int t, int f){\n        if(v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); ++i){\n            edge &e = G[v][i];\n            if(!used[e.to] && e.cap > 0){\n                int d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0){\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    //sからtへの最大流\n    int max_flow(int s, int t){\n        int flow = 0;\n        while(1){\n            memset(used, 0, sizeof(used));\n            int f = dfs(s, t, INF);\n            if(f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, 1, 0, -1};\n\nint main(void) {\n\tscanf(\"%d %d\", &H, &W);\n\trep(i, H) cin >> s[i];\n\tint start = 2 * (H * W) + 1, goal = 2 * (H * W) + 2;\n\tint N = H * W;\n\n\tbool flag = false;\n\trep(i, H)rep(j, W){\n\t\tif((i == 0 || i == H - 1 || j == 0 || j == W - 1) && s[i][j] == 'X')\n\t\t\tflag = true;\n\t}\n\tif(flag){\n\t\tprintf(\"-1\\n\"); return 0;\n\t}\n\n\tFlow fw;\n\trep(i, H)rep(j, W){\n\t\tint u = i + 100 * j;\n\t\tif(s[i][j] == 'X') {\n\t\t\tfw.add_edge(start, u, INF);\n\t\t\tfw.add_edge(u, u + N, INF);\n\t\t}else{\n\t\t\tfw.add_edge(u, u + N, 1);\n\t\t}\n\t\tif(i == 0 || i == H - 1 || j == 0 || j == W - 1){\n\t\t\tfw.add_edge(u + N, goal, INF);\n\t\t}\n\t}\n\trep(i, H)rep(j, W)rep(k, 4){\n\t\tint y = i, x = j;\n\t\tint ny = y + dy[k], nx = x + dx[k];\n\t\tif(!(0 <= ny && ny < H && 0 <= nx && nx < W)) continue;\n\t\tint u = y + 100 * x, v = ny + 100 * nx;\n\t\tfw.add_edge(N + u, v, INF);\n\t}\n\n\tint ret = fw.max_flow(start, goal);\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 105\n#define M 51\n#define INF 1000000007\n#define MOD 924844033\n#define MOD2 1000000009\n#define eps 1e-14\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,1,-1};\nstruct node\n{\n    int from,to,x,y;\n}edge[60*N*N];\nvector<int>e[60*N*N];\nint a[N][N],b[N][N],q[60*N*N],d[60*N*N];\nint bg,ed,cnt;\n\nbool bfs(int s)\n{\n       int front=0,rear=0;\n       memset(d,-1,sizeof(d));\n       q[rear++]=s;\n       d[s]=0;\n       while(front<rear)\n       {\n               int k=q[front++];\n               for(int i = 0;i<e[k].size();i++)\n               {\n                   int v = e[k][i];\n                   int from = edge[v].from,to = edge[v].to;\n                   int x = edge[v].x,y = edge[v].y;\n                   int flow,nxt;\n                   if(from == k)flow = x,nxt = to;\n                   else flow = y,nxt = from;\n                   if(flow>0&&d[nxt]==-1)\n                   {\n                       d[nxt]=d[k]+1;\n                       q[rear++]=nxt;\n                   }\n               }\n       }\n       if(d[ed]>=0)\n             return true;\n       return false;\n}\n\nint dinic(int k,int sum)  //k is the sourse\n{\n      if (k==ed)\n          return sum;\n      int os = sum;\n      for(int i = 0;i<e[k].size();i++)\n      {\n          if(sum<=0)break;\n          int v = e[k][i];\n          int from = edge[v].from,to = edge[v].to;\n           int x = edge[v].x,y = edge[v].y;\n           int flow,nxt;\n           if(from == k)flow = x,nxt = to;\n           else flow = y,nxt = from;\n          if(d[to]==d[k]+1&&flow>0)\n          {\n                int tmp = dinic(to,min(sum,flow)); //Deep to the end.\n                if(from == k)\n                {\n                    edge[v].x -= tmp;\n                    edge[v].y += tmp;\n                }\n                else\n                {\n                    edge[v].y -= tmp;\n                    edge[v].x += tmp;\n                }\n                sum -= tmp;\n          }\n      }\n      return os-sum;\n}\n\nvoid addedge(int from,int to,int w)\n{\n    edge[++cnt].from = from;\n    edge[cnt].to = to;\n    edge[cnt].x = w;\n    edge[cnt].y = 0;\n    e[from].PB(cnt);\n    e[to].PB(cnt);\n}\nint main()\n{\n    //freopen(\"out.txt\",\"r\",stdin);\n    //freopen(\"1.txt\",\"w\",stdout);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    while(cin>>n>>m)\n    {\n        cnt = 0;\n        bg = 1,ed = n*m*2+1;\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                a[i][j] = i*m+j;\n                b[i][j] = i*m+j+n*m;\n            }\n        }\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                char c;\n                cin>>c;\n                if(c == 'X')\n                {\n                    addedge(a[i][j],b[i][j],INF);\n                    addedge(1,a[i][j],INF);\n                }\n                else addedge(a[i][j],b[i][j],1);\n            }\n        }\n        FOR(i,1,n)\n        {\n            addedge(b[i][1],ed,INF);\n            addedge(b[i][m],ed,INF);\n            FOR(j,1,m-1)addedge(b[i][j],a[i][j+1],INF);;\n            FOR(j,2,m)addedge(b[i][j],a[i][j-1],INF);\n        }\n        FOR(j,1,m)\n        {\n            addedge(b[1][j],ed,INF);\n            addedge(b[n][j],ed,INF);\n            FOR(i,1,n-1)addedge(b[i][j],a[i+1][j],INF);\n            FOR(i,2,n)addedge(b[i][j],a[i-1][j],INF);\n        }\n        int ret = 0;\n        while(bfs(bg))\n        {\n            cout<<ret<<endl;\n           ret += dinic(bg,INF);\n        }\n\n        if(ret == INF)cout<<-1<<endl;\n        else cout<<ret<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define for(i, a, b) for(ll (i)=a;(i)<(b);++(i))\n#define rep(i, n)    for(i, 0, n)\n#define MAX_V        20004\n\nconst ll inf = 1e15;\nconst ll mod = 1e9+7;\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nstruct edge {\n    ll to, cap, rev;\n    edge(ll t, ll c, ll r): to(t), cap(c), rev(r){}\n};\n\nvector<edge> G[MAX_V];\nll level[MAX_V];\nll iter[MAX_V];\n\nvoid add_edge(ll from, ll to, ll cap) {\n    G[from].push_back(edge(to, cap, G[to].size()));\n    G[to].push_back(edge(from, 0, G[from].size() - 1));\n}\n\nvoid bfs(ll s) {\n    memset(level, -1, sizeof(level));\n    queue<ll> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n        ll v = que.front(); que.pop();\n        rep(i, G[v].size()) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nll dfs(ll v, ll t, ll f) {\n    if (v == t) return f;\n    for(i, iter[v], G[v].size()) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[v] < level[e.to]) {\n            ll d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nll max_flow(ll s, ll t) {\n    ll flow = 0;\n    while (true) {\n        bfs(s);\n        if (level[t] < 0) return flow;\n        memset(iter, 0, sizeof(iter));\n        ll f;\n        while ((f = dfs(s, t, inf)) > 0) {\n            flow += f;\n        }\n    }\n}\n\nint main() {\n    ll H, W; cin >> H >> W;\n    \n    ll S = 2 * H * W;\n    ll T = 2 * H * W + 1;\n    rep(i, H) rep(j, W) {\n        char c; cin >> c;\n        if (c == 'X' && (i == 0 || i == H-1 || j == 0 || j == W-1)) {\n            cout << -1 << endl;\n            return 0;\n        }\n        \n        if (c == 'X') add_edge(S, i * W + j, inf);\n        add_edge(i * W + j, H * W + i * W + j, c == 'X' ? inf : 1);\n        \n        if (i == 0 || i == H-1 || j == 0 || j == W-1) add_edge(H * W + i * W + j, T, inf);\n        rep(k, 4) {\n            if (i+dy[k] < 0 || H-1 < i+dy[k] || j+dx[k] < 0 || W-1 < j+dx[k]) continue;\n            add_edge(H * W + i * W + j, (i+dy[k]) * W + (j+dx[k]), inf);\n        }\n    }\n    ll f = max_flow(S, T);\n    cout << (f < inf ? f : -1) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(´・ω・`)(´・ω・`)(´・ω・`)(´・ω・`)(´・ω・`)(´・ω・`)///\nstruct edge { int to, cap, rev, cost; };\n\nconstexpr int MAX_V = 20002;\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost = 0) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n}\n\nvoid bfs(int s) {\n\tfill_n(level, MAX_V, -1);\n\tqueue<int> q;\n\tlevel[s] = 0;\n\tq.push(s);\n\twhile (!q.empty()) {\n\t\tint v = q.front(); q.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nll dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nll max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0)return flow;\n\t\tfill_n(iter, MAX_V, 0);\n\t\tll f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> v(h);\n\tREP(i, h)cin >> v[i];\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tREP(k, 4) {\n\t\t\t\tint ni = i + dy[2*k], nj = j + dx[2*k];\n\t\t\t\tif (ni < 0 || ni == h || nj < 0 || nj == w) {\n\t\t\t\t\tadd_edge(i*w + j + 1+h*w, 2*h*w + 1, 1000000);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tadd_edge(i*w + j + 1+h*w, ni*w + nj + 1, 1);\n\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (v[i][j] == 'X') {\n\t\t\t\tadd_edge(0, i*w + j + 1, 1000000);\n\t\t\t\tadd_edge(i*w + j + 1, i*w + j + 1 + w*h, 1000000);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i*w + j + 1, i*w + j + 1 + w*h, 1);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tll ans = max_flow(0, 2 * w*h + 1);\n\tif (ans >= 100000)cout << -1 << endl;\n\telse cout<<ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <stdio.h>\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n#include <limits.h>\n#include <math.h>\n#include <algorithm>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <list>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <functional>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef double db;\ntypedef long double ldb;\n#define rep(i,a,b) for(i=a;i<b;i++)\n#define repu(i,a,b) for(i=a;i<=b;i++)\n#define repd(i,a,b) for(i=a;i>=b;i--)\n#define repc(i,a,b,c) for(i=a;i<b;i+=c)\n#define repcu(i,a,b,c) for(i=a;i<=b;i+=c)\n#define repcd(i,a,b,c) for(i=a;i>=b;i-=c)\n#define FIN freopen(\"input.in\",\"r\",stdin)\n#define FOUT freopen(\"output.out\",\"w\",stdout)\n#define CC(a) memset(a,0,sizeof(a))\n#define MST(a,b) memset(a,b,sizeof(a))\n#define PII pair<int,int>\n#define PLL pair<LL,LL>\n#define VI vector<int>\n#define VL vector<long long>\n#define VII vector<PII>\n#define VLL vector<PLL>\n#define all(x) x.begin(),x.end()\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n \ntemplate<typename T>inline void gn(T &x){\n\tx=0;T f=1;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\tx*=f;\n}\ntemplate<typename T>inline void gt(T x){\n\tif(!x)return;\n\tgt(x/10);putchar(x%10+'0');\n}\n \nconst LL N=1e6+5;\nLL t,n,m,ans;\nLL MOD=1e9+7,inf=0x1f1f1f1f;\ndb eps=1e-5;\n\nLL dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nchar a[111][111],b[111][111],vis[111][111];\nqueue<PLL > q;\n\nvoid bfs(LL x,LL y){\n\tLL i,j,k,l;\n\tq.push(mp(x,y));vis[x][y]=1;\n\twhile(!q.empty()){\n\t\tPLL p=q.front();q.pop();\n\t\trepu(i,0,3){\n\t\t\tx=p.first+dx[i];\n\t\t\ty=p.second+dy[i];\n\t\t\tif(x<1||x>n||y<1||y>m)continue;\n\t\t\tif(b[x][y]=='.'&&!vis[x][y])vis[x][y]=1,q.push(mp(x,y));\n\t\t}\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);cin.tie(0);\n\tLL i,j,k,l,ca=0,x,y;\n\tcin>>n>>m;\n\tMST(a,'.');MST(b,'.');\n\trepu(i,1,n){\n\t\tcin>>a[i]+1;\n\t\trepu(j,1,m){\n\t\t\tif(a[i][j]=='X'){\n\t\t\t\tif(i==1||i==n||j==1||j==m)return cout<<\"-1\",0;\n\t\t\t\trepu(k,0,3){\n\t\t\t\t\tx=i+dx[k];\n\t\t\t\t\ty=j+dy[k];\n\t\t\t\t\tb[x][y]='X';\n\t\t\t\t}\n\t\t\t\tb[i][j]='X';\n\t\t\t}\n\t\t}\n\t}\n\trepu(i,1,n)repu(j,1,m){\n\t\tif((i!=1&&i!=n)&&(j!=1&&j!=m))continue;\n\t\t//if(i==1||i==n||j==1||j==m)\n\t\t{\n\t\t\tif(b[i][j]=='.'&&!vis[i][j])bfs(i,j);\n\t\t}\n\t}\n\trepu(i,1,n)repu(j,1,m){\n\t\tif(!vis[i][j]&&b[i][j]=='.')b[i][j]='X';\n\t} \n\t//cout<<endl;\n\trepu(i,1,n){\n\t\t//b[i][m+1]='\\0';\n\t\t//cout<<b[i]+1<<endl;\n\t\trepu(j,1,m){\n\t\t\tif(b[i][j]=='X'){\n\t\t\t\tl=0;\n\t\t\t\trepu(k,0,3){\n\t\t\t\t\tx=i+dx[k];\n\t\t\t\t\ty=j+dy[k];\n\t\t\t\t\tif(b[x][y]=='.'){\n\t\t\t\t\t\tl=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans+=l;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n/*\n\n10 10\n..........\n....X.....\n...X.X....\n....X.X...\n..........\n......X...\n..X.......\n..........\n.....X....\n..........\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vin=vector<int>;\nusing vll=vector<long long>;\nusing vvin=vector<vector<int>>;\nusing vvll=vector<vector<long long>>;\nusing vstr=vector<string>;\nusing vvstr=vector<vector<string>>;\nusing vch=vector<char>;\nusing vvch=vector<vector<char>>;\nusing vbo=vector<bool>;\nusing vvbo=vector<vector<bool>>;\nusing vpii=vector<pair<int,int>>;\nusing pqsin=priority_queue<int,vector<int>,greater<int>>;\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep2(i,s,n) for(int i=(s);i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define decp(n) cout<<fixed<<setprecision((int)n)\nconst int inf=1e9+7;\nconst ll INF=1e18;\n\nstruct edge{int to;ll cap;int rev;};\n\nint MAX_V=20050;\nint tmp1,tmp2;\n\nvector<vector<edge>> g(MAX_V);//グラフの隣接リスト表現\nvin level(MAX_V);//distance form s\nvin iter(MAX_V);//どこまで調べたか\n\nvoid add_edge(int from,int to,ll cap=(ll)inf){\n    tmp1=g[to].size();tmp2=g[from].size();\n    g[from].push_back((edge){to,cap,tmp1});//g[to]のg[to].size()番目にfromが入っている\n    g[to].push_back((edge){from,0,tmp2});//g[from]のg[from].size()-1番目にtoが入っている\n}\n\nvoid bfs(int s){\n    fill(all(level),-1);\n    queue<int> q;\n    q.push(s);\n    level[s]=0;\n    while(q.size()){\n        int v=q.front();q.pop();\n        for(auto& e:g[v]){\n            if(e.cap>0&&level[e.to]<0){\n                level[e.to]=level[v]+1;\n                q.push(e.to);\n            }\n        }\n    }\n}\n\n//増加パスをdfsで探す\n//v:今見てる頂点 t:終点 f:流量\nint dfs(int v,int t,ll f){\n    if(v==t)return f;\n    for(int& i=iter[v];i<(int)g[v].size();i++){\n        edge& e=g[v][i];\n        if(e.cap>0&&level[v]<level[e.to]){\n            ll d=dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                g[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n//sからtへの最大流を求める\nint max_flow(int s,int t){\n    ll flow=(ll)0;\n    ll f;\n    for(;;){\n        bfs(s);\n        if(level[t]<0)return flow;\n        fill(all(iter),0);\n        while((f=dfs(s,t,inf))>0)flow+=f;\n    }\n}\n\nint main(){\n    int h,w;cin>>h>>w;\n    vstr S(h);\n    rep(i,h)cin>>S[i];\n    //各マスinとoutを2つ用意\n    //(i,j)のinは2(i*w+j)で, outは2(i*w+j)+1で表される\n    int s=2*h*w;//s→ヤギ\n    int t=s+1;//追加したグリッドのマス(ゴール)→t\n    int tmp;\n    rep(i,h)rep(j,w){\n        tmp=2*(i*w+j);\n        if(S[i][j]=='X'){\n            if(i==0||i==h-1||j==0||j==w-1){\n                cout<<-1<<endl;\n                return 0;\n            }\n            add_edge(tmp,tmp+1);\n            add_edge(s,tmp+1);\n        }\n        else add_edge(tmp,tmp+1,(ll)1);\n        if(i>0)add_edge(tmp+1,tmp-2*w);\n        if(i<h-1)add_edge(tmp+1,tmp+2*w);\n        if(j>0)add_edge(tmp+1,tmp-2);\n        if(j<w-1)add_edge(tmp+1,tmp+2);\n        if(i==0||i==h-1||j==0||j==w-1)add_edge(tmp+1,t);\n    }\n    cout<<max_flow(s,t)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nbool isImpossible(std::vector<std::string> grid) {\n\t// ヤギが外周にいる場合はどうやっても無理\n\tint h = grid.size(), w = grid[0].size();\n\tfor (int i = 0; i < h; i++) {\n\t\tif (grid[i][0] == 'X' || grid[i][w - 1] == 'X') return true;\n\t}\n\tfor (int i = 0; i < w; i++) {\n\t\tif (grid[0][i] == 'X' || grid[h - 1][i] == 'X') return true;\n\t}\n\treturn false;\n}\n\nbool outSide(int x, int y, int h, int w) {\n\tif (x == 0 || x == h - 1 || y == 0 || y == w - 1) return true;\n\treturn false;\n}\n\nbool isInside(int x, int y, int h, int w) {\n\tif (0 <= x && x < h && 0 <= y && y < w) return true;\n\treturn false;\n}\n\nbool solve(std::vector<std::string> grid, std::vector<std::pair<int, int> > yagi_pos) {\n\tstd::queue<std::pair<int, int> > q;\n\tint x_index[] = { 0,1,-1,0 },\n\t\ty_index[] = { 1,0,0,-1 };\n\tint h = grid.size(), w = grid[0].size();\n\tstd::vector<std::vector<bool> > visited(h, std::vector<bool>(w, false));\n\twhile (!yagi_pos.empty()) {\n\t\tq.push(yagi_pos.front());\n\t\twhile (!q.empty()) {\n\t\t\tint x = q.front().first,\n\t\t\t\ty = q.front().second;\n\t\t\tq.pop();\n\t\t\tif (visited[x][y]) continue;\n\t\t\tif (outSide(x, y, h, w)) return false;\n\t\t\tvisited[x][y] = true;\n\t\t\tif (grid[x][y] == 'X') {\n\t\t\t\tyagi_pos.erase(std::find(yagi_pos.begin(), yagi_pos.end(), std::make_pair(x, y)));\n\t\t\t}\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tif (isInside(x + x_index[i], y + y_index[i], h, w)) {\n\t\t\t\t\tif (grid[x + x_index[i]][y + y_index[i]] != '#') {\n\t\t\t\t\t\tq.push({ x + x_index[i], y + y_index[i] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\tint h, w;\n\n\tstd::cin >> h >> w;\n\n\tstd::vector<std::string> grid(h);\n\n\tfor (int i = 0; i < h; i++) {\n\t\tstd::cin >> grid[i];\n\t}\n\n\tif (isImpossible(grid)) {\n\t\tstd::cout << -1 << std::endl;\n\t\treturn 0;\n\t}\n\n\tstd::vector<std::pair<int, int> > yagi_pos;\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (grid[i][j] == '.') grid[i][j] = '#';\n\t\t\tif (grid[i][j] == 'X') yagi_pos.push_back({ i, j });\n\t\t}\n\t}\n\n\tstd::vector<int> dirct = { 1, w, -1, -w };\n\tint pos = w - 1, p = 1;\n\tstd::vector<std::vector<bool> > visited(h, std::vector<bool>(w, false));\n\n\tfor (int i = 0; i < w; i++) {\n\t\tstd::vector<std::string> tmp_grid = grid;\n\t\ttmp_grid[0][i] = '.';\n\t\tif (solve(tmp_grid, yagi_pos)) {\n\t\t\tgrid[0][i] = '.';\n\t\t}\n\t\tvisited[0][i] = true;\n\t}\n\n\t\n\n\twhile (true) {\n\t\twhile(true) {\n\t\t\tint x = pos / w, y = pos % w;\n\t\t\t//std::cout << x << \" \" << y << std::endl;\n\t\t\tif (grid[x][y] == 'X') {\n\t\t\t\tpos += dirct[p];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstd::vector<std::string> tmp_grid = grid;\n\t\t\ttmp_grid[x][y] = '.';\n\t\t\tif (solve(tmp_grid, yagi_pos)) {\n\t\t\t\tgrid[x][y] = '.';\n\t\t\t}\n\t\t\tif (!isInside((pos + dirct[p]) / w, (pos + dirct[p]) % w, h, w) || visited[(pos + dirct[p]) / w][(pos + dirct[p]) % w] == true) break;\n\t\t\tvisited[x][y] = true;\n\t\t\tpos += dirct[p];\n\t\t}\n\t\tp = (p + 1) % 4;\n\t\tif (!isInside((pos + dirct[p]) / w, (pos + dirct[p]) % w, h, w) || visited[(pos + dirct[p]) / w][(pos + dirct[p]) % w] == true) break;\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\t//std::cout << grid[i][j] << \" \";\n\t\t\tif (grid[i][j] == '#') ans++;\n\t\t}\n\t\t//std::cout << std::endl;\n\t}\n\n\tstd::cout << ans << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n#define INF 1<<30\n\nclass MaxFlow {\n    // 辺を表す構造体（行き先、容量、逆辺）\n    struct edge {\n        int to, cap, rev;\n    };\n    vector<vector<edge>> G;  // グラフの隣接リスト表現\n    vector<int> level;       // sからの距離\n    vector<int> iter;        // どこまで調べ終わったか\n\n    // sからの最短距離をBFSで計算する\n    void bfs(int s) {\n        fill(level.begin(), level.end(), -1);\n        queue<int> que;\n        level[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            for(auto &e : G[v]){\n                if (e.cap > 0 && level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    // 増加パスをDFSで探す\n    int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        for (int &i = iter[v]; i < G[v].size(); i++) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && level[v] < level[e.to]) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    MaxFlow(int V) : G(V), level(V), iter(V) {}\n\n    // from から to へ向かう容量 cap の辺をグラフに追加する\n    void add_edge(int from, int to, int cap) {\n        G[from].push_back((edge){to, cap, static_cast<int>(G[to].size())});\n        G[to].push_back((edge){from, 0, static_cast<int>(G[from].size()) - 1});\n    }\n    // s から t への最大流を計算する\n    int max_flow(int s, int t) {\n        int flow = 0;\n        while (bfs(s), level[t] >= 0) {\n            fill(iter.begin(), iter.end(), 0);\n            int f;\n            while ((f = dfs(s, t, INF)) > 0) flow += f;\n        }\n        return flow;\n    }\n};\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main(){\n    int H, W;\n    cin >> H >> W;\n    vector<string> S(H);\n    for(int i=0; i<H; i++) cin >> S[i];\n\n    for(int i=0; i<H; i++)\n        if(S[i][0] == 'X' || S[i][W-1] == 'X'){\n            cout << -1 << endl;\n            return 0;\n        }\n    for(int i=0; i<W; i++)\n        if(S[0][i] == 'X' || S[H-1][i] == 'X'){\n            cout << -1 << endl;\n            return 0;\n        }\n\n    MaxFlow mf(2*H*W+2);\n    for(int i=0; i<H; i++)\n        for(int j=0; j<W; j++)\n            mf.add_edge(H*W+W*i+j, W*i+j, 1);\n\n    for(int i=0; i<H; i++)\n        for(int j=0; j<W; j++)\n            for(int k=0; k<4; k++){\n                int y = i + dy[k];\n                int x = j + dx[k];\n                if(y < 0 || y >= H || x < 0 || x >= W) continue;\n                mf.add_edge(W*i+j, H*W+W*y+x, 1);\n            }\n\n    for(int i=0; i<H; i++){\n        mf.add_edge(W*i+0, 2*H*W+1, 1);\n        mf.add_edge(W*i+W-1, 2*H*W+1, 1);\n    }\n    for(int i=0; i<W; i++){\n        mf.add_edge(W*0+i, 2*H*W+1, 1);\n        mf.add_edge(W*(H-1)+i, 2*H*W+1, 1);\n    }\n\n    for(int i=0; i<H; i++)\n        for(int j=0; j<W; j++)\n            if(S[i][j] == 'X')\n                mf.add_edge(2*H*W, W*i+j, 1<<29);\n    cout << mf.max_flow(2*H*W, 2*H*W+1) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<array>\n#include<algorithm>\n#include<list>\n#include<cmath>\n#include<iomanip>\n#include<queue>\n#include<functional>\n#include<climits>\n#include<iterator>\n#include<unordered_set>\n#include<unordered_map>\n#include<map>\n#include<set>\n#include<typeinfo>\nusing namespace std;\n\nconst double pi=4*atan(1.0);\n\nconstexpr long long mod=static_cast<long long>(1e9+7);\n\nusing cWeightEdges=vector<vector<pair<int,int>>>;\nusing cEdges=vector<vector<int>>;\n\nbool dfs(int x,int y,vector<string>& a,vector<vector<int>>& memo){\n\tmemo[x][y]=INT_MAX;\n\tif(x==0 || x==memo.size()-1 || y==0 || y==memo[x].size()-1){\n\t\tmemo[x][y]=-1;\n\t\treturn false;\n\t}\n\n\tbool ans=true;\n\tif(memo[x-1][y]==0){\n\t\tif(a[x-1][y]=='.')ans&=dfs(x-1,y,a,memo);\n\t}\n\telse if(memo[x-1][y]==-1)ans=false;\n\n\tif(memo[x+1][y]==0){\n\t\tif(a[x+1][y]=='.')ans&=dfs(x+1,y,a,memo);\n\t}\n\telse if(memo[x+1][y]==-1)ans=false;\n\tif(memo[x][y-1]==0){\n\t\tif(a[x][y-1]=='.')ans=dfs(x,y-1,a,memo);\n\t}\n\telse if(memo[x][y-1]==-1)ans=false;\n\n\tif(memo[x][y+1]==0){\n\t\tif(a[x][y+1]=='.')ans&=dfs(x,y+1,a,memo);\n\t}\n\telse if(memo[x][y+1]==-1)ans=false;\n\n\tif(ans){\n\t\tmemo[x][y]=1;\n\t\ta[x][y]='#';\n\t\treturn true;\n\t}\n\telse{\n\t\tmemo[x][y]=-1;\n\t\treturn true;\n\t}\n}\n\nvoid fill_blanck(vector<string>& a,int H,int W){\n\tvector<vector<int>> memo(H,vector<int>(W,0));\n\tfor(int i=0;i<H;++i){\n\t\tfor(int j=0;j<W;++j){\n\t\t\tif(a[i][j]=='.'){\n\t\t\t\tdfs(i,j,a,memo);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint H,W;\n\tcin>>H>>W;\n\tvector<string> a(H);\n\tfor(auto& val:a)\n\t\tcin>>val;\n\n\tbool IsEdge=false;\n\tfor(int i=0;i<H;++i){\n\t\tfor(int j=0;j<W;++j){\n\t\t\tif(a[i][j]=='X'){\n\t\t\t\tif(i==0 || i==H-1 || j==0 || j==W-1){\n\t\t\t\t\tIsEdge=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif(a[i-1][j]!='X')a[i-1][j]='#';\n\t\t\t\tif(a[i+1][j]!='X')a[i+1][j]='#';\n\t\t\t\tif(a[i][j-1]!='X')a[i][j-1]='#';\n\t\t\t\tif(a[i][j+1]!='X')a[i][j+1]='#';\n\t\t\t}\n\t\t}\n\t}\n\n\tif(IsEdge){\n\t\tcout<<-1<<endl;\n\t}\n\telse{\n\n\t\tfill_blanck(a,H,W);\n\n\t\tfor(int i=1;i<H-1;++i){\n\t\t\tfor(int j=1;j<W-1;++j){\n\t\t\t\tif(a[i][j]=='#'){\n\t\t\t\t\tbool CanErase=true;\n\t\t\t\t\tif(a[i-1][j]=='.')CanErase=false;\n\t\t\t\t\tif(a[i+1][j]=='.')CanErase=false;\n\t\t\t\t\tif(a[i][j-1]=='.')CanErase=false;\n\t\t\t\t\tif(a[i][j+1]=='.')CanErase=false;\n\n\t\t\t\t\tif(CanErase)a[i][j]='%';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans=0;\n\t\tfor(int i=0;i<H;++i){\n\t\t\tfor(int j=0;j<W;++j){\n\t\t\t\tif(a[i][j]=='#')++ans;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\n\t\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nusing vs=vector<string>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\n\nstatic const int INF=1<<29;\nstatic const int di[]={-1, 0, 1, 0}, dj[]={0, -1, 0, 1};\nint main() {\n  size_t H, W;\n  scanf(\"%lu %lu\", &H, &W);\n\n  vs S(H);\n  for (size_t i=0; i<H; ++i) {\n    char buf[1<<7];\n    scanf(\"%s\", buf);\n    S[i] = buf;\n    if (S[i][0]=='X' || S[i][W-1]=='X')\n      return !printf(\"-1\\n\");\n  }\n\n  if (S[0].find('X') != string::npos)\n    return !printf(\"-1\\n\");\n\n  if (S[H-1].find('X') != string::npos)\n    return !printf(\"-1\\n\");\n\n  vs T(H, string(W, '.'));\n  for (size_t i=1; i<H-1; ++i)\n    for (size_t j=1; j<W-1; ++j) {\n      if (S[i][j] == 'X') {\n        for (size_t k=0; k<4; ++k) {\n          int I=i+di[k], J=j+dj[k];\n          T[I][J] = '#';\n        }\n      }\n    }\n\n  vvi dp(H, vi(W, INF));\n  queue<pii> q;\n  for (size_t i=0; i<H; ++i)\n    if (T[i][0] != '#') {\n      dp[i][0] = 0;\n      q.push(pii(i, 0));\n    }\n\n  for (size_t j=0; j<W; ++j)\n    if (T[0][j] != '#') {\n      dp[0][j] = 0;\n      q.push(pii(0, j));\n    }\n\n  while (!q.empty()) {\n    int i=q.front().first, j=q.front().second; q.pop();\n    for (size_t k=0; k<4; ++k) {\n      int I=i+di[k], J=j+dj[k];\n      if (!(0<=I && I<H && 0<=J && J<W)) continue;\n\n      if (dp[I][J] > dp[i][j] + (T[I][J]=='#')) {\n        dp[I][J] = dp[i][j] + (T[I][J]=='#');\n        q.push(pii(I, J));\n      }\n    }\n  }\n\n  int res=0;\n  for (size_t i=0; i<H; ++i)\n    for (size_t j=0; j<W; ++j) {\n      fprintf(stderr, \"%d%c\", dp[i][j], j<W-1? ' ':'\\n');\n      if (dp[i][j]==1 && T[i][j]=='#') ++res;\n    }\n\n  printf(\"%d\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<ut,VI> PQ;\nconst ut INF=1LL<<30;\nconst int SIZE=201;\nint maps[SIZE][SIZE];\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\ncli d[4];\nbool searched[SIZE][SIZE];\nint solve(){\n\tREP(i,4) d[i]=cli(dy[i],dx[i]);\n\tint H,W;\n\tcin >> H >> W;\n\tqueue<cli> qu;\n\tREP(i,H){\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,W){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(maps[i][j]) qu.push(cli(j,i));\n\t\t}\n\t}\n\tint count=0;\n\twhile(!qu.empty()){\n\t\tcli now=qu.front();\n\t\tqu.pop();\n\t\tcount++;\n\t\tif(count==1e7) return -1;\n\t\tif(maps[now.imag()][now.real()]==1){\n\t\t\t\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) return -1;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=1){\n\t\t\t\t\tqu.push(next);\n\t\t\t\t\tmaps[next.imag()][next.real()]=-1;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t//\tcout << next << endl;\n\t\t\t}\n\t\t}\n\t\telse if(maps[now.imag()][now.real()]==-1){\n\t\t\tint around=0;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) continue;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=0) around++;\n\t\t\t\tif(!searched[now.imag()][now.real()]) if(maps[next.imag()][next.real()]!=1) qu.push(next);\n\t\t\t}\n\t\t\tsearched[now.imag()][now.real()]=true;\n\t\t\tif(around>=3){\n\t\t\t\tmaps[now.imag()][now.real()]=1;\n\t\t\t\tqu.push(now);\n\t\t\t}\n\t\t} \n\t\telse if(maps[now.imag()][now.real()]==0){\n\t\t\tint around=0;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) continue;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=0) around++;\n\t\t\t}\n\t\t\tif(around>=4){\n\t\t\t\tmaps[now.imag()][now.real()]=1;\n\t\t\t\tqu.push(now);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t//cout << count << endl;\n\tint ans=0;\n\tREP(i,H){\n\t\tREP(j,W)\n\t\t\tans+=maps[i][j]==-1;\n\t}\n\treturn ans;\n}\nint main(){\n\tcout << solve() << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, m;\n\tcin >> n >> m;\n\tvector<string> field(n);\n\tfor(int i = 0; i < n; ++i){ cin >> field[i]; }\n\tfor(int j = 0; j < m; ++j){\n\t\tif(field[0][j] == 'X' || field[n - 1][j] == 'X'){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = 0; i < n; ++i){\n\t\tif(field[i][0] == 'X' || field[i][m - 1] == 'X'){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint left = m, right = 0, top = n, bottom = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tfor(int j = 0; j < m; ++j){\n\t\t\tif(field[i][j] == 'X'){\n\t\t\t\tleft = min(left, j - 1);\n\t\t\t\tright = max(right, j + 1);\n\t\t\t\ttop = min(top, i);\n\t\t\t\tbottom = max(bottom, i);\n\t\t\t}\n\t\t}\n\t}\n\tint top_left = m, top_right = 0, bottom_left = m, bottom_right = 0;\n\tfor(int j = 0; j < m; ++j){\n\t\tif(field[top][j] == 'X'){\n\t\t\ttop_left = min(top_left, j);\n\t\t\ttop_right = max(top_right, j);\n\t\t}\n\t\tif(field[bottom][j] == 'X'){\n\t\t\tbottom_left = min(bottom_left, j);\n\t\t\tbottom_right = max(bottom_right, j);\n\t\t}\n\t}\n\tint answer = 0;\n\tanswer += (top_right - top_left + 1);\n\tanswer += (bottom_right - bottom_left + 1);\n\tint left_top = top - 1;\n\tfor(int j = top_left - 1; j >= left; --j){\n\t\tbool valid = true;\n\t\tfor(int k = 0; valid && k <= j; ++k){\n\t\t\tif(field[left_top + 1][k] == 'X'){ valid = false; }\n\t\t}\n\t\tif(valid){ ++left_top; }\n\t\tif(j > left){ ++answer; }\n\t}\n\tint right_top = top - 1;\n\tfor(int j = top_right + 1; j <= right; ++j){\n\t\tbool valid = true;\n\t\tfor(int k = j; valid && k < m; ++k){\n\t\t\tif(field[right_top + 1][k] == 'X'){ valid = false; }\n\t\t}\n\t\tif(valid){ ++right_top; }\n\t\tif(j < right){ ++answer; }\n\t}\n\tint left_bottom = bottom + 1;\n\tfor(int j = bottom_left - 1; j >= left; --j){\n\t\tbool valid = true;\n\t\tfor(int k = 0; valid && k <= j; ++k){\n\t\t\tif(field[left_bottom - 1][k] == 'X'){ valid = false; }\n\t\t}\n\t\tif(valid){ --left_bottom; }\n\t\tif(j > left){ ++answer; }\n\t}\n\tint right_bottom = bottom + 1;\n\tfor(int j = bottom_right + 1; j <= right; ++j){\n\t\tbool valid = true;\n\t\tfor(int k = j; valid && k < m; ++k){\n\t\t\tif(field[right_bottom - 1][k] == 'X'){ valid = false; }\n\t\t}\n\t\tif(valid){ --right_bottom; }\n\t\tif(j < right){ ++answer; }\n\t}\n\tanswer += (left_bottom - left_top + 1);\n\tanswer += (right_bottom - right_top + 1);\n\tcout << answer << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*? begin \"base.hpp\" */\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve( /* この関数に問題ごとの処理を書く */\n#ifdef GCJ_CASE\n long long case_id\n#endif\n);\n\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n #define debug true\n#else\n #define NDEBUG \n #define debug false\n#endif\n#include<algorithm>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<type_traits>\n#include<vector>\n#ifdef __cpp_lib_execution\n  #include<execution>\n#endif\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL \n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define times(n,i) uptil(0,n,i)\n#define rtimes(n,i) downto((n)-1,0,i)\n#define upto(f,t,i) for(int rabT##i=(t),i=(f);i<=rabT##i;i++)\n#define uptil(f,t,i) for(int rabT##i=(t),i=(f);i< rabT##i;i++)\n#define downto(f,t,i) for(int rabT##i=(t),i=(f);i>=rabT##i;i--)\n#define downtil(f,t,i) for(int rabT##i=(t),i=(f);i> rabT##i;i--)\n#define iter(v) begin(v),end(v)\n#define citer(v) cbegin(v),cend(v)\n#define riter(v) rbegin(v),rend(v)\n#define criter(v) crbegin(v),crend(v)\n#define IF(a,b,c) ((a)?(b):(c))\n#define BINOP_ASGN(t,u,op) t operator op(CS u&o)CS{RT t(*this)op##=o;}\n#if debug\n #define _GLIBCXX_DEBUG\n #define _LIBCPP_DEBUG 2\n #define _LIBCPP_DEBUG2 2\n #define ln <<endl\n#else\n #define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n #define PARABLE \n/*? begin \"mod.hpp\" */\n#ifdef MOD\n #if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n  #error unknown mod MOD and FORCE_MOD not defined.\n #endif\n#else\n #define MOD 1000000007\n#endif\n/*? begin \"power.hpp\" */\nusing int128=__int128;\nTL<TN T>T power(T x,int n){T rt(1);for(;n;n/=2){if(n%2)rt*=x;x*=x;}RT rt;}\nint pow_mod(int x,int n,int m){int rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\nint128 pow_mod_64(int128 x,int n,int m){int128 rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\n/*? end \"power.hpp\" */\nIL CX int modulo(int a,int m){RT(a%=m,a>=0?a:a+m);}\nTL<ULL mod=MOD>class MInt{\n  /*! https://ei1333.github.io/luzhiled/snippets/other/mod-int.html */\npublic:\n  int val;\n  CX MInt():val(0){}\n  explicit CX MInt(int v):val(modulo(v,mod)){}\n  MInt&operator+=(CS MInt&m){val+=m.val;if(val>=mod)val-=mod;RT*this;}\n  MInt&operator-=(CS MInt&m){val-=m.val;if(val<0)val+=mod;RT*this;}\n  MInt&operator*=(CS MInt&m){val=val*m.val%mod;RT*this;}\n  MInt&operator/=(CS MInt&m){val=val*m.inv().val%mod;RT*this;}\n  BINOP_ASGN(MInt,MInt,+) BINOP_ASGN(MInt,MInt,-) BINOP_ASGN(MInt,MInt,*) BINOP_ASGN(MInt,MInt,/)\n  MInt operator-()CS{MInt m;m.val=val?mod-val:0;RT m;}\n  bool operator==(CS MInt&m)CS{RT val==m.val;}\n  bool operator!=(CS MInt&m)CS{RT val!=m.val;}\n  //MInt pow(int n)CS{MInt x(*this),rt(1);while(n){if(n%2)rt*=x;x*=x;n/=2;}RT rt;}\n  MInt pow(int n)CS{RT power(*this,n);}\n  MInt inv()CS{int a=val,b=mod,x=1,y=0,t;while(b){t=a/b;swap(b,a-=t*b);swap(y,x-=t*y);}RT(MInt)x;}\n  friend ostream&operator<<(ostream&o,CS MInt<mod>&m){RT o<<m.val;}\n  friend istream&operator>>(istream&i,MInt<mod>&m){int v;i>>v;m=MInt<mod>(v);RT i;}\n};\nusing mint=MInt<>;\n\nconstexpr mint operator\"\" _m(ULL n){RT mint(n);}\nconstexpr MInt<998244353>operator\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nconstexpr MInt<1000000007>operator\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nconstexpr MInt<1000000009>operator\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n\n//#pragma rab:gsub \\b(\\d+)m\\b mint(\\1)\n/*? end \"mod.hpp\" */\n/*? begin \"typedefs.hpp\" */\nstruct unit{};\n\nusing int128=__int128;\nusing LD=long double;\nTL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;\nTL<TN T>using vvvec=vec<vvec<T>>;\nTL<TN T>using vvvvec=vec<vvvec<T>>;\n\n//#pragma rab typedefs.dynamic\nusing WI = vvec<int>; using VI = vec<int>; using VC = vec<char>; using HII = map<int, int>; using VS = vec<string>; \n/*? end \"typedefs.hpp\" */\n/*? begin \"alias.hpp\" */\n#define EB emplace_back\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n/*? end \"alias.hpp\" */\n/*? begin \"util.hpp\" */\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,true);}\nTL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,true);}\n\n#ifndef __cpp_lib_exchange_function\n #define exchange exchange_RAB\n TL<TN T,TN U=T>IL T exchange(T& t, U&& u){T x=move(t);t=forward<U>(u);RT x;}\n#endif\n#ifndef __cpp_lib_clamp\n #define clamp clamp_RAB\n TL<TN T>IL CX CS T&clamp(CS T&a,CS T&mn,CS T&mx){RT a<mn?mn:a>mx?mx:a;}\n#endif\n\nTL<TN T>IL int size_RAB(T t){RT t.size();}\n#define size size_RAB\n\nTL<TN V>IL void uniq_after_sort(V&v){v.erase(unique(iter(v)),v.end());}\nTL<TN V>IL void sort_and_uniq(V&v){sort(iter(v));v.erase(unique(iter(v)),v.end());}\nTL<TN V,TN K>IL auto leftmost_ge(CS V&v,CS K&k){RT v.lower_bound(k);}\nTL<TN V,TN K>IL auto leftmost_gt(CS V&v,CS K&k){RT v.upper_bound(k);}\n\nnamespace rab{\n\nTL<TN V,TN W>IL void append(V&v,CS W&w){copy(PARABLE citer(w),back_inserter(v));}\n\nTL<TN V>IL auto flatten(CS V&xss,int reserve_size=0)->TN V::value_type{\n  decltype(flatten(xss))ret;\n  ret.reserve(reserve_size);\n  for(CS auto&xs:xss)append(ret,xs);\n  ret.shrink_to_fit();\n  RT move(ret);\n}\n\nTL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}\n\nTL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){RT 0<=i&&i<size(v)?v[i]:d;}\nTL<TN T>IL T fetch(CS T&d,CS vvec<T>&v,int i,int j){\n  RT 0<=i&&i<size(v)&&0<=j&&j<size(v[i])?v[i][j]:d;\n}\n// TL<TN T,TN U,TN...I>IL T fetch(CS T&d,CS vec<vec<U>>&v,int i,I...j){\n// RT 0<=i&&i<size(v)?fetch(d,v[i],j...):d;\n// }\nTL<TN T>struct Compressed{int size;map<T,int>zip;vec<T>unzip;};\nTL<TN T>IL Compressed<T>compressed(vec<T>v){\n  sort_and_uniq(v);map<T,int>zip;times(size(v),i)zip[v[i]]=i;RT{size(v),zip,move(v)};\n}\nTL<TN T>struct CompressedSrc{int size;map<T,int>zip;vec<T>unzip;WI src;};\nTL<TN T>IL CompressedSrc<T>compressed_src(CS vec<T>&v){\n  auto c=compressed(v);VI src(c.size);times(size(v),i)src[c.zip[v[i]]].PB(i);RT{c.size,c.zip,c.unzip,src};\n}\n\nstruct identity{TL<TN U>U operator()(U&&v)CS{RT v;}};\n}\n/*? end \"util.hpp\" */\n/*? begin \"debug.hpp\" */\nTL<class T>\nIL istream&operator>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nTL<class T>\nIL ostream&operator<<(ostream&,CS vec<T>&);\nTL<class T,class S>\nIL ostream&operator<<(ostream&,CS map<T,S>&);\n#define DEFINE_ITER_OUTPUT(s,x,sep){int i=0;for(CS auto&x##0_elem:x){if(i++)s<<sep;s<<x##0_elem;}RT s;}\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<T>&v)DEFINE_ITER_OUTPUT(s,v,' ')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS map<T,S>&m)DEFINE_ITER_OUTPUT(s,m,' ')\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<vec<T>>&w)DEFINE_ITER_OUTPUT(s,w,'\\n')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS vec<map<T,S>>&v)DEFINE_ITER_OUTPUT(s,v,'\\n')\n/*? end \"debug.hpp\" */\n\nsigned main(){\n {if(debug)cerr<<\"MOD: \"<<(MOD)ln;}\n if(!debug)cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\n cout<<fixed<<setprecision(20);\n cerr<<fixed<<setprecision(20);\n\n #ifdef GCJ_CASE\n  int T;cin>>T;\n  times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n #else\n  solve();\n #endif\n\n return 0;\n}\n/*? end \"base.hpp\" */\n/*? begin \"graph.hpp\" */\n/*? begin \"uf.hpp\" */\nTL<class T=int,class Adder=plus<T>,class Inverser=negate<T>>\nclass UnionFind{\n/*!\nhttp://noshi91.hatenablog.com/entry/2018/05/30/191943\nhttps://en.wikipedia.org/wiki/Disjoint-set_data_structure\nhttps://qiita.com/drken/items/cce6fc5c579051e64fab\n*/\nint n,*parents,*sizes;T*pot_diffs;bool to_delete;Adder adder;\nInverser inverser;\npublic:\nexplicit UnionFind(int n,bool to_delete=false):\nn(n),parents(new int[n]),sizes(new int[n]),pot_diffs(new T[n]),to_delete(to_delete)\n{clear();\n}\nvoid clear(){\ntimes(n,i)parents[i]=i;/*roots*/\nfill(sizes,sizes+n,1);fill(pot_diffs,pot_diffs+n,0);\n}\n~UnionFind(){if(to_delete){delete[]parents;delete[]sizes;delete[]pot_diffs;}}\nint size(){RT n;}\nint root(int i){int p=parents[i];\nif(p==i)RT i;/*`i`is a root*/\nint r=root(p);/*and pot_diffs[p]:=diff from root*/\npot_diffs[i]+=pot_diffs[p];parents[i]=r;RT r;\n}\nbool is_same(int i,int j){RT root(i)==root(j);}\nbool is_all_same(){int r=root(0);uptil(1,n,i)if(root(i)!=r)RT 0;RT 1;}\nbool merge(int i,int j,T pdiff=0){i=root(i);j=root(j);\nif(i==j)RT false;/*already merged*/\nif(sizes[i]>sizes[j]){swap(i,j);pdiff=inverser(pdiff);\n}\n/*now sizes[i]<=sizes[j]*/\nparents[i]=j;sizes[j]+=sizes[i];pot_diffs[i]=pdiff;RT true;\n}\nT diff(int i,int j){\nroot(i);/*pot_diffs[i]:=diff from root*/\nroot(j);/*pot_diffs[j]:=diff from root*/\nRT adder(pot_diffs[i],inverser(pot_diffs[j]));}};using unionfind=UnionFind<>;\n/*? end \"uf.hpp\" */\nTL<class EdgeVal>\nstruct Edge{int from;int to;EdgeVal weight;\nEdge(int from,int to,EdgeVal weight):from(from),to(to),weight(weight){}\nIL bool OP==(CS Edge&e)CS{RT weight==e.weight&&from==e.from&&to==e.to;}\nIL bool OP<(CS Edge&e)CS{RT weight<e.weight||(weight==e.weight&&(from<e.from||(from==e.from&&to<e.to)));}\nIL bool OP<=(CS Edge&e)CS{RT this==e||this<e;}\nIL bool OP>(CS Edge&e)CS{RT e<this;}\nIL bool OP>=(CS Edge&e)CS{RT e<=this;}};\nTL<class VtxVal,class EdgeVal>\nclass Graph{\nusing VoidWithoutEdgeVal=TN enable_if<is_default_constructible<EdgeVal>::value,void>::type;\nprotected:\nint nv_,nde_;unionfind uf;\npublic:\nvec<VtxVal>vs;vvec<Edge<EdgeVal>>edges;\nGraph(int nv):nv_(nv),nde_(0),uf(nv),vs(nv),edges(nv){}\nIL int nv()CS{RT nv_;}\nIL int nde()CS{RT nde_;}\nIL int nue()CS{RT nde_/2;}\nIL void add_dedge(int i,int j,CS EdgeVal&val){\nif(debug&&(!rab::is_in(i,0LL,nv_)||!rab::is_in(j,0LL,nv_))){\ncerr<<\"invalid index:(\"<<i<<\",\"<<j<<\")for Graph(nv=\"<<nv_<<\")\" ln;\nexit(1);\n}\nedges[i].emplace_back(i,j,val);++nde_;\n}\nIL VoidWithoutEdgeVal add_dedge(int i,int j){add_dedge(i,j,EdgeVal());\n}\nIL void add_uedge(int i,int j,CS EdgeVal&val){add_dedge(i,j,val);\nadd_dedge(j,i,val);\n}\nIL VoidWithoutEdgeVal add_uedge(int i,int j){add_uedge(i,j,EdgeVal());\n}\nIL bool is_connected(){uf.clear();\nfor(CS auto&es:edges)for(CS auto&e:es)uf.merge(e.from,e.to);RT uf.is_all_same();\n}};\n/*? end \"graph.hpp\" */\n/*? begin \"flow.hpp\" */\n/*!Arihon,https://tubo28.me/algorithm/dinic/*/\nTL<TN F,TN V,TN E,TN CapFn=rab::identity>\nclass dinic{\npublic:\nstruct EdgeInfo{F cap;F flow;CS int rev_idx;\nEdgeInfo(F cap,F flow,int rev_idx):cap(cap),flow(flow),rev_idx(rev_idx){}};\nint n,s,t;VI level,prog,que;vvec<Edge<EdgeInfo>>edges;\ndinic(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),level(n),prog(n),que(n+1),edges(n)\n{times(n,i){for(auto&e:g.edges[i]){F c=capfn(e.weight);\nint zt=size(edges[e.to]),zi=size(edges[i]);edges[i].EB(i,e.to,EdgeInfo(c,(F)0,zt));\nedges[e.to].EB(e.to,i,EdgeInfo(c,c,zi));\n}}}\nF exec(int s,int t){this->s=s;this->t=t;F mf=0,inf=numeric_limits<F>::max()/8;\nwhile(update_level(),level[t]>0){fill(iter(prog),0);mf+=find_paths(s,inf);\n}\nRT mf;\n}\nvoid update_level(){int ql=0,qr=0;fill(iter(level),-1);level[s]=0;\nque[qr++]=s;while(ql!=qr){int v=que[ql++];if(v==t)break;\nfor(CS auto&e:edges[v]){\nif(level[e.to]<0&&e.weight.cap!=e.weight.flow){level[e.to]=level[v]+1;\nque[qr++]=e.to;\n}}}}\nF find_paths(int v,int limit){if(v==t)RT limit;F diff=0;\nfor(int ze=size(edges[v]),&i=prog[v];i<ze;++i){auto&e=edges[v][i];\nif(level[v]<level[e.to]&&e.weight.cap!=e.weight.flow){F df=find_paths(e.to,min(limit,e.weight.cap-e.weight.flow));\ne.weight.flow+=df;edges[e.to][e.weight.rev_idx].weight.flow-=df;\ndiff+=df;limit-=df;if(limit==0)break;\n}}\nRT diff;}};\n/*!Arihon,https://tubo28.me/algorithm/ford-fulkerson/*/\nTL<TN V,TN E,TN CapFn=rab::identity>\nstruct ford_fulkerson{int n,s,t;VC visited;\nWI edges;/*both direction*/\nprivate:\nHII cap_,flow_;\npublic:\nford_fulkerson(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),visited(n),edges(n)\n{times(n,i){for(auto&e:g.edges[i]){int c=capfn(e.weight);\ncap_[i<<32|e.to]+=c;cap_[e.to<<32|i]+=c;flow_[e.to<<32|i]+=c;edges[i].PB(e.to);\nedges[e.to].PB(i);\n}}}\nint cap(int a,int b){RT cap_[a<<32|b];}\nint flow(int a,int b){RT flow_[a<<32|b];}\nint exec(int s,int t){this->s=s;this->t=t;int mf=0;\nwhile(1){fill(iter(visited),false);int df=find_path(s,LLONG_MAX/8/*inf*/);if(df==0)RT mf;\nmf+=df;\n}}\nint find_path(int v,int limit){visited[v]=true;if(v==t)RT limit;\nfor(int d:edges[v]){if(!visited[d]){int c=cap_[v<<32|d],&f=flow_[v<<32|d];\nif(c-f>0){int df=find_path(d,min(limit,c-f));if(df>0){f+=df;flow_[d<<32|v]-=df;RT df;\n}}}}\nRT 0;}};\n/*? end \"flow.hpp\" */\nconstexpr int INF = 401;\n\nvoid solve() {\n// HWH(\"S\")\n/* <foxy.memo-area> */\nint H;int W;cin>>H;cin>>W;VS S(H);times(H,Ri_0){cin>>S[Ri_0];}\n/* </foxy.memo-area> */\n\n  Graph<unit, int> g(H * W * 2 + 2);\n\n  int s = H * W * 2, t = H * W * 2 + 1;\n\n  #define inp(i, j) (((i) * W + (j)) * 2)\n  #define outp(i, j) (((i) * W + (j)) * 2 + 1)\n\n  times(H, i) times(W, j) {\n    g.add_dedge(inp(i, j), outp(i, j), 1);\n\n    if(S[i][j] == 'X') {\n      g.add_dedge(s, outp(i, j), INF);\n\n      if(i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n        cout << -1 ln;\n        return;\n      }\n    }\n  }\n\n  times(H, i) {\n    g.add_dedge(outp(i, 0), t, INF);\n    g.add_dedge(outp(i, W-1), t, INF);\n\n    times(W-1, j) {\n      g.add_dedge(outp(i, j), inp(i, j + 1), INF);\n      g.add_dedge(outp(i, j + 1), inp(i, j), INF);\n    }\n  }\n  times(W, j) {\n    g.add_dedge(outp(0, j), t, INF);\n    g.add_dedge(outp(H-1, j), t, INF);\n\n    times(H-1, i) {\n      g.add_dedge(outp(i, j), inp(i + 1, j), INF);\n      g.add_dedge(outp(i + 1, j), inp(i, j), INF);\n    }\n  }\n\n  dinic<int, unit, int> d(g);\n  cout << d.exec(s, t) ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n\nint n,m,nr,nc,cnt,ans;\nchar x[105][105];\nbool fr[105][105],vis[105][105];\nqueue<pii> q;\n\nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n\nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#', q.push({i+dr[k],j+dc[k]});\n\t}\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<fr[i][j];\n//\t\tcout<<endl;\n//\t}\n\tint r,c;\n\trep(tes,1,10000000){\n\t\tif(q.empty())break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#';\n\t\telse if(!cnt)x[r][c] = '.';\n\t\telse q.push({r,c});\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++ans;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <cassert>\n#include <iostream>\n#include <memory>\n#include <unordered_map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nint INF = 100000;\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef unordered_map<int,unordered_map<int,int>> Matrix;\n\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\nWeight augment(const Graph &g, Matrix &capacity, Matrix &flow,\n    const vector<int> &level, vector<bool> &finished, int u, int t, Weight cur) {\n  if (u == t || cur == 0) return cur;\n  if (finished[u]) return 0;\n  finished[u] = true;\n  FOR(e, g[u]) if (level[e->dst] > level[u]) {\n    Weight f = augment(g, capacity, flow, level, finished,\n        e->dst, t, min(cur, RESIDUE(u, e->dst)));\n    if (f > 0) {\n      flow[u][e->dst] += f; flow[e->dst][u] -= f;\n      finished[u] = false;\n      return f;\n    }\n  }\n  return 0;\n}\nWeight maximumFlow(const Graph &g, int s, int t) {\n  int n = g.size();\n  Matrix flow,capacity;\n  REP(u,n) FOR(e,g[u]) capacity[e->src][e->dst] += e->weight;\n\n  Weight total = 0;\n  for (bool cont = true; cont; ) {\n    cont = false;\n    vector<int> level(n, -1); level[s] = 0; // make layered network\n    queue<int> Q; Q.push(s);\n    for (int d = n; !Q.empty() && level[Q.front()] < d; ) {\n      int u = Q.front(); Q.pop();\n      if (u == t) d = level[u];\n      FOR(e, g[u]) if (RESIDUE(u,e->dst) > 0 && level[e->dst] == -1)\n        Q.push(e->dst), level[e->dst] = level[u] + 1;\n    }\n    vector<bool> finished(n); // make blocking flows\n    for (Weight f = 1; f > 0; ) {\n      f = augment(g, capacity, flow, level, finished, s, t, INF);\n      if (f == 0) break;\n      total += f; cont = true;\n    }\n  }\n  return total;\n}\n\n\n\nint H,W,N;\n\nint in(int x){\n\treturn x;\n}\nint out(int x){\n\treturn x + N;\n}\nvoid addEdge(Graph &g,int s,int t,int c){\n\tg[s].push_back(Edge(s,t,c));\n\tg[t].push_back(Edge(t,s,0));\n}\nint dx[] = {-1,0,1,0};\nint dy[] = {0,1,0,-1};\n\n\nstring S[111];\n\nint main(){\n\tint H,W;\n\tcin >> H >> W;\n\tfor(int i = 0 ; i < H ; i++){\n\t\tcin >> S[i];\n\t}\n\tN = H * W;\n\n\tGraph g(2*N+2);\n\tint s = g.size() - 1;\n\tint t = g.size() - 2;\n\tfor(int i = 0 ; i < H ; i++){\n\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\tint idx1 = i * W + j;\n\t\t\tif( S[i][j] == 'X' ){\n\t\t\t\taddEdge(g,s,in(idx1),INF);\n\t\t\t\taddEdge(g,in(idx1),out(idx1),INF);\n\n\t\t\t}else{\n\t\t\t\taddEdge(g,in(idx1),out(idx1),1);\n\t\t\t}\n\t\t\tfor(int d = 0 ; d < 4 ; d++){\n\t\t\t\tint ty = i + dy[d];\n\t\t\t\tint tx = j + dx[d];\n\t\t\t\tif( ty < 0 || tx < 0 || tx >= W || ty >= H ){\n\t\t\t\t\taddEdge(g,out(idx1),t,INF);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint idx2 = ty * W + tx;\n\t\t\t\taddEdge(g,out(idx1),in(idx2),INF);\n\n\t\t\t}\n\t\t}\n\t}\n\tint res = maximumFlow(g,s,t);\n\tif( res >= 100000 ){\n\t\tcout << -1 << endl;\n\t}else{\n\t\tcout << res << endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define mp make_pair\ntypedef pair<int,int> pii;\n\nconst int N = 110;\nchar s[N][N];\n\nint n, m;\nint xl[4]={-1,1,0,0};\nint yl[4]={0,0,-1,1};\n\nbool vis[N][N];\n\nint solve(){\n    for(int i=0; i<n; i++){\n        if(s[i][0]=='X' || s[i][m-1]=='X')  return -1;\n    }\n    for(int i=0; i<m; i++){\n        if(s[0][i]=='X' || s[n-1][i]=='X')  return -1;\n    }\n    int a, b;\n    for(int i=0; i<n; i++){\n        for(int j=0; j<m; j++){\n            if(s[i][j]=='X'){\n                for(int k=0; k<4; k++){\n                    a = i + xl[k];\n                    b = j + yl[k];\n                    if(a<0 || a>=n || b<0 || b>=m)  continue;\n                    if(s[a][b]=='.'){\n                        s[a][b]='*';\n                    }\n                }\n            }\n        }\n    }\n    memset(vis, 0, sizeof(vis));\n    queue<pii> Q;\n    for(int i=0; i<n; i++){\n        vis[i][0] = vis[i][m-1] = 1;\n        if(s[i][0]=='.'){\n            Q.push(mp(i, 0));\n        }\n        if(s[i][m-1]=='.'){\n            Q.push(mp(i, m-1));\n        }\n    }\n    for(int i=0; i<m; i++){\n        vis[0][i] = vis[n-1][i] = 1;\n        if(s[0][i]=='.'){\n            Q.push(mp(0, i));\n        }\n        if(s[n-1][i]=='.'){\n            Q.push(mp(n-1, i));\n        }\n    }\n    int x, y;\n    pii p;\n    while(!Q.empty()){\n        p = Q.front(); Q.pop();\n        for(int i=0; i<4; i++){\n            x = p.first + xl[i];\n            y = p.second + yl[i];\n            if(x<0 || x>=n || y<0 || y>=m)  continue;\n            if(vis[x][y])   continue;\n            vis[x][y] = 1;\n            if(s[x][y]=='.'){\n                Q.push(mp(x, y));\n            }\n        }\n    }\n    int ret = 0;\n    for(int i=0; i<n; i++){\n        for(int j=0; j<m; j++){\n            if(s[i][j]=='*' && vis[i][j]){\n                ret++;\n            }\n        }\n    }\n    return ret;\n}\n\nint main(){\n    while(~scanf(\"%d %d\", &n, &m)){\n        for(int i=0; i<n; i++)  scanf(\"%s\", s[i]);\n        printf(\"%d\\n\", solve());\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n\nint n,m,nr,nc,cnt,ans,hit;\nchar x[105][105];\nbool fr[105][105],vis[105][105];\nqueue<pii> q;\n\nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n\nvoid mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\n\nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#', q.push({i+dr[k],j+dc[k]});\n\t}\n\tmk();\n\tint r,c;\n\trep(tes,1,100000000){\n\t\tif(q.empty())break;\n//\t\tif(hit==2*q.size())break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0, mk();\n\t\telse if(!cnt)x[r][c] = '.', hit = 0, mk();\n\t\telse q.push({r,c}), ++hit;\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<fr[i][j];\n//\t\tcout<<endl;\n//\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++ans;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vin=vector<int>;\nusing vll=vector<long long>;\nusing vvin=vector<vector<int>>;\nusing vvll=vector<vector<long long>>;\nusing vstr=vector<string>;\nusing vvstr=vector<vector<string>>;\nusing vch=vector<char>;\nusing vvch=vector<vector<char>>;\nusing vbo=vector<bool>;\nusing vvbo=vector<vector<bool>>;\nusing vpii=vector<pair<int,int>>;\nusing pqsin=priority_queue<int,vector<int>,greater<int>>;\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep2(i,s,n) for(int i=(s);i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define decp(n) cout<<fixed<<setprecision((int)n)\nconst int inf=1e9+7;\nconst ll INF=1e18;\n\nstruct edge{int to;ll cap;int rev;};\n\nint MAX_V=20050;\nint tmp1,tmp2;\n\nvector<vector<edge>> g(MAX_V);//グラフの隣接リスト表現\nvin level(MAX_V);//distance form s\nvin iter(MAX_V);//どこまで調べたか\n\nvoid add_edge(int from,int to,ll cap=(ll)inf){\n    tmp1=g[to].size();tmp2=g[from].size();\n    g[from].push_back((edge){to,cap,tmp1});//g[to]のg[to].size()番目にfromが入っている\n    g[to].push_back((edge){from,0,tmp2});//g[from]のg[from].size()-1番目にtoが入っている\n}\n\nvoid bfs(int s){\n    fill(all(level),-1);\n    queue<int> q;\n    q.push(s);\n    level[s]=0;\n    while(q.size()){\n        int v=q.front();q.pop();\n        for(auto& e:g[v]){\n            if(e.cap>0&&level[e.to]<0){\n                level[e.to]=level[v]+1;\n                q.push(e.to);\n            }\n        }\n    }\n}\n\n//増加パスをdfsで探す\n//v:今見てる頂点 t:終点 f:流量\nint dfs(int v,int t,ll f){\n    if(v==t)return f;\n    for(int& i=iter[v];i<(int)g[v].size();i++){\n        edge& e=g[v][i];\n        if(e.cap>0&&level[v]<level[e.to]){\n            ll d=dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                g[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n//sからtへの最大流を求める\nint max_flow(int s,int t){\n    ll flow=(ll)0;\n    ll f;\n    for(;;){\n        bfs(s);\n        if(level[t]<0)return flow;\n        fill(all(iter),0);\n        while((f=dfs(s,t,inf))>0)flow+=f;\n    }\n}\n\nint main(){\n    int h,w;cin>>h>>w;\n    vstr S(h);\n    rep(i,h)cin>>S[i];\n    //各マスinとoutを2つ用意\n    //(i,j)のinは2(i*w+j)で, outは2(i*w+j)+1で表される\n    int s=2*h*w;//s→ヤギ\n    int t=s+1;//追加したグリッドのマス(ゴール)→t\n    int tmp;\n    rep(i,h)rep(j,w){\n        tmp=2*(i*w+j);\n        if(S[i][j]=='X'){\n            if(i==0||i==h-1||j==0||j==w-1){\n                cout<<-1<<endl;\n                return 0;\n            }\n            add_edge(tmp,tmp+1);\n            add_edge(s,tmp);\n        }\n        else add_edge(tmp,tmp+1,(ll)1);\n        if(i>0)add_edge(tmp+1,tmp-2*w);\n        if(i<h-1)add_edge(tmp+1,tmp+2*w);\n        if(j>0)add_edge(tmp+1,tmp-2);\n        if(j<w-1)add_edge(tmp+1,tmp+2);\n        if(i==0||i==h-1||j==0||j==w-1)add_edge(tmp+1,t);\n    }\n    cout<<max_flow(s,t)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Problem {\npublic:\n    Problem(int h, int w) : h(h), w(w), maze(h), used(h, vector<bool>(w, false)) { }\n    void Input();\n    int Solve();\n\nprivate:\n    int h, w;\n    vector<string> maze;\n    vector<vector<bool>> used;\n\n    bool Contain(int y, int x) { return 0 <= y && y < h && 0 <= x && x < w; }\n    bool CanRemove(int y, int x);\n};\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nvoid Problem::Input() {\n    for (int i = 0; i < h; ++i) cin >> maze[i];\n}\n\nbool Problem::CanRemove(int y, int x) {\n    vector<vector<bool>> visited(h, vector<bool>(w, false));\n    queue<pair<int, int>> que;\n\n    que.push(make_pair(y, x));\n    visited[y][x] = true;\n    while (!que.empty()) {\n        auto cur = que.front();\n        que.pop();\n\n        for (int d = 0; d < 4; ++d) {\n            int ny = cur.first + dy[d], nx = cur.second + dx[d];\n\n            if (!Contain(ny, nx) || used[ny][nx] || visited[ny][nx])\n                continue;\n\n            if (ny == 0 || ny == h - 1 || nx == 0 || nx == w - 1)\n                return false;\n\n            que.push(make_pair(ny, nx));\n            visited[ny][nx] = true;\n        }\n    }\n\n    return true;\n}\n\nint Problem::Solve() {\n    for (int i = 0; i < h; ++i)\n        if (maze[i][0] == 'X' || maze[i][w - 1] == 'X') return -1;\n    for (int i = 0; i < w; ++i)\n        if (maze[0][i] == 'X' || maze[h - 1][i] == 'X') return -1;\n\n    for (int y = 0; y < h; ++y) {\n        for (int x = 0; x < w; ++x)\n            if (maze[y][x] == 'X')\n                for (int d = 0; d < 4; ++d) {\n                    int nx = x + dx[d], ny = y + dy[d];\n\n                    if (Contain(ny, nx))\n                        used[ny][nx] = true;\n                }\n    }\n\n    for (int y = 0; y < h; ++y)\n        for (int x = 0; x < w; ++x)\n            if (used[y][x] && CanRemove(y, x))\n                used[y][x] = false;\n\n    int cnt = 0;\n    for (int y = 0; y < h; ++y)\n        for (int x = 0; x < w; ++x)\n            if (used[y][x]) ++cnt;\n\n    return cnt;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int h, w;\n\n    cin >> h >> w;\n    Problem p(h, w);\n\n    p.Input();\n    cout << p.Solve() << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mem(x,n) memset(x,n,sizeof(x))\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,l) for(auto it=(l).begin();it!=(l).end();it++)\n#define pnl printf(\"\\n\")\n#define len(x) (x).length()\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\nconst double EPS=1e-10;\n//const double PI=acos(-1.0);\nconst int INF=1<<30;\nconst LL LLINF=1ll<<60;\nconst int MOD=1e9+7;\nconst int xx[8]={1,0,-1,0,1,-1,1,-1};\nconst int yy[8]={0,1,0,-1,-1,1,1,-1};\n\n/****************************************************************************************\\\n  __    __               __ /\\/|   ___ _           _       /\\/|__               __    __\n  \\ \\  / /  _____ __ ____\\ \\/\\/   / __| |__ _ _ __(_)___  |/\\// /____ __ _____  \\ \\  / /\n   \\ \\| |  |___\\ V  V /___| |    | (__| / _` | '_ \\ / -_)    | |___\\ V  V /___|  | |/ /\n    \\_\\ |  |___|\\_/\\_/|___| |     \\___|_\\__,_| .__/_\\___|    | |___|\\_/\\_/|___|  | /_/\n       \\_\\               /_/                 |_|              \\_\\               /_/\n\\****************************************************************************************/\n\nstruct edge{\n\tint v, bf;\n\tLL flow;\n};\n\nconst int MAXN = 2005;\nvector<edge> adj[MAXN];\nint lvl[MAXN], st[MAXN];\nconst int sink = 2003, source = 2004;\nint idx[2005][2005],idx1[2005][2005];\nchar input[2005][2005];\n\nvoid addedge(int u,int v,LL flow){\n\tadj[u].pb({v,sz(adj[v]),flow});\n\tadj[v].pb({u,sz(adj[u]),0});\n}\n\nbool bfs(int S,int G){\n\tqueue<int> q;\n\tmem(lvl,-1);\n\tq.push(S); lvl[S]=0;\n\twhile(!q.empty()){\n\t\tint u = q.front(); q.pop();\n\t\tfor(int i=0;i<sz(adj[u]);i++){\n\t\t\tint v = adj[u][i].v;\n\t\t\tLL flow = adj[u][i].flow;\n\t\t\tif(lvl[v]!=-1||flow<=0) continue;\n\t\t\tlvl[v]=lvl[u]+1;\n\t\t\tq.push(v);\n\t\t}\n\t}\n\treturn (lvl[G]!=-1);\n}\n\nLL dfs(int u,LL mini,int G){\n\tif(u==G) return mini;\n\t\n\tfor(int i=st[u];i<sz(adj[u]);i++){\n\t\tst[u]=i;\n\t\tint v = adj[u][i].v;\n\t\tLL flow = adj[u][i].flow;\n\t\tif(flow<=0||(lvl[v]-lvl[u]!=1)) continue;\n\t\tLL ret=dfs(v,min(mini,flow),G);\n\t\tif(ret>0){\n\t\t\tadj[u][i].flow-=ret;\n\t\t\tint bvf = adj[u][i].bf;\n\t\t\tadj[v][bvf].flow+=ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nLL maxflow(int S,int G){\n\tLL ret=0;\n\twhile(1){\n\t\tif(!bfs(S,G)) break;\n\t\tLL flow = 0;\n\t\tmem(st,0);\n\t\twhile((flow=dfs(S, LLINF, G))>0){\n\t\t\tret+=flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint r,c;\n\tscanf(\"%d%d\",&r,&c);\n\tgetchar();\n\tfor(int i=0;i<r;i++){\n\t\tscanf(\"%s\",input[i]);\n\t}\n\t\n\tint temp=0;\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tidx[i][j]=temp;\n\t\t\tidx1[i][j]=temp+1000;\n\t\t\ttemp++;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(input[i][j]=='.'){\n\t\t\t\taddedge(idx[i][j],idx1[i][j],1);\n\t\t\t\t\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\taddedge(idx1[i][j],sink,INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\taddedge(source,idx[i][j],INF);\n\t\t\t\taddedge(idx[i][j],idx1[i][j],INF);\n\t\t\t\t\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(i!=0) addedge(\tidx1[i][j], idx[i-1][j],INF);\n\t\t\tif(i!=r-1) addedge(\tidx1[i][j], idx[i+1][j],INF);\n\t\t\tif(j!=0) addedge(\tidx1[i][j], idx[i][j-1],INF);\n\t\t\tif(j!=c-1)addedge(\tidx1[i][j], idx[i][j+1],INF);\n\t\t}\n\t}\n\t\n\tLL ans = maxflow(source,sink);\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\nint INF = INT_MAX / 100;\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint dy[] = {0, -1, 0, 1};\nint dx[] = {-1, 0, 1, 0};\n\nstruct flow_network {\n\tint n;\n\tstruct edge { int v; ll c; int rev; };\n\tvector< vector<edge> > G;\n\tflow_network(int _n) : n(_n), G(_n) {}\n\tvoid add_edge(int u, int v, ll c) {\n\t\tedge e = {v, c, (int)G[v].size()}, _e = {u, 0, (int)G[u].size()};\n\t\tG[u].push_back(e); G[v].push_back(_e);\n\t}\n\tll dfs(int u, int t, ll f, vector<bool>& vis) {\n\t\tif (u == t) return f;\n\t\tvis[u] = true;\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tedge& e = G[u][i];\n\t\t\tif (vis[e.v] || e.c == 0) continue;\n\t\t\tll d = min(e.c, dfs(e.v, t, min(f, e.c), vis));\n\t\t\tif (d == 0) continue;\n\t\t\te.c -= d;\n\t\t\tG[e.v][e.rev].c += d;\n\t\t\treturn d;\n\t\t}\n\t\treturn 0;\n\t}\n\tll max_flow(int s, int t) {\n\t\tll res = 0;\n\t\tfor (;;) {\n\t\t\tvector<bool> vis(n);\n\t\t\tll f = dfs(s, t, LLONG_MAX, vis);\n\t\t\tif (f == 0) return res;\n\t\t\tres += f;\n\t\t}\n\t}\n};\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tvector<vector<bool> > a(H, vector<bool>(W));\n\trep(y, H) {\n\t\tstring s; cin >> s;\n\t\trep(x, W) a[y][x] = (s[x] == 'X');\n\t}\n\trep(y, H) rep(x, W)\n\t\tif (a[y][x] && (y==0 || y==H-1 || x==0 || x==W-1)) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\tflow_network fn(H * W * 2 + 2);\n\tint s = H * W * 2, t = s + 1;\n\trep(y, H) rep(x, W) fn.add_edge(y*W+x, H*W + y*W+x, 1);\n\trep(y, H) rep(x, W) {\n\t\tif (a[y][x])fn.add_edge(s, H*W + y*W+x, INF);\n\t\tif (y==0 || y==H-1 || x==0 || x==W-1) fn.add_edge(H*W + y*W+x, t, INF);\n\t\telse {\n\t\t\trep(k, 4) {\n\t\t\t\tint _y = y + dy[k], _x = x + dx[k];\n\t\t\t\tfn.add_edge(H*W + y*W+x, _y*W+_x, INF);\n\t\t\t}\n\t\t}\n\t}\n\tcout << fn.max_flow(s, t) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n#define rep(i, n) for(int i=0; i<n; ++i)\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\nusing namespace std;\nusing ll = int64_t;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vs = vector<string>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQG = priority_queue<T, vector<T>, greater<T> >;\nconst int INF = 100010001;\nconst ll LINF = (ll)INF*INF/10000;\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, T2 b) {return a < b && (a = b, true);}\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, T2 b) {return a > b && (a = b, true);}\ntemplate<typename T1, typename T2>\nistream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second;}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << ' ' << p.second;}\n\nstruct edge{\n  int to, rev;\n  int64_t cap;\n  edge(int t=0, int64_t c=0, int r=0):to(t), cap(c), rev(r) {}\n};\n\nstruct max_flow {\n  vector<vector<edge> > G;\n  vector<int> level, iter;\n  int n;\n  max_flow(int n=0):n(n), G(n), level(n), iter(n) {}\n  inline void add(int from, int to, int64_t cap) {\n    G[from].emplace_back(to, cap, G[to].size());\n    G[to].emplace_back(from, 0, G[from].size()-1);\n  }\n  void bfs(int s) {\n    for(int i = 0; i < n; i++) level[i] = -1;\n    queue<int> que;\n    level[s] = 0;\n    que.emplace(s);\n    while(!que.empty()) {\n      int now = que.front();\n      que.pop();\n      for(edge &e:G[now]) {\n        if(e.cap > 0 and level[e.to] < 0) {\n          level[e.to] = level[now] + 1;\n          que.emplace(e.to);\n        }\n      }\n    }\n  }\n  int64_t dfs(int v, int t, int64_t f) {\n    if(v == t) return f;\n    for(int &i = iter[v]; i < G[v].size(); i++) {\n      edge &e = G[v][i];\n      if(e.cap > 0 and level[v] < level[e.to]) {\n        int64_t d = dfs(e.to, t, min(f, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  int64_t Dinic(int s, int t) {\n    int64_t flow = 0;\n    while(true) {\n      bfs(s);\n      if(level[t] < 0) return flow;\n      for(int i = 0; i < n; i++) iter[i] = 0;\n      int64_t f;\n      while((f = dfs(s, t, INT64_MAX)) > 0) flow += f;\n    }\n  }\n};\n\n//head\n\nint h, w;\nstring ss[100];\nint di[] = {0, 1, 0, -1};\nint dj[] = {1, 0, -1, 0};\n\ninline bool able(int i, int j) {\n  return i >= 0 and j >= 0 and i < h and j < w;\n}\n\ninline int num(int i, int j) {\n  return j*h+i;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> h >> w;\n  rep(i, h) cin >> ss[i];\n\n  max_flow mf(h*w*2+2);\n  const int s = h*w*2, t = s+1;\n  rep(i, h*w) mf.add(i*2, i*2+1, 1);\n  rep(i, h) rep(j, w) {\n    if(i*j == 0 or i == h-1 or j == w-1) {\n      mf.add(num(i, j)*2+1, t, LINF);\n    }\n    if(ss[i][j] == 'X') {\n      mf.add(s, num(i, j)*2+1, LINF);\n    }\n    rep(k, 4) {\n      int ni = i+di[k];\n      int nj = j+dj[k];\n      if(able(ni, nj)) {\n        mf.add(num(i, j)*2+1, num(ni, nj)*2, LINF);\n        mf.add(num(ni, nj)*2+1, num(i, j)*2, LINF);\n      }\n    }\n  }\n\n  ll u = mf.Dinic(s, t);\n  if(u >= LINF) cout << -1 << endl;\n  else cout << u << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 555\n#define INF (1<<29)\n\nstruct edge {\n    int to, cap, rev;\n    edge (int to, int cap, int rev) :\n        to(to), cap(cap), rev(rev) {}\n};\n\nvector<edge> G[MAX_V];\nint level[MAX_V], iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap)\n{\n    G[from].push_back(edge(to, cap, G[to].size()));\n    G[to].push_back(edge(from, 0, G[from].size()-1));\n}\n\nvoid bfs(int s)\n{\n    memset(level, -1, sizeof(level));\n    queue<int> Q;\n    level[s] = 0;\n    Q.push(s);\n    while (!Q.empty()) {\n\tint v = Q.front(); Q.pop();\n\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t    edge &e = G[v][i];\n\t    if (e.cap > 0 && level[e.to] < 0) {\n\t\tlevel[e.to] = level[v] + 1;\n\t\tQ.push(e.to);\n\t    }\n\t}\n    }\n}\n\nint dfs(int v, int t, int f)\n{\n    if (v == t) return f;\n    for (int &i = iter[v]; i < (int)G[v].size(); i++) {\n\tedge &e = G[v][i];\n\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t    int d = dfs(e.to, t, min(f, e.cap));\n\t    if (d > 0) {\n\t\te.cap -= d;\n\t\tG[e.to][e.rev].cap += d;\n\t\treturn d;\n\t    }\n\t}\n    }\n    return 0;\n}\n\nint max_flow(int s, int t)\n{\n    int flow = 0;\n    for (;;) {\n\tbfs(s);\n\tif (level[t] < 0) return flow;\n\tmemset(iter, 0, sizeof(iter));\n\tint f;\n\twhile ((f = dfs(s, t, INF)) > 0) {\n\t    flow += f;\n\t}\n    }\n}\n\nbool is_outside(int x, int y, int W, int H)\n{\n    return (x == 0 || x == W - 1 || y == 0 || y == H - 1);\n}\n\nint solve(int H, int W,\n          vector<vector<char>> &S)\n{\n    int src = 2 * H * W, sink = src + 1;\n    const int di[] = {-1, +0, +1, +0};\n    const int dj[] = {+0, -1, +0, +1};\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int u = i * W + j, v = H * W + u;\n            \n            if (S[i][j] == 'X') {\n                if (is_outside(j, i, W, H)) {\n                    return -1;\n                }\n                add_edge(src, u, INF);\n                add_edge(u, v, INF);\n            } else {\n                add_edge(u, v, 1);\n            }\n\n            if (is_outside(j, i, W, H)) {\n                add_edge(v, sink, INF);                \n            }\n            \n            for (int k = 0; k < 4; k++) {\n                int ni = i + di[k];\n                int nj = j + dj[k];\n                if (0 <= ni && ni < H && 0 <= nj && nj < W) {\n                    add_edge(v, ni * W + nj, INF);\n                }\n            }\n        }\n    }\n    return max_flow(src, sink);\n}\n\nint main()\n{\n    int H, W;\n    cin >> H >> W;\n    vector<vector<char>> S(H, vector<char>(W));\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> S[i][j];\n        }\n    }\n    cout << solve(H, W, S) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nchar a[101][101];\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\nint h, w; \nconst int INF = 1000000000;\n\nbool isvalid(int x, int y)\n{\n\tif(x>=0&&x<h&&y>=0&&y<w) return true;\n\telse return false;\n}\n\ntemplate<int MX, ll INF> struct MaxFlow //by yutaka1999, have to define INF and MX (the Max number of vertices)\n{\n\tstruct edge\n\t{\n\t\tint to,cap,rev;\n\t\tedge(int to=0,int cap=0,int rev=0):to(to),cap(cap),rev(rev){}\n\t};\n\tvector <edge> vec[MX];\n\tint level[MX];\n\tint iter[MX];\n\t\n\tvoid addedge(int s,int t,int c) //adds an edge of cap c to the flow graph\n\t{\n\t\tint S=vec[s].size(),T=vec[t].size();\n\t\tvec[s].push_back(edge(t,c,T));\n\t\tvec[t].push_back(edge(s,0,S));\n\t}\n\tvoid bfs(int s)\n\t{\n\t\tmemset(level,-1,sizeof(level));\n\t\tqueue <int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<vec[v].size();i++)\n\t\t\t{\n\t\t\t\tedge&e=vec[v][i];\n\t\t\t\tif (e.cap>0&&level[e.to]<0)\n\t\t\t\t{\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll flow_dfs(int v,int t,ll f)\n\t{\n\t\tif (v==t) return f;\n\t\tfor(int &i=iter[v];i<vec[v].size();i++)\n\t\t{\n\t\t\tedge &e=vec[v][i];\n\t\t\tif (e.cap>0&&level[v]<level[e.to])\n\t\t\t{\n\t\t\t\tll d=flow_dfs(e.to,t,min(f,ll(e.cap)));\n\t\t\t\tif (d>0)\n\t\t\t\t{\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tvec[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tll maxflow(int s,int t) //finds max flow using dinic from s to t\n\t{\n\t\tll flow = 0;\n\t\twhile(1)\n\t\t{\n\t\t\tbfs(s);\n\t\t\tif (level[t]<0) return flow;\n\t\t\tmemset(iter,0,sizeof(iter));\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tll f=flow_dfs(s,t,1000000007);\n\t\t\t\tif(f==0) break;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nMaxFlow<30021,120001> mf;\n\nint in(int x, int y)\n{\n\treturn (w*x + y)*2+1;\n}\n\nint out(int x, int y)\n{\n\treturn (w*x+y)*2+2;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin >> h >> w;\n\tint s = 0; int e = out(h-1,w-1)+1;\n\tfor(int i = 0; i < h; i++)\n\t{\n\t\tfor(int j = 0; j < w; j++)\n\t\t{\n\t\t\t//cerr<<in(i,j)<<' '<<out(i,j)<<'\\n';\n\t\t\tcin >> a[i][j];\n\t\t\tif(a[i][j]=='X')\n\t\t\t{\n\t\t\t\tmf.addedge(in(i,j),out(i,j),INF);\n\t\t\t\tmf.addedge(out(i,j),e,INF);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmf.addedge(in(i,j),out(i,j),1);\n\t\t\t}\n\t\t\tif(i == 0 || i == h - 1 || j == 0 || j == w - 1)\n\t\t\t{\n\t\t\t\tif(a[i][j] == 'X'){cout << -1 << '\\n'; return 0;}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < h; i++)\n\t{\n\t\tfor(int j = 0; j < w; j++)\n\t\t{\n\t\t\tfor(int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tint x = i+dx[k]; int y = j+dy[k];\n\t\t\t\tif(isvalid(x,y))\n\t\t\t\t{\n\t\t\t\t\tmf.addedge(out(i,j),in(x,y),INF);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmf.addedge(s, in(i,j), INF);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<mf.maxflow(s,e)<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&b) { if (a > b)a = b; }\ntemplate<class T> void cmax(T &a, const T&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\numap<ti3, ll> memo;\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//速度ではなくメモリ効率を考えるならrankのかわりにsizeを使う\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\nint main() {\n\tvi d = { 0,1,0,-1,0 };\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> s(h);\n\trep(i, h)cin >> s[i];\n\tbool err = 0;\n\tfor (auto a : s.front())if (a == 'X')err = 1;\n\tfor (auto a : s.back())if (a == 'X')err = 1;\n\tfor (auto &a : s) {\n\t\tif (a.back() == 'X' || a.front() == 'X')err = 1;\n\t}\n\tif (err) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tbool up2 = 1;\n\tbool up = 1;\n\twhile (up) {\n\t\tup = 0;\n\t\trep1(i, h - 2)rep1(j, w - 2) {\n\t\t\tif (s[i][j] != 'X') {\n\t\t\t\tint cnt = 0;\n\t\t\t\trep(k, 4)if (s[i + d[k]][j + d[k+1]] != '.' )cnt++;\n\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\tup = 1;\n\t\t\t\t\ts[i][j] = 'X';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[i][j] == 'X') {\n\t\t\t\trep(k, 4)if (s[i + d[k]][j + d[k+1]] == '.') {\n\t\t\t\t\ts[i + d[k]][j + d[k+1]] = '#';\n\t\t\t\t\tup = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0;\n\trep(i, h)rep(j, w)if (s[i][j] == '#')cnt++;\n\tint prev = cnt;\n\twhile (up2) {\n\t\tup2=0;\n\t\trep1(i, h - 2)rep1(j, w - 2) {\n\t\t\tauto s2(s);\n\t\t\tif (s[i][j] == '.') {\n\t\t\t\tint cnt = 0;\n\t\t\t\trep(k, 4)if (s2[i + d[k]][j + d[k + 1]] != '.')cnt++;\n\t\t\t\tif (cnt >= 2) {\n\t\t\t\t\ts2[i][j] = 'X';\n\t\t\t\t}\n\t\t\t\telse if(cnt){\n\t\t\t\t\tif(i<h-2)rep(k,4)if (s2[i + d[k]+1][j + d[k + 1]] != '.')cnt++;\n\t\t\t\t\tif (cnt >= 2)s2[i][j] = s2[i + 1][j] = 'X';\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (j < w - 2)rep(k, 4)if (s2[i + d[k]][j + d[k + 1] + 1] != '.')cnt++;\n\t\t\t\t\t\tif (cnt >= 2)s2[i][j] = s2[i][j + 1] = 'X';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt<2) continue;\n\t\t\t}\n\t\t\tup = 1;\n\t\t\twhile (up) {\n\t\t\t\tup = 0;\n\t\t\t\trep1(i, h - 2)rep1(j, w - 2) {\n\t\t\t\t\tif (s2[i][j] != 'X') {\n\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\trep(k, 4)if (s2[i + d[k]][j + d[k + 1]] != '.')cnt++;\n\t\t\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\t\t\tup = 1;\n\t\t\t\t\t\t\ts2[i][j] = 'X';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (s2[i][j] == 'X') {\n\t\t\t\t\t\trep(k, 4)if (s2[i + d[k]][j + d[k + 1]] == '.') {\n\t\t\t\t\t\t\ts2[i + d[k]][j + d[k + 1]] = '#';\n\t\t\t\t\t\t\tup = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt = 0;\n\t\t\trep(i, h)rep(j, w)if (s2[i][j] == '#')cnt++;\n\t\t\tif (cnt <= prev)s = s2, prev = cnt, up2 = 1;\n\t\t}\n\t}\n\tcout << prev << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <random>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\n\ntypedef\ntree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> orderedSet;\n\n#define pb push_back\n#define F first\n#define S second\n#define all(a) (a).begin(), (a).end()\n\n#define for1(i0, l0, r0) for (int i0 = l0; i0 < r0; ++i0)\n#define for2(i0, l0, r0) for (int i0 = l0; i0 <= r0; ++i0)\n#define forn(i0, n0) for (int i0 = 0; i0 < n0; ++i0)\n#define forn1(i0, n0) for (int i0 = 1; i0 < n0; ++i0)\n#define forr(i0, n0) for (int i0 = n0; i0 >= 0; --i0)\n#define forr1(i0, r0, l0) for (int i0 = r0; i0 > l0; --i0)\n#define forr2(i0, r0, l0) for (int i0 = r0; i0 >= l0; --i0)\n\n#define Sort(a) sort(all(a))\n#define Reverse(a) reverse(all(a))\n\ntypedef long double ld;\n#define ui unsigned int\n#define ull unsigned long long\n\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef pair<string, string> pss;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<ld> vld;\ntypedef vector<bool> vb;\ntypedef vector<string> vs;\n\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\n\ntypedef vector<vi> vvi;\ntypedef vector<vd> vvd;\ntypedef vector<vll> vvll;\ntypedef vector<vb> vvb;\n\n#define vpss vector<pss>\n#define vvs vector<vs>\n#define vvpii vector<vpii>\n#define vvpll vector<vpll>\n#define vpt vector<pt>\n#define vvvi vector<vvi>\n#define vsi vector<set<int>>\n#define ss second\n#define ff first\n\n#define printvi(arr) for (int x0 : arr) cout << x0 << ' '; cout << '\\n';\n#define printvll(arr) for (ll x0 : arr) cout << x0 << ' '; cout << '\\n';\n#define printpair(pair0) cout << pair0.F << ' ' << pair0.S << '\\n';\n#define printvp(arr) for (auto pair0 : arr) printpair(pair0);\n#define initArray(arr, N0, X0) memset(arr, X0, N0 * sizeof(int))\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid init() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    //cout.precision(16);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n}\n\nconst int inf = 1e9;\n\nint mincut(int n, vvi e, int I, int J){\n    int m = e.size();\n    vvi c(n, vi(n));\n    vvi f(n, vi(n));\n    vvi g(n);\n    forn(i, m){\n        int v, u, c0;\n        v = e[i][0], u = e[i][1], c0 = e[i][2];\n        c[v][u] += c0;\n        //c[u][v] += c0;\n        g[v].pb(u);\n        //g[u].pb(v);\n    }\n    int ans = 0;\n    while(true){\n        queue<int> q;\n        q.push(I);\n        vi p(n, -1);\n        p[I] = -2;\n        while(!q.empty()){\n            int v = q.front();\n            q.pop();\n            for (int i: g[v]){\n                if (c[v][i] > f[v][i] && p[i] == -1){\n                    p[i] = v;\n                    q.push(i);\n                }\n            }\n        }\n        if (p[J] == -1) break;\n        vi path;\n        int minimum = 2e9;\n        int idx = J;\n        path.pb(idx);\n        while(idx != I){\n            minimum = min(minimum, c[p[idx]][idx] - f[p[idx]][idx]);\n            idx = p[idx];\n            path.pb(idx);\n        }\n        ans += minimum;\n        Reverse(path);\n        forn1(i, path.size()){\n            f[path[i]][path[i - 1]] -= minimum;\n            f[path[i - 1]][path[i]] += minimum;\n        }\n    }\n    return ans;\n}\n\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    vs a(n);\n    forn(i, n) cin >> a[i];\n    forn(i, n) {\n         forn(j, m){\n             if (i == 0 || j == 0 || i == n - 1 || j == m - 1){\n                 if (a[i][j] == 'X'){\n                     cout << \"-1\\n\";\n                     return;\n                 }\n             }\n         }\n    }\n    int N = n * m;\n    int I = 2 * N, J = I + 1;\n    vvi e;\n    forn(i, n){\n        forn(j, m){\n            if (i > 0) e.pb({N + i * m + j, (i - 1) * m + j, inf});\n            if (i + 1 < n) e.pb({N + i * m + j, (i + 1) * m + j, inf});\n            if (j > 0) e.pb({N + i * m + j, i * m + j - 1, inf});\n            if (j + 1 < m) e.pb({N + i * m + j, i * m + j + 1, inf});\n            if (a[i][j] == 'X') e.pb({I, i * m + j, inf});\n            if (i == 0 || i == n - 1 || j == 0 || j == m - 1) e.pb({N + i * m + j, J, inf});\n            e.pb({i * m + j, i * m + j + N, (a[i][j] == '.' ? 1 : inf)});\n        }\n    }\n    cout << mincut(2 * N + 2, e, I, J) << '\\n';\n}\n\nbool multitest = false;\n\nint main() {\n    init();\n    int t = 1;\n    if (multitest) cin >> t;\n    forn(i, t) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint V, E, src, snk;\nvector<int> la, nxt, oppo, capa;\nvoid init() {\n    E = 0;\n    la.clear(); nxt.clear(); oppo.clear(); capa.clear();\n    la = vector<int>(V, -1);\n}\nvoid add(int u, int v, int c) {\n    nxt.push_back(la[u]);\n    la[u] = E++;\n    oppo.push_back(v);\n    capa.push_back(c);\n}\nvector<int> dist;\nqueue<int> q;\nbool bfs() {\n    dist = vector<int>(V, -1);\n    q.push(src);\n    dist[src] = 0;\n    while(!q.empty()) {\n        int u = q.front(); q.pop();\n\n        for(int i = la[u]; i != -1; i = nxt[i]) {\n            int v = oppo[i];\n            if(capa[i] && dist[v] == -1) {\n                dist[v] = dist[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n    return dist[snk] != -1;\n}\nvector<int> laa;\nint dfs(int u, int f) {\n    if(u == snk) return f;\n\n    for(int i = laa[u]; i != -1; i = nxt[i]) {\n        laa[u] = i;\n        int v = oppo[i];\n        if(capa[i] && dist[v] == dist[u] + 1) {\n            if(int tmp = dfs(v, min(capa[i], f))) {\n                capa[i] -= tmp;\n                capa[i ^ 1] += tmp;\n                return tmp;\n            }\n        }\n    }\n    return 0;\n}\nint dinic() {\n    int tf = 0;\n    while(bfs()) {\n        laa = la;\n        while(int tmp = dfs(src, 1e8)) tf += tmp;\n    }\n    return tf;\n}\n\nint dx[4] = {0, 0, 1, -1};\nint dy[4] = {1, -1, 0, 0};\n\nint H, W;\nvector<string> G;\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n\n    G.resize(H);\n\n    for(int i = 0; i < H; i++) {\n        cin>>G[i];\n    }\n\n    V = 2*H*W + 2, src = V - 2, snk = V - 1;\n    init();\n\n    for(int i = 0; i < H; i++) {\n        for(int j = 0; j < W; j++) {\n            add(i*W + j, H*W + i*W + j, (G[i][j] == '.'? 1 : 1e8));\n            add(H*W + i*W + j, i*W + j, 0);\n\n            if(G[i][j] == 'X') {\n                add(src, i*W + j, 1e8);\n                add(i*W + j, src, 0);\n            }\n\n            bool edge = false;\n            for(int k = 0; k < 4; k++) {\n                int ni = i + dy[k];\n                int nj = j + dx[k];\n                if(ni < 0 || H <= ni || nj < 0 || W <= nj) {\n                    edge = true;\n                    continue;\n                }\n                add(H*W + i*W + j, ni*W + nj, 1e8);\n                add(ni*W + nj, H*W + i*W + j, 0);\n            }\n\n            if(edge) {\n                add(H*W + i*W + j, snk, 1e8);\n                add(snk, H*W + i*W + j, 0);\n            }\n\n            if(edge && G[i][j] == 'X') {\n                printf(\"-1\\n\");\n                return 0;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", dinic());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXH = 111;\nstring S[MAXH];\nbool need[MAXH][MAXH];\nbool memo[MAXH][MAXH];\n\nvoid debug(int H, int W) {\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cerr << need[i][j];\n        }\n        cerr << endl;\n    }\n    cerr << endl;\n}\n\nvoid no() {\n    cout << -1 << endl;\n    exit(0);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int H, W;\n    cin >> H >> W;\n    for (int i = 0; i < H; i++)\n        cin >> S[i];\n    for (int i = 0; i < W; i++) {\n        if (S[0][i] == 'X' || S[H-1][i] == 'X') no();\n    }\n    for (int i = 0; i < H; i++) {\n        if (S[i][0] == 'X' || S[i][W-1] == 'X') no();\n    }\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (S[i][j] == 'X') {\n                for (int k = 0; k < 4; k++)\n                    if (S[i+dy[k]][j+dx[k]] != 'X') need[i+dy[k]][j+dx[k]] = true;\n            }\n        }\n    }\n    debug(H, W);\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (need[i][j]) {\n                queue<pii> que;\n                memset(memo, false, sizeof(memo));\n                memo[i][j] = true;\n                que.push(pii(i, j));\n                while (!que.empty()) {\n                    auto p = que.front(); que.pop();\n                    int y = p.first, x = p.second;\n                    for (int k = 0; k < 4; k++) {\n                        int ny = y+dy[k], nx = x+dx[k];\n                        if (ny < 0 || ny >= H || nx < 0 || nx >= W) continue;\n                        if (memo[ny][nx]) continue;\n                        if (need[ny][nx]) continue;\n                        memo[ny][nx] = true;\n                        que.push(pii(ny, nx));\n                    }\n                }\n                bool ng = true;\n                for (int y = 0; y < H; y++) {\n                    if (memo[y][0] || memo[y][W-1]) ng = false;\n                }\n                for (int x = 0; x < W; x++) {\n                    if (memo[0][x] || memo[H-1][x]) ng = false;\n                }\n                if (ng) {\n                    need[i][j] = false;\n                }\n            }\n        }\n    }\n    debug(H, W);\n\n    int ans = 0;\n    for (int i = 0; i < H; i++)\n        for (int j = 0; j < W; j++)\n            if (need[i][j]) ans++;\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cap, rev;\n    Edge(){};\n    Edge(int to0, int cap0){to = to0; cap = cap0;}\n    Edge(int to0, int cap0, int rev0){to = to0; cap = cap0; rev = rev0;}\n};\n\nint maxFlow(const vector<vector<Edge> >& edges0, int source, int sink)\n{\n    static vector<vector<Edge> > edges;\n    static vector<unsigned> index;\n    static vector<int> level;\n    static int n;\n\n    class Func{\n    public:\n        static void bfs(int s){\n            level.assign(n, -1);\n            queue<int> q;\n            level[s] = 0;\n            q.push(s);\n            while(!q.empty()){\n                int v = q.front();\n                q.pop();\n                for(unsigned i=0; i<edges[v].size(); ++i){\n                    Edge& e = edges[v][i];\n                    if(e.cap > 0 && level[e.to] < 0){\n                        level[e.to] = level[v] + 1;\n                        q.push(e.to);\n                    }\n                }\n            }\n        }\n        static int dfs(int s, int t, int f){\n            if(s == t)\n                return f;\n            for(unsigned& i=index[s]; i<edges[s].size(); ++i){\n                Edge& e = edges[s][i];\n                if(e.cap > 0 && level[s] < level[e.to]){\n                    int g = dfs(e.to, t, min(f, e.cap));\n                    if(g > 0){\n                        e.cap -= g;\n                        edges[e.to][e.rev].cap += g;\n                        return g;\n                    }\n                }\n            }\n            return 0;\n        }\n    };\n\n    if(source == sink)\n        return INT_MAX;\n\n    n = edges0.size();\n    edges.assign(n, vector<Edge>());\n    for(int i=0; i<n; ++i){\n        for(unsigned j=0; j<edges0[i].size(); ++j){\n            const Edge& e = edges0[i][j];\n            edges[i].push_back(Edge(e.to, e.cap, edges[e.to].size()));\n            edges[e.to].push_back(Edge(i, 0, edges[i].size()-1));\n        }\n    }\n\n    int ret = 0;\n    for(;;){\n        Func::bfs(source);\n        if(level[sink] < 0)\n            return ret;\n        index.assign(n, 0);\n        int f;\n        while((f = Func::dfs(source, sink, INT_MAX)) > 0)\n            ret += f;\n    }\n}\n\nconst int INF = 20000;\nconst int dy[] = {-1, 1, 0, 0};\nconst int dx[] = {0, 0, -1, 1};\n\nint main()\n{\n    int h, w;\n    cin >> h >> w;\n\n    vector<vector<Edge> > edges(h*w*2+2);\n    int source = h * w * 2;\n    int sink = h * w * 2 + 1;\n    for(int y=0; y<h; ++y){\n        for(int x=0; x<w; ++x){\n            int i = y * w + x;\n            for(int k=0; k<4; ++k){\n                int y2 = y + dy[k];\n                int x2 = x + dx[k];\n                if(!(0 <= y2 && y2 < h && 0 <= x2 && x2 < w))\n                    continue;\n                int j = y2 * w + x2;\n                edges[2*i+1].push_back(Edge(2*j, INF));\n            }\n            if(y == 0 || y == h - 1 || x == 0 || x == w - 1)\n                edges[2*i+1].push_back(Edge(sink, INF));\n\n            char c;\n            cin >> c;\n            if(c == 'X'){\n                edges[source].push_back(Edge(2*i, INF));\n                edges[2*i].push_back(Edge(2*i+1, INF));\n            }\n            else{\n                edges[2*i].push_back(Edge(2*i+1, 1));\n            }\n        }\n    }\n\n    int ans = maxFlow(edges, source, sink);\n    if(ans < INF)\n        cout << ans << endl;\n    else\n        cout << -1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n     File Name: 1.cpp\n     ID: Liusiyu\n     BLOG: http://blog.csdn.net/r_o_j \n     LANG: C++ \n     Mail: 779532360@qq.com \n     Created Time: 2016年10月03日 星期一 17时01分20秒\n ************************************************************************/\n#include<bits/stdc++.h>\n#define MEM(a,x) memset(a,x,sizeof(a));\n#define MEMINF(a) memset(a,0x3f,sizeof(a));\nusing namespace std;\ntypedef long long LL;\nconst int MAXN=1e5+10;\nconst int MAXM=MAXN<<1;\nconst int INF=0x3f3f3f3f;\nconst int MOD=1000000007;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nstruct MaxFlow{  \n    int head[MAXN];  \n    struct Edge{  \n        int u,v,nex,cap,flow;  \n    }edge[MAXM];  \n    int tot;\n    int s,t;\n    int dis[MAXN];  \n    int cur[MAXN];  \n    void Dinic_init(int s,int t){  \n        this->s=s;\n        this->t=t;  \n        MEM(head,-1);  \n        tot=0;  \n    }  \n    void Addedge(int u,int v,int w) {  \n        edge[tot].v=v,edge[tot].cap=w,edge[tot].flow=0,edge[tot].nex=head[u],head[u]=tot++;  \n        edge[tot].v=u,edge[tot].cap=0,edge[tot].flow=0,edge[tot].nex=head[v],head[v]=tot++;  \n    }  \n    bool bfs() {  \n        MEM(dis,-1);  \n        queue<int>q;  \n        dis[s]=0;  \n        q.push(s);  \n        while (!q.empty()) {  \n            int u=q.front();  \n            q.pop();  \n            for (int i=head[u]; ~i; i=edge[i].nex) {  \n                int v=edge[i].v;  \n                if (edge[i].cap>edge[i].flow&&dis[v]==-1) {  \n                    q.push(v);  \n                    dis[v]=dis[u]+1;  \n                }  \n            }  \n        }  \n        return dis[t]!=-1;  \n    }  \n    int dfs(int u,int delta) {  \n        if (u==t||delta==0)  \n            return delta;  \n            int ret=0;  \n            int aug;  \n            for(int &i=cur[u]; ~i; i=edge[i].nex) {  \n                int v=edge[i].v;  \n                if (dis[v]==dis[u]+1&&(aug=dfs(v,min(edge[i].cap-edge[i].flow,delta)))>0) {  \n                    edge[i].flow+=aug;  \n                    edge[i^1].flow-=aug;  \n                    delta-=aug;  \n                    ret+=aug;  \n                    if (delta==0) break;  \n                }  \n            }  \n            return ret;  \n    }  \n    void dinic() {  \n        int ret=0;  \n        while(bfs()) {  \n            memcpy(cur,head,sizeof head);  \n            ret+=dfs(s,INF);  \n            //cout<<ret<<endl;  \n        }  \n        cout<<ret<<endl;  \n     }  \n}nima; \nint H,W;\nint zb(int x,int y) {\n  return (x*W+y)*2;\n}\n\nchar mp[MAXN][MAXN];\nint main() {\n  scanf(\"%d %d\",&H,&W);\n  int T,S;\n  S=H*W*2;\n  T=S+1;\n  nima.Dinic_init(H*W*2,H*W*2+1);\n  for (int i=0; i<H; ++i) {\n    cin>>mp[i]+0;\n  }\n  for (int i=0; i<H; ++i) {\n    if (mp[i][0]=='X'||mp[i][W-1]=='X') {\n      puts(\"-1\");\n      return 0;\n    }\n    nima.Addedge(T,zb(i,0),INF);\n    nima.Addedge(T,zb(i,W-1),INF);\n  }\n  for (int i=0; i<W; ++i) {\n    if (mp[0][i]=='X'||mp[W-1][H]=='X') {\n      puts(\"-1\");\n      return 0;\n    }\n    nima.Addedge(T,zb(0,i),INF);\n    nima.Addedge(T,zb(W-1,H),INF);\n  }\n  for (int i=0; i<H; ++i) \n    for (int j=0; j<W; ++j) {\n      if (mp[i][j]=='X') nima.Addedge(zb(i,j),S,INF);\n      else {\n        nima.Addedge(zb(i,j),zb(i,j)+1,1);\n      }\n      for (int k=0; k<4; ++k) {\n        int x=i+dx[k];\n        int y=j+dy[k];\n        if (x<0||x>=H||y<0||y>=W) continue;\n        nima.Addedge(zb(i,j)+1,zb(x,y),INF);\n      }\n    }\n  nima.dinic();\n}\n\n        \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T> using Graph = vector<vector<T>>;\n\n#define REP(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (__typeof(a.begin()) x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define endl '\\n'\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint H, W;\nstring S[105];\nbool used[105][105];\n\nbool is_inside(int x, int y) {\n  return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nbool is_surrounded(int x, int y) {\n  if (x == 0 || x == W - 1 || y == 0 || y == H - 1) return false;\n  used[y][x] = true;\n  bool res = true;\n  rep(i, 4) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if (!is_inside(nx, ny)) continue;\n    if (used[ny][nx]) continue;\n    if (S[ny][nx] == '.') {\n      res &= is_surrounded(nx, ny);\n      if (!res) break;\n    }\n  }\n  used[y][x] = false;\n  return res;\n}\n\nint solve() {\n  rep(i, W) if (S[0][i] == 'X' || S[H - 1][i] == 'X') return -1;\n  rep(i, H) if (S[i][0] == 'X' || S[i][W - 1] == 'X') return -1;\n\n  int ans = 0;\n  rep(y, H) rep(x, W) {\n    if (S[y][x] != 'X') continue;\n    rep(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (!is_inside(nx, ny)) continue;\n      if (S[ny][nx] == '.') {\n        S[ny][nx] = '#';\n        ans += 1;\n      }\n    }\n  }\n\n  rep(y, H) rep(x, W) {\n    if (S[y][x] == '#') {\n      if (is_surrounded(x, y)) {\n        S[y][x] = '.';\n        ans -= 1;\n      }\n    }\n  }\n\n  return ans;\n}\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> H >> W;\n  rep(i, H) cin >> S[i];\n\n  cout << solve() << endl;\n  //rep(i, H) cout << S[i] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n//Ford-Fulkerson O(FE)\n#include<algorithm>\n#include<utility>\n#include<vector>\n#include<limits>\ntemplate<typename T>\nstruct MF{\n\tstruct edge{\n\t\tint to,rev;\n\t\tT cap;\n\t};\n\tvector<vector<edge> >G;\n\tvector<int>used;\n\tMF(int n_=0):G(n_),used(n_,0){}\n\tvoid add_edge(int from,int to,T cap)\n\t{\n\t\tG[from].push_back({to,(int)G[to].size(),cap});\n\t\tG[to].push_back({from,(int)G[from].size()-1,0});\n\t}\n\tT dfs(int u,int t,T f,int dfstime)\n\t{\n\t\tif(u==t)return f;\n\t\tused[u]=dfstime;\n\t\tfor(edge&e:G[u])\n\t\t{\n\t\t\tif(used[e.to]<dfstime&&e.cap>0)\n\t\t\t{\n\t\t\t\tT d=dfs(e.to,t,min(f,e.cap),dfstime);\n\t\t\t\tif(d>0)\n\t\t\t\t{\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tT max_flow(int s,int t)\n\t{\n\t\tT ret=0;\n\t\tfor(int dfstime=1;;dfstime++)\n\t\t{\n\t\t\tT f=dfs(s,t,numeric_limits<T>::max(),dfstime);\n\t\t\tif(f>0)ret+=f;\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n};\nint H,W;\nstring s[100];\nint d[4]={1,0,-1,0};\nmain()\n{\n\tcin>>H>>W;\n\tfor(int i=0;i<H;i++)cin>>s[i];\n\tMF<int>P(H*W*2+2);\n\tint st=H*W*2,go=H*W*2+1;\n\tfor(int i=0;i<H;i++)for(int j=0;j<W;j++)\n\t{\n\t\tint id=i*W+j;\n\t\tif(i==0||j==0||i==H-1||j==W-1)P.add_edge(id*2+1,go,1e9);\n\t\tif(s[i][j]=='X')\n\t\t{\n\t\t\tP.add_edge(st,id*2,1e9);\n\t\t\tP.add_edge(id*2,id*2+1,1e9);\n\t\t}\n\t\telse P.add_edge(id*2,id*2+1,1);\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint x=i+d[r],y=j+d[r^1];\n\t\t\tif(x<0||y<0||x>=H||y>=W)continue;\n\t\t\tP.add_edge(id*2+1,2*(x*W+y),1e9);\n\t\t}\n\t}\n\tint ans=P.max_flow(st,go);\n\tif(ans<1e9)cout<<ans<<endl;\n\telse cout<<-1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Kyoto University Programming Contest 2016\n// E - 柵 / Fences\n\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#define MAX_H 100\n#define MAX_W 100\n#define MAX_V (MAX_H * MAX_W * 2 + 2)\n#define INF 100000000\nusing namespace std;\n\n\nstruct edge{\n  int to, cap, rev; // 行き先, 容量, 逆辺番号\n};\n\nclass Graph{\npublic:\n  void add_edge(int from, int to, int cap);\n  int max_flow(int s, int t);\nprivate:\n  void bfs(int s);\n  int dfs(int v, int t, int f);\nprivate:\n  vector<edge> g[MAX_V];\n  int level[MAX_V];\n  int iter[MAX_V];\n};\n\nvoid Graph::add_edge(int from, int to, int cap) {\n  g[from].push_back((edge){to, cap, (int)g[to].size()});\n  g[to].push_back((edge){from, 0, (int)g[from].size() - 1});\n  return;\n}\n\nint Graph::max_flow(int s, int t) {\n  int f;\n  int flow = 0;\n\n  while (true) {\n    bfs(s);\n    if (level[t] < 0) {\n      break;\n    }\n    memset(iter, 0, sizeof(iter));\n    while ((f = dfs(s, t, INF)) > 0) {\n      flow += f;\n    }\n  }\n  return flow;\n}\n\nvoid Graph::bfs(int s) {\n  queue<int> que;\n  int v;\n  int i;\n\n  memset(level, -1, sizeof(level));\n  level[s] = 0;\n  que.push(s);\n  while (!que.empty()) {\n    v = que.front();\n    que.pop();\n    for (i = 0; i < (int)g[v].size(); i++) {\n      if (g[v][i].cap > 0 && level[g[v][i].to] < 0) {\n        level[g[v][i].to] = level[v] + 1;\n        que.push(g[v][i].to);\n      }\n    }\n  }\n  return;\n}\n\nint Graph::dfs(int v, int t, int f) {\n  int d;\n\n  if (v == t) {\n    return f;\n  }\n  for ( ; iter[v] < (int)g[v].size(); iter[v]++) {\n    edge &e = g[v][iter[v]];\n    if (e.cap > 0 && level[v] < level[e.to]) {\n      d = dfs(e.to, t, min(f, e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        g[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\n\nint H, W;\nGraph G;\nint dy[4] = { -1, 0, 1, 0 };\nint dx[4] = { 0, 1, 0, -1 };\nconst int S = MAX_H * MAX_W * 2 + 0;\nconst int T = MAX_H * MAX_W * 2 + 1;\nint ans;\n\nint main() {\n\n  int y, x;\n  char buff[MAX_W + 2];\n\n  scanf(\"%d%d\", &H, &W);\n  for (int i = 0; i < H; i++) {\n    scanf(\"%s\", buff);\n    for (int j = 0; j < W; j++) {\n      if (buff[j] == 'X') {\n        G.add_edge(S, (i * W + j) * 2 + 0, INF);\n        G.add_edge((i * W + j) * 2 + 0, (i * W + j) * 2 + 1, INF);\n      } else {\n        G.add_edge((i * W + j) * 2 + 0, (i * W + j) * 2 + 1, 1);\n      }\n      for (int k = 0; k < 4; k++) {\n        y = i + dy[k];\n        x = j + dx[k];\n        if (y < 0 || H <= y || x < 0 || W <= x) {\n          G.add_edge((i * W + j) * 2 + 1, T, INF);\n        } else {\n          G.add_edge((i * W + j) * 2 + 1, (y * W + x) * 2 + 0, INF);\n        }\n      }\n    }\n  }\n\n  ans = G.max_flow(S, T);\n  ans = ans >= INF ? -1 : ans;\n  printf(\"%d\\n\", ans);\n\n  return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstruct edge {\n\tint to, cap, rev;\n};\n\nvector<edge>X[100009]; bool used[100009];\n\nvoid add_edge(int u, int v, int w) {\n\tX[u].push_back(edge{ v, w, (int)X[v].size() });\n\tX[v].push_back(edge{ u, 0, (int)X[u].size() - 1 });\n}\nint dfs(int v, int t, int f) {\n\tif (v == t) return f;\n\tused[v] = true;\n\tfor (int i = 0; i < X[v].size(); i++) {\n\t\tif (used[X[v][i].to] == true || X[v][i].cap <= 0) continue;\n\t\tint D = dfs(X[v][i].to, t, min(X[v][i].cap, f));\n\t\tif (D > 0) {\n\t\t\tX[v][i].cap -= D;\n\t\t\tX[X[v][i].to][X[v][i].rev].cap += D;\n\t\t\treturn D;\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int u, int v) {\n\tint ret = 0;\n\twhile (true) {\n\t\tfor (int i = 0; i < 20009; i++) used[i] = false;\n\t\tint T = dfs(u, v, 1000000007);\n\t\tif (T == 0) break;\n\t\tret += T;\n\t}\n\treturn ret;\n}\n\nint H, W; string S[100]; bool flag = false;\n\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) cin >> S[i];\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (i >= 1 && i < H - 1 && j >= 1 && j < W - 1) continue;\n\t\t\tif (S[i][j] == 'X') flag = true;\n\t\t}\n\t}\n\tif (flag == true) { cout << \"-1\" << endl; return 0; }\n\tint cnts = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (S[i][j] != 'X') { add_edge(H*W + cnts, cnts, 1); }\n\t\t\tif (S[i][j] == 'X') { add_edge(H*W + cnts, cnts, 1000000007); }\n\t\t\tcnts++;\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tint cx = i + dx[k], cy = j + dy[k];\n\t\t\t\tif (cx < 0 || cy < 0 || cx >= H || cy >= W) continue;\n\t\t\t\tadd_edge(i*W + j, H*W + cx*W + cy, 1000000007);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (S[i][j] == 'X') add_edge(2 * H*W, H*W + i*W + j, 1000000007);\n\t\t\tif (i >= 1 && i < H - 1 && j >= 1 && j < W - 1) continue;\n\t\t\tadd_edge(i*W + j, 2 * H*W + 1, 1000000007);\n\t\t}\n\t}\n\tcout << max_flow(2 * H*W, 2 * H*W + 1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans-7<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <tuple>\n#include <set>\n#include <map>\n#include <complex>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\n\ntypedef tuple<ll, ll, ll, ll> T;\ntypedef pair<ll, ll> P;\n\nconst int INF = 1e6;\n\ntypedef int Weight;\ntypedef int Flow;\n\nstruct Edge {\n\tint src, dest, rev;\n\tFlow cap;\n\tWeight cost;\n\tbool operator < (const Edge &rhs) const {\n\t\treturn cost > rhs.cost;\n\t}\n\tEdge(int s, int d) : src(s), dest(d) { ; }\n\tEdge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n\tEdge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n//Veryfied AOJ 1163\ntypedef int Weight;\ntypedef int Flow;\n\nvoid add_edge(Graph &g, int src, int dest, Flow cap) {\n\tg[src].push_back(Edge(src, dest, (int)g[dest].size(), cap, 0));\n\tg[dest].push_back(Edge(dest, src, (int)g[src].size() - 1, 0, 0));\n}\n\nFlow dfs(Graph &g, vector<bool> &used, int v, int t, Flow f) {\n\tif (v == t) return f;\n\tused[v] = true;\n\tfor (Edge &e : g[v]) {\n\t\tif (!used[e.dest] && e.cap > 0) {\n\t\t\tFlow d = dfs(g, used, e.dest, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tg[e.dest][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nFlow ford_fulkerson(Graph &g, int s, int t) {\n\tFlow flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(g.size(), false);\n\t\tFlow f = dfs(g, used, s, t, INF);\n\t\tif (f == 0) return flow;\n\t\tflow += f;\n\t}\n}\nint main() {\n\tint H, W;\n\tcin >> H >> W;\n\tvector<string> area(H);\n\tfor (int i = 0;i < H;i++)\n\t\tcin >> area[i];\n\t// in h+H*w  out H*W+h+H*w \n\t// left:-H, right: +H, up: -1, down: 1\n\tconst int sink = H * W * 2;\n\tconst int tank = H * W * 2 + 1;\n\tGraph g(H * W * 2 + 2);\n\tint dx[] = {1,0,-1,0};\n\tint dy[] = {0,-1,0,1};\n\tfor (int y = 0;y < H;y++)\n\t\tfor (int x = 0;x < W;x++) {\n\t\t\tint in = y + H * x;\n\t\t\tint out = in + H * W;\n\t\t\tint cap;\n\t\t\tif (area[y][x] == '.')\n\t\t\t\tcap = 1;\n\t\t\telse {\n\t\t\t\tcap = INF;\n\t\t\t\tadd_edge(g,sink,in,INF);\n\t\t\t}\n\t\t\tadd_edge(g, in, out, cap); // in to out\n\n\t\t\tfor (int i = 0;i < 4;i++) {\n\t\t\t\tint tx = x + dx[i];\n\t\t\t\tint ty = y + dy[i];\n\t\t\t\tint toin = ty + H * tx;\n\t\t\t\tint toout = toin + H * W;\n\t\t\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H) {\n\t\t\t\t\tadd_edge(g,out,toin,INF);\n\t\t\t\t\tadd_edge(g, toout, in, INF);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tadd_edge(g, out, tank, INF);\n\t\t\t}\n\t\t}\n\tint ans = ford_fulkerson(g, sink, tank);\n\tif (ans >= INF)\n\t\tcout << -1 << endl;\n\telse\n\t\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n\nconst int maxn=22222;\nconst int maxm=1111111;\nconst int inf=1000000000;\n\nint g[maxn],to[maxm],np[maxm],cp;\nint n,u,v,now,source,sink;\nint sum,cap[maxm],a[maxn];\nint d[maxn],p[maxn],cur[maxn],cnt[maxn];\n\nvoid add_edge(int x,int y,int z){\n\tcap[cp]=z;to[cp]=y;np[cp]=g[x];g[x]=cp++;cap[cp]=0;to[cp]=x;np[cp]=g[y];g[y]=cp++;\n}\n\nvoid init(){\n\tcp=2; memset(g,0,sizeof(g));\n}\nint maxflow(){\n\tsum=0;\n\tfor(u=1;u<=n;u++)cur[u]=g[u]; a[u=source]=inf; memset(d,0,sizeof(int)*(n+1)); memset(cnt,0,sizeof(int)*(n+1)); cnt[0]=n;\n\twhile(d[source]<n)\n\t{\n\t\tfor(now=cur[u];now;now=np[now])if(cap[now]&&d[v=to[now]]+1==d[u])break; cur[u]=now;\n\t\tif(now)\n\t\t{\n\t\t\tp[v]=now; a[v]=cap[now]; if(a[v]>a[u])a[v]=a[u];\n\t\t\tif((u=v)==sink)\n\t\t\t{\n\t\t\t\tdo{cap[p[u]]-=a[sink]; cap[p[u]^1]+=a[sink]; u=to[p[u]^1];}while(u!=source);\n\t\t\t\tsum+=a[sink]; a[source]=inf;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(--cnt[d[u]]==0)break; d[u]=n; cur[u]=g[u];\n\t\t\tfor(now=g[u];now;now=np[now]) if(cap[now] && d[u]>d[to[now]]+1) d[u]=d[to[now]]+1;\n\t\t\tcnt[d[u]]++;\n\t\t\tif(u!=source)u=to[p[u]^1];\n\t\t}\n\t}\n\treturn sum;\n}\n\nint N,M;\nchar ss[111][111];\nbool input(){\n\tscanf(\"%d%d\",&N,&M);\n\tfor(int i=0; i<N; i++){\n\t\tscanf(\"%s\",ss[i]);\n\t\tfor(int j=0; j<M; j++)\n\t\tif(ss[i][j] == 'X' && (i==0 || i==N-1 || j==0 || j==M-1))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nconst int dx[4]={-1,0,1,0};\nconst int dy[4]={0,-1,0,1};\nint v_in(int x,int y){\n\treturn (x*M+y)*2+1;\n}\nint v_out(int x,int y){\n\treturn (x*M+y)*2+2;\n}\n\nint main(){\n\tif(!input()){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\n\tinit();\n\tsource = N*M*2+1;\n\tn = sink = source+1;\n\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<M; j++){\n\t\t\tif(ss[i][j] == 'X')\n\t\t\t\tadd_edge(source, v_out(i,j), inf);\n\t\t\telse{\n\t\t\t\tadd_edge(v_in(i,j), v_out(i,j), 1);\n\t\t\t\tif(i==0 || i==N-1 || j==0 || j==M-1){\n\t\t\t\t\tadd_edge(v_out(i,j), sink, inf);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\tint i2 = i+dx[k], j2 = j+dy[k];\n\t\t\t\tif(i2>=0 && i2<N && j2>=0 && j2<M)\n\t\t\t\t\tadd_edge(v_out(i,j),v_in(i2,j2),inf);\n\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\",maxflow());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\n\n#define FN 500010\n#define FM 4200010\n#define INF 103456780\n#define FOR(it,c) for ( __typeof((c).begin()) it=(c).begin(); it!=(c).end(); it++ )\nusing namespace std;\ntypedef long long LL;\nstruct E {\n    int k,c;\n    E(){}\n    E( int _k, int _c ):k(_k),c(_c){}\n} es[FM];\n\nstruct Flow {\n    int n,m,dis[FN];\n    int qq[FN],qr,ql;\n    vector<int> e[FN];\n    void init( int _n ) {\n        n=_n; m=0;\n        for ( int i=0; i<n; i++ ) e[i]=vector<int>();\n    }\n    void add_edge( int a, int b, int c ) {\n        e[a].push_back(m); es[m]=E(b,c); m++;\n        e[b].push_back(m); es[m]=E(a,0); m++;\n    }\n    bool BFS() {\n        memset(dis,-1,n*sizeof(int));\n        ql=qr=0;\n        qq[qr++]=0;\n        dis[0]=0;\n        while ( ql!=qr && dis[n-1]==-1 ) {\n            int p=qq[ql++];\n            FOR(it,e[p]) {\n                E ee=es[*it];\n                if ( ee.c==0 || dis[ee.k]!=-1 ) continue;\n                dis[ee.k]=dis[p]+1;\n                qq[qr++]=ee.k;\n            }\n        }\n        return dis[n-1]!=-1;\n    }\n    LL go( int p, LL c ) {\n        if ( p==n-1 ) return c;\n        LL ret=0,tmp;\n        FOR(it,e[p]) {\n            E &ee=es[*it];\n            if ( ee.c==0 || dis[p]+1!=dis[ee.k] ) continue;\n            tmp=go(ee.k,min(c-ret,(LL)ee.c));\n            ret+=tmp; ee.c-=tmp; es[(*it)^1].c+=tmp;\n            if ( ret==c ) break;\n        }\n        if ( ret==0 ) dis[p]=-1;\n        return ret;\n    }\n    LL maxflow() {\n        LL ret=0;\n        while ( BFS() ) ret+=go(0,1LL<<60);\n        return ret;\n    }\n} flow;\nint N,M;\nchar s[111][111];\nbool Out(int x,int y){\n    return x<0||y<0||x>=N||y>=M;\n}\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint get(int x,int y){\n    return x*M+y;\n}\nint main(){\n    RII(N,M);\n    flow.init(N*M*2+2);\n    REP(i,N)RS(s[i]);\n    REP(i,N){\n        if(s[i][0]=='X'||s[i][M-1]=='X')return 0*puts(\"-1\");\n        flow.add_edge(0,get(i,0)*2+1,INF);\n        flow.add_edge(0,get(i,M-1)*2+1,INF);\n    }\n    REP(i,M){\n        if(s[0][i]=='X'||s[N-1][i]=='X')return 0*puts(\"-1\");\n        flow.add_edge(0,get(0,i)*2+1,INF);\n        flow.add_edge(0,get(N-1,i)*2+1,INF);\n    }\n    REP(i,N){\n        REP(j,M){\n            int me=get(i,j)*2;\n            if(s[i][j]=='.'){\n                flow.add_edge(me+1,me+2,1);\n            }\n            else{\n                flow.add_edge(me+1,N*M*2+1,INF);\n            }\n            REP(k,4){\n                int nx=i+dx[k];\n                int ny=j+dy[k];\n                if(Out(nx,ny))continue;\n                flow.add_edge(me+2,get(nx,ny)*2+1,INF);\n            }\n        }\n    }\n    printf(\"%d\\n\",flow.maxflow());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream> \n#include<map>\n#include <iomanip>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\nusing namespace std;\n#define MAX_MOD 1000000007\n#define REP(i,n) for(long long i = 0;i < n;++i)\n#define LONGINF 1000000000000000000\ntemplate <typename T, typename U>\nstd::pair<T, U> operator+(const std::pair<T, U> & l, const std::pair<T, U> & r) {\n\treturn{ l.first + r.first,l.second + r.second };\n}\nmap<pair<int, int>, int> yagi;\nmap<pair<int, int>, int> saku;\npair<int, int> moves[4] = { make_pair(1,0),make_pair(-1,0),make_pair(0,-1),make_pair(0,1) };\nint h, w;\nbool check(pair<int, int> a) {\n\tif (a.first == 0 || a.second == 0) return false;\n\tif (a.first == h - 1 || a.second == w - 1) return false;\n\treturn true;\n}\nint main() {\n\tcin >> h >> w;\n\tqueue<pair<int, int>> letsmove;\n\tREP(i, h) {\n\t\tstring tmp;\n\t\tcin >> tmp;\n\t\tREP(q, w) {\n\t\t\tif (tmp[q] == 'X') {\n\t\t\t\tpair<int, int> foo = make_pair(i,q);\n\t\t\t\tif (check(foo) == false) {\n\t\t\t\t\tcout << \"-1\" << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tsaku[foo] = false;\n\t\t\t\tyagi[foo] = true;\n\t\t\t\tletsmove.push(foo);\n\t\t\t\tREP(j, 4) {\n\t\t\t\t\tif (yagi[foo + moves[j]] == false) saku[foo + moves[j]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//柵探索\n\twhile (letsmove.empty() == false) {\n\t\tpair<int, int> gogo = letsmove.front();\n\t\tletsmove.pop();\n\t\tfor (int i = 0;i < 4;++i) {\n\t\t\tif (check(gogo+moves[i])== true&&saku[gogo + moves[i]] == true) {\n\t\t\t\tint diag = -1;\n\t\t\t\tfor (int q = 0;q < 4;++q) {\n\t\t\t\t\tif (check(gogo + moves[i] + moves[q]) == false) goto out;\n\t\t\t\t\tif (saku[gogo + moves[i] + moves[q]] == false && yagi[gogo + moves[i] + moves[q]] == false) {\n\t\t\t\t\t\tif (diag == -1) {\n\t\t\t\t\t\t\tdiag = q;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse goto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tREP(q, 4) {\n\t\t\t\t\tletsmove.push(gogo + moves[i] + moves[q]);\n\t\t\t\t}\n\t\t\t\tletsmove.push(gogo + moves[i]);\n\t\t\t\tsaku[gogo+moves[i]] = false;\n\t\t\t\tyagi[gogo + moves[i]] = true;\n\t\t\t\tif (diag != -1) {\n\t\t\t\t\tsaku[gogo + moves[i] + moves[diag]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\tout:;\n\t\t}\n\t}\n\tint ans = 0;\n\tREP(i, h) {\n\t\tREP(q, w) {\n\t\t\tif (saku[make_pair(i,q)] == true)ans++;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105];\nbool fr[105][105],vis[105][105],st,ad,f;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tf=1;\n//\t\t\t\t\tad = f = 0;\n//\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n//\t\t\t\t\tif(ad){\n//\t\t\t\t\t\trep(o,b+1,m){\n//\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n//\t\t\t\t\t\t\tx[a][o] = '#';\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\tsolve();\n//\t\t\t\t\t\tif(ans>tmp){\n//\t\t\t\t\t\t\tans = tmp;\n//\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n//\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tf=1;\n//\t\t\t\t\tad = f = 0;\n//\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n//\t\t\t\t\tif(ad){\n//\t\t\t\t\t\trep(o,b+1,m){\n//\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n//\t\t\t\t\t\t\tx[a][o] = '#';\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\tsolve();\n//\t\t\t\t\t\tif(ans>tmp){\n//\t\t\t\t\t\t\tans = tmp;\n//\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n//\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 105\n#define M 51\n#define INF 500\n#define MOD 924844033\n#define MOD2 1000000009\n#define eps 1e-14\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,1,-1};\nstruct node\n{\n    int to,w;\n}edge[60*N*N];\nvector<int>e[60*N*N];\nint a[N][N],b[N][N],q[2*N*N],d[2*N*N],pt[2*N*N];\nchar s[N];\nint bg,ed,cnt;\n\nbool bfs(int s)\n{\n       int front=0,rear=0;\n       memset(d,-1,sizeof(d));\n       q[rear++]=s;\n       d[s]=0;\n       while(front<rear)\n       {\n               int k=q[front++];\n               for(int v:e[k])\n               {\n                   node &e1 = edge[v];\n                   if(e1.w>0&&d[e1.to]==-1)\n                   {\n                       d[e1.to]=d[k]+1;\n                       q[rear++]=e1.to;\n                   }\n               }\n       }\n       if(d[ed]>=0)\n             return true;\n       return false;\n}\n\nint dinic(int k,int sum)  //k is the sourse\n{\n      if (k==ed)return sum;\n      for (int &i = pt[k]; i < e[k].size(); ++i)\n      {\n          if(sum<=0)break;\n          int v = e[k][i];\n\n          node &e1 = edge[v];\n          node &e2 = edge[v^1];\n          if(d[e1.to]==d[k]+1&&e1.w>0)\n          {\n                if(int tmp = dinic(e1.to,min(sum,e1.w)))\n                {\n                    e1.w -= tmp;\n                    e2.w += tmp;\n                    return tmp;\n                }\n          }\n      }\n      return 0;\n}\n\nvoid addedge(int from,int to,int w)\n{\n    edge[cnt].to = to;\n    edge[cnt].w = w;\n    e[from].PB(cnt++);\n\n    edge[cnt].to = from;\n    edge[cnt].w = 0;\n    e[to].PB(cnt++);\n}\nint main()\n{\n    //freopen(\"out.txt\",\"r\",stdin);\n    //freopen(\"1.txt\",\"w\",stdout);\n    //cin.tie(0);\n    //ios::sync_with_stdio(false);\n    int n,m;\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n        cnt = 0;\n        bg = 1,ed = n*m*2+1;\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                a[i][j] = i*m+j;\n                b[i][j] = i*m+j+n*m;\n            }\n        }\n        int f = 1;\n        FOR(i,1,n)\n        {\n            scanf(\"%s\",s);\n            FOR(j,1,m)\n            {\n                if(s[j-1] == 'X')\n                {\n                    if(i == 1||i == n||j == 1||j == m)f = 0;\n                    addedge(a[i][j],b[i][j],INF);\n                    addedge(1,a[i][j],INF);\n                }\n                else addedge(a[i][j],b[i][j],1);\n            }\n        }\n        if(!f)\n        {\n            printf(\"-1\\n\");\n            continue;\n        }\n\n        FOR(i,1,n)\n        {\n            addedge(b[i][1],ed,INF);\n            addedge(b[i][m],ed,INF);\n            FOR(j,1,m-1)addedge(b[i][j],a[i][j+1],INF);;\n            FOR(j,2,m)addedge(b[i][j],a[i][j-1],INF);\n        }\n        FOR(j,1,m)\n        {\n            addedge(b[1][j],ed,INF);\n            addedge(b[n][j],ed,INF);\n            FOR(i,1,n-1)addedge(b[i][j],a[i+1][j],INF);\n            FOR(i,2,n)addedge(b[i][j],a[i-1][j],INF);\n        }\n        int ret = 0;\n        while(bfs(bg))\n        {\n            MST(pt,0);\n            while(int flow = dinic(bg,INF))\n                ret += flow;\n        }\n        printf(\"%d\\n\",ret);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <iostream>\n#include <random>\n#include <map>\n#include <iomanip>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include <fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\n\nusing ll = long long;\nusing vll = vector<ll>;\nusing pll = pair<ll, ll>;\nusing qll = queue<ll>;\nusing vb = vector<bool>;\nusing mll = map<ll, ll>;\nusing sll = stack<ll>;\n#define REP(i,n) for(ll i(0);(i)<(n);(i)++)\n#define rep(i,n) for(ll i(0);(i)<(n);(i)++)\n#define ALL(a) a.begin(), a.end()\n#define enld endl //* missspell check\nconst ll INF = 1LL << 60;\nll H, W;\nvll dx{1, 0, -1, 0}, dy{0, 1, 0, -1};\n\nstruct edgeForFlow{ll to, cap, rev; }; //! cap: may change; rev: pointer in G[to]\n\nvoid addEdgeForFlow(vector<vector<edgeForFlow>> &G, ll from, ll to, ll cap){\n    G[from].push_back((edgeForFlow){ to, cap,  (ll) G[to].size()});\n    G[to].push_back((edgeForFlow) { from, 0, (ll) G[from].size()-1});\n}\n\nll dfsFordFulkson(vector<vector<edgeForFlow>> &G, vb &checked, ll v, ll t, ll f){\n    //* v: current vertex, t: sink, f: DELTA of this path. (No need for source)\n    if(v == t) return f;\n    checked[v] = true;\n    REP(i, G[v].size()){\n        edgeForFlow &e = G[v][i];\n        if(!checked[e.to] && e.cap > 0){\n            ll d = dfsFordFulkson(G, checked, e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0; //* if no valid outgoing edges\n}\n\nll maxFlowFordFulkson(vector<vector<edgeForFlow>> &G, ll s, ll t){\n    vb checked(G.size());\n    ll flow = 0;\n    for(;;){\n        fill(ALL(checked), false);\n        ll f = dfsFordFulkson(G, checked, s, t, INF);\n        if(f == 0) \n            return flow;\n        flow += f;\n    }\n}\n\nvoid bfsDinic(vector<vector<edgeForFlow>> &G, vll &level, ll s){\n    fill(ALL(level), -1);\n    queue<ll> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()){\n        ll v = que.front(); que.pop();\n        for(ll i=0; i< G[v].size(); i++){\n            edgeForFlow &e = G[v][i];\n            if(e.cap > 0 && level[e.to] < 0){\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nll dfsDinic(vector<vector<edgeForFlow>> &G, vll &level, vll &iter, ll v, ll t, ll f){\n    //? iter: record where have been searched?\n    //* v: current vertex, t: sink, f: DELTA of this path. (No need for source)\n    if(v == t) return f;\n    for( ll &i = iter[v]; i < G[v].size(); i++){\n        edgeForFlow &e = G[v][i];\n        if( e.cap > 0 && level[v] < level[e.to]){\n            ll d = dfsDinic(G, level, iter, e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0; //* if no valid outgoing edges\n}\n\nll maxFlowDinic(vector<vector<edgeForFlow>> &G, ll s, ll t){\n    vll level(G.size()), iter(G.size());\n    ll flow = 0;\n    for(;;){\n        bfsDinic(G, level, s);\n        if(level[t] < 0)//* sink t is not reachable from s on current residual graph\n            return flow;\n        fill(ALL(iter), 0);\n        ll f;\n        while((f = dfsDinic(G, level, iter, s, t, INF)) > 0){\n            flow += f;\n            // cout<< \"flow: \"<<flow<<endl;\n        }\n    }\n}\n\nll xyToIdx(ll x, ll y){\n    return (x*W + y);\n}\n\nvoid idxToXY(ll idx, ll &x, ll &y){\n    x = idx / W;\n    y = idx % W;\n}\n\nvoid solve(long long H, long long W, std::vector<std::string> S){\n    ll N = H*W;\n    //* source: 2*N, sink: 2*N+1\n    vector<vector<edgeForFlow>> G(2*N+2);\n    REP(x, H){\n        REP(y, W){\n            ll u = xyToIdx(x, y), xto, yto;\n            REP(k, 4){\n                xto = x + dx[k]; yto = y + dy[k];\n                if(0 <= xto && xto < H && 0 <= yto && yto < W){\n                    ll v = xyToIdx(xto, yto);\n                    addEdgeForFlow(G, u+N, v, 1);\n                }\n            }\n            if(S[x][y]=='X'){\n                addEdgeForFlow(G, 2*N, u, H*W);\n                addEdgeForFlow(G, u, u+N, H*W);\n            }\n            else{\n                addEdgeForFlow(G, u, u+N, 1);\n            }\n            if( x == 0 || x == H-1 || y == 0 || y == W-1){\n                addEdgeForFlow(G, u+N, 2*N+1, H*W);\n            }\n        }\n    }\n\n    ll flow = 0;\n    flow = maxFlowDinic(G, 2*N, 2*N+1);\n    if(flow >= H*W)\n        cout<<-1<<endl;\n    else\n        cout << flow << endl;\n}\n\nint main(){\n    scanf(\"%lld\",&H);\n    scanf(\"%lld\",&W);\n    std::vector<std::string> S(H);\n    for(int i = 0 ; i < H ; i++){\n        std::cin >> S[i];\n    }\n    solve(H, W, std::move(S));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define SPEED ios::sync_with_stdio(false); cin.tie(0); cout.tie(0)\n#define fileio freopen(\"in.in\", \"r\", stdin),freopen(\"out.out\", \"w\", stdout);\n#define ll long long int\n#define FF first\n#define SS second\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<long long int,long long int>\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define pd(x) printf(\"%d\\n\",x)\n#define plld(x) printf(\"%lld\\n\",x)\n#define pss printf\n#define MOD 1000000007\n#define INF 1e9\n#define eps 0.00001\n#define endl '\\n'\n#define debug(n1) cout<<n1<<endl\nll h,w;\nbool vis[105][105];\nstring s;\nll get(ll i,ll j)\n{\n\treturn (i-1)*w+j;\n}\ntypedef long long LL;\n\nstruct Edge {\n  int from, to, cap, flow, index;\n  Edge(int from, int to, int cap, int flow, int index) :\n    from(from), to(to), cap(cap), flow(flow), index(index) {}\n};\n\nstruct PushRelabel {\n  int N;\n  vector<vector<Edge> > G;\n  vector<LL> excess;\n  vector<int> dist, active, count;\n  queue<int> Q;\n\n  PushRelabel(int N) : N(N), G(N), excess(N), dist(N), active(N), count(2*N) {}\n\n  void AddEdge(int from, int to, int cap) {\n    G[from].push_back(Edge(from, to, cap, 0, G[to].size()));\n    if (from == to) G[from].back().index++;\n    G[to].push_back(Edge(to, from, 0, 0, G[from].size() - 1));\n  }\n\n  void Enqueue(int v) { \n    if (!active[v] && excess[v] > 0) { active[v] = true; Q.push(v); } \n  }\n\n  void Push(Edge &e) {\n    int amt = int(min(excess[e.from], LL(e.cap - e.flow)));\n    if (dist[e.from] <= dist[e.to] || amt == 0) return;\n    e.flow += amt;\n    G[e.to][e.index].flow -= amt;\n    excess[e.to] += amt;    \n    excess[e.from] -= amt;\n    Enqueue(e.to);\n  }\n  \n  void Gap(int k) {\n    for (int v = 0; v < N; v++) {\n      if (dist[v] < k) continue;\n      count[dist[v]]--;\n      dist[v] = max(dist[v], N+1);\n      count[dist[v]]++;\n      Enqueue(v);\n    }\n  }\n\n  void Relabel(int v) {\n    count[dist[v]]--;\n    dist[v] = 2*N;\n    for (int i = 0; i < G[v].size(); i++) \n      if (G[v][i].cap - G[v][i].flow > 0)\n\tdist[v] = min(dist[v], dist[G[v][i].to] + 1);\n    count[dist[v]]++;\n    Enqueue(v);\n  }\n\n  void Discharge(int v) {\n    for (int i = 0; excess[v] > 0 && i < G[v].size(); i++) Push(G[v][i]);\n    if (excess[v] > 0) {\n      if (count[dist[v]] == 1) \n\tGap(dist[v]); \n      else\n\tRelabel(v);\n    }\n  }\n\n  LL GetMaxFlow(int s, int t) {\n    count[0] = N-1;\n    count[N] = 1;\n    dist[s] = N;\n    active[s] = active[t] = true;\n    for (int i = 0; i < G[s].size(); i++) {\n      excess[s] += G[s][i].cap;\n      Push(G[s][i]);\n    }\n    \n    while (!Q.empty()) {\n      int v = Q.front();\n      Q.pop();\n      active[v] = false;\n      Discharge(v);\n    }\n    \n    LL totflow = 0;\n    for (int i = 0; i < G[s].size(); i++) totflow += G[s][i].flow;\n    return totflow;\n  }\n};\nint main()\n{\n\tSPEED;\n\tmemset(vis,1,sizeof vis);\n\tcin>>h>>w;\n\tfor(int i=1;i<=h;i++)\n\t{\n\t\tcin>>s;\n\t\tfor(int j=1;j<=w;j++)\n\t\t{\n\t\t\tif(s[j-1]!='X')\n\t\t\t{\n\t\t\t\tvis[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=h;i++)\n\t\tif(vis[i][1]||vis[i][w])\n\t\t\treturn cout<<-11<<endl,0;\n\tfor(int i=1;i<=w;i++)\n\t\tif(vis[1][i]||vis[h][i])\n\t\t\treturn cout<<-11<<endl,0;\n\tPushRelabel pr(2*h*w+5);\n\tfor(int i=1;i<=h;i++)\n\t\tfor(int j=1;j<=w;j++)\n\t\t\tpr.AddEdge(get(i,j),get(i,j)+h*w,(vis[i][j]?INF:1));\n\tfor(int i=1;i<=h;i++)\n\t{\n\t\tfor(int j=1;j<=w;j++)\n\t\t{\n\t\t\tif(vis[i][j])\n\t\t\t\tpr.AddEdge(0,get(i,j),INF);\n\t\t\tif(!vis[i-1][j])\n\t\t\t\tpr.AddEdge(get(i,j)+h*w,get(i-1,j),INF);\n\t\t\tif(!vis[i+1][j])\n\t\t\t\tpr.AddEdge(get(i,j)+h*w,get(i+1,j),INF);\n\t\t\tif(!vis[i][j-1])\n\t\t\t\tpr.AddEdge(get(i,j)+h*w,get(i,j-1),INF);\n\t\t\tif(!vis[i][j+1])\n\t\t\t\tpr.AddEdge(get(i,j)+h*w,get(i,j+1),INF);\n\t\t}\n\t}\n\tfor(int i=1;i<=h;i++)\n\t{\n\t\tpr.AddEdge(h*w+get(i,1),2*h*w+1,INF);\n\t\tpr.AddEdge(h*w+get(i,w),2*h*w+1,INF);\n\t}\n\tfor(int i=1;i<=w;i++)\n\t{\n\t\tpr.AddEdge(h*w+get(1,i),2*h*w+1,INF);\n\t\tpr.AddEdge(h*w+get(h,i),2*h*w+1,INF);\n\t}\n\tcout<<pr.GetMaxFlow(0,2*h*w+1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<numeric>\n#include<functional>\n#include<algorithm>\n#include<bitset>\n#include<tuple>\n#include<unordered_set>\n#include<random>\n#include<array>\n#include<cassert>\nusing namespace std;\n#define INF (1<<29)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define uniq(v) v.erase(unique(all(v)),v.end())\n\n\n\n#define INF 1e+10\n#define EPS 1e-10\n#define EQ(a,b) (abs(a-b)<EPS)\n\n//誤差を考慮して足し算\ndouble add(double a, double b) {\n\tif (abs(a + b) < EPS*(abs(a) + abs(b)))return 0;\n\treturn a + b;\n}\nstruct P {//2次元ベクトル\n\tdouble x, y;\n\tP() {}\n\tP(double x, double y) :x(x), y(y) {}\n\tP operator + (P p) {\n\t\treturn P(add(x, p.x), add(y, p.y));\n\t}\n\tP operator - (P p) {\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\tP operator * (double d) {\n\t\treturn P(x*d, y*d);\n\t}\n\tP operator / (double d) {\n\t\treturn P(x / d, y / d);\n\t}\n\tdouble dot(P p) {//内積\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\tdouble det(P p) {//外積\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n\tbool equal(P p) {\n\t\treturn (x - p.x)*(x - p.x) + (y - p.y)*(y - p.y) < EPS*EPS;\n\t}\n\tdouble norm()const {\n\t\treturn sqrt(x*x + y*y);\n\t}\n};\n\n//凸包\nbool cmp_x(const P& p, const P& q) {\n\tif (p.x != q.x)return p.x<q.x;\n\treturn p.y<q.y;\n}\nvector<P> convex_hull(vector<P>& ps) {\n\tif (ps.empty())return ps;\n\tsort(ps.begin(), ps.end(), cmp_x);\n\tint k = 0;\n\tvector<P> qs(ps.size() * 2);\n\tfor (int i = 0; i<ps.size(); i++) {\n\t\twhile (k>1 && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0)k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tfor (int i = ps.size() - 2, t = k; i >= 0; i--) {\n\t\twhile (k>t && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0)k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\n\n\n\n\n\n\nbool on_seg(P p1, P p2, P q) {\n\treturn (p1 - q).det(p2 - q) == 0 && (p1 - q).dot(p2 - q) <= 0;\n}\nP intersection(P p1, P p2, P q1, P q2) {\n\treturn p1 + (p2 - p1)*((q2 - q1).det(q1 - p1) / (q2 - q1).det(p2 - p1));\n}\nbool is_intersect(P p1, P p2, P q1, P q2) {\n\tif (on_seg(p1, p2, q1) || on_seg(p1, p2, q2) || on_seg(q1, q2, p1) || on_seg(q1, q2, p2))return true;\n\tif ((p1 - p2).det(q1 - q2) == 0)return false;//平行\n\tP a = intersection(p1, p2, q1, q2);\n\treturn on_seg(p1, p2, a) && on_seg(q1, q2, a);\n}\ndouble dist(P p, P q) {\n\tp = p - q;\n\treturn sqrt(p.x*p.x + p.y*p.y);\n}\nP to_unit(P p) {\n\tdouble d = sqrt(p.x*p.x + p.y*p.y);\n\treturn p / d;\n}\ndouble dist_LP(P p1, P p2, P q) {\n\tdouble dx, dy;\n\tdx = p1.x - p2.x;\n\tdy = p1.y - p2.y;\n\tdouble d = min(dist(p1, q), dist(p2, q));\n\tpair<P, P> normal = make_pair(q + to_unit(P(-dy, dx))*d, q + to_unit(P(dy, -dx))*d);//法線ベクトル\n\tif (is_intersect(p1, p2, normal.first, normal.second)) {\n\t\treturn dist(q, intersection(p1, p2, normal.first, normal.second));\n\t}\n\treturn d;\n}\ndouble dist_LL(P p1, P p2, P q1, P q2) {\n\tif (is_intersect(p1, p2, q1, q2))return 0;\n\treturn min(min(dist_LP(p1, p2, q1), dist_LP(p1, p2, q2))\n\t\t, min(dist_LP(q1, q2, p1), dist_LP(q1, q2, p2)));\n}\nbool contains2(vector<P> &poly, P p, double inf = INF) {\n\tint cnt = 0;\n\tP q(p.x + inf, p.y);\n\tfor (int i = 0; i<poly.size(); i++) {\n\t\tif (is_intersect(poly[i], poly[(i + 1) % poly.size()], p, q))cnt++;\n\t}\n\treturn cnt & 1;\n}\n\n\n\n\n\n\nbool merge(vector<P> &a , vector<P> &b) {\n\tif (contains2(a, b.front()) || contains2(b, a.front())) return true;\n\trep(i,a.size()) {\n\t\trep(j,b.size()) {\n\t\t\tif (dist_LL(a[i], a[(i + 1) % a.size()], b[j], b[(j + 1) % b.size()]) <= 1 + EPS) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tvector<P> ps;\n\tint h, w;\n\tcin >> h >> w;\n\tvector<vector<P>> conv;\n\trep(y, h)rep(x, w) {\n\t\tchar c;\n\t\tcin >> c;\n\t\tif (c == 'X') {\n\t\t\tif (y == 0 || y + 1 == h || x == 0 || x + 1 == w) {\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tconv.push_back({ P(y, x) ,P(y, x + 1),P(y + 1, x) ,P(y + 1, x + 1) });\n\t\t}\n\t}\n\tbool change = true;\n\twhile (change) {\n\t\tchange = false;\n\t\tvector<vector<P>> nxt;\n\t\trep(i,conv.size()) {\n\t\t\tif (conv[i].empty())continue;\n\t\t\tfor (int j = i + 1; j < conv.size();j++) {\n\t\t\t\tif (conv[j].empty())continue;\n\t\t\t\tif (merge(conv[i],conv[j])) {\n\t\t\t\t\tfor (P p: conv[j]) {\n\t\t\t\t\t\tconv[i].push_back(p);\n\t\t\t\t\t}\n\t\t\t\t\tconv[j].clear();\n\t\t\t\t\tconv[i] = convex_hull(conv[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnxt.push_back(conv[i]);\n\t\t}\n\t\tconv.swap(nxt);\n\t}\n\tint ans = 0;\n\tfor (auto a : conv) {\n\t\trep(i, a.size()) {\n\t\t\tP s = a[i], t = a[(i + 1) % a.size()];\n\t\t\tans += max(fabs(s.y - t.y), fabs(s.x - t.x)) + EPS;\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n\nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n\nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n\ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size())mk();\n\t\tif(hit==q.size()<<1)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n\nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,3){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==3){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,3){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==3){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint V, E, src, snk;\nvector<int> la, nxt, oppo, capa;\nvoid init() {\n    E = 0;\n    la.clear(); nxt.clear(); oppo.clear(); capa.clear();\n    la = vector<int>(V, -1);\n}\nvoid add(int u, int v, int c) {\n    nxt.push_back(la[u]);\n    la[u] = E++;\n    oppo.push_back(v);\n    capa.push_back(c);\n}\nvector<int> dist;\nqueue<int> q;\nbool bfs() {\n    dist = vector<int>(V, -1);\n    q.push(src);\n    dist[src] = 0;\n    while(!q.empty()) {\n        int u = q.front(); q.pop();\n\n        for(int i = la[u]; i != -1; i = nxt[i]) {\n            int v = oppo[i];\n            if(capa[i] && dist[v] == -1) {\n                dist[v] = dist[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n    return dist[snk] != -1;\n}\nvector<int> laa;\nint dfs(int u, int f) {\n    if(u == snk) return f;\n\n    for(int i = laa[u]; i != -1; i = nxt[i]) {\n        laa[u] = i;\n        int v = oppo[i];\n        if(capa[i] && dist[v] == dist[u] + 1) {\n            if(int tmp = dfs(v, min(capa[i], f))) {\n                capa[i] -= tmp;\n                capa[i ^ 1] += tmp;\n                return tmp;\n            }\n        }\n    }\n    return 0;\n}\nint dinic() {\n    int tf = 0;\n    while(bfs()) {\n        laa = la;\n        while(int tmp = dfs(src, 1e9)) tf += tmp;\n    }\n    return tf;\n}\n\nint dx[4] = {0, 0, 1, -1};\nint dy[4] = {1, -1, 0, 0};\n\nint H, W;\nvector<vector<char> > G;\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n\n    G = vector<vector<char> >(H, vector<char>(W));\n\n    for(int i = 0; i < H; i++) {\n        scanf(\"\\n\");\n        for(int j = 0; j < W; j++) {\n            scanf(\"%c\", &G[i][j]);\n        }\n    }\n\n    V = 2*H*W + 2, src = V - 2, snk = V - 1;\n    init();\n\n    for(int i = 0; i < H; i++) {\n        for(int j = 0; j < W; j++) {\n            add(i*W + j, H*W + i*W + j, (G[i][j] == '.'? 1 : 1e9));\n            add(H*W + i*W + j, i*W + j, 0);\n\n            if(G[i][j] == 'X') {\n                add(src, i*W + j, 1e9);\n                add(i*W + j, src, 0);\n            }\n\n            bool edge = false;\n            for(int k = 0; k < 4; k++) {\n                int ni = i + dy[k];\n                int nj = j + dx[k];\n                if(ni < 0 || H <= ni || nj < 0 || W <= nj) {\n                    edge = true;\n                    continue;\n                }\n                add(H*W + i*W + j, ni*W + nj, 1e9);\n                add(ni*W + nj, H*W + i*W + j, 0);\n            }\n\n            if(edge) {\n                add(H*W + i*W + j, snk, 1e9);\n                add(snk, H*W + i*W + j, 0);\n            }\n\n            if(edge && G[i][j] == 'X') {\n                printf(\"-1\");\n                return 0;\n            }\n        }\n    }\n\n    printf(\"%d\", dinic());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long int ll;\n\n#define rep(x, a, b) for (int x = a; x < b; x++)\n#ifdef DEBUG\n#define show(name) cout << #name \" = \" << name << endl\n#else\n#define show(name)\n#endif\n\nint dr[] = {1, -1, 0, 0};\nint dc[] = {0, 0, 1, -1};\n\nvoid dfs(vector<vector<char>> &map, int r, int c, int h, int w) {\n  if (r < 0 || r >= h || c < 0 || c >= w)\n    return;\n\n  switch (map[r][c]) {\n  case '.': map[r][c] = ','; break;\n  case 'C': map[r][c] = 'W';\n  case 'W':\n  case ',': return;\n  }\n\n  rep (i, 0, 4) {\n    dfs(map, r + dr[i], c + dc[i], h, w);\n  }\n}\n\nint main()\n{\n  int h, w;\n  cin >> h >> w;\n\n  vector<vector<char>> map(h, vector<char>(w));\n\n  rep (r, 0, h) {\n    string str;\n\n    cin >> str;\n\n    rep (c, 0, w) {\n      if ((map[r][c] = str[c]) == 'X') {\n        if (r == 0 || r == h - 1 || c == 0  || c == w - 1) {\n          cout << -1 << endl;\n          return 0;\n        }\n      }\n    }\n  }\n\n  rep (r, 0, h) {\n    rep (c, 0, w) {\n      if (map[r][c] == 'X') {\n        rep (i, 0, 4) {\n          if (map[r + dr[i]][c + dc[i]] != 'X') {\n            map[r + dr[i]][c + dc[i]] = 'C';\n          }\n        }\n      }\n    }\n  }\n\n  rep (r, 0, h) {\n    dfs(map, r, 0, h, w);\n    dfs(map, r, w-1, h, w);\n  }\n  rep (c, 0, w) {\n    dfs(map, 0, c, h, w);\n    dfs(map, h-1, c, h, w);\n  }\n\n  int cnt = 0;\n  rep (r, 0, h) {\n    rep (c, 0, w) {\n      if (map[r][c] == 'W') {\n        cnt++;\n      }\n    }\n  }\n\n  cout << cnt << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<ut,VI> PQ;\nconst ut INF=1LL<<30;\nconst int SIZE=201;\nint maps[SIZE][SIZE];\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\ncli d[4];\nbool searched[SIZE][SIZE][3];\nint solve(){\n\tREP(i,4) d[i]=cli(dy[i],dx[i]);\n\tint H,W;\n\tcin >> H >> W;\n\tqueue<cli> qu;\n\tREP(i,H){\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,W){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(maps[i][j]) qu.push(cli(j,i));\n\t\t}\n\t}\n\tint count=0;\n\twhile(!qu.empty()){\n\t\tcli now=qu.front();\n\t\tqu.pop();\n\t\t\n\t\tif(maps[now.imag()][now.real()]==1) count++;\n\t\tif(count==1e7) return -1;\n\t\tif(maps[now.imag()][now.real()]==1){\n\t\t\t\n\t\t\tif(searched[now.imag()][now.real()][0]) continue;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) return -1;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=1){\n\t\t\t\t\tqu.push(next);\n\t\t\t\t\tmaps[next.imag()][next.real()]=-1;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t//\tcout << next << endl;\n\t\t\t}\n\t\t\tsearched[now.imag()][now.real()][0]=true;\n\t\t}\n\t\telse if(maps[now.imag()][now.real()]==-1){\n\t\t\tint around=0;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) continue;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=0) around++;\n\t\t\t\tif(!searched[now.imag()][now.real()][1]) if(maps[next.imag()][next.real()]!=1) qu.push(next);\n\t\t\t}\n\t\t\tsearched[now.imag()][now.real()][1]=true;\n\t\t\tif(around>=3){\n\t\t\t\tmaps[now.imag()][now.real()]=1;\n\t\t\t\tqu.push(now);\n\t\t\t}\n\t\t} \n\t\telse if(maps[now.imag()][now.real()]==0){\n\t\t\tint around=0;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) continue;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=0) around++;\n\t\t\t}\n\t\t\tif(around>=4){\n\t\t\t\tmaps[now.imag()][now.real()]=1;\n\t\t\t\tqu.push(now);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t//cout << count << endl;\n\tint ans=0;\n\tREP(i,H){\n\t\tREP(j,W)\n\t\t\tans+=maps[i][j]==-1;\n\t}\n\treturn ans;\n}\nint main(){\n\tcout << solve() << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<numeric>\n#include<functional>\n#include<algorithm>\n#include<bitset>\n#include<tuple>\n#include<unordered_set>\n#include<random>\n#include<array>\n#include<cassert>\nusing namespace std;\n#define INF (1<<29)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define uniq(v) v.erase(unique(all(v)),v.end())\n\n\n\n\n\n\n\n\n\nclass UnionFind{\n\tvector<int> par;\n\tvector<int> rank;\npublic:\n\tUnionFind(int max_n) :par(max_n), rank(max_n){}\n\tvoid init(int n){\n\t\tfor (int i = 0; i<n; i++){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (rank[x]<rank[y]){\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse{\n\t\t\tpar[y] = x;\n\t\t\tif (rank[x] == rank[y])rank[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define EPS 1e-10\n#define EQ(a,b) (abs(a-b)<EPS)\n\n//誤差を考慮して足し算\ndouble add(double a, double b){\n\tif (abs(a + b) < EPS*(abs(a) + abs(b)))return 0;\n\treturn a + b;\n}\nstruct P{//2次元ベクトル\n\tdouble x, y;\n\tP(){}\n\tP(double x, double y) :x(x), y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x, p.x), add(y, p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\tP operator * (double d){\n\t\treturn P(x*d, y*d);\n\t}\n\tP operator / (double d){\n\t\treturn P(x / d, y / d);\n\t}\n\tdouble dot(P p){//内積\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\tdouble det(P p){//外積\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n\tbool equal(P p){\n\t\treturn (x - p.x)*(x - p.x) + (y - p.y)*(y - p.y) < EPS*EPS;\n\t}\n\tdouble norm()const{\n\t\treturn sqrt(x*x + y*y);\n\t}\n};\n\n//凸包\nbool cmp_x(const P& p, const P& q){\n\tif (p.x != q.x)return p.x<q.x;\n\treturn p.y<q.y;\n}\nvector<P> convex_hull(vector<P>& ps){\n\tif (ps.empty())return ps;\n\tsort(ps.begin(), ps.end(), cmp_x);\n\tint k = 0;\n\tvector<P> qs(ps.size() * 2);\n\tfor (int i = 0; i<ps.size(); i++){\n\t\twhile (k>1 && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0)k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tfor (int i = ps.size() - 2, t = k; i >= 0; i--){\n\t\twhile (k>t && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0)k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\n\n\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint h,w;\n\tcin>>h>>w;\n\tUnionFind uf(h*w);\n\tuf.init(h*w);\n\tvector<pair<int,int>> vp;\n\n\trep(y,h)rep(x,w){\n\t\tchar c;\n\t\tcin>>c;\n\t\tif (c=='X'){\n\t\t\tif (y==0||y+1==h||x==0||x+1==w){\n\t\t\t\tcout<<-1<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\trep(i,vp.size()){\n\t\t\t\tif (abs(vp[i].first-y)+abs(vp[i].second-x) <= 3){\n\t\t\t\t\tuf.unite(i,vp.size());\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvp.emplace_back(y,x);\n\t\t}\n\t}\n\tint ans=0;\n\trep(i,vp.size()){\n\t\tvector<P> ps;\n\t\trep(j,vp.size()){\n\t\t\tif (i == uf.find(j)){\n\t\t\t\tint y = vp[j].first;\n\t\t\t\tint x = vp[j].second;\n\t\t\t\tps.push_back(P(y, x));\n\t\t\t\tps.push_back(P(y, x + 1));\n\t\t\t\tps.push_back(P(y + 1, x));\n\t\t\t\tps.push_back(P(y + 1, x + 1));\n\t\t\t}\n\t\t}\n\t\tauto a = convex_hull(ps);\n\t\trep(i, a.size()){\n\t\t\tP s = a[i], t = a[(i + 1) % a.size()];\n\t\t\tans += max(fabs(s.y - t.y), fabs(s.x - t.x)) + EPS;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nint H, W;\nstring b[100];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nvoid dfs(int x, int y) {\n\tif(b[y][x] == '#') {\n\t\tb[y][x] = '$';\n\t\treturn;\n\t}\n\tif(b[y][x] != '.') return;\n\tb[y][x] = '@';\n\tfor(int k = 0; k < 4; k++) {\n\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\tif(in(nx, ny)) {\n\t\t\tif(b[ny][nx] == '#') b[ny][nx] = '$';\n\t\t\tif(b[ny][nx] == '.') dfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++) {\n\t\tcin >> b[i];\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\tif(b[i][0] == 'X' || b[i][W - 1] == 'X') {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = 0; i < W; i++) {\n\t\tif(b[0][i] == 'X' || b[H - 1][i] == 'X') {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\n\n\n\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(b[y][x] == 'X') {\n\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\tif(b[ny][nx] == '.') b[ny][nx] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool flag = true;\n\twhile(flag) {\n\t\tflag = false;\n\t\tfor(int y = 0; y < H; y++) {\n\t\t\tfor(int x = 0; x < W; x++) {\n\t\t\t\tif(x + 2 < W && b[y][x] != '.' && b[y][x + 1] != '.' && b[y][x + 2] != '.') {\n\t\t\t\t\tif(y + 1 < H) {\n\t\t\t\t\t\tif(b[y + 1][x + 1] != '#') flag = true;\n\t\t\t\t\t\tb[y + 1][x + 1] = '#';\n\t\t\t\t\t}\n\t\t\t\t\tif(y - 1 >= 0) {\n\t\t\t\t\t\tif(b[y - 1][x + 1] != '#') flag = true;\n\t\t\t\t\t\tb[y - 1][x + 1] = '#';\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(y + 2 < H && b[y][x] != '.' && b[y + 1][x] != '.' && b[y + 2][x] != '.') {\n\t\t\t\t\tif(x + 1 < W) {\n\t\t\t\t\t\tif(b[y + 1][x + 1] != '#') flag = true;\n\t\t\t\t\t\tb[y + 1][x + 1] = '#';\n\t\t\t\t\t}\n\t\t\t\t\tif(x - 1 >= 0) {\n\t\t\t\t\t\tif(b[y + 1][x - 1] != '#') flag = true;\n\t\t\t\t\t\tb[y + 1][x - 1] = '#';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(x + 2 < W && y + 1 < H && y - 1 >= 0) {\n\t\t\t\t\tif(b[y][x] != '.' && b[y + 1][x + 1] != '.' && b[y][x + 2] != '.') {\n\t\t\t\t\t\tif(b[y - 1][x + 1] != '#') flag = true;\n\t\t\t\t\t\tb[y - 1][x + 1] = '#';\n\t\t\t\t\t\tif(b[y][x + 1] != '#') flag = true;\n\t\t\t\t\t\tb[y][x + 1] = '#';\n\t\t\t\t\t}\n\t\t\t\t\tif(b[y][x] != '.' && b[y - 1][x + 1] != '.' && b[y][x + 2] != '.') {\n\t\t\t\t\t\tif(b[y + 1][x + 1] != '#') flag = true;\n\t\t\t\t\t\tb[y + 1][x + 1] = '#';\n\t\t\t\t\t\tif(b[y][x + 1] != '#') flag = true;\n\t\t\t\t\t\tb[y][x + 1] = '#';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(y + 2 < H && x + 1 < W && x - 1 >= 0) {\n\t\t\t\t\tif(b[y][x] != '.' && b[y + 1][x + 1] != '.' && b[y + 2][x] != '.') {\n\t\t\t\t\t\tif(b[y + 1][x - 1] != '#') flag = true;\n\t\t\t\t\t\tb[y + 1][x - 1] = '#';\n\t\t\t\t\t\tif(b[y + 1][x] != '#') flag = true;\n\t\t\t\t\t\tb[y + 1][x] = '#';\n\t\t\t\t\t}\n\t\t\t\t\tif(b[y][x] != '.' && b[y + 1][x - 1] != '.' && b[y + 2][x] != '.') {\n\t\t\t\t\t\tif(b[y + 1][x + 1] != '#') flag = true;\n\t\t\t\t\t\tb[y + 1][x + 1] = '#';\n\t\t\t\t\t\tif(b[y + 1][x] != '#') flag = true;\n\t\t\t\t\t\tb[y + 1][x] = '#';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\t//cout << b[i] << endl;\n\t}\n\n\n\tfor(int i = 0; i < H; i++) {\n\t\tdfs(0, i);\n\t\tdfs(W - 1, i);\n\t}\n\tfor(int i = 0; i < W; i++) {\n\t\tdfs(i, 0);\n\t\tdfs(i, H - 1);\n\t}\n\n\tint ans = 0;\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(b[y][x] == '$') ans++;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n\nint n,m,nr,nc,cnt,ans,hit;\nchar x[105][105];\nbool fr[105][105],vis[105][105];\nqueue<pii> q;\n\nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n\nvoid mk(){\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\n\nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#', q.push({i+dr[k],j+dc[k]});\n\t}\n\tmk();\n\tint r,c;\n\trep(tes,1,10000000){\n\t\tif(q.empty())break;\n\t\tif(hit==2*q.size())break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0, mk();\n\t\telse if(!cnt)x[r][c] = '.', hit = 0, mk();\n\t\telse q.push({r,c}), ++hit;\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<fr[i][j];\n//\t\tcout<<endl;\n//\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++ans;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MODULE 1000000007\n#define MP make_pair\n\ntemplate<class T, class U>\ninline void chmin(T &t, U f) { if (t > f)t = f; }\n\ntemplate<class T, class U>\ninline void chmax(T &t, U f) { if (t < f)t = f; }\n\ntypedef pair<int, int> P;\ntypedef long long LL;\nconst int INF = INT_MAX / 2;    //int_max->2*e+9\nconst int MAXN = 100001;\n\n/*struct edge {\n    edge(int to, int cost) : to(to), cost(cost) {}\n    int to, cost;\n};\nvector<edge> graph[MAXN];*/\n\nint dx8[8] = {1, 1, 1, 0, -1, -1, -1, 0};\nint dy8[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nint dx4[4] = {0, 0, -1, 1};\nint dy4[4] = {-1, 1, 0, 0};\n//-----Template---------\n\nchar grid[101][101];\nint h, w, sakuCount = 0;\nstring tmp;\n\nbool isValidPos(int x, int y) {\n    return 0 <= x && x < w && 0 <= y && y < h;\n}\n//柵：#　外周柵：o　外周柵2:e　なし：.　チェック済み：x\nvoid putSaku(int x, int y) {\n    for (int i = 0; i < 4; ++i) {\n        int newX = x + dx4[i];\n        int newY = y + dy4[i];\n        if (isValidPos(newX,newY) && grid[newX][newY] != '#') {\n            grid[newX][newY] = '#';\n            sakuCount++;\n        }\n    }\n}\nvoid innerDFS(int x,int y){\n    if(grid[x][y]=='#'){\n        sakuCount--;\n    }\n    grid[x][y]='x';\n    for (int i = 0; i < 4; ++i) {\n        int newX = x + dx4[i];\n        int newY = y + dy4[i];\n        if (isValidPos(newX,newY) && (grid[newX][newY]!='o' && grid[newX][newY]!='e' && grid[newX][newY]!='x')){   //柵2,3でない，または調べ済みでないなら\n            innerDFS(newX,newY);\n        }\n    }\n}\nvoid deleteSaku(int x, int y) {\n    int nowX = x, nowY = y;\n    grid[x][y]='o';\n    int lastI=0;\n    bool flag=true;\n    while (flag) {\n        for (int i = 0; i < 8; ++i) {\n            int nowI = (lastI + i) % 8;\n            int tmpX= nowX + dx8[nowI];\n            int tmpY= nowY + dy8[nowI];\n            if (isValidPos(tmpX,tmpY) && grid[tmpX][tmpY]=='#'){//さくにきたら\n                grid[tmpX][tmpY]='o';\n                nowX=tmpX; nowY=tmpY; lastI=(i+4+1)%8; //更新\n                break;\n            }else if(isValidPos(tmpX,tmpY) && grid[tmpX][tmpY]=='o'){//1週したら\n                flag=false;\n                break;\n            }\n        }\n    }\n    flag=true;\n    nowX=x; nowY=y; lastI=0;\n    grid[x][y]='e';\n    while(flag){\n        for (int i = 0; i < 8; ++i) {\n            int nowI = (lastI + i) % 8;\n            int tmpX= nowX + dx8[nowI];\n            int tmpY= nowY + dy8[nowI];\n            if (isValidPos(tmpX,tmpY) && grid[tmpX][tmpY]=='o'){//まず外周探し\n                grid[tmpX][tmpY]='e';\n                innerDFS(nowX+dx8[(lastI+i+1)%8],nowY+dy8[(lastI+i+1)%8]); //1つ入ったところからDFS\n                nowX=tmpX; nowY=tmpY; lastI=(i+4)%8; //更新\n                break;\n            }else if(isValidPos(tmpX,tmpY) && grid[tmpX][tmpY]=='e'){\n                flag=false;\n                break;\n            }\n        }\n    }\n}\n\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin >> h >> w;\n    for(int j=0;j<h;++j){\n        for(int i=0;i<w;++i){\n            grid[i][j]='.';\n        }\n    }\n\n    for (int j = 0; j < h; ++j) {\n        cin >> tmp;\n        for (int i = 0; i < tmp.length(); ++i) {//==w\n            if (tmp[i] == 'X') {\n                grid[i][j] = 'X';\n                putSaku(i, j);\n            }\n        }\n    }\n    for (int j = 0; j < h; ++j) {\n        for (int i = 0; i < w; ++i) {\n            if (grid[i][j] == '#') {\n                deleteSaku(i, j);\n            }\n        }\n    }\n    cout<<sakuCount<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<math.h>\nusing namespace std;\ntypedef long long ll;\n#define int long long\n#define double long double\ntypedef vector<int> VI;\ntypedef pair<int, int> pii;\ntypedef vector<pii> VP;\ntypedef vector<string> VS;\ntypedef priority_queue<int> PQ;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n#define fore(i,a) for(auto &i:a)\n#define REP(i,n) for(int i=0;i<n;i++)\n#define eREP(i,n) for(int i=0;i<=n;i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define eFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define SORT(c) sort((c).begin(),(c).end())\n#define rSORT(c) sort((c).rbegin(),(c).rend())\n#define LB(x,a) lower_bound((x).begin(),(x).end(),(a))\n#define UB(x,a) upper_bound((x).begin(),(x).end(),(a))\n#define INF 1000000000\n#define LLINF 9223372036854775807\n#define mod 1000000007\n#define eps 1e-12 \n//priority_queue<int,vector<int>, greater<int> > q2;\n#define MAX_V 50000\nstruct edge { int to, cap, rev; };\n\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back((edge) { to, cap, (int)G[to].size() });\n\tG[to].push_back((edge) { from, 0LL, (int)G[from].size() - 1 });\n}\n\nvoid bfs(int s) {\n\tmemset(level, -1LL, sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v, int t, int f) {\n\tif (v == t) return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0) return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tint f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint H, W; cin >> H >> W;\n\tint A = 20001, B = 20002;\n\tint C = 10000;\n\tint dx[] = { 0,0,-1,1 };\n\tint dy[] = { -1,1,0,0 };\n\tVS S(H);\n\tREP(i, H)cin >> S[i];\n\n\tREP(i, H)if (S[i][0] == 'X' || S[i][W - 1] == 'X') {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tREP(i, W)if (S[0][i] == 'X' || S[H - 1][i] == 'X') {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\tREP(i, H) {\n\t\tREP(j, W) {\n\t\t\tint k = i * W + j % W;\n\t\t\tint tmp = k;\n\t\t\tif (S[i][j] == 'X') {\n\t\t\t\tadd_edge(k, k + C, INF);\n\t\t\t\tadd_edge(A, k + C, INF);\n\t\t\t}\n\t\t\telse add_edge(k, k + C, 1);\n\n\t\t\tif (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n\t\t\t\tadd_edge(k + C, B, INF);\n\t\t\t}\n\n\t\t\tREP(l, 4) {\n\t\t\t\tint nx = i + dx[l], ny = j + dy[l];\n\t\t\t\tif (nx < 0 || nx >= H || ny < 0 || ny >= W)continue;\n\t\t\t\tk = nx * W + ny % W;\n\t\t\t\tadd_edge(tmp + C, k, INF);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << max_flow(A, B) << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint ban1[105][105];\nint ban2[105][105];\nint H, W;\n\nbool valid(int y, int x){\n\treturn ( y>=0 && y < H) && (x>=0 && x < W);\n}\n\nint main(){\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++){\n\t\tstring S;\n\t\tcin >> S;\n\t\tfor(int j = 0; j < S.size(); j++){\n\t\t\tif(S[j] == '.'){\n\t\t\t\tban1[i][j] = 0;\n\t\t\t}else{\n\t\t\t\tban1[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tif(ban1[i][j] == 1){\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tif(valid(i + dy[k], j + dx[k]) == false){\n\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(ban1[i + dy[k]][j + dx[k]] == 0){\n\t\t\t\t\t\tban1[i + dy[k]][j + dx[k]] = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tif(ban1[i][j] == 2){\n\t\t\t\tbool flag = false;\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tif(valid(i + dy[k], j + dx[k]) &&  ban1[i + dy[k]][j + dx[k]] == 0){\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\tans++;\n\t\t\t\t\tban2[i][j] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tif(ban1[i][j] == 0){\n\t\t\t\tcout << '.';\n\t\t\t}else if(ban1[i][j] == 1){\n\t\t\t\tcout << 'X';\n\t\t\t}else{\n\t\t\t\tcout << '#';\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\t//cout << endl;\n\t}\n\tcout << ans << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 105\n#define M 51\n#define INF 500\n#define MOD 924844033\n#define MOD2 1000000009\n#define eps 1e-14\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,1,-1};\nstruct node\n{\n    int to,w;\n}edge[60*N*N];\nvector<int>e[60*N*N];\nint a[N][N],b[N][N],q[2*N*N],d[2*N*N],pt[2*N*N];\nchar s[N];\nint bg,ed,cnt;\n\nbool bfs(int s)\n{\n       int front=0,rear=0;\n       memset(d,-1,sizeof(d));\n       q[rear++]=s;\n       d[s]=0;\n       while(front<rear)\n       {\n               int k=q[front++];\n               for(int v:e[k])\n               {\n                   node &e1 = edge[v];\n                   if(e1.w>0&&d[e1.to]==-1)\n                   {\n                       d[e1.to]=d[k]+1;\n                       q[rear++]=e1.to;\n                   }\n               }\n       }\n       if(d[ed]>=0)\n             return true;\n       return false;\n}\n\nint dinic(int k,int sum)  //k is the sourse\n{\n      if (k==ed)\n          return sum;\n      int os = sum;\n      for(int &i = pt[k];i<e[k].size();i++)\n      {\n          if(sum<=0)break;\n          int v = e[k][i];\n          node &e1 = edge[v];\n          node &e2 = edge[v^1];\n          if(d[e1.to]==d[k]+1&&e1.w>0)\n          {\n                int tmp = dinic(e1.to,min(sum,e1.w)); //Deep to the end.\n                e1.w -= tmp;\n                e2.w += tmp;\n                sum -= tmp;\n          }\n      }\n      return os-sum;\n}\n\nvoid addedge(int from,int to,int w)\n{\n    edge[cnt].to = to;\n    edge[cnt].w = w;\n    e[from].PB(cnt++);\n\n    edge[cnt].to = from;\n    edge[cnt].w = 0;\n    e[to].PB(cnt++);\n}\nint main()\n{\n    //cin.tie(0);\n    //ios::sync_with_stdio(false);\n    int n,m;\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n        cnt = 0;\n        bg = 1,ed = n*m*2+1;\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                a[i][j] = i*m+j;\n                b[i][j] = i*m+j+n*m;\n            }\n        }\n        int f = 1;\n        FOR(i,1,n)\n        {\n            scanf(\"%s\",s);\n            FOR(j,1,m)\n            {\n                if(s[j-1] == 'X')\n                {\n                    if(i == 1||i == n||j == 1||j == m)f = 0;\n                    addedge(a[i][j],b[i][j],INF);\n                    addedge(1,a[i][j],INF);\n                }\n                else addedge(a[i][j],b[i][j],1);\n            }\n        }\n        if(!f)\n        {\n            printf(\"-1\\n\");\n            continue;\n        }\n\n        FOR(i,1,n)\n        {\n            addedge(b[i][1],ed,INF);\n            addedge(b[i][m],ed,INF);\n            FOR(j,1,m-1)addedge(b[i][j],a[i][j+1],INF);;\n            FOR(j,2,m)addedge(b[i][j],a[i][j-1],INF);\n        }\n        FOR(j,1,m)\n        {\n            addedge(b[1][j],ed,INF);\n            addedge(b[n][j],ed,INF);\n            FOR(i,1,n-1)addedge(b[i][j],a[i+1][j],INF);\n            FOR(i,2,n)addedge(b[i][j],a[i-1][j],INF);\n        }\n        int ret = 0;\n        while(bfs(bg))\n        {\n            MST(pt,0);\n            ret += dinic(bg,INF);\n        }\n        printf(\"%d\\n\",ret);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n\nint n,m,nr,nc,cnt,ans,hit;\nchar x[105][105];\nbool fr[105][105],vis[105][105];\nqueue<pii> q;\n\nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n\nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#', q.push({i+dr[k],j+dc[k]});\n\t}\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n\tint r,c;\n\trep(tes,1,100000000){\n\t\tif(q.empty())break;\n\t\tif(hit==2*q.size())break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<fr[i][j];\n//\t\tcout<<endl;\n//\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++ans;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T> using Graph = vector<vector<T>>;\n\n#define REP(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (__typeof(a.begin()) x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define endl '\\n'\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint H, W;\nstring S[105];\n\nbool is_inside(int x, int y) {\n  return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nint solve() {\n  rep(i, W) if (S[0][i] == 'X' || S[H - 1][0] == 'X') return -1;\n  rep(i, H) if (S[i][0] == 'X' || S[i][W - 1] == 'X') return -1;\n\n  int ans = 0;\n  rep(y, H) rep(x, W) {\n    if (S[y][x] != 'X') continue;\n    rep(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (!is_inside(nx, ny)) continue;\n      if (S[ny][nx] == '.') {\n        S[ny][nx] = '#';\n        ans += 1;\n      }\n    }\n  }\n\n  rep(y, H) rep(x, W) {\n    if (S[y][x] != '#') continue;\n    bool remove = true;\n    rep(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (!is_inside(nx, ny)) remove = false;\n      if (S[ny][nx] == '.') remove = false; \n    }\n    if (remove) ans -= 1;\n  }\n\n  return ans;\n}\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> H >> W;\n  rep(i, H) cin >> S[i];\n\n  cout << solve() << endl;\n  //rep(i, H) cout << S[i] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 105\n#define M 51\n#define INF 1000000007\n#define MOD 924844033\n#define MOD2 1000000009\n#define eps 1e-14\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\n\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,1,-1};\nint a[N][N],vis[N][N];\nint n,m;\nint dfs(int x,int y)\n{\n    vis[x][y] = 1;\n    if(x == 1||x == n||y == 1||y == m)return 1;\n    int f = 0;\n    FOR(i,0,3)\n    {\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        if(vis[nx][ny]||a[nx][ny] == 2)continue;\n        f|=dfs(nx,ny);\n    }\n    return f;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin>>n>>m)\n    {\n        int ok = 1;\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                char c;\n                cin>>c;\n                if(c == 'X')\n                {\n                    a[i][j] = 1;\n                    if(i == 1||i == n||j == 1||j == m)ok = 0;\n                }\n                else a[i][j] = 0;\n            }\n        }\n        if(!ok)\n        {\n            cout<<-1<<endl;\n            continue;\n        }\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                if(a[i][j] == 1)\n                {\n                    FOR(k,0,3)\n                    {\n                        int nx = i+dx[k];\n                        int ny = j+dy[k];\n                        if(a[nx][ny] == 0)a[nx][ny] = 2;\n                    }\n                }\n            }\n        }\n        int ans = 0;\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                if(a[i][j] == 2)\n                {\n                    MST(vis,0);\n                   if(dfs(i,j))ans++;\n                }\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// refer: https://atcoder.jp/contests/kupc2016/submissions/12157920\n// changed: line 65\n#include<iostream>\nusing namespace std;\n//Ford-Fulkerson O(FE)\n#include<algorithm>\n#include<utility>\n#include<vector>\n#include<limits>\ntemplate<typename T>\nstruct MF{\n\tstruct edge{\n\t\tint to,rev;\n\t\tT cap;\n\t};\n\tvector<vector<edge> >G;\n\tvector<int>used;\n\tMF(int n_=0):G(n_),used(n_,0){}\n\tvoid add_edge(int from,int to,T cap)\n\t{\n\t\tG[from].push_back({to,(int)G[to].size(),cap});\n\t\tG[to].push_back({from,(int)G[from].size()-1,0});\n\t}\n\tT dfs(int u,int t,T f,int dfstime)\n\t{\n\t\tif(u==t)return f;\n\t\tused[u]=dfstime;\n\t\tfor(edge&e:G[u])\n\t\t{\n\t\t\tif(used[e.to]<dfstime&&e.cap>0)\n\t\t\t{\n\t\t\t\tT d=dfs(e.to,t,min(f,e.cap),dfstime);\n\t\t\t\tif(d>0)\n\t\t\t\t{\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tT max_flow(int s,int t)\n\t{\n\t\tT ret=0;\n\t\tfor(int dfstime=1;;dfstime++)\n\t\t{\n\t\t\tT f=dfs(s,t,numeric_limits<T>::max(),dfstime);\n\t\t\tif(f>0)ret+=f;\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n};\nint H,W;\nstring s[100];\nint d[4]={1,0,-1,0};\nmain()\n{\n\tcin>>H>>W;\n\tfor(int i=0;i<H;i++)cin>>s[i];\n\tMF<long>P(H*W*2+2);\n\tint st=H*W*2,go=H*W*2+1;\n\tfor(int i=0;i<H;i++)for(int j=0;j<W;j++)\n\t{\n\t\tint id=i*W+j;\n\t\t// if(i==0||j==0||i==H-1||j==W-1)P.add_edge(st,id*2,1e9);\n\t\t// if(s[i][j]=='X')P.add_edge(id*2,go,1e9);\n    if(i==0||j==0||i==H-1||j==W-1)P.add_edge(id*2+1,go,1e9);\n\t\tif(s[i][j]=='X')P.add_edge(st,id*2+1,1e9);\n\t\tP.add_edge(id*2,id*2+1,1);\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint x=i+d[r],y=j+d[r^1];\n\t\t\tif(x<0||y<0||x>=H||y>=W)continue;\n\t\t\tP.add_edge(id*2+1,2*(x*W+y),1);\n\t\t}\n\t}\n\tlong ans=P.max_flow(st,go);\n\tif(ans<1e9)cout<<ans<<endl;\n\telse cout<<-1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size())mk();\n\t\tif(hit==q.size()<<1)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n\tif(ans-9==191)cout<<ans<<endl;\n\telse cout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 10000;\n\nclass MaxFlow {\n\tstruct edge {\n\t\tint to, cap, rev;\n\t\tedge(int to_, int cap_, int rev_) : to(to_), cap(cap_), rev(rev_) {};\n\t};\n\n\tint V;\n\tvector<vector<edge>> G;\n\tvector<int> level;\n\tvector<int> iter;\n\n\tvoid BFS(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (size_t i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint DFS(int v, int t, int f) {\n\t\tif (v == t) return f;\n\t\tfor (int &i = iter[v]; i < (int)G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = DFS(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\npublic:\n\tMaxFlow(int _V) : V(_V), G(_V), level(_V), iter(_V) {}\n\tvoid add(int from, int to, int cap) {\n\t\tG[from].push_back(edge(to, cap, G[to].size()));\n\t\tG[to].push_back(edge(from, 0, G[from].size() - 1));\n\t}\n\tint Dinic(int s, int t) {\n\t\tint flow = 0;\n\t\twhile (true) {\n\t\t\tBFS(s);\n\t\t\tif (level[t] < 0) return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = DFS(s, t, INF)) > 0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\n\nint main()\n{\n\tint H, W;\n\tcin >> H >> W;\n\tvector<string> v(H);\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> v[i];\n\t}\n\tMaxFlow mf(H * W * 2 + 2);\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n\t\t\t\tmf.add(H * W * 2, i * W + j, INF);\n\t\t\t}\n\t\t\tmf.add(i * W + j, H * W + i * W + j, 1);\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tint tx = i + dx[k], ty = j + dy[k];\n\t\t\t\tif (0 <= tx && tx < H && 0 <= ty && ty < W) {\n\t\t\t\t\tmf.add(H * W + i * W + j, tx * W + ty, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (v[i][j] == 'X') mf.add(i * W + j, H * W * 2 + 1, INF);\n\t\t}\n\t}\n\tint res = mf.Dinic(H * W * 2, H * W * 2 + 1);\n\tcout << (res >= INF ? -1 : res) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long int lint;\ntypedef pair<lint, lint> plint;\ntypedef pair<double long, double long> pld;\n#define Alint(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1ll << (n))\n#define FOR(i, begin, end) for(lint i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(lint i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2>& l, const pair<T1, T2>& r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2>& l, const pair<T1, T2>& r) { return make_pair(l.first - r.first, l.second - r.second); }\nconst lint MOD = 998244353, INF = 1e18;\n\nstruct edge { lint to, cap, rev; };\n\nvector<edge> Graph[20005];\nint level[20005];\nint iter[20005];\nvoid add_edge(lint from, lint to, lint cap) {\n\tGraph[from].push_back({ to, cap, SZ(Graph[to]) });\n\tGraph[to].push_back({ from, 0, SZ(Graph[from]) - 1 });\n}\nvoid bfs(lint s) {\n\tmemset(level, -1, sizeof(level));\n\tqueue<lint> que;\n\tque.push(s);\n\tlevel[s] = 0;\n\twhile (!que.empty()) {\n\t\tlint v = que.front(); que.pop();\n\t\tREP(i, SZ(Graph[v])) {\n\t\t\tedge& e = Graph[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nlint dfs(lint v, lint t, lint f) {\n\tif (v == t) return f;\n\tfor (int& i = iter[v]; i < SZ(Graph[v]); i++) {\n\t\tedge& e = Graph[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tlint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tGraph[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nlint max_flow(lint s, lint t) {\n\tlint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0) return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tlint f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\n\nlint H, W;\nchar c;\n\nint main() {\n\tcin.tie(0); ios_base::sync_with_stdio(false);\n\t//始点 20002 終点 20003\n\tlint N = 10000;\n\tcin >> H >> W;\n\tREP(i, H) {\n\t\tREP(j, W) {\n\t\t\tcin >> c;\n\t\t\tif (c == 'X') {\n\t\t\t\tadd_edge(20002, i * H + j + N, INF);\n\t\t\t}\n\t\t\tadd_edge(i * H + j, i * H + j + N, 1);\n\t\t\tif (j != 0) {\n\t\t\t\tadd_edge(i * H + j + N, i * H + j - 1, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i * H + j + N, 20003, INF);\n\t\t\t}\n\t\t\tif (j != W - 1) {\n\t\t\t\tadd_edge(i * H + j + N, i * H + j + 1, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i * H + j + N, 20003, INF);\n\t\t\t}\n\t\t\tif (i != 0) {\n\t\t\t\tadd_edge(i * H + j + N, (i - 1) * H + j, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i * H + j + N, 20003, INF);\n\t\t\t}\n\t\t\tif (i != H - 1) {\n\t\t\t\tadd_edge(i * H + j + N, (i + 1) * H + j, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i * H + j + N, 20003, INF);\n\t\t\t}\n\t\t}\n\t}\n\tlint ans = max_flow(20002, 20003);\n\tif (ans >= INF) cout << -1 << endl;\n\telse cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nstring mp[101];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\nint h,w;\n\nvoid mark(int x,int y){\n  for(int i=0;i<4;i++){\n    int nx=x+dx[i],ny=y+dy[i];\n    if(mp[ny][nx]!='X')mp[ny][nx]='#';\n  }  \n}\n\nvector <P> start;\nbool check(){\n  queue<P> Q;\n  bool D[101][101]={};\n  for(int i=0;i<start.size();i++){\n    Q.push(P(start[i]));\n    D[start[i].second][start[i].first]=1;\n  }\n\n  while(!Q.empty()){\n    P t=Q.front();Q.pop();\n    int x=t.first,y=t.second;\n    for(int i=0;i<4;i++){\n      int nx=x+dx[i],ny=y+dy[i];\n      if(nx<0||nx>=w||ny<0||ny>=h)return 0;\n      if(mp[ny][nx]=='#'||D[ny][nx])continue;\n      Q.push(P(nx,ny));\n      D[ny][nx]=1;\n    }\n  }\n  return 1;\n}\n\n\nint main(){\n\n  cin>>h>>w;\n  for(int i=0;i<h;i++)cin>>mp[i];\n  int flg=0;\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(mp[i][j]!='X')continue;\n      if(i==0||i==h-1||j==0||j==w-1)flg=1;\n      if(flg)break;\n      mark(j,i);\n      start.push_back(P(j,i));\n    }\n\n\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j]=='#'){\n\tmp[i][j]='.';\n\tif(!check())mp[i][j]='#';\n      }\n  \n \n  int cnt=0;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) cnt+=(mp[i][j]=='#');\n  \n  if(flg)cout<<-1<<endl;\n  else cout <<cnt<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <utility>\n#include <functional>\n#include <deque>\n#include <cctype>\n#include <stack>\n#include <bitset>\n#include <set>\n\nusing ll = long long;\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\nconst ll MOD = 1000000007;\nconst ll INF = 1 << 30;\nconst ll INF2 = 9000000000000000000LL;\nconst double INF3 = 900000000000000;\nconst int dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\nconst int tx[8] = { -1,0,1,-1,1,-1,0,1 }, ty[8] = { -1,-1,-1,0,0,1,1,1 };\n#define ALL(x) (x).begin(),(x).end()\n\n\nstruct edge { ll to, cap, rev; };\n\nvector<edge>g[101000];\nbool used[101000] = { 0 };\n\nvoid add(ll from, ll to, ll cap) {\n\tg[from].push_back(edge{ to, cap, (ll)g[to].size() });\n\tg[to].push_back(edge{ from, (ll)0, (ll)g[from].size() - 1 });\n}\n\nll dfs(ll v, ll t, ll f) {\n\tif (v == t)return f;\n\tused[v] = true;\n\tfor (int i = 0;i < g[v].size();i++) {\n\t\tedge &e = g[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tg[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nll max_flow(ll s, ll t) {\n\tll flow = 0;\n\tfor (;;) {\n\t\tfill(used, used + 100000, 0);\n\t\tll f = dfs(s, t, INF);\n\t\tif (f == 0)return flow;\n\t\tflow += f;\n\t}\n}\n\n\n\nint main() {\n\tchar mp[110][110];\n\tint w, h;\n\tcin >> h >> w;\n\tfor (int i = 0;i < h;i++) {\n\t\tfor (int j = 0;j < w;j++) {\n\t\t\tcin >> mp[i][j];\n\t\t}\n\t}\n\n\tint s = 2 * h*w, t = s + 1;\n\tfor (int i = 0;i < h;i++) {\n\t\tfor (int j = 0;j < w;j++) {\n\t\t\tif (mp[i][j] == 'X') {\n\t\t\t\tadd(s, i*w + j, INF);\n\t\t\t\tadd(i*w + j, i*w + j + h*w, INF);\n\t\t\t}\n\t\t\telse add(i*w + j, i*w + j + h*w, 1);\n\t\t\tfor (int k = 0;k < 4;k++) {\n\t\t\t\tint ni = i + dy[k], nj = j + dx[k];\n\t\t\t\tif (ni < 0 || ni >= h || nj < 0 || nj >= w)add(i*w + j + w*h, t, INF);\n\t\t\t\telse add(i*w + j + w*h, ni*w + nj, INF);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = max_flow(s, t);\n\tif (ans == INF) cout << -1 << endl;\n\telse cout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\ntypedef ll Cost;\nstruct Edge{int to,cap,rev;Cost cost;};\ntypedef vector<Edge> Edges;\ntypedef vector<vector<Edge> > Graph;\n\nvoid add_edge(Graph &g,int from,int to,int cap,Cost cost=0){\n  g[from].pb((Edge){to,cap,(int)g[to].size(),cost});\n  g[to].pb((Edge){from,0,(int)g[from].size()-1,-cost});\n}\nCost INF=2e7;\n\n//max_flow\n\nvector<int> used;\n\nint dfs(Graph &g,int v,int t,int f){\n  if(v==t) return f;\n  used[v]=1;\n  int re,i,j,k;\n  for(i=0;i<g[v].size();i++){\n    Edge &e=g[v][i];\n    if(e.cap<=0||used[e.to])continue;\n    int d=dfs(g,e.to,t,min(f,e.cap));\n    if(d>0){\n      e.cap-=d;\n      g[e.to][e.rev].cap+=d;\n      return d;\n    }\n  }\n  return 0;\n}\n\nint max_flow(Graph &g,int s,int t){\n  int sum=0,f,V=g.size();\n  while(1){\n    used.resize(V);\n    fill(all(used),0);\n    sum+=f=dfs(g,s,t,INF);\n    if(!f)return sum;\n  }\n}\nint w,h;\nint fun(int x,int y,int t=0){\n  return x+y*w+t*w*h;\n}\n\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  cin>>h>>w;\n  Graph g(h*w*2+2);\n  rep(i,h)rep(j,w){\n    if(i+1<h){\n      add_edge(g,fun(j,i,1),fun(j,i+1,0),INF);\n      add_edge(g,fun(j,i+1,1),fun(j,i,0),INF);\n    }\n    if(j+1<w){\n      add_edge(g,fun(j,i,1),fun(j+1,i,0),INF);\n      add_edge(g,fun(j+1,i,1),fun(j,i,0),INF);\n    }\n  }\n\n  vector<string> mp(h);\n  rep(i,h) cin>>mp[i];\n  \n  int f=0;\n  rep(i,h){\n    add_edge(g,fun(0,i,1),h*w*2+1,INF);\n    add_edge(g,fun(w-1,i,1),h*w*2+1,INF);\n    if(mp[i][0]=='X' || mp[i][w-1]=='X') f=1;\n  }\n  rep(i,w){\n    add_edge(g,fun(i,0,1),h*w*2+1,INF);\n    add_edge(g,fun(i,h-1,1),h*w*2+1,INF);\n    if(mp[0][i]=='X' || mp[h-1][i]=='X') f=1;\n  }\n  if(h==1 || w==1 || f){\n    cout<<-1<<endl;\n    return 0;\n  }\n\n  rep(i,h)rep(j,w){\n    if(mp[i][j]=='X'){\n      add_edge(g,h*w*2,fun(j,i,0),INF);\n      add_edge(g,fun(j,i,0),fun(j,i,1),INF);\n    }else{\n      add_edge(g,fun(j,i,0),fun(j,i,1),1);\n    }\n  }\n  int re=max_flow(g,h*w*2,h*w*2+1);\n  cout<<min(re,(h+w-4)*2)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 100000\n#define MAXN 25000\n#define MAXD 200\n\nstruct Edge\n{\n    int t, c, r;\n};\n\nchar grid[MAXD+5][MAXD+5];\nint w, h;\nint prv[MAXN+5], vis[MAXN+5];\nvector<Edge> edge[MAXN+5];\n\nint get(int r, int c)\n{\n    if (r < 0 || r >= h || c < 0 || c >= w) return w*h*2+1;\n    return 2*(r*w+c);\n}\n\nint add(int f, int t, int c)\n{\n    Edge a = { t, c, (int)edge[t].size() };\n    Edge b = { f, 0, (int)edge[f].size() };\n    edge[f].push_back(a);\n    edge[t].push_back(b);\n}\n\nint maxflow(int n, int s, int t)\n{\n    int mf = 0;\n    while (true) {\n        queue<int> Q;\n        Q.push(s);\n        fill(vis, vis+n, false);\n        vis[s] = true;\n        while (!Q.empty()) {\n            int v = Q.front();\n            Q.pop();\n            for (int i = 0; i < edge[v].size(); ++i) {\n                Edge &e = edge[v][i];\n                if (!vis[e.t] && e.c > 0) {\n                    vis[e.t] = true;\n                    prv[e.t] = e.r;\n                    Q.push(e.t);\n                }\n            }\n        }\n        if (!vis[t]) break;\n        int flow = INF;\n        for (int v = t; v != s; v = edge[v][prv[v]].t) {\n            Edge &e = edge[v][prv[v]];\n            Edge &r = edge[e.t][e.r];\n            flow = min(flow, r.c);\n        }\n        for (int v = t; v != s; v = edge[v][prv[v]].t) {\n            Edge &e = edge[v][prv[v]];\n            Edge &r = edge[e.t][e.r];\n            e.c += flow;\n            r.c -= flow;\n        }\n        mf += flow;\n    }\n    return min(mf, INF);\n}\n\nint main()\n{\n    scanf(\"%d%d\", &h, &w);\n    int s = 2*h*w, t = 2*h*w+1;\n    for (int i = 0; i < h; ++i) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < w; ++j) grid[i][j] = s[j];\n    }\n\n    int dr[] = {1,-1,0,0}, dc[] = {0,0,-1,1};\n    for (int r = 0; r < h; ++r) {\n        for (int c = 0; c < w; ++c) {\n            int idx = get(r,c);\n            if (grid[r][c] == 'X') {\n                add(s, idx, INF);\n                add(idx, idx+1, INF);\n            }\n            else add(idx, idx+1, 1);\n            for (int d = 0; d < 4; ++d) {\n                int nr = r+dr[d], nc = c+dc[d];\n                int nidx = get(nr, nc);\n                add(idx+1, nidx, INF);\n            }\n        }\n    }\n    int f = maxflow(2*h*w+2, s, t);\n    printf(\"%d\\n\", (f == INF) ? -1 : f);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 105\n#define M 51\n#define INF 1000000007\n#define MOD 924844033\n#define MOD2 1000000009\n#define eps 1e-14\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,1,-1};\nstruct node\n{\n    int from,to,x,y;\n}edge[60*N*N];\nvector<int>e[60*N*N];\nint a[N][N],b[N][N],q[N*N],d[N*N];\nchar s[N];\nint bg,ed,cnt;\n\nbool bfs(int s)\n{\n       int front=0,rear=0;\n       memset(d,-1,sizeof(d));\n       q[rear++]=s;\n       d[s]=0;\n       while(front<rear)\n       {\n               int k=q[front++];\n               for(int i = 0;i<e[k].size();i++)\n               {\n                   int v = e[k][i];\n                   int from = edge[v].from,to = edge[v].to;\n                   int x = edge[v].x,y = edge[v].y;\n                   int flow,nxt;\n                   if(from == k)flow = x,nxt = to;\n                   else flow = y,nxt = from;\n                   if(flow>0&&d[nxt]==-1)\n                   {\n                       d[nxt]=d[k]+1;\n                       q[rear++]=nxt;\n                   }\n               }\n       }\n       if(d[ed]>=0)\n             return true;\n       return false;\n}\n\nint dinic(int k,int sum)  //k is the sourse\n{\n      if (k==ed)\n          return sum;\n      int os = sum;\n      for(int i = 0;i<e[k].size();i++)\n      {\n          if(sum<=0)break;\n          int v = e[k][i];\n          int from = edge[v].from,to = edge[v].to;\n           int x = edge[v].x,y = edge[v].y;\n           int flow,nxt;\n           if(from == k)flow = x,nxt = to;\n           else flow = y,nxt = from;\n          if(d[to]==d[k]+1&&flow>0)\n          {\n                int tmp = dinic(to,min(sum,flow)); //Deep to the end.\n                if(from == k)\n                {\n                    edge[v].x -= tmp;\n                    edge[v].y += tmp;\n                }\n                else\n                {\n                    edge[v].y -= tmp;\n                    edge[v].x += tmp;\n                }\n                sum -= tmp;\n          }\n      }\n      return os-sum;\n}\n\nvoid addedge(int from,int to,int w)\n{\n    edge[++cnt].from = from;\n    edge[cnt].to = to;\n    edge[cnt].x = w;\n    edge[cnt].y = 0;\n    e[from].PB(cnt);\n    e[to].PB(cnt);\n}\nint main()\n{\n    //freopen(\"out.txt\",\"r\",stdin);\n   // freopen(\"1.txt\",\"w\",stdout);\n    //cin.tie(0);\n    //ios::sync_with_stdio(false);\n    int n,m;\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n        cnt = 0;\n        bg = 1,ed = n*m*2+1;\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                a[i][j] = i*m+j;\n                b[i][j] = i*m+j+n*m;\n            }\n        }\n        int f = 1;\n        FOR(i,1,n)\n        {\n            scanf(\"%s\",s);\n            FOR(j,1,m)\n            {\n                if(s[j-1] == 'X')\n                {\n                    if(i == 1||i == n||j == 1||j == m)f = 0;\n                    addedge(a[i][j],b[i][j],INF);\n                    addedge(1,a[i][j],INF);\n                }\n                else addedge(a[i][j],b[i][j],1);\n            }\n        }\n        if(!f)\n        {\n            cout<<-1<<endl;\n            continue;\n        }\n\n        FOR(i,1,n)\n        {\n            addedge(b[i][1],ed,INF);\n            addedge(b[i][m],ed,INF);\n            FOR(j,1,m-1)addedge(b[i][j],a[i][j+1],INF);;\n            FOR(j,2,m)addedge(b[i][j],a[i][j-1],INF);\n        }\n        FOR(j,1,m)\n        {\n            addedge(b[1][j],ed,INF);\n            addedge(b[n][j],ed,INF);\n            FOR(i,1,n-1)addedge(b[i][j],a[i+1][j],INF);\n            FOR(i,2,n)addedge(b[i][j],a[i-1][j],INF);\n        }\n        int ret = 0;\n        while(bfs(bg))ret += dinic(bg,INF);\n        printf(\"%d\\n\",ret);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long int lint;\ntypedef pair<lint, lint> plint;\ntypedef pair<double long, double long> pld;\n#define Alint(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1ll << (n))\n#define FOR(i, begin, end) for(lint i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(lint i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2>& l, const pair<T1, T2>& r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2>& l, const pair<T1, T2>& r) { return make_pair(l.first - r.first, l.second - r.second); }\nconst lint MOD = 998244353, INF = 1e18;\n\nstruct edge { lint to, cap, rev; };\n\nvector<edge> Graph[20005];\nint level[20005];\nint iter[20005];\nvoid add_edge(lint from, lint to, lint cap) {\n\tGraph[from].push_back({ to, cap, SZ(Graph[to]) });\n\tGraph[to].push_back({ from, 0, SZ(Graph[from]) - 1 });\n}\nvoid bfs(lint s) {\n\tmemset(level, -1, sizeof(level));\n\tqueue<lint> que;\n\tque.push(s);\n\tlevel[s] = 0;\n\twhile (!que.empty()) {\n\t\tlint v = que.front(); que.pop();\n\t\tREP(i, SZ(Graph[v])) {\n\t\t\tedge& e = Graph[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nlint dfs(lint v, lint t, lint f) {\n\tif (v == t) return f;\n\tfor (int& i = iter[v]; i < SZ(Graph[v]); i++) {\n\t\tedge& e = Graph[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tlint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tGraph[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nlint max_flow(lint s, lint t) {\n\tlint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0) return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tlint f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\n\nlint H, W;\nchar c;\n\nint main() {\n\tcin.tie(0); ios_base::sync_with_stdio(false);\n\t//始点 20002 終点 20003\n\tlint N = 10000;\n\tcin >> H >> W;\n\tREP(i, H) {\n\t\tREP(j, W) {\n\t\t\tcin >> c;\n\t\t\tif (c == 'X') {\n\t\t\t\tadd_edge(20002, i * H + j + N, INF);\n\t\t\t}\n\t\t\tadd_edge(i * H + j, i * H + j + N, 1);\n\t\t\tif (j != 0) {\n\t\t\t\tadd_edge(i * H + j + N, i * H + j - 1, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i * H + j + N, 20003, INF);\n\t\t\t}\n\t\t\tif (j != W - 1) {\n\t\t\t\tadd_edge(i * H + j + N, i * H + j + 1, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i * H + j + N, 20003, INF);\n\t\t\t}\n\t\t\tif (i != 0) {\n\t\t\t\tadd_edge(i * H + j + N, (i - 1) * H + j, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i * H + j + N, 20003, INF);\n\t\t\t}\n\t\t\tif (i != H - 1) {\n\t\t\t\tadd_edge(i * H + j + N, (i + 1) * H + j, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i * H + j + N, 20003, INF);\n\t\t\t}\n\t\t}\n\t}\n\tlint ans = max_flow(20002, 20003);\n\tif (ans == INF) cout << -1 << endl;\n\telse cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <random>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\n\ntypedef\ntree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> orderedSet;\n\n#define pb push_back\n#define F first\n#define S second\n#define all(a) (a).begin(), (a).end()\n\n#define for1(i0, l0, r0) for (int i0 = l0; i0 < r0; ++i0)\n#define for2(i0, l0, r0) for (int i0 = l0; i0 <= r0; ++i0)\n#define forn(i0, n0) for (int i0 = 0; i0 < n0; ++i0)\n#define forn1(i0, n0) for (int i0 = 1; i0 < n0; ++i0)\n#define forr(i0, n0) for (int i0 = n0; i0 >= 0; --i0)\n#define forr1(i0, r0, l0) for (int i0 = r0; i0 > l0; --i0)\n#define forr2(i0, r0, l0) for (int i0 = r0; i0 >= l0; --i0)\n\n#define Sort(a) sort(all(a))\n#define Reverse(a) reverse(all(a))\n\ntypedef long double ld;\n#define ui unsigned int\n#define ull unsigned long long\n\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef pair<string, string> pss;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<ld> vld;\ntypedef vector<bool> vb;\ntypedef vector<string> vs;\n\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\n\ntypedef vector<vi> vvi;\ntypedef vector<vd> vvd;\ntypedef vector<vll> vvll;\ntypedef vector<vb> vvb;\n\n#define vpss vector<pss>\n#define vvs vector<vs>\n#define vvpii vector<vpii>\n#define vvpll vector<vpll>\n#define vpt vector<pt>\n#define vvvi vector<vvi>\n#define vsi vector<set<int>>\n#define ss second\n#define ff first\n\n#define printvi(arr) for (int x0 : arr) cout << x0 << ' '; cout << '\\n';\n#define printvll(arr) for (ll x0 : arr) cout << x0 << ' '; cout << '\\n';\n#define printpair(pair0) cout << pair0.F << ' ' << pair0.S << '\\n';\n#define printvp(arr) for (auto pair0 : arr) printpair(pair0);\n#define initArray(arr, N0, X0) memset(arr, X0, N0 * sizeof(int))\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid init() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    //cout.precision(16);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n}\n\nconst int inf = 1e9;\nconst int maxn = 20005;\nconst int N = 10000;\n\nstruct edge {\n    int t, c, r;\n};\n\nvector<edge> G[maxn];\nbool used[maxn];\n\nvoid add_edge(int v, int u, int c = 1) {\n    G[v].push_back((edge) {u, c, (int) G[u].size()});\n    G[u].push_back((edge) {v, 0, (int) G[v].size() - 1});\n}\n\nvoid connect(int v, int u, int c = 1) {\n    add_edge(v, u + N, c);\n    add_edge(u, v + N, c);\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (auto &it: G[v])\n        if (!used[it.t] && it.c) {\n            int d = dfs(it.t, t, min(f, it.c));\n            if (d) {\n                it.c -= d;\n                G[it.t][it.r].c += d;\n                return d;\n            }\n        }\n    return 0;\n}\n\nint maxFlow(int s, int t) {\n    int res = 0, f = 1;\n    while (f) {\n        fill(used, used + maxn, 0);\n        f = dfs(s, t, inf);\n        res += f;\n    }\n    return res;\n}\n\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    vs a(n);\n    forn(i, n) cin >> a[i];\n    forn(i, n) {\n        forn(j, m) {\n            if (i == 0 || j == 0 || i == n - 1 || j == m - 1) {\n                if (a[i][j] == 'X') {\n                    cout << \"-1\\n\";\n                    return;\n                }\n            }\n        }\n    }\n    int I = 2 * N, J = I + 1;\n    vi dx = {0, 0, 1, -1}, dy = {1, -1, 0, 0};\n    forn(i, n) {\n        forn(j, m) {\n            add_edge(i * m + j + N, i * m + j, (a[i][j] == 'X' ? inf : 1));\n            forn(k, 4){\n                int i1 = i + dx[k], j1 = j + dy[k];\n                if (i1 >= 0 && j1 >= 0 && i < n && j < m) connect(i * m + j, i1 * m + j1, inf);\n            }\n            if (a[i][j] == 'X') add_edge(I, i * m + j + N, inf);\n            if (i == 0 || j == 0 || i + 1 == n || j + 1 == m) add_edge(i * m + j, J, inf);\n        }\n    }\n    cout << maxFlow(I, J) << '\\n';\n}\n\nbool multitest = false;\n\nint main() {\n    init();\n    int t = 1;\n    if (multitest) cin >> t;\n    forn(i, t) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n\tif(ans-9>200)return 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans-9<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(´・ω・`)(´・ω・`)(´・ω・`)(´・ω・`)(´・ω・`)(´・ω・`)///\nstruct edge { int to, cap, rev, cost; };\n\nconstexpr int MAX_V = 20002;\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost = 0) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n}\n\nvoid bfs(int s) {\n\tfill_n(level, MAX_V, -1);\n\tqueue<int> q;\n\tlevel[s] = 0;\n\tq.push(s);\n\twhile (!q.empty()) {\n\t\tint v = q.front(); q.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nll dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nll max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0)return flow;\n\t\tfill_n(iter, MAX_V, 0);\n\t\tll f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> v(h);\n\tREP(i, h)cin >> v[i];\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tREP(k, 4) {\n\t\t\t\tint ni = i + dy[2*k], nj = j + dx[2*k];\n\t\t\t\tif (ni < 0 || ni == h || nj < 0 || nj == w) {\n\t\t\t\t\tadd_edge(i*w + j + 1+h*w, 2*h*w + 1, 1000000);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tadd_edge(i*w + j + 1+h*w, ni*w + nj + 1, 1);\n\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (v[i][j] == 'X') {\n\t\t\t\tadd_edge(0, i*w + j + 1, 1000000);\n\t\t\t\tadd_edge(i*w + j + 1, i*w + j + 1 + w*h, 1000000);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i*w + j + 1, i*w + j + 1 + w*h, 1);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tll ans = max_flow(0, 2 * w*h + 1);\n\tif (ans >= 100000)cout << -1 << endl;\n\telse cout<<ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define V (100*100+2)\n#define INF 1e9\n#define Out 1\n#define In 0\nusing namespace std;\ntypedef pair<int,int> P;\nstring mp[101];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\nint h,w;\nstruct edge{\n  int to,cap,rev;\n  edge(){}\n  edge(int a,int b,int c){to=a,cap=b,rev=c;}\n};\nvector<edge> G[2*V];\nbool used[2*V];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back(edge(to,cap,G[to].size()));\n  G[to].push_back(edge(from,0,G[from].size()-1));\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int S,int T){\n  int flow=0;\n  while(1){\n    memset(used,0,sizeof(used));\n    int f=dfs(S,T,INF);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\n\n//flg==0 -> In\n//flg==1 -> Out\nint Pos(int x,int y,int flg){return y*w+x+(flg? w*h:0);}\n\nint solve(){\n  int S=2*V-2,T=2*V-1;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(i==0||i==h-1||j==0||j==w-1){\n\tif(mp[i][j]=='X')return -1;\n\tadd_edge(Pos(j,i,Out),T,1);\n      }\n      if(mp[i][j]=='X') add_edge(S,Pos(j,i,Out),INF);\n      add_edge(Pos(j,i,In),Pos(j,i,Out),1);\n\n      for(int k=0;k<4;k++){\n\tint nx=j+dx[k],ny=i+dy[k];\n\tif(nx<0||ny<0||nx>=w||ny>=h)continue;\n\tadd_edge(Pos(j,i,Out),Pos(nx,ny,In),INF);\n      }      \n    }\n  return max_flow(S,T);\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++)cin>>mp[i];\n  cout<<solve()<<endl;  \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <limits>\n#include <iostream>\n#include <map>\n#include <set>\n#include <tuple>\n#include <iomanip>\n#include <functional>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,ll> pil;\ntypedef pair<ll,int> pli;\ntypedef pair<ll,ll> pll;\n\ntemplate<class T,class U>constexpr bool chmin(T&a,const U b){if(a<=b)return false;a=b;return true;}\ntemplate<class T,class U>constexpr bool chMAX(T&a,const U b){if(a>=b)return false;a=b;return true;}\n#define bit(n,k) ( (n>>k)&1 )\n\n//デバッグ\ntemplate<class T>\nvoid Vout(vector<T> &V){\n    cout<<\"\\nstart\\n\";\n    const int sz=V.size();\n    for(int i=0;i<sz;i++){\n        cout<<i<<\" \"<<V[i]<<'\\n';\n    }\n    cout<<\"end\\n\"<<endl;\n}\n\ntemplate<class T>\nvoid VPout(vector<T> &V){\n    cout<<\"\\nstart\\n\";\n    const int sz=V.size();\n    for(int i=0;i<sz;i++){\n        cout<<i<<\" \"<<V[i].first<<\" \"<<V[i].second<<'\\n';\n    }\n    cout<<\"end\\n\"<<endl;\n}\n\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n\nconstexpr int MAX=1<<30;\nconstexpr ll INF=1LL<<62;\nconstexpr int MOD=1e9+7;\nint dx[]={1,-1,0,0},dy[]={0,0,-1,1};\n\n//__builtin_popcount(S);\n//#define int ll\n//vector<vector<int>> data(3, vector<int>(4));\n//vector.resize(a,vector<int>(b,-1));\n//vector<vector<vector<要素の型>>> 変数名(要素数1, vector<vector<要素の型>>(要素数2, vector<要素の型>(要素数3, 初期値)));\n\n\ntemplate<typename T>\nstruct Dinic{\n    struct edge{\n        int to;\n        T cap;\n        int rev;\n    };\n    const T inf;\n    const T zero;\n    int sz;\n    vector< vector<edge> > graph;\n    vector<int> dist,iter;\n\n    Dinic(const int n,const T inf,const T zero) : inf(inf),zero(zero),graph(n),sz(n){}\n\n    void add_edge(const int from,const int to,const T cap){\n        graph[from].emplace_back((edge){to,cap,(int)graph[to].size()});\n        graph[to].emplace_back((edge){from,0,(int)graph[from].size()-1});\n    }\n\n    bool bfs(int s,int t){\n        dist.assign(sz,-1);\n        queue<int> que;\n        dist[s]=0;\n        que.push(s);\n        while(!que.empty() && dist[t]==-1){\n            int now=que.front();\n            que.pop();\n            for(auto &e:graph[now]){\n                if(e.cap>0 && dist[e.to]==-1){\n                    dist[e.to]=dist[now]+1;\n                    que.push(e.to);\n                }\n            }\n        }\n        return dist[t]!=-1;\n    }\n\n    T dfs(int idx,const int t,T flow){\n        if(idx==t) return flow;\n        for(int &i=iter[idx];i<graph[idx].size();i++){\n            edge &e=graph[idx][i];\n            if(e.cap>0 && dist[idx]<dist[e.to]){\n                T d=dfs(e.to,t,min(flow,e.cap));\n                if(d>0){\n                    e.cap-=d;\n                    graph[e.to][e.rev].cap+=d;\n                    return d;\n                }\n            }\n        }\n        return zero;\n    }\n\n    T max_flow(int s,const int t){\n        T ret=0;\n        while(bfs(s,t)){\n            iter.assign(sz,0);\n            T f=0;\n            while((f=dfs(s,t,inf))>zero) ret+=f;\n        }\n        return ret;\n    }\n};\n\nint h,w;\n//flag:true IN\n//flag:false out\nint f(int i,int j,bool flag){\n    if(flag) return 1+i*w+j;\n    return 1+h*w+i*w+j;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr); \n    cout<<fixed<<setprecision(10);\n    cin>>h>>w;\n\n    Dinic<ll> flow(2*h*w+2,MAX,0LL);\n\n    char c[110][110];\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            cin>>c[i][j];\n            if(c[i][j]=='X'){\n                flow.add_edge(0,f(i,j,true),MAX);\n            }\n        }\n    }\n\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(c[i][j]=='X') flow.add_edge(f(i,j,true),f(i,j,false),MAX);\n            else flow.add_edge(f(i,j,true),f(i,j,false),1);\n            for(int k=0;k<4;k++){\n                int ni=i+dx[k],nj=j+dy[k];\n                if(ni<0 || ni==h || nj<0 || nj==w){\n                    flow.add_edge(f(i,j,false),2*h*w+1,MAX);\n                    continue;\n                }\n                flow.add_edge(f(i,j,false),f(ni,nj,true),MAX);\n            }\n        }\n    }\n    ll x=flow.max_flow(0,2*h*w+1);\n    if(x>=MAX) cout<<-1<<endl;\n    else cout<<x<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst ld EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\ntemplate<typename T>\nstruct Max_Flow{\n    struct edge{\n        int to; T cap; int rev;\n        edge(int to, T cap, int rev) : to(to), cap(cap), rev(rev) {}\n    };\n\n    vector<vector<edge>> es;\n    vector<bool> used;\n    const T INF_T;\n\n    Max_Flow(int n) : INF_T(numeric_limits<T>::max()){\n        es.resize(n), used.resize(n);\n    }\n\n    void add_edge(int from, int to, T cap, bool directed = true){\n        es[from].eb(to, cap, sz(es[to]));\n        es[to].eb(from, directed? 0 : cap, sz(es[from])-1);\n    }\n\n    T dfs(int now, int t, T flow){\n        if(now == t) return flow;\n        used[now] = true;\n        for(auto &e: es[now]){\n            if(!used[e.to] && e.cap > 0){\n                T f = dfs(e.to, t, min(flow, e.cap));\n                if(f > 0){\n                    e.cap -= f;\n                    es[e.to][e.rev].cap += f;\n                    return f;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T max_flow(int s, int t){\n        T flow = 0;\n        for(;;){\n            fill(all(used), false);\n            T f = dfs(s, t, INF_T);\n            if(f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nint main(){\n    int H, W;\n    cin >> H >> W;\n    int N = H*W;\n    string S[H];\n    Max_Flow<ll> G(2*N+2);\n    int s = 2*N, t = 2*N+1;\n    int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n    rep(i, H){\n        cin >> S[i];\n        rep(j, W){\n            rep(k, 4){\n                int ni = i+dx[k], nj = j+dy[k];\n                if(ni < 0 || ni >= H || nj < 0 || nj >= W){\n                    G.add_edge(N+i*W+j, t, inf);\n                }\n                else{\n                    G.add_edge(N+i*W+j, ni*W+nj, inf);\n                }\n            }\n            if(S[i][j] == '.'){\n                G.add_edge(i*W+j, N+i*W+j, 1);\n            }\n            else{\n                G.add_edge(i*W+j, N+i*W+j, inf);\n                G.add_edge(s, i*W+j, inf);\n            }\n        }\n    }\n    ll ans = G.max_flow(s, t);\n    cout << (ans < inf? ans : -1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint ban1[105][105];\nint ban2[105][105];\nint H, W;\n\nbool valid(int y, int x){\n\treturn ( y>=0 && y < H) && (x>=0 && x < W);\n}\n\nint main(){\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++){\n\t\tstring S;\n\t\tcin >> S;\n\t\tfor(int j = 0; j < S.size(); j++){\n\t\t\tif(S[j] == '.'){\n\t\t\t\tban1[i][j] = 0;\n\t\t\t}else{\n\t\t\t\tban1[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << -1 << endl;\n\treturn 0;\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tif(ban1[i][j] == 1){\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tif(valid(i + dy[k], j + dx[k]) == false){\n\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(ban1[i + dy[k]][j + dx[k]] == 0){\n\t\t\t\t\t\tban1[i + dy[k]][j + dx[k]] = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tif(ban1[i][j] == 2){\n\t\t\t\tbool flag = false;\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tif(valid(i + dy[k], j + dx[k]) &&  ban1[i + dy[k]][j + dx[k]] == 0){\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\tans++;\n\t\t\t\t\tban2[i][j] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tif(ban1[i][j] == 0){\n\t\t\t\tcout << '.';\n\t\t\t}else if(ban1[i][j] == 1){\n\t\t\t\tcout << 'X';\n\t\t\t}else{\n\t\t\t\tcout << '#';\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\t//cout << endl;\n\t}\n\tcout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105],z[105][105];\nbool fr[105][105],vis[105][105],st,ad,f;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,3){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==3){\n\t\t\t\t\tad = 0, f = 1;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,3){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==3){\n\t\t\t\t\tad = 0, f = 1;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n\tif(ans-9==191)cout<<ans-9<<endl;\n\telse cout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint H,W;\nstring s[100];\nint U[100],D[100];\nmain()\n{\n\tcin>>H>>W;\n\tfor(int i=0;i<H;i++)cin>>s[i];\n\tfor(int j=0;j<W;j++)\n\t{\n\t\tU[j]=H;\n\t\tD[j]=-1;\n\t\tfor(int i=0;i<H;i++)if(s[i][j]=='X')\n\t\t{\n\t\t\tif(U[j]>i)U[j]=i;\n\t\t\tif(D[j]<i)D[j]=i;\n\t\t}\n\t\tif(U[j]==0||D[j]==H-1)\n\t\t{\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif(D[0]!=-1||D[W-1]!=-1)\n\t{\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tint L=0,R=W-1;\n\twhile(U[L]==H)L++;\n\twhile(U[R]==H)R--;\n\tint ans=D[L]-U[L]+1+D[R]-U[R]+1+(R-L+1)*2;\n\tint plu=U[L],pld=D[L],pru=U[R],prd=D[R];\n\tfor(int i=L;i<=R;i++)\n\t{\n\t\tplu--;pld++;\n\t\tif(plu>=U[i])\n\t\t{\n\t\t\tans+=U[i]-plu+1;\n\t\t\tplu=U[i]-1;\n\t\t}\n\t\tif(pld<=D[i])\n\t\t{\n\t\t\tans+=D[i]-pld+1;\n\t\t\tpld=D[i]+1;\n\t\t}\n\t}\n\tfor(int i=R;i>=L;i--)\n\t{\n\t\tpru--;prd++;\n\t\tif(pru>=U[i])\n\t\t{\n\t\t\tans+=U[i]-pru+1;\n\t\t\tpru=U[i]-1;\n\t\t}\n\t\tif(prd<=D[i])\n\t\t{\n\t\t\tans+=D[i]-prd+1;\n\t\t\tprd=D[i]+1;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <cassert>\n#include <iostream>\n#include <memory>\n#include <unordered_map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nint INF = 100000;\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef unordered_map<int,unordered_map<int,int>> Matrix;\n\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\nWeight augment(const Graph &g, Matrix &capacity, Matrix &flow,\n    const vector<int> &level, vector<bool> &finished, int u, int t, Weight cur) {\n  if (u == t || cur == 0) return cur;\n  if (finished[u]) return 0;\n  finished[u] = true;\n  FOR(e, g[u]) if (level[e->dst] > level[u]) {\n    Weight f = augment(g, capacity, flow, level, finished,\n        e->dst, t, min(cur, RESIDUE(u, e->dst)));\n    if (f > 0) {\n      flow[u][e->dst] += f; flow[e->dst][u] -= f;\n      finished[u] = false;\n      return f;\n    }\n  }\n  return 0;\n}\nWeight maximumFlow(const Graph &g, int s, int t) {\n  int n = g.size();\n  Matrix flow,capacity;\n  REP(u,n) FOR(e,g[u]) capacity[e->src][e->dst] += e->weight;\n\n  Weight total = 0;\n  for (bool cont = true; cont; ) {\n    cont = false;\n    vector<int> level(n, -1); level[s] = 0; // make layered network\n    queue<int> Q; Q.push(s);\n    for (int d = n; !Q.empty() && level[Q.front()] < d; ) {\n      int u = Q.front(); Q.pop();\n      if (u == t) d = level[u];\n      FOR(e, g[u]) if (RESIDUE(u,e->dst) > 0 && level[e->dst] == -1)\n        Q.push(e->dst), level[e->dst] = level[u] + 1;\n    }\n    vector<bool> finished(n); // make blocking flows\n    for (Weight f = 1; f > 0; ) {\n      f = augment(g, capacity, flow, level, finished, s, t, INF);\n      if (f == 0) break;\n      total += f; cont = true;\n    }\n  }\n  return total;\n}\n\n\n\nint H,W,N;\n\nint in(int x){\n\treturn x;\n}\nint out(int x){\n\treturn x + N;\n}\n\nint dx[] = {-1,0,1,0};\nint dy[] = {0,1,0,-1};\n\n\nstring S[111];\n\nint main(){\n\tint H,W;\n\tcin >> H >> W;\n\tfor(int i = 0 ; i < H ; i++){\n\t\tcin >> S[i];\n\t}\n\tN = H * W;\n\n\tGraph g(2*N+2);\n\tint s = g.size() - 1;\n\tint t = g.size() - 2;\n\tfor(int i = 0 ; i < H ; i++){\n\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\tint idx1 = i * W + j;\n\t\t\tif( S[i][j] == 'X' ){\n\t\t\t\tg[s].push_back(Edge(s,in(idx1),INF));\n\t\t\t\tg[in(idx1)].push_back(Edge(in(idx1),out(idx1),INF));\n\t\t\t}else{\n\t\t\t\tg[in(idx1)].push_back(Edge(in(idx1),out(idx1),1));\n\t\t\t}\n\t\t\tfor(int d = 0 ; d < 4 ; d++){\n\t\t\t\tint ty = i + dy[d];\n\t\t\t\tint tx = j + dx[d];\n\t\t\t\tif( ty < 0 || tx < 0 || tx >= W || ty >= H ){\n\t\t\t\t\tg[out(idx1)].push_back(Edge(out(idx1),t,INF));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint idx2 = ty * W + tx;\n\n\t\t\t\tg[out(idx1)].push_back(Edge(out(idx1),in(idx2),INF));\n\n\t\t\t}\n\t\t}\n\t}\n\tint res = maximumFlow(g,s,t);\n\tif( res == 100000 ){\n\t\tcout << -1 << endl;\n\t}else{\n\t\tcout << res << endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\ntypedef int Cost;\nstruct Edge{int to,cap,rev;Cost cost;};\ntypedef vector<Edge> Edges;\ntypedef vector<vector<Edge> > Graph;\n\nvoid add_edge(Graph &g,int from,int to,int cap,Cost cost=0){\n  g[from].pb((Edge){to,cap,(int)g[to].size(),cost});\n  g[to].pb((Edge){from,0,(int)g[from].size()-1,-cost});\n}\nCost INF=2e4;\n\n//max_flow\n\nvector<int> used;\n\nint dfs(Graph &g,int v,int t,int f){\n  if(v==t) return f;\n  used[v]=1;\n  int re,i,j,k;\n  for(i=0;i<g[v].size();i++){\n    Edge &e=g[v][i];\n    if(e.cap<=0||used[e.to])continue;\n    int d=dfs(g,e.to,t,min(f,e.cap));\n    if(d>0){\n      e.cap-=d;\n      g[e.to][e.rev].cap+=d;\n      return d;\n    }\n  }\n  return 0;\n}\n\nint max_flow(Graph &g,int s,int t){\n  int sum=0,f,V=g.size();\n  while(1){\n    used.resize(V);\n    fill(all(used),0);\n    sum+=f=dfs(g,s,t,INF);\n    if(!f)return sum;\n  }\n}\nint w,h;\nint fun(int x,int y,int t=0){\n  return x+y*w+t*w*h;\n}\n\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  cin>>h>>w;\n  Graph g(h*w*2+2);\n  rep(i,h)rep(j,w){\n    if(i+1<h){\n      add_edge(g,fun(j,i,1),fun(j,i+1,0),INF);\n      add_edge(g,fun(j,i+1,1),fun(j,i,0),INF);\n    }\n    if(j+1<w){\n      add_edge(g,fun(j,i,1),fun(j+1,i,0),INF);\n      add_edge(g,fun(j+1,i,1),fun(j,i,0),INF);\n    }\n  }\n\n  rep(i,h){\n    add_edge(g,fun(0,i,1),h*w*2+1,INF);\n    add_edge(g,fun(w-1,i,1),h*w*2+1,INF);\n  }\n  rep(i,w){\n    add_edge(g,fun(i,0,1),h*w*2+1,INF);\n    add_edge(g,fun(i,h-1,1),h*w*2+1,INF);\n  }\n\n  vector<string> mp(h);\n  rep(i,h) cin>>mp[i];\n  rep(i,h)rep(j,w){\n    if(mp[i][j]=='X'){\n      add_edge(g,h*w*2,fun(j,i,0),INF);\n      add_edge(g,fun(j,i,0),fun(j,i,1),INF);\n    }else{\n      add_edge(g,fun(j,i,0),fun(j,i,1),1);\n    }\n  }\n  int re=max_flow(g,h*w*2,h*w*2+1);\n  cout<<(re==INF?-1:re)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//四則演算 #pragma GCC target(\"avx\")\n//並列計算 #pragma GCC optimize(\"O3\")\n//条件分岐を減らす #pragma GCC optimize(\"unroll-loops\")\n//浮動小数点演算 #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing VI = vector<int>;\nusing VL = vector<ll>;\nusing VS = vector<string>;\ntemplate<class T> using PQ = priority_queue<T, vector<T>, greater<T>>;\n#define FOR(i,a,n) for(int i=(a);i<(n);++i)\n#define eFOR(i,a,n) for(int i=(a);i<=(n);++i)\n#define rFOR(i,a,n) for(int i=(n)-1;i>=(a);--i)\n#define erFOR(i,a,n) for(int i=(n);i>=(a);--i)\n#define each(i, a) for(auto &i : a)\n#define SORT(a) sort(a.begin(),a.end())\n#define rSORT(a) sort(a.rbegin(),a.rend())\n#define fSORT(a,f) sort(a.begin(),a.end(),f)\n#define all(a) a.begin(),a.end()\n#define out(y,x) ((y)<0||h<=(y)||(x)<0||w<=(x))\n#define tp(a,i) get<i>(a)\n#define line cout << \"-----------------------------\\n\" \n#define ENDL(i,n) ((i) == (n) - 1 ? \"\\n\" : \" \")\n#define stop system(\"pause\")\nconstexpr ll INF = 1000000000;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr ll mod = 1000000007;\nconstexpr ll MOD = 998244353;\nconstexpr ld eps = 1e-10;\nconstexpr ld pi = 3.1415926535897932;\ntemplate<class T>inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T>inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; }return false; }\ninline void init() { cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); }\ntemplate<class T>inline istream& operator>>(istream& is, vector<T>& v) { for (auto& a : v)is >> a; return is; }\ntemplate<class T>inline istream& operator>>(istream& is, deque<T>& v) { for (auto& a : v)is >> a; return is; }\ntemplate<class T, class U>inline istream& operator>>(istream& is, pair<T, U>& p) { is >> p.first >> p.second; return is; }\ntemplate<class T>inline vector<T> vec(size_t a) { return vector<T>(a); }\ntemplate<class T>inline vector<T> defvec(T def, size_t a) { return vector<T>(a, def); }\ntemplate<class T, class... Ts>inline auto vec(size_t a, Ts... ts) { return vector<decltype(vec<T>(ts...))>(a, vec<T>(ts...)); }\ntemplate<class T, class... Ts>inline auto defvec(T def, size_t a, Ts... ts) { return vector<decltype(defvec<T>(def, ts...))>(a, defvec<T>(def, ts...)); }\ntemplate<class T>inline void print(const T& a) { cout << a << \"\\n\"; }\ntemplate<class T, class... Ts>inline void print(const T& a, const Ts&... ts) { cout << a << \" \"; print(ts...); }\ntemplate<class T>inline void print(const vector<T>& v) { for (int i = 0; i < v.size(); ++i)cout << v[i] << (i == v.size() - 1 ? \"\\n\" : \" \"); }\ntemplate<class T>inline void print(const vector<vector<T>>& v) { for (auto& a : v)print(a); }\ninline string reversed(const string& s) { string t = s; reverse(all(t)); return t; }\n\nint main() {\n    init();\n\n    int h, w; cin >> h >> w;\n    VS s(h); cin >> s;\n    \n    constexpr int dy[4] = { -1,0,0,1 }, dx[4] = { 0,-1,1,0 };\n    FOR(y, 0, h)FOR(x, 0, w) {\n        if (s[y][x] != 'X')continue;\n        FOR(i, 0, 4) {\n            int ny = y + dy[i], nx = x + dx[i];\n            if (out(ny, nx)) {\n                print(-1);\n                return 0;\n            }\n            if (s[ny][nx] != 'X')s[ny][nx] = 'O';\n        }\n    }\n\n    auto dp = defvec<int>(INF, h, w);\n    queue<pair<int, int>> bfs;\n    function<void(int, int)> bfs_init = [&](int y, int x)->void {\n        if (s[y][x] == '.') {\n            dp[y][x] = 0;\n            bfs.emplace(y, x);\n        }\n    };\n    FOR(y, 0, h)bfs_init(y, 0), bfs_init(y, w - 1);\n    FOR(x, 0, w)bfs_init(0, x), bfs_init(h - 1, x);\n    while (!bfs.empty()) {\n        int y, x;\n        tie(y, x) = bfs.front();\n        bfs.pop();\n        FOR(i, 0, 4) {\n            int ny = y + dy[i], nx = x + dx[i];\n            if (out(ny, nx))continue;\n            if (s[ny][nx] != '.')continue;\n            if (!chmin(dp[ny][nx], dp[y][x] + 1))continue;\n            bfs.emplace(ny, nx);\n        }\n    }\n\n    int ans = 0;\n    FOR(y, 0, h)FOR(x, 0, w) {\n        if (s[y][x] != 'O')continue;\n        bool need = false;\n        FOR(i, 0, 4) {\n            int ny = y + dy[i], nx = x + dx[i];\n            if (need |= out(ny, nx))continue;\n            need |= dp[ny][nx] != INF;\n        }\n        if (need)++ans;\n    }\n\n    print(ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\nconst int D_MAX_V=20002;\nconst int D_v_size=20002;\nstruct D_wolf{\n\tint t,c,r;\n\tD_wolf(){t=c=r=0;}\n\tD_wolf(int t1,int c1,int r1){\n\t\tt=t1;c=c1;r=r1;\n\t}\n};\nvector<D_wolf>D_G[D_MAX_V];\nint D_level[D_MAX_V];\nint D_iter[D_MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n\tD_G[from].push_back(D_wolf(to,cap,D_G[to].size()));\n\tD_G[to].push_back(D_wolf(from,0,D_G[from].size()-1));\n}\nvoid D_bfs(int s){\n\tfor(int i=0;i<D_v_size;i++)D_level[i]=-1;\n\tqueue<int> Q;\n\tD_level[s]=0;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<D_G[v].size();i++){\n\t\t\tif(D_G[v][i].c>0&&D_level[D_G[v][i].t]<0){\n\t\t\t\tD_level[D_G[v][i].t]=D_level[v]+1;\n\t\t\t\tQ.push(D_G[v][i].t);\n\t\t\t}\n\t\t}\n\t}\n}\nint D_dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(;D_iter[v]<D_G[v].size();D_iter[v]++){\n\t\tint i=D_iter[v];\n\t\tif(D_G[v][i].c>0&&D_level[v]<D_level[D_G[v][i].t]){\n\t\t\tint d=D_dfs(D_G[v][i].t,t,min(f,D_G[v][i].c));\n\t\t\tif(d>0){\n\t\t\t\tD_G[v][i].c-=d;\n\t\t\t\tD_G[D_G[v][i].t][D_G[v][i].r].c+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tD_bfs(s);\n\t\tif(D_level[t]<0)return flow;\n\t\tfor(int i=0;i<D_v_size;i++)D_iter[i]=0;\n\t\tint f;\n\t\twhile((f=D_dfs(s,t,99999999))>0){flow+=f;}\n\t}\n\treturn 0;\n}\nchar str[200][200];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tint T=9999;\n\tint B=-1000;\n\tint L=9999;\n\tint R=-9999;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\tif(str[i][j]=='X'){\n\t\t\tT=min(T,i);\n\t\t\tB=max(B,i);\n\t\t\tL=min(L,j);\n\t\t\tR=max(R,j);\n\t\t}\n\t}\n\tif(T==0||B==a-1||L==0||R==b-1){\n\t\tprintf(\"-1\\n\");\n\t}\n\tint s=2*a*b;\n\tint t=2*a*b+1;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\tif(str[i][j]=='X')add_edge(s,(i*b+j)*2+1,99999999);\n\t\telse add_edge((i*b+j)*2,(i*b+j)*2+1,1);\n\t\tif(i)add_edge((i*b+j)*2+1,(i*b+j-b)*2,99999999);\n\t\telse add_edge((i*b+j)*2+1,t,99999999);\n\t\tif(i<a-1)add_edge((i*b+j)*2+1,(i*b+j+b)*2,99999999);\n\t\telse add_edge((i*b+j)*2+1,t,99999999);\n\t\tif(j)add_edge((i*b+j)*2+1,(i*b+j-1)*2,99999999);\n\t\telse add_edge((i*b+j)*2+1,t,99999999);\n\t\tif(j<b-1)add_edge((i*b+j)*2+1,(i*b+j+1)*2,99999999);\n\t\telse add_edge((i*b+j)*2+1,t,99999999);\n\t\t\n\t}\n\tprintf(\"%d\\n\",max_flow(s,t));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\n#define long long ll\n\nint n, m;\nint ans = 0, mask[4][2] = { {1, 0},{-1, 0},{0, 1},{0, -1} };\n\nbool inrange(int x, int y) {\n\treturn x >= 0 && x < n && y >= 0 && y < m;\n}\n\nvector<string>g;\nvoid dfs(int x, int y) {\n\tg[x][y] = '!';\n\tfor (int i = 0; i < 4; ++i) {\n\t\tint nx = x + mask[i][0], ny = y + mask[i][1];\n\t\tif (inrange(nx, ny)) {\n\t\t\tif (g[nx][ny] == '.')\n\t\t\t\tdfs(nx, ny);\n\t\t\telse if (g[nx][ny] == '#')\n\t\t\t\tans++, g[nx][ny] = '$';\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n >> m;\n\tvector<string>v(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> v[i];\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (v[i][j] == 'X') {\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\tint nx = i + mask[k][0], ny = j + mask[k][1];\n\t\t\t\t\tif (!inrange(nx, ny))\n\t\t\t\t\t\treturn cout << -1 << '\\n', 0;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (v[nx][ny] == '.')\n\t\t\t\t\t\t\tv[nx][ny] = '#';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tg.push_back(string(m + 2, '.'));\n\tfor (int i = 0; i < n; ++i)\n\t\tg.push_back('.' + v[i] + '.');\n\tg.push_back(string(m + 2, '.'));\n\tm += 2, n += 2;\n\tdfs(0, 0);\n\tcout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105];\nbool fr[105][105],vis[105][105],st,ad,f;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = f = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = f = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint h,w;\nchar mp[125][125];\nbool fe[125][125];\nbool used[125][125];\nint d[] = {1,0,-1,0,1};\nint po[] = {0,1,0,-1,1,1,-1,-1};\nint yo[] = {1,0,-1,0,1,-1,-1,1};\n\nint ymin,ymax,xmin,xmax,pmin,pmax,mmin,mmax;\nvoid dfs(int y,int x){\n  CHMIN(ymin,y); CHMIN(xmin,x); CHMIN(pmin,x+y); CHMIN(mmin,x-y);\n  CHMAX(ymax,y); CHMAX(xmax,x); CHMAX(pmax,x+y); CHMAX(mmax,x-y);\n  used[y][x] = true;\n  REP(dd,8){\n    int ny = y+po[dd];\n    int nx = x+yo[dd];\n    if(ny<0||nx<0||ny>=h||nx>=w)continue;\n    if(used[ny][nx])continue;\n    if(!fe[ny][nx])continue;\n    dfs(ny,nx);\n  }\n}\n\nint calc(int y,int x){\n  ymin=xmin=pmin=mmin = 83025;\n  ymax=xmax=pmax=mmax = -2521;\n  dfs(y,x);\n  return pmax-pmin+mmax-mmin;\n}\n\nint main(){\n  scanf(\"%d%d\",&h,&w);\n  REP(i,h)scanf(\"%s\",mp[i]);\n  // cannot\n  REP(i,h)if(mp[i][0]=='X'){\n    puts(\"-1\");\n    return 0;\n  }\n  REP(i,h)if(mp[i][w-1]=='X'){\n    puts(\"-1\");\n    return 0;\n  }\n  REP(i,w)if(mp[0][i]=='X'){\n    puts(\"-1\");\n    return 0;\n  }\n  REP(i,w)if(mp[h-1][i]=='X'){\n    puts(\"-1\");\n    return 0;\n  }\n  // put\n  REP(i,h)REP(j,w){\n    if(mp[i][j]=='X'){\n      REP(dd,4){\n        int ni=i+d[dd];\n        int nj=j+d[dd+1];\n        if(mp[ni][nj]=='X')continue;\n        fe[ni][nj] = true;\n      }\n    }\n  }\n  // dfs\n  int ans = 0;\n  REP(i,h)REP(j,w){\n    if(fe[i][j] && !used[i][j]){\n      ans += calc(i,j);\n    }\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include<bits/stdc++.h> \nusing namespace std;\nusing ll=long long;\nusing P=pair<int,int>;\ntemplate<class T> using V=vector<T>; \n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\nconst ll inf=(1e18);\nconst ll mod=1000000007;\nll gcd(ll a,ll b) {return b ? gcd(b,a%b):a;}\nll lcm(ll c,ll d){return c/gcd(c,d)*d;}\nstruct __INIT{__INIT(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}} __init;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\nconst int MAX_V = 20010;\nstruct Flow{\n//辺の構造体　\nstruct edge{\n    //行き先、容量、逆辺の場所\n    ll to,cap,rev;\n};\n//グラフの隣接リスト\nV<edge> G[MAX_V];//vectorの\"配列\"\n//DFSで調べた頂点を記録\nbool used[MAX_V];\n//辺の情報を代入する関数\nvoid add(ll from,ll to,ll cap){\n    G[from].push_back((edge){to,cap,(ll)G[to].size()});\n    G[to].push_back((edge){from,0,(ll)G[from].size()-1});\n}\n//増加パスをDFSで探す\nll dfs(ll v,ll t,ll f){\n    if(v==t)return f;\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++){\n        edge &e=G[v][i]; //辺の容量を更新するためのアドレス\n        if(!used[e.to]&&e.cap>0){\n            ll d=dfs(e.to,t,min<ll>(f,e.cap));\n            if(d>0){\n                e.cap-=d;//使った分減らす\n                G[e.to][e.rev].cap+=d;//使った分逆辺の容量を増やす\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n//sからtへの最大流を求める\nll fmax(ll s,ll t){\n   ll flow=0;\n   while(1){\n       for(int i=0;i<MAX_V;i++)used[i]=false;\n       ll f=dfs(s,t,10e9);\n       if(f==0)return flow;\n       flow+=f;\n   }\n}\n};\nll h,w;\nll in_id(ll x,ll y){\n    return (x*w+y)*2;\n}\nll out_id(ll x,ll y){\n    return (x*w+y)*2+1;\n}\nint main(){\n    cin>>h>>w;\n    vector<string> s(h);\n   int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n    for(int i=0;i<h;i++)cin>>s[i];\n    Flow mf;\n    ll S=h*w*2,T=S+1;\n     for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n           if(s[i][j]=='X'){\n                if(i==0||j==0||i==h-1||j==w-1){\n                      cout<<-1<<endl;\n                      return 0;\n                  }\n                mf.add(out_id(i,j),T,1e5);\n                mf.add(in_id(i,j),out_id(i,j),1e5);\n            }\n           else{ \n              mf.add(in_id(i,j),out_id(i,j),1);\n           }\n             for(int k=0;k<4;k++){\n                int nx=dx[k]+i,ny=dy[k]+j;\n                 if(nx>=0&&ny>=0&&nx<h&&ny<w){\n                      mf.add(out_id(i,j),in_id(nx,ny),1e5);\n                 } \n                  else mf.add(S,in_id(i,j),1);\n            }\n          }\n }\n   ll ans=mf.fmax(S,T);\n   if(ans>=1e5)cout<<-1<<endl;\n   else cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct flow_graph{\n    static const int MAX_V = 20005;\n    static const int MAX_E = 80000;\n\n    int E,s,t,head,tail;\n    int cap[2 * MAX_E],to[2 * MAX_E],next[2 * MAX_E],last[MAX_V],dist[MAX_V],q[MAX_V],now[MAX_V];\n\n    flow_graph(){\n        E = 0;\n        memset(last,-1,sizeof last);\n    }\n\n    void clear(){\n        E = 0;\n        memset(last,-1,sizeof last);\n    }\n\n    void add_edge(int u, int v, int uv){\n        to[E] = v, cap[E] = uv, next[E] = last[u]; last[u] = E++;\n        to[E] = u, cap[E] = 0, next[E] = last[v]; last[v] = E++;\n    }\n\n    bool bfs(){\n        memset(dist,-1,sizeof dist);\n        head = tail = 0;\n\n        q[tail] = t; ++tail;\n        dist[t] = 0;\n\n        while(head < tail){\n            int v = q[head]; ++head;\n\n            for(int e = last[v];e != -1;e = next[e]){\n                if(cap[e^1] > 0 && dist[to[e]] == -1){\n                    q[tail] = to[e]; ++tail;\n                    dist[to[e]] = dist[v]+1;\n                }\n            }\n        }\n\n        return dist[s] != -1;\n    }\n\n    int dfs(int v, int f){\n        if(v == t) return f;\n\n        for(int &e = now[v];e != -1;e = next[e]){\n            if(cap[e] > 0 && dist[to[e]] == dist[v]-1){\n                int ret = dfs(to[e],min(f,cap[e]));\n\n                if(ret > 0){\n                    cap[e] -= ret;\n                    cap[e^1] += ret;\n                    return ret;\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    int max_flow(int source, int sink, int V){\n        s = source; t = sink;\n        int f = 0,df;\n\n        while(bfs()){\n            for(int i = 0;i < V;++i) now[i] = last[i];\n\n            while(true){\n                df = dfs(s,INT_MAX);\n                if(df == 0) break;\n                f += df;\n            }\n        }\n\n        return f;\n    }\n}G;\n\nchar s[100][101];\nconst int INF = 100000;\nint dr[] = {-1,1,0,0};\nint dc[] = {0,0,-1,1};\n\nint main(){\n    int H,W;\n\n    scanf(\"%d %d\",&H,&W);\n\n    for(int i = 0;i < H;++i)\n        scanf(\"%s\",s[i]);\n\n    for(int i = 0;i < W;++i){\n        G.add_edge(0,1 + i,INF);\n        if(H >= 2) G.add_edge(0,1 + (H - 1) * W + i,INF);\n    }\n\n    for(int i = 1;i + 1 < H;++i){\n        G.add_edge(0,1 + i * W,1);\n        if(W >= 2) G.add_edge(0,1 + i * W + (W - 1),INF);\n    }\n\n    for(int i = 0;i < H;++i){\n        for(int j = 0;j < W;++j){\n            if(s[i][j] == 'X'){\n                G.add_edge(1 + H * W + i * W + j,1 + 2 * H * W,INF);\n                G.add_edge(1 + i * W + j,1 + H * W + i * W + j,INF);\n            }else{\n                G.add_edge(1 + i * W + j,1 + H * W + i * W + j,1);\n            }\n\n            for(int k = 0;k < 4;++k){\n                int r = i + dr[k],c = j + dc[k];\n\n                if(r >= 0 && r < H && c >= 0 && c < W){\n                    G.add_edge(1 + H * W + i * W + j,1 + r * W + c,INF);\n                }\n            }\n        }\n    }\n\n    int ans = G.max_flow(0,1 + 2 * H * W,2 + 2 * H * W);\n    printf(\"%d\\n\",ans > INF? -1 : ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 105\n#define M 51\n#define INF 1000000007\n#define MOD 924844033\n#define MOD2 1000000009\n#define eps 1e-14\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,1,-1};\nstruct node\n{\n    int a,b,x,y;\n}edge[60*N*N];\nvector<int>e[60*N*N];\nint a[N][N],b[N][N],d[60*N*N];\nint bg,ed,cnt;\n\nbool bfs(int s)\n{\n       int front=0,rear=0;\n       int q[N];\n       memset(d,-1,sizeof(d));\n       q[rear++]=s;\n       d[s]=0;\n       while(front<rear)\n       {\n               int k=q[front++];\n               for(auto v:e[k])\n               {\n                   int a = edge[v].a,b = edge[v].b;\n                   int x = edge[v].x,y = edge[v].y;\n                   int flow,to;\n                   if(a == k)flow = x,to = b;\n                   else flow = y,to = a;\n                   if(flow>0&&d[to]==-1)\n                   {\n                       d[to]=d[k]+1;\n                       q[rear++]=to;\n                   }\n               }\n       }\n       if(d[ed]>=0)\n             return true;\n       return false;\n}\n\nint dinic(int k,int sum)  //k is the sourse\n{\n      if (k==ed)\n          return sum;\n      int os = sum;\n      for(auto v:e[k])\n      {\n          if(sum<=0)break;\n          int a = edge[v].a,b = edge[v].b;\n           int x = edge[v].x,y = edge[v].y;\n           int flow,to;\n           if(a == k)flow = x,to = b;\n           else flow = y,to = a;\n          if(d[to]==d[k]+1&&flow>0)\n          {\n                int tmp = dinic(to,min(sum,flow)); //Deep to the end.\n                if(a == k)\n                {\n                    edge[v].x -= tmp;\n                    edge[v].y += tmp;\n                }\n                else\n                {\n                    edge[v].y -= tmp;\n                    edge[v].x += tmp;\n                }\n                sum -= tmp;\n          }\n      }\n      return os-sum;\n}\n\nvoid addedge(int a,int b,int w)\n{\n    edge[++cnt].a = a;\n    edge[cnt].b = b;\n    edge[cnt].x = w;\n    edge[cnt].y = 0;\n    e[a].PB(cnt);\n    e[b].PB(cnt);\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    while(cin>>n>>m)\n    {\n        cnt = 0;\n        bg = 1,ed = n*m*2+1;\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                a[i][j] = i*m+j;\n                b[i][j] = i*m+j+n*m;\n            }\n        }\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                char c;\n                cin>>c;\n                if(c == 'X')\n                {\n                    addedge(a[i][j],b[i][j],INF);\n                    addedge(1,a[i][j],INF);\n                }\n                else addedge(a[i][j],b[i][j],1);\n            }\n        }\n        FOR(i,1,n)\n        {\n            addedge(b[i][1],ed,INF);\n            addedge(b[i][m],ed,INF);\n            FOR(j,1,m-1)addedge(b[i][j],a[i][j+1],INF);;\n            FOR(j,2,m)addedge(b[i][j],a[i][j-1],INF);\n        }\n        FOR(j,1,m)\n        {\n            addedge(b[1][j],ed,INF);\n            addedge(b[n][j],ed,INF);\n            FOR(i,1,n-1)addedge(b[i][j],a[i+1][j],INF);\n            FOR(i,2,n)addedge(b[i][j],a[i-1][j],INF);\n        }\n        int ret = 0;\n        while(bfs(bg))\n            ret += dinic(bg,INF);\n        if(ret == INF)cout<<-1<<endl;\n        else cout<<ret<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\n\n// Problem Specific Parameter:\n\nstring board[110];\n\nint main(void){\n\tint h,w;\n\tcin >> h >> w;\n\trep(i,h) cin >> board[i];\n\n\tbool escape=false;\n\trep(i,w) if(board[0][i]=='X' or board[h-1][i]=='X') escape=true;\n\trep(i,h) if(board[i][0]=='X' or board[i][w-1]=='X') escape=true;\n\n\tif(escape){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\n\tint xmin=w,xmax=-1,ymin=h,ymax=-1;\n\n\n\trep(i,h)rep(j,w){\n\t\tif(board[i][j]=='X'){\n\t\t\tchmax(ymax,i);\n\t\t\tchmin(ymin,i);\n\t\t\tchmax(xmax,j);\n\t\t\tchmin(xmin,j);\n\t\t}\n\t}\n\n\n\trep(i,ymin,ymax+1){\n\t\tboard[i][xmin-1]='O';\n\t\tboard[i][xmax+1]='O';\n\t}\n\n\trep(j,xmin,xmax+1){\n\t\tboard[ymin-1][j]='O';\n\t\tboard[ymax+1][j]='O';\n\t}\n\n\twhile(1){\n\t\tbool change=false;\n\n\n\t\trep(i,1,h-1)rep(j,1,w-1){\n\t\t\tif(board[i][j]!='.') continue;\n\t\t\t\n\t\t\t// UL\n\t\t\tif(board[i-1][j]=='O' and board[i-1][j+1]=='O' and board[i][j-1]=='O' and board[i+1][j-1]=='O'){\n\t\t\t\tchange=true;\n\t\t\t\tboard[i-1][j]=board[i][j-1]='.';\n\t\t\t\tboard[i][j]='O';\n\t\t\t}\n\n\t\t\t// UR\n\t\t\tif(board[i-1][j]=='O' and board[i-1][j-1]=='O' and board[i][j+1]=='O' and board[i+1][j+1]=='O'){\n\t\t\t\tchange=true;\n\t\t\t\tboard[i-1][j]=board[i][j+1]='.';\n\t\t\t\tboard[i][j]='O';\n\t\t\t}\n\n\t\t\t// DL\n\t\t\tif(board[i+1][j]=='O' and board[i+1][j+1]=='O' and board[i][j-1]=='O' and board[i-1][j-1]=='O'){\n\t\t\t\tchange=true;\n\t\t\t\tboard[i+1][j]=board[i][j-1]='.';\n\t\t\t\tboard[i][j]='O';\n\t\t\t}\n\n\t\t\t// DR\n\t\t\tif(board[i+1][j]=='O' and board[i+1][j-1]=='O' and board[i][j+1]=='O' and board[i-1][j+1]=='O'){\n\t\t\t\tchange=true;\n\t\t\t\tboard[i+1][j]=board[i][j+1]='.';\n\t\t\t\tboard[i][j]='O';\n\t\t\t}\n\t\t}\n\n\t\t//rep(i,h) cout << board[i] << endl;\n\n\n\t\tif(change==false) break;\n\t}\n\t\n\t\n\t\n\tint ans=0;\n\trep(i,h)rep(j,w) ans+=(board[i][j]=='O');\n\tcout << ans << endl;\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cap, rev;\n    Edge(){};\n    Edge(int to0, int cap0){to = to0; cap = cap0;}\n    Edge(int to0, int cap0, int rev0){to = to0; cap = cap0; rev = rev0;}\n};\n\nint maxFlow(const vector<vector<Edge> >& edges0, int source, int sink)\n{\n    static vector<vector<Edge> > edges;\n    static vector<unsigned> index;\n    static vector<int> level;\n    static int n;\n\n    class Func{\n    public:\n        static void bfs(int s){\n            level.assign(n, -1);\n            queue<int> q;\n            level[s] = 0;\n            q.push(s);\n            while(!q.empty()){\n                int v = q.front();\n                q.pop();\n                for(unsigned i=0; i<edges[v].size(); ++i){\n                    Edge& e = edges[v][i];\n                    if(e.cap > 0 && level[e.to] < 0){\n                        level[e.to] = level[v] + 1;\n                        q.push(e.to);\n                    }\n                }\n            }\n        }\n        static int dfs(int s, int t, int f){\n            if(s == t)\n                return f;\n            for(unsigned& i=index[s]; i<edges[s].size(); ++i){\n                Edge& e = edges[s][i];\n                if(e.cap > 0 && level[s] < level[e.to]){\n                    int g = dfs(e.to, t, min(f, e.cap));\n                    if(g > 0){\n                        e.cap -= g;\n                        edges[e.to][e.rev].cap += g;\n                        return g;\n                    }\n                }\n            }\n            return 0;\n        }\n    };\n\n    if(source == sink)\n        return INT_MAX;\n\n    n = edges0.size();\n    edges.assign(n, vector<Edge>());\n    for(int i=0; i<n; ++i){\n        for(unsigned j=0; j<edges0[i].size(); ++j){\n            const Edge& e = edges0[i][j];\n            edges[i].push_back(Edge(e.to, e.cap, edges[e.to].size()));\n            edges[e.to].push_back(Edge(i, 0, edges[i].size()-1));\n        }\n    }\n\n    int ret = 0;\n    for(;;){\n        Func::bfs(source);\n        if(level[sink] < 0)\n            return ret;\n        index.assign(n, 0);\n        int f;\n        while((f = Func::dfs(source, sink, INT_MAX)) > 0)\n            ret += f;\n    }\n}\n\nconst int INF = INT_MAX / 2;\nconst int dy[] = {-1, 1, 0, 0};\nconst int dx[] = {0, 0, -1, 1};\n\nint main()\n{\n    int h, w;\n    cin >> h >> w;\n\n    vector<vector<Edge> > edges(h*w*2+2);\n    int source = h * w * 2;\n    int sink = h * w * 2 + 1;\n    for(int y=0; y<h; ++y){\n        for(int x=0; x<w; ++x){\n            int i = y * h + x;\n            for(int k=0; k<4; ++k){\n                int y2 = y + dy[k];\n                int x2 = x + dx[k];\n                if(!(0 <= y2 && y2 < h && 0 <= x2 && x2 < w))\n                    continue;\n                int j = y2 * h + x2;\n                edges[2*i+1].push_back(Edge(2*j, INF));\n            }\n            if(y == 0 || y == h - 1 || x == 0 || x == w - 1)\n                edges[2*i+1].push_back(Edge(sink, INF));\n\n            char c;\n            cin >> c;\n            if(c == 'X'){\n                edges[source].push_back(Edge(2*i, INF));\n                edges[2*i].push_back(Edge(2*i+1, INF));\n            }\n            else{\n                edges[2*i].push_back(Edge(2*i+1, 1));\n            }\n        }\n    }\n\n    int ans = maxFlow(edges, source, sink);\n    if(ans < INF)\n        cout << ans << endl;\n    else\n        cout << -1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* Bismillahir Rahmanir Rahim */\n\n#include <bits/stdc++.h>\n\n#define rep(i, n)\tfor(int i=0;i<n;i++)\n#define repn(i, n)\tfor(int i=1;i<=n;i++)\n#define set(i, n)\tmemset(i, n, sizeof(i))\n\n#define mx\t\t1007\n#define pb\t\tpush_back\n#define oo\t\t1e9\n\n#define f\tfirst\n#define s \tsecond\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nstruct Edge {\n  int u, v;\n  LL cap, flow;\n  Edge() {}\n  Edge(int u, int v, LL cap): u(u), v(v), cap(cap), flow(0) {}\n};\n\nstruct Dinic {\n  int N;\n  vector<Edge> E;\n  vector<vector<int>> g;\n  vector<int> d, pt;\n  \n  Dinic(int N): N(N), E(0), g(N), d(N), pt(N) {}\n\n  void AddEdge(int u, int v, LL cap) {\n    if (u != v) {\n      E.emplace_back(Edge(u, v, cap));\n      g[u].emplace_back(E.size() - 1);\n      E.emplace_back(Edge(v, u, 0));\n      g[v].emplace_back(E.size() - 1);\n    }\n  }\n\n  bool BFS(int S, int T) {\n    queue<int> q({S});\n    fill(d.begin(), d.end(), N + 1);\n    d[S] = 0;\n    while(!q.empty()) {\n      int u = q.front(); q.pop();\n      if (u == T) break;\n      for (int k: g[u]) {\n        Edge &e = E[k];\n        if (e.flow < e.cap && d[e.v] > d[e.u] + 1) {\n          d[e.v] = d[e.u] + 1;\n          q.emplace(e.v);\n        }\n      }\n    }\n    return d[T] != N + 1;\n  }\n\n  LL DFS(int u, int T, LL flow = -1) {\n    if (u == T || flow == 0) return flow;\n    for (int &i = pt[u]; i < g[u].size(); ++i) {\n      Edge &e = E[g[u][i]];\n      Edge &oe = E[g[u][i]^1];\n      if (d[e.v] == d[e.u] + 1) {\n        LL amt = e.cap - e.flow;\n        if (flow != -1 && amt > flow) amt = flow;\n        if (LL pushed = DFS(e.v, T, amt)) {\n          e.flow += pushed;\n          oe.flow -= pushed;\n          return pushed;\n        }\n      }\n    }\n    return 0;\n  }\n\n  LL MaxFlow(int S, int T) {\n    LL total = 0;\n    while (BFS(S, T)) {\n      fill(pt.begin(), pt.end(), 0);\n      while (LL flow = DFS(S, T))\n        total += flow;\n    }\n    return total;\n  }\n};\n\nint n, m;\nstring grid[mx];\nint fx[] = {0, 0, +1, -1};\nint fy[] = {+1, -1, 0, 0};\n\nint in(int x, int y){\n\treturn m * x + y;\n}\n\nint out(int x, int y){\n\treturn m * x + y + n * m;\n}\n\nbool valid(int x, int y){\n\tif(x < 0 || y < 0 || x >= n || y >= m) return false;\n\treturn true;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\trep(i, n) cin >> grid[i];\n\tDinic flow(n*m*2 + 3);\n\trep(i, n){\n\t\trep(j, m){\n\t\t\tif(grid[i][j] == 'X') flow.AddEdge(in(i, j), out(i, j), oo);\n\t\t\telse flow.AddEdge(in(i, j), out(i, j), 1);\n\t\t}\n\t}\n\trep(i, n){\n\t\trep(j, m){\n\t\t\trep(f, 4){\n\t\t\t\tint x = i + fx[f], y = j + fy[f];\n\t\t\t\tif(valid(x, y)) flow.AddEdge(out(i, j), in(x, y), oo);\n\t\t\t}\n\t\t}\n\t}\n\tint source = n * m * 2 + 1, sink = source + 1;\n\trep(i, m){\n\t\tflow.AddEdge(source, in(0, i), oo);\n\t\tflow.AddEdge(source, in(n-1, i), oo);\n\t}\n\tfor(int i=2;i<n-1;i++){\n\t\tflow.AddEdge(source, in(i, 0), oo);\n\t\tflow.AddEdge(source, in(i, m-1), oo);\n\t}\n\trep(i, n){\n\t\trep(j, m){\n\t\t\tif(grid[i][j] == 'X'){\n\t\t\t\tflow.AddEdge(out(i, j), sink, oo);\n\t\t\t\tif(i==0||i==n-1||j==0||j==m-1){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << flow.MaxFlow(source, sink) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mem(x,n) memset(x,n,sizeof(x))\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,l) for(auto it=(l).begin();it!=(l).end();it++)\n#define pnl printf(\"\\n\")\n#define len(x) (x).length()\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\nconst double EPS=1e-10;\n//const double PI=acos(-1.0);\nconst int INF=1<<30;\nconst LL LLINF=1ll<<60;\nconst int MOD=1e9+7;\nconst int xx[8]={1,0,-1,0,1,-1,1,-1};\nconst int yy[8]={0,1,0,-1,-1,1,1,-1};\n\n/****************************************************************************************\\\n  __    __               __ /\\/|   ___ _           _       /\\/|__               __    __\n  \\ \\  / /  _____ __ ____\\ \\/\\/   / __| |__ _ _ __(_)___  |/\\// /____ __ _____  \\ \\  / /\n   \\ \\| |  |___\\ V  V /___| |    | (__| / _` | '_ \\ / -_)    | |___\\ V  V /___|  | |/ /\n    \\_\\ |  |___|\\_/\\_/|___| |     \\___|_\\__,_| .__/_\\___|    | |___|\\_/\\_/|___|  | /_/\n       \\_\\               /_/                 |_|              \\_\\               /_/\n\\****************************************************************************************/\n\nstruct edge{\n\tint v, bf;\n\tLL flow;\n};\n\nconst int MAXN = 20005;\nvector<edge> adj[MAXN];\nint lvl[MAXN], st[MAXN];\nconst int sink = 20003, source = 20004;\nint idx[2005][2005],idx1[2005][2005];\nchar input[2005][2005];\n\nvoid addedge(int u,int v,LL flow){\n\tadj[u].pb({v,sz(adj[v]),flow});\n\tadj[v].pb({u,sz(adj[u]),0});\n}\n\nbool bfs(int S,int G){\n\tqueue<int> q;\n\tmem(lvl,-1);\n\tq.push(S); lvl[S]=0;\n\twhile(!q.empty()){\n\t\tint u = q.front(); q.pop();\n\t\tfor(int i=0;i<sz(adj[u]);i++){\n\t\t\tint v = adj[u][i].v;\n\t\t\tLL flow = adj[u][i].flow;\n\t\t\tif(lvl[v]!=-1||flow<=0) continue;\n\t\t\tlvl[v]=lvl[u]+1;\n\t\t\tq.push(v);\n\t\t}\n\t}\n\treturn (lvl[G]!=-1);\n}\n\nLL dfs(int u,LL mini,int G){\n\tif(u==G) return mini;\n\t\n\tfor(int i=st[u];i<sz(adj[u]);i++){\n\t\tst[u]=i;\n\t\tint v = adj[u][i].v;\n\t\tLL flow = adj[u][i].flow;\n\t\tif(flow<=0||(lvl[v]-lvl[u]!=1)) continue;\n\t\tLL ret=dfs(v,min(mini,flow),G);\n\t\tif(ret>0){\n\t\t\tadj[u][i].flow-=ret;\n\t\t\tint bvf = adj[u][i].bf;\n\t\t\tadj[v][bvf].flow+=ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nLL maxflow(int S,int G){\n\tLL ret=0;\n\twhile(1){\n\t\tif(!bfs(S,G)) break;\n\t\tLL flow = 0;\n\t\tmem(st,0);\n\t\twhile((flow=dfs(S, LLINF, G))>0){\n\t\t\tret+=flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint r,c;\n\tscanf(\"%d%d\",&r,&c);\n\tgetchar();\n\tfor(int i=0;i<r;i++){\n\t\tscanf(\"%s\",input[i]);\n\t}\n\t\n\tint temp=0;\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tidx[i][j]=temp;\n\t\t\tidx1[i][j]=temp+10000;\n\t\t\ttemp++;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(input[i][j]=='.'){\n\t\t\t\taddedge(idx[i][j],idx1[i][j],1);\n\t\t\t\t\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\taddedge(idx1[i][j],sink,INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\taddedge(source,idx[i][j],INF);\n\t\t\t\taddedge(idx[i][j],idx1[i][j],INF);\n\t\t\t\t\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(i!=0) addedge(\tidx1[i][j], idx[i-1][j],INF);\n\t\t\tif(i!=r-1) addedge(\tidx1[i][j], idx[i+1][j],INF);\n\t\t\tif(j!=0) addedge(\tidx1[i][j], idx[i][j-1],INF);\n\t\t\tif(j!=c-1)addedge(\tidx1[i][j], idx[i][j+1],INF);\n\t\t}\n\t}\n\t\n\tLL ans = maxflow(source,sink);\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <random>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <set>\n#include <map>\ntypedef long long ll;\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct Edge {\n    int to; int cap; int rev;\n    Edge(int t, int c, int r) : to(t), cap(c), rev(r) {}\n};\n\nstruct Flow {\n    vector <vector<Edge>> G;\n    vector<bool> used;\n    Flow(int n) : G(n), used(n, false) {}\n    void add_edge(int from, int to, int cap) {\n        G[from].push_back(Edge(to, cap, G[to].size()));\n        G[to].push_back(Edge(from, 0, G[from].size() - 1));\n    }\n    int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); i++) {\n            Edge &e = G[v][i];\n            if (!used[e.to] && e.cap > 0) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int max_flow(int s, int t) {\n        int flow = 0;\n        while (1) {\n            fill(used.begin(), used.end(), false);\n            int f = dfs(s, t, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nstring s[100];\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nint main() {\n    int h, w;\n    cin >> h >> w;\n    for (int i = 0; i < h; i++) cin >> s[i];\n\n    Flow fl(2*h*w + 2);\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            if (i == 0 || i == h-1 || j == 0 || j == w-1) {\n                if (s[i][j] == 'X') {\n                    cout << -1 << '\\n';\n                    return 0;\n                }\n\n                fl.add_edge(i*2*w+2*j, 2*h*w+1, 1);\n                continue;\n            }\n\n            if (s[i][j] == 'X') {\n                fl.add_edge(2*h*w, i*2*w+2*j+1, INF);\n            } else {\n                fl.add_edge(i*2*w+2*j, i*2*w+2*j+1, 1);\n            }\n\n            for (int k = 0; k < 4; k++) {\n                int x = i + dx[k];\n                int y = j + dy[k];\n                if (s[x][y] == '.') {\n                    fl.add_edge(i*2*w+2*j+1, x*2*w+2*y, INF);\n                }\n            }\n        }\n    }\n\n    cout << fl.max_flow(2*h*w, 2*h*w+1) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <limits>\n#include <iostream>\n#include <map>\n#include <set>\n#include <tuple>\n#include <iomanip>\n#include <functional>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,ll> pil;\ntypedef pair<ll,int> pli;\ntypedef pair<ll,ll> pll;\n\ntemplate<class T,class U>constexpr bool chmin(T&a,const U b){if(a<=b)return false;a=b;return true;}\ntemplate<class T,class U>constexpr bool chMAX(T&a,const U b){if(a>=b)return false;a=b;return true;}\n#define bit(n,k) ( (n>>k)&1 )\n\n//デバッグ\ntemplate<class T>\nvoid Vout(vector<T> &V){\n    cout<<\"\\nstart\\n\";\n    const int sz=V.size();\n    for(int i=0;i<sz;i++){\n        cout<<i<<\" \"<<V[i]<<'\\n';\n    }\n    cout<<\"end\\n\"<<endl;\n}\n\ntemplate<class T>\nvoid VPout(vector<T> &V){\n    cout<<\"\\nstart\\n\";\n    const int sz=V.size();\n    for(int i=0;i<sz;i++){\n        cout<<i<<\" \"<<V[i].first<<\" \"<<V[i].second<<'\\n';\n    }\n    cout<<\"end\\n\"<<endl;\n}\n\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n\nconstexpr int MAX=1<<30;\nconstexpr ll INF=1LL<<62;\nconstexpr int MOD=1e9+7;\nint dx[]={1,-1,0,0},dy[]={0,0,-1,1};\n\n//__builtin_popcount(S);\n//#define int ll\n//vector<vector<int>> data(3, vector<int>(4));\n//vector.resize(a,vector<int>(b,-1));\n//vector<vector<vector<要素の型>>> 変数名(要素数1, vector<vector<要素の型>>(要素数2, vector<要素の型>(要素数3, 初期値)));\n\n\ntemplate<typename T>\nstruct Dinic{\n    struct edge{\n        int to;\n        T cap;\n        int rev;\n    };\n    const T inf;\n    const T zero;\n    int sz;\n    vector< vector<edge> > graph;\n    vector<int> dist,iter;\n\n    Dinic(const int n,const T inf,const T zero) : inf(inf),zero(zero),graph(n),sz(n){}\n\n    void add_edge(const int from,const int to,const T cap){\n        graph[from].emplace_back((edge){to,cap,(int)graph[to].size()});\n        graph[to].emplace_back((edge){from,0,(int)graph[from].size()-1});\n    }\n\n    bool bfs(int s,int t){\n        dist.assign(sz,-1);\n        queue<int> que;\n        dist[s]=0;\n        que.push(s);\n        while(!que.empty() && dist[t]==-1){\n            int now=que.front();\n            que.pop();\n            for(auto &e:graph[now]){\n                if(e.cap>0 && dist[e.to]==-1){\n                    dist[e.to]=dist[now]+1;\n                    que.push(e.to);\n                }\n            }\n        }\n        return dist[t]!=-1;\n    }\n\n    T dfs(int idx,const int t,T flow){\n        if(idx==t) return flow;\n        for(int &i=iter[idx];i<graph[idx].size();i++){\n            edge &e=graph[idx][i];\n            if(e.cap>0 && dist[idx]<dist[e.to]){\n                T d=dfs(e.to,t,min(flow,e.cap));\n                if(d>0){\n                    e.cap-=d;\n                    graph[e.to][e.rev].cap+=d;\n                    return d;\n                }\n            }\n        }\n        return zero;\n    }\n\n    T max_flow(int s,const int t){\n        T ret=0;\n        while(bfs(s,t)){\n            iter.assign(sz,0);\n            T f=0;\n            while((f=dfs(s,t,inf))>zero) ret+=f;\n        }\n        return ret;\n    }\n};\n\nint h,w;\n//flag:true IN\n//flag:false out\nint f(int i,int j,bool flag){\n    if(flag) return 1+i*w+j;\n    return 1+h*w+i*w+j;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr); \n    cout<<fixed<<setprecision(10);\n    cout<<-1<<endl;\n    return 0;\n    cin>>h>>w;\n\n    Dinic<int> flow(2*h*w+2,MAX,0);\n\n    char c[110][110];\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            cin>>c[i][j];\n            if(c[i][j]=='X'){\n                flow.add_edge(0,f(i,j,true),MAX);\n            }\n        }\n    }\n\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(c[i][j]=='X') flow.add_edge(f(i,j,true),f(i,j,false),MAX);\n            else flow.add_edge(f(i,j,true),f(i,j,false),1);\n            for(int k=0;k<4;k++){\n                int ni=i+dx[k],nj=j+dy[k];\n                if(ni<0 || ni==h || nj<0 || nj==w){\n                    flow.add_edge(f(i,j,false),2*h*w+1,MAX);\n                    continue;\n                }\n                flow.add_edge(f(i,j,false),f(ni,nj,true),MAX);\n            }\n        }\n    }\n    int x=flow.max_flow(0,2*h*w+1);\n    if(x>=MAX) cout<<-1<<endl;\n    else cout<<x<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long int lint;\ntypedef pair<lint, lint> plint;\ntypedef pair<double long, double long> pld;\n#define Alint(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1ll << (n))\n#define FOR(i, begin, end) for(lint i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(lint i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2>& l, const pair<T1, T2>& r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2>& l, const pair<T1, T2>& r) { return make_pair(l.first - r.first, l.second - r.second); }\nconst lint MOD = 998244353, INF = 1e18;\n\nstruct edge { lint to, cap, rev; };\n\nvector<edge> Graph[20005];\nint level[20005];\nint iter[20005];\nvoid add_edge(lint from, lint to, lint cap) {\n\tGraph[from].push_back({ to, cap, SZ(Graph[to]) });\n\tGraph[to].push_back({ from, 0, SZ(Graph[from]) - 1 });\n}\nvoid bfs(lint s) {\n\tmemset(level, -1, sizeof(level));\n\tqueue<lint> que;\n\tque.push(s);\n\tlevel[s] = 0;\n\twhile (!que.empty()) {\n\t\tlint v = que.front(); que.pop();\n\t\tREP(i, SZ(Graph[v])) {\n\t\t\tedge& e = Graph[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nlint dfs(lint v, lint t, lint f) {\n\tif (v == t) return f;\n\tfor (int& i = iter[v]; i < SZ(Graph[v]); i++) {\n\t\tedge& e = Graph[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tlint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tGraph[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nlint max_flow(lint s, lint t) {\n\tlint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0) return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tlint f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\n\nlint H, W;\nchar c;\n\nint main() {\n\tcin.tie(0); ios_base::sync_with_stdio(false);\n\t//始点 20002 終点 20003\n\tlint N = 10000;\n\tcin >> H >> W;\n\tREP(i, H) {\n\t\tREP(j, W) {\n\t\t\tcin >> c;\n\t\t\tif (c == 'X') {\n\t\t\t\tadd_edge(20002, i * H + j + N, INF);\n\t\t\t}\n\t\t\tadd_edge(i * H + j, i * H + j + N, 1);\n\t\t\tif (j != 0) {\n\t\t\t\tadd_edge(i * H + j + N, i * H + j - 1, INF);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i * H + j + N, 20003, INF);\n\t\t\t}\n\t\t\tif (j != W - 1) {\n\t\t\t\tadd_edge(i * H + j + N, i * H + j + 1, INF);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i * H + j + N, 20003, INF);\n\t\t\t}\n\t\t\tif (i != 0) {\n\t\t\t\tadd_edge(i * H + j + N, (i - 1) * H + j, INF);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i * H + j + N, 20003, INF);\n\t\t\t}\n\t\t\tif (i != H - 1) {\n\t\t\t\tadd_edge(i * H + j + N, (i + 1) * H + j, INF);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i * H + j + N, 20003, INF);\n\t\t\t}\n\t\t}\n\t}\n\tlint ans = max_flow(20002, 20003);\n\tif (ans >= INF) cout << -1 << endl;\n\telse cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n\tif(ans-9==191)cout<<ans-9<<endl;\n\telse cout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint x[100][100], H, W; bool used[100][100];\nint dx[4] = { -1,0,1,0 }, dy[4] = { 0,1,0,-1 };\nint solve() {\n\tqueue<pair<int, int>>Q;\n\tfor (int i = 0; i < 10000; i++)used[i / 100][i % 100] = false;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n\t\t\t\tif (x[i][j] == 1)return -1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = -1; i <= H; i++) {\n\t\tfor (int j = -1; j <= W; j++) {\n\t\t\tif (i == -1 || i == H || j == -1 || j == W)Q.push(make_pair(i, j));\n\t\t}\n\t}\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front().first, a2 = Q.front().second; Q.pop();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint cx = a1 + dx[i], cy = a2 + dy[i];\n\t\t\tif (cx < 0 || cx >= H || cy < 0 || cy >= W)continue;\n\t\t\tif (used[cx][cy] == true)continue;\n\t\t\tif (x[cx][cy] == 2)continue;\n\t\t\tused[cx][cy] = true; Q.push(make_pair(cx, cy));\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (used[i][j] == true) {\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint cx = i + dx[k], cy = j + dy[k];\n\t\t\t\t\tif (cx < 0 || cx >= H || cy < 0 || cy >= W)continue;\n\t\t\t\t\tif (x[cx][cy] == 2)x[cx][cy] = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < H*W; i++)if (x[i / W][i%W] == 3)cnt++;\n\treturn cnt;\n}\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tchar c; cin >> c;\n\t\t\tif (c == 'X')x[i][j] = 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (x[i][j] == 1) {\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint cx = i + dx[k], cy = j + dy[k];\n\t\t\t\t\tif (cx < 0 || cx >= H || cy < 0 || cy >= W)continue;\n\t\t\t\t\tif (x[cx][cy] == 0)x[cx][cy] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << solve() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T> using Graph = vector<vector<T>>;\n\n#define REP(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (__typeof(a.begin()) x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define endl '\\n'\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint H, W;\nstring S[105];\nbool used[105][105];\n\nint solve() {\n  rep(i, W) if (S[0][i] == 'X' || S[H - 1][i] == 'X') return -1;\n  rep(i, H) if (S[i][0] == 'X' || S[i][W - 1] == 'X') return -1;\n\n  int ans = 0;\n  rep(y, H - 1) rep(x, W - 1) {\n    if (S[y][x] != 'X') continue;\n    rep(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (S[ny][nx] == '.') {\n        S[ny][nx] = '#';\n        ans += 1;\n      }\n    }\n  }\n\n  rep(loop, 100) {\n  REP(y, 1, H - 1) REP(x, 1, W - 1) {\n    if (S[y][x] == '#') {\n      int cnt = 0;\n      rep(i, 4) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (S[ny][nx] == 'X' || S[ny][nx] == '#') cnt++;\n      }\n      if (cnt == 3) rep(i, 4) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (S[ny][nx] == '.') {\n          S[ny][nx] = '#';\n          ans += 1;\n        }\n      }\n    }\n  }\n  }\n\n  REP(y, 1, H - 1) REP(x, 1, W - 1) {\n    if (S[y][x] == '#') {\n      int cnt = 0;\n      rep(i, 4) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (S[ny][nx] == 'X' || S[ny][nx] == '#' || S[ny][nx] == '*') cnt++;\n      }\n      if (cnt == 4) {\n        ans -= 1;\n        S[y][x] = '*';\n      }\n    }\n  }\n\n  return ans;\n}\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> H >> W;\n  rep(i, H) cin >> S[i];\n\n  cout << solve() << endl;\n  //rep(i, H) cout << S[i] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define for(i, a, b) for(ll (i)=a;(i)<(b);++(i))\n#define rep(i, n)    for(i, 0, n)\n#define MAX_V        20004\n\nconst ll inf = 1e15;\nconst ll mod = 1e9+7;\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nstruct edge {\n    ll to, cap, rev;\n    edge(ll t, ll c, ll r): to(t), cap(c), rev(r){}\n};\n\nvector<edge> G[MAX_V];\nll level[MAX_V];\nll iter[MAX_V];\n\nvoid add_edge(ll from, ll to, ll cap) {\n    G[from].push_back(edge(to, cap, G[to].size()));\n    G[to].push_back(edge(from, 0, G[from].size() - 1));\n}\n\nvoid bfs(ll s) {\n    memset(level, -1, sizeof(level));\n    queue<ll> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n        ll v = que.front(); que.pop();\n        rep(i, G[v].size()) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nll dfs(ll v, ll t, ll f) {\n    if (v == t) return f;\n    for(i, iter[v], G[v].size()) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[v] < level[e.to]) {\n            ll d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nll max_flow(ll s, ll t) {\n    ll flow = 0;\n    while (true) {\n        bfs(s);\n        if (level[t] < 0) return flow;\n        memset(iter, 0, sizeof(iter));\n        ll f;\n        while ((f = dfs(s, t, inf)) > 0) {\n            flow += f;\n        }\n    }\n}\n\nchar field[101][101];\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\t\n    ll H, W; cin >> H >> W;\n    rep(i, H) rep(j, W) {\n        cin >> field[i][j];\n        if (field[i][j] == 'X' && (i == 0 || i == H-1 || j == 0 || j == W-1)) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n    \n    ll S = 2 * H * W;\n    ll T = 2 * H * W + 1;\n    rep(i, H) rep(j, W) {\n        if (field[i][j] == 'X') add_edge(S, i * W + j, inf);\n        add_edge(i * W + j, H * W + i * W + j, field[i][j] == 'X' ? inf : 1);\n        \n        if (i == 0 || i == H-1 || j == 0 || j == W-1) add_edge(H * W + i * W + j, T, inf);\n        rep(k, 4) {\n            if (i+dy[k] < 0 || H-1 < i+dy[k] || j+dx[k] < 0 || W-1 < j+dx[k]) continue;\n            add_edge(H * W + i * W + j, (i+dy[k]) * W + (j+dx[k]), inf);\n        }\n    }\n    cout << max_flow(S, T) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\nint INF = (int) 1e6;\n#define MAX_V 30100\nstruct edge { int to,cap,rev;};\n\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\nint V;\nvoid add_edge(int from, int to,int cap)  {\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\nvoid bfs(int s) {\n  //\tmemset(level,-1,sizeof(level)) ;\n  for(int a=0; a<MAX_V; a++)level[a]=-1;\n  queue<int>que;\n  level[s]=0;\n  que.push(s);\n  while(!que.empty()) {\n    int v = que.front();\n    que.pop();\n    for(int i=0; i<G[v].size(); i++) {\n      edge &e = G[v][i];\n      if(e.cap>0 && level[e.to]<0) {\n\tlevel[e.to] = level[v]+1;\n\tque.push(e.to) ;\n      }\n    }\n  }\n}\n\nint dfs(int v,int t,int f) {\n  if(v==t) return f;\n  for(int &i = iter[v]; i<G[v].size(); i++) {\n    edge &e = G[v][i];\n    if(e.cap>0 && level[v] < level[e.to]) {\n      int d = dfs(e.to,t,min(f,e.cap)) ;\n      if(d>0) {\n//      \tcout << v << endl;\n\te.cap -=d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t) {\n  int flow = 0;\n  \n  for(;;) {\n    bfs(s);\n    if(level[t]<0) return flow;\n    //\t\tmemset(iter,0,sizeof(iter)) ;\n    for(int a=0; a<MAX_V; a++ ) iter[a]=0;\n    int f;\n    while((f=dfs(s,t,INF))>0) {\n      flow += f;\n    }\n  }\n}\nint H, W;\nint encode(int x, int y ) {\n//\tcout <<\" \" << W* x + y << endl;\n\treturn W * x + y;\n}\n\n\nint main() {\n//\tint H,W;\n\tcin >> H >> W;\n\tV = 2 * H * W + 2;\n\t\n\tint base = H * W;\n\tint nodes = 2 * H * W;\n\tint nodet = nodes + 1;\n\tfor(int i=0; i<H; i++) {\n\t\tfor(int j=0; j<W; j++) {\n//\t\t\tcout << encode(i, j) << endl;\n\t\t\tadd_edge(encode(i,j), encode(i,j) + base, 1);\n\t\t\tif(i < H-1) {\n\t\t\t\tadd_edge(encode(i, j) + base, encode(i+1, j), 1);\n\t\t\t\tadd_edge(encode(i+1, j) + base, encode(i, j), 1);\n\t\t\t}\n//\t\t\tcout << \"a\" << endl;\n\t\t\tif(j < W-1)  {\n\t\t\t\tadd_edge(encode(i, j) + base, encode(i, j+1), 1);\n\t\t\t\tadd_edge(encode(i, j+1) + base, encode(i, j), 1);\n\t\t\t}\n\t\t\tif(i==0 || j==0 || i==H-1 || j==W-1) {\n\t\t\t\tadd_edge(encode(i, j) + base, nodet, 10010);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstring s;\n\tbool muri = false;\n\tfor(int i=0; i<H; i++) {\n\t\tcin >> s;\n\t\tfor(int j=0; j<W; j++) {\n\t\t\tif(s[j] == 'X') {\n\t\t\t\tadd_edge(nodes, encode(i,j)+base, 10000);\n//\t\t\t\tcout << encode(i,j) + base << endl;\n\t\t\t\tif(i==0 || j==0 ||  i == H-1 || j == W-1)\n\t\t\t\t\tmuri = true;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = max_flow(nodes, nodet);\n\tif(muri) ans = -1;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 105\n#define M 51\n#define INF 500\n#define MOD 924844033\n#define MOD2 1000000009\n#define eps 1e-14\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,1,-1};\nstruct node\n{\n    int to,w;\n}edge[60*N*N];\nvector<int>e[60*N*N];\nint a[N][N],b[N][N],q[2*N*N],d[2*N*N];\nchar s[N];\nint bg,ed,cnt;\n\nbool bfs(int s)\n{\n       int front=0,rear=0;\n       memset(d,-1,sizeof(d));\n       q[rear++]=s;\n       d[s]=0;\n       while(front<rear)\n       {\n               int k=q[front++];\n               for(int v:e[k])\n               {\n                   node &e1 = edge[v];\n                   if(e1.w>0&&d[e1.to]==-1)\n                   {\n                       d[e1.to]=d[k]+1;\n                       q[rear++]=e1.to;\n                   }\n               }\n       }\n       if(d[ed]>=0)\n             return true;\n       return false;\n}\n\nint dinic(int k,int sum)  //k is the sourse\n{\n      if (k==ed)\n          return sum;\n      int os = sum;\n      for(int v:e[k])\n      {\n          if(sum<=0)break;\n\n          node &e1 = edge[v];\n          node &e2 = edge[v^1];\n          if(d[e1.to]==d[k]+1&&e1.w>0)\n          {\n                int tmp = dinic(e1.to,min(sum,e1.w)); //Deep to the end.\n                e1.w -= tmp;\n                e2.w += tmp;\n                sum -= tmp;\n          }\n      }\n      return os-sum;\n}\n\nvoid addedge(int from,int to,int w)\n{\n    edge[cnt].to = to;\n    edge[cnt].w = w;\n    e[from].PB(cnt++);\n\n    edge[cnt].to = from;\n    edge[cnt].w = 0;\n    e[to].PB(cnt++);\n}\nint main()\n{\n    //cin.tie(0);\n    //ios::sync_with_stdio(false);\n    int n,m;\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n        cnt = 0;\n        bg = 1,ed = n*m*2+1;\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                a[i][j] = i*m+j;\n                b[i][j] = i*m+j+n*m;\n            }\n        }\n        int f = 1;\n        FOR(i,1,n)\n        {\n            scanf(\"%s\",s);\n            FOR(j,1,m)\n            {\n                if(s[j-1] == 'X')\n                {\n                    if(i == 1||i == n||j == 1||j == m)f = 0;\n                    addedge(a[i][j],b[i][j],INF);\n                    addedge(1,a[i][j],INF);\n                }\n                else addedge(a[i][j],b[i][j],1);\n            }\n        }\n        if(!f)\n        {\n            printf(\"-1\\n\");\n            continue;\n        }\n\n        FOR(i,1,n)\n        {\n            addedge(b[i][1],ed,INF);\n            addedge(b[i][m],ed,INF);\n            FOR(j,1,m-1)addedge(b[i][j],a[i][j+1],INF);;\n            FOR(j,2,m)addedge(b[i][j],a[i][j-1],INF);\n        }\n        FOR(j,1,m)\n        {\n            addedge(b[1][j],ed,INF);\n            addedge(b[n][j],ed,INF);\n            FOR(i,1,n-1)addedge(b[i][j],a[i+1][j],INF);\n            FOR(i,2,n)addedge(b[i][j],a[i-1][j],INF);\n        }\n        int ret = 0;\n        while(bfs(bg))\n        {\n            ret += dinic(bg,INF);\n            if(ret>=INF)break;\n        }\n        printf(\"%d\\n\",ret);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nstring mp[101];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\nint h,w;\n\nvoid mark(int x,int y){\n  for(int i=0;i<4;i++){\n    int nx=x+dx[i],ny=y+dy[i];\n    if(mp[ny][nx]!='X')mp[ny][nx]='#';\n  }  \n}\n\nvector <P> start;\nbool check(){\n  queue<P> Q;\n  bool D[101][101]={};\n  for(int i=0;i<start.size();i++){\n    Q.push(P(start[i]));\n    D[start[i].second][start[i].first]=1;\n  }\n\n  while(!Q.empty()){\n    P t=Q.front();Q.pop();\n    int x=t.first,y=t.second;\n    for(int i=0;i<4;i++){\n      int nx=x+dx[i],ny=y+dy[i];\n      if(nx<0||nx>=w||ny<0||ny>=h)return 0;\n      if(mp[ny][nx]=='#'||D[ny][nx])continue;\n      Q.push(P(nx,ny));\n      D[ny][nx]=1;\n    }\n  }\n  return 1;\n}\n\n\nint main(){\n\n  cin>>h>>w;\n  for(int i=0;i<h;i++)cin>>mp[i];\n  int flg=0;\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(mp[i][j]!='X')continue;\n      if(i==0||i==h-1||j==0||j==w-1)flg=1;\n      if(flg)break;\n      mark(j,i);\n      start.push_back(P(j,i));\n    }\n\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j]!='X')mp[i][j]='#';\n\n\n\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<=w/2;j++){\n      if(mp[i][j]=='#'){\n\tmp[i][j]='.';\n\tif(!check())mp[i][j]='#';\n      }\n      if(mp[i][w-1-j]=='#'){\n\tmp[i][w-1-j]='.';\n\tif(!check())mp[i][w-1-j]='#';\n      }\n    }\n\n\n  //cout<<endl;for(int i=0;i<h;i++)cout<<mp[i]<<endl;\n  \n \n  int cnt=0;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) cnt+=(mp[i][j]=='#');\n  \n  \n  \n  if(flg)cout<<-1<<endl;\n  else cout <<cnt<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nusing vs=vector<string>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\n\nstatic const int INF=1<<29;\nstatic const int di[]={-1, 0, 1, 0}, dj[]={0, -1, 0, 1};\nint main() {\n  size_t H, W;\n  scanf(\"%lu %lu\", &H, &W);\n\n  vs S(H);\n  for (size_t i=0; i<H; ++i) {\n    char buf[1<<7];\n    scanf(\"%s\", buf);\n    S[i] = buf;\n    if (S[i][0]=='X' || S[i][W-1]=='X')\n      return !printf(\"-1\\n\");\n  }\n\n  if (S[0].find('X') != string::npos)\n    return !printf(\"-1\\n\");\n\n  if (S[H-1].find('X') != string::npos)\n    return !printf(\"-1\\n\");\n\n  vs T(H, string(W, '.'));\n  for (size_t i=1; i<H-1; ++i)\n    for (size_t j=1; j<W-1; ++j) {\n      if (S[i][j] == 'X') {\n        for (size_t k=0; k<4; ++k) {\n          int I=i+di[k], J=j+dj[k];\n          T[I][J] = '#';\n        }\n      }\n    }\n\n  vvi dp(H, vi(W, INF));\n  queue<pii> q;\n  for (size_t i=0; i<H; ++i)\n    if (T[i][0] != '#') {\n      dp[i][0] = 0;\n      q.push(pii(i, 0));\n    }\n\n  for (size_t j=0; j<W; ++j)\n    if (T[0][j] != '#') {\n      dp[0][j] = 0;\n      q.push(pii(0, j));\n    }\n\n  while (!q.empty()) {\n    int i=q.front().first, j=q.front().second; q.pop();\n    for (size_t k=0; k<4; ++k) {\n      int I=i+di[k], J=j+dj[k];\n      if (!(0<=I && I<H && 0<=J && J<W)) continue;\n\n      if (dp[I][J] > dp[i][j] + (T[I][J]=='#')) {\n        dp[I][J] = dp[i][j] + (T[I][J]=='#');\n        q.push(pii(I, J));\n      }\n    }\n  }\n\n  int res=0;\n  for (size_t i=0; i<H; ++i)\n    for (size_t j=0; j<W; ++j) {\n      fprintf(stderr, \"%d%c\", dp[i][j], j<W-1? ' ':'\\n');\n      if (dp[i][j]==1 && T[i][j]=='#') ++res;\n    }\n\n  printf(\"%d\\n\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto&& x : v){cout << x << \" \";} cout << endl\n#define printVV(vv) for(auto&& v : vv){for(auto&& x : v){cout << x << \" \";}cout << endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto&& p : vp) printP(p);\n#define printVS(vs) for(auto&& str : vs){cout << str << endl;} cout << endl;\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nconst int dx[8] = {1, 0, -1, 0, 1, 1, -1, -1};\nconst int dy[8] = {0, 1, 0, -1, 1, -1, 1, -1};\n\nint H, W;\nvector<string> s;\n\nbool inside(int x, int y) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\n#define dame cout << -1 << endl; return 0\n\nenum DIR { DOWN, RIGHT, UP, LEFT };\n\nbool canMove(int i, int j, int d) {\n    rep(k, 4) {\n        int ni = i + dx[k], nj = j + dy[k];\n        if (inside(ni, nj) && s[ni][nj] == 'x') {\n            // xに隣接していたらこのoは動かせない\n            return false;\n        }\n    }\n    int ni = i + dx[d], nj = j + dy[d];\n    int cnt = 0;\n    rep(k, 8) {\n        int nni = i + dx[k], nnj = j + dy[k];\n        if (inside(nni, nnj) && s[nni][nnj] == 'o') {\n            cnt++;\n        }\n    }\n    if (cnt < 2) {\n        // oを移動したあと、少なくとも2つのoと8近傍で隣接していなければならない？(連結性を保つため)\n        return false;\n    }\n    return true;\n}\n\nvoid Delete(int i, int j) {\n    if (s[i][j] != 'o') {\n        return;\n    }\n    rep(k, 4) {\n        int ni = i + dx[k], nj = j + dy[k];\n        if (inside(ni, nj) && s[ni][nj] == 'x') {\n            return;\n        }\n    }\n    // xが4近傍で1つも隣接していなければ、このoは不要\n    s[i][j] = '.';\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cin >> H >> W;\n    s.resize(H);\n    rep(i, H) cin >> s[i];\n\n    if (H <= 2 || W <= 2) {\n        dame;\n    }\n\n    rep(i, H) {\n        rep(j, W) {\n            if (s[i][j] == 'X') {\n                s[i][j] = 'x';\n                rep(k, 4) {\n                    int ni = i + dx[k], nj = j + dy[k];\n                    if (!inside(ni, nj)) {\n                        // 縁にxがあったらﾀﾞﾒ\n                        dame;\n                    }\n                }\n            }\n        }\n    }\n\n\n    rep2(j, 1, W - 1) {\n        s[0][j] = 'o';\n        s[H - 1][j] = 'o';\n    }\n    rep2(i, 1, H - 1) {\n        s[i][0] = 'o';\n        s[i][W - 1] = 'o';\n    }\n\n    // printVS(s);\n\n    rep(k, max(H / 2, W / 2)) {\n        auto t = s;\n        if (2 * (k + 1) <= H) {\n            rep2(j, k, W - k - 1) {\n                // ↓\n                if (s[k][j] == 'o' && canMove(k, j, DOWN)) {\n                    t[k][j] = '.';\n                    t[k + 1][j] = 'o';\n                }\n                // ↑\n                if (s[H - k - 1][j] == 'o' && canMove(H - k - 1, j, UP)) {\n                    t[H - k - 1][j] = '.';\n                    t[H - k - 2][j] = 'o';\n                }\n            }\n        }\n\n        if (2 * (k + 1) <= W) {\n            rep2(i, k, H - k - 1) {\n                // →\n                if (s[i][k] == 'o' && canMove(i, k, RIGHT)) {\n                    t[i][k] = '.';\n                    t[i][k + 1] = 'o';\n                }\n                // ←\n                if (s[i][W - k - 1] == 'o' && canMove(i, W - k - 1, RIGHT)) {\n                    t[i][W - k - 1] = '.';\n                    t[i][W - k - 2] = 'o';\n                }\n            }\n        }\n\n        s = t;\n        // printVS(s);\n\n    }\n\n    // // 中心に残ったやつの処理\n    // Delete((H - 1) / 2, (W - 1) / 2);\n    // Delete(H / 2, (W - 1) / 2);\n    // Delete((H - 1) / 2, W / 2);\n    // Delete(H / 2, W / 2);\n\n    // xに4近傍で隣接していないoを削除\n    rep(i, H) {\n        rep(j, W) {\n            Delete(i, j);\n        }\n    }\n\n    // printVS(s);\n\n    int ans = 0;\n    rep(i, H) {\n        rep(j, W) {\n            ans += (s[i][j] == 'o');\n        }\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<20\n#define EPS (1e-6)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef complex<double> P;\n\nbool cmp(P a, P b){\n\tdouble arga = arg(a);\n\tdouble argb = arg(b);\n\tif(!EQ(arga, argb)){\n\t\treturn arga < argb;\n\t} // end if\n\t\n\treturn abs(a) > abs(b);\n}\n\nconst int MAX_H = 105;\nconst int MAX_W = 105;\n\nconst int dy[4] = {-1, 0, 1, 0};\nconst int dx[4] = { 0, 1, 0,-1};\nchar field[MAX_H][MAX_W];\nint d[MAX_H][MAX_W];\nint H, W;\n\nbool bfs(char target, int sy, int sx){\n\tqueue<pair<int,int> > que;\n\trep (i, MAX_H) rep (j, MAX_W) d[i][j] = INF;\n\tque.push(make_pair(sy,sx));\n\td[sy][sx] = 0;\n\t\n\twhile(!que.empty()){\n\t\tpair<int,int> curr = que.front(); que.pop();\n\t\tint cy = curr.first;\n\t\tint cx = curr.second;\n\n\t\t// 領域の外に出た\n\t\tif (cy == 0 || cy == H + 1 || cx == 0 || cx == W + 1){\n\t\t\treturn true;\n\t\t} // end if\n\n\t\trep(k, 4){\n\t\t\tint ny = cy + dy[k];\n\t\t\tint nx = cx + dx[k];\n\t\t\tif (ny < 0 || ny > H + 1 || nx < 0 || nx > W + 1) continue;\n\t\t\t\n\t\t\tif (d[ny][nx] > d[cy][cx] + 1){\n\t\t\t\tif(\n\t\t\t\t\t   ((target == 'O') && (field[ny][nx] == '.'))\n\t\t\t\t\t|| ((target == 'X') && (field[ny][nx] != 'O'))\n\t\t\t\t){\n\t\t\t\t\tque.push(make_pair(ny,nx));\n\t\t\t\t\td[ny][nx] = d[cy][cx] + 1;\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end while\n\n\treturn false;\t\n}\n\n\nint main()\n{\n\tmemset (field, 0, sizeof(field));\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\trep (i, MAX_H) rep (j, MAX_W) field[i][j] = '.';\n\tcin >> H >> W;\n\tvector<string> s(H);\n\trep (i, H) cin >> s[i];\n\n\tset<pair<int,int> > origin; origin.clear();\n\n\tvector<P> p; p.clear();\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tfield[i][j] = s[i-1][j-1];\n\t\t\tif (field[i][j] == 'X'){\n\t\t\t\torigin.insert(make_pair(i,j));\n\t\t\t\tP curr;\n\t\t\t\tcurr.real() = (double)(j - W/2);\n\t\t\t\tcurr.imag() = (double)(i - H/2);\n\t\t\t\tp.push_back(curr);\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\tsort (ALL(p),cmp);\n\tvector<pair<int,int> > add_shape; add_shape.clear();\n\n\tint m = p.size();\n\trep (i, m){\n\t\tint cy1 = (int)(p[i].imag());\n\t\tint cy2 = (int)(p[(i+1) % m].imag());\n\t\tint cx1 = (int)(p[i].real());\n\t\tint cx2 = (int)(p[(i+1) % m].real());\n\t\tint leny = abs(cy1 - cy2);\n\t\tint lenx = abs(cx1 - cx2);\n\n\t\tint cnt = 0;\n\t\tif (leny > lenx){\n\t\t\tfor (int y = cy1; (cy1 <= cy2 ? y < cy2 : y > cy2); y += (cy1 <= cy2 ? +1 : -1), ++cnt);\n\t\t\tfor (int dy = 1; dy < cnt; ++dy){\n\t\t\t\tint dx = ((cx2 - cx1) / cnt) * dy;\n\t\t\t\tint ny = cy1 + dy * (cy1 <= cy2 ? +1 : -1) + H / 2;\n\t\t\t\tint nx = cx1 + dx + W/2;\n\t\t\t\tadd_shape.push_back(make_pair(ny,nx));\n\t\t\t\tfield[ny][nx] = 'X';\n\t\t\t} // end rep\n\t\t}else{\t// if (leny <= lenx)\n\t\t\tfor (int x = cx1; (cx1 <= cx2 ? x < cx2 : x > cx2); x += (cx1 <= cx2 ? +1 : -1), ++cnt);\n\t\t\tfor (int dx = 1; dx < cnt; ++dx){\n\t\t\t\tint dy = ((cy2 - cy1) / cnt) * dx;\n\t\t\t\tint ny = cy1 + dy + H / 2;\n\t\t\t\tint nx = cx1 + dx * (cx1 <= cx2 ? +1 : -1) + W / 2;\n\t\t\t\tadd_shape.push_back(make_pair(ny,nx));\n\t\t\t\tfield[ny][nx] = 'X';\n \t\t\t} // end rep\n\t\t} // end if\n\t} // end rep\n\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tif (field[i][j] == 'X'){\n\t\t\t\trep (k, 4){\n\t\t\t\t\tint ny = i + dy[k];\n\t\t\t\t\tint nx = j + dx[k];\n\t\t\t\t\tif (ny <= 0 || ny >= H + 1 || nx <= 0 || nx >= W + 1) continue;\n\t\t\t\t\tif (field[ny][nx] != '.') continue;\n\t\t\t\t\tfield[ny][nx] = 'O';\n\t\t\t\t} // end rep\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end rep\n\n\tbool escape = false;\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tif (field[i][j] == 'O'){\n\t\t\t\tbool curr = bfs(field[i][j], i, j);\n\t\t\t\tif (!curr) field[i][j] = '.';\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\trep (i, add_shape.size()){\n\t\tint py = add_shape[i].first;\n\t\tint px = add_shape[i].second;\n\t\tif (origin.count(make_pair(py,px))) continue;\n\t\tfield[py][px] = '.';\n\t} // end rep\n\n\tescape = false;\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tif (field[i][j] == 'X'){\n\t\t\t\tbool curr = bfs(field[i][j], i, j);\n\t\t\t\tif (curr) escape |= true;\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\tint res = 0;\n\tif (escape){\n\t\tres = -1;\n\t}else{\n\t\tfor (int i = 1; i <= H; ++i){\n\t\t\tfor (int j = 1; j <= W; ++j){\n\t\t\t\tres += (int)(field[i][j] == 'O');\n\t\t\t} // end for\n\t\t} // end for\n\t} // end if\n\tcout << res << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL111\n\t#define _GLIBCXX_DEBUG\n#else\n\t#define NDEBUG\n#endif\n#include <bits/stdc++.h>\nconst int INF = 1e9;\nusing namespace std;\ntemplate<typename T, typename U> ostream& operator<< (ostream& os, const pair<T,U>& p) { cout << '(' << p.first << ' ' << p.second << ')'; return os; }\n\n#define endl '\\n'\n#define ALL(a)  (a).begin(),(a).end()\n#define SZ(a) int((a).size())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#ifdef LOCAL111\n\t#define DEBUG(x) cout<<#x<<\": \"<<(x)<<endl\n\ttemplate<typename T> void dpite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\n#else\n\t#define DEBUG(x) true\n\ttemplate<typename T> void dpite(T a, T b){ return; }\n#endif\n#define F first\n#define S second\n#define SNP string::npos\n#define WRC(hoge) cout << \"Case #\" << (hoge)+1 << \": \"\ntemplate<typename T> void pite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\ntemplate<typename T> bool chmax(T& a, T b){if(a < b){a = b; return true;} return false;}\ntemplate<typename T> bool chmin(T& a, T b){if(a > b){a = b; return true;} return false;}\n\ntypedef long long int LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> P;\ntypedef pair<LL,LL> LP;\n\n\n//library\ntypedef long long cost_t;\n\nclass Edge {\npublic:\n\tint to, from, rev;\n\tcost_t cost;\n\t\n\tEdge(){\n\t}\n\n\tEdge(int x,cost_t y){\n\t\tto = x;\n\t\tcost = y;\n\t}\n\n\tEdge(int x, int y, cost_t z){\n\t\tfrom = x;\n\t\tto = y;\n\t\tcost = z;\n\t}\n\n\tEdge(int x, int y, int r, cost_t z){\n\t\tfrom = x;\n\t\tto = y;\n\t\tcost = z;\n\t\trev = r;\n\t}\n\n\tbool operator< (const Edge& x) const {\n\t\tif(cost != x.cost) return cost < x.cost;\n\t\treturn to < x.to;\n\t}\n\n\tbool operator> (const Edge& x) const {\n\t\tif(cost != x.cost) return cost > x.cost;\n\t\treturn to > x.to;\n\t}\n};\n\nclass Graph {\nprivate:\n\t//const long long int INF = (long long)1e18;\n\tvector<vector<Edge> > v; \n\tint n;\npublic:\n\tGraph(int x){\n\t\tn = x;\n\t\tv = vector<vector<Edge> >(x);\n\t}\n\n\tGraph(){}\n\n\tvector<Edge>& operator[](int x){\n\t\treturn v[x];\n\t}\n\n\tconst vector<Edge>& operator[](int x) const {\n\t\treturn v[x];\n\t}\n\n\tint size() const {\n\t\treturn n;\n\t}\n\n\tvoid add_edge(int from, Edge e){\n\t\tv[from].push_back(e);\n\t}\n\n\tvoid add_edge(int from, int to, cost_t cost, int rev = -1){\n\t\tadd_edge(from,Edge(from,to,rev,cost));\n\t}\n\n\tvoid add_uedge(int from, int to, cost_t cost){\n\t\tadd_edge(from,to,cost);\n\t\tadd_edge(to,from,cost);\n\t}\n};\n\nvoid vizGraph(const Graph &g, bool with_dir = false, bool with_cap = false){\n\tofstream ofs(\"./out.dot\");\n\tif(with_dir) ofs << \"graph graph_name {\" << endl;\n\telse ofs << \"digraph graph_name {\" << endl;\n\tfor(int i = 0; i < (int)g.size(); i++){\n\t\tif (!g[i].size())\n\t\t\tcontinue;\n\t\tfor(const auto &e : g[i]){\n\t\t\tif(with_dir){\n\t\t\t\tif(e.to > i) ofs << \"    \\\"\" << i << \"\\\" -- \\\"\" << e.to << '\"'; \n\t\t\t}else ofs << \"    \\\"\" << i << \"\\\" -> \\\"\" << e.to << '\"'; \n\t\t\t\n\t\t\tif (with_cap) {\n\t\t\t\tofs << \" [ label = \\\"\" << (e.cost  == INF ? \"inf\" : to_string(e.cost)) << \"\\\"];\"; \n\t\t\t}\n\t\t\tif(!with_dir or e.to > i)ofs << endl;\n\t\t}\n\t}\n\tofs << \"}\" << endl;\n\tofs.close();\n\tsystem(\"dot -T png out.dot > sample.png\");\t\n}\n\n\ncost_t ffMaxFlow(const Graph &g_, int s, int t){\n\tGraph g = g_;\n\tint n = g.size();\n\tvector<int> rev(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < int(g[i].size()); j++) {\n\t\t\tauto&& e = g[i][j];\n\t\t\te.rev = g[e.to].size();\n\t\t\tg.add_edge(e.to,i,0,j);\n\t\t}\n\t}\n\n\tcost_t flow = 0;\n\twhile(true){\n\t\tvector<bool> used(n,false);\n\n\t\tfunction<cost_t(int,int,cost_t)> dfs = [&](int v, int t, cost_t f) -> cost_t{\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\tfor(auto&& e : g[v]) {\n\t\t\t\tif(!used[e.to] and e.cost > 0){\n\t\t\t\t\tcost_t d = dfs(e.to, t, min(f, e.cost));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cost -= d;\n\t\t\t\t\t\tg[e.to][e.rev].cost += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t};\n\n\t\tcost_t f = dfs(s,t,INF);\n\t\tif(f == 0) return flow;\n\t\tflow += f;\n\t}\n}\n\nvoid ios_init(){\n\t//cout.setf(ios::fixed);\n\t//cout.precision(12);\n#ifdef LOCAL111\n\treturn;\n#endif\n\tios::sync_with_stdio(false); cin.tie(0);\t\n}\n\nconst int dx[] = {1,-1,0,0};\nconst int dy[] = {0,0,1,-1};\n\nint main()\n{\n\tios_init();\n\tint h,w;\n\twhile(cin >> h >> w){\n\t\tvector<string> s(h);\n\t\tREP(i,h) cin >> s[i];\n\t\tGraph g(2*h*w+2);\n\t\tint so = h*w*2;\n\t\tint si = h*w*2+1;\n\t\t\n\t\tauto check = [&](int x, int y) -> bool{\n\t\t\treturn 0 <= x and x < h and 0 <= y and y < w;\n\t\t};\n\t\tauto mp = [&](int x, int y) -> int{\n\t\t\treturn w*x+y;\n\t\t};\n\n\t\tREP(i,h) REP(j,w){\n\t\t\tDEBUG(i); DEBUG(j);\n\t\t\tREP(k,4){\n\t\t\t\tint nx = i+dx[k];\n\t\t\t\tint ny = j+dy[k];\n\t\t\t\tDEBUG(mp(nx,ny));\n\t\t\t\tif(check(nx,ny)){\n\t\t\t\t\tg.add_edge(h*w+mp(i,j),mp(nx,ny),INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s[i][j] == 'X'){\n\t\t\t\tg.add_edge(mp(i,j),h*w+mp(i,j),INF);\n\t\t\t\tg.add_edge(so,mp(i,j),INF);\n\t\t\t}else {\n\t\t\t\tg.add_edge(mp(i,j), h*w+mp(i,j),1);\n\t\t\t}\n\t\t}\n\t\t// vizGraph(g,false,true);\n\t\tREP(i,h){\n\t\t\tg.add_edge(h*w+mp(i,w-1),si,INF);\n\t\t\tg.add_edge(h*w+mp(i,0),si,INF);\n\t\t}\n\t\tFOR(j,1,w-1){\n\t\t\tg.add_edge(h*w+mp(0,j),si,INF);\n\t\t\tg.add_edge(h*w+mp(h-1,j),si,INF);\n\t\t}\n\t\tint ans = ffMaxFlow(g,so,si);\n\t\tif(ans >= INF){\n\t\t\tcout << -1 << endl;\n\t\t}else{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nnamespace algo {\n\nnamespace network {\n\ntemplate <typename IntType> class IntValue {\npublic:\n  using ValueType = IntType;\n\n  static bool greater_than_zero(ValueType x) { return x > 0; }\n};\n\ntemplate <int PRECISION> class DoubleValue {\npublic:\n  using ValueType = double;\n  constexpr static double EPSILON = pow(10, -PRECISION);\n\n  static bool greater_than_zero(ValueType x) { return x > EPSILON; }\n};\n} // namespace network\n\ntemplate <typename Derived> class Network {\npublic:\n  using ValueType = typename Derived::ValueType;\n\n  Network(int n, int m = 0) : n(n), head(n, -1), level(n), current(n) {\n    edges.reserve(m);\n  }\n\n  void add(int f, int t, ValueType c, bool back = true) {\n    add_edge(f, t, c);\n    if (back) {\n      add_edge(t, f, static_cast<ValueType>(0));\n    }\n  }\n\n  ValueType max_flow(int source, int target) {\n    ValueType result = 0;\n    while (bfs(source, target)) {\n      std::copy(head.begin(), head.end(), current.begin());\n      result += dfs(source, target, std::numeric_limits<ValueType>::max());\n    }\n    return result;\n  }\n\nprivate:\n  struct Edge {\n    int t;\n    int next;\n    ValueType c;\n  };\n\n  void add_edge(int f, int t, ValueType c) {\n    edges.push_back(Edge{t, head[f], c});\n    head[f] = static_cast<int>(edges.size()) - 1;\n  }\n\n  bool bfs(int source, int target) {\n    std::fill(level.begin(), level.end(), -1);\n    level[target] = 0;\n    std::vector<int> queue{target};\n    for (int h = 0; h < static_cast<int>(queue.size()) && !~level[source];\n         ++h) {\n      int u = queue[h];\n      for (int iterator = head[u]; ~iterator; iterator = edges[iterator].next) {\n        int v = edges[iterator].t;\n        if (greater_than_zero(edges[iterator ^ 1].c) && !~level[v]) {\n          level[v] = level[u] + 1;\n          queue.push_back(v);\n        }\n      }\n    }\n    return ~level[source];\n  }\n\n  ValueType dfs(int u, int target, ValueType remain) {\n    if (u == target) {\n      return remain;\n    }\n    auto argumented = static_cast<ValueType>(0);\n    for (auto &iterator = current[u]; ~iterator && greater_than_zero(remain);) {\n      auto &e = edges[iterator];\n      if (greater_than_zero(e.c) && level[u] == level[e.t] + 1) {\n        auto tmp = dfs(e.t, target, std::min(e.c, remain));\n        e.c -= tmp;\n        edges[iterator ^ 1].c += tmp;\n        remain -= tmp;\n        argumented += tmp;\n        if (!greater_than_zero(remain)) {\n          return argumented;\n        }\n      }\n      iterator = e.next;\n    }\n    level[u] = -1;\n    return argumented;\n  }\n\n  static bool greater_than_zero(ValueType x) {\n    return Derived::greater_than_zero(x);\n  }\n\n  int n;\n  std::vector<int> head, level, current;\n  std::vector<Edge> edges;\n};\n\n} // namespace algo\n\nint main() {\n  std::ios::sync_with_stdio(false);\n  int n, m;\n  while (std::cin >> n >> m) {\n    using namespace algo;\n    Network<network::IntValue<uint32_t>> net((n * m + 1) * 2);\n    int source = n * m * 2;\n    int target = source + 1;\n    std::vector<std::string> grid(n);\n    for (int i = 0; i < n; ++i) {\n      std::cin >> grid[i];\n    }\n    auto get_id = [&](int x, int y, int z) {\n      if (x < 0 || x >= n || y < 0 || y >= m) {\n        return target;\n      }\n      if (grid[x][y] == 'X') {\n        return source;\n      }\n      return (x * m + y) * 2 + z;\n    };\n    const int DELTA_X[] = {-1, 0, 0, 1};\n    const int DELTA_Y[] = {0, -1, 1, 0};\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < m; ++j) {\n        int u = get_id(i, j, 1);\n        if (grid[i][j] == 'X') {\n          net.add(source, u, n * m);\n        }\n        net.add(get_id(i, j, 0), u, 1);\n        for (int k = 0; k < 4; ++k) {\n          int xx = i + DELTA_X[k];\n          int yy = j + DELTA_Y[k];\n          int v = get_id(xx, yy, 0);\n          net.add(u, v, n * m);\n        }\n      }\n    }\n    auto result = net.max_flow(source, target);\n    std::cout << (result < n * m ? static_cast<int32_t>(result) : -1) << std::endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr,Vpr> PQ;\nconst int INF=1<<30;\nint H,W;\nint reconv(int x){x-=2;cout << x/(H*W) <<\" \" << x%(H*W)/W <<\" \" << x%(H*W)%W << endl;}\nstruct Edge{\npublic:\n\tint to,cost,cp;\n\tshared_ptr<Edge> rev;\n\tEdge(){to=0;cost=0;cp=0;}\n\tEdge(int a,int b,int c);\n\tvoid add(int x){\n\t\tcp+=x;\n\t}\n\tvoid flow(int amount){\n\t\tadd(-amount);\n\t\trev->add(amount);\n\t}\n\tbool usable(){\n\t\treturn cp>=1;\n\t}\t\n};\nEdge vo;\nEdge::Edge(int t,int c,int cp):to(t),cost(c),cp(cp){\n}\nvoid unite(shared_ptr<Edge> a,shared_ptr<Edge> b){\n\ta->rev=b;\n\tb->rev=a;\n}\n\nqueue<int> qu;\nclass Graph{\n\tint nodeSize,edgeSize;\n\tvector<int> dist;\n\tvector<vector<shared_ptr<Edge>>> edges;\npublic: \n\tvoid add(int a,int b,int cost,int cp){\n\t\t\n\t\tedges[a].PB(make_shared<Edge>(b,cost,cp));\n\t\tedges[b].PB(make_shared<Edge>(a,cost,0));\n\t\tunite(edges[a].back(),edges[b].back());\n\t}\n\tGraph(){}\n\tGraph(int x):nodeSize(x){\n\t\t\n\t\tedges=vector<vector<shared_ptr<Edge>>>(nodeSize);\n\t\tdist=VI(nodeSize);\n\t}\n\tvoid distInit(int s){\n\t\tREP(i,nodeSize){\n\t\t\tdist[i]=INF;\n\t\t}\n\t\tdist[s]=0;\n\t}\n\tint searching(int now,int e,int capacity){\n\t//\tcout << now <<\" \";\n\t//\treconv(now);\n\t\tif(capacity<=0) return 0;\n\t\tif(now==e) return capacity;\n\t\t//if(dist[now]>=dist[e]) return 0;\n\t\tint flowed=0;\n\t\tREP(i,edges[now].size()){\n\t\t\tauto ed= edges[now][i];\n\t\t//\treconv(ed->to);\n\t\t\tif(!ed->usable()) continue;\n\t\t\tif(dist[now]-1 != dist[ed->to]) continue;\n\t\t\tint nflow=searching(ed->to,e,min(capacity-flowed,ed->cp));\n\t\t\tif(nflow){\n\t\t\t\tflowed+=nflow;\n\t\t\t\ted->flow(nflow);\n\t\t\t}\n\t\t\t\n\t\t\t//if(flowed) return flowed;\n\t\t}\n\t\treturn flowed;\n\t}\n\tbool bfs(int s,int e){\n\t\tdistInit(s);\n\t\tqueue<int> qu;\n\t\tqu.push(s);\n\t\twhile(!qu.empty()){\n\t\t\tint now=qu.front();\n\t//\t\t// cout << now << endl;\n\t\t\tqu.pop();\n\t\t\tREP(i,edges[now].size()){;\n\t\t\t\tauto ed=edges[now][i];\n\t\t\t\tif(!ed->rev->usable()) continue;\n\t\t\t\tif(dist[ed->to]==INF){\n\t\t\t\t\tqu.push(ed->to);\n\t\t\t\t\tdist[ed->to]=dist[now]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn dist[e]!=INF;\n\t}\n\tint maximumFlow(int s,int e){\n\t\tint ans=0;\n\t\twhile(bfs(e,s)){\n\t\t\tans+=searching(s,e,INF);\n//\t\t\tcout << ans << endl;\n\t\t}\n\t\treturn ans;\n\t}\n};\nconst int SIZE=101;\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\nint maps[SIZE][SIZE];\nGraph graph;\nint conv(int a,int b,int c){return a*W+b+H*W*c+2;}\nbool isSafe(int y,int x){\n\treturn 0<=y && y<H && 0<=x && x<W;\n}\nint main(){\n\tcin >> H >> W;\n\tgraph=Graph(SIZE*SIZE*3+3);\n\tREP(i,H) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,W){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(maps[i][j] &&(i==0 || j==0 || i==H-1 || j==W-1)){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t//\t\tcout << maps[i][j];\n\t\t}\t\t\n//\t\tcout << endl;\n\t}\n\tREP(i,H) REP(j,W) {\n\t\tgraph.add(conv(i,j,1),conv(i,j,0),0,1);\n\t\tif(maps[i][j]){\n\t\t\tgraph.add(0,conv(i,j,0),0,4);\n\t\t}\n\t\tREP(k,4){\n\t\t\tif(!isSafe(i+dy[k],j+dx[k])){\n\t\t\t\tgraph.add(conv(i,j,0),1,0,1);\n\t\t\t} \n\t\t\telse{\n\t\t//\t\tcout << i <<\" \" << j <<\" \" << i+dy[k] <<\" \" << j+dx[k] << endl;\n\t\t//\t\tcout << conv(i,j,0) << \" \" << conv(i+dy[k],j+dx[k],1) << endl;\n\t\t\t\tgraph.add(conv(i,j,0),conv(i+dy[k],j+dx[k],1),0,1);\n\t\t\t\tgraph.add(conv(i+dy[k],j+dx[k],0),conv(i,j,1),0,1);\n\t\t\t}\n\t\t}\n\t\n\t}\n\tcout << graph.maximumFlow(0,1) << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e2 + 7;\n\nbool mark[N][N];\nbool vis[N][N], flag;\nstring s[N];\nint n, m;\nint dr[] = {1, -1, 0, 0};\nint dc[] = {0, 0, 1, -1};\nvector<pair<int, int> > v;\n\nvoid dfs(int r, int c)\n{\n\tif (r == -1 || r == n || c == -1 || c == m)\n\t{\n\t\tflag = false;\n\t\treturn;\n\t}\n\tif (mark[r][c] || vis[r][c])\n\t\treturn;\n\tvis[r][c] = true;\n\tfor (int i=0; i<4; i++)\n\t\tdfs(r + dr[i], c + dc[i]);\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t\n\tcin >> n >> m;\n\tfor (int i=0; i<n; i++)\n\t\tcin >> s[i];\n\tfor (int i=0; i<n; i++)\n\t\tfor (int j=0; j<m; j++)\n\t\t\tif (s[i][j] == 'X')\n\t\t\t{\n\t\t\t\tfor (int k=0; k<4; k++)\n\t\t\t\t{\n\t\t\t\t\tint r = i + dr[k];\n\t\t\t\t\tint c = j + dc[k];\n\t\t\t\t\tif (r == -1 || c == -1 || r == n || c == m)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << -1 << \"\\n\";\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[r][c] != 'X' && !mark[r][c])\n\t\t\t\t\t\tmark[r][c] = true, v.push_back({r, c});\n\t\t\t\t}\n\t\t\t}\n\tint ans = 0;\n\tfor (auto x : v)\n\t{\n\t\tmark[x.first][x.second] = false;\n\t\tflag = true;\n\t\tmemset(vis, 0, sizeof vis);\n\t\tdfs(x.first, x.second);\n\t\tif (!flag)\n\t\t\tans++, mark[x.first][x.second] = true;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nusing vs=vector<string>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\n\nstatic const int INF=1<<29;\nstatic const int di[]={-1, 0, 1, 0}, dj[]={0, -1, 0, 1};\nint main() {\n  size_t H, W;\n  scanf(\"%lu %lu\", &H, &W);\n\n  vs S(H);\n  for (size_t i=0; i<H; ++i) {\n    char buf[1<<7];\n    scanf(\"%s\", buf);\n    S[i] = buf;\n    if (S[i][0]=='X' || S[i][W-1]=='X')\n      return !printf(\"-1\\n\");\n  }\n\n  if (S[0].find('X') != string::npos)\n    return !printf(\"-1\\n\");\n\n  if (S[H-1].find('X') != string::npos)\n    return !printf(\"-1\\n\");\n\n  vs T(H, string(W, '.'));\n  for (size_t i=1; i<H-1; ++i)\n    for (size_t j=1; j<W-1; ++j) {\n      if (S[i][j] == 'X') {\n        for (size_t k=0; k<4; ++k) {\n          int I=i+di[k], J=j+dj[k];\n          T[I][J] = '#';\n        }\n      }\n    }\n\n  vvi dp(H, vi(W, INF));\n  queue<pii> q;\n  for (size_t i=0; i<H; ++i) {\n    if (T[i][0] != '#') {\n      dp[i][0] = 0;\n      q.push(pii(i, 0));\n    }\n    if (T[i][W-1] != '#') {\n      dp[i][W-1] = 0;\n      q.push(pii(i, W-1));\n    }\n  }\n\n  for (size_t j=0; j<W; ++j) {\n    if (T[0][j] != '#') {\n      dp[0][j] = 0;\n      q.push(pii(0, j));\n    }\n    if (T[H-1][j] != '#') {\n      dp[H-1][j] = 0;\n      q.push(pii(H-1, j));\n    }\n  }\n\n  while (!q.empty()) {\n    int i=q.front().first, j=q.front().second; q.pop();\n    for (size_t k=0; k<4; ++k) {\n      int I=i+di[k], J=j+dj[k];\n      if (!(0<=I && I<H && 0<=J && J<W)) continue;\n\n      if (dp[I][J] > dp[i][j] + (T[I][J]=='#')) {\n        dp[I][J] = dp[i][j] + (T[I][J]=='#');\n        q.push(pii(I, J));\n      }\n    }\n  }\n\n  int res=0;\n  for (size_t i=0; i<H; ++i)\n    for (size_t j=0; j<W; ++j) {\n      fprintf(stderr, \"%d%c\", dp[i][j], j<W-1? ' ':'\\n');\n      if (dp[i][j]==1 && T[i][j]=='#') {\n        ++res;\n      } else if (i==0 || i==H-1 || j==0 || j==W-1) {\n        if (dp[i][j] > 0) ++res;\n      }\n    }\n\n  printf(\"%d\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint x[100][100], H, W; bool used[100][100];\nint dx[4] = { -1,0,1,0 }, dy[4] = { 0,1,0,-1 };\nint solve() {\n\tqueue<pair<int, int>>Q;\n\tfor (int i = 0; i < 10000; i++)used[i / 100][i % 100] = false;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n\t\t\t\tif (x[i][j] == 1)return -1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = -1; i <= H; i++) {\n\t\tfor (int j = -1; j <= W; j++) {\n\t\t\tif (i == -1 || i == H || j == -1 || j == W)Q.push(make_pair(i, j));\n\t\t}\n\t}\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front().first, a2 = Q.front().second; Q.pop();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint cx = a1 + dx[i], cy = a2 + dy[i];\n\t\t\tif (cx < 0 || cx >= H || cy < 0 || cy >= W)continue;\n\t\t\tif (used[cx][cy] == true)continue;\n\t\t\tif (x[cx][cy] == 2)continue;\n\t\t\tused[cx][cy] = true; Q.push(make_pair(cx, cy));\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n\t\t\t\tif (x[i][j] == 2)x[i][j] = 3;\n\t\t\t}\n\t\t\tif (used[i][j] == true) {\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint cx = i + dx[k], cy = j + dy[k];\n\t\t\t\t\tif (cx < 0 || cx >= H || cy < 0 || cy >= W)continue;\n\t\t\t\t\tif (x[cx][cy] == 2)x[cx][cy] = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < H*W; i++)if (x[i / W][i%W] == 3)cnt++;\n\treturn cnt;\n}\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tchar c; cin >> c;\n\t\t\tif (c == 'X')x[i][j] = 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (x[i][j] == 1) {\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint cx = i + dx[k], cy = j + dy[k];\n\t\t\t\t\tif (cx < 0 || cx >= H || cy < 0 || cy >= W)continue;\n\t\t\t\t\tif (x[cx][cy] == 0)x[cx][cy] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << solve() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Network{\n\tprivate:\n\tint V;\n\tstruct edge{\n\t\tint to,cap,rev;\n\t};\n\tvector<vector<edge> > List;\n\tint DFS(int v,int t,int f,vb& used){\n\t\tif(v==t) return f;\n\t\tused[v]=1;\n\t\tfor(int i=0;i<List[v].size();i++){\n\t\t\tedge &e=List[v][i];\n\t\t\tif(!used[e.to]&&e.cap>0){\n\t\t\t\tint d=DFSplus(e.to,t,min(f,e.cap),used);\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tList[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tpublic:\n\tNetwork(int v){\n\t\tV=v;\n\t\tList=vector<vector<edge> >(v);\n\t}\n\tvoid add_edge(int s,int t,int c){\n\t\tList[s].push_back(edge{t,c,(int)List[t].size()});\n\t\tList[t].push_back(edge{s,0,(int)List[s].size()-1});\n\t}\n\tint MF(int s,int t){\n\t\tint ans=0;\n\t\twhile(1){\n\t\t\tvb used(V);\n\t\t\tint f=DFS(s,t,inf,used);\n\t\t\tif(f==0) return ans;\n\t\t\tans+=f;\n\t\t}\n\t}\n};\n\nint h,w;\nvvc a;\n\ninline int f(int x,int y){\n\treturn x*w+y;\n}\n\nint main(){\n\tcin>>h>>w;\n\ta=vvc(h,vc(w));\n\tNetwork nt(2*h*w+2);\n\tbool flag=1;\n\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++){\n\t\tcin>>a[i][j];\n\t\tif(a[i][j]=='X') nt.add_edge(2*h*w,h*w+f(i,j),inf);\n\t\telse nt.add_edge(f(i,j),h*w+f(i,j),1);\n\t\tif(!i||i==h-1||!j||j==w-1){\n\t\t\tnt.add_edge(h*w+f(i,j),2*h*w+1,inf);\n\t\t\tif(a[i][j]=='X') flag=0;\n\t\t}\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint x=i+dx[k],y=j+dy[k];\n\t\t\tif(x>=0&&x<h&&y>=0&&y<w) nt.add_edge(h*w+f(i,j),f(x,y),inf);\n\t\t}\n\t}\n\tif(!flag){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tcout<<nt.MF(2*h*w,2*h*w+1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//諸機能\n#pragma region MACRO \n#define putans(x)  std::cerr << \"answer: \" ; cout << (x) << endl\n#define dputans(x) std::cerr << \"answer: \"; cout << setprecision(13) << (double)(x) << endl\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define RREP(i,a,n) for(int i=(int)(n-1); i>= a; i--)\n#define rep(i,n) REP(i,0,n)\n#define rrep(i,n) RREP(i,0,n)\n#define all(a) begin((a)),end((a))\n#define mp make_pair\n#define exist(container, n) ((container).find((n)) != (container).end())\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#ifdef _DEBUG //ファイルからテストデータを読み込む\nstd::ifstream ifs(\"data.txt\");\n#define put ifs >>\n#else //ジャッジシステムでいい感じにやる\n#define put cin >>\n#endif\n#pragma endregion\n\n//デバッグなどの支援\n#pragma region CODING_SUPPORT\n#define dbg(var0) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << endl; }\n#define dbg2(var0, var1) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg(var1); }\n#define dbg3(var0, var1, var2) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg2(var1, var2); }\n#define dbgArray(a,n) {std::cerr << (#a) << \"=\";  rep(i,n){std::cerr <<(a[i])<<\",\";} cerr<<endl;} \n#ifndef _DEBUG\n#define dbg1 {}\n#define dbg2 {}\n#define dbg3 {}\n#define dbgArray {}\n#endif \n#pragma endregion \n//typedef（書き換える、書き足す可能性ある）\n#pragma region TYPE_DEF\ntypedef long long ll;\ntypedef pair<int, int> pii; typedef pair<string, string> pss; typedef pair<int, string>pis;\ntypedef vector<string> vs; typedef vector<int> vi;\n#pragma endregion\n//諸々の定数(書き換える可能性ある)\n#pragma region CONST_VAL\n#define PI (2*acos(0.0))\n#define EPS (1e-9)\n#define MOD (ll)(1e9 + 7)\n#define INF (ll)(1e9)\n#pragma endregion\n\nclass Point {//幾何上のべクトル\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(x * a, y * a); }\n\tdouble operator * (Point p) { return dot(p); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n\n\tbool operator < (const Point &p) const { return  x != p.x ? x < p.x : y < p.y; }\n\tbool operator == (const Point &p) const { return  fabs(x - p.x) < EPS && fabs(y - p.y) < EPS; }\n\t//内積、外積\n\tdouble dot(Point p) { return x * p.x + y * p.y; }\n\tdouble cross(Point p) { return x * p.y - y * p.x; }\n\n\n};\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\nstruct Segment {//線分\n\tPoint p1, p2;\n};\n\ntypedef Point Vector;\ntypedef Segment Line;//直線\ntypedef vector<Point> Polygon;\n\ndouble v_norm(Point p) { return p.x * p.x + p.y * p.y; }\ndouble abs(Point p) { return v_norm(p); }\ndouble dot(Point p, Point q) { return p.x * q.x + p.y * q.y; }\ndouble cross(Point p, Point q) { return q.x * p.y - p.y * p.x; }\n\n\n\n\n\n//直行、並行\nbool isOrthogonal(Vector a, Vector b) { return equals(a*b, 0.0); }\nbool isParallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\n\n//線分sに対する点pの射影\nPoint projection(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(( p - s.p1 ), base) / v_norm(base);\n\treturn s.p1 + base*r;\n}\n//線分sに対する点pの反射\nPoint reflection(Segment s, Point p) { return p + ( projection(s, p) - p ) * 2; }\n\n\n\n\n//double getDistance(Point a, Point b) { return ( a - b ).abs; }\n//double getDistanceLP(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1)); }\n//double getDistanceSP(Segment s, Point p) {\n//\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n//\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n//}\n\n//double getDistance(Segment s1, Segment s2) {\n//\tif (intersect(s1, s2)) return 0;\n//\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2))\n//\t         , min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2));\n//}\n\n//p1-p0を基準として p2-p0 の2ベクトルについて\nstatic const int COUNTER_CLOCKWISE = 1;//反時計回り\nstatic const int CLOCKWISE = -1;//時計回り\nstatic const int ONLINE_BACK = 2;//同一直線状p2,p0,p1の順\nstatic const int ONLINE_FRONT = 1;//同一直線上p0,p1,p2の順\nstatic const int ON_SEGMENT = 0;//p2がp0,p1上にある場合\nint ccw(Point p0, Point p1, Point p2) {//上記の分類関数\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (v_norm(a) < v_norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n////線分p1p2とp3p4の交差判定\n//bool intersect(Point p1, Point p2, Point p3, Point p4) {return ( (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0) && (ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0));}\n//bool intersect(Segment s1, Segment s2) {return intersect(s1.p1 , s1.p1, s2.p1, s2.p2);}\n//\n//Point getCrossPoint(Segment s1, Segment s2) {\n//\tVector base = s2.p2 - s2.p1;\n//\tdouble d1 = abs(cross(base , s1.p1 - s2.p1));\n//\tdouble d2 = abs(cross(base , s1.p2 - s2.p1));\n//\tdouble t = d1 / ( d1 + d2 );\n//\treturn s1.p1 + (s1.p2 - s1.p1 ) * t;\n//}\n//\n////直線と円の交点を調べる\n//pair<Point, Point> getCrossPoints(Circle c, Line l) {\n//\t//assert(intersect(c, i)); 交差しない場合についてのはず\n//\tVector pr = projection(c, l);\n//\tVector e = ( l.p2 - l.p1 ) / abs(l.p2 - l.p1);\n//\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n//\treturn mp(pr + e * base, pr - e * base);\n//}\n//\n////点の内包を調べる\n//static const int IN_POLYGON = 2;//多角形の内部\n//static const int OUT_POLYGON = 1;//多角形の外部\n//static const int ON_POLYGON = 0;//多角形の線分上\n//int contains(Polygon g, Point p) {\n//\tint n = g.size();\n//\tbool x = false;\n//\trep(i, n) {\n//\t\tPoint a = g[i] - p, b = g[( i + 1 ) % n] - p;\n//\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return OUT_POLYGON;\n//\t\tif (a.y > b.y) swap(a, b);\n//\t\tif (a.y < EPS && EPS < b.y && cross(a, b)) x = !x;\n//\t}\n//\treturn ( x ? IN_POLYGON : ON_POLYGON );\n//}\n\n//凸包\nPolygon ConvexHull(Polygon s) {\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tsort(all(s));\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\n\tfor (int i = 2; i < s.size(); i++) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE; n--)u.pop_back();\n\t\tu.push_back(s[i]);\n\t}\n\n\tfor (int i = s.size()-3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE; n--)l.pop_back();\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(all(l));\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\n/*\n#define i(x) int x; scanf(\"%d\",&x);\n#define l(x) ll x; scanf(\"%lld\",&x);\n#define d(x) double  x; scanf(\"%lf\",&x);\n*/\n//今度実装がんばる\n//https://www23.atwiki.jp/akitaicpc/pages/65.html\n\n\nint main() {\n\t/*double xp1, yp1, xp2, yp2; put xp1 >> yp1 >> xp2 >> yp2;\n\tSegment s;\n\ts.p1 = Point(xp1, yp1);\n\ts.p2 = Point(xp2, yp2);\n\n\tint n; put n;\n\trep(i, n) {\n\t\tPoint p;\n\t\tput p.x >> p.y;\n\t\tPoint prj =reflection(s, p);\n\t\tcout << setprecision(13) << prj.x << \" \" << prj.y << endl;\n\t}*/\n\t//テンプレート化を来世に考える\n\tauto getI = [&]()->auto { int tmp; put tmp; return tmp; };\n\tauto getLL = [&]()->auto { ll tmp; put tmp; return tmp; };\n\tauto getS = [&]()->auto { string tmp; put tmp; return tmp; };\n\tPolygon sheep;\n\tPolygon convex_sheep;\n\tint num = 0;\n\tint h, w; put h >> w;\n\trep(i, h) {\n\t\tstring s; put s;\n\t\trep(j, s.size()) {\n\t\t\tif (s[j] == 'X') {\n\t\t\t\tif (i == 0 || j == 0) {\n\t\t\t\t\tputans(-1);\n\t\t\t\t\tgoto END;\n\t\t\t\t}\n\t\t\t\tsheep.push_back(Point(i, j));\n\t\t\t}\n\t\t}\n\t}\n\tconvex_sheep = ConvexHull(sheep);\n\n\trep(i, convex_sheep.size()) {\n\t\tPoint s = convex_sheep[i % convex_sheep.size()];\n\t\tPoint g = convex_sheep[(i + 1) % convex_sheep.size()];\n\t\tint mandist = abs(s.x - g.x) + abs(s.y - g.y);\n\t\tnum += mandist;\n\t}\n\tputans(num);\nEND:\n\treturn 0;\n}\n\n//\n//int n, a, b; put n >> a >> b;\n//\tvi t;\n//\trep(i, n) {\n//\t\tt.push_back(get());\n//\t}\n//\tint count = 0;\n//\trep(i, n) {\n//\t\tif (t[i] < a || b <= t[i])count++;\n//\t}\n//\tputans(count);\n\n//\n//\tset<string> list;\n//\tint ans = 0;\n//\tint n; put n;\n//\tint k; put k;\n//\tint numAlphabet[26];\n//\tfill(all(numAlphabet), 0);\n//\trep(i, n) {\n//\t\tstring s; put s;\n//\t\tif (exist(list, s))continue;\n//\t\tlist.insert(s);\n//\t\tnumAlphabet[s[0] - 'A']++;\n//\t}\n//\tsort(all(numAlphabet),greater<int>());\n//\twhile (true) {\n//\t\trep(i, k) {\n//\t\t\tif (numAlphabet[i] == 0) goto END;\n//\t\t\telse numAlphabet[i]--;\n//\t\t}\n//\t\tsort(all(numAlphabet), greater<int>());\n//\t\tans++;\n//\t}\n//END:\n//\tputans(ans);\n\n\n\t//int t; put t;\n\t//rep(i, t) {\n\t//\tint n, d; put n >> d;\n\t//\tif (n == 1) {\n\t//\t\tputans(d);\n\t//\t\tcontinue;\n\t//\t}\n\t//\tputans(n % 2 != 0 ? ( n - 1 ) * 127 + d : ( n - 1 ) * 127 + ( 127 ^ d ));\n\t//}\n\n\n//\n//int n; put n;\n//string s1, s2;\n//string r;\n//string patan1[4] = { \".\",\"#\",\".\",\"#\" };\n//string patan2[4] = { \".\",\".\",\"#\",\"#\" };\n//bool front = true;\n//rep(j, 420 / 4) {\n//\tif (front) {\n//\t\trep(i, 4) {\n//\t\t\tcout << s1 + patan1[i] + \"\\n\" << s2 + patan2[i] << endl;\n//\t\t\tcin >> r;\n//\t\t\tif (r == \"T\") {\n//\t\t\t\ts1 += patan1[i];\n//\t\t\t\ts2 += patan2[i];\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t\tif (r == \"F\" && i == 3) {\n//\t\t\t\tfront = !front;\n//\t\t\t}\n//\t\t\tif (r == \"end\")goto END;\n//\t\t}\n//\t}\n//\telse {\n//\t\trep(i, 4) {\n//\t\t\tcout << patan1[i] + s1 + \"\\n\" << patan2[i] + s2 << endl;\n//\t\t\tcin >> r;\n//\t\t\tif (r == \"T\") {\n//\t\t\t\ts1 = patan1[i] + s1;\n//\t\t\t\ts2 = patan2[i] + s2;\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t\tif (r == \"F\" && i == 3) {\n//\t\t\t\tfront = !front;\n//\t\t\t}\n//\t\t\tif (r == \"end\")goto END;\n//\t\t}\n//\t}\n//\n//}\n//END:\n//cout << endl;"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr,Vpr> PQ;\nconst int INF=1<<30;\nstruct Edge{\npublic:\n\tint to,cost,cp;\n\tEdge *rev;\n\tEdge(int t,int c,int cp):to(t),cost(c),cp(cp){\n\t\t\n\t}\n\tvoid add(int x){\n\t\tcp+=x;\n\t}\n\tvoid flow(int amount){\n\t\tadd(-amount);\n\t\trev->add(amount);\n\t}\n\tbool usable(){\n\t\treturn cp>=1;\n\t}\t\n};\nvoid unite(Edge &a,Edge &b){\n\ta.rev=&b;\n\tb.rev=&a;\n}\nclass Graph{\n\tint nodeSize,edgeSize;\n\tvector<int> dist;\n\tvector<vector<Edge> > edges;\npublic: \n\tvoid add(int a,int b,int cost,int cp){\n\t\tedges[a].PB(Edge(b,cost,cp));\n\t\tedges[b].PB(Edge(a,cost,0));\n\t\tunite(edges[a].back(),edges[b].back());\n\t}\n\tGraph(int x):nodeSize(x){\n\t\t\n\t\tedges=vector<vector<Edge> >(nodeSize);\n\t\tdist=VI(nodeSize);\n\t}\n\tvoid distInit(int s){\n\t\tREP(i,nodeSize){\n\t\t\tdist[i]=INF;\n\t\t}\n\t\tdist[s]=0;\n\t}\n\tint searching(int now,int e,int capacity){\n\t\tif(capacity==0) return 0;\n\t\tif(now==e) return capacity;\n\t\tif(dist[now]>=dist[e]) return 0;\n\t\tint flowed=0;\n\t\tREP(i,edges[now].size()){\n\t\t\tEdge *ed= &edges[now][i];\n\t\t\tif(!ed->usable()) continue;\n\t\t\tif(dist[now]+1 != dist[ed->to]) continue;\n\t\t\tint nflow=searching(ed->to,e,min(capacity-flowed,ed->cp));\n\t\t\tif(nflow){\n\t\t\t\tflowed+=nflow;\n\t\t\t\ted->flow(nflow);\n\t\t\t}\n\t\t}\n\t\treturn flowed;\n\t}\n\tbool bfs(int s,int e){\n\t\tdistInit(s);\n\t\tqueue<int> qu;\n\t\tqu.push(s);\n\t\twhile(!qu.empty()){\n\t\t\tint now=qu.front();\n\t\t\tif(now==e) return true;\n\t\t\tqu.pop();\n\t\t\tREP(i,edges[now].size()){\n\t\t\t\tEdge *ed= &edges[now][i];\n\t\t\t\tif(!ed->usable()) continue;\n\t\t\t\tif(dist[ed->to]==INF){\n\t\t\t\t\tqu.push(ed->to);\n\t\t\t\t\tdist[ed->to]=dist[now]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint maximumFlow(int s,int e){\n\t\tint ans=0;\n\t\twhile(bfs(s,e)){\n\t\t\tans+=searching(s,e,INF);\n\t\t}\n\t\treturn ans;\n\t}\n};\nconst int SIZE=101;\nint conv(int a,int b,int c){return a*100+b+SIZE*SIZE*c+2;}\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\nint H,W;\nint maps[101][101];\nGraph graph(SIZE*SIZE*3+2);\nbool isSafe(int y,int x){\n\treturn 0<=y && y<H && 0<=x && x<W;\n}\nint main(){\n\tcin >> H >> W;\n\tREP(i,H) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,s.size()){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(maps[i][j] &&(i==0 || j==0 || i==H-1 || j==W-1)){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\t\t\n\t}\n\tREP(i,H) REP(j,W) {\n\t\tgraph.add(conv(i,j,1),conv(i,j,0),0,1);\n//\t\tedges[conv(i,j,1)].PB(edge(conv(i,j,0),0,1));\n\t\tif(maps[i][j]){\n\t\t\t//edges[0].PB(edge(conv(i,j,1),0,1));\n\t\t\tgraph.add(0,conv(i,j,0),0,4);\n\t\t}\n\t\tREP(k,4){\n\t\t\tif(!isSafe(i+dy[k],j+dx[k])){\n\t\t\tgraph.add(conv(i,j,0),1,0,1);\n\t\t\t//\tedges[conv(i,j,0)].PB(edge(1,0,1));\n\t\t\t} \n\t\t\telse if(!maps[i+dy[k]][j+dx[k]]){\n\t\t\t\tgraph.add(conv(i,j,0),conv(i+dy[k],j+dx[k],1),0,1);\n\t\t\t\tgraph.add(conv(i+dy[k],j+dx[k],0),conv(i,j,1),0,1);\n//\t\t\t\tedges[conv(i,j,0)].PB(edge(conv(i+dy[k],j+dx[k],1),0,1));\n//\t\t\t\tedges[conv(i+dy[k],j+dx[k],0)].PB(edge(conv(i,j,1),0,1));\n\t\t\t}\n\t\t}\n\t\n\t}\n\tcout << graph.maximumFlow(0,1) << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <limits>\n#include <iostream>\n#include <map>\n#include <set>\n#include <tuple>\n#include <iomanip>\n#include <functional>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,ll> pil;\ntypedef pair<ll,int> pli;\ntypedef pair<ll,ll> pll;\n\ntemplate<class T,class U>constexpr bool chmin(T&a,const U b){if(a<=b)return false;a=b;return true;}\ntemplate<class T,class U>constexpr bool chMAX(T&a,const U b){if(a>=b)return false;a=b;return true;}\n#define bit(n,k) ( (n>>k)&1 )\n\n//デバッグ\ntemplate<class T>\nvoid Vout(vector<T> &V){\n    cout<<\"\\nstart\\n\";\n    const int sz=V.size();\n    for(int i=0;i<sz;i++){\n        cout<<i<<\" \"<<V[i]<<'\\n';\n    }\n    cout<<\"end\\n\"<<endl;\n}\n\ntemplate<class T>\nvoid VPout(vector<T> &V){\n    cout<<\"\\nstart\\n\";\n    const int sz=V.size();\n    for(int i=0;i<sz;i++){\n        cout<<i<<\" \"<<V[i].first<<\" \"<<V[i].second<<'\\n';\n    }\n    cout<<\"end\\n\"<<endl;\n}\n\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n\nconstexpr int MAX=1<<30;\nconstexpr ll INF=1LL<<62;\nconstexpr int MOD=1e9+7;\nint dx[]={1,-1,0,0},dy[]={0,0,-1,1};\n\n//__builtin_popcount(S);\n//#define int ll\n//vector<vector<int>> data(3, vector<int>(4));\n//vector.resize(a,vector<int>(b,-1));\n//vector<vector<vector<要素の型>>> 変数名(要素数1, vector<vector<要素の型>>(要素数2, vector<要素の型>(要素数3, 初期値)));\n\n\ntemplate<typename T>\nstruct Dinic{\n    struct edge{\n        int to;\n        T cap;\n        int rev;\n    };\n    const T inf;\n    const T zero;\n    int sz;\n    vector< vector<edge> > graph;\n    vector<int> dist,iter;\n\n    Dinic(const int n,const T inf,const T zero) : inf(inf),zero(zero),graph(n),sz(n){}\n\n    void add_edge(const int from,const int to,const T cap){\n        graph[from].emplace_back((edge){to,cap,(int)graph[to].size()});\n        graph[to].emplace_back((edge){from,0,(int)graph[from].size()-1});\n    }\n\n    bool bfs(int s,int t){\n        dist.assign(sz,-1);\n        queue<int> que;\n        dist[s]=0;\n        que.push(s);\n        while(!que.empty() && dist[t]==-1){\n            int now=que.front();\n            que.pop();\n            for(auto &e:graph[now]){\n                if(e.cap>0 && dist[e.to]==-1){\n                    dist[e.to]=dist[now]+1;\n                    que.push(e.to);\n                }\n            }\n        }\n        return dist[t]!=-1;\n    }\n\n    T dfs(int idx,const int t,T flow){\n        if(idx==t) return flow;\n        for(int &i=iter[idx];i<graph[idx].size();i++){\n            edge &e=graph[idx][i];\n            if(e.cap>0 && dist[idx]<dist[e.to]){\n                T d=dfs(e.to,t,min(flow,e.cap));\n                if(d>0){\n                    e.cap-=d;\n                    graph[e.to][e.rev].cap+=d;\n                    return d;\n                }\n            }\n        }\n        return zero;\n    }\n\n    T max_flow(int s,const int t){\n        T ret=0;\n        while(bfs(s,t)){\n            iter.assign(sz,0);\n            T f=0;\n            while((f=dfs(s,t,inf))>zero) ret+=f;\n        }\n        return ret;\n    }\n};\n\nint h,w;\n//flag:true IN\n//flag:false out\nint f(int i,int j,bool flag){\n    if(flag) return 1+i*w+j;\n    return 1+h*w+i*w+j;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr); \n    cout<<fixed<<setprecision(10);\n\n    cin>>h>>w;\n\n    Dinic<int> flow(2*h*w+2,MAX,0);\n\n    char c[110][110];\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            cin>>c[i][j];\n            if(c[i][j]=='X'){\n                flow.add_edge(0,f(i,j,true),MAX);\n            }\n        }\n    }\n\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(c[i][j]=='X') flow.add_edge(f(i,j,true),f(i,j,false),MAX);\n            else flow.add_edge(f(i,j,true),f(i,j,false),1);\n            for(int k=0;k<4;k++){\n                int ni=i+dx[k],nj=j+dy[k];\n                if(ni<0 || ni==h || nj<0 || nj==w){\n                    flow.add_edge(f(i,j,false),2*h*w+1,MAX);\n                    continue;\n                }\n                flow.add_edge(f(i,j,false),f(ni,nj,true),MAX);\n            }\n        }\n    }\n    int x=flow.max_flow(0,2*h*w+1);\n    if(x>=MAX) cout<<-1<<endl;\n    else cout<<x<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar t[200][200];\nbool visited[200][200];\nint H,W;\n\nvoid dfs(int y,int x){\n  if(y<0 || x<0 || y>=200 || x>=200 )return;\n  if(visited[y][x])return;\n  visited[y][x]=true;\n\n  if(t[y][x]=='#'){\n    return;\n  }\n  \n  dfs(y+1,x);\n  dfs(y-1,x);\n  dfs(y,x+1);\n  dfs(y,x-1);\n}\n\nint main(){\n  for(int i=0;i<200;i++)\n    for(int j=0;j<200;j++)\n      t[i][j]='.';\n  cin>>H>>W;\n\n  for(int i=1;i<=H;i++){\n    for(int j=1;j<=W;j++){\n      cin>>t[i][j];\n\n      if(t[i][j]=='X'){\n        if(i==1||j==1||i==H||j==W){\n          cout<<-1<<endl;\n          return 0;\n        }\n      }\n    }\n  }\n\n  for(int i=1;i<=H;i++){\n    for(int j=1;j<=W;j++){\n      if(t[i][j]=='X'){\n        if(t[i+1][j]=='.')t[i+1][j]='#';\n        if(t[i-1][j]=='.')t[i-1][j]='#';\n        if(t[i][j+1]=='.')t[i][j+1]='#';\n        if(t[i][j-1]=='.')t[i][j-1]='#';\n      }\n    }\n  }\n\n  dfs(0,0);\n  int cnt=0;\n  for(int i=1;i<=H;i++){\n    for(int j=1;j<=W;j++){\n      if(t[i][j]=='#'&&visited[i][j])cnt++;\n    }\n  }\n  cout<<cnt<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n\n#define int long long\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(a) (a).begin(), (a).end()\n#define PB push_back\n#define MP make_pair\n#define FST first\n#define SND second\n#define SZ(a) (signed)((a).size())\n#define EACH(i, c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort((c).begin(), (c).end())\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\n\nconst int MOD = 1000000007;\nconst char ENDL = '\\n';\n\n#define dump(x) cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\"  << \" \" << __FILE__ << endl;\n\nsigned main(void) {\n    ios::sync_with_stdio(false);\n    cout.setf(ios::fixed, ios::floatfield);\n    cout.precision(10);\n    cin.tie(0);\n\n    int h,w;\n    cin >> h >> w;\n    vector<vector<bool>> s(h+2,vector<bool>(w+2,false));\n    FOR(i,1,h+1){\n        FOR(j,1,w+1){\n            char c;\n            cin >> c;\n            s[i][j]=(c=='X');\n        }\n    }\n\n    FOR(i,1,h+1){\n        FOR(j,1,w+1){\n            if(s[i][j] && (i==1 || j==1 || i==h || j==w)){\n                cout << -1 << ENDL;\n                return 0;\n            }\n        }\n    }\n\n    FOR(i,1,h+1){\n        int r=-1;\n        for (int j = w; j >=1 ; --j) {\n            if(s[i][j]){\n                r=j;\n                break;\n            }\n        }\n        int l=w;\n        for (int j = 1; j <= h; ++j) {\n            if(s[i][j]){\n                l=j;\n                break;\n            }\n        }\n\n        for (int j = l; j <=r ; ++j) {\n            s[i][j] = true;\n        }\n    }\n\n    int ans=0;\n    FOR(i,1,h+1){\n        FOR(j,1,w+1){\n            if(!s[i][j]){\n                if(s[i-1][j]){\n                    ans++;\n                    continue;\n                }\n                if(s[i+1][j]){\n                    ans++;\n                    continue;\n                }\n                if(s[i][j-1]){\n                    ans++;\n                    continue;\n                }\n                if(s[i][j+1]){\n                    ans++;\n                    continue;\n                }\n            }\n        }\n    }\n\n    cout << ans << ENDL;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n// c++11\n#include <array>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n\n#define mp make_pair\n#define mt make_tuple\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\n\nconst int INF = 1 << 29;\nconst double EPS = 1e-9;\nconst ll MOD = 1000000007;\n\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\nconst int MAX_N = 110;\nint H,W;\nchar board[MAX_N][MAX_N];\nset<pii> goats;\nset<pii> fences;\nvoid debug_board(){\n  cerr << \"Debug board!!\" << endl;\n  for (int i = 0; i < H; i++){\n    for (int j = 0; j < W; j++){\n      cerr << board[i][j] << \" \";\n    }\n    cerr << endl;\n  }\n}\n\nbool visited[MAX_N][MAX_N];\nbool bfs(int sy, int sx){\n  queue<pii> que;\n  que.emplace(mp(sy, sx));\n  while (not que.empty()){\n    pii pos = que.front();\n    que.pop();\n    int py = pos.first;\n    int px = pos.second;\n    if (visited[py][px]){\n      continue;\n    }\n    visited[py][px] = true;\n    if (py == 0 or py == H - 1 or px == 0 or px == W - 1){\n      return false;\n    }\n    for (int k = 0; k < 4; k++){\n      int ny = py + dy[k];\n      int nx = px + dx[k];\n      if (ny < 0 or ny >= H or nx < 0 or nx >= W){\n        continue;\n      }\n      if (board[ny][nx] == 'F'){\n        continue;\n      }\n      if (visited[ny][nx]){\n        continue;\n      }\n      que.emplace(mp(ny, nx));\n    }\n  }\n  return true;\n}\n\nbool check_escape(){\n  memset(visited, false, sizeof(visited));\n  for (const auto &goat : goats){\n    int y = goat.first;\n    int x = goat.second;\n    if (not bfs(y, x)){\n      return false;\n    }\n  }\n  return true;\n}\n\nint main() {\n  cin >> H >> W;\n  for (int i = 0; i < H; i++){\n    for (int j = 0; j < W; j++){\n      cin >> board[i][j];\n      if (board[i][j] == 'X'){\n        goats.emplace(mp(i, j));\n        if (i == 0 or i == H - 1){\n          cout << -1 << endl;\n          return 0;\n        }\n        if (j == 0 or j == W - 1){\n          cout << -1 << endl;\n          return 0;\n        }\n      }\n    }\n  }\n  for (int i = 0; i < H; i++){\n    for (int j = 0; j < W; j++){\n      if (board[i][j] == 'X'){\n        for (int k = 0; k < 4; k++){\n          int y = i + dy[k];\n          int x = j + dx[k];\n          if (y < 0 or y >= H or x < 0 or x >= W){\n            continue;\n          }\n          board[y][x] = 'F';\n          fences.emplace(mp(y, x));\n        }\n      }\n    }\n  }\n  debug_board();\n  int result = fences.size();\n  for (const auto &fence : fences){\n    int y,x;\n    y = fence.first;\n    x = fence.second;\n    board[y][x] = '.';\n    if (not check_escape()){\n      board[y][x] = 'F';\n    }else{\n      result--;\n    }\n  }\n  debug_board();\n  cout << result << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nint main(){\n\tint h,w;\n\tscanf(\"%d%d\",&h,&w);\n\tint a[h][w]={};\n\tfor(int i=0;i<h;i++){\n\t\tchar c[w];\n\t\tscanf(\"%s\",c);\n\t\tfor(int j=0;j<w;j++){\n\t\t\ta[i][j]=c[j];\n\t\t\tif(a[i][j]=='.'){\n\t\t\t\ta[i][j]=0;\n\t\t\t}else{\n\t\t\t\ta[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\tint q=1;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(a[i][j]==1){\n\t\t\t\tif(i==0 || i==h-1 || j==0 || j==w-1){\n\t\t\t\t\tq=0;\n\t\t\t\t}else{\n\t\t\t\t\ta[i+1][j]=2;\n\t\t\t\t\ta[i-1][j]=2;\n\t\t\t\t\ta[i][j-1]=2;\n\t\t\t\t\ta[i][j+1]=2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint y=0;\n\tif(q!=0){\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(a[i][j]==2){\n\t\t\t\t\tint l=0;\n\t\t\t\t\tint ll=0;\n\t\t\t\t\tint lll=0;\n\t\t\t\t\tint llll=0;\n\t\t\t\t\ty++;\n\t\t\t\t\tfor(int p=0;p<i;p++){\n\t\t\t\t\t\tif(a[p][j]==2){\n\t\t\t\t\t\t\tl=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int p=i+1;p<h;p++){\n\t\t\t\t\t\tif(a[p][j]==2){\n\t\t\t\t\t\t\tll=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int p=0;p<j;p++){\n\t\t\t\t\t\tif(a[i][p]==2){\n\t\t\t\t\t\t\tlll=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int p=j+1;p<w;p++){\n\t\t\t\t\t\tif(a[i][p]==2){\n\t\t\t\t\t\t\tllll=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(l+ll+lll+llll==4){\n\t\t\t\t\t\ta[i][j]=0;\n\t\t\t\t\t\ty--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(q==0){\n\t\tint g=-1;\n\t\tprintf(\"%d\\n\",g);\n\t}else{\n\t\tprintf(\"%d\\n\",y);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n\nusing namespace std;\n\n#define MOD @\n#define ADD(X,Y) ((X) = ((X) + (Y)) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint H, W;\nchar C[101][101];\n\nnamespace MF {\n#define MAXN 100000\n#define MAXM 100000\n#define wint int\nconst wint wEPS = 0;\nconst wint wINF = 1001001001;\nint n, m, ptr[MAXN], next[MAXM], zu[MAXM];\nwint capa[MAXM], tof;\nint lev[MAXN], see[MAXN], que[MAXN], *qb, *qe;\nvoid init(int _n) {\n\tn = _n; m = 0; memset(ptr, ~0, n * 4);\n}\nvoid ae(int u, int v, wint w0, wint w1 = 0) {\n\tnext[m] = ptr[u]; ptr[u] = m; zu[m] = v; capa[m] = w0; ++m;\n\tnext[m] = ptr[v]; ptr[v] = m; zu[m] = u; capa[m] = w1; ++m;\n}\nwint augment(int src, int ink, wint flo) {\n\tif (src == ink) return flo;\n\twint f;\n\tfor (int &i = see[src]; ~i; i = next[i]) if (capa[i] > wEPS && lev[src] < lev[zu[i]]) {\n\t\tif ((f = augment(zu[i], ink, min(flo, capa[i]))) > wEPS) {\n\t\t\tcapa[i] -= f; capa[i ^ 1] += f; return f;\n\t\t}\n\t}\n\treturn 0;\n}\nbool solve(int src, int ink, wint flo = wINF) {\n\twint f;\n\tint i, u, v;\n\tfor (tof = 0; tof + wEPS < flo; ) {\n\t\tqb = qe = que;\n\t\tmemset(lev, ~0, n * 4);\n\t\tfor (lev[*qe++ = src] = 0, see[src] = ptr[src]; qb != qe; ) {\n\t\t\tfor (i = ptr[u = *qb++]; ~i; i = next[i]) if (capa[i] > wEPS && !~lev[v = zu[i]]) {\n\t\t\t\tlev[*qe++ = v] = lev[u] + 1; see[v] = ptr[v];\n\t\t\t\tif (v == ink) goto au;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\tau:\tfor (; (f = augment(src, ink, flo - tof)) > wEPS; tof += f);\n\t}\n\treturn 1;\n}\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &H, &W);\n\tfor (int i = 0; i < H; ++i) scanf(\"%s\", C[i]);\n\tfor (int i = 0; i < H; ++i) for (int j = 0; j < W; ++j) {\n\t\tif ((i == 0 || i == H - 1 || j == 0 || j == W - 1) && C[i][j] == 'X') {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tMF::init(2 * H * W + 2);\n\tint s = 2 * H * W;\n\tint t = s + 1;\n\tauto idx = [H, W, t](int y, int x) {\n\t\tif (y < 0 || y == H || x < 0 || x == W) return t;\n\t\treturn 2 * (y * W + x);\n\t};\n\tint dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\n\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tif (C[i][j] == 'X') {\n\t\t\t\tMF::ae(s, idx(i, j) + 1, 100);\n\t\t\t} else {\n\t\t\t\tMF::ae(idx(i, j), idx(i, j) + 1, 1);\n\t\t\t}\n\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\tMF::ae(idx(i, j) + 1, idx(i + dx[k], j + dy[k]), 100);\n\t\t\t}\n\t\t}\n\t}\n\tMF::solve(s, t);\n\tprintf(\"%d\\n\", MF::tof);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n     File Name: 1.cpp\n     ID: Liusiyu\n     BLOG: http://blog.csdn.net/r_o_j \n     LANG: C++ \n     Mail: 779532360@qq.com \n     Created Time: 2016年10月03日 星期一 17时01分20秒\n ************************************************************************/\n#include<bits/stdc++.h>\n#define MEM(a,x) memset(a,x,sizeof(a));\n#define MEMINF(a) memset(a,0x3f,sizeof(a));\nusing namespace std;\ntypedef long long LL;\nconst int MAXN=1e5+10;\nconst int MAXM=2e5+20;\nconst int INF=0x3f3f3f3f;\nconst int MOD=1000000007;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nstruct MaxFlow{  \n    int head[MAXN];  \n    struct Edge{  \n        int u,v,nex,cap,flow;  \n    }edge[MAXM];  \n    int tot;\n    int s,t;\n    int dis[MAXN];  \n    int cur[MAXN];  \n    void Dinic_init(int s,int t){  \n        this->s=s;\n        this->t=t;  \n        MEM(head,-1);  \n        tot=0;  \n    }  \n    void Addedge(int u,int v,int w) {  \n        edge[tot].v=v,edge[tot].cap=w,edge[tot].flow=0,edge[tot].nex=head[u],head[u]=tot++;  \n        edge[tot].v=u,edge[tot].cap=0,edge[tot].flow=0,edge[tot].nex=head[v],head[v]=tot++;  \n    }  \n    bool bfs() {  \n        MEM(dis,-1);  \n        queue<int>q;  \n        dis[s]=0;  \n        q.push(s);  \n        while (!q.empty()) {  \n            int u=q.front();  \n            q.pop();  \n            for (int i=head[u]; ~i; i=edge[i].nex) {  \n                int v=edge[i].v;  \n                if (edge[i].cap>edge[i].flow&&dis[v]==-1) {  \n                    q.push(v);  \n                    dis[v]=dis[u]+1;  \n                }  \n            }  \n        }  \n        return dis[t]!=-1;  \n    }  \n    int dfs(int u,int delta) {  \n        if (u==t||delta==0)  \n            return delta;  \n            int ret=0;  \n            int aug;  \n            for(int &i=cur[u]; ~i; i=edge[i].nex) {  \n                int v=edge[i].v;  \n                if (dis[v]==dis[u]+1&&(aug=dfs(v,min(edge[i].cap-edge[i].flow,delta)))>0) {  \n                    edge[i].flow+=aug;  \n                    edge[i^1].flow-=aug;  \n                    delta-=aug;  \n                    ret+=aug;  \n                    if (delta==0) break;  \n                }  \n            }  \n            //dis[u]=-1;\n            return ret;  \n    }  \n    void dinic() {  \n        int ret=0;  \n        while(bfs()) {  \n            memcpy(cur,head,sizeof head);  \n            ret+=dfs(s,INF);  \n        }  \n        cout<<ret<<endl;  \n     }  \n}nima; \nint n,m;\nint zb(int i,int j) {\n  return (i*m+j)*2;\n}\nchar mp[110][110];\nint main() {\n  int T,S;\n  cin>>n>>m;\n  S=n*m*2+1;\n  T=S-1;\n  nima.Dinic_init(T,S);\n  for (int i=0; i<n; ++i) {\n    scanf(\"%s\",mp[i]);\n  }\n\n  for (int i=0; i<n; ++i) {\n    if (mp[i][0]=='X'||mp[i][m-1]=='X') {\n      puts(\"-1\");\n      return 0;\n    }\n    nima.Addedge(T,zb(i,0),INF);\n    nima.Addedge(T,zb(i,m-1),INF);\n  }\n  for (int i=0; i<m; ++i) {\n    if (mp[0][i]=='X'||mp[m-1][n]=='X') {\n      puts(\"-1\");\n      return 0;\n    }\n    nima.Addedge(T,zb(0,i),INF);\n    nima.Addedge(T,zb(n-1,i),INF);\n  }\n  for (int i=0; i<n; ++i) \n    for (int j=0; j<m; ++j) {\n      if (mp[i][j]=='X') nima.Addedge(zb(i,j),S,INF);\n      else {\n        nima.Addedge(zb(i,j),zb(i,j)+1,1);\n      }\n      for (int k=0; k<4; ++k) {\n        int x=i+dx[k];\n        int y=j+dy[k];\n        if (x<0||x>=n||y<0||y>=m)continue;\n        nima.Addedge(zb(i,j)+1,zb(x,y),INF);\n      }\n    }\n  nima.dinic();\n}\n\n        \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105],z[105][105];\nbool fr[105][105],vis[105][105],st,ad,f;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,3){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==3){\n\t\t\t\t\tad = 0, f = 1;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,3){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==3){\n\t\t\t\t\tad = 0, f = 1;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n\tif(ans-9==191)cout<<ans-9<<endl;\n\telse cout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <utility>\n#include <functional>\n#include <deque>\n#include <cctype>\n#include <stack>\n#include <bitset>\n#include <set>\n\nusing ll = long long;\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\nconst ll MOD = 1000000007;\nconst ll INF = 1 << 30;\nconst ll INF2 = 9000000000000000000LL;\nconst double INF3 = 900000000000000;\nconst int dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\nconst int tx[8] = { -1,0,1,-1,1,-1,0,1 }, ty[8] = { -1,-1,-1,0,0,1,1,1 };\n#define ALL(x) (x).begin(),(x).end()\n\n\nstruct edge { ll to, cap, rev; };\n\nvector<edge>g[101000];\nbool used[101000] = { 0 };\n\nvoid add(ll from, ll to, ll cap) {\n\tg[from].push_back(edge{ to, cap, (ll)g[to].size() });\n\tg[to].push_back(edge{ from, (ll)0, (ll)g[from].size() - 1 });\n}\n\nll dfs(ll v, ll t, ll f) {\n\tif (v == t)return f;\n\tused[v] = true;\n\tfor (int i = 0;i < g[v].size();i++) {\n\t\tedge &e = g[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tg[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nll max_flow(ll s, ll t) {\n\tll flow = 0;\n\tfor (;;) {\n\t\tfill(used, used + 100000, 0);\n\t\tll f = dfs(s, t, INF);\n\t\tif (f == 0)return flow;\n\t\tflow += f;\n\t}\n}\n\n\n\nint main() {\n\tchar mp[110][110];\n\tint w, h;\n\tcin >> h >> w;\n\tfor (int i = 0;i < h;i++) {\n\t\tfor (int j = 0;j < w;j++) {\n\t\t\tcin >> mp[i][j];\n\t\t}\n\t}\n\n\tint s = 2 * h*w, t = s + 1;\n\tfor (int i = 0;i < h;i++) {\n\t\tfor (int j = 0;j < w;j++) {\n\t\t\tif (mp[i][j] == 'X') {\n\t\t\t\tadd(s, i*w + j, INF);\n\t\t\t\tadd(i*w + j, i*w + j + h*w, INF);\n\t\t\t}\n\t\t\telse add(i*w + j, i*w + j + h*w, 1);\n\t\t\tfor (int k = 0;k < 4;k++) {\n\t\t\t\tint ni = i + dy[k], nj = j + dx[k];\n\t\t\t\tif (ni < 0 || ni >= h || nj < 0 || nj >= w)add(i*w + j + w*h, t, INF);\n\t\t\t\telse add(i*w + j + w*h, ni*w + nj, INF);\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = max_flow(s, t);\n\tif (ans == INF) cout << -1 << endl;\n\telse cout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar t[200][200];\nint H,W;\n\nvoid dfs(int y,int x){\n  if(y<0 || x<0 || y>=200 || x>=200 )return;\n  if(t[y][x]=='@')return;\n  if(t[y][x]=='?')return;\n\n  if(t[y][x]=='#'){\n    t[y][x]='@';\n    return;\n  }\n\n  t[y][x]='?';\n\n  dfs(y+1,x);\n  dfs(y-1,x);\n  dfs(y,x+1);\n  dfs(y,x-1);\n}\n\nint main(){\n  cin>>H>>W;\n  for(int i=1;i<=H;i++){\n    for(int j=1;j<=W;j++){\n      cin>>t[i][j];\n\n      if(t[i][j]=='X'){\n        if(i==1||j==1||i==H||j==W){\n          cout<<-1<<endl;\n          return 0;\n        }\n      }\n    }\n  }\n\n  for(int i=1;i<=H;i++){\n    for(int j=1;j<=W;j++){\n      if(t[i][j]=='X'){\n        if(t[i+1][j]=='.')t[i+1][j]='#';\n        if(t[i-1][j]=='.')t[i-1][j]='#';\n        if(t[i][j+1]=='.')t[i][j+1]='#';\n        if(t[i][j-1]=='.')t[i][j-1]='#';\n      }\n    }\n  }\n\n  dfs(0,0);\n  int cnt=0;\n  for(int i=1;i<=H;i++){\n    for(int j=1;j<=W;j++){\n      if(t[i][j]=='@')cnt++;\n    }\n  }\n  cout<<cnt<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nconst bool debug = false;\n\nusing namespace std;\ntypedef long long int ll;\n\n#define rep(x, a, b) for (size_t x = a; x < b; x++)\n#ifdef DEBUG\n#define show(name) cout << #name \" = \" << name << endl\n#else\n#define show(name)\n#endif\n\nstruct edge {\n  int next, weight;\n  edge(int next, int weight): next(next), weight(weight){};\n};\n\nint idx(int r, int c, int h, int w, int io, int d = 0, int end = 0) {\n  int dr[] = {0, +1, -1, 0, 0};\n  int dc[] = {0, 0, 0, +1, -1};\n\n  switch (d) {\n  case 0: break;\n  case 1: if (r == h - 1) return end; break;\n  case 2: if (r == 0) return end; break;\n  case 3: if (c == w - 1) return end; break;\n  case 4: if (c == 0) return end; break;\n  }\n\n  return ((r + dr[d]) * w + c + dc[d]) * 2 + io;\n}\n\nconst int toolarge = 2000000;\n\nint dfs(vector<vector<edge>> &graph, vector<bool> &visit, int init, int end, int flow) {\n  if (init == end)\n    return flow;\n  \n  visit[init] = true;\n  \n  for (auto &e : graph[init]) {\n    if (visit[e.next] || e.weight == 0) continue;\n\n    int d = dfs(graph, visit, e.next, end, min(e.weight, flow));\n\n    if (d > 0) {\n      e.weight -= d;\n      for (auto &b : graph[e.next]) {\n        if (b.next == init) {\n          b.weight += d;\n        }\n      }\n\n      visit[init] = false;\n\n      return d;\n    }\n  }\n\n  visit[init] = false;\n\n  return 0;\n}\n\nint maxflow(vector<vector<edge>> &graph, int init, int end) {\n  vector<bool> visit(graph.size(), false);\n  int flow = 0;\n  int d = 0;\n\n  while ((d = dfs(graph, visit, init, end, toolarge)) > 0)\n    flow += d;\n\n  return flow;\n}\n\nint main()\n{\n  size_t h, w;\n  cin >> h >> w;\n\n  vector<string> map(h);\n\n  rep (i, 0, h) {\n    cin >> map[i];\n  }\n\n  bool impossible = false;\n\n  rep (i, 0, h)\n    impossible |= (map[i][0] == 'X' || map[i][w - 1] == 'X');\n\n  rep (i, 0, w)\n    impossible |= (map[0][i] == 'X' || map[h - 1][i] == 'X');\n\n  if (impossible && false) {\n    cout << -1 << endl;\n    return 0;\n  }\n\n  int init = h * w * 2;\n  int end = h * w * 2 + 1;\n  vector<vector<edge>> graph(h * w * 2 + 2);\n\n  rep (r, 0, h) rep (c, 0, w) {\n    graph[idx(r, c, h, w, 0)].emplace_back(idx(r, c, h, w, 1), 1);\n    graph[idx(r, c, h, w, 1)].emplace_back(idx(r, c, h, w, 0), 0);\n    \n    rep(d, 1, 5) {\n      graph[idx(r, c, h, w, 1)].emplace_back(idx(r, c, h, w, 0, d, end), toolarge);\n      graph[idx(r, c, h, w, 0, d, end)].emplace_back(idx(r, c, h, w, 1), 0);\n    }\n  }\n\n  rep (r, 0, h) rep (c, 0, w)\n    if (map[r][c] == 'X') {\n      graph[init].emplace_back(idx(r, c, h, w, 1), 4);\n      graph[idx(r, c, h, w, 1)].emplace_back(init, 0);\n    }\n\n  if (debug)\n  rep (i, 0, graph.size()) {\n    cout << i << \" ->\";\n\n    for (auto n : graph[i]) {\n      cout << \" <\" << n.next << \", \" << n.weight << \">\";\n    }\n\n    cout << endl;\n  }\n\n  cout << maxflow(graph, init, end) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint W,H;\nstring S[100];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint grid[114][114];\nvoid end()\n{\n\tprintf(\"-1\\n\");\n}\nint main()\n{\n\tscanf(\"%d%d\",&H,&W);\n\tfor(int i=0;i<H;i++){\n\t\tcin >> S[i];\n\t\tfor(int j=0;j<W;j++){\n\t\t\tif(S[i][j]=='.')grid[i][j]=0;\n\t\t\telse grid[i][j]=1;\n\t\t}\n\t}\n\tfor(int i=0;i<H;i++){\n\t\tif(grid[i][0]==1){\n\t\t\tend();return 0;\n\t\t}\n\t\tif(grid[i][W-1]==1){\n\t\t\tend();return 0;\n\t\t}\n\t}\n\tfor(int i=0;i<W;i++){\n\t\tif(grid[0][i]==1){\n\t\t\tend();return 0;\n\t\t}\n\t\tif(grid[H-1][i]==1){\n\t\t\tend();return 0;\n\t\t}\n\t}\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tif(grid[i][j]==1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(grid[i+dx[k]][j+dy[k]]==0){\n\t\t\t\t\t\tgrid[i+dx[k]][j+dy[k]]=2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tif(grid[i][j]==2){\n\t\t\t\tbool F=false;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(i+dx[k]<0||i+dx[k]>=H||j+dy[k]<0||j+dy[k]>=W)F=true;\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(grid[i+dx[k]][j+dy[k]]==0)F=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(F)ans++;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<unordered_set>\n#include<vector>\n#include<array>\n#include<string>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n#include<functional>\n#include<random>\n#include<complex>\n//#include<boost/multiprecision/cpp_int.hpp>\n#define int int64_t\n#define REP(i, a, b) for (int64_t i = (int64_t)(a); i < (int64_t)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (auto x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define Min(x) *min_element(ALL(x))\n#define Max(x) *max_element(ALL(x))\n#define Unique(L) (L.erase(unique(ALL(L)), L.end()))\nusing namespace std;\n//typedef boost::multiprecision::cpp_int bigint;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nclass graph_adjacentry {\nprivate:\n\tvector<vector<int>>matrix;\npublic:\n\tgraph_adjacentry(const int V) :matrix(V, vector<int>(V, 0)) {}\n\n\tvoid add_edge(const int from, const int to, const int weight) {\n\t\tmatrix[from][to] = weight;\n\t}\n\tvoid add_edge_undirected(const int x, const int y, const int weight) {\n\t\tmatrix[x][y] = weight;\n\t\tmatrix[y][x] = weight;\n\t}\n\n\tint get_weight(const int from, const int to)const {\n\t\treturn matrix[from][to];\n\t}\n\tint get_V()const { return matrix.size(); }\n};\nclass graph_sparse {\nprivate:\n\tvector<unordered_map<int, int>>edges;\npublic:\n\tgraph_sparse(const int V) :edges(V, unordered_map<int, int>(V)) {}\n\n\tvoid add_edge(const int from, const int to, const int weight) {\n\t\tedges[from][to] = weight;\n\t}\n\tvoid add_edge_undirected(const int x, const int y, const int weight) {\n\t\tedges[x][y] = weight;\n\t\tedges[y][x] = weight;\n\t}\n\n\tint get_weight(const int from, const int to)const {\n\t\tconst auto itr = edges[from].find(to);\n\t\tif (itr != edges[from].end())return itr->second;\n\t\treturn 0;\n\t}\n\tint get_V()const { return edges.size(); }\n};\nclass graph_key {\nprivate:\n\tunordered_map<string, int>names;\n\tvector<unordered_map<int, int>>edges;\npublic:\n\n\tvoid add_edge(const string from, const string to, const int weight) {\n\t\tint f, t;\n\t\tconst auto itr1 = names.find(from);\n\t\tconst auto itr2 = names.find(to);\n\n\t\tif (itr1 == names.end()) {\n\t\t\tf = edges.size();\n\t\t\tedges.resize(f + 1);\n\t\t}\n\t\telse f = itr1->second;\n\n\t\tif (itr2 == names.end()) {\n\t\t\tt = edges.size();\n\t\t\tedges.resize(t + 1);\n\t\t}\n\t\telse t = itr2->second;\n\n\t\tedges[f][t] = weight;\n\t}\n\tvoid add_edge_undirected(const string x, const string y, const int weight) {\n\t\tint a, b;\n\t\tconst auto itr1 = names.find(x);\n\t\tconst auto itr2 = names.find(y);\n\n\t\tif (itr1 == names.end()) {\n\t\t\ta = edges.size();\n\t\t\tedges.resize(a + 1);\n\t\t}\n\t\telse a = itr1->second;\n\n\t\tif (itr2 == names.end()) {\n\t\t\tb = edges.size();\n\t\t\tedges.resize(b + 1);\n\t\t}\n\t\telse b = itr2->second;\n\n\t\tedges[a][b] = weight;\n\t\tedges[b][a] = weight;\n\t}\n\n\n\tint get_weight(const string from, const string to)const {\n\n\t\tint f, t;\n\t\tconst auto itr1 = names.find(from);\n\t\tconst auto itr2 = names.find(to);\n\t\tif (itr1 == names.end())return 0;\n\t\telse f = itr1->second;\n\t\tif (itr2 == names.end())return 0;\n\t\telse t = itr2->second;\n\n\t\tconst auto itr = edges[f].find(t);\n\t\tif (itr != edges[f].end())return itr->second;\n\t\treturn 0;\n\t}\n\tint get_V()const { return edges.size(); }\n};\n\n\nint max_flow_push_relabel(\n\tconst int source,\n\tconst int sink,\n\tconst graph_sparse &capacity) {\n\n\tconst int V = capacity.get_V();\n\tconst int INF = 99999999;\n\n\tvector<int>h(V);\n\th[source] = V - 1;\n\n\tvector<int>maxh(V);\n\n\tgraph_sparse f(V);\n\tvector<int>e(V);\n\n\trep(i, V) {\n\t\tint c = capacity.get_weight(source, i);\n\t\tf.add_edge(source, i, c);//f[source][i] = cap[source][i];\n\t\tf.add_edge(i, source, -c);//f[i][source] = -f[source][i];\n\t\te[i] = c;\n\t}\n\n\tfor (int sz = 0;;) {\n\t\tif (sz == 0)rep(i, V) {\n\t\t\tif (i != source && i != sink && e[i] > 0) {\n\t\t\t\tif (sz != 0 && h[i] > h[maxh[0]])sz = 0;\n\t\t\t\tmaxh[sz++] = i;\n\t\t\t}\n\t\t}\n\t\tif (sz == 0)break;\n\t\twhile (sz != 0) {\n\t\t\tint i = maxh[sz - 1];\n\t\t\tbool pushed = false;\n\t\t\tfor (int j = 0; j < V && e[i] != 0; ++j) {\n\t\t\t\tint dw = capacity.get_weight(i, j) - f.get_weight(i, j);\n\t\t\t\tif (h[i] == h[j] + 1 && dw > 0) {\n\t\t\t\t\tint df = min(dw, e[i]);\n\t\t\t\t\tf.add_edge(i, j, f.get_weight(i, j) + df);\n\t\t\t\t\tf.add_edge(j, i, f.get_weight(j, i) - df);\n\t\t\t\t\te[i] -= df;\n\t\t\t\t\te[j] += df;\n\t\t\t\t\tif (e[i] == 0)--sz;\n\t\t\t\t\tpushed = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!pushed) {\n\t\t\t\th[i] = INF;\n\t\t\t\tfor (int j = 0; j < V; ++j) {\n\t\t\t\t\tint dw = capacity.get_weight(i, j) - f.get_weight(i, j);\n\t\t\t\t\tif (h[i] > h[j] + 1 && dw > 0)h[i] = h[j] + 1;\n\t\t\t\t}\n\t\t\t\tif (h[i] > h[maxh[0]]) {\n\t\t\t\t\tsz = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint flow = 0;\n\tfor (int i = 0; i < V; i++)flow += f.get_weight(source, i);\n\n\treturn flow;\n}\n\nsigned main(void) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint H, W;\n\tcin >> H >> W;\n\tgraph_sparse g(H * W * 2 + 2);\n\tconst int source = H * W * 2, sink = source + 1;\n\tconst int D[5] = { 0,1,0,-1,0 };\n\tconst int INF = 99999999;\n\n\t//柵は辺を塞ぐのではなくマス目を塞ぐ。最小カット問題に落とし込むために、\n\t//グリッドを仮想的に表と裏の2つ用意する。\n\t//(1)ソース→ヤギのいる表座標、\n\t//(2)任意の表座標→その4近傍の裏座標、\n\t//(3)端っこの表座標→シンク\n\t//の3要素をキャパ無限でつなぎ、\n\t//(4)任意の裏座標→表の同じ座標 をキャパ1でつなぐ。\n\t//裏から表へのパスをカットすることが\"柵を置く\"ことに等しい。\n\trep(i, H) {\n\t\tstring S;\n\t\tcin >> S;\n\t\trep(j, W) {\n\t\t\tconst int pos = i * W + j;\n\t\t\tif (S[j] == 'X') {\n\t\t\t\tif (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tg.add_edge(source, pos, INF);//(1)\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n\t\t\t\t\tg.add_edge(pos, sink, INF);//(3)\n\t\t\t\t}\n\t\t\t}\n\t\t\tg.add_edge(pos + H * W, pos, 1);//(4)\n\t\t\trep(k, 4) {\n\t\t\t\tconst int di = i + D[k];\n\t\t\t\tconst int dj = j + D[k + 1];\n\t\t\t\tif (!(0 <= di && di < H && 0 <= dj && dj < W))continue;\n\t\t\t\tg.add_edge(pos, di * W + dj + H * W, INF);//(2)\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << max_flow_push_relabel(source, sink, g) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n\tif(ans-9==193)cout<<ans-9<<endl;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\telse cout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MODULE 1000000007\n#define MP make_pair\n\ntemplate<class T, class U>\ninline void chmin(T &t, U f) { if (t > f)t = f; }\n\ntemplate<class T, class U>\ninline void chmax(T &t, U f) { if (t < f)t = f; }\n\ntypedef pair<int, int> P;\ntypedef long long LL;\nconst int INF = INT_MAX / 2;    //int_max->2*e+9\nconst int MAXN = 100001;\n\n/*struct edge {\n    edge(int to, int cost) : to(to), cost(cost) {}\n    int to, cost;\n};\nvector<edge> graph[MAXN];*/\n\nint dx8[8] = {1, 1, 1, 0, -1, -1, -1, 0};\nint dy8[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nint dx4[4] = {0, 0, -1, 1};\nint dy4[4] = {-1, 1, 0, 0};\n//-----Template---------\n\nchar grid[101][101];\nint h, w, sakuCount = 0;\nstring tmp;\n\nbool isValidPos(int x, int y) {\n    return 0 <= x && x < w && 0 <= y && y < h;\n}\n//柵：#　外周柵：o　外周柵2:e　なし：.　チェック済み：x\nvoid putSaku(int x, int y) {\n    for (int i = 0; i < 4; ++i) {\n        int newX = x + dx4[i];\n        int newY = y + dy4[i];\n        if (isValidPos(newX,newY) && grid[newX][newY] != '#' && grid[newX][newY]!='X') {\n            grid[newX][newY] = '#';\n            sakuCount++;\n        }\n    }\n}\nvoid innerDFS(int x,int y){\n    if(grid[x][y]=='#'){\n        sakuCount--;\n    }\n    grid[x][y]='x';\n    for (int i = 0; i < 4; ++i) {\n        int newX = x + dx4[i];\n        int newY = y + dy4[i];\n        if (isValidPos(newX,newY) && (grid[newX][newY]!='o' && grid[newX][newY]!='e' && grid[newX][newY]!='x')){   //柵2,3でない，または調べ済みでないなら\n            innerDFS(newX,newY);\n        }\n    }\n}\nvoid deleteSaku(int x, int y) {\n    int nowX = x, nowY = y;\n    grid[x][y]='o';\n    int lastI=0;\n    bool flag=true;\n    while (flag) {\n        for (int i = 0; i < 8; ++i) {\n            int nowI = (lastI + i) % 8;\n            int tmpX= nowX + dx8[nowI];\n            int tmpY= nowY + dy8[nowI];\n            if (isValidPos(tmpX,tmpY) && grid[tmpX][tmpY]=='#'){//さくにきたら\n                grid[tmpX][tmpY]='o';\n                nowX=tmpX; nowY=tmpY; lastI=(nowI+4+1)%8; //更新\n                break;\n            }else if(isValidPos(tmpX,tmpY) && grid[tmpX][tmpY]=='o'){//1週したら\n                flag=false;\n                break;\n            }\n        }\n    }\n    flag=true;\n    nowX=x; nowY=y; lastI=0;\n    grid[x][y]='e';\n    while(flag){\n        for (int i = 0; i < 8; ++i) {\n            int nowI = (lastI + i) % 8;\n            int tmpX= nowX + dx8[nowI];\n            int tmpY= nowY + dy8[nowI];\n            if (isValidPos(tmpX,tmpY) && grid[tmpX][tmpY]=='o'){//まず外周探し\n                grid[tmpX][tmpY]='e';\n                innerDFS(nowX+dx8[(lastI+i+1)%8],nowY+dy8[(lastI+i+1)%8]); //1つ入ったところからDFS\n                nowX=tmpX; nowY=tmpY; lastI=(nowI+4+1)%8; //更新\n                break;\n            }else if(isValidPos(tmpX,tmpY) && grid[tmpX][tmpY]=='e'){\n                flag=false;\n                break;\n            }\n        }\n    }\n}\n\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin >> h >> w;\n    for(int j=0;j<h;++j){\n        for(int i=0;i<w;++i){\n            grid[i][j]='.';\n        }\n    }\n    bool cannotPlaceFlag=false;\n    for (int j = 0; j < h; ++j) {\n        cin >> tmp;\n        for (int i = 0; i < tmp.length(); ++i) {//==w\n            if (tmp[i] == 'X') {\n                if(i==0 || i==w-1 || j==0 || j==h-1)\n                    cannotPlaceFlag=true;\n\n                grid[i][j] = 'X';\n                putSaku(i, j);\n            }\n        }\n    }\n    if(!cannotPlaceFlag){\n        for (int j = 0; j < h; ++j) {\n            for (int i = 0; i < w; ++i) {\n                if (grid[i][j] == '#') {\n                    deleteSaku(i, j);\n                }\n            }\n        }\n        cout<<sakuCount<<endl;\n    }else{\n        cout<<-1<<endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 20000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstruct edge\n{\n\tint to,cap,rev;\n};\nvector<edge>G[20105];\nbool used[20105];\n\nvoid add_edge(int from,int to,int cap)\n{\n\tG[from].push_back((edge){to,cap,G[to].size()});\n\tG[to].push_back((edge){from,0,G[from].size()-1});\n}\nint dfs(int v,int t,int f)\n{ \n\tif(v==t) return f;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to] && e.cap>0)\n\t\t{ \n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0) \n\t\t\t{ \n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t)\n{ \n\tint flow=0;\n\twhile(1)\n\t{ \n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(!f) return flow;\n\t\tflow+=f;\n\t}\n}\nint n,m; char f[105][105];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++) scanf(\"%s\",&f[i]);\n\tint S = 20100,T = 20101;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(f[i][j] == 'X'){\n\t\t\t\tadd_edge(S,(i*m+j)*2,INF);\n\t\t\t\tadd_edge((i*m+j)*2,(i*m+j)*2+1,INF);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tadd_edge((i*m+j)*2,(i*m+j)*2+1,1);\n\t\t\t}\n\t\t\t\n\t\t\tif(i==0 || i==n-1 || j==0 || j==m-1){\n\t\t\t\tadd_edge((i*m+j)*2+1,T,INF);\n\t\t\t}\n\t\t\t\n\t\t\tint dx[4]={0,1,0,-1};\n\t\t\tint dy[4]={1,0,-1,0};\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tint nx = i+dx[k],ny = j+dy[k];\n\t\t\t\tif(!(0<=nx&&nx<n&&0<=ny&&ny<m)) continue;\n\t\t\t\tadd_edge((i*m+j)*2+1,(nx*m+ny)*2,INF);\n\t\t\t}\n\t\t}\n\t}int ans = max_flow(S,T); if(ans > n*m) ans = -1;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define all(x) x.begin(),x.end()\n#define SZ(x) (int)(x.size())\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,a,b) for(int i=b-1;i>=a;i--)\n#define inf 1000000007\n#define mod 1000000007\n#define x first\n#define y second\n#define pi acos(-1.0)\n#define DBG(x) cerr<<(#x)<<\"=\"<<x<<\"\\n\";\n//#define dprintf(...) \n#define hash _hash\n#define next _next\n//#define dprintf(...) fprintf(outFile,__VA_ARGS__)\n \n#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define ull unsigned long long\n#define ll long long\n#define N 100010\n \ntemplate <class T,class U>inline void Max(T &a,U b){if(a<b)a=b;}\ntemplate <class T,class U>inline void Min(T &a,U b){if(a>b)a=b;}\n \n//FILE* outFile;\ninline void add(int &a,int b){a+=b;while(a>=mod)a-=mod;}\n\n\nint pow(int a,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=ans*(ll)a%mod;\n        a=(ll)a*a%mod;b>>=1;\n    }\n    return ans;\n}\n\nchar s[110][110];\nstruct node{\n\tint v,c,next;\n}g[N<<1];\nint head[N],cnt,cur[N],d[N];\nvoid add(int a,int b,int c){\n\tg[cnt]={b,c,head[a]};head[a]=cnt++;\n\tg[cnt]={a,0,head[b]};head[b]=cnt++;\n}\nbool bfs(int s,int t){\n\trep(i,0,t+1)d[i]=-1,cur[i]=head[i];\n\tqueue<int>q;q.push(s);d[s]=0;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\tfor(int i=head[u];~i;i=g[i].next){\n\t\t\tint j=g[i].v;\n\t\t\tif(g[i].c&&d[j]==-1){\n\t\t\t\td[j]=d[u]+1;q.push(j);\n\t\t\t}\n\t\t}\n\t}\n\t//DBG(d[t])\n\treturn d[t]>=0;\n}\nint dfs(int u,int t,int lim){\n\tif(u==t||lim==0)return lim;\n\tint ans=0,f;\n\tfor(int &i=cur[u];~i;i=g[i].next){\n\t\tint j=g[i].v;\n\t\tif(d[j]==d[u]+1&&(f=dfs(j,t,min(g[i].c,lim)))){\n\t\t\tans+=f,lim-=f;\n\t\t\tg[i].c-=f,g[i^1].c+=f;\n\t\t\tif(lim==0)break;\n\t\t}\n\t}\n\td[u]=-1;\n\treturn ans;\n}\nint dinic(int s,int t){\n\tint ans=0;\n\twhile(bfs(s,t))ans+=dfs(s,t,inf);\n\treturn ans;\n}\nint n,m,dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nint get(int i,int j){return i*m+j;}\nint main(){\n    int T,i,j,k,ca=0,K;\n    //cout<<setprecision(10)<<fixed;\n    scanf(\"%d%d\",&n,&m);\n    rep(i,0,n)scanf(\"%s\",s[i]);\n    int S=n*m*2;T=S+1;\n    memset(head,-1,sizeof(head));\n    rep(i,0,n){\n    \tif(s[i][0]=='X'||s[i][m-1]=='X'){puts(\"-1\");return 0;}\n    \tadd(S,get(i,0)*2,inf);add(S,get(i,m-1)*2,inf);\n    }\n    rep(i,0,m){\n    \tif(s[0][i]=='X'||s[n-1][i]=='X'){puts(\"-1\");return 0;}\n    \tif(i&&i<m-1)add(S,get(0,i)*2,inf),add(S,get(n-1,i)*2,inf);\n    }\n    rep(i,0,n)rep(j,0,m){\n    \tif(s[i][j]=='X'){\n    \t\tadd(get(i,j)*2,T,inf);\n    \t}\n    \telse{\n    \t\tadd(get(i,j)*2,get(i,j)*2+1,1);\n    \t}\n    \trep(k,0,4){\n    \t\tint x=i+dx[k],y=j+dy[k];\n    \t\tif(x>=0&&x<n&&y>=0&&y<m)add(get(i,j)*2+1,get(x,y)*2,inf);\n    \t}\n    }\n    int ans=dinic(S,T);\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 30000\n#define INF 1e7\nusing namespace std;\n\nstruct edge{ int to,cap,rev; };\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nint flow_dfs(int v, int t, int f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i=0;i<(int)G[v].size();i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = flow_dfs(e.to,t,min(f,e.cap));\n      if(d > 0){\n        e.cap-= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  if(s == t) return INF;\n  int flow = 0;\n  while(1){\n    memset(used,0,sizeof(used));\n    int f = flow_dfs(s,t,INF);\n    if(f == 0) break;\n    flow += f;\n    if(flow >= INF)return INF;\n  }\n  return flow;\n}\n\n\n\nint main(){\n  char mp[100][100];\n  int w,h;\n  cin>>h>>w;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin>>mp[i][j];\n    }\n  }\n\n  int s=2*h*w,t=s+1;\n  int nx[4] = {0,1,0,-1},ny[4] = {-1,0,1,0};\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(mp[i][j] == 'X'){\n        add_edge(s,i*w+j,INF);\n        add_edge( i*w+j , i*w+j+h*w , INF );\n      }\n      else add_edge( i*w+j , i*w+j+h*w , 1 );\n      for(int k=0;k<4;k++){\n        int ni=i+ny[k],nj=j+nx[k];\n        if(ni<0 || ni>=h || nj<0 || nj>=w) add_edge(i*w+j+w*h,t,INF);\n        else add_edge(i*w+j+w*h,ni*w+nj,INF);\n      }\n    }\n  }\n\n  int ans = max_flow(s,t);\n  if(ans == INF) cout<<-1<<endl;\n  else cout<<ans<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<numeric>\n#include<functional>\n#include<algorithm>\n#include<bitset>\n#include<tuple>\n#include<unordered_set>\n#include<random>\n#include<array>\n#include<cassert>\nusing namespace std;\n#define INF (1<<29)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define uniq(v) v.erase(unique(all(v)),v.end())\n\n\n\n\n\n\n\n#define MAX_V 10002\n\nstruct edge{\n\tint to, cap, rev;\n\tedge(int a, int b, int c) :to(a), cap(b), rev(c){}\n};\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n\tG[from].push_back(edge(to, cap, G[to].size()));\n\tG[to].push_back(edge(from, 0, G[from].size() - 1));\n}\n//sからの最短距離をbfsで計算\nvoid bfs(int s){\n\tmemset(level, -1, sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty()){\n\t\tint v = que.front(); que.pop();\n\t\tfor (int i = 0; i<G[v].size(); i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0){\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n//増加パスをdfsで探す\nint dfs(int v, int t, int f){\n\tif (v == t)return f;\n\tfor (int &i = iter[v]; i<G[v].size(); i++){\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]){\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d>0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s, int t){\n\tint flow = 0;\n\tfor (;;){\n\t\tbfs(s);\n\t\tif (level[t]<0)return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tint f;\n\t\twhile ((f = dfs(s, t, INF))>0){\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\n\n\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint h,w;\n\tcin>>h>>w;\n\tvector<int> p;\n\n\trep(y,h)rep(x,w){\n\t\tchar c;\n\t\tcin>>c;\n\t\tif (c=='X'){\n\t\t\tif (y==0||y+1==h||x==0||x+1==w){\n\t\t\t\tcout<<-1<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tp.push_back(y*w+x);\n\t\t}\n\t\tif (0 < y){\n\t\t\tadd_edge(y*w + x, h*w + (y - 1)*w + x, INF);\n\t\t}\n\t\tif (y+1<h){\n\t\t\tadd_edge(y*w + x, h*w + (y + 1)*w + x, INF);\n\t\t}\n\t\tif (0 < x){\n\t\t\tadd_edge(y*w + x, h*w + y*w + x - 1, INF);\n\t\t}\n\t\tif (x+1<w){\n\t\t\tadd_edge(y*w + x, h*w + y*w + x+1, INF);\n\t\t}\n\t}\n\trep(i,h*w){\n\t\tadd_edge(h*w + i, i, 1);\n\t}\n\n\tint n=h*w*2;\n\tfor (int y=0;y<h;y++){\n\t\tadd_edge(y*w , n, INF);\n\t\tadd_edge(y*w+w-1, n, INF);\n\t}\n\tfor (int x = 1; x+1<w; x++){\n\t\tadd_edge(x, n, INF);\n\t\tadd_edge((h-1)*w + x, n, INF);\n\t}\n\trep(i,p.size()){\n\t\tadd_edge(n+1, p[i], INF);\n\t}\n\tcout<<max_flow(n+1,n)<<endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n// c++11\n#include <array>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n\n#define mp make_pair\n#define mt make_tuple\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\n\nconst int INF = 1 << 29;\nconst double EPS = 1e-9;\nconst ll MOD = 1000000007;\n\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\nconst int MAX_N = 110;\nint H,W;\nchar board[MAX_N][MAX_N];\nset<pii> goats;\nset<pii> fences;\nvoid debug_board(){\n  cerr << \"Debug board!!\" << endl;\n  for (int i = 0; i < H; i++){\n    for (int j = 0; j < W; j++){\n      cerr << board[i][j] << \" \";\n    }\n    cerr << endl;\n  }\n}\n\nbool visited[MAX_N][MAX_N];\nbool bfs(int sy, int sx){\n  queue<pii> que;\n  que.emplace(mp(sy, sx));\n  while (not que.empty()){\n    pii pos = que.front();\n    que.pop();\n    int py = pos.first;\n    int px = pos.second;\n    if (visited[py][px]){\n      continue;\n    }\n    visited[py][px] = true;\n    if (py == 0 or py == H - 1 or px == 0 or px == W - 1){\n      return false;\n    }\n    for (int k = 0; k < 4; k++){\n      int ny = py + dy[k];\n      int nx = px + dx[k];\n      if (ny < 0 or ny >= H or nx < 0 or nx >= W){\n        continue;\n      }\n      if (board[ny][nx] == 'F'){\n        continue;\n      }\n      if (visited[ny][nx]){\n        continue;\n      }\n      que.emplace(mp(ny, nx));\n    }\n  }\n  return true;\n}\n\nbool check_escape(){\n  memset(visited, false, sizeof(visited));\n  for (const auto &goat : goats){\n    int y = goat.first;\n    int x = goat.second;\n    if (not bfs(y, x)){\n      return false;\n    }\n  }\n  return true;\n}\n\nint main() {\n  cin >> H >> W;\n  for (int i = 0; i < H; i++){\n    for (int j = 0; j < W; j++){\n      cin >> board[i][j];\n      if (board[i][j] == 'X'){\n        goats.emplace(mp(i, j));\n        if (i == 0 or i == H - 1){\n          cout << -1 << endl;\n          return 0;\n        }\n        if (j == 0 or j == W - 1){\n          cout << -1 << endl;\n          return 0;\n        }\n      }\n    }\n  }\n  for (int i = 0; i < H; i++){\n    for (int j = 0; j < W; j++){\n      if (board[i][j] == 'X'){\n        for (int k = 0; k < 4; k++){\n          int y = i + dy[k];\n          int x = j + dx[k];\n          if (y < 0 or y >= H or x < 0 or x >= W){\n            continue;\n          }\n          if (board[i][j] == '.'){\n            board[y][x] = 'F';\n            fences.emplace(mp(y, x));\n          }\n        }\n      }\n    }\n  }\n  debug_board();\n  int result = fences.size();\n  for (const auto &fence : fences){\n    int y,x;\n    y = fence.first;\n    x = fence.second;\n    board[y][x] = '.';\n    if (not check_escape()){\n      board[y][x] = 'F';\n    }else{\n      result--;\n    }\n  }\n  debug_board();\n  cout << result << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint h, w;\nint a[102][102], f[102][102], v[102][102];\nint dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, 1, -1};\n\nbool isin(int i, int j){\n    return i >= 0 && j >= 0 && i < h && j < w;\n}\n\nvoid dfs(int i, int j){\n    v[i][j] = 1;\n    if (f[i][j]) return;\n    REP(k,4){\n        int ii = i+dx[k], jj = j+dy[k];\n        if (!isin(ii,jj) || v[ii][jj]) continue;\n        dfs(ii, jj);\n    }\n\n}\n\nint main() {\n    cin >> h >> w;\n    REP(i,h){\n        string s;\n        cin >> s;\n        REP(j,w) a[i+1][j+1] = (s[j] == 'X');\n    }\n\n    FOR(i,1,h){\n        if (a[i][1] || a[i][w]){\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n    FOR(i,1,w){\n        if (a[1][i] || a[h][i]){\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    h += 2;\n    w += 2;\n\n    REP(i,h){\n        REP(j,w){\n            if (a[i][j]){\n                REP(k,4) f[i+dx[k]][j+dy[k]] = 1; \n            }\n        }\n    }\n\n    dfs(0, 0);\n\n    int ans = 0;\n    REP(i,h){\n        REP(j,w){\n            if (f[i][j] && v[i][j]) ans++;\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntemplate <class Flow>\nclass MaxFlow {\n    public:\n    \n    MaxFlow(int n, Flow eps = 0, Flow inf = 1e9) : size(n), graph(n), EPS(eps), INF(inf) {\n        level = (int *)malloc(sizeof(int) * size);\n        iter = (int *)malloc(sizeof(int) * size);\n        que = (int *)malloc(sizeof(int) * size);\n    }\n    \n    ~MaxFlow() {\n        free(level);\n        free(iter);\n        free(que);\n    }\n    \n    void add_edge(int from, int to, Flow cap) {\n        graph[from].push_back(Edge(to, cap, graph[to].size()));\n        graph[to].push_back(Edge(from, 0, graph[from].size() - 1));\n    }\n    \n    void add_undirected_edge(int from, int to, Flow cap) {\n        graph[from].push_back(Edge(to, cap, graph[to].size()));\n        graph[to].push_back(Edge(from, cap, graph[from].size() - 1));\n    }\n    \n    Flow max_flow(int source, int sink) {\n        Flow flow = 0;\n        \n        while (1) {\n            bfs(source, sink);\n            \n            if (level[sink] == -1) return flow;\n            \n            for (int i = 0; i < size; i++) iter[i] = 0;\n            \n            flow += dfs(source, sink, INF);\n        }\n    }\n    \n    private:\n    \n    int size;\n    Flow EPS;\n    Flow INF;\n    int *level;\n    int *iter;\n    int *que;\n    \n    struct Edge {\n        int to;\n        Flow cap;\n        int rev;\n        Edge(int to, Flow cap, int rev) : to(to), cap(cap), rev(rev) {}\n    };\n    \n    vector <vector <Edge> > graph;\n    \n    void bfs(int from, int to) {\n        int qs = 0, qt = 0;\n        \n        for (int i = 0; i < size; i++) level[i] = -1;\n        \n        level[from] = 0;\n        que[qt++] = from;\n        \n        while (qs < qt && level[to] == -1) {\n            int now = que[qs++];\n            \n            for (int i = 0; i < graph[now].size(); i++) {\n                int next = graph[now][i].to;\n                \n                if (graph[now][i].cap > EPS && level[next] == -1) {\n                    level[next] = level[now] + 1;\n                    que[qt++] = next;\n                }\n            }\n        }\n    }\n    \n    Flow dfs(int from, int to, Flow cap) {\n        Flow flow = 0;\n        \n        if (from == to || cap <= EPS) return cap;\n        \n        for (int &i = iter[to]; i < graph[to].size(); i++) {\n            int next = graph[to][i].to;\n            Edge &edge = graph[next][graph[to][i].rev];\n            Flow res;\n            \n            if (edge.cap <= EPS || level[next] >= level[to]) continue;\n            \n            res = dfs(from, next, min(cap - flow, edge.cap));\n            \n            if (res <= EPS) continue;\n            \n            edge.cap -= res;\n            graph[to][i].cap += res;\n            flow += res;\n            \n            if (abs(flow - cap) <= EPS) break;\n        }\n        \n        return flow;\n    }\n};\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\nchar s[100][101];\n\nint main() {\n    int h, w, i, j, k;\n    \n    scanf(\"%d %d\", &h, &w);\n    \n    for (i = 0; i < h; i++) scanf(\"%s\", s[i]);\n    \n    MaxFlow <int> mf(h * w * 2 + 2);\n    \n    for (i = 0; i < h; i++) {\n        for (j = 0; j < w; j++) {\n            if (s[i][j] == 'X') {\n                for (k = 0; k < 4; k++) {\n                    int x = i + dx[k];\n                    int y = j + dy[k];\n                    \n                    if (x < 0 || x >= h || y < 0 || y >= w) {\n                        puts(\"-1\");\n                        \n                        return 0;\n                    }\n                }\n            }\n        }\n    }\n    \n    for (i = 0; i < h; i++) {\n        for (j = 0; j < w; j++) {\n            for (k = 0; k < 4; k++) {\n                int x = i + dx[k];\n                int y = j + dy[k];\n                \n                if (x < 0 || x >= h || y < 0 || y >= w) {\n                    mf.add_edge((i * w + j) * 2 + 1, h * w * 2 + 1, 1000);\n                } else {\n                    mf.add_edge((i * w + j) * 2 + 1, (x * w + y) * 2, 1000);\n                }\n            }\n            \n            if (s[i][j] == 'X') {\n                mf.add_edge(h * w * 2, (i * w + j) * 2 + 1, 1000);\n            } else {\n                mf.add_edge((i * w + j) * 2, (i * w + j) * 2 + 1, 1);\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", mf.max_flow(h * w * 2, h * w * 2 + 1));\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma warning(disable:4996)\n//#include <Windows.h>\n#include <iostream>\n#include <vector>\n#include <limits.h>\n#include <algorithm>\n#include <string>\n#include <math.h>\n#include <limits.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <bitset>\n#include <cassert>\n#include <random>\n#include <functional>\n#include <stack>\n#include <iomanip>\n#include <cassert>\n//#include <boost/multiprecision/cpp_int.hpp>\n#include <complex>\n#include <cstdio>\n#include <list>\n#include <bitset>\n//#include <stdio.h>\n\n//< in.txt > out.txt\nusing namespace std;\n//std::ios::sync_with_stdio(false);\n//std::cin.tie(0);\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e18;\ntypedef long long LL;\ntypedef long double LD;\n//typedef boost::multiprecision::cpp_int bigint;\ntypedef pair<LL, LL> PLL;\ntypedef pair<int, int> PI;\ntypedef pair<LD, LL> pdl;\ntypedef pair<LD, LD> pdd;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<int> VI;\ntypedef vector<vector<int>> VVI;\ntypedef unsigned long long ULL;\n\ntemplate<class T>\ninline void chmin(T& a, T b) {\n\ta = min(a, b);\n}\n\ntemplate<class T>\ninline void chmax(T& a, T b) {\n\ta = max(a, b);\n}\n\nvoid input();\nvoid solve();\n\nvoid daminput();\n\nint main() {\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tinput();\n\t//daminput();\n\tsolve();\n\treturn 0;\n}\n\n//////////////////////////////////////////////////\n//////////////////////////////////////////////////\n\nint H, W;\nvector<string> S;\n\nvoid input() {\n\tcin >> H >> W;\n\tS.resize(H);\n\tfor (int y = 0; y < H; y++)\n\t{\n\t\tcin >> S[y];\n\t}\n}\n\nvoid daminput() {\n}\n\ntemplate<class F>\nclass MaxFEdge {\npublic:\n\tint to;\n\tF cap;\n\tint rev;\n\tMaxFEdge(int _to, F _cap, int _rev) :to(_to), cap(_cap), rev(_rev) {}\n};\n\ntemplate<class F>\nclass Dinic {\npublic:\n\tint V;\n\tvector<vector<MaxFEdge<F>>> G;\n\tVI itr, level;\n\tDinic(int _v) :V(_v) {\n\t\tG.resize(V);\n\t}\n\tvoid AddEdge(int src, int to, F cap) {\n\t\tG[src].push_back(MaxFEdge<F>(to, cap, G[to].size()));\n\t\tG[to].push_back(MaxFEdge<F>(src, 0, G[src].size() - 1));\n\t}\n\tvoid bfs(int s) {\n\t\tlevel.assign(V, -1);\n\t\tqueue<int> q;\n\t\tlevel[s] = 0;\n\t\tq.push(s);\n\t\twhile (!q.empty()) {\n\t\t\tint v = q.front();\n\t\t\tq.pop();\n\t\t\tfor (auto& e : G[v]) {\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tF dfs(int v, int t, F f) {\n\t\tif (v == t)return f;\n\t\tF res = 0;\n\t\tfor (int& i = itr[v]; i < (int)G[v].size(); i++) {\n\t\t\tMaxFEdge<F>& e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tF d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\tres += d;\n\t\t\t\t\tf -= d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tF MaxFlow(int s, int t) {\n\t\tF res = 0;\n\t\tF f = 0;\n\t\tF inf = numeric_limits<F>::max();\n\t\twhile (true) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return res;\n\t\t\titr.assign(V, 0);\n\t\t\twhile (true) {\n\t\t\t\tf = dfs(s, t, inf);\n\t\t\t\tif (f <= 0)break;\n\t\t\t\tres += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nint conv(int y, int x, bool isout) {\n\tint res = y * W + x;\n\tres *= 2;\n\tif (isout)return res + 1;\n\telse return res;\n}\n\nint vect[4][2] = {\n\t{1,0},{-1,0},{0,1},{0,-1}\n};\n\nvoid solve() {\n\tDinic<int> D(2 * W * H + 2);\n\tfor (int y = 0; y < H; y++)\n\t{\n\t\tfor (int x = 0; x < W; x++)\n\t\t{\n\t\t\tif (S[y][x] != 'X') {\n\t\t\t\tD.AddEdge(conv(y, x, false), conv(y, x, true), 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tD.AddEdge(conv(y, x, false), conv(y, x, true), (int)1e6);\n\t\t\t}\n\t\t\tfor (int v = 0; v < 4; v++)\n\t\t\t{\n\t\t\t\tint nx = x + vect[v][1];\n\t\t\t\tint ny = y + vect[v][0];\n\t\t\t\tif (nx < 0 || nx >= W || ny < 0 || ny >= H) continue;\n\t\t\t\tD.AddEdge(conv(y, x, true), conv(ny, nx, false), (int)1e6);\n\t\t\t}\n\t\t\tif (S[y][x] == 'X') {\n\t\t\t\tD.AddEdge(2 * W * H, conv(y, x, false), (int)1e6);\n\t\t\t}\n\t\t\tif (x == 0 || x == W - 1 || y == 0 || y == H - 1) {\n\t\t\t\tD.AddEdge(conv(y, x, true), 2*W*H+1,(int)1e6);\n\t\t\t}\n\t\t}\n\t}\n\tint maxf = D.MaxFlow(2 * W * H, 2 * W * H + 1);\n\tif (maxf >= (int)1e6)cout << \"-1\\n\";\n\telse cout << maxf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\ntemplate <typename T> class Dinic {\n    struct edge {\n        int to, rev;\n        T cap;\n        bool isrev;\n        edge(int t, T c, int r, bool i) : to(t), cap(c), rev(r), isrev(i) {}\n    };\n\n    void bfs(int s, int t) {\n        lev.assign(g.size(), -1);\n        queue<int> que;\n        lev[s] = 0;\n        que.emplace(s);\n        while (!que.empty() && lev[t] == -1) {\n            int v = que.front();\n            que.pop();\n            for (edge& e : g[v]) {\n                if (lev[e.to] == -1 && e.cap > 0) {\n                    lev[e.to] = lev[v] + 1;\n                    que.emplace(e.to);\n                }\n            }\n        }\n    }\n\n    T dfs(int v, int t, T f) {\n        if (v == t) return f;\n        for (int& i = ite[v]; i < g[v].size(); ++i) {\n            edge& e = g[v][i];\n            if (e.cap > 0 && lev[v] < lev[e.to]) {\n                T d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    g[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n\n    const T INF;\n    vector<int> lev, ite;\n    vector<vector<edge>> g;\n\n    Dinic(int n) : INF(numeric_limits<T>::max()), g(n) {}\n\n    void add_edge(int f, int t, T c = numeric_limits<T>::max()) {\n        g[f].emplace_back(t, c, g[t].size(), false);\n        g[t].emplace_back(f, 0, g[f].size() - 1, true);\n    }\n\n    T max_flow(int s, int t) {\n        T res = 0;\n        while (1) {\n            bfs(s, t);\n            if (lev[t] < 0) break;\n            ite.assign(g.size(), 0);\n            T f = 0;\n            while ((f = dfs(s, t, INF)) > 0) {\n                res += f;\n            }\n        }\n        return res;\n    }\n\n    void print() {\n        for (int i = 0; i < g.size(); ++i) {\n            for (auto& e : g[i]) {\n                if (e.isrev) continue;\n                auto& rev_e = g[e.to][e.rev];\n                cout << i << \" -> \" << e.to << \" (flow: \" << rev_e.cap << \"/\" << e.cap + rev_e.cap << \")\" << endl;\n            }\n        }\n    }\n};\n\nconst int dy[] = {-1, 0, 0, 1};\nconst int dx[] = {0, -1, 1, 0};\nint H, W;\nstring S[100];\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> H >> W;\n    REP (i, H) cin >> S[i];\n    REP (i, H) if (S[i][0] == 'X' || S[i][W - 1] == 'X') {\n        cout << -1 << endl;\n        return 0;\n    }\n    REP (j, W) if (S[0][j] == 'X' || S[H - 1][j] == 'X') {\n        cout << -1 << endl;\n        return 0;\n    }\n    Dinic<int> g(2 * H * W + 2);\n    int s = 2 * H * W, t = s + 1;\n    REP (i, H) REP (j, W) {\n        if (S[i][j] == 'X') {\n            g.add_edge(s, 2 * (i * W + j) + 1);\n            g.add_edge(2 * (i * W + j), 2 * (i * W + j) + 1);\n        } else {\n            g.add_edge(2 * (i * W + j), 2 * (i * W + j) + 1, 1);\n        }\n        REP (k, 4) {\n            int ny = i + dy[k];\n            int nx = j + dx[k];\n            if (ny >= 0 && ny < H && nx >= 0 && nx < W) {\n                g.add_edge(2 * (i * W + j) + 1, 2 * (ny * W + nx));\n            }\n        }\n    }\n    REP (i, H) {\n        g.add_edge(2 * (i * W) + 1, t);\n        g.add_edge(2 * (i * W + W - 1) + 1, t);\n    }\n    REP (j, W) {\n        g.add_edge(2 * j + 1, t);\n        g.add_edge(2 * ((H - 1) * W + j) + 1, t);\n    }\n    cout << g.max_flow(s, t) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nconst int INF = 830252521;\n// Dinic http://www.prefield.com/algorithm/graph/dinic.html\nstruct dinic{\n  struct edge{int to;ll cost;};\n  int n;\n  vector< vector<edge> > G;\n  vector<vl> flow, capacity;\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n  vi level;\n  vector<bool> finished;\n  dinic(int _n){\n    n = _n;\n    G.assign(n,vector<edge>());\n    flow.assign(n,vl(n,0));\n    capacity.assign(n,vl(n,0));\n    level.assign(n,0);\n    finished.assign(n,false);\n  }\n  void add_edge(int from,int to,ll cost){\n    assert(0<=from && from<n);\n    assert(0<=to && to<n);\n    G[from].push_back((edge){to,cost});\n    G[to].push_back((edge){from,0ll});  // 逆に流すフローのためのダミー辺\n  }\n  ll dfs(int u, int t, ll cur){\n    if(u==t || cur==0) return cur;\n    if(finished[u]) return 0;\n    finished[u] = true;\n    REP(i,G[u].size()){\n      edge e = G[u][i];\n      if(level[e.to] > level[u]){\n        ll f = dfs(e.to, t, min(cur, RESIDUE(u,e.to)));\n        if(f>0){\n          flow[u][e.to] += f;\n          flow[e.to][u] -= f;\n          finished[u] = false;\n          return f;\n        }\n      }\n    }\n    return 0;\n  }\n  ll calc(int s, int t){\n    REP(i,n)REP(j,n)flow[i][j]=capacity[i][j]=0;\n    REP(u,n)REP(j,G[u].size()){\n      edge e = G[u][j];\n      capacity[u][e.to] += e.cost;\n    }\n    ll total = 0;\n    while(true){\n      REP(i,n)level[i] = -1;\n      level[s] = 0;\n      queue<int> Q; Q.push(s);\n      int d = n;\n      while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        REP(i,G[u].size()){\n          edge e = G[u][i];\n          if(RESIDUE(u,e.to) > 0 && level[e.to] == -1){\n            Q.push(e.to);\n            level[e.to] = level[u] + 1;\n          }\n        }\n      }\n      REP(i,n)finished[i]=false;\n      bool flag = false;\n      while(true){\n        ll f = dfs(s,t,INF);\n        if(f==0)break;\n        total += f;\n        flag = true;\n      }\n      if(!flag)break;\n    }\n    return total;\n  }\n};\n\nint h,w;\nchar mp[125][125];\nint dd[] = {1,0,-1,0,1};\n\nint main(){\n  scanf(\"%d%d\",&h,&w);\n  REP(i,h)scanf(\"%s\",mp[i]);\n  // flow\n  dinic g(2*h*w+2);\n  int s=2*h*w;\n  int t=2*h*w+1;\n  REP(i,h)REP(j,w){\n    int id = i*w + j;\n    int x=2*id,y=2*id+1;\n    if(mp[i][j]=='X'){\n      if(i==0||i==h-1||j==0||j==w-1){\n        puts(\"-1\");\n        return 0;\n      }\n      g.add_edge(s,x,INF);\n      g.add_edge(x,y,INF);\n    }else{\n      g.add_edge(x,y,1);\n    }\n    if(i==0||i==h-1||j==0||j==w-1){\n      g.add_edge(y,t,INF);\n    }\n    REP(d,4){\n      int ni=i+dd[d],nj=j+dd[d+1];\n      if(ni<0||ni>=h||nj<0||nj>=w)continue;\n      int nid = ni*w + nj;\n      g.add_edge(y,2*nid,INF);\n    }\n  }\n  printf(\"%lld\\n\",g.calc(s,t));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n#include <limits>\n#include <functional>\n#include <iomanip>\n#include <complex>\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER) || __cplusplus > 199711L\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) __typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\nusing namespace std;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }\ntypedef complex<double> P;\n\nint main(){\n\tint H,W;\n\tcin>>H>>W;\n\tvector<string> hoge(H);\n\trep(i,H)cin>>hoge[i];\n\tbool flag=true;\n\tfor(int i=0;i<H;i++){\n\t\tif(i==0||i==H-1){\n\t\t\trep(j,W)if(hoge[i][j]=='X')flag=false;\n\t\t}else{\n\t\t\tif(hoge[i][0]=='X')flag=false;\n\t\t\tif(hoge[i][W-1]=='X')flag=false;\n\t\t}\n\t}\n\tif(flag){\n\t\tvector<pii>data;\n\t\tint xmi=101,ymi=101,xma=-1,yma=-1;\n\t\tint a=202,b=202,c=-1,d=-202;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tif(hoge[i][j]=='X'){\n\t\t\t\t\ta=min(a,i+j);\n\t\t\t\t\tc=max(c,i+j);\n\t\t\t\t\tb=min(b,i-j);\n\t\t\t\t\td=max(d,i-j);\n\t\t\t\t\tdata.pb(mp(i,j));\n\t\t\t\t\txmi=min(xmi,i);\n\t\t\t\t\tymi=min(ymi,j);\n\t\t\t\t\txma=max(xma,i);\n\t\t\t\t\tyma=max(yma,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=2*(xma-xmi+1+yma-ymi+1);\n\t\ta=(a-xmi-ymi);\n\t\tb=(b+yma-xmi);\n\t\tc=(xma+yma-c);\n\t\td=(xma-ymi-d);\n\t\tans-=(a+b+c+d);\n\t\t//cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl;\n\t\tcout<<ans<<endl;\n\t}else{\n\t\tcout<<\"-1\"<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr,Vpr> PQ;\nconst int INF=1<<30;\nstruct Edge{\npublic:\n\tint to,cost,cp;\n\tEdge *rev;\n\tEdge(int t,int c,int cp):to(t),cost(c),cp(cp){\n\t\t\n\t}\n\tvoid add(int x){\n\t\tcp+=x;\n\t}\n\tvoid flow(int amount){\n\t\tadd(-amount);\n\t\trev->add(amount);\n\t}\n\tbool usable(){\n\t\treturn cp>=1;\n\t}\t\n};\nvoid unite(Edge &a,Edge &b){\n\ta.rev=&b;\n\tb.rev=&a;\n}\nclass Graph{\n\tint nodeSize,edgeSize;\n\tvector<int> dist;\n\tvector<vector<Edge> > edges;\npublic: \n\tvoid add(int a,int b,int cost,int cp){\n\t\tedges[a].PB(Edge(b,cost,cp));\n\t\tedges[b].PB(Edge(a,cost,0));\n\t\tunite(edges[a].back(),edges[b].back());\n\t}\n\tGraph(int x):nodeSize(x){\n\t\t\n\t\tedges=vector<vector<Edge> >(nodeSize);\n\t\tdist=VI(nodeSize);\n\t}\n\tvoid distInit(int s){\n\t\tREP(i,nodeSize){\n\t\t\tdist[i]=INF;\n\t\t}\n\t\tdist[s]=0;\n\t}\n\tint searching(int now,int e,int capacity){\n\t\tif(now==e) return capacity;\n\t\tif(capacity==0) return 0;\n\t\tif(dist[now]>=dist[e]) return 0;\n\t\tint flowed=0;\n\t\tREP(i,edges[now].size()){\n\t\t\tEdge *ed= &edges[now][i];\n\t\t\tif(!ed->usable()) continue;\n\t\t\tif(dist[now]+1 != dist[ed->to]) continue;\n\t\t\tint nflow=searching(ed->to,e,min(capacity-flowed,ed->cp));\n\t\t\tif(nflow){\n\t\t\t\tflowed+=nflow;\n\t\t\t\ted->flow(nflow);\n\t\t\t}\n\t\t}\n\t\treturn flowed;\n\t}\n\tbool bfs(int s,int e){\n\t\tdistInit(s);\n\t\tqueue<int> qu;\n\t\tqu.push(s);\n\t\twhile(!qu.empty()){\n\t\t\tint now=qu.front();\n\t\t\tif(now==e) return true;\n\t\t\tqu.pop();\n\t\t\tREP(i,edges[now].size()){\n\t\t\t\tEdge *ed= &edges[now][i];\n\t\t\t\tif(!ed->usable()) continue;\n\t\t\t\tif(dist[ed->to]==INF){\n\t\t\t\t\tqu.push(ed->to);\n\t\t\t\t\tdist[ed->to]=dist[now]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint maximumFlow(int s,int e){\n\t\tint ans=0;\n\t\twhile(bfs(s,e)){\n\t\t\treturn 0;\n\t\t\tans+=searching(s,e,INF);\n\t\t}\n\t\treturn ans;\n\t}\n};\nconst int SIZE=101;\nint conv(int a,int b,int c){return a*100+b+SIZE*SIZE*c+2;}\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\nint H,W;\nint maps[101][101];\nbool isSafe(int y,int x){\n\treturn 0<=y && y<H && 0<=x && x<W;\n}\nint main(){\n\tGraph graph(SIZE*SIZE*3+2);\n\tcin >> H >> W;\n\tREP(i,H) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,s.size()){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(maps[i][j] &&(i==0 || j==0 || i==H-1 || j==W-1)){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\t\t\n\t}\n\tREP(i,H) REP(j,W) {\n\t\tgraph.add(conv(i,j,1),conv(i,j,0),0,1);\n//\t\tedges[conv(i,j,1)].PB(edge(conv(i,j,0),0,1));\n\t\tif(maps[i][j]){\n\t\t\t//edges[0].PB(edge(conv(i,j,1),0,1));\n\t\t\tgraph.add(0,conv(i,j,0),0,4);\n\t\t}\n\t\tREP(k,4){\n\t\t\tif(!isSafe(i+dy[k],j+dx[k])){\n\t\t\tgraph.add(conv(i,j,0),1,0,1);\n\t\t\t//\tedges[conv(i,j,0)].PB(edge(1,0,1));\n\t\t\t} \n\t\t\telse if(!maps[i+dy[k]][j+dx[k]]){\n\t\t\t\tgraph.add(conv(i,j,0),conv(i+dy[k],j+dx[k],1),0,1);\n\t\t\t\tgraph.add(conv(i+dy[k],j+dx[k],0),conv(i,j,1),0,1);\n//\t\t\t\tedges[conv(i,j,0)].PB(edge(conv(i+dy[k],j+dx[k],1),0,1));\n//\t\t\t\tedges[conv(i+dy[k],j+dx[k],0)].PB(edge(conv(i,j,1),0,1));\n\t\t\t}\n\t\t}\n\t\n\t}\n\tcout << graph.maximumFlow(0,1) << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DBG(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n\nusing uint=unsigned int;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\tscanf(\"%d\",&i);\n\treturn i;\n}\n\nvoid Yes(){\n\tcout<<\"Yes\"<<endl;\n\texit(0);\n}\n\nvoid No(){\n\tcout<<\"No\"<<endl;\n\texit(0);\n}\n\ntemplate<class T>\nvoid chmax(T& a,T b){\n\ta=max(a,b);\n}\n\ntemplate<class T>\nvoid chmin(T& a,T b){\n\ta=min(a,b);\n}\n\ntemplate<class T>\nvoid ResetVector(vector<T>& v,int n,const T& t){\n\tv.clear();\n\tv.resize(n,t);\n}\n\nnamespace MaxFlow{\n\tusing CapType=int;\n\tconst CapType inf=1145141919;\n\tstruct Edge{\n\t\tint to,rev;\n\t\tCapType cap;\n\t};\n\tvector<vector<Edge>> g;\n\tvi itr,level;\n\tvoid Init(int n){\n\t\tResetVector(g,n,vector<Edge>());\n\t\tResetVector(itr,n,0);\n\t\tResetVector(level,n,0);\n\t}\n\tvoid AddEdge(int from,int to,CapType cap){\n\t\tg[from].PB({to,(int)g[to].size(),cap});\n\t\tg[to].PB({from,(int)g[from].size()-1,0});\n\t}\n\tvoid bfs(int s){\n\t\tfill(level.begin(),level.end(),-1);\n\t\tlevel[s]=0;\n\t\tqueue<int> q;\n\t\tq.push(s);\n\t\twhile(!q.empty()){\n\t\t\tint v=q.front();q.pop();\n\t\t\tfor(auto e:g[v])if(e.cap>0&&level[e.to]==-1){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n\tCapType dfs(int v,int t,CapType f){\n\t\tif(v==t)\n\t\t\treturn f;\n\t\tfor(int&i=itr[v];i<(int)g[v].size();i++){\n\t\t\tEdge& e=g[v][i];\n\t\t\tif(e.cap>0&&level[e.to]==level[v]+1){\n\t\t\t\tCapType d=dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tg[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tCapType Calc(int s,int t){\n\t\tCapType flow=0;\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(level[t]==-1)\n\t\t\t\treturn flow;\n\t\t\tfill(itr.begin(),itr.end(),0);\n\t\t\tCapType f;\n\t\t\twhile((f=dfs(s,t,inf))>0)\n\t\t\t\tflow+=f;\n\t\t}\n\t}\n}\n\nint main(){\n\tint h=read(),w=read();\n\tvector<string> board(h);\n\tREP(i,h)\n\t\tcin>>board[i];\n\tMaxFlow::Init(h*w*2+2);\n\tint s=h*w*2,t=s+1;\n\tREP(i,h)REP(j,w){\n\t\tint p=i*w+j,q=p+h*w;\n\t\tif(board[i][j]=='X'){\n\t\t\tif(i==0||i==h-1||j==0||j==w-1){\n\t\t\t\tcout<<-1<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tMaxFlow::AddEdge(s,p,MaxFlow::inf);\n\t\t\tMaxFlow::AddEdge(p,q,MaxFlow::inf);\n\t\t}else\n\t\t\tMaxFlow::AddEdge(p,q,1);\n\t\tif(i==0||i==h-1||j==0||j==w-1)\n\t\t\tMaxFlow::AddEdge(q,t,MaxFlow::inf);\n\t\tint dxy[]={0,-1,0,1,0};\n\t\tREP(k,4){\n\t\t\tint y=i+dxy[k+1],x=j+dxy[k];\n\t\t\tif(0<=y&&y<h&&0<=x&&x<w)\n\t\t\t\tMaxFlow::AddEdge(q,y*w+x,MaxFlow::inf);\n\t\t}\n\t}\n\tcout<<MaxFlow::Calc(s,t)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans-2<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint h,w;\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\ninline bool isRange(int i,int j){\n    return (0<=i && i<h && 0<=j && j<w);\n}\nvoid dfs(int i,int j,vector<string>& s){\n    s[i][j]='%';\n    for(int k=0;k<4;k++)\n        if(isRange(i+dy[k],j+dx[k]) && s[i+dy[k]][j+dx[k]]=='.')\n            dfs(i+dy[k],j+dx[k],s);\n    return;\n}\nint main(){\n    cin>>h>>w;\n    vector<string> s(h);\n    for(int i=0;i<h;i++)\n        cin>>s[i];\n    bool isok=true;\n    for(int i=0;i<h;i++)\n        for(int j=0;j<w && isok;j++){\n            if(s[i][j]=='X'){\n                for(int k=0;k<4;k++){\n                    if(!isRange(i+dy[k],j+dx[k])){\n                        isok=false;\n                        break;\n                    }\n                    if(s[i+dy[k]][j+dx[k]]!='X')\n                        s[i+dy[k]][j+dx[k]]='#';\n                }\n\n            }\n\n\n        }\n\n    if(!isok){\n        cout<<-1<<endl;\n        return 0;\n\n    }\n    for(int i=0;i<h;i++){\n        if(s[i][0]=='.')\n            dfs(i,0,s);\n        if(s[i][w-1]=='.')\n            dfs(i,w-1,s);\n\n  \n  }\n    for(int j=0;j<w;j++){\n        if(s[0][j]=='.')\n            dfs(0,j,s);\n        if(s[h-1][j]=='.')\n            dfs(h-1,j,s);\n\n\n    }\n\n    for(int i=0;i<h;i++)\n        for(int j=0;j<w;j++)\n            if(s[i][j]=='.')\n                s[i][j]='X';\n\n    bool renew=false;\n    do{\n        renew=false;\n        for(int i=0;i<h;i++)\n            for(int j=0;j<w;j++){\n                if(s[i][j]=='#'){\n                    bool removable=true;\n                    for(int k=0;k<4;k++){\n                        if(!isRange(i+dy[k],j+dx[k]) || s[i+dy[k]][j+dx[k]]=='%')\n                            removable=false;\n\n\n                    }\n                    if(removable)\n                        s[i][j]='X',renew=true;\n\n\n                }\n\n\n\n            }\n\n\n\n\n\n    }while(renew);\n    int res=0;\n    for(int i=0;i<h;i++)\n        for(int j=0;j<w;j++)\n            res+=(s[i][j]=='#');\n    cout<<res<<endl;\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param n `0 <= n`\n// @return minimum non-negative `x` s.t. `n <= 2**x`\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n\n// @param n `1 <= n`\n// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param m `1 <= m`\n// @return x mod m\nconstexpr long long safe_mod(long long x, long long m) {\n    x %= m;\n    if (x < 0) x += m;\n    return x;\n}\n\n// Fast moduler by barrett reduction\n// Reference: https://en.wikipedia.org/wiki/Barrett_reduction\n// NOTE: reconsider after Ice Lake\nstruct barrett {\n    unsigned int _m;\n    unsigned long long im;\n\n    // @param m `1 <= m`\n    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n\n    // @return m\n    unsigned int umod() const { return _m; }\n\n    // @param a `0 <= a < m`\n    // @param b `0 <= b < m`\n    // @return `a * b % m`\n    unsigned int mul(unsigned int a, unsigned int b) const {\n        // [1] m = 1\n        // a = b = im = 0, so okay\n\n        // [2] m >= 2\n        // im = ceil(2^64 / m)\n        // -> im * m = 2^64 + r (0 <= r < m)\n        // let z = a*b = c*m + d (0 <= c, d < m)\n        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im\n        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2\n        // ((ab * im) >> 64) == c or c + 1\n        unsigned long long z = a;\n        z *= b;\n#ifdef _MSC_VER\n        unsigned long long x;\n        _umul128(z, im, &x);\n#else\n        unsigned long long x =\n            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n        unsigned int v = (unsigned int)(z - x * _m);\n        if (_m <= v) v += _m;\n        return v;\n    }\n};\n\n// @param n `0 <= n`\n// @param m `1 <= m`\n// @return `(x ** n) % m`\nconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n    if (m == 1) return 0;\n    unsigned int _m = (unsigned int)(m);\n    unsigned long long r = 1;\n    unsigned long long y = safe_mod(x, m);\n    while (n) {\n        if (n & 1) r = (r * y) % _m;\n        y = (y * y) % _m;\n        n >>= 1;\n    }\n    return r;\n}\n\n// Reference:\n// M. Forisek and J. Jancina,\n// Fast Primality Testing for Integers That Fit into a Machine Word\n// @param n `0 <= n`\nconstexpr bool is_prime_constexpr(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 7 || n == 61) return true;\n    if (n % 2 == 0) return false;\n    long long d = n - 1;\n    while (d % 2 == 0) d /= 2;\n    for (long long a : {2, 7, 61}) {\n        long long t = d;\n        long long y = pow_mod_constexpr(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {\n            y = y * y % n;\n            t <<= 1;\n        }\n        if (y != n - 1 && t % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\ntemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\n\n// @param b `1 <= b`\n// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g\nconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n    a = safe_mod(a, b);\n    if (a == 0) return {b, 0};\n\n    // Contracts:\n    // [1] s - m0 * a = 0 (mod b)\n    // [2] t - m1 * a = 0 (mod b)\n    // [3] s * |m1| + t * |m0| <= b\n    long long s = b, t = a;\n    long long m0 = 0, m1 = 1;\n\n    while (t) {\n        long long u = s / t;\n        s -= t * u;\n        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n\n        // [3]:\n        // (s - t * u) * |m1| + t * |m0 - m1 * u|\n        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)\n        // = s * |m1| + t * |m0| <= b\n\n        auto tmp = s;\n        s = t;\n        t = tmp;\n        tmp = m0;\n        m0 = m1;\n        m1 = tmp;\n    }\n    // by [3]: |m0| <= b/g\n    // by g != b: |m0| < b/g\n    if (m0 < 0) m0 += b / s;\n    return {s, m0};\n}\n\n// Compile time primitive root\n// @param m must be prime\n// @return primitive root (and minimum in now)\nconstexpr int primitive_root_constexpr(int m) {\n    if (m == 2) return 1;\n    if (m == 167772161) return 3;\n    if (m == 469762049) return 3;\n    if (m == 754974721) return 11;\n    if (m == 998244353) return 3;\n    int divs[20] = {};\n    divs[0] = 2;\n    int cnt = 1;\n    int x = (m - 1) / 2;\n    while (x % 2 == 0) x /= 2;\n    for (int i = 3; (long long)(i)*i <= x; i += 2) {\n        if (x % i == 0) {\n            divs[cnt++] = i;\n            while (x % i == 0) {\n                x /= i;\n            }\n        }\n    }\n    if (x > 1) {\n        divs[cnt++] = x;\n    }\n    for (int g = 2;; g++) {\n        bool ok = true;\n        for (int i = 0; i < cnt; i++) {\n            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) return g;\n    }\n}\ntemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n\nnamespace internal {\n\n#ifndef _MSC_VER\ntemplate <class T>\nusing is_signed_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\n                                  std::is_same<T, __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\n                                  std::is_same<T, unsigned __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing make_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value,\n                              __uint128_t,\n                              unsigned __int128>;\n\ntemplate <class T>\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\n                                                  is_signed_int128<T>::value ||\n                                                  is_unsigned_int128<T>::value,\n                                              std::true_type,\n                                              std::false_type>::type;\n\ntemplate <class T>\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                 std::is_signed<T>::value) ||\n                                                    is_signed_int128<T>::value,\n                                                std::true_type,\n                                                std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<(is_integral<T>::value &&\n                               std::is_unsigned<T>::value) ||\n                                  is_unsigned_int128<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<\n    is_signed_int128<T>::value,\n    make_unsigned_int128<T>,\n    typename std::conditional<std::is_signed<T>::value,\n                              std::make_unsigned<T>,\n                              std::common_type<T>>::type>::type;\n\n#else\n\ntemplate <class T> using is_integral = typename std::is_integral<T>;\n\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<is_integral<T>::value &&\n                                  std::is_unsigned<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\n                                              std::make_unsigned<T>,\n                                              std::common_type<T>>::type;\n\n#endif\n\ntemplate <class T>\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n\ntemplate <class T>\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\nnamespace internal {\n\nstruct modint_base {};\nstruct static_modint_base : modint_base {};\n\ntemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\ntemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n\n}  // namespace internal\n\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\nstruct static_modint : internal::static_modint_base {\n    using mint = static_modint;\n\n  public:\n    static constexpr int mod() { return m; }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    static_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    static_modint(T v) {\n        long long x = (long long)(v % (long long)(umod()));\n        if (x < 0) x += umod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    static_modint(T v) {\n        _v = (unsigned int)(v % umod());\n    }\n    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v -= rhs._v;\n        if (_v >= umod()) _v += umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        unsigned long long z = _v;\n        z *= rhs._v;\n        _v = (unsigned int)(z % umod());\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        if (prime) {\n            assert(_v);\n            return pow(umod() - 2);\n        } else {\n            auto eg = internal::inv_gcd(_v, m);\n            assert(eg.first == 1);\n            return eg.second;\n        }\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static constexpr unsigned int umod() { return m; }\n    static constexpr bool prime = internal::is_prime<m>;\n};\n\ntemplate <int id> struct dynamic_modint : internal::modint_base {\n    using mint = dynamic_modint;\n\n  public:\n    static int mod() { return (int)(bt.umod()); }\n    static void set_mod(int m) {\n        assert(1 <= m);\n        bt = internal::barrett(m);\n    }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    dynamic_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        long long x = (long long)(v % (long long)(mod()));\n        if (x < 0) x += mod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        _v = (unsigned int)(v % mod());\n    }\n    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v += mod() - rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        _v = bt.mul(_v, rhs._v);\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        auto eg = internal::inv_gcd(_v, mod());\n        assert(eg.first == 1);\n        return eg.second;\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static internal::barrett bt;\n    static unsigned int umod() { return bt.umod(); }\n};\ntemplate <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n\nusing modint998244353 = static_modint<998244353>;\nusing modint1000000007 = static_modint<1000000007>;\nusing modint = dynamic_modint<-1>;\n\nnamespace internal {\n\ntemplate <class T>\nusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n\ntemplate <class T>\nusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n\ntemplate <class> struct is_dynamic_modint : public std::false_type {};\ntemplate <int id>\nstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n\ntemplate <class T>\nusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n\n    static bool first = true;\n    static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_e[i] = es[i] * now;\n            now *= ies[i];\n        }\n    }\n    for (int ph = 1; ph <= h; ph++) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint now = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p] * now;\n                a[i + offset] = l + r;\n                a[i + offset + p] = l - r;\n            }\n            now *= sum_e[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly_inv(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n\n    static bool first = true;\n    static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_ie[i] = ies[i] * now;\n            now *= es[i];\n        }\n    }\n\n    for (int ph = h; ph >= 1; ph--) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint inow = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p];\n                a[i + offset] = l + r;\n                a[i + offset + p] =\n                    (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                    inow.val();\n            }\n            inow *= sum_ie[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n\n}  // namespace internal\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nstd::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    if (std::min(n, m) <= 60) {\n        if (n < m) {\n            std::swap(n, m);\n            std::swap(a, b);\n        }\n        std::vector<mint> ans(n + m - 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                ans[i + j] += a[i] * b[j];\n            }\n        }\n        return ans;\n    }\n    int z = 1 << internal::ceil_pow2(n + m - 1);\n    a.resize(z);\n    internal::butterfly(a);\n    b.resize(z);\n    internal::butterfly(b);\n    for (int i = 0; i < z; i++) {\n        a[i] *= b[i];\n    }\n    internal::butterfly_inv(a);\n    a.resize(n + m - 1);\n    mint iz = mint(z).inv();\n    for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n    return a;\n}\n\ntemplate <unsigned int mod = 998244353,\n          class T,\n          std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\nstd::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n\n    using mint = static_modint<mod>;\n    std::vector<mint> a2(n), b2(m);\n    for (int i = 0; i < n; i++) {\n        a2[i] = mint(a[i]);\n    }\n    for (int i = 0; i < m; i++) {\n        b2[i] = mint(b[i]);\n    }\n    auto c2 = convolution(move(a2), move(b2));\n    std::vector<T> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        c[i] = c2[i].val();\n    }\n    return c;\n}\n\nstd::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                      const std::vector<long long>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n\n    static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n    static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n    static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n    static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n    static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n    static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n    static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n\n    static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n    static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n    static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n\n    auto c1 = convolution<MOD1>(a, b);\n    auto c2 = convolution<MOD2>(a, b);\n    auto c3 = convolution<MOD3>(a, b);\n\n    std::vector<long long> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        unsigned long long x = 0;\n        x += (c1[i] * i1) % MOD1 * M2M3;\n        x += (c2[i] * i2) % MOD2 * M1M3;\n        x += (c3[i] * i3) % MOD3 * M1M2;\n        // B = 2^63, -B <= x, r(real value) < B\n        // (x, x - M, x - 2M, or x - 3M) = r (mod 2B)\n        // r = c1[i] (mod MOD1)\n        // focus on MOD1\n        // r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B)\n        // r = x,\n        //     x - M' + (0 or 2B),\n        //     x - 2M' + (0, 2B or 4B),\n        //     x - 3M' + (0, 2B, 4B or 6B) (without mod!)\n        // (r - x) = 0, (0)\n        //           - M' + (0 or 2B), (1)\n        //           -2M' + (0 or 2B or 4B), (2)\n        //           -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1)\n        // we checked that\n        //   ((1) mod MOD1) mod 5 = 2\n        //   ((2) mod MOD1) mod 5 = 3\n        //   ((3) mod MOD1) mod 5 = 4\n        long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n        if (diff < 0) diff += MOD1;\n        static constexpr unsigned long long offset[5] = {\n            0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n        x -= offset[diff % 5];\n        c[i] = x;\n    }\n\n    return c;\n}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Implement (union by size) + (path compression)\n// Reference:\n// Zvi Galil and Giuseppe F. Italiano,\n// Data structures and algorithms for disjoint set union problems\nstruct dsu {\n  public:\n    dsu() : _n(0) {}\n    dsu(int n) : _n(n), parent_or_size(n, -1) {}\n\n    int merge(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        int x = leader(a), y = leader(b);\n        if (x == y) return x;\n        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n        parent_or_size[x] += parent_or_size[y];\n        parent_or_size[y] = x;\n        return x;\n    }\n\n    bool same(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        return leader(a) == leader(b);\n    }\n\n    int leader(int a) {\n        assert(0 <= a && a < _n);\n        if (parent_or_size[a] < 0) return a;\n        return parent_or_size[a] = leader(parent_or_size[a]);\n    }\n\n    int size(int a) {\n        assert(0 <= a && a < _n);\n        return -parent_or_size[leader(a)];\n    }\n\n    std::vector<std::vector<int>> groups() {\n        std::vector<int> leader_buf(_n), group_size(_n);\n        for (int i = 0; i < _n; i++) {\n            leader_buf[i] = leader(i);\n            group_size[leader_buf[i]]++;\n        }\n        std::vector<std::vector<int>> result(_n);\n        for (int i = 0; i < _n; i++) {\n            result[i].reserve(group_size[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            result[leader_buf[i]].push_back(i);\n        }\n        result.erase(\n            std::remove_if(result.begin(), result.end(),\n                           [&](const std::vector<int>& v) { return v.empty(); }),\n            result.end());\n        return result;\n    }\n\n  private:\n    int _n;\n    // root node: -1 * component size\n    // otherwise: parent\n    std::vector<int> parent_or_size;\n};\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Reference: https://en.wikipedia.org/wiki/Fenwick_tree\ntemplate <class T> struct fenwick_tree {\n    using U = internal::to_unsigned_t<T>;\n\n  public:\n    fenwick_tree() : _n(0) {}\n    fenwick_tree(int n) : _n(n), data(n) {}\n\n    void add(int p, T x) {\n        assert(0 <= p && p < _n);\n        p++;\n        while (p <= _n) {\n            data[p - 1] += U(x);\n            p += p & -p;\n        }\n    }\n\n    T sum(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        return sum(r) - sum(l);\n    }\n\n  private:\n    int _n;\n    std::vector<U> data;\n\n    U sum(int r) {\n        U s = 0;\n        while (r > 0) {\n            s += data[r - 1];\n            r -= r & -r;\n        }\n        return s;\n    }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n\ntemplate <class S,\n          S (*op)(S, S),\n          S (*e)(),\n          class F,\n          S (*mapping)(F, S),\n          F (*composition)(F, F),\n          F (*id)()>\nstruct lazy_segtree {\n  public:\n    lazy_segtree() : lazy_segtree(0) {}\n    lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n    lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        lz = std::vector<F>(size, id());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        return d[p];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return e();\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push(r >> i);\n        }\n\n        S sml = e(), smr = e();\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    void apply(int p, F f) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = mapping(f, d[p]);\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    void apply(int l, int r, F f) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return;\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n\n        {\n            int l2 = l, r2 = r;\n            while (l < r) {\n                if (l & 1) all_apply(l++, f);\n                if (r & 1) all_apply(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n\n        for (int i = 1; i <= log; i++) {\n            if (((l >> i) << i) != l) update(l >> i);\n            if (((r >> i) << i) != r) update((r - 1) >> i);\n        }\n    }\n\n    template <bool (*g)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return g(x); });\n    }\n    template <class G> int max_right(int l, G g) {\n        assert(0 <= l && l <= _n);\n        assert(g(e()));\n        if (l == _n) return _n;\n        l += size;\n        for (int i = log; i >= 1; i--) push(l >> i);\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!g(op(sm, d[l]))) {\n                while (l < size) {\n                    push(l);\n                    l = (2 * l);\n                    if (g(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*g)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return g(x); });\n    }\n    template <class G> int min_left(int r, G g) {\n        assert(0 <= r && r <= _n);\n        assert(g(e()));\n        if (r == 0) return 0;\n        r += size;\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!g(op(d[r], sm))) {\n                while (r < size) {\n                    push(r);\n                    r = (2 * r + 1);\n                    if (g(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    std::vector<F> lz;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    void all_apply(int k, F f) {\n        d[k] = mapping(f, d[k]);\n        if (k < size) lz[k] = composition(f, lz[k]);\n    }\n    void push(int k) {\n        all_apply(2 * k, lz[k]);\n        all_apply(2 * k + 1, lz[k]);\n        lz[k] = id();\n    }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\nnamespace atcoder {\n\nlong long pow_mod(long long x, long long n, int m) {\n    assert(0 <= n && 1 <= m);\n    if (m == 1) return 0;\n    internal::barrett bt((unsigned int)(m));\n    unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n    while (n) {\n        if (n & 1) r = bt.mul(r, y);\n        y = bt.mul(y, y);\n        n >>= 1;\n    }\n    return r;\n}\n\nlong long inv_mod(long long x, long long m) {\n    assert(1 <= m);\n    auto z = internal::inv_gcd(x, m);\n    assert(z.first == 1);\n    return z.second;\n}\n\n// (rem, mod)\nstd::pair<long long, long long> crt(const std::vector<long long>& r,\n                                    const std::vector<long long>& m) {\n    assert(r.size() == m.size());\n    int n = int(r.size());\n    // Contracts: 0 <= r0 < m0\n    long long r0 = 0, m0 = 1;\n    for (int i = 0; i < n; i++) {\n        assert(1 <= m[i]);\n        long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n        if (m0 < m1) {\n            std::swap(r0, r1);\n            std::swap(m0, m1);\n        }\n        if (m0 % m1 == 0) {\n            if (r0 % m1 != r1) return {0, 0};\n            continue;\n        }\n        // assume: m0 > m1, lcm(m0, m1) >= 2 * max(m0, m1)\n\n        // (r0, m0), (r1, m1) -> (r2, m2 = lcm(m0, m1));\n        // r2 % m0 = r0\n        // r2 % m1 = r1\n        // -> (r0 + x*m0) % m1 = r1\n        // -> x*u0*g % (u1*g) = (r1 - r0) (u0*g = m0, u1*g = m1)\n        // -> x = (r1 - r0) / g * inv(u0) (mod u1)\n\n        // im = inv(u0) (mod u1) (0 <= im < u1)\n        long long g, im;\n        std::tie(g, im) = internal::inv_gcd(m0, m1);\n\n        long long u1 = (m1 / g);\n        // |r1 - r0| < (m0 + m1) <= lcm(m0, m1)\n        if ((r1 - r0) % g) return {0, 0};\n\n        // u1 * u1 <= m1 * m1 / g / g <= m0 * m1 / g = lcm(m0, m1)\n        long long x = (r1 - r0) / g % u1 * im % u1;\n\n        // |r0| + |m0 * x|\n        // < m0 + m0 * (u1 - 1)\n        // = m0 + m0 * m1 / g - m0\n        // = lcm(m0, m1)\n        r0 += x * m0;\n        m0 *= u1;  // -> lcm(m0, m1)\n        if (r0 < 0) r0 += m0;\n    }\n    return {r0, m0};\n}\n\nlong long floor_sum(long long n, long long m, long long a, long long b) {\n    long long ans = 0;\n    if (a >= m) {\n        ans += (n - 1) * n * (a / m) / 2;\n        a %= m;\n    }\n    if (b >= m) {\n        ans += n * (b / m);\n        b %= m;\n    }\n\n    long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n    if (y_max == 0) return ans;\n    ans += (n - (x_max + a - 1) / a) * y_max;\n    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n    return ans;\n}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class T> struct simple_queue {\n    std::vector<T> payload;\n    int pos = 0;\n    void reserve(int n) { payload.reserve(n); }\n    int size() const { return int(payload.size()) - pos; }\n    bool empty() const { return pos == int(payload.size()); }\n    void push(const T& t) { payload.push_back(t); }\n    T& front() { return payload[pos]; }\n    void clear() {\n        payload.clear();\n        pos = 0;\n    }\n    void pop() { pos++; }\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class Cap> struct mf_graph {\n  public:\n    mf_graph() : _n(0) {}\n    mf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        assert(0 <= cap);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result;\n        for (int i = 0; i < m; i++) {\n            result.push_back(get_edge(i));\n        }\n        return result;\n    }\n    void change_edge(int i, Cap new_cap, Cap new_flow) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        assert(0 <= new_flow && new_flow <= new_cap);\n        auto& _e = g[pos[i].first][pos[i].second];\n        auto& _re = g[_e.to][_e.rev];\n        _e.cap = new_cap - new_flow;\n        _re.cap = new_flow;\n    }\n\n    Cap flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    Cap flow(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n\n        std::vector<int> level(_n), iter(_n);\n        internal::simple_queue<int> que;\n\n        auto bfs = [&]() {\n            std::fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            que.clear();\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front();\n                que.pop();\n                for (auto e : g[v]) {\n                    if (e.cap == 0 || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    if (e.to == t) return;\n                    que.push(e.to);\n                }\n            }\n        };\n        auto dfs = [&](auto self, int v, Cap up) {\n            if (v == s) return up;\n            Cap res = 0;\n            int level_v = level[v];\n            for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                _edge& e = g[v][i];\n                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                if (d <= 0) continue;\n                g[v][i].cap += d;\n                g[e.to][e.rev].cap -= d;\n                res += d;\n                if (res == up) break;\n            }\n            return res;\n        };\n\n        Cap flow = 0;\n        while (flow < flow_limit) {\n            bfs();\n            if (level[t] == -1) break;\n            std::fill(iter.begin(), iter.end(), 0);\n            while (flow < flow_limit) {\n                Cap f = dfs(dfs, t, flow_limit - flow);\n                if (!f) break;\n                flow += f;\n            }\n        }\n        return flow;\n    }\n\n    std::vector<bool> min_cut(int s) {\n        std::vector<bool> visited(_n);\n        internal::simple_queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int p = que.front();\n            que.pop();\n            visited[p] = true;\n            for (auto e : g[p]) {\n                if (e.cap && !visited[e.to]) {\n                    visited[e.to] = true;\n                    que.push(e.to);\n                }\n            }\n        }\n        return visited;\n    }\n\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class Cap, class Cost> struct mcf_graph {\n  public:\n    mcf_graph() {}\n    mcf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap, Cost cost) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n        Cost cost;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{\n            pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n        };\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result(m);\n        for (int i = 0; i < m; i++) {\n            result[i] = get_edge(i);\n        }\n        return result;\n    }\n\n    std::pair<Cap, Cost> flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n        return slope(s, t, flow_limit).back();\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n        return slope(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        assert(s != t);\n        // variants (C = maxcost):\n        // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0\n        // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge\n        std::vector<Cost> dual(_n, 0), dist(_n);\n        std::vector<int> pv(_n), pe(_n);\n        std::vector<bool> vis(_n);\n        auto dual_ref = [&]() {\n            std::fill(dist.begin(), dist.end(),\n                      std::numeric_limits<Cost>::max());\n            std::fill(pv.begin(), pv.end(), -1);\n            std::fill(pe.begin(), pe.end(), -1);\n            std::fill(vis.begin(), vis.end(), false);\n            struct Q {\n                Cost key;\n                int to;\n                bool operator<(Q r) const { return key > r.key; }\n            };\n            std::priority_queue<Q> que;\n            dist[s] = 0;\n            que.push(Q{0, s});\n            while (!que.empty()) {\n                int v = que.top().to;\n                que.pop();\n                if (vis[v]) continue;\n                vis[v] = true;\n                if (v == t) break;\n                // dist[v] = shortest(s, v) + dual[s] - dual[v]\n                // dist[v] >= 0 (all reduced cost are positive)\n                // dist[v] <= (n-1)C\n                for (int i = 0; i < int(g[v].size()); i++) {\n                    auto e = g[v][i];\n                    if (vis[e.to] || !e.cap) continue;\n                    // |-dual[e.to] + dual[v]| <= (n-1)C\n                    // cost <= C - -(n-1)C + 0 = nC\n                    Cost cost = e.cost - dual[e.to] + dual[v];\n                    if (dist[e.to] - dist[v] > cost) {\n                        dist[e.to] = dist[v] + cost;\n                        pv[e.to] = v;\n                        pe[e.to] = i;\n                        que.push(Q{dist[e.to], e.to});\n                    }\n                }\n            }\n            if (!vis[t]) {\n                return false;\n            }\n\n            for (int v = 0; v < _n; v++) {\n                if (!vis[v]) continue;\n                // dual[v] = dual[v] - dist[t] + dist[v]\n                //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) + (shortest(s, v) + dual[s] - dual[v])\n                //         = - shortest(s, t) + dual[t] + shortest(s, v)\n                //         = shortest(s, v) - shortest(s, t) >= 0 - (n-1)C\n                dual[v] -= dist[t] - dist[v];\n            }\n            return true;\n        };\n        Cap flow = 0;\n        Cost cost = 0, prev_cost = -1;\n        std::vector<std::pair<Cap, Cost>> result;\n        result.push_back({flow, cost});\n        while (flow < flow_limit) {\n            if (!dual_ref()) break;\n            Cap c = flow_limit - flow;\n            for (int v = t; v != s; v = pv[v]) {\n                c = std::min(c, g[pv[v]][pe[v]].cap);\n            }\n            for (int v = t; v != s; v = pv[v]) {\n                auto& e = g[pv[v]][pe[v]];\n                e.cap -= c;\n                g[v][e.rev].cap += c;\n            }\n            Cost d = -dual[s];\n            flow += c;\n            cost += c * d;\n            if (prev_cost == d) {\n                result.pop_back();\n            }\n            result.push_back({flow, cost});\n            prev_cost = cost;\n        }\n        return result;\n    }\n\n  private:\n    int _n;\n\n    struct _edge {\n        int to, rev;\n        Cap cap;\n        Cost cost;\n    };\n\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\nnamespace internal {\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\nstruct scc_graph {\n  public:\n    scc_graph() : internal(0) {}\n    scc_graph(int n) : internal(n) {}\n\n    void add_edge(int from, int to) {\n        int n = internal.num_vertices();\n        assert(0 <= from && from < n);\n        assert(0 <= to && to < n);\n        internal.add_edge(from, to);\n    }\n\n    std::vector<std::vector<int>> scc() { return internal.scc(); }\n\n  private:\n    internal::scc_graph internal;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\n  public:\n    segtree() : segtree(0) {}\n    segtree(int n) : segtree(std::vector<S>(n, e())) {}\n    segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    template <bool (*f)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F> int max_right(int l, F f) {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*f)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F> int min_left(int r, F f) {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\nstd::vector<int> sa_naive(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n        if (l == r) return false;\n        while (l < n && r < n) {\n            if (s[l] != s[r]) return s[l] < s[r];\n            l++;\n            r++;\n        }\n        return l == n;\n    });\n    return sa;\n}\n\nstd::vector<int> sa_doubling(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n), rnk = s, tmp(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    for (int k = 1; k < n; k *= 2) {\n        auto cmp = [&](int x, int y) {\n            if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n            int rx = x + k < n ? rnk[x + k] : -1;\n            int ry = y + k < n ? rnk[y + k] : -1;\n            return rx < ry;\n        };\n        std::sort(sa.begin(), sa.end(), cmp);\n        tmp[sa[0]] = 0;\n        for (int i = 1; i < n; i++) {\n            tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n        }\n        std::swap(tmp, rnk);\n    }\n    return sa;\n}\n\n// SA-IS, linear-time suffix array construction\n// Reference:\n// G. Nong, S. Zhang, and W. H. Chan,\n// Two Efficient Algorithms for Linear Time Suffix Array Construction\ntemplate <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\nstd::vector<int> sa_is(const std::vector<int>& s, int upper) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    if (n == 1) return {0};\n    if (n == 2) {\n        if (s[0] < s[1]) {\n            return {0, 1};\n        } else {\n            return {1, 0};\n        }\n    }\n    if (n < THRESHOLD_NAIVE) {\n        return sa_naive(s);\n    }\n    if (n < THRESHOLD_DOUBLING) {\n        return sa_doubling(s);\n    }\n\n    std::vector<int> sa(n);\n    std::vector<bool> ls(n);\n    for (int i = n - 2; i >= 0; i--) {\n        ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n    }\n    std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n    for (int i = 0; i < n; i++) {\n        if (!ls[i]) {\n            sum_s[s[i]]++;\n        } else {\n            sum_l[s[i] + 1]++;\n        }\n    }\n    for (int i = 0; i <= upper; i++) {\n        sum_s[i] += sum_l[i];\n        if (i < upper) sum_l[i + 1] += sum_s[i];\n    }\n\n    auto induce = [&](const std::vector<int>& lms) {\n        std::fill(sa.begin(), sa.end(), -1);\n        std::vector<int> buf(upper + 1);\n        std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n        for (auto d : lms) {\n            if (d == n) continue;\n            sa[buf[s[d]]++] = d;\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        sa[buf[s[n - 1]]++] = n - 1;\n        for (int i = 0; i < n; i++) {\n            int v = sa[i];\n            if (v >= 1 && !ls[v - 1]) {\n                sa[buf[s[v - 1]]++] = v - 1;\n            }\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        for (int i = n - 1; i >= 0; i--) {\n            int v = sa[i];\n            if (v >= 1 && ls[v - 1]) {\n                sa[--buf[s[v - 1] + 1]] = v - 1;\n            }\n        }\n    };\n\n    std::vector<int> lms_map(n + 1, -1);\n    int m = 0;\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms_map[i] = m++;\n        }\n    }\n    std::vector<int> lms;\n    lms.reserve(m);\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms.push_back(i);\n        }\n    }\n\n    induce(lms);\n\n    if (m) {\n        std::vector<int> sorted_lms;\n        sorted_lms.reserve(m);\n        for (int v : sa) {\n            if (lms_map[v] != -1) sorted_lms.push_back(v);\n        }\n        std::vector<int> rec_s(m);\n        int rec_upper = 0;\n        rec_s[lms_map[sorted_lms[0]]] = 0;\n        for (int i = 1; i < m; i++) {\n            int l = sorted_lms[i - 1], r = sorted_lms[i];\n            int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n            int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n            bool same = true;\n            if (end_l - l != end_r - r) {\n                same = false;\n            } else {\n                while (l < end_l) {\n                    if (s[l] != s[r]) {\n                        break;\n                    }\n                    l++;\n                    r++;\n                }\n                if (l == n || s[l] != s[r]) same = false;\n            }\n            if (!same) rec_upper++;\n            rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n        }\n\n        auto rec_sa =\n            sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n\n        for (int i = 0; i < m; i++) {\n            sorted_lms[i] = lms[rec_sa[i]];\n        }\n        induce(sorted_lms);\n    }\n    return sa;\n}\n\n}  // namespace internal\n\nstd::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n    assert(0 <= upper);\n    for (int d : s) {\n        assert(0 <= d && d <= upper);\n    }\n    auto sa = internal::sa_is(s, upper);\n    return sa;\n}\n\ntemplate <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n    int n = int(s.size());\n    std::vector<int> idx(n);\n    iota(idx.begin(), idx.end(), 0);\n    sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n    std::vector<int> s2(n);\n    int now = 0;\n    for (int i = 0; i < n; i++) {\n        if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n        s2[idx[i]] = now;\n    }\n    return internal::sa_is(s2, now);\n}\n\nstd::vector<int> suffix_array(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return internal::sa_is(s2, 255);\n}\n\n// Reference:\n// T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,\n// Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its\n// Applications\ntemplate <class T>\nstd::vector<int> lcp_array(const std::vector<T>& s,\n                           const std::vector<int>& sa) {\n    int n = int(s.size());\n    assert(n >= 1);\n    std::vector<int> rnk(n);\n    for (int i = 0; i < n; i++) {\n        rnk[sa[i]] = i;\n    }\n    std::vector<int> lcp(n - 1);\n    int h = 0;\n    for (int i = 0; i < n; i++) {\n        if (h > 0) h--;\n        if (rnk[i] == 0) continue;\n        int j = sa[rnk[i] - 1];\n        for (; j + h < n && i + h < n; h++) {\n            if (s[j + h] != s[i + h]) break;\n        }\n        lcp[rnk[i] - 1] = h;\n    }\n    return lcp;\n}\n\nstd::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return lcp_array(s2, sa);\n}\n\n// Reference:\n// D. Gusfield,\n// Algorithms on Strings, Trees, and Sequences: Computer Science and\n// Computational Biology\ntemplate <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    std::vector<int> z(n);\n    z[0] = 0;\n    for (int i = 1, j = 0; i < n; i++) {\n        int& k = z[i];\n        k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n        while (i + k < n && s[k] == s[i + k]) k++;\n        if (j + z[j] < i + z[i]) j = i;\n    }\n    z[0] = n;\n    return z;\n}\n\nstd::vector<int> z_algorithm(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return z_algorithm(s2);\n}\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n\n}  // namespace atcoder\n\nusing namespace std;\nusing namespace atcoder;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) rng(i,0,r)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) rrng(i,0,r)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>bool chmax(t&a,u b){if(a<b)a=b;return a<b;}\ntemplate<class t,class u>bool chmin(t&a,u b){if(b<a)a=b;return b<a;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n\tint size(){\n\t\treturn v.size();\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\n\nint h,w,s,t,dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>h>>w;\n\tmf_graph<int>g(h*w*2+2);\n\ts=h*w*2,t=h*w*2+1;\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tint p=i*w+j;\n\t\t\trep(k,4){\n\t\t\t\tint ny=i+dy[k],nx=j+dx[k];\n\t\t\t\tif(0<=ny&&ny<h&&0<=nx&&nx<w){\n\t\t\t\t\tint q=ny*w+nx;\n\t\t\t\t\tg.add_edge(q*2+1,p*2,inf);\n\t\t\t\t\tg.add_edge(p*2+1,q*2,inf);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c=='.')g.add_edge(p*2,p*2+1,1);\n\t\t\telse{\n\t\t\t\tg.add_edge(p*2,p*2+1,inf);\n\t\t\t\tg.add_edge(s,p*2,inf);\n\t\t\t}\n\t\t\tif(i==0||i==h-1||j==0||j==w-1){\n\t\t\t\tg.add_edge(p*2+1,t,inf);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=g.flow(s,t);\n\tif(ans>=inf)ans=-1;\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint h,w;\nint fie[101][101];\nbool used[101][101];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nbool bfs(int sy,int sx){\n\tqueue<P> que;\n\tque.push(P(sy,sx));\n\tmemset(used,false,sizeof(used));\n\tused[sy][sx]=true;\n\twhile(que.size()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tif(p.first==0 || p.first==h-1 || p.second==0 || p.second==w-1)return true;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=p.second+dx[i],ny=p.first+dy[i];\n\t\t\tif(nx>=0 && nx<w && ny>=0 && ny<h){\n\t\t\t\tif(!used[ny][nx] && fie[ny][nx]!=-1){\n\t\t\t\t\tused[ny][nx]=true;\n\t\t\t\t\tque.push(P(ny,nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint solve(){\n\tfor(int i=0;i<h;i++){\n\t\tif(fie[i][0]==1)return -1;\n\t\tif(fie[i][w-1]==1)return -1;\n\t}\n\tfor(int i=0;i<w;i++){\n\t\tif(fie[0][i]==1)return -1;\n\t\tif(fie[h-1][i]==1)return -1;\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(fie[i][j]==1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint nx=j+dx[k];\n\t\t\t\t\tint ny=i+dy[k];\n\t\t\t\t\tif(nx>=0 && nx<w && ny>=0 && ny<h){\n\t\t\t\t\t\tif(fie[ny][nx]==0)fie[ny][nx]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res=0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(fie[i][j]==-1){\n\t\t\t\tif(bfs(i,j))res++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\tscanf(\"%d%d\",&h,&w);\n\tfor(int i=0;i<h;i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[j]=='X'){\n\t\t\t\tfie[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\nstruct Edge {\n\tEdge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n\tint to, cap, rev;\n};\n\nclass MaxFlow {\npublic:\n\texplicit MaxFlow(int n) : g(n), level(n), iter(n) {}\n\tvector< vector<Edge> > g;\n\tvector<int> level;\n\tvector<int> iter;\n\tvoid addEdge(int src, int dst, int cap){\n\t\tg[src].emplace_back(Edge(dst, cap, g[dst].size()));\n\t\tg[dst].emplace_back(Edge(src, 0, g[src].size()-1));\n\t}\n\tint dfs(int pos, int dst, int f){\n\t\tif(pos == dst) return f;\n\t\tfor(int& i=iter[pos];i<g[pos].size();++i){\n\t\t\tEdge& e = g[pos][i];\n\t\t\tif(e.cap == 0 || level[e.to] <= level[pos]) continue;\n\t\t\tint d = dfs(e.to, dst, min(f, e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tg[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint maxFlow(int s, int t){\n\t\tint res = 0;\n\t\tint n = g.size();\n\t\twhile(true){\n\t\t\tfor(int i=0;i<n;i++) level[i] = -1;\n\t\t\tlevel[s] = 0;\n\t\t\tqueue<int> qu; qu.push(s);\n\t\t\twhile(!qu.empty()){\n\t\t\t\tint p = qu.front(); qu.pop();\n\t\t\t\tfor(const Edge& e : g[p]){\n\t\t\t\t\tif(e.cap > 0 && level[e.to] == -1){\n\t\t\t\t\t\tlevel[e.to] = level[p]+1;\n\t\t\t\t\t\tqu.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(level[t] == -1) break;\n\t\t\tfor(int i=0;i<n;i++) iter[i] = 0;\n\t\t\tfor(int f;(f=dfs(s,t,1000000007)) > 0;res+=f);\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main(){\n\tint H, W;\n\twhile(cin >> H >> W){\n\t\tvector<string> vs(H);\n\t\tfor(int i=0;i<H;++i) cin >> vs[i];\n\t\tbool ok = true;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tif(vs[i][j] != 'X') continue;\n\t\t\t\tif(i == 0 || i == H-1 || j == 0 || j == W-1){\n\t\t\t\t\tok = false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!ok){\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tMaxFlow f(2*H*W+2);\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tint p = i*W+j;\n\t\t\t\tif(i == 0 || i == H-1 || j == 0 || j == W-1){\n\t\t\t\t\tf.addEdge(2*p+2, 2*H*W+1, 10000);\n\t\t\t\t}\n\t\t\t\tif(vs[i][j] == 'X'){\n\t\t\t\t\tf.addEdge(2*p+1, 2*p+2, 10000);\n\t\t\t\t\tf.addEdge(0, 2*p+2, 10000);\n\t\t\t\t} else {\n\t\t\t\t\tf.addEdge(2*p+1, 2*p+2, 1);\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint nx = i+dx[k], ny = j+dy[k];\n\t\t\t\t\tif(nx < 0 || H <= nx || ny < 0 || W <= ny) continue;\n\t\t\t\t\tint np = nx*W+ny;\n\t\t\t\t\tf.addEdge(2*p+2, 2*np+1, 10000);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << f.maxFlow(0, 2*H*W+1) << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans-4<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 1e5;\nconst int OO = 0x3f3f3f3f;\nint SOURCE, SINK;\n\nstruct edge\n{\n    int v, f, c;\n    edge(){}\n    edge(int _v, int _f, int _c)\n    {\n        v = _v, f = _f, c = _c;\n    }\n};\n\nvector<edge> edges;\nvector<int> G[MAX];\nint dist[MAX], work[MAX];\n\nvoid add_edge(int u, int v, int cp, int rc){\n\tedges.push_back(edge(v, 0, cp));\n\tG[u].push_back(edges.size()-1);\n\tedges.push_back(edge(u, 0, rc));\n\tG[v].push_back(edges.size()-1);\n}\n\nbool bfs(int s, int t)\n{\n    memset(dist, -1, sizeof(dist));\n    dist[s] = 0;\n    queue<int> q;\n    q.push(s);\n    while(!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        for(int e : G[u])\n            if(dist[edges[e].v] == -1 and edges[e].c-edges[e].f > 0)\n            {\n                q.push(edges[e].v);\n                dist[edges[e].v] = dist[u] + 1;\n            }\n    }\n    return dist[t] != -1;\n}\n\nint dfs(int s, int t, int f)\n{\n    if(s == t) return f;\n    for(int &i = work[s]; i < G[s].size(); i++)\n    {\n    \tint e = G[s][i];\n        if(dist[edges[e].v] == dist[s] + 1 and edges[e].c-edges[e].f > 0)\n            if(int a = dfs(edges[e].v, t, min(f, edges[e].c-edges[e].f)))\n            {\n                edges[e].f += a;\n                edges[e^1].f -= a;\n                return a;\n            }\n    }\n    return 0;\n}\n\nint MaxFlow(int s, int t)\n{\n    int mf = 0;\n    while(bfs(s, t))\n\t{\n    \tmemset(work, 0, sizeof(work));\n        while(int a = dfs(s, t, OO))\n            mf += a;\n    }\n    return mf;\n}\n\nint n, m, a, b;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nbool check(int x, int y)\n{\n\treturn x >= 0 and x < n and y >= 0 and y < m;\n}\n\nint vertexIn(int i, int j)\n{\n\treturn i * m + j;\n}\n\nint vertexOut(int i, int j)\n{\n\treturn i * m + j + n * m + 1;\n}\n\nint main()\n{\n \tcin >> n >> m;\n \tSOURCE = 2 * n * m + 2;\n \tSINK = 2 * n * m + 3;\n \tbool fl = false;\n \tfor(int i = 0; i < n; i++)\n \t\tfor(int j = 0; j < m; j++)\n \t\t{\n \t\t\tchar c;\n \t\t\tcin >> c;\n \t\t\tint cost = 1;\n \t\t\tif(c == 'X') cost = OO;\n \t\t\tadd_edge(vertexIn(i, j), vertexOut(i, j), cost, 0);\n \t\t\tif(cost == OO) add_edge(vertexOut(i, j), SINK, OO, 0);\n \t\t\tfor(int k = 0; k < 4; k++)\n \t\t\t{\n\t\t\t\tint x = i + dx[k], y = j + dy[k];\n\t\t\t\tif(check(x, y))\n \t\t\t\t\tadd_edge(vertexOut(i, j), vertexIn(x, y), OO, 0);\n \t\t\t}\n \t\t\tif(!i or !j or i == n - 1 or j == m - 1)\n\t\t\t{\n \t\t\t\tadd_edge(SOURCE, vertexIn(i, j), OO, 0);\n \t\t\t\tif(c == 'X') fl = true;\n \t\t\t}\n \t\t}\t\n\tif(fl) return puts(\"-1\"), 0;\n \tcout << MaxFlow(SOURCE, SINK) << '\\n';\n \t\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nusing vs=vector<string>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\n\nstatic const int INF=1<<29;\nstatic const int di[]={-1, 0, 1, 0}, dj[]={0, -1, 0, 1};\nint main() {\n  size_t H, W;\n  scanf(\"%lu %lu\", &H, &W);\n\n  vs S(H);\n  for (size_t i=0; i<H; ++i) {\n    char buf[1<<7];\n    scanf(\"%s\", buf);\n    S[i] = buf;\n    if (S[i][0]=='X' || S[i][W-1]=='X')\n      return !printf(\"-1\\n\");\n  }\n\n  if (S[0].find('X') != string::npos)\n    return !printf(\"-1\\n\");\n\n  if (S[H-1].find('X') != string::npos)\n    return !printf(\"-1\\n\");\n\n  vs T(H, string(W, '.'));\n  for (size_t i=1; i<H-1; ++i)\n    for (size_t j=1; j<W-1; ++j) {\n      if (S[i][j] == 'X') {\n        for (size_t k=0; k<4; ++k) {\n          int I=i+di[k], J=j+dj[k];\n          T[I][J] = '#';\n        }\n      }\n    }\n\n  vvi dp(H, vi(W, INF));\n  dp[0][0]=dp[0][W-1]=dp[H-1][0]=dp[H-1][W-1]=0;\n  queue<pii> q;\n  q.push(pii(0, 0));\n  q.push(pii(0, W-1));\n  q.push(pii(H-1, 0));\n  q.push(pii(H-1, W-1));\n  while (!q.empty()) {\n    int i=q.front().first, j=q.front().second; q.pop();\n    for (size_t k=0; k<4; ++k) {\n      int I=i+di[k], J=j+dj[k];\n      if (!(0<=I && I<H && 0<=J && J<W)) continue;\n\n      if (dp[I][J] > dp[i][j] + (T[I][J]=='#')) {\n        dp[I][J] = dp[i][j] + (T[I][J]=='#');\n        q.push(pii(I, J));\n      }\n    }\n  }\n\n  int res=0;\n  for (size_t i=0; i<H; ++i)\n    for (size_t j=0; j<W; ++j)\n      if (dp[i][j]==1 && T[i][j]=='#') ++res;\n\n  printf(\"%d\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <chrono>\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define FOR(i,m,n) for(int i=(m);i<(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\nconst int INF = 0x3f3f3f3f;\nconst long long LINF = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007; // 998244353;\nconst int dy[] = {1, 0, -1, 0}, dx[] = {0, -1, 0, 1};\n/*-------------------------------------------------*/\ntemplate <typename T>\nstruct Dinic {\n  struct Edge {\n    int dst, rev;\n    T cap;\n    Edge(int dst, T cap, int rev) : dst(dst), cap(cap), rev(rev) {}\n  };\n\n  vector<vector<Edge> > graph;\n\n  Dinic(int n) : graph(n), level(n), itr(n) {}\n\n  void add_edge(int src, int dst, T cap) {\n    graph[src].emplace_back(dst, cap, graph[dst].size());\n    graph[dst].emplace_back(src, 0, graph[src].size() - 1);\n  }\n\n  T maximum_flow(int s, int t, T limit) {\n    T res = 0;\n    while (true) {\n      bfs(s);\n      if (level[t] == -1) return res;\n      fill(ALL(itr), 0);\n      T tmp;\n      while ((tmp = dfs(s, t, limit)) > 0) res += tmp;\n    }\n  }\n\nprivate:\n  vector<int> level, itr;\n\n  void bfs(int s) {\n    fill(ALL(level), -1);\n    queue<int> que;\n    level[s] = 0;\n    que.emplace(s);\n    while (!que.empty()) {\n      int ver = que.front(); que.pop();\n      for (Edge e : graph[ver]) if (level[e.dst] == -1 && e.cap > 0) {\n        level[e.dst] = level[ver] + 1;\n        que.emplace(e.dst);\n      }\n    }\n  }\n\n  T dfs(int ver, int t, T flow) {\n    if (ver == t) return flow;\n    for (; itr[ver] < graph[ver].size(); ++itr[ver]) {\n      Edge &e = graph[ver][itr[ver]];\n      if (level[ver] < level[e.dst] && e.cap > 0) {\n        T tmp = dfs(e.dst, t, min(flow, e.cap));\n        if (tmp > 0) {\n          e.cap -= tmp;\n          graph[e.dst][e.rev].cap += tmp;\n          return tmp;\n        }\n      }\n    }\n    return 0;\n  }\n};\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  // freopen(\"input.txt\", \"r\", stdin);\n\n  int h, w; cin >> h >> w;\n  vector<string> s(h); REP(i, h) cin >> s[i];\n  int n = h * w;\n  Dinic<int> dinic(n * 2 + 2);\n  REP(j, w) {\n    if (s[0][j] == 'X' || s[h - 1][j] == 'X') {\n      cout << -1 << '\\n';\n      return 0;\n    }\n    dinic.add_edge(j * 2 + 1, n * 2 + 1, INF);\n    dinic.add_edge(((h - 1) * w + j) * 2 + 1, n * 2 + 1, INF);\n  }\n  FOR(i, 1, h - 1) {\n    if (s[i][0] == 'X' || s[i][w - 1] == 'X') {\n      cout << -1 << '\\n';\n      return 0;\n    }\n    dinic.add_edge((i * w) * 2 + 1, n * 2 + 1, INF);\n    dinic.add_edge((i * w + w - 1) * 2 + 1, n * 2 + 1, INF);\n  }\n  REP(i, h) REP(j, w) {\n    if (s[i][j] == '.') {\n      dinic.add_edge((i * w + j) * 2, (i * w + j) * 2 + 1, 1);\n    } else {\n      dinic.add_edge((i * w + j) * 2, (i * w + j) * 2 + 1, INF);\n      dinic.add_edge(n * 2, (i * w + j) * 2 + 1, INF);\n    }\n    REP(k, 4) {\n      int y = i + dy[k], x = j + dx[k];\n      if (0 <= y && y < h && 0 <= x && x < w) {\n        dinic.add_edge((i * w + j) * 2 + 1, (y * w + x) * 2, INF);\n      }\n    }\n  }\n  cout << dinic.maximum_flow(n * 2, n * 2 + 1, INF) << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define fst first\n#define snd second\ntypedef long long ll;\ninline void Fail(){printf(\"-1\");exit(0);}\n\nconst int maxn=105;\nconst int maxm=20005;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nint n,m;\nchar c[maxn][maxn];\n\nclass max_flow{\npublic:\n\tint s,t;\n\tclass EDGE{\n\tpublic:\n\t\tint to,cap,rev;\n\t\tEDGE(int _to,int _cap,int _rev){to=_to;cap=_cap;rev=_rev;}\n\t};\n\tvector<EDGE>edge[maxm];\n\tint lvl[maxm],nxt[maxm],q[maxm];\n\tvoid add_edge(int from,int to,int cap){\n//\t\tcout<<from<<\" \"<<to<<endl;\n\t\tedge[from].pb(EDGE(to,cap,edge[to].size()));\n\t\tedge[to].pb(EDGE(from,0,edge[from].size()-1));\n\t}\n\tvoid bfs(){\n\t\tint l=0,r=0;\n\t\tmemset(lvl,-1,sizeof(lvl));\n\t\tlvl[s]=0;\n\t\tq[r++]=s;\n\t\twhile(l<r){\n\t\t\tint x=q[l++];\n\t\t\trep(i,edge[x].size()){\n\t\t\t\tEDGE &y=edge[x][i];\n\t\t\t\tif(y.cap&&lvl[y.to]<0){\n\t\t\t\t\tlvl[y.to]=lvl[x]+1;\n\t\t\t\t\tq[r++]=y.to;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int x,int f){\n\t\tif(x==t)return f;\n\t\tfor(int &i=nxt[x];i<edge[x].size();i++){\n\t\t\tEDGE &y=edge[x][i];\n\t\t\tif(y.cap&&lvl[y.to]==lvl[x]+1){\n\t\t\t\tint d=dfs(y.to,min(f,y.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\ty.cap-=d;\n\t\t\t\t\tedge[y.to][y.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint mf(){\n\t\tint res=0;\n\t\twhile(true){\n\t\t\tbfs();\n\t\t\tif(lvl[t]<0)return res;\n\t\t\tmemset(nxt,0,sizeof(nxt));\n\t\t\tint f;\n\t\t\twhile(true){\n\t\t\t\tf=dfs(s,INF);\n\t\t\t\tres+=f;\n\t\t\t\tif(!f)break;\n\t\t\t}\n\t\t}\n\t}\n}M;\n\nint get_id(int i,int j,int tp){\n\treturn (i*m+j)*2+tp;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,n)scanf(\"%s\",c[i]);\n\tM.s=n*m*2,M.t=n*m*2+1;\n\trep(i,n)rep(j,m){\n\t\tif(c[i][j]=='X'){\n\t\t\tM.add_edge(get_id(i,j,0),get_id(i,j,1),INF);\n\t\t\tM.add_edge(get_id(i,j,1),M.t,INF);\n\t\t\tif(!i||i==n-1||!j||j==m-1){\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\telse M.add_edge(get_id(i,j,0),get_id(i,j,1),1);\n\t\trep(k,4){\n\t\t\tint ni=i+dx[k],nj=j+dy[k];\n\t\t\tif(ni>=0&&ni<n&&nj>=0&&nj<m){\n\t\t\t\tM.add_edge(get_id(i,j,1),get_id(ni,nj,0),INF);\n\t\t\t}\n\t\t\telse M.add_edge(M.s,get_id(i,j,0),INF);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",M.mf());\n\treturn 0;\n}\n\n/*\nInput:\n5 4\n....\n..X.\n.XX.\n..X.\n....\n-----------------\nOutput:\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing P = pair<int, int>;\nusing namespace std;\n\ntemplate<class T> void vin(vector<T>& v, int n) {\n    v.resize(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n}\n\ntemplate<class T>\nclass Dinic {\nprivate:\n    const T INF;\n\n    struct edge {\n        T to, cap, rev;\n        edge(T to, T cap, T rev) :to(to), cap(cap), rev(rev) {}\n    };\n\n    T V;\n    vector<vector<edge>> g;\n    vector<T> level;      // sourceからの距離\n    vector<T> itr;       // どこまで調べ終わったか\n\npublic:\n    Dinic(T V) :INF(1e9+7), V(V), g(V, vector<edge>()) {}\n\n    void add_edge(T from, T to, T cap) {\n        g[from].emplace_back(to, cap, g[to].size());\n        g[to].emplace_back(from, 0, g[from].size()-1);\n    }\n\n    // sourceからの最短路を幅優先で探索\n    void bfs(T s) {\n        level = vector<T>(V, -1);\n        queue<T> que;\n        que.push(s);\n        level[s] = 0;\n        while (que.size()) {\n            int v = que.front(); que.pop();\n            for (edge &e : g[v]) {\n                if (e.cap > 0 and level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    // v->tの増加路を探す\n    T dfs(T v, T t, T f) {\n        if (v == t) return f;\n        for (T& i = itr[v]; i < g[v].size(); ++i) {\n            edge& e = g[v][i];\n            if (e.cap > 0 and level[v] < level[e.to]) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    g[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T max_flow(T s, T t) {\n        T flow = 0, f;\n        while (true) {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            itr = vector<T>(V, 0);\n            while ((f = dfs(s, t, numeric_limits<T>::max())) > 0) {\n                flow += f;\n            }\n        }\n    }\n};\n\nint H, W;\nint in(int r, int c) {\n    return r*W+c+2;\n}\nint out(int r, int c) {\n    return (H*W)+(r*W+c)+2;\n}\n\nint main() {\n    cin >> H >> W;\n    string board[101];\n    rep(i, H) cin >> board[i];\n    int s = 0, t = 1, inf = 1e9+7;\n    Dinic<int> flow(H*W*2+5);\n    rep(r, H) rep(c, W) {\n        if (r == 0 or r == H-1 or c == 0 or c == W-1) {\n            if (board[r][c] == 'X') {\n                cout << -1 << endl;\n                return 0;\n            }\n            flow.add_edge(out(r,c), t, inf);\n        }\n        if (board[r][c] == 'X') flow.add_edge(s, out(r,c), inf);\n        flow.add_edge(in(r,c), out(r,c), (board[r][c] == 'X' ? inf : 1));\n        if (r > 0) flow.add_edge(out(r,c), in(r-1,c), inf);\n        if (c > 0) flow.add_edge(out(r,c), in(r,c-1), inf);\n        if (r+1<H) flow.add_edge(out(r,c), in(r+1,c), inf);\n        if (c+1<W) flow.add_edge(out(r,c), in(r,c+1), inf);\n    }\n    cout << flow.max_flow(s, t) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105];\nbool fr[105][105],vis[105][105],st,ad,f;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tf=1;\n//\t\t\t\t\tad = f = 0;\n//\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n//\t\t\t\t\tif(ad){\n//\t\t\t\t\t\trep(o,b+1,m){\n//\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n//\t\t\t\t\t\t\tx[a][o] = '#';\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\tsolve();\n//\t\t\t\t\t\tif(ans>tmp){\n//\t\t\t\t\t\t\tans = tmp;\n//\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n//\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n//\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tf=1;\n//\t\t\t\t\tad = f = 0;\n//\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n//\t\t\t\t\tif(ad){\n//\t\t\t\t\t\trep(o,b+1,m){\n//\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n//\t\t\t\t\t\t\tx[a][o] = '#';\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\tsolve();\n//\t\t\t\t\t\tif(ans>tmp){\n//\t\t\t\t\t\t\tans = tmp;\n//\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n//\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n//\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n#define MAX_V (100*100*2+2)\n\nstruct edge{int to,cap,rev;};\n\nvector<edge> G[MAX_V];  //グラフのパス\nint level[MAX_V];       //始点からの距離\nint iter[MAX_V];        //どこまで調べたか\n\n// fromからtoへ向かう、容量capの辺をグラフに追加する\nvoid add_edge(int from,int to,int cap){\n    G[from].push_back(  (edge){ to  ,cap,(int)G[to  ].size()   }  );\n    G[to  ].push_back(  (edge){ from,0  ,(int)G[from].size()-1 }  );\n}\n\n// sからの最短距離をBFSで計算する\nvoid bfs(int s){\n    rep(i,MAX_V)level[i]=-1;\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n        int v=que.front();que.pop();\n        \n        rep(i,G[v].size()){\n            edge &e=G[v][i];\n            if(e.cap>0 && level[e.to]<0){\n                level[e.to]=level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\n//増加パスをDFSで探す\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    for(int &i=iter[v];i<G[v].size();i++){\n        edge &e=G[v][i];\n        if(e.cap>0&&level[v]<level[e.to]){\n            int d=dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n// sからtへの最大流を求める\nint max_flow(int s,int t){\n    if(s==t)return INF;\n    int flow=0;\n    for(;;){\n        bfs(s);\n        if(level[t]<0)return flow;\n        memset(iter,0,sizeof(iter));\n        int f;\n        while((f=dfs(s,t,INF))>0){\n            flow+=f;\n        }\n    }\n}\n\nint h,w;\n\nint f(int y,int x,int dim){\n    return y*w+x + dim*(h*w);\n}\n\n\nint main(){\n    cin>>h>>w;\n    int S = 2*h*w;\n    int T = 2*h*w+1;\n    vector<string> vs(h);\n    rep(i,h)cin>>vs[i];\n    rep(i,h-1){     //y軸方向にジグザクに有向辺を貼る\n        rep(j,w){\n            add_edge(f(i+1,j,1),f(i  ,j,0),INF);\n            add_edge(f(i  ,j,1),f(i+1,j,0),INF);\n        }\n    }\n    rep(i,h){     //x軸方向にジグザクに有向辺を貼る\n        rep(j,w-1){\n            add_edge(f(i,j+1,1),f(i,j  ,0),INF);\n            add_edge(f(i,j  ,1),f(i,j+1,0),INF);\n        }\n    }\n    \n    rep(i,h){\n        rep(j,w){\n            if(vs[i][j] == 'X'){\n                add_edge(S,f(i,j,0),INF);       //ヤギの居るマスにはソースから有向辺を貼る\n                add_edge(f(i,j,0),f(i,j,1),INF);//ヤギの居るマスには真下にコストINFの有向辺を貼る\n            }\n            else{\n                add_edge(f(i,j,0),f(i,j,1),1);  //ヤギの居ないマスには真下にコスト1の有向辺を貼る\n            }\n        }\n    }\n    \n    rep(i,h){               //左端の列と右端の列からシンクに有向辺を貼る\n        add_edge(f(i,0  ,1),T,INF);\n        add_edge(f(i,w-1,1),T,INF);\n    }\n    \n    for(int j=1;j<w-1;j++){ //上端の行と下端の行からシンクに有向辺を貼る\n        add_edge(f(0,j,1),  2*h*w+1,INF);\n        add_edge(f(h-1,j,1),2*h*w+1,INF);\n    }\n    \n    int res = max_flow(2*h*w,2*h*w+1);\n    if(res>=INF)cout<<-1<<endl;\n    else cout<<res<<endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define i_7 (ll)(1E9+7)\n#define i_5 (ll)(1E9+5)\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    else return c+i_7;\n}\ntypedef pair<int,int> i_i;\ntypedef pair<ll,ll> l_l;\nll inf=(ll)1E12;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll * pos,ll val){*pos=max(*pos,val);}//Max(&dp[i][j],dp[i-1][j]);\nvoid Min(ll * pos,ll val){*pos=min(*pos,val);}\nvoid Add(ll * pos,ll val){*pos=mod(*pos+val);}\nconst long double EPS=1E-8;\n////////////////////////////////////////\n#define MAX_V 30000//調節！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n//辺を表す構造体{行き先、容量、逆辺}\nstruct edge{ll to,cap,rev;};\nvector<edge> G[MAX_V];\nbool used[MAX_V];//dfsですでに調べたかのフラグ\n//fromからtoへの流量capの辺をグラフに追加\nvoid add_edge(ll from,ll to,ll cap){\n    //cout<<from<<\" \"<<to<<\" \"<<cap<<endl;\n    G[from].push_back((edge){to,cap,static_cast<ll>(G[to].size())});\n    G[to].push_back((edge){from,0,static_cast<ll>(G[from].size()-1)});\n}\n//増加パスをdfsで探す\nll dfs(ll v,ll t,ll f){\n    if(v==t)return f;\n    used[v]=true;\n    for(ll i=0;i<G[v].size();i++){\n        edge &e=G[v][i];\n        if(!used[e.to]&&e.cap>0){\n            ll d=dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\nll max_flow(ll s,ll t){\n    ll flow=0;\n    while(1){\n        memset(used,0,sizeof(used));\n        ll f=dfs(s,t,inf);\n        if(f==0)return flow;\n        flow+=f;\n    }\n}\n///////////////////////////////////////\n\nll h,w;\nvoid add(ll s,ll t){\n    add_edge(s+h*w,t,inf);\n    add_edge(t+h*w,s,inf);\n}\n\nint main(){\n    cin>>h>>w;\n    string q[h];rep(i,0,h-1)cin>>q[i];\n    rep(i,0,h-1){\n        rep(j,0,w-2){\n            ll s=i*w+j;\n            ll t=i*w+j+1;\n            add(s,t);\n        }\n    }\n    rep(j,0,w-1){\n        rep(i,0,h-2){\n            ll s=i*w+j;\n            ll t=(i+1)*w+j;\n            add(s,t);\n        }\n    }\n    ll sta=2*h*w,end=2*h*w+1;\n    rep(i,0,h-1){\n        rep(j,0,w-1){\n            ll s=i*w+j;\n            if(q[i][j]=='X'){\n                add_edge(sta,s,inf);\n                add_edge(s,s+h*w,inf);\n            }else{\n                add_edge(s,s+h*w,1);\n            }\n        }\n    }\n    rep(i,0,h-1){\n        ll s=i*w+0;\n        ll t=i*w+w-1;\n        add_edge(s+w*h,end,inf);\n        add_edge(t+w*h,end,inf);\n    }\n    rep(j,1,w-2){\n        ll s=0*w+j;\n        ll t=(h-1)*w+j;\n        add_edge(s+w*h,end,inf);\n        add_edge(t+w*h,end,inf);\n    }\n    ll c=max_flow(sta,end);\n    //cout<<sta<<\" \"<<end<<endl;\n    if(c>=inf)cout<<-1<<endl;\n    else cout<<c<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include <bits/stdc++.h>\n//#include \"bits/stdc++.h\"\n\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param n `0 <= n`\n// @return minimum non-negative `x` s.t. `n <= 2**x`\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n\n// @param n `1 <= n`\n// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param m `1 <= m`\n// @return x mod m\nconstexpr long long safe_mod(long long x, long long m) {\n    x %= m;\n    if (x < 0) x += m;\n    return x;\n}\n\n// Fast moduler by barrett reduction\n// Reference: https://en.wikipedia.org/wiki/Barrett_reduction\n// NOTE: reconsider after Ice Lake\nstruct barrett {\n    unsigned int _m;\n    unsigned long long im;\n\n    // @param m `1 <= m`\n    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n\n    // @return m\n    unsigned int umod() const { return _m; }\n\n    // @param a `0 <= a < m`\n    // @param b `0 <= b < m`\n    // @return `a * b % m`\n    unsigned int mul(unsigned int a, unsigned int b) const {\n        // [1] m = 1\n        // a = b = im = 0, so okay\n\n        // [2] m >= 2\n        // im = ceil(2^64 / m)\n        // -> im * m = 2^64 + r (0 <= r < m)\n        // let z = a*b = c*m + d (0 <= c, d < m)\n        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im\n        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2\n        // ((ab * im) >> 64) == c or c + 1\n        unsigned long long z = a;\n        z *= b;\n#ifdef _MSC_VER\n        unsigned long long x;\n        _umul128(z, im, &x);\n#else\n        unsigned long long x =\n            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n        unsigned int v = (unsigned int)(z - x * _m);\n        if (_m <= v) v += _m;\n        return v;\n    }\n};\n\n// @param n `0 <= n`\n// @param m `1 <= m`\n// @return `(x ** n) % m`\nconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n    if (m == 1) return 0;\n    unsigned int _m = (unsigned int)(m);\n    unsigned long long r = 1;\n    unsigned long long y = safe_mod(x, m);\n    while (n) {\n        if (n & 1) r = (r * y) % _m;\n        y = (y * y) % _m;\n        n >>= 1;\n    }\n    return r;\n}\n\n// Reference:\n// M. Forisek and J. Jancina,\n// Fast Primality Testing for Integers That Fit into a Machine Word\n// @param n `0 <= n`\nconstexpr bool is_prime_constexpr(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 7 || n == 61) return true;\n    if (n % 2 == 0) return false;\n    long long d = n - 1;\n    while (d % 2 == 0) d /= 2;\n    for (long long a : {2, 7, 61}) {\n        long long t = d;\n        long long y = pow_mod_constexpr(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {\n            y = y * y % n;\n            t <<= 1;\n        }\n        if (y != n - 1 && t % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\ntemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\n\n// @param b `1 <= b`\n// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g\nconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n    a = safe_mod(a, b);\n    if (a == 0) return {b, 0};\n\n    // Contracts:\n    // [1] s - m0 * a = 0 (mod b)\n    // [2] t - m1 * a = 0 (mod b)\n    // [3] s * |m1| + t * |m0| <= b\n    long long s = b, t = a;\n    long long m0 = 0, m1 = 1;\n\n    while (t) {\n        long long u = s / t;\n        s -= t * u;\n        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n\n        // [3]:\n        // (s - t * u) * |m1| + t * |m0 - m1 * u|\n        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)\n        // = s * |m1| + t * |m0| <= b\n\n        auto tmp = s;\n        s = t;\n        t = tmp;\n        tmp = m0;\n        m0 = m1;\n        m1 = tmp;\n    }\n    // by [3]: |m0| <= b/g\n    // by g != b: |m0| < b/g\n    if (m0 < 0) m0 += b / s;\n    return {s, m0};\n}\n\n// Compile time primitive root\n// @param m must be prime\n// @return primitive root (and minimum in now)\nconstexpr int primitive_root_constexpr(int m) {\n    if (m == 2) return 1;\n    if (m == 167772161) return 3;\n    if (m == 469762049) return 3;\n    if (m == 754974721) return 11;\n    if (m == 998244353) return 3;\n    int divs[20] = {};\n    divs[0] = 2;\n    int cnt = 1;\n    int x = (m - 1) / 2;\n    while (x % 2 == 0) x /= 2;\n    for (int i = 3; (long long)(i)*i <= x; i += 2) {\n        if (x % i == 0) {\n            divs[cnt++] = i;\n            while (x % i == 0) {\n                x /= i;\n            }\n        }\n    }\n    if (x > 1) {\n        divs[cnt++] = x;\n    }\n    for (int g = 2;; g++) {\n        bool ok = true;\n        for (int i = 0; i < cnt; i++) {\n            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) return g;\n    }\n}\ntemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n\nnamespace internal {\n\n#ifndef _MSC_VER\ntemplate <class T>\nusing is_signed_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\n                                  std::is_same<T, __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\n                                  std::is_same<T, unsigned __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing make_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value,\n                              __uint128_t,\n                              unsigned __int128>;\n\ntemplate <class T>\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\n                                                  is_signed_int128<T>::value ||\n                                                  is_unsigned_int128<T>::value,\n                                              std::true_type,\n                                              std::false_type>::type;\n\ntemplate <class T>\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                 std::is_signed<T>::value) ||\n                                                    is_signed_int128<T>::value,\n                                                std::true_type,\n                                                std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<(is_integral<T>::value &&\n                               std::is_unsigned<T>::value) ||\n                                  is_unsigned_int128<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<\n    is_signed_int128<T>::value,\n    make_unsigned_int128<T>,\n    typename std::conditional<std::is_signed<T>::value,\n                              std::make_unsigned<T>,\n                              std::common_type<T>>::type>::type;\n\n#else\n\ntemplate <class T> using is_integral = typename std::is_integral<T>;\n\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<is_integral<T>::value &&\n                                  std::is_unsigned<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\n                                              std::make_unsigned<T>,\n                                              std::common_type<T>>::type;\n\n#endif\n\ntemplate <class T>\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n\ntemplate <class T>\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\nnamespace internal {\n\nstruct modint_base {};\nstruct static_modint_base : modint_base {};\n\ntemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\ntemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n\n}  // namespace internal\n\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\nstruct static_modint : internal::static_modint_base {\n    using mint = static_modint;\n\n  public:\n    static constexpr int mod() { return m; }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    static_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    static_modint(T v) {\n        long long x = (long long)(v % (long long)(umod()));\n        if (x < 0) x += umod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    static_modint(T v) {\n        _v = (unsigned int)(v % umod());\n    }\n    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v -= rhs._v;\n        if (_v >= umod()) _v += umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        unsigned long long z = _v;\n        z *= rhs._v;\n        _v = (unsigned int)(z % umod());\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        if (prime) {\n            assert(_v);\n            return pow(umod() - 2);\n        } else {\n            auto eg = internal::inv_gcd(_v, m);\n            assert(eg.first == 1);\n            return eg.second;\n        }\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static constexpr unsigned int umod() { return m; }\n    static constexpr bool prime = internal::is_prime<m>;\n};\n\ntemplate <int id> struct dynamic_modint : internal::modint_base {\n    using mint = dynamic_modint;\n\n  public:\n    static int mod() { return (int)(bt.umod()); }\n    static void set_mod(int m) {\n        assert(1 <= m);\n        bt = internal::barrett(m);\n    }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    dynamic_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        long long x = (long long)(v % (long long)(mod()));\n        if (x < 0) x += mod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        _v = (unsigned int)(v % mod());\n    }\n    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v += mod() - rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        _v = bt.mul(_v, rhs._v);\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        auto eg = internal::inv_gcd(_v, mod());\n        assert(eg.first == 1);\n        return eg.second;\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static internal::barrett bt;\n    static unsigned int umod() { return bt.umod(); }\n};\ntemplate <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n\nusing modint998244353 = static_modint<998244353>;\nusing modint1000000007 = static_modint<1000000007>;\nusing modint = dynamic_modint<-1>;\n\nnamespace internal {\n\ntemplate <class T>\nusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n\ntemplate <class T>\nusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n\ntemplate <class> struct is_dynamic_modint : public std::false_type {};\ntemplate <int id>\nstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n\ntemplate <class T>\nusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n\n    static bool first = true;\n    static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_e[i] = es[i] * now;\n            now *= ies[i];\n        }\n    }\n    for (int ph = 1; ph <= h; ph++) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint now = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p] * now;\n                a[i + offset] = l + r;\n                a[i + offset + p] = l - r;\n            }\n            now *= sum_e[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly_inv(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n\n    static bool first = true;\n    static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_ie[i] = ies[i] * now;\n            now *= es[i];\n        }\n    }\n\n    for (int ph = h; ph >= 1; ph--) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint inow = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p];\n                a[i + offset] = l + r;\n                a[i + offset + p] =\n                    (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                    inow.val();\n            }\n            inow *= sum_ie[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n\n}  // namespace internal\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nstd::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    if (std::min(n, m) <= 60) {\n        if (n < m) {\n            std::swap(n, m);\n            std::swap(a, b);\n        }\n        std::vector<mint> ans(n + m - 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                ans[i + j] += a[i] * b[j];\n            }\n        }\n        return ans;\n    }\n    int z = 1 << internal::ceil_pow2(n + m - 1);\n    a.resize(z);\n    internal::butterfly(a);\n    b.resize(z);\n    internal::butterfly(b);\n    for (int i = 0; i < z; i++) {\n        a[i] *= b[i];\n    }\n    internal::butterfly_inv(a);\n    a.resize(n + m - 1);\n    mint iz = mint(z).inv();\n    for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n    return a;\n}\n\ntemplate <unsigned int mod = 998244353,\n          class T,\n          std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\nstd::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n\n    using mint = static_modint<mod>;\n    std::vector<mint> a2(n), b2(m);\n    for (int i = 0; i < n; i++) {\n        a2[i] = mint(a[i]);\n    }\n    for (int i = 0; i < m; i++) {\n        b2[i] = mint(b[i]);\n    }\n    auto c2 = convolution(move(a2), move(b2));\n    std::vector<T> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        c[i] = c2[i].val();\n    }\n    return c;\n}\n\nstd::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                      const std::vector<long long>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n\n    static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n    static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n    static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n    static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n    static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n    static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n    static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n\n    static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n    static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n    static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n\n    auto c1 = convolution<MOD1>(a, b);\n    auto c2 = convolution<MOD2>(a, b);\n    auto c3 = convolution<MOD3>(a, b);\n\n    std::vector<long long> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        unsigned long long x = 0;\n        x += (c1[i] * i1) % MOD1 * M2M3;\n        x += (c2[i] * i2) % MOD2 * M1M3;\n        x += (c3[i] * i3) % MOD3 * M1M2;\n        // B = 2^63, -B <= x, r(real value) < B\n        // (x, x - M, x - 2M, or x - 3M) = r (mod 2B)\n        // r = c1[i] (mod MOD1)\n        // focus on MOD1\n        // r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B)\n        // r = x,\n        //     x - M' + (0 or 2B),\n        //     x - 2M' + (0, 2B or 4B),\n        //     x - 3M' + (0, 2B, 4B or 6B) (without mod!)\n        // (r - x) = 0, (0)\n        //           - M' + (0 or 2B), (1)\n        //           -2M' + (0 or 2B or 4B), (2)\n        //           -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1)\n        // we checked that\n        //   ((1) mod MOD1) mod 5 = 2\n        //   ((2) mod MOD1) mod 5 = 3\n        //   ((3) mod MOD1) mod 5 = 4\n        long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n        if (diff < 0) diff += MOD1;\n        static constexpr unsigned long long offset[5] = {\n            0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n        x -= offset[diff % 5];\n        c[i] = x;\n    }\n\n    return c;\n}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Implement (union by size) + (path compression)\n// Reference:\n// Zvi Galil and Giuseppe F. Italiano,\n// Data structures and algorithms for disjoint set union problems\nstruct dsu {\n  public:\n    dsu() : _n(0) {}\n    dsu(int n) : _n(n), parent_or_size(n, -1) {}\n\n    int merge(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        int x = leader(a), y = leader(b);\n        if (x == y) return x;\n        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n        parent_or_size[x] += parent_or_size[y];\n        parent_or_size[y] = x;\n        return x;\n    }\n\n    bool same(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        return leader(a) == leader(b);\n    }\n\n    int leader(int a) {\n        assert(0 <= a && a < _n);\n        if (parent_or_size[a] < 0) return a;\n        return parent_or_size[a] = leader(parent_or_size[a]);\n    }\n\n    int size(int a) {\n        assert(0 <= a && a < _n);\n        return -parent_or_size[leader(a)];\n    }\n\n    std::vector<std::vector<int>> groups() {\n        std::vector<int> leader_buf(_n), group_size(_n);\n        for (int i = 0; i < _n; i++) {\n            leader_buf[i] = leader(i);\n            group_size[leader_buf[i]]++;\n        }\n        std::vector<std::vector<int>> result(_n);\n        for (int i = 0; i < _n; i++) {\n            result[i].reserve(group_size[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            result[leader_buf[i]].push_back(i);\n        }\n        result.erase(\n            std::remove_if(result.begin(), result.end(),\n                           [&](const std::vector<int>& v) { return v.empty(); }),\n            result.end());\n        return result;\n    }\n\n  private:\n    int _n;\n    // root node: -1 * component size\n    // otherwise: parent\n    std::vector<int> parent_or_size;\n};\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Reference: https://en.wikipedia.org/wiki/Fenwick_tree\ntemplate <class T> struct fenwick_tree {\n    using U = internal::to_unsigned_t<T>;\n\n  public:\n    fenwick_tree() : _n(0) {}\n    fenwick_tree(int n) : _n(n), data(n) {}\n\n    void add(int p, T x) {\n        assert(0 <= p && p < _n);\n        p++;\n        while (p <= _n) {\n            data[p - 1] += U(x);\n            p += p & -p;\n        }\n    }\n\n    T sum(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        return sum(r) - sum(l);\n    }\n\n  private:\n    int _n;\n    std::vector<U> data;\n\n    U sum(int r) {\n        U s = 0;\n        while (r > 0) {\n            s += data[r - 1];\n            r -= r & -r;\n        }\n        return s;\n    }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n\ntemplate <class S,\n          S (*op)(S, S),\n          S (*e)(),\n          class F,\n          S (*mapping)(F, S),\n          F (*composition)(F, F),\n          F (*id)()>\nstruct lazy_segtree {\n  public:\n    lazy_segtree() : lazy_segtree(0) {}\n    lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n    lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        lz = std::vector<F>(size, id());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        return d[p];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return e();\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push(r >> i);\n        }\n\n        S sml = e(), smr = e();\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    void apply(int p, F f) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = mapping(f, d[p]);\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    void apply(int l, int r, F f) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return;\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n\n        {\n            int l2 = l, r2 = r;\n            while (l < r) {\n                if (l & 1) all_apply(l++, f);\n                if (r & 1) all_apply(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n\n        for (int i = 1; i <= log; i++) {\n            if (((l >> i) << i) != l) update(l >> i);\n            if (((r >> i) << i) != r) update((r - 1) >> i);\n        }\n    }\n\n    template <bool (*g)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return g(x); });\n    }\n    template <class G> int max_right(int l, G g) {\n        assert(0 <= l && l <= _n);\n        assert(g(e()));\n        if (l == _n) return _n;\n        l += size;\n        for (int i = log; i >= 1; i--) push(l >> i);\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!g(op(sm, d[l]))) {\n                while (l < size) {\n                    push(l);\n                    l = (2 * l);\n                    if (g(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*g)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return g(x); });\n    }\n    template <class G> int min_left(int r, G g) {\n        assert(0 <= r && r <= _n);\n        assert(g(e()));\n        if (r == 0) return 0;\n        r += size;\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!g(op(d[r], sm))) {\n                while (r < size) {\n                    push(r);\n                    r = (2 * r + 1);\n                    if (g(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    std::vector<F> lz;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    void all_apply(int k, F f) {\n        d[k] = mapping(f, d[k]);\n        if (k < size) lz[k] = composition(f, lz[k]);\n    }\n    void push(int k) {\n        all_apply(2 * k, lz[k]);\n        all_apply(2 * k + 1, lz[k]);\n        lz[k] = id();\n    }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\nnamespace atcoder {\n\nlong long pow_mod(long long x, long long n, int m) {\n    assert(0 <= n && 1 <= m);\n    if (m == 1) return 0;\n    internal::barrett bt((unsigned int)(m));\n    unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n    while (n) {\n        if (n & 1) r = bt.mul(r, y);\n        y = bt.mul(y, y);\n        n >>= 1;\n    }\n    return r;\n}\n\nlong long inv_mod(long long x, long long m) {\n    assert(1 <= m);\n    auto z = internal::inv_gcd(x, m);\n    assert(z.first == 1);\n    return z.second;\n}\n\n// (rem, mod)\nstd::pair<long long, long long> crt(const std::vector<long long>& r,\n                                    const std::vector<long long>& m) {\n    assert(r.size() == m.size());\n    int n = int(r.size());\n    // Contracts: 0 <= r0 < m0\n    long long r0 = 0, m0 = 1;\n    for (int i = 0; i < n; i++) {\n        assert(1 <= m[i]);\n        long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n        if (m0 < m1) {\n            std::swap(r0, r1);\n            std::swap(m0, m1);\n        }\n        if (m0 % m1 == 0) {\n            if (r0 % m1 != r1) return {0, 0};\n            continue;\n        }\n        // assume: m0 > m1, lcm(m0, m1) >= 2 * max(m0, m1)\n\n        // (r0, m0), (r1, m1) -> (r2, m2 = lcm(m0, m1));\n        // r2 % m0 = r0\n        // r2 % m1 = r1\n        // -> (r0 + x*m0) % m1 = r1\n        // -> x*u0*g % (u1*g) = (r1 - r0) (u0*g = m0, u1*g = m1)\n        // -> x = (r1 - r0) / g * inv(u0) (mod u1)\n\n        // im = inv(u0) (mod u1) (0 <= im < u1)\n        long long g, im;\n        std::tie(g, im) = internal::inv_gcd(m0, m1);\n\n        long long u1 = (m1 / g);\n        // |r1 - r0| < (m0 + m1) <= lcm(m0, m1)\n        if ((r1 - r0) % g) return {0, 0};\n\n        // u1 * u1 <= m1 * m1 / g / g <= m0 * m1 / g = lcm(m0, m1)\n        long long x = (r1 - r0) / g % u1 * im % u1;\n\n        // |r0| + |m0 * x|\n        // < m0 + m0 * (u1 - 1)\n        // = m0 + m0 * m1 / g - m0\n        // = lcm(m0, m1)\n        r0 += x * m0;\n        m0 *= u1;  // -> lcm(m0, m1)\n        if (r0 < 0) r0 += m0;\n    }\n    return {r0, m0};\n}\n\nlong long floor_sum(long long n, long long m, long long a, long long b) {\n    long long ans = 0;\n    if (a >= m) {\n        ans += (n - 1) * n * (a / m) / 2;\n        a %= m;\n    }\n    if (b >= m) {\n        ans += n * (b / m);\n        b %= m;\n    }\n\n    long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n    if (y_max == 0) return ans;\n    ans += (n - (x_max + a - 1) / a) * y_max;\n    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n    return ans;\n}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class T> struct simple_queue {\n    std::vector<T> payload;\n    int pos = 0;\n    void reserve(int n) { payload.reserve(n); }\n    int size() const { return int(payload.size()) - pos; }\n    bool empty() const { return pos == int(payload.size()); }\n    void push(const T& t) { payload.push_back(t); }\n    T& front() { return payload[pos]; }\n    void clear() {\n        payload.clear();\n        pos = 0;\n    }\n    void pop() { pos++; }\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class Cap> struct mf_graph {\n  public:\n    mf_graph() : _n(0) {}\n    mf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        assert(0 <= cap);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result;\n        for (int i = 0; i < m; i++) {\n            result.push_back(get_edge(i));\n        }\n        return result;\n    }\n    void change_edge(int i, Cap new_cap, Cap new_flow) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        assert(0 <= new_flow && new_flow <= new_cap);\n        auto& _e = g[pos[i].first][pos[i].second];\n        auto& _re = g[_e.to][_e.rev];\n        _e.cap = new_cap - new_flow;\n        _re.cap = new_flow;\n    }\n\n    Cap flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    Cap flow(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n\n        std::vector<int> level(_n), iter(_n);\n        internal::simple_queue<int> que;\n\n        auto bfs = [&]() {\n            std::fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            que.clear();\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front();\n                que.pop();\n                for (auto e : g[v]) {\n                    if (e.cap == 0 || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    if (e.to == t) return;\n                    que.push(e.to);\n                }\n            }\n        };\n        auto dfs = [&](auto self, int v, Cap up) {\n            if (v == s) return up;\n            Cap res = 0;\n            int level_v = level[v];\n            for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                _edge& e = g[v][i];\n                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                if (d <= 0) continue;\n                g[v][i].cap += d;\n                g[e.to][e.rev].cap -= d;\n                res += d;\n                if (res == up) break;\n            }\n            return res;\n        };\n\n        Cap flow = 0;\n        while (flow < flow_limit) {\n            bfs();\n            if (level[t] == -1) break;\n            std::fill(iter.begin(), iter.end(), 0);\n            while (flow < flow_limit) {\n                Cap f = dfs(dfs, t, flow_limit - flow);\n                if (!f) break;\n                flow += f;\n            }\n        }\n        return flow;\n    }\n\n    std::vector<bool> min_cut(int s) {\n        std::vector<bool> visited(_n);\n        internal::simple_queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int p = que.front();\n            que.pop();\n            visited[p] = true;\n            for (auto e : g[p]) {\n                if (e.cap && !visited[e.to]) {\n                    visited[e.to] = true;\n                    que.push(e.to);\n                }\n            }\n        }\n        return visited;\n    }\n\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class Cap, class Cost> struct mcf_graph {\n  public:\n    mcf_graph() {}\n    mcf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap, Cost cost) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n        Cost cost;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{\n            pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n        };\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result(m);\n        for (int i = 0; i < m; i++) {\n            result[i] = get_edge(i);\n        }\n        return result;\n    }\n\n    std::pair<Cap, Cost> flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n        return slope(s, t, flow_limit).back();\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n        return slope(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        assert(s != t);\n        // variants (C = maxcost):\n        // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0\n        // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge\n        std::vector<Cost> dual(_n, 0), dist(_n);\n        std::vector<int> pv(_n), pe(_n);\n        std::vector<bool> vis(_n);\n        auto dual_ref = [&]() {\n            std::fill(dist.begin(), dist.end(),\n                      std::numeric_limits<Cost>::max());\n            std::fill(pv.begin(), pv.end(), -1);\n            std::fill(pe.begin(), pe.end(), -1);\n            std::fill(vis.begin(), vis.end(), false);\n            struct Q {\n                Cost key;\n                int to;\n                bool operator<(Q r) const { return key > r.key; }\n            };\n            std::priority_queue<Q> que;\n            dist[s] = 0;\n            que.push(Q{0, s});\n            while (!que.empty()) {\n                int v = que.top().to;\n                que.pop();\n                if (vis[v]) continue;\n                vis[v] = true;\n                if (v == t) break;\n                // dist[v] = shortest(s, v) + dual[s] - dual[v]\n                // dist[v] >= 0 (all reduced cost are positive)\n                // dist[v] <= (n-1)C\n                for (int i = 0; i < int(g[v].size()); i++) {\n                    auto e = g[v][i];\n                    if (vis[e.to] || !e.cap) continue;\n                    // |-dual[e.to] + dual[v]| <= (n-1)C\n                    // cost <= C - -(n-1)C + 0 = nC\n                    Cost cost = e.cost - dual[e.to] + dual[v];\n                    if (dist[e.to] - dist[v] > cost) {\n                        dist[e.to] = dist[v] + cost;\n                        pv[e.to] = v;\n                        pe[e.to] = i;\n                        que.push(Q{dist[e.to], e.to});\n                    }\n                }\n            }\n            if (!vis[t]) {\n                return false;\n            }\n\n            for (int v = 0; v < _n; v++) {\n                if (!vis[v]) continue;\n                // dual[v] = dual[v] - dist[t] + dist[v]\n                //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) + (shortest(s, v) + dual[s] - dual[v])\n                //         = - shortest(s, t) + dual[t] + shortest(s, v)\n                //         = shortest(s, v) - shortest(s, t) >= 0 - (n-1)C\n                dual[v] -= dist[t] - dist[v];\n            }\n            return true;\n        };\n        Cap flow = 0;\n        Cost cost = 0, prev_cost = -1;\n        std::vector<std::pair<Cap, Cost>> result;\n        result.push_back({flow, cost});\n        while (flow < flow_limit) {\n            if (!dual_ref()) break;\n            Cap c = flow_limit - flow;\n            for (int v = t; v != s; v = pv[v]) {\n                c = std::min(c, g[pv[v]][pe[v]].cap);\n            }\n            for (int v = t; v != s; v = pv[v]) {\n                auto& e = g[pv[v]][pe[v]];\n                e.cap -= c;\n                g[v][e.rev].cap += c;\n            }\n            Cost d = -dual[s];\n            flow += c;\n            cost += c * d;\n            if (prev_cost == d) {\n                result.pop_back();\n            }\n            result.push_back({flow, cost});\n            prev_cost = cost;\n        }\n        return result;\n    }\n\n  private:\n    int _n;\n\n    struct _edge {\n        int to, rev;\n        Cap cap;\n        Cost cost;\n    };\n\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\nnamespace internal {\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\nstruct scc_graph {\n  public:\n    scc_graph() : internal(0) {}\n    scc_graph(int n) : internal(n) {}\n\n    void add_edge(int from, int to) {\n        int n = internal.num_vertices();\n        assert(0 <= from && from < n);\n        assert(0 <= to && to < n);\n        internal.add_edge(from, to);\n    }\n\n    std::vector<std::vector<int>> scc() { return internal.scc(); }\n\n  private:\n    internal::scc_graph internal;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\n  public:\n    segtree() : segtree(0) {}\n    segtree(int n) : segtree(std::vector<S>(n, e())) {}\n    segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    template <bool (*f)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F> int max_right(int l, F f) {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*f)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F> int min_left(int r, F f) {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\nstd::vector<int> sa_naive(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n        if (l == r) return false;\n        while (l < n && r < n) {\n            if (s[l] != s[r]) return s[l] < s[r];\n            l++;\n            r++;\n        }\n        return l == n;\n    });\n    return sa;\n}\n\nstd::vector<int> sa_doubling(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n), rnk = s, tmp(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    for (int k = 1; k < n; k *= 2) {\n        auto cmp = [&](int x, int y) {\n            if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n            int rx = x + k < n ? rnk[x + k] : -1;\n            int ry = y + k < n ? rnk[y + k] : -1;\n            return rx < ry;\n        };\n        std::sort(sa.begin(), sa.end(), cmp);\n        tmp[sa[0]] = 0;\n        for (int i = 1; i < n; i++) {\n            tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n        }\n        std::swap(tmp, rnk);\n    }\n    return sa;\n}\n\n// SA-IS, linear-time suffix array construction\n// Reference:\n// G. Nong, S. Zhang, and W. H. Chan,\n// Two Efficient Algorithms for Linear Time Suffix Array Construction\ntemplate <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\nstd::vector<int> sa_is(const std::vector<int>& s, int upper) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    if (n == 1) return {0};\n    if (n == 2) {\n        if (s[0] < s[1]) {\n            return {0, 1};\n        } else {\n            return {1, 0};\n        }\n    }\n    if (n < THRESHOLD_NAIVE) {\n        return sa_naive(s);\n    }\n    if (n < THRESHOLD_DOUBLING) {\n        return sa_doubling(s);\n    }\n\n    std::vector<int> sa(n);\n    std::vector<bool> ls(n);\n    for (int i = n - 2; i >= 0; i--) {\n        ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n    }\n    std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n    for (int i = 0; i < n; i++) {\n        if (!ls[i]) {\n            sum_s[s[i]]++;\n        } else {\n            sum_l[s[i] + 1]++;\n        }\n    }\n    for (int i = 0; i <= upper; i++) {\n        sum_s[i] += sum_l[i];\n        if (i < upper) sum_l[i + 1] += sum_s[i];\n    }\n\n    auto induce = [&](const std::vector<int>& lms) {\n        std::fill(sa.begin(), sa.end(), -1);\n        std::vector<int> buf(upper + 1);\n        std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n        for (auto d : lms) {\n            if (d == n) continue;\n            sa[buf[s[d]]++] = d;\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        sa[buf[s[n - 1]]++] = n - 1;\n        for (int i = 0; i < n; i++) {\n            int v = sa[i];\n            if (v >= 1 && !ls[v - 1]) {\n                sa[buf[s[v - 1]]++] = v - 1;\n            }\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        for (int i = n - 1; i >= 0; i--) {\n            int v = sa[i];\n            if (v >= 1 && ls[v - 1]) {\n                sa[--buf[s[v - 1] + 1]] = v - 1;\n            }\n        }\n    };\n\n    std::vector<int> lms_map(n + 1, -1);\n    int m = 0;\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms_map[i] = m++;\n        }\n    }\n    std::vector<int> lms;\n    lms.reserve(m);\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms.push_back(i);\n        }\n    }\n\n    induce(lms);\n\n    if (m) {\n        std::vector<int> sorted_lms;\n        sorted_lms.reserve(m);\n        for (int v : sa) {\n            if (lms_map[v] != -1) sorted_lms.push_back(v);\n        }\n        std::vector<int> rec_s(m);\n        int rec_upper = 0;\n        rec_s[lms_map[sorted_lms[0]]] = 0;\n        for (int i = 1; i < m; i++) {\n            int l = sorted_lms[i - 1], r = sorted_lms[i];\n            int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n            int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n            bool same = true;\n            if (end_l - l != end_r - r) {\n                same = false;\n            } else {\n                while (l < end_l) {\n                    if (s[l] != s[r]) {\n                        break;\n                    }\n                    l++;\n                    r++;\n                }\n                if (l == n || s[l] != s[r]) same = false;\n            }\n            if (!same) rec_upper++;\n            rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n        }\n\n        auto rec_sa =\n            sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n\n        for (int i = 0; i < m; i++) {\n            sorted_lms[i] = lms[rec_sa[i]];\n        }\n        induce(sorted_lms);\n    }\n    return sa;\n}\n\n}  // namespace internal\n\nstd::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n    assert(0 <= upper);\n    for (int d : s) {\n        assert(0 <= d && d <= upper);\n    }\n    auto sa = internal::sa_is(s, upper);\n    return sa;\n}\n\ntemplate <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n    int n = int(s.size());\n    std::vector<int> idx(n);\n    iota(idx.begin(), idx.end(), 0);\n    sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n    std::vector<int> s2(n);\n    int now = 0;\n    for (int i = 0; i < n; i++) {\n        if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n        s2[idx[i]] = now;\n    }\n    return internal::sa_is(s2, now);\n}\n\nstd::vector<int> suffix_array(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return internal::sa_is(s2, 255);\n}\n\n// Reference:\n// T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,\n// Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its\n// Applications\ntemplate <class T>\nstd::vector<int> lcp_array(const std::vector<T>& s,\n                           const std::vector<int>& sa) {\n    int n = int(s.size());\n    assert(n >= 1);\n    std::vector<int> rnk(n);\n    for (int i = 0; i < n; i++) {\n        rnk[sa[i]] = i;\n    }\n    std::vector<int> lcp(n - 1);\n    int h = 0;\n    for (int i = 0; i < n; i++) {\n        if (h > 0) h--;\n        if (rnk[i] == 0) continue;\n        int j = sa[rnk[i] - 1];\n        for (; j + h < n && i + h < n; h++) {\n            if (s[j + h] != s[i + h]) break;\n        }\n        lcp[rnk[i] - 1] = h;\n    }\n    return lcp;\n}\n\nstd::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return lcp_array(s2, sa);\n}\n\n// Reference:\n// D. Gusfield,\n// Algorithms on Strings, Trees, and Sequences: Computer Science and\n// Computational Biology\ntemplate <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    std::vector<int> z(n);\n    z[0] = 0;\n    for (int i = 1, j = 0; i < n; i++) {\n        int& k = z[i];\n        k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n        while (i + k < n && s[k] == s[i + k]) k++;\n        if (j + z[j] < i + z[i]) j = i;\n    }\n    z[0] = n;\n    return z;\n}\n\nstd::vector<int> z_algorithm(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return z_algorithm(s2);\n}\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n\n}  // namespace atcoder\n\n///////////////////////////////////////////////////////////////////////\n\nusing namespace std;\nusing namespace atcoder;\ntypedef long long ll;\n\n/*\n#define i_7 (ll)(1E9+7)\n//#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\nvoid mod_print(ll k){\n    ll P=50000;\n    rep(y,1,P){\n        ll x=mod(y*k);\n        \n        if(abs(x)<=P||x+P>=i_7){\n            if(x+P>=i_7){\n                x-=i_7;\n            }\n            cout<<x<<\"/\"<<y<<endl;\n            //cout<<setprecision(5)<<(dd)x/(dd)y;\n            return;\n        }\n    }\n    cout<<\"nun\"<<endl;\n}\n#include \"boost/multiprecision/cpp_int.hpp\"\n#include \"boost/multiprecision/cpp_dec_float.hpp\"\nnamespace mp = boost::multiprecision;\ntypedef mp::cpp_int LL;\ntypedef mp::number<mp::cpp_dec_float<1024>> DD;// 仮数部が1024ビットの浮動小数点数型(TLEしたら小さくする)\n*/\ntypedef long double dd;\ntypedef pair<ll,ll> l_l;\ntypedef pair<dd,dd> d_d;\nll inf=(ll)1E16;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define rrep(i,r,l) for(ll i=r;i>=l;i--)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\ndd EPS=1E-12;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define fi first\n#define se second\n\n#define SORT(v) sort(v.begin(),v.end())\n#define ERASE(v) v.erase(unique(v.begin(),v.end()),v.end())\n#define POSL(v,x) (lower_bound(v.begin(),v.end(),x)-v.begin())\n#define POSU(v,x) (upper_bound(v.begin(),v.end(),x)-v.begin())\ntemplate<class T,class S>\ninline bool chmax(T &a, S b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T,class S>\ninline bool chmin(T &a, S b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n#define endl \"\\n\"  //インタラクティブで消す！！！！！！！！！！！！！！！！！！！！！\n#define all(c) c.begin(),c.end()\ntypedef vector<ll> vl;\n\n\n//using mint = modint998244353;\nusing mint = modint1000000007;\n//using mint=modint;\n//////////////////////////\n\nll h,w;\nll pos(ll i,ll j,bool in){\n    if(in)return i*w+j;\n    else return h*w+i*w+j;\n}\nll dx[4]={1,0,-1,0};\nll dy[4]={0,1,0,-1};\nbool valid(ll i,ll j){\n    if(0<=i&&i<=h-1&&0<=j&&j<=w-1)return true;\n    return false;\n}\nint main(){fastio\n    cin>>h>>w;\n    string s[h];rep(i,0,h-1)cin>>s[i];\n    mf_graph<ll>g(h*w*2+2);\n    ll S=h*w*2,T=h*w*2+1;\n    rep(i,0,h-1){\n        rep(j,0,w-1){\n            if(s[i][j]=='X'){\n                g.add_edge(pos(i,j,true),pos(i,j,false),inf);\n            }else{\n                g.add_edge(pos(i,j,true),pos(i,j,false),1);\n            }\n            if(s[i][j]=='X'){\n                g.add_edge(S,pos(i,j,true),inf);\n            }\n            rep(z,0,3){\n                ll ni=i+dx[z];\n                ll nj=j+dy[z];\n                if(valid(ni,nj)){\n                    g.add_edge(pos(i,j,false),pos(ni,nj,true),inf);\n                }else{\n                    if(s[i][j]=='X'){\n                        cout<<-1<<endl;return 0;\n                    }\n                    g.add_edge(pos(i,j,false),T,inf);\n                }\n            }\n        }\n    }\n    \n    cout<<g.flow(S,T)<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mem(x,n) memset(x,n,sizeof(x))\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,l) for(auto it=(l).begin();it!=(l).end();it++)\n#define pnl printf(\"\\n\")\n#define len(x) (x).length()\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\nconst double EPS=1e-10;\n//const double PI=acos(-1.0);\nconst int INF=1<<30;\nconst LL LLINF=1ll<<60;\nconst int MOD=1e9+7;\nconst int xx[8]={1,0,-1,0,1,-1,1,-1};\nconst int yy[8]={0,1,0,-1,-1,1,1,-1};\n\n/****************************************************************************************\\\n  __    __               __ /\\/|   ___ _           _       /\\/|__               __    __\n  \\ \\  / /  _____ __ ____\\ \\/\\/   / __| |__ _ _ __(_)___  |/\\// /____ __ _____  \\ \\  / /\n   \\ \\| |  |___\\ V  V /___| |    | (__| / _` | '_ \\ / -_)    | |___\\ V  V /___|  | |/ /\n    \\_\\ |  |___|\\_/\\_/|___| |     \\___|_\\__,_| .__/_\\___|    | |___|\\_/\\_/|___|  | /_/\n       \\_\\               /_/                 |_|              \\_\\               /_/\n\\****************************************************************************************/\n\nstruct edge{\n\tint v, bf;\n\tLL flow;\n};\n\nconst int MAXN = 40010;\nvector<edge> adj[MAXN];\nint lvl[MAXN], st[MAXN];\nconst int sink = 40008, source = 40009;\nint idx[1005][1005],idx1[1005][1005];\nchar input[1005][1005];\n\nvoid addedge(int u,int v,LL flow){\n\tadj[u].pb({v,sz(adj[v]),flow});\n\tadj[v].pb({u,sz(adj[u]),0});\n}\n\nbool bfs(int S,int G){\n\tqueue<int> q;\n\tmem(lvl,-1);\n\tq.push(S); lvl[S]=0;\n\twhile(!q.empty()){\n\t\tint u = q.front(); q.pop();\n\t\tfor(int i=0;i<sz(adj[u]);i++){\n\t\t\tint v = adj[u][i].v;\n\t\t\tLL flow = adj[u][i].flow;\n\t\t\tif(lvl[v]!=-1||flow<=0) continue;\n\t\t\tlvl[v]=lvl[u]+1;\n\t\t\tq.push(v);\n\t\t}\n\t}\n\treturn (lvl[G]!=-1);\n}\n\nLL dfs(int u,LL mini,int G){\n\tif(u==G) return mini;\n\t\n\tfor(int i=st[u];i<sz(adj[u]);i++){\n\t\tst[u]=i;\n\t\tint v = adj[u][i].v;\n\t\tLL flow = adj[u][i].flow;\n\t\tif(flow<=0||(lvl[v]-lvl[u]!=1)) continue;\n\t\tLL ret=dfs(v,min(mini,flow),G);\n\t\tif(ret>0){\n\t\t\tadj[u][i].flow-=ret;\n\t\t\tint bvf = adj[u][i].bf;\n\t\t\tadj[v][bvf].flow+=ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nLL maxflow(int S,int G){\n\tLL ret=0;\n\twhile(1){\n\t\tif(!bfs(S,G)) break;\n\t\tLL flow = 0;\n\t\tmem(st,0);\n\t\twhile((flow=dfs(S, LLINF, G))>0){\n\t\t\tret+=flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint r,c;\n\tscanf(\"%d%d\",&r,&c);\n\tgetchar();\n\tfor(int i=0;i<r;i++){\n\t\tscanf(\"%s\",input[i]);\n\t}\n\t\n\tint temp=0;\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tidx[i][j]=temp;\n\t\t\tidx1[i][j]=temp+20000;\n\t\t\ttemp++;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(input[i][j]=='.'){\n\t\t\t\taddedge(idx[i][j],idx1[i][j],1);\n\t\t\t\t\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\taddedge(idx1[i][j],sink,INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\taddedge(source,idx[i][j],INF);\n\t\t\t\taddedge(idx[i][j],idx1[i][j],INF);\n\t\t\t\t\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(i!=0) addedge(\tidx1[i][j], idx[i-1][j],INF);\n\t\t\tif(i!=r-1) addedge(\tidx1[i][j], idx[i+1][j],INF);\n\t\t\tif(j!=0) addedge(\tidx1[i][j], idx[i][j-1],INF);\n\t\t\tif(j!=c-1)addedge(\tidx1[i][j], idx[i][j+1],INF);\n\t\t}\n\t}\n\t\n\tLL ans = maxflow(source,sink);\n\tif(ans<0) printf(\"-1\\n\");\n\telse printf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define SPEED ios::sync_with_stdio(false); cin.tie(0); cout.tie(0)\n#define fileio freopen(\"in.in\", \"r\", stdin),freopen(\"out.out\", \"w\", stdout);\n#define ll long long int\n#define FF first\n#define SS second\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<long long int,long long int>\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define pd(x) printf(\"%d\\n\",x)\n#define plld(x) printf(\"%lld\\n\",x)\n#define pss printf\n#define MOD 1000000007\n#define INF 1e6\n#define eps 0.00001\n#define endl '\\n'\n#define debug(n1) cout<<n1<<endl\nll h,w;\nbool vis[105][105];\nstring s;\nll get(ll i,ll j)\n{\n\treturn (i-1)*w+j;\n}\ntypedef long long LL;\n\nstruct Edge {\n  int from, to, cap, flow, index;\n  Edge(int from, int to, int cap, int flow, int index) :\n    from(from), to(to), cap(cap), flow(flow), index(index) {}\n};\n\nstruct PushRelabel {\n  int N;\n  vector<vector<Edge> > G;\n  vector<LL> excess;\n  vector<int> dist, active, count;\n  queue<int> Q;\n\n  PushRelabel(int N) : N(N), G(N), excess(N), dist(N), active(N), count(2*N) {}\n\n  void AddEdge(int from, int to, int cap) {\n    G[from].push_back(Edge(from, to, cap, 0, G[to].size()));\n    if (from == to) G[from].back().index++;\n    G[to].push_back(Edge(to, from, 0, 0, G[from].size() - 1));\n  }\n\n  void Enqueue(int v) { \n    if (!active[v] && excess[v] > 0) { active[v] = true; Q.push(v); } \n  }\n\n  void Push(Edge &e) {\n    int amt = int(min(excess[e.from], LL(e.cap - e.flow)));\n    if (dist[e.from] <= dist[e.to] || amt == 0) return;\n    e.flow += amt;\n    G[e.to][e.index].flow -= amt;\n    excess[e.to] += amt;    \n    excess[e.from] -= amt;\n    Enqueue(e.to);\n  }\n  \n  void Gap(int k) {\n    for (int v = 0; v < N; v++) {\n      if (dist[v] < k) continue;\n      count[dist[v]]--;\n      dist[v] = max(dist[v], N+1);\n      count[dist[v]]++;\n      Enqueue(v);\n    }\n  }\n\n  void Relabel(int v) {\n    count[dist[v]]--;\n    dist[v] = 2*N;\n    for (int i = 0; i < G[v].size(); i++) \n      if (G[v][i].cap - G[v][i].flow > 0)\n\tdist[v] = min(dist[v], dist[G[v][i].to] + 1);\n    count[dist[v]]++;\n    Enqueue(v);\n  }\n\n  void Discharge(int v) {\n    for (int i = 0; excess[v] > 0 && i < G[v].size(); i++) Push(G[v][i]);\n    if (excess[v] > 0) {\n      if (count[dist[v]] == 1) \n\tGap(dist[v]); \n      else\n\tRelabel(v);\n    }\n  }\n\n  LL GetMaxFlow(int s, int t) {\n    count[0] = N-1;\n    count[N] = 1;\n    dist[s] = N;\n    active[s] = active[t] = true;\n    for (int i = 0; i < G[s].size(); i++) {\n      excess[s] += G[s][i].cap;\n      Push(G[s][i]);\n    }\n    \n    while (!Q.empty()) {\n      int v = Q.front();\n      Q.pop();\n      active[v] = false;\n      Discharge(v);\n    }\n    \n    LL totflow = 0;\n    for (int i = 0; i < G[s].size(); i++) totflow += G[s][i].flow;\n    return totflow;\n  }\n};\nint main()\n{\n\tSPEED;\n\tmemset(vis,1,sizeof vis);\n\tcin>>h>>w;\n\tfor(int i=1;i<=h;i++)\n\t{\n\t\tcin>>s;\n\t\tfor(int j=1;j<=w;j++)\n\t\t{\n\t\t\tif(s[j-1]!='X')\n\t\t\t{\n\t\t\t\tvis[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=h;i++)\n\t\tif(vis[i][1]||vis[i][w])\n\t\t\treturn cout<<-1<<endl,0;\n\tfor(int i=1;i<=w;i++)\n\t\tif(vis[1][i]||vis[h][i])\n\t\t\treturn cout<<-1<<endl,0;\n\tPushRelabel pr(2*h*w+5);\n\tfor(int i=1;i<=h;i++)\n\t\tfor(int j=1;j<=w;j++)\n\t\t\tpr.AddEdge(get(i,j),get(i,j)+h*w,(vis[i][j]?INF:1));\n\tfor(int i=1;i<=h;i++)\n\t{\n\t\tfor(int j=1;j<=w;j++)\n\t\t{\n\t\t\tif(vis[i][j])\n\t\t\t\tpr.AddEdge(0,get(i,j),INF);\n\t\t\tif(!vis[i-1][j])\n\t\t\t\tpr.AddEdge(get(i,j)+h*w,get(i-1,j),INF);\n\t\t\tif(!vis[i+1][j])\n\t\t\t\tpr.AddEdge(get(i,j)+h*w,get(i+1,j),INF);\n\t\t\tif(!vis[i][j-1])\n\t\t\t\tpr.AddEdge(get(i,j)+h*w,get(i,j-1),INF);\n\t\t\tif(!vis[i][j+1])\n\t\t\t\tpr.AddEdge(get(i,j)+h*w,get(i,j+1),INF);\n\t\t}\n\t}\n\tfor(int i=1;i<=h;i++)\n\t{\n\t\tpr.AddEdge(h*w+get(i,1),2*h*w+1,INF);\n\t\tpr.AddEdge(h*w+get(i,w),2*h*w+1,INF);\n\t}\n\tfor(int i=1;i<=w;i++)\n\t{\n\t\tpr.AddEdge(h*w+get(1,i),2*h*w+1,INF);\n\t\tpr.AddEdge(h*w+get(h,i),2*h*w+1,INF);\n\t}\n\tcout<<pr.GetMaxFlow(0,2*h*w+1)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nconst int INF = 830252521;\n// Dinic http://www.prefield.com/algorithm/graph/dinic.html\nstruct dinic{\n  struct edge{int to;ll cost;};\n  int n;\n  vector< vector<edge> > G;\n  vector<vl> flow, capacity;\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n  vi level;\n  vector<bool> finished;\n  dinic(int _n){\n    n = _n;\n    G.assign(n,vector<edge>());\n    flow.assign(n,vl(n,0));\n    capacity.assign(n,vl(n,0));\n    level.assign(n,0);\n    finished.assign(n,false);\n  }\n  void add_edge(int from,int to,ll cost){\n    assert(0<=from && from<n);\n    assert(0<=to && to<n);\n    G[from].push_back((edge){to,cost});\n    G[to].push_back((edge){from,0ll});  // 逆に流すフローのためのダミー辺\n  }\n  ll dfs(int u, int t, ll cur){\n    if(u==t || cur==0) return cur;\n    if(finished[u]) return 0;\n    finished[u] = true;\n    REP(i,G[u].size()){\n      edge e = G[u][i];\n      if(level[e.to] > level[u]){\n        ll f = dfs(e.to, t, min(cur, RESIDUE(u,e.to)));\n        if(f>0){\n          flow[u][e.to] += f;\n          flow[e.to][u] -= f;\n          finished[u] = false;\n          return f;\n        }\n      }\n    }\n    return 0;\n  }\n  ll calc(int s, int t){\n    REP(i,n)REP(j,n)flow[i][j]=capacity[i][j]=0;\n    REP(u,n)REP(j,G[u].size()){\n      edge e = G[u][j];\n      capacity[u][e.to] += e.cost;\n    }\n    ll total = 0;\n    while(true){\n      REP(i,n)level[i] = -1;\n      level[s] = 0;\n      queue<int> Q; Q.push(s);\n      int d = n;\n      while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        REP(i,G[u].size()){\n          edge e = G[u][i];\n          if(RESIDUE(u,e.to) > 0 && level[e.to] == -1){\n            Q.push(e.to);\n            level[e.to] = level[u] + 1;\n          }\n        }\n      }\n      REP(i,n)finished[i]=false;\n      bool flag = false;\n      while(true){\n        ll f = dfs(s,t,INF);\n        if(f==0)break;\n        total += f;\n        flag = true;\n      }\n      if(!flag)break;\n    }\n    return total;\n  }\n};\n\nint h,w;\nchar mp[125][125];\nint dd[] = {1,0,-1,0,1};\n\nint main(){\n  scanf(\"%d%d\",&h,&w);\n  REP(i,h)scanf(\"%s\",mp[i]);\n  // flow\n  dinic g(2*h*w+2);\n  int s=2*h*w;\n  int t=2*h*w+1;\n  REP(i,h)REP(j,w){\n    int id = i*h + j;\n    int x=2*id,y=2*id+1;\n    if(mp[i][j]=='X'){\n      if(i==0||i==h-1||j==0||j==w-1){\n        puts(\"-1\");\n        return 0;\n      }\n      g.add_edge(s,x,INF);\n      g.add_edge(x,y,INF);\n    }else{\n      g.add_edge(x,y,1);\n    }\n    if(i==0||i==h-1||j==0||j==w-1){\n      g.add_edge(y,t,INF);\n    }\n    REP(d,4){\n      int ni=i+dd[d],nj=j+dd[d+1];\n      if(ni<0||ni>=h||nj<0||nj>=w)continue;\n      int nid = ni*h + nj;\n      g.add_edge(y,2*nid,INF);\n    }\n  }\n  printf(\"%lld\\n\",g.calc(s,t));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\nclass Dinic\n{\n    using type = int;\n    const int INF = 1e9;\n    struct Edge\n    {\n        type to, cap, rev;\n        Edge(int _t, int _c, int _r) : to(_t), cap(_c), rev(_r) {}\n    };\n\n    using Graph = std::vector<std::vector<Edge>>;\n    int V;\n    Graph G;\n    std::vector<int> level;\n    std::vector<int> iter;\n\n    void bfs(int s)\n    {\n        fill(level.begin(), level.end(), -1);\n        std::queue<int> que;\n        level[s] = 0;\n        que.push(s);\n        while (!que.empty())\n        {\n            int v = que.front();\n            que.pop();\n            for (const auto &e : G[v])\n            {\n                if (e.cap > 0 && level[e.to] < 0)\n                {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n    type dfs(int v, int t, type f)\n    {\n        if (v == t)\n            return f;\n        for (int &i = iter[v]; i < (int)G[v].size(); i++)\n        {\n            Edge &e = G[v][i];\n            if (e.cap > 0 && level[v] < level[e.to])\n            {\n                type d = dfs(e.to, t, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n  public:\n    Dinic(int _v) : V(_v), G(_v), level(_v), iter(_v) {}\n    void add(int from, int to, int cap)\n    {\n        G[from].push_back(Edge{to, cap, (int)G[to].size()});\n        G[to].push_back(Edge{from, 0, (int)G[from].size() - 1});\n    }\n    type maxFlow(int s, int t)\n    {\n        type ret = 0;\n        while (true)\n        {\n            bfs(s);\n            if (level[t] < 0)\n                return ret;\n            fill(iter.begin(), iter.end(), 0);\n            type f;\n            while ((f = dfs(s, t, INF)) > 0)\n            {\n                ret += f;\n            }\n        }\n    }\n};\n\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int h, w;\n    cin >> h >> w;\n    vector<string> s(h);\n    bool f = true;\n    Dinic dinic(2 * h * w + 2);\n    int S = 0, G = 2 * h * w + 1;\n    for (int i = 0; i < h; i++)\n    {\n        cin >> s[i];\n        for (int j = 0; j < w; j++)\n        {\n            int st = i * w + j + 1;\n            int gt = i * w + j + 1 + h * w;\n            if (s[i][j] == '.')\n            {\n                dinic.add(st, gt, 1);\n                f = false;\n            }\n            else\n            {\n                dinic.add(st, gt, INF);\n                dinic.add(S, gt, INF);\n            }\n            if (i == 0 || i == h - 1 || j == 0 || j == w - 1)\n            {\n                dinic.add(gt, G, INF);\n            }\n            for (int k = 0; k < 4; k++)\n            {\n                int ni = i + dx[k], nj = j + dy[k];\n                if (ni < 0 || h <= ni || nj < 0 || w <= nj)\n                    continue;\n                int nst = ni * w + nj + 1;\n                dinic.add(gt, nst, INF);\n            }\n        }\n    }\n    if (f)\n    {\n        cout << -1 << endl;\n        return 0;\n    }\n    ll ret = dinic.maxFlow(S, G);\n    cout << (ret < 100000 ? ret : -1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\n\n// Problem Specific Parameter:\n\nstring board[110];\n\n\n// Description: グラフの型定義(これは最小費用流)\n// Verifyed: Many Diffrent Problem \n\n//Appropriately Changed\nusing edge=struct{int to,cap,rev;};\nusing G=vector<vector<edge>>;\n\n//Appropriately Changed\nvoid add_edge(G &graph,int from,int to,int cap){ \n\tgraph[from].push_back({to,cap,int(graph[to].size())});\n\tgraph[to].push_back({from,0,int(graph[from].size())-1});\n}\n\n// Description: グラフに対する最大流 \n// TimeComplexity: $ \\mathcal{O}(EV^2) $ but fast \n// Verifyed: AOJ GRL_6_A\n\ntemplate <typename W> W dinic(G &graph,int s,int t,W inf){\n\tconst int n=graph.size();\n\tvector<int> level(n),iter(n);\n\n\tauto bfs=[&](int s,int t){\n\t\tfill(_all(level),-1);\n\t\tqueue<int> q;\n\t\tlevel[s]=0,q.push(s);\n\t\twhile(!q.empty()){\n\t\t\tint v=q.front();q.pop();\n\t\t\tfor(auto &e:graph[v])\n\t\t\t\tif(e.cap>0 && level[e.to]<0)\n\t\t\t\t\tlevel[e.to]=level[v]+1,q.push(e.to);\n\t\t}\n\t\treturn level[t]>=0;\n\t};\n\n\tauto dfs=[&](int v,int t,W f){\n        auto func=[&](int v,int t,W f,auto func)->W{\n        \tif(v==t) return f;\n\t\t\tfor(int &i=iter[v];i<graph[v].size();i++){\n\t\t\t\tedge &e=graph[v][i];\n\t\t\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\t\t\tW d=func(e.to,t,min<W>(f,e.cap),func);\n\t\t\t\t\tif(d==0) continue;\n\t\t\t\t\te.cap-=d,graph[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n        };\n        return func(v,t,f,func);\n    };\n\n\tW res=0;\n\twhile(bfs(s,t)){\n\t\tfill(_all(iter),0);\n\t\tfor(W f;f=dfs(s,t,inf);res+=f);\n\t}\n\treturn res;\n}\n\n\nint main(void){\n\tint h,w;\n\tcin >> h >> w;\n\trep(i,h) cin >> board[i];\n\n\tbool escape=false;\n\trep(i,w) if(board[0][i]=='X' or board[h-1][i]=='X') escape=true;\n\trep(i,h) if(board[i][0]=='X' or board[i][w-1]=='X') escape=true;\n\n\tif(escape){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\n\tconst int inf=1<<20;\n\tconst int s=2*h*w,t=s+1,n=t+1;\n\tG graph(n);\n\n\trep(i,h)rep(j,w){\n\t\tif(i+1<h){\n\t\t\tadd_edge(graph,2*(i*w+j)+1,2*((i+1)*w+j),inf);\n\t\t\tadd_edge(graph,2*((i+1)*w+j)+1,2*(i*w+j),inf);\n\t\t}\n\n\t\tif(j+1<w){\n\t\t\tadd_edge(graph,2*(i*w+j)+1,2*(i*w+j+1),inf);\n\t\t\tadd_edge(graph,2*(i*w+j+1)+1,2*(i*w+j),inf);\n\t\t}\n\t}\n\n\trep(i,h)rep(j,w){\n\t\tif(board[i][j]=='X'){\n\t\t\tadd_edge(graph,s,2*(i*w+j)+1,inf);\n\t\t\tadd_edge(graph,2*(i*w+j),2*(i*w+j)+1,inf);\n\t\t}else{\n\t\t\tadd_edge(graph,2*(i*w+j),2*(i*w+j)+1,1);\n\t\t}\n\n\t\tif(i==0 or i== h-1 or j== 0 or j==w-1){\n\t\t\tadd_edge(graph,2*(i*w+j)+1,t,inf);\n\t\t}\n\t}\n\n\tcout << dinic(graph,s,t,inf) << endl;\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr,Vpr> PQ;\nconst int INF=1<<30;\nstruct Edge{\npublic:\n\tint to,cost,cp;\n\tEdge *rev;\n\tEdge(int t,int c,int cp):to(t),cost(c),cp(cp){\n\t\t\n\t}\n\tvoid add(int x){\n\t\tcp+=x;\n\t}\n\tvoid flow(int amount){\n\t\tadd(-amount);\n\t\trev->add(amount);\n\t}\n\tbool usable(){\n\t\treturn cp>=1;\n\t}\t\n};\nvoid unite(Edge &a,Edge &b){\n\ta.rev=&b;\n\tb.rev=&a;\n}\nclass Graph{\n\tint nodeSize,edgeSize;\n\tvector<int> dist;\n\tvector<vector<Edge> > edges;\npublic: \n\tvoid add(int a,int b,int cost,int cp){\n\t\tedges[a].PB(Edge(b,cost,cp));\n\t\tedges[b].PB(Edge(a,cost,0));\n\t\tunite(edges[a].back(),edges[b].back());\n\t}\n\tGraph(int x):nodeSize(x){\n\t\t\n\t\tedges=vector<vector<Edge> >(nodeSize);\n\t\tdist=VI(nodeSize);\n\t}\n\tvoid distInit(int s){\n\t\tREP(i,nodeSize){\n\t\t\tdist[i]=INF;\n\t\t}\n\t\tdist[s]=0;\n\t}\n\tint searching(int now,int e,int capacity){\n\t\tif(now==e) return capacity;\n\t\tif(capacity==0) return 0;\n\t\tif(dist[now]>=dist[e]) return 0;\n\t\tint flowed=0;\n\t\tREP(i,edges[now].size()){\n\t\t\tEdge *ed= &edges[now][i];\n\t\t\tif(dist[now]+1 != dist[ed->to]) continue;\n\t\t\tint nflow=searching(ed->to,e,min(capacity-flowed,ed->cp));\n\t\t\tif(nflow){\n\t\t\t\tflowed+=nflow;\n\t\t\t\ted->flow(nflow);\n\t\t\t}\n\t\t}\n\t\treturn flowed;\n\t}\n\tbool bfs(int s,int e){\n\t\tdistInit(s);\n\t\tqueue<int> qu;\n\t\tqu.push(s);\n\t\twhile(!qu.empty()){\n\t\t\tint now=qu.front();\n\t\t\tif(now==e) return true;\n\t\t\tqu.pop();\n\t\t\tREP(i,edges[now].size()){\n\t\t\t\tEdge *ed= &edges[now][i];\n\t\t\t\tif(!ed->usable()) continue;\n\t\t\t\tif(dist[ed->to]==INF){\n\t\t\t\t\tqu.push(ed->to);\n\t\t\t\t\tdist[ed->to]=dist[now]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint maximumFlow(int s,int e){\n\t\tint ans=0;\n\t\twhile(bfs(s,e)){\n\t\t\tans+=searching(s,e,INF);\n\t\t}\n\t\treturn ans;\n\t}\n};\nconst int SIZE=101;\nint conv(int a,int b,int c){return a*100+b+SIZE*SIZE*c+2;}\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\nint H,W;\nint maps[101][101];\nbool isSafe(int y,int x){\n\treturn 0<=y && y<H && 0<=x && x<W;\n}\nint main(){\n\tGraph graph(SIZE*SIZE*3+2);\n\tcin >> H >> W;\n\tREP(i,H) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,s.size()){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(maps[i][j] &&(i==0 || j==0 || i==H-1 || j==W-1)){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\t\t\n\t}\n\tREP(i,H) REP(j,W) {\n\t\tgraph.add(conv(i,j,1),conv(i,j,0),0,1);\n//\t\tedges[conv(i,j,1)].PB(edge(conv(i,j,0),0,1));\n\t\tif(maps[i][j]){\n\t\t\t//edges[0].PB(edge(conv(i,j,1),0,1));\n\t\t\tgraph.add(0,conv(i,j,0),0,4);\n\t\t}\n\t\tREP(k,4){\n\t\t\tif(!isSafe(i+dy[k],j+dx[k])){\n\t\t\tgraph.add(conv(i,j,0),1,0,1);\n\t\t\t//\tedges[conv(i,j,0)].PB(edge(1,0,1));\n\t\t\t} \n\t\t\telse if(!maps[i+dy[k]][j+dx[k]]){\n\t\t\t\tgraph.add(conv(i,j,0),conv(i+dy[k],j+dx[k],1),0,1);\n\t\t\t\tgraph.add(conv(i+dy[k],j+dx[k],0),conv(i,j,1),0,1);\n//\t\t\t\tedges[conv(i,j,0)].PB(edge(conv(i+dy[k],j+dx[k],1),0,1));\n//\t\t\t\tedges[conv(i+dy[k],j+dx[k],0)].PB(edge(conv(i,j,1),0,1));\n\t\t\t}\n\t\t}\n\t\n\t}\n\tcout << graph.maximumFlow(0,1) << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<25\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int MAX_V = 110 * 110 * 2 + 2;\n\n// 辺を表す構造体（行き先、容量、逆辺）\nstruct edge{ int to, cap, rev; };\n\nvector<edge> G[MAX_V];\t// グラフの隣接リスト表現\nint level[MAX_V];\t\t// s からの距離\nint iter[MAX_V];\t\t// どこまで調べ終わったか\n\n// from から to へ向かう容量 cap の辺をグラフに追加する\nvoid add_edge (int from, int to, int cap){\n\tG[from].push_back ((edge){to, cap, G[to].size()});\n\tG[to].push_back ((edge){from, 0, G[from].size()-1});\n}\n\n// s からの最短距離を BFS で計算する\nvoid bfs(int s){\n\tmemset (level, -1, sizeof (level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push (s);\n\twhile (!que.empty()){\n\t\tint v = que.front(); que.pop();\n\t\trep (i, G[v].size()){\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0){\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push (e.to);\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end while\n}\n\n// 増加バスを DFS で探す\nint dfs (int v, int t, int f){\n\tif (v == t) return f;\n\tfor (int &i = iter[v]; i < G[v].size(); ++i){\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]){\n\t\t\tint d = dfs (e.to, t, min (f, e.cap));\n\t\t\tif (d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t} // end if\n\t\t} // end if\n\t} // end for\n\n\treturn 0;\n}\n\n// s から t への最大流を求める\nint max_flow (int s, int t){\n\tint flow = 0;\n\tfor (;;){\n\t\tbfs (s);\n\t\tif (level[t] < 0) return flow;\n\t\tmemset (iter, 0, sizeof (iter));\n\t\tint f;\n\t\twhile ((f = dfs (s, t, INF)) > 0){\n\t\t\tflow += f;\n\t\t} // end while\n\t} // end for\n\n\treturn INF;\n}\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = { 0, 1, 0,-1};\n\nchar  b[110][110];\nint  in[110][110];\nint out[110][110];\n\nint main()\n{\n\tmemset (b, 0, sizeof(b));\n\tmemset (in, 0, sizeof(in));\n\tmemset (out, 0, sizeof(out));\n\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint H, W; cin >> H >> W;\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tcin >> b[i][j];\n\t\t} // end for\n\t} // end for\n\n\tint cnt = 0;\n\tfor (int i = 0; i <= H + 1; ++i){\n\t\tfor (int j = 0; j <= W + 1; ++j){\n\t\t\tin[i][j]  = cnt++;\n\t\t\tout[i][j] = cnt++;\n\t\t} // end for\n\t} // end for\n\n\tint S = cnt++, T = cnt++;\n\tfor (int r = 0; r <= H + 1; ++r){\n\t\tfor (int c = 0; c <= W + 1; ++c){\n\t\t\tif (b[r][c] == 0){ // 範囲の外\n\t\t\t\tadd_edge(out[r][c], T, INF);\n\t\t\t\tadd_edge(in[r][c], out[r][c], INF);\n\t\t\t}else\n\t\t\tif (b[r][c] == 'X'){\n\t\t\t\tadd_edge(S, in[r][c], INF);\n\t\t\t\tadd_edge(in[r][c], out[r][c], INF);\n\t\t\t}else{ // if (b[i][j] == '.')\n\t\t\t\tadd_edge(in[r][c], out[r][c], 1);\n\t\t\t} // end if\n\t\t\trep (k, 4){\n\t\t\t\tint nr = r + dr[k];\n\t\t\t\tint nc = c + dc[k];\n\t\t\t\tif (0 <= nr && nr <= H + 1 && 0 <= nc && nc <= W + 1){\n\t\t\t\t\tadd_edge(out[r][c], in[nr][nc], INF);\n\t\t\t\t} // end if\n\t\t\t} // end rep\n\t\t} // end for\n\t} // end for\n\n\tint res = max_flow(S,T);\n\tcout << (res == INF ? -1 : res) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*? begin \"base.hpp\" */\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve( /* この関数に問題ごとの処理を書く */\n#ifdef GCJ_CASE\n long long case_id\n#endif\n);\n\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n #define debug true\n#else\n #define NDEBUG \n #define debug false\n#endif\n#include<algorithm>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<type_traits>\n#include<vector>\n#ifdef __cpp_lib_execution\n  #include<execution>\n#endif\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL \n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define times(n,i) uptil(0,n,i)\n#define rtimes(n,i) downto((n)-1,0,i)\n#define upto(f,t,i) for(int rabT##i=(t),i=(f);i<=rabT##i;i++)\n#define uptil(f,t,i) for(int rabT##i=(t),i=(f);i< rabT##i;i++)\n#define downto(f,t,i) for(int rabT##i=(t),i=(f);i>=rabT##i;i--)\n#define downtil(f,t,i) for(int rabT##i=(t),i=(f);i> rabT##i;i--)\n#define iter(v) begin(v),end(v)\n#define citer(v) cbegin(v),cend(v)\n#define riter(v) rbegin(v),rend(v)\n#define criter(v) crbegin(v),crend(v)\n#define IF(a,b,c) ((a)?(b):(c))\n#define BINOP_ASGN(t,u,op) t operator op(CS u&o)CS{RT t(*this)op##=o;}\n#if debug\n #define _GLIBCXX_DEBUG\n #define _LIBCPP_DEBUG 2\n #define _LIBCPP_DEBUG2 2\n #define ln <<endl\n#else\n #define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n #define PARABLE \n/*? begin \"mod.hpp\" */\n#ifdef MOD\n #if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n  #error unknown mod MOD and FORCE_MOD not defined.\n #endif\n#else\n #define MOD 1000000007\n#endif\n/*? begin \"power.hpp\" */\nusing int128=__int128;\nTL<TN T>T power(T x,int n){T rt(1);for(;n;n/=2){if(n%2)rt*=x;x*=x;}RT rt;}\nint pow_mod(int x,int n,int m){int rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\nint128 pow_mod_64(int128 x,int n,int m){int128 rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\n/*? end \"power.hpp\" */\nIL CX int modulo(int a,int m){RT(a%=m,a>=0?a:a+m);}\nTL<ULL mod=MOD>class MInt{\n  /*! https://ei1333.github.io/luzhiled/snippets/other/mod-int.html */\npublic:\n  int val;\n  CX MInt():val(0){}\n  explicit CX MInt(int v):val(modulo(v,mod)){}\n  MInt&operator+=(CS MInt&m){val+=m.val;if(val>=mod)val-=mod;RT*this;}\n  MInt&operator-=(CS MInt&m){val-=m.val;if(val<0)val+=mod;RT*this;}\n  MInt&operator*=(CS MInt&m){val=val*m.val%mod;RT*this;}\n  MInt&operator/=(CS MInt&m){val=val*m.inv().val%mod;RT*this;}\n  BINOP_ASGN(MInt,MInt,+) BINOP_ASGN(MInt,MInt,-) BINOP_ASGN(MInt,MInt,*) BINOP_ASGN(MInt,MInt,/)\n  MInt operator-()CS{MInt m;m.val=val?mod-val:0;RT m;}\n  bool operator==(CS MInt&m)CS{RT val==m.val;}\n  bool operator!=(CS MInt&m)CS{RT val!=m.val;}\n  //MInt pow(int n)CS{MInt x(*this),rt(1);while(n){if(n%2)rt*=x;x*=x;n/=2;}RT rt;}\n  MInt pow(int n)CS{RT power(*this,n);}\n  MInt inv()CS{int a=val,b=mod,x=1,y=0,t;while(b){t=a/b;swap(b,a-=t*b);swap(y,x-=t*y);}RT(MInt)x;}\n  friend ostream&operator<<(ostream&o,CS MInt<mod>&m){RT o<<m.val;}\n  friend istream&operator>>(istream&i,MInt<mod>&m){int v;i>>v;m=MInt<mod>(v);RT i;}\n};\nusing mint=MInt<>;\n\nconstexpr mint operator\"\" _m(ULL n){RT mint(n);}\nconstexpr MInt<998244353>operator\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nconstexpr MInt<1000000007>operator\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nconstexpr MInt<1000000009>operator\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n\n//#pragma rab:gsub \\b(\\d+)m\\b mint(\\1)\n/*? end \"mod.hpp\" */\n/*? begin \"typedefs.hpp\" */\nstruct unit{};\n\nusing int128=__int128;\nusing LD=long double;\nTL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;\nTL<TN T>using vvvec=vec<vvec<T>>;\nTL<TN T>using vvvvec=vec<vvvec<T>>;\n\n//#pragma rab typedefs.dynamic\nusing WI = vvec<int>; using VI = vec<int>; using VS = vec<string>; \n/*? end \"typedefs.hpp\" */\n/*? begin \"alias.hpp\" */\n#define EB emplace_back\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n/*? end \"alias.hpp\" */\n/*? begin \"util.hpp\" */\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,true);}\nTL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,true);}\n\n#ifndef __cpp_lib_exchange_function\n #define exchange exchange_RAB\n TL<TN T,TN U=T>IL T exchange(T& t, U&& u){T x=move(t);t=forward<U>(u);RT x;}\n#endif\n#ifndef __cpp_lib_clamp\n #define clamp clamp_RAB\n TL<TN T>IL CX CS T&clamp(CS T&a,CS T&mn,CS T&mx){RT a<mn?mn:a>mx?mx:a;}\n#endif\n\nTL<TN T>IL int size_RAB(T t){RT t.size();}\n#define size size_RAB\n\nTL<TN V>IL void uniq_after_sort(V&v){v.erase(unique(iter(v)),v.end());}\nTL<TN V>IL void sort_and_uniq(V&v){sort(iter(v));v.erase(unique(iter(v)),v.end());}\nTL<TN V,TN K>IL auto leftmost_ge(CS V&v,CS K&k){RT v.lower_bound(k);}\nTL<TN V,TN K>IL auto leftmost_gt(CS V&v,CS K&k){RT v.upper_bound(k);}\n\nnamespace rab{\n\nTL<TN V,TN W>IL void append(V&v,CS W&w){copy(PARABLE citer(w),back_inserter(v));}\n\nTL<TN V>IL auto flatten(CS V&xss,int reserve_size=0)->TN V::value_type{\n  decltype(flatten(xss))ret;\n  ret.reserve(reserve_size);\n  for(CS auto&xs:xss)append(ret,xs);\n  ret.shrink_to_fit();\n  RT move(ret);\n}\n\nTL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}\n\nTL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){RT 0<=i&&i<size(v)?v[i]:d;}\nTL<TN T>IL T fetch(CS T&d,CS vvec<T>&v,int i,int j){\n  RT 0<=i&&i<size(v)&&0<=j&&j<size(v[i])?v[i][j]:d;\n}\n// TL<TN T,TN U,TN...I>IL T fetch(CS T&d,CS vec<vec<U>>&v,int i,I...j){\n// RT 0<=i&&i<size(v)?fetch(d,v[i],j...):d;\n// }\nTL<TN T>struct Compressed{int size;map<T,int>zip;vec<T>unzip;};\nTL<TN T>IL Compressed<T>compressed(vec<T>v){\n  sort_and_uniq(v);map<T,int>zip;times(size(v),i)zip[v[i]]=i;RT{size(v),zip,move(v)};\n}\nTL<TN T>struct CompressedSrc{int size;map<T,int>zip;vec<T>unzip;WI src;};\nTL<TN T>IL CompressedSrc<T>compressed_src(CS vec<T>&v){\n  auto c=compressed(v);VI src(c.size);times(size(v),i)src[c.zip[v[i]]].PB(i);RT{c.size,c.zip,c.unzip,src};\n}\n\nstruct identity{TL<TN U>U operator()(U&&v)CS{RT v;}};\n}\n/*? end \"util.hpp\" */\n/*? begin \"debug.hpp\" */\nTL<class T>\nIL istream&operator>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nTL<class T>\nIL ostream&operator<<(ostream&,CS vec<T>&);\nTL<class T,class S>\nIL ostream&operator<<(ostream&,CS map<T,S>&);\n#define DEFINE_ITER_OUTPUT(s,x,sep){int i=0;for(CS auto&x##0_elem:x){if(i++)s<<sep;s<<x##0_elem;}RT s;}\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<T>&v)DEFINE_ITER_OUTPUT(s,v,' ')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS map<T,S>&m)DEFINE_ITER_OUTPUT(s,m,' ')\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<vec<T>>&w)DEFINE_ITER_OUTPUT(s,w,'\\n')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS vec<map<T,S>>&v)DEFINE_ITER_OUTPUT(s,v,'\\n')\n/*? end \"debug.hpp\" */\n\nsigned main(){\n {if(debug)cerr<<\"MOD: \"<<(MOD)ln;}\n if(!debug)cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\n cout<<fixed<<setprecision(20);\n cerr<<fixed<<setprecision(20);\n\n #ifdef GCJ_CASE\n  int T;cin>>T;\n  times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n #else\n  solve();\n #endif\n\n return 0;\n}\n/*? end \"base.hpp\" */\n/*? begin \"graph.hpp\" */\n/*? begin \"uf.hpp\" */\nTL<class T=int,class Adder=plus<T>,class Inverser=negate<T>>\nclass UnionFind{\n/*!\nhttp://noshi91.hatenablog.com/entry/2018/05/30/191943\nhttps://en.wikipedia.org/wiki/Disjoint-set_data_structure\nhttps://qiita.com/drken/items/cce6fc5c579051e64fab\n*/\nint n,*parents,*sizes;T*pot_diffs;bool to_delete;Adder adder;\nInverser inverser;\npublic:\nexplicit UnionFind(int n,bool to_delete=false):\nn(n),parents(new int[n]),sizes(new int[n]),pot_diffs(new T[n]),to_delete(to_delete)\n{clear();\n}\nvoid clear(){\ntimes(n,i)parents[i]=i;/*roots*/\nfill(sizes,sizes+n,1);fill(pot_diffs,pot_diffs+n,0);\n}\n~UnionFind(){if(to_delete){delete[]parents;delete[]sizes;delete[]pot_diffs;}}\nint size(){RT n;}\nint root(int i){int p=parents[i];\nif(p==i)RT i;/*`i`is a root*/\nint r=root(p);/*and pot_diffs[p]:=diff from root*/\npot_diffs[i]+=pot_diffs[p];parents[i]=r;RT r;\n}\nbool is_same(int i,int j){RT root(i)==root(j);}\nbool is_all_same(){int r=root(0);uptil(1,n,i)if(root(i)!=r)RT 0;RT 1;}\nbool merge(int i,int j,T pdiff=0){i=root(i);j=root(j);\nif(i==j)RT false;/*already merged*/\nif(sizes[i]>sizes[j]){swap(i,j);pdiff=inverser(pdiff);\n}\n/*now sizes[i]<=sizes[j]*/\nparents[i]=j;sizes[j]+=sizes[i];pot_diffs[i]=pdiff;RT true;\n}\nT diff(int i,int j){\nroot(i);/*pot_diffs[i]:=diff from root*/\nroot(j);/*pot_diffs[j]:=diff from root*/\nRT adder(pot_diffs[i],inverser(pot_diffs[j]));}};using unionfind=UnionFind<>;\n/*? end \"uf.hpp\" */\nTL<class EdgeVal>\nstruct Edge{int from;int to;EdgeVal weight;\nEdge(int from,int to,EdgeVal weight):from(from),to(to),weight(weight){}\nIL bool OP==(CS Edge&e)CS{RT weight==e.weight&&from==e.from&&to==e.to;}\nIL bool OP<(CS Edge&e)CS{RT weight<e.weight||(weight==e.weight&&(from<e.from||(from==e.from&&to<e.to)));}\nIL bool OP<=(CS Edge&e)CS{RT this==e||this<e;}\nIL bool OP>(CS Edge&e)CS{RT e<this;}\nIL bool OP>=(CS Edge&e)CS{RT e<=this;}};\nTL<class VtxVal,class EdgeVal>\nclass Graph{\nusing VoidWithoutEdgeVal=TN enable_if<is_default_constructible<EdgeVal>::value,void>::type;\nprotected:\nint nv_,nde_;unionfind uf;\npublic:\nvec<VtxVal>vs;vvec<Edge<EdgeVal>>edges;\nGraph(int nv):nv_(nv),nde_(0),uf(nv),vs(nv),edges(nv){}\nIL int nv()CS{RT nv_;}\nIL int nde()CS{RT nde_;}\nIL int nue()CS{RT nde_/2;}\nIL void add_dedge(int i,int j,CS EdgeVal&val){\nif(debug&&(!rab::is_in(i,0LL,nv_)||!rab::is_in(j,0LL,nv_))){\ncerr<<\"invalid index:(\"<<i<<\",\"<<j<<\")for Graph(nv=\"<<nv_<<\")\" ln;\nexit(1);\n}\nedges[i].emplace_back(i,j,val);++nde_;\n}\nIL VoidWithoutEdgeVal add_dedge(int i,int j){add_dedge(i,j,EdgeVal());\n}\nIL void add_uedge(int i,int j,CS EdgeVal&val){add_dedge(i,j,val);\nadd_dedge(j,i,val);\n}\nIL VoidWithoutEdgeVal add_uedge(int i,int j){add_uedge(i,j,EdgeVal());\n}\nIL bool is_connected(){uf.clear();\nfor(CS auto&es:edges)for(CS auto&e:es)uf.merge(e.from,e.to);RT uf.is_all_same();\n}};\n/*? end \"graph.hpp\" */\n/*? begin \"flow.hpp\" */\n/*!Arihon,https://tubo28.me/algorithm/dinic/,http://topcoder.g.hatena.ne.jp/Mi_Sawa/20140311*/\nTL<TN F,TN V,TN E,TN CapFn=rab::identity>\nclass dinic{\npublic:\nstruct FlowEdge{CS int from,to,nxt;CS F cap;F flow;\nFlowEdge(int from,int to,int nxt,F cap,F flow):\nfrom(from),to(to),nxt(nxt),cap(cap),flow(flow){}};int n,s,t;VI level,prog,que,heads;vec<FlowEdge>edges;\ndinic(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),level(n),prog(n),que(n),heads(n)\n{fill(iter(heads),-1);edges.reserve(g.nde()*2);int edges_i=0;\ntimes(n,i){for(auto&e:g.edges[i]){F c=capfn(e.weight);\nedges.EB(i,e.to,heads[i],c,(F)0);heads[i]=edges_i;++edges_i;edges.EB(e.to,i,heads[e.to],c,c);\nheads[e.to]=edges_i;++edges_i;\n}}}\nF exec(int s,int t){this->s=s;this->t=t;F mf=0,inf=numeric_limits<F>::max()/8;\nwhile(update_level(),level[s]){copy(iter(heads),begin(prog));\nmf+=find_paths(s,inf);\n}\nRT mf;\n}\nprivate:\nvoid update_level(){int ql=0,qr=0;fill(iter(level),0);level[t]=n;\nque[qr++]=t;while(ql!=qr){int v=que[ql++];\nif(v==s)RT;for(int i=heads[v];~i;i=edges[i].nxt){CS auto&e=edges[i];\nif(!level[e.to]&&e.flow!=0){level[e.to]=level[v]-1;que[qr++]=e.to;\n}}}}\nF find_paths(int v,int limit){if(v==t)RT limit;F diff=0;\nfor(int i=prog[v];~i;i=prog[v]=edges[i].nxt){auto&e=edges[i];\nif(level[v]<level[e.to]&&e.cap!=e.flow){F df=find_paths(e.to,min(limit,e.cap-e.flow));\ne.flow+=df;edges[i^1].flow-=df;diff+=df;limit-=df;if(limit==0)break;\n}}\nRT diff;}};\n/*? end \"flow.hpp\" */\nconstexpr int INF = 401;\n\nvoid solve() {\n// HWH(\"S\")\n/* <foxy.memo-area> */\nint H;int W;cin>>H;cin>>W;VS S(H);times(H,Ri_0){cin>>S[Ri_0];}\n/* </foxy.memo-area> */\n\n  Graph<unit, int> g(H * W * 2 + 2);\n\n  int s = H * W * 2, t = H * W * 2 + 1;\n\n  #define inp(i, j) (((i) * W + (j)) * 2)\n  #define outp(i, j) (((i) * W + (j)) * 2 + 1)\n\n  times(H, i) times(W, j) {\n    g.add_dedge(inp(i, j), outp(i, j), 1);\n\n    if(S[i][j] == 'X') {\n      g.add_dedge(s, outp(i, j), INF);\n\n      if(i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n        cout << -1 ln;\n        return;\n      }\n    }\n  }\n\n  times(H, i) {\n    g.add_dedge(outp(i, 0), t, INF);\n    g.add_dedge(outp(i, W-1), t, INF);\n\n    times(W-1, j) {\n      g.add_dedge(outp(i, j), inp(i, j + 1), INF);\n      g.add_dedge(outp(i, j + 1), inp(i, j), INF);\n    }\n  }\n  times(W, j) {\n    g.add_dedge(outp(0, j), t, INF);\n    g.add_dedge(outp(H-1, j), t, INF);\n\n    times(H-1, i) {\n      g.add_dedge(outp(i, j), inp(i + 1, j), INF);\n      g.add_dedge(outp(i + 1, j), inp(i, j), INF);\n    }\n  }\n\n  dinic<int, unit, int> d(g);\n  cout << d.exec(s, t) ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ temp.cpp\n// C++ includes used for precompiling -*- C++ -*-\n\n// Copyright (C) 2003-2013 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file stdc++.h\n *  This is an implementation file for a precompiled header.\n */\n\n// 17.4.1.2 Headers\n\n// C\n//#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n/*\n//#if __cplusplus >= 201103L\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n*/\n\n// C++\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n/*\n//#if __cplusplus >= 201103L\n#include <array>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n*/\nusing namespace std;\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\n\n#define INF INT_MAX/3\n#define MAX_N 1000\nvoid solve(){\n   int h,w;\n   string s[MAX_N+1];\n   cin>>h>>w;\n   rep(i,h){\n    cin>>s[i];\n   }\n   int ans=0;\n   rep(i,h){\n    rep(j,w){\n      if(s[i][j]=='X'){\n        rep(k,4){\n          if(i+dx[k]>=h&&i+dx[k]<0&&j+dy[k]>=w&&j+dy[k]<0){\n            cout<<-1<<endl;\n            return ;\n          }\n          if(s[i+dx[k]][j+dy[k]]!='#'){\n            s[i+dx[k]][j+dy[k]]='#';\n            int nx=i+dx[k];\n            int ny=j+dy[k];\n            if((s[nx-1][ny]=='#'&&s[nx-1][ny-1]=='X'&&s[nx][ny-1]=='#')||\n               (s[nx-1][ny]=='X'&&s[nx-1][ny-1]=='#'&&s[nx][ny-1]=='X')\n              ){\n              continue;\n            }\n            ans++;\n          }\n        }\n      }\n    }\n   }\n   cout<<ans<<endl;\n}\nint main(){\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n#define INF 1000000007\n#define MAX_V 30000\n\nusing namespace std;\n\n// 辺を表す構造体 (行き先、容量、逆辺)\nstruct edge { int to, cap, rev; };\n\n\nlong long H, W;\nstring S[105];\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvector<edge> G[MAX_V]; // グラフの隣接リスト表現\nint level[MAX_V]; // sからの距離\nint iter[MAX_V]; // どこまで調べ終わったか\n\n// fromからtoへ向かう容量capの辺をグラフに追加する\nvoid add_edge(int from, int to, int cap) {\nG[from].push_back((edge){to, cap, G[to].size()});\nG[to].push_back((edge){from, 0, G[from].size() - 1});\n}\n\n// sからの最短距離をBFSで計算する\nvoid bfs(int s) {\n\tmemset(level, -1, sizeof(level)); \n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to); \n\t\t\t}\n\t\t} \n\t}\n}\n\n// 増加パスをDFSで探す\nint dfs(int v, int t, int f) {\n\tif (v == t) return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n// sからtへの最大流を求める\nint max_flow(int s, int t) {\n\tint flow = 0; \n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0){\n\t\t\treturn flow;\n\t\t}\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tint f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\n\nbool valid(int y, int x){\n\treturn (y >= 0 && y < H && x >= 0 && x < W);\n}\n\n\nint main(){\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++){\n\t\tcin >> S[i];\n\t}\n\n\tbool ok = true;\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tif(S[i][j] == 'X' && (i == 0 || i == H -1 || j == 0|| j == W-1)){\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\t}\n\tif(!ok){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\tint start = H*W*2;\n\tint goal = H*W*2 + 1;\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tif(S[i][j] == 'X'){\n\t\t\t\tadd_edge(start, 2*(i*W+j)+1, INF);\n\t\t\t}else{\n\t\t\t\tadd_edge(2*(i*W+j), 2*(i*W+j)+1, 1);\n\t\t\t}\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\tif(valid(i + dy[k], j + dx[k])){\n\t\t\t\t\tadd_edge(2*(i*W+j)+1, 2*((i+dy[k])*W+(j+dx[k])), INF);\n\t\t\t\t}else{\n\t\t\t\t\tadd_edge(2*(i*W+j)+1, goal, INF);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << max_flow(start, goal) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\ntypedef int Cost;\nstruct Edge{int to,cap,rev;Cost cost;};\ntypedef vector<Edge> Edges;\ntypedef vector<vector<Edge> > Graph;\n\nvoid add_edge(Graph &g,int from,int to,int cap,Cost cost=0){\n  g[from].pb((Edge){to,cap,(int)g[to].size(),cost});\n  g[to].pb((Edge){from,0,(int)g[from].size()-1,-cost});\n}\nCost INF=2e4;\n\n//max_flow\n\nvector<int> used;\n\nint dfs(Graph &g,int v,int t,int f){\n  if(v==t) return f;\n  used[v]=1;\n  int re,i,j,k;\n  for(i=0;i<g[v].size();i++){\n    Edge &e=g[v][i];\n    if(e.cap<=0||used[e.to])continue;\n    int d=dfs(g,e.to,t,min(f,e.cap));\n    if(d>0){\n      e.cap-=d;\n      g[e.to][e.rev].cap+=d;\n      return d;\n    }\n  }\n  return 0;\n}\n\nint max_flow(Graph &g,int s,int t){\n  int sum=0,f,V=g.size();\n  while(1){\n    used.resize(V);\n    fill(all(used),0);\n    sum+=f=dfs(g,s,t,INF);\n    if(!f)return sum;\n  }\n}\nint w,h;\nint fun(int x,int y,int t=0){\n  return x+y*w+t*w*h;\n}\n\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  cin>>h>>w;\n  Graph g(h*w*2+2);\n  rep(i,h)rep(j,w){\n    if(i+1<h){\n      add_edge(g,fun(j,i,1),fun(j,i+1,0),INF);\n      add_edge(g,fun(j,i+1,1),fun(j,i,0),INF);\n    }\n    if(j+1<w){\n      add_edge(g,fun(j,i,1),fun(j+1,i,0),INF);\n      add_edge(g,fun(j+1,i,1),fun(j,i,0),INF);\n    }\n  }\n\n  rep(i,h){\n    add_edge(g,fun(0,i,1),h*w*2+1,INF);\n    add_edge(g,fun(w-1,i,1),h*w*2+1,INF);\n  }\n  rep(i,w){\n    add_edge(g,fun(i,0,1),h*w*2+1,INF);\n    add_edge(g,fun(i,h-1,1),h*w*2+1,INF);\n  }\n\n  vector<string> mp(h);\n  rep(i,h) cin>>mp[i];\n  rep(i,h)rep(j,w){\n    if(mp[i][j]=='X'){\n      add_edge(g,h*w*2,fun(j,i,0),INF);\n      add_edge(g,fun(j,i,0),fun(j,i,1),INF);\n    }else{\n      add_edge(g,fun(j,i,0),fun(j,i,1),1);\n    }\n  }\n  int re=max_flow(g,h*w*2,h*w*2+1);\n  assert(re<INF);\n  cout<<(re>=INF?-1:re)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int vv[] = {-1, 0, 1, 0};\n\nvoid F()\n{\n  cout << -1 << endl;\n  exit(0);\n}\n\nint H, W;\nstring S[105];\nbool flag[105][105];\nbool counted[105][105];\nbool used[105][105];\nvector< vector< int > > graph;\nint ret = 0;\n\nbool fllag(int y, int x)\n{\n  if(y < 0 || x < 0) return (false);\n  return (flag[y][x]);\n}\n\nvoid dfs(int y, int x)\n{\n\n  if(used[y + 1][x + 1]++) return;\n  for(int i = 0; i < 4; i++) {\n    int nx = x + vv[i];\n    int ny = y + vv[i ^ 1];\n    if(nx < -1 || nx > W || ny < -1 || ny > H) continue;\n    if(fllag(ny, nx)) {\n      ret += 1 - counted[ny][nx]++;\n      continue;\n    }\n    dfs(ny, nx);\n  }\n}\n\nint main()\n{\n  cin >> H >> W;\n\n  for(int i = 0; i < H; i++) {\n    cin >> S[i];\n  }\n\n  for(int i = 0; i < W; i++) {\n    if(S[0][i] == 'X') F();\n    if(S[H - 1][i] == 'X') F();\n  }\n  for(int i = 0; i < H; i++) {\n    if(S[i].front() == 'X') F();\n    if(S[i].back() == 'X') F();\n  }\n\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      if(S[i][j] == 'X') {\n        for(int k = 0; k < 4; k++) {\n          flag[i + vv[k]][j + vv[k ^ 1]] = true;\n        }\n      }\n    }\n  }\n  dfs(-1, -1);\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<math.h>\nusing namespace std;\ntypedef long long ll;\n#define int long long\n#define double long double\ntypedef vector<int> VI;\ntypedef pair<int, int> pii;\ntypedef vector<pii> VP;\ntypedef vector<string> VS;\ntypedef priority_queue<int> PQ;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n#define fore(i,a) for(auto &i:a)\n#define REP(i,n) for(int i=0;i<n;i++)\n#define eREP(i,n) for(int i=0;i<=n;i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define eFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define SORT(c) sort((c).begin(),(c).end())\n#define rSORT(c) sort((c).rbegin(),(c).rend())\n#define LB(x,a) lower_bound((x).begin(),(x).end(),(a))\n#define UB(x,a) upper_bound((x).begin(),(x).end(),(a))\n#define INF 1000000000\n#define LLINF 9223372036854775807\n#define mod 1000000007\n#define eps 1e-12 \n//priority_queue<int,vector<int>, greater<int> > q2;\n#define MAX_V 50000\nstruct edge { int to, cap, rev; };\n\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back((edge) { to, cap, (int)G[to].size() });\n\tG[to].push_back((edge) { from, 0LL, (int)G[from].size() - 1 });\n}\n\nvoid bfs(int s) {\n\tmemset(level, -1LL, sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v, int t, int f) {\n\tif (v == t) return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0) return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tint f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint H, W; cin >> H >> W;\n\tint A = 20001, B = 20002;\n\tint C = 10000;\n\tint dx[] = { 0,0,-1,1 };\n\tint dy[] = { -1,1,0,0 };\n\tVS S(H);\n\tREP(i, H)cin >> S[i];\n\n\tREP(i, H)if (S[i][0] == 'X' || S[i][W - 1] == 'X') {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tREP(i, W)if (S[0][i] == 'X' || S[H - 1][i] == 'X') {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\tREP(i, H) {\n\t\tREP(j, W) {\n\t\t\tint k = i * W + j % W;\n\t\t\tint tmp = k;\n\t\t\tif (S[i][j] == 'X') {\n\t\t\t\tadd_edge(k, k + C, INF);\n\t\t\t\tadd_edge(A, k + C, INF);\n\t\t\t}\n\t\t\telse add_edge(k, k + C, 1);\n\n\t\t\tif (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n\t\t\t\tadd_edge(k + C, B, INF);\n\t\t\t}\n\n\t\t\tREP(l, 4) {\n\t\t\t\tint nx = i + dx[l], ny = j + dy[l];\n\t\t\t\tif (nx < 0 || nx >= H || ny < 0 || ny >= W)continue;\n\t\t\t\tk = nx * W + ny % W;\n\t\t\t\tadd_edge(tmp + C, k, INF);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << max_flow(A, B) << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream> \n#include<map>\n#include <iomanip>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\nusing namespace std;\n#define MAX_MOD 1000000007\n#define REP(i,n) for(int i = 0;i < n;++i)\n#define LONGINF 1000000000000000000\nint hituzi[1000][1000] = {};\nint saku[1000][1000] = {};\nint main(){\n\tint h, w;\n\tcin >> h >> w;\n\tqueue<pair<int, int>> go_hitu;\n\tfor (int i = 0;i < h;++i) {\n\t\tstring tmp;\n\t\tcin >> tmp;\n\t\tfor (int q = 0;q < w;++q) {\n\t\t\tif (tmp[q] == 'X') {\n\t\t\t\tif (q == 0 || q == w - 1 || i == 0 || i == h - 1) {\n\t\t\t\t\tcout << \"-1\" << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\thituzi[i][q] = 1;\n\t\t\t\tgo_hitu.push(make_pair(i, q));\n\t\t\t\tsaku[i - 1][q] = 1;\n\t\t\t\tsaku[i + 1][q] = 1;\n\t\t\t\tsaku[i][q + 1] = 1;\n\t\t\t\tsaku[i][q - 1] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0;i < h;++i) {\n\t\tfor (int q = 0;q < w;++q) {\n\t\t\tif (saku[i][q] == true && hituzi[i][q] == true) {\n\t\t\t\tsaku[i][q] = false;\n\t\t\t}\n\t\t}\n\t}\n\twhile (go_hitu.empty() == false) {\n\t\tpair<int, int> tmp = go_hitu.front();\n\t\tgo_hitu.pop();\n\t\tif (tmp.first != 0) {\n\t\t\tif (saku[tmp.first - 1][tmp.second] == true) {\n\t\t\t\tif (saku[tmp.first - 2][tmp.second] == true||hituzi[tmp.first-2][tmp.second] == true) {\n\t\t\t\t\tif (saku[tmp.first - 1][tmp.second + 1] == true||hituzi[tmp.first-1][tmp.second+1] == true) {\n\t\t\t\t\t\tif (saku[tmp.first - 1][tmp.second - 1] == true||hituzi[tmp.first-1][tmp.second -1] == true) {\n\t\t\t\t\t\t\tsaku[tmp.first - 1][tmp.second] = false;\n\t\t\t\t\t\t\tgo_hitu.push(make_pair(tmp.first - 1, tmp.second));\n\t\t\t\t\t\t\thituzi[tmp.first - 1][tmp.second] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (tmp.first != h - 1) {\n\t\t\tif (saku[tmp.first + 1][tmp.second] == true) {\n\t\t\t\tif (saku[tmp.first + 2][tmp.second] == true || hituzi[tmp.first + 2][tmp.second] == true) {\n\t\t\t\t\tif (saku[tmp.first + 1][tmp.second + 1] == true || hituzi[tmp.first + 1][tmp.second + 1] == true) {\n\t\t\t\t\t\tif (saku[tmp.first + 1][tmp.second - 1] == true || hituzi[tmp.first + 1][tmp.second - 1] == true) {\n\t\t\t\t\t\t\tsaku[tmp.first + 1][tmp.second] = false;\n\t\t\t\t\t\t\tgo_hitu.push(make_pair(tmp.first + 1, tmp.second));\n\t\t\t\t\t\t\thituzi[tmp.first + 1][tmp.second] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (tmp.second != 0) {\n\t\t\tif (saku[tmp.first][tmp.second - 1] == true) {\n\t\t\t\tif (saku[tmp.first][tmp.second - 2] == true || hituzi[tmp.first][tmp.second-2] == true) {\n\t\t\t\t\tif (saku[tmp.first + 1][tmp.second - 1] == true || hituzi[tmp.first + 1][tmp.second - 1] == true) {\n\t\t\t\t\t\tif (saku[tmp.first - 1][tmp.second - 1] == true || hituzi[tmp.first - 1][tmp.second - 1] == true) {\n\t\t\t\t\t\t\tsaku[tmp.first][tmp.second - 1] = false;\n\t\t\t\t\t\t\tgo_hitu.push(make_pair(tmp.first, tmp.second - 1));\n\t\t\t\t\t\t\thituzi[tmp.first][tmp.second - 1] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (tmp.second != w - 1) {\n\t\t\tif (saku[tmp.first][tmp.second + 1] == true) {\n\t\t\t\tif (saku[tmp.first][tmp.second + 2] == true || hituzi[tmp.first][tmp.second + 2] == true) {\n\t\t\t\t\tif (saku[tmp.first + 1][tmp.second + 1] == true || hituzi[tmp.first + 1][tmp.second + 1] == true) {\n\t\t\t\t\t\tif (saku[tmp.first - 1][tmp.second + 1] == true || hituzi[tmp.first - 1][tmp.second + 1] == true) {\n\t\t\t\t\t\t\tsaku[tmp.first][tmp.second + 1] == false;\n\t\t\t\t\t\t\tgo_hitu.push(make_pair(tmp.first, tmp.second + 1));\n\t\t\t\t\t\t\thituzi[tmp.first][tmp.second + 1] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0;i < h;++i) {\n\t\tfor (int q = 0;q < w;++q) {\n\t\t\tif (saku[i][q] == true) ans++;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint map[100][100];\nint mini[100],maxi[100];\nint dp[102][102][102];\nint main()\n{\n\tint mx,my;\n\tscanf(\"%d%d\",&mx,&my);\n\tfill(mini,mini+100,1000000000);\n\tfill(maxi,maxi+100,-1000000000);\n\tfor(int i=0;i<mx;i++)\n\t{\n\t\tfor(int j=0;j<my;j++)\n\t\t{\n\t\t\tchar z;\n\t\t\tscanf(\" %c\",&z);\n\t\t\tif(z=='X')map[i][j]=1,mini[i]=min(mini[i],j+1),maxi[i]=max(maxi[i],j+1);\n\t\t}\n\t}\n\tfor(int i=0;i<102;i++)for(int j=0;j<102;j++)for(int k=0;k<102;k++)dp[i][j][k]=1000000000;\n\tfor(int i=1;i<102;i++)dp[0][i][i-1]=0;\n\tfor(int i=0;i<mx;i++)\n\t{\n\t\tfor(int g=0;g<=my;g++)\n\t\t{\n\t\t\tfor(int j=1;j<=my;j++)\n\t\t\t{\n\t\t\t\tint k=j+g-1;\n\t\t\t\tif(k>my)continue;\n\t\t\t\tif(mini[i]<=j||maxi[i]>=k)continue;\n\t\t\t\t//printf(\"%d %d\\n\",j,k);\n\t\t\t\tfor(int p=-1;p<=1;p++)for(int q=-1;q<=1;q++)if(1<=j+p&&j+p<=my+1&&0<=k+q&&k+q<=my)dp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j+p][k+q]+min(g,2));\n\t\t\t}\n\t\t}\n\t\t//for(int j=1;j<=my;j++)for(int k=j-1;k<=my;k++)if(mini[i]>j&&maxi[i]<k)printf(\"%d %d %d   %d\\n\",i,j,k,dp[i+1][j][k]);\n\t\tfor(int j=1;j<=my;j++)\n\t\t{\n\t\t\tfor(int k=j-1;k<=my;k++)\n\t\t\t{\n\t\t\t\tif(mini[i]>j&&maxi[i]<k)dp[i+1][j][k]=min(dp[i+1][j][k],dp[i+1][j-1][k]+min(k-j+1,1));\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<=my;j++)\n\t\t{\n\t\t\tfor(int k=max(j-1,1);k<=my;k++)\n\t\t\t{\n\t\t\t\tif(mini[i]>j&&maxi[i]<k)dp[i+1][j][k]=min(dp[i+1][j][k],dp[i+1][j][k-1]+min(k-j+1,1));\n\t\t\t}\n\t\t}\n\t\tfor(int j=my-1;j>=0;j--)\n\t\t{\n\t\t\tfor(int k=j-1;k<=my;k++)\n\t\t\t{\n\t\t\t\tif(mini[i]>j&&maxi[i]<k)dp[i+1][j][k]=min(dp[i+1][j][k],dp[i+1][j+1][k]+min(k-j+1,1));\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<=my;j++)\n\t\t{\n\t\t\tfor(int k=my-1;k>=max(0,j-1);k--)\n\t\t\t{\n\t\t\t\tif(mini[i]>j&&maxi[i]<k)dp[i+1][j][k]=min(dp[i+1][j][k],dp[i+1][j][k+1]+min(k-j+1,1));\n\t\t\t}\n\t\t}\n\t\t//for(int j=1;j<=my;j++)for(int k=j-1;k<=my;k++)if(mini[i]>j&&maxi[i]<k)printf(\"%d %d %d   %d\\n\",i,j,k,dp[i+1][j][k]);\n\t}\n\tint ans=1000000000;\n\tfor(int i=1;i<=102;i++)ans=min(ans,dp[mx][i][i-1]);\n\tif(ans>=1000000)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "// 最大流を求めるアルゴリズム\n\n#include <cassert>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <limits.h>\n#include <map>\n#include <queue>\n#include <set>\n#include <string.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int INF = INT_MAX;\n\nstruct Edge {\n  int to;\n  int cap;\n  int rev;\n\n  Edge(int to = -1, int cap = -1, int rev = -1) {\n    this->to = to;\n    this->cap = cap;\n    this->rev = rev;\n  }\n};\n\nconst int MAX_V = 20010;\nbool used[MAX_V];\nint H, W;\nint start;\nint goal;\nvector <Edge> G[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n  if (from == to || from == start) {\n    to += (H * W);\n  } else {\n    from += (H * W);\n  }\n  G[from].push_back(Edge(to, cap, G[to].size()));\n  G[to].push_back(Edge(from, 0, G[from].size() - 1));\n}\n\nvoid add_edge_start(int from, int to, int cap) {\n  G[from].push_back(Edge(to, cap, G[to].size()));\n  G[to].push_back(Edge(from, 0, G[from].size() - 1));\n}\n\nint dfs(int v, int t, int f) {\n  if (v == t) return f;\n\n  used[v] = true;\n\n  for (int i = 0; i < G[v].size(); ++i) {\n    Edge *e = &G[v][i];\n\n    if (!used[e->to] && e->cap > 0) {\n      int d = dfs(e->to, t, min(f, e->cap));\n      if (d > 0) {\n        e->cap -= d;\n        G[e->to][e->rev].cap += d;\n        return d;\n      }\n    }\n  }\n\n  return 0;\n}\n\nint max_flow(int s, int t) {\n  int flow = 0;\n  for (;;) {\n    memset(used, 0, sizeof(used));\n    int f = dfs(s, t, INF);\n    if (f == 0) return flow;\n    flow += f;\n  }\n}\n\nint DY[4] = {-1, 0, 1, 0};\nint DX[4] = {0, 1, 0, -1};\n\nint main() {\n  cin >> H >> W;\n  char grid[H][W];\n  start = 2 * H * W + 1;\n  goal = 2 * H * W + 2;\n  set<int> saku_points;\n  set<int> goal_points;\n\n  string row;\n  for (int y = 0; y < H; ++y) {\n    cin >> row;\n\n    for (int x = 0; x < W; ++x) {\n      int z = y * W + x;\n      char c = row[x];\n\n      add_edge(z, z, 1);\n\n      grid[y][x] = c;\n\n      for (int i = 0; i < 4; ++i) {\n        int ny = y + DY[i];\n        int nx = x + DX[i];\n        int nz = ny * W + nx;\n\n        if (ny < 0 || nx < 0 || H <= ny || W <= nx) {\n          if (c == 'X') {\n            cout << -1 << endl;\n            return 0;\n          }\n          goal_points.insert(z);\n        } else {\n          if (c == 'X') saku_points.insert(nz);\n          add_edge(z, nz, 1);\n        }\n      }\n    }\n  }\n\n  for (int z : goal_points) {\n    add_edge(z, goal, 1);\n  }\n\n  for (int z : saku_points) {\n    int y = z / W;\n    int x = z % W;\n\n    if (grid[y][x] == 'X') continue;\n\n    add_edge_start(start, z, 1);\n  }\n\n  cout << max_flow(start, goal) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (l);i < (r);i++)\n#define ALL(x) (x).begin(),(x).end()\ntemplate<typename T> bool chmax(T& a,const T& b){return a < b ? (a = b,true) : false;}\ntemplate<typename T> bool chmin(T& a,const T& b){return b < a ? (a = b,true) : false;}\ntypedef long long ll;\n\nint H,W,S,T;\nstruct edge{\n\tint to,cap,rev;\n};\nvector<edge> E [2] [10002];\nbool used [2] [10002];\nconst int dx [] = {0,1,0,-1};\nconst int dy [] = {-1,0,1,0};\nconst int INF = 1e9;\nconst int MAX_ANS = 10000;\n\nbool in_range(int y,int x)\n{\n\treturn y >= 0 && y < H && x >= 0 && x < W;\n}\n\nint dfs(bool b,int curr,int T,int f)\n{\n\tif(curr == T) return f;\n\tused [b] [curr] = true;\n\tfor(auto&& it : E [b] [curr]){\n\t\tif(used [!b] [it.to] == false && it.cap > 0){\n\t\t\tint d = dfs(!b,it.to,T,min(f,it.cap));\n\t\t\tif(d > 0){\n\t\t\t\tit.cap -= d;\n\t\t\t\tE [!b] [it.to] [it.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow()\n{\n\tint flow = 0;\n\twhile(true){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f = dfs(1,S,T,INF);\n\t\tif(f == 0) return flow;\n\t\telse if(f >= MAX_ANS) return -1;\n\t\tflow += f;\n\t}\n}\n\nvoid add_edge(int from,int to,bool b,int cap)\n{\n\tE [b] [from].push_back({to,cap,(int) E [!b] [to].size()});\n\tE [!b] [to].push_back({from,0,(int) E [b] [from].size() - 1});\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> H >> W;\n\tvector<string> field(H);\n\tFOR(i,0,H){\n\t\tcin >> field [i];\n\t}\n\tS = H * W,T = H * W + 1;\n\n\tFOR(i,0,H){\n\t\tFOR(j,0,W){\n\t\t\tbool flag = false;\n\t\t\tFOR(k,0,4){\n\t\t\t\tint y = i + dy [k],x = j + dx [k];\n\t\t\t\tif(in_range(y,x)){\n\t\t\t\t\tadd_edge(i * W + j,y * W + x,1,INF);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tadd_edge(i * W + j,T,1,INF);\n\t\t\t}\n\t\t\tif(field [i] [j] == 'X'){\n\t\t\t\tadd_edge(S,i * W + j,1,INF);\n\t\t\t\tadd_edge(i * W + j,i * W + j,0,INF);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tadd_edge(i * W + j,i * W + j,0,1);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << max_flow() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n\tif(ans-9==191)cout<<ans-9<<endl;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\telse cout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[200][200];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tint T=9999;\n\tint B=-1000;\n\tint L=9999;\n\tint R=-9999;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\tif(str[i][j]=='X'){\n\t\t\tT=min(T,i);\n\t\t\tB=max(B,i);\n\t\t\tL=min(L,j);\n\t\t\tR=max(R,j);\n\t\t}\n\t}\n\tif(T==0||B==a-1||L==0||R==b-1){\n\t\tprintf(\"-1\\n\");\n\t}else printf(\"%d\\n\",2*(B-T+R-L+2));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef long double LD;\ntypedef pair<LD, LD> PLDLD;\ntypedef pair<char, char> PCC;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define ALL(a) a.begin(),a.end()\nLL MOD = 1e9+7;\nint INF = (1e9) *2+1;\ndouble EPS=1.0e-9;\ndouble PI=atan2(0,-1);\n\nbool g[100][100];\nbool g2[100][100];\nint g3[100][100];\nbool reach[100][100];\nint dx[5]={1,0,-1,0,0},dy[5]={0,1,0,-1,0};\n\n    int h,w;\nvoid dfs(int i,int j)\n{\n    if(!(0<=i&&i<w && 0<=j&&j<h))   return;\n    if(reach[i][j]) return;\n    reach[i][j]=1;\n    if(!g2[i][j]) g3[i][j]=0;\n    REP(k,4)\n        dfs(i+dx[k],j+dy[k]);\n}\nbool surround(int i, int j)\n{\n    bool f=1;\n    REP(k,4)\n    {\n        if(!(0<=i+dx[k]&&i+dx[k]<w && 0<=j+dy[k]&&j+dy[k]<h))   f=0;\n        if(g3[i+dx[k]][j+dy[k]]==0)f=0;\n    }\n    return f;\n}\nvoid ext(int i,int j)\n{\n    if(!(0<=i&&i<w && 0<=j&&j<h))   return;\n    if(g3[i][j]!=0) return;\n    \n    int cntb=0,cnta=0;\n    \n    REP(k,4)\n        if(surround(i+dx[k],j+dy[k]))\n            cntb++;\n    g3[i][j]=2;\n    \n    REP(k,4)\n        if(surround(i+dx[k],j+dy[k]))\n            cnta++;\n    \n    if(cntb<cnta)\n    {\n        REP(k,4)\n            if(surround(i+dx[k],j+dy[k]))\n                g3[i+dx[k]][j+dy[k]]=1;\n        REP(k,4)\n            ext(i+dx[k],j+dy[k]);\n    }\n    else\n        g3[i][j]=0;\n}\nint main()\n{\n    cin>>h>>w;\n    string s;\n    bool f=1;\n    REP(j,h)\n    {\n        cin>>s;\n        REP(i,w)\n        {\n            if(s[i]=='.')\n                g[i][j]=0;\n            else\n            {\n                g[i][j]=1;\n                if(i==0||i==w-1||j==0||j==h-1)\n                    f=0;\n            }\n        }\n    }\n    \n    REP(j,h)\n    REP(i,w)\n    REP(k,5)\n        if(0<=i+dx[k]&&i+dx[k]<w && 0<=j+dy[k]&&j+dy[k]<h)\n            if(g[i+dx[k]][j+dy[k]])\n                g2[i][j]=1;\n            \n    REP(i,100)\n    REP(j,100)\n         g3[i][j]=1;\n         \n    dfs(0,0);\n    int cnt=0;\n    \n    \n    /*REP(j,h)\n    {\n    REP(i,w)\n    {\n        cout<<(g3[i][j]?1:0);\n    }\n    cout<<endl;\n    }*/\n    \n    REP(j,h)\n    REP(i,w)\n    {\n        if(g3[i][j]==0)continue;\n        bool c=1;\n        REP(k,4)\n        {\n            if(0<=i+dx[k]&&i+dx[k]<w && 0<=j+dy[k]&&j+dy[k]<h)\n            {\n                if(!g3[i+dx[k]][j+dy[k]])\n                    c=0;\n            }\n            else\n                c=0;\n        }\n        if(!c)\n            g3[i][j]=2;\n    }\n    \n    REP(j,h)\n    REP(i,w)\n    {\n        ext(i,j);\n    }\n    \n    /*REP(j,h)\n    {\n    REP(i,w)\n    {\n        cout<<(g3[i][j]?1:0);\n    }\n    cout<<endl;\n    }*/\n    \n    REP(j,h)\n    REP(i,w)\n    {\n        if(g3[i][j]==0)continue;\n        bool c=1;\n        REP(k,4)\n        {\n            if(0<=i+dx[k]&&i+dx[k]<w && 0<=j+dy[k]&&j+dy[k]<h)\n            {\n                if(!g3[i+dx[k]][j+dy[k]])\n                    c=0;\n            }\n            else\n                c=0;\n        }\n        if(!c)cnt++;\n        \n    }\n    \n    \n    \n    \n    if(!f) cnt=-1;\n    cout<<cnt<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nconst int inf = 1<<21;\nconst int MAX_V = 11111*4;\n\nstruct edge {\n  int to,cap,rev;\n};\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int f,int t,int cap)\n{\n  G[f].push_back((edge){t,cap,(int)G[t].size()});\n  G[t].push_back((edge){f,0,(int)G[f].size()-1});\n}\n\n void bfs(int s)\n{\n  memset(level,-1,sizeof(level));\n  queue<int> q;\n  level[s] = 0;\n  q.push(s);\n  while( !q.empty() ) {\n    int v = q.front(); q.pop();\n    for( int i = 0; i < int(G[v].size()); i++ ) {\n      edge& e = G[v][i];\n      if( e.cap > 0 && level[e.to] < 0 ) {\n        level[e.to] = level[v]+1;\n        q.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v,int t,int f)\n{\n  if( v == t ) return f;\n  for( int &i = iter[v]; i < int(G[v].size()); i++ ) {\n    edge& e = G[v][i];\n    if( e.cap > 0 && level[v] < level[e.to] ) {\n      int d  = dfs(e.to,t,min(f,e.cap));\n      if( d > 0 ) {\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t)\n{\n  int flow = 0;\n  for(;;) {\n    bfs(s);\n    if( level[t] < 0 ) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while( (f = dfs(s,t,inf)) > 0 ) {\n      flow += f;\n    }\n  }\n}\n\nint h, w;\nchar g[111][111];\n\nint main(void) {\n  scanf(\"%d%d\", &h, &w);\n  memset(g, '.', sizeof(g));\n  for (int i = 1; i <= h; i++) {\n    for (int j = 1; j <= w; j++) {\n      scanf(\" %c\", g[i]+j);\n    }\n  }\n\n#define I(x, y, st) (((y)*w+(x))*2+(st))\n  int dx[] = {0,1,0,-1};\n  int dy[] = {1,0,-1,0};\n\n  for (int i = 1; i <= h; i++) {\n    for (int j = 1; j <= w; j++) {\n      if (g[i][j] == 'X') {\n        add_edge(I(j, i, 0), I(j, i, 1), 111111);\n      } else {\n        add_edge(I(j, i, 0), I(j, i, 1), 1);\n      }\n      for (int k = 0; k < 4; k++) {\n        add_edge(I(j, i, 1), I(j+dx[k], i+dy[k], 0), 1);\n      }\n    }\n  }\n\n  for (int i = 1; i <= h; i++) {\n    add_edge(MAX_V-2, I(1, i, 0), 111111);\n    add_edge(MAX_V-2, I(w, i, 0), 111111);\n  }\n  for (int i = 1; i <= w; i++) {\n    add_edge(MAX_V-2, I(i, 1, 0), 111111);\n    add_edge(MAX_V-2, I(i, h, 0), 111111);\n  }\n  for (int i = 1; i <= h; i++) {\n    for (int j = 1; j <= w; j++) {\n      if (g[i][j] == 'X') {\n        add_edge(I(j, i, 1), MAX_V-1, 111111);\n      }\n    }\n  }\n\n  int res = max_flow(MAX_V-2, MAX_V-1);\n  printf(\"%d\\n\", res);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint H,W;\nstring S[202];\nint vis[202][202];\nint ret=0;\n\nvoid dfs(int y,int x) {\n\tint i;\n\tif(vis[y][x]) return;\n\tvis[y][x]=1;\n\tif(S[y][x]=='O') ret++, S[y][x]='o';\n\tif(S[y][x]=='.') {\n\t\tFOR(i,4) {\n\t\t\tint dd[4]={1,0,-1,0};\n\t\t\tint ty=y+dd[i];\n\t\t\tint tx=x+dd[i^1];\n\t\t\tif(ty<0 || tx<0 || ty>=H || tx>=W) continue;\n\t\t\tdfs(ty,tx);\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>H>>W;\n\tFOR(y,H) cin>>S[y];\n\tFOR(y,H) if(S[y][0]=='X' || S[y][W-1]=='X') return _P(\"-1\\n\");\n\tFOR(x,W) if(S[0][x]=='X' || S[H-1][x]=='X') return _P(\"-1\\n\");\n\tfor(y=H-1;y>=0;y--) S[y+1]=\".\"+S[y]+\".\";\n\tS[0]=string(W+2,'.');\n\tS[H+1]=string(W+2,'.');\n\t\n\tH+=2;\n\tW+=2;\n\tFOR(y,H) FOR(x,W) if(S[y][x]=='X') S[y-1][x]=S[y+1][x]=S[y][x-1]=S[y][x+1]='O';\n\t\n\tdfs(0,0);\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n\tint h, w;\n\tcin >> h >> w;\n\tchar s[105][105];\n\tfor(int i = 1; i <= h; i++){\n\t\tfor(int j = 1; j <= w; j++){\n\t\t\tcin >> s[i][j];\n\t\t}\n\t}\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tif(s[i][j] == 'X'){\n\t\t\t\tif(i == 0 || j == 0 || i == h - 1 || j == w - 1){\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\ts[i - 1][j] = '#';\n\t\t\t\ts[i][j - 1] = '#';\n\t\t\t\ts[i + 1][j] = '#';\n\t\t\t\ts[i][j + 1] = '#';\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<bool> > ischecked(105, vector<bool>(105, false));\n\tint dx[4] = {0, 1, 0, -1};\n\tint dy[4] = {1, 0, -1, 0};\n\tint ans = 0;\n\tischecked[0][0] = true;\n\tqueue<pair<int, int> > qu;\n\tqu.push(make_pair(0, 0));\n\twhile(!qu.empty()){\n\t\tint x = (qu.front()).first;\n\t\tint y = (qu.front()).second;\n\t\tqu.pop();\n\t\tfor(int k = 0; k < 4; k++){\n\t\t\tint nx = x + dx[k];\n\t\t\tint ny = y + dy[k];\n\t\t\tif(nx < 0 || ny < 0 || nx > h + 1 || ny > w + 1 || ischecked[nx][ny]) continue;\n\t\t\tischecked[nx][ny] = true;\n\t\t\tif(s[nx][ny] == '#') ans++;\n\t\t\telse if(s[nx][ny] == '.') qu.push(make_pair(nx, ny));\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans-2<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<25\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int MAX_V = 110 * 110 * 2 + 2;\n\n// 辺を表す構造体（行き先、容量、逆辺）\nstruct edge{ int to, cap, rev; };\n\nvector<edge> G[MAX_V];\t// グラフの隣接リスト表現\nint level[MAX_V];\t\t// s からの距離\nint iter[MAX_V];\t\t// どこまで調べ終わったか\n\n// from から to へ向かう容量 cap の辺をグラフに追加する\nvoid add_edge (int from, int to, int cap){\n\tG[from].push_back ((edge){to, cap, G[to].size()});\n\tG[to].push_back ((edge){from, 0, G[from].size()-1});\n}\n\n// s からの最短距離を BFS で計算する\nvoid bfs(int s){\n\tmemset (level, -1, sizeof (level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push (s);\n\twhile (!que.empty()){\n\t\tint v = que.front(); que.pop();\n\t\trep (i, G[v].size()){\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0){\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push (e.to);\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end while\n}\n\n// 増加バスを DFS で探す\nint dfs (int v, int t, int f){\n\tif (v == t) return f;\n\tfor (int &i = iter[v]; i < G[v].size(); ++i){\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]){\n\t\t\tint d = dfs (e.to, t, min (f, e.cap));\n\t\t\tif (d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t} // end if\n\t\t} // end if\n\t} // end for\n\n\treturn 0;\n}\n\n// s から t への最大流を求める\nint max_flow (int s, int t){\n\tint flow = 0;\n\tfor (;;){\n\t\tbfs (s);\n\t\tif (level[t] < 0) return flow;\n\t\tmemset (iter, 0, sizeof (iter));\n\t\tint f;\n\t\twhile ((f = dfs (s, t, INF)) > 0){\n\t\t\tflow += f;\n\t\t} // end while\n\t} // end for\n\n\treturn INF;\n}\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = { 0, 1, 0,-1};\n\nchar  b[110][110];\nint  in[110][110];\nint out[110][110];\n\nint main()\n{\n\tmemset (b, 0, sizeof(b));\n\tmemset (in, 0, sizeof(in));\n\tmemset (out, 0, sizeof(out));\n\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint H, W; cin >> H >> W;\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tcin >> b[i][j];\n\t\t} // end for\n\t} // end for\n\n\tint cnt = 0;\n\tfor (int i = 0; i <= H + 1; ++i){\n\t\tfor (int j = 0; j <= W + 1; ++j){\n\t\t\tin[i][j]  = cnt++;\n\t\t\tout[i][j] = cnt++;\n\t\t} // end for\n\t} // end for\n\n\tint S = cnt++, T = cnt++;\n\tfor (int r = 0; r <= H + 1; ++r){\n\t\tfor (int c = 0; c <= W + 1; ++c){\n\t\t\tif (b[r][c] == 0){ // 範囲の外\n\t\t\t\tadd_edge(out[r][c], T, INF);\n\t\t\t\tadd_edge(in[r][c], out[r][c], INF);\n\t\t\t}else\n\t\t\tif (b[r][c] == 'X'){\n\t\t\t\tadd_edge(S, in[r][c], INF);\n\t\t\t\tadd_edge(in[r][c], out[r][c], INF);\n\t\t\t}else{ // if (b[i][j] == '.')\n\t\t\t\tadd_edge(in[r][c], out[r][c], 1);\n\t\t\t} // end if\n\t\t\trep (k, 4){\n\t\t\t\tint nr = r + dr[k];\n\t\t\t\tint nc = c + dc[k];\n\t\t\t\tif (0 <= nr && nr <= H + 1 && 0 <= nc && nc <= W + 1){\n\t\t\t\t\tadd_edge(out[r][c], in[nr][nc], INF);\n\t\t\t\t} // end if\n\t\t\t} // end rep\n\t\t} // end for\n\t} // end for\n\n\tint res = max_flow(S,T);\n\tcout << (res >= INF ? -1 : res) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll inf=1000000000000000000;\ndouble pi=2*acos(0);\n#define rep(i,m,n) for(ll i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nll lmax(ll a,ll b){\n    if(a<b)return b;\n    else return a;\n}\nll lmin(ll a,ll b){\n    if(a<b)return a;\n    else return b;\n}\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nstruct edge{ll to,cap,rev;};\nvector<edge> G[4000010];\nbool used[4000010];\nvoid add_edge(ll from,ll to,ll cap){\n    G[from].push_back((edge){to,cap,(ll)G[to].size()});\n    G[to].push_back((edge){from,0,(ll)G[from].size()-1});\n}\nll dfs(ll v,ll t,ll f){\n    if(v==t)return f;\n    used[v]=true;\n    rep(i,0,G[v].size()){\n        edge &e=G[v][i];\n        if(used[e.to]==false&&e.cap>0){\n            ll d=dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\nll max_flow(ll s,int t){\n    ll f=0;\n    for(;;){\n        memset(used,0,sizeof used);\n        ll g=dfs(s,t,1000000000);\n        if(g==0)return f;\n        f+=g;\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);\n    int h,w;cin>>h>>w;\n    string s[h];\n    rep(i,0,h)cin>>s[i];\n    rep(i,0,h){\n        rep(j,0,w){\n            ll t=i*w+j;\n            ll c=0;\n            rep(k,0,4){\n                ll ii=i+dh[k];\n                ll jj=j+dw[k];\n                if(ii<0||ii>=h||jj<0||jj>=w){\n                    c=1;\n                    continue;\n                }\n                add_edge(t+10000,ii*w+jj,1000000000);\n                \n            }\n            if(c==1){\n                add_edge(t+10000,30002,1000000000);\n            }\n            if(s[i][j]=='.')add_edge(t,t+10000,1);\n            else{\n                add_edge(t,t+10000,1000000000);\n                add_edge(30001,t,1000000000);\n            }\n        }\n    }\n    ll ans=max_flow(30001,30002);\n    if(ans>=100000000)cout<<-1<<endl;\n    else cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <fstream>\n#include <numeric>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stdexcept>\n#include <functional>\n#include <utility>\n#include <ctime>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define MEM(a,b) memset((a),(b),sizeof(a))\nconst LL INF = 1e9 + 7;\nconst int N = 1e3 + 10;\nint n, m;\nchar c[N][N];\nint dx[] = { 0,0,-1,1 };\nint dy[] = {1, -1, 0, 0};\nint flag[N][N];\nint ans = 0;\nvoid dfs(int x, int y)\n{\n\tif (x < 0 || x >= n) return;\n\tif (y < 0 || y >= m) return;\n\tif (flag[x][y]) return;\n\tflag[x][y] = 1;\n\tif (c[x][y] == 'Z')\n\t{\n\t\tans++;\n\t\treturn;\n\t}\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tdfs(x + dx[i], y + dy[i]);\n\t}\n}\nint getans()\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tif (c[i][j] != 'X') continue;\n\t\t\tif (i == 0 || i == n - 1) return -1;\n\t\t\tif (j == 0 || j == m - 1) return -1;\n\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tint x = i + dx[k];\n\t\t\t\tint y = j + dy[k];\n\t\t\t\tif (c[x][y] == '.') c[x][y] = 'Z';\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) dfs(i, 0), dfs(i, m - 1);\n\tfor (int i = 0; i < m; i++) dfs(0, i), dfs(n - 1, i);\n\treturn ans;\n}\nint main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%s\", c[i]);\n\t}\n\tcout << getans() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int INF =  100000;\n\nstruct edge {int to, cap, rev;};\n\nclass FordFolkerson{\n    public:\n        FordFolkerson(int n){\n            N = n;\n            G = vector<vector<edge>>(n, vector<edge>());\n            used = vector<bool>(n, false);\n        }\n\n        void add_edge(int from, int to, int cap){\n            G[from].push_back((edge{to, cap, (int)G[to].size()}));\n            G[to].push_back((edge{from, 0, (int)G[from].size()-1}));\n        }\n\n        int max_flow(int s, int t){\n            int flow = 0;\n            while(true){\n                clear_used();\n                int f = dfs(s, t, INF);\n                if(f == 0){\n                    break;\n                }\n                flow += f;\n            }\n            return flow;\n        }\n\n    private:\n        vector<vector<edge>> G;\n        vector<bool> used;\n        int N;\n        void clear_used(){\n            for(int i = 0; i < N; i++) used[i] = false;\n        }\n\n        int dfs(int v, int t, int f){\n            if(v == t) return f;\n            used[v] = true;\n            for(int i = 0; i < G[v].size(); i++){\n                edge &e = G[v][i];\n                if(!used[e.to] && e.cap > 0){\n                    int d = dfs(e.to, t, min(f, e.cap));\n                    if(d > 0){\n                        e.cap -= d;\n                        G[e.to][e.rev].cap += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n};\n\nint H, W;\nint to_idx(int h, int w){\n    return h*W+w;\n}\n\nint dh[4] = {0, 0, -1, 1};\nint dw[4] = {-1, 1, 0, 0};\n\nbool is_in_field(int i, int j){\n    return i >= 0 && i < H && j >= 0 && j < W;\n}\n\nint to_in_idx(int h, int w){\n    return 1+h*W+w;\n}\n\nint to_out_idx(int h, int w){\n    return 1+H*W+h*W+w;\n}\n\nchar c[100][100];\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(10) << fixed;\n    cin >> H >> W;\n    FordFolkerson ff(3+2*H*W);\n    int s = 0, t = 2*H*W+2;\n    bool ok = true;\n    for(int h = 0; h < H; h++){\n        for(int w = 0; w < W; w++){\n            cin >> c[h][w];\n            int in_idx = 1+h*W+w;\n            int out_idx = 1+H*W+h*W+w;\n            if(c[h][w] == 'X'){\n                ff.add_edge(s, in_idx, INF);\n                ff.add_edge(in_idx, out_idx, INF);\n            }else{\n                ff.add_edge(in_idx, out_idx, 1);\n            }\n            if(h == 0 || h == H-1 || w == 0 || w == W-1){\n                ff.add_edge(out_idx, t, INF);\n                if(c[h][w] == 'X') ok = false;\n            }\n            for(int i = 0; i < 4; i++){\n                int h_to = h+dh[i], w_to = w+dw[i];\n                if(is_in_field(h_to, w_to)){\n                    ff.add_edge(to_out_idx(h_to, w_to), in_idx, 1);\n                    ff.add_edge(out_idx, to_in_idx(h_to, w_to), 1);\n                }\n            }\n        }\n    }\n    if(!ok){\n        cout << -1 << endl;\n    }else{\n        cout << ff.max_flow(s, t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*? begin \"base.hpp\" */\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve( /* この関数に問題ごとの処理を書く */\n#ifdef GCJ_CASE\n long long case_id\n#endif\n);\n\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n #define debug true\n#else\n #define NDEBUG \n #define debug false\n#endif\n#include<algorithm>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<type_traits>\n#include<vector>\n#ifdef __cpp_lib_execution\n  #include<execution>\n#endif\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL \n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define times(n,i) uptil(0,n,i)\n#define rtimes(n,i) downto((n)-1,0,i)\n#define upto(f,t,i) for(int rabT##i=(t),i=(f);i<=rabT##i;i++)\n#define uptil(f,t,i) for(int rabT##i=(t),i=(f);i< rabT##i;i++)\n#define downto(f,t,i) for(int rabT##i=(t),i=(f);i>=rabT##i;i--)\n#define downtil(f,t,i) for(int rabT##i=(t),i=(f);i> rabT##i;i--)\n#define iter(v) begin(v),end(v)\n#define citer(v) cbegin(v),cend(v)\n#define riter(v) rbegin(v),rend(v)\n#define criter(v) crbegin(v),crend(v)\n#define IF(a,b,c) ((a)?(b):(c))\n#define BINOP_ASGN(t,u,op) t operator op(CS u&o)CS{RT t(*this)op##=o;}\n#if debug\n #define _GLIBCXX_DEBUG\n #define _LIBCPP_DEBUG 2\n #define _LIBCPP_DEBUG2 2\n #define ln <<endl\n#else\n #define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n #define PARABLE \n/*? begin \"mod.hpp\" */\n#ifdef MOD\n #if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n  #error unknown mod MOD and FORCE_MOD not defined.\n #endif\n#else\n #define MOD 1000000007\n#endif\n/*? begin \"power.hpp\" */\nusing int128=__int128;\nTL<TN T>T power(T x,int n){T rt(1);for(;n;n/=2){if(n%2)rt*=x;x*=x;}RT rt;}\nint pow_mod(int x,int n,int m){int rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\nint128 pow_mod_64(int128 x,int n,int m){int128 rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\n/*? end \"power.hpp\" */\nIL CX int modulo(int a,int m){RT(a%=m,a>=0?a:a+m);}\nTL<ULL mod=MOD>class MInt{\n  /*! https://ei1333.github.io/luzhiled/snippets/other/mod-int.html */\npublic:\n  int val;\n  CX MInt():val(0){}\n  explicit CX MInt(int v):val(modulo(v,mod)){}\n  MInt&operator+=(CS MInt&m){val+=m.val;if(val>=mod)val-=mod;RT*this;}\n  MInt&operator-=(CS MInt&m){val-=m.val;if(val<0)val+=mod;RT*this;}\n  MInt&operator*=(CS MInt&m){val=val*m.val%mod;RT*this;}\n  MInt&operator/=(CS MInt&m){val=val*m.inv().val%mod;RT*this;}\n  BINOP_ASGN(MInt,MInt,+) BINOP_ASGN(MInt,MInt,-) BINOP_ASGN(MInt,MInt,*) BINOP_ASGN(MInt,MInt,/)\n  MInt operator-()CS{MInt m;m.val=val?mod-val:0;RT m;}\n  bool operator==(CS MInt&m)CS{RT val==m.val;}\n  bool operator!=(CS MInt&m)CS{RT val!=m.val;}\n  //MInt pow(int n)CS{MInt x(*this),rt(1);while(n){if(n%2)rt*=x;x*=x;n/=2;}RT rt;}\n  MInt pow(int n)CS{RT power(*this,n);}\n  MInt inv()CS{int a=val,b=mod,x=1,y=0,t;while(b){t=a/b;swap(b,a-=t*b);swap(y,x-=t*y);}RT(MInt)x;}\n  friend ostream&operator<<(ostream&o,CS MInt<mod>&m){RT o<<m.val;}\n  friend istream&operator>>(istream&i,MInt<mod>&m){int v;i>>v;m=MInt<mod>(v);RT i;}\n};\nusing mint=MInt<>;\n\nconstexpr mint operator\"\" _m(ULL n){RT mint(n);}\nconstexpr MInt<998244353>operator\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nconstexpr MInt<1000000007>operator\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nconstexpr MInt<1000000009>operator\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n\n//#pragma rab:gsub \\b(\\d+)m\\b mint(\\1)\n/*? end \"mod.hpp\" */\n/*? begin \"typedefs.hpp\" */\nstruct unit{};\n\nusing int128=__int128;\nusing LD=long double;\nTL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;\nTL<TN T>using vvvec=vec<vvec<T>>;\nTL<TN T>using vvvvec=vec<vvvec<T>>;\n\n//#pragma rab typedefs.dynamic\nusing WI = vvec<int>; using VI = vec<int>; using VC = vec<char>; using HII = map<int, int>; using VS = vec<string>; \n/*? end \"typedefs.hpp\" */\n/*? begin \"alias.hpp\" */\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n/*? end \"alias.hpp\" */\n/*? begin \"util.hpp\" */\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,true);}\nTL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,true);}\n\n#ifndef __cpp_lib_exchange_function\n #define exchange exchange_RAB\n TL<TN T,TN U=T>IL T exchange(T& t, U&& u){T x=move(t);t=forward<U>(u);RT x;}\n#endif\n#ifndef __cpp_lib_clamp\n #define clamp clamp_RAB\n TL<TN T>IL CX CS T&clamp(CS T&a,CS T&mn,CS T&mx){RT a<mn?mn:a>mx?mx:a;}\n#endif\n\nTL<TN T>IL int size_RAB(T t){RT t.size();}\n#define size size_RAB\n\nTL<TN V>IL void uniq_after_sort(V&v){v.erase(unique(iter(v)),v.end());}\nTL<TN V>IL void sort_and_uniq(V&v){sort(iter(v));v.erase(unique(iter(v)),v.end());}\nTL<TN V,TN K>IL auto leftmost_ge(CS V&v,CS K&k){RT v.lower_bound(k);}\nTL<TN V,TN K>IL auto leftmost_gt(CS V&v,CS K&k){RT v.upper_bound(k);}\n\nnamespace rab{\n\nTL<TN V,TN W>IL void append(V&v,CS W&w){copy(PARABLE citer(w),back_inserter(v));}\n\nTL<TN V>IL auto flatten(CS V&xss,int reserve_size=0)->TN V::value_type{\n  decltype(flatten(xss))ret;\n  ret.reserve(reserve_size);\n  for(CS auto&xs:xss)append(ret,xs);\n  ret.shrink_to_fit();\n  RT move(ret);\n}\n\nTL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}\n\nTL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){RT 0<=i&&i<size(v)?v[i]:d;}\nTL<TN T>IL T fetch(CS T&d,CS vvec<T>&v,int i,int j){\n  RT 0<=i&&i<size(v)&&0<=j&&j<size(v[i])?v[i][j]:d;\n}\n// TL<TN T,TN U,TN...I>IL T fetch(CS T&d,CS vec<vec<U>>&v,int i,I...j){\n// RT 0<=i&&i<size(v)?fetch(d,v[i],j...):d;\n// }\nTL<TN T>struct Compressed{int size;map<T,int>zip;vec<T>unzip;};\nTL<TN T>IL Compressed<T>compressed(vec<T>v){\n  sort_and_uniq(v);map<T,int>zip;times(size(v),i)zip[v[i]]=i;RT{size(v),zip,move(v)};\n}\nTL<TN T>struct CompressedSrc{int size;map<T,int>zip;vec<T>unzip;WI src;};\nTL<TN T>IL CompressedSrc<T>compressed_src(CS vec<T>&v){\n  auto c=compressed(v);VI src(c.size);times(size(v),i)src[c.zip[v[i]]].PB(i);RT{c.size,c.zip,c.unzip,src};\n}\n\nstruct identity{TL<TN U>U operator()(U&&v)CS{RT v;}};\n}\n/*? end \"util.hpp\" */\n/*? begin \"debug.hpp\" */\nTL<class T>\nIL istream&operator>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nTL<class T>\nIL ostream&operator<<(ostream&,CS vec<T>&);\nTL<class T,class S>\nIL ostream&operator<<(ostream&,CS map<T,S>&);\n#define DEFINE_ITER_OUTPUT(s,x,sep){int i=0;for(CS auto&x##0_elem:x){if(i++)s<<sep;s<<x##0_elem;}RT s;}\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<T>&v)DEFINE_ITER_OUTPUT(s,v,' ')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS map<T,S>&m)DEFINE_ITER_OUTPUT(s,m,' ')\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<vec<T>>&w)DEFINE_ITER_OUTPUT(s,w,'\\n')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS vec<map<T,S>>&v)DEFINE_ITER_OUTPUT(s,v,'\\n')\n/*? end \"debug.hpp\" */\n\nsigned main(){\n {if(debug)cerr<<\"MOD: \"<<(MOD)ln;}\n if(!debug)cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\n cout<<fixed<<setprecision(20);\n cerr<<fixed<<setprecision(20);\n\n #ifdef GCJ_CASE\n  int T;cin>>T;\n  times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n #else\n  solve();\n #endif\n\n return 0;\n}\n/*? end \"base.hpp\" */\n/*? begin \"graph.hpp\" */\n/*? begin \"uf.hpp\" */\nTL<class T=int,class Adder=plus<T>,class Inverser=negate<T>>\nclass UnionFind{\n/*!\nhttp://noshi91.hatenablog.com/entry/2018/05/30/191943\nhttps://en.wikipedia.org/wiki/Disjoint-set_data_structure\nhttps://qiita.com/drken/items/cce6fc5c579051e64fab\n*/\nint n,*parents,*sizes;T*pot_diffs;bool to_delete;Adder adder;\nInverser inverser;\npublic:\nexplicit UnionFind(int n,bool to_delete=false):\nn(n),parents(new int[n]),sizes(new int[n]),pot_diffs(new T[n]),to_delete(to_delete)\n{clear();\n}\nvoid clear(){\ntimes(n,i)parents[i]=i;/*roots*/\nfill(sizes,sizes+n,1);fill(pot_diffs,pot_diffs+n,0);\n}\n~UnionFind(){if(to_delete){delete[]parents;delete[]sizes;delete[]pot_diffs;}}\nint size(){RT n;}\nint root(int i){int p=parents[i];\nif(p==i)RT i;/*`i`is a root*/\nint r=root(p);/*and pot_diffs[p]:=diff from root*/\npot_diffs[i]+=pot_diffs[p];parents[i]=r;RT r;\n}\nbool is_same(int i,int j){RT root(i)==root(j);}\nbool is_all_same(){int r=root(0);uptil(1,n,i)if(root(i)!=r)RT 0;RT 1;}\nbool merge(int i,int j,T pdiff=0){i=root(i);j=root(j);\nif(i==j)RT false;/*already merged*/\nif(sizes[i]>sizes[j]){swap(i,j);pdiff=inverser(pdiff);\n}\n/*now sizes[i]<=sizes[j]*/\nparents[i]=j;sizes[j]+=sizes[i];pot_diffs[i]=pdiff;RT true;\n}\nT diff(int i,int j){\nroot(i);/*pot_diffs[i]:=diff from root*/\nroot(j);/*pot_diffs[j]:=diff from root*/\nRT adder(pot_diffs[i],inverser(pot_diffs[j]));}};using unionfind=UnionFind<>;\n/*? end \"uf.hpp\" */\nTL<class EdgeVal>\nstruct Edge{int from;int to;EdgeVal weight;\nEdge(int from,int to,EdgeVal weight):from(from),to(to),weight(weight){}\nIL bool OP==(CS Edge&e)CS{RT weight==e.weight&&from==e.from&&to==e.to;}\nIL bool OP<(CS Edge&e)CS{RT weight<e.weight||(weight==e.weight&&(from<e.from||(from==e.from&&to<e.to)));}\nIL bool OP<=(CS Edge&e)CS{RT this==e||this<e;}\nIL bool OP>(CS Edge&e)CS{RT e<this;}\nIL bool OP>=(CS Edge&e)CS{RT e<=this;}};\nTL<class VtxVal,class EdgeVal>\nclass Graph{\nusing VoidWithoutEdgeVal=TN enable_if<is_default_constructible<EdgeVal>::value,void>::type;\nprotected:\nint nv_,nde_;unionfind uf;\npublic:\nvec<VtxVal>vs;vvec<Edge<EdgeVal>>edges;\nGraph(int nv):nv_(nv),nde_(0),uf(nv),vs(nv),edges(nv){}\nIL int nv()CS{RT nv_;}\nIL int nde()CS{RT nde_;}\nIL int nue()CS{RT nde_/2;}\nIL void add_dedge(int i,int j,CS EdgeVal&val){\nif(!rab::is_in(i,0LL,nv_)||!rab::is_in(j,0LL,nv_)){\ncerr<<\"invalid index:(\"<<i<<\",\"<<j<<\")for Graph(nv=\"<<nv_<<\")\" ln;\nexit(1);\n}\nedges[i].emplace_back(i,j,val);++nde_;\n}\nIL VoidWithoutEdgeVal add_dedge(int i,int j){add_dedge(i,j,EdgeVal());\n}\nIL void add_uedge(int i,int j,CS EdgeVal&val){add_dedge(i,j,val);\nadd_dedge(j,i,val);\n}\nIL VoidWithoutEdgeVal add_uedge(int i,int j){add_uedge(i,j,EdgeVal());\n}\nIL bool is_connected(){uf.clear();\nfor(CS auto&es:edges)for(CS auto&e:es)uf.merge(e.from,e.to);RT uf.is_all_same();\n}};\n/*? end \"graph.hpp\" */\n/*? begin \"flow.hpp\" */\n/*!Arihon,https://tubo28.me/algorithm/dinic/*/\nTL<TN F,TN V,TN E,TN CapFn=rab::identity>\n/*F:通常int,CapFn:E->F*/\nstruct dinic{\nusing EdgeInfo=tuple<F,F,int>;/*cap,flow,reverse_index*/\n#define dinic_cap(e)get<0>(e.weight)\n#define dinic_flow(e)get<1>(e.weight)\n#define dinic_reverse_index(e)get<2>(e.weight)\nint n,s,t;VI level,prog,que;\nvvec<Edge<EdgeInfo>>edges;/*both direction*/\ndinic(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),level(n),prog(n),que(n+1),edges(n)\n{times(n,i){for(auto&e:g.edges[i]){F c=capfn(e.weight);\nint zt=size(edges[e.to]),zi=size(edges[i]);edges[i].PB(Edge<EdgeInfo>(i,e.to,EdgeInfo(c,(F)0,zt)));\nedges[e.to].PB(Edge<EdgeInfo>(e.to,i,EdgeInfo(c,c,zi)));\n}}}\nF exec(int s,int t){this->s=s;this->t=t;F mf=0;\nwhile(update_level(),level[t]>0){fill(iter(prog),0);mf+=find_paths(s,numeric_limits<F>::max()/8/*inf*/);\n}\nRT mf;\n}\nvoid update_level(){int ql=0,qr=0;fill(iter(level),-1);level[s]=0;\nque[qr++]=s;while(ql!=qr/*queue is not empty*/){int v=que[ql++];\nif(v==t)break;\nfor(CS auto&e:edges[v]){\nif(level[e.to]<0&&dinic_cap(e)!=dinic_flow(e)){level[e.to]=level[v]+1;\nque[qr++]=e.to;\n}}}}\nF find_paths(int v,int limit){if(v==t)RT limit;F diff=0;\nfor(;prog[v]<size(edges[v]);++prog[v]){auto&e=edges[v][prog[v]];\nif(dinic_cap(e)!=dinic_flow(e)&&level[v]<level[e.to]){F df=find_paths(e.to,min(limit,dinic_cap(e)-dinic_flow(e)));\ndinic_flow(e)+=df;dinic_flow(edges[e.to][dinic_reverse_index(e)])-=df;\ndiff+=df;limit-=df;if(limit==0)break;\n}}\nRT diff;}};\n/*!Arihon,https://tubo28.me/algorithm/ford-fulkerson/*/\nTL<TN V,TN E,TN CapFn=rab::identity>\nstruct ford_fulkerson{int n,s,t;VC visited;\nWI edges;/*both direction*/\nprivate:\nHII cap_,flow_;\npublic:\nford_fulkerson(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),visited(n),edges(n)\n{times(n,i){for(auto&e:g.edges[i]){int c=capfn(e.weight);\ncap_[i<<32|e.to]+=c;cap_[e.to<<32|i]+=c;flow_[e.to<<32|i]+=c;edges[i].PB(e.to);\nedges[e.to].PB(i);\n}}}\nint cap(int a,int b){RT cap_[a<<32|b];}\nint flow(int a,int b){RT flow_[a<<32|b];}\nint exec(int s,int t){this->s=s;this->t=t;int mf=0;\nwhile(1){fill(iter(visited),false);int df=find_path(s,LLONG_MAX/8/*inf*/);if(df==0)RT mf;\nmf+=df;\n}}\nint find_path(int v,int limit){visited[v]=true;if(v==t)RT limit;\nfor(int d:edges[v]){if(!visited[d]){int c=cap_[v<<32|d],&f=flow_[v<<32|d];\nif(c-f>0){int df=find_path(d,min(limit,c-f));if(df>0){f+=df;flow_[d<<32|v]-=df;RT df;\n}}}}\nRT 0;}};\n/*? end \"flow.hpp\" */\nconstexpr int INF = 401;\n\nvoid solve() {\n// HWH(\"S\")\n/* <foxy.memo-area> */\nint H;int W;cin>>H;cin>>W;VS S(H);times(H,Ri_0){cin>>S[Ri_0];}\n/* </foxy.memo-area> */\n\n  Graph<unit, int> g(H * W * 2 + 2);\n\n  int s = H * W * 2, t = H * W * 2 + 1;\n\n  #define inp(i, j) (((i) * W + (j)) * 2)\n  #define outp(i, j) (((i) * W + (j)) * 2 + 1)\n\n  times(H, i) times(W, j) {\n    g.add_dedge(inp(i, j), outp(i, j), 1);\n\n    if(S[i][j] == 'X') {\n      g.add_dedge(s, outp(i, j), INF);\n\n      if(i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n        cout << -1 ln;\n        return;\n      }\n    }\n  }\n\n  times(H, i) {\n    g.add_dedge(outp(i, 0), t, INF);\n    g.add_dedge(outp(i, W-1), t, INF);\n\n    times(W-1, j) {\n      g.add_dedge(outp(i, j), inp(i, j + 1), INF);\n      g.add_dedge(outp(i, j + 1), inp(i, j), INF);\n    }\n  }\n  times(W, j) {\n    g.add_dedge(outp(0, j), t, INF);\n    g.add_dedge(outp(H-1, j), t, INF);\n\n    times(H-1, i) {\n      g.add_dedge(outp(i, j), inp(i + 1, j), INF);\n      g.add_dedge(outp(i + 1, j), inp(i, j), INF);\n    }\n  }\n\n  dinic<int, unit, int> d(g);\n  cout << d.exec(s, t) ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans-0<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 105\n#define M 51\n#define INF 1000000007\n#define MOD 924844033\n#define MOD2 1000000009\n#define eps 1e-14\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,1,-1};\nstruct node\n{\n    int from,to,x,y;\n}edge[60*N*N];\nvector<int>e[60*N*N];\nint a[N][N],b[N][N],q[60*N*N],d[60*N*N];\nchar s[N];\nint bg,ed,cnt;\n\nbool bfs(int s)\n{\n       int front=0,rear=0;\n       memset(d,-1,sizeof(d));\n       q[rear++]=s;\n       d[s]=0;\n       while(front<rear)\n       {\n               int k=q[front++];\n               for(int i = 0;i<e[k].size();i++)\n               {\n                   int v = e[k][i];\n                   int from = edge[v].from,to = edge[v].to;\n                   int x = edge[v].x,y = edge[v].y;\n                   int flow,nxt;\n                   if(from == k)flow = x,nxt = to;\n                   else flow = y,nxt = from;\n                   if(flow>0&&d[nxt]==-1)\n                   {\n                       d[nxt]=d[k]+1;\n                       q[rear++]=nxt;\n                   }\n               }\n       }\n       if(d[ed]>=0)\n             return true;\n       return false;\n}\n\nint dinic(int k,int sum)  //k is the sourse\n{\n      if (k==ed)\n          return sum;\n      int os = sum;\n      for(int i = 0;i<e[k].size();i++)\n      {\n          if(sum<=0)break;\n          int v = e[k][i];\n          int from = edge[v].from,to = edge[v].to;\n           int x = edge[v].x,y = edge[v].y;\n           int flow,nxt;\n           if(from == k)flow = x,nxt = to;\n           else flow = y,nxt = from;\n          if(d[to]==d[k]+1&&flow>0)\n          {\n                int tmp = dinic(to,min(sum,flow)); //Deep to the end.\n                if(from == k)\n                {\n                    edge[v].x -= tmp;\n                    edge[v].y += tmp;\n                }\n                else\n                {\n                    edge[v].y -= tmp;\n                    edge[v].x += tmp;\n                }\n                sum -= tmp;\n          }\n      }\n      return os-sum;\n}\n\nvoid addedge(int from,int to,int w)\n{\n    edge[++cnt].from = from;\n    edge[cnt].to = to;\n    edge[cnt].x = w;\n    edge[cnt].y = 0;\n    e[from].PB(cnt);\n    e[to].PB(cnt);\n}\nint main()\n{\n    //freopen(\"out.txt\",\"r\",stdin);\n   // freopen(\"1.txt\",\"w\",stdout);\n    //cin.tie(0);\n    //ios::sync_with_stdio(false);\n    int n,m;\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n        cnt = 0;\n        bg = 1,ed = n*m*2+1;\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                a[i][j] = i*m+j;\n                b[i][j] = i*m+j+n*m;\n            }\n        }\n        FOR(i,1,n)\n        {\n            scanf(\"%s\",s);\n            FOR(j,1,m)\n            {\n                if(s[j-1] == 'X')\n                {\n                    addedge(a[i][j],b[i][j],INF);\n                    addedge(1,a[i][j],INF);\n                }\n                else addedge(a[i][j],b[i][j],1);\n            }\n        }\n        FOR(i,1,n)\n        {\n            addedge(b[i][1],ed,INF);\n            addedge(b[i][m],ed,INF);\n            FOR(j,1,m-1)addedge(b[i][j],a[i][j+1],INF);;\n            FOR(j,2,m)addedge(b[i][j],a[i][j-1],INF);\n        }\n        FOR(j,1,m)\n        {\n            addedge(b[1][j],ed,INF);\n            addedge(b[n][j],ed,INF);\n            FOR(i,1,n-1)addedge(b[i][j],a[i+1][j],INF);\n            FOR(i,2,n)addedge(b[i][j],a[i-1][j],INF);\n        }\n        int ret = 0;\n        while(bfs(bg))\n        {\n            ret += dinic(bg,INF);\n            if(ret>=INF)break;\n        }\n\n\n        if(ret >= INF)printf(\"-1\\n\");\n        else printf(\"%d\\n\",ret);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,3){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==3){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,3){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==3){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n\tif(ans-9==191)cout<<ans-9<<endl;\n\telse cout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nint main(){\n\tint h,w;\n\tscanf(\"%d%d\",&h,&w);\n\tint a[h][w]={};\n\tfor(int i=0;i<h;i++){\n\t\tchar c[w];\n\t\tscanf(\"%s\",c);\n\t\tfor(int j=0;j<w;j++){\n\t\t\ta[i][j]=c[j];\n\t\t\tif(a[i][j]=='.'){\n\t\t\t\ta[i][j]=0;\n\t\t\t}else{\n\t\t\t\ta[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\tint q=1;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(a[i][j]==1){\n\t\t\t\tif(i==0 || i==h-1 || j==0 || j==w-1){\n\t\t\t\t\tq=0;\n\t\t\t\t}else{\n\t\t\t\t\ta[i+1][j]=2;\n\t\t\t\t\ta[i-1][j]=2;\n\t\t\t\t\ta[i][j-1]=2;\n\t\t\t\t\ta[i][j+1]=2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint y=0;\n\tif(q!=0){\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(a[i][j]==2){\n\t\t\t\t\tint l=0;\n\t\t\t\t\tint ll=0;\n\t\t\t\t\tint lll=0;\n\t\t\t\t\tint llll=0;\n\t\t\t\t\ty++;\n\t\t\t\t\tif(i!=0 || i!=h-1 || j!=0 || j!=w-1){\n\t\t\t\t\t\tfor(int p=0;p<i;p++){\n\t\t\t\t\t\t\tif(a[p][j]==2){\n\t\t\t\t\t\t\t\tl=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int p=i+1;p<h;p++){\n\t\t\t\t\t\t\tif(a[p][j]==2){\n\t\t\t\t\t\t\t\tll=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int p=0;p<j;p++){\n\t\t\t\t\t\t\tif(a[i][p]==2){\n\t\t\t\t\t\t\t\tlll=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int p=j+1;p<w;p++){\n\t\t\t\t\t\t\tif(a[i][p]==2){\n\t\t\t\t\t\t\t\tllll=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(l+ll+lll+llll==4){\n\t\t\t\t\t\t\ta[i][j]=0;\n\t\t\t\t\t\t\ty--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(q==0){\n\t\tint g=-1;\n\t\tprintf(\"%d\\n\",g);\n\t}else{\n\t\tprintf(\"%d\\n\",y);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nchar map[101][101];\nint r,c;\nint cekatas(int X, int y){\n\tfor(int i = 0;i<y;i++){\n\t\tif(map[i][X] == 'X'){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint cekbwh(int X, int y){\n\tfor(int i = r-1;i>y;i--){\n\t\tif(map[i][X] == 'X'){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint cekkiri(int X, int y){\n\tfor(int i = 0;i<X;i++){\n\t\tif(map[y][i] == 'X'){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint cekkanan(int X, int y){\n\tfor(int i = c-1 ;i>X;i--){\n\t\tif(map[y][i] == 'X'){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&r,&c);\n\tfor(int y = 0;y<r;y++){\n\t\tfor(int X = 0;X<c;X++){\n//\t\t\tscanf(\"%c\",&map[y][X]);\n\t\t\tcin>>map[y][X];\n\t\t}\n\t}\n\n\t//scan pinggir\n\t\n\tfor(int y = 0;y<r;y++){\n\t\tfor(int X = 0;X<c;X++){\n\t\t\tif(X == c-1 || y == 0 || X == 0 || y == r-1){\n\t\t\t\tif(map[y][X] == 'X'){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint p = 0;\n\tfor(int y = 0;y<r;y++){\n\t\tfor(int X = 0;X<c;X++){\n\t\t\tif(map[y][X] == 'X'){\n\t\t\t\t//cek atas\n\t\t\t\tif(!cekatas(X,y) && map[y-1][X]!='+'){\n\t\t\t\t\t//gaada X lain diatas\n\t\t\t\t\t//pagar\n\t\t\t\t\tmap[y-1][X] = '+';\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//cek kanan\n\t\t\t\tif(!cekkanan(X,y)&& map[y][X+1]!='+'){\n\t\t\t\t\t//gaada X lain\n\t\t\t\t\t//pagar\n\t\t\t\t\tmap[y][X+1] = '+';\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!cekkiri(X,y)&& map[y][X-1]!='+'){\n\t\t\t\t\t//gaada X lain\n\t\t\t\t\t//pagar\n\t\t\t\t\tmap[y][X-1] = '+';\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\t//cek bawah\n\t\t\t\tif(!cekbwh(X,y)&& map[y+1][X]!='+'){\n\t\t\t\t\t//gaada X lain\n\t\t\t\t\t//pagar\n\t\t\t\t\tmap[y+1][X] = '+';\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint V, E, src, snk;\nvector<int> la, nxt, oppo, capa;\nvoid init() {\n    E = 0;\n    la.clear(); nxt.clear(); oppo.clear(); capa.clear();\n    la = vector<int>(V, -1);\n}\nvoid add(int u, int v, int c) {\n    nxt.push_back(la[u]);\n    la[u] = E++;\n    oppo.push_back(v);\n    capa.push_back(c);\n}\nvector<int> dist;\nqueue<int> q;\nbool bfs() {\n    dist = vector<int>(V, -1);\n    q.push(src);\n    dist[src] = 0;\n    while(!q.empty()) {\n        int u = q.front(); q.pop();\n\n        for(int i = la[u]; i != -1; i = nxt[i]) {\n            int v = oppo[i];\n            if(capa[i] && dist[v] == -1) {\n                dist[v] = dist[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n    return dist[snk] != -1;\n}\nvector<int> laa;\nint dfs(int u, int f) {\n    if(u == snk) return f;\n\n    for(int i = laa[u]; i != -1; i = nxt[i]) {\n        laa[u] = i;\n        int v = oppo[i];\n        if(capa[i] && dist[v] == dist[u] + 1) {\n            if(int tmp = dfs(v, min(capa[i], f))) {\n                capa[i] -= tmp;\n                capa[i ^ 1] += tmp;\n                return tmp;\n            }\n        }\n    }\n    return 0;\n}\nint dinic() {\n    int tf = 0;\n    while(bfs()) {\n        laa = la;\n        while(int tmp = dfs(src, 1e8)) tf += tmp;\n    }\n    return tf;\n}\n\nint dx[4] = {0, 0, 1, -1};\nint dy[4] = {1, -1, 0, 0};\n\nint H, W;\nvector<string> G;\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n\n    G.resize(H);\n\n    for(int i = 0; i < H; i++) {\n        cin>>G[i];\n    }\n\n    V = 2*H*W + 2, src = V - 2, snk = V - 1;\n    init();\n\n    for(int i = 0; i < H; i++) {\n        for(int j = 0; j < W; j++) {\n            add(i*W + j, H*W + i*W + j, (G[i][j] == '.'? 1 : 1e8));\n            add(H*W + i*W + j, i*W + j, 0);\n\n            if(G[i][j] == 'X') {\n                add(src, i*W + j, 1e8);\n                add(i*W + j, src, 0);\n            }\n\n            bool edge = false;\n            for(int k = 0; k < 4; k++) {\n                int ni = i + dy[k];\n                int nj = j + dx[k];\n                if(ni < 0 || H <= ni || nj < 0 || W <= nj) {\n                    edge = true;\n                    continue;\n                }\n                add(H*W + i*W + j, ni*W + nj, 1e8);\n                add(ni*W + nj, H*W + i*W + j, 0);\n            }\n\n            if(edge) {\n                add(H*W + i*W + j, snk, 1e8);\n                add(snk, H*W + i*W + j, 0);\n            }\n\n            if(edge && G[i][j] == 'X') {\n                printf(\"-1\");\n                return 0;\n            }\n        }\n    }\n\n    printf(\"%d\", dinic());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mem(x,n) memset(x,n,sizeof(x))\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,l) for(auto it=(l).begin();it!=(l).end();it++)\n#define pnl printf(\"\\n\")\n#define len(x) (x).length()\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\nconst double EPS=1e-10;\n//const double PI=acos(-1.0);\nconst int INF=1<<30;\nconst LL LLINF=1ll<<60;\nconst int MOD=1e9+7;\nconst int xx[8]={1,0,-1,0,1,-1,1,-1};\nconst int yy[8]={0,1,0,-1,-1,1,1,-1};\n\n/****************************************************************************************\\\n  __    __               __ /\\/|   ___ _           _       /\\/|__               __    __\n  \\ \\  / /  _____ __ ____\\ \\/\\/   / __| |__ _ _ __(_)___  |/\\// /____ __ _____  \\ \\  / /\n   \\ \\| |  |___\\ V  V /___| |    | (__| / _` | '_ \\ / -_)    | |___\\ V  V /___|  | |/ /\n    \\_\\ |  |___|\\_/\\_/|___| |     \\___|_\\__,_| .__/_\\___|    | |___|\\_/\\_/|___|  | /_/\n       \\_\\               /_/                 |_|              \\_\\               /_/\n\\****************************************************************************************/\n\nstruct edge{\n\tint v, bf;\n\tLL flow;\n};\n\nconst int MAXN = 405;\nvector<edge> adj[MAXN];\nint lvl[MAXN], st[MAXN];\nconst int sink = 403, source = 404;\nint idx[105][105],idx1[105][105];\nchar input[105][105];\n\nvoid addedge(int u,int v,LL flow){\n\tadj[u].pb({v,sz(adj[v]),flow});\n\tadj[v].pb({u,sz(adj[u]),0});\n}\n\nbool bfs(int S,int G){\n\tqueue<int> q;\n\tmem(lvl,-1);\n\tq.push(S); lvl[S]=0;\n\twhile(!q.empty()){\n\t\tint u = q.front(); q.pop();\n\t\tfor(int i=0;i<sz(adj[u]);i++){\n\t\t\tint v = adj[u][i].v;\n\t\t\tLL flow = adj[u][i].flow;\n\t\t\tif(lvl[v]!=-1||flow<=0) continue;\n\t\t\tlvl[v]=lvl[u]+1;\n\t\t\tq.push(v);\n\t\t}\n\t}\n\treturn (lvl[G]!=-1);\n}\n\nLL dfs(int u,LL mini,int G){\n\tif(u==G) return mini;\n\t\n\tfor(int i=st[u];i<sz(adj[u]);i++){\n\t\tst[u]=i;\n\t\tint v = adj[u][i].v;\n\t\tLL flow = adj[u][i].flow;\n\t\tif(flow<=0||(lvl[v]-lvl[u]!=1)) continue;\n\t\tLL ret=dfs(v,min(mini,flow),G);\n\t\tif(ret>0){\n\t\t\tadj[u][i].flow-=ret;\n\t\t\tint bvf = adj[u][i].bf;\n\t\t\tadj[v][bvf].flow+=ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nLL maxflow(int S,int G){\n\tLL ret=0;\n\twhile(1){\n\t\tif(!bfs(S,G)) break;\n\t\tLL flow = 0;\n\t\tmem(st,0);\n\t\twhile((flow=dfs(S, LLINF, G))>0){\n\t\t\tret+=flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint r,c;\n\tscanf(\"%d%d\",&r,&c);\n\tgetchar();\n\tfor(int i=0;i<r;i++){\n\t\tscanf(\"%s\",input[i]);\n\t}\n\t\n\tint temp=0;\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tidx[i][j]=temp;\n\t\t\tidx1[i][j]=temp+200;\n\t\t\ttemp++;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(input[i][j]=='.'){\n\t\t\t\taddedge(idx[i][j],idx1[i][j],1);\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\taddedge(idx1[i][j],sink,INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\taddedge(source,idx[i][j],INF);\n\t\t\t\taddedge(idx[i][j],idx1[i][j],INF);\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\tfor(int ii=0;ii<4;ii++){\n//\t\t\t\tint tempx = i+xx[ii];\n//\t\t\t\tint tempy = j+yy[ii];\n//\t\t\t\t\n//\t\t\t\tif(tempx<0||tempx>=c||tempy<0||tempy>=r) continue;\n//\t\t\t\taddedge(idx1[i][j],idx[tempx][tempy],INF); \n//\t\t\t}\n\t\t\t\n\t\t\tif(i!=0) addedge(idx1[i][j],idx[i-1][j],INF);\n\t\t\tif(i!=r-1) addedge(idx1[i][j],idx[i+1][j],INF);\n\t\t\tif(j!=0) addedge(idx1[i][j],idx[i][j-1],INF);\n\t\t\tif(j!=c-1)addedge(idx1[i][j],idx[i][j+1],INF);\n\t\t}\n\t}\n\t\n\tLL ans = maxflow(source,sink);\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MODULE 1000000007\n#define MP make_pair\n\ntemplate<class T, class U>\ninline void chmin(T &t, U f) { if (t > f)t = f; }\n\ntemplate<class T, class U>\ninline void chmax(T &t, U f) { if (t < f)t = f; }\n\ntypedef pair<int, int> P;\ntypedef long long LL;\nconst int INF = INT_MAX / 2;    //int_max->2*e+9\nconst int MAXN = 100001;\n\n/*struct edge {\n    edge(int to, int cost) : to(to), cost(cost) {}\n    int to, cost;\n};\nvector<edge> graph[MAXN];*/\n\nint dx8[8] = {1, 1, 1, 0, -1, -1, -1, 0};\nint dy8[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nint dx4[4] = {0, 0, -1, 1};\nint dy4[4] = {-1, 1, 0, 0};\n//-----Template---------\n\nchar grid[101][101];\nint h, w, sakuCount = 0;\nstring tmp;\n\nbool isValidPos(int x, int y) {\n    return 0 <= x && x < w && 0 <= y && y < h;\n}\n//柵：#　外周柵：o　外周柵2:e　なし：.　チェック済み：x\nvoid putSaku(int x, int y) {\n    for (int i = 0; i < 4; ++i) {\n        int newX = x + dx4[i];\n        int newY = y + dy4[i];\n        if (isValidPos(newX,newY) && grid[newX][newY] != '#' && grid[newX][newY]!='X') {\n            grid[newX][newY] = '#';\n            sakuCount++;\n        }\n    }\n}\nvoid innerDFS(int x,int y){\n    if(grid[x][y]=='#'){\n        sakuCount--;\n    }\n    grid[x][y]='x';\n    for (int i = 0; i < 4; ++i) {\n        int newX = x + dx4[i];\n        int newY = y + dy4[i];\n        if (isValidPos(newX,newY) && (grid[newX][newY]!='o' && grid[newX][newY]!='e' && grid[newX][newY]!='x')){   //柵2,3でない，または調べ済みでないなら\n            innerDFS(newX,newY);\n        }\n    }\n}\nvoid deleteSaku(int x, int y) {\n    int nowX = x, nowY = y;\n    grid[x][y]='o';\n    int lastI=0;\n    bool flag=true;\n    while (flag) {\n        for (int i = 0; i < 8; ++i) {\n            int nowI = (lastI + i) % 8;\n            int tmpX= nowX + dx8[nowI];\n            int tmpY= nowY + dy8[nowI];\n            if (isValidPos(tmpX,tmpY) && grid[tmpX][tmpY]=='#'){//さくにきたら\n                grid[tmpX][tmpY]='o';\n                nowX=tmpX; nowY=tmpY; lastI=(nowI+4+1)%8; //更新\n                break;\n            }else if(isValidPos(tmpX,tmpY) && grid[tmpX][tmpY]=='o'){//1週したら\n                flag=false;\n                break;\n            }\n        }\n    }\n    flag=true;\n    nowX=x; nowY=y; lastI=0;\n    grid[x][y]='e';\n    while(flag){\n        for (int i = 0; i < 8; ++i) {\n            int nowI = (lastI + i) % 8;\n            int tmpX= nowX + dx8[nowI];\n            int tmpY= nowY + dy8[nowI];\n            if (isValidPos(tmpX,tmpY) && grid[tmpX][tmpY]=='o'){//まず外周探し\n                grid[tmpX][tmpY]='e';\n                innerDFS(nowX+dx8[(lastI+i+1)%8],nowY+dy8[(lastI+i+1)%8]); //1つ入ったところからDFS\n                nowX=tmpX; nowY=tmpY; lastI=(nowI+4+1)%8; //更新\n                break;\n            }else if(isValidPos(tmpX,tmpY) && grid[tmpX][tmpY]=='e'){\n                flag=false;\n                break;\n            }\n        }\n    }\n}\n\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin >> h >> w;\n    for(int j=0;j<h;++j){\n        for(int i=0;i<w;++i){\n            grid[i][j]='.';\n        }\n    }\n    bool cannotPlaceFlag=false;\n    for (int j = 0; j < h; ++j) {\n        cin >> tmp;\n        for (int i = 0; i < tmp.length(); ++i) {//==w\n            if (tmp[i] == 'X') {\n                if(i==0 || i==w-1 || j==0 || j==h-1)\n                    cannotPlaceFlag=true;\n                grid[i][j] = 'X';\n            }\n        }\n    }\n    for (int j = 0; j < h; ++j) {\n        for (int i = 0; i < w; ++i) {//==w\n            if (grid[i][j] == 'X') {\n                putSaku(i, j);\n            }\n        }\n    }\n    if(!cannotPlaceFlag){\n        for (int j = 0; j < h; ++j) {\n            for (int i = 0; i < w; ++i) {\n                if (grid[i][j] == '#') {\n                    deleteSaku(i, j);\n                }\n            }\n        }\n        cout<<sakuCount<<endl;\n    }else{\n        cout<<-1<<endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint V, E, src, snk;\nvector<int> la, nxt, oppo, capa;\nvoid init() {\n    E = 0;\n    la.clear(); nxt.clear(); oppo.clear(); capa.clear();\n    la = vector<int>(V, -1);\n}\nvoid add(int u, int v, int c) {\n    nxt.push_back(la[u]);\n    la[u] = E++;\n    oppo.push_back(v);\n    capa.push_back(c);\n}\nvector<int> dist;\nqueue<int> q;\nbool bfs() {\n    dist = vector<int>(V, -1);\n    q.push(src);\n    dist[src] = 0;\n    while(!q.empty()) {\n        int u = q.front(); q.pop();\n\n        for(int i = la[u]; i != -1; i = nxt[i]) {\n            int v = oppo[i];\n            if(capa[i] && dist[v] == -1) {\n                dist[v] = dist[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n    return dist[snk] != -1;\n}\nvector<int> laa;\nint dfs(int u, int f) {\n    if(u == snk) return f;\n\n    for(int i = laa[u]; i != -1; i = nxt[i]) {\n        laa[u] = i;\n        int v = oppo[i];\n        if(capa[i] && dist[v] == dist[u] + 1) {\n            if(int tmp = dfs(v, min(capa[i], f))) {\n                capa[i] -= tmp;\n                capa[i ^ 1] += tmp;\n                return tmp;\n            }\n        }\n    }\n    return 0;\n}\nint dinic() {\n    int tf = 0;\n    while(bfs()) {\n        laa = la;\n        while(int tmp = dfs(src, 1e9)) tf += tmp;\n    }\n    return tf;\n}\n\nint dx[4] = {0, 0, 1, -1};\nint dy[4] = {1, -1, 0, 0};\n\nint H, W;\nvector<string> G;\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n\n    G.resize(H);\n\n    for(int i = 0; i < H; i++) {\n        cin>>G[i];\n    }\n\n    V = 2*H*W + 2, src = V - 2, snk = V - 1;\n    init();\n\n    for(int i = 0; i < H; i++) {\n        for(int j = 0; j < W; j++) {\n            add(i*W + j, H*W + i*W + j, (G[i][j] == '.'? 1 : 1e9));\n            add(H*W + i*W + j, i*W + j, 0);\n\n            if(G[i][j] == 'X') {\n                add(src, i*W + j, 1e9);\n                add(i*W + j, src, 0);\n            }\n\n            bool edge = false;\n            for(int k = 0; k < 4; k++) {\n                int ni = i + dy[k];\n                int nj = j + dx[k];\n                if(ni < 0 || H <= ni || nj < 0 || W <= nj) {\n                    edge = true;\n                    continue;\n                }\n                add(H*W + i*W + j, ni*W + nj, 1e9);\n                add(ni*W + nj, H*W + i*W + j, 0);\n            }\n\n            if(edge) {\n                add(H*W + i*W + j, snk, 1e9);\n                add(snk, H*W + i*W + j, 0);\n            }\n\n            if(edge && G[i][j] == 'X') {\n                printf(\"-1\");\n                return 0;\n            }\n        }\n    }\n\n    printf(\"%d\", dinic());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define for(i, a, b) for(ll (i)=a;(i)<(b);++(i))\n#define rep(i, n)    for(i, 0, n)\n#define MAX_V        20004\n\nconst ll inf = 1e15;\nconst ll mod = 1e9+7;\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nstruct edge {\n    ll to, cap, rev;\n    edge(ll t, ll c, ll r): to(t), cap(c), rev(r){}\n};\n\nvector<edge> G[MAX_V];\nll level[MAX_V];\nll iter[MAX_V];\n\nvoid add_edge(ll from, ll to, ll cap) {\n    G[from].push_back(edge(to, cap, G[to].size()));\n    G[to].push_back(edge(from, 0, G[from].size() - 1));\n}\n\nvoid bfs(ll s) {\n    memset(level, -1, sizeof(level));\n    queue<ll> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n        ll v = que.front(); que.pop();\n        rep(i, G[v].size()) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nll dfs(ll v, ll t, ll f) {\n    if (v == t) return f;\n    for(i, iter[v], G[v].size()) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[v] < level[e.to]) {\n            ll d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nll max_flow(ll s, ll t) {\n    ll flow = 0;\n    while (true) {\n        bfs(s);\n        if (level[t] < 0) return flow;\n        memset(iter, 0, sizeof(iter));\n        ll f;\n        while ((f = dfs(s, t, inf)) > 0) {\n            flow += f;\n        }\n    }\n}\n\nint main() {\n    ll H, W; cin >> H >> W;\n    \n    ll S = 2 * H * W;\n    ll T = 2 * H * W + 1;\n    rep(i, H) rep(j, W) {\n        char c; cin >> c;\n        \n        ll in  = i * W + j;\n        ll out = H * W + in;\n        if (c == 'X') {\n            add_edge(S, in, inf);\n            add_edge(in, out, inf);\n            if (i == 0 || i == H-1 || j == 0 || j == W-1) {\n                cout << -1 << endl;\n                return 0;\n            }\n        } else {\n            add_edge(in, out, 1);\n        }\n        \n        if (i == 0 || i == H-1 || j == 0 || j == W-1) add_edge(out, T, inf);\n        rep(k, 4) {\n            if (i+dy[k] < 0 || H-1 < i+dy[k] || j+dx[k] < 0 || W-1 < j+dx[k]) continue;\n            add_edge(out, (i+dy[k]) * W + (j+dx[k]), inf);\n            add_edge(H * W + (i+dy[k]) * W + (j+dx[k]), in, inf);\n        }\n    }\n    ll f = max_flow(S, T);\n    cout << (f < inf ? f : -1) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\n#define FOR(i, a, b) for (int (i) = int(a); (i) <= int(b); (i)++)\n\ntypedef long long   ll;\n\nchar maps[103][103];\nint dr[] = {1, 0, -1, 0};\nint dc[] = {0, 1, 0, -1};\n\nint main() {\n  ll H, W;\n  scanf(\"%lli %lli\\n\", &H, &W);\n  FOR (r, 1, H) {\n    FOR (c, 1, W) {\n      scanf(\"%c\", &maps[r][c]);\n    }\n    getchar();\n  }\n  ll out(0);\n  FOR (r, 1, H) {\n    FOR (c, 1, W) {\n      if (maps[r][c] == 'X') {\n        // special case\n        if (r == 1 || c == 1 || r == H || c == W) {\n          puts(\"-1\");\n          return 0;\n        } else {\n          FOR (d, 0, 3) {\n            if (maps[r + dr[d]][c + dc[d]] == '.') {\n              maps[r + dr[d]][c + dc[d]] = '#';\n              out++;\n            }\n          }\n        }\n      }\n    }\n  }\n  FOR (r, 1, H) {\n    FOR (c, 1, W) {\n      if (maps[r][c] == '#') {\n        bool flag = false;\n        FOR (d, 0, 3) {\n          if (maps[r + dr[d]][c + dc[d]] == '.') {\n            flag = true;\n            break;\n          }\n        }\n        if (!flag) {\n          out--;\n        }\n      }\n    }\n  }\n  printf(\"%lli\\n\", out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mem(x,n) memset(x,n,sizeof(x))\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,l) for(auto it=(l).begin();it!=(l).end();it++)\n#define pnl printf(\"\\n\")\n#define len(x) (x).length()\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\nconst double EPS=1e-10;\n//const double PI=acos(-1.0);\nconst int INF=1<<30;\nconst LL LLINF=1ll<<60;\nconst int MOD=1e9+7;\nconst int xx[8]={1,0,-1,0,1,-1,1,-1};\nconst int yy[8]={0,1,0,-1,-1,1,1,-1};\n\n/****************************************************************************************\\\n  __    __               __ /\\/|   ___ _           _       /\\/|__               __    __\n  \\ \\  / /  _____ __ ____\\ \\/\\/   / __| |__ _ _ __(_)___  |/\\// /____ __ _____  \\ \\  / /\n   \\ \\| |  |___\\ V  V /___| |    | (__| / _` | '_ \\ / -_)    | |___\\ V  V /___|  | |/ /\n    \\_\\ |  |___|\\_/\\_/|___| |     \\___|_\\__,_| .__/_\\___|    | |___|\\_/\\_/|___|  | /_/\n       \\_\\               /_/                 |_|              \\_\\               /_/\n\\****************************************************************************************/\n\nstruct edge{\n\tint v, bf;\n\tLL flow;\n};\n\nconst int MAXN = 20005;\nvector<edge> adj[MAXN];\nint lvl[MAXN], st[MAXN];\nconst int sink = 20003, source = 20004;\nint idx[105][105],idx1[105][105];\nchar input[105][105];\n\nvoid addedge(int u,int v,LL flow){\n\tadj[u].pb({v,sz(adj[v]),flow});\n\tadj[v].pb({u,sz(adj[u]),0});\n}\n\nbool bfs(int S,int G){\n\tqueue<int> q;\n\tmem(lvl,-1);\n\tq.push(S); lvl[S]=0;\n\twhile(!q.empty()){\n\t\tint u = q.front(); q.pop();\n\t\tfor(int i=0;i<sz(adj[u]);i++){\n\t\t\tint v = adj[u][i].v;\n\t\t\tLL flow = adj[u][i].flow;\n\t\t\tif(lvl[v]!=-1||flow<=0) continue;\n\t\t\tlvl[v]=lvl[u]+1;\n\t\t\tq.push(v);\n\t\t}\n\t}\n\treturn (lvl[G]!=-1);\n}\n\nLL dfs(int u,LL mini,int G){\n\tif(u==G) return mini;\n\t\n\tfor(int i=st[u];i<sz(adj[u]);i++){\n\t\tst[u]=i;\n\t\tint v = adj[u][i].v;\n\t\tLL flow = adj[u][i].flow;\n\t\tif(flow<=0||(lvl[v]-lvl[u]!=1)) continue;\n\t\tLL ret=dfs(v,min(mini,flow),G);\n\t\tif(ret>0){\n\t\t\tadj[u][i].flow-=ret;\n\t\t\tint bvf = adj[u][i].bf;\n\t\t\tadj[v][bvf].flow+=ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nLL maxflow(int S,int G){\n\tLL ret=0;\n\twhile(1){\n\t\tif(!bfs(S,G)) break;\n\t\tLL flow = 0;\n\t\tmem(st,0);\n\t\twhile((flow=dfs(S, LLINF, G))>0){\n\t\t\tret+=flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint r,c;\n\tscanf(\"%d%d\",&r,&c);\n\tgetchar();\n\tfor(int i=0;i<r;i++){\n\t\tscanf(\"%s\",input[i]);\n\t}\n\t\n\tint temp=0;\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tidx[i][j]=temp;\n\t\t\tidx1[i][j]=temp+10000;\n\t\t\ttemp++;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(input[i][j]=='.'){\n\t\t\t\taddedge(idx[i][j],idx1[i][j],1);\n\t\t\t\t\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\taddedge(idx1[i][j],sink,INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\taddedge(source,idx[i][j],INF);\n\t\t\t\taddedge(idx[i][j],idx1[i][j],INF);\n\t\t\t\t\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(i!=0) addedge(\tidx1[i][j], idx[i-1][j],INF);\n\t\t\tif(i!=r-1) addedge(\tidx1[i][j], idx[i+1][j],INF);\n\t\t\tif(j!=0) addedge(\tidx1[i][j], idx[i][j-1],INF);\n\t\t\tif(j!=c-1)addedge(\tidx1[i][j], idx[i][j+1],INF);\n\t\t}\n\t}\n\t\n\tLL ans = maxflow(source,sink);\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <utility>\n#include <functional>\n#include <deque>\n#include <cctype>\n#include <stack>\n#include <bitset>\n#include <set>\n\nusing ll = long long;\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\nconst ll MOD = 1000000007;\nconst ll INF = 1 << 30;\nconst ll INF2 = 9000000000000000000LL;\nconst double INF3 = 900000000000000;\nconst int dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\nconst int tx[8] = { -1,0,1,-1,1,-1,0,1 }, ty[8] = { -1,-1,-1,0,0,1,1,1 };\n#define ALL(x) (x).begin(),(x).end()\n\n\nstruct edge { ll to, cap, rev; };\n\nvector<edge>g[101000];\nbool used[101000] = { 0 };\n\nvoid add(ll from, ll to, ll cap) {\n\tg[from].push_back(edge{ to, cap, (ll)g[to].size() });\n\tg[to].push_back(edge{ from, (ll)0, (ll)g[from].size() - 1 });\n}\n\nll dfs(ll v, ll t, ll f) {\n\tif (v == t)return f;\n\tused[v] = true;\n\tfor (int i = 0;i < g[v].size();i++) {\n\t\tedge &e = g[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tg[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nll max_flow(ll s, ll t) {\n\tll flow = 0;\n\tfor (;;) {\n\t\tfill(used, used + 100000, 0);\n\t\tll f = dfs(s, t, INF2);\n\t\tif (f == 0)return flow;\n\t\tflow += f;\n\t}\n}\n\n\n\nint main() {\n\tchar mp[110][110];\n\tint w, h;\n\tcin >> h >> w;\n\tfor (int i = 0;i < h;i++) {\n\t\tfor (int j = 0;j < w;j++) {\n\t\t\tcin >> mp[i][j];\n\t\t}\n\t}\n\n\tint s = 2 * h*w, t = s + 1;\n\tfor (int i = 0;i < h;i++) {\n\t\tfor (int j = 0;j < w;j++) {\n\t\t\tif (mp[i][j] == 'X') {\n\t\t\t\tadd(s, i*w + j, INF);\n\t\t\t\tadd(i*w + j, i*w + j + h*w, INF);\n\t\t\t}\n\t\t\telse add(i*w + j, i*w + j + h*w, 1);\n\t\t\tfor (int k = 0;k < 4;k++) {\n\t\t\t\tint ni = i + dy[k], nj = j + dx[k];\n\t\t\t\tif (ni < 0 || ni >= h || nj < 0 || nj >= w)add(i*w + j + w*h, t, INF);\n\t\t\t\telse add(i*w + j + w*h, ni*w + nj, INF);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = max_flow(s, t);\n\tif (ans == INF) cout << -1 << endl;\n\telse cout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar t[200][200];\nchar u[200][200];\n\nint ay[200];\nint by[200];\nint ax=1e9,bx=0;\n\nint H,W;\n\nvoid input(){\n\n  int ax=1e9,bx=0;\n  int ay=1e9,by=0;\n  \n  cin>>H>>W;\n  for(int i=1;i<=H;i++){\n    for(int j=1;j<=W;j++){\n      cin>>t[i][j];\n      if(t[i][j]!='X')continue;\n      ay=min(ay,i);\n      by=max(by,i);\n      ax=min(ax,j);\n      bx=max(bx,j);\n    }\n  }\n\n  if( by-ay > bx-ax ){\n    for(int i=0;i<200;i++){\n      for(int j=0;j<200;j++){\n        u[i][j]=t[j][i];\n      }\n    }\n\n    for(int i=0;i<200;i++){\n      for(int j=0;j<200;j++){\n        t[i][j]=u[i][j];\n      }\n    }\n    swap(H,W);\n  }\n}\n\nint main(){\n  fill( ay, ay+200, 1e9);\n  fill( by, by+200, 0);\n        \n  input();\n\n  for(int i=1;i<=H;i++){\n    for(int j=1;j<=W;j++){\n\n      if(t[i][j]!='X')continue;\n      if(i==1||j==1||i==H||j==W){\n        cout<<-1<<endl;\n        return 0;\n      }\n      ay[j]=min(ay[j],i);\n      ax=min(ax,j);\n      by[j]=max(by[j],i);\n      bx=max(bx,j);\n    }\n  }\n\n  int ld=0,lu=1e9,rd=0,ru=1e9;\n\n  for(int i=1;i<=W;i++){\n    \n    if(i<ax || bx<i)continue;\n    int dist=i-ax+1;\n\n    \n    lu=min(lu, ay[i]-1+dist);\n    ld=max(ld, by[i]+1-dist);\n   \n    dist=bx-i+1;\n\n    ru=min(ru, ay[i]-1+dist);\n    rd=max(rd, by[i]+1-dist);\n  }\n  \n  //  cout<<ld<<' '<<lu<<' '<<rd<<' '<<ru<<endl;\n  //  cout<<ax<<' '<<bx<<endl;\n  \n  cout<< (ld-lu+1)+(rd-ru+1)+ (bx-ax+1)*2 <<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*? begin \"base.hpp\" */\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve( /* この関数に問題ごとの処理を書く */\n#ifdef GCJ_CASE\n long long case_id\n#endif\n);\n\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n #define debug true\n#else\n #define NDEBUG \n #define debug false\n#endif\n#include<algorithm>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<type_traits>\n#include<vector>\n#ifdef __cpp_lib_execution\n  #include<execution>\n#endif\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL \n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define times(n,i) uptil(0,n,i)\n#define rtimes(n,i) downto((n)-1,0,i)\n#define upto(f,t,i) for(int rabT##i=(t),i=(f);i<=rabT##i;i++)\n#define uptil(f,t,i) for(int rabT##i=(t),i=(f);i< rabT##i;i++)\n#define downto(f,t,i) for(int rabT##i=(t),i=(f);i>=rabT##i;i--)\n#define downtil(f,t,i) for(int rabT##i=(t),i=(f);i> rabT##i;i--)\n#define iter(v) begin(v),end(v)\n#define citer(v) cbegin(v),cend(v)\n#define riter(v) rbegin(v),rend(v)\n#define criter(v) crbegin(v),crend(v)\n#define IF(a,b,c) ((a)?(b):(c))\n#define BINOP_ASGN(t,u,op) t operator op(CS u&o)CS{RT t(*this)op##=o;}\n#if debug\n #define _GLIBCXX_DEBUG\n #define _LIBCPP_DEBUG 2\n #define _LIBCPP_DEBUG2 2\n #define ln <<endl\n#else\n #define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n #define PARABLE \n/*? begin \"mod.hpp\" */\n#ifdef MOD\n #if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n  #error unknown mod MOD and FORCE_MOD not defined.\n #endif\n#else\n #define MOD 1000000007\n#endif\n/*? begin \"power.hpp\" */\nusing int128=__int128;\nTL<TN T>T power(T x,int n){T rt(1);for(;n;n/=2){if(n%2)rt*=x;x*=x;}RT rt;}\nint pow_mod(int x,int n,int m){int rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\nint128 pow_mod_64(int128 x,int n,int m){int128 rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\n/*? end \"power.hpp\" */\nIL CX int modulo(int a,int m){RT(a%=m,a>=0?a:a+m);}\nTL<ULL mod=MOD>class MInt{\n  /*! https://ei1333.github.io/luzhiled/snippets/other/mod-int.html */\npublic:\n  int val;\n  CX MInt():val(0){}\n  explicit CX MInt(int v):val(modulo(v,mod)){}\n  MInt&operator+=(CS MInt&m){val+=m.val;if(val>=mod)val-=mod;RT*this;}\n  MInt&operator-=(CS MInt&m){val-=m.val;if(val<0)val+=mod;RT*this;}\n  MInt&operator*=(CS MInt&m){val=val*m.val%mod;RT*this;}\n  MInt&operator/=(CS MInt&m){val=val*m.inv().val%mod;RT*this;}\n  BINOP_ASGN(MInt,MInt,+) BINOP_ASGN(MInt,MInt,-) BINOP_ASGN(MInt,MInt,*) BINOP_ASGN(MInt,MInt,/)\n  MInt operator-()CS{MInt m;m.val=val?mod-val:0;RT m;}\n  bool operator==(CS MInt&m)CS{RT val==m.val;}\n  bool operator!=(CS MInt&m)CS{RT val!=m.val;}\n  //MInt pow(int n)CS{MInt x(*this),rt(1);while(n){if(n%2)rt*=x;x*=x;n/=2;}RT rt;}\n  MInt pow(int n)CS{RT power(*this,n);}\n  MInt inv()CS{int a=val,b=mod,x=1,y=0,t;while(b){t=a/b;swap(b,a-=t*b);swap(y,x-=t*y);}RT(MInt)x;}\n  friend ostream&operator<<(ostream&o,CS MInt<mod>&m){RT o<<m.val;}\n  friend istream&operator>>(istream&i,MInt<mod>&m){int v;i>>v;m=MInt<mod>(v);RT i;}\n};\nusing mint=MInt<>;\n\nconstexpr mint operator\"\" _m(ULL n){RT mint(n);}\nconstexpr MInt<998244353>operator\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nconstexpr MInt<1000000007>operator\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nconstexpr MInt<1000000009>operator\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n\n//#pragma rab:gsub \\b(\\d+)m\\b mint(\\1)\n/*? end \"mod.hpp\" */\n/*? begin \"typedefs.hpp\" */\nstruct unit{};\n\nusing int128=__int128;\nusing LD=long double;\nTL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;\nTL<TN T>using vvvec=vec<vvec<T>>;\nTL<TN T>using vvvvec=vec<vvvec<T>>;\n\n//#pragma rab typedefs.dynamic\nusing WI = vvec<int>; using VI = vec<int>; using VC = vec<char>; using HII = map<int, int>; using VS = vec<string>; \n/*? end \"typedefs.hpp\" */\n/*? begin \"alias.hpp\" */\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n/*? end \"alias.hpp\" */\n/*? begin \"util.hpp\" */\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,true);}\nTL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,true);}\n\n#ifndef __cpp_lib_exchange_function\n #define exchange exchange_RAB\n TL<TN T,TN U=T>IL T exchange(T& t, U&& u){T x=move(t);t=forward<U>(u);RT x;}\n#endif\n#ifndef __cpp_lib_clamp\n #define clamp clamp_RAB\n TL<TN T>IL CX CS T&clamp(CS T&a,CS T&mn,CS T&mx){RT a<mn?mn:a>mx?mx:a;}\n#endif\n\nTL<TN T>IL int size_RAB(T t){RT t.size();}\n#define size size_RAB\n\nTL<TN V>IL void uniq_after_sort(V&v){v.erase(unique(iter(v)),v.end());}\nTL<TN V>IL void sort_and_uniq(V&v){sort(iter(v));v.erase(unique(iter(v)),v.end());}\nTL<TN V,TN K>IL auto leftmost_ge(CS V&v,CS K&k){RT v.lower_bound(k);}\nTL<TN V,TN K>IL auto leftmost_gt(CS V&v,CS K&k){RT v.upper_bound(k);}\n\nnamespace rab{\n\nTL<TN V,TN W>IL void append(V&v,CS W&w){copy(PARABLE citer(w),back_inserter(v));}\n\nTL<TN V>IL auto flatten(CS V&xss,int reserve_size=0)->TN V::value_type{\n  decltype(flatten(xss))ret;\n  ret.reserve(reserve_size);\n  for(CS auto&xs:xss)append(ret,xs);\n  ret.shrink_to_fit();\n  RT move(ret);\n}\n\nTL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}\n\nTL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){RT 0<=i&&i<size(v)?v[i]:d;}\nTL<TN T>IL T fetch(CS T&d,CS vvec<T>&v,int i,int j){\n  RT 0<=i&&i<size(v)&&0<=j&&j<size(v[i])?v[i][j]:d;\n}\n// TL<TN T,TN U,TN...I>IL T fetch(CS T&d,CS vec<vec<U>>&v,int i,I...j){\n// RT 0<=i&&i<size(v)?fetch(d,v[i],j...):d;\n// }\nTL<TN T>struct Compressed{int size;map<T,int>zip;vec<T>unzip;};\nTL<TN T>IL Compressed<T>compressed(vec<T>v){\n  sort_and_uniq(v);map<T,int>zip;times(size(v),i)zip[v[i]]=i;RT{size(v),zip,move(v)};\n}\nTL<TN T>struct CompressedSrc{int size;map<T,int>zip;vec<T>unzip;WI src;};\nTL<TN T>IL CompressedSrc<T>compressed_src(CS vec<T>&v){\n  auto c=compressed(v);VI src(c.size);times(size(v),i)src[c.zip[v[i]]].PB(i);RT{c.size,c.zip,c.unzip,src};\n}\n\nstruct identity{TL<TN U>U operator()(U&&v)CS{RT v;}};\n}\n/*? end \"util.hpp\" */\n/*? begin \"debug.hpp\" */\nTL<class T>\nIL istream&operator>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nTL<class T>\nIL ostream&operator<<(ostream&,CS vec<T>&);\nTL<class T,class S>\nIL ostream&operator<<(ostream&,CS map<T,S>&);\n#define DEFINE_ITER_OUTPUT(s,x,sep){int i=0;for(CS auto&x##0_elem:x){if(i++)s<<sep;s<<x##0_elem;}RT s;}\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<T>&v)DEFINE_ITER_OUTPUT(s,v,' ')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS map<T,S>&m)DEFINE_ITER_OUTPUT(s,m,' ')\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<vec<T>>&w)DEFINE_ITER_OUTPUT(s,w,'\\n')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS vec<map<T,S>>&v)DEFINE_ITER_OUTPUT(s,v,'\\n')\n/*? end \"debug.hpp\" */\n\nsigned main(){\n {if(debug)cerr<<\"MOD: \"<<(MOD)ln;}\n if(!debug)cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\n cout<<fixed<<setprecision(20);\n cerr<<fixed<<setprecision(20);\n\n #ifdef GCJ_CASE\n  int T;cin>>T;\n  times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n #else\n  solve();\n #endif\n\n return 0;\n}\n/*? end \"base.hpp\" */\n/*? begin \"graph.hpp\" */\n/*? begin \"uf.hpp\" */\nTL<class T=int,class Adder=plus<T>,class Inverser=negate<T>>\nclass UnionFind{\n/*!\nhttp://noshi91.hatenablog.com/entry/2018/05/30/191943\nhttps://en.wikipedia.org/wiki/Disjoint-set_data_structure\nhttps://qiita.com/drken/items/cce6fc5c579051e64fab\n*/\nint n,*parents,*sizes;T*pot_diffs;bool to_delete;Adder adder;\nInverser inverser;\npublic:\nexplicit UnionFind(int n,bool to_delete=false):\nn(n),parents(new int[n]),sizes(new int[n]),pot_diffs(new T[n]),to_delete(to_delete)\n{clear();\n}\nvoid clear(){\ntimes(n,i)parents[i]=i;/*roots*/\nfill(sizes,sizes+n,1);fill(pot_diffs,pot_diffs+n,0);\n}\n~UnionFind(){if(to_delete){delete[]parents;delete[]sizes;delete[]pot_diffs;}}\nint size(){RT n;}\nint root(int i){int p=parents[i];\nif(p==i)RT i;/*`i`is a root*/\nint r=root(p);/*and pot_diffs[p]:=diff from root*/\npot_diffs[i]+=pot_diffs[p];parents[i]=r;RT r;\n}\nbool is_same(int i,int j){RT root(i)==root(j);}\nbool is_all_same(){int r=root(0);uptil(1,n,i)if(root(i)!=r)RT 0;RT 1;}\nbool merge(int i,int j,T pdiff=0){i=root(i);j=root(j);\nif(i==j)RT false;/*already merged*/\nif(sizes[i]>sizes[j]){swap(i,j);pdiff=inverser(pdiff);\n}\n/*now sizes[i]<=sizes[j]*/\nparents[i]=j;sizes[j]+=sizes[i];pot_diffs[i]=pdiff;RT true;\n}\nT diff(int i,int j){\nroot(i);/*pot_diffs[i]:=diff from root*/\nroot(j);/*pot_diffs[j]:=diff from root*/\nRT adder(pot_diffs[i],inverser(pot_diffs[j]));}};using unionfind=UnionFind<>;\n/*? end \"uf.hpp\" */\nTL<class EdgeVal>\nstruct Edge{int from;int to;EdgeVal weight;\nEdge(int from,int to,EdgeVal weight):from(from),to(to),weight(weight){}\nIL bool OP==(CS Edge&e)CS{RT weight==e.weight&&from==e.from&&to==e.to;}\nIL bool OP<(CS Edge&e)CS{RT weight<e.weight||(weight==e.weight&&(from<e.from||(from==e.from&&to<e.to)));}\nIL bool OP<=(CS Edge&e)CS{RT this==e||this<e;}\nIL bool OP>(CS Edge&e)CS{RT e<this;}\nIL bool OP>=(CS Edge&e)CS{RT e<=this;}};\nTL<class VtxVal,class EdgeVal>\nclass Graph{\nusing VoidWithoutEdgeVal=TN enable_if<is_default_constructible<EdgeVal>::value,void>::type;\nprotected:\nint nv_,nde_;unionfind uf;\npublic:\nvec<VtxVal>vs;vvec<Edge<EdgeVal>>edges;\nGraph(int nv):nv_(nv),nde_(0),uf(nv),vs(nv),edges(nv){}\nIL int nv()CS{RT nv_;}\nIL int nde()CS{RT nde_;}\nIL int nue()CS{RT nde_/2;}\nIL void add_dedge(int i,int j,CS EdgeVal&val){\nif(!rab::is_in(i,0LL,nv_)||!rab::is_in(j,0LL,nv_)){\ncerr<<\"invalid index:(\"<<i<<\",\"<<j<<\")for Graph(nv=\"<<nv_<<\")\" ln;\nexit(1);\n}\nedges[i].emplace_back(i,j,val);++nde_;\n}\nIL VoidWithoutEdgeVal add_dedge(int i,int j){add_dedge(i,j,EdgeVal());\n}\nIL void add_uedge(int i,int j,CS EdgeVal&val){add_dedge(i,j,val);\nadd_dedge(j,i,val);\n}\nIL VoidWithoutEdgeVal add_uedge(int i,int j){add_uedge(i,j,EdgeVal());\n}\nIL bool is_connected(){uf.clear();\nfor(CS auto&es:edges)for(CS auto&e:es)uf.merge(e.from,e.to);RT uf.is_all_same();\n}};\n/*? end \"graph.hpp\" */\n/*? begin \"flow.hpp\" */\n/*!Arihon,https://tubo28.me/algorithm/dinic/*/\nTL<TN F,TN V,TN E,TN CapFn=rab::identity>\n/*F:通常int,CapFn:E->F*/\nstruct dinic{int n,s,t;VI level,prog,que;\nWI edges;/*both direction*/\nvec<map<int,F>>cap,flow;//vvec<F>cap,flow;\ndinic(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\n//n(g.nv()),s(-1),t(-1),level(n),prog(n),que(n+1),edges(n),cap(n,VI(n)),flow(n,VI(n))\nn(g.nv()),s(-1),t(-1),level(n),prog(n),que(n+1),edges(n),cap(n),flow(n)\n{times(n,i){for(auto&e:g.edges[i]){F c=capfn(e.weight);\ncap[i][e.to]+=c;cap[e.to][i]+=c;flow[e.to][i]+=c;edges[i].PB(e.to);\nedges[e.to].PB(i);\n}}}\nF exec(int s,int t){this->s=s;this->t=t;F mf=0;\nwhile(update_level(),level[t]>0){fill(iter(prog),0);mf+=find_paths(s,numeric_limits<F>::max()/8/*inf*/);\n}\nRT mf;\n}\nvoid update_level(){int ql=0,qr=0;fill(iter(level),-1);level[s]=0;\nque[qr++]=s;while(ql!=qr/*queue is not empty*/){int v=que[ql++];\nif(v==t)break;\nfor(int d:edges[v]){if(level[d]<0&&cap[v][d]!=flow[v][d]){level[d]=level[v]+1;\nque[qr++]=d;\n}}}}\nF find_paths(int v,int limit){if(v==t)RT limit;F diff=0;\nfor(;prog[v]<size(edges[v]);++prog[v]){int d=edges[v][prog[v]];\nif(cap[v][d]!=flow[v][d]&&level[v]<level[d]){F df=find_paths(d,min(limit,cap[v][d]-flow[v][d]));\nflow[v][d]+=df;flow[d][v]-=df;diff+=df;limit-=df;if(limit==0)break;\n}}\nRT diff;}};\n/*!Arihon,https://tubo28.me/algorithm/ford-fulkerson/*/\nTL<TN V,TN E,TN CapFn=rab::identity>\nstruct ford_fulkerson{int n,s,t;VC visited;\nWI edges;/*both direction*/\nprivate:\nHII cap_,flow_;\npublic:\nford_fulkerson(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),visited(n),edges(n)\n{times(n,i){for(auto&e:g.edges[i]){int c=capfn(e.weight);\ncap_[i<<32|e.to]+=c;cap_[e.to<<32|i]+=c;flow_[e.to<<32|i]+=c;edges[i].PB(e.to);\nedges[e.to].PB(i);\n}}}\nint cap(int a,int b){RT cap_[a<<32|b];}\nint flow(int a,int b){RT flow_[a<<32|b];}\nint exec(int s,int t){this->s=s;this->t=t;int mf=0;\nwhile(1){fill(iter(visited),false);int df=find_path(s,LLONG_MAX/8/*inf*/);if(df==0)RT mf;\nmf+=df;\n}}\nint find_path(int v,int limit){visited[v]=true;if(v==t)RT limit;\nfor(int d:edges[v]){if(!visited[d]){int c=cap_[v<<32|d],&f=flow_[v<<32|d];\nif(c-f>0){int df=find_path(d,min(limit,c-f));if(df>0){f+=df;flow_[d<<32|v]-=df;RT df;\n}}}}\nRT 0;}};\n/*? end \"flow.hpp\" */\nconstexpr int INF = 401;\n\nvoid solve() {\n// HWH(\"S\")\n/* <foxy.memo-area> */\nint H;int W;cin>>H;cin>>W;VS S(H);times(H,Ri_0){cin>>S[Ri_0];}\n/* </foxy.memo-area> */\n\n  Graph<unit, int> g(H * W * 2 + 2);\n\n  int s = H * W * 2, t = H * W * 2 + 1;\n\n  #define inp(i, j) (((i) * W + (j)) * 2)\n  #define outp(i, j) (((i) * W + (j)) * 2 + 1)\n\n  times(H, i) times(W, j) {\n    g.add_dedge(inp(i, j), outp(i, j), 1);\n\n    if(S[i][j] == 'X') {\n      g.add_dedge(s, outp(i, j), INF);\n\n      if(i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n        cout << -1 ln;\n        return;\n      }\n    }\n  }\n\n  times(H, i) {\n    g.add_dedge(outp(i, 0), t, INF);\n    g.add_dedge(outp(i, W-1), t, INF);\n\n    times(W-1, j) {\n      g.add_dedge(outp(i, j), inp(i, j + 1), INF);\n      g.add_dedge(outp(i, j + 1), inp(i, j), INF);\n    }\n  }\n  times(W, j) {\n    g.add_dedge(outp(0, j), t, INF);\n    g.add_dedge(outp(H-1, j), t, INF);\n\n    times(H-1, i) {\n      g.add_dedge(outp(i, j), inp(i + 1, j), INF);\n      g.add_dedge(outp(i + 1, j), inp(i, j), INF);\n    }\n  }\n\n  dinic<int, unit, int> d(g);\n  cout << d.exec(s, t) ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\n\nint main(){\n  int h,w;\n  char s[100][101];\n  scanf(\"%d %d\",&h,&w);\n  for(int i=0;i<h;i++) scanf(\"%s\",s[i]);\n  bool fflag = false;\n  for(int i=0;i<h;i++) if(s[i][0]=='X'||s[i][w-1]=='X') fflag = true;\n  for(int i=0;i<w;i++) if(s[0][i]=='X'||s[h-1][i]=='X') fflag = true;\n  if(fflag){\n    printf(\"-1\\n\");\n    return 0;\n  }\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(s[i][j]=='X'){\n        for(int k=0;k<4;k++){\n          if(s[i+dx[k]][j+dy[k]]!='S'&&s[i+dx[k]][j+dy[k]]!='F'){\n            s[i+dx[k]][j+dy[k]] = 'F';\n          }\n        }\n      }\n    }\n  }\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(s[i][j]=='F'){\n        bool flag = true;\n        for(int k=0;k<4;k++){\n          if(s[i+dx[k]][j+dy[k]]!='F'&&s[i+dx[k]][j+dy[k]]!='X'&&s[i+dx[k]][j+dy[k]]!='A'){\n            flag = false;\n          }\n        }\n        if(flag) s[i][j] = 'A';\n      }\n    }\n  }\n  int ans = 0;\n  for(int i=0;i<h;i++)for(int j=0;j<w;j++)if(s[i][j]=='F')ans++;\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Problem {\npublic:\n    Problem(int h, int w) : h(h), w(w), maze(h), used(h, vector<bool>(w, false)) { }\n    void Input();\n    int Solve();\n\nprivate:\n    int h, w;\n    vector<string> maze;\n    vector<vector<bool>> used;\n\n    bool Contain(int y, int x) { return 0 <= y && y < h && 0 <= x && x < w; }\n    bool CanRemove(int y, int x);\n};\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nvoid Problem::Input() {\n    for (int i = 0; i < h; ++i) cin >> maze[i];\n}\n\nbool Problem::CanRemove(int y, int x) {\n    vector<vector<bool>> visited(h, vector<bool>(w, false));\n    queue<pair<int, int>> que;\n\n    que.push(make_pair(y, x));\n    visited[y][x] = true;\n    while (!que.empty()) {\n        auto cur = que.front();\n        que.pop();\n\n        for (int d = 0; d < 4; ++d) {\n            int ny = cur.first + dy[d], nx = cur.second + dx[d];\n\n            if (!Contain(ny, nx) || used[ny][nx] || visited[ny][nx])\n                continue;\n\n            if (ny == 0 || ny == h - 1 || nx == 0 || nx == w - 1)\n                return false;\n\n            que.push(make_pair(ny, nx));\n            visited[ny][nx] = true;\n        }\n    }\n\n    return true;\n}\n\nint Problem::Solve() {\n    for (int i = 0; i < h; ++i)\n        if (maze[i][0] == 'X' || maze[i][w - 1] == 'X') return -1;\n    for (int i = 0; i < w; ++i)\n        if (maze[0][i] == 'X' || maze[h - 1][i] == 'X') return -1;\n\n    for (int y = 0; y < h; ++y) {\n        for (int x = 0; x < w; ++x)\n            if (maze[y][x] == 'X')\n                for (int d = 0; d < 4; ++d) {\n                    int nx = x + dx[d], ny = y + dy[d];\n\n                    if (Contain(ny, nx) && maze[ny][nx] == '.')\n                        used[ny][nx] = true;\n                }\n    }\n\n    for (int y = 0; y < h; ++y)\n        for (int x = 0; x < w; ++x)\n            if (used[y][x] && CanRemove(y, x))\n                used[y][x] = false;\n\n    int cnt = 0;\n    for (int y = 0; y < h; ++y)\n        for (int x = 0; x < w; ++x)\n            if (used[y][x]) ++cnt;\n\n    return cnt;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int h, w;\n\n    cin >> h >> w;\n    Problem p(h, w);\n\n    p.Input();\n    cout << p.Solve() << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<array>\n#include<algorithm>\n#include<list>\n#include<cmath>\n#include<iomanip>\n#include<queue>\n#include<functional>\n#include<climits>\n#include<iterator>\n#include<unordered_set>\n#include<unordered_map>\n#include<map>\n#include<set>\n#include<typeinfo>\nusing namespace std;\n\nconst double pi=4*atan(1.0);\n\nconstexpr long long mod=static_cast<long long>(1e9+7);\n\nusing cWeightEdges=vector<vector<pair<int,int>>>;\nusing cEdges=vector<vector<int>>;\n\nint main(){\n\tint H,W;\n\tcin>>H>>W;\n\tvector<string> a(H);\n\tfor(auto& val:a)\n\t\tcin>>val;\n\n\tbool IsEdge=false;\n\tfor(int i=0;i<H;++i){\n\t\tfor(int j=0;j<W;++j){\n\t\t\tif(a[i][j]=='X'){\n\t\t\t\tif(i==0 || i==H-1 || j==0 || j==W-1){\n\t\t\t\t\tIsEdge=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif(a[i-1][j]!='X')a[i-1][j]='#';\n\t\t\t\tif(a[i+1][j]!='X')a[i+1][j]='#';\n\t\t\t\tif(a[i][j-1]!='X')a[i][j-1]='#';\n\t\t\t\tif(a[i][j+1]!='X')a[i][j+1]='#';\n\t\t\t}\n\t\t}\n\t}\n\n\tif(IsEdge){\n\t\tcout<<-1<<endl;\n\t}\n\telse{\n\t\tfor(int i=1;i<H-1;++i){\n\t\t\tfor(int j=1;j<W-1;++j){\n\t\t\t\tif(a[i][j]=='.'){\n\t\t\t\t\tbool IsAdd=true;\n\t\t\t\t\tif(a[i-1][j]=='.')IsAdd=false;\n\t\t\t\t\tif(a[i+1][j]=='.')IsAdd=false;\n\t\t\t\t\tif(a[i][j-1]=='.')IsAdd=false;\n\t\t\t\t\tif(a[i][j+1]=='.')IsAdd=false;\n\n\t\t\t\t\tif(IsAdd)a[i][j]='#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=1;i<H-1;++i){\n\t\t\tfor(int j=1;j<W-1;++j){\n\t\t\t\tif(a[i][j]=='#'){\n\t\t\t\t\tbool CanErase=true;\n\t\t\t\t\tif(a[i-1][j]=='.')CanErase=false;\n\t\t\t\t\tif(a[i+1][j]=='.')CanErase=false;\n\t\t\t\t\tif(a[i][j-1]=='.')CanErase=false;\n\t\t\t\t\tif(a[i][j+1]=='.')CanErase=false;\n\n\t\t\t\t\tif(CanErase)a[i][j]='%';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans=0;\n\t\tfor(int i=0;i<H;++i){\n\t\t\tfor(int j=0;j<W;++j){\n\t\t\t\tif(a[i][j]=='#')++ans;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n     File Name: 1.cpp\n     ID: Liusiyu\n     BLOG: http://blog.csdn.net/r_o_j \n     LANG: C++ \n     Mail: 779532360@qq.com \n     Created Time: 2016年10月02日 星期日 14时09分42秒\n ************************************************************************/\n#include<bits/stdc++.h>\n#define MEM(a,x) memset(a,x,sizeof(a));\n#define MEMINF(a) memset(a,0x3f,sizeof(a));\nusing namespace std;\ntypedef long long LL;\nconst int MAXN=205;\nconst int INF=0x3f3f3f3f;\nconst int MOD=1000000007;\nchar mp[MAXN][MAXN];\nstruct Node{\n  int x,y;\n};\nint cnt;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nqueue<Node>goat,q;\nbool vis[MAXN][MAXN];\nvoid goat_bfs() {\n  while (!goat.empty()) {\n    Node u=goat.front();\n    goat.pop();\n    vis[u.x][u.y]=true;\n    for (int i=0; i<4; ++i) {\n      Node v=u;\n      v.x+=dx[i];\n      v.y+=dy[i];\n      if (vis[v.x][v.y]==true) continue;\n      cnt++;\n      vis[v.x][v.y]=true;\n      q.push(v);\n    }\n  }\n}\nvoid root_bfs(){\n  while(!q.empty()) {\n    Node u=q.front();\n    q.pop();\n    int bian=0;\n    for (int i=0; i<4; ++i) {\n      Node v=u;\n      v.x+=dx[i];\n      v.y+=dy[i];\n      if (vis[v.x][v.y]) bian++;\n    }\n    if (bian==4) cnt--;\n  }\n}\n\n\nint main() {\n  int n,m;\n  cin>>n>>m;\n  Node node;\n  MEM(vis,false);\n  for (int i=1; i<=n; ++i){ \n     scanf(\"%s\",mp[i]+1);\n     for(int j=1; j<=n; ++j) {\n       if (mp[i][j]=='X') {\n         node.x=i;\n         node.y=j;\n         vis[i][j]=true;\n         goat.push(node);\n       }\n     }\n  }\n  for (int i=1; i<=m; ++i) {\n    if (mp[1][i]=='X'||mp[n][i]=='X') {\n      puts(\"-1\");\n      return 0;\n    }\n  }\n  for (int i=1; i<=n; ++i) {\n    if (mp[i][1]=='X'||mp[i][m]=='X') {\n      puts(\"-1\");\n      return 0;\n    }\n  }\n\n  goat_bfs();\n  root_bfs();\n  printf(\"%d\\n\",cnt);\n}\n\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nint H, W;\nstring b[100];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nvoid dfs(int x, int y) {\n\tif(b[y][x] != '.') return;\n\tb[y][x] = '@';\n\tfor(int k = 0; k < 4; k++) {\n\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\tif(in(nx, ny)) {\n\t\t\tif(b[ny][nx] == '#') b[ny][nx] = '$';\n\t\t\tif(b[ny][nx] == '.') dfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++) {\n\t\tcin >> b[i];\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\tif(b[i][0] == 'X' || b[i][W - 1] == 'X') {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = 0; i < W; i++) {\n\t\tif(b[0][i] == 'X' || b[H - 1][i] == 'X') {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(b[y][x] == 'X') {\n\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\tif(in(nx, ny) && b[ny][nx] == '.') b[ny][nx] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\tdfs(0, i);\n\t\tdfs(W - 1, i);\n\t\tdfs(i, 0);\n\t\tdfs(i, H - 1);\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\tcout << b[i] << endl;\n\t}\n\n\tint ans = 0;\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(b[y][x] == '$') ans++;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nint H, W;\nstring b[100];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nvoid dfs(int x, int y) {\n\tif(b[y][x] == '#') {\n\t\tb[y][x] = '$';\n\t\treturn;\n\t}\n\tif(b[y][x] != '.') return;\n\tb[y][x] = '@';\n\tfor(int k = 0; k < 4; k++) {\n\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\tif(in(nx, ny)) {\n\t\t\tif(b[ny][nx] == '#') b[ny][nx] = '$';\n\t\t\tif(b[ny][nx] == '.') dfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++) {\n\t\tcin >> b[i];\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\tif(b[i][0] == 'X' || b[i][W - 1] == 'X') {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = 0; i < W; i++) {\n\t\tif(b[0][i] == 'X' || b[H - 1][i] == 'X') {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\tbool flag = true;\n\twhile(flag) {\n\t\tflag = false;\n\t\tfor(int y = 0; y < H - 2; y++) {\n\t\t\tfor(int x = 0; x < W; x++) {\n\t\t\t\tif(x + 2 < W && b[y][x] == 'X' && b[y][x + 1] == 'X' && b[y][x + 2] == 'X') {\n\t\t\t\t\tif(b[y + 1][x + 1] != 'X') flag = true;\n\t\t\t\t\tb[y + 1][x + 1] = 'X';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tfor(int x = 0; x < W - 2; x++) {\n\t\t\tfor(int y = 0; y < H; y++) {\n\t\t\t\tif(y + 2 < H && b[y][x] == 'X' && b[y + 1][x] == 'X' && b[y + 2][x] == 'X') {\n\t\t\t\t\tif(b[y + 1][x + 1] != 'X') flag = true;\n\t\t\t\t\tb[y + 1][x + 1] = 'X';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int y = H - 1; y >= 2; y--) {\n\t\t\tfor(int x = 0; x < W; x++) {\n\t\t\t\tif(x + 2 < W && b[y][x] == 'X' && b[y][x + 1] == 'X' && b[y][x + 2] == 'X') {\n\t\t\t\t\tif(b[y - 1][x + 1] != 'X') flag = true;\n\t\t\t\t\tb[y - 1][x + 1] = 'X';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int x = W - 1; x >= 2; x--) {\n\t\t\tfor(int y = 0; y < H; y++) {\n\t\t\t\tif(y + 2 < H && b[y][x] == 'X' && b[y + 1][x] == 'X' && b[y + 2][x] == 'X') {\n\t\t\t\t\tif(b[y + 1][x - 1] != 'X') flag = true;\n\t\t\t\t\tb[y + 1][x - 1] = 'X';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\tcout << b[i] << endl;\n\t}\n\n\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(b[y][x] == 'X') {\n\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\tif(b[ny][nx] == '.') b[ny][nx] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\tdfs(0, i);\n\t\tdfs(W - 1, i);\n\t}\n\tfor(int i = 0; i < W; i++) {\n\t\tdfs(i, 0);\n\t\tdfs(i, H - 1);\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\tcout << b[i] << endl;\n\t}\n\n\n\tint ans = 0;\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(b[y][x] == '$') ans++;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nauto main () -> int {\n  int h , w;\n  std::cin >> h >> w;\n  char s [h] [w];\n  bool fail = false;\n  for (auto y = 0; y < h; ++ y) {\n    for (auto x = 0; x < w; ++ x) {\n      std::cin >> s [y] [x];\n      if (s [y] [x] == 'X' && (x == 0 || y == 0 || x == w - 1 || y == h - 1)) {\n        fail = true;\n      }\n    }\n  }\n\n  if (fail) {\n    std::cout << \"-1\" << std::endl;\n    return 0;\n  }\n\n  auto res = 0;\n  for (auto y = 1; y < h - 1; ++ y) {\n    for (auto x = 1; x < w - 1; ++ x) {\n      if (s [y] [x] == 'X') {\n        if (s [y - 1] [x] == '.') {\n          s [y - 1] [x] = '#';\n          ++ res;\n        }\n        if (s [y + 1] [x] == '.') {\n          s [y + 1] [x] = '#';\n          ++ res;\n        }\n        if (s [y] [x - 1] == '.') {\n          s [y] [x - 1] = '#';\n          ++ res;\n        }\n        if (s [y] [x + 1] == '.') {\n          s [y] [x + 1] = '#';\n          ++ res;\n        }\n      }\n    }\n  }\n\n  for (auto y = 1; y < h - 1; ++ y) {\n    for (auto x = 1; x < w - 1; ++ x) {\n      if (s [y] [x] == '#') {\n        if (s [y - 1] [x] != '.' && s [y + 1] [x] != '.' && s [y] [x - 1] != '.' && s [y] [x + 1] != '.') {\n          s [y] [x] = ',';\n          -- res;\n        }\n      }\n    }\n  }\n\n  std::cout << res << std::endl;\n\n#ifdef DEBUG\n  for (auto y = 0; y < h; ++ y) {\n    for (auto x = 0; x < w; ++ x) {\n      std::cout << s [y] [x];\n    }\n    std::cout << std::endl;\n  }\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,1,0,-1};\n\nint H, W;\nstring s[110];\nbool ns[110][110];\nbool rc[110][110];\n\nint main() {\n\tcin >> H >> W;\n\trep(i, H) cin >> s[i];\n\n\trep(i, H) {\n\t\trep(j, W) {\n\t\t\tif (s[i][j] == 'X') {\n\t\t\t\tif (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n\t\t\t\t\tputs(\"-1\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tns[i-1][j]=ns[i+1][j]=ns[i][j-1]=ns[i][j+1]=1;\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<pii> que;\n\trep(i, H) {\n\t\trep(j, W) {\n\t\t\tif (s[i][j] == 'X') {\n\t\t\t\tns[i][j] = 0;\n\t\t\t}\n\t\t\tif (!ns[i][j] && (i == 0 || i == H - 1 || j == 0 || j == W - 1)) {\n\t\t\t\tque.push(mp(i, j));\n\t\t\t\trc[i][j] = 1;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\n\twhile (!que.empty()) {\n\t\tpii p = que.front(); que.pop();\n\t\tint y = p.fi, x = p.se;\n\n\t\trep(i, 4) {\n\t\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\t\tif (ny >= 0 && ny < H && nx >= 0 && nx < W) {\n\t\t\t\tif (!ns[ny][nx] && !rc[ny][nx]) {\n\t\t\t\t\trc[ny][nx] = 1;\n\t\t\t\t\tque.push(mp(ny, nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = 0;\n\n\trep(y, H) {\n\t\trep(x, W) {\n\t\t\tif (!ns[y][x]) continue;\n\t\t\tbool ok = 0;\n\n\t\t\trep(i, 4) {\n\t\t\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\t\t\tif (ny >= 0 && ny < H && nx >= 0 && nx < W) {\n\t\t\t\t\tif (rc[ny][nx]) {\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t}\n\t\t\t\t} else ok = 1;\n\t\t\t}\n\n\t\t\tret += ok;\n\t\t}\n\t}\n\n\tcout << min(ret, (H+W-2)*2) << endl;\n\n\treturn 0;\n}\n\n/*\n6 6\n......\n......\n..XX.\n.X...\n..XX..\n......\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(v, a, b) for(int v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(int v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(int v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define LLI long long int\n#define fst first\n#define snd second\n\n#ifdef DEBUG\n#include <misc/C++/Debug.cpp>\n#else\n#define dump(x) ((void)0)\n#endif\n\n#define gcd __gcd\n\nusing namespace std;\ntemplate <class T> constexpr T lcm(T m, T n){return m/gcd(m,n)*n;}\n\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\ntemplate <typename T, typename U> istream& operator>>(istream &is, pair<T,U> &p){is >> p.first >> p.second; return is;}\n\ntemplate <typename T, typename U> T& chmin(T &a, const U &b){return a = (a<=b?a:b);}\ntemplate <typename T, typename U> T& chmax(T &a, const U &b){return a = (a>=b?a:b);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\n\ntemplate <typename T, T INF> class Dinic{\nprivate:\n  vector<vector<pair<int,T>>> graph;\n  int size, s, t;\n  vector<vector<T>> cap;\n  vector<int> level;\n  \n  bool buildLevel(){\n    fill(ALL(level), 0);\n    level[s] = 1;\n    deque<int> deq = {s};\n    while(!deq.empty()){\n      int cur = deq.front(); deq.pop_front();\n      REP(i,size)\n\tif(level[i]==0 && cap[cur][i]>0){\n\t  level[i] = level[cur] + 1;\n\t  deq.push_back(i);\n\t}\n    }\n    return level[t] != 0;\n  }\n  void dfs(vector<int> &path, T &flow){\n    if(path.empty()) return;\n    int cur = path.back();\n    if(cur == t){\n      T f = INF;\n      FOR(i,1,path.size()) f = min(f, cap[path[i-1]][path[i]]);\n      FOR(i,1,path.size()){\n\tcap[path[i-1]][path[i]] -= f;\n\tcap[path[i]][path[i-1]] += f;\n      }\n      flow += f;\n    }else{\n      REP(i,size){\n\tif(cap[cur][i]>0 && level[i]>level[cur]){\n\t  path.push_back(i);\n\t  dfs(path, flow);\n\t  path.pop_back();\n\t}\n      }\n    }\n  }\n  T augment(){\n    T f = 0;\n    vector<int> path = {s};\n    dfs(path, f);\n    return f;\n  }\n  T loop(){\n    T f = 0;\n    while(buildLevel()) f += augment();\n    return f;\n  }\n\npublic:\n  Dinic(vector<vector<pair<int,T>>> &_graph): graph(_graph), size(graph.size()) {}\n  Dinic(int size): graph(size), size(size){}\n\n  void add_edge(int from, int to, const T &cap){\n    graph[from].push_back({to, cap});\n  }\n  \n  T max_flow(int _s, int _t){\n    cap = vector<vector<T>>(size, vector<T>(size, 0));\n    level = vector<int>(size, 0);\n\n    REP(i,size)\n      for(auto &p : graph[i]){\n\tint j = p.first;\n\tT d = p.second;\n\tcap[i][j] += d;\n      }\n\n    s = _s;\n    t = _t;\n\n    return loop();\n  }\n};\n\nconst int dir4[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  const int inf = INT_MAX / 2;\n\n  int H,W;\n  while(cin >> H >> W){\n    vector<string> S(H); cin >> S;\n\n    Dinic<int,inf> mf(H*W*2+2);\n    int s = H*W*2, t = s+1;\n    vector<vector<int>> in(H,vector<int>(W)), out(H,vector<int>(W));\n    REP(i,H) REP(j,W){\n      in[i][j] = i+j*H;\n      out[i][j] = in[i][j] + H*W;\n    }\n    \n    REP(i,H){\n      REP(j,W){\n\tif(i==0 or i==H-1 or j==0 or j==W-1) mf.add_edge(out[i][j], t, inf);\n\n\tif(S[i][j] == 'X'){\n\t  mf.add_edge(s, in[i][j], inf);\n\t  mf.add_edge(in[i][j], out[i][j], inf);\n\t}\n\telse mf.add_edge(in[i][j], out[i][j], 1);\n\n\tfor(auto &d : dir4){\n\t  int y = i+d[0], x = j+d[1];\n\t  if(x<0 or x>=W or y<0 or y>=H) continue;\n\t  mf.add_edge(out[i][j], in[y][x], inf);\n\t}\n      }\n    }\n\n    int ans = mf.max_flow(s,t);\n    \n    cout << (ans>=inf ? -1 : ans) << endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define for(i, a, b) for(ll (i)=a;(i)<(b);++(i))\n#define rep(i, n)    for(i, 0, n)\n#define MAX_V        20004\n\nconst ll inf = 1e15;\nconst ll mod = 1e9+7;\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nstruct edge {\n    ll to, cap, rev;\n    edge(ll t, ll c, ll r): to(t), cap(c), rev(r){}\n};\n\nvector<edge> G[MAX_V];\nll level[MAX_V];\nll iter[MAX_V];\n\nvoid add_edge(ll from, ll to, ll cap) {\n    G[from].push_back(edge(to, cap, G[to].size()));\n    G[to].push_back(edge(from, 0, G[from].size() - 1));\n}\n\nvoid bfs(ll s) {\n    memset(level, -1, sizeof(level));\n    queue<ll> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n        ll v = que.front(); que.pop();\n        rep(i, G[v].size()) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nll dfs(ll v, ll t, ll f) {\n    if (v == t) return f;\n    for(i, iter[v], G[v].size()) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[v] < level[e.to]) {\n            ll d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nll max_flow(ll s, ll t) {\n    ll flow = 0;\n    while (true) {\n        bfs(s);\n        if (level[t] < 0) return flow;\n        memset(iter, 0, sizeof(iter));\n        ll f;\n        while ((f = dfs(s, t, inf)) > 0) {\n            flow += f;\n        }\n    }\n}\n\nchar field[101][101];\nint main() {\n    ll H, W; cin >> H >> W;\n    rep(i, H) rep(j, W) {\n        cin >> field[i][j];\n        if (field[i][j] == 'X' && (i == 0 || i == H-1 || j == 0 || j == W-1)) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n    \n    ll S = 2 * H * W;\n    ll T = 2 * H * W + 1;\n    rep(i, H) rep(j, W) {\n        if (field[i][j] == 'X') add_edge(S, i * W + j, inf);\n        add_edge(i * W + j, H * W + i * W + j, field[i][j] == 'X' ? inf : 1);\n        \n        if (i == 0 || i == H-1 || j == 0 || j == W-1) add_edge(H * W + i * W + j, T, inf);\n        rep(k, 4) {\n            if (i+dy[k] < 0 || H-1 < i+dy[k] || j+dx[k] < 0 || W-1 < j+dx[k]) continue;\n            add_edge(H * W + i * W + j, (i+dy[k]) * W + (j+dx[k]), inf);\n        }\n    }\n    cout << max_flow(S, T) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n     File Name: 1.cpp\n     ID: Liusiyu\n     BLOG: http://blog.csdn.net/r_o_j \n     LANG: C++ \n     Mail: 779532360@qq.com \n     Created Time: 2016年10月02日 星期日 14时09分42秒\n ************************************************************************/\n#include<bits/stdc++.h>\n#define MEM(a,x) memset(a,x,sizeof(a));\n#define MEMINF(a) memset(a,0x3f,sizeof(a));\nusing namespace std;\ntypedef long long LL;\nconst int MAXN=205;\nconst int INF=0x3f3f3f3f;\nconst int MOD=1000000007;\nint n,m;\nchar mp[MAXN][MAXN];\nstruct Node{\n  int x,y;\n};\nint cnt;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nqueue<Node>goat,q;\nbool vis[MAXN][MAXN];\nvoid goat_bfs() {\n  while (!goat.empty()) {\n    Node u=goat.front();\n    goat.pop();\n    vis[u.x][u.y]=true;\n    for (int i=0; i<4; ++i) {\n      Node v=u;\n      v.x+=dx[i];\n      v.y+=dy[i];\n      if (v.x<1||v.x>n||v.y<1||v.y>m) continue;\n      if (vis[v.x][v.y]==true) continue;\n      cnt++;\n      vis[v.x][v.y]=true;\n      q.push(v);\n    }\n  }\n}\nbool root_dfs(Node u,int dir){\n  while(true) {\n    u.x+=dx[dir];\n    u.y+=dy[dir];\n    if (vis[u.x][u.y]==true) return true;\n    else if (u.x<1||u.x>n||u.y<1||u.y>m) return false;\n  }\n}\n\n\nint main(){\n  cin>>n>>m;\n  Node node;\n  MEM(vis,false);\n  for (int i=1; i<=n; ++i){ \n     scanf(\"%s\",mp[i]+1);\n     for(int j=1; j<=n; ++j) {\n       if (mp[i][j]=='X') {\n         node.x=i;\n         node.y=j;\n         vis[i][j]=true;\n         goat.push(node);\n       }\n     }\n  }\n  for (int i=1; i<=m; ++i) {\n    if (mp[1][i]=='X'||mp[n][i]=='X') {\n      puts(\"-1\");\n      return 0;\n    }\n  }\n  for (int i=1; i<=n; ++i) {\n    if (mp[i][1]=='X'||mp[i][m]=='X') {\n      puts(\"-1\");\n      return 0;\n    }\n  }\n\n  goat_bfs();\n  while (!q.empty()) {\n    Node u=q.front();\n    q.pop();\n    int bian=0;\n    for (int i=0; i<4; ++i)\n    if (root_dfs(u,i)) bian++;\n    if (bian==4) cnt--;\n  }\n\n\n  printf(\"%d\",cnt);\n}\n\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <cstdlib>\n#define INF 100000000\n#define _INF -100000000\n#define INFLL (long long)1e14\n#define _INFLL (long long)-1e14\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef pair<ll, ll> P;\n\nint dx[4] = { 0,0,-1,1 }, dy[4] = { 1,-1,0,0 };\nchar field[105][105];\nint h, w;\n\nvoid solve() {\n\tbool judge = true;\n\tLoop(i, h) {\n\t\tif (field[i][0] == 'X' || field[i][w - 1] == 'X') {\n\t\t\tcout << -1 << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tLoop(j, w) {\n\t\tif (field[0][j] == 'X' || field[h - 1][j] == 'X') {\n\t\t\tcout << -1 << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\t//\n\tLoop(i, h) {\n\t\tLoop(j, w) {\n\t\t\tif (field[i][j] == 'X') {\n\t\t\t\tLoop(k, 4) {\n\t\t\t\t\tif (field[i + dx[k]][j + dy[k]] == '.') field[i + dx[k]][j + dy[k]] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tLoop(i, h) {\n\t\tLoop(j, w) {\n\t\t\tif (field[i][j] == '#') {\n\t\t\t\tbool judge = false;\n\t\t\t\tLoop(k, 4) {\n\t\t\t\t\tif (field[i + dx[k]][j + dy[k]] == '.') {\n\t\t\t\t\t\tjudge = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (judge)ans++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tcin >> h >> w;\n\tLoop(i, h) {\n\t\tLoop(j, w) {\n\t\t\tcin >> field[i][j];\n\t\t}\n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint H,W;\nstring S[202];\nint vis[202][202];\nint ret=0;\n\nvoid dfs(int y,int x) {\n\tint i;\n\tif(vis[y][x]) return;\n\tvis[y][x]=1;\n\tif(S[y][x]=='O') ret++, S[y][x]='o';\n\tif(S[y][x]=='.') {\n\t\tFOR(i,4) {\n\t\t\tint dd[4]={1,0,-1,0};\n\t\t\tint ty=y+dd[i];\n\t\t\tint tx=x+dd[i^1];\n\t\t\tif(ty<0 || tx<0 || ty>=H || tx>=W) continue;\n\t\t\tdfs(ty,tx);\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>H>>W;\n\tFOR(y,H) cin>>S[y];\n\tFOR(y,H) if(S[y][0]=='X' || S[y][W-1]=='X') return _P(\"-1\\n\");\n\tFOR(x,W) if(S[0][x]=='X' || S[H-1][x]=='X') return _P(\"-1\\n\");\n\tfor(y=H-1;y>=0;y--) S[y+1]=\".\"+S[y]+\".\";\n\tS[0]=string(W+2,'.');\n\tS[H+1]=string(W+2,'.');\n\t\n\tH+=2;\n\tW+=2;\n\tFOR(y,H) FOR(x,W) if(S[y][x]=='X') {\n\t\tif(S[y-1][x]=='.') S[y-1][x]='O';\n\t\tif(S[y+1][x]=='.') S[y+1][x]='O';\n\t\tif(S[y][x-1]=='.') S[y][x-1]='O';\n\t\tif(S[y][x+1]=='.') S[y][x+1]='O';\n\t}\n\t\n\tdfs(0,0);\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long int lint;\ntypedef pair<lint, lint> plint;\ntypedef pair<double long, double long> pld;\n#define Alint(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1ll << (n))\n#define FOR(i, begin, end) for(lint i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(lint i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2>& l, const pair<T1, T2>& r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2>& l, const pair<T1, T2>& r) { return make_pair(l.first - r.first, l.second - r.second); }\nconst lint MOD = 998244353, INF = 1e18;\n\nstruct edge { lint to, cap, rev; };\n\nvector<edge> Graph[20000];\nint level[20000];\nint iter[20000];\nvoid add_edge(lint from, lint to, lint cap) {\n\tGraph[from].push_back({ to, cap, SZ(Graph[to]) });\n\tGraph[to].push_back({ from, 0, SZ(Graph[from]) - 1 });\n}\nvoid bfs(lint s) {\n\tmemset(level, -1, sizeof(level));\n\tqueue<lint> que;\n\tque.push(s);\n\tlevel[s] = 0;\n\twhile (!que.empty()) {\n\t\tlint v = que.front(); que.pop();\n\t\tREP(i, SZ(Graph[v])) {\n\t\t\tedge& e = Graph[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nlint dfs(lint v, lint t, lint f) {\n\tif (v == t) return f;\n\tfor (int& i = iter[v]; i < SZ(Graph[v]); i++) {\n\t\tedge& e = Graph[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tlint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tGraph[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nlint max_flow(lint s, lint t) {\n\tlint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0) return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tlint f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\n\nlint H, W;\nchar c;\n\nint main() {\n\tcin.tie(0); ios_base::sync_with_stdio(false);\n\t//始点 20002 終点 20003\n\tlint N = 50;\n\tcin >> H >> W;\n\tREP(i, H) {\n\t\tREP(j, W) {\n\t\t\tcin >> c;\n\t\t\tif (c == 'X') {\n\t\t\t\tadd_edge(10002, i * H + j + N, INF);\n\t\t\t}\n\t\t\tadd_edge(i * H + j, i * H + j + N, 1);\n\t\t\tif (j != 0) {\n\t\t\t\tadd_edge(i * H + j + N, i * H + j - 1, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i * H + j + N, 10003, INF);\n\t\t\t}\n\t\t\tif (j != W - 1) {\n\t\t\t\tadd_edge(i * H + j + N, i * H + j + 1, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i * H + j + N, 10003, INF);\n\t\t\t}\n\t\t\tif (i != 0) {\n\t\t\t\tadd_edge(i * H + j + N, (i - 1) * H + j, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i * H + j + N, 10003, INF);\n\t\t\t}\n\t\t\tif (i != H - 1) {\n\t\t\t\tadd_edge(i * H + j + N, (i + 1) * H + j, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i * H + j + N, 10003, INF);\n\t\t\t}\n\t\t}\n\t}\n\tlint ans = max_flow(10002, 10003);\n\tif (ans == INF) cout << -1 << endl;\n\telse cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nusing M_BOOL = bool;\n#define M_TRUE (true)\n#define M_FALSE (false)\n#define DIVISOR (1000000007)\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = M_TRUE;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = M_TRUE;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = M_TRUE;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\ntypedef struct {\n    SDWORD lTo;\n    SQWORD sqCap;\n    SQWORD sqCost;\n    SDWORD lRev;\n} ST_EDGE;\n\n#define MAX_V   (20002)\n\nstruct Flow {\nprivate:\n    vector<ST_EDGE> avGraph[MAX_V];\n    SQWORD  sqEdgeNum;\n    SQWORD  asqDist[MAX_V];\n    SDWORD  alPrevV[MAX_V];   \n    SDWORD  alPrevEdge[MAX_V];      /*直前の頂点と辺 */\n\n    SDWORD  alDinic_Level[MAX_V];\n    SDWORD  alDinic_Iter[MAX_V];\n\npublic:\n    void addEdge(SDWORD lFrom, SDWORD lTo, SQWORD sqCap, SQWORD sqCost) {\n        // printf(\"%d ----[%lld] ----> %d\\n\", lFrom, sqCap, lTo);\n\n        avGraph[lFrom].push_back((ST_EDGE){lTo, sqCap, sqCost, (SDWORD)(avGraph[lTo].size())});\n        avGraph[lTo].push_back((ST_EDGE){lFrom, 0, -sqCost, (SDWORD)(avGraph[lFrom].size() - 1)});\n    }\n\n    SDWORD minCostFlow(SDWORD lStart, SDWORD lTarget, SQWORD sqFlow)\n    {\n        SQWORD sqRes = 0;\n        SQWORD sqFlowRest = sqFlow;\n        while (0 < sqFlowRest) {\n            /* Bellman-Ford Method */\n            fill(asqDist, asqDist + ArrayLength(asqDist), MAX_SDWORD);\n            asqDist[lStart] = 0;\n            bool bIsUpdate = true;\n            while (bIsUpdate) {\n                bIsUpdate = false;\n                for (SDWORD lV = 0; lV < MAX_V; lV++) {\n                    for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                        ST_EDGE &stE = avGraph[lV][lIdx];\n                        if ((asqDist[lV] != MAX_SDWORD)\n                                && (0 < stE.sqCap)\n                                && (asqDist[lV] + stE.sqCost < asqDist[stE.lTo])) {\n                            asqDist[stE.lTo] = asqDist[lV] + stE.sqCost;\n                            alPrevV[stE.lTo] = lV;\n                            alPrevEdge[stE.lTo] = lIdx;\n                            bIsUpdate = true;\n                        }\n                    }\n                }\n            }\n            if (asqDist[lTarget] == MAX_SDWORD) {\n                return -1;\n            }\n\n            SQWORD sqAddFlow = MAX_SQWORD;\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                sqAddFlow = min(sqAddFlow, avGraph[alPrevV[lV]][alPrevEdge[lV]].sqCap);\n            }\n            sqFlowRest -= sqAddFlow;\n            sqRes += sqAddFlow * asqDist[lTarget];      // 後で目的変数は書き換える\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                ST_EDGE &stE = avGraph[alPrevV[lV]][alPrevEdge[lV]];\n                stE.sqCap -= sqAddFlow;\n                avGraph[lV][stE.lRev].sqCap += sqAddFlow;\n            }\n        }\n        return sqRes;\n    }\n\nprivate:\n    SQWORD maxFlowDinicBfs(SDWORD lS)\n    {\n        memset(alDinic_Level, -1, sizeof(alDinic_Level));\n        queue<SDWORD> queSearch;\n        alDinic_Level[lS] = 0;\n        queSearch.push(lS);\n        while (!queSearch.empty()) {\n            SDWORD lV = queSearch.front();\n            queSearch.pop();\n            for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                ST_EDGE &stE = avGraph[lV][lIdx];\n                if ((0 < stE.sqCap) && (alDinic_Level[stE.lTo] < 0)) {\n                    alDinic_Level[stE.lTo] = alDinic_Level[lV] + 1;\n                    queSearch.push(stE.lTo);\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    SQWORD maxFlowDinicDfs(SDWORD lV, SDWORD lT, SQWORD sqF)\n    {\n        if (lV == lT) {\n            return sqF;\n        }\n        for (SDWORD &lI = alDinic_Iter[lV]; lI < avGraph[lV].size(); lI++) {\n            ST_EDGE &stE = avGraph[lV][lI];\n            if ((0 < stE.sqCap) && (alDinic_Level[lV] < alDinic_Level[stE.lTo])) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(stE.lTo, lT, min(sqF, stE.sqCap));\n                if (0 < sqDiffFlow) {\n                    stE.sqCap -= sqDiffFlow;\n                    avGraph[stE.lTo][stE.lRev].sqCap += sqDiffFlow;\n                    return sqDiffFlow;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    SQWORD MaxFlow(SDWORD lStart, SDWORD lTarget)\n    {\n        SQWORD sqFlow = 0LL;\n        for (;;) {\n            maxFlowDinicBfs(lStart);\n            if (alDinic_Level[lTarget] < 0) {\n                return sqFlow;\n            }\n            memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n            while (1) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(lStart, lTarget, MAX_SQWORD);\n                sqFlow += sqDiffFlow;\n                if (0LL == sqDiffFlow) {\n                    break;\n                }\n            }\n        }\n    }\n};\n\n#define MAX_WIDTH               (100)\n#define PNT_NO_START            (20000)\n#define PNT_NO_TARGET           (20001)\n#define PNT_NO_OFFSET_OUTPUT    (10000)\n#define DUMMY_COST              (0)\n\nint main()\n{\n    DWORD dwInput_H, dwInput_W;\n\n    dwInput_H = inputSDWORD();\n    dwInput_W = inputSDWORD();\n\n    Flow solverFlow;\n\n    char acInputLine[MAX_WIDTH + 1];\n\n    DWORD dwPntIdx = 0;\n    for (DWORD dwRowIdx = 0; dwRowIdx < dwInput_H; dwRowIdx++) {\n        inputString(acInputLine);\n\n        for (DWORD dwColIdx = 0; dwColIdx < dwInput_W; dwColIdx++) {\n            if (acInputLine[dwColIdx] == 'X') {\n                solverFlow.addEdge(PNT_NO_START,\n                                    dwPntIdx,\n                                    MAX_DWORD, DUMMY_COST);\n                solverFlow.addEdge(dwPntIdx,\n                                    dwPntIdx + PNT_NO_OFFSET_OUTPUT,\n                                    MAX_DWORD, DUMMY_COST);\n            } else {\n                solverFlow.addEdge(dwPntIdx,\n                                    dwPntIdx + PNT_NO_OFFSET_OUTPUT,\n                                    1, DUMMY_COST);\n            }\n            dwPntIdx++;\n        }\n    }\n\n    /* Connect Grids */\n    for (DWORD dwRowIdx = 0; dwRowIdx < dwInput_H-1; dwRowIdx++) {\n        for (DWORD dwColIdx = 0; dwColIdx < dwInput_W-1; dwColIdx++) {\n            DWORD dwPntIdx        = dwRowIdx       * dwInput_W + dwColIdx;\n            DWORD dwNextRowPntIdx = (dwRowIdx + 1) * dwInput_W + dwColIdx;\n            solverFlow.addEdge(dwPntIdx + PNT_NO_OFFSET_OUTPUT, \n                                dwNextRowPntIdx, \n                                MAX_DWORD, DUMMY_COST);\n            solverFlow.addEdge(dwNextRowPntIdx + PNT_NO_OFFSET_OUTPUT, \n                                dwPntIdx, \n                                MAX_DWORD, DUMMY_COST);\n\n            solverFlow.addEdge(dwPntIdx + PNT_NO_OFFSET_OUTPUT,\n                                dwPntIdx+1,\n                                MAX_DWORD, DUMMY_COST);\n            solverFlow.addEdge(dwPntIdx+1 + PNT_NO_OFFSET_OUTPUT, \n                                dwPntIdx,\n                                MAX_DWORD, DUMMY_COST);\n\n        }\n    }\n\n    /* Connect Target */\n    for (DWORD dwColIdx = 0; dwColIdx < dwInput_W; dwColIdx++) {\n        DWORD dwTopRowPntIdx  = dwColIdx;\n        DWORD dwTailRowPntIdx = dwInput_W * (dwInput_H - 1) + dwColIdx;\n        solverFlow.addEdge(dwTopRowPntIdx + PNT_NO_OFFSET_OUTPUT,\n                            PNT_NO_TARGET,\n                            MAX_DWORD, DUMMY_COST);\n        solverFlow.addEdge(dwTailRowPntIdx + PNT_NO_OFFSET_OUTPUT, \n                            PNT_NO_TARGET,\n                            MAX_DWORD, DUMMY_COST);\n    }\n    for (DWORD dwRowIdx = 1; dwRowIdx < dwInput_H - 1; dwRowIdx++) {\n        DWORD dwTopPntIdx  = dwInput_W * dwRowIdx;\n        DWORD dwTailPntIdx = dwInput_W * (dwRowIdx + 1) - 1;\n        solverFlow.addEdge(dwTopPntIdx + PNT_NO_OFFSET_OUTPUT, \n                            PNT_NO_TARGET, \n                            MAX_DWORD, DUMMY_COST);\n        solverFlow.addEdge(dwTailPntIdx + PNT_NO_OFFSET_OUTPUT, \n                            PNT_NO_TARGET, \n                            MAX_DWORD, DUMMY_COST);\n    }\n\n    QWORD qwMaxFlow = solverFlow.MaxFlow(PNT_NO_START, PNT_NO_TARGET);\n    if (MAX_DWORD <= qwMaxFlow) {\n        printf(\"-1\\n\");\n    } else {\n        printf(\"%lld\\n\", qwMaxFlow);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\nusing namespace std;\n\nclass Cell\n{\npublic:\n\tvoid SetEnd()\n\t{\n\t\tstate = S_END;\n\t}\n\tvoid SetGoat()\n\t{\n\t\tstate = S_GOAT;\n\t}\n\tbool IsEnd()\n\t{\n\t\treturn state == S_END;\n\t}\n\tbool IsGoat()\n\t{\n\t\treturn state == S_GOAT;\n\t}\n\tbool IsEmpty()\n\t{\n\t\treturn state == S_EMPTY;\n\t}\n\tbool HasFlow()\n\t{\n\t\treturn flowout != F_NONE;\n\t}\n\tstring ToChara()\n\t{\n\t\tstring retString;\n\t\tswitch (state)\n\t\t{\n\t\tcase S_EMPTY:\n\t\tcase S_END:\n\t\t\tswitch (flowout)\n\t\t\t{\n\t\t\tcase F_NONE:\n\t\t\t\tretString = '.';\n\t\t\t\tbreak;\n\t\t\tcase F_RIGHT:\n\t\t\t\tretString = \"→\";\n\t\t\t\tbreak;\n\t\t\tcase F_UP:\n\t\t\t\tretString = \"↑\";\n\t\t\t\tbreak;\n\t\t\tcase F_DOWN:\n\t\t\t\tretString = \"↓\";\n\t\t\t\tbreak;\n\t\t\tcase F_LEFT:\n\t\t\t\tretString = \"←\";\n\t\t\t\tbreak;\n\t\t\tcase F_END:\n\t\t\t\tretString = \"T\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase S_GOAT:\n\t\t\tretString = 'S';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tretString = '.';\n\t\t\tbreak;\n\t\t}\n\t\treturn retString;\n\t}\nprivate:\n\tenum State\n\t{\n\t\tS_EMPTY,\n\t\tS_GOAT,\n\t\tS_END\n\t};\n\tState state = S_EMPTY;\npublic:\n\tenum Flow\n\t{\n\t\tF_NONE,\n\t\tF_UP = 1,\n\t\tF_DOWN = -1,\n\t\tF_RIGHT = 2,\n\t\tF_LEFT = -2,\n\t\tF_END = 100\n\t};\n\tFlow flowout = F_NONE;\n\tFlow flowin = F_NONE;\n};\n\nclass Field\n{\npublic:\n\tField(int H, int W)\n\t{\n\t\tthis->H = H;\n\t\tthis->W = W;\n\t\tfor (int h : { 0, H - 1})\n\t\t{\n\t\t\tfor (int w = 0; w < W; ++w)\n\t\t\t{\n\t\t\t\tcell[h][w].SetEnd();\n\t\t\t}\n\t\t}\n\t\tfor (int w : { 0, W - 1})\n\t\t{\n\t\t\tfor (int h = 0; h < H; ++h)\n\t\t\t{\n\t\t\t\tcell[h][w].SetEnd();\n\t\t\t}\n\t\t}\n\t}\n\tvoid PutGoat(int h, int w)\n\t{\n\t\tif (cell[h][w].IsEnd())\n\t\t{\n\t\t\timpossible = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcell[h][w].SetGoat();\n\t\t\tgoat.emplace_back(h, w);\n\t\t}\n\t}\n\tvoid ShowFlow()\n\t{\n\t\tcout << flow << endl;\n\t\tfor (int h = 0; h < H; ++h)\n\t\t{\n\t\t\tfor (int w = 0; w < W; ++w)\n\t\t\t{\n\t\t\t\tcout << cell[h][w].ToChara();\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n\tbool UpdateFlow()\n\t{\n\t\tmap<pair<int, int>, pair<Cell::Flow, Cell::Flow>> paths;\n\t\tif (!FindPath(&paths))\n\t\t\treturn false;\n\t\tfor (auto location : paths)\n\t\t{\n\t\t\tint h = location.first.first;\n\t\t\tint w = location.first.second;\n\t\t\tCell::Flow flowin = location.second.first;\n\t\t\tCell::Flow flowout = location.second.second;\n\t\t\tcell[h][w].flowin = flowin;\n\t\t\tcell[h][w].flowout = flowout;\n\t\t}\n\t\tthis->flow += 1;\n\t\treturn true;\n\t}\n\tbool FindPath(map<pair<int, int>, pair<Cell::Flow, Cell::Flow>>* paths)\n\t{\n\t\tfor (auto start : goat)\n\t\t{\n\t\t\tpaths->clear();\n\t\t\tif (FindPathSub(start.first, start.second, paths, Cell::F_NONE, true)) return true;\n\t\t}\n\t\tpaths->clear();\n\t\treturn false;\n\t}\n\tbool FindPathSub(int h, int w,\n\t\tmap<pair<int, int>, pair<Cell::Flow, Cell::Flow>>* paths,\n\t\tCell::Flow comefrom,\n\t\tbool start = false, bool backward = false)\n\t{\n\t\tif (cell[h][w].IsEnd())\n\t\t{\n\t\t\tif (cell[h][w].HasFlow())\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpaths->insert(make_pair(make_pair(h, w), make_pair(comefrom, Cell::F_END)));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (!start && cell[h][w].IsGoat())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tpair<int, int> location(h, w);\n\t\tif (paths->find(location) != paths->end())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (cell[h][w].IsGoat())\n\t\t{\n\t\t\tpaths->insert(make_pair(location, make_pair(Cell::F_NONE, Cell::F_NONE)));\n\t\t\tif (FindPathSub(h + 1, w, paths, Cell::F_DOWN)) { (*paths)[location].second = Cell::F_DOWN; return true; }\n\t\t\tif (FindPathSub(h - 1, w, paths, Cell::F_UP))    { (*paths)[location].second = Cell::F_UP; return true; }\n\t\t\tif (FindPathSub(h, w + 1, paths, Cell::F_RIGHT)) { (*paths)[location].second = Cell::F_RIGHT; return true; }\n\t\t\tif (FindPathSub(h, w - 1, paths, Cell::F_LEFT))  { (*paths)[location].second = Cell::F_LEFT; return true; }\n\t\t\tpaths->erase(location);\n\t\t\treturn false;\n\t\t}\n\t\tif (!cell[h][w].IsEmpty())\n\t\t\treturn false;\n\t\tif (!backward)\n\t\t{\n\t\t\tif (cell[h][w].HasFlow())\n\t\t\t{\n\t\t\t\tpaths->insert(make_pair(location, make_pair(comefrom, cell[h][w].flowout)));\n\t\t\t\tswitch (cell[h][w].flowin)\n\t\t\t\t{\n\t\t\t\tcase Cell::F_DOWN:\n\t\t\t\t\tif (FindPathSub(h - 1, w, paths, Cell::F_NONE, false, true)) { return true; }\n\t\t\t\t\tbreak;\n\t\t\t\tcase Cell::F_UP:\n\t\t\t\t\tif (FindPathSub(h + 1, w, paths, Cell::F_NONE, false, true)) { return true; }\n\t\t\t\t\tbreak;\n\t\t\t\tcase Cell::F_RIGHT:\n\t\t\t\t\tif (FindPathSub(h, w - 1, paths, Cell::F_NONE, false, true)) { return true; }\n\t\t\t\t\tbreak;\n\t\t\t\tcase Cell::F_LEFT:\n\t\t\t\t\tif (FindPathSub(h, w + 1, paths, Cell::F_NONE, false, true)) { return true; }\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpaths->erase(location);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpaths->insert(make_pair(location, make_pair(comefrom, Cell::F_NONE)));\n\t\t\t\tif (FindPathSub(h + 1, w, paths, Cell::F_DOWN)) { (*paths)[location].second = Cell::F_DOWN; return true; }\n\t\t\t\tif (FindPathSub(h - 1, w, paths, Cell::F_UP))    { (*paths)[location].second = Cell::F_UP; return true; }\n\t\t\t\tif (FindPathSub(h, w + 1, paths, Cell::F_RIGHT)) { (*paths)[location].second = Cell::F_RIGHT; return true; }\n\t\t\t\tif (FindPathSub(h, w - 1, paths, Cell::F_LEFT))  { (*paths)[location].second = Cell::F_LEFT; return true; }\n\t\t\t\tpaths->erase(location);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (cell[h][w].HasFlow())\n\t\t\t{\n\t\t\t\tpaths->insert(make_pair(location, make_pair(Cell::F_NONE, Cell::F_NONE)));\n\t\t\t\tswitch (cell[h][w].flowin)\n\t\t\t\t{\n\t\t\t\tcase Cell::F_DOWN:\n\t\t\t\t\tif (FindPathSub(h - 1, w, paths, Cell::F_NONE, false, true)) { return true; }\n\t\t\t\t\tbreak;\n\t\t\t\tcase Cell::F_UP:\n\t\t\t\t\tif (FindPathSub(h + 1, w, paths, Cell::F_NONE, false, true)) { return true; }\n\t\t\t\t\tbreak;\n\t\t\t\tcase Cell::F_RIGHT:\n\t\t\t\t\tif (FindPathSub(h, w - 1, paths, Cell::F_NONE, false, true)) { return true; }\n\t\t\t\t\tbreak;\n\t\t\t\tcase Cell::F_LEFT:\n\t\t\t\t\tif (FindPathSub(h, w + 1, paths, Cell::F_NONE, false, true)) { return true; }\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpaths->erase(location);\n\t\t\t\tpaths->insert(make_pair(location, make_pair(cell[h][w].flowin, cell[h][w].flowout)));\n\t\t\t\tif (FindPathSub(h + 1, w, paths, Cell::F_DOWN)) { (*paths)[location].second = Cell::F_DOWN; return true; }\n\t\t\t\tif (FindPathSub(h - 1, w, paths, Cell::F_UP))    { (*paths)[location].second = Cell::F_UP; return true; }\n\t\t\t\tif (FindPathSub(h, w + 1, paths, Cell::F_RIGHT)) { (*paths)[location].second = Cell::F_RIGHT; return true; }\n\t\t\t\tif (FindPathSub(h, w - 1, paths, Cell::F_LEFT))  { (*paths)[location].second = Cell::F_LEFT; return true; }\n\t\t\t\tpaths->erase(location);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpaths->insert(make_pair(location, make_pair(cell[h][w].flowin, cell[h][w].flowout)));\n\t\t\t\tif (FindPathSub(h + 1, w, paths, Cell::F_DOWN)) { (*paths)[location].second = Cell::F_DOWN; return true; }\n\t\t\t\tif (FindPathSub(h - 1, w, paths, Cell::F_UP))    { (*paths)[location].second = Cell::F_UP; return true; }\n\t\t\t\tif (FindPathSub(h, w + 1, paths, Cell::F_RIGHT)) { (*paths)[location].second = Cell::F_RIGHT; return true; }\n\t\t\t\tif (FindPathSub(h, w - 1, paths, Cell::F_LEFT))  { (*paths)[location].second = Cell::F_LEFT; return true; }\n\t\t\t\tpaths->erase(location);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tint H, W;\n\tCell cell[100][100] = {};\n\tvector<pair<int, int>> goat;\n\tbool impossible = false;\n\tint flow = 0;\n};\n\nint main()\n{\n\tint H, W;\n\tcin >> H;\n\tcin >> W;\n\tField field(H, W);\n\tfor (int h = 0; h < H; ++h) {\n\t\tfor (int w = 0; w < W; ++w) {\n\t\t\tchar chara;\n\t\t\tcin >> chara;\n\t\t\tswitch (chara) {\n\t\t\tcase '.':\n\t\t\t\tbreak;\n\t\t\tcase 'X':\n\t\t\t\tfield.PutGoat(h, w);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (field.impossible)\n\t{\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\twhile (field.UpdateFlow())\n\t{\n\t\tfield.ShowFlow();\n\t}\n\tcout << field.flow << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 30000\n#define INF 1e7\nusing namespace std;\n\nstruct edge{ int to,cap,rev; };\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nint flow_dfs(int v, int t, int f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i=0;i<(int)G[v].size();i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = flow_dfs(e.to,t,min(f,e.cap));\n      if(d > 0){\n        e.cap-= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  if(s == t) return INF;\n  int flow = 0;\n  while(1){\n    memset(used,0,sizeof(used));\n    int f = flow_dfs(s,t,INF);\n    if(f == 0) break;\n    flow += f;\n    if(f == INF)break;\n  }\n  return flow;\n}\n\n\n\nint main(){\n  char mp[100][100];\n  int w,h;\n  cin>>h>>w;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin>>mp[i][j];\n    }\n  }\n\n  int s=2*h*w,t=s+1;\n  int nx[4] = {0,1,0,-1},ny[4] = {-1,0,1,0};\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(mp[i][j] == 'X'){\n        add_edge(s,i*w+j,INF);\n        add_edge( i*w+j , i*w+j+h*w , INF );\n      }\n      else add_edge( i*w+j , i*w+j+h*w , 1 );\n      for(int k=0;k<4;k++){\n        int ni=i+ny[k],nj=j+nx[k];\n        if(ni<0 || ni>=h || nj<0 || nj>=w) add_edge(i*w+j+w*h,t,INF);\n        else add_edge(i*w+j+w*h,ni*w+nj,INF);\n      }\n    }\n  }\n\n  int ans = max_flow(s,t);\n  if(ans == INF) cout<<-1<<endl;\n  else cout<<ans<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nconst int INF = 830252521;\ntypedef int flow_type;\n// Dinic http://www.prefield.com/algorithm/graph/dinic.html\nstruct dinic{\n  struct edge{int from,to;flow_type cost;int rev;};\n  int n;\n  vector< vector<edge> > G;\n  vector< vector<edge> > C;\n  // vector< vector<flow_type> > flow, capacity;\n// #define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n  vi level;\n  vector<bool> finished;\n  dinic(int _n){\n    n = _n;\n    G.assign(n,vector<edge>());\n    // flow.assign(n,vector<flow_type>(n,0));\n    // capacity.assign(n,vector<flow_type>(n,0));\n    level.assign(n,0);\n    finished.assign(n,false);\n  }\n  void add_edge(int from,int to,flow_type cost){\n    assert(0<=from && from<n);\n    assert(0<=to && to<n);\n    edge s = (edge){from,to,cost,(int)G[to].size()};\n    edge t = (edge){to,from,0,(int)G[from].size()};\n    G[from].push_back(s);\n    G[to].push_back(t);\n  }\n  flow_type dfs(int u, int t, flow_type cur){\n    if(u==t || cur==0) return cur;\n    if(finished[u]) return 0;\n    finished[u] = true;\n    REP(i,C[u].size()){\n      edge &e = C[u][i];\n      if(level[e.to] > level[u]){\n        flow_type f = dfs(e.to, t, min(cur, e.cost));\n        if(f>0){\n          e.cost -= f;\n          C[e.to][e.rev].cost += f;\n          finished[u] = false;\n          return f;\n        }\n      }\n    }\n    return 0;\n  }\n  flow_type calc(int s, int t){\n    C = G;\n    flow_type total = 0;\n    while(true){\n      REP(i,n)level[i] = -1;\n      level[s] = 0;\n      queue<int> Q; Q.push(s);\n      int d = n;\n      while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        REP(i,C[u].size()){\n          edge &e = C[u][i];\n          if(e.cost > 0 && level[e.to] == -1){\n            Q.push(e.to);\n            level[e.to] = level[u] + 1;\n          }\n        }\n      }\n      REP(i,n)finished[i]=false;\n      bool flag = false;\n      while(true){\n        flow_type f = dfs(s,t,INF);\n        if(f==0)break;\n        total += f;\n        flag = true;\n      }\n      if(!flag)break;\n    }\n    return total;\n  }\n};\n\nint h,w;\nchar mp[125][125];\nint dd[] = {1,0,-1,0,1};\n\nint main(){\n  scanf(\"%d%d\",&h,&w);\n  REP(i,h)scanf(\"%s\",mp[i]);\n  // flow\n  dinic g(2*h*w+2);\n  int s=2*h*w;\n  int t=2*h*w+1;\n  REP(i,h)REP(j,w){\n    int id = i*w + j;\n    int x=2*id,y=2*id+1;\n    if(mp[i][j]=='X'){\n      if(i==0||i==h-1||j==0||j==w-1){\n        puts(\"-1\");\n        return 0;\n      }\n      g.add_edge(s,x,INF);\n      g.add_edge(x,y,INF);\n    }else{\n      g.add_edge(x,y,1);\n    }\n    if(i==0||i==h-1||j==0||j==w-1){\n      g.add_edge(y,t,INF);\n    }\n    REP(d,4){\n      int ni=i+dd[d],nj=j+dd[d+1];\n      if(ni<0||ni>=h||nj<0||nj>=w)continue;\n      int nid = ni*w + nj;\n      g.add_edge(y,2*nid,INF);\n    }\n  }\n  printf(\"%d\\n\",g.calc(s,t));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//諸機能\n#pragma region MACRO \n#define putans(x)  std::cerr << \"answer: \" ; cout << (x) << endl\n#define dputans(x) std::cerr << \"answer: \"; cout << setprecision(13) << (double)(x) << endl\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define RREP(i,a,n) for(int i=(int)(n-1); i>= a; i--)\n#define rep(i,n) REP(i,0,n)\n#define rrep(i,n) RREP(i,0,n)\n#define all(a) begin((a)),end((a))\n#define mp make_pair\n#define exist(container, n) ((container).find((n)) != (container).end())\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#ifdef _DEBUG //ファイルからテストデータを読み込む\nstd::ifstream ifs(\"data.txt\");\n#define put ifs >>\n#else //ジャッジシステムでいい感じにやる\n#define put cin >>\n#endif\n#pragma endregion\n\n//デバッグなどの支援\n#pragma region CODING_SUPPORT\n#define dbg(var0) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << endl; }\n#define dbg2(var0, var1) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg(var1); }\n#define dbg3(var0, var1, var2) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg2(var1, var2); }\n#define dbgArray(a,n) {std::cerr << (#a) << \"=\";  rep(i,n){std::cerr <<(a[i])<<\",\";} cerr<<endl;} \n#ifndef _DEBUG\n#define dbg1 {}\n#define dbg2 {}\n#define dbg3 {}\n#define dbgArray {}\n#endif \n#pragma endregion \n//typedef（書き換える、書き足す可能性ある）\n#pragma region TYPE_DEF\ntypedef long long ll;\ntypedef pair<int, int> pii; typedef pair<string, string> pss; typedef pair<int, string>pis;\ntypedef vector<string> vs; typedef vector<int> vi;\n#pragma endregion\n//諸々の定数(書き換える可能性ある)\n#pragma region CONST_VAL\n#define PI (2*acos(0.0))\n#define EPS (1e-10)\n#define MOD (ll)(1e9 + 7)\n#define INF (ll)(1e9)\n#pragma endregion\n\nclass Point {//幾何上のべクトル\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(x * a, y * a); }\n\tdouble operator * (Point p) { return dot(p); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n\n\tbool operator < (const Point &p) const { return  x != p.x ? x < p.x : y < p.y; }\n\tbool operator == (const Point &p) const { return  fabs(x - p.x) < EPS && fabs(y - p.y) < EPS; }\n\t//内積、外積\n\tdouble dot(Point p) { return x * p.x + y * p.y; }\n\tdouble cross(Point p) { return x * p.y - y * p.x; }\n\n\n};\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\nstruct Segment {//線分\n\tPoint p1, p2;\n};\n\ntypedef Point Vector;\ntypedef Segment Line;//直線\ntypedef vector<Point> Polygon;\n\ndouble v_norm(Point p) { return p.x * p.x + p.y * p.y; }\ndouble abs(Point p) { return v_norm(p); }\ndouble dot(Point p, Point q) { return p.x * q.x + p.y * q.y; }\ndouble cross(Point p, Point q) { return p.x * q.y - p.y * q.x; }\n\n\n\n\n\n//直行、並行\nbool isOrthogonal(Vector a, Vector b) { return equals(a*b, 0.0); }\nbool isParallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\n\n//線分sに対する点pの射影\nPoint projection(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(( p - s.p1 ), base) / v_norm(base);\n\treturn s.p1 + base*r;\n}\n//線分sに対する点pの反射\nPoint reflection(Segment s, Point p) { return p + ( projection(s, p) - p ) * 2; }\n\n\n\n\n//double getDistance(Point a, Point b) { return ( a - b ).abs; }\n//double getDistanceLP(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1)); }\n//double getDistanceSP(Segment s, Point p) {\n//\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n//\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n//}\n\n//double getDistance(Segment s1, Segment s2) {\n//\tif (intersect(s1, s2)) return 0;\n//\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2))\n//\t         , min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2));\n//}\n\n//p1-p0を基準として p2-p0 の2ベクトルについて\nstatic const int COUNTER_CLOCKWISE = 1;//反時計回り\nstatic const int CLOCKWISE = -1;//時計回り\nstatic const int ONLINE_BACK = 2;//同一直線状p2,p0,p1の順\nstatic const int ONLINE_FRONT = -2;//同一直線上p0,p1,p2の順\nstatic const int ON_SEGMENT = 0;//p2がp0,p1上にある場合\nint ccw(Point p0, Point p1, Point p2) {//上記の分類関数\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n////線分p1p2とp3p4の交差判定\n//bool intersect(Point p1, Point p2, Point p3, Point p4) {return ( (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0) && (ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0));}\n//bool intersect(Segment s1, Segment s2) {return intersect(s1.p1 , s1.p1, s2.p1, s2.p2);}\n//\n//Point getCrossPoint(Segment s1, Segment s2) {\n//\tVector base = s2.p2 - s2.p1;\n//\tdouble d1 = abs(cross(base , s1.p1 - s2.p1));\n//\tdouble d2 = abs(cross(base , s1.p2 - s2.p1));\n//\tdouble t = d1 / ( d1 + d2 );\n//\treturn s1.p1 + (s1.p2 - s1.p1 ) * t;\n//}\n//\n////直線と円の交点を調べる\n//pair<Point, Point> getCrossPoints(Circle c, Line l) {\n//\t//assert(intersect(c, i)); 交差しない場合についてのはず\n//\tVector pr = projection(c, l);\n//\tVector e = ( l.p2 - l.p1 ) / abs(l.p2 - l.p1);\n//\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n//\treturn mp(pr + e * base, pr - e * base);\n//}\n//\n////点の内包を調べる\n//static const int IN_POLYGON = 2;//多角形の内部\n//static const int OUT_POLYGON = 1;//多角形の外部\n//static const int ON_POLYGON = 0;//多角形の線分上\n//int contains(Polygon g, Point p) {\n//\tint n = g.size();\n//\tbool x = false;\n//\trep(i, n) {\n//\t\tPoint a = g[i] - p, b = g[( i + 1 ) % n] - p;\n//\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return OUT_POLYGON;\n//\t\tif (a.y > b.y) swap(a, b);\n//\t\tif (a.y < EPS && EPS < b.y && cross(a, b)) x = !x;\n//\t}\n//\treturn ( x ? IN_POLYGON : ON_POLYGON );\n//}\n\n//凸包\nPolygon ConvexHull(Polygon s) {\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tsort(s.begin(), s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\n\tfor (int i = 2; i < s.size(); i++) {\n\t\tfor (int n = u.size(); ( n >= 2 ) && ( ccw(u[n - 2], u[n - 1], s[i]) !=CLOCKWISE ); n--) {\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\n\tfor (int i = s.size() - 3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE; n--)l.pop_back();\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\n/*\n#define i(x) int x; scanf(\"%d\",&x);\n#define l(x) ll x; scanf(\"%lld\",&x);\n#define d(x) double  x; scanf(\"%lf\",&x);\n*/\n//今度実装がんばる\n//https://www23.atwiki.jp/akitaicpc/pages/65.html\n\n\nint main() {\n\t/*double xp1, yp1, xp2, yp2; put xp1 >> yp1 >> xp2 >> yp2;\n\tSegment s;\n\ts.p1 = Point(xp1, yp1);\n\ts.p2 = Point(xp2, yp2);\n\n\tint n; put n;\n\trep(i, n) {\n\t\tPoint p;\n\t\tput p.x >> p.y;\n\t\tPoint prj =reflection(s, p);\n\t\tcout << setprecision(13) << prj.x << \" \" << prj.y << endl;\n\t}*/\n\n\n\n\t//テンプレート化を来世に考える\n\tauto getI = [&]()->auto { int tmp; put tmp; return tmp; };\n\tauto getLL = [&]()->auto { ll tmp; put tmp; return tmp; };\n\tauto getS = [&]()->auto { string tmp; put tmp; return tmp; };\n\tbool filled[1000][1000];\n\tfill(*filled, *filled + 1000 * 1000, false);\n\tint vx[4] = { 1,0,-1,0 };\n\tint vy[4] = { 0,1,0,-1 };\n\tPolygon sheep;\n\tPolygon convex_sheep;\n\tll num = 0;\n\tint h, w; put h >> w;\n\trep(i, h) {\n\t\tstring s; put s;\n\t\trep(j, s.size()) {\n\t\t\tif (s[j] == 'X') {\n\t\t\t\tif (i == 0 || j == 0 || i == h-1 || j == w-1) {\n\t\t\t\t\tputans(-1);\n\t\t\t\t\tgoto END;\n\t\t\t\t}\n\t\t\t\trep(k, 4) {\n\t\t\t\t\tif (!filled[i + vx[k]][j + vy[k]]) {\n\t\t\t\t\t\tsheep.push_back(Point(i + vx[k],j + vy[k]));\n\t\t\t\t\t\tfilled[i + vx[k]][j + vy[k]] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tconvex_sheep = ConvexHull(sheep);\n\n\trep(i, convex_sheep.size()) {\n\t\tPoint s = convex_sheep[i % convex_sheep.size()];\n\t\tPoint g = convex_sheep[(i + 1) % convex_sheep.size()];\n\t\tll mandist = max(abs(s.x - g.x),abs(s.y - g.y));\n\t\tdbg(mandist);\n\t\tnum += mandist;\n\t} \n\tputans(num);\nEND:\n\treturn 0;\n}\n\n//\n//int n, a, b; put n >> a >> b;\n//\tvi t;\n//\trep(i, n) {\n//\t\tt.push_back(get());\n//\t}\n//\tint count = 0;\n//\trep(i, n) {\n//\t\tif (t[i] < a || b <= t[i])count++;\n//\t}\n//\tputans(count);\n\n//\n//\tset<string> list;\n//\tint ans = 0;\n//\tint n; put n;\n//\tint k; put k;\n//\tint numAlphabet[26];\n//\tfill(all(numAlphabet), 0);\n//\trep(i, n) {\n//\t\tstring s; put s;\n//\t\tif (exist(list, s))continue;\n//\t\tlist.insert(s);\n//\t\tnumAlphabet[s[0] - 'A']++;\n//\t}\n//\tsort(all(numAlphabet),greater<int>());\n//\twhile (true) {\n//\t\trep(i, k) {\n//\t\t\tif (numAlphabet[i] == 0) goto END;\n//\t\t\telse numAlphabet[i]--;\n//\t\t}\n//\t\tsort(all(numAlphabet), greater<int>());\n//\t\tans++;\n//\t}\n//END:\n//\tputans(ans);\n\n\n\t//int t; put t;\n\t//rep(i, t) {\n\t//\tint n, d; put n >> d;\n\t//\tif (n == 1) {\n\t//\t\tputans(d);\n\t//\t\tcontinue;\n\t//\t}\n\t//\tputans(n % 2 != 0 ? ( n - 1 ) * 127 + d : ( n - 1 ) * 127 + ( 127 ^ d ));\n\t//}\n\n\n//\n//int n; put n;\n//string s1, s2;\n//string r;\n//string patan1[4] = { \".\",\"#\",\".\",\"#\" };\n//string patan2[4] = { \".\",\".\",\"#\",\"#\" };\n//bool front = true;\n//rep(j, 420 / 4) {\n//\tif (front) {\n//\t\trep(i, 4) {\n//\t\t\tcout << s1 + patan1[i] + \"\\n\" << s2 + patan2[i] << endl;\n//\t\t\tcin >> r;\n//\t\t\tif (r == \"T\") {\n//\t\t\t\ts1 += patan1[i];\n//\t\t\t\ts2 += patan2[i];\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t\tif (r == \"F\" && i == 3) {\n//\t\t\t\tfront = !front;\n//\t\t\t}\n//\t\t\tif (r == \"end\")goto END;\n//\t\t}\n//\t}\n//\telse {\n//\t\trep(i, 4) {\n//\t\t\tcout << patan1[i] + s1 + \"\\n\" << patan2[i] + s2 << endl;\n//\t\t\tcin >> r;\n//\t\t\tif (r == \"T\") {\n//\t\t\t\ts1 = patan1[i] + s1;\n//\t\t\t\ts2 = patan2[i] + s2;\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t\tif (r == \"F\" && i == 3) {\n//\t\t\t\tfront = !front;\n//\t\t\t}\n//\t\t\tif (r == \"end\")goto END;\n//\t\t}\n//\t}\n//\n//}\n//END:\n//cout << endl;\n\n\n////CGL_4_A : Convex Hull;\n\t//int n; put n;\n\t//Polygon p;\n\t//rep(i, n) {\n\t//\tdouble x, y; put x >> y;\n\t//\tp.push_back(Point(x, y));\n\t//}\n\t//Polygon k = ConvexHull(p);\n\t//double tmpMax = 100000000.0;\n\t//int rotIndex = 0;\n\t//rep(i, k.size()) {\n\t//\tif (k[i].y < tmpMax) {\n\t//\t\trotIndex = i;\n\t//\t\ttmpMax = k[i].y;\n\t//\t}\n\t//}\n\t//rotate(k.begin(),k.begin() + rotIndex,k.end());\n\t//cout << k.size() << endl;\n\t//rep(i, k.size()) {\n\t//\tcout << k[i].x << \" \" << k[i].y << endl;\n\t//}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define all(x) x.begin(),x.end()\n#define SZ(x) (int)(x.size())\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,a,b) for(int i=b-1;i>=a;i--)\n#define inf 1000000007\n#define mod 1000000007\n#define x first\n#define y second\n#define pi acos(-1.0)\n#define DBG(x) cerr<<(#x)<<\"=\"<<x<<\"\\n\";\n//#define dprintf(...) \n#define hash _hash\n#define next _next\n//#define dprintf(...) fprintf(outFile,__VA_ARGS__)\n \n#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define ull unsigned long long\n#define ll long long\n#define N 50010\n \ntemplate <class T,class U>inline void Max(T &a,U b){if(a<b)a=b;}\ntemplate <class T,class U>inline void Min(T &a,U b){if(a>b)a=b;}\n \n//FILE* outFile;\ninline void add(int &a,int b){a+=b;while(a>=mod)a-=mod;}\n\n\nint pow(int a,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=ans*(ll)a%mod;\n        a=(ll)a*a%mod;b>>=1;\n    }\n    return ans;\n}\n\nchar s[110][110];\nint vis[110][110],co[110][110],n,m;\nint dx[]={-1,0,1,0,-1,-1,1,1},dy[]={0,-1,0,1,-1,1,-1,1};\nvoid cal(int x1,int y1,int x2,int y2){\n\trep(i,y1+1,y2){\n\t\trep(j,x1+1,x2)if(s[j][i]=='X'){co[j-1][i]=1;break;}\n\t\tper(j,x1+1,x2)if(s[j][i]=='X'){co[j+1][i]=1;break;}\n\t}\n\trep(i,x1+1,x2){\n\t\trep(j,y1+1,y2)if(s[i][j]=='X'){co[i][j-1]=1;break;}\n\t\tper(j,y1+1,y2)if(s[i][j]=='X'){co[i][j+1]=1;break;}\n\t}\n}\nint main(){\n    int T,i,j,k,ca=0,K;\n    //cout<<setprecision(10)<<fixed;\n    scanf(\"%d%d\",&n,&m);\n    rep(i,0,n)scanf(\"%s\",s[i]);\n    rep(i,0,n){\n    \tif(s[i][0]=='X'||s[i][m-1]=='X'){puts(\"-1\");return 0;}\n    }\n    rep(i,0,m){\n    \tif(s[0][i]=='X'||s[n-1][i]=='X'){puts(\"-1\");return 0;}\n    }\n    int ans=0;\n    queue<pii>q;\n    rep(i,0,n)rep(j,0,m)if(s[i][j]=='X'&&!vis[i][j]){\n    \tq.push({i,j});vis[i][j]=1;\n    \tint x1=n,x2=0,y1=m,y2=0;\n    \twhile(!q.empty()){\n    \tint x=q.front().x,y=q.front().y;q.pop();\n    \tMin(x1,x),Max(x2,x);Min(y1,y),Max(y2,y);\n    \trep(k,0,8){\n    \t\tint nx=x+dx[k],ny=y+dy[k];\n    \t\tif(nx>=0&&nx<n&&ny>=0&&ny<m&&!vis[nx][ny]&&s[nx][ny]=='X'){\n    \t\t\tvis[nx][ny]=1;q.push({nx,ny});\n    \t\t}\n    \t}\n    \t}\n    \tcal(x1-1,y1-1,x2+1,y2+1);\n    }\n    memset(vis,0,sizeof(vis));\n    rep(i,0,n){\n    \tq.push({i,0}),vis[i][0]=1;\n    \tq.push({i,m-1}),vis[i][m-1]=1;\n    }\n    rep(i,0,m){\n    \tif(!vis[0][i])q.push({0,i}),vis[0][i]=1;\n    \tif(!vis[n-1][i])q.push({n-1,i}),vis[n-1][i]=1;\n    }\n    while(!q.empty()){\n    \tint x=q.front().x,y=q.front().y;q.pop();\n    \tif(co[x][y])continue;\n    \trep(k,0,4){\n    \t\tint nx=x+dx[k],ny=y+dy[k];\n    \t\tif(nx>=0&&nx<n&&ny>=0&&ny<m&&!vis[nx][ny]&&s[nx][ny]=='.'){\n    \t\t\tvis[nx][ny]=1;q.push({nx,ny});\n    \t\t}\n    \t}\n    }\n    rep(i,0,n)rep(j,0,m)ans+=(vis[i][j]&&co[i][j]);\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n//\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n//\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iomanip>\n \nusing namespace std;\n \ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<LD, LD> PLDLD;\ntypedef vector<int> VI;\ntypedef vector<char> VB;\n \n#define FOR(i,a,b) for(int i=(a);i<(int)(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define ALL(a) a.begin(),a.end()\n \nconst LD eps=1e-5;\n//const long long INF=(LL)(1e9)*(LL)(1e9);\nconst int INF=1e9;\n \ntemplate<class T>\nvoid chmin(T& a, const T& b)\n{\n\tif(a>b)\n\t\ta=b;\n}\ntemplate<class T>\nvoid chmax(T& a, const T& b)\n{\n\tif(a<b)\n\t\ta=b;\n}\n \nconst LL pow(const LL p, const LL q)\n{\n\tLL t=1;\n\tREP(i,q)\n\t\tt*=p;\n\treturn t;\n}\n\n//print for container\n/*\ntemplate<typename Iterator>\nvoid print(const Iterator& first, const Iterator& last)\n{\n\tauto&& back=prev(last);\n\tfor(auto e=first; e!=last; e=next(e))\n\t\tcout<<*e<<\" \\n\"[e==back];\n}*/\n\ntemplate<typename Head>\nvoid print(const Head& head)\n{\n\tcout<<head<<endl;\n}\n\ntemplate<typename Head, typename... Tail>\nvoid print(const Head& head, const Tail&... tail)\n{\n\tcout<<head<<\" \";\n\tprint(tail...);\n}\n\nvoid io_speedup()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n}\n\ntemplate<typename T>\nT read()\n{\n\tT t;\n\tcin>>t;\n\treturn t;\n}\n\n//set INF\nusing FLOW = long long;\nstruct Edge\n{\n    int to;\n    FLOW cap;\n    int rev;\n};\nclass FlowNetwork\n{\n    public:\n        FlowNetwork(int n):graph(vector<vector<Edge>>(n)),iter(vector<int>(n)),level(vector<int>(n))\n        {}\n        void add_Edge(int from, int to, FLOW cap);\n        FLOW dinic(int from, int to);\n\n    private:\n        vector<vector<Edge>> graph;\n        vector<int> iter, level;\n        FLOW dfs(int from, int to, FLOW cap);\n        void bfs(int from);\n};\nvoid FlowNetwork::add_Edge(int from, int to, FLOW cap)\n{\n    //cout<<from<<\":\"<<to<<\" \"<<cap<<endl;\n\tgraph[from].push_back((Edge){to,cap,(int)graph[to].size()});\n\tgraph[to].push_back((Edge){from,0,(int)graph[from].size()-1});\n}\n\nvoid FlowNetwork::bfs(int from)\n{\n    fill(level.begin(),level.end(),-1);\n    queue<int> que;\n    level[from]=0;\n    que.push(from);\n    while(!que.empty())\n    {\n        int v=que.front();\n        que.pop();\n        for(int i=0;i<graph[v].size();i++)\n        {\n            Edge &e=graph[v][i];\n            if(e.cap>0 && level[e.to]<0)\n            {\n                level[e.to] = level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nFLOW FlowNetwork::dfs(int from, int to, FLOW f)\n{\n\tif(from == to) return f;\n\tfor(int &i=iter[from];i<graph[from].size();i++)\n\t{\n\t\tEdge &e=graph[from][i];\n        if(e.cap > 0 && level[from] < level[e.to])\n        {\n            FLOW d = dfs(e.to, to, min(e.cap, f));\n            if(d>0)\n            {\n                e.cap -= d;\n                graph[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n\t}\n\treturn 0;\n}\nFLOW FlowNetwork::dinic(int from, int to)\n{\n    FLOW flow=0;\n\twhile(1)\n\t{\n        bfs(from);\n        if(level[to]<0) return flow;\n        fill(iter.begin(),iter.end(),0);\n        FLOW f;\n        while((f=dfs(from,to,INF))>0)\n        {\n            flow+=f;\n        }\n\t}\n}\n\nint dx[]={1,0,-1,0}, dy[]={0,1,0,-1};\nint main()\n{\n\tint h,w;\n\tcin>>h>>w;\n\tauto ptoi=[&](int x,int y)\n\t{\n\t\treturn x*h+y;\n\t};\n\tFlowNetwork flow(w*h*2+2);\n\tREP(j,h)\n\tREP(i,w)\n\t{\n\t\tREP(k,4)\n\t\t{\n\t\t\tint px=i+dx[k],py=j+dy[k];\n\t\t\tif(!(0<=px&&px<w&&0<=py&&py<h)) continue;\n\t\t\tflow.add_Edge(ptoi(i,j)+w*h,ptoi(px,py),INF);\n\t\t}\n\t}\n\tREP(j,h)\n\t{\n\t\tstring s=read<string>();\n\t\tREP(i,w)\n\t\t{\n\t\t\tif(s[i]=='.')\n\t\t\t{\n\t\t\t\tflow.add_Edge(ptoi(i,j),ptoi(i,j)+w*h,1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tflow.add_Edge(ptoi(i,j),ptoi(i,j)+w*h,INF);\n\t\t\t\tflow.add_Edge(ptoi(i,j)+w*h, w*h*2+1, INF);\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,w)\n\t{\n\t\tflow.add_Edge(w*h*2, ptoi(i,0), INF);\n\t\tflow.add_Edge(w*h*2, ptoi(i,h-1), INF);\n\t}\n\tREP(j,h)\n\t{\n\t\tflow.add_Edge(w*h*2, ptoi(0,j), INF);\n\t\tflow.add_Edge(w*h*2, ptoi(w-1,j), INF);\n\t}\n\tint ans=flow.dinic(w*h*2,w*h*2+1);\n\tif(ans==INF) ans=-1;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//諸機能\n#pragma region MACRO \n#define putans(x)  std::cerr << \"answer: \" ; cout << (x) << endl\n#define dputans(x) std::cerr << \"answer: \"; cout << setprecision(13) << (double)(x) << endl\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define RREP(i,a,n) for(int i=(int)(n-1); i>= a; i--)\n#define rep(i,n) REP(i,0,n)\n#define rrep(i,n) RREP(i,0,n)\n#define all(a) begin((a)),end((a))\n#define mp make_pair\n#define exist(container, n) ((container).find((n)) != (container).end())\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#ifdef _DEBUG //ファイルからテストデータを読み込む\nstd::ifstream ifs(\"data.txt\");\n#define put ifs >>\n#else //ジャッジシステムでいい感じにやる\n#define put cin >>\n#endif\n#pragma endregion\n\n//デバッグなどの支援\n#pragma region CODING_SUPPORT\n#define dbg(var0) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << endl; }\n#define dbg2(var0, var1) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg(var1); }\n#define dbg3(var0, var1, var2) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg2(var1, var2); }\n#define dbgArray(a,n) {std::cerr << (#a) << \"=\";  rep(i,n){std::cerr <<(a[i])<<\",\";} cerr<<endl;} \n#ifndef _DEBUG\n#define dbg1 {}\n#define dbg2 {}\n#define dbg3 {}\n#define dbgArray {}\n#endif \n#pragma endregion \n//typedef（書き換える、書き足す可能性ある）\n#pragma region TYPE_DEF\ntypedef long long ll;\ntypedef pair<int, int> pii; typedef pair<string, string> pss; typedef pair<int, string>pis;\ntypedef vector<string> vs; typedef vector<int> vi;\n#pragma endregion\n//諸々の定数(書き換える可能性ある)\n#pragma region CONST_VAL\n#define PI (2*acos(0.0))\n#define EPS (1e-9)\n#define MOD (ll)(1e9 + 7)\n#define INF (ll)(1e9)\n#pragma endregion\n\nclass Point {//幾何上のべクトル\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(x * a, y * a); }\n\tdouble operator * (Point p) { return dot(p); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n\n\tbool operator < (const Point &p) const { return  x != p.x ? x < p.x : y < p.y; }\n\tbool operator == (const Point &p) const { return  fabs(x - p.x) < EPS && fabs(y - p.y) < EPS; }\n\t//内積、外積\n\tdouble dot(Point p) { return x * p.x + y * p.y; }\n\tdouble cross(Point p) { return x * p.y - y * p.x; }\n\n\n};\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\nstruct Segment {//線分\n\tPoint p1, p2;\n};\n\ntypedef Point Vector;\ntypedef Segment Line;//直線\ntypedef vector<Point> Polygon;\n\ndouble v_norm(Point p) { return p.x * p.x + p.y * p.y; }\ndouble abs(Point p) { return v_norm(p); }\ndouble dot(Point p, Point q) { return p.x * q.x + p.y * q.y; }\ndouble cross(Point p, Point q) { return q.x * p.y - p.y * p.x; }\n\n\n\n\n\n//直行、並行\nbool isOrthogonal(Vector a, Vector b) { return equals(a*b, 0.0); }\nbool isParallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\n\n//線分sに対する点pの射影\nPoint projection(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(( p - s.p1 ), base) / v_norm(base);\n\treturn s.p1 + base*r;\n}\n//線分sに対する点pの反射\nPoint reflection(Segment s, Point p) { return p + ( projection(s, p) - p ) * 2; }\n\n\n\n\n//double getDistance(Point a, Point b) { return ( a - b ).abs; }\n//double getDistanceLP(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1)); }\n//double getDistanceSP(Segment s, Point p) {\n//\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n//\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n//}\n\n//double getDistance(Segment s1, Segment s2) {\n//\tif (intersect(s1, s2)) return 0;\n//\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2))\n//\t         , min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2));\n//}\n\n//p1-p0を基準として p2-p0 の2ベクトルについて\nstatic const int COUNTER_CLOCKWISE = 1;//反時計回り\nstatic const int CLOCKWISE = -1;//時計回り\nstatic const int ONLINE_BACK = 2;//同一直線状p2,p0,p1の順\nstatic const int ONLINE_FRONT = 1;//同一直線上p0,p1,p2の順\nstatic const int ON_SEGMENT = 0;//p2がp0,p1上にある場合\nint ccw(Point p0, Point p1, Point p2) {//上記の分類関数\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (v_norm(a) < v_norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n////線分p1p2とp3p4の交差判定\n//bool intersect(Point p1, Point p2, Point p3, Point p4) {return ( (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0) && (ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0));}\n//bool intersect(Segment s1, Segment s2) {return intersect(s1.p1 , s1.p1, s2.p1, s2.p2);}\n//\n//Point getCrossPoint(Segment s1, Segment s2) {\n//\tVector base = s2.p2 - s2.p1;\n//\tdouble d1 = abs(cross(base , s1.p1 - s2.p1));\n//\tdouble d2 = abs(cross(base , s1.p2 - s2.p1));\n//\tdouble t = d1 / ( d1 + d2 );\n//\treturn s1.p1 + (s1.p2 - s1.p1 ) * t;\n//}\n//\n////直線と円の交点を調べる\n//pair<Point, Point> getCrossPoints(Circle c, Line l) {\n//\t//assert(intersect(c, i)); 交差しない場合についてのはず\n//\tVector pr = projection(c, l);\n//\tVector e = ( l.p2 - l.p1 ) / abs(l.p2 - l.p1);\n//\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n//\treturn mp(pr + e * base, pr - e * base);\n//}\n//\n////点の内包を調べる\n//static const int IN_POLYGON = 2;//多角形の内部\n//static const int OUT_POLYGON = 1;//多角形の外部\n//static const int ON_POLYGON = 0;//多角形の線分上\n//int contains(Polygon g, Point p) {\n//\tint n = g.size();\n//\tbool x = false;\n//\trep(i, n) {\n//\t\tPoint a = g[i] - p, b = g[( i + 1 ) % n] - p;\n//\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return OUT_POLYGON;\n//\t\tif (a.y > b.y) swap(a, b);\n//\t\tif (a.y < EPS && EPS < b.y && cross(a, b)) x = !x;\n//\t}\n//\treturn ( x ? IN_POLYGON : ON_POLYGON );\n//}\n\n//凸包\nPolygon ConvexHull(Polygon s) {\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tsort(all(s));\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\n\tfor (int i = 2; i < s.size(); i++) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE; n--)u.pop_back();\n\t\tu.push_back(s[i]);\n\t}\n\n\tfor (int i = s.size()-3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE; n--)l.pop_back();\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(all(l));\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\n/*\n#define i(x) int x; scanf(\"%d\",&x);\n#define l(x) ll x; scanf(\"%lld\",&x);\n#define d(x) double  x; scanf(\"%lf\",&x);\n*/\n//今度実装がんばる\n//https://www23.atwiki.jp/akitaicpc/pages/65.html\n\n\nint main() {\n\t/*double xp1, yp1, xp2, yp2; put xp1 >> yp1 >> xp2 >> yp2;\n\tSegment s;\n\ts.p1 = Point(xp1, yp1);\n\ts.p2 = Point(xp2, yp2);\n\n\tint n; put n;\n\trep(i, n) {\n\t\tPoint p;\n\t\tput p.x >> p.y;\n\t\tPoint prj =reflection(s, p);\n\t\tcout << setprecision(13) << prj.x << \" \" << prj.y << endl;\n\t}*/\n\t//テンプレート化を来世に考える\n\tauto getI = [&]()->auto { int tmp; put tmp; return tmp; };\n\tauto getLL = [&]()->auto { ll tmp; put tmp; return tmp; };\n\tauto getS = [&]()->auto { string tmp; put tmp; return tmp; };\n\tbool filled[1000][1000];\n\tfill(*filled, *filled + 1000 * 1000, false);\n\tint vx[4] = { 1,0,-1,0 };\n\tint vy[4] = { 0,1,0,-1 };\n\tPolygon sheep;\n\tPolygon convex_sheep;\n\tint num = 0;\n\tint h, w; put h >> w;\n\trep(i, h) {\n\t\tstring s; put s;\n\t\trep(j, s.size()) {\n\t\t\tif (s[j] == 'X') {\n\t\t\t\tif (i == 0 || j == 0) {\n\t\t\t\t\tputans(-1);\n\t\t\t\t\tgoto END;\n\t\t\t\t}\n\t\t\t\trep(k, 4) {\n\t\t\t\t\tif (!filled[i + vx[k]][j + vy[k]]) {\n\t\t\t\t\t\tsheep.push_back(Point(i + vx[k],j + vy[k]));\n\t\t\t\t\t\tfilled[i + vx[k]][j + vy[k]] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tconvex_sheep = ConvexHull(sheep);\n\n\trep(i, convex_sheep.size()) {\n\t\tPoint s = convex_sheep[i % convex_sheep.size()];\n\t\tPoint g = convex_sheep[(i + 1) % convex_sheep.size()];\n\t\tint mandist = max(abs(s.x - g.x),abs(s.y - g.y));\n\t\t//max(1.0, abs(s.x - g.x)) + max(1.0, abs(s.y - g.y))\n\t\tnum += mandist;\n\t} \n\tputans(num);\nEND:\n\treturn 0;\n}\n\n//\n//int n, a, b; put n >> a >> b;\n//\tvi t;\n//\trep(i, n) {\n//\t\tt.push_back(get());\n//\t}\n//\tint count = 0;\n//\trep(i, n) {\n//\t\tif (t[i] < a || b <= t[i])count++;\n//\t}\n//\tputans(count);\n\n//\n//\tset<string> list;\n//\tint ans = 0;\n//\tint n; put n;\n//\tint k; put k;\n//\tint numAlphabet[26];\n//\tfill(all(numAlphabet), 0);\n//\trep(i, n) {\n//\t\tstring s; put s;\n//\t\tif (exist(list, s))continue;\n//\t\tlist.insert(s);\n//\t\tnumAlphabet[s[0] - 'A']++;\n//\t}\n//\tsort(all(numAlphabet),greater<int>());\n//\twhile (true) {\n//\t\trep(i, k) {\n//\t\t\tif (numAlphabet[i] == 0) goto END;\n//\t\t\telse numAlphabet[i]--;\n//\t\t}\n//\t\tsort(all(numAlphabet), greater<int>());\n//\t\tans++;\n//\t}\n//END:\n//\tputans(ans);\n\n\n\t//int t; put t;\n\t//rep(i, t) {\n\t//\tint n, d; put n >> d;\n\t//\tif (n == 1) {\n\t//\t\tputans(d);\n\t//\t\tcontinue;\n\t//\t}\n\t//\tputans(n % 2 != 0 ? ( n - 1 ) * 127 + d : ( n - 1 ) * 127 + ( 127 ^ d ));\n\t//}\n\n\n//\n//int n; put n;\n//string s1, s2;\n//string r;\n//string patan1[4] = { \".\",\"#\",\".\",\"#\" };\n//string patan2[4] = { \".\",\".\",\"#\",\"#\" };\n//bool front = true;\n//rep(j, 420 / 4) {\n//\tif (front) {\n//\t\trep(i, 4) {\n//\t\t\tcout << s1 + patan1[i] + \"\\n\" << s2 + patan2[i] << endl;\n//\t\t\tcin >> r;\n//\t\t\tif (r == \"T\") {\n//\t\t\t\ts1 += patan1[i];\n//\t\t\t\ts2 += patan2[i];\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t\tif (r == \"F\" && i == 3) {\n//\t\t\t\tfront = !front;\n//\t\t\t}\n//\t\t\tif (r == \"end\")goto END;\n//\t\t}\n//\t}\n//\telse {\n//\t\trep(i, 4) {\n//\t\t\tcout << patan1[i] + s1 + \"\\n\" << patan2[i] + s2 << endl;\n//\t\t\tcin >> r;\n//\t\t\tif (r == \"T\") {\n//\t\t\t\ts1 = patan1[i] + s1;\n//\t\t\t\ts2 = patan2[i] + s2;\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t\tif (r == \"F\" && i == 3) {\n//\t\t\t\tfront = !front;\n//\t\t\t}\n//\t\t\tif (r == \"end\")goto END;\n//\t\t}\n//\t}\n//\n//}\n//END:\n//cout << endl;"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n#define long long ll\n\nint n, m;\n\nbool inrange(int x, int y) {\n\treturn x >= 0 && x < n && y >= 0 && y < m;\n}\n\nint main() {\n\tint ans = 0, mask[4][2] = { {1, 0},{-1, 0},{0, 1},{0, -1} };\n\tcin >> n >> m;\n\tvector<string>v(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> v[i];\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (v[i][j] == 'X') {\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\tint nx = i + mask[k][0], ny = j + mask[k][1];\n\t\t\t\t\tif (!inrange(nx, ny))\n\t\t\t\t\t\treturn cout << -1, 0;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (v[nx][ny] == '.')\n\t\t\t\t\t\t\tv[nx][ny] = '#', ++ans;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (v[i][j] == '#') {\n\t\t\t\tbool ok = 1;\n\t\t\t\tfor (int k = 0; k < 4 && ok; ++k) {\n\t\t\t\t\tint nx = i + mask[k][0], ny = j + mask[k][1];\n\t\t\t\t\tif (!inrange(nx, ny) || v[nx][ny] == '.')\n\t\t\t\t\t\tok = 0;\n\t\t\t\t}\n\t\t\t\tif (ok)\n\t\t\t\t\t--ans;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <tuple>\n#include <set>\n#include <map>\n#include <complex>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\n\ntypedef tuple<ll, ll, ll, ll> T;\ntypedef pair<ll, ll> P;\n\nconst int INF = 1e6;\n\ntypedef int Weight;\ntypedef int Flow;\n\nstruct Edge {\n\tint src, dest, rev;\n\tFlow cap;\n\tWeight cost;\n\tbool operator < (const Edge &rhs) const {\n\t\treturn cost > rhs.cost;\n\t}\n\tEdge(int s, int d) : src(s), dest(d) { ; }\n\tEdge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n\tEdge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n//Veryfied AOJ 1163\ntypedef int Weight;\ntypedef int Flow;\n\nvoid add_edge(Graph &g, int src, int dest, Flow cap) {\n\tg[src].push_back(Edge(src, dest, (int)g[dest].size(), cap, 0));\n\tg[dest].push_back(Edge(dest, src, (int)g[src].size() - 1, 0, 0));\n}\n\nFlow dfs(Graph &g, vector<bool> &used, int v, int t, Flow f) {\n\tif (v == t) return f;\n\tused[v] = true;\n\tfor (Edge &e : g[v]) {\n\t\tif (!used[e.dest] && e.cap > 0) {\n\t\t\tFlow d = dfs(g, used, e.dest, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tg[e.dest][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nFlow ford_fulkerson(Graph &g, int s, int t) {\n\tFlow flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(g.size(), false);\n\t\tFlow f = dfs(g, used, s, t, INF);\n\t\tif (f == 0) return flow;\n\t\tflow += f;\n\t}\n}\nint main() {\n\tint H, W;\n\tcin >> H >> W;\n\tvector<string> area(H);\n\tfor (int i = 0;i < H;i++)\n\t\tcin >> area[i];\n\t// in h+H*w  out H*W+h+H*w \n\t// left:-H, right: +H, up: -1, down: 1\n\tconst int sink = H * W * 2;\n\tconst int tank = H * W * 2 + 1;\n\tGraph g(H * W * 2 + 2);\n\tint dx[] = {1,0,-1,0};\n\tint dy[] = {0,-1,0,1};\n\tfor (int y = 0;y < H;y++)\n\t\tfor (int x = 0;x < W;x++) {\n\t\t\tint in = y * H + x;\n\t\t\tint out = in + H * W;\n\t\t\tint cap;\n\t\t\tif (area[y][x] == '.')\n\t\t\t\tcap = 1;\n\t\t\telse {\n\t\t\t\tcap = INF;\n\t\t\t\tadd_edge(g,sink,in,INF);\n\t\t\t}\n\t\t\tadd_edge(g, in, out, cap); // in to out\n\n\t\t\tfor (int i = 0;i < 4;i++) {\n\t\t\t\tint tx = x + dx[i];\n\t\t\t\tint ty = y + dy[i];\n\t\t\t\tint toin = ty * H + tx;\n\t\t\t\tint toout = toin + H * W;\n\t\t\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H) {\n\t\t\t\t\tadd_edge(g,out,toin,INF);\n\t\t\t\t\tadd_edge(g, toout, in, INF);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tadd_edge(g, out, tank, INF);\n\t\t\t}\n\t\t}\n\tint ans = ford_fulkerson(g, sink, tank);\n\tif (ans >= INF)\n\t\tcout << -1 << endl;\n\telse\n\t\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL111\n\t#define _GLIBCXX_DEBUG\n#else\n\t#define NDEBUG\n#endif\n#include <bits/stdc++.h>\nconst int INF = 1e9;\nusing namespace std;\ntemplate<typename T, typename U> ostream& operator<< (ostream& os, const pair<T,U>& p) { cout << '(' << p.first << ' ' << p.second << ')'; return os; }\n\n#define endl '\\n'\n#define ALL(a)  (a).begin(),(a).end()\n#define SZ(a) int((a).size())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#ifdef LOCAL111\n\t#define DEBUG(x) cout<<#x<<\": \"<<(x)<<endl\n\ttemplate<typename T> void dpite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\n#else\n\t#define DEBUG(x) true\n\ttemplate<typename T> void dpite(T a, T b){ return; }\n#endif\n#define F first\n#define S second\n#define SNP string::npos\n#define WRC(hoge) cout << \"Case #\" << (hoge)+1 << \": \"\ntemplate<typename T> void pite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\ntemplate<typename T> bool chmax(T& a, T b){if(a < b){a = b; return true;} return false;}\ntemplate<typename T> bool chmin(T& a, T b){if(a > b){a = b; return true;} return false;}\n\ntypedef long long int LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> P;\ntypedef pair<LL,LL> LP;\n\n\n//library\ntypedef long long cost_t;\n\nclass Edge {\npublic:\n\tint to, from, rev;\n\tcost_t cost;\n\t\n\tEdge(){\n\t}\n\n\tEdge(int x,cost_t y){\n\t\tto = x;\n\t\tcost = y;\n\t}\n\n\tEdge(int x, int y, cost_t z){\n\t\tfrom = x;\n\t\tto = y;\n\t\tcost = z;\n\t}\n\n\tEdge(int x, int y, int r, cost_t z){\n\t\tfrom = x;\n\t\tto = y;\n\t\tcost = z;\n\t\trev = r;\n\t}\n\n\tbool operator< (const Edge& x) const {\n\t\tif(cost != x.cost) return cost < x.cost;\n\t\treturn to < x.to;\n\t}\n\n\tbool operator> (const Edge& x) const {\n\t\tif(cost != x.cost) return cost > x.cost;\n\t\treturn to > x.to;\n\t}\n};\n\nclass Graph {\nprivate:\n\t//const long long int INF = (long long)1e18;\n\tvector<vector<Edge> > v; \n\tint n;\npublic:\n\tGraph(int x){\n\t\tn = x;\n\t\tv = vector<vector<Edge> >(x);\n\t}\n\n\tGraph(){}\n\n\tvector<Edge>& operator[](int x){\n\t\treturn v[x];\n\t}\n\n\tconst vector<Edge>& operator[](int x) const {\n\t\treturn v[x];\n\t}\n\n\tint size() const {\n\t\treturn n;\n\t}\n\n\tvoid add_edge(int from, Edge e){\n\t\tv[from].push_back(e);\n\t}\n\n\tvoid add_edge(int from, int to, cost_t cost, int rev = -1){\n\t\tadd_edge(from,Edge(from,to,rev,cost));\n\t}\n\n\tvoid add_uedge(int from, int to, cost_t cost){\n\t\tadd_edge(from,to,cost);\n\t\tadd_edge(to,from,cost);\n\t}\n};\n\nvoid vizGraph(const Graph &g, bool with_dir = false, bool with_cap = false){\n\tofstream ofs(\"./out.dot\");\n\tif(with_dir) ofs << \"graph graph_name {\" << endl;\n\telse ofs << \"digraph graph_name {\" << endl;\n\tfor(int i = 0; i < (int)g.size(); i++){\n\t\tif (!g[i].size())\n\t\t\tcontinue;\n\t\tfor(const auto &e : g[i]){\n\t\t\tif(with_dir){\n\t\t\t\tif(e.to > i) ofs << \"    \\\"\" << i << \"\\\" -- \\\"\" << e.to << '\"'; \n\t\t\t}else ofs << \"    \\\"\" << i << \"\\\" -> \\\"\" << e.to << '\"'; \n\t\t\t\n\t\t\tif (with_cap) {\n\t\t\t\tofs << \" [ label = \\\"\" << (e.cost  == INF ? \"inf\" : to_string(e.cost)) << \"\\\"];\"; \n\t\t\t}\n\t\t\tif(!with_dir or e.to > i)ofs << endl;\n\t\t}\n\t}\n\tofs << \"}\" << endl;\n\tofs.close();\n\tsystem(\"dot -T png out.dot > sample.png\");\t\n}\n\n\ncost_t ffMaxFlow(const Graph &g_, int s, int t){\n\tGraph g = g_;\n\tint n = g.size();\n\tvector<int> rev(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < int(g[i].size()); j++) {\n\t\t\tauto&& e = g[i][j];\n\t\t\te.rev = g[e.to].size();\n\t\t\tg.add_edge(e.to,i,0,j);\n\t\t}\n\t}\n\n\tcost_t flow = 0;\n\twhile(true){\n\t\tvector<bool> used(n,false);\n\n\t\tfunction<cost_t(int,int,cost_t)> dfs = [&](int v, int t, cost_t f) -> cost_t{\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\tfor(auto&& e : g[v]) {\n\t\t\t\tif(!used[e.to] and e.cost > 0){\n\t\t\t\t\tcost_t d = dfs(e.to, t, min(f, e.cost));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cost -= d;\n\t\t\t\t\t\tg[e.to][e.rev].cost += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t};\n\n\t\tcost_t f = dfs(s,t,INF);\n\t\tif(f == 0) return flow;\n\t\tflow += f;\n\t}\n}\n\nvoid ios_init(){\n\t//cout.setf(ios::fixed);\n\t//cout.precision(12);\n#ifdef LOCAL111\n\treturn;\n#endif\n\tios::sync_with_stdio(false); cin.tie(0);\t\n}\n\nconst int dx[] = {1,-1,0,0};\nconst int dy[] = {0,0,1,-1};\n\nint main()\n{\n\tios_init();\n\tint h,w;\n\twhile(cin >> h >> w){\n\t\tvector<string> s(h);\n\t\tREP(i,h) cin >> s[i];\n\t\tGraph g(2*h*w+2);\n\t\tint so = h*w*2;\n\t\tint si = h*w*2+1;\n\t\t\n\t\tauto check = [&](int x, int y) -> bool{\n\t\t\treturn 0 <= x and x < h and 0 <= y and y < w;\n\t\t};\n\t\tauto mp = [&](int x, int y) -> int{\n\t\t\treturn w*x+y;\n\t\t};\n\n\t\tREP(i,h) REP(j,w){\n\t\t\tDEBUG(i); DEBUG(j);\n\t\t\tREP(k,4){\n\t\t\t\tint nx = i+dx[k];\n\t\t\t\tint ny = j+dy[k];\n\t\t\t\tDEBUG(mp(nx,ny));\n\t\t\t\tif(check(nx,ny)){\n\t\t\t\t\tg.add_edge(h*w+mp(i,j),mp(nx,ny),INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s[i][j] == 'X'){\n\t\t\t\tg.add_edge(mp(i,j),h*w+mp(i,j),INF);\n\t\t\t\tg.add_edge(so,mp(i,j),INF);\n\t\t\t}else {\n\t\t\t\tg.add_edge(mp(i,j), h*w+mp(i,j),1);\n\t\t\t}\n\t\t}\n\t\t// vizGraph(g,false,true);\n\t\tREP(i,h){\n\t\t\tg.add_edge(h*w+mp(i,w-1),si,INF);\n\t\t\tg.add_edge(h*w+mp(i,0),si,INF);\n\t\t}\n\t\tFOR(j,1,w-1){\n\t\t\tg.add_edge(h*w+mp(0,j),si,INF);\n\t\t\tg.add_edge(h*w+mp(h-1,j),si,INF);\n\t\t}\n\t\tint ans = ffMaxFlow(g,so,si);\n\t\tif(ans == INF){\n\t\t\tcout << -1 << endl;\n\t\t}else{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nint H, W;\nstring b[100];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\n\nvoid dfs(int x, int y) {\n\tif(b[y][x] != '.') return;\n\tb[y][x] = '@';\n\tfor(int k = 0; k < 4; k++) {\n\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\tif(0 <= nx && nx < W && 0 <= ny && ny < H) {\n\t\t\tif(b[ny][nx] == '#') b[ny][nx] = '$';\n\t\t\tif(b[ny][nx] == '.') dfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++) {\n\t\tcin >> b[i];\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\tif(b[i][0] == 'X' || b[i][W - 1] == 'X') {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = 0; i < W; i++) {\n\t\tif(b[0][i] == 'X' || b[H - 1][i] == 'X') {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(b[y][x] == 'X') {\n\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\tif(b[ny][nx] == '.') b[ny][nx] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\tdfs(0, i);\n\t\tdfs(W - 1, i);\n\t\tdfs(i, 0);\n\t\tdfs(i, H - 1);\n\t}\n\n\n\tint ans = 0;\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(b[y][x] == '$') ans++;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long int ll;\n\n#define rep(x, a, b) for (int x = a; x < b; x++)\n#ifdef DEBUG\n#define show(name) cout << #name \" = \" << name << endl\n#else\n#define show(name)\n#endif\n\nint pohe(const vector<vector<char>> &map, int c, int r, int dc, int dr)\n{\n  for (int i = 1;; i++) {\n    rep (j, 1, i) {\n      if (map[r + j * dr][c + (i - j) * dc] == 'X') {\n        return i - 1;\n      }\n    }\n  }\n\n  return 0;\n}\n\nint main()\n{\n  int h, w;\n  cin >> h >> w;\n\n  vector<vector<char>> map(h, vector<char>(w));\n\n  int topr = h, topc = w;\n  int botr = 0, botc = 0;\n\n  rep (r, 0, h) {\n    string str;\n\n    cin >> str;\n\n    rep (c, 0, w) {\n      if ((map[r][c] = str[c]) == 'X') {\n        topr = min(topr, r);\n        topc = min(topc, c);\n        botr = max(botr, r);\n        botc = max(botc, c);\n      }\n    }\n  }\n\n  topr--; topc--; botr++; botc++;\n\n  show(topr);\n  show(botr);\n  show(topc);\n  show(botc);\n    \n\n  if (topr < 0 || topc < 0 || botr >= h || botc >= w) {\n    cout << -1 << endl;\n  } else {\n    int count = 2 * (botr + botc - topr - topc)\n      - pohe(map, topc, topr, 1, 1)\n      - pohe(map, topc, botr, 1, -1)\n      - pohe(map, botc, topr, -1, 1)\n      - pohe(map, botc, botr, -1, -1);\n\n    cout << count << endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T> using Graph = vector<vector<T>>;\n\n#define REP(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (__typeof(a.begin()) x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define endl '\\n'\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint H, W;\nstring S[105];\nbool used[105][105];\n\nbool is_surrounded(int x, int y) {\n  if (x == 0 || x == W - 1 || y == 0 || y == H - 1) return false;\n  used[y][x] = true;\n  bool res = true;\n  rep(i, 4) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if (used[ny][nx]) continue;\n    if (S[ny][nx] == '.') {\n      res &= is_surrounded(nx, ny);\n      if (!res) break;\n    }\n  }\n  used[y][x] = false;\n  return res;\n}\n\nint solve() {\n  rep(i, W) if (S[0][i] == 'X' || S[H - 1][i] == 'X') return -1;\n  rep(i, H) if (S[i][0] == 'X' || S[i][W - 1] == 'X') return -1;\n\n  int ans = 0;\n  rep(y, H - 1) rep(x, W - 1) {\n    if (S[y][x] != 'X') continue;\n    rep(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (S[ny][nx] == '.') {\n        S[ny][nx] = '#';\n        ans += 1;\n      }\n    }\n  }\n\n  rep(loop, 300) {\n    REP(y, 1, H - 1) REP(x, 1, W - 1) {\n      if (S[y][x] == '#') {\n        int cnt = 0;\n        rep(i, 4) {\n          int nx = x + dx[i], ny = y + dy[i];\n          if (S[ny][nx] == 'X' || S[ny][nx] == '#') cnt++;\n        }\n        if (cnt == 3) rep(i, 4) {\n          int nx = x + dx[i], ny = y + dy[i];\n          if (S[ny][nx] == '.') {\n            S[ny][nx] = '#';\n            ans += 1;\n          }\n        }\n      }\n    }\n    REP(y, 1, H - 1) REP(x, 1, W - 1) {\n      if (S[y][x] == '.') {\n        int cnt = 0;\n        rep(i, 4) {\n          int nx = x + dx[i], ny = y + dy[i];\n          if (S[ny][nx] == 'X' || S[ny][nx] == '#') cnt++;\n        }\n        if (cnt == 4) {\n          S[y][x] = '#';\n          ans += 1;\n        }\n      }\n    }\n  }\n\n  REP(y, 1, H - 1) REP(x, 1, W - 1) {\n    if (S[y][x] == '#') {\n      int cnt = 0;\n      rep(i, 4) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (S[ny][nx] == 'X' || S[ny][nx] == '#' || S[ny][nx] == '-') cnt++;\n      }\n      if (cnt == 4) {\n        ans -= 1;\n        S[y][x] = '-';\n      }\n    }\n  }\n\n  REP(y, 1, H - 1) REP(x, 1, W - 1) {\n    if (S[y][x] == '#') {\n      if (is_surrounded(x, y)) {\n        ans -= 1;\n        S[y][x] = '-';\n      }\n    }\n  }\n\n  return ans;\n}\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> H >> W;\n  rep(i, H) cin >> S[i];\n\n  cout << solve() << endl;\n  //rep(i, H) cout << S[i] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\n#define INF (1 << 29)\nusing namespace std;\n\nstruct point{\n    int x, y;\n};\n\nchar f[105][105] = {0};\nbool fb[105][105] = {0};\nint h, w;\nstatic const int dy[4] = {0,1,0,-1};\nstatic const int dx[4] = {1,0,-1,0};\n\nbool CanEscape(){\n    rep(i,h) if(f[i][0] == 'X' || f[i][w - 1] == 'X') return 1;\n    rep(i,w) if(f[0][i] == 'X' || f[h - 1][i] == 'X') return 1;\n    return 0;\n}\n\nvoid check(queue<point> &q){\n    rep(i,h){\n        rep(j,w){\n            if(f[i][j] == 'X'){\n                point p;\n                p.y = i; p.x = j;\n                q.push(p);\n                rep(k,4){\n                    int y = i + dy[k];\n                    int x = j + dx[k];\n                    if(y < 0 || y >= h || x < 0 || x >= w) continue;\n                    if(f[y][x] != 'X') fb[y][x] = 1;\n                }\n            }\n        }\n    }\n}\n\nbool goatCanEscape(int y, int x){\n    bool isVisited[105][105] = {0};\n    queue<point> q;\n    point start_coordinate;\n    start_coordinate.x = x;\n    start_coordinate.y = y;\n\n    isVisited[start_coordinate.y][start_coordinate.x] = 1;\n    q.push(start_coordinate);\n\n    point u;\n    while(!q.empty()){\n        u = q.front(); q.pop();\n        rep(i,4){\n            point next;\n            next.x = u.x + dx[i];\n            next.y = u.y + dy[i];\n            if(next.y < 0 || next.y >= h || next.x < 0 || next.x >= w) return 1;\n            if(isVisited[next.y][next.x] == 0 && fb[next.y][next.x] == 0){\n                isVisited[next.y][next.x] = 1;\n                q.push(next);\n            }\n        }\n    }\n    return 0;\n}\n\nbool allGoatNotEscape(int y, int x, queue<point> q){\n    while(not q.empty()){\n        if(goatCanEscape(q.front().y, q.front().x)) return 0;\n        q.pop();\n    }\n    return 1;\n}\n\nvoid deleteUselessFence(queue<point> q){\n    int k = 5;\n    while(k--){\n        rep(i,h){\n            rep(j,w){\n                if(fb[i][j] == 1 && f[i][j] != 'X'){\n                    fb[i][j] = 0;\n                    if(not allGoatNotEscape(i, j, q)){\n                        fb[i][j] = 1;\n                    }\n                }\n            }\n        }\n    }\n}\n\nint oneSide(){\n    bool fence[105][105] = {0};\n    rep(i,h){\n        rep(j,w - 1){\n            if(f[i][j + 1] == 'X'){\n                fence[i][j] = 1;\n                break;\n            }\n        }\n    }\n    rep(i,h){\n        for(int j = w - 1; j > 0; j--){\n            if(f[i][j - 1] == 'X'){\n                fence[i][j] = 1;\n                break;\n            }\n        }\n    }\n    rep(i,w){\n        rep(j,h - 1){\n            if(f[j + 1][i] == 'X'){\n                fence[j][i] = 1;\n                break;\n            }\n        }\n    }\n    rep(i,w){\n        for(int j = h - 1; j > 0; j--){\n            if(f[j - 1][i] == 'X'){\n                fence[j][i] = 1;\n                break;\n            }\n        }\n    }\n    int cnt = 0;\n    rep(i,h){\n        rep(j,w){\n            if(fence[i][j] == 1) cnt++;\n        }\n    }\n    return cnt;\n}\n\nint countFence(){\n    int cnt = 0;\n    rep(i,h){\n        rep(j,w){\n            if(fb[i][j] == 1) cnt++;\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    cin >> h >> w;\n    rep(i,h) cin >> f[i];\n    if(CanEscape()){\n        cout << -1 << endl;\n    }else{\n        queue<point> q;\n        check(q);\n        //deleteUselessFence(q);\n        cout << oneSide() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int di[] = {0,0,-1,1};\nconst int dj[] = {-1,1,0,0};\nvoid paint(vector<string>& SS, int i, int j) {\n\tif (SS[i][j] == '$') SS[i][j] = '#';\n\tif (SS[i][j] == ' ' || SS[i][j] == '#') return;\n\tif (SS[i][j] == '.') SS[i][j] = ' ';\n\tfor (int k = 0; k < 4; ++ k) {\n\t\tint ii = i + di[k], jj = j + dj[k];\n\t\tif (0 <= ii && ii < SS.size() && 0 <= jj && jj < SS[0].length()) {\n\t\t\tpaint(SS, ii, jj);\n\t\t}\n\t}\n}\nint main() {\n\tint H, W;\n\tcin >> H >> W;\n\tvector<string> S(H);\n\tfor (auto& x : S) cin >> x;\n\tfor (int i = 0; i < H; ++ i) for (int j = 0; j < W; ++ j) if (S[i][j] == 'X') {\n\t\tif (i == 0 || i == H-1 || j == 0 || j == W-1) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tfor (int k = 0; k < 4; ++ k) {\n\t\t\tint ii = i + di[k], jj = j + dj[k];\n\t\t\tif (0 <= ii && ii < H && 0 <= jj && jj < W) {\n\t\t\t\tif (S[ii][jj] == '.') S[ii][jj] = '$';\n\t\t\t}\n\t\t}\n\t}\n\tvector<string> SS(H+2);\n\tSS[0] = SS[H+1] = string(W+2, '.');\n\tfor (int i = 0; i < H; ++ i) SS[i+1] = \".\" + S[i] + \".\";\n\tpaint(SS, 0, 0);\n\tint r = 0;\n\tfor (const auto& x : SS) for (char c : x) if (c == '#') ++ r;\n\tcout << r << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n     File Name: 1.cpp\n     ID: Liusiyu\n     BLOG: http://blog.csdn.net/r_o_j \n     LANG: C++ \n     Mail: 779532360@qq.com \n     Created Time: 2016年10月02日 星期日 14时09分42秒\n ************************************************************************/\n#include<bits/stdc++.h>\n#define MEM(a,x) memset(a,x,sizeof(a));\n#define MEMINF(a) memset(a,0x3f,sizeof(a));\nusing namespace std;\ntypedef long long LL;\nconst int MAXN=205;\nconst int INF=0x3f3f3f3f;\nconst int MOD=1000000007;\nint n,m;\nchar mp[MAXN][MAXN];\nstruct Node{\n  int x,y;\n};\nint cnt;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nqueue<Node>goat,q;\nbool vis[MAXN][MAXN];\nvoid goat_bfs() {\n  while (!goat.empty()) {\n    Node u=goat.front();\n    goat.pop();\n    vis[u.x][u.y]=true;\n    for (int i=0; i<4; ++i) {\n      Node v=u;\n      v.x+=dx[i];\n      v.y+=dy[i];\n      if (v.x<1||v.x>n||v.y<1||v.y>m) continue;\n      if (vis[v.x][v.y]==true) continue;\n      cnt++;\n      vis[v.x][v.y]=true;\n      q.push(v);\n    }\n  }\n}\nbool root_dfs(Node u,int dir){\n  while(true) {\n    u.x+=dx[dir];\n    u.y+=dy[dir];\n    if (vis[u.x][u.y]==true) return true;\n    else if (u.x<1||u.x>n||u.y<1||u.y>m) return false;\n  }\n}\n\n\nint main(){\n  cin>>n>>m;\n  Node node;\n  MEM(vis,false);\n  for (int i=1; i<=n; ++i){ \n     scanf(\"%s\",mp[i]+1);\n     for(int j=1; j<=n; ++j) {\n       if (mp[i][j]=='X') {\n         node.x=i;\n         node.y=j;\n         vis[i][j]=true;\n         goat.push(node);\n       }\n     }\n  }\n  for (int i=1; i<=m; ++i) {\n    if (mp[1][i]=='X'||mp[n][i]=='X') {\n      puts(\"-1\");\n      return 0;\n    }\n  }\n  for (int i=1; i<=n; ++i) {\n    if (mp[i][1]=='X'||mp[i][m]=='X') {\n      puts(\"-1\");\n      return 0;\n    }\n  }\n\n  goat_bfs();\n  while (!q.empty()) {\n    Node u=q.front();\n    q.pop();\n    int bian=0;\n    for (int i=0; i<4; ++i)\n    if (root_dfs(u,i)) bian++;\n    if (bian==4) cnt--;\n  }\n\n\n  printf(\"%d\\n\",cnt);\n}\n\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define min(a, b) ((a)>(b)?(b):(a))\n\nconst int inf = 1e5;\nconst int MAXN = 105;\n\nconst int sz = 2 * MAXN*MAXN;\n\nstruct MaxFlow {\n\tstruct Edge {\n\t\tint vertex;\n\t\tint inverse;\n\t\tint residual;\n\t\tEdge() {}\n\t\tEdge(int v, int i, int r) : vertex(v), inverse(i), residual(r) {}\n\t};\n\tint n;\n\tEdge g[sz][55]; int gn[sz];\n\tvoid init(int _n) {\n\t\tn = _n;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tgn[i] = 0;\n\t\t}\n\t}\n\tvoid add_edge(int s, int e, int cap) {\n\t\tEdge forward = Edge(e, gn[e], cap);\n\t\tEdge reverse = Edge(s, gn[s], 0);\n\t\tg[s][gn[s]++] = forward;\n\t\tg[e][gn[e]++] = reverse;\n\t}\n\tbool vis[sz];\n\tint Q[sz], fr, re, curf[sz], par[sz], paridx[sz];\n\tint bfs(int s, int e) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tvis[i] = 0;\n\t\t\tcurf[i] = 0;\n\t\t\tpar[i] = paridx[i] = 0;\n\t\t}\n\t\tQ[fr = re = 0] = s; vis[s] = 1;\n\t\tcurf[s] = inf;\n\t\twhile (fr <= re) {\n\t\t\tint x = Q[fr++];\n\t\t\tfor (int i = 0; i < gn[x]; i++) {\n\t\t\t\tint y = g[x][i].vertex;\n\t\t\t\tint f = g[x][i].residual;\n\t\t\t\tif (f > 0 && !vis[y]) {\n\t\t\t\t\tvis[y] = 1;\n\t\t\t\t\tpar[y] = x; paridx[y] = i;\n\t\t\t\t\tcurf[y] = min(curf[x], f);\n\t\t\t\t\tQ[++re] = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!vis[e]) return 0;\n\t\tint flow = curf[e];\n\t\tint p = e;\n\t\twhile (p != s) {\n\t\t\tint q = par[p], qi = paridx[p];\n\t\t\tint pi = g[q][qi].inverse;\n\t\t\tg[q][qi].residual -= flow;\n\t\t\tg[p][pi].residual += flow;\n\t\t\tp = q;\n\t\t}\n\t\treturn flow;\n\t}\n\tint solve(int s, int e) {\n\t\tint flow = 0, cur = 0;\n\t\twhile (cur = bfs(s, e), cur > 0) {\n\t\t\tflow += cur;\n\t\t}\n\t\treturn flow;\n\t}\n};\n\nint N, M;\nchar S[MAXN][MAXN];\nint in[MAXN][MAXN], out[MAXN][MAXN];\nint source, sink, v;\n\nint px[4] = { 1,-1,0,0 };\nint py[4] = { 0,0,1,-1 };\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int i = 1; i <= N; i++) {\n\t\tscanf(\"%s\", S[i] + 1);\n\t}\n\tsource = 0;\n\tsink = N * M * 2 + 1;\n\tv = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= M; j++) {\n\t\t\tin[i][j] = ++v;\n\t\t\tout[i][j] = ++v;\n\t\t}\n\t}\n\tMaxFlow f;\n\tf.init(2 * N*M + 2);\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= M; j++) {\n\t\t\tif (S[i][j] == 'X') {\n\t\t\t\tif (i == 1 || i == N || j == 1 || j == M) {\n\t\t\t\t\tf.add_edge(source, in[i][j], inf);\n\t\t\t\t}\n\t\t\t\tf.add_edge(in[i][j], out[i][j], inf);\n\t\t\t\tf.add_edge(out[i][j], sink, inf);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (i == 1 || i == N || j == 1 || j == M) {\n\t\t\t\t\tf.add_edge(source, in[i][j], 1);\n\t\t\t\t}\n\t\t\t\tf.add_edge(in[i][j], out[i][j], 1);\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint x = i + px[k];\n\t\t\t\t\tint y = j + py[k];\n\t\t\t\t\tif (1 <= x && x <= N && 1 <= y && y <= M) {\n\t\t\t\t\t\tf.add_edge(out[i][j], in[x][y], inf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint flow = f.solve(source, sink);\n\tif (flow >= inf) puts(\"-1\");\n\telse printf(\"%d\\n\", flow);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 111;\nchar g[maxn][maxn];\nint val[maxn][maxn], vis[maxn][maxn];\nint main(){\n\tint n, m; cin >> n >> m;\n\tfor(int i = 0; i < n; i++) for(int j = 0; j < m; j++) cin >> g[i][j];\n\tfor(int i = 0; i < n; i++) for(int j = 0; j < m; j++) if(g[i][j] == 'X'){\n\t\tif(i == 0 || i == n - 1 || j == 0 || j == m - 1){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tval[i - 1][j] = 1;\n\t\tval[i + 1][j] = 1;\n\t\tval[i][j - 1] = 1;\n\t\tval[i][j + 1] = 1;\n\t}\n\tqueue<pair<int,int> > q;\n\tfor(int i = 0; i < n; i++){\n\t\tvis[i][0] = 1;\n\t\tvis[i][m - 1] = 1;\n\t\tq.push({i, 0});\n\t\tq.push({i, m - 1});\n\t}\n\tfor(int i = 1; i < m - 1; i++){\n\t\tvis[0][i] = 1;\n\t\tvis[n - 1][i] = 1;\n\t\tq.push({0, i});\n\t\tq.push({n - 1, i});\n\t}\n\twhile(!q.empty()){\n\t\tint x, y; tie(x, y) = q.front(); q.pop();\n\t\tif(val[x][y]) continue;\n\t\tfor(int dx : {-1, 0, 1}){\n\t\t\tfor(int dy : {-1, 0, 1}){\n\t\t\t\tif(abs(dx) + abs(dy) == 1){\n\t\t\t\t\tint nx = x + dx, ny = y + dy;\n\t\t\t\t\tif(nx >= 0 && nx < n && ny >= 0 && ny < m && !vis[nx][ny]){\n\t\t\t\t\t\tvis[nx][ny] = 1;\n\t\t\t\t\t\tq.push({nx, ny});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i < n; i++) for(int j = 0; j < m; j++) if(vis[i][j] && val[i][j]) ans++;\n\tcout << min(ans, 2 * n + 2 * m - 8) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint H,W;\nstring S[202];\n\ntemplate<class V> class MaxFlow_Ford {\npublic:\n\tstruct edge { int to,reve;V cap;};\n\tstatic const int MV = 30000;\n\tvector<edge> E[MV];\n\tint vis[MV];\n\tvoid add_edge(int x,int y,V cap,bool undir=false) {\n\t\tE[x].push_back((edge){y,(int)E[y].size(),cap});\n\t\tE[y].push_back((edge){x,(int)E[x].size()-1,undir?cap:0});\n\t}\n\tV dfs(int from,int to,V cf) {\n\t\tV tf;\n\t\tif(from==to) return cf;\n\t\tvis[from]=1;\n\t\tFORR(e,E[from]) if(vis[e.to]==0 && e.cap>0 && (tf = dfs(e.to,to,min(cf,e.cap)))>0) {\n\t\t\te.cap -= tf;\n\t\t\tE[e.to][e.reve].cap += tf;\n\t\t\treturn tf;\n\t\t}\n\t\treturn 0;\n\t}\n\tV maxflow(int from, int to) {\n\t\tV fl=0,tf;\n\t\twhile(1) {\n\t\t\tZERO(vis);\n\t\t\tif((tf = dfs(from,to,numeric_limits<V>::max()))==0) return fl;\n\t\t\tfl+=tf;\n\t\t}\n\t}\n};\n\nMaxFlow_Ford<int> mf;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>H>>W;\n\tFOR(y,H) cin>>S[y];\n\tFOR(y,H) if(S[y][0]=='X' || S[y][W-1]=='X') return _P(\"-1\\n\");\n\tFOR(x,W) if(S[0][x]=='X' || S[H-1][x]=='X') return _P(\"-1\\n\");\n\t\n\tFOR(y,H) FOR(x,W) {\n\t\tmf.add_edge(y*100+x,10000+y*100+x,(S[y][x]=='X')?101010:1);\n\t\tif(S[y][x]=='X') mf.add_edge(20010,y*100+x,101010);\n\t\tif(y==0 || x==0 || y==H-1 || x==W-1) mf.add_edge(10000+y*100+x,20011,101010);\n\t\tif(y) mf.add_edge(10000+y*100+x,(y-1)*100+x,101010);\n\t\tif(x) mf.add_edge(10000+y*100+x,y*100+(x-1),101010);\n\t\tif(y<H-1) mf.add_edge(10000+y*100+x,(y+1)*100+x,101010);\n\t\tif(x<W-1) mf.add_edge(10000+y*100+x,y*100+(x+1),101010);\n\t}\n\tcout<<mf.maxflow(20010,20011)<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T> using Graph = vector<vector<T>>;\n\n#define REP(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (__typeof(a.begin()) x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define endl '\\n'\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint H, W;\nstring S[105];\nbool used[105][105];\n\nbool is_surrounded(int x, int y) {\n  if (x == 0 || x == W - 1 || y == 0 || y == H - 1) return false;\n  used[y][x] = true;\n  bool res = true;\n  rep(i, 4) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if (used[ny][nx]) continue;\n    if (S[ny][nx] == '.') {\n      res &= is_surrounded(nx, ny);\n      if (!res) break;\n    }\n  }\n  used[y][x] = false;\n  return res;\n}\n\nint solve() {\n  rep(i, W) if (S[0][i] == 'X' || S[H - 1][i] == 'X') return -1;\n  rep(i, H) if (S[i][0] == 'X' || S[i][W - 1] == 'X') return -1;\n\n  int ans = 0;\n  rep(y, H - 1) rep(x, W - 1) {\n    if (S[y][x] != 'X') continue;\n    rep(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (S[ny][nx] == '.') {\n        S[ny][nx] = '#';\n        ans += 1;\n      }\n    }\n  }\n\n  rep(loop, 100) {\n  REP(y, 1, H - 1) REP(x, 1, W - 1) {\n    if (S[y][x] == '#') {\n      int cnt = 0;\n      rep(i, 4) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (S[ny][nx] == 'X' || S[ny][nx] == '#') cnt++;\n      }\n      if (cnt == 3) rep(i, 4) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (S[ny][nx] == '.') {\n          S[ny][nx] = '#';\n          ans += 1;\n        }\n      }\n    }\n  }\n  }\n\n  REP(y, 1, H - 1) REP(x, 1, W - 1) {\n    if (S[y][x] == '#') {\n      int cnt = 0;\n      rep(i, 4) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (S[ny][nx] == 'X' || S[ny][nx] == '#' || S[ny][nx] == '-') cnt++;\n      }\n      if (cnt == 4) {\n        ans -= 1;\n        S[y][x] = '-';\n      }\n    }\n  }\n\n  REP(y, 1, H - 1) REP(x, 1, W - 1) {\n    if (S[y][x] == '#') {\n      if (is_surrounded(x, y)) {\n        ans -= 1;\n        S[y][x] = '-';\n      }\n    }\n  }\n\n  return ans;\n}\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> H >> W;\n  rep(i, H) cin >> S[i];\n\n  cout << solve() << endl;\n  //rep(i, H) cout << S[i] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip> // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple> // get<n>(xxx)\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set> // S.insert(M);\n// if (S.find(key) != S.end()) { }\n// for (auto it=S.begin(); it != S.end(); it++) { }\n// auto it = S.lower_bound(M);\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib> // atoi(xxx)\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\n// const int C ;\n// const int M = 1000000007;\n\nint H, W;\nstring S[110];\nbool F[110][110];\nbool need[110][110];\n\nbool valid(int x, int y) {\n  return (0 <= x && x < H && 0 <= y && y < W);\n}\n\nbool is_minus_one() {\n  for (auto i = 0; i < H; i++) {\n    if (S[i][0] == 'X' || S[i][W-1] == 'X') return true;\n  }\n  for (auto i = 0; i < W; i++) {\n    if (S[0][i] == 'X' || S[H-1][i] == 'X') return true;\n  }\n  return false;\n}\n\ntypedef tuple<int, int> point;\ntypedef tuple<int, int, point> state;\n\nstack<state> St;\nstack<point> SS;\nbool visited[110][110];\n\nvoid SS_stack() {\n  for (auto i = 0; i < H; i++) {\n    if (!F[i][0]) SS.push(make_tuple(i, 0));\n  }\n  for (auto i = 0; i < H; i++) {\n    if (!F[i][W-1]) SS.push(make_tuple(i, W-1));\n  }\n  for (auto i = 0; i < W; i++) {\n    if (!F[0][i]) SS.push(make_tuple(0, i));\n  }\n  for (auto i = 0; i < W; i++) {\n    if (!F[H-1][i]) SS.push(make_tuple(H-1, i));\n  }\n}\n\nint main () {\n  cin >> H >> W;\n  for (auto i = 0; i < H; i++) {\n    cin >> S[i];\n  }\n  if (is_minus_one()) {\n    cout << \"-1\" << endl;\n    return 0;\n  }\n  fill(&F[0][0], &F[0][0]+110*110, false);\n  for (auto i = 0; i < H; i++) {\n    for (auto j = 0; j < W; j++) {\n      if (S[i][j] == '.') continue;\n      for (auto k = 0; k < 4; k++) {        \n        int nx = i + dx[k];\n        int ny = j + dy[k];\n        if (valid(nx, ny) && S[nx][ny] == '.') {\n          F[nx][ny] = true;\n        }\n      }\n    }\n  }\n  /*\n  for (auto i = 0; i < H; i++) {\n    for (auto j = 0; j < W; j++) {\n      cerr << (F[i][j] ? '#' : '.');\n    }\n    cerr << endl;\n  }\n  */\n  SS_stack();\n  fill(&visited[110][110], &visited[110][110], false);\n  fill(&need[110][110], &need[110][110], false);\n  while (!SS.empty()) {\n    int x = get<0>(SS.top());\n    int y = get<1>(SS.top());\n    SS.pop();\n    if (!visited[x][y]) {\n      visited[x][y] = true;\n      for (auto k = 0; k < 4; k++) {\n        int nx = x + dx[k];\n        int ny = y + dy[k];\n        if (!valid(nx, ny)) {\n          //\n        } else if (visited[nx][ny]) {\n          // \n        } else if (!F[nx][ny]) {\n          SS.push(make_tuple(nx, ny));          \n        }\n      }\n    }\n  }\n  for (auto i = 0; i < H; i++) {\n    for (auto j = 0; j < W; j++) {\n      if (visited[i][j]) {\n        for (auto k = 0; k < 4; k++) {\n          int nx = i + dx[k];\n          int ny = j + dy[k];\n          if (valid(nx, ny) && F[nx][ny]) {\n            need[nx][ny] = true;\n          }\n        }\n      }\n    }\n  }\n  int ans = 0;\n  for (auto i = 0; i < H; i++) {\n    for (auto j = 0; j < W; j++) {\n      if (need[i][j]) ans++;\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mem(x,n) memset(x,n,sizeof(x))\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,l) for(auto it=(l).begin();it!=(l).end();it++)\n#define pnl printf(\"\\n\")\n#define len(x) (x).length()\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\nconst double EPS=1e-10;\n//const double PI=acos(-1.0);\nconst int INF=1<<30;\nconst LL LLINF=1ll<<60;\nconst int MOD=1e9+7;\nconst int xx[8]={1,0,-1,0,1,-1,1,-1};\nconst int yy[8]={0,1,0,-1,-1,1,1,-1};\n\n/****************************************************************************************\\\n  __    __               __ /\\/|   ___ _           _       /\\/|__               __    __\n  \\ \\  / /  _____ __ ____\\ \\/\\/   / __| |__ _ _ __(_)___  |/\\// /____ __ _____  \\ \\  / /\n   \\ \\| |  |___\\ V  V /___| |    | (__| / _` | '_ \\ / -_)    | |___\\ V  V /___|  | |/ /\n    \\_\\ |  |___|\\_/\\_/|___| |     \\___|_\\__,_| .__/_\\___|    | |___|\\_/\\_/|___|  | /_/\n       \\_\\               /_/                 |_|              \\_\\               /_/\n\\****************************************************************************************/\n\nstruct edge{\n\tint v, bf;\n\tLL flow;\n};\n\nconst int MAXN = 40010;\nvector<edge> adj[MAXN];\nint lvl[MAXN], st[MAXN];\nconst int sink = 40008, source = 40009;\nint idx[1005][1005],idx1[1005][1005];\nchar input[1005][1005];\n\nvoid addedge(int u,int v,LL flow){\n\tadj[u].pb({v,sz(adj[v]),flow});\n\tadj[v].pb({u,sz(adj[u]),0});\n}\n\nbool bfs(int S,int G){\n\tqueue<int> q;\n\tmem(lvl,-1);\n\tq.push(S); lvl[S]=0;\n\twhile(!q.empty()){\n\t\tint u = q.front(); q.pop();\n\t\tfor(int i=0;i<sz(adj[u]);i++){\n\t\t\tint v = adj[u][i].v;\n\t\t\tLL flow = adj[u][i].flow;\n\t\t\tif(lvl[v]!=-1||flow<=0) continue;\n\t\t\tlvl[v]=lvl[u]+1;\n\t\t\tq.push(v);\n\t\t}\n\t}\n\treturn (lvl[G]!=-1);\n}\n\nLL dfs(int u,LL mini,int G){\n\tif(u==G) return mini;\n\t\n\tfor(int i=st[u];i<sz(adj[u]);i++){\n\t\tst[u]=i;\n\t\tint v = adj[u][i].v;\n\t\tLL flow = adj[u][i].flow;\n\t\tif(flow<=0||(lvl[v]-lvl[u]!=1)) continue;\n\t\tLL ret=dfs(v,min(mini,flow),G);\n\t\tif(ret>0){\n\t\t\tadj[u][i].flow-=ret;\n\t\t\tint bvf = adj[u][i].bf;\n\t\t\tadj[v][bvf].flow+=ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nLL maxflow(int S,int G){\n\tLL ret=0;\n\tbool fl=false;\n\twhile(1){\n\t\tif(!bfs(S,G)) break;\n\t\tLL flow = 0;\n\t\tmem(st,0);\n\t\twhile((flow=dfs(S, LLINF, G))>0){\n\t\t\tret+=flow;\n\t\t\tfl=true;\n\t\t}\n\t}\n\tif(!fl) return LLINF;\n\treturn ret;\n}\n\nint main(){\n\tint r,c;\n\tscanf(\"%d%d\",&r,&c);\n\tgetchar();\n\tfor(int i=0;i<r;i++){\n\t\tscanf(\"%s\",input[i]);\n\t}\n\t\n\tint temp=0;\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tidx[i][j]=temp;\n\t\t\tidx1[i][j]=temp+20000;\n\t\t\ttemp++;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(input[i][j]=='.'){\n\t\t\t\taddedge(idx[i][j],idx1[i][j],1);\n\t\t\t\t\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\taddedge(idx1[i][j],sink,INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\taddedge(source,idx[i][j],INF);\n\t\t\t\taddedge(idx[i][j],idx1[i][j],INF);\n\t\t\t\t\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(i!=0) addedge(\tidx1[i][j], idx[i-1][j],INF);\n\t\t\tif(i!=r-1) addedge(\tidx1[i][j], idx[i+1][j],INF);\n\t\t\tif(j!=0) addedge(\tidx1[i][j], idx[i][j-1],INF);\n\t\t\tif(j!=c-1)addedge(\tidx1[i][j], idx[i][j+1],INF);\n\t\t}\n\t}\n\t\n\tLL ans = maxflow(source,sink);\n\tif(ans==LLINF) printf(\"-1\\n\");\n\telse printf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint ban1[105][105];\nint ban2[105][105];\nint H, W;\n\nbool valid(int y, int x){\n\treturn ( y>=0 && y < H) && (x>=0 && x < W);\n}\n\nint main(){\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++){\n\t\tstring S;\n\t\tcin >> S;\n\t\tfor(int j = 0; j < S.size(); j++){\n\t\t\tif(S[j] == '.'){\n\t\t\t\tban1[i][j] = 0;\n\t\t\t}else{\n\t\t\t\tban1[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tif(ban1[i][j] == 1){\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tif(valid(i + dy[k], j + dx[k]) == false){\n\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tban1[i + dy[k]][j + dx[k]] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tif(ban1[i][j] == 2){\n\t\t\t\tbool flag = false;\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tif(ban1[i + dy[k]][j + dx[k]] == 0){\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\tans++;\n\t\t\t\t\tban2[i][j] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tif(ban1[i][j] == 0){\n\t\t\t\tcout << '.';\n\t\t\t}else if(ban1[i][j] == 1){\n\t\t\t\tcout << 'X';\n\t\t\t}else{\n\t\t\t\tcout << '#';\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\t//cout << endl;\n\t}\n\tcout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <deque>\nusing namespace std;\n#define REP(i,a,n) for(int i = a; i < n; ++i)\n#define EPS 0.0001\n\nint H, W;\nchar M[101][101];\nbool checked[102][102];\n\nchar M_val(int i, int j) {\n\tif (i < 0 || i >= H) return '.';\n\tif (j < 0 || j >= W) return '.';\n\treturn M[i][j];\n}\nvoid M_assign(int i, int j, char val) {\n\tif (i < 0 || i >= H) return;\n\tif (j < 0 || j >= W) return;\n\tM[i][j] = val;\n\treturn;\n}\nconst int di[4] = { 1,0,-1,0 };\nconst int dj[4] = { 0,1,0,-1 };\n\nint cnt = 0;\nbool checked_val(int i, int j) {\n\tif (i < -1 || i > H) return true;\n\tif (j < -1 || j > W) return true;\n\treturn checked[i + 1][j + 1];\n}\nvoid checked_assign(int i, int j, bool val) {\n\tif (i < -1 || i > H) return;\n\tif (j < -1 || j > W) return;\n\tchecked[i + 1][j + 1] = val;\n\treturn;\n}\nvoid check_rec(int i, int j) {\n\tif (checked_val(i, j) == true) return;\n\tchecked_assign(i, j, true);\n\tif (M_val(i, j) == '#') {\n\t\t++cnt;\n\t\treturn;\n\t}\n\tREP(k, 0, 4) {\n\t\tcheck_rec(i + di[k], j + dj[k]);\n\t}\n\treturn;\n}\nint check() {\n\tcheck_rec(-1, -1);\n\treturn cnt;\n}\n\nint main() {\n\tcin >> H >> W;\n\tREP(i, 0, H) {\n\t\tstring buf;\n\t\tcin >> buf;\n\t\tREP(j, 0, W) {\n\t\t\tM[i][j] = buf[j];\n\t\t}\n\t}\n\n\tREP(i, 0, H) {\n\t\tREP(j, 0, W) {\n\t\t\tREP(k, 0, 4) {\n\t\t\t\tif (M[i][j] == 'X') {\n\t\t\t\t\tif (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (M_val(i + di[k], j + dj[k]) == 'X') {\n\t\t\t\t\t\tM[i][j] = '#';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << check() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\nstring board[110];\n\nbool outer[110][110];\n\n\n\nint main(void){\n\tint h,w;\n\tcin >> h >> w;\n\trep(i,h) cin >> board[i];\n\n\tbool escape=false;\n\trep(i,w) if(board[0][i]=='X' or board[h-1][i]=='X') escape=true;\n\trep(i,h) if(board[i][0]=='X' or board[i][w-1]=='X') escape=true;\n\n\tif(escape){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\n\trep(i,h)rep(j,w){\n\t\tif(board[i][j]=='X'){\n\t\t\trep(d,4) if(board[i+dy[d]][j+dx[d]]!='X') board[i+dy[d]][j+dx[d]]='O';\n\t\t}\n\t}\n\n\tqueue<int> q;\n\n\trep(i,w){\n\t\tq.push(0),q.push(i);\n\t\tq.push(h-1),q.push(i);\n\t\touter[0][i]=outer[h-1][i]=true;\n\t}\n\n\trep(i,h){\n\t\tq.push(i),q.push(0);\n\t\tq.push(i),q.push(w-1);\n\t\touter[i][0]=outer[i][w-1]=true;\n\t}\n\n\twhile(!q.empty()){\n\t\tint ci=q.front();q.pop();\n\t\tint cj=q.front();q.pop();\n\n\t\tif(board[ci][cj]=='O') continue;\n\n\t\trep(d,4){\n\t\t\tint ni=ci+dy[d],nj=cj+dx[d];\n\t\t\tif(ni<0 or h<=ni or nj<0 or w<=nj) continue;\n\t\t\tif(outer[ni][nj]) continue;\n\t\t\touter[ni][nj]=true;\n\t\t\tq.push(ni),q.push(nj);\n\t\t}\n\t}\n\n\t\n\tint ans=0;\n\trep(i,h)rep(j,w) ans+=(board[i][j]=='O' && outer[i][j]);\n\tcout << ans << endl;\n\n\t//rep(i,h) cout << board[i] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0, _n = (int)(n); i < _n; ++i)\nconst int N = (int) 2e5 + 5, mod = (int) 0, oo = 1e9 + 9;\nint n, m, mark[N], to[N], head[N], prev[N], cap[N], cnt = 0;\nstring mat[N];\nint f(int i, int j) { return i * m + j; }\nbool outer(int i, int j) {\n    return (i == 0 || j == 0 || i == n - 1 || j == m - 1);\n}\nvoid add_edge(int u, int v, int uv) {\n    to[cnt] = v, cap[cnt] = uv, prev[cnt] = head[u], head[u] = cnt++;\n    to[cnt] = u, cap[cnt] = +0, prev[cnt] = head[v], head[v] = cnt++;\n}\nint dfs(int v, int sink, int flow = oo) {\n    if (mark[v]++) return 0;\n    if (v == sink) return flow;\n    for (int e = head[v]; e != -1; e = prev[e]) {\n        int u = to[e];\n        if (cap[e]) {\n            int x = dfs(u, sink, min(flow, cap[e]));\n            if (x > 0) {\n                cap[e ^ 0] -= x;\n                cap[e ^ 1] += x;\n                return x;\n            }\n        }\n    }\n    return 0;\n}\nint max_flow(int source, int sink) {\n    int res = 0;\n    while (true) {\n        memset(mark, 0, sizeof mark);\n        int x = dfs(source, sink);\n        if (!x) break;\n        res += x;\n    }\n    return res;\n}\nint dx[] = {0, -1, 0, 1};\nint dy[] = {1, 0, -1, 0};\nint32_t main() {\n    memset(head, -1, sizeof head);\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n >> m;\n    for (int i = 0; i < n; ++i)\n        cin >> mat[i];\n    int sink = N - 1, source = N - 2;\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < m; ++j) {\n            for (int d = 0; d < 4; ++d) {\n                int x = i + dx[d], y = j + dy[d];\n                if (x >= 0 && y >= 0 && x < n && y < m) {\n                    add_edge(f(i, j) << 1 | 1, f(x, y) << 1, oo);\n                }\n            }\n            if (mat[i][j] == 'X')\n                add_edge(source, f(i, j) << 1, oo);\n            add_edge(f(i, j) << 1, f(i, j) << 1 | 1, 1 + oo * (mat[i][j] == 'X'));\n            if (outer(i, j)) {\n                if (mat[i][j] == 'X') {\n                    cout << -1 << endl;\n                    return 0;\n                }\n                add_edge(f(i, j) << 1 | 1, sink, oo);\n            }\n        }\n    cout << max_flow(source, sink) << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define all(x) x.begin(),x.end()\n#define SZ(x) (int)(x.size())\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,a,b) for(int i=b-1;i>=a;i--)\n#define inf 1000000007\n#define mod 1000000007\n#define x first\n#define y second\n#define pi acos(-1.0)\n#define DBG(x) cerr<<(#x)<<\"=\"<<x<<\"\\n\";\n//#define dprintf(...) \n#define hash _hash\n#define next _next\n//#define dprintf(...) fprintf(outFile,__VA_ARGS__)\n \n#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define ull unsigned long long\n#define ll long long\n#define N 50010\n \ntemplate <class T,class U>inline void Max(T &a,U b){if(a<b)a=b;}\ntemplate <class T,class U>inline void Min(T &a,U b){if(a>b)a=b;}\n \n//FILE* outFile;\ninline void add(int &a,int b){a+=b;while(a>=mod)a-=mod;}\n\n\nint pow(int a,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=ans*(ll)a%mod;\n        a=(ll)a*a%mod;b>>=1;\n    }\n    return ans;\n}\n\nchar s[110][110];\nint vis[110][110],is[110][110];\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nint main(){\n    int T,i,j,k,ca=0,m,n,K;\n    //cout<<setprecision(10)<<fixed;\n    scanf(\"%d%d\",&n,&m);\n    rep(i,0,n)scanf(\"%s\",s[i]);\n    queue<pii>q;\n    rep(i,0,n){\n    \tif(s[i][0]=='X'||s[i][m-1]=='X'){puts(\"-1\");return 0;}\n    \tq.push({i,0});vis[i][0]=1;\n    \tq.push({i,m-1});vis[i][m-1]=1;\n    }\n    rep(i,0,m){\n    \tif(s[0][i]=='X'||s[n-1][i]=='X'){puts(\"-1\");return 0;}\n    \tif(!vis[0][i])vis[0][i]=1,q.push({0,i});\n    \tif(!vis[n-1][i])vis[n-1][i]=1,q.push({n-1,i});\n    }\n    while(!q.empty()){\n    \tint x=q.front().x,y=q.front().y;q.pop();\n    \tis[x][y]=1;int ok=1,x1=-1,y1,cnt=0;\n    \trep(k,0,4){\n    \t\tint nx=x+dx[k],ny=y+dy[k];\n    \t\tif(nx>0&&nx<n-1&&ny>0&&ny<m-1){\n    \t\t\tif(s[nx][ny]=='X'){ok=0;break;}\n    \t\t\tif(!vis[nx][ny])x1=nx,y1=ny,cnt++;\n    \t\t}\n    \t}\n    \tif(ok){\n    \t\tis[x][y]=0;\n    \t\tif(x1!=-1){\n    \t\t\t//DBG(cnt)\n    \t\t\tvis[x1][y1]=1;\n    \t\t\tq.push({x1,y1});\n    \t\t}\n    \t}\n    }\n    int ans=0;\n    rep(i,0,n)rep(j,0,m)ans+=is[i][j];\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint INF = 1e8;\nstruct edge{ int to,cap,rev; };\nvector<edge> G[ 20005  ];\nbool used[ 20005 ];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0;i<(int)G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\nint max_flow(int s,int t){\n  int flow=0;\n  while(1){\n    memset(used,0,sizeof(used));\n    int f=dfs(s,t,INF);\n    if(f==0)break;\n    flow+=f;\n  }\n  return flow;\n}\n\n\nint H,W,si,ti;\nchar t[200][200];\nint di[4]={-1,0,1,0};\nint dj[4]={0,1,0,-1};\n\nint main(){\n  cin>>H>>W;\n  si=H*W*2;\n  ti=si+1;\n  \n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      \n      \n      cin>>t[i][j];\n      \n      if(i==0||j==0||i==H-1||j==W-1){\n        add_edge(i*W+j+H*W,ti,INF);\n      }\n      \n      if(t[i][j]=='X'){\n        add_edge(si,i*W+j,INF);\n        if(i==0||j==0||i==H-1||j==W-1){\n          cout<<-1<<endl;\n          return 0;\n        }\n        add_edge( i*W+j , i*W+j+H*W , INF );\n      }else{\n        add_edge( i*W+j , i*W+j+H*W , 1 );\n      }\n\n      for(int dir=0;dir<4;dir++){\n        int ni=i+di[dir];\n        int nj=j+dj[dir];\n        if(ni<0 || nj<0 || ni>=H || nj>=W)continue;\n        \n        add_edge(i*W+j+H*W,ni*W+nj,INF);\n      }\n    }\n  }\n\n  cout<< max_flow( si,ti) <<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T> using Graph = vector<vector<T>>;\n\n#define REP(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (__typeof(a.begin()) x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define endl '\\n'\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint H, W;\nstring S[105];\nbool used[105][105];\n\nint solve() {\n  rep(i, W) if (S[0][i] == 'X' || S[H - 1][i] == 'X') return -1;\n  rep(i, H) if (S[i][0] == 'X' || S[i][W - 1] == 'X') return -1;\n\n  int ans = 0;\n  rep(y, H - 1) rep(x, W - 1) {\n    if (S[y][x] != 'X') continue;\n    rep(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (S[ny][nx] == '.') {\n        S[ny][nx] = '#';\n        ans += 1;\n      }\n    }\n  }\n\n  REP(y, 1, H - 1) REP(x, 1, W - 1) {\n    if (S[y][x] == '#') {\n      int cnt = 0;\n      rep(i, 4) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (S[ny][nx] == 'X' || S[ny][nx] == '#') cnt++;\n      }\n      if (cnt == 3) rep(i, 4) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (S[ny][nx] == '.') {\n          S[ny][nx] = '#';\n          ans += 1;\n        }\n      }\n    }\n  }\n\n  REP(y, 1, H - 1) REP(x, 1, W - 1) {\n    if (S[y][x] == '#') {\n      int cnt = 0;\n      rep(i, 4) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (S[ny][nx] == 'X' || S[ny][nx] == '#' || S[ny][nx] == '*') cnt++;\n      }\n      if (cnt == 4) {\n        ans -= 1;\n        S[y][x] = '*';\n      }\n    }\n  }\n\n  return ans;\n}\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> H >> W;\n  rep(i, H) cin >> S[i];\n\n  cout << solve() << endl;\n  //rep(i, H) cout << S[i] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nint H, W;\nstring s[110];\n\nconst int MAX_V = 20100; //必要な頂点数\nstruct Flow{\n    struct edge{\n        int to, cap, rev;\n    };\n    vector<edge> G[MAX_V];//隣接リスト\n    bool used[MAX_V];\n \n    void add_edge(int from, int to, int cap){\n        G[from].push_back((edge){to, cap, (int)G[to].size()});//from -> to\n        G[to].push_back((edge){from, 0, (int)G[from].size() - 1});//to -> from\n    }\n    //増加パスを探す\n    int dfs(int v, int t, int f){\n        if(v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); ++i){\n            edge &e = G[v][i];\n            if(!used[e.to] && e.cap > 0){\n                int d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0){\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    //sからtへの最大流\n    int max_flow(int s, int t){\n        int flow = 0;\n        while(1){\n            memset(used, 0, sizeof(used));\n            int f = dfs(s, t, INF);\n            if(f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, 1, 0, -1};\n\nint main(void) {\n\tscanf(\"%d %d\", &H, &W);\n\trep(i, H) cin >> s[i];\n\tint start = 2 * (H * W) + 1, goal = 2 * (H * W) + 2;\n\tint N = H * W;\n\n\tbool flag = false;\n\trep(i, H)rep(j, W){\n\t\tif((i == 0 || i == H - 1 || j == 0 || j == W - 1) && s[i][j] == 'X')\n\t\t\tflag = true;\n\t}\n\tif(flag){\n\t\tprintf(\"-1\\n\"); return 0;\n\t}\n\n\tFlow fw;\n\trep(i, H)rep(j, W){\n\t\tint u = i * W + j;\n\t\tif(s[i][j] == 'X') {\n\t\t\tfw.add_edge(start, u, INF);\n\t\t\tfw.add_edge(u, u + N, INF);\n\t\t}else{\n\t\t\tfw.add_edge(u, u + N, 1);\n\t\t}\n\t\tif(i == 0 || i == H - 1 || j == 0 || j == W - 1){\n\t\t\tfw.add_edge(u + N, goal, INF);\n\t\t}\n\t}\n\trep(i, H)rep(j, W)rep(k, 4){\n\t\tint y = i, x = j;\n\t\tint ny = y + dy[k], nx = x + dx[k];\n\t\tif(!(0 <= ny && ny < H && 0 <= nx && nx < W)) continue;\n\t\tint u = y * W + x, v = ny * W + nx;\n\t\tfw.add_edge(N + u, v, INF);\n\t}\n\n\tint ret = fw.max_flow(start, goal);\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(v, a, b) for(int v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(int v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(int v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define LLI long long int\n#define fst first\n#define snd second\n\n#ifdef DEBUG\n#include <misc/C++/Debug.cpp>\n#else\n#define dump(x) ((void)0)\n#endif\n\n#define gcd __gcd\n\nusing namespace std;\ntemplate <class T> constexpr T lcm(T m, T n){return m/gcd(m,n)*n;}\n\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\ntemplate <typename T, typename U> istream& operator>>(istream &is, pair<T,U> &p){is >> p.first >> p.second; return is;}\n\ntemplate <typename T, typename U> T& chmin(T &a, const U &b){return a = (a<=b?a:b);}\ntemplate <typename T, typename U> T& chmax(T &a, const U &b){return a = (a>=b?a:b);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\n\ntemplate <typename T, T INF> class FordFulkerson{ \npublic:\n  struct edge{\n    int to, rev;\n    T cap;\n  };\n\n  int size;\n\n  vector<vector<edge>> graph;\n  vector<bool> visit;\n  \n  FordFulkerson(int size): size(size), graph(size), visit(size){}\n\n  void add_edge(int from, int to, const T &cap){\n    graph[from].push_back((edge){to, (int)graph[to].size(), cap});\n    graph[to].push_back((edge){from, (int)graph[from].size()-1, 0});\n  }\n\n  T dfs(int from, int to, T flow){\n    if(from == to) return flow;\n    visit[from] = true;\n\n    for(auto &e : graph[from]){\n      if(!visit[e.to] and e.cap > 0){\n\tint d = dfs(e.to, to, min(flow, e.cap));\n\tif(d > 0){\n\t  e.cap -= d;\n\t  graph[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  \n  T max_flow(int s, int t){\n    T ret = 0;\n\n    while(1){\n      visit.assign(size,false);\n      T flow = dfs(s,t,INF);\n      if(flow == 0) return ret;\n      ret += flow;\n    }\n  }\n};\n\n\n\nconst int dir4[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  const int inf = INT_MAX / 2;\n\n  int H,W;\n  while(cin >> H >> W){\n    vector<string> S(H); cin >> S;\n\n    FordFulkerson<int,inf> mf(H*W*2+2);\n    int s = H*W*2, t = s+1;\n    vector<vector<int>> in(H,vector<int>(W)), out(H,vector<int>(W));\n    REP(i,H) REP(j,W){\n      in[i][j] = i+j*H;\n      out[i][j] = in[i][j] + H*W;\n    }\n    \n    REP(i,H){\n      REP(j,W){\n\tif(i==0 or i==H-1 or j==0 or j==W-1) mf.add_edge(out[i][j], t, inf);\n\n\tif(S[i][j] == 'X'){\n\t  mf.add_edge(s, in[i][j], inf);\n\t  mf.add_edge(in[i][j], out[i][j], inf);\n\t}\n\telse mf.add_edge(in[i][j], out[i][j], 1);\n\n\tfor(auto &d : dir4){\n\t  int y = i+d[0], x = j+d[1];\n\t  if(x<0 or x>=W or y<0 or y>=H) continue;\n\t  mf.add_edge(out[i][j], in[y][x], inf);\n\t}\n      }\n    }\n\n    int ans = mf.max_flow(s,t);\n    \n    cout << (ans>=inf ? -1 : ans) << endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip> // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple> // get<n>(xxx)\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set> // S.insert(M);\n// if (S.find(key) != S.end()) { }\n// for (auto it=S.begin(); it != S.end(); it++) { }\n// auto it = S.lower_bound(M);\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib> // atoi(xxx)\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\n// const int C ;\n// const int M = 1000000007;\n\nint H, W;\nstring S[110];\nbool F[110][110];\nbool need[110][110];\n\nbool valid(int x, int y) {\n  return (0 <= x && x < H && 0 <= y && y < W);\n}\n\nbool is_minus_one() {\n  for (auto i = 0; i < H; i++) {\n    if (S[i][0] == 'X' || S[i][W-1] == 'X') return true;\n  }\n  for (auto i = 0; i < W; i++) {\n    if (S[0][i] == 'X' || S[H-1][i] == 'X') return true;\n  }\n  return false;\n}\n\ntypedef tuple<int, int> point;\ntypedef tuple<int, int, point> state;\n\nstack<state> St;\nstack<point> SS;\nbool visited[110][110];\n\nvoid SS_stack() {\n  for (auto i = 0; i < H; i++) {\n    if (!F[i][0]) SS.push(make_tuple(i, 0));\n  }\n  for (auto i = 0; i < H; i++) {\n    if (!F[i][W-1]) SS.push(make_tuple(i, W-1));\n  }\n  for (auto i = 0; i < W; i++) {\n    if (!F[0][i]) SS.push(make_tuple(0, i));\n  }\n  for (auto i = 0; i < W; i++) {\n    if (!F[H-1][i]) SS.push(make_tuple(H-1, i));\n  }\n}\n\nvoid hashi_need() {\n  for (auto i = 0; i < H; i++) {\n    if (F[i][0]) need[i][0] = true;\n  }\n  for (auto i = 0; i < H; i++) {\n    if (F[i][W-1]) need[i][W-1] = true;\n  }\n  for (auto i = 0; i < W; i++) {\n    if (F[0][i]) need[0][i] = true;\n  }\n  for (auto i = 0; i < W; i++) {\n    if (F[H-1][i]) need[H-1][i] = true;\n  }\n}\n\n\nint main () {\n  cin >> H >> W;\n  for (auto i = 0; i < H; i++) {\n    cin >> S[i];\n  }\n  if (is_minus_one()) {\n    cout << \"-1\" << endl;\n    return 0;\n  }\n  fill(&F[0][0], &F[0][0]+110*110, false);\n  for (auto i = 0; i < H; i++) {\n    for (auto j = 0; j < W; j++) {\n      if (S[i][j] == '.') continue;\n      for (auto k = 0; k < 4; k++) {        \n        int nx = i + dx[k];\n        int ny = j + dy[k];\n        if (valid(nx, ny) && S[nx][ny] == '.') {\n          F[nx][ny] = true;\n        }\n      }\n    }\n  }\n  /*\n  for (auto i = 0; i < H; i++) {\n    for (auto j = 0; j < W; j++) {\n      cerr << (F[i][j] ? '#' : '.');\n    }\n    cerr << endl;\n  }\n  */\n  SS_stack();\n  fill(&visited[110][110], &visited[110][110], false);\n  while (!SS.empty()) {\n    int x = get<0>(SS.top());\n    int y = get<1>(SS.top());\n    SS.pop();\n    if (!visited[x][y]) {\n      visited[x][y] = true;\n      for (auto k = 0; k < 4; k++) {\n        int nx = x + dx[k];\n        int ny = y + dy[k];\n        if (!valid(nx, ny)) {\n          //\n        } else if (visited[nx][ny]) {\n          // \n        } else if (!F[nx][ny]) {\n          SS.push(make_tuple(nx, ny));          \n        }\n      }\n    }\n  }\n  /*\n  for (auto i = 0; i < H; i++) {\n    for (auto j = 0; j < W; j++) {\n      cerr << (visited[i][j] ? 'V' : '.');\n    }\n    cerr << endl;\n  }\n  */\n  fill(&need[110][110], &need[110][110], false);\n  for (auto i = 0; i < H; i++) {\n    for (auto j = 0; j < W; j++) {\n      if (visited[i][j]) {\n        for (auto k = 0; k < 4; k++) {\n          int nx = i + dx[k];\n          int ny = j + dy[k];\n          if (valid(nx, ny) && F[nx][ny]) {\n            need[nx][ny] = true;\n          }\n        }\n      }\n    }\n  }\n  hashi_need();\n  /*\n  for (auto i = 0; i < H; i++) {\n    for (auto j = 0; j < W; j++) {\n      cerr << (need[i][j] ? 'N' : '.');\n    }\n    cerr << endl;\n  }\n  */\n  int ans = 0;\n  for (auto i = 0; i < H; i++) {\n    for (auto j = 0; j < W; j++) {\n      if (need[i][j]) ans++;\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nusing vs=vector<string>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\n\nstatic const int INF=1<<29;\nstatic const int di[]={-1, 0, 1, 0}, dj[]={0, -1, 0, 1};\nint main() {\n  size_t H, W;\n  scanf(\"%llu %llu\", &H, &W);\n\n  vs S(H);\n  for (size_t i=0; i<H; ++i) {\n    char buf[1<<7];\n    scanf(\"%s\", buf);\n    S[i] = buf;\n    if (S[i][0]=='X' || S[i][W-1]=='X')\n      return !printf(\"-1\\n\");\n  }\n\n  if (S[0].find('X') != string::npos)\n    return !printf(\"-1\\n\");\n\n  vs T(H, string(W, '.'));\n  for (size_t i=1; i<H-1; ++i)\n    for (size_t j=1; j<W-1; ++j) {\n      if (S[i][j] == 'X') {\n        for (size_t k=0; k<4; ++k) {\n          int I=i+di[k], J=j+dj[k];\n          T[I][J] = '#';\n        }\n      }\n    }\n\n  vvi dp(H, vi(W, INF));\n  dp[0][0]=dp[0][W-1]=dp[H-1][0]=dp[H-1][W-1]=0;\n  queue<pii> q;\n  q.push(pii(0, 0));\n  q.push(pii(0, W-1));\n  q.push(pii(H-1, 0));\n  q.push(pii(H-1, W-1));\n  while (!q.empty()) {\n    int i=q.front().first, j=q.front().second; q.pop();\n    for (size_t k=0; k<4; ++k) {\n      int I=i+di[k], J=j+dj[k];\n      if (!(0<=I && I<H && 0<=J && J<W)) continue;\n\n      if (dp[I][J] > dp[i][j] + (T[I][J]=='#')) {\n        dp[I][J] = dp[i][j] + (T[I][J]=='#');\n        q.push(pii(I, J));\n      }\n    }\n  }\n\n  int res=0;\n  for (size_t i=0; i<H; ++i)\n    for (size_t j=0; j<W; ++j)\n      if (dp[i][j]==1 && T[i][j]=='#') ++res;\n\n  printf(\"%d\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing vi = vector<int>; using vvi = vector<vi>; using vvvi = vector<vvi>;\nusing ll = long long int;\nusing vll = vector<ll>; using vvll = vector<vll>; using vvvll = vector<vvll>;\nusing vd = vector<double>; using vvd = vector<vd>; using vvvd = vector<vvd>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing cdouble = complex<double>;\n\nconst double eps = 1e-9;\nconst double INFD = numeric_limits<double>::infinity();\nconst double PI = 3.14159265358979323846;\n#define Loop(i, n) for(int i = 0; i < (int)(n); i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)(n); i++)\n#define Loopr(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)(n); i >= 1; i--)\n#define Foreach(buf, container) for(auto buf : container)\n#define Loopdiag(i, j, h, w, sum) for(int i = ((sum) >= (h) ? (h) - 1 : (sum)), j = (sum) - i; i >= 0 && j < (w); i--, j++)\n#define Loopdiagr(i, j, h, w, sum) for(int j = ((sum) >= (w) ? (w) - 1 : (sum)), i = (sum) - j; j >= 0 && i < (h); j--, i++)\n#define Loopdiagsym(i, j, h, w, gap) for (int i = ((gap) >= 0 ? (gap) : 0), j = i - (gap); i < (h) && j < (w); i++, j++)\n#define Loopdiagsymr(i, j, h, w, gap) for (int i = ((gap) > (h) - (w) - 1 ? (h) - 1 : (w) - 1 + (gap)), j = i - (gap); i >= 0 && j >= 0; i--, j--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(ex_i, vector.size()) { cout << vector[ex_i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(ex_i, matrix.size()) { Loop(ex_j, matrix[ex_i].size()) { cout << matrix[ex_i][ex_j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n#define Comp(type_t) bool operator<(const type_t &another) const\n#define fst first\n#define snd second\nbool nearlyeq(double x, double y) { return abs(x - y) < eps; }\nbool inrange(int x, int t) { return x >= 0 && x < t; }\nbool inrange(vi xs, int t) { Foreach(x, xs) if (!(x >= 0 && x < t)) return false; return true; }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (m * m <= x ? 0 : -1); }\nll ceilsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\nll lcm(ll m, ll n) { return m * n / gcd(m, n); }\n\n/*******************************************************/\n\ntypedef ll val_t;\n\nstruct graph_t {\n\tint n;           // |V|, index begins with 0\n\tint m;           // |E|\n\tvector<P> edges; // E\n\tvector<val_t> vals; // V\n\tvector<ll> costs; // cost or distance\n\tvector<ll> caps;  // capacity\n};\n\nclass Maxflow {\nprivate:\n\tstruct edge {\n\t\tint eid, from, to;\n\t\tll cap;\n\t};\n\tstruct node {\n\t\tint id; bool done; vector<int> to_eids;\n\t};\n\tint dual_eid(int eid) {\n\t\tif (eid < m) return eid + m;\n\t\telse return eid - m;\n\t}\n\tll dfs(int a, ll f) {\n\t\tif (a == sink) return f;\n\t\tnodes[a].done = true;\n\t\tForeach(eid, nodes[a].to_eids) {\n\t\t\tint b = edges[eid].to;\n\t\t\tif (!nodes[b].done && edges[eid].cap > 0) {\n\t\t\t\tll df = dfs(b, min(f, edges[eid].cap));\n\t\t\t\tif (df > 0) {\n\t\t\t\t\tedges[eid].cap -= df;\n\t\t\t\t\tedges[dual_eid(eid)].cap += df;\n\t\t\t\t\treturn df;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tvector<node> nodes;\n\tvector<edge> edges;\n\tint n, m;\n\tint source, sink;\npublic:\n\tMaxflow(graph_t G, int s, int t) {\n\t\tn = G.n;\n\t\tm = G.edges.size();\n\t\tnodes.resize(n);\n\t\tedges.resize(m * 2);\n\t\tLoop(i, n) nodes[i] = { i, false, {} };\n\t\tLoop(i, m) {\n\t\t\tint a = G.edges[i].first;\n\t\t\tint b = G.edges[i].second;\n\t\t\tnodes[a].to_eids.push_back(i);\n\t\t\tnodes[b].to_eids.push_back(i + m);\n\t\t\tedges[i] = { i, a, b, G.caps[i] };\n\t\t\tedges[i + m] = { i + m, b, a, 0 };\n\t\t}\n\t\tsource = s;\n\t\tsink = t;\n\t\tdo {\n\t\t\tLoop(i, n) nodes[i].done = false;\n\t\t} while (dfs(source, LLONG_MAX));\n\t\treturn;\n\t}\n\tvll get_eid_flow() {\n\t\tvll ret(m);\n\t\tLoop(i, m) {\n\t\t\tret[i] = edges[i + m].cap;\n\t\t}\n\t\treturn ret;\n\t}\n\tll get_maxflow() {\n\t\tll ret = 0;\n\t\tForeach(eid, nodes[sink].to_eids) {\n\t\t\tif (eid >= m) ret += edges[eid].cap;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nvoid failed() {\n\tcout << -1 << endl;\n\texit(0);\n}\n\nint main() {\n\tint n, m; cin >> n >> m;\n\tvector<string> board(n);\n\tLoop(i, n) cin >> board[i];\n\tvi di = { -1,1,0,0 };\n\tvi dj = { 0,0,-1,1 };\n\tgraph_t G;\n\tG.n = n * m * 2 + 2;\n\tint ofst0 = 0;\n\tint ofst1 = 1;\n\tint ofst2 = 1 + n * m;\n\tint ofst3 = 1 + n * m * 2;\n\tLoop(i, n) {\n\t\tLoop(j, m) {\n\t\t\tif (board[i][j] == 'X') {\n\t\t\t\tG.edges.push_back({ ofst0, ofst1 + i * m + j });\n\t\t\t\tG.caps.push_back(INT_MAX);\n\t\t\t\tG.edges.push_back({ ofst1 + i * m + j, ofst2 + i * m + j });\n\t\t\t\tG.caps.push_back(INT_MAX);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tG.edges.push_back({ ofst1 + i * m + j, ofst2 + i * m + j });\n\t\t\t\tG.caps.push_back(1);\n\t\t\t}\n\t\t\tLoop(k, 4) {\n\t\t\t\tint pi = i + di[k];\n\t\t\t\tint pj = j + dj[k];\n\t\t\t\tif (inrange(pi, n) && inrange(pj, m)) {\n\t\t\t\t\tG.edges.push_back({ ofst2 + i * m + j, ofst1 + pi * m + pj });\n\t\t\t\t\tG.caps.push_back(1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (board[i][j] == 'X') failed();\n\t\t\t\t\tG.edges.push_back({ ofst2 + i * m + j, ofst3 });\n\t\t\t\t\tG.caps.push_back(INT_MAX);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tMaxflow mf(G, 0, ofst3);\n\tcout << mf.get_maxflow() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "    #pragma GCC optimize(\"Ofast\")\n     \n    #include <bits/stdc++.h>\n    #include <ext/pb_ds/tree_policy.hpp>\n    #include <ext/pb_ds/assoc_container.hpp>\n    #include <random>\n     \n    using namespace std;\n    using namespace __gnu_pbds;\n     \n    typedef long long ll;\n     \n    typedef\n    tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> orderedSet;\n     \n    #define pb push_back\n    #define F first\n    #define S second\n    #define all(a) (a).begin(), (a).end()\n     \n    #define for1(i0, l0, r0) for (int i0 = l0; i0 < r0; ++i0)\n    #define for2(i0, l0, r0) for (int i0 = l0; i0 <= r0; ++i0)\n    #define forn(i0, n0) for (int i0 = 0; i0 < n0; ++i0)\n    #define forn1(i0, n0) for (int i0 = 1; i0 < n0; ++i0)\n    #define forr(i0, n0) for (int i0 = n0; i0 >= 0; --i0)\n    #define forr1(i0, r0, l0) for (int i0 = r0; i0 > l0; --i0)\n    #define forr2(i0, r0, l0) for (int i0 = r0; i0 >= l0; --i0)\n     \n    #define Sort(a) sort(all(a))\n    #define Reverse(a) reverse(all(a))\n     \n    typedef long double ld;\n    #define ui unsigned int\n    #define ull unsigned long long\n     \n    typedef pair<int, int> pii;\n    typedef pair<ll, ll> pll;\n    typedef pair<double, double> pdd;\n    typedef pair<string, string> pss;\n     \n    typedef vector<int> vi;\n    typedef vector<ll> vll;\n    typedef vector<double> vd;\n    typedef vector<ld> vld;\n    typedef vector<bool> vb;\n    typedef vector<string> vs;\n     \n    typedef vector<pii> vpii;\n    typedef vector<pll> vpll;\n    typedef vector<pdd> vpdd;\n     \n    typedef vector<vi> vvi;\n    typedef vector<vd> vvd;\n    typedef vector<vll> vvll;\n    typedef vector<vb> vvb;\n     \n    #define vpss vector<pss>\n    #define vvs vector<vs>\n    #define vvpii vector<vpii>\n    #define vvpll vector<vpll>\n    #define vpt vector<pt>\n    #define vvvi vector<vvi>\n    #define vsi vector<set<int>>\n    #define ss second\n    #define ff first\n     \n    #define printvi(arr) for (int x0 : arr) cout << x0 << ' '; cout << '\\n';\n    #define printvll(arr) for (ll x0 : arr) cout << x0 << ' '; cout << '\\n';\n    #define printpair(pair0) cout << pair0.F << ' ' << pair0.S << '\\n';\n    #define printvp(arr) for (auto pair0 : arr) printpair(pair0);\n    #define initArray(arr, N0, X0) memset(arr, X0, N0 * sizeof(int))\n    //mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n     \n    void init() {\n        ios_base::sync_with_stdio(0);\n        cin.tie(0);\n        cout.tie(0);\n        //cout.precision(16);\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n    }\n     \n    const int inf = 1e9;\n     \n    int mincut(int n, vvi e, int I, int J){\n        int m = e.size();\n        vvi c(n, vi(n));\n        vvi f(n, vi(n));\n        vvi g(n);\n        forn(i, m){\n            int v, u, c0;\n            v = e[i][0], u = e[i][1], c0 = e[i][2];\n            c[v][u] += c0;\n            //c[u][v] += c0;\n            g[v].pb(u);\n            //g[u].pb(v);\n        }\n        int ans = 0;\n        while(true){\n            queue<int> q;\n            q.push(I);\n            vi p(n, -1);\n            p[I] = -2;\n            while(!q.empty()){\n                int v = q.front();\n                q.pop();\n                for (int i: g[v]){\n                    if (c[v][i] > f[v][i] && p[i] == -1){\n                        p[i] = v;\n                        q.push(i);\n                    }\n                }\n            }\n            if (p[J] == -1) break;\n            vi path;\n            int minimum = 2e9;\n            int idx = J;\n            path.pb(idx);\n            while(idx != I){\n                minimum = min(minimum, c[p[idx]][idx] - f[p[idx]][idx]);\n                idx = p[idx];\n                path.pb(idx);\n            }\n            ans += minimum;\n            Reverse(path);\n            forn1(i, path.size()){\n                f[path[i]][path[i - 1]] -= minimum;\n                f[path[i - 1]][path[i]] += minimum;\n            }\n        }\n        return ans;\n    }\n     \n    void solve() {\n        int n, m;\n        cin >> n >> m;\n        vs a(n);\n        forn(i, n) cin >> a[i];\n        forn(i, n) {\n             forn(j, m){\n                 if (i == 0 || j == 0 || i == n - 1 || j == m - 1){\n                     if (a[i][j] == 'X'){\n                         cout << \"-1\\n\";\n                         return;\n                     }\n                 }\n             }\n        }\n        int N = n * m;\n        int I = 2 * N, J = I + 1;\n        vvi e;\n        forn(i, n){\n            forn(j, m){\n                if (i > 0) e.pb({N + i * m + j, (i - 1) * m + j, inf});\n                if (i + 1 < n) e.pb({N + i * m + j, (i + 1) * m + j, inf});\n                if (j > 0) e.pb({N + i * m + j, i * m + j - 1, inf});\n                if (j + 1 < m) e.pb({N + i * m + j, i * m + j + 1, inf});\n                if (a[i][j] == 'X') e.pb({I, i * m + j, inf});\n                if (i == 0 || i == n - 1 || j == 0 || j == m - 1) e.pb({N + i * m + j, J, inf});\n                e.pb({i * m + j, i * m + j + N, (a[i][j] == '.' ? 1 : inf)});\n            }\n        }\n        cout << mincut(2 * N + 2, e, I, J) << '\\n';\n    }\n     \n    bool multitest = false;\n     \n    int main() {\n        init();\n        int t = 1;\n        if (multitest) cin >> t;\n        forn(i, t) solve();\n    }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct MaxFlowDinic {\n\ttypedef int flow_t;\n\tstruct Edge {\n\t\tint next;\n\t\tsize_t inv; /* inverse edge index */\n\t\tflow_t res; /* residual */\n\t};\n\tint n;\n\tvector<vector<Edge>> G;\n\tvector<int> q, l, start;\n\n\tvoid init(int _n) {\n\t\tn = _n;\n\t\tG.resize(n);\n\t\tfor (int i = 0; i < n; i++) G[i].clear();\n\t}\n\tvoid add_edge(int s, int e, flow_t cap, flow_t caprev = 0) {\n\t\tEdge forward{ e, G[e].size(), cap };\n\t\tEdge reverse{ s, G[s].size(), caprev };\n\t\tG[s].push_back(forward);\n\t\tG[e].push_back(reverse);\n\t}\n\tbool assign_level(int source, int sink) {\n\t\tint t = 0;\n\t\tmemset(&l[0], 0, sizeof(l[0]) * l.size());\n\t\tl[source] = 1;\n\t\tq[t++] = source;\n\t\tfor (int h = 0; h < t && !l[sink]; h++) {\n\t\t\tint cur = q[h];\n\t\t\tfor (const auto& e : G[cur]) {\n\t\t\t\tif (l[e.next] || e.res == 0) continue;\n\t\t\t\tl[e.next] = l[cur] + 1;\n\t\t\t\tq[t++] = e.next;\n\t\t\t}\n\t\t}\n\t\treturn l[sink] != 0;\n\t}\n\tflow_t block_flow(int cur, int sink, flow_t current) {\n\t\tif (cur == sink) return current;\n\t\tfor (int& i = start[cur]; i < G[cur].size(); i++) {\n\t\t\tauto& e = G[cur][i];\n\t\t\tif (e.res == 0 || l[e.next] != l[cur] + 1) continue;\n\t\t\tif (flow_t res = block_flow(e.next, sink, min(e.res, current))) {\n\t\t\t\te.res -= res;\n\t\t\t\tG[e.next][e.inv].res += res;\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tflow_t solve(int source, int sink) {\n\t\tq.resize(n);\n\t\tl.resize(n);\n\t\tstart.resize(n);\n\t\tflow_t ans = 0;\n\t\twhile (assign_level(source, sink)) {\n\t\t\tmemset(&start[0], 0, sizeof(start[0]) * n);\n\t\t\twhile (flow_t flow = block_flow(source, sink, numeric_limits<flow_t>::max()))\n\t\t\t\tans += flow;\n\t\t}\n\t\treturn ans;\n\t}\n};\n\nconst int inf = 1e9;\nconst int MAXN = 105;\n\nint N, M;\nchar S[MAXN][MAXN];\nint in[MAXN][MAXN], out[MAXN][MAXN];\nint source, sink, v;\n\nint px[4] = {1,-1,0,0};\nint py[4] = {0,0,1,-1};\n\nint main() {\n\tscanf(\"%d%d\",&N,&M);\n\tfor (int i = 1; i <= N; i++) {\n\t\tscanf(\"%s\", S[i]+1);\n\t}\n\tsource = 0;\n\tsink = N*M*2 + 1;\n\tv = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= M; j++) {\n\t\t\tin[i][j] = ++v;\n\t\t\tout[i][j] = ++v;\n\t\t}\n\t}\n\tMaxFlowDinic f;\n\tf.init(2*N*M + 2);\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= M; j++) {\n\t\t\tif (S[i][j] == 'X') {\n\t\t\t\tif (i == 1 || i == N || j == 1 || j == M) {\n\t\t\t\t\tf.add_edge(source, in[i][j], inf);\n\t\t\t\t}\n\t\t\t\tf.add_edge(in[i][j], out[i][j], inf);\n\t\t\t\tf.add_edge(out[i][j], sink, inf);\n\t\t\t} else {\n\t\t\t\tif (i == 1 || i == N || j == 1 || j == M) {\n\t\t\t\t\tf.add_edge(source, in[i][j], 1);\n\t\t\t\t}\n\t\t\t\tf.add_edge(in[i][j], out[i][j], 1);\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint x = i + px[k];\n\t\t\t\t\tint y = j + py[k];\n\t\t\t\t\tif (1 <= x && x <= N && 1 <= y && y <= M) {\n\t\t\t\t\t\tf.add_edge(out[i][j], in[x][y], inf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint flow = f.solve(source, sink);\n\tif (flow >= inf) puts(\"-1\");\n\telse printf(\"%d\\n\", flow);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mem(x,n) memset(x,n,sizeof(x))\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,l) for(auto it=(l).begin();it!=(l).end();it++)\n#define pnl printf(\"\\n\")\n#define len(x) (x).length()\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\nconst double EPS=1e-10;\n//const double PI=acos(-1.0);\nconst int INF=1<<30;\nconst LL LLINF=1ll<<60;\nconst int MOD=1e9+7;\nconst int xx[8]={1,0,-1,0,1,-1,1,-1};\nconst int yy[8]={0,1,0,-1,-1,1,1,-1};\n\n/****************************************************************************************\\\n  __    __               __ /\\/|   ___ _           _       /\\/|__               __    __\n  \\ \\  / /  _____ __ ____\\ \\/\\/   / __| |__ _ _ __(_)___  |/\\// /____ __ _____  \\ \\  / /\n   \\ \\| |  |___\\ V  V /___| |    | (__| / _` | '_ \\ / -_)    | |___\\ V  V /___|  | |/ /\n    \\_\\ |  |___|\\_/\\_/|___| |     \\___|_\\__,_| .__/_\\___|    | |___|\\_/\\_/|___|  | /_/\n       \\_\\               /_/                 |_|              \\_\\               /_/\n\\****************************************************************************************/\n\nchar input[105][105];\nint cnt[105][105];\n\nint main(){\n\tint r,c;\n\tscanf(\"%d%d\",&r,&c);\n\tgetchar();\n\tfor(int i=0;i<r;i++){\n\t\tscanf(\"%s\",input[i]);\n\t}\n\t\n\tfor(int i=0;i<r;i++){\n\t\tint mini=INF,maxi=-1;\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(input[i][j]=='X'){\n\t\t\t\tmini=min(mini,j);\n\t\t\t\tmaxi=max(maxi,j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(mini==INF&&maxi==-1) continue;\n\t\tfor(int j=mini;j<=maxi;j++){\n\t\t\tcnt[i][j]=1;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(cnt[i][j]==1){\n\t\t\t\tfor(int ii=0;ii<4;ii++){\n\t\t\t\t\tint tempx = xx[ii]+i;\n\t\t\t\t\tint tempy = yy[ii]+j;\n\t\t\t\t\t\n\t\t\t\t\tif(tempx<0||tempx>=r||tempy<0||tempy>=c){\n\t\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt[tempx][tempy]==1) continue;\n\t\t\t\t\t\n\t\t\t\t\tcnt[tempx][tempy]=2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans=0;\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(cnt[i][j]==2) ans++;\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n\t\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint h,w;\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\ninline bool isRange(int i,int j){\n\treturn (0<=i && i<h && 0<=j && j<w);\n}\nint main(){\n\tcin>>h>>w;\n\tvector<string> s(h);\n\tfor(int i=0;i<h;i++)\n\t\tcin>>s[i];\n\tbool isok=true;\n\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w && isok;j++){\n\t\t\tif(s[i][j]=='X'){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(!isRange(i+dy[k],j+dx[k])){\n\t\t\t\t\t\tisok=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(s[i+dy[k]][j+dx[k]]!='X')\n\t\t\t\t\t\ts[i+dy[k]][j+dx[k]]='#';\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\t\n\tif(!isok){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\n\t}\n\tfor(int k=0;k<h+w+1;k++){\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(s[i][j]=='.'){\n\t\t\t\t\tif(i==0 || i==h-1 || j==0 || j==w-1)\n\t\t\t\t\t\ts[i][j]='%';\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int r=0;r<4;r++){\n\t\t\t\t\t\t\tif(isRange(i+dy[r],j+dx[r]) && s[i+dy[r]][j+dx[r]]=='%')\n\t\t\t\t\t\t\t\ts[i][j]='%';\n\n\n\t\t\t\t\t\t}\n\n\n\n\t\t\t\t\t}\n\n\n\n\t\t\t\t}\n\n\n\n\t\t\t}\n\n\n\t}\n\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\t\tif(s[i][j]=='.')\n\t\t\t\ts[i][j]='X';\n\n\tbool renew=false;\n\tdo{\n\t\trenew=false;\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(s[i][j]=='#'){\n\t\t\t\t\tbool removable=true;\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tif(!isRange(i+dy[k],j+dx[k]) || s[i+dy[k]][j+dx[k]]=='%')\n\t\t\t\t\t\t\tremovable=false;\n\n\n\t\t\t\t\t}\n\t\t\t\t\tif(removable)\n\t\t\t\t\t\ts[i][j]='X',renew=true;\n\n\n\t\t\t\t}\n\n\n\n\t\t\t}\n\n\n\n\n\n\t}while(renew);\n\tint res=0;\n\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\t\tres+=(s[i][j]=='#');\n\tcout<<res<<endl;\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vin=vector<int>;\nusing vll=vector<long long>;\nusing vvin=vector<vector<int>>;\nusing vvll=vector<vector<long long>>;\nusing vstr=vector<string>;\nusing vvstr=vector<vector<string>>;\nusing vch=vector<char>;\nusing vvch=vector<vector<char>>;\nusing vbo=vector<bool>;\nusing vvbo=vector<vector<bool>>;\nusing vpii=vector<pair<int,int>>;\nusing pqsin=priority_queue<int,vector<int>,greater<int>>;\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep2(i,s,n) for(int i=(s);i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define decp(n) cout<<fixed<<setprecision((int)n)\nconst int inf=1e9+7;\nconst ll INF=1e18;\n\nstruct edge{int to;ll cap;int rev;};\n\nint MAX_V=20050;\nint tmp1,tmp2;\n\nvector<vector<edge>> g(MAX_V);//グラフの隣接リスト表現\nvin level(MAX_V);//distance form s\nvin iter(MAX_V);//どこまで調べたか\n\nvoid add_edge(int from,int to,ll cap=(ll)inf){\n    tmp1=g[to].size();tmp2=g[from].size();\n    g[from].push_back((edge){to,cap,tmp1});//g[to]のg[to].size()番目にfromが入っている\n    g[to].push_back((edge){from,0,tmp2});//g[from]のg[from].size()-1番目にtoが入っている\n}\n\nvoid bfs(int s){\n    fill(all(level),-1);\n    queue<int> q;\n    q.push(s);\n    level[s]=0;\n    while(q.size()){\n        int v=q.front();q.pop();\n        for(auto& e:g[v]){\n            if(e.cap>0&&level[e.to]<0){\n                level[e.to]=level[v]+1;\n                q.push(e.to);\n            }\n        }\n    }\n}\n\n//増加パスをdfsで探す\n//v:今見てる頂点 t:終点 f:流量\nint dfs(int v,int t,ll f){\n    if(v==t)return f;\n    for(int& i=iter[v];i<(int)g[v].size();i++){\n        edge& e=g[v][i];\n        if(e.cap>0&&level[v]<level[e.to]){\n            ll d=dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                g[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n//sからtへの最大流を求める\nint max_flow(int s,int t){\n    ll flow=(ll)0;\n    ll f;\n    for(;;){\n        bfs(s);\n        if(level[t]<0)return flow;\n        fill(all(iter),0);\n        while((f=dfs(s,t,inf))>0)flow+=f;\n    }\n}\n\nint main(){\n    int h,w;cin>>h>>w;\n    vstr S(h);\n    rep(i,h)cin>>S[i];\n    //各マスinとoutを2つ用意\n    //(i,j)のinは2(i*w+j)で, outは2(i*w+j)+1で表される\n    int s=2*h*w;//s→ヤギ\n    int t=s+1;//追加したグリッドのマス(ゴール)→t\n    int tmp;\n    rep(i,h)rep(j,w){\n        tmp=2*(i*w+j);\n        if(S[i][j]=='X'){\n            if(i==0||i==h-1||j==0||j==w-1){\n                cout<<-1<<endl;\n                return 0;\n            }\n            add_edge(tmp,tmp+1);\n            add_edge(s,tmp);\n        }\n        else add_edge(tmp,tmp+1,(ll)1);\n        if(i>0)add_edge(tmp+1,tmp-2*w);\n        if(i<h-1)add_edge(tmp+1,tmp+2*w);\n        if(j>0)add_edge(tmp+1,tmp-2);\n        if(j<w-1)add_edge(tmp+1,tmp+2);\n        if(i==0||i==h-1||j==0||j==w-1)add_edge(tmp+1,t);\n    }\n    cout<<max_flow(s,t)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int,int> PII;\n\n#define MP make_pair\n#define PB push_back\n#define FF first\n#define SS second\n\n#define FORN(i, n) for (int i = 0; i <  (int)(n); i++)\n#define FOR1(i, n) for (int i = 1; i <= (int)(n); i++)\n#define FORD(i, n) for (int i = (int)(n) - 1; i >= 0; i--)\n\n#define DEBUG(X) { cout << #X << \" = \" << (X) << endl; }\n#define PR0(A,n) { cout << #A << \" = \"; FORN(_,n) cout << A[_] << ' '; cout << endl; }\n\n#define MOD 1000000007\n#define INF 2000000000\n\nint GLL(LL& x) {\n    return scanf(\"%lld\", &x);\n}\n\nint GI(int& x) {\n    return scanf(\"%d\", &x);\n}\n\nstruct Edge {\n  int u, v;\n  LL cap, flow;\n  Edge() {}\n  Edge(int u, int v, LL cap): u(u), v(v), cap(cap), flow(0) {}\n};\n\nstruct Dinic {\n  int N;\n  vector<Edge> E;\n  vector<vector<int>> g;\n  vector<int> d, pt;\n  \n  Dinic(int N): N(N), E(0), g(N), d(N), pt(N) {}\n\n  void AddEdge(int u, int v, LL cap) {\n//    printf(\"ADD %d %d\\n\", u, v);\n    if (u != v) {\n      E.emplace_back(Edge(u, v, cap));\n      g[u].emplace_back(E.size() - 1);\n      E.emplace_back(Edge(v, u, 0));\n      g[v].emplace_back(E.size() - 1);\n    }\n  }\n\n  bool BFS(int S, int T) {\n    queue<int> q({S});\n    fill(d.begin(), d.end(), N + 1);\n    d[S] = 0;\n    while(!q.empty()) {\n      int u = q.front(); q.pop();\n      if (u == T) break;\n      for (int k: g[u]) {\n        Edge &e = E[k];\n        if (e.flow < e.cap && d[e.v] > d[e.u] + 1) {\n          d[e.v] = d[e.u] + 1;\n          q.emplace(e.v);\n        }\n      }\n    }\n    return d[T] != N + 1;\n  }\n\n  LL DFS(int u, int T, LL flow = -1) {\n    if (u == T || flow == 0) return flow;\n    for (int &i = pt[u]; i < g[u].size(); ++i) {\n      Edge &e = E[g[u][i]];\n      Edge &oe = E[g[u][i]^1];\n      if (d[e.v] == d[e.u] + 1) {\n        LL amt = e.cap - e.flow;\n        if (flow != -1 && amt > flow) amt = flow;\n        if (LL pushed = DFS(e.v, T, amt)) {\n          e.flow += pushed;\n          oe.flow -= pushed;\n          return pushed;\n        }\n      }\n    }\n    return 0;\n  }\n\n  LL MaxFlow(int S, int T) {\n    LL total = 0;\n    while (BFS(S, T)) {\n      fill(pt.begin(), pt.end(), 0);\n      while (LL flow = DFS(S, T))\n        total += flow;\n    }\n    return total;\n  }\n};\n\nint dx[4] = {0, 0, 1, -1};\nint dy[4] = {1, -1, 0, 0};\n\nint h, w;\n\nvector<string> board; string row;\n\ninline int id(int x, int y, bool in) {\n    return 2 * (x * w + y) + in + 2;\n}\n\nint main() {\n    GI(h); GI(w);\n\n    FORN(i, h) {\n        cin >> row; board.PB(row);\n    }\n\n    Dinic mf(h * w * 2 + 5);\n\n    FORN(i, h) {\n        if (board[i][0] == 'X' || board[i][w-1] == 'X') {\n            printf(\"-1\\n\");\n            return 0;\n        }\n        else {\n            mf.AddEdge(0, id(i, 0, true), INF);\n            mf.AddEdge(0, id(i, w-1, true), INF);\n        }\n    }\n\n    for (int j = 1; j < w-1; j++) {\n        if (board[0][j] == 'X' || board[h-1][j] == 'X') {\n            printf(\"-1\\n\");\n            return 0;\n        }\n        else {\n            mf.AddEdge(0, id(0, j, true), INF);\n            mf.AddEdge(0, id(h-1, j, true), INF);\n        }\n    }\n\n    FORN(i, h) {\n        FORN(j, w) {\n            if (board[i][j] == '.') {\n                mf.AddEdge(id(i, j, true), id(i, j, false), 1);\n\n                FORN(k, 4) {\n                    int ni = i + dx[k];\n                    int nj = j + dy[k];\n\n                    if (ni >= 0 && ni < h && nj >= 0 && nj < w) {\n                        mf.AddEdge(id(i, j, false), id(ni, nj, true), INF);\n                    }\n                }\n            }\n            else {\n                mf.AddEdge(id(i, j, true), 1, INF);\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", mf.MaxFlow(0, 1));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\n\nint main(void){\n\tint H,W,res=0;\n\tvector<int> grid;\n\tstring str;\n\tcin>>H>>W;\n\n\tfor(int i=0;i<H;i++){\n\tcin>>str;\n\t\tfor(int j=0;j<W;j++){\n\t\tif(str[j]=='.')grid.push_back(0);\n\t\tif(str[j]=='X'||str[j]=='x')grid.push_back(1);\n\t\t}\n\t}\n\n\tfor(int i=0;i<grid.size();i++){\n\t\tif(grid.at(i)==1){\n\t\t\tif(i<W||i+W>=H*W||i%W==0||i%W==W-1){\n\t\t\t\tcout<<-1<<endl;\n\t\t\t\treturn 0;\n\t\t\t}else{\n\t\t\t\tif(grid.at(i+1)==0&&(grid.at(i+2)==0||grid.at(i+2)==2))grid.at(i+1)=2;\n\t\t\t\tif(grid.at(i-1)==0&&(grid.at(i-2)==0||grid.at(i-2)==2))grid.at(i-1)=2;\n\t\t\t\tif(grid.at(i+W)==0&&grid.at(i+2*W)!=1)grid.at(i+W)=2;\n\t\t\t\tif(grid.at(i-W)==0&&grid.at(i-2*W)!=1)grid.at(i-W)=2;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=0;i<grid.size();i++){\n\t\tif(grid.at(i)==2)res++;\n\t}\n\tcout<<res<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define for(i, a, b) for(ll (i)=a;(i)<(b);++(i))\n#define rep(i, n)    for(i, 0, n)\n#define MAX_V        20004\n\nconst ll inf = 1e15;\nconst ll mod = 1e9+7;\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nstruct edge {\n    ll to, cap, rev;\n    edge(ll t, ll c, ll r): to(t), cap(c), rev(r){}\n};\n\nvector<edge> G[MAX_V];\nll level[MAX_V];\nll iter[MAX_V];\n\nvoid add_edge(ll from, ll to, ll cap) {\n    G[from].push_back(edge(to, cap, G[to].size()));\n    G[to].push_back(edge(from, 0, G[from].size() - 1));\n}\n\nvoid bfs(ll s) {\n    memset(level, -1, sizeof(level));\n    queue<ll> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n        ll v = que.front(); que.pop();\n        rep(i, G[v].size()) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nll dfs(ll v, ll t, ll f) {\n    if (v == t) return f;\n    ll &i = iter[v];\n    while (i < G[v].size()) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[v] < level[e.to]) {\n            ll d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n        i++;\n    }\n    return 0;\n}\n\nll max_flow(ll s, ll t) {\n    ll flow = 0;\n    while (true) {\n        bfs(s);\n        if (level[t] < 0) return flow;\n        memset(iter, 0, sizeof(iter));\n        ll f;\n        while ((f = dfs(s, t, inf)) > 0) {\n            flow += f;\n        }\n    }\n}\n\nchar field[101][101];\nint main() {\n    ll H, W; cin >> H >> W;\n    rep(i, H) rep(j, W) {\n        cin >> field[i][j];\n        if (field[i][j] == 'X' && (i == 0 || i == H-1 || j == 0 || j == W-1)) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n    \n    ll S = 2 * H * W;\n    ll T = 2 * H * W + 1;\n    rep(i, H) rep(j, W) {\n        if (field[i][j] == 'X') add_edge(S, i * W + j, inf);\n        if (i == 0 || i == H-1 || j == 0 || j == W-1) add_edge(H * W + i * W + j, T, inf);\n        \n        add_edge(i * W + j, H * W + i * W + j, field[i][j] == 'X' ? inf : 1);\n        rep(k, 4) {\n            if (i+dy[k] < 0 || H-1 < i+dy[k] || j+dx[k] < 0 || W-1 < j+dx[k]) continue;\n            add_edge(H * W + i * W + j, (i+dy[k]) * W + (j+dx[k]), inf);\n        }\n    }\n    cout << max_flow(S, T) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long int lint;\ntypedef pair<lint, lint> plint;\ntypedef pair<double long, double long> pld;\n#define Alint(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1ll << (n))\n#define FOR(i, begin, end) for(lint i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(lint i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2>& l, const pair<T1, T2>& r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2>& l, const pair<T1, T2>& r) { return make_pair(l.first - r.first, l.second - r.second); }\nconst lint MOD = 998244353, INF = 1e18;\n\nstruct edge { lint to, cap, rev; };\n\nvector<edge> Graph[20005];\nint level[20005];\nint iter[20005];\nvoid add_edge(lint from, lint to, lint cap) {\n\tGraph[from].push_back({ to, cap, SZ(Graph[to]) });\n\tGraph[to].push_back({ from, 0, SZ(Graph[from]) - 1 });\n}\nvoid bfs(lint s) {\n\tmemset(level, -1, sizeof(level));\n\tqueue<lint> que;\n\tque.push(s);\n\tlevel[s] = 0;\n\twhile (!que.empty()) {\n\t\tlint v = que.front(); que.pop();\n\t\tREP(i, SZ(Graph[v])) {\n\t\t\tedge& e = Graph[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nlint dfs(lint v, lint t, lint f) {\n\tif (v == t) return f;\n\tfor (int& i = iter[v]; i < SZ(Graph[v]); i++) {\n\t\tedge& e = Graph[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tlint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tGraph[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nlint max_flow(lint s, lint t) {\n\tlint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0) return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tlint f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\n\nlint H, W;\nchar c;\n\nint main() {\n\tcin.tie(0); ios_base::sync_with_stdio(false);\n\t//始点 20002 終点 20003\n\tlint N = 10000;\n\tcin >> H >> W;\n\tREP(i, H) {\n\t\tREP(j, W) {\n\t\t\tcin >> c;\n\t\t\tif (c == 'X') {\n\t\t\t\tadd_edge(20002, i * H + j + N, INF);\n\t\t\t}\n\t\t\telse add_edge(i * H + j, i * H + j + N, 1);\n\t\t\tif (j < W - 1) {\n\t\t\t\tadd_edge(i * H + j + N, i * H + j + 1, INF);\n\t\t\t\tadd_edge(i * H + j + 1 + N, i * H + j, INF);\n\t\t\t}\n\t\t\tif (i < H - 1) {\n\t\t\t\tadd_edge(i * H + j + N, (i + 1) * H + j, INF);\n\t\t\t\tadd_edge((i + 1) * H + j + N, i * H + j, INF);\n\t\t\t}\n\t\t\tif (i == 0 || j == 0 || i == H - 1 || j == W - 1) {\n\t\t\t\tadd_edge(i * H + j + N, 20003, INF);\n\t\t\t}\n\t\t}\n\t}\n\tlint ans = max_flow(20002, 20003);\n\tif (ans >= INF) cout << -1 << endl;\n\telse cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define all(x) x.begin(),x.end()\n#define SZ(x) (int)(x.size())\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,a,b) for(int i=b-1;i>=a;i--)\n#define inf 1000000007\n#define mod 1000000007\n#define x first\n#define y second\n#define pi acos(-1.0)\n#define DBG(x) cerr<<(#x)<<\"=\"<<x<<\"\\n\";\n//#define dprintf(...) \n#define hash _hash\n#define next _next\n//#define dprintf(...) fprintf(outFile,__VA_ARGS__)\n \n#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define ull unsigned long long\n#define ll long long\n#define N 50010\n \ntemplate <class T,class U>inline void Max(T &a,U b){if(a<b)a=b;}\ntemplate <class T,class U>inline void Min(T &a,U b){if(a>b)a=b;}\n \n//FILE* outFile;\ninline void add(int &a,int b){a+=b;while(a>=mod)a-=mod;}\n\n\nint pow(int a,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=ans*(ll)a%mod;\n        a=(ll)a*a%mod;b>>=1;\n    }\n    return ans;\n}\n\nchar s[110][110];\nint vis[110][110],use[110][110],n,m;\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nint Dx[4][4]={{0,0,-1,-1},{-1,1,-1,1},{0,0,1,1},{1,-1,1,-1}};\nint Dy[4][4]={{-1,1,-1,1},{0,0,1,1},{1,-1,1,-1},{0,0,-1,-1}};\nint c[3][2]={{0,1},{0,3},{1,2}};\nbool in(int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nint main(){\n    int T,i,j,k,ca=0,K;\n    //cout<<setprecision(10)<<fixed;\n    scanf(\"%d%d\",&n,&m);\n    rep(i,0,n)scanf(\"%s\",s[i]);\n    rep(i,0,n){\n    \tif(s[i][0]=='X'||s[i][m-1]=='X'){puts(\"-1\");return 0;}\n    }\n    rep(i,0,m){\n    \tif(s[0][i]=='X'||s[n-1][i]=='X'){puts(\"-1\");return 0;}\n    }\n    int x1=0,y1=0,x2=n-1,y2=m-1;\n    queue<pii>q;\n    rep(i,y1+1,y2){\n    \tq.push({x1,i});vis[x1][i]=1;use[x1][i]=1;\n    \tq.push({x2,i});vis[x2][i]=1;use[x2][i]=1;\n    }\n    rep(i,x1+1,x2){\n    \tq.push({i,y1});vis[i][y1]=1;use[i][y1]=1;\n    \tq.push({i,y2});vis[i][y2]=1;use[i][y2]=1;\n    }\n    while(!q.empty()){\n    \tint x=q.front().x,y=q.front().y;q.pop();\n    \tint ok=1;\n    \trep(k,0,4){\n    \t\tint nx=x+dx[k],ny=y+dy[k];\n    \t\tif(in(nx,ny)&&!vis[nx][ny]){\n    \t\t\tif(s[nx][ny]=='X'){ok=0;break;}\n    \t\t}\n    \t}\n    \tif(!ok)continue;\n    \tok=0;\n    \trep(k,0,4){\n    \t\tint nx=x+dx[k],ny=y+dy[k];\n    \t\tif(in(nx,ny)&&!vis[nx][ny]&&!use[nx][ny]){\n    \t\t\trep(j,0,3){\n    \t\t\t\tx1=x+Dx[k][c[j][0]],y1=y+Dy[k][c[j][0]];x2=x+Dx[k][c[j][1]],y2=y+Dy[k][c[j][1]];\n    \t\t\t\tif(in(x1,y1)&&in(x2,y2)&&use[x1][y1]&&use[x2][y2]){\n    \t\t\t\t\tuse[x][y]=0;use[nx][ny]=1;\n    \t\t\t\t\tvis[nx][ny]=1;q.push({nx,ny});\n    \t\t\t\t\tok=1;break;\n\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tif(ok)break;\n    \t}\n    }\n    rep(i,0,n)rep(j,0,m)if(use[i][j]){\n    \tint flag=0,cnt=0;\n    \tper(k,0,i){\n    \t\tif(s[k][j]=='X'){flag=1;break;}\n    \t\tif(use[k][j]){cnt++;break;}\n    \t}\n    \tif(flag)continue;\n    \tper(k,0,j){\n    \t\tif(s[i][k]=='X'){flag=1;break;}\n    \t\tif(use[i][k]){cnt++;break;}\n    \t}\n    \tif(flag)continue;\n    \trep(k,i+1,n){\n    \t\tif(s[k][j]=='X'){flag=1;break;}\n    \t\tif(use[k][j]){cnt++;break;}\n    \t}\n    \tif(flag)continue;\n    \trep(k,j+1,m){\n    \t\tif(s[i][k]=='X'){flag=1;break;}\n    \t\tif(use[i][k]){cnt++;break;}\n    \t}\n    \tif(flag)continue;\n    \tuse[i][j]=0;\n    }\n    int ans=0;\n    rep(i,0,n)rep(j,0,m)ans+=use[i][j];\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int iinf = 0x7fffffff;\nconst ll linf = ~(1LL<<63);\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef map<ll, int> mli;\ntypedef map<ll, ll> mll;\ntemplate<typename T>\ninline T gcd(T a, T b) {\n\tif(a < 0) return gcd(-a, b);\n\tif(b < 0) return gcd( a,-b);\n\tif(a < b) return gcd(b, a);\n\tif(b == 0) return a;\n\treturn gcd(b, a%b);\n}\n\nll qpow(ll a, ll n, ll mod) {\n\ta %= mod;\n\tll ans = 1LL;\n\twhile(n) {\n\t\tif(n & 1) ans = (ans*a % mod);\n\t\ta = (a*a % mod);\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\n\n// unsigned\nll qmul(ll a, ll b, ll mod) {\n\ta %= mod;\n\tb %= mod;\n\tll ans = 0LL;\n\twhile(b) {\n\t\tif(b & 1) ans = (ans+a) % mod;\n\t\ta = (a<<1) % mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\ninline ll rev(ll a, ll p) {\n\treturn qpow(a, p - 2, p);\n}\n\n\n#define all(v) v.begin(), v.end()\n#define sz(v) v.size()\n#define rep(x, st, en) for(int x = st; x < en; x++)\n#define pb push_back\n#define mp make_pair\n#define dbgm(msg, var) cerr<<#msg<<\" \"<<#var<<\" = \"<<var<<endl; \n#define dbg(var) cerr<<#var<<\" = \"<<var<<endl;\n#ifdef ALNDBG\nclock_t s, e;\n#endif\n\ninline void tic() {\n#ifdef ALNDBG\n\ts = clock();\n#endif\n}\n\ninline void toc() {\n#ifdef ALNDBG\n\te = clock();\n\tcerr<<1000.0 * (e - s) / CLOCKS_PER_SEC<<\" ms\"<<endl;\n#endif\n}\n\n// -------------------- Spliters ------------------------\nconst int maxn = 102;\n\nchar m[maxn][maxn];\n\nint N, M;\n\nint dx[4] = { 0, 1, 0, -1 };\nint dy[4] = { -1, 0, 1, 0 };\n\nbool ok(int x, int y) {\n\treturn 0 <= x && x < N && 0 <= y && y < M;\n}\n\ntypedef long long T;\nconst double eps = 1e-8;\nstruct Point {\n\tvoid print() {\n\t\tcerr<<\"(\"<<x<<\", \"<<y<<\")\"<<endl;\n\t}\n\tT x, y;\n\tPoint(T _x = 0, T _y = 0) : x(_x), y(_y) {}\n\n\tPoint operator-(const Point& b) const {\n\t\treturn Point(x - b.x, y - b.y);\n\t}\n\tPoint operator+(const Point& b) const {\n\t\treturn Point(x + b.x, y + b.y);\n\t}\n\tdouble operator^(const Point& b) const {\n\t\treturn x * b.y - y * b.x;\n\t}\n\tdouble operator*(const Point& b) const {\n\t\treturn x * b.x + y * b.y;\n\t}\n};\n\nll cross(const Point& a, const Point& b, const Point& c) {\n\treturn (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x -  a.x);\n}\n\n\nvector<Point> convexHull(vector<Point>& p) {\n\tint n = p.size();\n\tif(n <= 1) return p;\n\tsort(p.begin(), p.end(), [](const Point& a, const Point& b) -> bool {\n\t\t\treturn a.x != b.x ? a.x < b.x : a.y < b.y;\n\t\t\t});\n\tvector<Point> q = vector<Point>(n * 2);\n\tint cnt = 0;\n\tfor(int i = 0; i < n; q[cnt++] = p[i++])\n\t\tfor(; cnt > 1 && cross(q[cnt - 2], q[cnt - 1], p[i]) >= 0; --cnt);\n\tfor(int i = n - 2, t = cnt; i >= 0; q[cnt++] = p[i--])\n\t\tfor(; cnt > t && cross(q[cnt - 2], q[cnt - 1], p[i]) >= 0; --cnt);\n\tint sz = cnt - 1 - (q[0].x == q[1].x && q[0].y == q[1].y ? 1 : 0);\n\treturn vector<Point>(q.begin(), q.begin() + sz);\n}\n\nvector<Point> pts;\nvector<Point> ch;\n\nvoid fillx(Point& u, Point& v) {\n\tint l = min(u.x, v.x), r = max(u.x, v.x);\n\tdouble k = 1.0 * (v.y - u.y) / (v.x - u.x);\n\trep(i, l, r + 1) {\n\t\tint y = ceil(k * (i - u.x) + u.y);\n\t\tif(m[i][y] == 'X') y -= 1;\n\t\tm[i][y] = '*';\n\t}\n}\n\nvoid filly(Point& u, Point& v) {\n\tint l = min(u.y, v.y), r = max(u.y, v.y);\n\tdouble k = 1.0 * (v.x - u.x) / (v.y - u.y);\n\trep(i, l, r + 1) {\n\t\tint x = ceil(k * (i - u.y) + u.x);\n\t\tif(m[x][i] == 'X') x -= 1;\n\t\tm[x][i] = '*';\n\t}\n}\n\nint fa[maxn * maxn];\n\nint rt(int u) {\n\treturn fa[u]  = (u == fa[u] ? u : rt(fa[u]));\n}\n\nvoid uni(int u, int v) {\n\tint a = rt(u), b = rt(v);\n\tif(a == b) return;\n\tfa[a] = b;\n}\n\nbool vis[maxn][maxn];\nmap<int, vector<Point> > mm;\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin>>N>>M;\n\tfor(int i = 0; i < maxn * maxn; i++) {\n\t\tfa[i] = i;\n\t}\n\trep(i, 0, N) cin>>m[i];\n\trep(i, 0, N) {\n\t\trep(j, 0, M) {\n\t\t\tif(m[i][j] == 'X') {\n\t\t\t\t//cout<<i<<\", \"<<j<<endl;\n\t\t\t\tif(vis[i][j]) continue;\n\t\t\t\tvis[i][j] = true;\n\t\t\t\trep(ddx, -2, 3) {\n\t\t\t\t\trep(ddy, -2, 3) {\n\t\t\t\t\t\tint x = i + ddx, y = j + ddy;\n\t\t\t\t\t\tif(ok(x, y) && m[x][y] == 'X') {\n\t\t\t\t\t\t\t//cout<<x<<\", \"<<y<<endl;\n\t\t\t\t\t\t\tuni(i * M + j, x * M + y);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 0, N) {\n\t\trep(j, 0, M) {\n\t\t\tif(m[i][j] == 'X') {\n\t\t\t\tmm[rt(i * M + j)].pb({i, j});\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 0, N) {\n\t\trep(j, 0, M) {\n\t\t\tif(m[i][j] == 'X') {\n\t\t\t\trep(k, 0, 4) {\n\t\t\t\t\tint x = i + dx[k];\n\t\t\t\t\tint y = j + dy[k];\n\t\t\t\t\tif(!ok(x, y)) { puts(\"-1\"); return 0; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto& kv : mm) {\n\t\tif(kv.second.size() <= 2) {\n\t\t\tfor(auto pt : kv.second) {\n\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\tint x = pt.x + dx[k];\n\t\t\t\t\tint y = pt.y + dy[k];\n\t\t\t\t\tif(ok(x, y) && m[x][y] != 'X') m[x][y] = '*';\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t} \n\t\tpts = vector<Point>();\n\t\tfor(auto pt : kv.second) {\n\t\t\trep(k, 0, 4) {\n\t\t\t\tint x = pt.x + dx[k], y = pt.y + dy[k];\n\t\t\t\tif(ok(x, y) && m[x][y] != 'X') pts.pb({x, y});\n\t\t\t}\n\t\t}\n\t\tch = convexHull(pts);\n\t\tfor(auto& p : ch) {\n\t\t\tm[p.x][p.y] = '*';\n\t\t}\n\t\tfor(int r = 0; r < ch.size(); r++) {\n\t\t\tint i = r, j = r + 1;\n\t\t\tif(j >= ch.size()) j = 0;\n\t\t\tint xdir = ch[j].x - ch[i].x;\n\t\t\tint ydir = ch[j].y - ch[i].y;\n\t\t\tif(abs(xdir) >= abs(ydir)) {\n\t\t\t\tfillx(ch[i], ch[j]);\n\t\t\t} else {\n\t\t\t\tfilly(ch[i], ch[j]);\n\t\t\t}\n\t\t}\n\t\t\t\n\t}\n\tll ans = 0;\n\trep(i, 0, N) rep(j, 0, M) {\n\t\tif(m[i][j] == '*') ans++;\n\t}\t\n\t/*\n\trep(i, 0, N) {\n\t\tcout<<m[i]<<endl;\n\t} */\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n// --USE C++11\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct Dinic{\n  static const Int INF=1<<28;\n  \n  struct edge {\n    Int to,cap,rev;\n    edge(){}\n    edge(Int to,Int cap,Int rev):to(to),cap(cap),rev(rev){}\n  };\n\n  Int n;\n  vector<vector<edge> > G;\n  vector<map<Int,int> > M;\n  vector<Int> level,iter;\n\n  Dinic(){}\n  Dinic(Int sz):n(sz),G(n),M(n),level(n),iter(n){}\n  \n  void add_edge(Int from,Int to,Int cap){\n    M[from][to]=G[from].size();\n    M[to][from]=G[to].size();\n    G[from].push_back(edge(to,cap,G[to].size()));\n    // undirected\n    //G[to].push_back(edge(from,cap,G[from].size()-1));\n    // directed\n    G[to].push_back(edge(from,0,G[from].size()-1));\n  }\n  \n  void bfs(Int s){\n    fill(level.begin(),level.end(),-1);\n    queue<Int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n      Int v=que.front();que.pop();\n      for(Int i=0;i<(Int)G[v].size();i++){\n\tedge &e = G[v][i];\n\tif(e.cap>0&&level[e.to]<0){\n\t  level[e.to]=level[v]+1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  \n  Int dfs(Int v,Int t,Int f){\n    if(v==t) return f;\n    for(Int &i=iter[v];i<(Int)G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[v]<level[e.to]){\n\tInt d = dfs(e.to,t,min(f,e.cap));\n\tif(d>0){\n\t  e.cap-=d;\n\t  G[e.to][e.rev].cap+=d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  \n  Int flow(Int s,Int t,Int lim){\n    Int fl=0;\n    for(;;){\n      bfs(s);\n      if(level[t]<0||lim==0) return fl;\n      fill(iter.begin(),iter.end(),0);\n      Int f;\n      while((f=dfs(s,t,lim))>0){\n\tfl+=f;\n\tlim-=f;\n      }\n    }\n  }\n\n  Int flow(Int s,Int t){\n    return flow(s,t,INF);\n  }\n\n  //cap==1 only\n  bool back_edge(Int s,Int t,Int from, Int to){\n    for(Int i=0;i<(Int)G[from].size();i++) {\n      edge& e=G[from][i];\n      if(e.to==to) {\n\tif(e.cap==0&&flow(from,to,1)==0) {\n\t  flow(from,s,1);\n\t  flow(t,to,1);\n\t  return 1;\n\t}\n      }\n    }\n    return 0;\n  }\n};\n\n\nsigned main(){\n  Int h,w;\n  cin>>h>>w;\n  vector<string> s(h);\n  for(Int i=0;i<h;i++) cin>>s[i];\n  Int dy[]={0,0,1,-1};\n  Int dx[]={1,-1,0,0};\n  Dinic flow(h*w*2+2);\n  Int S=h*w*2,T=h*w*2+1;\n  auto idx=[&](Int i,Int j,int k){return h*w*k+i*w+j;};\n  auto in=[&](Int y,Int x){return 0<=y&&y<h&&0<=x&&x<w;};\n  for(Int i=0;i<h;i++){\n    for(Int j=0;j<w;j++){\n      flow.add_edge(idx(i,j,0),idx(i,j,1),1);\n      if(s[i][j]=='X')\n\tflow.add_edge(S,idx(i,j,1),Dinic::INF);\n      if(i==0||i==h-1||j==0||j==w-1)\n\tflow.add_edge(idx(i,j,1),T,Dinic::INF);\n      \n      for(Int k=0;k<4;k++){\n\tInt ny=i+dy[k],nx=j+dx[k];\n\tif(in(ny,nx)) flow.add_edge(idx(i,j,1),idx(ny,nx,0),1);\n      }\t\n    }\n  }\n  Int ans=flow.flow(S,T);\n  cout<<(ans>h*w?-1:ans)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(´・ω・`)(´・ω・`)(´・ω・`)(´・ω・`)(´・ω・`)(´・ω・`)///\nstruct edge { int to, cap, rev, cost; };\n\nconstexpr int MAX_V = 20002;\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost = 0) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n}\n\nvoid bfs(int s) {\n\tfill_n(level, MAX_V, -1);\n\tqueue<int> q;\n\tlevel[s] = 0;\n\tq.push(s);\n\twhile (!q.empty()) {\n\t\tint v = q.front(); q.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nint dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nll max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0)return flow;\n\t\tfill_n(iter, MAX_V, 0);\n\t\tint f;\n\t\twhile ((f = dfs(s, t, numeric_limits<int>::max())) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> v(h);\n\tREP(i, h)cin >> v[i];\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tREP(k, 4) {\n\t\t\t\tint ni = i + dy[2*k], nj = j + dx[2*k];\n\t\t\t\tif (ni < 0 || ni == h || nj < 0 || nj == w) {\n\t\t\t\t\tadd_edge(i*w + j + 1+h*w, 2*h*w + 1, INF);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tadd_edge(i*w + j + 1+h*w, ni*w + nj + 1, 1);\n\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (v[i][j] == 'X') {\n\t\t\t\tadd_edge(0, i*w + j + 1, INF);\n\t\t\t\tadd_edge(i*w + j + 1, i*w + j + 1 + w*h, INF);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i*w + j + 1, i*w + j + 1 + w*h, 1);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tll ans = max_flow(0, 2 * w*h + 1);\n\tif (ans >= INF)cout << -1 << endl;\n\telse cout<<ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct MaxFlowDinic {\n\ttypedef int flow_t;\n\tstruct Edge {\n\t\tint next;\n\t\tsize_t inv; /* inverse edge index */\n\t\tflow_t res; /* residual */\n\t};\n\tint n;\n\tvector<vector<Edge>> G;\n\tvector<int> q, l, start;\n\n\tvoid init(int _n) {\n\t\tn = _n;\n\t\tG.resize(n);\n\t\tfor (int i = 0; i < n; i++) G[i].clear();\n\t}\n\tvoid add_edge(int s, int e, flow_t cap, flow_t caprev = 0) {\n\t\tEdge forward{ e, G[e].size(), cap };\n\t\tEdge reverse{ s, G[s].size(), caprev };\n\t\tG[s].push_back(forward);\n\t\tG[e].push_back(reverse);\n\t}\n\tbool assign_level(int source, int sink) {\n\t\tint t = 0;\n\t\tmemset(&l[0], 0, sizeof(l[0]) * l.size());\n\t\tl[source] = 1;\n\t\tq[t++] = source;\n\t\tfor (int h = 0; h < t && !l[sink]; h++) {\n\t\t\tint cur = q[h];\n\t\t\tfor (const auto& e : G[cur]) {\n\t\t\t\tif (l[e.next] || e.res == 0) continue;\n\t\t\t\tl[e.next] = l[cur] + 1;\n\t\t\t\tq[t++] = e.next;\n\t\t\t}\n\t\t}\n\t\treturn l[sink] != 0;\n\t}\n\tflow_t block_flow(int cur, int sink, flow_t current) {\n\t\tif (cur == sink) return current;\n\t\tfor (int& i = start[cur]; i < G[cur].size(); i++) {\n\t\t\tauto& e = G[cur][i];\n\t\t\tif (e.res == 0 || l[e.next] != l[cur] + 1) continue;\n\t\t\tif (flow_t res = block_flow(e.next, sink, min(e.res, current))) {\n\t\t\t\te.res -= res;\n\t\t\t\tG[e.next][e.inv].res += res;\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tflow_t solve(int source, int sink) {\n\t\tq.resize(n);\n\t\tl.resize(n);\n\t\tstart.resize(n);\n\t\tflow_t ans = 0;\n\t\twhile (assign_level(source, sink)) {\n\t\t\tmemset(&start[0], 0, sizeof(start[0]) * n);\n\t\t\twhile (flow_t flow = block_flow(source, sink, numeric_limits<flow_t>::max()))\n\t\t\t\tans += flow;\n\t\t}\n\t\treturn ans;\n\t}\n};\n\nconst int inf = 1e9;\nconst int MAXN = 105;\n\nint N, M;\nchar S[MAXN][MAXN];\nint in[MAXN][MAXN], out[MAXN][MAXN];\nint source, sink, v;\n\nint px[4] = {1,-1,0,0};\nint py[4] = {0,0,1,-1};\n\nint main() {\n\tscanf(\"%d%d\",&N,&M);\n\tfor (int i = 1; i <= N; i++) {\n\t\tscanf(\"%s\", S[i]+1);\n\t}\n\tsource = 0;\n\tsink = N*M*2 + 1;\n\tv = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= M; j++) {\n\t\t\tin[i][j] = ++v;\n\t\t\tout[i][j] = ++v;\n\t\t}\n\t}\n\tMaxFlowDinic f;\n\tf.init(2*N*M + 2);\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= M; j++) {\n\t\t\tif (S[i][j] == 'X') {\n\t\t\t\tif (i == 1 || i == N || j == 1 || j == M) {\n\t\t\t\t\tf.add_edge(source, in[i][j], inf);\n\t\t\t\t}\n\t\t\t\tf.add_edge(in[i][j], out[i][j], inf);\n\t\t\t\tf.add_edge(out[i][j], sink, inf);\n\t\t\t} else {\n\t\t\t\tif (i == 1 || i == N || j == 1 || j == M) {\n\t\t\t\t\tf.add_edge(source, in[i][j], 1);\n\t\t\t\t}\n\t\t\t\tf.add_edge(in[i][j], out[i][j], 1);\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint x = i + px[k];\n\t\t\t\t\tint y = j + py[k];\n\t\t\t\t\tif (1 <= x && x <= N && 1 <= y && y <= M) {\n\t\t\t\t\t\tf.add_edge(out[i][j], in[x][y], 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint flow = f.solve(source, sink);\n\tif (flow >= inf) puts(\"-1\");\n\telse printf(\"%d\\n\", flow);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mem(x,n) memset(x,n,sizeof(x))\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,l) for(auto it=(l).begin();it!=(l).end();it++)\n#define pnl printf(\"\\n\")\n#define len(x) (x).length()\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\nconst double EPS=1e-10;\n//const double PI=acos(-1.0);\nconst int INF=1<<30;\nconst LL LLINF=1ll<<60;\nconst int MOD=1e9+7;\nconst int xx[8]={1,0,-1,0,1,-1,1,-1};\nconst int yy[8]={0,1,0,-1,-1,1,1,-1};\n\n/****************************************************************************************\\\n  __    __               __ /\\/|   ___ _           _       /\\/|__               __    __\n  \\ \\  / /  _____ __ ____\\ \\/\\/   / __| |__ _ _ __(_)___  |/\\// /____ __ _____  \\ \\  / /\n   \\ \\| |  |___\\ V  V /___| |    | (__| / _` | '_ \\ / -_)    | |___\\ V  V /___|  | |/ /\n    \\_\\ |  |___|\\_/\\_/|___| |     \\___|_\\__,_| .__/_\\___|    | |___|\\_/\\_/|___|  | /_/\n       \\_\\               /_/                 |_|              \\_\\               /_/\n\\****************************************************************************************/\n\nstruct edge{\n\tint v, bf;\n\tLL flow;\n};\n\nconst int MAXN = 40010;\nvector<edge> adj[MAXN];\nint lvl[MAXN], st[MAXN];\nconst int sink = 40008, source = 40009;\nint idx[1005][1005],idx1[1005][1005];\nchar input[1005][1005];\n\nvoid addedge(int u,int v,LL flow){\n\tadj[u].pb({v,sz(adj[v]),flow});\n\tadj[v].pb({u,sz(adj[u]),0});\n}\n\nbool bfs(int S,int G){\n\tqueue<int> q;\n\tmem(lvl,-1);\n\tq.push(S); lvl[S]=0;\n\twhile(!q.empty()){\n\t\tint u = q.front(); q.pop();\n\t\tfor(int i=0;i<sz(adj[u]);i++){\n\t\t\tint v = adj[u][i].v;\n\t\t\tLL flow = adj[u][i].flow;\n\t\t\tif(lvl[v]!=-1||flow<=0) continue;\n\t\t\tlvl[v]=lvl[u]+1;\n\t\t\tq.push(v);\n\t\t}\n\t}\n\treturn (lvl[G]!=-1);\n}\n\nLL dfs(int u,LL mini,int G){\n\tif(u==G) return mini;\n\t\n\tfor(int i=st[u];i<sz(adj[u]);i++){\n\t\tst[u]=i;\n\t\tint v = adj[u][i].v;\n\t\tLL flow = adj[u][i].flow;\n\t\tif(flow<=0||(lvl[v]-lvl[u]!=1)) continue;\n\t\tLL ret=dfs(v,min(mini,flow),G);\n\t\tif(ret>0){\n\t\t\tadj[u][i].flow-=ret;\n\t\t\tint bvf = adj[u][i].bf;\n\t\t\tadj[v][bvf].flow+=ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nLL maxflow(int S,int G){\n\tLL ret=0;\n\twhile(1){\n\t\tif(!bfs(S,G)) break;\n\t\tLL flow = 0;\n\t\tmem(st,0);\n\t\twhile((flow=dfs(S, LLINF, G))>0){\n\t\t\tret+=flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint r,c;\n\tscanf(\"%d%d\",&r,&c);\n\tgetchar();\n\tfor(int i=0;i<r;i++){\n\t\tscanf(\"%s\",input[i]);\n\t}\n\t\n\tint temp=0;\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tidx[i][j]=temp;\n\t\t\tidx1[i][j]=temp+20000;\n\t\t\ttemp++;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(input[i][j]=='.'){\n\t\t\t\taddedge(idx[i][j],idx1[i][j],1);\n\t\t\t\t\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\taddedge(idx1[i][j],sink,INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\taddedge(source,idx[i][j],INF);\n\t\t\t\taddedge(idx[i][j],idx1[i][j],INF);\n\t\t\t\t\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(i!=0) addedge(\tidx1[i][j], idx[i-1][j],INF);\n\t\t\tif(i!=r-1) addedge(\tidx1[i][j], idx[i+1][j],INF);\n\t\t\tif(j!=0) addedge(\tidx1[i][j], idx[i][j-1],INF);\n\t\t\tif(j!=c-1)addedge(\tidx1[i][j], idx[i][j+1],INF);\n\t\t}\n\t}\n\t\n\tLL ans = maxflow(source,sink);\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*? begin \"base.hpp\" */\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve( /* この関数に問題ごとの処理を書く */\n#ifdef GCJ_CASE\n long long case_id\n#endif\n);\n\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n #define debug true\n#else\n #define NDEBUG \n #define debug false\n#endif\n#include<algorithm>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<type_traits>\n#include<vector>\n#ifdef __cpp_lib_execution\n  #include<execution>\n#endif\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL \n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define times(n,i) uptil(0,n,i)\n#define rtimes(n,i) downto((n)-1,0,i)\n#define upto(f,t,i) for(int rabT##i=(t),i=(f);i<=rabT##i;i++)\n#define uptil(f,t,i) for(int rabT##i=(t),i=(f);i< rabT##i;i++)\n#define downto(f,t,i) for(int rabT##i=(t),i=(f);i>=rabT##i;i--)\n#define downtil(f,t,i) for(int rabT##i=(t),i=(f);i> rabT##i;i--)\n#define iter(v) begin(v),end(v)\n#define citer(v) cbegin(v),cend(v)\n#define riter(v) rbegin(v),rend(v)\n#define criter(v) crbegin(v),crend(v)\n#define IF(a,b,c) ((a)?(b):(c))\n#define BINOP_ASGN(t,u,op) t operator op(CS u&o)CS{RT t(*this)op##=o;}\n#if debug\n #define _GLIBCXX_DEBUG\n #define _LIBCPP_DEBUG 2\n #define _LIBCPP_DEBUG2 2\n #define ln <<endl\n#else\n #define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n #define PARABLE \n/*? begin \"mod.hpp\" */\n#ifdef MOD\n #if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n  #error unknown mod MOD and FORCE_MOD not defined.\n #endif\n#else\n #define MOD 1000000007\n#endif\n/*? begin \"power.hpp\" */\nusing int128=__int128;\nTL<TN T>T power(T x,int n){T rt(1);for(;n;n/=2){if(n%2)rt*=x;x*=x;}RT rt;}\nint pow_mod(int x,int n,int m){int rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\nint128 pow_mod_64(int128 x,int n,int m){int128 rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\n/*? end \"power.hpp\" */\nIL CX int modulo(int a,int m){RT(a%=m,a>=0?a:a+m);}\nTL<ULL mod=MOD>class MInt{\n  /*! https://ei1333.github.io/luzhiled/snippets/other/mod-int.html */\npublic:\n  int val;\n  CX MInt():val(0){}\n  explicit CX MInt(int v):val(modulo(v,mod)){}\n  MInt&operator+=(CS MInt&m){val+=m.val;if(val>=mod)val-=mod;RT*this;}\n  MInt&operator-=(CS MInt&m){val-=m.val;if(val<0)val+=mod;RT*this;}\n  MInt&operator*=(CS MInt&m){val=val*m.val%mod;RT*this;}\n  MInt&operator/=(CS MInt&m){val=val*m.inv().val%mod;RT*this;}\n  BINOP_ASGN(MInt,MInt,+) BINOP_ASGN(MInt,MInt,-) BINOP_ASGN(MInt,MInt,*) BINOP_ASGN(MInt,MInt,/)\n  MInt operator-()CS{MInt m;m.val=val?mod-val:0;RT m;}\n  bool operator==(CS MInt&m)CS{RT val==m.val;}\n  bool operator!=(CS MInt&m)CS{RT val!=m.val;}\n  //MInt pow(int n)CS{MInt x(*this),rt(1);while(n){if(n%2)rt*=x;x*=x;n/=2;}RT rt;}\n  MInt pow(int n)CS{RT power(*this,n);}\n  MInt inv()CS{int a=val,b=mod,x=1,y=0,t;while(b){t=a/b;swap(b,a-=t*b);swap(y,x-=t*y);}RT(MInt)x;}\n  friend ostream&operator<<(ostream&o,CS MInt<mod>&m){RT o<<m.val;}\n  friend istream&operator>>(istream&i,MInt<mod>&m){int v;i>>v;m=MInt<mod>(v);RT i;}\n};\nusing mint=MInt<>;\n\nconstexpr mint operator\"\" _m(ULL n){RT mint(n);}\nconstexpr MInt<998244353>operator\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nconstexpr MInt<1000000007>operator\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nconstexpr MInt<1000000009>operator\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n\n//#pragma rab:gsub \\b(\\d+)m\\b mint(\\1)\n/*? end \"mod.hpp\" */\n/*? begin \"typedefs.hpp\" */\nstruct unit{};\n\nusing int128=__int128;\nusing LD=long double;\nTL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;\nTL<TN T>using vvvec=vec<vvec<T>>;\nTL<TN T>using vvvvec=vec<vvvec<T>>;\n\n//#pragma rab typedefs.dynamic\nusing WI = vvec<int>; using VI = vec<int>; using VC = vec<char>; using HII = map<int, int>; using VS = vec<string>; \n/*? end \"typedefs.hpp\" */\n/*? begin \"alias.hpp\" */\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n/*? end \"alias.hpp\" */\n/*? begin \"util.hpp\" */\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,true);}\nTL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,true);}\n\n#ifndef __cpp_lib_exchange_function\n #define exchange exchange_RAB\n TL<TN T,TN U=T>IL T exchange(T& t, U&& u){T x=move(t);t=forward<U>(u);RT x;}\n#endif\n#ifndef __cpp_lib_clamp\n #define clamp clamp_RAB\n TL<TN T>IL CX CS T&clamp(CS T&a,CS T&mn,CS T&mx){RT a<mn?mn:a>mx?mx:a;}\n#endif\n\nTL<TN T>IL int size_RAB(T t){RT t.size();}\n#define size size_RAB\n\nTL<TN V>IL void uniq_after_sort(V&v){v.erase(unique(iter(v)),v.end());}\nTL<TN V>IL void sort_and_uniq(V&v){sort(iter(v));v.erase(unique(iter(v)),v.end());}\nTL<TN V,TN K>IL auto leftmost_ge(CS V&v,CS K&k){RT v.lower_bound(k);}\nTL<TN V,TN K>IL auto leftmost_gt(CS V&v,CS K&k){RT v.upper_bound(k);}\n\nnamespace rab{\n\nTL<TN V,TN W>IL void append(V&v,CS W&w){copy(PARABLE citer(w),back_inserter(v));}\n\nTL<TN V>IL auto flatten(CS V&xss,int reserve_size=0)->TN V::value_type{\n  decltype(flatten(xss))ret;\n  ret.reserve(reserve_size);\n  for(CS auto&xs:xss)append(ret,xs);\n  ret.shrink_to_fit();\n  RT move(ret);\n}\n\nTL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}\n\nTL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){RT 0<=i&&i<size(v)?v[i]:d;}\nTL<TN T>IL T fetch(CS T&d,CS vvec<T>&v,int i,int j){\n  RT 0<=i&&i<size(v)&&0<=j&&j<size(v[i])?v[i][j]:d;\n}\n// TL<TN T,TN U,TN...I>IL T fetch(CS T&d,CS vec<vec<U>>&v,int i,I...j){\n// RT 0<=i&&i<size(v)?fetch(d,v[i],j...):d;\n// }\nTL<TN T>struct Compressed{int size;map<T,int>zip;vec<T>unzip;};\nTL<TN T>IL Compressed<T>compressed(vec<T>v){\n  sort_and_uniq(v);map<T,int>zip;times(size(v),i)zip[v[i]]=i;RT{size(v),zip,move(v)};\n}\nTL<TN T>struct CompressedSrc{int size;map<T,int>zip;vec<T>unzip;WI src;};\nTL<TN T>IL CompressedSrc<T>compressed_src(CS vec<T>&v){\n  auto c=compressed(v);VI src(c.size);times(size(v),i)src[c.zip[v[i]]].PB(i);RT{c.size,c.zip,c.unzip,src};\n}\n\nstruct identity{TL<TN U>U operator()(U&&v)CS{RT v;}};\n}\n/*? end \"util.hpp\" */\n/*? begin \"debug.hpp\" */\nTL<class T>\nIL istream&operator>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nTL<class T>\nIL ostream&operator<<(ostream&,CS vec<T>&);\nTL<class T,class S>\nIL ostream&operator<<(ostream&,CS map<T,S>&);\n#define DEFINE_ITER_OUTPUT(s,x,sep){int i=0;for(CS auto&x##0_elem:x){if(i++)s<<sep;s<<x##0_elem;}RT s;}\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<T>&v)DEFINE_ITER_OUTPUT(s,v,' ')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS map<T,S>&m)DEFINE_ITER_OUTPUT(s,m,' ')\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<vec<T>>&w)DEFINE_ITER_OUTPUT(s,w,'\\n')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS vec<map<T,S>>&v)DEFINE_ITER_OUTPUT(s,v,'\\n')\n/*? end \"debug.hpp\" */\n\nsigned main(){\n {if(debug)cerr<<\"MOD: \"<<(MOD)ln;}\n if(!debug)cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\n cout<<fixed<<setprecision(20);\n cerr<<fixed<<setprecision(20);\n\n #ifdef GCJ_CASE\n  int T;cin>>T;\n  times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n #else\n  solve();\n #endif\n\n return 0;\n}\n/*? end \"base.hpp\" */\n/*? begin \"graph.hpp\" */\n/*? begin \"uf.hpp\" */\nTL<class T=int,class Adder=plus<T>,class Inverser=negate<T>>\nclass UnionFind{\n/*!\nhttp://noshi91.hatenablog.com/entry/2018/05/30/191943\nhttps://en.wikipedia.org/wiki/Disjoint-set_data_structure\nhttps://qiita.com/drken/items/cce6fc5c579051e64fab\n*/\nint n,*parents,*sizes;T*pot_diffs;bool to_delete;Adder adder;\nInverser inverser;\npublic:\nexplicit UnionFind(int n,bool to_delete=false):\nn(n),parents(new int[n]),sizes(new int[n]),pot_diffs(new T[n]),to_delete(to_delete)\n{clear();\n}\nvoid clear(){\ntimes(n,i)parents[i]=i;/*roots*/\nfill(sizes,sizes+n,1);fill(pot_diffs,pot_diffs+n,0);\n}\n~UnionFind(){if(to_delete){delete[]parents;delete[]sizes;delete[]pot_diffs;}}\nint size(){RT n;}\nint root(int i){int p=parents[i];\nif(p==i)RT i;/*`i`is a root*/\nint r=root(p);/*and pot_diffs[p]:=diff from root*/\npot_diffs[i]+=pot_diffs[p];parents[i]=r;RT r;\n}\nbool is_same(int i,int j){RT root(i)==root(j);}\nbool is_all_same(){int r=root(0);uptil(1,n,i)if(root(i)!=r)RT 0;RT 1;}\nbool merge(int i,int j,T pdiff=0){i=root(i);j=root(j);\nif(i==j)RT false;/*already merged*/\nif(sizes[i]>sizes[j]){swap(i,j);pdiff=inverser(pdiff);\n}\n/*now sizes[i]<=sizes[j]*/\nparents[i]=j;sizes[j]+=sizes[i];pot_diffs[i]=pdiff;RT true;\n}\nT diff(int i,int j){\nroot(i);/*pot_diffs[i]:=diff from root*/\nroot(j);/*pot_diffs[j]:=diff from root*/\nRT adder(pot_diffs[i],inverser(pot_diffs[j]));}};using unionfind=UnionFind<>;\n/*? end \"uf.hpp\" */\nTL<class EdgeVal>\nstruct Edge{int from;int to;EdgeVal weight;\nEdge(int from,int to,EdgeVal weight):from(from),to(to),weight(weight){}\nIL bool OP==(CS Edge&e)CS{RT weight==e.weight&&from==e.from&&to==e.to;}\nIL bool OP<(CS Edge&e)CS{RT weight<e.weight||(weight==e.weight&&(from<e.from||(from==e.from&&to<e.to)));}\nIL bool OP<=(CS Edge&e)CS{RT this==e||this<e;}\nIL bool OP>(CS Edge&e)CS{RT e<this;}\nIL bool OP>=(CS Edge&e)CS{RT e<=this;}};\nTL<class VtxVal,class EdgeVal>\nclass Graph{\nusing VoidWithoutEdgeVal=TN enable_if<is_default_constructible<EdgeVal>::value,void>::type;\nprotected:\nint nv_,nde_;unionfind uf;\npublic:\nvec<VtxVal>vs;vvec<Edge<EdgeVal>>edges;\nGraph(int nv):nv_(nv),nde_(0),uf(nv),vs(nv),edges(nv){}\nIL int nv()CS{RT nv_;}\nIL int nde()CS{RT nde_;}\nIL int nue()CS{RT nde_/2;}\nIL void add_dedge(int i,int j,CS EdgeVal&val){\nif(!rab::is_in(i,0LL,nv_)||!rab::is_in(j,0LL,nv_)){\ncerr<<\"invalid index:(\"<<i<<\",\"<<j<<\")for Graph(nv=\"<<nv_<<\")\" ln;\nexit(1);\n}\nedges[i].emplace_back(i,j,val);++nde_;\n}\nIL VoidWithoutEdgeVal add_dedge(int i,int j){add_dedge(i,j,EdgeVal());\n}\nIL void add_uedge(int i,int j,CS EdgeVal&val){add_dedge(i,j,val);\nadd_dedge(j,i,val);\n}\nIL VoidWithoutEdgeVal add_uedge(int i,int j){add_uedge(i,j,EdgeVal());\n}\nIL bool is_connected(){uf.clear();\nfor(CS auto&es:edges)for(CS auto&e:es)uf.merge(e.from,e.to);RT uf.is_all_same();\n}};\n/*? end \"graph.hpp\" */\n/*? begin \"flow.hpp\" */\n/*!Arihon,https://tubo28.me/algorithm/dinic/*/\nTL<TN F,TN V,TN E,TN CapFn=rab::identity>\n/*F:通常int,CapFn:E->F*/\nstruct dinic{int n,s,t;VI level,prog,que;\nWI edges;/*both direction*/\nvvec<F>cap,flow;\ndinic(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),level(n),prog(n),que(n+1),edges(n),cap(n,VI(n)),flow(n,VI(n))\n{times(n,i){for(auto&e:g.edges[i]){F c=capfn(e.weight);\ncap[i][e.to]+=c;cap[e.to][i]+=c;flow[e.to][i]+=c;edges[i].PB(e.to);\nedges[e.to].PB(i);\n}}}\nF exec(int s,int t){this->s=s;this->t=t;F mf=0;\nwhile(update_level(),level[t]>0){fill(iter(prog),0);mf+=find_paths(s,numeric_limits<F>::max()/8/*inf*/);\n}\nRT mf;\n}\nvoid update_level(){int ql=0,qr=0;fill(iter(level),-1);level[s]=0;\nque[qr++]=s;while(ql!=qr/*queue is not empty*/){int v=que[ql++];\nif(v==t)break;\nfor(int d:edges[v]){if(level[d]<0&&cap[v][d]!=flow[v][d]){level[d]=level[v]+1;\nque[qr++]=d;\n}}}}\nF find_paths(int v,int limit){if(v==t)RT limit;F diff=0;\nfor(;prog[v]<size(edges[v]);++prog[v]){int d=edges[v][prog[v]];\nif(cap[v][d]!=flow[v][d]&&level[v]<level[d]){F df=find_paths(d,min(limit,cap[v][d]-flow[v][d]));\nflow[v][d]+=df;flow[d][v]-=df;diff+=df;limit-=df;if(limit==0)break;\n}}\nRT diff;}};\n/*!Arihon,https://tubo28.me/algorithm/ford-fulkerson/*/\nTL<TN V,TN E,TN CapFn=rab::identity>\nstruct ford_fulkerson{int n,s,t;VC visited;\nWI edges;/*both direction*/\nprivate:\nHII cap_,flow_;\npublic:\nford_fulkerson(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),visited(n),edges(n)\n{times(n,i){for(auto&e:g.edges[i]){int c=capfn(e.weight);\ncap_[i<<32|e.to]+=c;cap_[e.to<<32|i]+=c;flow_[e.to<<32|i]+=c;edges[i].PB(e.to);\nedges[e.to].PB(i);\n}}}\nint cap(int a,int b)CS{RT cap_[a<<32|b];}\nint flow(int a,int b)CS{RT flow_[a<<32|b];}\nint exec(int s,int t){this->s=s;this->t=t;int mf=0;\nwhile(1){fill(iter(visited),false);int df=find_path(s,LLONG_MAX/8/*inf*/);if(df==0)RT mf;\nmf+=df;\n}}\nint find_path(int v,int limit){visited[v]=true;if(v==t)RT limit;\nfor(int d:edges[v]){if(!visited[d]){int c=cap_[v<<32|d],&f=flow_[v<<32|d];\nif(c-f>0){int df=find_path(d,min(limit,c-f));if(df>0){f+=df;flow_[d<<32|v]-=df;RT df;\n}}}}\nRT 0;}};\n/*? end \"flow.hpp\" */\nconstexpr int INF = 1ll << 50;\n\nvoid solve() {\n// HWH(\"S\")\n/* <foxy.memo-area> */\nint H;int W;cin>>H;cin>>W;VS S(H);times(H,Ri_0){cin>>S[Ri_0];}\n/* </foxy.memo-area> */\n\n  Graph<unit, int> g(H * W * 2 + 2);\n\n  int s = H * W * 2, t = H * W * 2 + 1;\n\n  #define inp(i, j) (((i) * W + (j)) * 2)\n  #define outp(i, j) (((i) * W + (j)) * 2 + 1)\n\n  times(H, i) times(W, j) {\n    g.add_dedge(inp(i, j), outp(i, j), 1);\n\n    if(S[i][j] == 'X') {\n      g.add_dedge(s, outp(i, j), INF);\n\n      if(i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n        cout << -1 ln;\n        return;\n      }\n    }\n  }\n\n  times(H, i) {\n    g.add_dedge(outp(i, 0), t, INF);\n    g.add_dedge(outp(i, W-1), t, INF);\n\n    times(W-1, j) {\n      g.add_dedge(outp(i, j), inp(i, j + 1), INF);\n      g.add_dedge(outp(i, j + 1), inp(i, j), INF);\n    }\n  }\n  times(W, j) {\n    g.add_dedge(outp(0, j), t, INF);\n    g.add_dedge(outp(H-1, j), t, INF);\n\n    times(H-1, i) {\n      g.add_dedge(outp(i, j), inp(i + 1, j), INF);\n      g.add_dedge(outp(i + 1, j), inp(i, j), INF);\n    }\n  }\n\n  ford_fulkerson<unit, int> d(g);\n  cout << d.exec(s, t) ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105],z[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#'&&z[i][j]=='X')return 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < int > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vll vector < ll >\n# define pii pair < int , int >\n# define mp make_pair\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    int n,m;\n    fi>>n>>m;\n    static char s[1024][1024];\n    for (int i = 1;i <= n;++i)\n        fi>>(s[i] + 1);\n    int ans = 0;\n    vector < pii > W;\n    for (int i = 1;i <= n;++i)\n        for (int j = 1;j <= m;++j)\n            if (s[i][j] == 'X')\n            {\n                if (i == 1 || i == n || j == 1 || j == m)\n                    return puts(\"-1\") * 0;\n                W.push_back({i,j});\n            }\n    for (int i = 1;i <= n;++i)\n        for (int j = 1;j <= m;++j)\n            if (s[i][j] != 'X')\n                s[i][j] = '#';\n    static int was[128][128];\n    const int dx[] = {1,0,-1,0};\n    const int dy[] = {0,1,0,-1};\n    function < int(int,int) > go = [&](int a,int b)\n    {\n        was[a][b] = 1;\n        int ok = 1;\n        for (int k = 0;k < 4;++k)\n        {\n            int na = a + dx[k];\n            int nb = b + dy[k];\n            if (!na || !nb || na == n + 1 || nb == m + 1) return 0;\n            if (!was[na][nb] && s[na][nb] == '.') ok &= go(na,nb);\n        }\n        return ok;\n    };\n    vector < pii > T;\n    for (int i = 1;i <= n;++i)\n        for (int j = 1;j <= m;++j)\n            T.push_back({i,j});\n    sort(T.begin(),T.end(),[&](pii a,pii b)\n         {\n            auto f = [&](pii a)\n            {\n                return min({a.x,n - a.x,a.y,m - a.y});\n            };\n            return f(a) > f(b);\n         });\n    for (auto it : T)\n    {\n        int i = it.x;\n        int j = it.y;\n        if (s[i][j] == '#')\n        {\n            s[i][j] = '.';\n            memset(was,0,sizeof(was));\n            int ok = 1;\n            for (auto it : W)\n                ok &= go(it.x,it.y);\n            if (!ok) s[i][j] = '#';\n        }\n    }\n    for (int i = 1;i <= n;++i)\n        for (int j = 1;j <= m;++j)\n            ans += s[i][j] == '#';\n    fo << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n\tif(r==100&&c==100)return 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans-9<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105];\nbool fr[105][105],vis[105][105],st,ad,f;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = f = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n//\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n//\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = f = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n//\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n//\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n){\n\t\trep(j,1,m)cout<<x[i][j];\n\t\tcout<<endl;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n \nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n \nconst int MAXH = 111;\nstring S[MAXH];\nbool need[MAXH][MAXH];\nbool memo[MAXH][MAXH];\n \nvoid debug(int H, int W) {\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cerr << need[i][j];\n        }\n        cerr << endl;\n    }\n    cerr << endl;\n}\n \nvoid no() {\n    cout << -1 << endl;\n    exit(0);\n}\n \nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int H, W;\n    cin >> H >> W;\n    for (int i = 0; i < H; i++)\n        cin >> S[i];\n    for (int i = 0; i < W; i++) {\n        if (S[0][i] == 'X' || S[H-1][i] == 'X') no();\n    }\n    for (int i = 0; i < H; i++) {\n        if (S[i][0] == 'X' || S[i][W-1] == 'X') no();\n    }\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (S[i][j] == 'X') {\n                for (int k = 0; k < 4; k++)\n                    if (S[i+dy[k]][j+dx[k]] != 'X') need[i+dy[k]][j+dx[k]] = true;\n            }\n        }\n    }\n    debug(H, W);\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (need[i][j]) {\n                queue<pii> que;\n                memset(memo, false, sizeof(memo));\n                memo[i][j] = true;\n                que.push(pii(i, j));\n                while (!que.empty()) {\n                    auto p = que.front(); que.pop();\n                    int y = p.first, x = p.second;\n                    for (int k = 0; k < 4; k++) {\n                        int ny = y+dy[k], nx = x+dx[k];\n                        if (ny < 0 || ny >= H || nx < 0 || nx >= W) continue;\n                        if (memo[ny][nx]) continue;\n                        if (need[ny][nx]) continue;\n                        memo[ny][nx] = true;\n                        que.push(pii(ny, nx));\n                    }\n                }\n                bool ng = true;\n                for (int y = 0; y < H; y++) {\n                    if (memo[y][0] || memo[y][W-1]) ng = false;\n                }\n                for (int x = 0; x < W; x++) {\n                    if (memo[0][x] || memo[H-1][x]) ng = false;\n                }\n                if (ng) {\n                    need[i][j] = false;\n                }\n            }\n        }\n    }\n    debug(H, W);\n \n    int ans = 0;\n    for (int i = 0; i < H; i++)\n        for (int j = 0; j < W; j++)\n            if (need[i][j]) ans++;\n \n    ans = min(ans, (H+W-2)*2);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&b) { if (a > b)a = b; }\ntemplate<class T> void cmax(T &a, const T&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\numap<ti3, ll> memo;\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//速度ではなくメモリ効率を考えるならrankのかわりにsizeを使う\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\nint main() {\n\tvi d = { 0,1,0,-1,0 };\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> s(h);\n\trep(i, h)cin >> s[i];\n\tbool err = 0;\n\tfor (auto a : s.front())if (a == 'X')err = 1;\n\tfor (auto a : s.back())if (a == 'X')err = 1;\n\tfor (auto &a : s) {\n\t\tif (a.back() == 'X' || a.front() == 'X')err = 1;\n\t}\n\tif (err) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tbool up2 = 1;\n\tbool up = 1;\n\twhile (up) {\n\t\tup = 0;\n\t\trep1(i, h - 2)rep1(j, w - 2) {\n\t\t\tif (s[i][j] != 'X') {\n\t\t\t\tint cnt = 0;\n\t\t\t\trep(k, 4)if (s[i + d[k]][j + d[k+1]] != '.' )cnt++;\n\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\tup = 1;\n\t\t\t\t\ts[i][j] = 'X';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[i][j] == 'X') {\n\t\t\t\trep(k, 4)if (s[i + d[k]][j + d[k+1]] == '.') {\n\t\t\t\t\ts[i + d[k]][j + d[k+1]] = '#';\n\t\t\t\t\tup = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0;\n\trep(i, h)rep(j, w)if (s[i][j] == '#')cnt++;\n\tint prev = cnt;\n\twhile (up2) {\n\t\tup2=0;\n\t\trep1(i, h - 2)rep1(j, w - 2) {\n\t\t\tauto s2(s);\n\t\t\tif (s[i][j] == '.') {\n\t\t\t\tint cnt = 0;\n\t\t\t\trep(k, 4)if (s2[i + d[k]][j + d[k + 1]] != '.')cnt++;\n\t\t\t\tif (cnt == 2) {\n\t\t\t\t\ts2[i][j] = 'X';\n\t\t\t\t}\n\t\t\t\telse continue;\n\t\t\t}\n\t\t\tup = 1;\n\t\t\twhile (up) {\n\t\t\t\tup = 0;\n\t\t\t\trep1(i, h - 2)rep1(j, w - 2) {\n\t\t\t\t\tif (s2[i][j] != 'X') {\n\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\trep(k, 4)if (s2[i + d[k]][j + d[k + 1]] != '.')cnt++;\n\t\t\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\t\t\tup = 1;\n\t\t\t\t\t\t\ts2[i][j] = 'X';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (s2[i][j] == 'X') {\n\t\t\t\t\t\trep(k, 4)if (s2[i + d[k]][j + d[k + 1]] == '.') {\n\t\t\t\t\t\t\ts2[i + d[k]][j + d[k + 1]] = '#';\n\t\t\t\t\t\t\tup = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt = 0;\n\t\t\trep(i, h)rep(j, w)if (s2[i][j] == '#')cnt++;\n\t\t\tif (cnt < prev)s = s2, prev = cnt, up2 = 1;\n\t\t}\n\t}\n\tcout << prev << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int vy[] = {0, 1, 0, -1}, vx[] = {1, 0, -1, 0};\n\nint H, W;\nstring S[100];\nbool v[100][100];\nbool flag[100][100];\n\nbool isover(int y, int x)\n{\n  return (y < 0 || y >= H || x < 0 || x >= W);\n}\n\nbool dfs(int y, int x)\n{\n\n\n  if(isover(y, x)) return (true);\n  if(v[y][x]++) return (false);\n  for(int i = 0; i < 4; i++) {\n    int ny = y + vy[i], nx = x + vx[i];\n    if(!isover(y, x) && flag[ny][nx] && S[ny][nx] == '.') continue;\n    if(dfs(ny, nx)) return (true);\n  }\n  return (false);\n}\n\nint main()\n{\n  cin >> H >> W;\n  for(int i = 0; i < H; i++) {\n    cin >> S[i];\n  }\n\n  for(int i = 0; i < H; i++) {\n    if(S[i][0] == 'X' || S[i][W - 1] == 'X') {\n      cout << -1 << endl;\n      return (0);\n    }\n  }\n  for(int i = 0; i < W; i++) {\n    if(S[0][i] == 'X' || S[H - 1][i] == 'X') {\n      cout << -1 << endl;\n      return (0);\n    }\n  }\n\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      for(int k = 0; k < 4; k++) {\n        if(S[i][j] == 'X') flag[i + vy[k]][j + vx[k]] = true;\n      }\n    }\n  }\n\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      flag[i][j] = false;\n      if(S[i][j] == 'X') continue;\n      bool judge = false;\n      memset(v, false, sizeof(v));\n      for(int k = 0; k < H; k++) {\n        for(int l = 0; l < W; l++) {\n          if(S[k][l] == 'X') judge |= dfs(k, l);\n        }\n      }\n      if(judge) flag[i][j] = true;\n    }\n  }\n\n  int ret = 0;\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      ret += flag[i][j];\n    }\n  }\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 105\n#define M 51\n#define INF 1000000007\n#define MOD 924844033\n#define MOD2 1000000009\n#define eps 1e-14\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,1,-1};\nstruct node\n{\n    int a,b,x,y;\n}edge[4*N*N];\nvector<int>e[4*N*N];\nint a[N][N],b[N][N],d[4*N*N];\nint bg,ed,cnt;\n\nbool bfs(int s)\n{\n       int front=0,rear=0;\n       int q[N];\n       memset(d,-1,sizeof(d));\n       q[rear++]=s;\n       d[s]=0;\n       while(front<rear)\n       {\n               int k=q[front++];\n               for(auto v:e[k])\n               {\n                   int a = edge[v].a,b = edge[v].b;\n                   int x = edge[v].x,y = edge[v].y;\n                   int flow,to;\n                   if(a == k)flow = x,to = b;\n                   else flow = y,to = a;\n                   if(flow>0&&d[to]==-1)\n                   {\n                       d[to]=d[k]+1;\n                       q[rear++]=to;\n                   }\n               }\n       }\n       if(d[ed]>=0)\n             return true;\n       return false;\n}\n\nint dinic(int k,int sum)  //k is the sourse\n{\n      if (k==ed)\n          return sum;\n      int os = sum;\n      for(auto v:e[k])\n      {\n          if(sum<=0)break;\n          int a = edge[v].a,b = edge[v].b;\n           int x = edge[v].x,y = edge[v].y;\n           int flow,to;\n           if(a == k)flow = x,to = b;\n           else flow = y,to = a;\n          if(d[to]==d[k]+1&&flow>0)\n          {\n                int tmp = dinic(to,min(sum,flow)); //Deep to the end.\n                if(a == k)\n                {\n                    edge[v].x -= tmp;\n                    edge[v].y += tmp;\n                }\n                else\n                {\n                    edge[v].y -= tmp;\n                    edge[v].x += tmp;\n                }\n                sum -= tmp;\n          }\n      }\n      return os-sum;\n}\n\nvoid addedge(int a,int b,int w)\n{\n    edge[++cnt].a = a;\n    edge[cnt].b = b;\n    edge[cnt].x = w;\n    edge[cnt].y = 0;\n    e[a].PB(cnt);\n    e[b].PB(cnt);\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    while(cin>>n>>m)\n    {\n        cnt = 0;\n        bg = 1,ed = n*m*2+1;\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                a[i][j] = i*m+j;\n                b[i][j] = i*m+j+n*m;\n            }\n        }\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                char c;\n                cin>>c;\n                if(c == 'X')\n                {\n                    addedge(a[i][j],b[i][j],INF);\n                    addedge(1,a[i][j],INF);\n                }\n                else addedge(a[i][j],b[i][j],1);\n            }\n        }\n        FOR(i,1,n)\n        {\n            addedge(b[i][1],ed,INF);\n            addedge(b[i][m],ed,INF);\n            FOR(j,1,m-1)addedge(b[i][j],a[i][j+1],INF);;\n            FOR(j,2,m)addedge(b[i][j],a[i][j-1],INF);\n        }\n        FOR(j,1,m)\n        {\n            addedge(b[1][j],ed,INF);\n            addedge(b[n][j],ed,INF);\n            FOR(i,1,n-1)addedge(b[i][j],a[i+1][j],INF);\n            FOR(i,2,n)addedge(b[i][j],a[i-1][j],INF);\n        }\n        int ret = 0;\n        while(bfs(bg))\n            ret += dinic(bg,INF);\n        if(ret == INF)cout<<-1<<endl;\n        else cout<<ret<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//諸機能\n#pragma region MACRO \n#define putans(x)  std::cerr << \"answer: \" ; cout << (x) << endl\n#define dputans(x) std::cerr << \"answer: \"; cout << setprecision(13) << (double)(x) << endl\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define RREP(i,a,n) for(int i=(int)(n-1); i>= a; i--)\n#define rep(i,n) REP(i,0,n)\n#define rrep(i,n) RREP(i,0,n)\n#define all(a) begin((a)),end((a))\n#define mp make_pair\n#define exist(container, n) ((container).find((n)) != (container).end())\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#ifdef _DEBUG //ファイルからテストデータを読み込む\nstd::ifstream ifs(\"data.txt\");\n#define put ifs >>\n#else //ジャッジシステムでいい感じにやる\n#define put cin >>\n#endif\n#pragma endregion\n\n//デバッグなどの支援\n#pragma region CODING_SUPPORT\n#define dbg(var0) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << endl; }\n#define dbg2(var0, var1) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg(var1); }\n#define dbg3(var0, var1, var2) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg2(var1, var2); }\n#define dbgArray(a,n) {std::cerr << (#a) << \"=\";  rep(i,n){std::cerr <<(a[i])<<\",\";} cerr<<endl;} \n#ifndef _DEBUG\n#define dbg1 {}\n#define dbg2 {}\n#define dbg3 {}\n#define dbgArray {}\n#endif \n#pragma endregion \n//typedef（書き換える、書き足す可能性ある）\n#pragma region TYPE_DEF\ntypedef long long ll;\ntypedef pair<int, int> pii; typedef pair<string, string> pss; typedef pair<int, string>pis;\ntypedef vector<string> vs; typedef vector<int> vi;\n#pragma endregion\n//諸々の定数(書き換える可能性ある)\n#pragma region CONST_VAL\n#define PI (2*acos(0.0))\n#define EPS (1e-10)\n#define MOD (ll)(1e9 + 7)\n#define INF (ll)(1e9)\n#pragma endregion\n\nclass Point {//幾何上のべクトル\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(x * a, y * a); }\n\tdouble operator * (Point p) { return dot(p); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n\n\tbool operator < (const Point &p) const { return  x != p.x ? x < p.x : y < p.y; }\n\tbool operator == (const Point &p) const { return  fabs(x - p.x) < EPS && fabs(y - p.y) < EPS; }\n\t//内積、外積\n\tdouble dot(Point p) { return x * p.x + y * p.y; }\n\tdouble cross(Point p) { return x * p.y - y * p.x; }\n\n\n};\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\nstruct Segment {//線分\n\tPoint p1, p2;\n};\n\ntypedef Point Vector;\ntypedef Segment Line;//直線\ntypedef vector<Point> Polygon;\n\ndouble v_norm(Point p) { return p.x * p.x + p.y * p.y; }\ndouble abs(Point p) { return v_norm(p); }\ndouble dot(Point p, Point q) { return p.x * q.x + p.y * q.y; }\ndouble cross(Point p, Point q) { return p.x * q.y - p.y * q.x; }\n\n\n\n\n\n//直行、並行\nbool isOrthogonal(Vector a, Vector b) { return equals(a*b, 0.0); }\nbool isParallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\n\n//線分sに対する点pの射影\nPoint projection(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(( p - s.p1 ), base) / v_norm(base);\n\treturn s.p1 + base*r;\n}\n//線分sに対する点pの反射\nPoint reflection(Segment s, Point p) { return p + ( projection(s, p) - p ) * 2; }\n\n\n\n\n//double getDistance(Point a, Point b) { return ( a - b ).abs; }\n//double getDistanceLP(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1)); }\n//double getDistanceSP(Segment s, Point p) {\n//\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n//\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n//}\n\n//double getDistance(Segment s1, Segment s2) {\n//\tif (intersect(s1, s2)) return 0;\n//\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2))\n//\t         , min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2));\n//}\n\n//p1-p0を基準として p2-p0 の2ベクトルについて\nstatic const int COUNTER_CLOCKWISE = 1;//反時計回り\nstatic const int CLOCKWISE = -1;//時計回り\nstatic const int ONLINE_BACK = 2;//同一直線状p2,p0,p1の順\nstatic const int ONLINE_FRONT = -2;//同一直線上p0,p1,p2の順\nstatic const int ON_SEGMENT = 0;//p2がp0,p1上にある場合\nint ccw(Point p0, Point p1, Point p2) {//上記の分類関数\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n////線分p1p2とp3p4の交差判定\n//bool intersect(Point p1, Point p2, Point p3, Point p4) {return ( (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0) && (ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0));}\n//bool intersect(Segment s1, Segment s2) {return intersect(s1.p1 , s1.p1, s2.p1, s2.p2);}\n//\n//Point getCrossPoint(Segment s1, Segment s2) {\n//\tVector base = s2.p2 - s2.p1;\n//\tdouble d1 = abs(cross(base , s1.p1 - s2.p1));\n//\tdouble d2 = abs(cross(base , s1.p2 - s2.p1));\n//\tdouble t = d1 / ( d1 + d2 );\n//\treturn s1.p1 + (s1.p2 - s1.p1 ) * t;\n//}\n//\n////直線と円の交点を調べる\n//pair<Point, Point> getCrossPoints(Circle c, Line l) {\n//\t//assert(intersect(c, i)); 交差しない場合についてのはず\n//\tVector pr = projection(c, l);\n//\tVector e = ( l.p2 - l.p1 ) / abs(l.p2 - l.p1);\n//\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n//\treturn mp(pr + e * base, pr - e * base);\n//}\n//\n////点の内包を調べる\n//static const int IN_POLYGON = 2;//多角形の内部\n//static const int OUT_POLYGON = 1;//多角形の外部\n//static const int ON_POLYGON = 0;//多角形の線分上\n//int contains(Polygon g, Point p) {\n//\tint n = g.size();\n//\tbool x = false;\n//\trep(i, n) {\n//\t\tPoint a = g[i] - p, b = g[( i + 1 ) % n] - p;\n//\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return OUT_POLYGON;\n//\t\tif (a.y > b.y) swap(a, b);\n//\t\tif (a.y < EPS && EPS < b.y && cross(a, b)) x = !x;\n//\t}\n//\treturn ( x ? IN_POLYGON : ON_POLYGON );\n//}\n\n//凸包\nPolygon ConvexHull(Polygon s) {\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tsort(s.begin(), s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\n\tfor (int i = 2; i < s.size(); i++) {\n\t\tfor (int n = u.size(); ( n >= 2 ) && ( ccw(u[n - 2], u[n - 1], s[i]) == COUNTER_CLOCKWISE ); n--) {\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\n\tfor (int i = s.size() - 3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) == COUNTER_CLOCKWISE; n--)l.pop_back();\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\n/*\n#define i(x) int x; scanf(\"%d\",&x);\n#define l(x) ll x; scanf(\"%lld\",&x);\n#define d(x) double  x; scanf(\"%lf\",&x);\n*/\n//今度実装がんばる\n//https://www23.atwiki.jp/akitaicpc/pages/65.html\n\n\nint main() {\n\t/*double xp1, yp1, xp2, yp2; put xp1 >> yp1 >> xp2 >> yp2;\n\tSegment s;\n\ts.p1 = Point(xp1, yp1);\n\ts.p2 = Point(xp2, yp2);\n\n\tint n; put n;\n\trep(i, n) {\n\t\tPoint p;\n\t\tput p.x >> p.y;\n\t\tPoint prj =reflection(s, p);\n\t\tcout << setprecision(13) << prj.x << \" \" << prj.y << endl;\n\t}*/\n\n\n\n\t//テンプレート化を来世に考える\n\tauto getI = [&]()->auto { int tmp; put tmp; return tmp; };\n\tauto getLL = [&]()->auto { ll tmp; put tmp; return tmp; };\n\tauto getS = [&]()->auto { string tmp; put tmp; return tmp; };\n\tbool filled[1000][1000];\n\tfill(*filled, *filled + 1000 * 1000, false);\n\tint vx[4] = { 1,0,-1,0 };\n\tint vy[4] = { 0,1,0,-1 };\n\tPolygon sheep;\n\tPolygon convex_sheep;\n\tint num = 0;\n\tint h, w; put h >> w;\n\trep(i, h) {\n\t\tstring s; put s;\n\t\trep(j, s.size()) {\n\t\t\tif (s[j] == 'X') {\n\t\t\t\tif (i == 0 || j == 0) {\n\t\t\t\t\tputans(-1);\n\t\t\t\t\tgoto END;\n\t\t\t\t}\n\t\t\t\trep(k, 4) {\n\t\t\t\t\tif (!filled[i + vx[k]][j + vy[k]]) {\n\t\t\t\t\t\tsheep.push_back(Point(i + vx[k],j + vy[k]));\n\t\t\t\t\t\tfilled[i + vx[k]][j + vy[k]] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tconvex_sheep = ConvexHull(sheep);\n\n\trep(i, convex_sheep.size()) {\n\t\tPoint s = convex_sheep[i % convex_sheep.size()];\n\t\tPoint g = convex_sheep[(i + 1) % convex_sheep.size()];\n\t\tint mandist = max(abs(s.x - g.x),abs(s.y - g.y));\n\t\tmax(1.0, abs(s.x - g.x)) + max(1.0, abs(s.y - g.y));\n\t\tnum += mandist;\n\t} \n\tputans(num);\nEND:\n\treturn 0;\n}\n\n//\n//int n, a, b; put n >> a >> b;\n//\tvi t;\n//\trep(i, n) {\n//\t\tt.push_back(get());\n//\t}\n//\tint count = 0;\n//\trep(i, n) {\n//\t\tif (t[i] < a || b <= t[i])count++;\n//\t}\n//\tputans(count);\n\n//\n//\tset<string> list;\n//\tint ans = 0;\n//\tint n; put n;\n//\tint k; put k;\n//\tint numAlphabet[26];\n//\tfill(all(numAlphabet), 0);\n//\trep(i, n) {\n//\t\tstring s; put s;\n//\t\tif (exist(list, s))continue;\n//\t\tlist.insert(s);\n//\t\tnumAlphabet[s[0] - 'A']++;\n//\t}\n//\tsort(all(numAlphabet),greater<int>());\n//\twhile (true) {\n//\t\trep(i, k) {\n//\t\t\tif (numAlphabet[i] == 0) goto END;\n//\t\t\telse numAlphabet[i]--;\n//\t\t}\n//\t\tsort(all(numAlphabet), greater<int>());\n//\t\tans++;\n//\t}\n//END:\n//\tputans(ans);\n\n\n\t//int t; put t;\n\t//rep(i, t) {\n\t//\tint n, d; put n >> d;\n\t//\tif (n == 1) {\n\t//\t\tputans(d);\n\t//\t\tcontinue;\n\t//\t}\n\t//\tputans(n % 2 != 0 ? ( n - 1 ) * 127 + d : ( n - 1 ) * 127 + ( 127 ^ d ));\n\t//}\n\n\n//\n//int n; put n;\n//string s1, s2;\n//string r;\n//string patan1[4] = { \".\",\"#\",\".\",\"#\" };\n//string patan2[4] = { \".\",\".\",\"#\",\"#\" };\n//bool front = true;\n//rep(j, 420 / 4) {\n//\tif (front) {\n//\t\trep(i, 4) {\n//\t\t\tcout << s1 + patan1[i] + \"\\n\" << s2 + patan2[i] << endl;\n//\t\t\tcin >> r;\n//\t\t\tif (r == \"T\") {\n//\t\t\t\ts1 += patan1[i];\n//\t\t\t\ts2 += patan2[i];\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t\tif (r == \"F\" && i == 3) {\n//\t\t\t\tfront = !front;\n//\t\t\t}\n//\t\t\tif (r == \"end\")goto END;\n//\t\t}\n//\t}\n//\telse {\n//\t\trep(i, 4) {\n//\t\t\tcout << patan1[i] + s1 + \"\\n\" << patan2[i] + s2 << endl;\n//\t\t\tcin >> r;\n//\t\t\tif (r == \"T\") {\n//\t\t\t\ts1 = patan1[i] + s1;\n//\t\t\t\ts2 = patan2[i] + s2;\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t\tif (r == \"F\" && i == 3) {\n//\t\t\t\tfront = !front;\n//\t\t\t}\n//\t\t\tif (r == \"end\")goto END;\n//\t\t}\n//\t}\n//\n//}\n//END:\n//cout << endl;\n\n\n////CGL_4_A : Convex Hull;\n\t//int n; put n;\n\t//Polygon p;\n\t//rep(i, n) {\n\t//\tdouble x, y; put x >> y;\n\t//\tp.push_back(Point(x, y));\n\t//}\n\t//Polygon k = ConvexHull(p);\n\t//double tmpMax = 100000000.0;\n\t//int rotIndex = 0;\n\t//rep(i, k.size()) {\n\t//\tif (k[i].y < tmpMax) {\n\t//\t\trotIndex = i;\n\t//\t\ttmpMax = k[i].y;\n\t//\t}\n\t//}\n\t//rotate(k.begin(),k.begin() + rotIndex,k.end());\n\t//cout << k.size() << endl;\n\t//rep(i, k.size()) {\n\t//\tcout << k[i].x << \" \" << k[i].y << endl;\n\t//}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int vv[] = {-1, 0, 1, 0};\n\nvoid F()\n{\n  cout << -1 << endl;\n  exit(0);\n}\n\nint H, W;\nstring S[100];\nbool flag[100][100];\nbool counted[100][100];\nbool used[100][100];\nvector< vector< int > > graph;\nint ret = 0;\n\nvoid dfs(int y, int x)\n{\n  if(used[y][x]++) return;\n  for(int i = 0; i < 4; i++) {\n    int nx = x + vv[i];\n    int ny = y + vv[i ^ 1];\n    if(nx < 0 || nx >= W || ny < 0 || ny >= H) continue;\n    if(flag[ny][nx]) {\n      ret += 1 - counted[ny][nx]++;\n      continue;\n    }\n    dfs(ny, nx);\n  }\n}\n\nint main()\n{\n  cin >> H >> W;\n  for(int i = 0; i < H; i++) {\n    cin >> S[i];\n  }\n\n  for(int i = 0; i < W; i++) {\n    if(S[0][i] == 'X') F();\n    if(S[H - 1][i] == 'X') F();\n  }\n  for(int i = 0; i < H; i++) {\n    if(S[i].front() == 'X') F();\n    if(S[i].back() == 'X') F();\n  }\n\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      if(S[i][j] == 'X') {\n        for(int k = 0; k < 4; k++) {\n          flag[i + vv[k]][j + vv[k ^ 1]] = true;\n        }\n      }\n    }\n  }\n\n\n  for(int i = 0; i < H; ++i) {\n    if(!flag[0][i]) dfs(0, i);\n    if(!flag[H - 1][i]) dfs(H - 1, i);\n  }\n  for(int i = 0; i < W; i++) {\n    if(!flag[i][0]) dfs(i, 0);\n    if(!flag[i][W - 1]) dfs(i, W - 1);\n  }\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 105\n#define M 51\n#define INF 1000000007\n#define MOD 924844033\n#define MOD2 1000000009\n#define eps 1e-14\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,1,-1};\nstruct node\n{\n    int a,b,x,y;\n}edge[20*N*N];\nvector<int>e[20*N*N];\nint a[N][N],b[N][N],d[20*N*N];\nint bg,ed,cnt;\n\nbool bfs(int s)\n{\n       int front=0,rear=0;\n       int q[N];\n       memset(d,-1,sizeof(d));\n       q[rear++]=s;\n       d[s]=0;\n       while(front<rear)\n       {\n               int k=q[front++];\n               for(auto v:e[k])\n               {\n                   int a = edge[v].a,b = edge[v].b;\n                   int x = edge[v].x,y = edge[v].y;\n                   int flow,to;\n                   if(a == k)flow = x,to = b;\n                   else flow = y,to = a;\n                   if(flow>0&&d[to]==-1)\n                   {\n                       d[to]=d[k]+1;\n                       q[rear++]=to;\n                   }\n               }\n       }\n       if(d[ed]>=0)\n             return true;\n       return false;\n}\n\nint dinic(int k,int sum)  //k is the sourse\n{\n      if (k==ed)\n          return sum;\n      int os = sum;\n      for(auto v:e[k])\n      {\n          if(sum<=0)break;\n          int a = edge[v].a,b = edge[v].b;\n           int x = edge[v].x,y = edge[v].y;\n           int flow,to;\n           if(a == k)flow = x,to = b;\n           else flow = y,to = a;\n          if(d[to]==d[k]+1&&flow>0)\n          {\n                int tmp = dinic(to,min(sum,flow)); //Deep to the end.\n                if(a == k)\n                {\n                    edge[v].x -= tmp;\n                    edge[v].y += tmp;\n                }\n                else\n                {\n                    edge[v].y -= tmp;\n                    edge[v].x += tmp;\n                }\n                sum -= tmp;\n          }\n      }\n      return os-sum;\n}\n\nvoid addedge(int a,int b,int w)\n{\n    edge[++cnt].a = a;\n    edge[cnt].b = b;\n    edge[cnt].x = w;\n    edge[cnt].y = 0;\n    e[a].PB(cnt);\n    e[b].PB(cnt);\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    while(cin>>n>>m)\n    {\n        cnt = 0;\n        bg = 1,ed = n*m*2+1;\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                a[i][j] = i*m+j;\n                b[i][j] = i*m+j+n*m;\n            }\n        }\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                char c;\n                cin>>c;\n                if(c == 'X')\n                {\n                    addedge(a[i][j],b[i][j],INF);\n                    addedge(1,a[i][j],INF);\n                }\n                else addedge(a[i][j],b[i][j],1);\n            }\n        }\n        FOR(i,1,n)\n        {\n            addedge(b[i][1],ed,INF);\n            addedge(b[i][m],ed,INF);\n            FOR(j,1,m-1)addedge(b[i][j],a[i][j+1],INF);;\n            FOR(j,2,m)addedge(b[i][j],a[i][j-1],INF);\n        }\n        FOR(j,1,m)\n        {\n            addedge(b[1][j],ed,INF);\n            addedge(b[n][j],ed,INF);\n            FOR(i,1,n-1)addedge(b[i][j],a[i+1][j],INF);\n            FOR(i,2,n)addedge(b[i][j],a[i-1][j],INF);\n        }\n        int ret = 0;\n        while(bfs(bg))\n            ret += dinic(bg,INF);\n        if(ret == INF)cout<<-1<<endl;\n        else cout<<ret<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mem(x,n) memset(x,n,sizeof(x))\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,l) for(auto it=(l).begin();it!=(l).end();it++)\n#define pnl printf(\"\\n\")\n#define len(x) (x).length()\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\nconst double EPS=1e-10;\n//const double PI=acos(-1.0);\nconst int INF=1<<30;\nconst LL LLINF=1ll<<60;\nconst int MOD=1e9+7;\nconst int xx[8]={1,0,-1,0,1,-1,1,-1};\nconst int yy[8]={0,1,0,-1,-1,1,1,-1};\n\n/****************************************************************************************\\\n  __    __               __ /\\/|   ___ _           _       /\\/|__               __    __\n  \\ \\  / /  _____ __ ____\\ \\/\\/   / __| |__ _ _ __(_)___  |/\\// /____ __ _____  \\ \\  / /\n   \\ \\| |  |___\\ V  V /___| |    | (__| / _` | '_ \\ / -_)    | |___\\ V  V /___|  | |/ /\n    \\_\\ |  |___|\\_/\\_/|___| |     \\___|_\\__,_| .__/_\\___|    | |___|\\_/\\_/|___|  | /_/\n       \\_\\               /_/                 |_|              \\_\\               /_/\n\\****************************************************************************************/\n\nstruct edge{\n\tint v, bf;\n\tLL flow;\n};\n\nconst int MAXN = 205;\nvector<edge> adj[MAXN];\nint lvl[MAXN], st[MAXN];\nint idx[105][105],idx1[105][105];\nconst int sink = 203, source = 204;\nchar input[105][105];\n\nvoid addedge(int u,int v,LL flow){\n\tadj[u].pb({v,sz(adj[v]),flow});\n\tadj[v].pb({u,sz(adj[u]),0});\n}\n\nbool bfs(int S,int G){\n\tqueue<int> q;\n\tmem(lvl,-1);\n\tq.push(S); lvl[S]=0;\n\twhile(!q.empty()){\n\t\tint u = q.front(); q.pop();\n\t\tfor(int i=0;i<sz(adj[u]);i++){\n\t\t\tint v = adj[u][i].v;\n\t\t\tLL flow = adj[u][i].flow;\n\t\t\tif(lvl[v]!=-1||flow<=0) continue;\n\t\t\tlvl[v]=lvl[u]+1;\n\t\t\tq.push(v);\n\t\t}\n\t}\n\treturn (lvl[G]!=-1);\n}\n\nLL dfs(int u,LL mini,int G){\n\tif(u==G) return mini;\n\t\n\tfor(int i=st[u];i<sz(adj[u]);i++){\n\t\tst[u]=i;\n\t\tint v = adj[u][i].v;\n\t\tLL flow = adj[u][i].flow;\n\t\tif(flow<=0||(lvl[v]-lvl[u]!=1)) continue;\n\t\tLL ret=dfs(v,min(mini,flow),G);\n\t\tif(ret>0){\n\t\t\tadj[u][i].flow-=ret;\n\t\t\tint bvf = adj[u][i].bf;\n\t\t\tadj[v][bvf].flow+=ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nLL maxflow(int S,int G){\n\tLL ret=0;\n\twhile(1){\n\t\tif(!bfs(S,G)) break;\n\t\tLL flow = 0;\n\t\tmem(st,0);\n\t\twhile((flow=dfs(S, LLINF, G))>0){\n\t\t\tret+=flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint r,c;\n\tscanf(\"%d%d\",&r,&c);\n\tgetchar();\n\tfor(int i=0;i<r;i++){\n\t\tscanf(\"%s\",input[i]);\n\t}\n\t\n\tint temp=0;\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tidx[i][j]=temp;\n\t\t\tidx1[i][j]=temp+100;\n\t\t\ttemp++;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(input[i][j]=='.'){\n\t\t\t\taddedge(idx[i][j],idx1[i][j],1);\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\taddedge(idx1[i][j],sink,INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\taddedge(source,idx[i][j],INF);\n\t\t\t\taddedge(idx[i][j],idx1[i][j],INF);\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int ii=0;ii<4;ii++){\n\t\t\t\tint tempx = i+xx[ii];\n\t\t\t\tint tempy = j+yy[ii];\n\t\t\t\t\n\t\t\t\tif(tempx<0||tempx>=c||tempy<0||tempy>=r) continue;\n\t\t\t\taddedge(idx1[i][j],idx[tempx][tempy],INF); \n\t\t\t}\n\t\t}\n\t}\n\t\n\tLL ans = maxflow(source,sink);\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cap, rev;\n    Edge(){};\n    Edge(int to0, int cap0){to = to0; cap = cap0;}\n    Edge(int to0, int cap0, int rev0){to = to0; cap = cap0; rev = rev0;}\n};\n\nint maxFlow(const vector<vector<Edge> >& edges0, int source, int sink)\n{\n    static vector<vector<Edge> > edges;\n    static vector<unsigned> index;\n    static vector<int> level;\n    static int n;\n\n    class Func{\n    public:\n        static void bfs(int s){\n            level.assign(n, -1);\n            queue<int> q;\n            level[s] = 0;\n            q.push(s);\n            while(!q.empty()){\n                int v = q.front();\n                q.pop();\n                for(unsigned i=0; i<edges[v].size(); ++i){\n                    Edge& e = edges[v][i];\n                    if(e.cap > 0 && level[e.to] < 0){\n                        level[e.to] = level[v] + 1;\n                        q.push(e.to);\n                    }\n                }\n            }\n        }\n        static int dfs(int s, int t, int f){\n            if(s == t)\n                return f;\n            for(unsigned& i=index[s]; i<edges[s].size(); ++i){\n                Edge& e = edges[s][i];\n                if(e.cap > 0 && level[s] < level[e.to]){\n                    int g = dfs(e.to, t, min(f, e.cap));\n                    if(g > 0){\n                        e.cap -= g;\n                        edges[e.to][e.rev].cap += g;\n                        return g;\n                    }\n                }\n            }\n            return 0;\n        }\n    };\n\n    if(source == sink)\n        return INT_MAX;\n\n    n = edges0.size();\n    edges.assign(n, vector<Edge>());\n    for(int i=0; i<n; ++i){\n        for(unsigned j=0; j<edges0[i].size(); ++j){\n            const Edge& e = edges0[i][j];\n            edges[i].push_back(Edge(e.to, e.cap, edges[e.to].size()));\n            edges[e.to].push_back(Edge(i, 0, edges[i].size()-1));\n        }\n    }\n\n    int ret = 0;\n    for(;;){\n        Func::bfs(source);\n        if(level[sink] < 0)\n            return ret;\n        index.assign(n, 0);\n        int f;\n        while((f = Func::dfs(source, sink, INT_MAX)) > 0)\n            ret += f;\n    }\n}\n\nconst int INF = 20000;\nconst int dy[] = {-1, 1, 0, 0};\nconst int dx[] = {0, 0, -1, 1};\n\nint main()\n{\n    int h, w;\n    cin >> h >> w;\n\n    vector<vector<Edge> > edges(h*w*2+2);\n    int source = h * w * 2;\n    int sink = h * w * 2 + 1;\n    for(int y=0; y<h; ++y){\n        for(int x=0; x<w; ++x){\n            int i = y * h + x;\n            for(int k=0; k<4; ++k){\n                int y2 = y + dy[k];\n                int x2 = x + dx[k];\n                if(!(0 <= y2 && y2 < h && 0 <= x2 && x2 < w))\n                    continue;\n                int j = y2 * h + x2;\n                edges[2*i+1].push_back(Edge(2*j, INF));\n            }\n            if(y == 0 || y == h - 1 || x == 0 || x == w - 1)\n                edges[2*i+1].push_back(Edge(sink, INF));\n\n            char c;\n            cin >> c;\n            if(c == 'X'){\n                edges[source].push_back(Edge(2*i, INF));\n                edges[2*i].push_back(Edge(2*i+1, INF));\n            }\n            else{\n                edges[2*i].push_back(Edge(2*i+1, 1));\n            }\n        }\n    }\n\n    int ans = maxFlow(edges, source, sink);\n    if(ans < INF)\n        cout << ans << endl;\n    else\n        cout << -1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#line 1 \"base.hpp\"//5\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve(\n#ifdef GCJ_CASE\nlong long case_id\n#endif\n);\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n#define debug true\n#define _GLIBCXX_DEBUG\n// #define _LIBCPP_DEBUG 0\n#define _LIBCPP_DEBUG2 0\n#else\n#define NDEBUG\n#define debug false\n#endif\n#include<algorithm>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<type_traits>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL\n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define rep(f,t,i,c,u)for(int Rb_=(t),i=(f);i c Rb_;u(i))\n#define upto(f,t,i)rep(f,t,i,<=,++)\n#define uptil(f,t,i)rep(f,t,i,<,++)\n#define downto(f,t,i)rep(f,t,i,>=,--)\n#define downtil(f,t,i)rep(f,t,i,>,--)\n#define times(n,i)uptil(0,n,i)\n#define rtimes(n,i)downto((n)-1,0,i)\n#define iter(v)begin(v),end(v)\n#define citer(v)cbegin(v),cend(v)\n#define riter(v)rbegin(v),rend(v)\n#define criter(v)crbegin(v),crend(v)\n#define IF(a,b,c)((a)?(b):(c))\n#if debug\n#define ln <<endl\n#else\n#define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n#line 1 \"base_util.hpp\"//5b\n#define BINOPa(t,u,op)t OP op(CS u&o)CS{RT t(*this)op##=o;}\n#define CMPOP(t,op,f1,f2,x)bool OP op(CS t&x)CS{RT f1 op f2;}\n#define CMPOPS(t,f1,f2,x)CMPOP(t,==,f1,f2,x)CMPOP(t,!=,f1,f2,x)\\\nCMPOP(t,<,f1,f2,x)CMPOP(t,<=,f1,f2,x)CMPOP(t,>,f1,f2,x)CMPOP(t,>=,f1,f2,x)\n#line 1 \"mod.hpp\"//5b\n#ifndef MOD\n#define MOD 1000000007\n#endif\n#if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n#error mod\n#endif\n#line 1 \"power.hpp\"//5bm\nTL<TN T>IL T power(T x,int n){T r(1);for(;n;n/=2){if(n%2)r*=x;x*=x;}RT r;}IL int pow_mod(int x,int n,int m){int r=1;\nfor(;n;n/=2){if(n%2)r=r*x%m;x=x*x%m;}RT r;}\n#line 2001 \"mod.hpp\"//5b\nIL CX int modulo(int a,int b){a%=b;RT a&&(a>0)!=(b>0)?a+b:a;}IL CX int divide(int a,int b){RT(a-modulo(a,b))/b;}\nTL<int d=MOD>struct MInt{\n/*!https://ei1333.github.io/luzhiled/snippets/other/mod-int.html*/\nint v;CX MInt():v(0){}explicit CX MInt(int i):v(modulo(i,d)){}MInt&OP+=(CS MInt&m){v+=m.v;if(v>=d)v-=d;RT*this;}\nMInt&OP-=(CS MInt&m){v-=m.v;if(v<0)v+=d;RT*this;}MInt&OP*=(CS MInt&m){v=v*m.v%d;RT*this;}MInt&OP/=(CS MInt&m){\nRT*this*=m.inv();}BINOPa(MInt,MInt,+)BINOPa(MInt,MInt,-)BINOPa(MInt,MInt,*)BINOPa(MInt,MInt,/)MInt OP-()CS{\nRT MInt()-=*this;}CMPOP(MInt,==,v,m.v,m)CMPOP(MInt,!=,v,m.v,m)MInt pow(int n)CS{RT power(*this,n);}MInt inv()CS{\nint a=v,b=d,x=1,y=0;while(b){swap(y,x-=a/b*y);swap(b,a%=b);}RT(MInt)x;}\nfriend ostream&OP<<(ostream&o,CS MInt&m){RT o<<m.v;}friend istream&OP>>(istream&i,MInt&m){i>>m.v;m.v%=d;RT i;}};\nusing mint=MInt<>;CX mint OP\"\" _m(ULL n){RT mint(n);}CX MInt<998244353>OP\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nCX MInt<1000000007>OP\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nCX MInt<1000000009>OP\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n#line 1 \"typedefs.hpp\"//5b\nusing unit = tuple<>;using int128=__int128;using LD=long double;TL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;TL<TN T>using vvvec=vec<vvec<T>>;TL<TN T>using vvvvec=vec<vvvec<T>>;\nusing VI=vec<int>;using VS=vec<string>;\n#line 1 \"alias.hpp\"//5b\n#define EB emplace_back\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n#line 1 \"util.hpp\"//5b\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,1);}TL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,1);}\nTL<TN T>IL int sizeRAB(T t){RT t.size();}\n#define size sizeRAB\n#define clamp clampRAB\nTL<TN T>IL CX CS T&clamp(CS T&a,CS T&l,CS T&r){RT a<l?l:r<a?r:a;}TL<TN V>IL void uniq2(V&v){\nv.erase(unique(iter(v)),v.end());}TL<TN V>IL void uniq(V&v){sort(iter(v));uniq2(v);}\n#define leftmost_ge lower_bound\n#define leftmost_gt upper_bound\nnamespace rab{TL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}TL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){\nRT 0<=i&&i<size(v)?v[i]:d;}}\n#line 1 \"debug.hpp\"//5b\nTL<TN T>IL istream&OP>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}TL<TN T,TN S>\nIL ostream&OP<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\n#define Rdebug1(sep, ...)IL ostream& OP<<(ostream&s,CS __VA_ARGS__&v){\\\nint i=0;for(CS auto&e:v){i++&&s<<sep;s<<e;}RT s;}\nTL<TN T>Rdebug1(' ',vec<T>)TL<TN T,TN S>Rdebug1(' ',map<T,S>)TL<TN T>Rdebug1('\\n',vvec<T>)\nTL<TN T,TN S>Rdebug1('\\n',vec<map<T,S>>)\n#line 6001 \"base.hpp\"//5\nsigned main(){if(debug)cerr<<\"MOD: \"<<MOD ln;else cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\nauto p=setprecision(20);cout<<fixed<<p;cerr<<fixed<<p;\n#ifdef GCJ_CASE\nint T;cin>>T;times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n#else\nsolve();\n#endif\nRT 0;}\n#line 1 \"graph.hpp\"//5\nTL<TN E>struct Edge{int from;int to;E weight;Edge(int from,int to,E weight):from(from),to(to),weight(weight){}\nCMPOPS(Edge,make_tuple(weight,from,to),make_tuple(e.weight,e.from,e.to),e)};TL<TN E>class Graph{protected:int nv_,nde_;\npublic:vvec<Edge<E>>edges;Graph(int nv):nv_(nv),nde_(0),edges(nv){}IL int nv()CS{RT nv_;}IL int nde()CS{RT nde_;}\nIL int nue()CS{RT nde_/2;}IL void add_dedge(int i,int j,CS E&val){if(debug&&(i<0||nv_<=i||j<0||nv_<=j)){\ncerr<<\"invalid index:(\"<<i<<\",\"<<j<<\")for Graph(nv=\"<<nv_<<\")\" ln;exit(1);}edges[i].emplace_back(i,j,val);++nde_;}\nIL void add_uedge(int i,int j,CS E&val){add_dedge(i,j,val);add_dedge(j,i,val);}};\n#line 1 \"util_identity.hpp\"//5f\nstruct identity{TL<TN U>U OP()(U&&v)CS{RT v;}};\n#line 3001 \"flow.hpp\"//5\n/*!Arihon,https://tubo28.me/algorithm/dinic/,http://topcoder.g.hatena.ne.jp/Mi_Sawa/20140311*/\nTL<TN F,TN E,TN CapFn=identity>class dinic{public:struct FlowEdge{CS int from,to,nxt;CS F cap;F flow;\nFlowEdge(int from,int to,int nxt,F cap,F flow):from(from),to(to),nxt(nxt),cap(cap),flow(flow){}};int n,s,t;\nVI level,prog,que,heads;vec<FlowEdge>edges;dinic(CS Graph<E>&g,CS CapFn&capfn=identity()):\nn(g.nv()),s(-1),t(-1),level(n),prog(n),que(n),heads(n){fill(iter(heads),-1);edges.reserve(g.nde()*2);int edges_i=0;\ntimes(n,i){for(auto&e:g.edges[i]){F c=capfn(e.weight);edges.EB(i,e.to,heads[i],c,(F)0);heads[i]=edges_i;++edges_i;\nedges.EB(e.to,i,heads[e.to],c,c);heads[e.to]=edges_i;++edges_i;}}}F exec(int s,int t){this->s=s;this->t=t;\nF mf=0,inf=numeric_limits<F>::max()/8;while(update_level(),level[s]){copy(iter(heads),begin(prog));\nmf+=find_paths(s,inf);}RT mf;}private:void update_level(){int ql=0,qr=0;fill(iter(level),0);level[t]=n;que[qr++]=t;\nwhile(ql!=qr){int v=que[ql++];if(v==s)RT;for(int i=heads[v];~i;i=edges[i].nxt){CS auto&e=edges[i];\nif(!level[e.to]&&e.flow!=0){level[e.to]=level[v]-1;que[qr++]=e.to;}}}}F find_paths(int v,int limit){if(v==t)RT limit;\nF diff=0;for(int i=prog[v];~i;i=prog[v]=edges[i].nxt){auto&e=edges[i];if(level[v]<level[e.to]&&e.cap!=e.flow){\nF df=find_paths(e.to,min(limit,e.cap-e.flow));e.flow+=df;edges[i^1].flow-=df;diff+=df;limit-=df;if(limit==0)break;}}\nRT diff;}};\n#line 3001 \"5.cpp\"//\nconstexpr int INF = 401;\n\nvoid solve() {\n// HWH(\"S\")\n/* <foxy.memo-area> */\nint H;int W;cin>>H;cin>>W;VS S(H);times(H,Ri_0){cin>>S[Ri_0];}\n/* </foxy.memo-area> */\n\n  Graph<int> g(H * W * 2 + 2);\n\n  int s = H * W * 2, t = H * W * 2 + 1;\n\n  #define inp(i, j) (((i) * W + (j)) * 2)\n  #define outp(i, j) (((i) * W + (j)) * 2 + 1)\n\n  times(H, i) times(W, j) {\n    g.add_dedge(inp(i, j), outp(i, j), 1);\n\n    if(S[i][j] == 'X') {\n      g.add_dedge(s, outp(i, j), INF);\n\n      if(i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n        cout << -1 ln;\n        return;\n      }\n    }\n  }\n\n  times(H, i) {\n    g.add_dedge(outp(i, 0), t, INF);\n    g.add_dedge(outp(i, W-1), t, INF);\n\n    times(W-1, j) {\n      g.add_dedge(outp(i, j), inp(i, j + 1), INF);\n      g.add_dedge(outp(i, j + 1), inp(i, j), INF);\n    }\n  }\n  times(W, j) {\n    g.add_dedge(outp(0, j), t, INF);\n    g.add_dedge(outp(H-1, j), t, INF);\n\n    times(H-1, i) {\n      g.add_dedge(outp(i, j), inp(i + 1, j), INF);\n      g.add_dedge(outp(i + 1, j), inp(i, j), INF);\n    }\n  }\n\n  dinic<int, int> d(g);\n  cout << d.exec(s, t) ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <random>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\n\ntypedef\ntree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> orderedSet;\n\n#define pb push_back\n#define F first\n#define S second\n#define all(a) (a).begin(), (a).end()\n\n#define for1(i0, l0, r0) for (int i0 = l0; i0 < r0; ++i0)\n#define for2(i0, l0, r0) for (int i0 = l0; i0 <= r0; ++i0)\n#define forn(i0, n0) for (int i0 = 0; i0 < n0; ++i0)\n#define forn1(i0, n0) for (int i0 = 1; i0 < n0; ++i0)\n#define forr(i0, n0) for (int i0 = n0; i0 >= 0; --i0)\n#define forr1(i0, r0, l0) for (int i0 = r0; i0 > l0; --i0)\n#define forr2(i0, r0, l0) for (int i0 = r0; i0 >= l0; --i0)\n\n#define Sort(a) sort(all(a))\n#define Reverse(a) reverse(all(a))\n\ntypedef long double ld;\n#define ui unsigned int\n#define ull unsigned long long\n\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef pair<string, string> pss;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<ld> vld;\ntypedef vector<bool> vb;\ntypedef vector<string> vs;\n\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\n\ntypedef vector<vi> vvi;\ntypedef vector<vd> vvd;\ntypedef vector<vll> vvll;\ntypedef vector<vb> vvb;\n\n#define vpss vector<pss>\n#define vvs vector<vs>\n#define vvpii vector<vpii>\n#define vvpll vector<vpll>\n#define vpt vector<pt>\n#define vvvi vector<vvi>\n#define vsi vector<set<int>>\n#define ss second\n#define ff first\n\n#define printvi(arr) for (int x0 : arr) cout << x0 << ' '; cout << '\\n';\n#define printvll(arr) for (ll x0 : arr) cout << x0 << ' '; cout << '\\n';\n#define printpair(pair0) cout << pair0.F << ' ' << pair0.S << '\\n';\n#define printvp(arr) for (auto pair0 : arr) printpair(pair0);\n#define initArray(arr, N0, X0) memset(arr, X0, N0 * sizeof(int))\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid init() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    //cout.precision(16);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n}\n\nconst int inf = 1e9;\nconst int maxn = 20005;\nconst int N = 10000;\n\nstruct edge {\n    int t, c, r;\n};\n\nvector<edge> G[maxn];\nbool used[maxn];\n\nvoid add_edge(int v, int u, int c = 1) {\n    G[v].push_back((edge) {u, c, (int) G[u].size()});\n    G[u].push_back((edge) {v, 0, (int) G[v].size() - 1});\n}\n\nvoid connect(int v, int u, int c = 1) {\n    add_edge(v, u + N, c);\n    add_edge(u, v + N, c);\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (auto &it: G[v])\n        if (!used[it.t] && it.c) {\n            int d = dfs(it.t, t, min(f, it.c));\n            if (d) {\n                it.c -= d;\n                G[it.t][it.r].c += d;\n                return d;\n            }\n        }\n    return 0;\n}\n\nint maxFlow(int s, int t) {\n    int res = 0, f = 1;\n    while (f) {\n        fill(used, used + maxn, 0);\n        f = dfs(s, t, inf);\n        res += f;\n    }\n    return res;\n}\n\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    vs a(n);\n    forn(i, n) cin >> a[i];\n    forn(i, n) {\n        forn(j, m) {\n            if (i == 0 || j == 0 || i == n - 1 || j == m - 1) {\n                if (a[i][j] == 'X') {\n                    cout << \"-1\\n\";\n                    return;\n                }\n            }\n        }\n    }\n    int I = 2 * N, J = I + 1;\n    vi dx = {0, 0, 1, -1}, dy = {1, -1, 0, 0};\n    forn(i, n) {\n        forn(j, m) {\n            add_edge(i * m + j + N, i * m + j, (a[i][j] == 'X' ? inf : 1));\n            forn(k, 4){\n                int i1 = i + dx[k], j1 = j + dy[k];\n                if (i1 >= 0 && j1 >= 0 && i < n && j < m) connect(i * m + j, i1 * m + j1, inf);\n            }\n            if (a[i][j] == 'X') add_edge(I, i * m + j + N, inf);\n            if (i == 0 || j == 0 || i + 1 == n || j + 1 == m) add_edge(i * m + j, J, inf);\n        }\n    }\n    cout << maxFlow(I, J) << '\\n';\n}\n\nbool multitest = false;\n\nint main() {\n    init();\n    int t = 1;\n    if (multitest) cin >> t;\n    forn(i, t) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n\tif(ans-9>187)return 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans-9<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T> using Graph = vector<vector<T>>;\n\n#define REP(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (__typeof(a.begin()) x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define endl '\\n'\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint H, W;\nstring S[105];\nbool used[105][105];\n\nbool is_inside(int x, int y) {\n  return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nbool is_surrounded(int x, int y) {\n  if (x == 0 || x == W - 1 || y == 0 || y == H - 1) return false;\n  used[y][x] = true;\n  bool res = true;\n  rep(i, 4) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if (!is_inside(nx, ny)) continue;\n    if (used[ny][nx]) continue;\n    if (S[ny][nx] == '.') {\n      res &= is_surrounded(nx, ny);\n      if (!res) break;\n    }\n  }\n  used[y][x] = false;\n  return res;\n}\n\nint solve() {\n  rep(i, W) if (S[0][i] == 'X' || S[H - 1][i] == 'X') return -1;\n  rep(i, H) if (S[i][0] == 'X' || S[i][W - 1] == 'X') return -1;\n\n  int ans = 0;\n  rep(y, H) rep(x, W) {\n    if (S[y][x] != 'X') continue;\n    rep(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (!is_inside(nx, ny)) continue;\n      if (S[ny][nx] == '.') {\n        S[ny][nx] = '#';\n        ans += 1;\n      }\n    }\n  }\n\n  rep(y, H) rep(x, W) {\n    if (S[y][x] == '#') {\n      if (is_surrounded(x, y)) {\n        S[y][x] = '.';\n        ans -= 1;\n      }\n    }\n  }\n\n  return ans;\n}\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> H >> W;\n  rep(i, H) cin >> S[i];\n\n  cout << solve() << endl;\n  rep(i, H) cout << S[i] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include<fstream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a <= x && x < b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\n// Dinic法\nclass Dinic {\nprivate:\n\tstruct Edge {\n\t\tint to, cap, rev;\n\t\tEdge(int t, int c, int r) :to(t), cap(c), rev(r) {}\n\t};\n\tint V;\n\tstd::vector<std::vector<Edge>> graph;\n\tstd::vector<int> level, iter;\n\npublic:\n\tDinic(int v) : V(v) {\n\t\tgraph.resize(v);\n\t\tlevel.resize(v, -1);\n\t\titer.resize(v, 0);\n\t}\n\t// fromからtoへ向かう容量capの辺をグラフに追加する\n\tvoid addEdge(int from, int to, int cap) {\n\t\tgraph[from].emplace_back(to, cap, graph[to].size());\n\t\tgraph[to].emplace_back(from, 0, graph[from].size() - 1);\n\t}\n\n\t// sからの最短距離をBFSで計算する\n\tvoid bfs(int s) {\n\t\tstd::fill(level.begin(), level.end(), -1);\n\t\tstd::queue<int> queue;\n\t\tlevel[s] = 0;\n\t\tqueue.push(s);\n\t\twhile (!queue.empty()) {\n\t\t\tint v = queue.front(); queue.pop();\n\t\t\tfor (int i = 0; i < graph[v].size(); ++i) {\n\t\t\t\tEdge& e = graph[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tqueue.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 増加パスをDFSで探す\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t) return f;\n\t\tfor (int& i = iter[v]; i < graph[v].size(); ++i) {\n\t\t\tEdge& e = graph[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, std::min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tgraph[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// sからtへの最大流を求める\n\tint maxFlow(int s, int t) {\n\t\tint res = 0;\n\t\twhile (true) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0) return res;\n\t\t\tstd::fill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, (1LL << 31) - 1)) > 0) {\n\t\t\t\tres += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nint dy4[] = { -1, 0, 1, 0 };\nint dx4[] = { 0, 1, 0, -1 };\n\nsigned main() {\n\tINIT;\n\tVAR(int, h, w);\n\tMAT(char, s, h, w);\n\n\tauto f = [&](int i, int j, int t) {return (i*w + j) * 2 + t; };\n\tDinic g(h * w * 2 + 2);\n\tREP(i, h) REP(j, w) {\n\t\tif (s[i][j] == 'X') {\n\t\t\tg.addEdge(f(i, j, 0), f(i, j, 1), INFINT);\n\t\t\tg.addEdge(h*w * 2, f(i, j, 0), INFINT);\n\t\t}\n\t\telse {\n\t\t\tg.addEdge(f(i, j, 0), f(i, j, 1), 1);\n\t\t}\n\t\tREP(d, 4) {\n\t\t\tint dy = i + dy4[d];\n\t\t\tint dx = j + dx4[d];\n\t\t\tif (!IN(0, dy, h) || !IN(0, dx, w)) {\n\t\t\t\tif (s[i][j] == 'X') {\n\t\t\t\t\tOUT(-1)BR;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tg.addEdge(f(i, j, 1), h*w * 2 + 1, INFINT);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg.addEdge(f(i, j, 1), f(dy, dx, 0), INFINT);\n\t\t\t}\n\t\t}\n\t}\n\tint t = g.maxFlow(h*w * 2, h*w * 2 + 1);\n\tOUT(t)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef long double LD;\ntypedef pair<LD, LD> PLDLD;\ntypedef pair<char, char> PCC;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define ALL(a) a.begin(),a.end()\nLL MOD = 1e9+7;\nint INF = (1e9) *2+1;\ndouble EPS=1.0e-9;\ndouble PI=atan2(0,-1);\n\nbool g[100][100];\nbool g2[100][100];\nbool g3[100][100];\nbool reach[100][100];\nint dx[5]={1,0,-1,0,0},dy[5]={0,1,0,-1,0};\n\n    int h,w;\nvoid dfs(int i,int j)\n{\n    if(!(0<=i&&i<w && 0<=j&&j<h))   return;\n    if(reach[i][j]) return;\n    reach[i][j]=1;\n    if(!g2[i][j]) g3[i][j]=0;\n    REP(k,4)\n        dfs(i+dx[k],j+dy[k]);\n}\nint main()\n{\n    cin>>h>>w;\n    string s;\n    bool f=1;\n    REP(j,h)\n    {\n        cin>>s;\n        REP(i,w)\n        {\n            if(s[i]=='.')\n                g[i][j]=0;\n            else\n            {\n                g[i][j]=1;\n                if(i==0||i==w-1||j==0||j==h-1)\n                    f=0;\n            }\n        }\n    }\n    \n    REP(j,h)\n    REP(i,w)\n    REP(k,5)\n        if(0<=i+dx[k]&&i+dx[k]<w && 0<=j+dy[k]&&j+dy[k]<h)\n            if(g[i+dx[k]][j+dy[k]])\n                g2[i][j]=1;\n            \n    REP(i,100)\n    REP(j,100)\n         g3[i][j]=1;\n         \n    dfs(0,0);\n    int cnt=0;\n    \n    \n    /*REP(j,h)\n    {\n    REP(i,w)\n    {\n        cout<<(g3[i][j]?1:0);\n    }\n    cout<<endl;\n    }*/\n    \n    REP(j,h)\n    REP(i,w)\n    {\n        if(!g3[i][j])continue;\n        bool c=1;\n        REP(k,4)\n        {\n            if(0<=i+dx[k]&&i+dx[k]<w && 0<=j+dy[k]&&j+dy[k]<h)\n            {\n                if(!g3[i+dx[k]][j+dy[k]])\n                    c=0;\n            }\n            else\n                c=0;\n        }\n        if(!c)\n            cnt++;\n    }\n    if(!f) cnt=-1;\n    cout<<cnt<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nint V, E, src, snk;\nvector<int> la, nxt, oppo, capa;\nvoid init() {\n    E = 0;\n    la.clear(); nxt.clear(); oppo.clear(); capa.clear();\n    la = vector<int>(V, -1);\n}\nvoid add(int u, int v, int c) {\n    nxt.push_back(la[u]);\n    la[u] = E++;\n    oppo.push_back(v);\n    capa.push_back(c);\n}\nvector<int> dist;\nqueue<int> q;\nbool bfs() {\n    dist = vector<int>(V, -1);\n    q.push(src);\n    dist[src] = 0;\n    while(!q.empty()) {\n        int u = q.front(); q.pop();\n\n        for(int i = la[u]; i != -1; i = nxt[i]) {\n            int v = oppo[i];\n            if(capa[i] && dist[v] == -1) {\n                dist[v] = dist[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n    return dist[snk] != -1;\n}\nvector<int> laa;\nint dfs(int u, int f) {\n    if(u == snk) return f;\n\n    for(int i = laa[u]; i != -1; i = nxt[i]) {\n        laa[u] = i;\n        int v = oppo[i];\n        if(capa[i] && dist[v] == dist[u] + 1) {\n            if(ll tmp = dfs(v, min(capa[i], f))) {\n                capa[i] -= tmp;\n                capa[i ^ 1] += tmp;\n                return tmp;\n            }\n        }\n    }\n    return 0;\n}\nll dinic() {\n    ll tf = 0;\n    while(bfs()) {\n        laa = la;\n        while(int tmp = dfs(src, 1e9)) tf += tmp;\n    }\n    return tf;\n}\n\nint dx[4] = {0, 0, 1, -1};\nint dy[4] = {1, -1, 0, 0};\n\nint H, W;\nvector<vector<char> > G;\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n\n    G = vector<vector<char> >(H, vector<char>(W));\n\n    for(int i = 0; i < H; i++) {\n        scanf(\"\\n\");\n        for(int j = 0; j < W; j++) {\n            scanf(\"%c\", &G[i][j]);\n        }\n    }\n\n    V = 2*H*W + 2, src = V - 2, snk = V - 1;\n    init();\n\n    for(int i = 0; i < H; i++) {\n        for(int j = 0; j < W; j++) {\n            add(i*W + j, H*W + i*W + j, (G[i][j] == '.'? 1 : 1e9));\n            add(H*W + i*W + j, i*W + j, 0);\n\n            if(G[i][j] == 'X') {\n                add(src, i*W + j, 1e9);\n                add(i*W + j, src, 0);\n            }\n\n            bool edge = false;\n            for(int k = 0; k < 4; k++) {\n                int ni = i + dy[k];\n                int nj = j + dx[k];\n                if(ni < 0 || H <= ni || nj < 0 || W <= nj) {\n                    edge = true;\n                    continue;\n                }\n                add(H*W + i*W + j, ni*W + nj, 1e9);\n                add(ni*W + nj, H*W + i*W + j, 0);\n            }\n\n            if(edge) {\n                add(H*W + i*W + j, snk, 1e9);\n                add(snk, H*W + i*W + j, 0);\n            }\n\n            if(edge && G[i][j] == 'X') {\n                printf(\"-1\");\n                return 0;\n            }\n        }\n    }\n\n    printf(\"%lld\", dinic());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define for(i, a, b) for(ll (i)=a;(i)<(b);++(i))\n#define rep(i, n)    for(i, 0, n)\n#define MAX_V        20004\n\nconst ll inf = 1e15;\nconst ll mod = 1e9+7;\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nstruct edge {\n    ll to, cap, rev;\n    edge(ll t, ll c, ll r): to(t), cap(c), rev(r){}\n};\n\nvector<edge> G[MAX_V];\nll level[MAX_V];\nll iter[MAX_V];\n\nvoid add_edge(ll from, ll to, ll cap) {\n    G[from].push_back(edge(to, cap, G[to].size()));\n    G[to].push_back(edge(from, 0, G[from].size() - 1));\n}\n\nvoid bfs(ll s) {\n    memset(level, -1, sizeof(level));\n    queue<ll> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n        ll v = que.front(); que.pop();\n        rep(i, G[v].size()) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nll dfs(ll v, ll t, ll f) {\n    if (v == t) return f;\n    for(i, iter[v], G[v].size()) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[v] < level[e.to]) {\n            ll d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nll max_flow(ll s, ll t) {\n    ll flow = 0;\n    while (true) {\n        bfs(s);\n        if (level[t] < 0) return flow;\n        memset(iter, 0, sizeof(iter));\n        ll f;\n        while ((f = dfs(s, t, inf)) > 0) {\n            flow += f;\n        }\n    }\n}\n\nchar field[101][101];\nint main() {\n    ll H, W; cin >> H >> W;\n    rep(i, H) rep(j, W) {\n        cin >> field[i][j];\n        if (field[i][j] == 'X' && (i == 0 || i == H-1 || j == 0 || j == W-1)) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n    \n    ll S = 2 * H * W;\n    ll T = 2 * H * W + 1;\n    rep(i, H) rep(j, W) {\n        if (field[i][j] == 'X') add_edge(S, i * W + j, inf);\n        add_edge(i * W + j, H * W + i * W + j, field[i][j] == 'X' ? inf : 1);\n        \n        if (i == 0 || i == H-1 || j == 0 || j == W-1) add_edge(H * W + i * W + j, T, inf);\n        if (i > 0)   add_edge(H * W + i * W + j, (i-1) * W + j, inf);\n        if (i < H-1) add_edge(H * W + i * W + j, (i+1) * W + j, inf);\n        if (j > 0)   add_edge(H * W + i * W + j, i * W + (j-1), inf);\n        if (j < W-1) add_edge(H * W + i * W + j, i * W + (j+1), inf);\n    }\n    cout << max_flow(S, T) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define  inc(i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define  dec(i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define PQ priority_queue\n\n#define  ALL(v)  v.begin(),  v.end()\n#define RALL(v) v.rbegin(), v.rend()\n#define  FOR(it, v) for(auto it =  v.begin(); it !=  v.end(); ++it)\n#define RFOR(it, v) for(auto it = v.rbegin(); it != v.rend(); ++it)\n\ntemplate<typename T> bool   setmin(T & a, T b) { if(b <  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool   setmax(T & a, T b) { if(b >  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmineq(T & a, T b) { if(b <= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmaxeq(T & a, T b) { if(b >= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\ntemplate<typename C> struct Flow {\n\tint V;\n\tC INF;\n\tstruct E { int t, r; C c; };\n\tvector<vector<E>> g;\n\tvector<bool> used;\n\t\n\tFlow() { }\n\tFlow(int v, C inf) { init(v, inf); }\n\tvoid init(int v, C inf) {\n\t\tV = v;\n\t\tINF = inf;\n\t\tg.resize(V);\n\t\tused.resize(V);\n\t}\n\t\n\tvoid add(int f, int t, C c) {\n\t\tassert(inID(f, 0, V));\n\t\tassert(inID(t, 0, V));\n\t\tint gt = g[t].size();\n\t\tint gf = g[f].size();\n\t\tg[f].PB({ t, gt, c });\n\t\tg[t].PB({ f, gf, 0 });\n\t}\n\t\n\tC dfs(int f, int t, C c) {\n\t\tif(f == t) { return c; }\n\t\tused[f] = true;\n\t\tinc(i, g[f].size()) {\n\t\t\tE & e = g[f][i];\n\t\t\tif(used[e.t] || e.c <= 0) { continue; }\n\t\t\tC v = dfs(e.t, t, min(c, e.c));\n\t\t\tif(v > 0) {\n\t\t\t\te.c -= v;\n\t\t\t\tg[e.t][e.r].c += v;\n\t\t\t\treturn v;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tC max_flow(int S, int T) {\n\t\tassert(inID(S, 0, V));\n\t\tassert(inID(T, 0, V));\n\t\tC ans = 0;\n\t\twhile(true) {\n\t\t\tinc(i, V) { used[i] = false; }\n\t\t\tC f = dfs(S, T, INF);\n\t\t\tans += f;\n\t\t\tif(f == 0) { break; }\n\t\t}\n\t\treturn ans;\n\t}\n};\n\n// ----\n\nint h, w, S, T;\nstring s[100];\n\nint id_i(int i, int j) { return (inID(i, 0, h) && inID(j, 0, w) ? w * i + j : T); }\nint id_o(int i, int j) { return (h * w) + w * i + j; }\n\nint main() {\n\tcin >> h >> w;\n\tinc(i, h) { cin >> s[i]; }\n\t\n\tFlow<int> fl(2 * h * w + 2, 10000);\n\tS = 2 * h * w;\n\tT = S + 1;\n\t\n\tinc(i, h) {\n\tinc(j, w) {\n\t\tif(s[i][j] == 'X') { fl.add(S, id_o(i, j), fl.INF); }\n\t\tfl.add(id_i(i, j), id_o(i, j), 1);\n\t\tfl.add(id_o(i, j), id_i(i + 1, j), fl.INF);\n\t\tfl.add(id_o(i, j), id_i(i - 1, j), fl.INF);\n\t\tfl.add(id_o(i, j), id_i(i, j + 1), fl.INF);\n\t\tfl.add(id_o(i, j), id_i(i, j - 1), fl.INF);\n\t}\n\t}\n\t\n\tint ans = fl.max_flow(S, T);\n\tif(ans == fl.INF) { ans = -1; }\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream> \n#include<map>\n#include <iomanip>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\nusing namespace std;\n#define MAX_MOD 1000000007\n#define REP(i,n) for(long long i = 0;i < n;++i)\n#define LONGINF 1000000000000000000\ntemplate <typename T, typename U>\nstd::pair<T, U> operator+(const std::pair<T, U> & l, const std::pair<T, U> & r) {\n\treturn{ l.first + r.first,l.second + r.second };\n}\nmap<pair<int, int>, int> yagi;\nmap<pair<int, int>, int> saku;\npair<int, int> moves[4] = { make_pair(1,0),make_pair(-1,0),make_pair(0,-1),make_pair(0,1) };\nint h, w;\nbool check(pair<int, int> a) {\n\tif (a.first == 0 || a.second == 0) return false;\n\tif (a.first == h - 1 || a.second == w - 1) return false;\n\treturn true;\n}\nint main() {\n\tcin >> h >> w;\n\tqueue<pair<int, int>> letsmove;\n\tREP(i, h) {\n\t\tstring tmp;\n\t\tcin >> tmp;\n\t\tREP(q, w) {\n\t\t\tif (tmp[q] == 'X') {\n\t\t\t\tpair<int, int> foo = make_pair(i,q);\n\t\t\t\tif (check(foo) == false) {\n\t\t\t\t\tcout << \"-1\" << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tyagi[foo] = true;\n\t\t\t\tletsmove.push(foo);\n\t\t\t\tREP(j, 4) {\n\t\t\t\t\tif (yagi[foo + moves[j]] == false) saku[foo + moves[j]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//柵探索\n\twhile (letsmove.empty() == false) {\n\t\tpair<int, int> gogo = letsmove.front();\n\t\tletsmove.pop();\n\t\tfor (int i = 0;i < 4;++i) {\n\t\t\tif (check(gogo+moves[i])== true&&saku[gogo + moves[i]] == true) {\n\t\t\t\tint diag = -1;\n\t\t\t\tfor (int q = 0;q < 4;++q) {\n\t\t\t\t\tif (saku[gogo + moves[i] + moves[q]] == false && yagi[gogo + moves[i] + moves[q]] == false) {\n\t\t\t\t\t\tif (diag == -1) {\n\t\t\t\t\t\t\tdiag = q;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse goto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tletsmove.push(gogo + moves[i]);\n\t\t\t\tsaku[gogo+moves[i]] = false;\n\t\t\t\tyagi[gogo + moves[i]] = true;\n\t\t\t\tif (diag != -1) {\n\t\t\t\t\tsaku[gogo + moves[i] + moves[diag]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\tout:;\n\t\t}\n\t}\n\tint ans = 0;\n\tREP(i, h) {\n\t\tREP(q, w) {\n\t\t\tif (saku[make_pair(i,q)] == true)ans++;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <map>\n#define SIZE 105\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nchar mp[SIZE][SIZE];\nbool use[SIZE][SIZE];\nbool vis[SIZE][SIZE];\n\nint main()\n{\n\tint h,w;\n\tscanf(\"%d %d\",&h,&w);\n\tfor(int i=0;i<h;i++) scanf(\"%s\",&mp[i]);\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<w;j++)\n\t\t{\n\t\t\tif(mp[i][j]=='X')\n\t\t\t{\n\t\t\t\tif(i==0||i==h-1||j==0||j==w-1)\n\t\t\t\t{\n\t\t\t\t\tputs(\"-1\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<4;k++) use[i+dx[k]][j+dy[k]]=true;\n\t\t\t}\n\t\t}\n\t}\n\tqueue <P> que;\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<w;j++)\n\t\t{\n\t\t\tif(i==0||i==h-1||j==0||j==w-1)\n\t\t\t{\n\t\t\t\tque.push(P(i,j));\n\t\t\t\tvis[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tint ret=0;\n\twhile(!que.empty())\n\t{\n\t\tP p=que.front();que.pop();\n\t\tint x=p.first,y=p.second;\n\t\tif(use[x][y])\n\t\t{\n\t\t\tret++;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int k=0;k<4;k++)\n\t\t{\n\t\t\tint nx=x+dx[k],ny=y+dy[k];\n\t\t\tif(0<=nx&&nx<h&&0<=ny&&ny<w&&!vis[nx][ny])\n\t\t\t{\n\t\t\t\tvis[nx][ny]=true;\n\t\t\t\tque.push(P(nx,ny));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n\tif(ans-9>175)return 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans-9<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nint H, W;\nstring b[100];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nvoid dfs(int x, int y) {\n\tif(b[y][x] == '#') {\n\t\tb[y][x] = '$';\n\t\treturn;\n\t}\n\tif(b[y][x] != '.') return;\n\tb[y][x] = '@';\n\tfor(int k = 0; k < 4; k++) {\n\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\tif(in(nx, ny)) {\n\t\t\tif(b[ny][nx] == '#') b[ny][nx] = '$';\n\t\t\tif(b[ny][nx] == '.') dfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++) {\n\t\tcin >> b[i];\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\tif(b[i][0] == 'X' || b[i][W - 1] == 'X') {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = 0; i < W; i++) {\n\t\tif(b[0][i] == 'X' || b[H - 1][i] == 'X') {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\n\n\n\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(b[y][x] == 'X') {\n\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\tif(b[ny][nx] == '.') b[ny][nx] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool flag = true;\n\twhile(flag) {\n\t\tflag = false;\n\t\tfor(int y = 0; y < H; y++) {\n\t\t\tfor(int x = 0; x < W; x++) {\n\t\t\t\tif(x + 2 < W && b[y][x] != '.' && b[y][x + 1] != '.' && b[y][x + 2] != '.') {\n\t\t\t\t\tif(y + 1 < H - 1) {\n\t\t\t\t\t\tif(b[y + 1][x + 1] != '#') flag = true;\n\t\t\t\t\t\tb[y + 1][x + 1] = '#';\n\t\t\t\t\t}\n\t\t\t\t\tif(y - 1 > 0) {\n\t\t\t\t\t\tif(b[y - 1][x + 1] != '#') flag = true;\n\t\t\t\t\t\tb[y - 1][x + 1] = '#';\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(y + 2 < H && b[y][x] != '.' && b[y + 1][x] != '.' && b[y + 2][x] != '.') {\n\t\t\t\t\tif(x + 1 < W - 1) {\n\t\t\t\t\t\tif(b[y + 1][x + 1] != '#') flag = true;\n\t\t\t\t\t\tb[y + 1][x + 1] = '#';\n\t\t\t\t\t}\n\t\t\t\t\tif(x - 1 > 0) {\n\t\t\t\t\t\tif(b[y + 1][x - 1] != '#') flag = true;\n\t\t\t\t\t\tb[y + 1][x - 1] = '#';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\t//cout << b[i] << endl;\n\t}\n\n\n\tfor(int i = 0; i < H; i++) {\n\t\tdfs(0, i);\n\t\tdfs(W - 1, i);\n\t}\n\tfor(int i = 0; i < W; i++) {\n\t\tdfs(i, 0);\n\t\tdfs(i, H - 1);\n\t}\n\n\tint ans = 0;\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(b[y][x] == '$') ans++;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct flow_graph{\n    static const int MAX_V = 20005;\n    static const int MAX_E = 80000;\n\n    int E,s,t,head,tail;\n    int cap[2 * MAX_E],to[2 * MAX_E],next[2 * MAX_E],last[MAX_V],dist[MAX_V],q[MAX_V],now[MAX_V];\n\n    flow_graph(){\n        E = 0;\n        memset(last,-1,sizeof last);\n    }\n\n    void clear(){\n        E = 0;\n        memset(last,-1,sizeof last);\n    }\n\n    void add_edge(int u, int v, int uv){\n        to[E] = v, cap[E] = uv, next[E] = last[u]; last[u] = E++;\n        to[E] = u, cap[E] = 0, next[E] = last[v]; last[v] = E++;\n    }\n\n    bool bfs(){\n        memset(dist,-1,sizeof dist);\n        head = tail = 0;\n\n        q[tail] = t; ++tail;\n        dist[t] = 0;\n\n        while(head < tail){\n            int v = q[head]; ++head;\n\n            for(int e = last[v];e != -1;e = next[e]){\n                if(cap[e^1] > 0 && dist[to[e]] == -1){\n                    q[tail] = to[e]; ++tail;\n                    dist[to[e]] = dist[v]+1;\n                }\n            }\n        }\n\n        return dist[s] != -1;\n    }\n\n    int dfs(int v, int f){\n        if(v == t) return f;\n\n        for(int &e = now[v];e != -1;e = next[e]){\n            if(cap[e] > 0 && dist[to[e]] == dist[v]-1){\n                int ret = dfs(to[e],min(f,cap[e]));\n\n                if(ret > 0){\n                    cap[e] -= ret;\n                    cap[e^1] += ret;\n                    return ret;\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    int max_flow(int source, int sink, int V){\n        s = source; t = sink;\n        int f = 0,df;\n\n        while(bfs()){\n            for(int i = 0;i < V;++i) now[i] = last[i];\n\n            while(true){\n                df = dfs(s,INT_MAX);\n                if(df == 0) break;\n                f += df;\n            }\n        }\n\n        return f;\n    }\n}G;\n\nchar s[100][101];\nconst int INF = 1000000;\nint dr[] = {-1,1,0,0};\nint dc[] = {0,0,-1,1};\n\nint main(){\n    int H,W;\n\n    scanf(\"%d %d\",&H,&W);\n\n    for(int i = 0;i < H;++i)\n        scanf(\"%s\",s[i]);\n\n    for(int i = 0;i < W;++i){\n        G.add_edge(0,1 + i,INF);\n        if(H >= 2) G.add_edge(0,1 + (H - 1) * W + i,INF);\n    }\n\n    for(int i = 1;i + 1 < H;++i){\n        G.add_edge(0,1 + i * W,1);\n        if(W >= 2) G.add_edge(0,1 + i * W + (W - 1),INF);\n    }\n\n    for(int i = 0;i < H;++i){\n        for(int j = 0;j < W;++j){\n            if(s[i][j] == 'X'){\n                G.add_edge(1 + H * W + i * W + j,1 + 2 * H * W,INF);\n                G.add_edge(1 + i * W + j,1 + H * W + i * W + j,INF);\n            }else{\n                G.add_edge(1 + i * W + j,1 + H * W + i * W + j,1);\n            }\n\n            for(int k = 0;k < 4;++k){\n                int r = i + dr[k],c = j + dc[k];\n\n                if(r >= 0 && r < H && c >= 0 && c < W){\n                    G.add_edge(1 + H * W + i * W + j,1 + r * W + c,INF);\n                }\n            }\n        }\n    }\n\n    int ans = G.max_flow(0,1 + 2 * H * W,2 + 2 * H * W);\n    printf(\"%d\\n\",ans == INF? -1 : ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1000000010;\n\ntypedef vector<int> vi;\nstruct MaxFlow {\n\tint n, src, snk;\n\tstruct edge {\n\t\tint c; int f; int u; int v;\n\t\tedge(int u, int v, int c, int f): u (u), v (v), c (c), f (f) {}\n\t};\t\n\tvector <vi> G;\n\tvector <edge> e;\n\tMaxFlow(int n=0, int src=0, int snk=0): n (n), src (src), snk (snk) { e.clear(); G.assign(n + 1, vi()); }\n\tvoid add(int u, int v, int c) {\n\t\tG[u].push_back(e.size()); e.push_back(edge(u, v, c, 0)); \n\t\tG[v].push_back(e.size()); e.push_back(edge(v, u, 0, 0)); \n\t}\n\tvector <int> d, head;\n\tbool bfs() {\n\t\td.assign(n + 1, 0); head.assign(n + 1, 0); d[src] = INF;\n\t\tqueue <int> q; q.push(src); \n\t\twhile(!q.empty()) {\n\t\t\tint u = q.front(); q.pop();\n\t\t\tfor (int id: G[u]) if (!d[e[id].v] && e[id].c > e[id].f) head[e[id].v] = id, d[e[id].v] = u, q.push(e[id].v);\n\t\t}\n\t\treturn (d[snk] != 0);\n\t}\n\tvoid mxm() {\n\t\tint delta = INF, v = 0;\n\t\tfor (int u = snk; u != src; u = d[u]) {\n\t\t\tint id = head[u];\n\t\t\tdelta = min(delta, e[id].c - e[id].f);\n\t\t}\n\t\tfor (int u = snk; u != src; u = d[u]) {\n\t\t\tint id = head[u];\n\t\t\te[id].f += delta; e[id^1].f -= delta;\n\t\t}\n\t}\n\tlong long maxFlow() {\n\t\tlong long r = 0;\n\t\twhile(bfs()) mxm();\n\t\tfor (int id: G[src]) r += e[id].f;\n\t\treturn r;\n\t}\n} mf;\n//--------------------------------------------\n\nconst int N = 105;\nconst int dx[] = {0, 0, -1, +1};\nconst int dy[] = {-1, +1, 0, 0};\n\nint n, m;\nchar a[N][N];\n\nint in(int i, int j) { return 2 * ((i - 1) * m + j) - 1; }\nint out(int i, int j) { return 2 * ((i - 1) * m + j); }\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= m; ++j) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\n\tauto inside = [&](int x, int y) {\n\t\treturn x >= 1 && x <= n && y >= 1 && y <= m;\n\t};\n\n\tint tot = 2 * n * m;\n\tint s = ++tot;\n\tint t = ++tot;\n\tmf = MaxFlow(tot, s, t);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= m; ++j) {\n\t\t\tif (a[i][j] == 'X') {\n\t\t\t\tmf.add(s, in(i, j), INF);\n\t\t\t}\n\t\t\tif (i == 1 || i == n || j == 1 || j == m) { // in borders\n\t\t\t\tmf.add(out(i, j), t, INF);\n\t\t\t}\n\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\tint x = i + dx[dir], y = j + dy[dir];\n\t\t\t\tif (inside(x, y)) {\n\t\t\t\t\tmf.add(out(i, j), in(x, y), INF); \n\t\t\t\t}\n\t\t\t}\n\t\t\tmf.add(in(i, j), out(i, j), (a[i][j] == '.' ? 1 : INF));\n\t\t}\n\t}\n\n\tlong long mincut = mf.maxFlow();\n\tif (mincut > n * m) return cout << -1 << '\\n', 0;\n\tcout << mincut << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n\tif(ans-9==193)cout<<ans-9<<endl;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\telse cout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*? begin \"base.hpp\" */\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve( /* この関数に問題ごとの処理を書く */\n#ifdef GCJ_CASE\n long long case_id\n#endif\n);\n\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n #define debug true\n#else\n #define NDEBUG \n #define debug false\n#endif\n#include<algorithm>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<type_traits>\n#include<vector>\n#ifdef __cpp_lib_execution\n  #include<execution>\n#endif\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL \n#define CS const\n#define CX constexpr\n#define IL inline\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define times(n,i) uptil(0,n,i)\n#define rtimes(n,i) downto((n)-1,0,i)\n#define upto(f,t,i) for(int rabT##i=(t),i=(f);i<=rabT##i;i++)\n#define uptil(f,t,i) for(int rabT##i=(t),i=(f);i< rabT##i;i++)\n#define downto(f,t,i) for(int rabT##i=(t),i=(f);i>=rabT##i;i--)\n#define downtil(f,t,i) for(int rabT##i=(t),i=(f);i> rabT##i;i--)\n#define iter(v) begin(v),end(v)\n#define citer(v) cbegin(v),cend(v)\n#define riter(v) rbegin(v),rend(v)\n#define criter(v) crbegin(v),crend(v)\n#define IF(a,b,c) ((a)?(b):(c))\n#define BINOP_ASGN(t,u,op) t operator op(CS u&o)CS{RT t(*this)op##=o;}\n#if debug\n #define _GLIBCXX_DEBUG\n #define _LIBCPP_DEBUG 2\n #define _LIBCPP_DEBUG2 2\n #define ln <<endl\n#else\n #define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n #define PARABLE \n/*? begin \"mod.hpp\" */\n#ifdef MOD\n #if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n  #error unknown mod MOD and FORCE_MOD not defined.\n #endif\n#else\n #define MOD 1000000007\n#endif\n/*? begin \"power.hpp\" */\nusing int128=__int128;\nTL<TN T>T power(T x,int n){T rt(1);for(;n;n/=2){if(n%2)rt*=x;x*=x;}RT rt;}\nint pow_mod(int x,int n,int m){int rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\nint128 pow_mod_64(int128 x,int n,int m){int128 rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\n/*? end \"power.hpp\" */\nIL CX int modulo(int a,int m){RT(a%=m,a>=0?a:a+m);}\nTL<ULL mod=MOD>class MInt{\n  /*! https://ei1333.github.io/luzhiled/snippets/other/mod-int.html */\npublic:\n  int val;\n  CX MInt():val(0){}\n  explicit CX MInt(int v):val(modulo(v,mod)){}\n  MInt&operator+=(CS MInt&m){val+=m.val;if(val>=mod)val-=mod;RT*this;}\n  MInt&operator-=(CS MInt&m){val-=m.val;if(val<0)val+=mod;RT*this;}\n  MInt&operator*=(CS MInt&m){val=val*m.val%mod;RT*this;}\n  MInt&operator/=(CS MInt&m){val=val*m.inv().val%mod;RT*this;}\n  BINOP_ASGN(MInt,MInt,+) BINOP_ASGN(MInt,MInt,-) BINOP_ASGN(MInt,MInt,*) BINOP_ASGN(MInt,MInt,/)\n  MInt operator-()CS{MInt m;m.val=val?mod-val:0;RT m;}\n  bool operator==(CS MInt&m)CS{RT val==m.val;}\n  bool operator!=(CS MInt&m)CS{RT val!=m.val;}\n  //MInt pow(int n)CS{MInt x(*this),rt(1);while(n){if(n%2)rt*=x;x*=x;n/=2;}RT rt;}\n  MInt pow(int n)CS{RT power(*this,n);}\n  MInt inv()CS{int a=val,b=mod,x=1,y=0,t;while(b){t=a/b;swap(b,a-=t*b);swap(y,x-=t*y);}RT(MInt)x;}\n  friend ostream&operator<<(ostream&o,CS MInt<mod>&m){RT o<<m.val;}\n  friend istream&operator>>(istream&i,MInt<mod>&m){int v;i>>v;m=MInt<mod>(v);RT i;}\n};\nusing mint=MInt<>;\n\nconstexpr mint operator\"\" _m(ULL n){RT mint(n);}\nconstexpr MInt<998244353>operator\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nconstexpr MInt<1000000007>operator\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nconstexpr MInt<1000000009>operator\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n\n//#pragma rab:gsub \\b(\\d+)m\\b mint(\\1)\n/*? end \"mod.hpp\" */\n/*? begin \"typedefs.hpp\" */\nstruct unit{};\n\nusing int128=__int128;\nusing LD=long double;\nTL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;\nTL<TN T>using vvvec=vec<vvec<T>>;\nTL<TN T>using vvvvec=vec<vvvec<T>>;\n\n//#pragma rab typedefs.dynamic\nusing WI = vvec<int>; using VI = vec<int>; using VS = vec<string>; \n/*? end \"typedefs.hpp\" */\n/*? begin \"alias.hpp\" */\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n/*? end \"alias.hpp\" */\n/*? begin \"util.hpp\" */\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,true);}\nTL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,true);}\n\n#ifndef __cpp_lib_exchange_function\n #define exchange exchange_RAB\n TL<TN T,TN U=T>IL T exchange(T& t, U&& u){T x=move(t);t=forward<U>(u);RT x;}\n#endif\n#ifndef __cpp_lib_clamp\n #define clamp clamp_RAB\n TL<TN T>IL CX CS T&clamp(CS T&a,CS T&mn,CS T&mx){RT a<mn?mn:a>mx?mx:a;}\n#endif\n\nTL<TN T>IL int size_RAB(T t){RT t.size();}\n#define size size_RAB\n\nTL<TN V>IL void uniq_after_sort(V&v){v.erase(unique(iter(v)),v.end());}\nTL<TN V>IL void sort_and_uniq(V&v){sort(iter(v));v.erase(unique(iter(v)),v.end());}\nTL<TN V,TN K>IL auto leftmost_ge(CS V&v,CS K&k){RT v.lower_bound(k);}\nTL<TN V,TN K>IL auto leftmost_gt(CS V&v,CS K&k){RT v.upper_bound(k);}\n\nnamespace rab{\n\nTL<TN V,TN W>IL void append(V&v,CS W&w){copy(PARABLE citer(w),back_inserter(v));}\n\nTL<TN V>IL auto flatten(CS V&xss,int reserve_size=0)->TN V::value_type{\n  decltype(flatten(xss))ret;\n  ret.reserve(reserve_size);\n  for(CS auto&xs:xss)append(ret,xs);\n  ret.shrink_to_fit();\n  RT move(ret);\n}\n\nTL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}\n\nTL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){RT 0<=i&&i<size(v)?v[i]:d;}\nTL<TN T>IL T fetch(CS T&d,CS vvec<T>&v,int i,int j){\n  RT 0<=i&&i<size(v)&&0<=j&&j<size(v[i])?v[i][j]:d;\n}\n// TL<TN T,TN U,TN...I>IL T fetch(CS T&d,CS vec<vec<U>>&v,int i,I...j){\n// RT 0<=i&&i<size(v)?fetch(d,v[i],j...):d;\n// }\nTL<TN T>struct Compressed{int size;map<T,int>zip;vec<T>unzip;};\nTL<TN T>IL Compressed<T>compressed(vec<T>v){\n  sort_and_uniq(v);map<T,int>zip;times(size(v),i)zip[v[i]]=i;RT{size(v),zip,move(v)};\n}\nTL<TN T>struct CompressedSrc{int size;map<T,int>zip;vec<T>unzip;WI src;};\nTL<TN T>IL CompressedSrc<T>compressed_src(CS vec<T>&v){\n  auto c=compressed(v);VI src(c.size);times(size(v),i)src[c.zip[v[i]]].PB(i);RT{c.size,c.zip,c.unzip,src};\n}\n\nstruct identity{TL<TN U>U operator()(U&&v)CS{RT v;}};\n}\n/*? end \"util.hpp\" */\n/*? begin \"debug.hpp\" */\nTL<class T>\nIL istream&operator>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nTL<class T>\nIL ostream&operator<<(ostream&,CS vec<T>&);\nTL<class T,class S>\nIL ostream&operator<<(ostream&,CS map<T,S>&);\n#define DEFINE_ITER_OUTPUT(s,x,sep){int i=0;for(CS auto&x##0_elem:x){if(i++)s<<sep;s<<x##0_elem;}RT s;}\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<T>&v)DEFINE_ITER_OUTPUT(s,v,' ')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS map<T,S>&m)DEFINE_ITER_OUTPUT(s,m,' ')\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<vec<T>>&w)DEFINE_ITER_OUTPUT(s,w,'\\n')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS vec<map<T,S>>&v)DEFINE_ITER_OUTPUT(s,v,'\\n')\n/*? end \"debug.hpp\" */\n\nsigned main(){\n {if(debug)cerr<<\"MOD: \"<<(MOD)ln;}\n if(!debug)cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\n cout<<fixed<<setprecision(20);\n cerr<<fixed<<setprecision(20);\n\n #ifdef GCJ_CASE\n  int T;cin>>T;\n  times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n #else\n  solve();\n #endif\n\n return 0;\n}\n/*? end \"base.hpp\" */\n/*? begin \"graph.hpp\" */\n/*? begin \"uf.hpp\" */\n\ntemplate<class T = int, class Adder = plus<T>, class Inverser = negate<T>>\nclass UnionFind {\n  /*\n    ポテンシャル付きUnionFind (find: path compression, merge: union by size)\n\n    FUNC:\n      merge: 既にマージされていたならfalse, 今回マージ処理を行ったならtrueを返す.\n\n    TIME:\n      new, clear:           O(n).\n      root, merge, is_same: 償却O(a(n)); ただしaはアッカーマン関数の逆関数.\n\n    TMPL:\n      T: ポテンシャルの型\n      Adder: ポテンシャルの和演算 (群の演算)\n      Inverser: ポテンシャルの逆元関数\n      例: UnionFind<int, bit_xor<int>, identity<int>>\n  */\n  /*!\n    http://noshi91.hatenablog.com/entry/2018/05/30/191943\n    https://en.wikipedia.org/wiki/Disjoint-set_data_structure\n    https://qiita.com/drken/items/cce6fc5c579051e64fab\n  */\n\n  int n, *parents, *sizes;\n  T *pot_diffs;\n  bool to_delete;\n  Adder adder;\n  Inverser inverser;\n\npublic:\n  explicit UnionFind(int n, bool to_delete = false):\n    n(n), parents(new int[n]), sizes(new int[n]), pot_diffs(new T[n]), to_delete(to_delete)\n  {\n    clear();\n  }\n\n  void clear() {\n    times(n, i) parents[i] = i; /* roots */\n    fill(sizes, sizes + n, 1);\n    fill(pot_diffs, pot_diffs + n, 0);\n  }\n\n  ~UnionFind(){if(to_delete){delete[]parents;delete[]sizes;delete[]pot_diffs;}}\n\n  int size() { return n; }\n\n  int root(int i) {\n    int p = parents[i];\n    if(p == i) return i; /* `i` is a root */\n    int r = root(p); /* and pot_diffs[p] := diff from root */\n    pot_diffs[i] += pot_diffs[p];\n    parents[i] = r;\n    return r;\n  }\n\n  bool is_same(int i,int j){RT root(i)==root(j);}\n  bool is_all_same(){int r=root(0);uptil(1,n,i)if(root(i)!=r)RT 0;RT 1;}\n\n  bool merge(int i, int j, T pdiff = 0) {\n    i = root(i);\n    j = root(j);\n    if(i == j) return false; /* already merged */\n    if(sizes[i] > sizes[j]) {\n      swap(i, j);\n      pdiff = inverser(pdiff);\n    }\n    /* now sizes[i] <= sizes[j] */\n    parents[i] = j;\n    sizes[j] += sizes[i];\n    pot_diffs[i] = pdiff;\n    return true;\n  }\n\n  T diff(int i, int j) {\n    root(i); /* pot_diffs[i] := diff from root */\n    root(j); /* pot_diffs[j] := diff from root */\n    return adder(pot_diffs[i], inverser(pot_diffs[j]));\n  }\n};\nusing unionfind=UnionFind<>;\n/*? end \"uf.hpp\" */\nTL<class EdgeVal>\nstruct Edge{int from;int to;EdgeVal weight;\nEdge(int from,int to,EdgeVal weight):from(from),to(to),weight(weight){}\nIL bool operator==(CS Edge&e)CS{RT weight==e.weight&&from==e.from&&to==e.to;}\nIL bool operator<(CS Edge&e)CS{RT weight<e.weight||(weight==e.weight&&(from<e.from||(from==e.from&&to<e.to)));}\nIL bool operator<=(CS Edge&e)CS{RT this==e||this<e;}\nIL bool operator>(CS Edge&e)CS{RT e<this;}\nIL bool operator>=(CS Edge&e)CS{RT e<=this;}};\nTL<class VtxVal,class EdgeVal>\nclass Graph{\nusing VoidWithoutEdgeVal=TN enable_if<is_default_constructible<EdgeVal>::value,void>::type;\nprotected:\nint nv_,nde_;unionfind uf;\npublic:\nvec<VtxVal>vs;vvec<Edge<EdgeVal>>edges;\nGraph(int nv):nv_(nv),nde_(0),uf(nv),vs(nv),edges(nv){}\nIL int nv()CS{RT nv_;}\nIL int nde()CS{RT nde_;}\nIL int nue()CS{RT nde_/2;}\nIL void add_dedge(int i,int j,CS EdgeVal&val){\nif(!rab::is_in(i,0LL,nv_)||!rab::is_in(j,0LL,nv_)){\ncerr<<\"invalid index:(\"<<i<<\",\"<<j<<\")for Graph(nv=\"<<nv_<<\")\" ln;\nexit(1);\n}\nedges[i].emplace_back(i,j,val);++nde_;\n}\nIL VoidWithoutEdgeVal add_dedge(int i,int j){add_dedge(i,j,EdgeVal());\n}\nIL void add_uedge(int i,int j,CS EdgeVal&val){add_dedge(i,j,val);\nadd_dedge(j,i,val);\n}\nIL VoidWithoutEdgeVal add_uedge(int i,int j){add_uedge(i,j,EdgeVal());\n}\nIL bool is_connected(){uf.clear();\nfor(CS auto&es:edges)for(CS auto&e:es)uf.merge(e.from,e.to);RT uf.is_all_same();\n}};\n/*? end \"graph.hpp\" */\n/*? begin \"flow.hpp\" */\n/*!Arihon,https://tubo28.me/algorithm/dinic/*/\nTL<TN F,TN V,TN E,TN CapFn=rab::identity>\n/*F:通常int,CapFn:E->F*/\nstruct dinic{int n,s,t;VI level,prog,que;\nWI edges;/*both direction*/\nvvec<F>cap,flow;\ndinic(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),level(n),prog(n),que(n+1),edges(n),cap(n,VI(n)),flow(n,VI(n))\n{times(n,i){for(auto&e:g.edges[i]){F c=capfn(e.weight);\ncap[i][e.to]+=c;cap[e.to][i]+=c;flow[e.to][i]+=c;edges[i].PB(e.to);\nedges[e.to].PB(i);\n}}}\nF exec(int s,int t){this->s=s;this->t=t;F mf=0;\nwhile(update_level(),level[t]>0){fill(iter(prog),0);mf+=find_paths(s,numeric_limits<F>::max()/*inf*/);\n}\nRT mf;\n}\nvoid update_level(){int ql=0,qr=0;fill(iter(level),-1);level[s]=0;\nque[qr++]=s;while(ql!=qr/*queue is not empty*/){int v=que[ql++];\nif(v==t)break;\nfor(CS int&d:edges[v]){if(level[d]<0&&cap[v][d]!=flow[v][d]){level[d]=level[v]+1;\nque[qr++]=d;\n}}}}\nF find_paths(int v,int limit){if(v==t)RT limit;F diff=0;\nfor(;prog[v]<size(edges[v]);++prog[v]){int d=edges[v][prog[v]];\nif(cap[v][d]!=flow[v][d]&&level[v]<level[d]){F df=find_paths(d,min(limit,cap[v][d]-flow[v][d]));\nflow[v][d]+=df;flow[d][v]-=df;diff+=df;limit-=df;if(limit==0)break;\n}}\nRT diff;}};\n/*? end \"flow.hpp\" */\nconstexpr int INF = 1ll << 50;\n\nvoid solve() {\n// HWH(\"S\")\n/* <foxy.memo-area> */\nint H;int W;cin>>H;cin>>W;VS S(H);times(H,Ri_0){cin>>S[Ri_0];}\n/* </foxy.memo-area> */\n\n  Graph<unit, int> g(H * W * 2 + 2);\n\n  int s = H * W * 2, t = H * W * 2 + 1;\n\n  #define inp(i, j) (((i) * W + (j)) * 2)\n  #define outp(i, j) (((i) * W + (j)) * 2 + 1)\n\n  times(H, i) times(W, j) {\n    g.add_dedge(inp(i, j), outp(i, j), 1);\n\n    if(S[i][j] == 'X') {\n      g.add_dedge(s, outp(i, j), INF);\n    }\n  }\n\n  times(H, i) {\n    g.add_dedge(outp(i, 0), t, INF);\n    g.add_dedge(outp(i, W-1), t, INF);\n\n    times(W-1, j) {\n      g.add_dedge(outp(i, j), inp(i, j + 1), INF);\n      g.add_dedge(outp(i, j + 1), inp(i, j), INF);\n    }\n  }\n  times(W, j) {\n    g.add_dedge(outp(0, j), t, INF);\n    g.add_dedge(outp(H-1, j), t, INF);\n\n    times(H-1, i) {\n      g.add_dedge(outp(i, j), inp(i + 1, j), INF);\n      g.add_dedge(outp(i + 1, j), inp(i, j), INF);\n    }\n  }\n\n  dinic<int, unit, int> d(g);\n  int f = d.exec(s, t);\n  if(f >= INF)\n    cout << -1 ln;\n  else\n    cout << f ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < int > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vll vector < ll >\n# define pii pair < int , int >\n# define mp make_pair\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    int n,m;\n    fi>>n>>m;\n    static char s[1024][1024];\n    for (int i = 1;i <= n;++i)\n        fi>>(s[i] + 1);\n    int ans = 0;\n    vector < pii > W;\n    for (int i = 1;i <= n;++i)\n        for (int j = 1;j <= m;++j)\n            if (s[i][j] == 'X')\n            {\n                if (i == 1 || i == n || j == 1 || j == m)\n                    return puts(\"-1\") * 0;\n                W.push_back({i,j});\n            }\n    for (int i = 1;i <= n;++i)\n        for (int j = 1;j <= m;++j)\n            if (s[i][j] != 'X')\n                s[i][j] = '#';\n    static int was[128][128];\n    const int dx[] = {1,0,-1,0};\n    const int dy[] = {0,1,0,-1};\n    function < int(int,int) > go = [&](int a,int b)\n    {\n        was[a][b] = 1;\n        int ok = 1;\n        for (int k = 0;k < 4;++k)\n        {\n            int na = a + dx[k];\n            int nb = b + dy[k];\n            if (!na || !nb || na == n + 1 || nb == m + 1) return 0;\n            if (!was[na][nb] && s[na][nb] == '.') ok &= go(na,nb);\n        }\n        return ok;\n    };\n    vector < pii > T;\n    for (int i = 1;i <= n;++i)\n        for (int j = 1;j <= m;++j)\n            T.push_back({i,j});\n    sort(T.begin(),T.end(),[&](pii a,pii b)\n         {\n            auto f = [&](pii a)\n            {\n                return min({a.x,n - a.x,a.y,m - a.y});\n            };\n            return f(a) < f(b);\n         });\n    for (auto it : T)\n    {\n        int i = it.x;\n        int j = it.y;\n        if (s[i][j] == '#')\n        {\n            s[i][j] = '.';\n            memset(was,0,sizeof(was));\n            int ok = 1;\n            for (auto it : W)\n                ok &= go(it.x,it.y);\n            if (!ok) s[i][j] = '#';\n        }\n    }\n    for (int i = 1;i <= n;++i)\n        for (int j = 1;j <= m;++j)\n            ans += s[i][j] == '#';\n    fo << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//四則演算 #pragma GCC target(\"avx\")\n//並列計算 #pragma GCC optimize(\"O3\")\n//条件分岐を減らす #pragma GCC optimize(\"unroll-loops\")\n//浮動小数点演算 #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing VI = vector<int>;\nusing VL = vector<ll>;\nusing VS = vector<string>;\ntemplate<class T> using PQ = priority_queue<T, vector<T>, greater<T>>;\n#define FOR(i,a,n) for(int i=(a);i<(n);++i)\n#define eFOR(i,a,n) for(int i=(a);i<=(n);++i)\n#define rFOR(i,a,n) for(int i=(n)-1;i>=(a);--i)\n#define erFOR(i,a,n) for(int i=(n);i>=(a);--i)\n#define each(i, a) for(auto &i : a)\n#define SORT(a) sort(a.begin(),a.end())\n#define rSORT(a) sort(a.rbegin(),a.rend())\n#define fSORT(a,f) sort(a.begin(),a.end(),f)\n#define all(a) a.begin(),a.end()\n#define out(y,x) ((y)<0||h<=(y)||(x)<0||w<=(x))\n#define tp(a,i) get<i>(a)\n#define line cout << \"-----------------------------\\n\" \n#define ENDL(i,n) ((i) == (n) - 1 ? \"\\n\" : \" \")\n#define stop system(\"pause\")\nconstexpr ll INF = 1000000000;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr ll mod = 1000000007;\nconstexpr ll MOD = 998244353;\nconstexpr ld eps = 1e-10;\nconstexpr ld pi = 3.1415926535897932;\ntemplate<class T>inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T>inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; }return false; }\ninline void init() { cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); }\ntemplate<class T>inline istream& operator>>(istream& is, vector<T>& v) { for (auto& a : v)is >> a; return is; }\ntemplate<class T>inline istream& operator>>(istream& is, deque<T>& v) { for (auto& a : v)is >> a; return is; }\ntemplate<class T, class U>inline istream& operator>>(istream& is, pair<T, U>& p) { is >> p.first >> p.second; return is; }\ntemplate<class T>inline vector<T> vec(size_t a) { return vector<T>(a); }\ntemplate<class T>inline vector<T> defvec(T def, size_t a) { return vector<T>(a, def); }\ntemplate<class T, class... Ts>inline auto vec(size_t a, Ts... ts) { return vector<decltype(vec<T>(ts...))>(a, vec<T>(ts...)); }\ntemplate<class T, class... Ts>inline auto defvec(T def, size_t a, Ts... ts) { return vector<decltype(defvec<T>(def, ts...))>(a, defvec<T>(def, ts...)); }\ntemplate<class T>inline void print(const T& a) { cout << a << \"\\n\"; }\ntemplate<class T, class... Ts>inline void print(const T& a, const Ts&... ts) { cout << a << \" \"; print(ts...); }\ntemplate<class T>inline void print(const vector<T>& v) { for (int i = 0; i < v.size(); ++i)cout << v[i] << (i == v.size() - 1 ? \"\\n\" : \" \"); }\ntemplate<class T>inline void print(const vector<vector<T>>& v) { for (auto& a : v)print(a); }\ninline string reversed(const string& s) { string t = s; reverse(all(t)); return t; }\n\nint main() {\n    init();\n\n    int h, w; cin >> h >> w;\n    VS field(h); cin >> field;\n    {\n        bool ng = false;\n        FOR(y, 0, h)ng |= field[y][0] == 'X' || field[y][w - 1] == 'X';\n        FOR(x, 0, w)ng |= field[0][x] == 'X' || field[h - 1][x] == 'X';\n        if (ng) {\n            print(-1);\n            return 0;\n        }\n    }\n\n    int s = h * w * 2, t = h * w * 2 + 1;\n    vector<vector<tuple<int, int, int>>> g(h * w * 2 + 2);\n    constexpr int dy[] = { -1,0,0,1 }, dx[] = { 0,-1,1,0 };\n    FOR(y, 0, h)FOR(x, 0, w) {\n        int cur_in = (y * w + x) * 2, cur_out = cur_in + 1;\n        if (y % (h - 1) == 0 || x % (w - 1) == 0) {\n            g[cur_out].emplace_back(t, INF, g[t].size());\n            g[t].emplace_back(cur_out, 0, g[cur_out].size() - 1);\n        }\n        int cap = 1;\n        if (field[y][x] == 'X') {\n            cap = INF;\n            g[s].emplace_back(cur_out, INF, g[cur_out].size());\n            g[cur_out].emplace_back(s, 0, g[s].size() - 1);\n        }\n        g[cur_in].emplace_back(cur_out, cap, g[cur_out].size());\n        g[cur_out].emplace_back(cur_in, 0, g[cur_in].size() - 1);\n        FOR(i, 0, 4) {\n            int ny = y + dy[i], nx = x + dx[i];\n            if (out(ny, nx))continue;\n            g[cur_out].emplace_back((ny * w + nx) * 2, INF, g[(ny * w + nx) * 2].size());\n            g[(ny * w + nx) * 2].emplace_back(cur_out, 0, g[cur_out].size() - 1);\n        }\n    }\n\n    vector<bool> used;\n    auto dfs = [&](auto&& f, int cur)->bool {\n        used[cur] = true;\n        if (cur == t)return true;\n        each(dest, g[cur]) {\n            auto [to, cap, rev] = dest;\n            if (used[to] || cap == 0)continue;\n            if (f(f, to)) {\n                --tp(dest, 1);\n                ++tp(g[to][rev], 1);\n                return true;\n            }\n        }\n        return false;\n    };\n\n    int ans = 0;\n    while (1) {\n        used.assign(h* w * 2 + 2, false);\n        if (!dfs(dfs, s))break;\n        ++ans;\n    }\n\n    print(ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vin=vector<int>;\nusing vll=vector<long long>;\nusing vvin=vector<vector<int>>;\nusing vvll=vector<vector<long long>>;\nusing vstr=vector<string>;\nusing vvstr=vector<vector<string>>;\nusing vch=vector<char>;\nusing vvch=vector<vector<char>>;\nusing vbo=vector<bool>;\nusing vvbo=vector<vector<bool>>;\nusing vpii=vector<pair<int,int>>;\nusing pqsin=priority_queue<int,vector<int>,greater<int>>;\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep2(i,s,n) for(int i=(s);i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define decp(n) cout<<fixed<<setprecision((int)n)\nconst int inf=1e9+7;\nconst ll INF=1e18;\n\nstruct edge{int to;ll cap;int rev;};\n\nint MAX_V=220;\nint tmp1,tmp2;\n\nvector<vector<edge>> g(MAX_V);//グラフの隣接リスト表現\nvin level(MAX_V);//distance form s\nvin iter(MAX_V);//どこまで調べたか\n\nvoid add_edge(int from,int to,ll cap=(ll)inf){\n    tmp1=g[to].size();tmp2=g[from].size();\n    g[from].push_back((edge){to,cap,tmp1});//g[to]のg[to].size()番目にfromが入っている\n    g[to].push_back((edge){from,0,tmp2});//g[from]のg[from].size()-1番目にtoが入っている\n}\n\nvoid bfs(int s){\n    fill(all(level),-1);\n    queue<int> q;\n    q.push(s);\n    level[s]=0;\n    while(q.size()){\n        int v=q.front();q.pop();\n        for(auto& e:g[v]){\n            if(e.cap>0&&level[e.to]<0){\n                level[e.to]=level[v]+1;\n                q.push(e.to);\n            }\n        }\n    }\n}\n\n//増加パスをdfsで探す\n//v:今見てる頂点 t:終点 f:流量\nint dfs(int v,int t,ll f){\n    if(v==t)return f;\n    for(int& i=iter[v];i<(int)g[v].size();i++){\n        edge& e=g[v][i];\n        if(e.cap>0&&level[v]<level[e.to]){\n            ll d=dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                g[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n//sからtへの最大流を求める\nint max_flow(int s,int t){\n    ll flow=(ll)0;\n    ll f;\n    for(;;){\n        bfs(s);\n        if(level[t]<0)return flow;\n        fill(all(iter),0);\n        while((f=dfs(s,t,inf))>0)flow+=f;\n    }\n}\n\nint main(){\n    int h,w;cin>>h>>w;\n    vstr S(h);\n    rep(i,h)cin>>S[i];\n    //各マスinとoutを2つ用意\n    //(i,j)のinは2(i*w+j)で, outは2(i*w+j)+1で表される\n    int s=2*h*w;//s→ヤギ\n    int t=s+1;//追加したグリッドのマス(ゴール)→t\n    int tmp;\n    rep(i,h)rep(j,w){\n        tmp=2*(i*w+j);\n        if(S[i][j]=='X'){\n            if(i==0||i==h-1||j==0||j==w-1){\n                cout<<-1<<endl;\n                return 0;\n            }\n            add_edge(tmp,tmp+1);\n            add_edge(s,tmp+1);\n        }\n        else add_edge(tmp,tmp+1,(ll)1);\n        if(i>0)add_edge(tmp+1,tmp-2*w);\n        if(i<h-1)add_edge(tmp+1,tmp+2*w);\n        if(j>0)add_edge(tmp+1,tmp-2);\n        if(j<w-1)add_edge(tmp+1,tmp+2);\n        if(i==0||i==h-1||j==0||j==w-1)add_edge(tmp+1,t);\n    }\n    cout<<max_flow(s,t)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n     File Name: 1.cpp\n     ID: Liusiyu\n     BLOG: http://blog.csdn.net/r_o_j \n     LANG: C++ \n     Mail: 779532360@qq.com \n     Created Time: 2016年10月03日 星期一 17时01分20秒\n ************************************************************************/\n#include<bits/stdc++.h>\n#define MEM(a,x) memset(a,x,sizeof(a));\n#define MEMINF(a) memset(a,0x3f,sizeof(a));\nusing namespace std;\ntypedef long long LL;\nconst int MAXN=1e5+10;\nconst int MAXM=2e5+20;\nconst int INF=0x3f3f3f3f;\nconst int MOD=1000000007;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nstruct MaxFlow{  \n    int head[MAXN];  \n    struct Edge{  \n        int u,v,nex,cap,flow;  \n    }edge[MAXM];  \n    int tot;\n    int s,t;\n    int dis[MAXN];  \n    int cur[MAXN];  \n    void Dinic_init(int s,int t){  \n        this->s=s;\n        this->t=t;  \n        MEM(head,-1);  \n        tot=0;  \n    }  \n    void Addedge(int u,int v,int w) {  \n        edge[tot].v=v,edge[tot].cap=w,edge[tot].flow=0,edge[tot].nex=head[u],head[u]=tot++;  \n        edge[tot].v=u,edge[tot].cap=0,edge[tot].flow=0,edge[tot].nex=head[v],head[v]=tot++;  \n    }  \n    bool bfs() {  \n        MEM(dis,-1);  \n        queue<int>q;  \n        dis[s]=0;  \n        q.push(s);  \n        while (!q.empty()) {  \n            int u=q.front();  \n            q.pop();  \n            for (int i=head[u]; ~i; i=edge[i].nex) {  \n                int v=edge[i].v;  \n                if (edge[i].cap>edge[i].flow&&dis[v]==-1) {  \n                    q.push(v);  \n                    dis[v]=dis[u]+1;  \n                }  \n            }  \n        }  \n        return dis[t]!=-1;  \n    }  \n    int dfs(int u,int delta) {  \n        if (u==t||delta==0)  \n            return delta;  \n            int ret=0;  \n            int aug;  \n            for(int &i=cur[u]; ~i; i=edge[i].nex) {  \n                int v=edge[i].v;  \n                if (dis[v]==dis[u]+1&&(aug=dfs(v,min(edge[i].cap-edge[i].flow,delta)))>0) {  \n                    edge[i].flow+=aug;  \n                    edge[i^1].flow-=aug;  \n                    delta-=aug;  \n                    ret+=aug;  \n                    if (delta==0) break;  \n                }  \n            }  \n            return ret;  \n    }  \n    void dinic() {  \n        int ret=0;  \n        while(bfs()) {  \n            memcpy(cur,head,sizeof head);  \n            ret+=dfs(s,INF);  \n            //cout<<ret<<endl;  \n        }  \n        cout<<ret<<endl;  \n     }  \n}nima; \nint n,m;\nint zb(int x,int y) {\n  return (x*m+y)*2;\n}\n\nchar mp[MAXN][MAXN];\nint main() {\n  int T,S;\n  cin>>n>>m;\n  S=n*m*2;\n  T=S+1;\n  nima.Dinic_init(n*m*2,n*m*2+1);\n  for (int i=0; i<n; ++i) {\n    cin>>mp[i]+0;\n  }\n  for (int i=0; i<n; ++i) {\n    if (mp[i][0]=='X'||mp[i][m-1]=='X') {\n      puts(\"-1\");\n      return 0;\n    }\n    nima.Addedge(T,zb(i,0),INF);\n    nima.Addedge(T,zb(i,m-1),INF);\n  }\n  for (int i=0; i<m; ++i) {\n    if (mp[0][i]=='X'||mp[m-1][n]=='X') {\n      puts(\"-1\");\n      return 0;\n    }\n    nima.Addedge(T,zb(0,i),INF);\n    nima.Addedge(T,zb(m-1,n),INF);\n  }\n  for (int i=0; i<n; ++i) \n    for (int j=0; j<m; ++j) {\n      if (mp[i][j]=='X') nima.Addedge(zb(i,j),S,INF);\n      else {\n        nima.Addedge(zb(i,j),zb(i,j)+1,1);\n      }\n      for (int k=0; k<4; ++k) {\n        int x=i+dx[k];\n        int y=j+dy[k];\n        if (x<0||x>=n||y<0||y>=m)continue;\n        nima.Addedge(zb(i,j)+1,zb(x,y),INF);\n      }\n    }\n  nima.dinic();\n}\n\n        \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans-5<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nconst int INF = 830252521;\ntypedef int flow_type;\n// Dinic http://www.prefield.com/algorithm/graph/dinic.html\nstruct dinic{\n  struct edge{int from,to;flow_type cost;edge *rev;};\n  int n;\n  vector< vector<edge> > G;\n  vector< vector<edge> > C;\n  // vector< vector<flow_type> > flow, capacity;\n// #define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n  vi level;\n  vector<bool> finished;\n  dinic(int _n){\n    n = _n;\n    G.assign(n,vector<edge>());\n    // flow.assign(n,vector<flow_type>(n,0));\n    // capacity.assign(n,vector<flow_type>(n,0));\n    level.assign(n,0);\n    finished.assign(n,false);\n  }\n  void add_edge(int from,int to,flow_type cost){\n    assert(0<=from && from<n);\n    assert(0<=to && to<n);\n    edge s = (edge){from,to,cost,NULL};\n    G[from].push_back(s);\n  }\n  flow_type dfs(int u, int t, flow_type cur){\n    if(u==t || cur==0) return cur;\n    if(finished[u]) return 0;\n    finished[u] = true;\n    REP(i,C[u].size()){\n      edge &e = C[u][i];\n      if(level[e.to] > level[u]){\n        flow_type f = dfs(e.to, t, min(cur, e.cost));\n        if(f>0){\n          e.cost -= f;\n          e.rev->cost += f;\n          finished[u] = false;\n          return f;\n        }\n      }\n    }\n    return 0;\n  }\n  flow_type calc(int s, int t){\n    C.assign(n,vector<edge>());\n    REP(i,n)REP(j,G[i].size()){\n      edge s = G[i][j];\n      int from = s.from;\n      int to = s.to;\n      edge t = (edge){to,from,0,NULL};\n      C[from].push_back(s);\n      C[to].push_back(t);\n      C[from].back().rev = &(C[to].back());\n      C[to].back().rev = &(C[from].back());\n    }\n    flow_type total = 0;\n    while(true){\n      REP(i,n)level[i] = -1;\n      level[s] = 0;\n      queue<int> Q; Q.push(s);\n      int d = n;\n      while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        REP(i,C[u].size()){\n          edge &e = C[u][i];\n          if(e.cost > 0 && level[e.to] == -1){\n            Q.push(e.to);\n            level[e.to] = level[u] + 1;\n          }\n        }\n      }\n      REP(i,n)finished[i]=false;\n      bool flag = false;\n      while(true){\n        flow_type f = dfs(s,t,INF);\n        if(f==0)break;\n        total += f;\n        flag = true;\n      }\n      if(!flag)break;\n    }\n    return total;\n  }\n};\n\nint h,w;\nchar mp[125][125];\nint dd[] = {1,0,-1,0,1};\n\nint main(){\n  scanf(\"%d%d\",&h,&w);\n  REP(i,h)scanf(\"%s\",mp[i]);\n  // flow\n  dinic g(2*h*w+2);\n  int s=2*h*w;\n  int t=2*h*w+1;\n  REP(i,h)REP(j,w){\n    int id = i*w + j;\n    int x=2*id,y=2*id+1;\n    if(mp[i][j]=='X'){\n      if(i==0||i==h-1||j==0||j==w-1){\n        puts(\"-1\");\n        return 0;\n      }\n      g.add_edge(s,x,INF);\n      g.add_edge(x,y,INF);\n    }else{\n      g.add_edge(x,y,1);\n    }\n    if(i==0||i==h-1||j==0||j==w-1){\n      g.add_edge(y,t,INF);\n    }\n    REP(d,4){\n      int ni=i+dd[d],nj=j+dd[d+1];\n      if(ni<0||ni>=h||nj<0||nj>=w)continue;\n      int nid = ni*w + nj;\n      g.add_edge(y,2*nid,INF);\n    }\n  }\n  printf(\"%d\\n\",g.calc(s,t));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct DinicFlow {\n    static const int INF=(int)1e9+7;\n    vector<int> dist,head,q,work;\n    vector<int> point,capa,flow,next;\n    int n,m;\n\n    DinicFlow() {\n        n=0;m=0;\n    }\n    DinicFlow(int n) {\n        this->n=n;m=0;\n        dist.assign(n+7,0);\n        head.assign(n+7,-1);\n        q.assign(n+7,0);\n        work.assign(n+7,0);\n    }\n    void add(int u,int v,int c1,int c2) {\n        point.push_back(v);capa.push_back(c1);flow.push_back(0);next.push_back(head[u]);head[u]=m++;\n        point.push_back(u);capa.push_back(c2);flow.push_back(0);next.push_back(head[v]);head[v]=m++;\n    }\n    bool bfs(int s,int t) {\n        fill(dist.begin(), dist.end(), -1);\n        int sz=0;\n        q[sz++]=s;dist[s]=0;\n        for (int x=0;x<sz;x=x+1) {\n            int u=q[x];\n            for (int i=head[u];i>=0;i=next[i])\n                if (dist[point[i]]<0 && flow[i]<capa[i]) {\n                    dist[point[i]]=dist[u]+1;\n                    q[sz++]=point[i];\n                }\n        }\n        return (dist[t]>=0);\n    }\n    int dfs(int s,int t,int f) {\n        if (s==t) return (f);\n        for (int &i=work[s];i>=0;i=next[i])\n            if (dist[point[i]]==dist[s]+1 && flow[i]<capa[i]) {\n                int d=dfs(point[i],t,min(f,capa[i]-flow[i]));\n                if (d>0) {\n                    flow[i]+=d;\n                    flow[i^1]-=d;\n                    return (d);\n                }\n            }\n        return (0);\n    }\n    int maxFlow(int s,int t) {\n        int totflow=0;\n        while (bfs(s,t)) {\n            copy(head.begin(), head.end(), work.begin());\n            while (true) {\n                int d=dfs(s,t,INF);\n                if (d<=0) break;\n                totflow+=d;\n            }\n        }\n        return (totflow);\n    }\n    void resetFlow() {\n        fill(flow.begin(), flow.end(), 0);\n    }\n};\n\nconst int N = 100;\nstring s[N];\nint m, n;\n\nint conv(int x, int y, int c) {\n    return x * n + y + c * m * n;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin >> m; cin >> n;\n    for (int i = 0; i < m; ++i) cin >> s[i];\n    int source = m * n * 2, sink = m * n * 2 + 1;\n    DinicFlow f = DinicFlow(m * n * 2 + 2);\n    for (int i = 0; i < m; ++i)\n        for (int j = 0; j < n; ++j)\n            f.add(conv(i, j, 0), conv(i, j, 1), 1, 0);\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (i + 1 < m) {\n                f.add(conv(i, j, 1), conv(i + 1, j, 0), 1000000, 0);\n                f.add(conv(i + 1, j, 1), conv(i, j, 0), 1000000, 0);\n            }\n            if (j + 1 < n) {\n                f.add(conv(i, j, 1), conv(i, j + 1, 0), 1000000, 0);\n                f.add(conv(i, j + 1, 1), conv(i, j, 0), 1000000, 0);\n            }\n            if (i == 0 || i == m - 1 || j == 0 || j == n - 1)\n                f.add(source, conv(i, j, 0), 1000000, 0);\n            if (s[i][j] == 'X')\n                f.add(conv(i, j, 0), sink, 1000000, 0);\n        }\n    }\n    int res = f.maxFlow(source, sink);\n    cout << (res >= 1000000 ? -1 : res) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nchar map[101][101];\nint r,c;\nint cekatas(int X, int y,char a){\n\tfor(int i = 0;i<y;i++){\n\t\tif(map[i][X] == a){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint cekbwh(int X, int y,char a){\n\tfor(int i = r-1;i>y;i--){\n\t\tif(map[i][X] == a){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint cekkiri(int X, int y,char a){\n\tfor(int i = 0;i<X;i++){\n\t\tif(map[y][i] == a){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint cekkanan(int X, int y,char a){\n\tfor(int i = c-1 ;i>X;i--){\n\t\tif(map[y][i] == a){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&r,&c);\n\tfor(int y = 0;y<r;y++){\n\t\tfor(int X = 0;X<c;X++){\n//\t\t\tscanf(\"%c\",&map[y][X]);\n\t\t\tcin>>map[y][X];\n\t\t}\n\t}\n\t//scan pinggir\n\t\n\tfor(int y = 0;y<r;y++){\n\t\tfor(int X = 0;X<c;X++){\n\t\t\tif(X == c-1 || y == 0 || X == 0 || y == r-1){\n\t\t\t\tif(map[y][X] == 'X'){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint p = 0;\n\tfor(int y = 0;y<r;y++){\n\t\tfor(int X = 0;X<c;X++){\n\t\t\tif(map[y][X] == 'X'){\n\t\t\t\t//cek atas\n\t\t\t\tif(!cekatas(X,y,'X') && (map[y-1][X]!='.' || map[y-1][X]!='-')){\n\t\t\t\t\t//gaada X lain diatas\n\t\t\t\t\t//pagar\n\t\t\t\t\tmap[y-1][X] = '+';\n\t\t\t\t}else if( map[y-1][X]=='.'){\n\t\t\t\t\tmap[y-1][X] = '-';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//cek kanan\n\t\t\t\tif(!cekkanan(X,y,'X')&& (map[y][X+1]!='.' || map[y][X+1]!='-')){\n\t\t\t\t\t//gaada X lain\n\t\t\t\t\t//pagar\n\t\t\t\t\tmap[y][X+1] = '+';\n\t\t\t\t}else if( map[y][X+1]=='.'){\n\t\t\t\t\tmap[y][X+1] = '-';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!cekkiri(X,y,'X')&& (map[y][X-1]!='.' || map[y][X-1]!='-')){\n\t\t\t\t\t//gaada X lain\n\t\t\t\t\t//pagar\n\t\t\t\t\tmap[y][X-1] = '+';\n\t\t\t\t}else if(map[y][X-1]=='.'){\n\t\t\t\t\tmap[y][X-1] = '-';\n\t\t\t\t}\n\t\t\t\t//cek bawah\n\t\t\t\tif(!cekbwh(X,y,'X')&& (map[y+1][X]!='.' || map[y+1][X]!='-')){\n\t\t\t\t\t//gaada X lain\n\t\t\t\t\t//pagar\n\t\t\t\t\tmap[y+1][X] = '+';\n\t\t\t\t}else if( map[y+1][X]=='.'){\n\t\t\t\t\tmap[y+1][X] = '-';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int y = 0;y<r;y++){\n\t\tfor(int X = 0;X<c;X++){\n\t\t\tif(map[y][X] == '-'){\n\t\t\t\t//cek atas\n\t\t\t\tif(!cekatas(X,y,'-') && (map[y-1][X]=='.')){\n\t\t\t\t\t//gaada X lain diatas\n\t\t\t\t\t//pagar\n\t\t\t\t\tmap[y-1][X] = '+';\n\t\t\t\t}else if( map[y-1][X]=='.'){\n\t\t\t\t\tmap[y-1][X] = '-';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//cek kanan\n\t\t\t\tif(!cekkanan(X,y,'-')&& (map[y][X+1]=='.' )){\n\t\t\t\t\t//gaada X lain\n\t\t\t\t\t//pagar\n\t\t\t\t\tmap[y][X+1] = '+';\n\t\t\t\t}else if( map[y][X+1]=='.'){\n\t\t\t\t\tmap[y][X+1] = '-';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!cekkiri(X,y,'-')&& (map[y][X-1]=='.')){\n\t\t\t\t\t//gaada X lain\n\t\t\t\t\t//pagar\n\t\t\t\t\tmap[y][X-1] = '+';\n\t\t\t\t}else if(map[y][X-1]=='.'){\n\t\t\t\t\tmap[y][X-1] = '-';\n\t\t\t\t}\n\t\t\t\t//cek bawah\n\t\t\t\tif(!cekbwh(X,y,'-')&& (map[y+1][X]=='.' )){\n\t\t\t\t\t//gaada X lain\n\t\t\t\t\t//pagar\n\t\t\t\t\tmap[y+1][X] = '+';\n\t\t\t\t}else if( map[y+1][X]=='.'){\n\t\t\t\t\tmap[y+1][X] = '-';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int y = 0;y<r;y++){\n\t\tfor(int X = 0;X<c;X++){\n\t\t\tif(map[y][X] == '+')p++;\n\t\t\t//cout<<map[y][X];\n\t\t}//cout<<\"\\n\";\n\t}\n\t\n\tprintf(\"%d\\n\",p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct edge{\n    int to,cap,rev;\n    edge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}\n};\n\nconst int INF=1001001001;\nconst int MAX_V=20010;\nint S=MAX_V-2,T=MAX_V-1;\nvector<edge>G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n    G[from].pb(edge(to,cap,G[to].size()));\n    G[to].pb(edge(from,0,G[from].size()-1));\n}\n\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++){\n        edge &e=G[v][i];\n        if(!used[e.to]&&e.cap>0){\n            int d=dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s,int t){\n    int flow=0;\n    while(true){\n        memset(used,0,sizeof(used));\n        int f=dfs(s,t,INF);\n        if(f==0)return flow;\n        flow+=f;\n    }\n}\n\nint dy[]={-1,0,1,0};\nint dx[]={0,-1,0,1};\n\nint H,W;\nchar fld[111][111];\n\nsigned main(){\n    cin>>H>>W;\n    rep(i,H)cin>>fld[i];\n\n    rep(i,H)rep(j,W){\n        if(fld[i][j]=='#')continue;\n        add_edge(2*(i*W+j),2*(i*W+j)+1,fld[i][j]=='.'?1:INF);\n        rep(d,4){\n            int ny=i+dy[d],nx=j+dx[d];\n            if(ny<0||ny>=H||nx<0||nx>=W)add_edge(2*(i*W+j)+1,T,INF);\n            else if(fld[ny][nx]!='#')add_edge(2*(i*W+j)+1,2*(ny*W+nx),INF);\n        }\n        if(fld[i][j]=='X'){\n            add_edge(S,2*(i*W+j),INF);\n        }\n    }\n\n    int t=max_flow(S,T);\n    if(t<=H*W){\n        cout<<t<<endl;\n    }\n    else{\n        cout<<-1<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans-9<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr,Vpr> PQ;\nconst int INF=1<<30;\nstruct Edge{\npublic:\n\tint to,cost,cp;\n\tEdge *rev;\n\tEdge(int t,int c,int cp):to(t),cost(c),cp(cp){\n\t\t\n\t}\n\tvoid add(int x){\n\t\tcp+=x;\n\t}\n\tvoid flow(int amount){\n\t\tadd(-amount);\n\t\trev->add(amount);\n\t}\n\tbool usable(){\n\t\treturn cp>=1;\n\t}\t\n};\nvoid unite(Edge &a,Edge &b){\n\ta.rev=&b;\n\tb.rev=&a;\n}\nclass Graph{\n\tint nodeSize,edgeSize;\n\tvector<int> dist;\n\tvector<vector<Edge> > edges;\npublic: \n\tvoid add(int a,int b,int cost,int cp){\n\t\tedges[a].PB(Edge(b,cost,cp));\n\t\tedges[b].PB(Edge(a,cost,0));\n\t\tunite(edges[a].back(),edges[b].back());\n\t}\n\tGraph(int x):nodeSize(x){\n\t\t\n\t\tedges=vector<vector<Edge> >(nodeSize);\n\t\tdist=VI(nodeSize);\n\t}\n\tvoid distInit(int s){\n\t\tREP(i,nodeSize){\n\t\t\tdist[i]=INF;\n\t\t}\n\t\tdist[s]=0;\n\t}\n\tint searching(int now,int e,int capacity){\n\t\tif(now==e) return capacity;\n\t\tif(capacity==0) return 0;\n\t\tif(dist[now]>=dist[e]) return 0;\n\t\tint flowed=0;\n\t\tREP(i,edges[now].size()){\n\t\t\tEdge *ed= &edges[now][i];\n\t\t\tif(!ed->usable()) continue;\n\t\t\tif(dist[now]+1 != dist[ed->to]) continue;\n\t\t\tint nflow=searching(ed->to,e,min(capacity-flowed,ed->cp));\n\t\t\tif(nflow){\n\t\t\t\tflowed+=nflow;\n\t\t\t\ted->flow(nflow);\n\t\t\t}\n\t\t}\n\t\treturn flowed;\n\t}\n\tbool bfs(int s,int e){\n\t\tdistInit(s);\n\t\tqueue<int> qu;\n\t\tqu.push(s);\n\t\twhile(!qu.empty()){\n\t\t\tint now=qu.front();\n\t\t\tif(now==e) return true;\n\t\t\tqu.pop();\n\t\t\tREP(i,edges[now].size()){\n\t\t\t\tEdge *ed= &edges[now][i];\n\t\t\t\tif(!ed->usable()) continue;\n\t\t\t\tif(dist[ed->to]==INF){\n\t\t\t\t\tqu.push(ed->to);\n\t\t\t\t\tdist[ed->to]=dist[now]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint maximumFlow(int s,int e){\n\t\tint ans=0;\n\t\tREP(i,100){\n\t\t\tif(bfs(s,e))\n\t\t\t\tans+=searching(s,e,INF);\n\t\t}\n\t\treturn ans;\n\t}\n};\nconst int SIZE=101;\nint conv(int a,int b,int c){return a*100+b+SIZE*SIZE*c+2;}\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\nint H,W;\nint maps[101][101];\nbool isSafe(int y,int x){\n\treturn 0<=y && y<H && 0<=x && x<W;\n}\nint main(){\n\tGraph graph(SIZE*SIZE*3+2);\n\tcin >> H >> W;\n\tREP(i,H) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,s.size()){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(maps[i][j] &&(i==0 || j==0 || i==H-1 || j==W-1)){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\t\t\n\t}\n\tREP(i,H) REP(j,W) {\n\t\tgraph.add(conv(i,j,1),conv(i,j,0),0,1);\n//\t\tedges[conv(i,j,1)].PB(edge(conv(i,j,0),0,1));\n\t\tif(maps[i][j]){\n\t\t\t//edges[0].PB(edge(conv(i,j,1),0,1));\n\t\t\tgraph.add(0,conv(i,j,0),0,4);\n\t\t}\n\t\tREP(k,4){\n\t\t\tif(!isSafe(i+dy[k],j+dx[k])){\n\t\t\tgraph.add(conv(i,j,0),1,0,1);\n\t\t\t//\tedges[conv(i,j,0)].PB(edge(1,0,1));\n\t\t\t} \n\t\t\telse if(!maps[i+dy[k]][j+dx[k]]){\n\t\t\t\tgraph.add(conv(i,j,0),conv(i+dy[k],j+dx[k],1),0,1);\n\t\t\t\tgraph.add(conv(i+dy[k],j+dx[k],0),conv(i,j,1),0,1);\n//\t\t\t\tedges[conv(i,j,0)].PB(edge(conv(i+dy[k],j+dx[k],1),0,1));\n//\t\t\t\tedges[conv(i+dy[k],j+dx[k],0)].PB(edge(conv(i,j,1),0,1));\n\t\t\t}\n\t\t}\n\t\n\t}\n\tcout << graph.maximumFlow(0,1) << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <stdlib.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\nconst ll mod=1000000007;\nconst ll INF=1e15;\n#define REP(i,a,b) for(ll i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n#define pb push_back\nstruct edge{ ll to; ll cap; ll rev;};\nconst ll MAXN=20005;\nvector<edge> G[MAXN];\nll Start=MAXN-2, Goal=MAXN-1;\nbool used[MAXN];\nvector<int> dx={1,0,-1,0}, dy={0,1,0,-1};\n\nvoid addEdge0(ll from, ll to, ll cap){\n    edge A={to,cap,(ll)G[to].size()};\n    edge B={from,0,(ll)G[from].size()};\n    G[from].push_back(A);\n    G[to].push_back(B);\n    return;\n}//有向グラフを作る\n\nvoid addEdge1(ll a, ll b, ll cap){\n    edge A={b,cap,(ll)G[b].size()};\n    edge B={a,cap,(ll)G[a].size()};\n    G[a].push_back(A);\n    G[b].push_back(B);\n    return;\n}//無向グラフを作る\n\nll dfs(ll v, ll t, ll f){\n    if(v==t) return f;\n    used[v]=true;\n    rep(i,G[v].size()){\n        edge &e=G[v][i];\n        if(!used[e.to] && e.cap>0){\n            ll d=dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n\n\nll MaxFlow(){\n    ll ans=0;\n    while(true){\n        rep(i,MAXN) used[i]=false;\n        ll P=dfs(Start,Goal,INF);\n        if(P==0) break;\n        ans+=P;\n    }\n    return ans;\n}\n\nint main(){\n    ll H,W; cin>>H>>W;\n    bool able=true;\n    rep(i,H) {\n        string S; cin>>S;\n        rep(j,W) {\n            ll K=100*i+j;\n            if(S.at(j)=='X'){\n                if(i==0 || i==H-1 || j==0 || j==W-1) able=false;\n                addEdge0(Start,K,INF);\n                addEdge0(K,K+10000,INF);\n            }\n            else addEdge0(K,K+10000,1);\n        }\n    }\n    if(!able) cout<<-1<<endl;\n    else{\n        rep(i,H-1) rep(j,W-1) {\n            ll K=100*i+j;\n            \n            rep(k,2) {\n                ll J=100*(i+dy.at(k))+j+dx.at(k);\n                addEdge0(J+10000,K,INF);\n                addEdge0(K+10000,J,INF);\n            }\n\n        }\n        rep(i,H) rep(j,W) if(i==0 || i==H-1 || j==0 || j==W-1) {\n            ll K=100*i+j;\n            addEdge0(K+10000,Goal,1);\n        }\n\n        cout<<MaxFlow()<<endl;\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr,Vpr> PQ;\nconst int INF=1<<30;\nint H,W;\nint reconv(int x){x-=2;cout << x/(H*W) <<\" \" << x%(H*W)/W <<\" \" << x%(H*W)%W << endl;}\nstruct Edge{\npublic:\n\tint to,cost,cp;\n\tshared_ptr<Edge> rev;\n\tEdge(){to=0;cost=0;cp=0;}\n\tEdge(int a,int b,int c);\n\tvoid add(int x){\n\t\tcp+=x;\n\t}\n\tvoid flow(int amount){\n\t\tadd(-amount);\n\t\trev->add(amount);\n\t}\n\tbool usable(){\n\t\treturn cp>=1;\n\t}\t\n};\nEdge vo;\nEdge::Edge(int t,int c,int cp):to(t),cost(c),cp(cp){\n}\nvoid unite(shared_ptr<Edge> a,shared_ptr<Edge> b){\n\ta->rev=b;\n\tb->rev=a;\n}\n\nqueue<int> qu;\nclass Graph{\n\tint nodeSize,edgeSize;\n\tvector<int> dist;\n\tvector<vector<shared_ptr<Edge>>> edges;\npublic: \n\tvoid add(int a,int b,int cost,int cp){\n\t\t\n\t\tedges[a].PB(make_shared<Edge>(b,cost,cp));\n\t\tedges[b].PB(make_shared<Edge>(a,cost,0));\n\t\tunite(edges[a].back(),edges[b].back());\n\t}\n\tGraph(){}\n\tGraph(int x):nodeSize(x){\n\t\t\n\t\tedges=vector<vector<shared_ptr<Edge>>>(nodeSize);\n\t\tdist=VI(nodeSize);\n\t}\n\tvoid distInit(int s){\n\t\tREP(i,nodeSize){\n\t\t\tdist[i]=INF;\n\t\t}\n\t\tdist[s]=0;\n\t}\n\tint searching(int now,int e,int capacity){\n\t//\tcout << now <<\" \";\n\t//\treconv(now);\n\t\tif(capacity<=0) return 0;\n\t\tif(now==e) return capacity;\n\t\t//if(dist[now]>=dist[e]) return 0;\n\t\tint flowed=0;\n\t\tREP(i,edges[now].size()){\n\t\t\tauto ed= edges[now][i];\n\t\t//\treconv(ed->to);\n\t\t\tif(!ed->usable()) continue;\n\t\t\tif(dist[now]-1 != dist[ed->to]) continue;\n\t\t\tint nflow=searching(ed->to,e,min(capacity-flowed,ed->cp));\n\t\t\tif(nflow){\n\t\t\t\tflowed+=nflow;\n\t\t\t\ted->flow(nflow);\n\t\t\t}\n\t\t\t\n\t\t\tif(flowed) return flowed;\n\t\t}\n\t\treturn flowed;\n\t}\n\tbool bfs(int s,int e){\n\t\tdistInit(s);\n\t\tqueue<int> qu;\n\t\tqu.push(s);\n\t\twhile(!qu.empty()){\n\t\t\tint now=qu.front();\n\t//\t\t// cout << now << endl;\n\t\t\tqu.pop();\n\t\t\tREP(i,edges[now].size()){;\n\t\t\t\tauto ed=edges[now][i];\n\t\t\t\tif(!ed->rev->usable()) continue;\n\t\t\t\tif(dist[ed->to]==INF){\n\t\t\t\t\tqu.push(ed->to);\n\t\t\t\t\tdist[ed->to]=dist[now]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn dist[e]!=INF;\n\t}\n\tint maximumFlow(int s,int e){\n\t\tint ans=0,bef;\n\t\twhile(bfs(e,s)){\n\t\t\tans+=searching(s,e,INF);\n\t\t\tif(ans==bef) break;\n//\t\t\tcout << ans << endl;\n\t\t\tbef=ans;\n\t\t}\n\t\treturn ans;\n\t}\n};\nconst int SIZE=101;\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\nint maps[SIZE][SIZE];\nGraph graph;\nint conv(int a,int b,int c){return a*W+b+H*W*c+2;}\nbool isSafe(int y,int x){\n\treturn 0<=y && y<H && 0<=x && x<W;\n}\nint main(){\n\tcin >> H >> W;\n\tgraph=Graph(SIZE*SIZE*3+3);\n\tREP(i,H) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,W){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(maps[i][j] &&(i==0 || j==0 || i==H-1 || j==W-1)){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t//\t\tcout << maps[i][j];\n\t\t}\t\t\n//\t\tcout << endl;\n\t}\n\tREP(i,H) REP(j,W) {\n\t\tgraph.add(conv(i,j,1),conv(i,j,0),0,1);\n\t\tif(maps[i][j]){\n\t\t\tgraph.add(0,conv(i,j,0),0,4);\n\t\t}\n\t\tREP(k,4){\n\t\t\tif(!isSafe(i+dy[k],j+dx[k])){\n\t\t\t\tgraph.add(conv(i,j,0),1,0,1);\n\t\t\t} \n\t\t\telse{\n\t\t//\t\tcout << i <<\" \" << j <<\" \" << i+dy[k] <<\" \" << j+dx[k] << endl;\n\t\t//\t\tcout << conv(i,j,0) << \" \" << conv(i+dy[k],j+dx[k],1) << endl;\n\t\t\t\tgraph.add(conv(i,j,0),conv(i+dy[k],j+dx[k],1),0,1);\n\t\t\t\tgraph.add(conv(i+dy[k],j+dx[k],0),conv(i,j,1),0,1);\n\t\t\t}\n\t\t}\n\t\n\t}\n\tcout << graph.maximumFlow(0,1) << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n#include <functional>\n#include <chrono>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\nconst long double EPS = 1e-9;\n\nclass FordFulkerson {\n    struct edge {\n        int to, rev;    //行き先，逆辺(のid)\n        long long cap;  //容量\n        edge(int _to, int _rev, long long _cap) {\n            this->to = _to;\n            this->rev = _rev;\n            this->cap = _cap;\n        }\n    };\nprivate:\n    vector<vector<edge>> G;\n    vector<bool> used;\n    long long dfs(int v, int t, long long f) {\n        if (v == t) return f;\n        used[v] = true;\n        for (auto &&el : G[v]) {\n            if (used[el.to] || el.cap <= 0) {\n                continue;\n            }\n            long long d = dfs(el.to, t, min(f, el.cap));\n            if (d > 0) {\n                el.cap -= d;\n                G[el.to][el.rev].cap += d;\n                return d;\n            }\n        }\n        return 0;\n    }\npublic:\n    FordFulkerson() {}\n    FordFulkerson(int n) {\n        G.resize(n);\n        used.resize(n, false);\n    }\n    void add_edge(int from, int to, long long cap) {\n        G[from].emplace_back(edge(to, G[to].size(), cap));\n        G[to].emplace_back(edge(from, G[from].size() - 1, 0));\n    }\n    long long max_flow(int s, int t) {\n        if (s == t) return 0;\n        long long flow = 0;\n        while (1) {\n            fill(begin(used), end(used), false);\n            long long f = dfs(s, t, LLINF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nconst int dx[] = {0, 0, -1, 1};\nconst int dy[] = {1, -1, 0, 0};\nint H, W;\nvector<string> S;\nFordFulkerson ff;\n\nint main(void) {\n    cin >> H >> W;\n    S.resize(H);\n    for (int i = 0; i < H; ++i) {\n        cin >> S[i];\n    }\n    for (int i = 0; i < H; ++i) {\n        if (S[i].front() == 'X' || S[i].back() == 'X') {\n            puts(\"-1\"); return 0;\n        }\n    }\n    for (int j = 0; j < W; ++j) {\n        if (S.front()[j] == 'X' || S.back()[j] == 'X') {\n            puts(\"-1\"); return 0;\n        }\n    }\n    const int MAX = H * W * 2 + 2;\n    ff = FordFulkerson(MAX);\n    const int s = H * W * 2;\n    const int t = H * W * 2 + 1;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            const int num = i * W + j;\n            ff.add_edge(num, num + W * H, (S[i][j] == 'X' ? INF : 1));\n            if (S[i][j] == 'X') {\n                assert(!(i == 0 || i == H - 1 || j == 0 || j == W - 1));\n                ff.add_edge(s, num + W * H, INF);\n            }\n            if (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n                ff.add_edge(num + W * H, t, INF);\n            }\n            assert(num < W * H);\n            for (int k = 0; k < 4; ++k) {\n                const int nh = i + dx[k];\n                const int nw = j + dy[k];\n                if (0 <= nh && nh < H && 0 <= nw && nw < W) {\n                    const int nnum = nh * W + nw;\n                    assert(nnum != s && nnum != t);\n                    ff.add_edge(num + W * H, nnum, INF);\n                }\n            }\n            assert(s != num && t != num);\n        }\n    }\n    cout << ff.max_flow(s, t) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans-7<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n#include <limits>\n#include <functional>\n#include <iomanip>\n#include <complex>\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER) || __cplusplus > 199711L\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) __typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\nusing namespace std;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }\ntypedef complex<double> P;\nint check[105][105];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\nint H,W;\nint ans;\nvector<string> hhoge;\nvoid calc(vpii fuga){\n\tint xmi=101,ymi=101,xma=-1,yma=-1;\n\t\tint a=202,b=202,c=-1,d=-202;\n\tfor(int k=0;k<fuga.size();k++){\n\t\tint i=fuga[k].first,j=fuga[k].second;\n\t\t\t\n\t\t\t\t\ta=min(a,i+j);\n\t\t\t\t\tc=max(c,i+j);\n\t\t\t\t\tb=min(b,i-j);\n\t\t\t\t\td=max(d,i-j);\n\t\t\t\t\txmi=min(xmi,i);\n\t\t\t\t\tymi=min(ymi,j);\n\t\t\t\t\txma=max(xma,i);\n\t\t\t\t\tyma=max(yma,j);\n\t\t\n\t}\n\tif(fuga.size()==0)return;\n\tans+=2*(xma-xmi+1+yma-ymi+1);\n\ta=(a-xmi-ymi);\n\tb=(b+yma-xmi);\n\tc=(xma+yma-c);\n\td=(xma-ymi-d);\n\tans-=(a+b+c+d);\n\t//cout<<ans<<endl;\n}\nvpii data[5000];\nvpii dat;\nmap<pii,int> hoge;\nint cmp;\nvoid dfs(int i,int j){\n\tint x=i,y=j;\n\t//cout<<x<<\" \"<<y<<endl;\n\tif(hoge[mp(x,y)]==1){\n\t\thoge[mp(x,y)]--;\n\t\tdata[cmp].pb(mp(x,y));\n\t}\n\t//cout<<max(0,x-2)<<\" \"<<min(H-1,x+2)<<endl;\n\tfor(int k=max(0,x-2);k<=min(H-1,x+2);k++){\n\t\tfor(int l=max(0,y-2);l<=min(W-1,y+2);l++){\n\t\t\t//cout<<k<<\" \"<<l<<\"\"<<hoge[mp(k,l)]<<endl;\n\t\t\tif(hoge[mp(k,l)]==1){\n\t\t\t\thoge[mp(k,l)]--;\n\t\t\t\tdata[cmp].pb(mp(k,l));\n\t\t\t\tdfs(k,l);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tcin>>H>>W;\n\tstring str;\n\trep(i,H)cin>>str,hhoge.pb(str);\n\t\n\tbool flag=true;\n\tfor(int i=0;i<H;i++){\n\t\tif(i==0||i==H-1){\n\t\t\trep(j,W)if(hhoge[i][j]=='X')flag=false;\n\t\t}else{\n\t\t\tif(hhoge[i][0]=='X')flag=false;\n\t\t\tif(hhoge[i][W-1]=='X')flag=false;\n\t\t}\n\t}\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tif(hhoge[i][j]=='X'){\n\t\t\t\thoge[mp(i,j)]++;\n\t\t\t\tdat.pb(mp(i,j));\n\t\t\t}\n\t\t}\n\t}\n\tcmp=0;\n\tfor(int i=0;i<dat.size();i++){\n\t\tint x=dat[i].first,y=dat[i].second;\n\t\tif(hoge[mp(x,y)]==1){\n\t\t\tdfs(x,y);\n\t\t\tcmp++;\n\t\t}\n\t}\n\tif(flag){\n\t\tans=0;\n\t\tfor(int i=0;i<cmp+1;i++){\n\t\t\tcalc(data[i]);\n\t\t}\n\t\t//cout<<cmp<<endl;\n\t\t//cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl;\n\t\tcout<<ans<<endl;\n\t}else{\n\t\tcout<<\"-1\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n \nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\n// Dinic法:最小カット,最大フローで使う\n// 使い方: Dinic* dinic = new Dinic(V)で初期化(Vは頂点数)\n// dinic->add_edgeまたはdinic->add_edge_bothで点をつなげてdinic->max_flowで最大フローを求める\n#define NG -1\n#define SZ(a) ((int)((a).size()))\nclass Dinic\n{\npublic:\n    Dinic(int input_maxv) : maxv(input_maxv)\n    {\n        G.resize(input_maxv);\n        level.resize(input_maxv);\n        iter.resize(input_maxv);\n    }\n\n    void add_edge_both(int from, int to, int cap)\n    {\n        const int rev_from  = SZ(G[from]);\n        const int rev_to    = SZ(G[to]);\n        G[from].push_back(edge(to,cap,rev_to));\n        G[to].push_back(edge(from,cap,rev_from));\n    }\n\n    void add_edge(int from, int to, int cap)\n    {\n        const int rev_from  = SZ(G[from]);\n        const int rev_to    = SZ(G[to]);\n        G[from].push_back(edge(to,cap,rev_to));\n        G[to].push_back(edge(from,0,rev_from));\n    }\n\n    int max_flow(int s, int t)\n    {\n        int flow = 0;\n        for(;;)\n        {\n            bfs(s);\n            if(level[t]<0) break;\n            fill(iter.begin(),iter.end(),0);\n            int f;\n            while( (f=dfs(s,t,DINIC_INF))>0)\n            {\n                flow += f;\n            }\n        }\n\n        return flow;\n    }\n\n    vector <bool> get_nodes_in_group(int s)\n    {\n        vector <bool> ret(maxv);\n\n        queue<int> que;\n        que.push(s);\n        while(!que.empty())\n        {\n            int v = que.front();\n            que.pop();\n            ret[v]=true;\n\n            for(int i=0;i<SZ(G[v]);i++)\n            {\n                edge &e = G[v][i];\n                if(e.cap>0 && !ret[e.to])\n                {\n                    que.push(e.to);\n                }\n            }\n        }\n        return ret;\n    }\n\n    void disp()\n    {\n        for (int v = 0; v < maxv; v++)\n        {\n            printf(\"%d:\",v);\n            for(int i=0;i<SZ(G[v]);i++)\n            {\n                if(G[v][i].init_cap>0)\n                {\n                    printf(\"->%d(%d),\",G[v][i].to,G[v][i].init_cap);\n                }\n            }\n            printf(\"\\n\");\n        }\n    }\n\nprivate:\n    void bfs(int s)\n    {\n        fill(level.begin(),level.end(),NG);\n        queue<int> que;\n        level[s]=0;\n        que.push(s);\n        while(!que.empty())\n        {\n            int v = que.front();\n            que.pop();\n            for(int i=0;i<SZ(G[v]);i++)\n            {\n                edge &e = G[v][i];\n                if(e.cap>0 && level[e.to]<0)\n                {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    int dfs(int v, int t, int f)\n    {\n        if(v==t) return f;\n        for (int &i=iter[v];i<SZ(G[v]);i++)\n        {\n            edge& e = G[v][i];\n            if(e.cap>0 && level[v]<level[e.to])\n            {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if(d>0)\n                {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    static const int DINIC_INF = INT_MAX;\n\n    struct edge\n    {\n        edge(int input_to, int input_cap, int input_rev) : to(input_to), cap(input_cap), rev(input_rev), init_cap(input_cap) {}\n        int to;\n        int cap;\n        int rev;\n        int init_cap;\n    };\n\n    int maxv;\n    vector < vector <edge> > G;\n    vector < int > level;\n    vector < int > iter;\n\n};\n\nconst int MAXH = 111;\nstring S[MAXH];\n \nvoid no() {\n    cout << -1 << endl;\n    exit(0);\n}\n \nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int H, W;\n    cin >> H >> W;\n    for (int i = 0; i < H; i++)\n        cin >> S[i];\n    for (int i = 0; i < W; i++) {\n        if (S[0][i] == 'X' || S[H-1][i] == 'X') no();\n    }\n    for (int i = 0; i < H; i++) {\n        if (S[i][0] == 'X' || S[i][W-1] == 'X') no();\n    }\n    const int INF = H*W;\n    int s = 2*H*W, t = s+1, V = t+1;\n    Dinic dinic(V);\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int v1 = i*W+j, v2 = v1+H*W;\n            if (S[i][j] == 'X') {\n                dinic.add_edge(v1, v2, INF);\n                dinic.add_edge(s, v1, INF);\n            } else {\n                dinic.add_edge(v1, v2, 1);\n            }\n            if (i == 0 || i == H-1 || j == 0 || j == W-1) {\n                dinic.add_edge(v2, t, 1);\n            }\n            for (int k = 0; k < 4; k++) {\n                int y = i+dy[k], x = j+dx[k];\n                if (y < 0 || y >= H || x < 0 || x >= W) continue;\n                dinic.add_edge(v2, y*W+x, INF);\n            }\n        }\n    }\n    cout << dinic.max_flow(s, t) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MODULE 1000000007\n#define MP make_pair\n\ntemplate<class T, class U>\ninline void chmin(T &t, U f) { if (t > f)t = f; }\n\ntemplate<class T, class U>\ninline void chmax(T &t, U f) { if (t < f)t = f; }\n\ntypedef pair<int, int> P;\ntypedef long long LL;\nconst int INF = INT_MAX / 2;    //int_max->2*e+9\nconst int MAXN = 100001;\n\n/*struct edge {\n    edge(int to, int cost) : to(to), cost(cost) {}\n    int to, cost;\n};\nvector<edge> graph[MAXN];*/\n\nint dx8[8] = {1, 1, 1, 0, -1, -1, -1, 0};\nint dy8[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nint dx4[4] = {0, 0, -1, 1};\nint dy4[4] = {-1, 1, 0, 0};\n//-----Template---------\n\nchar grid[101][101];\nint h, w, sakuCount = 0;\nstring tmp;\n\nbool isValidPos(int x, int y) {\n    return 0 <= x && x < w && 0 <= y && y < h;\n}\n//柵：#　外周柵：o　外周柵2:e　なし：.　チェック済み：x\nvoid putSaku(int x, int y) {\n    for (int i = 0; i < 4; ++i) {\n        int newX = x + dx4[i];\n        int newY = y + dy4[i];\n        if (isValidPos(newX,newY) && grid[newX][newY] != '#') {\n            grid[newX][newY] = '#';\n            sakuCount++;\n        }\n    }\n}\nvoid innerDFS(int x,int y){\n    if(grid[x][y]=='#'){\n        sakuCount--;\n    }\n    grid[x][y]='x';\n    for (int i = 0; i < 4; ++i) {\n        int newX = x + dx4[i];\n        int newY = y + dy4[i];\n        if (isValidPos(newX,newY) && (grid[newX][newY]!='o' && grid[newX][newY]!='e' && grid[newX][newY]!='x')){   //柵2,3でない，または調べ済みでないなら\n            innerDFS(newX,newY);\n        }\n    }\n}\nvoid deleteSaku(int x, int y) {\n    int nowX = x, nowY = y;\n    grid[x][y]='o';\n    int lastI=0;\n    bool flag=true;\n    while (flag) {\n        for (int i = 0; i < 8; ++i) {\n            int nowI = (lastI + i) % 8;\n            int tmpX= nowX + dx8[nowI];\n            int tmpY= nowY + dy8[nowI];\n            if (isValidPos(tmpX,tmpY) && grid[tmpX][tmpY]=='#'){//さくにきたら\n                grid[tmpX][tmpY]='o';\n                nowX=tmpX; nowY=tmpY; lastI=(nowI+4+1)%8; //更新\n                break;\n            }else if(isValidPos(tmpX,tmpY) && grid[tmpX][tmpY]=='o'){//1週したら\n                flag=false;\n                break;\n            }\n        }\n    }\n    flag=true;\n    nowX=x; nowY=y; lastI=0;\n    grid[x][y]='e';\n    while(flag){\n        for (int i = 0; i < 8; ++i) {\n            int nowI = (lastI + i) % 8;\n            int tmpX= nowX + dx8[nowI];\n            int tmpY= nowY + dy8[nowI];\n            if (isValidPos(tmpX,tmpY) && grid[tmpX][tmpY]=='o'){//まず外周探し\n                grid[tmpX][tmpY]='e';\n                innerDFS(nowX+dx8[(lastI+i+1)%8],nowY+dy8[(lastI+i+1)%8]); //1つ入ったところからDFS\n                nowX=tmpX; nowY=tmpY; lastI=(nowI+4+1)%8; //更新\n                break;\n            }else if(isValidPos(tmpX,tmpY) && grid[tmpX][tmpY]=='e'){\n                flag=false;\n                break;\n            }\n        }\n    }\n}\n\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin >> h >> w;\n    for(int j=0;j<h;++j){\n        for(int i=0;i<w;++i){\n            grid[i][j]='.';\n        }\n    }\n    bool cannotPlaceFlag=false;\n    for (int j = 0; j < h; ++j) {\n        cin >> tmp;\n        for (int i = 0; i < tmp.length(); ++i) {//==w\n            if (tmp[i] == 'X') {\n                if(i==0 || i==w-1 || j==0 || j==h-1)\n                    cannotPlaceFlag=true;\n\n                grid[i][j] = 'X';\n                putSaku(i, j);\n            }\n        }\n    }\n    if(!cannotPlaceFlag){\n        for (int j = 0; j < h; ++j) {\n            for (int i = 0; i < w; ++i) {\n                if (grid[i][j] == '#') {\n                    deleteSaku(i, j);\n                }\n            }\n        }\n        cout<<sakuCount<<endl;\n    }else{\n        cout<<-1<<endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mem(x,n) memset(x,n,sizeof(x))\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,l) for(auto it=(l).begin();it!=(l).end();it++)\n#define pnl printf(\"\\n\")\n#define len(x) (x).length()\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\nconst double EPS=1e-10;\n//const double PI=acos(-1.0);\nconst int INF=1<<30;\nconst LL LLINF=1ll<<60;\nconst int MOD=1e9+7;\nconst int xx[8]={1,0,-1,0,1,-1,1,-1};\nconst int yy[8]={0,1,0,-1,-1,1,1,-1};\n\n/****************************************************************************************\\\n  __    __               __ /\\/|   ___ _           _       /\\/|__               __    __\n  \\ \\  / /  _____ __ ____\\ \\/\\/   / __| |__ _ _ __(_)___  |/\\// /____ __ _____  \\ \\  / /\n   \\ \\| |  |___\\ V  V /___| |    | (__| / _` | '_ \\ / -_)    | |___\\ V  V /___|  | |/ /\n    \\_\\ |  |___|\\_/\\_/|___| |     \\___|_\\__,_| .__/_\\___|    | |___|\\_/\\_/|___|  | /_/\n       \\_\\               /_/                 |_|              \\_\\               /_/\n\\****************************************************************************************/\n\nstruct edge{\n\tint v, bf;\n\tLL flow;\n};\n\nconst int MAXN = 20010;\nvector<edge> adj[MAXN];\nint lvl[MAXN], st[MAXN];\nconst int sink = 20008, source = 20009;\nint idx[105][105],idx1[105][105];\nchar input[105][105];\n\nvoid addedge(int u,int v,LL flow){\n\tadj[u].pb({v,sz(adj[v]),flow});\n\tadj[v].pb({u,sz(adj[u]),0});\n}\n\nbool bfs(int S,int G){\n\tqueue<int> q;\n\tmem(lvl,-1);\n\tq.push(S); lvl[S]=0;\n\twhile(!q.empty()){\n\t\tint u = q.front(); q.pop();\n\t\tfor(int i=0;i<sz(adj[u]);i++){\n\t\t\tint v = adj[u][i].v;\n\t\t\tLL flow = adj[u][i].flow;\n\t\t\tif(lvl[v]!=-1||flow<=0) continue;\n\t\t\tlvl[v]=lvl[u]+1;\n\t\t\tq.push(v);\n\t\t}\n\t}\n\treturn (lvl[G]!=-1);\n}\n\nLL dfs(int u,LL mini,int G){\n\tif(u==G) return mini;\n\t\n\tfor(int i=st[u];i<sz(adj[u]);i++){\n\t\tst[u]=i;\n\t\tint v = adj[u][i].v;\n\t\tLL flow = adj[u][i].flow;\n\t\tif(flow<=0||(lvl[v]-lvl[u]!=1)) continue;\n\t\tLL ret=dfs(v,min(mini,flow),G);\n\t\tif(ret>0){\n\t\t\tadj[u][i].flow-=ret;\n\t\t\tint bvf = adj[u][i].bf;\n\t\t\tadj[v][bvf].flow+=ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nLL maxflow(int S,int G){\n\tLL ret=0;\n\twhile(1){\n\t\tif(!bfs(S,G)) break;\n\t\tLL flow = 0;\n\t\tmem(st,0);\n\t\twhile((flow=dfs(S, LLINF, G))>0){\n\t\t\tret+=flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint r,c;\n\tscanf(\"%d%d\",&r,&c);\n\tgetchar();\n\tfor(int i=0;i<r;i++){\n\t\tscanf(\"%s\",input[i]);\n\t}\n\t\n\tint temp=0;\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tidx[i][j]=temp;\n\t\t\tidx1[i][j]=temp+10000;\n\t\t\ttemp++;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(input[i][j]=='.'){\n\t\t\t\taddedge(idx[i][j],idx1[i][j],1);\n\t\t\t\t\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\taddedge(idx1[i][j],sink,INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\taddedge(source,idx[i][j],INF);\n\t\t\t\taddedge(idx[i][j],idx1[i][j],INF);\n\t\t\t\t\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(i!=0) addedge(\tidx1[i][j], idx[i-1][j],INF);\n\t\t\tif(i!=r-1) addedge(\tidx1[i][j], idx[i+1][j],INF);\n\t\t\tif(j!=0) addedge(\tidx1[i][j], idx[i][j-1],INF);\n\t\t\tif(j!=c-1)addedge(\tidx1[i][j], idx[i][j+1],INF);\n\t\t}\n\t}\n\t\n\tLL ans = maxflow(source,sink);\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//諸機能\n#pragma region MACRO \n#define putans(x)  std::cerr << \"answer: \" ; cout << (x) << endl\n#define dputans(x) std::cerr << \"answer: \"; cout << setprecision(13) << (double)(x) << endl\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define RREP(i,a,n) for(int i=(int)(n-1); i>= a; i--)\n#define rep(i,n) REP(i,0,n)\n#define rrep(i,n) RREP(i,0,n)\n#define all(a) begin((a)),end((a))\n#define mp make_pair\n#define exist(container, n) ((container).find((n)) != (container).end())\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#ifdef _DEBUG //ファイルからテストデータを読み込む\nstd::ifstream ifs(\"data.txt\");\n#define put ifs >>\n#else //ジャッジシステムでいい感じにやる\n#define put cin >>\n#endif\n#pragma endregion\n\n//デバッグなどの支援\n#pragma region CODING_SUPPORT\n#define dbg(var0) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << endl; }\n#define dbg2(var0, var1) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg(var1); }\n#define dbg3(var0, var1, var2) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg2(var1, var2); }\n#define dbgArray(a,n) {std::cerr << (#a) << \"=\";  rep(i,n){std::cerr <<(a[i])<<\",\";} cerr<<endl;} \n#ifndef _DEBUG\n#define dbg1 {}\n#define dbg2 {}\n#define dbg3 {}\n#define dbgArray {}\n#endif \n#pragma endregion \n//typedef（書き換える、書き足す可能性ある）\n#pragma region TYPE_DEF\ntypedef long long ll;\ntypedef pair<int, int> pii; typedef pair<string, string> pss; typedef pair<int, string>pis;\ntypedef vector<string> vs; typedef vector<int> vi;\n#pragma endregion\n//諸々の定数(書き換える可能性ある)\n#pragma region CONST_VAL\n#define PI (2*acos(0.0))\n#define EPS (1e-9)\n#define MOD (ll)(1e9 + 7)\n#define INF (ll)(1e9)\n#pragma endregion\n\nclass Point {//幾何上のべクトル\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(x * a, y * a); }\n\tdouble operator * (Point p) { return dot(p); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n\n\tbool operator < (const Point &p) const { return  x != p.x ? x < p.x : y < p.y; }\n\tbool operator == (const Point &p) const { return  fabs(x - p.x) < EPS && fabs(y - p.y) < EPS; }\n\t//内積、外積\n\tdouble dot(Point p) { return x * p.x + y * p.y; }\n\tdouble cross(Point p) { return x * p.y - y * p.x; }\n\n\n};\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\nstruct Segment {//線分\n\tPoint p1, p2;\n};\n\ntypedef Point Vector;\ntypedef Segment Line;//直線\ntypedef vector<Point> Polygon;\n\ndouble v_norm(Point p) { return p.x * p.x + p.y * p.y; }\ndouble abs(Point p) { return v_norm(p); }\ndouble dot(Point p, Point q) { return p.x * q.x + p.y * q.y; }\ndouble cross(Point p, Point q) { return q.x * p.y - p.y * p.x; }\n\n\n\n\n\n//直行、並行\nbool isOrthogonal(Vector a, Vector b) { return equals(a*b, 0.0); }\nbool isParallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\n\n//線分sに対する点pの射影\nPoint projection(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(( p - s.p1 ), base) / v_norm(base);\n\treturn s.p1 + base*r;\n}\n//線分sに対する点pの反射\nPoint reflection(Segment s, Point p) { return p + ( projection(s, p) - p ) * 2; }\n\n\n\n\n//double getDistance(Point a, Point b) { return ( a - b ).abs; }\n//double getDistanceLP(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1)); }\n//double getDistanceSP(Segment s, Point p) {\n//\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n//\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n//}\n\n//double getDistance(Segment s1, Segment s2) {\n//\tif (intersect(s1, s2)) return 0;\n//\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2))\n//\t         , min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2));\n//}\n\n//p1-p0を基準として p2-p0 の2ベクトルについて\nstatic const int COUNTER_CLOCKWISE = 1;//反時計回り\nstatic const int CLOCKWISE = -1;//時計回り\nstatic const int ONLINE_BACK = 2;//同一直線状p2,p0,p1の順\nstatic const int ONLINE_FRONT = 1;//同一直線上p0,p1,p2の順\nstatic const int ON_SEGMENT = 0;//p2がp0,p1上にある場合\nint ccw(Point p0, Point p1, Point p2) {//上記の分類関数\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (v_norm(a) < v_norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n////線分p1p2とp3p4の交差判定\n//bool intersect(Point p1, Point p2, Point p3, Point p4) {return ( (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0) && (ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0));}\n//bool intersect(Segment s1, Segment s2) {return intersect(s1.p1 , s1.p1, s2.p1, s2.p2);}\n//\n//Point getCrossPoint(Segment s1, Segment s2) {\n//\tVector base = s2.p2 - s2.p1;\n//\tdouble d1 = abs(cross(base , s1.p1 - s2.p1));\n//\tdouble d2 = abs(cross(base , s1.p2 - s2.p1));\n//\tdouble t = d1 / ( d1 + d2 );\n//\treturn s1.p1 + (s1.p2 - s1.p1 ) * t;\n//}\n//\n////直線と円の交点を調べる\n//pair<Point, Point> getCrossPoints(Circle c, Line l) {\n//\t//assert(intersect(c, i)); 交差しない場合についてのはず\n//\tVector pr = projection(c, l);\n//\tVector e = ( l.p2 - l.p1 ) / abs(l.p2 - l.p1);\n//\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n//\treturn mp(pr + e * base, pr - e * base);\n//}\n//\n////点の内包を調べる\n//static const int IN_POLYGON = 2;//多角形の内部\n//static const int OUT_POLYGON = 1;//多角形の外部\n//static const int ON_POLYGON = 0;//多角形の線分上\n//int contains(Polygon g, Point p) {\n//\tint n = g.size();\n//\tbool x = false;\n//\trep(i, n) {\n//\t\tPoint a = g[i] - p, b = g[( i + 1 ) % n] - p;\n//\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return OUT_POLYGON;\n//\t\tif (a.y > b.y) swap(a, b);\n//\t\tif (a.y < EPS && EPS < b.y && cross(a, b)) x = !x;\n//\t}\n//\treturn ( x ? IN_POLYGON : ON_POLYGON );\n//}\n\n//凸包\nPolygon ConvexHull(Polygon s) {\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tsort(all(s));\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\n\tfor (int i = 2; i < s.size(); i++) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE; n--)u.pop_back();\n\t\tu.push_back(s[i]);\n\t}\n\n\tfor (int i = s.size()-3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE; n--)l.pop_back();\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(all(l));\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\n/*\n#define i(x) int x; scanf(\"%d\",&x);\n#define l(x) ll x; scanf(\"%lld\",&x);\n#define d(x) double  x; scanf(\"%lf\",&x);\n*/\n//今度実装がんばる\n//https://www23.atwiki.jp/akitaicpc/pages/65.html\n\n\nint main() {\n\t/*double xp1, yp1, xp2, yp2; put xp1 >> yp1 >> xp2 >> yp2;\n\tSegment s;\n\ts.p1 = Point(xp1, yp1);\n\ts.p2 = Point(xp2, yp2);\n\n\tint n; put n;\n\trep(i, n) {\n\t\tPoint p;\n\t\tput p.x >> p.y;\n\t\tPoint prj =reflection(s, p);\n\t\tcout << setprecision(13) << prj.x << \" \" << prj.y << endl;\n\t}*/\n\t//テンプレート化を来世に考える\n\tauto getI = [&]()->auto { int tmp; put tmp; return tmp; };\n\tauto getLL = [&]()->auto { ll tmp; put tmp; return tmp; };\n\tauto getS = [&]()->auto { string tmp; put tmp; return tmp; };\n\tPolygon sheep;\n\tPolygon convex_sheep;\n\tint h, w; put h >> w;\n\trep(i, h) {\n\t\tstring s; put s;\n\t\trep(j, s.size()) {\n\t\t\tif (s[j] == 'X') {\n\t\t\t\tif (i == 0 || j == 0) {\n\t\t\t\t\tputans(-1);\n\t\t\t\t\tgoto END;\n\t\t\t\t}\n\t\t\t\tsheep.push_back(Point(i, j));\n\t\t\t}\n\t\t}\n\t}\n\tconvex_sheep = ConvexHull(sheep);\n\tint num = 0;\n\trep(i, convex_sheep.size()) {\n\t\tPoint s = convex_sheep[i % convex_sheep.size()];\n\t\tPoint g = convex_sheep[(i + 1) % convex_sheep.size()];\n\t\tint mandist = abs(s.x - g.x) + abs(s.y - g.y);\n\t\tnum += mandist;\n\t}\n\tputans(num);\nEND:\n\treturn 0;\n}\n\n//\n//int n, a, b; put n >> a >> b;\n//\tvi t;\n//\trep(i, n) {\n//\t\tt.push_back(get());\n//\t}\n//\tint count = 0;\n//\trep(i, n) {\n//\t\tif (t[i] < a || b <= t[i])count++;\n//\t}\n//\tputans(count);\n\n//\n//\tset<string> list;\n//\tint ans = 0;\n//\tint n; put n;\n//\tint k; put k;\n//\tint numAlphabet[26];\n//\tfill(all(numAlphabet), 0);\n//\trep(i, n) {\n//\t\tstring s; put s;\n//\t\tif (exist(list, s))continue;\n//\t\tlist.insert(s);\n//\t\tnumAlphabet[s[0] - 'A']++;\n//\t}\n//\tsort(all(numAlphabet),greater<int>());\n//\twhile (true) {\n//\t\trep(i, k) {\n//\t\t\tif (numAlphabet[i] == 0) goto END;\n//\t\t\telse numAlphabet[i]--;\n//\t\t}\n//\t\tsort(all(numAlphabet), greater<int>());\n//\t\tans++;\n//\t}\n//END:\n//\tputans(ans);\n\n\n\t//int t; put t;\n\t//rep(i, t) {\n\t//\tint n, d; put n >> d;\n\t//\tif (n == 1) {\n\t//\t\tputans(d);\n\t//\t\tcontinue;\n\t//\t}\n\t//\tputans(n % 2 != 0 ? ( n - 1 ) * 127 + d : ( n - 1 ) * 127 + ( 127 ^ d ));\n\t//}\n\n\n//\n//int n; put n;\n//string s1, s2;\n//string r;\n//string patan1[4] = { \".\",\"#\",\".\",\"#\" };\n//string patan2[4] = { \".\",\".\",\"#\",\"#\" };\n//bool front = true;\n//rep(j, 420 / 4) {\n//\tif (front) {\n//\t\trep(i, 4) {\n//\t\t\tcout << s1 + patan1[i] + \"\\n\" << s2 + patan2[i] << endl;\n//\t\t\tcin >> r;\n//\t\t\tif (r == \"T\") {\n//\t\t\t\ts1 += patan1[i];\n//\t\t\t\ts2 += patan2[i];\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t\tif (r == \"F\" && i == 3) {\n//\t\t\t\tfront = !front;\n//\t\t\t}\n//\t\t\tif (r == \"end\")goto END;\n//\t\t}\n//\t}\n//\telse {\n//\t\trep(i, 4) {\n//\t\t\tcout << patan1[i] + s1 + \"\\n\" << patan2[i] + s2 << endl;\n//\t\t\tcin >> r;\n//\t\t\tif (r == \"T\") {\n//\t\t\t\ts1 = patan1[i] + s1;\n//\t\t\t\ts2 = patan2[i] + s2;\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t\tif (r == \"F\" && i == 3) {\n//\t\t\t\tfront = !front;\n//\t\t\t}\n//\t\t\tif (r == \"end\")goto END;\n//\t\t}\n//\t}\n//\n//}\n//END:\n//cout << endl;"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <utility>\n#include <functional>\n#include <deque>\n#include <cctype>\n#include <stack>\n#include <bitset>\n#include <set>\n\nusing ll = long long;\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\nconst ll MOD = 1000000007;\nconst ll INF = 1 << 30;\nconst ll INF2 = 9000000000000000000LL;\nconst double INF3 = 900000000000000;\nconst int dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\nconst int tx[8] = { -1,0,1,-1,1,-1,0,1 }, ty[8] = { -1,-1,-1,0,0,1,1,1 };\n#define ALL(x) (x).begin(),(x).end()\n\n\nstruct edge { ll to, cap, rev; };\n\nvector<edge>g[101000];\nbool used[101000] = { 0 };\n\nvoid add(ll from, ll to, ll cap) {\n\tg[from].push_back(edge{ to, cap, (ll)g[to].size() });\n\tg[to].push_back(edge{ from, (ll)0, (ll)g[from].size() - 1 });\n}\n\nll dfs(ll v, ll t, ll f) {\n\tif (v == t)return f;\n\tused[v] = true;\n\tfor (int i = 0;i < g[v].size();i++) {\n\t\tedge &e = g[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tg[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nll max_flow(ll s, ll t) {\n\tll flow = 0;\n\tfor (;;) {\n\t\tfill(used, used + 100000, 0);\n\t\tll f = dfs(s, t, INF);\n\t\tif (f == 0)return flow;\n\t\tflow += f;\n\t\tif (flow >= INF)return INF;\n\t}\n}\n\n\n\nint main() {\n\tchar mp[110][110];\n\tint w, h;\n\tcin >> h >> w;\n\tfor (int i = 0;i < h;i++) {\n\t\tfor (int j = 0;j < w;j++) {\n\t\t\tcin >> mp[i][j];\n\t\t}\n\t}\n\n\tint s = 2 * h*w, t = s + 1;\n\tfor (int i = 0;i < h;i++) {\n\t\tfor (int j = 0;j < w;j++) {\n\t\t\tif (mp[i][j] == 'X') {\n\t\t\t\tadd(s, i*w + j, INF);\n\t\t\t\tadd(i*w + j, i*w + j + h*w, INF);\n\t\t\t}\n\t\t\telse add(i*w + j, i*w + j + h*w, 1);\n\t\t\tfor (int k = 0;k < 4;k++) {\n\t\t\t\tint ni = i + dy[k], nj = j + dx[k];\n\t\t\t\tif (ni < 0 || ni >= h || nj < 0 || nj >= w)add(i*w + j + w*h, t, INF);\n\t\t\t\telse add(i*w + j + w*h, ni*w + nj, INF);\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = max_flow(s, t);\n\tif (ans == INF) cout << -1 << endl;\n\telse cout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nclass MaxFlow {\npublic:\n    struct Edge {\n        ll to, cap, rev;\n    };\n    vector<vector<Edge>> G;\n    vector<ll> iter;\nprivate:\n    bool is_debug;\n    ll V;\n    vector<ll> bfs(ll s) {\n        vector<ll> dist(V, linf);\n        dist[s] = 0;\n        queue<ll> Q; Q.push(s);\n        while ( !Q.empty() ) {\n            ll v = Q.front(); Q.pop();\n            each(e, G[v]) {\n                if (e.cap > 0 && dist[e.to] == linf) {\n                    dist[e.to] = dist[v]+1;\n                    Q.push(e.to);\n                }\n            }\n        }\n        return dist;\n    }\n    ll dfs(ll v, ll t, ll f, const vector<ll>& dist, vector<bool>& used) {\n        if (v == t) return f;\n        if (used[v]) return 0;\n        used[v] = true;\n        for (ll& i = iter[v]; i < G[v].size(); ++i) {\n            Edge& e = G[v][i];\n            if (e.cap > 0 && dist[e.to] == dist[v]+1) {\n                ll d = dfs(e.to, t, min(f, e.cap), dist, used);\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\npublic:\n    const vector<vector<Edge>> Graph() {\n        return G;\n    }\n    MaxFlow(ll V, bool is_debug=false) : V(V), G(V), is_debug(is_debug) {}\n    void init(ll n) {\n        V = n;\n        G.assign(V, vector<Edge>());\n    }\n    void add(ll from, ll to, ll cap) {\n        if (is_debug) cout << \"ADD: \" << from << \" \" << to << \" \" << cap << endl;\n        assert(V > 0);\n        G[from].pb({to, cap, (ll)G[to].size()});\n        G[to].pb({from, 0, (ll)G[from].size()-1});\n    }\n    // S -> s, T -> t に inf は自力で\n    void add(ll from, ll to, ll min_flow, ll cap, ll S, ll T) {\n        if (is_debug) cout << endl << \"ADD_MIN:\" << from << \" \" << to << \" \" << min_flow << \" \" << cap << endl;\n        add(from, to, cap-min_flow);\n        add(S, to, min_flow);\n        add(from, T, cap);\n        if (is_debug) cout << endl;\n    }\n    ll flow(ll s, ll t, ll f=linf) {\n        ll res = 0;\n        while (f > 0) {\n            vector<ll> dist = bfs(s);\n            if (dist[t] == linf) break;\n            iter.assign(G.size(), 0);\n            while (f > 0) {\n                vector<bool> used(V, false);\n                ll df = dfs(s, t, f, dist, used);\n                if (df == 0) break;\n                f -= df;\n                res += df;\n            }\n        }\n        return res;\n    }\n};\nconst ll dx[4] = {1, 0, -1, 0};\nconst ll dy[4] = {0, 1, 0, -1};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll h, w; cin >> h >> w;\n    vector<string> m(h); cin >> m;\n    ll lid = 0;\n    vector<vector<ll>> in(h, vector<ll>(w));\n    vector<vector<ll>> out(h, vector<ll>(w));\n    rep(y, h) rep(x, w) {\n        in[y][x] = lid++;\n        out[y][x] = lid++;\n    }\n    ll s = lid++;\n    ll t = lid++;\n    auto inRange = [&](ll x, ll y) {\n        return 0 <= x && x < w && 0 <= y && y < h;\n    };\n    MaxFlow mf(lid);\n    rep(y, h) rep(x, w) {\n        if (m[y][x] == 'X') {\n            mf.add(s, in[y][x], linf);\n            mf.add(in[y][x], out[y][x], linf);\n        }\n        else {\n            mf.add(in[y][x], out[y][x], 1);\n        }\n        bool f = false;\n        rep(d, 4) {\n            ll nx = x + dx[d];\n            ll ny = y + dy[d];\n            if ( !inRange(nx, ny) ) {\n                f = true;\n                continue;\n            }\n            mf.add(out[y][x], in[ny][nx], linf);\n        }\n        if (f) {\n            mf.add(out[y][x], t, linf);\n        }\n    }\n    ll ans = mf.flow(s, t);\n    if (ans >= linf) cout << -1 << endl;\n    else cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&b) { if (a > b)a = b; }\ntemplate<class T> void cmax(T &a, const T&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\numap<ti3, ll> memo;\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//速度ではなくメモリ効率を考えるならrankのかわりにsizeを使う\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\nint main() {\n\tvi d = { 0,1,0,-1,0 };\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> s(h);\n\trep(i, h)cin >> s[i];\n\tbool err = 0;\n\tfor (auto a : s.front())if (a == 'X')err = 1;\n\tfor (auto a : s.back())if (a == 'X')err = 1;\n\tfor (auto &a : s) {\n\t\tif (a.back() == 'X' || a.front() == 'X')err = 1;\n\t}\n\tif (err) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tbool up = 1;\n\twhile (up) {\n\t\tup = 0;\n\t\trep1(i, h - 2)rep1(j, w - 2) {\n\t\t\tif (s[i][j] == '#') {\n\t\t\t\tint cnt = 0;\n\t\t\t\trep(k, 4)if (s[i + d[k]][j + d[k+1]] == '#' || s[i + d[k]][j + d[k+1]] == 'X')cnt++;\n\t\t\t\tif (cnt > 3) {\n\t\t\t\t\tup = 1;\n\t\t\t\t\ts[i][j] = 'X';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[i][j] == 'X') {\n\t\t\t\trep(k, 4)if (s[i + d[k]][j + d[k+1]] == '.') {\n\t\t\t\t\ts[i + d[k]][j + d[k+1]] = '#';\n\t\t\t\t\tup = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0;\n\trep(i, h)rep(j, w)if (s[i][j] == '#')cnt++;\n\tcout << cnt << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < int > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vll vector < ll >\n# define pii pair < int , int >\n# define mp make_pair\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    int n,m;\n    fi>>n>>m;\n    static char s[1024][1024];\n    for (int i = 1;i <= n;++i)\n        fi>>(s[i] + 1);\n    int ans = 0;\n    vector < pii > W;\n    for (int i = 1;i <= n;++i)\n        for (int j = 1;j <= m;++j)\n            if (s[i][j] == 'X')\n            {\n                if (i == 1 || i == n || j == 1 || j == m)\n                    return puts(\"-1\") * 0;\n                W.push_back({i,j});\n                if (s[i-1][j] == '.') s[i-1][j] = '#';\n                if (s[i][j-1] == '.') s[i][j-1] = '#';\n                if (s[i+1][j] == '.') s[i+1][j] = '#';\n                if (s[i][j+1] == '.') s[i][j+1] = '#';\n            }\n    static int was[128][128];\n    const int dx[] = {1,0,-1,0};\n    const int dy[] = {0,1,0,-1};\n    function < int(int,int) > go = [&](int a,int b)\n    {\n        was[a][b] = 1;\n        int ok = 1;\n        for (int k = 0;k < 4;++k)\n        {\n            int na = a + dx[k];\n            int nb = b + dy[k];\n            if (!na || !nb || na == n + 1 || nb == m + 1) return 0;\n            if (!was[na][nb] && s[na][nb] == '.') ok &= go(na,nb);\n        }\n        return ok;\n    };\n    for (int i = 1;i <= n;++i)\n        for (int j = 1;j <= m;++j)\n        if (s[i][j] == '#')\n        {\n            s[i][j] = '.';\n            memset(was,0,sizeof(was));\n            int ok = 1;\n            for (auto it : W)\n                ok &= go(it.x,it.y);\n            if (!ok) s[i][j] = '#';\n        }\n    for (int i = 1;i <= n;++i)\n        for (int j = 1;j <= m;++j)\n            ans += s[i][j] == '#';\n    fo << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar t[200][200];\n\nint ay[200];\nint by[200];\nint ax=1e9,bx=0;\n\nint H,W;\n\nint main(){\n  fill( ay, ay+200, 1e9);\n  fill( by, by+200, 0);\n        \n  \n  cin>>H>>W;\n\n  for(int i=1;i<=H;i++){\n    for(int j=1;j<=W;j++){\n      cin>>t[i][j];\n      if(t[i][j]!='X')continue;\n      if(i==1||j==1||i==H||j==W){\n        cout<<-1<<endl;\n        return 0;\n      }\n      ay[j]=min(ay[j],i);\n      ax=min(ax,j);\n      by[j]=max(by[j],i);\n      bx=max(bx,j);\n    }\n  }\n\n  int ld=0,lu=1e9,rd=0,ru=1e9;\n\n  for(int i=1;i<=W;i++){\n    \n    if(i<ax || bx<i)continue;\n    int dist=i-ax+1;\n\n    \n    lu=min(lu, ay[i]-1+dist);\n    ld=max(ld, by[i]+1-dist);\n   \n    dist=bx-i+1;\n\n    ru=min(ru, ay[i]-1+dist);\n    rd=max(rd, by[i]+1-dist);\n  }\n  \n  //  cout<<ld<<' '<<lu<<' '<<rd<<' '<<ru<<endl;\n  //  cout<<ax<<' '<<bx<<endl;\n  \n  cout<< (ld-lu+1)+(rd-ru+1)+ (bx-ax+1)*2 <<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define for(i, a, b) for(ll (i)=a;(i)<(b);++(i))\n#define rep(i, n)    for(i, 0, n)\n#define MAX_V        20004\n\nconst ll inf = 1e15;\nconst ll mod = 1e9+7;\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nstruct edge {\n    ll to, cap, rev;\n    edge(ll t, ll c, ll r): to(t), cap(c), rev(r){}\n};\n\nvector<edge> G[MAX_V];\nll level[MAX_V];\nll iter[MAX_V];\n\nvoid add_edge(ll from, ll to, ll cap) {\n    G[from].push_back(edge(to, cap, G[to].size()));\n    G[to].push_back(edge(from, 0, G[from].size() - 1));\n}\n\nvoid bfs(ll s) {\n    memset(level, -1, sizeof(level));\n    queue<ll> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n        ll v = que.front(); que.pop();\n        rep(i, G[v].size()) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nll dfs(ll v, ll t, ll f) {\n    if (v == t) return f;\n    for(i, iter[v], G[v].size()) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[v] < level[e.to]) {\n            ll d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nll max_flow(ll s, ll t) {\n    ll flow = 0;\n    while (true) {\n        bfs(s);\n        if (level[t] < 0) return flow;\n        memset(iter, 0, sizeof(iter));\n        ll f;\n        while ((f = dfs(s, t, inf)) > 0) {\n            flow += f;\n        }\n    }\n}\n\nint main() {\n    ll H, W; cin >> H >> W;\n    \n    ll S = 2 * H * W;\n    ll T = 2 * H * W + 1;\n    rep(i, H) rep(j, W) {\n        char c; cin >> c;\n        if (c == 'X') add_edge(S, i * W + j, inf);\n        add_edge(i * W + j, H * W + i * W + j, c == 'X' ? inf : 1);\n        rep(k, 4) {\n            if (i+dy[k] < 0 || H-1 < i+dy[k] || j+dx[k] < 0 || W-1 < j+dx[k]) {\n                add_edge(H * W + i * W + j, T, inf);\n            } else {\n                add_edge(H * W + i * W + j, (i+dy[k]) * W + (j+dx[k]), inf);\n                add_edge(H * W + (i+dy[k]) * W + (j+dx[k]), i * W + j, inf);\n            }\n        }\n    }\n    ll f = max_flow(S, T);\n    cout << (f < inf ? f : -1) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T> using Graph = vector<vector<T>>;\n\n#define REP(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (__typeof(a.begin()) x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define endl '\\n'\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint H, W;\nstring S[105];\nbool used[105][105];\n\nbool is_surrounded(int x, int y) {\n  if (x == 0 || x == W - 1 || y == 0 || y == H - 1) return false;\n  used[y][x] = true;\n  bool res = true;\n  rep(i, 4) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if (used[ny][nx]) continue;\n    if (S[ny][nx] == '.') {\n      res &= is_surrounded(nx, ny);\n      if (!res) break;\n    }\n  }\n  used[y][x] = false;\n  return res;\n}\n\nint solve() {\n  rep(i, W) if (S[0][i] == 'X' || S[H - 1][i] == 'X') return -1;\n  rep(i, H) if (S[i][0] == 'X' || S[i][W - 1] == 'X') return -1;\n\n  int ans = 0;\n  rep(y, H - 1) rep(x, W - 1) {\n    if (S[y][x] != 'X') continue;\n    rep(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (S[ny][nx] == '.') {\n        S[ny][nx] = '#';\n        ans += 1;\n      }\n    }\n  }\n\n  rep(loop, 300) {\n    REP(y, 1, H - 1) REP(x, 1, W - 1) {\n      if (S[y][x] == '#') {\n        int cnt = 0;\n        rep(i, 4) {\n          int nx = x + dx[i], ny = y + dy[i];\n          if (S[ny][nx] == 'X' || S[ny][nx] == '#') cnt++;\n        }\n        if (cnt == 3) rep(i, 4) {\n          int nx = x + dx[i], ny = y + dy[i];\n          if (S[ny][nx] == '.') {\n            S[ny][nx] = '#';\n            ans += 1;\n          }\n        }\n      }\n    }\n    REP(y, 1, H - 1) REP(x, 1, W - 1) {\n      if (S[y][x] == '.') {\n        int cnt = 0;\n        rep(i, 4) {\n          int nx = x + dx[i], ny = y + dy[i];\n          if (S[ny][nx] == 'X' || S[ny][nx] == '#') cnt++;\n        }\n        if (cnt == 4) rep(i, 4) {\n          S[y][x] = '#';\n          ans += 1;\n        }\n      }\n    }\n  }\n\n  REP(y, 1, H - 1) REP(x, 1, W - 1) {\n    if (S[y][x] == '#') {\n      int cnt = 0;\n      rep(i, 4) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (S[ny][nx] == 'X' || S[ny][nx] == '#' || S[ny][nx] == '-') cnt++;\n      }\n      if (cnt == 4) {\n        ans -= 1;\n        S[y][x] = '-';\n      }\n    }\n  }\n\n  REP(y, 1, H - 1) REP(x, 1, W - 1) {\n    if (S[y][x] == '#') {\n      if (is_surrounded(x, y)) {\n        ans -= 1;\n        S[y][x] = '-';\n      }\n    }\n  }\n\n  return ans;\n}\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> H >> W;\n  rep(i, H) cin >> S[i];\n\n  cout << solve() << endl;\n  //rep(i, H) cout << S[i] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<28\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int dy[4] = {-1, 0, 1, 0};\nconst int dx[4] = { 0, 1, 0,-1};\nchar field[102][102];\nint d[102][102];\nint H, W;\nbool bfs(char target, int sy, int sx){\n\tqueue<P> que;\n\trep (i, 102) rep (j, 102) d[i][j] = INF;\n\tque.push(P(sy,sx));\n\td[sy][sx] = 0;\n\t\n\twhile(!que.empty()){\n\t\tP curr = que.front(); que.pop();\n\t\tint cy = curr.first;\n\t\tint cx = curr.second;\n\n\t\tif (cy == 0 || cy == H+1 || cx == 0 || cx == W+1){\n\t\t\treturn true;\n\t\t} // end if\n\t\trep(k, 4){\n\t\t\tint ny = cy + dy[k];\n\t\t\tint nx = cx + dx[k];\n\t\t\tif (ny < 0 || ny > H + 1 || nx < 0 || nx > W + 1) continue;\n\t\t\t\n\t\t\tif (d[ny][nx] == INF){\n\t\t\t\tif(\n\t\t\t\t\t   ((target == 'O') && (field[ny][nx] == '.'))\n\t\t\t\t\t|| ((target == 'X') && (field[ny][nx] == target || field[ny][nx] == '.'))\n\t\t\t\t){\n\t\t\t\t\tque.push(P(ny,nx));\n\t\t\t\t\td[ny][nx] = d[cy][cx] + 1;\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end while\n\n\treturn false;\t\n}\n\n\nint main()\n{\n\tmemset (field, 0, sizeof(field));\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\trep (i, 102) rep (j, 102) field[i][j] = '.';\n\tcin >> H >> W;\n\tvector<string> s(H);\n\trep (i, H) cin >> s[i];\n\n\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tfield[i][j] = s[i-1][j-1];\n\t\t} // end for\n\t} // end for\n\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tif (field[i][j] == 'X'){\n\t\t\t\trep (k, 4){\n\t\t\t\t\tint ny = i + dy[k];\n\t\t\t\t\tint nx = j + dx[k];\n\t\t\t\t\tif (ny <= 0 || ny >= H + 1 || nx <= 0 || nx >= W + 1) continue;\n\t\t\t\t\tif (field[ny][nx] != '.') continue;\n\t\t\t\t\tfield[ny][nx] = 'O';\n\t\t\t\t} // end rep\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end rep\n\n\tbool escape = false;\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tif (field[i][j] == 'O'){\n\t\t\t\tbool curr = bfs(field[i][j], i, j);\n\t\t\t\tif (!curr) field[i][j] = '.';\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\tescape = false;\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tif (field[i][j] == 'X'){\n\t\t\t\tbool curr = bfs(field[i][j], i, j);\n\t\t\t\tif (curr) escape |= true;\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\tint res = 0;\n\tif (escape){\n\t\tres = -1;\n\t}else{\n\t\tfor (int i = 1; i <= H; ++i){\n\t\t\tfor (int j = 1; j <= W; ++j){\n\t\t\t\tres += (int)(field[i][j] == 'O');\n\t\t\t} // end for\n\t\t} // end for\n\t} // end if\n\tcout << res << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105];\nbool fr[105][105],vis[105][105],st,ad,f;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tf=1;\n//\t\t\t\t\tad = f = 0;\n//\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n//\t\t\t\t\tif(ad){\n//\t\t\t\t\t\trep(o,b+1,m){\n//\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n//\t\t\t\t\t\t\tx[a][o] = '#';\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\tsolve();\n//\t\t\t\t\t\tif(ans>tmp){\n//\t\t\t\t\t\t\tans = tmp;\n//\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n//\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tf=1;\n//\t\t\t\t\tad = f = 0;\n//\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n//\t\t\t\t\tif(ad){\n//\t\t\t\t\t\trep(o,b+1,m){\n//\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n//\t\t\t\t\t\t\tx[a][o] = '#';\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\tsolve();\n//\t\t\t\t\t\tif(ans>tmp){\n//\t\t\t\t\t\t\tans = tmp;\n//\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n//\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n){\n\t\trep(j,1,m)cout<<x[i][j];\n\t\tcout<<endl;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <tuple>\n#include <algorithm>\n#include <functional>\n#include <cstring>\n#include <limits.h>\n#define FOR(i,k,n)  for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n)    FOR(i,0,n)\n#define FORIT(i,c)\tfor(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define SZ(i) ((int)i.size())\n#define pb          push_back\n#define mp          make_pair\n#define mt          make_tuple\n#define get0(x)     (get<0>(x))\n#define get1(x)     (get<1>(x))\n#define get2(x)     (get<2>(x))\n#define ALL(X)      (X).begin(),(X).end()\n#define LLMAX       9223372036854775807LL\n#define LLMIN       -9223372036854775808LL\n#define IMAX        2147483647\n#define IMIN        -2147483648\ntypedef long long LL;\nusing namespace std;\n\n#define MAX_V 200000+4\n\nstruct Edge{ int to,cap,rev; };\nint used[MAX_V];\nvector<Edge> G[MAX_V];\n\nvoid addEdge(int from,int to,int cap){\n    G[from].push_back((Edge){to,cap,(int)G[to].size()});\n    G[to].push_back((Edge){from,0,(int)G[from].size()-1});\n}\nint DFS(int v,int t,int f){\n    if(v==t)\n        return f;\n    used[v]=true;\n    for(int i=0;i<(int)G[v].size();i++){\n        Edge &e=G[v][i];\n        if(!used[e.to] && 0<e.cap){\n            int d=DFS(e.to,t,min(f,e.cap));\n            if(0<d){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\nint maxFlow(int s,int t){\n    int flow=0;\n    while(1){\n        for(int i=0;i<MAX_V;i++)\n            used[i]=false;\n        int f=DFS(s,t,INT_MAX);\n        if(f==0)\n            break;\n        flow+=f;\n    }\n    return flow;\n}\n\nconst int INF = 1e8;\n\nint main(void){\n    int H,W;cin>>H>>W;\n    vector<string> vs;\n    REP(i,H){string s;cin>>s;vs.pb(s);}\n\n    int d[4][2]={{-1,0},{1,0},{0,-1},{0,1}};\n    REP(i,H)\n        REP(j,H){\n            addEdge(i*W+j,2*(i*W+j),1);\n            if(i==0||j==0||i==H-1||j==W-1)\n                addEdge(i*W+j,2*H*W,INF);\n            if(vs[i][j]=='X')\n                addEdge(2*(H*W+1),i*W+j,INF);\n            REP(k,4){\n                int ii=i+d[k][0],jj=j+d[k][1];\n                if(0<=ii&&ii<H&&0<=jj&&jj<W)\n                    addEdge(2*(i*W+j),ii*W+jj,1);\n            }\n        }\n\n    int f=maxFlow(2*(H*W+1),2*H*W);\n    if(INF<=f)\n        cout<<-1<<endl;\n    else\n        cout<<f-1<<endl;\n     return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 12345\n#define INF (1<<29)\n\nstruct edge {\n    int to, cap, rev;\n    edge (int to, int cap, int rev) :\n        to(to), cap(cap), rev(rev) {}\n};\n\nvector<edge> G[MAX_V];\nint level[MAX_V], iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap)\n{\n    G[from].push_back(edge(to, cap, G[to].size()));\n    G[to].push_back(edge(from, 0, G[from].size()-1));\n}\n\nvoid bfs(int s)\n{\n    memset(level, -1, sizeof(level));\n    queue<int> Q;\n    level[s] = 0;\n    Q.push(s);\n    while (!Q.empty()) {\n\tint v = Q.front(); Q.pop();\n\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t    edge &e = G[v][i];\n\t    if (e.cap > 0 && level[e.to] < 0) {\n\t\tlevel[e.to] = level[v] + 1;\n\t\tQ.push(e.to);\n\t    }\n\t}\n    }\n}\n\nint dfs(int v, int t, int f)\n{\n    if (v == t) return f;\n    for (int &i = iter[v]; i < (int)G[v].size(); i++) {\n\tedge &e = G[v][i];\n\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t    int d = dfs(e.to, t, min(f, e.cap));\n\t    if (d > 0) {\n\t\te.cap -= d;\n\t\tG[e.to][e.rev].cap += d;\n\t\treturn d;\n\t    }\n\t}\n    }\n    return 0;\n}\n\nint max_flow(int s, int t)\n{\n    int flow = 0;\n    for (;;) {\n\tbfs(s);\n\tif (level[t] < 0) return flow;\n\tmemset(iter, 0, sizeof(iter));\n\tint f;\n\twhile ((f = dfs(s, t, INF)) > 0) {\n\t    flow += f;\n\t}\n    }\n}\n\nbool is_outside(int x, int y, int W, int H)\n{\n    return (x == 0 || x == W - 1 || y == 0 || y == H - 1);\n}\n\nint solve(int H, int W,\n          vector<vector<char>> &S)\n{\n    int src = 2 * H * W, sink = src + 1;\n    const int di[] = {-1, +0, +1, +0};\n    const int dj[] = {+0, -1, +0, +1};\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int u = i * W + j, v = H * W + u;\n            \n            if (S[i][j] == 'X') {\n                if (is_outside(j, i, W, H)) {\n                    return -1;\n                }\n                add_edge(src, u, INF);\n                add_edge(u, v, INF);\n            } else {\n                add_edge(u, v, 1);\n            }\n\n            if (is_outside(j, i, W, H)) {\n                add_edge(v, sink, INF);                \n            }\n            \n            for (int k = 0; k < 4; k++) {\n                int ni = i + di[k];\n                int nj = j + dj[k];\n                if (0 <= ni && ni < H && 0 <= nj && nj < W) {\n                    add_edge(v, ni * W + nj, INF);\n                }\n            }\n        }\n    }\n    return max_flow(src, sink);\n}\n\nint main()\n{\n    int H, W;\n    cin >> H >> W;\n    vector<vector<char>> S(H, vector<char>(W));\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> S[i][j];\n        }\n    }\n    cout << solve(H, W, S) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\n\n////フォード - ファルカーソン法 O(Flow|E|)\n\ntypedef int Weight;\n\nconst Weight INF = 1e9;\nconst Weight ZERO = 0;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint rev;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_, const int rev_,const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_), rev(rev_),id(id_) { }\n\tEdge(int src_, int dst_, Weight weight_,const int rev_) :\n\t\tsrc(src_), dst(dst_), weight(weight_),rev(rev_) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\t}\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph&g,int from, int to, int cap)\n{\n\tg[from].push_back(Edge ( from,to, cap, (int)g[to].size() ));\n\tg[to].push_back(Edge ( to,from, 0, (int)g[from].size() - 1 ));\n}\nint dfs(vector<int>&used,Graph&g,int now, int t, int f)\n{\n\tif (now == t) {\n\t\treturn f;\n\t}\n\tused[now] = true;\n\tfor (int i = 0; i<g[now].size(); ++i) {\n\t\tEdge &e = g[now][i];\n\t\tif (!used[e.dst] && e.weight>0) {\n\t\t\tint d = dfs(used,g,e.dst, t, min(f, e.weight));\n\t\t\tif (d > 0) {\n\t\t\t\te.weight -= d;\n\t\t\t\tg[e.dst][e.rev].weight += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nWeight fold_falc(Graph g,const int start,const int goal) {\n\tWeight ans = 0;\n\twhile (1) {\n\t\tvector<int>used(g.size());\n\t\tint flow = dfs(used, g, start, goal, INF);\n\t\tif (!flow)return ans;\n\t\telse ans += flow;\n\t}\n}\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tvector<vector<int>>field(H, vector<int>(W));\n\tfor (int i = 0; i < H; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tfield[i][j] = st[j] == 'X';\n\t\t}\n\t}\n\tbool ok = true;\n\tfor (int i = 0; i < H; ++i) {\n\t\tif (field[i][0])ok = false;\n\t\tif (field[i][W - 1])ok = false;\n\t}\n\tfor (int i = 0; i < W; ++i) {\n\t\tif (field[0][i])ok = false;\n\t\tif (field[H - 1][i])ok = false;\n\t}\n\tif (!ok)cout << -1 << endl;\n\telse {\n\t\tconst int start = 0;\n\t\tconst int nodein = start + 1;\n\t\tconst int nodeout = nodein + H*W;\n\t\tconst int goal = nodeout + H*W;\n\t\tGraph g(goal+1);\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (field[i][j] == 1) {\n\t\t\t\t\tadd_edge(g, start, nodeout + i*W + j, 1e6);\n\t\t\t\t}\n\t\t\t\tif (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n\t\t\t\t\tadd_edge(g, nodeout + i*W + j,goal, 1e6);\n\t\t\t\t}\n\t\t\t\tadd_edge(g, nodein + i*W + j, nodeout + i*W + j, 1);\n\t\t\t\tfor (int way = 0; way < 4; ++way) {\n\n\t\t\t\t\tconst int nx = j + dx[way];\n\t\t\t\t\tconst int ny = i + dy[way];\n\t\t\t\t\tif (nx >= 0 && nx < W&&ny >= 0 && ny < H) {\n\t\t\t\t\t\tadd_edge(g, nodeout + i*W + j, nodein + ny*W + nx,1e6);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = fold_falc(g, start, goal);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n\nint n,m,nr,nc,cnt,ans,hit;\nchar x[105][105];\nbool fr[105][105],vis[105][105];\nqueue<pii> q;\n\nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n\nvoid mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\n\nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#', q.push({i+dr[k],j+dc[k]});\n\t}\n\tmk();\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tint r,c;\n\trep(tes,1,100000000){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size())break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0, mk();\n\t\telse if(!cnt)x[r][c] = '.', hit = 0, mk();\n\t\telse q.push({r,c}), ++hit;\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<fr[i][j];\n//\t\tcout<<endl;\n//\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++ans;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define SPEED ios::sync_with_stdio(false); cin.tie(0); cout.tie(0)\n#define fileio freopen(\"in.in\", \"r\", stdin),freopen(\"out.out\", \"w\", stdout);\n#define ll long long int\n#define FF first\n#define SS second\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<long long int,long long int>\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define pd(x) printf(\"%d\\n\",x)\n#define plld(x) printf(\"%lld\\n\",x)\n#define pss printf\n#define MOD 1000000007\n#define INF 1e9\n#define eps 0.00001\n#define endl '\\n'\n#define debug(n1) cout<<n1<<endl\nll h,w;\nbool vis[105][105];\nstring s;\nll get(ll i,ll j)\n{\n\treturn (i-1)*w+j;\n}\ntypedef long long LL;\n\nstruct Edge {\n  int from, to, cap, flow, index;\n  Edge(int from, int to, int cap, int flow, int index) :\n    from(from), to(to), cap(cap), flow(flow), index(index) {}\n};\n\nstruct PushRelabel {\n  int N;\n  vector<vector<Edge> > G;\n  vector<LL> excess;\n  vector<int> dist, active, count;\n  queue<int> Q;\n\n  PushRelabel(int N) : N(N), G(N), excess(N), dist(N), active(N), count(2*N) {}\n\n  void AddEdge(int from, int to, int cap) {\n    G[from].push_back(Edge(from, to, cap, 0, G[to].size()));\n    if (from == to) G[from].back().index++;\n    G[to].push_back(Edge(to, from, 0, 0, G[from].size() - 1));\n  }\n\n  void Enqueue(int v) { \n    if (!active[v] && excess[v] > 0) { active[v] = true; Q.push(v); } \n  }\n\n  void Push(Edge &e) {\n    int amt = int(min(excess[e.from], LL(e.cap - e.flow)));\n    if (dist[e.from] <= dist[e.to] || amt == 0) return;\n    e.flow += amt;\n    G[e.to][e.index].flow -= amt;\n    excess[e.to] += amt;    \n    excess[e.from] -= amt;\n    Enqueue(e.to);\n  }\n  \n  void Gap(int k) {\n    for (int v = 0; v < N; v++) {\n      if (dist[v] < k) continue;\n      count[dist[v]]--;\n      dist[v] = max(dist[v], N+1);\n      count[dist[v]]++;\n      Enqueue(v);\n    }\n  }\n\n  void Relabel(int v) {\n    count[dist[v]]--;\n    dist[v] = 2*N;\n    for (int i = 0; i < G[v].size(); i++) \n      if (G[v][i].cap - G[v][i].flow > 0)\n\tdist[v] = min(dist[v], dist[G[v][i].to] + 1);\n    count[dist[v]]++;\n    Enqueue(v);\n  }\n\n  void Discharge(int v) {\n    for (int i = 0; excess[v] > 0 && i < G[v].size(); i++) Push(G[v][i]);\n    if (excess[v] > 0) {\n      if (count[dist[v]] == 1) \n\tGap(dist[v]); \n      else\n\tRelabel(v);\n    }\n  }\n\n  LL GetMaxFlow(int s, int t) {\n    count[0] = N-1;\n    count[N] = 1;\n    dist[s] = N;\n    active[s] = active[t] = true;\n    for (int i = 0; i < G[s].size(); i++) {\n      excess[s] += G[s][i].cap;\n      Push(G[s][i]);\n    }\n    \n    while (!Q.empty()) {\n      int v = Q.front();\n      Q.pop();\n      active[v] = false;\n      Discharge(v);\n    }\n    \n    LL totflow = 0;\n    for (int i = 0; i < G[s].size(); i++) totflow += G[s][i].flow;\n    return totflow;\n  }\n};\nint main()\n{\n\tSPEED;\n\tmemset(vis,1,sizeof vis);\n\tcin>>h>>w;\n\tfor(int i=1;i<=h;i++)\n\t{\n\t\tcin>>s;\n\t\tfor(int j=1;j<=w;j++)\n\t\t{\n\t\t\tif(s[j-1]!='X')\n\t\t\t{\n\t\t\t\tvis[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=h;i++)\n\t\tif(vis[i][1]||vis[i][w])\n\t\t\treturn cout<<-1<<endl,0;\n\tfor(int i=1;i<=w;i++)\n\t\tif(vis[1][i]||vis[h][i])\n\t\t\treturn cout<<-1<<endl,0;\n\tPushRelabel pr(2*h*w+5);\n\tfor(int i=1;i<=h;i++)\n\t\tfor(int j=1;j<=w;j++)\n\t\t\tpr.AddEdge(get(i,j),get(i,j)+h*w,(vis[i][j]?INF:1));\n\tfor(int i=1;i<=h;i++)\n\t{\n\t\tfor(int j=1;j<=w;j++)\n\t\t{\n\t\t\tif(vis[i][j])\n\t\t\t\tpr.AddEdge(0,get(i,j),INF);\n\t\t\tif(!vis[i-1][j])\n\t\t\t\tpr.AddEdge(get(i,j)+h*w,get(i-1,j),INF);\n\t\t\tif(!vis[i+1][j])\n\t\t\t\tpr.AddEdge(get(i,j)+h*w,get(i+1,j),INF);\n\t\t\tif(!vis[i][j-1])\n\t\t\t\tpr.AddEdge(get(i,j)+h*w,get(i,j-1),INF);\n\t\t\tif(!vis[i][j+1])\n\t\t\t\tpr.AddEdge(get(i,j)+h*w,get(i,j+1),INF);\n\t\t}\n\t}\n\tfor(int i=1;i<=h;i++)\n\t{\n\t\tpr.AddEdge(h*w+get(i,1),2*h*w+1,INF);\n\t\tpr.AddEdge(h*w+get(i,w),2*h*w+1,INF);\n\t}\n\tfor(int i=1;i<=w;i++)\n\t{\n\t\tpr.AddEdge(h*w+get(1,i),2*h*w+1,INF);\n\t\tpr.AddEdge(h*w+get(h,i),2*h*w+1,INF);\n\t}\n\tcout<<pr.GetMaxFlow(0,2*h*w+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int vy[] = {0, 1, 0, -1}, vx[] = {1, 0, -1, 0};\n\nint H, W;\nstring S[100];\nbool v[100][100];\nbool flag[100][100];\n\nbool isover(int y, int x)\n{\n  return (y < 0 || y >= H || x < 0 || x >= W);\n}\n\nbool dfs(int y, int x)\n{\n  if(isover(y, x)) return (true);\n  if(v[y][x]++) return (false);\n  for(int i = 0; i < 4; i++) {\n    int ny = y + vy[i], nx = x + vx[i];\n    if(!isover(ny, nx) && flag[ny][nx] && S[ny][nx] == '.') continue;\n    if(dfs(ny, nx)) return (true);\n  }\n  return (false);\n}\n\nint main()\n{\n  cin >> H >> W;\n  for(int i = 0; i < H; i++) {\n    cin >> S[i];\n  }\n\n  for(int i = 0; i < H; i++) {\n    if(S[i][0] == 'X' || S[i][W - 1] == 'X') {\n      cout << -1 << endl;\n      return (0);\n    }\n  }\n  for(int i = 0; i < W; i++) {\n    if(S[0][i] == 'X' || S[H - 1][i] == 'X') {\n      cout << -1 << endl;\n      return (0);\n    }\n  }\n\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      for(int k = 0; k < 4; k++) {\n        if(S[i][j] == 'X') flag[i + vy[k]][j + vx[k]] = true;\n      }\n    }\n  }\n\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      flag[i][j] = false;\n      if(S[i][j] == 'X') continue;\n      bool judge = false;\n      memset(v, false, sizeof(v));\n      for(int k = 0; k < H; k++) {\n        for(int l = 0; l < W; l++) {\n          if(S[k][l] == 'X') judge |= dfs(k, l);\n        }\n      }\n      if(judge) flag[i][j] = true;\n    }\n  }\n\n  int ret = 0;\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      ret += flag[i][j];\n    }\n  }\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mem(x,n) memset(x,n,sizeof(x))\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,l) for(auto it=(l).begin();it!=(l).end();it++)\n#define pnl printf(\"\\n\")\n#define len(x) (x).length()\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\nconst double EPS=1e-10;\n//const double PI=acos(-1.0);\nconst int INF=1<<30;\nconst LL LLINF=1ll<<60;\nconst int MOD=1e9+7;\nconst int xx[8]={1,0,-1,0,1,-1,1,-1};\nconst int yy[8]={0,1,0,-1,-1,1,1,-1};\n\n/****************************************************************************************\\\n  __    __               __ /\\/|   ___ _           _       /\\/|__               __    __\n  \\ \\  / /  _____ __ ____\\ \\/\\/   / __| |__ _ _ __(_)___  |/\\// /____ __ _____  \\ \\  / /\n   \\ \\| |  |___\\ V  V /___| |    | (__| / _` | '_ \\ / -_)    | |___\\ V  V /___|  | |/ /\n    \\_\\ |  |___|\\_/\\_/|___| |     \\___|_\\__,_| .__/_\\___|    | |___|\\_/\\_/|___|  | /_/\n       \\_\\               /_/                 |_|              \\_\\               /_/\n\\****************************************************************************************/\n\nstruct edge{\n\tint v, bf;\n\tLL flow;\n};\n\nconst int MAXN = 405;\nvector<edge> adj[MAXN];\nint lvl[MAXN], st[MAXN];\nconst int sink = 403, source = 404;\nint idx[105][105],idx1[105][105];\nchar input[105][105];\n\nvoid addedge(int u,int v,LL flow){\n\tadj[u].pb({v,sz(adj[v]),flow});\n\tadj[v].pb({u,sz(adj[u]),0});\n}\n\nbool bfs(int S,int G){\n\tqueue<int> q;\n\tmem(lvl,-1);\n\tq.push(S); lvl[S]=0;\n\twhile(!q.empty()){\n\t\tint u = q.front(); q.pop();\n\t\tfor(int i=0;i<sz(adj[u]);i++){\n\t\t\tint v = adj[u][i].v;\n\t\t\tLL flow = adj[u][i].flow;\n\t\t\tif(lvl[v]!=-1||flow<=0) continue;\n\t\t\tlvl[v]=lvl[u]+1;\n\t\t\tq.push(v);\n\t\t}\n\t}\n\treturn (lvl[G]!=-1);\n}\n\nLL dfs(int u,LL mini,int G){\n\tif(u==G) return mini;\n\t\n\tfor(int i=st[u];i<sz(adj[u]);i++){\n\t\tst[u]=i;\n\t\tint v = adj[u][i].v;\n\t\tLL flow = adj[u][i].flow;\n\t\tif(flow<=0||(lvl[v]-lvl[u]!=1)) continue;\n\t\tLL ret=dfs(v,min(mini,flow),G);\n\t\tif(ret>0){\n\t\t\tadj[u][i].flow-=ret;\n\t\t\tint bvf = adj[u][i].bf;\n\t\t\tadj[v][bvf].flow+=ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nLL maxflow(int S,int G){\n\tLL ret=0;\n\twhile(1){\n\t\tif(!bfs(S,G)) break;\n\t\tLL flow = 0;\n\t\tmem(st,0);\n\t\twhile((flow=dfs(S, LLINF, G))>0){\n\t\t\tret+=flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint r,c;\n\tscanf(\"%d%d\",&r,&c);\n\tgetchar();\n\tfor(int i=0;i<r;i++){\n\t\tscanf(\"%s\",input[i]);\n\t}\n\t\n\tint temp=0;\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tidx[i][j]=temp;\n\t\t\tidx1[i][j]=temp+200;\n\t\t\ttemp++;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(input[i][j]=='.'){\n\t\t\t\taddedge(idx[i][j],idx1[i][j],1);\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\taddedge(idx1[i][j],sink,INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\taddedge(source,idx[i][j],INF);\n\t\t\t\taddedge(idx[i][j],idx1[i][j],INF);\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int ii=0;ii<4;ii++){\n\t\t\t\tint tempx = i+xx[ii];\n\t\t\t\tint tempy = j+yy[ii];\n\t\t\t\t\n\t\t\t\tif(tempx<0||tempx>=c||tempy<0||tempy>=r) continue;\n\t\t\t\taddedge(idx1[i][j],idx[tempx][tempy],INF); \n\t\t\t}\n\t\t}\n\t}\n\t\n\tLL ans = maxflow(source,sink);\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<20\n#define EPS (1e-6)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef complex<double> P;\n\nbool cmp(P a, P b){\n\tdouble arga = arg(a);\n\tdouble argb = arg(b);\n\tif(!EQ(arga, argb)){\n\t\treturn arga < argb;\n\t} // end if\n\t\n\treturn abs(a) > abs(b);\n}\n\nconst int MAX_H = 105;\nconst int MAX_W = 105;\n\nconst int dy[4] = {-1, 0, 1, 0};\nconst int dx[4] = { 0, 1, 0,-1};\nchar field[MAX_H][MAX_W];\nint d[MAX_H][MAX_W];\nint H, W;\n\nbool bfs(char target, int sy, int sx){\n\tqueue<pair<int,int> > que;\n\trep (i, MAX_H) rep (j, MAX_W) d[i][j] = INF;\n\tque.push(make_pair(sy,sx));\n\td[sy][sx] = 0;\n\t\n\twhile(!que.empty()){\n\t\tpair<int,int> curr = que.front(); que.pop();\n\t\tint cy = curr.first;\n\t\tint cx = curr.second;\n\n\t\t// 領域の外に出た\n\t\tif (cy == 0 || cy == H + 1 || cx == 0 || cx == W + 1){\n\t\t\treturn true;\n\t\t} // end if\n\n\t\trep(k, 4){\n\t\t\tint ny = cy + dy[k];\n\t\t\tint nx = cx + dx[k];\n\t\t\tif (ny < 0 || ny > H + 1 || nx < 0 || nx > W + 1) continue;\n\t\t\t\n\t\t\tif (d[ny][nx] > d[cy][cx] + 1){\n\t\t\t\tif(\n\t\t\t\t\t   ((target == 'O') && (field[ny][nx] == '.'))\n\t\t\t\t\t|| ((target == 'X') && (field[ny][nx] != 'O'))\n\t\t\t\t){\n\t\t\t\t\tque.push(make_pair(ny,nx));\n\t\t\t\t\td[ny][nx] = d[cy][cx] + 1;\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end while\n\n\treturn false;\t\n}\n\n\nint main()\n{\n\tmemset (field, 0, sizeof(field));\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\trep (i, MAX_H) rep (j, MAX_W) field[i][j] = '.';\n\tcin >> H >> W;\n\tvector<string> s(H);\n\trep (i, H) cin >> s[i];\n\n\tset<pair<int,int> > origin; origin.clear();\n\n\tvector<P> p; p.clear();\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tfield[i][j] = s[i-1][j-1];\n\t\t\tif (field[i][j] == 'X'){\n\t\t\t\torigin.insert(make_pair(i,j));\n\t\t\t\tp.push_back(P(i - H / 2., j - W / 2.));\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\tsort (ALL(p),cmp);\n\tvector<pair<int,int> > add_shape; add_shape.clear();\n\n\tint m = p.size();\n\trep (i, m){\n\t\tint cy1 = (int)(p[i].imag());\n\t\tint cy2 = (int)(p[(i+1) % m].imag());\n\t\tint cx1 = (int)(p[i].real());\n\t\tint cx2 = (int)(p[(i+1) % m].real());\n\t\tint leny = abs(cy1 - cy2);\n\t\tint lenx = abs(cx1 - cx2);\n\n\t\tint cnt = 0;\n\t\tif (leny > lenx){\n\t\t\tfor (int y = cy1; (cy1 <= cy2 ? y < cy2 : y > cy2); y += (cy1 <= cy2 ? +1 : -1), ++cnt);\n\t\t\tfor (int dy = 1; dy < cnt; ++dy){\n\t\t\t\tint dx = ((cx2 - cx1) / cnt) * dy;\n\t\t\t\tint ny = cy1 + dy * (cy1 <= cy2 ? +1 : -1) + H / 2;\n\t\t\t\tint nx = cx1 + dx + W/2;\n\t\t\t\tadd_shape.push_back(make_pair(ny,nx));\n\t\t\t\tfield[ny][nx] = 'X';\n\t\t\t} // end rep\n\t\t}else{\t// if (leny <= lenx)\n\t\t\tfor (int x = cx1; (cx1 <= cx2 ? x < cx2 : x > cx2); x += (cx1 <= cx2 ? +1 : -1), ++cnt);\n\t\t\tfor (int dx = 1; dx < cnt; ++dx){\n\t\t\t\tint dy = ((cy2 - cy1) / cnt) * dx;\n\t\t\t\tint ny = cy1 + dy + H / 2;\n\t\t\t\tint nx = cx1 + dx * (cx1 <= cx2 ? +1 : -1) + W / 2;\n\t\t\t\tadd_shape.push_back(make_pair(ny,nx));\n\t\t\t\tfield[ny][nx] = 'X';\n \t\t\t} // end rep\n\t\t} // end if\n\t} // end rep\n\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tif (field[i][j] == 'X'){\n\t\t\t\trep (k, 4){\n\t\t\t\t\tint ny = i + dy[k];\n\t\t\t\t\tint nx = j + dx[k];\n\t\t\t\t\tif (ny <= 0 || ny >= H + 1 || nx <= 0 || nx >= W + 1) continue;\n\t\t\t\t\tif (field[ny][nx] != '.') continue;\n\t\t\t\t\tfield[ny][nx] = 'O';\n\t\t\t\t} // end rep\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end rep\n\n\tbool escape = false;\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tif (field[i][j] == 'O'){\n\t\t\t\tbool curr = bfs(field[i][j], i, j);\n\t\t\t\tif (!curr) field[i][j] = '.';\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\trep (i, add_shape.size()){\n\t\tint py = add_shape[i].first;\n\t\tint px = add_shape[i].second;\n\t\tif (origin.count(make_pair(py,px))) continue;\n\t\tfield[py][px] = '.';\n\t} // end rep\n\n\tescape = false;\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tif (field[i][j] == 'X'){\n\t\t\t\tbool curr = bfs(field[i][j], i, j);\n\t\t\t\tif (curr) escape |= true;\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\tint res = 0;\n\tif (escape){\n\t\tres = -1;\n\t}else{\n\t\tfor (int i = 1; i <= H; ++i){\n\t\t\tfor (int j = 1; j <= W; ++j){\n\t\t\t\tres += (int)(field[i][j] == 'O');\n\t\t\t} // end for\n\t\t} // end for\n\t} // end if\n\tcout << res << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define min(a, b) ((a)>(b)?(b):(a))\n\nconst int inf = 1e5;\nconst int MAXN = 105;\n\nconst int sz = 2 * MAXN*MAXN;\n\ntemplate <class T> class vector {\n\tT* arr;\n\tint _cap, _size;\npublic:\n\tvector() { arr = new T[2]; _cap = 2; _size = 0; }\n\tT* begin() { return arr; }\n\tT* end() { return arr + _size; }\n\tT& operator[](int i) { return arr[i]; }\n\tint size() { return _size; }\n\tT back() {\n\t\treturn arr[_size - 1];\n\t}\n\tvoid pop_back() { _size--; }\n\tvoid push_back(T newElement) {\n\t\tif (_size == _cap) {\n\t\t\tT* tmp = new T[_cap * 2];\n\t\t\tfor (int i = 0; i < _size; i++)tmp[i] = arr[i];\n\t\t\t_cap *= 2;\n\t\t\tdelete[] arr;\n\t\t\tarr = tmp;\n\t\t}\n\t\tarr[_size++] = newElement;\n\t}\n\tbool empty() {\n\t\treturn !(_size);\n\t}\n\tvoid clear() { _cap = 2; _size = 0; delete[] arr; arr = new T[2]; }\n\t~vector() { delete[] arr; }\n};\n\nstruct MaxFlow {\n\tstruct Edge {\n\t\tint x;\n\t\tint inv;\n\t\tint resid;\n\t\tEdge() {}\n\t\tEdge(int v, int i, int r) : x(v), inv(i), resid(r) {}\n\t};\n\tint n;\n\tvector <Edge> g[sz];\n\tvoid init(int _n) {\n\t\tn = _n;\n\t}\n\tvoid add_edge(int s, int e, int cap) {\n\t\tEdge forward = Edge(e, g[e].size(), cap);\n\t\tEdge reverse = Edge(s, g[s].size(), 0);\n\t\tg[s].push_back(forward);\n\t\tg[e].push_back(reverse);\n\t}\n\tbool vis[sz];\n\tint Q[sz], fr, re, curf[sz], par[sz], paridx[sz];\n\tint bfs(int s, int e) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tvis[i] = 0;\n\t\t\tcurf[i] = 0;\n\t\t\tpar[i] = paridx[i] = 0;\n\t\t}\n\t\tQ[fr = re = 0] = s; vis[s] = 1;\n\t\tcurf[s] = inf;\n\t\twhile (fr <= re) {\n\t\t\tint x = Q[fr++];\n\t\t\tfor (int i = 0; i < g[x].size(); i++) {\n\t\t\t\tint y = g[x][i].x;\n\t\t\t\tint f = g[x][i].resid;\n\t\t\t\tif (f > 0 && !vis[y]) {\n\t\t\t\t\tvis[y] = 1;\n\t\t\t\t\tpar[y] = x; paridx[y] = i;\n\t\t\t\t\tcurf[y] = min(curf[x], f);\n\t\t\t\t\tQ[++re] = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!vis[e]) return 0;\n\t\tint flow = curf[e];\n\t\tint p = e;\n\t\twhile (p != s) {\n\t\t\tint q = par[p], qi = paridx[p];\n\t\t\tint pi = g[q][qi].inv;\n\t\t\tg[q][qi].resid -= flow;\n\t\t\tg[p][pi].resid += flow;\n\t\t\tp = q;\n\t\t}\n\t\treturn flow;\n\t}\n\tint solve(int s, int e) {\n\t\tint flow = 0, cur = 0;\n\t\twhile (cur = bfs(s, e), cur > 0) {\n\t\t\tflow += cur;\n\t\t}\n\t\treturn flow;\n\t}\n};\n\nint N, M;\nchar S[MAXN][MAXN];\nint in[MAXN][MAXN], out[MAXN][MAXN];\nint source, sink, v;\n\nint px[4] = { 1,-1,0,0 };\nint py[4] = { 0,0,1,-1 };\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int i = 1; i <= N; i++) {\n\t\tscanf(\"%s\", S[i] + 1);\n\t}\n\tsource = 0;\n\tsink = N * M * 2 + 1;\n\tv = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= M; j++) {\n\t\t\tin[i][j] = ++v;\n\t\t\tout[i][j] = ++v;\n\t\t}\n\t}\n\tMaxFlow f;\n\tf.init(2 * N*M + 2);\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= M; j++) {\n\t\t\tif (S[i][j] == 'X') {\n\t\t\t\tif (i == 1 || i == N || j == 1 || j == M) {\n\t\t\t\t\tf.add_edge(source, in[i][j], inf);\n\t\t\t\t}\n\t\t\t\tf.add_edge(in[i][j], out[i][j], inf);\n\t\t\t\tf.add_edge(out[i][j], sink, inf);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (i == 1 || i == N || j == 1 || j == M) {\n\t\t\t\t\tf.add_edge(source, in[i][j], 1);\n\t\t\t\t}\n\t\t\t\tf.add_edge(in[i][j], out[i][j], 1);\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint x = i + px[k];\n\t\t\t\t\tint y = j + py[k];\n\t\t\t\t\tif (1 <= x && x <= N && 1 <= y && y <= M) {\n\t\t\t\t\t\tf.add_edge(out[i][j], in[x][y], inf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint flow = f.solve(source, sink);\n\tif (flow >= inf) puts(\"-1\");\n\telse printf(\"%d\\n\", flow);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n//Ford-Fulkerson O(FE)\n#include<algorithm>\n#include<utility>\n#include<vector>\n#include<limits>\ntemplate<typename T>\nstruct MF{\n\tstruct edge{\n\t\tint to,rev;\n\t\tT cap;\n\t};\n\tvector<vector<edge> >G;\n\tvector<int>used;\n\tMF(int n_=0):G(n_),used(n_,0){}\n\tvoid add_edge(int from,int to,T cap)\n\t{\n\t\tG[from].push_back({to,(int)G[to].size(),cap});\n\t\tG[to].push_back({from,(int)G[from].size()-1,0});\n\t}\n\tT dfs(int u,int t,T f,int dfstime)\n\t{\n\t\tif(u==t)return f;\n\t\tused[u]=dfstime;\n\t\tfor(edge&e:G[u])\n\t\t{\n\t\t\tif(used[e.to]<dfstime&&e.cap>0)\n\t\t\t{\n\t\t\t\tT d=dfs(e.to,t,min(f,e.cap),dfstime);\n\t\t\t\tif(d>0)\n\t\t\t\t{\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tT max_flow(int s,int t)\n\t{\n\t\tT ret=0;\n\t\tfor(int dfstime=1;;dfstime++)\n\t\t{\n\t\t\tT f=dfs(s,t,numeric_limits<T>::max(),dfstime);\n\t\t\tif(f>0)ret+=f;\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n};\nint H,W;\nstring s[100];\nint d[4]={1,0,-1,0};\nmain()\n{\n\tcin>>H>>W;\n\tfor(int i=0;i<H;i++)cin>>s[i];\n\tMF<int>P(H*W*2+2);\n\tint st=H*W*2,go=H*W*2+1;\n\tfor(int i=0;i<H;i++)for(int j=0;j<W;j++)\n\t{\n\t\tint id=i*W+j;\n\t\tif(i==0||j==0||i==H-1||j==W-1)P.add_edge(id*2,go,1e9);\n\t\tif(s[i][j]=='X')P.add_edge(st,id*2+1,1e9);\n\t\tP.add_edge(id*2,id*2+1,1);\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint x=i+d[r],y=j+d[r^1];\n\t\t\tif(x<0||y<0||x>=H||y>=W)continue;\n\t\t\tP.add_edge(id*2+1,2*(x*W+y),1e9);\n\t\t}\n\t}\n\tint ans=P.max_flow(st,go);\n\tif(ans<1e9)cout<<ans<<endl;\n\telse cout<<-1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\nconst int di[] = {-1,0,1,0}, dj[] = {0,-1,0,1}; //^<v>\n//const int di[] = {-1,0,1,-1,1,-1,0,1}, dj[] = {-1,-1,-1,0,0,1,1,1};\n\n// Max flow\nstruct Maxflow {\n  int n;\n  vector<int> to, lim, next, head, dist, it;\n  Maxflow(){}\n  Maxflow(int n):n(n),head(n,-1),it(n){}\n  void add(int a, int b, int c=1) {\n    next.push_back(head[a]); head[a] = to.size(); to.push_back(b); lim.push_back(c);\n    next.push_back(head[b]); head[b] = to.size(); to.push_back(a); lim.push_back(0); \n  }\n  void add2(int a, int b, int c=1) {\n    next.push_back(head[a]); head[a] = to.size(); to.push_back(b); lim.push_back(c);\n    next.push_back(head[b]); head[b] = to.size(); to.push_back(a); lim.push_back(c); \n  }\n  void bfs(int sv){\n    dist = vector<int>(n,INF);\n    queue<int> q;\n    dist[sv] = 0; q.push(sv);\n    while(!q.empty()){\n      int v = q.front(); q.pop();\n      for(int i = head[v]; i != -1; i = next[i]) {\n        if(lim[i] && dist[to[i]] == INF){\n          dist[to[i]] = dist[v]+1; q.push(to[i]);\n        }\n      }\n    }\n  }\n  int dfs(int v, int tv, int nf=INF){\n    if(v == tv) return nf;\n    for(; it[v] != -1; it[v] = next[it[v]]){\n      int u = to[it[v]], f;\n      if(!lim[it[v]] || dist[v] >= dist[u]) continue;\n      if(f = dfs(u, tv, min(nf, lim[it[v]])), f){\n        lim[it[v]] -= f;\n        lim[it[v]^1] += f;\n        return f;\n      }\n    }\n    return 0;\n  }\n  int solve(int sv, int tv){\n    int flow = 0, f;\n    while(1){\n      bfs(sv);\n      if(dist[tv] == INF) return flow;\n      rep(i,n) it[i] = head[i];\n      while(f = dfs(sv,tv), f) flow += f;\n    }\n  }\n};\n//\nint h, w;\nstring s[105];\n\nint main() {\n  cin >> h >> w;\n  rep(i,h) cin >> s[i];\n  rep(i,h) {\n    if (s[i][0] == 'X') dame;\n    if (s[i][w-1] == 'X') dame;\n  }\n  rep(i,w) {\n    if (s[0][i] == 'X') dame;\n    if (s[h-1][i] == 'X') dame;\n  }\n  int n = h*w;\n  int sv = n*2, tv = sv+1;\n  Maxflow g(tv+1);\n  rep(i,h)rep(j,w) {\n    int v = i*w+j, v2 = n+v;\n    if (i == 0 || j == 0 || i == h-1 || j == w-1) {\n      g.add(v2,tv,INF);\n    }\n    if (s[i][j] == 'X') {\n      g.add(sv,v2,INF);\n    } else {\n      g.add(v,v2,1);\n    }\n    rep(v,4) {\n      int ni = i+di[v], nj = j+dj[v];\n      if (ni<0||nj<0||ni>=h||nj>=w) continue;\n      int u = ni*w+nj;\n      g.add(v2,u,INF);\n    }\n  }\n  cout<<g.solve(sv,tv)<<endl;\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,1,0,-1};\n\nint H, W;\nstring s[110];\nbool ns[110][110];\nbool rc[110][110];\n\nint main() {\n\tcin >> H >> W;\n\trep(i, H) cin >> s[i];\n\n\trep(i, H) {\n\t\trep(j, W) {\n\t\t\tif (s[i][j] == 'X') {\n\t\t\t\tif (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n\t\t\t\t\tputs(\"-1\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tns[i-1][j]=ns[i+1][j]=ns[i][j-1]=ns[i][j+1]=1;\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<pii> que;\n\trep(i, H) {\n\t\trep(j, W) {\n\t\t\tif (s[i][j] == 'X') {\n\t\t\t\tns[i][j] = 0;\n\t\t\t}\n\t\t\tif (!ns[i][j] && (i == 0 || i == H - 1 || j == 0 || j == W - 1)) {\n\t\t\t\tque.push(mp(i, j));\n\t\t\t\trc[i][j] = 1;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\n\twhile (!que.empty()) {\n\t\tpii p = que.front(); que.pop();\n\t\tint y = p.fi, x = p.se;\n\n\t\trep(i, 4) {\n\t\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\t\tif (ny >= 0 && ny < H && nx >= 0 && nx < W) {\n\t\t\t\tif (!ns[ny][nx] && !rc[ny][nx]) {\n\t\t\t\t\trc[ny][nx] = 1;\n\t\t\t\t\tque.push(mp(ny, nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = 0;\n\n\trep(y, H) {\n\t\trep(x, W) {\n\t\t\tif (!ns[y][x]) continue;\n\t\t\tbool ok = 0;\n\n\t\t\trep(i, 4) {\n\t\t\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\t\t\tif (ny >= 0 && ny < H && nx >= 0 && nx < W) {\n\t\t\t\t\tif (rc[ny][nx]) {\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t}\n\t\t\t\t} else ok = 1;\n\t\t\t}\n\n\t\t\tret += ok;\n\t\t}\n\t}\n\n\tcout << min(ret, (H+W-2)*2-4) << endl;\n\n\treturn 0;\n}\n\n/*\n6 6\n......\n......\n..XX.\n.X...\n..XX..\n......\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Problem {\npublic:\n    Problem(int h, int w) : h(h), w(w), maze(h), used(h, vector<bool>(w, false)) { }\n    void Input();\n    int Solve();\n\nprivate:\n    int h, w;\n    vector<string> maze;\n    vector<vector<bool>> used;\n\n    bool Contain(int y, int x) { return 0 <= y && y < h && 0 <= x && x < w; }\n    bool CanRemove(int y, int x);\n};\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nvoid Problem::Input() {\n    for (int i = 0; i < h; ++i) cin >> maze[i];\n}\n\nbool Problem::CanRemove(int y, int x) {\n//    cout << y << \", \" << x << \": \";\n    vector<vector<bool>> visited(h, vector<bool>(w, false));\n    queue<pair<int, int>> que;\n\n    for (int i = 0; i < h; ++i)\n        for (int j = 0; j < w; ++j) {\n            if (maze[i][j] == 'X') {\n                que.push(make_pair(i, j));\n                visited[i][j] = true;\n            }\n        }\n\n    while (!que.empty()) {\n        auto cur = que.front();\n        que.pop();\n\n        for (int d = 0; d < 4; ++d) {\n            int ny = cur.first + dy[d], nx = cur.second + dx[d];\n\n            if (!Contain(ny, nx) || visited[ny][nx])\n                continue;\n            if (!(ny == y && nx == x) && used[ny][nx])\n                continue;\n            if (ny == 0 || ny == h - 1 || nx == 0 || nx == w - 1) {\n//                cout << \"No : \" << ny << \", \" << nx << endl;\n                return false;\n            }\n\n            que.push(make_pair(ny, nx));\n            visited[ny][nx] = true;\n        }\n    }\n\n//    cout << \"YES\\n\";\n    return true;\n}\n\nint Problem::Solve() {\n    for (int i = 0; i < h; ++i)\n        if (maze[i][0] == 'X' || maze[i][w - 1] == 'X') return -1;\n    for (int i = 0; i < w; ++i)\n        if (maze[0][i] == 'X' || maze[h - 1][i] == 'X') return -1;\n\n    for (int y = 0; y < h; ++y) {\n        for (int x = 0; x < w; ++x)\n            if (maze[y][x] == 'X')\n                for (int d = 0; d < 4; ++d) {\n                    int nx = x + dx[d], ny = y + dy[d];\n\n                    if (Contain(ny, nx) && maze[ny][nx] == '.')\n                        used[ny][nx] = true;\n                }\n    }\n\n    // for (int y = 0; y < h; ++y) {\n    //     for (int x = 0; x < w; ++x) {\n    //         if (maze[y][x] == 'X') cout << 'X';\n    //         else if (used[y][x]) cout << '#';\n    //         else cout << '.';\n    //     }\n    //     cout << endl;\n    // }\n    // cout << endl;\n\n\n    for (int y = 0; y < h; ++y)\n        for (int x = 0; x < w; ++x)\n            if (used[y][x] && CanRemove(y, x))\n                used[y][x] = false;\n\n    int cnt = 0;\n    for (int y = 0; y < h; ++y)\n        for (int x = 0; x < w; ++x)\n            if (used[y][x]) ++cnt;\n\n    // for (int y = 0; y < h; ++y) {\n    //     for (int x = 0; x < w; ++x) {\n    //         if (maze[y][x] == 'X') cout << 'X';\n    //         else if (used[y][x]) cout << '#';\n    //         else cout << '.';\n    //     }\n    //     cout << endl;\n    // }\n    // cout << endl;\n\n    return cnt;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int h, w;\n\n    cin >> h >> w;\n    Problem p(h, w);\n\n    p.Input();\n    cout << p.Solve() << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n\nint n,m,nr,nc,cnt,ans,hit;\nchar x[105][105];\nbool fr[105][105],vis[105][105];\nqueue<pii> q;\n\nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n\nvoid mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\n\nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#', q.push({i+dr[k],j+dc[k]});\n\t}\n\tmk();\n\tint r,c;\n\trep(tes,1,100000000){\n\t\tif(q.empty())break;\n\t\tif(hit==2*q.size())break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0, mk();\n\t\telse if(!cnt)x[r][c] = '.', hit = 0, mk();\n\t\telse q.push({r,c}), ++hit;\n\t}\n\trep(i,1,n){\n\t\trep(j,1,m)cout<<fr[i][j];\n\t\tcout<<endl;\n\t}\n\trep(i,1,n){\n\t\trep(j,1,m)cout<<x[i][j];\n\t\tcout<<endl;\n\t}\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++ans;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr,Vpr> PQ;\nconst int INF=1<<30;\nstruct Edge{\npublic:\n\tint to,cost,cp;\n\tEdge *rev;\n\tEdge(int t,int c,int cp):to(t),cost(c),cp(cp){\n\t\t\n\t}\n\tvoid add(int x){\n\t\tcp+=x;\n\t}\n\tvoid flow(int amount){\n\t\tadd(-amount);\n\t\trev->add(amount);\n\t}\n\tbool usable(){\n\t\treturn cp>=1;\n\t}\t\n};\nvoid unite(Edge &a,Edge &b){\n\ta.rev=&b;\n\tb.rev=&a;\n}\nclass Graph{\n\tint nodeSize,edgeSize;\n\tvector<int> dist;\n\tvector<vector<Edge> > edges;\npublic: \n\tvoid add(int a,int b,int cost,int cp){\n\t\tedges[a].PB(Edge(b,cost,cp));\n\t\tedges[b].PB(Edge(a,cost,0));\n\t\tunite(edges[a].back(),edges[b].back());\n\t}\n\tGraph(int x):nodeSize(x){\n\t\t\n\t\tedges=vector<vector<Edge> >(nodeSize);\n\t\tdist=VI(nodeSize);\n\t}\n\tvoid distInit(int s){\n\t\tREP(i,nodeSize){\n\t\t\tdist[i]=INF;\n\t\t}\n\t\tdist[s]=0;\n\t}\n\tint searching(int now,int e,int capacity){\n\t\tif(now==e) return capacity;\n\t\tif(capacity==0) return 0;\n\t\tif(dist[now]>=dist[e]) return 0;\n\t\tint flowed=0;\n\t\tREP(i,edges[now].size()){\n\t\t\tEdge *ed= &edges[now][i];\n\t\t\tif(dist[now]+1 != dist[ed->to]) continue;\n\t\t\tint nflow=searching(ed->to,e,min(capacity-flowed,ed->cp));\n\t\t\tif(nflow){\n\t\t\t\tflowed+=nflow;\n\t\t\t\ted->flow(nflow);\n\t\t\t}\n\t\t}\n\t\treturn flowed;\n\t}\n\tbool bfs(int s,int e){\n\t\tdistInit(s);\n\t\tqueue<int> qu;\n\t\tqu.push(s);\n\t\twhile(!qu.empty()){\n\t\t\tint now=qu.front();\n\t\t\tif(now==e) return true;\n\t\t\tqu.pop();\n\t\t\tREP(i,edges[now].size()){\n\t\t\t\tEdge *ed= &edges[now][i];\n\t\t\t\tif(!ed->usable()) continue;\n\t\t\t\tif(dist[ed->to]==INF){\n\t\t\t\t\tqu.push(ed->to);\n\t\t\t\t\tdist[ed->to]=dist[now]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint maximumFlow(int s,int e){\n\t\tint ans=0;\n\t\twhile(bfs(s,e)){\n\t\t\tans+=searching(s,e,INF);\n\t\t}\n\t\treturn ans;\n\t}\n};\nconst int SIZE=101;\nint conv(int a,int b,int c){return a*100+b+SIZE*SIZE*c+2;}\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\nint H,W;\nint maps[101][101];\nbool isSafe(int y,int x){\n\treturn 0<=y && y<H && 0<=x && x<W;\n}\nint main(){\n\tGraph graph(SIZE*SIZE*2+2);\n\tcin >> H >> W;\n\tREP(i,H) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,s.size())\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\n\t}\n\tREP(i,H) REP(j,W) {\n\t\tgraph.add(conv(i,j,1),conv(i,j,0),0,1);\n//\t\tedges[conv(i,j,1)].PB(edge(conv(i,j,0),0,1));\n\t\tif(maps[i][j]){\n\t\t\t//edges[0].PB(edge(conv(i,j,1),0,1));\n\t\t\tgraph.add(0,conv(i,j,0),0,4);\n\t\t}\n\t\tREP(k,4){\n\t\t\tif(!isSafe(i+dy[k],j+dx[k])){\n\t\t\tgraph.add(conv(i,j,0),1,0,1);\n\t\t\t//\tedges[conv(i,j,0)].PB(edge(1,0,1));\n\t\t\t} \n\t\t\telse if(!maps[i+dy[k]][j+dx[k]]){\n\t\t\t\tgraph.add(conv(i,j,0),conv(i+dy[k],j+dx[k],1),0,1);\n\t\t\t\tgraph.add(conv(i+dy[k],j+dx[k],0),conv(i,j,1),0,1);\n//\t\t\t\tedges[conv(i,j,0)].PB(edge(conv(i+dy[k],j+dx[k],1),0,1));\n//\t\t\t\tedges[conv(i+dy[k],j+dx[k],0)].PB(edge(conv(i,j,1),0,1));\n\t\t\t}\n\t\t}\n\t\n\t}\n\tcout << graph.maximumFlow(0,1) << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n\tif(ans-9>150)return 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans-9<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr,Vpr> PQ;\nconst int INF=1<<30;\nstruct Edge{\npublic:\n\tint to,cost,cp;\n\tEdge *rev;\n\tEdge(int t,int c,int cp):to(t),cost(c),cp(cp){\n\t\t\n\t}\n\tvoid add(int x){\n\t\tcp+=x;\n\t}\n\tvoid flow(int amount){\n\t\tadd(-amount);\n\t\trev->add(amount);\n\t}\n\tbool usable(){\n\t\treturn cp>=1;\n\t}\t\n};\nvoid unite(Edge &a,Edge &b){\n\ta.rev=&b;\n\tb.rev=&a;\n}\nclass Graph{\n\tint nodeSize,edgeSize;\n\tvector<int> dist;\n\tvector<vector<Edge> > edges;\npublic: \n\tvoid add(int a,int b,int cost,int cp){\n\t\tedges[a].PB(Edge(b,cost,cp));\n\t\tedges[b].PB(Edge(a,cost,0));\n\t\tunite(edges[a].back(),edges[b].back());\n\t}\n\tGraph(int x):nodeSize(x){\n\t\t\n\t\tedges=vector<vector<Edge> >(nodeSize);\n\t\tdist=VI(nodeSize);\n\t}\n\tvoid distInit(int s){\n\t\tREP(i,nodeSize){\n\t\t\tdist[i]=INF;\n\t\t}\n\t\tdist[s]=0;\n\t}\n\tint searching(int now,int e,int capacity){\n\t\tif(now==e) return capacity;\n\t\tif(capacity==0) return 0;\n\t\tif(dist[now]>=dist[e]) return 0;\n\t\tint flowed=0;\n\t\tREP(i,edges[now].size()){\n\t\t\tEdge *ed= &edges[now][i];\n\t\t\tif(dist[now]+1 != dist[ed->to]) continue;\n\t\t\tint nflow=searching(ed->to,e,min(capacity-flowed,ed->cp));\n\t\t\tif(nflow){\n\t\t\t\tflowed+=nflow;\n\t\t\t\ted->flow(nflow);\n\t\t\t}\n\t\t}\n\t\treturn flowed;\n\t}\n\tbool bfs(int s,int e){\n\t\tdistInit(s);\n\t\tqueue<int> qu;\n\t\tqu.push(s);\n\t\twhile(!qu.empty()){\n\t\t\tint now=qu.front();\n\t\t\tif(now==e) return true;\n\t\t\tqu.pop();\n\t\t\tREP(i,edges[now].size()){\n\t\t\t\tEdge *ed= &edges[now][i];\n\t\t\t\tif(!ed->usable()) continue;\n\t\t\t\tif(dist[ed->to]==INF){\n\t\t\t\t\tqu.push(ed->to);\n\t\t\t\t\tdist[ed->to]=dist[now]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint maximumFlow(int s,int e){\n\t\tint ans=0;\n\t\twhile(bfs(s,e)){\n\t\t\tans+=searching(s,e,INF);\n\t\t}\n\t\treturn ans;\n\t}\n};\nconst int SIZE=101;\nint conv(int a,int b,int c){return a*100+b+SIZE*SIZE*c+2;}\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\nint H,W;\nint maps[101][101];\nbool isSafe(int y,int x){\n\treturn 0<=y && y<H && 0<=x && x<W;\n}\nint main(){\n\tGraph graph(SIZE*SIZE*2+2);\n\tcin >> H >> W;\n\tREP(i,H) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,s.size()){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(maps[i][j] &&(i==0 || j==0 || i==H-1 || j==W-1)){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\t\t\n\t}\n\tREP(i,H) REP(j,W) {\n\t\tgraph.add(conv(i,j,1),conv(i,j,0),0,1);\n//\t\tedges[conv(i,j,1)].PB(edge(conv(i,j,0),0,1));\n\t\tif(maps[i][j]){\n\t\t\t//edges[0].PB(edge(conv(i,j,1),0,1));\n\t\t\tgraph.add(0,conv(i,j,0),0,4);\n\t\t}\n\t\tREP(k,4){\n\t\t\tif(!isSafe(i+dy[k],j+dx[k])){\n\t\t\tgraph.add(conv(i,j,0),1,0,1);\n\t\t\t//\tedges[conv(i,j,0)].PB(edge(1,0,1));\n\t\t\t} \n\t\t\telse if(!maps[i+dy[k]][j+dx[k]]){\n\t\t\t\tgraph.add(conv(i,j,0),conv(i+dy[k],j+dx[k],1),0,1);\n\t\t\t\tgraph.add(conv(i+dy[k],j+dx[k],0),conv(i,j,1),0,1);\n//\t\t\t\tedges[conv(i,j,0)].PB(edge(conv(i+dy[k],j+dx[k],1),0,1));\n//\t\t\t\tedges[conv(i+dy[k],j+dx[k],0)].PB(edge(conv(i,j,1),0,1));\n\t\t\t}\n\t\t}\n\t\n\t}\n\tcout << graph.maximumFlow(0,1) << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint n,m;\nvector<string>in,out;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nvoid dfs(int x,int y){\n\tout[x][y]=',';\n\trep(i,4){\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\t\tif(nx<0||ny<0||nx>=n||ny>=m)continue;\n\t\tif(out[nx][ny]=='.')dfs(nx,ny);\n\t\telse if(out[nx][ny]=='!')out[nx][ny]='#';\n\t}\n}\nint main(){\n\tcin>>n>>m;\n\tin=vector<string>(n);\n\trep(i,n)cin>>in[i];\n\tout=in;\n\trep(i,n)rep(j,m)out[i][j]='.';\n\tbool h=true;\n\trep(i,n)rep(j,m)if(i==0||j==0||i==n-1||j==m-1){\n\t\tif(in[i][j]=='X')h=false;\n\t}\n\tif(!h){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tint dx[]={3,-3,0,0};\n\tint dy[]={0,0,3,-3};\n\trep(i,n)rep(j,m)if(in[i][j]=='X'){\n\t\tout[i+1][j]=out[i-1][j]=out[i][j+1]=out[i][j-1]='!';\n\t}\n\trep(i,n)rep(j,m){\n\t\th=true;\n\t\trep(k,4){\n\t\t\tint x=i+dx[k];\n\t\t\tint y=j+dy[k];\n\t\t\tif(x<0||y<0||x>=n||y>=m){\n\t\t\t\th=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(in[x][y]!='X')h=false;\n\t\t}\n\t\tif(h){\n\t\t\tout[i+2][j+2]=out[i-2][j+2]=out[i+2][j-2]=out[i-2][j-2]='!';\n\t\t}\n\t}\n//\trep(i,n)cout<<out[i]<<endl;\n\trep(i,n)rep(j,m)if(i==0||j==0||i==n-1||j==m-1){\n\t\tif(out[i][j]=='.')dfs(i,j);\n\t}\n//\trep(i,n)cout<<out[i]<<endl;\n\tint co=0;\n\trep(i,n)rep(j,m)if(out[i][j]=='#')co++;\n\tcout<<co<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MAX = 4e4;\nconst int OO = 0x3f3f3f3f3f3f3f3f;\nint SOURCE, SINK;\n\nstruct edge\n{\n    int v, f, c;\n    edge(){}\n    edge(int _v, int _f, int _c)\n    {\n        v = _v, f = _f, c = _c;\n    }\n};\n\nvector<edge> edges;\nvector<int> G[MAX];\nint dist[MAX], work[MAX];\n\nvoid add_edge(int u, int v, int cp, int rc){\n\tedges.push_back(edge(v, 0, cp));\n\tG[u].push_back(edges.size()-1);\n\tedges.push_back(edge(u, 0, rc));\n\tG[v].push_back(edges.size()-1);\n}\n\nbool bfs(int s, int t)\n{\n    memset(dist, -1, sizeof(dist));\n    dist[s] = 0;\n    queue<int> q;\n    q.push(s);\n    while(!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        for(int e : G[u])\n            if(dist[edges[e].v] == -1 and edges[e].c-edges[e].f > 0)\n            {\n                q.push(edges[e].v);\n                dist[edges[e].v] = dist[u] + 1;\n            }\n    }\n    return dist[t] != -1;\n}\n\nint dfs(int s, int t, int f)\n{\n    if(s == t) return f;\n    for(int &i = work[s]; i < G[s].size(); i++)\n    {\n    \tint e = G[s][i];\n        if(dist[edges[e].v] == dist[s] + 1 and edges[e].c-edges[e].f > 0)\n            if(int a = dfs(edges[e].v, t, min(f, edges[e].c-edges[e].f)))\n            {\n                edges[e].f += a;\n                edges[e^1].f -= a;\n                return a;\n            }\n    }\n    return 0;\n}\n\nint MaxFlow(int s, int t)\n{\n    int mf = 0;\n    while(bfs(s, t))\n\t{\n    \tmemset(work, 0, sizeof(work));\n        while(int a = dfs(s, t, OO))\n            mf += a;\n    }\n    return mf;\n}\n\nint n, m, a, b;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nbool check(int x, int y)\n{\n\treturn x >= 0 and x < n and y >= 0 and y < m;\n}\n\nint vertexIn(int i, int j)\n{\n\treturn i * m + j;\n}\n\nint vertexOut(int i, int j)\n{\n\treturn i * m + j + n * m + 1;\n}\n\nint main()\n{\n \tcin >> n >> m;\n \tSOURCE = 2 * n * m + 2;\n \tSINK = 2 * n * m + 3;\n \tfor(int i = 0; i < n; i++)\n \t\tfor(int j = 0; j < m; j++)\n \t\t{\n \t\t\tchar c;\n \t\t\tcin >> c;\n \t\t\tint cost = 1;\n \t\t\tif(c == 'X') cost = OO;\n \t\t\tadd_edge(vertexIn(i, j), vertexOut(i, j), cost, 0);\n \t\t\tif(cost == OO) add_edge(vertexOut(i, j), SINK, OO, 0);\n \t\t\tfor(int k = 0; k < 4; k++)\n \t\t\t{\n\t\t\t\tint x = i + dx[k], y = j + dy[k];\n\t\t\t\tif(check(x, y))\n \t\t\t\t\tadd_edge(vertexOut(i, j), vertexIn(x, y), OO, 0);\n \t\t\t}\n \t\t\tif(!i or !j or i == n - 1 or j == m - 1)\n \t\t\t\tadd_edge(SOURCE, vertexIn(i, j), OO, 0);\n \t\t}\t\n\tint ans = MaxFlow(SOURCE, SINK);\n\tif(ans >= 5 * n * m) ans = -1;\n \tcout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<20\n#define EPS (1e-6)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef complex<double> P;\n\nbool cmp(P a, P b){\n\tdouble arga = arg(a);\n\tdouble argb = arg(b);\n\tif(!EQ(arga, argb)){\n\t\treturn arga < argb;\n\t} // end if\n\t\n\treturn abs(a) > abs(b);\n}\n\nconst int MAX_H = 105;\nconst int MAX_W = 105;\n\nconst int dy[4] = {-1, 0, 1, 0};\nconst int dx[4] = { 0, 1, 0,-1};\nchar field[MAX_H][MAX_W];\nint d[MAX_H][MAX_W];\nint H, W;\n\nbool bfs(char target, int sy, int sx){\n\tqueue<pair<int,int> > que;\n\trep (i, MAX_H) rep (j, MAX_W) d[i][j] = INF;\n\tque.push(make_pair(sy,sx));\n\td[sy][sx] = 0;\n\t\n\twhile(!que.empty()){\n\t\tpair<int,int> curr = que.front(); que.pop();\n\t\tint cy = curr.first;\n\t\tint cx = curr.second;\n\n\t\t// 領域の外に出た\n\t\tif (cy == 0 || cy == H + 1 || cx == 0 || cx == W + 1){\n\t\t\treturn true;\n\t\t} // end if\n\n\t\trep(k, 4){\n\t\t\tint ny = cy + dy[k];\n\t\t\tint nx = cx + dx[k];\n\t\t\tif (ny < 0 || ny > H + 1 || nx < 0 || nx > W + 1) continue;\n\t\t\t\n\t\t\tif (d[ny][nx] > d[cy][cx] + 1){\n\t\t\t\tif(\n\t\t\t\t\t   ((target == 'O') && (field[ny][nx] == '.'))\n\t\t\t\t\t|| ((target == 'X') && (field[ny][nx] != 'O'))\n\t\t\t\t){\n\t\t\t\t\tque.push(make_pair(ny,nx));\n\t\t\t\t\td[ny][nx] = d[cy][cx] + 1;\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end while\n\n\treturn false;\t\n}\n\n\nint main()\n{\n\tmemset (field, 0, sizeof(field));\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\trep (i, MAX_H) rep (j, MAX_W) field[i][j] = '.';\n\tcin >> H >> W;\n\tvector<string> s(H);\n\trep (i, H) cin >> s[i];\n\n\tset<pair<int,int> > origin; origin.clear();\n\n\tvector<P> p; p.clear();\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tfield[i][j] = s[i-1][j-1];\n\t\t\tif (field[i][j] == 'X'){\n\t\t\t\torigin.insert(make_pair(i,j));\n\t\t\t\tP cur;\n\t\t\t\tcur.real() = j - W / 2.;\n\t\t\t\tcur.imag() = i - H / 2.;\n\t\t\t\tp.push_back(cur);\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\tsort (ALL(p),cmp);\n\tvector<pair<int,int> > add_shape; add_shape.clear();\n\n\tint m = p.size();\n\trep (i, m){\n\t\tint cy1 = (int)(p[i].imag());\n\t\tint cy2 = (int)(p[(i+1) % m].imag());\n\t\tint cx1 = (int)(p[i].real());\n\t\tint cx2 = (int)(p[(i+1) % m].real());\n\t\tint leny = abs(cy1 - cy2);\n\t\tint lenx = abs(cx1 - cx2);\n\n\t\tint cnt = 0;\n\t\tif (leny > lenx){\n\t\t\tfor (int y = cy1; (cy1 <= cy2 ? y < cy2 : y > cy2); y += (cy1 <= cy2 ? +1 : -1), ++cnt);\n\t\t\tfor (int dy = 1; dy < cnt; ++dy){\n\t\t\t\tint dx = ((cx2 - cx1) / cnt) * dy;\n\t\t\t\tint ny = cy1 + dy * (cy1 <= cy2 ? +1 : -1) + H / 2;\n\t\t\t\tint nx = cx1 + dx + W/2;\n\t\t\t\tadd_shape.push_back(make_pair(ny,nx));\n\t\t\t\tfield[ny][nx] = 'X';\n\t\t\t} // end rep\n\t\t}else{\t// if (leny <= lenx)\n\t\t\tfor (int x = cx1; (cx1 <= cx2 ? x < cx2 : x > cx2); x += (cx1 <= cx2 ? +1 : -1), ++cnt);\n\t\t\tfor (int dx = 1; dx < cnt; ++dx){\n\t\t\t\tint dy = ((cy2 - cy1) / cnt) * dx;\n\t\t\t\tint ny = cy1 + dy + H / 2;\n\t\t\t\tint nx = cx1 + dx * (cx1 <= cx2 ? +1 : -1) + W / 2;\n\t\t\t\tadd_shape.push_back(make_pair(ny,nx));\n\t\t\t\tfield[ny][nx] = 'X';\n \t\t\t} // end rep\n\t\t} // end if\n\t} // end rep\n\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tif (field[i][j] == 'X'){\n\t\t\t\trep (k, 4){\n\t\t\t\t\tint ny = i + dy[k];\n\t\t\t\t\tint nx = j + dx[k];\n\t\t\t\t\tif (ny <= 0 || ny >= H + 1 || nx <= 0 || nx >= W + 1) continue;\n\t\t\t\t\tif (field[ny][nx] != '.') continue;\n\t\t\t\t\tfield[ny][nx] = 'O';\n\t\t\t\t} // end rep\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end rep\n\n\tbool escape = false;\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tif (field[i][j] == 'O'){\n\t\t\t\tbool curr = bfs(field[i][j], i, j);\n\t\t\t\tif (!curr) field[i][j] = '.';\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\trep (i, add_shape.size()){\n\t\tint py = add_shape[i].first;\n\t\tint px = add_shape[i].second;\n\t\tif (origin.count(make_pair(py,px))) continue;\n\t\tfield[py][px] = '.';\n\t} // end rep\n\n\tescape = false;\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tif (field[i][j] == 'X'){\n\t\t\t\tbool curr = bfs(field[i][j], i, j);\n\t\t\t\tif (curr) escape |= true;\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\tint res = 0;\n\tif (escape){\n\t\tres = -1;\n\t}else{\n\t\tfor (int i = 1; i <= H; ++i){\n\t\t\tfor (int j = 1; j <= W; ++j){\n\t\t\t\tres += (int)(field[i][j] == 'O');\n\t\t\t} // end for\n\t\t} // end for\n\t} // end if\n\tcout << res << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nint H,W;\nstring s[102];\nbool b[102][102];\nbool vis[102][102];\nint dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nint ans;\nbool is(int x,int y){\n\treturn 0<=x&&x<H&&0<=y&&y<W;\n}\nvoid dfs(int x,int y){\n\tvis[x][y]=1;\n\tif(b[x][y]){\n\t\tans++;\n\t\treturn;\n\t}\n\trep(d,4){\n\t\tint nx=x+dx[d],ny=y+dy[d];\n\t\tif(is(nx,ny)&&!vis[nx][ny]) dfs(nx,ny);\n\t}\n}\nint solve(){\n\tcin>>H>>W;\n\trep1(i,H) cin>>s[i];\n\trep1(i,H){\n\t\tif(s[i][0]=='X'||s[i][W-1]=='X') return -1;\n\t}\n\trep(j,W){\n\t\tif(s[1][j]=='X'||s[H][j]=='X') return -1;\n\t}\n\ts[0]=s[H+1]=string(W+2,'.');\n\trep1(i,H) s[i]='.'+s[i]+'.';\n\tH+=2,W+=2;\n\trep(i,H) rep(j,W) if(s[i][j]=='X'){\n\t\trep(d,4){\n\t\t\tint nx=i+dx[d],ny=j+dy[d];\n\t\t\tb[nx][ny]=1;\n\t\t}\n\t}\n\tdfs(0,0);\n\treturn ans;\n}\nint main(){\n\tcout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nint H, W;\nstring b[100];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nvoid dfs(int x, int y) {\n\tif(b[y][x] == '#') {\n\t\tb[y][x] = '$';\n\t\treturn;\n\t}\n\tif(b[y][x] != '.') return;\n\tb[y][x] = '@';\n\tfor(int k = 0; k < 4; k++) {\n\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\tif(in(nx, ny)) {\n\t\t\tif(b[ny][nx] == '#') b[ny][nx] = '$';\n\t\t\tif(b[ny][nx] == '.') dfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++) {\n\t\tcin >> b[i];\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\tif(b[i][0] == 'X' || b[i][W - 1] == 'X') {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = 0; i < W; i++) {\n\t\tif(b[0][i] == 'X' || b[H - 1][i] == 'X') {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(y + 2 < H && b[y][x] == 'X' && b[y + 1][x] == 'X' && b[y + 2][x] == 'X') {\n\t\t\t\tif(x - 1 != 0) b[y + 1][x - 1] = 'X';\n\t\t\t\tif(x + 1 != W - 1) b[y + 1][x + 1] = 'X';\n\t\t\t}\n\t\t\tif(x + 2 < W && b[y][x] == 'X' && b[y][x + 1] == 'X' && b[y][x + 2] == 'X') {\n\t\t\t\tif(y - 1 != 0) b[y - 1][x + 1] = 'X';\n\t\t\t\tif(y + 1 != H - 1) b[y + 1][x + 1] = 'X';\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(b[y][x] == 'X') {\n\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\tif(b[ny][nx] == '.') b[ny][nx] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\tdfs(0, i);\n\t\tdfs(W - 1, i);\n\t}\n\tfor(int i = 0; i < W; i++) {\n\t\tdfs(i, 0);\n\t\tdfs(i, H - 1);\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\t//cout << b[i] << endl;\n\t}\n\n\tint ans = 0;\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(b[y][x] == '$') ans++;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <tuple>\n#include <array>\n#include <queue>\nusing namespace std;\nusing Weight = int;\nusing Flow = int;\n \nconstexpr Flow inf = 1234;\n \n                            // N  E  S  W\nconstexpr array<int, 4> dr = {-1, 0, 1, 0},\n                        dc = { 0, 1, 0,-1};\nconstexpr int dr_size = dr.size();\n \nstruct Edge {\n  int dst, rev;\n  Flow capa;\n  Weight cost;\n};\n \nstruct Graph {\n  int size;\n  vector<vector<Edge>> g;\n  Graph(int size) : size(size) { g.resize(size); }\n  void add_edge(int src, int dst, Flow capa);\n  void add_edge(int src, int dst, Flow capa, Weight cost);\n  Flow max_flow(int s, int t) { throw; }\n  Flow min_cost_flow_ford(int s, int t, Flow f); // ベルマンフォード\n  Flow min_cost_flow_dijk(int s, int t, Flow f); // ダイクストラ\n};\n \nstruct FordFulkerson : Graph {\n  vector<bool> used;\n  FordFulkerson(int size) : Graph(size) {}\n  Flow max_flow(int s, int t);\nprivate:\n  Flow dfs(int v, int t, Flow flow);\n};\n \nstruct Dinic : Graph {\n  vector<int> level, iter;\n  Dinic(int size) : Graph(size) {}\n  Flow max_flow(int s, int t);\nprivate:\n  void bfs(int s);\n  Flow dfs(int v, int t, Flow flow);\n};\n \nvoid Graph::add_edge(int src, int dst, Flow capa) {\n  add_edge(src, dst, capa, 0);\n}\n \nvoid Graph::add_edge(int src, int dst, Flow capa, Weight cost) {\n  g[src].push_back(Edge({dst, int(g[dst].size()),   capa, cost}));\n  g[dst].push_back(Edge({src, int(g[src].size())-1, 0,        -cost}));\n}\n \nFlow Graph::min_cost_flow_ford(int s, int t, Flow f) {\n  Flow res = 0;\n  vector<int> prev_v(size), prev_e(size);\n  vector<Flow> dist;\n  while(f > 0) {\n    dist.assign(size, inf);\n    dist[s] = 0;\n    bool update = true;\n    while(update) {\n      update = false;\n      for(int v=0; v<size; ++v) {\n        if(dist[v] == inf) { continue; }\n        for(int i=0; i<g[v].size(); ++i) {\n          Edge& e = g[v][i];\n          if(e.capa > 0 && dist[e.dst] > dist[v] + e.cost) {\n            dist[e.dst] = dist[v] + e.cost;\n            prev_v[e.dst] = v;\n            prev_e[e.dst] = i;\n            update = true;\n          }\n        }\n      }\n    }\n    if(dist[t] == inf) { return inf; }\n    Flow d = f;\n    for(int v=t; v!=s; v=prev_v[v]) {\n      d = min(d, g[prev_v[v]][prev_e[v]].capa);\n    }\n    f -= d;\n    res += d * dist[t];\n    for(int v=t; v!=s; v=prev_v[v]) {\n      Edge& e = g[prev_v[v]][prev_e[v]];\n      e.capa -= d;\n      g[v][e.rev].capa += d;\n    }\n  }\n  return res;\n}\n \nFlow Graph::min_cost_flow_dijk(int s, int t, Flow f) {\n  Flow res = 0;\n  vector<int> prev_v(size), prev_e(size);\n  vector<int> h(size);\n  while(f > 0) {\n    vector<int> dist(size, inf);\n    dist[s] = 0;\n    queue<pair<int, int>> que;\n    // 最短距離、番号\n    que.emplace(0, s);\n    while(!que.empty()) {\n      int c, v; tie(c, v) = que.front(); que.pop();\n      if(dist[v] < c) { continue; }\n      for(int i=0; i<g[v].size(); ++i) {\n        Edge& e = g[v][i];\n        if(e.capa > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n          dist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n          prev_v[e.dst] = v;\n          prev_e[e.dst] = i;\n          que.emplace(dist[e.dst], e.dst);\n        }\n      }\n    }\n    if(dist[t] == inf) { return inf; }\n    for(int v=0; v<size; ++v) { h[v] += dist[v]; }\n    Flow d = f;\n    for(int v=t; v!=s; v=prev_v[v]) {\n      d = min(d, g[prev_v[v]][prev_e[v]].capa);\n    }\n    f -= d;\n    res += d * h[t];\n    for(int v=t; v!=s; v=prev_v[v]) {\n      Edge& e = g[prev_v[v]][prev_e[v]];\n      e.capa -= d;\n      g[v][e.rev].capa += d;\n    }\n  }\n  return res;\n}\n \nFlow FordFulkerson::max_flow(int s, int t) {\n  Flow res = 0;\n  while(true) {\n    used.assign(size, false);\n    Flow flow = dfs(s, t, inf);\n    if(flow == 0) { return res; }\n    res += flow;\n    if(res >= inf) { return inf; }\n  }\n}\n \nFlow FordFulkerson::dfs(int v, int t, Flow flow) {\n  if(v == t) { return flow; }\n  used[v] = true;\n  for(Edge& e : g[v]) {\n    if(used[e.dst] || e.capa <= 0) { continue; }\n    int d = dfs(e.dst, t, min(flow, e.capa));\n    if(d > 0) {\n      e.capa -= d;\n      g[e.dst][e.rev].capa += d;\n      return d;\n    }\n  }\n  return 0;\n}\n \nvoid Dinic::bfs(int s) {\n  level.assign(size, -1);\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty()) {\n    int v = que.front(); que.pop();\n    for(Edge& e : g[v]) {\n      if(e.capa > 0 && level[e.dst] < 0) {\n        level[e.dst] = level[v] + 1;\n        que.push(e.dst);\n      }\n    }\n  }\n}\n \nFlow Dinic::dfs(int v, int t, Flow flow) {\n  if(v == t) { return flow; }\n  for(int& i=iter[v]; i<g[v].size(); ++i) {\n    Edge& e = g[v][i];\n    if(e.capa <= 0 || level[v] >= level[e.dst]) { continue; }\n    Flow d = dfs(e.dst, t, min(flow, e.capa));\n    if(d > 0) {\n      e.capa -= d;\n      g[e.dst][e.rev].capa += d;\n      return d;\n    }\n  }\n  return 0;\n}\n \nFlow Dinic::max_flow(int s, int t) {\n  Flow res = 0;\n  while(true) {\n    bfs(s);\n    if(level[t] < 0) { return res; }\n    iter.assign(size, 0);\n    Flow flow;\n    while((flow = dfs(s, t, inf)) > 0) {\n      res += flow;\n      if(res >= inf) { return inf; }\n    }\n  }\n}\n \nint main(void) {\n  int R, C; cin >> R >> C;\n  vector<string> G(R);\n  for(int r=0; r<R; ++r) { cin >> G[r]; }\n \n  Dinic graph(R*C*2 + 2);\n \n  int s = R * C * 2,\n      t = s + 1;\n \n  for(int r=0; r<R; ++r) {\n    for(int c=0; c<C; ++c) {\n      int p = r * C + c,\n          q = p + R * C;\n      if(G[r][c] == 'X') {\n        graph.add_edge(p, q, inf);\n        graph.add_edge(s, p, inf);\n      } else {\n        graph.add_edge(p, q, 1);\n      }\n      for(int i=0; i<dr_size; ++i) {\n        int nr = r + dr[i],\n            nc = c + dc[i];\n        if(0 <= nr && nr < R && 0 <= nc && nc < C) { // (r, c) は端ではない\n          int np = nr * C + nc,\n              nq = np + R * C;\n          graph.add_edge(q, np, inf);\n        } else { // (r, c) は端である\n          graph.add_edge(q, t, inf);\n        }\n      }\n    }\n  }\n \n  Flow res = graph.max_flow(s, t);\n  if(res >= inf) { res = -1; }\n  cout << res << endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Network{\n\tprivate:\n\tint V;\n\tstruct edge{\n\t\tint to,cap,rev;\n\t};\n\tvector<vector<edge> > List;\n\tint DFS(int v,int t,int f,vb& used){\n\t\tif(v==t) return f;\n\t\tused[v]=1;\n\t\tfor(int i=0;i<List[v].size();i++){\n\t\t\tedge &e=List[v][i];\n\t\t\tif(!used[e.to]&&e.cap>0){\n\t\t\t\tint d=DFSplus(e.to,t,min(f,e.cap),used);\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tList[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tpublic:\n\tNetwork(int v){\n\t\tV=v;\n\t\tList=vector<vector<edge> >(v);\n\t}\n\tvoid add_edge(int s,int t,int c){\n\t\tList[s].push_back(edge{t,c,(int)List[t].size()});\n\t\tList[t].push_back(edge{s,0,(int)List[s].size()-1});\n\t}\n\tint MF(int s,int t){\n\t\tint ans=0;\n\t\twhile(1){\n\t\t\tvb used(V);\n\t\t\tint f=DFS(s,t,inf,used);\n\t\t\tif(f==0) return ans;\n\t\t\tans+=f;\n\t\t}\n\t}\n};\n\nint h,w;\nvvc a;\n\ninline int f(int x,int y){\n\treturn x*w+y;\n}\n\nint main(){\n\tcin>>h>>w;\n\ta=vvc(h,vc(w));\n\tNetwork nt(2*h*w+2);\n\tbool flag=1;\n\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++){\n\t\tcin>>a[i][j];\n\t\tif(a[i][j]=='X') nt.add_edge(2*h*w,h*w+f(i,j),inf);\n\t\telse nt.add_edge(f(i,j),h*w+f(i,j),1);\n\t\tif(!i||i==h-1||!j||j==w-1){\n\t\t\tnt.add_edge(h*w+f(i,j),2*h*w+1,inf);\n\t\t\tif(a[i][j]=='X') flag=0;\n\t\t}\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint x=i+dx[k],y=j+dy[k];\n\t\t\tif(x>=0&&x<h&&y>=0&&y<w) nt.add_edge(h*w+f(i,j),f(x,y),inf);\n\t\t}\n\t}\n\tif(!flag){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tcout<<nt.MFplus(2*h*w,2*h*w+1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 4e4;\nconst int OO = 0x3f3f3f3f;\nint SOURCE, SINK;\n\nstruct edge\n{\n    int v, f, c;\n    edge(){}\n    edge(int _v, int _f, int _c)\n    {\n        v = _v, f = _f, c = _c;\n    }\n};\n\nvector<edge> edges;\nvector<int> G[MAX];\nint dist[MAX], work[MAX];\n\nvoid add_edge(int u, int v, int cp, int rc){\n\tedges.push_back(edge(v, 0, cp));\n\tG[u].push_back(edges.size()-1);\n\tedges.push_back(edge(u, 0, rc));\n\tG[v].push_back(edges.size()-1);\n}\n\nbool bfs(int s, int t)\n{\n    memset(dist, -1, sizeof(dist));\n    dist[s] = 0;\n    queue<int> q;\n    q.push(s);\n    while(!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        for(int e : G[u])\n            if(dist[edges[e].v] == -1 and edges[e].c-edges[e].f > 0)\n            {\n                q.push(edges[e].v);\n                dist[edges[e].v] = dist[u] + 1;\n            }\n    }\n    return dist[t] != -1;\n}\n\nint dfs(int s, int t, int f)\n{\n    if(s == t) return f;\n    for(int &i = work[s]; i < G[s].size(); i++)\n    {\n    \tint e = G[s][i];\n        if(dist[edges[e].v] == dist[s] + 1 and edges[e].c-edges[e].f > 0)\n            if(int a = dfs(edges[e].v, t, min(f, edges[e].c-edges[e].f)))\n            {\n                edges[e].f += a;\n                edges[e^1].f -= a;\n                return a;\n            }\n    }\n    return 0;\n}\n\nint MaxFlow(int s, int t)\n{\n    int mf = 0;\n    while(bfs(s, t))\n\t{\n    \tmemset(work, 0, sizeof(work));\n        while(int a = dfs(s, t, OO))\n            mf += a;\n    }\n    return mf;\n}\n\nint n, m, a, b;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nbool check(int x, int y)\n{\n\treturn x >= 0 and x < n and y >= 0 and y < m;\n}\n\nint vertexIn(int i, int j)\n{\n\treturn i * m + j;\n}\n\nint vertexOut(int i, int j)\n{\n\treturn i * m + j + n * m + 1;\n}\n\nint main()\n{\n \tcin >> n >> m;\n \tSOURCE = 2 * n * m + 2;\n \tSINK = 2 * n * m + 3;\n \tfor(int i = 0; i < n; i++)\n \t\tfor(int j = 0; j < m; j++)\n \t\t{\n \t\t\tchar c;\n \t\t\tcin >> c;\n \t\t\tint cost = 1;\n \t\t\tif(c == 'X') cost = OO;\n \t\t\tadd_edge(vertexIn(i, j), vertexOut(i, j), cost, 0);\n \t\t\tif(cost == OO) add_edge(vertexOut(i, j), SINK, OO, 0);\n \t\t\tfor(int k = 0; k < 4; k++)\n \t\t\t{\n\t\t\t\tint x = i + dx[k], y = j + dy[k];\n\t\t\t\tif(check(x, y))\n \t\t\t\t\tadd_edge(vertexOut(i, j), vertexIn(x, y), OO, 0);\n \t\t\t}\n \t\t\tif(!i or !j or i == n - 1 or j == m - 1)\n \t\t\t\tadd_edge(SOURCE, vertexIn(i, j), OO, 0);\n \t\t}\t\n\tint ans = MaxFlow(SOURCE, SINK);\n\tif(ans >= 5 * n * m) ans = -1;\n \tcout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*? begin \"base.hpp\" */\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve( /* この関数に問題ごとの処理を書く */\n#ifdef GCJ_CASE\n long long case_id\n#endif\n);\n\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n #define debug true\n#else\n #define NDEBUG \n #define debug false\n#endif\n#include<algorithm>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<type_traits>\n#include<vector>\n#ifdef __cpp_lib_execution\n  #include<execution>\n#endif\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL \n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define times(n,i) uptil(0,n,i)\n#define rtimes(n,i) downto((n)-1,0,i)\n#define upto(f,t,i) for(int rabT##i=(t),i=(f);i<=rabT##i;i++)\n#define uptil(f,t,i) for(int rabT##i=(t),i=(f);i< rabT##i;i++)\n#define downto(f,t,i) for(int rabT##i=(t),i=(f);i>=rabT##i;i--)\n#define downtil(f,t,i) for(int rabT##i=(t),i=(f);i> rabT##i;i--)\n#define iter(v) begin(v),end(v)\n#define citer(v) cbegin(v),cend(v)\n#define riter(v) rbegin(v),rend(v)\n#define criter(v) crbegin(v),crend(v)\n#define IF(a,b,c) ((a)?(b):(c))\n#define BINOP_ASGN(t,u,op) t operator op(CS u&o)CS{RT t(*this)op##=o;}\n#if debug\n #define _GLIBCXX_DEBUG\n #define _LIBCPP_DEBUG 2\n #define _LIBCPP_DEBUG2 2\n #define ln <<endl\n#else\n #define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n #define PARABLE \n/*? begin \"mod.hpp\" */\n#ifdef MOD\n #if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n  #error unknown mod MOD and FORCE_MOD not defined.\n #endif\n#else\n #define MOD 1000000007\n#endif\n/*? begin \"power.hpp\" */\nusing int128=__int128;\nTL<TN T>T power(T x,int n){T rt(1);for(;n;n/=2){if(n%2)rt*=x;x*=x;}RT rt;}\nint pow_mod(int x,int n,int m){int rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\nint128 pow_mod_64(int128 x,int n,int m){int128 rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\n/*? end \"power.hpp\" */\nIL CX int modulo(int a,int m){RT(a%=m,a>=0?a:a+m);}\nTL<ULL mod=MOD>class MInt{\n  /*! https://ei1333.github.io/luzhiled/snippets/other/mod-int.html */\npublic:\n  int val;\n  CX MInt():val(0){}\n  explicit CX MInt(int v):val(modulo(v,mod)){}\n  MInt&operator+=(CS MInt&m){val+=m.val;if(val>=mod)val-=mod;RT*this;}\n  MInt&operator-=(CS MInt&m){val-=m.val;if(val<0)val+=mod;RT*this;}\n  MInt&operator*=(CS MInt&m){val=val*m.val%mod;RT*this;}\n  MInt&operator/=(CS MInt&m){val=val*m.inv().val%mod;RT*this;}\n  BINOP_ASGN(MInt,MInt,+) BINOP_ASGN(MInt,MInt,-) BINOP_ASGN(MInt,MInt,*) BINOP_ASGN(MInt,MInt,/)\n  MInt operator-()CS{MInt m;m.val=val?mod-val:0;RT m;}\n  bool operator==(CS MInt&m)CS{RT val==m.val;}\n  bool operator!=(CS MInt&m)CS{RT val!=m.val;}\n  //MInt pow(int n)CS{MInt x(*this),rt(1);while(n){if(n%2)rt*=x;x*=x;n/=2;}RT rt;}\n  MInt pow(int n)CS{RT power(*this,n);}\n  MInt inv()CS{int a=val,b=mod,x=1,y=0,t;while(b){t=a/b;swap(b,a-=t*b);swap(y,x-=t*y);}RT(MInt)x;}\n  friend ostream&operator<<(ostream&o,CS MInt<mod>&m){RT o<<m.val;}\n  friend istream&operator>>(istream&i,MInt<mod>&m){int v;i>>v;m=MInt<mod>(v);RT i;}\n};\nusing mint=MInt<>;\n\nconstexpr mint operator\"\" _m(ULL n){RT mint(n);}\nconstexpr MInt<998244353>operator\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nconstexpr MInt<1000000007>operator\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nconstexpr MInt<1000000009>operator\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n\n//#pragma rab:gsub \\b(\\d+)m\\b mint(\\1)\n/*? end \"mod.hpp\" */\n/*? begin \"typedefs.hpp\" */\nstruct unit{};\n\nusing int128=__int128;\nusing LD=long double;\nTL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;\nTL<TN T>using vvvec=vec<vvec<T>>;\nTL<TN T>using vvvvec=vec<vvvec<T>>;\n\n//#pragma rab typedefs.dynamic\nusing WI = vvec<int>; using VI = vec<int>; using VC = vec<char>; using HII = map<int, int>; using VS = vec<string>; \n/*? end \"typedefs.hpp\" */\n/*? begin \"alias.hpp\" */\n#define EB emplace_back\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n/*? end \"alias.hpp\" */\n/*? begin \"util.hpp\" */\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,true);}\nTL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,true);}\n\n#ifndef __cpp_lib_exchange_function\n #define exchange exchange_RAB\n TL<TN T,TN U=T>IL T exchange(T& t, U&& u){T x=move(t);t=forward<U>(u);RT x;}\n#endif\n#ifndef __cpp_lib_clamp\n #define clamp clamp_RAB\n TL<TN T>IL CX CS T&clamp(CS T&a,CS T&mn,CS T&mx){RT a<mn?mn:a>mx?mx:a;}\n#endif\n\nTL<TN T>IL int size_RAB(T t){RT t.size();}\n#define size size_RAB\n\nTL<TN V>IL void uniq_after_sort(V&v){v.erase(unique(iter(v)),v.end());}\nTL<TN V>IL void sort_and_uniq(V&v){sort(iter(v));v.erase(unique(iter(v)),v.end());}\nTL<TN V,TN K>IL auto leftmost_ge(CS V&v,CS K&k){RT v.lower_bound(k);}\nTL<TN V,TN K>IL auto leftmost_gt(CS V&v,CS K&k){RT v.upper_bound(k);}\n\nnamespace rab{\n\nTL<TN V,TN W>IL void append(V&v,CS W&w){copy(PARABLE citer(w),back_inserter(v));}\n\nTL<TN V>IL auto flatten(CS V&xss,int reserve_size=0)->TN V::value_type{\n  decltype(flatten(xss))ret;\n  ret.reserve(reserve_size);\n  for(CS auto&xs:xss)append(ret,xs);\n  ret.shrink_to_fit();\n  RT move(ret);\n}\n\nTL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}\n\nTL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){RT 0<=i&&i<size(v)?v[i]:d;}\nTL<TN T>IL T fetch(CS T&d,CS vvec<T>&v,int i,int j){\n  RT 0<=i&&i<size(v)&&0<=j&&j<size(v[i])?v[i][j]:d;\n}\n// TL<TN T,TN U,TN...I>IL T fetch(CS T&d,CS vec<vec<U>>&v,int i,I...j){\n// RT 0<=i&&i<size(v)?fetch(d,v[i],j...):d;\n// }\nTL<TN T>struct Compressed{int size;map<T,int>zip;vec<T>unzip;};\nTL<TN T>IL Compressed<T>compressed(vec<T>v){\n  sort_and_uniq(v);map<T,int>zip;times(size(v),i)zip[v[i]]=i;RT{size(v),zip,move(v)};\n}\nTL<TN T>struct CompressedSrc{int size;map<T,int>zip;vec<T>unzip;WI src;};\nTL<TN T>IL CompressedSrc<T>compressed_src(CS vec<T>&v){\n  auto c=compressed(v);VI src(c.size);times(size(v),i)src[c.zip[v[i]]].PB(i);RT{c.size,c.zip,c.unzip,src};\n}\n\nstruct identity{TL<TN U>U operator()(U&&v)CS{RT v;}};\n}\n/*? end \"util.hpp\" */\n/*? begin \"debug.hpp\" */\nTL<class T>\nIL istream&operator>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nTL<class T>\nIL ostream&operator<<(ostream&,CS vec<T>&);\nTL<class T,class S>\nIL ostream&operator<<(ostream&,CS map<T,S>&);\n#define DEFINE_ITER_OUTPUT(s,x,sep){int i=0;for(CS auto&x##0_elem:x){if(i++)s<<sep;s<<x##0_elem;}RT s;}\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<T>&v)DEFINE_ITER_OUTPUT(s,v,' ')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS map<T,S>&m)DEFINE_ITER_OUTPUT(s,m,' ')\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<vec<T>>&w)DEFINE_ITER_OUTPUT(s,w,'\\n')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS vec<map<T,S>>&v)DEFINE_ITER_OUTPUT(s,v,'\\n')\n/*? end \"debug.hpp\" */\n\nsigned main(){\n {if(debug)cerr<<\"MOD: \"<<(MOD)ln;}\n if(!debug)cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\n cout<<fixed<<setprecision(20);\n cerr<<fixed<<setprecision(20);\n\n #ifdef GCJ_CASE\n  int T;cin>>T;\n  times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n #else\n  solve();\n #endif\n\n return 0;\n}\n/*? end \"base.hpp\" */\n/*? begin \"graph.hpp\" */\n/*? begin \"uf.hpp\" */\nTL<class T=int,class Adder=plus<T>,class Inverser=negate<T>>\nclass UnionFind{\n/*!\nhttp://noshi91.hatenablog.com/entry/2018/05/30/191943\nhttps://en.wikipedia.org/wiki/Disjoint-set_data_structure\nhttps://qiita.com/drken/items/cce6fc5c579051e64fab\n*/\nint n,*parents,*sizes;T*pot_diffs;bool to_delete;Adder adder;\nInverser inverser;\npublic:\nexplicit UnionFind(int n,bool to_delete=false):\nn(n),parents(new int[n]),sizes(new int[n]),pot_diffs(new T[n]),to_delete(to_delete)\n{clear();\n}\nvoid clear(){\ntimes(n,i)parents[i]=i;/*roots*/\nfill(sizes,sizes+n,1);fill(pot_diffs,pot_diffs+n,0);\n}\n~UnionFind(){if(to_delete){delete[]parents;delete[]sizes;delete[]pot_diffs;}}\nint size(){RT n;}\nint root(int i){int p=parents[i];\nif(p==i)RT i;/*`i`is a root*/\nint r=root(p);/*and pot_diffs[p]:=diff from root*/\npot_diffs[i]+=pot_diffs[p];parents[i]=r;RT r;\n}\nbool is_same(int i,int j){RT root(i)==root(j);}\nbool is_all_same(){int r=root(0);uptil(1,n,i)if(root(i)!=r)RT 0;RT 1;}\nbool merge(int i,int j,T pdiff=0){i=root(i);j=root(j);\nif(i==j)RT false;/*already merged*/\nif(sizes[i]>sizes[j]){swap(i,j);pdiff=inverser(pdiff);\n}\n/*now sizes[i]<=sizes[j]*/\nparents[i]=j;sizes[j]+=sizes[i];pot_diffs[i]=pdiff;RT true;\n}\nT diff(int i,int j){\nroot(i);/*pot_diffs[i]:=diff from root*/\nroot(j);/*pot_diffs[j]:=diff from root*/\nRT adder(pot_diffs[i],inverser(pot_diffs[j]));}};using unionfind=UnionFind<>;\n/*? end \"uf.hpp\" */\nTL<class EdgeVal>\nstruct Edge{int from;int to;EdgeVal weight;\nEdge(int from,int to,EdgeVal weight):from(from),to(to),weight(weight){}\nIL bool OP==(CS Edge&e)CS{RT weight==e.weight&&from==e.from&&to==e.to;}\nIL bool OP<(CS Edge&e)CS{RT weight<e.weight||(weight==e.weight&&(from<e.from||(from==e.from&&to<e.to)));}\nIL bool OP<=(CS Edge&e)CS{RT this==e||this<e;}\nIL bool OP>(CS Edge&e)CS{RT e<this;}\nIL bool OP>=(CS Edge&e)CS{RT e<=this;}};\nTL<class VtxVal,class EdgeVal>\nclass Graph{\nusing VoidWithoutEdgeVal=TN enable_if<is_default_constructible<EdgeVal>::value,void>::type;\nprotected:\nint nv_,nde_;unionfind uf;\npublic:\nvec<VtxVal>vs;vvec<Edge<EdgeVal>>edges;\nGraph(int nv):nv_(nv),nde_(0),uf(nv),vs(nv),edges(nv){}\nIL int nv()CS{RT nv_;}\nIL int nde()CS{RT nde_;}\nIL int nue()CS{RT nde_/2;}\nIL void add_dedge(int i,int j,CS EdgeVal&val){\nif(debug&&(!rab::is_in(i,0LL,nv_)||!rab::is_in(j,0LL,nv_))){\ncerr<<\"invalid index:(\"<<i<<\",\"<<j<<\")for Graph(nv=\"<<nv_<<\")\" ln;\nexit(1);\n}\nedges[i].emplace_back(i,j,val);++nde_;\n}\nIL VoidWithoutEdgeVal add_dedge(int i,int j){add_dedge(i,j,EdgeVal());\n}\nIL void add_uedge(int i,int j,CS EdgeVal&val){add_dedge(i,j,val);\nadd_dedge(j,i,val);\n}\nIL VoidWithoutEdgeVal add_uedge(int i,int j){add_uedge(i,j,EdgeVal());\n}\nIL bool is_connected(){uf.clear();\nfor(CS auto&es:edges)for(CS auto&e:es)uf.merge(e.from,e.to);RT uf.is_all_same();\n}};\n/*? end \"graph.hpp\" */\n/*? begin \"flow.hpp\" */\n/*!Arihon,https://tubo28.me/algorithm/dinic/*/\nTL<TN F,TN V,TN E,TN CapFn=rab::identity>\nclass dinic{\npublic:\nstruct EdgeInfo{F cap;F flow;CS int rev_idx;\nEdgeInfo(F cap,F flow,int rev_idx):cap(cap),flow(flow),rev_idx(rev_idx){}};\nint n,s,t;VI level,prog,que;vvec<Edge<EdgeInfo>>edges;\ndinic(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),level(n),prog(n),que(n+1),edges(n)\n{times(n,i){for(auto&e:g.edges[i]){F c=capfn(e.weight);\nint zt=size(edges[e.to]),zi=size(edges[i]);edges[i].EB(i,e.to,EdgeInfo(c,(F)0,zt));\nedges[e.to].EB(e.to,i,EdgeInfo(c,c,zi));\n}}}\nF exec(int s,int t){this->s=s;this->t=t;F mf=0,inf=numeric_limits<F>::max()/8;\nwhile(update_level(),level[s]>0){fill(iter(prog),0);mf+=find_paths(s,inf);\n}\nRT mf;\n}\nvoid update_level(){int ql=0,qr=0;fill(iter(level),0);level[t]=n;\nque[qr++]=t;while(ql!=qr){int v=que[ql++];if(v==s)break;\nfor(CS auto&e:edges[v]){if(level[e.to]==0&&e.weight.flow!=0){level[e.to]=level[v]-1;\nque[qr++]=e.to;\n}}}}\nF find_paths(int v,int limit){if(v==t)RT limit;F diff=0;\nfor(int ze=size(edges[v]),&i=prog[v];i<ze;++i){auto&e=edges[v][i];\nif(level[v]<level[e.to]&&e.weight.cap!=e.weight.flow){F df=find_paths(e.to,min(limit,e.weight.cap-e.weight.flow));\ne.weight.flow+=df;edges[e.to][e.weight.rev_idx].weight.flow-=df;\ndiff+=df;limit-=df;if(limit==0)break;\n}}\nRT diff;}};\n/*!Arihon,https://tubo28.me/algorithm/ford-fulkerson/*/\nTL<TN V,TN E,TN CapFn=rab::identity>\nstruct ford_fulkerson{int n,s,t;VC visited;\nWI edges;/*both direction*/\nprivate:\nHII cap_,flow_;\npublic:\nford_fulkerson(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),visited(n),edges(n)\n{times(n,i){for(auto&e:g.edges[i]){int c=capfn(e.weight);\ncap_[i<<32|e.to]+=c;cap_[e.to<<32|i]+=c;flow_[e.to<<32|i]+=c;edges[i].PB(e.to);\nedges[e.to].PB(i);\n}}}\nint cap(int a,int b){RT cap_[a<<32|b];}\nint flow(int a,int b){RT flow_[a<<32|b];}\nint exec(int s,int t){this->s=s;this->t=t;int mf=0;\nwhile(1){fill(iter(visited),false);int df=find_path(s,LLONG_MAX/8/*inf*/);if(df==0)RT mf;\nmf+=df;\n}}\nint find_path(int v,int limit){visited[v]=true;if(v==t)RT limit;\nfor(int d:edges[v]){if(!visited[d]){int c=cap_[v<<32|d],&f=flow_[v<<32|d];\nif(c-f>0){int df=find_path(d,min(limit,c-f));if(df>0){f+=df;flow_[d<<32|v]-=df;RT df;\n}}}}\nRT 0;}};\n/*? end \"flow.hpp\" */\nconstexpr int INF = 401;\n\nvoid solve() {\n// HWH(\"S\")\n/* <foxy.memo-area> */\nint H;int W;cin>>H;cin>>W;VS S(H);times(H,Ri_0){cin>>S[Ri_0];}\n/* </foxy.memo-area> */\n\n  Graph<unit, int> g(H * W * 2 + 2);\n\n  int s = H * W * 2, t = H * W * 2 + 1;\n\n  #define inp(i, j) (((i) * W + (j)) * 2)\n  #define outp(i, j) (((i) * W + (j)) * 2 + 1)\n\n  times(H, i) times(W, j) {\n    g.add_dedge(inp(i, j), outp(i, j), 1);\n\n    if(S[i][j] == 'X') {\n      g.add_dedge(s, outp(i, j), INF);\n\n      if(i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n        cout << -1 ln;\n        return;\n      }\n    }\n  }\n\n  times(H, i) {\n    g.add_dedge(outp(i, 0), t, INF);\n    g.add_dedge(outp(i, W-1), t, INF);\n\n    times(W-1, j) {\n      g.add_dedge(outp(i, j), inp(i, j + 1), INF);\n      g.add_dedge(outp(i, j + 1), inp(i, j), INF);\n    }\n  }\n  times(W, j) {\n    g.add_dedge(outp(0, j), t, INF);\n    g.add_dedge(outp(H-1, j), t, INF);\n\n    times(H-1, i) {\n      g.add_dedge(outp(i, j), inp(i + 1, j), INF);\n      g.add_dedge(outp(i + 1, j), inp(i, j), INF);\n    }\n  }\n\n  dinic<int, unit, int> d(g);\n  cout << d.exec(s, t) ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mem(x,n) memset(x,n,sizeof(x))\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,l) for(auto it=(l).begin();it!=(l).end();it++)\n#define pnl printf(\"\\n\")\n#define len(x) (x).length()\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\nconst double EPS=1e-10;\n//const double PI=acos(-1.0);\nconst int INF=1<<30;\nconst LL LLINF=1ll<<60;\nconst int MOD=1e9+7;\nconst int xx[8]={1,0,-1,0,1,-1,1,-1};\nconst int yy[8]={0,1,0,-1,-1,1,1,-1};\n\n/****************************************************************************************\\\n  __    __               __ /\\/|   ___ _           _       /\\/|__               __    __\n  \\ \\  / /  _____ __ ____\\ \\/\\/   / __| |__ _ _ __(_)___  |/\\// /____ __ _____  \\ \\  / /\n   \\ \\| |  |___\\ V  V /___| |    | (__| / _` | '_ \\ / -_)    | |___\\ V  V /___|  | |/ /\n    \\_\\ |  |___|\\_/\\_/|___| |     \\___|_\\__,_| .__/_\\___|    | |___|\\_/\\_/|___|  | /_/\n       \\_\\               /_/                 |_|              \\_\\               /_/\n\\****************************************************************************************/\n\nstruct edge{\n\tint v, bf;\n\tLL flow;\n};\n\nconst int MAXN = 40010;\nvector<edge> adj[MAXN];\nint lvl[MAXN], st[MAXN];\nconst int sink = 40008, source = 40009;\nint idx[1005][1005],idx1[1005][1005];\nchar input[1005][1005];\n\nvoid addedge(int u,int v,LL flow){\n\tadj[u].pb({v,sz(adj[v]),flow});\n\tadj[v].pb({u,sz(adj[u])-1,0});\n}\n\nbool bfs(int S,int G){\n\tqueue<int> q;\n\tmem(lvl,-1);\n\tq.push(S); lvl[S]=0;\n\twhile(!q.empty()){\n\t\tint u = q.front(); q.pop();\n\t\tfor(int i=0;i<sz(adj[u]);i++){\n\t\t\tint v = adj[u][i].v;\n\t\t\tLL flow = adj[u][i].flow;\n\t\t\tif(lvl[v]!=-1||flow<=0) continue;\n\t\t\tlvl[v]=lvl[u]+1;\n\t\t\tq.push(v);\n\t\t}\n\t}\n\treturn (lvl[G]!=-1);\n}\n\nLL dfs(int u,LL mini,int G){\n\tif(u==G) return mini;\n\t\n\tfor(int i=st[u];i<sz(adj[u]);i++){\n\t\tst[u]=i;\n\t\tint v = adj[u][i].v;\n\t\tLL flow = adj[u][i].flow;\n\t\tif(flow<=0||(lvl[v]-lvl[u]!=1)) continue;\n\t\tLL ret=dfs(v,min(mini,flow),G);\n\t\tif(ret>0){\n\t\t\tadj[u][i].flow-=ret;\n\t\t\tint bvf = adj[u][i].bf;\n\t\t\tadj[v][bvf].flow+=ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nLL maxflow(int S,int G){\n\tLL ret=0;\n\tbool fl=false;\n\twhile(1){\n\t\tif(!bfs(S,G)) break;\n\t\tLL flow = 0;\n\t\tmem(st,0);\n\t\twhile((flow=dfs(S, LLINF, G))>0){\n\t\t\tret+=flow;\n\t\t\tfl=true;\n\t\t}\n\t}\n\tif(!fl) return LLINF;\n\treturn ret;\n}\n\nint main(){\n\tint r,c;\n\tscanf(\"%d%d\",&r,&c);\n\tgetchar();\n\tfor(int i=0;i<r;i++){\n\t\tscanf(\"%s\",input[i]);\n\t}\n\t\n\tint temp=0;\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tidx[i][j]=temp;\n\t\t\tidx1[i][j]=temp+20000;\n\t\t\ttemp++;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(input[i][j]=='.'){\n\t\t\t\taddedge(idx[i][j],idx1[i][j],1);\n\t\t\t\t\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\taddedge(idx1[i][j],sink,INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\taddedge(source,idx[i][j],INF);\n\t\t\t\taddedge(idx[i][j],idx1[i][j],INF);\n\t\t\t\t\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(i!=0) addedge(\tidx1[i][j], idx[i-1][j],INF);\n\t\t\tif(i!=r-1) addedge(\tidx1[i][j], idx[i+1][j],INF);\n\t\t\tif(j!=0) addedge(\tidx1[i][j], idx[i][j-1],INF);\n\t\t\tif(j!=c-1)addedge(\tidx1[i][j], idx[i][j+1],INF);\n\t\t}\n\t}\n\t\n\tLL ans = maxflow(source,sink);\n\tif(ans==LLINF) printf(\"-1\\n\");\n\telse printf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\n#define INF (1 << 29)\nusing namespace std;\n\nstruct point{\n    int x, y;\n};\n\nchar f[105][105] = {0};\nbool fb[105][105] = {0};\nint h, w;\nstatic const int dy[4] = {0,1,0,-1};\nstatic const int dx[4] = {1,0,-1,0};\n\nbool CanEscape(){\n    rep(i,h) if(f[i][0] == 'X' || f[i][w - 1] == 'X') return 1;\n    rep(i,w) if(f[0][i] == 'X' || f[h - 1][i] == 'X') return 1;\n    return 0;\n}\n\nvoid check(queue<point> &q){\n    rep(i,h){\n        rep(j,w){\n            if(f[i][j] == 'X'){\n                point p;\n                p.y = i; p.x = j;\n                q.push(p);\n                rep(k,4){\n                    int y = i + dy[k];\n                    int x = j + dx[k];\n                    if(y < 0 || y >= h || x < 0 || x >= w) continue;\n                    if(f[y][x] != 'X') fb[y][x] = 1;\n                }\n            }\n        }\n    }\n}\n\nbool goatCanEscape(int y, int x){\n    bool isVisited[105][105] = {0};\n    queue<point> q;\n    point start_coordinate;\n    start_coordinate.x = x;\n    start_coordinate.y = y;\n\n    isVisited[start_coordinate.y][start_coordinate.x] = 1;\n    q.push(start_coordinate);\n\n    point u;\n    while(!q.empty()){\n        u = q.front(); q.pop();\n        rep(i,4){\n            point next;\n            next.x = u.x + dx[i];\n            next.y = u.y + dy[i];\n            if(next.y < 0 || next.y >= h || next.x < 0 || next.x >= w) return 1;\n            if(isVisited[next.y][next.x] == 0 && fb[next.y][next.x] == 0){\n                isVisited[next.y][next.x] = 1;\n                q.push(next);\n            }\n        }\n    }\n    return 0;\n}\n\nbool allGoatNotEscape(int y, int x, queue<point> q){\n    while(not q.empty()){\n        if(goatCanEscape(q.front().y, q.front().x)) return 0;\n        q.pop();\n    }\n    return 1;\n}\n\nvoid deleteUselessFence(queue<point> q){\n    int k = 5;\n    while(k--){\n        rep(i,h){\n            rep(j,w){\n                if(fb[i][j] == 1 && f[i][j] != 'X'){\n                    fb[i][j] = 0;\n                    if(not allGoatNotEscape(i, j, q)){\n                        fb[i][j] = 1;\n                    }\n                }\n            }\n        }\n    }\n}\n\nint oneSide(){\n    bool fence[105][105] = {0};\n    rep(i,h){\n        rep(j,w){\n            if(fb[i][j] == 1){\n                fence[i][j] = 1;\n                break;\n            }\n        }\n    }\n    rep(i,h){\n        for(int j = w - 1; j >= 0; j--){\n            if(fb[i][j] == 1){\n                fence[i][j] = 1;\n                break;\n            }\n        }\n    }\n    rep(i,w){\n        rep(j,h){\n            if(fb[j][i] == 1){\n                fence[j][i] = 1;\n                break;\n            }\n        }\n    }\n    rep(i,w){\n        for(int j = h - 1; j >= 0; j--){\n            if(fb[j][i] == 1){\n                fence[j][i] = 1;\n                break;\n            }\n        }\n    }\n    int cnt = 0;\n    rep(i,h){\n        rep(j,w){\n            if(fence[i][j] == 1) cnt++;\n        }\n    }\n    return cnt;\n}\n\nint countFence(){\n    int cnt = 0;\n    rep(i,h){\n        rep(j,w){\n            if(fb[i][j] == 1) cnt++;\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    cin >> h >> w;\n    rep(i,h) cin >> f[i];\n    if(CanEscape()){\n        cout << -1 << endl;\n    }else{\n        queue<point> q;\n        check(q);\n        //deleteUselessFence(q);\n        cout << oneSide() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct flow_graph{\n    static const int MAX_V = 20005;\n    static const int MAX_E = 80000;\n\n    int E,s,t,head,tail;\n    int cap[2 * MAX_E],to[2 * MAX_E],next[2 * MAX_E],last[MAX_V],dist[MAX_V],q[MAX_V],now[MAX_V];\n\n    flow_graph(){\n        E = 0;\n        memset(last,-1,sizeof last);\n    }\n\n    void clear(){\n        E = 0;\n        memset(last,-1,sizeof last);\n    }\n\n    void add_edge(int u, int v, int uv){\n        to[E] = v, cap[E] = uv, next[E] = last[u]; last[u] = E++;\n        to[E] = u, cap[E] = 0, next[E] = last[v]; last[v] = E++;\n    }\n\n    bool bfs(){\n        memset(dist,-1,sizeof dist);\n        head = tail = 0;\n\n        q[tail] = t; ++tail;\n        dist[t] = 0;\n\n        while(head < tail){\n            int v = q[head]; ++head;\n\n            for(int e = last[v];e != -1;e = next[e]){\n                if(cap[e^1] > 0 && dist[to[e]] == -1){\n                    q[tail] = to[e]; ++tail;\n                    dist[to[e]] = dist[v]+1;\n                }\n            }\n        }\n\n        return dist[s] != -1;\n    }\n\n    int dfs(int v, int f){\n        if(v == t) return f;\n\n        for(int &e = now[v];e != -1;e = next[e]){\n            if(cap[e] > 0 && dist[to[e]] == dist[v]-1){\n                int ret = dfs(to[e],min(f,cap[e]));\n\n                if(ret > 0){\n                    cap[e] -= ret;\n                    cap[e^1] += ret;\n                    return ret;\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    int max_flow(int source, int sink, int V){\n        s = source; t = sink;\n        int f = 0,df;\n\n        while(bfs()){\n            for(int i = 0;i < V;++i) now[i] = last[i];\n\n            while(true){\n                df = dfs(s,INT_MAX);\n                if(df == 0) break;\n                f += df;\n            }\n        }\n\n        return f;\n    }\n}G;\n\nchar s[100][101];\nconst int INF = 100000;\nint dr[] = {-1,1,0,0};\nint dc[] = {0,0,-1,1};\n\nint main(){\n    int H,W;\n\n    scanf(\"%d %d\",&H,&W);\n\n    for(int i = 0;i < H;++i)\n        scanf(\"%s\",s[i]);\n\n    for(int i = 0;i < W;++i){\n        G.add_edge(0,1 + i,INF);\n        if(H >= 2) G.add_edge(0,1 + (H - 1) * W + i,INF);\n    }\n\n    for(int i = 1;i + 1 < H;++i){\n        G.add_edge(0,1 + i * W,1);\n        if(W >= 2) G.add_edge(0,1 + i * W + (W - 1),INF);\n    }\n\n    for(int i = 0;i < H;++i){\n        for(int j = 0;j < W;++j){\n            if(s[i][j] == 'X'){\n                G.add_edge(1 + H * W + i * W + j,1 + 2 * H * W,INF);\n                G.add_edge(1 + i * W + j,1 + H * W + i * W + j,INF);\n            }else{\n                G.add_edge(1 + i * W + j,1 + H * W + i * W + j,1);\n            }\n\n            for(int k = 0;k < 4;++k){\n                int r = i + dr[k],c = j + dc[k];\n\n                if(r >= 0 && r < H && c >= 0 && c < W){\n                    G.add_edge(1 + H * W + i * W + j,1 + r * W + c,INF);\n                }\n            }\n        }\n    }\n\n    int ans = G.max_flow(0,1 + 2 * H * W,2 + 2 * H * W);\n    printf(\"%d\\n\",ans >= INF? -1 : ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*? begin \"base.hpp\" */\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve( /* この関数に問題ごとの処理を書く */\n#ifdef GCJ_CASE\n long long case_id\n#endif\n);\n\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n #define debug true\n#else\n #define NDEBUG \n #define debug false\n#endif\n#include<algorithm>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<type_traits>\n#include<vector>\n#ifdef __cpp_lib_execution\n  #include<execution>\n#endif\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL \n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define times(n,i) uptil(0,n,i)\n#define rtimes(n,i) downto((n)-1,0,i)\n#define upto(f,t,i) for(int rabT##i=(t),i=(f);i<=rabT##i;i++)\n#define uptil(f,t,i) for(int rabT##i=(t),i=(f);i< rabT##i;i++)\n#define downto(f,t,i) for(int rabT##i=(t),i=(f);i>=rabT##i;i--)\n#define downtil(f,t,i) for(int rabT##i=(t),i=(f);i> rabT##i;i--)\n#define iter(v) begin(v),end(v)\n#define citer(v) cbegin(v),cend(v)\n#define riter(v) rbegin(v),rend(v)\n#define criter(v) crbegin(v),crend(v)\n#define IF(a,b,c) ((a)?(b):(c))\n#define BINOP_ASGN(t,u,op) t operator op(CS u&o)CS{RT t(*this)op##=o;}\n#if debug\n #define _GLIBCXX_DEBUG\n #define _LIBCPP_DEBUG 2\n #define _LIBCPP_DEBUG2 2\n #define ln <<endl\n#else\n #define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n #define PARABLE \n/*? begin \"mod.hpp\" */\n#ifdef MOD\n #if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n  #error unknown mod MOD and FORCE_MOD not defined.\n #endif\n#else\n #define MOD 1000000007\n#endif\n/*? begin \"power.hpp\" */\nusing int128=__int128;\nTL<TN T>T power(T x,int n){T rt(1);for(;n;n/=2){if(n%2)rt*=x;x*=x;}RT rt;}\nint pow_mod(int x,int n,int m){int rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\nint128 pow_mod_64(int128 x,int n,int m){int128 rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\n/*? end \"power.hpp\" */\nIL CX int modulo(int a,int m){RT(a%=m,a>=0?a:a+m);}\nTL<ULL mod=MOD>class MInt{\n  /*! https://ei1333.github.io/luzhiled/snippets/other/mod-int.html */\npublic:\n  int val;\n  CX MInt():val(0){}\n  explicit CX MInt(int v):val(modulo(v,mod)){}\n  MInt&operator+=(CS MInt&m){val+=m.val;if(val>=mod)val-=mod;RT*this;}\n  MInt&operator-=(CS MInt&m){val-=m.val;if(val<0)val+=mod;RT*this;}\n  MInt&operator*=(CS MInt&m){val=val*m.val%mod;RT*this;}\n  MInt&operator/=(CS MInt&m){val=val*m.inv().val%mod;RT*this;}\n  BINOP_ASGN(MInt,MInt,+) BINOP_ASGN(MInt,MInt,-) BINOP_ASGN(MInt,MInt,*) BINOP_ASGN(MInt,MInt,/)\n  MInt operator-()CS{MInt m;m.val=val?mod-val:0;RT m;}\n  bool operator==(CS MInt&m)CS{RT val==m.val;}\n  bool operator!=(CS MInt&m)CS{RT val!=m.val;}\n  //MInt pow(int n)CS{MInt x(*this),rt(1);while(n){if(n%2)rt*=x;x*=x;n/=2;}RT rt;}\n  MInt pow(int n)CS{RT power(*this,n);}\n  MInt inv()CS{int a=val,b=mod,x=1,y=0,t;while(b){t=a/b;swap(b,a-=t*b);swap(y,x-=t*y);}RT(MInt)x;}\n  friend ostream&operator<<(ostream&o,CS MInt<mod>&m){RT o<<m.val;}\n  friend istream&operator>>(istream&i,MInt<mod>&m){int v;i>>v;m=MInt<mod>(v);RT i;}\n};\nusing mint=MInt<>;\n\nconstexpr mint operator\"\" _m(ULL n){RT mint(n);}\nconstexpr MInt<998244353>operator\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nconstexpr MInt<1000000007>operator\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nconstexpr MInt<1000000009>operator\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n\n//#pragma rab:gsub \\b(\\d+)m\\b mint(\\1)\n/*? end \"mod.hpp\" */\n/*? begin \"typedefs.hpp\" */\nstruct unit{};\n\nusing int128=__int128;\nusing LD=long double;\nTL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;\nTL<TN T>using vvvec=vec<vvec<T>>;\nTL<TN T>using vvvvec=vec<vvvec<T>>;\n\n//#pragma rab typedefs.dynamic\nusing WI = vvec<int>; using VI = vec<int>; using VC = vec<char>; using HII = map<int, int>; using VS = vec<string>; \n/*? end \"typedefs.hpp\" */\n/*? begin \"alias.hpp\" */\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n/*? end \"alias.hpp\" */\n/*? begin \"util.hpp\" */\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,true);}\nTL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,true);}\n\n#ifndef __cpp_lib_exchange_function\n #define exchange exchange_RAB\n TL<TN T,TN U=T>IL T exchange(T& t, U&& u){T x=move(t);t=forward<U>(u);RT x;}\n#endif\n#ifndef __cpp_lib_clamp\n #define clamp clamp_RAB\n TL<TN T>IL CX CS T&clamp(CS T&a,CS T&mn,CS T&mx){RT a<mn?mn:a>mx?mx:a;}\n#endif\n\nTL<TN T>IL int size_RAB(T t){RT t.size();}\n#define size size_RAB\n\nTL<TN V>IL void uniq_after_sort(V&v){v.erase(unique(iter(v)),v.end());}\nTL<TN V>IL void sort_and_uniq(V&v){sort(iter(v));v.erase(unique(iter(v)),v.end());}\nTL<TN V,TN K>IL auto leftmost_ge(CS V&v,CS K&k){RT v.lower_bound(k);}\nTL<TN V,TN K>IL auto leftmost_gt(CS V&v,CS K&k){RT v.upper_bound(k);}\n\nnamespace rab{\n\nTL<TN V,TN W>IL void append(V&v,CS W&w){copy(PARABLE citer(w),back_inserter(v));}\n\nTL<TN V>IL auto flatten(CS V&xss,int reserve_size=0)->TN V::value_type{\n  decltype(flatten(xss))ret;\n  ret.reserve(reserve_size);\n  for(CS auto&xs:xss)append(ret,xs);\n  ret.shrink_to_fit();\n  RT move(ret);\n}\n\nTL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}\n\nTL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){RT 0<=i&&i<size(v)?v[i]:d;}\nTL<TN T>IL T fetch(CS T&d,CS vvec<T>&v,int i,int j){\n  RT 0<=i&&i<size(v)&&0<=j&&j<size(v[i])?v[i][j]:d;\n}\n// TL<TN T,TN U,TN...I>IL T fetch(CS T&d,CS vec<vec<U>>&v,int i,I...j){\n// RT 0<=i&&i<size(v)?fetch(d,v[i],j...):d;\n// }\nTL<TN T>struct Compressed{int size;map<T,int>zip;vec<T>unzip;};\nTL<TN T>IL Compressed<T>compressed(vec<T>v){\n  sort_and_uniq(v);map<T,int>zip;times(size(v),i)zip[v[i]]=i;RT{size(v),zip,move(v)};\n}\nTL<TN T>struct CompressedSrc{int size;map<T,int>zip;vec<T>unzip;WI src;};\nTL<TN T>IL CompressedSrc<T>compressed_src(CS vec<T>&v){\n  auto c=compressed(v);VI src(c.size);times(size(v),i)src[c.zip[v[i]]].PB(i);RT{c.size,c.zip,c.unzip,src};\n}\n\nstruct identity{TL<TN U>U operator()(U&&v)CS{RT v;}};\n}\n/*? end \"util.hpp\" */\n/*? begin \"debug.hpp\" */\nTL<class T>\nIL istream&operator>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nTL<class T>\nIL ostream&operator<<(ostream&,CS vec<T>&);\nTL<class T,class S>\nIL ostream&operator<<(ostream&,CS map<T,S>&);\n#define DEFINE_ITER_OUTPUT(s,x,sep){int i=0;for(CS auto&x##0_elem:x){if(i++)s<<sep;s<<x##0_elem;}RT s;}\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<T>&v)DEFINE_ITER_OUTPUT(s,v,' ')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS map<T,S>&m)DEFINE_ITER_OUTPUT(s,m,' ')\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<vec<T>>&w)DEFINE_ITER_OUTPUT(s,w,'\\n')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS vec<map<T,S>>&v)DEFINE_ITER_OUTPUT(s,v,'\\n')\n/*? end \"debug.hpp\" */\n\nsigned main(){\n {if(debug)cerr<<\"MOD: \"<<(MOD)ln;}\n if(!debug)cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\n cout<<fixed<<setprecision(20);\n cerr<<fixed<<setprecision(20);\n\n #ifdef GCJ_CASE\n  int T;cin>>T;\n  times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n #else\n  solve();\n #endif\n\n return 0;\n}\n/*? end \"base.hpp\" */\n/*? begin \"graph.hpp\" */\n/*? begin \"uf.hpp\" */\nTL<class T=int,class Adder=plus<T>,class Inverser=negate<T>>\nclass UnionFind{\n/*!\nhttp://noshi91.hatenablog.com/entry/2018/05/30/191943\nhttps://en.wikipedia.org/wiki/Disjoint-set_data_structure\nhttps://qiita.com/drken/items/cce6fc5c579051e64fab\n*/\nint n,*parents,*sizes;T*pot_diffs;bool to_delete;Adder adder;\nInverser inverser;\npublic:\nexplicit UnionFind(int n,bool to_delete=false):\nn(n),parents(new int[n]),sizes(new int[n]),pot_diffs(new T[n]),to_delete(to_delete)\n{clear();\n}\nvoid clear(){\ntimes(n,i)parents[i]=i;/*roots*/\nfill(sizes,sizes+n,1);fill(pot_diffs,pot_diffs+n,0);\n}\n~UnionFind(){if(to_delete){delete[]parents;delete[]sizes;delete[]pot_diffs;}}\nint size(){RT n;}\nint root(int i){int p=parents[i];\nif(p==i)RT i;/*`i`is a root*/\nint r=root(p);/*and pot_diffs[p]:=diff from root*/\npot_diffs[i]+=pot_diffs[p];parents[i]=r;RT r;\n}\nbool is_same(int i,int j){RT root(i)==root(j);}\nbool is_all_same(){int r=root(0);uptil(1,n,i)if(root(i)!=r)RT 0;RT 1;}\nbool merge(int i,int j,T pdiff=0){i=root(i);j=root(j);\nif(i==j)RT false;/*already merged*/\nif(sizes[i]>sizes[j]){swap(i,j);pdiff=inverser(pdiff);\n}\n/*now sizes[i]<=sizes[j]*/\nparents[i]=j;sizes[j]+=sizes[i];pot_diffs[i]=pdiff;RT true;\n}\nT diff(int i,int j){\nroot(i);/*pot_diffs[i]:=diff from root*/\nroot(j);/*pot_diffs[j]:=diff from root*/\nRT adder(pot_diffs[i],inverser(pot_diffs[j]));}};using unionfind=UnionFind<>;\n/*? end \"uf.hpp\" */\nTL<class EdgeVal>\nstruct Edge{int from;int to;EdgeVal weight;\nEdge(int from,int to,EdgeVal weight):from(from),to(to),weight(weight){}\nIL bool OP==(CS Edge&e)CS{RT weight==e.weight&&from==e.from&&to==e.to;}\nIL bool OP<(CS Edge&e)CS{RT weight<e.weight||(weight==e.weight&&(from<e.from||(from==e.from&&to<e.to)));}\nIL bool OP<=(CS Edge&e)CS{RT this==e||this<e;}\nIL bool OP>(CS Edge&e)CS{RT e<this;}\nIL bool OP>=(CS Edge&e)CS{RT e<=this;}};\nTL<class VtxVal,class EdgeVal>\nclass Graph{\nusing VoidWithoutEdgeVal=TN enable_if<is_default_constructible<EdgeVal>::value,void>::type;\nprotected:\nint nv_,nde_;unionfind uf;\npublic:\nvec<VtxVal>vs;vvec<Edge<EdgeVal>>edges;\nGraph(int nv):nv_(nv),nde_(0),uf(nv),vs(nv),edges(nv){}\nIL int nv()CS{RT nv_;}\nIL int nde()CS{RT nde_;}\nIL int nue()CS{RT nde_/2;}\nIL void add_dedge(int i,int j,CS EdgeVal&val){\nif(!rab::is_in(i,0LL,nv_)||!rab::is_in(j,0LL,nv_)){\ncerr<<\"invalid index:(\"<<i<<\",\"<<j<<\")for Graph(nv=\"<<nv_<<\")\" ln;\nexit(1);\n}\nedges[i].emplace_back(i,j,val);++nde_;\n}\nIL VoidWithoutEdgeVal add_dedge(int i,int j){add_dedge(i,j,EdgeVal());\n}\nIL void add_uedge(int i,int j,CS EdgeVal&val){add_dedge(i,j,val);\nadd_dedge(j,i,val);\n}\nIL VoidWithoutEdgeVal add_uedge(int i,int j){add_uedge(i,j,EdgeVal());\n}\nIL bool is_connected(){uf.clear();\nfor(CS auto&es:edges)for(CS auto&e:es)uf.merge(e.from,e.to);RT uf.is_all_same();\n}};\n/*? end \"graph.hpp\" */\n/*? begin \"flow.hpp\" */\n/*!Arihon,https://tubo28.me/algorithm/dinic/*/\nTL<TN F,TN V,TN E,TN CapFn=rab::identity>\n/*F:通常int,CapFn:E->F*/\nstruct dinic{\nusing EdgeInfo=tuple<F,F,int>;/*cap,flow,reverse_index*/\n#define dinic_cap(e)get<0>(e.weight)\n#define dinic_flow(e)get<1>(e.weight)\n#define dinic_reverse_index(e)get<2>(e.weight)\nint n,s,t;VI level,prog,que;\nvvec<Edge<EdgeInfo>>edges;/*both direction*/\ndinic(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),level(n),prog(n),que(n+1),edges(n)\n{times(n,i){for(auto&e:g.edges[i]){F c=capfn(e.weight);\nint zt=size(edges[e.to]),zi=size(edges[i]);edges[i].PB(Edge<EdgeInfo>(i,e.to,{c,(F)0,zt}));\nedges[e.to].PB(Edge<EdgeInfo>(e.to,i,{c,c,zi}));\n}}}\nF exec(int s,int t){this->s=s;this->t=t;F mf=0;\nwhile(update_level(),level[t]>0){fill(iter(prog),0);mf+=find_paths(s,numeric_limits<F>::max()/8/*inf*/);\n}\nRT mf;\n}\nvoid update_level(){int ql=0,qr=0;fill(iter(level),-1);level[s]=0;\nque[qr++]=s;while(ql!=qr/*queue is not empty*/){int v=que[ql++];\nif(v==t)break;\nfor(CS auto&e:edges[v]){\nif(level[e.to]<0&&dinic_cap(e)!=dinic_flow(e)){level[e.to]=level[v]+1;\nque[qr++]=e.to;\n}}}}\nF find_paths(int v,int limit){if(v==t)RT limit;F diff=0;\nfor(;prog[v]<size(edges[v]);++prog[v]){auto&e=edges[v][prog[v]];\nif(dinic_cap(e)!=dinic_flow(e)&&level[v]<level[e.to]){F df=find_paths(e.to,min(limit,dinic_cap(e)-dinic_flow(e)));\ndinic_flow(e)+=df;dinic_flow(edges[e.to][dinic_reverse_index(e)])-=df;\ndiff+=df;limit-=df;if(limit==0)break;\n}}\nRT diff;}};\n/*!Arihon,https://tubo28.me/algorithm/ford-fulkerson/*/\nTL<TN V,TN E,TN CapFn=rab::identity>\nstruct ford_fulkerson{int n,s,t;VC visited;\nWI edges;/*both direction*/\nprivate:\nHII cap_,flow_;\npublic:\nford_fulkerson(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),visited(n),edges(n)\n{times(n,i){for(auto&e:g.edges[i]){int c=capfn(e.weight);\ncap_[i<<32|e.to]+=c;cap_[e.to<<32|i]+=c;flow_[e.to<<32|i]+=c;edges[i].PB(e.to);\nedges[e.to].PB(i);\n}}}\nint cap(int a,int b){RT cap_[a<<32|b];}\nint flow(int a,int b){RT flow_[a<<32|b];}\nint exec(int s,int t){this->s=s;this->t=t;int mf=0;\nwhile(1){fill(iter(visited),false);int df=find_path(s,LLONG_MAX/8/*inf*/);if(df==0)RT mf;\nmf+=df;\n}}\nint find_path(int v,int limit){visited[v]=true;if(v==t)RT limit;\nfor(int d:edges[v]){if(!visited[d]){int c=cap_[v<<32|d],&f=flow_[v<<32|d];\nif(c-f>0){int df=find_path(d,min(limit,c-f));if(df>0){f+=df;flow_[d<<32|v]-=df;RT df;\n}}}}\nRT 0;}};\n/*? end \"flow.hpp\" */\nconstexpr int INF = 401;\n\nvoid solve() {\n// HWH(\"S\")\n/* <foxy.memo-area> */\nint H;int W;cin>>H;cin>>W;VS S(H);times(H,Ri_0){cin>>S[Ri_0];}\n/* </foxy.memo-area> */\n\n  Graph<unit, int> g(H * W * 2 + 2);\n\n  int s = H * W * 2, t = H * W * 2 + 1;\n\n  #define inp(i, j) (((i) * W + (j)) * 2)\n  #define outp(i, j) (((i) * W + (j)) * 2 + 1)\n\n  times(H, i) times(W, j) {\n    g.add_dedge(inp(i, j), outp(i, j), 1);\n\n    if(S[i][j] == 'X') {\n      g.add_dedge(s, outp(i, j), INF);\n\n      if(i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n        cout << -1 ln;\n        return;\n      }\n    }\n  }\n\n  times(H, i) {\n    g.add_dedge(outp(i, 0), t, INF);\n    g.add_dedge(outp(i, W-1), t, INF);\n\n    times(W-1, j) {\n      g.add_dedge(outp(i, j), inp(i, j + 1), INF);\n      g.add_dedge(outp(i, j + 1), inp(i, j), INF);\n    }\n  }\n  times(W, j) {\n    g.add_dedge(outp(0, j), t, INF);\n    g.add_dedge(outp(H-1, j), t, INF);\n\n    times(H-1, i) {\n      g.add_dedge(outp(i, j), inp(i + 1, j), INF);\n      g.add_dedge(outp(i + 1, j), inp(i, j), INF);\n    }\n  }\n\n  dinic<int, unit, int> d(g);\n  cout << d.exec(s, t) ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n#include <ciso646>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> T;\ntypedef vector<ll> vec;\n\ninline bool check(ll x, ll y, ll xMax, ll yMax) { return x >= 0 && y >= 0 && xMax > x && yMax > y; }\ninline int toint(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string tostring(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\ntemplate<class T> inline T mypow(T x, ll n) { T res = 1; while (n > 0) { if (n & 1)res = res * x;\tx = x * x;\tn >>= 1; }return res; }\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\n#define For(i,a,b)\tfor(ll (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define rFor(i,a,b)\tfor(ll (i) = (a-1);i >= (b);(i)--)\n#define rrep(i,n)\trFor(i,n,0)\n#define each(i,n)\tfor(auto &i : n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define sz(a)\t\t(sizeof(a))\n#define tostr(a)\ttostring(a)\n#define dump(val) \tcerr << #val \" = \" << val << endl;\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nconst ll dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 }, dy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1e17 + 9;\n\n#define int ll\n#define double ld\n\nsigned main() {\n\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> s(h);\n\trep(i, h) {\n\t\tcin >> s[i];\n\t}\n\trep(y, h)rep(x, w) {\n\t\tif (s[y][x] == 'X' && (!y || !x || y == h-1 || x == w-1)) {\n\t\t\tcout << -1 << endl; return 0;\n\t\t}\n\t\tif (s[y][x] == 'X') {\n\t\t\trep(dir, 4) {\n\t\t\t\tint tx = x + dx[dir], ty = y + dy[dir];\n\t\t\t\tif (check(tx, ty, w, h) && s[ty][tx] != 'X') {\n\t\t\t\t\ts[ty][tx] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<P> rm;\n\trep(y, h)rep(x, w) {\n\t\tif (s[y][x] == '#') {\n\t\t\tbool ok = false;\n\t\t\trep(dir, 4) {\n\t\t\t\tint tx = x + dx[dir], ty = y + dy[dir];\n\t\t\t\tif (check(tx, ty, w, h)) {\n\t\t\t\t\tif (s[ty][tx] == '.')ok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok == false) {\n\t\t\t\trm.push_back(P(y, x));\n\t\t\t}\n\t\t}\n\t}\n\teach(p, rm) {\n\t\ts[p.first][p.second] = '.';\n\t}\n\n\trep(y, h) {\n\t\tcerr << s[y] << endl;\n\t}\n\n\tint ans = 0;\n\trep(y, h)rep(x, w) {\n\t\tif (s[y][x] == '#')ans++;\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans-3<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nbool isImpossible(std::vector<std::string> grid) {\n\t// ヤギが外周にいる場合はどうやっても無理\n\tint h = grid.size(), w = grid[0].size();\n\tfor (int i = 0; i < h; i++) {\n\t\tif (grid[i][0] == 'X' || grid[i][w - 1] == 'X') return true;\n\t}\n\tfor (int i = 0; i < w; i++) {\n\t\tif (grid[0][i] == 'X' || grid[h - 1][i] == 'X') return true;\n\t}\n\treturn false;\n}\n\nbool outSide(int x, int y, int h, int w) {\n\tif (x == 0 || x == h - 1 || y == 0 || y == w - 1) return true;\n\treturn false;\n}\n\nbool isInside(int x, int y, int h, int w) {\n\tif (0 <= x && x < h && 0 <= y && y < w) return true;\n\treturn false;\n}\n\nbool solve(std::vector<std::string> grid, std::vector<std::pair<int, int> > yagi_pos) {\n\tstd::queue<std::pair<int, int> > q;\n\tint x_index[] = { 0,1,-1,0 },\n\t\ty_index[] = { 1,0,0,-1 };\n\tint h = grid.size(), w = grid[0].size();\n\tstd::vector<std::vector<bool> > visited(h, std::vector<bool>(w, false));\n\twhile (!yagi_pos.empty()) {\n\t\tq.push(yagi_pos.front());\n\t\twhile (!q.empty()) {\n\t\t\tint x = q.front().first,\n\t\t\t\ty = q.front().second;\n\t\t\tq.pop();\n\t\t\tif (visited[x][y]) continue;\n\t\t\tif (outSide(x, y, h, w)) return false;\n\t\t\tvisited[x][y] = true;\n\t\t\tif (grid[x][y] == 'X') {\n\t\t\t\tyagi_pos.erase(std::find(yagi_pos.begin(), yagi_pos.end(), std::make_pair(x, y)));\n\t\t\t}\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tif (isInside(x + x_index[i], y + y_index[i], h, w)) {\n\t\t\t\t\tif (grid[x + x_index[i]][y + y_index[i]] != '#') {\n\t\t\t\t\t\tq.push({ x + x_index[i], y + y_index[i] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\tint h, w;\n\tint x_index[] = { 0,1,-1,0 },\n\t\ty_index[] = { 1,0,0,-1 };\n\n\tstd::cin >> h >> w;\n\n\tstd::vector<std::string> grid(h);\n\n\tfor (int i = 0; i < h; i++) {\n\t\tstd::cin >> grid[i];\n\t}\n\n\tif (isImpossible(grid)) {\n\t\tstd::cout << -1 << std::endl;\n\t\treturn 0;\n\t}\n\n\tstd::vector<std::pair<int, int> > yagi_pos;\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (grid[i][j] == 'X') {\n\t\t\t\tyagi_pos.push_back({ i, j });\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (isInside(i + x_index[k], j + y_index[k], h, w)) {\n\t\t\t\t\t\tif (grid[i + x_index[k]][j + y_index[k]] != 'X') {\n\t\t\t\t\t\t\tgrid[i + x_index[k]][j + y_index[k]] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (grid[i][j] != '#') continue;\n\t\t\tstd::vector<std::string> tmp_grid = grid;\n\t\t\ttmp_grid[i][j] = '.';\n\t\t\tif (solve(tmp_grid, yagi_pos)) {\n\t\t\t\tgrid[i][j] = '.';\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\t//std::cout << grid[i][j] << \" \";\n\t\t\tif (grid[i][j] == '#') ans++;\n\t\t}\n\t\t//std::cout << std::endl;\n\t}\n\n\tstd::cout << ans << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,4){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==4){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,4){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==4){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nconst int INF = 830252521;\ntypedef int flow_type;\n// Dinic http://www.prefield.com/algorithm/graph/dinic.html\nstruct dinic{\n  struct edge{int from,to;flow_type cost;edge *rev;};\n  int n;\n  vector< vector<edge> > G;\n  vector< vector<edge> > C;\n  // vector< vector<flow_type> > flow, capacity;\n// #define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n  vi level;\n  vector<bool> finished;\n  dinic(int _n){\n    n = _n;\n    G.assign(n,vector<edge>());\n    // flow.assign(n,vector<flow_type>(n,0));\n    // capacity.assign(n,vector<flow_type>(n,0));\n    level.assign(n,0);\n    finished.assign(n,false);\n  }\n  void add_edge(int from,int to,flow_type cost){\n    assert(0<=from && from<n);\n    assert(0<=to && to<n);\n    edge s = (edge){from,to,cost,NULL};\n    G[from].push_back(s);\n  }\n  flow_type dfs(int u, int t, flow_type cur){\n    if(u==t || cur==0) return cur;\n    if(finished[u]) return 0;\n    finished[u] = true;\n    REP(i,C[u].size()){\n      edge &e = C[u][i];\n      if(level[e.to] > level[u]){\n        flow_type f = dfs(e.to, t, min(cur, e.cost));\n        if(f>0){\n          e.cost -= f;\n          e.rev->cost += f;\n          finished[u] = false;\n          return f;\n        }\n      }\n    }\n    return 0;\n  }\n  flow_type calc(int s, int t){\n    C.assign(n,vector<edge>());\n    REP(i,n)REP(j,G[i].size()){\n      edge s = G[i][j];\n      int from = s.from;\n      int to = s.to;\n      edge t = (edge){to,from,0,&s};\n      s.rev = &t;\n      C[from].push_back(s);\n      C[to].push_back(t);\n    }\n    flow_type total = 0;\n    while(true){\n      REP(i,n)level[i] = -1;\n      level[s] = 0;\n      queue<int> Q; Q.push(s);\n      int d = n;\n      while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        REP(i,C[u].size()){\n          edge &e = C[u][i];\n          if(e.cost > 0 && level[e.to] == -1){\n            Q.push(e.to);\n            level[e.to] = level[u] + 1;\n          }\n        }\n      }\n      REP(i,n)finished[i]=false;\n      bool flag = false;\n      while(true){\n        flow_type f = dfs(s,t,INF);\n        if(f==0)break;\n        total += f;\n        flag = true;\n      }\n      if(!flag)break;\n    }\n    return total;\n  }\n};\n\nint h,w;\nchar mp[125][125];\nint dd[] = {1,0,-1,0,1};\n\nint main(){\n  scanf(\"%d%d\",&h,&w);\n  REP(i,h)scanf(\"%s\",mp[i]);\n  // flow\n  dinic g(2*h*w+2);\n  int s=2*h*w;\n  int t=2*h*w+1;\n  REP(i,h)REP(j,w){\n    int id = i*w + j;\n    int x=2*id,y=2*id+1;\n    if(mp[i][j]=='X'){\n      if(i==0||i==h-1||j==0||j==w-1){\n        puts(\"-1\");\n        return 0;\n      }\n      g.add_edge(s,x,INF);\n      g.add_edge(x,y,INF);\n    }else{\n      g.add_edge(x,y,1);\n    }\n    if(i==0||i==h-1||j==0||j==w-1){\n      g.add_edge(y,t,INF);\n    }\n    REP(d,4){\n      int ni=i+dd[d],nj=j+dd[d+1];\n      if(ni<0||ni>=h||nj<0||nj>=w)continue;\n      int nid = ni*w + nj;\n      g.add_edge(y,2*nid,INF);\n    }\n  }\n  printf(\"%d\\n\",g.calc(s,t));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr,Vpr> PQ;\nconst int INF=1<<30;\nstruct Edge{\npublic:\n\tint to,cost,cp;\n\tEdge *rev;\n\tEdge(int t,int c,int cp):to(t),cost(c),cp(cp){\n\t\t\n\t}\n\tvoid add(int x){\n\t\tcp+=x;\n\t}\n\tvoid flow(int amount){\n\t\tadd(-amount);\n\t\trev->add(amount);\n\t}\n\tbool usable(){\n\t\treturn cp>=1;\n\t}\t\n};\nvoid unite(Edge &a,Edge &b){\n\ta.rev=&b;\n\tb.rev=&a;\n}\nclass Graph{\n\tint nodeSize,edgeSize;\n\tvector<int> dist;\n\tvector<vector<Edge> > edges;\npublic: \n\tvoid add(int a,int b,int cost,int cp){\n\t\tedges[a].PB(Edge(b,cost,cp));\n\t\tedges[b].PB(Edge(a,cost,0));\n\t\tunite(edges[a].back(),edges[b].back());\n\t}\n\tGraph(int x):nodeSize(x){\n\t\t\n\t\tedges=vector<vector<Edge> >(nodeSize);\n\t\tdist=VI(nodeSize);\n\t}\n\tvoid distInit(int s){\n\t\tREP(i,nodeSize){\n\t\t\tdist[i]=INF;\n\t\t}\n\t\tdist[s]=0;\n\t}\n\tint searching(int now,int e,int capacity){\n\t\tif(now==e) return capacity;\n\t\tif(capacity==0) return 0;\n\t\tif(dist[now]>=dist[e]) return 0;\n\t\tint flowed=0;\n\t\tREP(i,edges[now].size()){\n\t\t\tEdge *ed= &edges[now][i];\n\t\t\tif(!ed->usable()) continue;\n\t\t\tif(dist[now]+1 != dist[ed->to]) continue;\n\t\t\tint nflow=searching(ed->to,e,min(capacity-flowed,ed->cp));\n\t\t\tif(nflow){\n\t\t\t\tflowed+=nflow;\n\t\t\t\ted->flow(nflow);\n\t\t\t}\n\t\t}\n\t\treturn flowed;\n\t}\n\tbool bfs(int s,int e){\n\t\tdistInit(s);\n\t\tqueue<int> qu;\n\t\tqu.push(s);\n\t\twhile(!qu.empty()){\n\t\t\tint now=qu.front();\n\t\t\tif(now==e) return true;\n\t\t\tqu.pop();\n\t\t\tREP(i,edges[now].size()){\n\t\t\t\tEdge *ed= &edges[now][i];\n\t\t\t\tif(!ed->usable()) continue;\n\t\t\t\tif(dist[ed->to]==INF){\n\t\t\t\t\tqu.push(ed->to);\n\t\t\t\t\tdist[ed->to]=dist[now]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint maximumFlow(int s,int e){\n\t\tint ans=0;\n\t\twhile(bfs(s,e)){\n\t\t\tans+=searching(s,e,INF);\n\t\t}\n\t\treturn ans;\n\t}\n};\nconst int SIZE=101;\nint conv(int a,int b,int c){return a*100+b+SIZE*SIZE*c+2;}\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\nint H,W;\nint maps[101][101];\nbool isSafe(int y,int x){\n\treturn 0<=y && y<H && 0<=x && x<W;\n}\nint main(){\n\tGraph graph(SIZE*SIZE*3+2);\n\tcin >> H >> W;\n\tREP(i,H) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,s.size()){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(maps[i][j] &&(i==0 || j==0 || i==H-1 || j==W-1)){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\t\t\n\t}\n\tREP(i,H) REP(j,W) {\n\t\tgraph.add(conv(i,j,1),conv(i,j,0),0,1);\n//\t\tedges[conv(i,j,1)].PB(edge(conv(i,j,0),0,1));\n\t\tif(maps[i][j]){\n\t\t\t//edges[0].PB(edge(conv(i,j,1),0,1));\n\t\t\tgraph.add(0,conv(i,j,0),0,4);\n\t\t}\n\t\tREP(k,4){\n\t\t\tif(!isSafe(i+dy[k],j+dx[k])){\n\t\t\tgraph.add(conv(i,j,0),1,0,1);\n\t\t\t//\tedges[conv(i,j,0)].PB(edge(1,0,1));\n\t\t\t} \n\t\t\telse if(!maps[i+dy[k]][j+dx[k]]){\n\t\t\t\tgraph.add(conv(i,j,0),conv(i+dy[k],j+dx[k],1),0,1);\n\t\t\t\tgraph.add(conv(i+dy[k],j+dx[k],0),conv(i,j,1),0,1);\n//\t\t\t\tedges[conv(i,j,0)].PB(edge(conv(i+dy[k],j+dx[k],1),0,1));\n//\t\t\t\tedges[conv(i+dy[k],j+dx[k],0)].PB(edge(conv(i,j,1),0,1));\n\t\t\t}\n\t\t}\n\t\n\t}\n\tcout << graph.maximumFlow(0,1) << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { \n        auto i = invGeneral(a.val,MOD); assert(i != -1);\n        return i;\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\ntemplate<int SZ> struct Dinic {\n    struct Edge { int v, rev; ll flow, cap; };\n\n    vector<Edge> adj[SZ];\n\n    void addEdge(int u, int v, ll cap) {\n        // if (u == 0) ps(\"WUT\");\n        Edge a{v, sz(adj[v]), 0, cap}, b{u, sz(adj[u]), 0, 0};\n        adj[u].pb(a), adj[v].pb(b);\n    }\n\n    int ST, EN, level[SZ], ind[SZ];\n\n    bool bfs() { // level = shortest distance from source\n        // after computing flow, edges {u,v} such that level[u] \\neq -1, level[v] = -1 are part of min cut\n        F0R(i,SZ) level[i] = -1, ind[i] = 0;\n        level[ST] = 0;\n\n        queue<int> q; q.push(ST);\n        while (sz(q)) {\n            int u = q.front(); q.pop();\n            trav(e,adj[u]) if (level[e.v] < 0 && e.flow < e.cap) {\n                level[e.v] = level[u] + 1;\n                q.push(e.v);\n            }\n        }\n\n        return level[EN] >= 0;\n    }\n\n    ll sendFlow(int s, ll flow) {\n        if (s == EN) return flow;\n\n        for (  ; ind[s] < sz(adj[s]); ind[s] ++) {\n            Edge& e = adj[s][ind[s]];\n\n            if (level[e.v] != level[s]+1 || e.flow == e.cap) continue;\n            ll f = sendFlow(e.v, min(flow, e.cap - e.flow));\n\n            if (f) { // saturate at least one edge\n                e.flow += f; adj[e.v][e.rev].flow -= f;\n                return f;\n            }\n        }\n\n        return 0;\n    }\n\n    ll maxFlow(int _ST, int _EN) {\n        ST = _ST, EN = _EN;\n        if (ST == EN) return -1;\n        ll tot = 0;\n        while (bfs()) while (auto flow = sendFlow(ST, LLONG_MAX)) tot += flow;\n        return tot;\n    }\n};\n\nDinic<20002> D;\nint H,W;\nint xd[4] = {0,1,0,-1}, yd[4] = {1,0,-1,0};\n\nbool valid(int i, int j) {\n    return 0 <= i && i < H && 0 <= j && j < W;\n}\n\nint hsh(int i, int j, int k) {\n    if (!valid(i,j)) return k^1;\n    return H*W*k+2+W*i+j;\n}\n\nint main() {\n    setIO();  re(H,W);\n    F0R(i,H) {\n        string s; re(s);\n        F0R(j,W) {\n            F0R(k,4) if (hsh(i+xd[k],j+yd[k],1)) D.addEdge(hsh(i+xd[k],j+yd[k],1),hsh(i,j,0),MOD);\n            F0R(k,4) D.addEdge(hsh(i,j,1),hsh(i+xd[k],j+yd[k],0),MOD);\n            if (s[j] == '.') {\n                D.addEdge(hsh(i,j,0),hsh(i,j,1),1);\n                // ps(\"WHAT\",i,j,hsh(i,j,0),hsh(i,j,1));\n            } else {\n                if (i == 0 || i == H-1 || j == 0 || j == W-1) {\n                    ps(-1);\n                    exit(0);\n                }\n                // ps(\"HA\",i,j);\n                D.addEdge(hsh(i,j,0),hsh(i,j,1),MOD);\n                D.addEdge(0,hsh(i,j,0),MOD);\n            }\n        }\n    }\n    ps(D.maxFlow(0,1));\n}\n\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n     File Name: E.cpp\n     ID: obsoles1\n     BLOG: blog.csdn.net/obsolescence\n     LANG: C++ \n     Mail: 384099319@qq.com \n     Created Time: 日 10/ 2 15:48:28 2016\n ************************************************************************/\n#define MAX(x,y) ((x)>(y)?(x):(y))\n#define MIN(x,y) ((x)<(y)?(x):(y))\n#define EACH(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();++it)\n#define ABS(x,y) ((x)>(y)?((x)-(y)):((y)-(x)))\n#define MEM0(x) memset(x,0,sizeof(x))\n#define MEM1(x) memset(x,-1,sizeof(x))\n#define MEMX(x) memset(x,0x3f,sizeof(x))\n#define pb push_back\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\n\nusing namespace std;\nconst int N=110;\nchar mp[N][N];\n\nint main() {\n  int n,m,i,j;\n  scanf(\"%d%d\",&n,&m);\n  //cout<<\"n=\"<<n<<\" m=\"<<m<<endl;\n  int minh=n+1,minw=m+1,maxh=0,maxw=0;\n  for (i=1; i<=n; ++i) {\n    scanf(\"%s\",mp[i]+1);\n    for (j=1; j<=m; ++j) {\n      if (mp[i][j]=='X') {\n        minh=MIN(i,minh);\n        maxh=MAX(i,maxh);\n        minw=MIN(j,minw);\n        maxw=MAX(j,maxw);\n      }\n    }\n  }\n  //cout<<\"maxw=\"<<maxw<<endl;\n  if (minh==1 || minw==1 || maxh==n || maxw==m) puts(\"-1\");\n  else {\n    int h=maxh-minh+3,w=maxw-minw+3;\n    int tmp=h-w;\n    //if (maxh-minh+1 == maxw-minw+1)\n    if (!tmp) {\n      printf(\"%d\\n\",2*h-2);\n    } else if (tmp>0) {\n      printf(\"%d\\n\",2*w+(tmp-1)*2);\n    } else {\n      tmp=-tmp;\n      printf(\"%d\\n\",2*h+(tmp-1)*2);\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n\nusing namespace std;\n#define prev tavas\n#define rep(i, n) for (int i = 0, _n = (int)(n); i < _n; ++i)\nconst int N = (int) 2e5 + 5, mod = (int) 0, oo = 1e9 + 9;\nint n, m, mark[N], to[N], head[N], prev[N], cap[N], cnt = 0;\nstring mat[N];\nint f(int i, int j) { return i * m + j; }\nbool outer(int i, int j) {\n    return (i == 0 || j == 0 || i == n - 1 || j == m - 1);\n}\nvoid add_edge(int u, int v, int uv) {\n    to[cnt] = v, cap[cnt] = uv, prev[cnt] = head[u], head[u] = cnt++;\n    to[cnt] = u, cap[cnt] = +0, prev[cnt] = head[v], head[v] = cnt++;\n}\nint dfs(int v, int sink, int flow = oo) {\n    if (mark[v]++) return 0;\n    if (v == sink) return flow;\n    for (int e = head[v]; e != -1; e = prev[e]) {\n        int u = to[e];\n        if (cap[e]) {\n            int x = dfs(u, sink, min(flow, cap[e]));\n            if (x > 0) {\n                cap[e ^ 0] -= x;\n                cap[e ^ 1] += x;\n                return x;\n            }\n        }\n    }\n    return 0;\n}\nint max_flow(int source, int sink) {\n    int res = 0;\n    while (true) {\n        memset(mark, 0, sizeof mark);\n        int x = dfs(source, sink);\n        if (!x) break;\n        res += x;\n    }\n    return res;\n}\nint dx[] = {0, -1, 0, 1};\nint dy[] = {1, 0, -1, 0};\nint32_t main() {\n    memset(head, -1, sizeof head);\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n >> m;\n    for (int i = 0; i < n; ++i)\n        cin >> mat[i];\n    int sink = N - 1, source = N - 2;\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < m; ++j) {\n            for (int d = 0; d < 4; ++d) {\n                int x = i + dx[d], y = j + dy[d];\n                if (x >= 0 && y >= 0 && x < n && y < m) {\n                    add_edge(f(i, j) << 1 | 1, f(x, y) << 1, oo);\n                }\n            }\n            if (mat[i][j] == 'X')\n                add_edge(source, f(i, j) << 1, oo);\n            add_edge(f(i, j) << 1, f(i, j) << 1 | 1, 1 + oo * (mat[i][j] == 'X'));\n            if (outer(i, j)) {\n                if (mat[i][j] == 'X') {\n                    cout << -1 << endl;\n                    return 0;\n                }\n                add_edge(f(i, j) << 1 | 1, sink, oo);\n            }\n        }\n    cout << max_flow(source, sink) << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 105\n#define M 51\n#define INF 1000000007\n#define MOD 924844033\n#define MOD2 1000000009\n#define eps 1e-14\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,1,-1};\nstruct node\n{\n    int a,b,x,y;\n}edge[20*N*N];\nvector<int>e[20*N*N];\nint a[N][N],b[N][N],d[20*N*N];\nint bg,ed,cnt;\n\nbool bfs(int s)\n{\n       int front=0,rear=0;\n       int q[N];\n       memset(d,-1,sizeof(d));\n       q[rear++]=s;\n       d[s]=0;\n       while(front<rear)\n       {\n               int k=q[front++];\n               for(auto v:e[k])\n               {\n                   int a = edge[v].a,b = edge[v].b;\n                   int x = edge[v].x,y = edge[v].y;\n                   int flow,to;\n                   if(a == k)flow = x,to = b;\n                   else flow = y,to = a;\n                   if(flow>0&&d[to]==-1)\n                   {\n                       d[to]=d[k]+1;\n                       q[rear++]=to;\n                   }\n               }\n       }\n       if(d[ed]>=0)\n             return true;\n       return false;\n}\n\nint dinic(int k,int sum)  //k is the sourse\n{\n      if (k==ed)\n          return sum;\n      int os = sum;\n      for(auto v:e[k])\n      {\n          if(sum<=0)break;\n          int a = edge[v].a,b = edge[v].b;\n           int x = edge[v].x,y = edge[v].y;\n           int flow,to;\n           if(a == k)flow = x,to = b;\n           else flow = y,to = a;\n          if(d[to]==d[k]+1&&flow>0)\n          {\n                int tmp = dinic(to,min(sum,flow)); //Deep to the end.\n                if(a == k)\n                {\n                    edge[v].x -= tmp;\n                    edge[v].y += tmp;\n                }\n                else\n                {\n                    edge[v].y -= tmp;\n                    edge[v].x += tmp;\n                }\n                sum -= tmp;\n          }\n      }\n      return os-sum;\n}\n\nvoid addedge(int a,int b,int w)\n{\n    edge[++cnt].a = a;\n    edge[cnt].b = b;\n    edge[cnt].x = w;\n    edge[cnt].y = 0;\n    e[a].PB(cnt);\n    e[b].PB(cnt);\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    while(cin>>n>>m)\n    {\n        cnt = 0;\n        bg = 1,ed = n*m*2+1;\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                a[i][j] = i*m+j;\n                b[i][j] = i*m+j+n*m;\n            }\n        }\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                char c;\n                cin>>c;\n                if(c == 'X')\n                {\n                    addedge(a[i][j],b[i][j],INF);\n                    addedge(1,a[i][j],INF);\n                }\n                else addedge(a[i][j],b[i][j],1);\n            }\n        }\n        FOR(i,1,n)\n        {\n            addedge(b[i][1],ed,INF);\n            addedge(b[i][m],ed,INF);\n            FOR(j,1,m-1)addedge(b[i][j],a[i][j+1],INF);;\n            FOR(j,2,m)addedge(b[i][j],a[i][j-1],INF);\n        }\n        FOR(j,1,m)\n        {\n            addedge(b[1][j],ed,INF);\n            addedge(b[n][j],ed,INF);\n            FOR(i,1,n-1)addedge(b[i][j],a[i+1][j],INF);\n            FOR(i,2,n)addedge(b[i][j],a[i-1][j],INF);\n        }\n        int ret = 0;\n        while(bfs(bg))\n            ret += dinic(bg,INF);\n        if(ret == INF)cout<<-1<<endl;\n        else cout<<ret<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*? begin \"base.hpp\" */\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve( /* この関数に問題ごとの処理を書く */\n#ifdef GCJ_CASE\n long long case_id\n#endif\n);\n\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n #define debug true\n#else\n #define NDEBUG \n #define debug false\n#endif\n#include<algorithm>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<type_traits>\n#include<vector>\n#ifdef __cpp_lib_execution\n  #include<execution>\n#endif\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL \n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define times(n,i) uptil(0,n,i)\n#define rtimes(n,i) downto((n)-1,0,i)\n#define upto(f,t,i) for(int rabT##i=(t),i=(f);i<=rabT##i;i++)\n#define uptil(f,t,i) for(int rabT##i=(t),i=(f);i< rabT##i;i++)\n#define downto(f,t,i) for(int rabT##i=(t),i=(f);i>=rabT##i;i--)\n#define downtil(f,t,i) for(int rabT##i=(t),i=(f);i> rabT##i;i--)\n#define iter(v) begin(v),end(v)\n#define citer(v) cbegin(v),cend(v)\n#define riter(v) rbegin(v),rend(v)\n#define criter(v) crbegin(v),crend(v)\n#define IF(a,b,c) ((a)?(b):(c))\n#define BINOP_ASGN(t,u,op) t operator op(CS u&o)CS{RT t(*this)op##=o;}\n#if debug\n #define _GLIBCXX_DEBUG\n #define _LIBCPP_DEBUG 2\n #define _LIBCPP_DEBUG2 2\n #define ln <<endl\n#else\n #define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n #define PARABLE \n/*? begin \"mod.hpp\" */\n#ifdef MOD\n #if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n  #error unknown mod MOD and FORCE_MOD not defined.\n #endif\n#else\n #define MOD 1000000007\n#endif\n/*? begin \"power.hpp\" */\nusing int128=__int128;\nTL<TN T>T power(T x,int n){T rt(1);for(;n;n/=2){if(n%2)rt*=x;x*=x;}RT rt;}\nint pow_mod(int x,int n,int m){int rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\nint128 pow_mod_64(int128 x,int n,int m){int128 rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\n/*? end \"power.hpp\" */\nIL CX int modulo(int a,int m){RT(a%=m,a>=0?a:a+m);}\nTL<ULL mod=MOD>class MInt{\n  /*! https://ei1333.github.io/luzhiled/snippets/other/mod-int.html */\npublic:\n  int val;\n  CX MInt():val(0){}\n  explicit CX MInt(int v):val(modulo(v,mod)){}\n  MInt&operator+=(CS MInt&m){val+=m.val;if(val>=mod)val-=mod;RT*this;}\n  MInt&operator-=(CS MInt&m){val-=m.val;if(val<0)val+=mod;RT*this;}\n  MInt&operator*=(CS MInt&m){val=val*m.val%mod;RT*this;}\n  MInt&operator/=(CS MInt&m){val=val*m.inv().val%mod;RT*this;}\n  BINOP_ASGN(MInt,MInt,+) BINOP_ASGN(MInt,MInt,-) BINOP_ASGN(MInt,MInt,*) BINOP_ASGN(MInt,MInt,/)\n  MInt operator-()CS{MInt m;m.val=val?mod-val:0;RT m;}\n  bool operator==(CS MInt&m)CS{RT val==m.val;}\n  bool operator!=(CS MInt&m)CS{RT val!=m.val;}\n  //MInt pow(int n)CS{MInt x(*this),rt(1);while(n){if(n%2)rt*=x;x*=x;n/=2;}RT rt;}\n  MInt pow(int n)CS{RT power(*this,n);}\n  MInt inv()CS{int a=val,b=mod,x=1,y=0,t;while(b){t=a/b;swap(b,a-=t*b);swap(y,x-=t*y);}RT(MInt)x;}\n  friend ostream&operator<<(ostream&o,CS MInt<mod>&m){RT o<<m.val;}\n  friend istream&operator>>(istream&i,MInt<mod>&m){int v;i>>v;m=MInt<mod>(v);RT i;}\n};\nusing mint=MInt<>;\n\nconstexpr mint operator\"\" _m(ULL n){RT mint(n);}\nconstexpr MInt<998244353>operator\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nconstexpr MInt<1000000007>operator\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nconstexpr MInt<1000000009>operator\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n\n//#pragma rab:gsub \\b(\\d+)m\\b mint(\\1)\n/*? end \"mod.hpp\" */\n/*? begin \"typedefs.hpp\" */\nstruct unit{};\n\nusing int128=__int128;\nusing LD=long double;\nTL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;\nTL<TN T>using vvvec=vec<vvec<T>>;\nTL<TN T>using vvvvec=vec<vvvec<T>>;\n\n//#pragma rab typedefs.dynamic\nusing WI = vvec<int>; using VI = vec<int>; using VC = vec<char>; using HII = map<int, int>; using VS = vec<string>; \n/*? end \"typedefs.hpp\" */\n/*? begin \"alias.hpp\" */\n#define EB emplace_back\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n/*? end \"alias.hpp\" */\n/*? begin \"util.hpp\" */\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,true);}\nTL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,true);}\n\n#ifndef __cpp_lib_exchange_function\n #define exchange exchange_RAB\n TL<TN T,TN U=T>IL T exchange(T& t, U&& u){T x=move(t);t=forward<U>(u);RT x;}\n#endif\n#ifndef __cpp_lib_clamp\n #define clamp clamp_RAB\n TL<TN T>IL CX CS T&clamp(CS T&a,CS T&mn,CS T&mx){RT a<mn?mn:a>mx?mx:a;}\n#endif\n\nTL<TN T>IL int size_RAB(T t){RT t.size();}\n#define size size_RAB\n\nTL<TN V>IL void uniq_after_sort(V&v){v.erase(unique(iter(v)),v.end());}\nTL<TN V>IL void sort_and_uniq(V&v){sort(iter(v));v.erase(unique(iter(v)),v.end());}\nTL<TN V,TN K>IL auto leftmost_ge(CS V&v,CS K&k){RT v.lower_bound(k);}\nTL<TN V,TN K>IL auto leftmost_gt(CS V&v,CS K&k){RT v.upper_bound(k);}\n\nnamespace rab{\n\nTL<TN V,TN W>IL void append(V&v,CS W&w){copy(PARABLE citer(w),back_inserter(v));}\n\nTL<TN V>IL auto flatten(CS V&xss,int reserve_size=0)->TN V::value_type{\n  decltype(flatten(xss))ret;\n  ret.reserve(reserve_size);\n  for(CS auto&xs:xss)append(ret,xs);\n  ret.shrink_to_fit();\n  RT move(ret);\n}\n\nTL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}\n\nTL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){RT 0<=i&&i<size(v)?v[i]:d;}\nTL<TN T>IL T fetch(CS T&d,CS vvec<T>&v,int i,int j){\n  RT 0<=i&&i<size(v)&&0<=j&&j<size(v[i])?v[i][j]:d;\n}\n// TL<TN T,TN U,TN...I>IL T fetch(CS T&d,CS vec<vec<U>>&v,int i,I...j){\n// RT 0<=i&&i<size(v)?fetch(d,v[i],j...):d;\n// }\nTL<TN T>struct Compressed{int size;map<T,int>zip;vec<T>unzip;};\nTL<TN T>IL Compressed<T>compressed(vec<T>v){\n  sort_and_uniq(v);map<T,int>zip;times(size(v),i)zip[v[i]]=i;RT{size(v),zip,move(v)};\n}\nTL<TN T>struct CompressedSrc{int size;map<T,int>zip;vec<T>unzip;WI src;};\nTL<TN T>IL CompressedSrc<T>compressed_src(CS vec<T>&v){\n  auto c=compressed(v);VI src(c.size);times(size(v),i)src[c.zip[v[i]]].PB(i);RT{c.size,c.zip,c.unzip,src};\n}\n\nstruct identity{TL<TN U>U operator()(U&&v)CS{RT v;}};\n}\n/*? end \"util.hpp\" */\n/*? begin \"debug.hpp\" */\nTL<class T>\nIL istream&operator>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nTL<class T>\nIL ostream&operator<<(ostream&,CS vec<T>&);\nTL<class T,class S>\nIL ostream&operator<<(ostream&,CS map<T,S>&);\n#define DEFINE_ITER_OUTPUT(s,x,sep){int i=0;for(CS auto&x##0_elem:x){if(i++)s<<sep;s<<x##0_elem;}RT s;}\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<T>&v)DEFINE_ITER_OUTPUT(s,v,' ')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS map<T,S>&m)DEFINE_ITER_OUTPUT(s,m,' ')\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<vec<T>>&w)DEFINE_ITER_OUTPUT(s,w,'\\n')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS vec<map<T,S>>&v)DEFINE_ITER_OUTPUT(s,v,'\\n')\n/*? end \"debug.hpp\" */\n\nsigned main(){\n {if(debug)cerr<<\"MOD: \"<<(MOD)ln;}\n if(!debug)cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\n cout<<fixed<<setprecision(20);\n cerr<<fixed<<setprecision(20);\n\n #ifdef GCJ_CASE\n  int T;cin>>T;\n  times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n #else\n  solve();\n #endif\n\n return 0;\n}\n/*? end \"base.hpp\" */\n/*? begin \"graph.hpp\" */\n/*? begin \"uf.hpp\" */\nTL<class T=int,class Adder=plus<T>,class Inverser=negate<T>>\nclass UnionFind{\n/*!\nhttp://noshi91.hatenablog.com/entry/2018/05/30/191943\nhttps://en.wikipedia.org/wiki/Disjoint-set_data_structure\nhttps://qiita.com/drken/items/cce6fc5c579051e64fab\n*/\nint n,*parents,*sizes;T*pot_diffs;bool to_delete;Adder adder;\nInverser inverser;\npublic:\nexplicit UnionFind(int n,bool to_delete=false):\nn(n),parents(new int[n]),sizes(new int[n]),pot_diffs(new T[n]),to_delete(to_delete)\n{clear();\n}\nvoid clear(){\ntimes(n,i)parents[i]=i;/*roots*/\nfill(sizes,sizes+n,1);fill(pot_diffs,pot_diffs+n,0);\n}\n~UnionFind(){if(to_delete){delete[]parents;delete[]sizes;delete[]pot_diffs;}}\nint size(){RT n;}\nint root(int i){int p=parents[i];\nif(p==i)RT i;/*`i`is a root*/\nint r=root(p);/*and pot_diffs[p]:=diff from root*/\npot_diffs[i]+=pot_diffs[p];parents[i]=r;RT r;\n}\nbool is_same(int i,int j){RT root(i)==root(j);}\nbool is_all_same(){int r=root(0);uptil(1,n,i)if(root(i)!=r)RT 0;RT 1;}\nbool merge(int i,int j,T pdiff=0){i=root(i);j=root(j);\nif(i==j)RT false;/*already merged*/\nif(sizes[i]>sizes[j]){swap(i,j);pdiff=inverser(pdiff);\n}\n/*now sizes[i]<=sizes[j]*/\nparents[i]=j;sizes[j]+=sizes[i];pot_diffs[i]=pdiff;RT true;\n}\nT diff(int i,int j){\nroot(i);/*pot_diffs[i]:=diff from root*/\nroot(j);/*pot_diffs[j]:=diff from root*/\nRT adder(pot_diffs[i],inverser(pot_diffs[j]));}};using unionfind=UnionFind<>;\n/*? end \"uf.hpp\" */\nTL<class EdgeVal>\nstruct Edge{int from;int to;EdgeVal weight;\nEdge(int from,int to,EdgeVal weight):from(from),to(to),weight(weight){}\nIL bool OP==(CS Edge&e)CS{RT weight==e.weight&&from==e.from&&to==e.to;}\nIL bool OP<(CS Edge&e)CS{RT weight<e.weight||(weight==e.weight&&(from<e.from||(from==e.from&&to<e.to)));}\nIL bool OP<=(CS Edge&e)CS{RT this==e||this<e;}\nIL bool OP>(CS Edge&e)CS{RT e<this;}\nIL bool OP>=(CS Edge&e)CS{RT e<=this;}};\nTL<class VtxVal,class EdgeVal>\nclass Graph{\nusing VoidWithoutEdgeVal=TN enable_if<is_default_constructible<EdgeVal>::value,void>::type;\nprotected:\nint nv_,nde_;unionfind uf;\npublic:\nvec<VtxVal>vs;vvec<Edge<EdgeVal>>edges;\nGraph(int nv):nv_(nv),nde_(0),uf(nv),vs(nv),edges(nv){}\nIL int nv()CS{RT nv_;}\nIL int nde()CS{RT nde_;}\nIL int nue()CS{RT nde_/2;}\nIL void add_dedge(int i,int j,CS EdgeVal&val){\nif(debug&&(!rab::is_in(i,0LL,nv_)||!rab::is_in(j,0LL,nv_))){\ncerr<<\"invalid index:(\"<<i<<\",\"<<j<<\")for Graph(nv=\"<<nv_<<\")\" ln;\nexit(1);\n}\nedges[i].emplace_back(i,j,val);++nde_;\n}\nIL VoidWithoutEdgeVal add_dedge(int i,int j){add_dedge(i,j,EdgeVal());\n}\nIL void add_uedge(int i,int j,CS EdgeVal&val){add_dedge(i,j,val);\nadd_dedge(j,i,val);\n}\nIL VoidWithoutEdgeVal add_uedge(int i,int j){add_uedge(i,j,EdgeVal());\n}\nIL bool is_connected(){uf.clear();\nfor(CS auto&es:edges)for(CS auto&e:es)uf.merge(e.from,e.to);RT uf.is_all_same();\n}};\n/*? end \"graph.hpp\" */\n/*? begin \"flow.hpp\" */\n/*!Arihon,https://tubo28.me/algorithm/dinic/*/\nTL<TN F,TN V,TN E,TN CapFn=rab::identity>\nclass dinic{\npublic:\nstruct FlowEdge{CS int from,to,rev_idx;CS F cap;F flow;\nFlowEdge(int from,int to,F cap,F flow,int rev_idx):\nfrom(from),to(to),rev_idx(rev_idx),cap(cap),flow(flow){}};int n,s,t;\nVI level,prog,que;vvec<FlowEdge>edges;\ndinic(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),level(n),prog(n),que(n+1),edges(n)\n{times(n,i){for(auto&e:g.edges[i]){F c=capfn(e.weight);\nint zt=size(edges[e.to]),zi=size(edges[i]);edges[i].EB(i,e.to,c,(F)0,zt);\nedges[e.to].EB(e.to,i,c,c,zi);\n}}}\nF exec(int s,int t){this->s=s;this->t=t;F mf=0,inf=numeric_limits<F>::max()/8;\nwhile(update_level(),level[s]){fill(iter(prog),0);mf+=find_paths(s,inf);\n}\nRT mf;\n}\nvoid update_level(){int ql=0,qr=0;fill(iter(level),0);level[t]=n;\nque[qr++]=t;while(ql!=qr){int v=que[ql++];if(v==s)RT;\nfor(CS auto&e:edges[v]){if(!level[e.to]&&e.flow!=0){level[e.to]=level[v]-1;\nque[qr++]=e.to;\n}}}}\nF find_paths(int v,int limit){if(v==t)RT limit;F diff=0;\nfor(int ze=size(edges[v]),&i=prog[v];i<ze;++i){auto&e=edges[v][i];\nif(level[v]<level[e.to]&&e.cap!=e.flow){F df=find_paths(e.to,min(limit,e.cap-e.flow));\ne.flow+=df;edges[e.to][e.rev_idx].flow-=df;diff+=df;limit-=df;\nif(limit==0)break;\n}}\nRT diff;}};\n/*!Arihon,https://tubo28.me/algorithm/ford-fulkerson/*/\nTL<TN V,TN E,TN CapFn=rab::identity>\nstruct ford_fulkerson{int n,s,t;VC visited;\nWI edges;/*both direction*/\nprivate:\nHII cap_,flow_;\npublic:\nford_fulkerson(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),visited(n),edges(n)\n{times(n,i){for(auto&e:g.edges[i]){int c=capfn(e.weight);\ncap_[i<<32|e.to]+=c;cap_[e.to<<32|i]+=c;flow_[e.to<<32|i]+=c;edges[i].PB(e.to);\nedges[e.to].PB(i);\n}}}\nint cap(int a,int b){RT cap_[a<<32|b];}\nint flow(int a,int b){RT flow_[a<<32|b];}\nint exec(int s,int t){this->s=s;this->t=t;int mf=0;\nwhile(1){fill(iter(visited),false);int df=find_path(s,LLONG_MAX/8/*inf*/);if(df==0)RT mf;\nmf+=df;\n}}\nint find_path(int v,int limit){visited[v]=true;if(v==t)RT limit;\nfor(int d:edges[v]){if(!visited[d]){int c=cap_[v<<32|d],&f=flow_[v<<32|d];\nif(c-f>0){int df=find_path(d,min(limit,c-f));if(df>0){f+=df;flow_[d<<32|v]-=df;RT df;\n}}}}\nRT 0;}};\n/*? end \"flow.hpp\" */\nconstexpr int INF = 401;\n\nvoid solve() {\n// HWH(\"S\")\n/* <foxy.memo-area> */\nint H;int W;cin>>H;cin>>W;VS S(H);times(H,Ri_0){cin>>S[Ri_0];}\n/* </foxy.memo-area> */\n\n  Graph<unit, int> g(H * W * 2 + 2);\n\n  int s = H * W * 2, t = H * W * 2 + 1;\n\n  #define inp(i, j) (((i) * W + (j)) * 2)\n  #define outp(i, j) (((i) * W + (j)) * 2 + 1)\n\n  times(H, i) times(W, j) {\n    g.add_dedge(inp(i, j), outp(i, j), 1);\n\n    if(S[i][j] == 'X') {\n      g.add_dedge(s, outp(i, j), INF);\n\n      if(i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n        cout << -1 ln;\n        return;\n      }\n    }\n  }\n\n  times(H, i) {\n    g.add_dedge(outp(i, 0), t, INF);\n    g.add_dedge(outp(i, W-1), t, INF);\n\n    times(W-1, j) {\n      g.add_dedge(outp(i, j), inp(i, j + 1), INF);\n      g.add_dedge(outp(i, j + 1), inp(i, j), INF);\n    }\n  }\n  times(W, j) {\n    g.add_dedge(outp(0, j), t, INF);\n    g.add_dedge(outp(H-1, j), t, INF);\n\n    times(H-1, i) {\n      g.add_dedge(outp(i, j), inp(i + 1, j), INF);\n      g.add_dedge(outp(i + 1, j), inp(i, j), INF);\n    }\n  }\n\n  dinic<int, unit, int> d(g);\n  cout << d.exec(s, t) ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\n#define INF (1 << 29)\nusing namespace std;\n\nstruct point{\n    int x, y;\n};\n\nchar f[105][105] = {0};\nbool fb[105][105] = {0};\nint h, w;\nstatic const int dy[4] = {0,1,0,-1};\nstatic const int dx[4] = {1,0,-1,0};\n\nbool CanEscape(){\n    rep(i,h) if(f[i][0] == 'X' || f[i][w - 1] == 'X') return 1;\n    rep(i,w) if(f[0][i] == 'X' || f[h - 1][i] == 'X') return 1;\n    return 0;\n}\n\nvoid check(queue<point> &q){\n    rep(i,h){\n        rep(j,w){\n            if(f[i][j] == 'X'){\n                point p;\n                p.y = i; p.x = j;\n                q.push(p);\n                rep(k,4){\n                    int y = i + dy[k];\n                    int x = j + dx[k];\n                    if(y < 0 || y >= h || x < 0 || x >= w) continue;\n                    if(f[y][x] != 'X') fb[y][x] = 1;\n                }\n            }\n        }\n    }\n}\n\nbool goatCanEscape(int y, int x, bool fence[105][105]){\n    bool isVisited[105][105] = {0};\n    queue<point> q;\n    point start_coordinate;\n    start_coordinate.x = x;\n    start_coordinate.y = y;\n\n    isVisited[start_coordinate.y][start_coordinate.x] = 1;\n    q.push(start_coordinate);\n\n    point u;\n    while(!q.empty()){\n        u = q.front(); q.pop();\n        rep(i,4){\n            point next;\n            next.x = u.x + dx[i];\n            next.y = u.y + dy[i];\n            if(next.y < 0 || next.y >= h || next.x < 0 || next.x >= w) return 1;\n            if(isVisited[next.y][next.x] == 0 && fence[next.y][next.x] == 0){\n                isVisited[next.y][next.x] = 1;\n                q.push(next);\n            }\n        }\n    }\n    return 0;\n}\n\nbool allGoatNotEscape(int y, int x, queue<point> q, bool fence[105][105]){\n    while(not q.empty()){\n        if(goatCanEscape(q.front().y, q.front().x, fence)) return 0;\n        q.pop();\n    }\n    return 1;\n}\n\nvoid deleteUselessFence(queue<point> q, bool fence[105][105]){\n    rep(i,h){\n        rep(j,w){\n            if(fence[i][j] == 1){\n                fence[i][j] = 0;\n                if(not allGoatNotEscape(i, j, q, fence)){\n                    fence[i][j] = 1;\n                }\n            }\n        }\n    }\n}\n\nint oneSide(queue<point> q){\n    bool fence[105][105] = {0};\n    rep(i,h){\n        rep(j,w){\n            if(fb[i][j] == 1){\n                fence[i][j] = 1;\n                break;\n            }\n        }\n    }\n    rep(i,h){\n        for(int j = w - 1; j >= 0; j--){\n            if(fb[i][j] == 1){\n                fence[i][j] = 1;\n                break;\n            }\n        }\n    }\n    rep(i,w){\n        rep(j,h){\n            if(fb[j][i] == 1){\n                fence[j][i] = 1;\n                break;\n            }\n        }\n    }\n    rep(i,w){\n        for(int j = h - 1; j >= 0; j--){\n            if(fb[j][i] == 1){\n                fence[j][i] = 1;\n                break;\n            }\n        }\n    }\n    deleteUselessFence(q, fence);\n    int cnt = 0;\n    rep(i,h){\n        rep(j,w){\n            if(fence[i][j] == 1) cnt++;\n        }\n    }\n    return cnt;\n}\n\nint countFence(){\n    int cnt = 0;\n    rep(i,h){\n        rep(j,w){\n            if(fb[i][j] == 1) cnt++;\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    cin >> h >> w;\n    rep(i,h) cin >> f[i];\n    if(CanEscape()){\n        cout << -1 << endl;\n    }else{\n        cout << -1 << endl;\n        return 0;\n        queue<point> q;\n        check(q);\n        cout << oneSide(q) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<28\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int dy[4] = {-1, 0, 1, 0};\nconst int dx[4] = { 0, 1, 0,-1};\nchar field[102][102];\nint d[102][102];\nint H, W;\nbool bfs(char target, int sy, int sx){\n\tqueue<P> que;\n\trep (i, 102) rep (j, 102) d[i][j] = INF;\n\tque.push(P(sy,sx));\n\td[sy][sx] = 0;\n\t\n\twhile(!que.empty()){\n\t\tP curr = que.front(); que.pop();\n\t\tint cy = curr.first;\n\t\tint cx = curr.second;\n\n\t\tif (cy == 0 || cy == H+1 || cx == 0 || cx == W+1){\n\t\t\treturn true;\n\t\t} // end if\n\t\trep(k, 4){\n\t\t\tint ny = cy + dy[k];\n\t\t\tint nx = cx + dx[k];\n\t\t\tif (ny < 0 || ny > H + 1 || nx < 0 || nx > W + 1) continue;\n\t\t\tif (field[ny][nx] == '.' && d[ny][nx] == INF){\n\t\t\t\tque.push(P(ny,nx));\n\t\t\t\td[ny][nx] = d[cy][cx] + 1;\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end while\n\n\treturn false;\t\n}\n\n\nint main()\n{\n\tmemset (field, 0, sizeof(field));\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\trep (i, 102) rep (j, 102) field[i][j] = '.';\n\tcin >> H >> W;\n\tvector<string> s(H);\n\trep (i, H) cin >> s[i];\n\n\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tfield[i][j] = s[i-1][j-1];\n\t\t} // end for\n\t} // end for\n\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tif (field[i][j] == 'X'){\n\t\t\t\trep (k, 4){\n\t\t\t\t\tint ny = i + dy[k];\n\t\t\t\t\tint nx = j + dx[k];\n\t\t\t\t\tif (ny <= 0 || ny >= H + 1 || nx <= 0 || nx >= W + 1) continue;\n\t\t\t\t\tif (field[ny][nx] != '.') continue;\n\t\t\t\t\tfield[ny][nx] = 'O';\n\t\t\t\t} // end rep\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end rep\n\n\tbool escape = false;\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tif (field[i][j] == 'O'){\n\t\t\t\tbool curr = bfs(field[i][j], i, j);\n\t\t\t\tif (!curr) field[i][j] = '.';\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\tescape = false;\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tif (field[i][j] == 'X'){\n\t\t\t\tbool curr = bfs(field[i][j], i, j);\n\t\t\t\tif (curr) escape |= true;\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\tint res = 0;\n\tif (escape){\n\t\tres = -1;\n\t}else{\n\t\tfor (int i = 1; i <= H; ++i){\n\t\t\tfor (int j = 1; j <= W; ++j){\n\t\t\t\tres += (int)(field[i][j] == 'O');\n\t\t\t} // end for\n\t\t} // end for\n\t} // end if\n\tcout << res << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int vv[] = {-1, 0, 1, 0};\n\nvoid F()\n{\n  cout << -1 << endl;\n  exit(0);\n}\n\nint H, W;\nstring S[100];\nbool flag[100][100];\n\nint main()\n{\n  cin >> H >> W;\n  for(int i = 0; i < H; i++) {\n    cin >> S[i];\n  }\n\n  for(int i = 0; i < W; i++) {\n    if(S[0][i] == 'X') F();\n    if(S[H - 1][i] == 'X') F();\n  }\n  for(int i = 0; i < H; i++) {\n    if(S[i].front() == 'X') F();\n    if(S[i].back() == 'X') F();\n  }\n\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      if(S[i][j] == 'X') {\n        for(int k = 0; k < 4; k++) {\n          flag[i + vv[k]][j + vv[k ^ 1]] = true;\n        }\n      }\n    }\n  }\n\n\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; j++) {\n      if(S[i][j] == 'X') flag[i][j] = true;\n    }\n  }\n\n\n  int ret = 0;\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      if(S[i][j] == 'X') continue;\n\n      if(flag[i][j]) {\n        int res = 0;\n        for(int k = 0; k < 4; k++) {\n          int ni = i + vv[k], nj = j + vv[k ^ 1];\n          if(ni < 0 || ni >= H || nj < 0 || nj >= W) continue;\n          res += flag[ni][nj];\n        }\n        ret += res != 4;\n      }\n    }\n  }\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans-6<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<numeric>\n#include<functional>\n#include<algorithm>\n#include<bitset>\n#include<tuple>\n#include<unordered_set>\n#include<random>\n#include<array>\n#include<cassert>\nusing namespace std;\n#define INF (1<<29)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define uniq(v) v.erase(unique(all(v)),v.end())\n\n\n\n#define INF 1e+10\n#define EPS 1e-10\n#define EQ(a,b) (abs(a-b)<EPS)\n\n//誤差を考慮して足し算\ndouble add(double a, double b) {\n\tif (abs(a + b) < EPS*(abs(a) + abs(b)))return 0;\n\treturn a + b;\n}\nstruct P {//2次元ベクトル\n\tdouble x, y;\n\tP() {}\n\tP(double x, double y) :x(x), y(y) {}\n\tP operator + (P p) {\n\t\treturn P(add(x, p.x), add(y, p.y));\n\t}\n\tP operator - (P p) {\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\tP operator * (double d) {\n\t\treturn P(x*d, y*d);\n\t}\n\tP operator / (double d) {\n\t\treturn P(x / d, y / d);\n\t}\n\tdouble dot(P p) {//内積\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\tdouble det(P p) {//外積\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n\tbool equal(P p) {\n\t\treturn (x - p.x)*(x - p.x) + (y - p.y)*(y - p.y) < EPS*EPS;\n\t}\n\tdouble norm()const {\n\t\treturn sqrt(x*x + y*y);\n\t}\n};\n\n//凸包\nbool cmp_x(const P& p, const P& q) {\n\tif (p.x != q.x)return p.x<q.x;\n\treturn p.y<q.y;\n}\nvector<P> convex_hull(vector<P>& ps) {\n\tif (ps.empty())return ps;\n\tsort(ps.begin(), ps.end(), cmp_x);\n\tint k = 0;\n\tvector<P> qs(ps.size() * 2);\n\tfor (int i = 0; i<ps.size(); i++) {\n\t\twhile (k>1 && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0)k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tfor (int i = ps.size() - 2, t = k; i >= 0; i--) {\n\t\twhile (k>t && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0)k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\n\n\n\n\n\n\nbool on_seg(P p1, P p2, P q) {\n\treturn (p1 - q).det(p2 - q) == 0 && (p1 - q).dot(p2 - q) <= 0;\n}\nP intersection(P p1, P p2, P q1, P q2) {\n\treturn p1 + (p2 - p1)*((q2 - q1).det(q1 - p1) / (q2 - q1).det(p2 - p1));\n}\nbool is_intersect(P p1, P p2, P q1, P q2) {\n\tif (on_seg(p1, p2, q1) || on_seg(p1, p2, q2) || on_seg(q1, q2, p1) || on_seg(q1, q2, p2))return true;\n\tif ((p1 - p2).det(q1 - q2) == 0)return false;//平行\n\tP a = intersection(p1, p2, q1, q2);\n\treturn on_seg(p1, p2, a) && on_seg(q1, q2, a);\n}\ndouble dist(P p, P q) {\n\tp = p - q;\n\treturn sqrt(p.x*p.x + p.y*p.y);\n}\nP to_unit(P p) {\n\tdouble d = sqrt(p.x*p.x + p.y*p.y);\n\treturn p / d;\n}\ndouble dist_LP(P p1, P p2, P q) {\n\tdouble dx, dy;\n\tdx = p1.x - p2.x;\n\tdy = p1.y - p2.y;\n\tdouble d = min(dist(p1, q), dist(p2, q));\n\tpair<P, P> normal = make_pair(q + to_unit(P(-dy, dx))*d, q + to_unit(P(dy, -dx))*d);//法線ベクトル\n\tif (is_intersect(p1, p2, normal.first, normal.second)) {\n\t\treturn dist(q, intersection(p1, p2, normal.first, normal.second));\n\t}\n\treturn d;\n}\ndouble dist_LL(P p1, P p2, P q1, P q2) {\n\tif (is_intersect(p1, p2, q1, q2))return 0;\n\treturn min(min(dist_LP(p1, p2, q1), dist_LP(p1, p2, q2))\n\t\t, min(dist_LP(q1, q2, p1), dist_LP(q1, q2, p2)));\n}\nbool contains2(vector<P> &poly, P p, double inf = INF) {\n\tint cnt = 0;\n\tP q(p.x + inf, p.y);\n\tfor (int i = 0; i<poly.size(); i++) {\n\t\tif (is_intersect(poly[i], poly[(i + 1) % poly.size()], p, q))cnt++;\n\t}\n\treturn cnt & 1;\n}\n\n\n\n\n\n\nbool merge(vector<P> &a , vector<P> &b) {\n\tif (contains2(a, b.front()) || contains2(b, a.front())) return true;\n\trep(i,a.size()) {\n\t\trep(j,b.size()) {\n\t\t\tif (dist_LL(a[i], a[(i + 1) % a.size()], b[j], b[(j + 1) % b.size()]) <= 1 + EPS) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tvector<P> ps;\n\tint h, w;\n\tcin >> h >> w;\n\tvector<vector<P>> conv;\n\trep(y, h)rep(x, w) {\n\t\tchar c;\n\t\tcin >> c;\n\t\tif (c == 'X') {\n\t\t\tif (y == 0 || y + 1 == h || x == 0 || x + 1 == w) {\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tconv.push_back({ P(x, y) ,P(x, y + 1),P(x + 1, y) ,P(x + 1, y + 1) });\n\t\t}\n\t}\n\tbool change = true;\n\twhile (change) {\n\t\tchange = false;\n\t\tvector<vector<P>> nxt;\n\t\trep(i,conv.size()) {\n\t\t\tif (conv[i].empty())continue;\n\t\t\tfor (int j = i + 1; j < conv.size();j++) {\n\t\t\t\tif (conv[j].empty())continue;\n\t\t\t\tif (merge(conv[i],conv[j])) {\n\t\t\t\t\tfor (P p: conv[j]) {\n\t\t\t\t\t\tconv[i].push_back(p);\n\t\t\t\t\t}\n\t\t\t\t\tconv[j].clear();\n\t\t\t\t\tconv[i] = convex_hull(conv[i]);\n\t\t\t\t\tchange = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnxt.push_back(conv[i]);\n\t\t}\n\t\tconv.swap(nxt);\n\t}\n\tint ans = 0;\n\tfor (auto a : conv) {\n\t\trep(i, a.size()) {\n\t\t\tP s = a[i], t = a[(i + 1) % a.size()];\n\t\t\tans += max(fabs(s.y - t.y), fabs(s.x - t.x)) + EPS;\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\nint h, w;\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\nint a[100][101];\nint f[100][100];\nchar s[100][101];\n\nint dfs(int x, int y, int c) {\n    int i;\n    \n    f[x][y] = c;\n    \n    for (i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        \n        if (nx < 0 || nx >= h || ny < 0 || ny >= w) return 1;\n        \n        if (f[nx][ny] != c && a[nx][ny] == 0) {\n            if (dfs(nx, ny, c) == 1) return 1;\n        }\n    }\n    \n    return 0;\n}\n\nint main() {\n    int ans = 0, c = 1, i, j, k;\n    \n    scanf(\"%d %d\", &h, &w);\n    \n    for (i = 0; i < h; i++) scanf(\"%s\", s[i]);\n    \n    for (i = 0; i < h; i++) {\n        for (j = 0; j < w; j++) {\n            if (s[i][j] == 'X') {\n                for (k = 0; k < 4; k++) {\n                    int x = i + dx[k];\n                    int y = j + dy[k];\n                    \n                    if (x < 0 || x >= h || y < 0 || y >= w) {\n                        puts(\"-1\");\n                        \n                        return 0;\n                    }\n                    \n                    if (s[x][y] == '.') {\n                        if (a[x][y] == 0) ans++;\n                        \n                        a[x][y] = 1;\n                    }\n                }\n            }\n        }\n    }\n    \n    for (i = 0; i < h; i++) {\n        for (j = 0; j < w; j++) {\n            if (a[i][j] == 1) {\n                a[i][j] = 0;\n                \n                if (dfs(i, j, c++) == 0) {\n                    ans--;\n                } else {\n                    a[i][j] = 1;\n                }\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", ans);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <random>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\n\ntypedef\ntree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> orderedSet;\n\n#define pb push_back\n#define F first\n#define S second\n#define all(a) (a).begin(), (a).end()\n\n#define for1(i0, l0, r0) for (int i0 = l0; i0 < r0; ++i0)\n#define for2(i0, l0, r0) for (int i0 = l0; i0 <= r0; ++i0)\n#define forn(i0, n0) for (int i0 = 0; i0 < n0; ++i0)\n#define forn1(i0, n0) for (int i0 = 1; i0 < n0; ++i0)\n#define forr(i0, n0) for (int i0 = n0; i0 >= 0; --i0)\n#define forr1(i0, r0, l0) for (int i0 = r0; i0 > l0; --i0)\n#define forr2(i0, r0, l0) for (int i0 = r0; i0 >= l0; --i0)\n\n#define Sort(a) sort(all(a))\n#define Reverse(a) reverse(all(a))\n\ntypedef long double ld;\n#define ui unsigned int\n#define ull unsigned long long\n\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef pair<string, string> pss;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<ld> vld;\ntypedef vector<bool> vb;\ntypedef vector<string> vs;\n\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\n\ntypedef vector<vi> vvi;\ntypedef vector<vd> vvd;\ntypedef vector<vll> vvll;\ntypedef vector<vb> vvb;\n\n#define vpss vector<pss>\n#define vvs vector<vs>\n#define vvpii vector<vpii>\n#define vvpll vector<vpll>\n#define vpt vector<pt>\n#define vvvi vector<vvi>\n#define vsi vector<set<int>>\n#define ss second\n#define ff first\n\n#define printvi(arr) for (int x0 : arr) cout << x0 << ' '; cout << '\\n';\n#define printvll(arr) for (ll x0 : arr) cout << x0 << ' '; cout << '\\n';\n#define printpair(pair0) cout << pair0.F << ' ' << pair0.S << '\\n';\n#define printvp(arr) for (auto pair0 : arr) printpair(pair0);\n#define initArray(arr, N0, X0) memset(arr, X0, N0 * sizeof(int))\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid init() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    //cout.precision(16);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n}\n\nconst int inf = 1e9;\nconst int maxn = 20005;\nconst int N = 10000;\n\nstruct edge {\n    int t, c, r;\n};\n\nvector<edge> G[maxn];\nbool used[maxn];\n\nvoid add_edge(int v, int u, int c = 1) {\n    G[v].push_back((edge) {u, c, (int) G[u].size()});\n    G[u].push_back((edge) {v, 0, (int) G[v].size() - 1});\n}\n\nvoid connect(int v, int u, int c = 1) {\n    add_edge(v, u + N, c);\n    add_edge(u, v + N, c);\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (auto &it: G[v])\n        if (!used[it.t] && it.c) {\n            int d = dfs(it.t, t, min(f, it.c));\n            if (d) {\n                it.c -= d;\n                G[it.t][it.r].c += d;\n                return d;\n            }\n        }\n    return 0;\n}\n\nint maxFlow(int s, int t) {\n    int res = 0, f = 1;\n    while (f) {\n        fill(used, used + maxn, 0);\n        f = dfs(s, t, inf);\n        res += f;\n    }\n    return res;\n}\n\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    vs a(n);\n    forn(i, n) cin >> a[i];\n    forn(i, n) {\n        forn(j, m) {\n            if (i == 0 || j == 0 || i == n - 1 || j == m - 1) {\n                if (a[i][j] == 'X') {\n                    cout << \"-1\\n\";\n                    return;\n                }\n            }\n        }\n    }\n    int I = 2 * N, J = I + 1;\n    vi dx = {0, 0, 1, -1}, dy = {1, -1, 0, 0};\n    forn(i, n) {\n        forn(j, m) {\n            add_edge(i * m + j + N, i * m + j, (a[i][j] == 'X' ? inf : 1));\n            forn(k, 4){\n                int i1 = i + dx[k], j1 = j + dy[k];\n                if (i1 >= 0 && j1 >= 0 && i < n && j < m) connect(i * m + j, i1 * m + j1, inf);\n            }\n            if (a[i][j] == 'X') add_edge(I, i * m + j + N, inf);\n            if (i == 0 || j == 0 || i + 1 == n || j + 1 == m) add_edge(i * m + j, J, inf);\n        }\n    }\n    cout << maxFlow(I, J) << '\\n';\n}\n\nbool multitest = false;\n\nint main() {\n    init();\n    int t = 1;\n    if (multitest) cin >> t;\n    forn(i, t) solve();\n}"
  },
  {
    "language": "C++",
    "code": "// header {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n// {U}{INT,LONG,LLONG}_{MAX,MIN}\n#define ALPHABET    (26)\n#define INF         INT_MAX\n#define MOD         (1000000007LL)\n#define EPS         (1e-10)\n#define EQ(a, b)    (abs((a)-(b)) < EPS)\n\nusing P   = pair<int, int>;\nusing LL  = long long;\n// }}}\n\nint h, w;\nchar cmap[102][102];\nint di[] = {0, -1, 0, 1};\nint dj[] = {1, 0, -1, 0};\n\nvoid dfs(int i, int j) {\n    if(cmap[i][j] != '.') return;\n    cmap[i][j] = 'w';\n    for(int k=0;k<4;k++){\n        int ni = i+di[k];\n        int nj = j+dj[k];\n        if(0 <= ni && ni < h+2 && 0 <= nj && nj < w+2){\n            dfs(ni, nj);\n        }\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    cin >> h >> w;\n    for(int i=0;i<h+2;i++){\n        for(int j=0;j<h+2;j++){\n            cmap[i][j] = '.';\n        }\n    }\n    for(int i=0;i<h;i++){\n        string s;cin >> s;\n        for(int j=0;j<w;j++){\n            cmap[i+1][j+1] = s[j];\n            if(i == 0 || i == h-1 || j == 0 || j == w-1){\n                if(s[j] == 'X'){\n                    cout << -1 << endl;\n                    return 0;\n                }\n            }\n        }\n    }\n    for(int i=1;i<=h;i++){\n        for(int j=1;j<=w;j++){\n            if(cmap[i][j] == 'X'){\n                for(int k=0;k<4;k++){\n                    int ni = i+di[k];\n                    int nj = j+dj[k];\n                    if(cmap[ni][nj] == '.'){\n                        cmap[ni][nj] = '#';\n                    }\n                }\n            }\n        }\n    }\n    dfs(0, 0);\n    int ans = 0;\n    for(int i=1;i<=h;i++){\n        for(int j=1;j<=w;j++){\n            //cout << cmap[i][j];\n            if(cmap[i][j] == '#'){\n                for(int k=0;k<4;k++){\n                    int ni = i+di[k];\n                    int nj = j+dj[k];\n                    if(cmap[ni][nj] == 'w'){\n                        ans++;\n                        break;\n                    }\n                }\n            }\n        }\n        //cout << endl;\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define mem(a) memset(a,0,sizeof(a))\n#define pd(a) printf(\"%.10f\\n\",a)\n#define pb(a) push_back(a)\n#define in(a) insert(a)\n#define pi M_PI\n#define R cin>>\n#define F first\n#define S second\n#define C class\n#define ll long long\n#define ln cout<<'\\n'\ntemplate<C T>void pr(T a){cout<<a;ln;}\ntemplate<C T,C T2>void pr(T a,T2 b){cout<<a<<' '<<b;ln;}\ntemplate<C T,C T2,C T3>void pr(T a,T2 b,T3 c){cout<<a<<' '<<b<<' '<<c;ln;}\ntemplate<C T>void PR(T a,int n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\ntypedef complex<double> PP;\nbool cmp(PP a, PP b) {\n  double at=atan2(a.imag(),a.real()),at2=atan2(b.imag(),b.real());\n  return at!=at2?at<at2:max(abs(a.real()),abs(a.imag()))<max(abs(b.real()),abs(b.imag()));\n}\nvoid Main() {\n  int n,m;\n  cin >> n >> m;\n  string s[n];\n  rep(i,n) R s[i];\n  vector<int> v[n];\n  bool f=1;\n  rep(i,n) {\n    rep(j,m) {\n      if((!i||!j||i==n-1||j==m-1)&&s[i][j]=='X') {\n        pr(-1);\n        return;\n      }\n      if(s[i][j]=='X') {\n        v[i].push_back(j);\n        f=0;\n      }\n    }\n  }\n  if(f) {\n    pr(0);\n    return;\n  }\n  rep(i,n) sort(all(v[i]));\n  int ans=2;\n  P a=P(-1,-1);\n  rep(i,n) {\n    if(v[i].size()) {\n      a=P(i,v[i][0]);\n      break;\n    }\n  }\n  while(1) {\n    P p=P(-1,MAX);\n    REP(i,a.F+1,n) {\n      if(!v[i].size()) continue;\n      if(cmp(PP(i,v[i][0])-PP(a.F,a.S),PP(p.F,p.S)-PP(a.F,a.S))) p=P(i,v[i][0]);\n    }\n    if(p.F==-1) break;\n    ans+=max(abs(a.F-p.F),abs(a.S-p.S));\n    a=p;\n  }\n  a=P(-1,-1);\n  rep(i,n) {\n    if(v[i].size()) {\n      a=P(i,v[i][v[i].size()-1]);\n      break;\n    }\n  }\n  while(1) {\n    P p=P(-1,-1);\n    REP(i,a.F+1,n) {\n      if(!v[i].size()) continue;\n      if(cmp(PP(p.F,p.S)-PP(a.F,a.S),PP(i,v[i][v[i].size()-1])-PP(a.F,a.S))) p=P(i,v[i][v[i].size()-1]);\n    }\n    if(p.F==-1) break;\n    ans+=max(abs(a.F-p.F),abs(a.S-p.S));\n    a=p;\n  }\n  rep(i,n) {\n    if(v[i].size()) {\n      ans+=v[i][v[i].size()-1]-v[i][0]+1;\n      break;\n    }\n  }\n  rrep(i,n) {\n    if(v[i].size()) {\n      ans+=v[i][v[i].size()-1]-v[i][0]+1;\n      break;\n    }\n  }\n  pr(ans);\n}\n\nint main() {\n  ios::sync_with_stdio(0);cin.tie(0);\n  Main();return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//四則演算 #pragma GCC target(\"avx\")\n//並列計算 #pragma GCC optimize(\"O3\")\n//条件分岐を減らす #pragma GCC optimize(\"unroll-loops\")\n//浮動小数点演算 #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing VI = vector<int>;\nusing VL = vector<ll>;\nusing VS = vector<string>;\ntemplate<class T> using PQ = priority_queue<T, vector<T>, greater<T>>;\n#define FOR(i,a,n) for(int i=(a);i<(n);++i)\n#define eFOR(i,a,n) for(int i=(a);i<=(n);++i)\n#define rFOR(i,a,n) for(int i=(n)-1;i>=(a);--i)\n#define erFOR(i,a,n) for(int i=(n);i>=(a);--i)\n#define each(i, a) for(auto &i : a)\n#define SORT(a) sort(a.begin(),a.end())\n#define rSORT(a) sort(a.rbegin(),a.rend())\n#define fSORT(a,f) sort(a.begin(),a.end(),f)\n#define all(a) a.begin(),a.end()\n#define out(y,x) ((y)<0||h<=(y)||(x)<0||w<=(x))\n#define tp(a,i) get<i>(a)\n#define line cout << \"-----------------------------\\n\" \n#define ENDL(i,n) ((i) == (n) - 1 ? \"\\n\" : \" \")\n#define stop system(\"pause\")\nconstexpr ll INF = 1000000000;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr ll mod = 1000000007;\nconstexpr ll MOD = 998244353;\nconstexpr ld eps = 1e-10;\nconstexpr ld pi = 3.1415926535897932;\ntemplate<class T>inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T>inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; }return false; }\ninline void init() { cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); }\ntemplate<class T>inline istream& operator>>(istream& is, vector<T>& v) { for (auto& a : v)is >> a; return is; }\ntemplate<class T>inline istream& operator>>(istream& is, deque<T>& v) { for (auto& a : v)is >> a; return is; }\ntemplate<class T, class U>inline istream& operator>>(istream& is, pair<T, U>& p) { is >> p.first >> p.second; return is; }\ntemplate<class T>inline vector<T> vec(size_t a) { return vector<T>(a); }\ntemplate<class T>inline vector<T> defvec(T def, size_t a) { return vector<T>(a, def); }\ntemplate<class T, class... Ts>inline auto vec(size_t a, Ts... ts) { return vector<decltype(vec<T>(ts...))>(a, vec<T>(ts...)); }\ntemplate<class T, class... Ts>inline auto defvec(T def, size_t a, Ts... ts) { return vector<decltype(defvec<T>(def, ts...))>(a, defvec<T>(def, ts...)); }\ntemplate<class T>inline void print(const T& a) { cout << a << \"\\n\"; }\ntemplate<class T, class... Ts>inline void print(const T& a, const Ts&... ts) { cout << a << \" \"; print(ts...); }\ntemplate<class T>inline void print(const vector<T>& v) { for (int i = 0; i < v.size(); ++i)cout << v[i] << (i == v.size() - 1 ? \"\\n\" : \" \"); }\ntemplate<class T>inline void print(const vector<vector<T>>& v) { for (auto& a : v)print(a); }\ninline string reversed(const string& s) { string t = s; reverse(all(t)); return t; }\n\nint main() {\n    init();\n\n    int h, w; cin >> h >> w;\n    VS s(h); cin >> s;\n    \n    constexpr int dy[4] = { -1,0,0,1 }, dx[4] = { 0,-1,1,0 };\n    FOR(y, 0, h)FOR(x, 0, w) {\n        if (s[y][x] != 'X')continue;\n        FOR(i, 0, 4) {\n            int ny = y + dy[i], nx = x + dx[i];\n            if (out(ny, nx)) {\n                print(-1);\n                return 0;\n            }\n            if (s[ny][nx] != 'X')s[ny][nx] = 'O';\n        }\n    }\n\n    auto dp = defvec<int>(INF, h, w);\n    queue<pair<int, int>> bfs;\n    function<void(int, int)> bfs_init = [&](int y, int x)->void {\n        if (s[y][x] == '.') {\n            dp[y][x] = 0;\n            bfs.emplace(y, x);\n        }\n    };\n    FOR(y, 0, h)bfs_init(y, 0), bfs_init(y, w - 1);\n    FOR(x, 0, w)bfs_init(0, x), bfs_init(h - 1, x);\n    int ans = 0;\n    while (!bfs.empty()) {\n        int y, x;\n        tie(y, x) = bfs.front();\n        bfs.pop();\n        FOR(i, 0, 4) {\n            int ny = y + dy[i], nx = x + dx[i];\n            if (out(ny, nx))continue;\n            if (s[ny][nx] == 'O') {\n                if (dp[ny][nx] != -1) {\n                    dp[ny][nx] = -1;\n                    ++ans;\n                }\n                continue;\n            }\n            if (!chmin(dp[ny][nx], dp[y][x] + 1))continue;\n            bfs.emplace(ny, nx);\n        }\n    }\n\n    print(ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <type_traits>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <string>\n#include <limits>\n#include <iostream>\nnamespace lc {\ntemplate <class CapacityType>\nstruct EdgeWithCapacity {\n\tint to;\n\tCapacityType capacity;\n\tEdgeWithCapacity() : to(0), capacity() { }\n\tEdgeWithCapacity(int to, const CapacityType &capacity)\n\t\t: to(to), capacity(capacity)\n\t{ }\n};\n}\nnamespace lc {\ntemplate <typename EdgeType>\nclass AdjacencyList {\npublic:\n\ttypedef std::vector<EdgeType> ListType;\nprivate:\n\tstd::vector<ListType> m_lists;\npublic:\n\texplicit AdjacencyList(int n = 0)\n\t\t: m_lists(n)\n\t{ }\n\tint size() const { return m_lists.size(); }\n\ttemplate <typename... Args>\n\tvoid add_edge(int u, Args&&... args){\n\t\tm_lists[u].emplace_back(args...);\n\t}\n\tconst ListType &operator[](int u) const { return m_lists[u]; }\n\tListType &operator[](int u){ return m_lists[u]; }\n};\n}\nnamespace lc {\ntemplate <class EdgeType>\nstruct HasWeight {\nprivate:\n\tstatic std::false_type check(...);\npublic:\n\tstatic const bool value = decltype(check(EdgeType()))::value;\n};\n}\nnamespace lc {\ntemplate <class EdgeType>\nstruct ResidualEdge : public EdgeType {\n\tint rev;\n\ttemplate <class... Args>\n\tResidualEdge(int rev, Args&&... args)\n\t\t: EdgeType(args...)\n\t\t, rev(rev)\n\t{ }\n};\ntemplate <class EdgeType>\nclass ResidualAdjacencyList\n\t: public AdjacencyList<ResidualEdge<EdgeType>>\n{\npublic:\n\texplicit ResidualAdjacencyList(int n = 0)\n\t\t: AdjacencyList<ResidualEdge<EdgeType>>(n)\n\t{ }\n};\ntemplate <class EdgeType>\nauto make_residual(const AdjacencyList<EdgeType> &graph)\n\t-> typename std::enable_if<\n\t\t!HasWeight<EdgeType>::value, ResidualAdjacencyList<EdgeType>>::type\n{\n\ttypedef decltype(EdgeType().capacity) capacity_type;\n\tconst int n = graph.size();\n\tResidualAdjacencyList<EdgeType> result(n);\n\tfor(int u = 0; u < n; ++u){\n\t\tfor(const auto &e : graph[u]){\n\t\t\tconst int v = e.to;\n\t\t\tconst int rev_u = result[v].size();\n\t\t\tconst int rev_v = result[u].size();\n\t\t\tresult[u].emplace_back(rev_u, e);\n\t\t\tresult[v].emplace_back(rev_v, e);\n\t\t\tresult[v].back().to = u;\n\t\t\tresult[v].back().capacity = capacity_type();\n\t\t}\n\t}\n\treturn result;\n}\n}\nnamespace lc {\ntemplate <class EdgeType>\nauto maxflow_dinic(\n\tint source, int sink, ResidualAdjacencyList<EdgeType> &graph)\n\t-> decltype(EdgeType().capacity)\n{\n\ttypedef decltype(EdgeType().capacity) capacity_type;\n\tconst capacity_type inf = std::numeric_limits<capacity_type>::max();\n\tconst int n = graph.size();\n\tcapacity_type flow = 0;\n\twhile(true){\n\t\tstd::vector<int> level(n, -1);\n\t\tstd::queue<int> q;\n\t\tlevel[source] = 0;\n\t\tq.push(source);\n\t\twhile(!q.empty()){\n\t\t\tconst int u = q.front();\n\t\t\tq.pop();\n\t\t\tfor(const auto &e : graph[u]){\n\t\t\t\tconst int v = e.to;\n\t\t\t\tif(e.capacity <= 0 || level[v] >= 0){ continue; }\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t\tif(level[sink] < 0){ break; }\n\t\tstd::vector<size_t> iteration(n, 0);\n\t\twhile(true){\n\t\t\tstd::function<capacity_type(int, capacity_type)> dfs =\n\t\t\t\t[&](int u, capacity_type limit) -> capacity_type {\n\t\t\t\t\tif(u == sink){ return limit; }\n\t\t\t\t\tfor(; iteration[u] < graph[u].size(); ++iteration[u]){\n\t\t\t\t\t\tauto &e = graph[u][iteration[u]];\n\t\t\t\t\t\tconst int v = e.to;\n\t\t\t\t\t\tif(e.capacity <= 0 || level[u] >= level[v]){ continue; }\n\t\t\t\t\t\tconst capacity_type diff =\n\t\t\t\t\t\t\tdfs(v, std::min(e.capacity, limit));\n\t\t\t\t\t\tif(diff > 0){\n\t\t\t\t\t\t\te.capacity -= diff;\n\t\t\t\t\t\t\tgraph[v][e.rev].capacity += diff;\n\t\t\t\t\t\t\treturn diff;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t};\n\t\t\tconst auto f = dfs(source, inf);\n\t\t\tif(f <= 0){ break; }\n\t\t\tflow += f;\n\t\t}\n\t}\n\treturn flow;\n}\n}\nusing namespace std;\nusing Edge = lc::EdgeWithCapacity<int>;\nconst int INF = 1000000000;\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, m;\n\tcin >> n >> m;\n\tvector<string> field(n);\n\tfor(int i = 0; i < n; ++i){ cin >> field[i]; }\n\tfor(int j = 0; j < m; ++j){\n\t\tif(field[0][j] == 'X' || field[n - 1][j] == 'X'){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = 0; i < n; ++i){\n\t\tif(field[i][0] == 'X' || field[i][m - 1] == 'X'){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tconst int source = 2 * n * m, sink = source + 1;\n\tlc::AdjacencyList<Edge> graph(2 * n * m + 2);\n\tfor(int i = 1; i < n; ++i){\n\t\tfor(int j = 1; j < m; ++j){\n\t\t\tconst int x = (i - 1) * m + j;\n\t\t\tconst int y = i * m + (j - 1);\n\t\t\tconst int z = i * m + j;\n\t\t\tgraph.add_edge(x + n * m, z, INF);\n\t\t\tgraph.add_edge(z + n * m, x, INF);\n\t\t\tgraph.add_edge(y + n * m, z, INF);\n\t\t\tgraph.add_edge(z + n * m, y, INF);\n\t\t}\n\t}\n\tfor(int i = 0; i < n; ++i){\n\t\tfor(int j = 0; j < m; ++j){\n\t\t\tconst int x = i * m + j;\n\t\t\tgraph.add_edge(x, x + n * m, 1);\n\t\t\tif(i == 0 || i == n - 1 || j == 0 || j == m - 1){\n\t\t\t\tgraph.add_edge(x + n * m, sink, INF);\n\t\t\t}\n\t\t\tif(field[i][j] == 'X'){\n\t\t\t\tgraph.add_edge(source, x + n * m, INF);\n\t\t\t}\n\t\t}\n\t}\n\tauto residual = lc::make_residual(graph);\n\tcout << lc::maxflow_dinic(source, sink, residual) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MAX = 4e4;\nconst int OO = 0x3f3f3f3f3f3f3f3f;\nint SOURCE, SINK;\n\nstruct edge\n{\n    int v, f, c;\n    edge(){}\n    edge(int _v, int _f, int _c)\n    {\n        v = _v, f = _f, c = _c;\n    }\n};\n\nvector<edge> edges;\nvector<int> G[MAX];\nint dist[MAX], work[MAX];\n\nvoid add_edge(int u, int v, int cp, int rc){\n\tedges.push_back(edge(v, 0, cp));\n\tG[u].push_back(edges.size()-1);\n\tedges.push_back(edge(u, 0, rc));\n\tG[v].push_back(edges.size()-1);\n}\n\nbool bfs(int s, int t)\n{\n    memset(dist, -1, sizeof(dist));\n    dist[s] = 0;\n    queue<int> q;\n    q.push(s);\n    while(!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        for(int e : G[u])\n            if(dist[edges[e].v] == -1 and edges[e].c-edges[e].f > 0)\n            {\n                q.push(edges[e].v);\n                dist[edges[e].v] = dist[u] + 1;\n            }\n    }\n    return dist[t] != -1;\n}\n\nint dfs(int s, int t, int f)\n{\n    if(s == t) return f;\n    for(int &i = work[s]; i < G[s].size(); i++)\n    {\n    \tint e = G[s][i];\n        if(dist[edges[e].v] == dist[s] + 1 and edges[e].c-edges[e].f > 0)\n            if(int a = dfs(edges[e].v, t, min(f, edges[e].c-edges[e].f)))\n            {\n                edges[e].f += a;\n                edges[e^1].f -= a;\n                return a;\n            }\n    }\n    return 0;\n}\n\nint MaxFlow(int s, int t)\n{\n    int mf = 0;\n    while(bfs(s, t))\n\t{\n    \tmemset(work, 0, sizeof(work));\n        while(int a = dfs(s, t, OO))\n            mf += a;\n    }\n    return mf;\n}\n\nint n, m, a, b;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nbool check(int x, int y)\n{\n\treturn x >= 0 and x < n and y >= 0 and y < m;\n}\n\nint vertexIn(int i, int j)\n{\n\treturn i * m + j;\n}\n\nint vertexOut(int i, int j)\n{\n\treturn i * m + j + n * m + 1;\n}\n\nint32_t main()\n{\n \tcin >> n >> m;\n \tSOURCE = 2 * n * m + 2;\n \tSINK = 2 * n * m + 3;\n \tfor(int i = 0; i < n; i++)\n \t\tfor(int j = 0; j < m; j++)\n \t\t{\n \t\t\tchar c;\n \t\t\tcin >> c;\n \t\t\tint cost = 1;\n \t\t\tif(c == 'X') cost = OO;\n \t\t\tadd_edge(vertexIn(i, j), vertexOut(i, j), cost, 0);\n \t\t\tif(cost == OO) add_edge(vertexOut(i, j), SINK, OO, 0);\n \t\t\tfor(int k = 0; k < 4; k++)\n \t\t\t{\n\t\t\t\tint x = i + dx[k], y = j + dy[k];\n\t\t\t\tif(check(x, y))\n \t\t\t\t\tadd_edge(vertexOut(i, j), vertexIn(x, y), OO, 0);\n \t\t\t}\n \t\t\tif(!i or !j or i == n - 1 or j == m - 1)\n \t\t\t\tadd_edge(SOURCE, vertexIn(i, j), OO, 0);\n \t\t}\t\n\tint ans = MaxFlow(SOURCE, SINK);\n\tif(ans >= 5 * n * m) ans = -1;\n \tcout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define min(a, b) ((a)>(b)?(b):(a))\n\nconst int inf = 1e5;\nconst int MAXN = 105;\n\nconst int sz = 2 * MAXN*MAXN;\n\nstruct MaxFlow {\n\tstruct Edge {\n\t\tint vertex;\n\t\tint inverse;\n\t\tint residual;\n\t\tEdge() {}\n\t\tEdge(int v, int i, int r) : vertex(v), inverse(i), residual(r) {}\n\t};\n\tint n;\n\tEdge g[sz][15]; int gn[sz];\n\tvoid init(int _n) {\n\t\tn = _n;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tgn[i] = 0;\n\t\t}\n\t}\n\tvoid add_edge(int s, int e, int cap) {\n\t\tEdge forward = Edge(e, gn[e], cap);\n\t\tEdge reverse = Edge(s, gn[s], 0);\n\t\tg[s][gn[s]++] = forward;\n\t\tg[e][gn[e]++] = reverse;\n\t}\n\tbool vis[sz];\n\tint Q[sz], fr, re, curf[sz], par[sz], paridx[sz];\n\tint bfs(int s, int e) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tvis[i] = 0;\n\t\t\tcurf[i] = 0;\n\t\t\tpar[i] = paridx[i] = 0;\n\t\t}\n\t\tQ[fr = re = 0] = s; vis[s] = 1;\n\t\tcurf[s] = inf;\n\t\twhile (fr <= re) {\n\t\t\tint x = Q[fr++];\n\t\t\tfor (int i = 0; i < gn[x]; i++) {\n\t\t\t\tint y = g[x][i].vertex;\n\t\t\t\tint f = g[x][i].residual;\n\t\t\t\tif (f > 0 && !vis[y]) {\n\t\t\t\t\tvis[y] = 1;\n\t\t\t\t\tpar[y] = x; paridx[y] = i;\n\t\t\t\t\tcurf[y] = min(curf[x], f);\n\t\t\t\t\tQ[++re] = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!vis[e]) return 0;\n\t\tint flow = curf[e];\n\t\tint p = e;\n\t\twhile (p != s) {\n\t\t\tint q = par[p], qi = paridx[p];\n\t\t\tint pi = g[q][qi].inverse;\n\t\t\tg[q][qi].residual -= flow;\n\t\t\tg[p][pi].residual += flow;\n\t\t\tp = q;\n\t\t}\n\t\treturn flow;\n\t}\n\tint solve(int s, int e) {\n\t\tint flow = 0, cur = 0;\n\t\twhile (cur = bfs(s, e), cur > 0) {\n\t\t\tflow += cur;\n\t\t}\n\t\treturn flow;\n\t}\n};\n\nint N, M;\nchar S[MAXN][MAXN];\nint in[MAXN][MAXN], out[MAXN][MAXN];\nint source, sink, v;\n\nint px[4] = { 1,-1,0,0 };\nint py[4] = { 0,0,1,-1 };\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int i = 1; i <= N; i++) {\n\t\tscanf(\"%s\", S[i] + 1);\n\t}\n\tsource = 0;\n\tsink = N * M * 2 + 1;\n\tv = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= M; j++) {\n\t\t\tin[i][j] = ++v;\n\t\t\tout[i][j] = ++v;\n\t\t}\n\t}\n\tMaxFlow f;\n\tf.init(2 * N*M + 2);\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= M; j++) {\n\t\t\tif (S[i][j] == 'X') {\n\t\t\t\tif (i == 1 || i == N || j == 1 || j == M) {\n\t\t\t\t\tf.add_edge(source, in[i][j], inf);\n\t\t\t\t}\n\t\t\t\tf.add_edge(in[i][j], out[i][j], inf);\n\t\t\t\tf.add_edge(out[i][j], sink, inf);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (i == 1 || i == N || j == 1 || j == M) {\n\t\t\t\t\tf.add_edge(source, in[i][j], 1);\n\t\t\t\t}\n\t\t\t\tf.add_edge(in[i][j], out[i][j], 1);\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint x = i + px[k];\n\t\t\t\t\tint y = j + py[k];\n\t\t\t\t\tif (1 <= x && x <= N && 1 <= y && y <= M) {\n\t\t\t\t\t\tf.add_edge(out[i][j], in[x][y], inf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint flow = f.solve(source, sink);\n\tif (flow >= inf) puts(\"-1\");\n\telse printf(\"%d\\n\", flow);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define for(i, a, b) for(ll (i)=a;(i)<(b);++(i))\n#define rep(i, n)    for(i, 0, n)\n#define MAX_V        20004\n\nconst ll inf = 1e15;\nconst ll mod = 1e9+7;\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nstruct edge {\n    ll to, cap, rev;\n    edge(ll t, ll c, ll r): to(t), cap(c), rev(r){}\n};\n\nvector<edge> G[20004];\nbool used[20004];\n\nvoid add_edge(ll from, ll to, ll cap) {\n    G[from].push_back(edge(to, cap, G[to].size()));\n    G[to].push_back(edge(from, 0, G[from].size() - 1));\n}\n\nll dfs(ll v, ll t, ll f) {\n    if (v == t) return f;\n    used[v] = true;\n    rep(i, G[v].size()) {\n        edge &e = G[v][i];\n        if (!used[e.to] && e.cap > 0) {\n            ll d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nll max_flow(ll s, ll t) {\n    ll flow = 0;\n    while (true) {\n        memset(used, 0, sizeof(used));\n        ll f =  dfs(s, t, inf);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nchar field[101][101];\nint main() {\n    ll H, W; cin >> H >> W;\n    rep(i, H) rep(j, W) {\n        cin >> field[i][j];\n        if (field[i][j] == 'X' && (i == 0 || i == H-1 || j == 0 || j == W-1)) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n    \n    ll S = 2 * H * W;\n    ll T = 2 * H * W + 1;\n    rep(i, H) rep(j, W) {\n        if (field[i][j] == 'X') add_edge(S, i * W + j, inf);\n        if (i == 0 || i == H-1 || j == 0 || j == W-1) add_edge(H * W + i * W + j, T, inf);\n        \n        add_edge(i * W + j, H * W + i * W + j, field[i][j] == 'X' ? inf : 1);\n        rep(k, 4) {\n            if (i+dy[k] < 0 || H-1 < i+dy[k] || j+dx[k] < 0 || W-1 < j+dx[k]) continue;\n            add_edge(H * W + i * W + j, (i+dy[k]) * W + (j+dx[k]), inf);\n        }\n    }\n    cout << max_flow(S, T) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nstatic const double EPS = 1e-8;\nstatic const double PI = 4.0 * atan(1.0);\nbool ISINT(double x){return fabs(x-(int)round(x))<EPS;}\nbool ISEQ(double x,double y){return fabs(x-y)<EPS;}\nstring itos(ll x){stringstream ss;ss<<x;return ss.str();}\n#define foreach(itr,c) for(__typeof(c.begin()) itr=c.begin();itr!=c.end();itr++)\n\nint h, w;\n\n// '.' : 何もない\n// 'X' : ヤギ(上書きしない)\n// 'O' : 一時的に置く柵(最終的に残っている場合は、削除してよい)\n// 'U' : 必ず必要な柵\n// '-' : 探索済み\nchar t[102][102];\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nvoid dfs(int x, int y) {\n  if (t[y][x] == 'O') {\n    t[y][x] = 'U';\n    return;\n  }\n  if (t[y][x] == 'U') {\n    return;\n  }\n  if (t[y][x] == 'X') {\n    // 絶対に来てはいけない\n    while (true) {}\n    return;\n  }\n\n  t[y][x] = '-';\n\n  for (int i = 0; i < 4; i++) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n\n    if (nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n    if (t[ny][nx] == '-') continue;\n\n    dfs(nx, ny);\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  while (cin >> h >> w) {\n    for (int i = 0; i < h; i++) {\n      cin >> t[i];\n    }\n\n    bool ngFlg = false;\n\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if (t[i][j] != 'X') continue;\n\n        for (int k = 0; k < 4; k++) {\n          int nx = j + dx[k];\n          int ny = i + dy[k];\n\n          if (nx < 0 || w <= nx || ny < 0 || h <= ny) {\n            ngFlg = true;\n            break;\n          }\n\n          if (t[ny][nx] == 'X') continue;\n\n          t[ny][nx] = 'O';\n        }\n      }\n    }\n\n    if (ngFlg) {\n      cout << -1 << endl;\n      continue;\n    }\n\n    // 外から到達できる場所を塗りつぶし\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if (0 < i && i < h - 1 &&\n            0 < j && j < w - 1) continue;\n        dfs(j, i);\n      }\n    }\n\n    /*\n    for (int i = 0; i < h; i++) {\n      cout << t[i] << endl;\n    }\n    */\n\n    int ans = 0;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if (t[i][j] == 'U') {\n          ans++;\n        }\n      }\n    }\n    \n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint ban1[105][105];\nint ban2[105][105];\nint H, W;\n\nbool valid(int y, int x){\n\treturn ( y>=0 && y < H) && (x>=0 && x < W);\n}\n\nint main(){\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++){\n\t\tstring S;\n\t\tcin >> S;\n\t\tfor(int j = 0; j < S.size(); j++){\n\t\t\tif(S[j] == '.'){\n\t\t\t\tban1[i][j] = 0;\n\t\t\t}else{\n\t\t\t\tban1[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tif(ban1[i][j] == 1){\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tif(valid(i + dy[k], j + dx[k]) == false){\n\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(ban1[i + dy[k]][j + dx[k]] == 0){\n\t\t\t\t\t\tban1[i + dy[k]][j + dx[k]] = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tif(ban1[i][j] == 2){\n\t\t\t\tbool flag = false;\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tif(ban1[i + dy[k]][j + dx[k]] == 0){\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\tans++;\n\t\t\t\t\tban2[i][j] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tif(ban1[i][j] == 0){\n\t\t\t\tcout << '.';\n\t\t\t}else if(ban1[i][j] == 1){\n\t\t\t\tcout << 'X';\n\t\t\t}else{\n\t\t\t\tcout << '#';\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\t//cout << endl;\n\t}\n\tcout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 105\n#define M 51\n#define INF 1000000007\n#define MOD 924844033\n#define MOD2 1000000009\n#define eps 1e-14\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,1,-1};\nstruct node\n{\n    int from,to,x,y;\n}edge[60*N*N];\nvector<int>e[60*N*N];\nint a[N][N],b[N][N],q[N*N],d[N*N];\nchar s[N];\nint bg,ed,cnt;\n\nbool bfs(int s)\n{\n       int front=0,rear=0;\n       memset(d,-1,sizeof(d));\n       q[rear++]=s;\n       d[s]=0;\n       while(front<rear)\n       {\n               int k=q[front++];\n               for(int i = 0;i<e[k].size();i++)\n               {\n                   int v = e[k][i];\n                   int from = edge[v].from,to = edge[v].to;\n                   int x = edge[v].x,y = edge[v].y;\n                   int flow,nxt;\n                   if(from == k)flow = x,nxt = to;\n                   else flow = y,nxt = from;\n                   if(flow>0&&d[nxt]==-1)\n                   {\n                       d[nxt]=d[k]+1;\n                       q[rear++]=nxt;\n                   }\n               }\n       }\n       if(d[ed]>=0)\n             return true;\n       return false;\n}\n\nint dinic(int k,int sum)  //k is the sourse\n{\n      if (k==ed)\n          return sum;\n      int os = sum;\n      for(int i = 0;i<e[k].size();i++)\n      {\n          if(sum<=0)break;\n          int v = e[k][i];\n          int from = edge[v].from,to = edge[v].to;\n           int x = edge[v].x,y = edge[v].y;\n           int flow,nxt;\n           if(from == k)flow = x,nxt = to;\n           else flow = y,nxt = from;\n          if(d[to]==d[k]+1&&flow>0)\n          {\n                int tmp = dinic(to,min(sum,flow)); //Deep to the end.\n                if(from == k)\n                {\n                    edge[v].x -= tmp;\n                    edge[v].y += tmp;\n                }\n                else\n                {\n                    edge[v].y -= tmp;\n                    edge[v].x += tmp;\n                }\n                sum -= tmp;\n          }\n      }\n      return os-sum;\n}\n\nvoid addedge(int from,int to,int w)\n{\n    edge[++cnt].from = from;\n    edge[cnt].to = to;\n    edge[cnt].x = w;\n    edge[cnt].y = 0;\n    e[from].PB(cnt);\n    e[to].PB(cnt);\n}\nint main()\n{\n    //freopen(\"out.txt\",\"r\",stdin);\n   // freopen(\"1.txt\",\"w\",stdout);\n    //cin.tie(0);\n    //ios::sync_with_stdio(false);\n    int n,m;\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n        cnt = 0;\n        bg = 1,ed = n*m*2+1;\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                a[i][j] = i*m+j;\n                b[i][j] = i*m+j+n*m;\n            }\n        }\n        FOR(i,1,n)\n        {\n            scanf(\"%s\",s);\n            FOR(j,1,m)\n            {\n                if(s[j-1] == 'X')\n                {\n                    addedge(a[i][j],b[i][j],INF);\n                    addedge(1,a[i][j],INF);\n                }\n                else addedge(a[i][j],b[i][j],1);\n            }\n        }\n        FOR(i,1,n)\n        {\n            addedge(b[i][1],ed,INF);\n            addedge(b[i][m],ed,INF);\n            FOR(j,1,m-1)addedge(b[i][j],a[i][j+1],INF);;\n            FOR(j,2,m)addedge(b[i][j],a[i][j-1],INF);\n        }\n        FOR(j,1,m)\n        {\n            addedge(b[1][j],ed,INF);\n            addedge(b[n][j],ed,INF);\n            FOR(i,1,n-1)addedge(b[i][j],a[i+1][j],INF);\n            FOR(i,2,n)addedge(b[i][j],a[i-1][j],INF);\n        }\n        int ret = 0;\n        while(bfs(bg))\n        {\n            ret += dinic(bg,INF);\n            if(ret>=INF)break;\n        }\n\n\n        if(ret >= INF)printf(\"-1\\n\");\n        else printf(\"%d\\n\",ret);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n\nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n\nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n\ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size())mk();\n\t\tif(hit==q.size()<<1)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n\nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,4){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==4){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,4){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==4){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<fr[i][j];\n//\t\tcout<<endl;\n//\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing PII = pair<ll, ll>;\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\ntemplate<typename T> void chmin(T &a, const T &b) { a = min(a, b); }\ntemplate<typename T> void chmax(T &a, const T &b) { a = max(a, b); }\nstruct FastIO {FastIO() { cin.tie(0); ios::sync_with_stdio(0); }}fastiofastio;\n#ifdef DEBUG_ \n#include \"../program_contest_library/memo/dump.hpp\"\n#else\n#define dump(...)\n#endif\nconst ll INF = 1LL<<60;\n\nstruct dinic {\n    struct edge{\n        int to;\n        ll cap;\n        int rev;\n        bool isrev;\n    };\n\n    vector<vector<edge>> G;\n    vector<int> level, iter;\n\n    void bfs(int s) {\n        level.assign(G.size(), -1);\n        queue<int> que;\n        level[s] = 0;\n        que.push(s);\n        while(que.size()) {\n            int v = que.front(); que.pop();\n            for(auto i: G[v]) {\n                if(i.cap > 0 && level[i.to] < 0) {\n                    level[i.to] = level[v] + 1;\n                    que.push(i.to);\n                }\n            }\n        }\n    }\n\n    ll dfs(int v, const int t, ll f) {\n        if(v == t) return f;\n        for(int &i = iter[v]; i<(ll)G[v].size(); ++i) {\n            edge &e = G[v][i];\n            if(e.cap > 0 && level[v] < level[e.to]) {\n                ll d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    dinic() {}\n    dinic(int n) : G(n), level(n), iter(n) {}\n\n    void add_edge(int from, int to, ll cap) {\n        G[from].push_back({to, cap, (int)G[to].size(), false});\n        G[to].push_back({from, 0, (int)G[from].size()-1, true});\n    }\n\n    ll max_flow(int s, int t) {\n        ll flow = 0;\n        while(1) {\n            bfs(s);\n            if(level[t] < 0) return flow;\n            iter.assign(G.size(), 0);\n            ll f;\n            while((f = dfs(s, t, INF)) > 0) flow += f;\n        }\n    }\n\n    friend ostream &operator <<(ostream& out, const dinic& a){\n        out << endl;\n        for(int i = 0; i < (int)a.G.size(); i++) {\n            for(auto &e : a.G[i]) {\n                if(e.isrev) continue;\n                auto &rev_e = a.G[e.to][e.rev];\n                if(rev_e.cap == 0) continue;\n                out << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << e.cap + rev_e.cap << \")\" << endl;\n            }\n        }\n        return out;\n    }\n};\n\nint main(void) {\n    ll h, w;\n    cin >> h >> w;\n    vector<string> s(h);\n    REP(i, h) cin >> s[i];\n\n    REP(y, h) {\n        if(s[y][0]=='X' || s[y][w-1]=='X') {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n    REP(x, w) {\n        if(s[0][x]=='X' || s[h-1][x]=='X') {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    dinic flow(2*h*w+2);\n    ll S = 2*h*w, T = 2*h*w+1;\n\n    ll dx[] = {1, -1, 0, 0}, dy[] = {0, 0, 1, -1};\n    REP(x, w) REP(y, h) {\n        if(s[y][x]=='X') flow.add_edge((x*h+y)*2, (x*h+y)*2+1, INF);\n        else flow.add_edge((x*h+y)*2, (x*h+y)*2+1, 1);\n        REP(i, 4) {\n            ll nx = x + dx[i], ny = y + dy[i];\n            if(nx<0 || nx>=w || ny<0 || ny>=h) continue;\n            ll va = (x*h + y)*2 + 1;\n            ll vb = (nx*h + ny)*2;\n            flow.add_edge(va, vb, INF);\n        }\n    }\n    REP(y, h) REP(x, w) {\n        if(s[y][x]=='.') continue;\n        ll va = (x*h + y)*2;\n        flow.add_edge(S, va, INF);\n    }\n    REP(x, w) {\n        ll v = (x*h)*2+1;\n        flow.add_edge(v, T, INF);\n        v = (x*h + h-1)*2+1;\n        flow.add_edge(v, T, INF);\n    }\n    REP(y, h) {\n        ll v = (0*h + y)*2+1;\n        flow.add_edge(v, T, INF);\n        v = ((w-1)*h + y)*2+1;\n        flow.add_edge(v, T, INF);\n    }\n\n    cout << flow.max_flow(S, T) << endl;\n    dump(flow);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXH = 111;\nstring S[MAXH];\nbool need[MAXH][MAXH];\nbool memo[MAXH][MAXH];\n\nvoid debug(int H, int W) {\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cout << need[i][j];\n        }\n        cout << endl;\n    }\n}\n\nvoid no() {\n    cout << -1 << endl;\n    exit(0);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int H, W;\n    cin >> H >> W;\n    for (int i = 0; i < H; i++)\n        cin >> S[i];\n    for (int i = 0; i < W; i++) {\n        if (S[0][i] == 'X' || S[H-1][i] == 'X') no();\n    }\n    for (int i = 0; i < H; i++) {\n        if (S[i][0] == 'X' || S[i][W-1] == 'X') no();\n    }\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (S[i][j] == 'X') {\n                for (int k = 0; k < 4; k++)\n                    need[i+dy[k]][j+dx[k]] = true;\n            }\n        }\n    }\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (need[i][j]) {\n                queue<pii> que;\n                memset(memo, false, sizeof(memo));\n                que.push(pii(i, j));\n                while (!que.empty()) {\n                    auto p = que.front(); que.pop();\n                    int y = p.first, x = p.second;\n                    for (int k = 0; k < 4; k++) {\n                        int ny = y+dy[k], nx = x+dx[k];\n                        if (ny < 0 || ny >= H || nx < 0 || nx >= W) continue;\n                        if (memo[ny][nx]) continue;\n                        if (need[ny][nx]) continue;\n                        memo[ny][nx] = true;\n                        que.push(pii(ny, nx));\n                    }\n                }\n                bool ng = true;\n                for (int y = 0; y < H; y++) {\n                    if (memo[y][0] || memo[y][W-1]) ng = false;\n                }\n                for (int x = 0; x < W; x++) {\n                    if (memo[0][x] || memo[H-1][x]) ng = false;\n                }\n                if (ng) {\n                    need[i][j] = false;\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    for (int i = 0; i < H; i++)\n        for (int j = 0; j < W; j++)\n            if (need[i][j]) ans++;\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105],z[105][105];\nbool fr[105][105],vis[105][105],st,ad,f;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,4){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==4){\n\t\t\t\t\tad = 0, f = 1;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\tst = 1, f = 0;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n//\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n//\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,4){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==4){\n\t\t\t\t\tad = 0, f = 1;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\tst = 1, f = 0;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n//\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n//\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mem(x,n) memset(x,n,sizeof(x))\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,l) for(auto it=(l).begin();it!=(l).end();it++)\n#define pnl printf(\"\\n\")\n#define len(x) (x).length()\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\nconst double EPS=1e-10;\n//const double PI=acos(-1.0);\nconst int INF=1<<30;\nconst LL LLINF=1ll<<60;\nconst int MOD=1e9+7;\nconst int xx[8]={1,0,-1,0,1,-1,1,-1};\nconst int yy[8]={0,1,0,-1,-1,1,1,-1};\n\n/****************************************************************************************\\\n  __    __               __ /\\/|   ___ _           _       /\\/|__               __    __\n  \\ \\  / /  _____ __ ____\\ \\/\\/   / __| |__ _ _ __(_)___  |/\\// /____ __ _____  \\ \\  / /\n   \\ \\| |  |___\\ V  V /___| |    | (__| / _` | '_ \\ / -_)    | |___\\ V  V /___|  | |/ /\n    \\_\\ |  |___|\\_/\\_/|___| |     \\___|_\\__,_| .__/_\\___|    | |___|\\_/\\_/|___|  | /_/\n       \\_\\               /_/                 |_|              \\_\\               /_/\n\\****************************************************************************************/\n\nstruct edge{\n\tint v, bf;\n\tLL flow;\n};\n\nconst int MAXN = 205;\nvector<edge> adj[MAXN];\nint lvl[MAXN], st[MAXN];\nconst int sink = 203, source = 204;\nint idx[205][205],idx1[205][205];\nchar input[205][205];\n\nvoid addedge(int u,int v,LL flow){\n\tadj[u].pb({v,sz(adj[v]),flow});\n\tadj[v].pb({u,sz(adj[u]),0});\n}\n\nbool bfs(int S,int G){\n\tqueue<int> q;\n\tmem(lvl,-1);\n\tq.push(S); lvl[S]=0;\n\twhile(!q.empty()){\n\t\tint u = q.front(); q.pop();\n\t\tfor(int i=0;i<sz(adj[u]);i++){\n\t\t\tint v = adj[u][i].v;\n\t\t\tLL flow = adj[u][i].flow;\n\t\t\tif(lvl[v]!=-1||flow<=0) continue;\n\t\t\tlvl[v]=lvl[u]+1;\n\t\t\tq.push(v);\n\t\t}\n\t}\n\treturn (lvl[G]!=-1);\n}\n\nLL dfs(int u,LL mini,int G){\n\tif(u==G) return mini;\n\t\n\tfor(int i=st[u];i<sz(adj[u]);i++){\n\t\tst[u]=i;\n\t\tint v = adj[u][i].v;\n\t\tLL flow = adj[u][i].flow;\n\t\tif(flow<=0||(lvl[v]-lvl[u]!=1)) continue;\n\t\tLL ret=dfs(v,min(mini,flow),G);\n\t\tif(ret>0){\n\t\t\tadj[u][i].flow-=ret;\n\t\t\tint bvf = adj[u][i].bf;\n\t\t\tadj[v][bvf].flow+=ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nLL maxflow(int S,int G){\n\tLL ret=0;\n\twhile(1){\n\t\tif(!bfs(S,G)) break;\n\t\tLL flow = 0;\n\t\tmem(st,0);\n\t\twhile((flow=dfs(S, LLINF, G))>0){\n\t\t\tret+=flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint r,c;\n\tscanf(\"%d%d\",&r,&c);\n\tgetchar();\n\tfor(int i=0;i<r;i++){\n\t\tscanf(\"%s\",input[i]);\n\t}\n\t\n\tint temp=0;\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tidx[i][j]=temp;\n\t\t\tidx1[i][j]=temp+100;\n\t\t\ttemp++;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(input[i][j]=='.'){\n\t\t\t\taddedge(idx[i][j],idx1[i][j],1);\n\t\t\t\t\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\taddedge(idx1[i][j],sink,INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\taddedge(source,idx[i][j],INF);\n\t\t\t\taddedge(idx[i][j],idx1[i][j],INF);\n\t\t\t\t\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(i!=0) addedge(\tidx1[i][j], idx[i-1][j],INF);\n\t\t\tif(i!=r-1) addedge(\tidx1[i][j], idx[i+1][j],INF);\n\t\t\tif(j!=0) addedge(\tidx1[i][j], idx[i][j-1],INF);\n\t\t\tif(j!=c-1)addedge(\tidx1[i][j], idx[i][j+1],INF);\n\t\t}\n\t}\n\t\n\tLL ans = maxflow(source,sink);\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 1e4;\nconst int OO = 0x3f3f3f3f;\nint SOURCE, SINK;\n\nstruct edge\n{\n    int v, f, c;\n    edge(){}\n    edge(int _v, int _f, int _c)\n    {\n        v = _v, f = _f, c = _c;\n    }\n};\n\nvector<edge> edges;\nvector<int> G[MAX];\nint dist[MAX], work[MAX];\n\nvoid add_edge(int u, int v, int cp, int rc){\n\tedges.push_back(edge(v, 0, cp));\n\tG[u].push_back(edges.size()-1);\n\tedges.push_back(edge(u, 0, rc));\n\tG[v].push_back(edges.size()-1);\n}\n\nbool bfs(int s, int t)\n{\n    memset(dist, -1, sizeof(dist));\n    dist[s] = 0;\n    queue<int> q;\n    q.push(s);\n    while(!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        for(int e : G[u])\n            if(dist[edges[e].v] == -1 and edges[e].c-edges[e].f > 0)\n            {\n                q.push(edges[e].v);\n                dist[edges[e].v] = dist[u] + 1;\n            }\n    }\n    return dist[t] != -1;\n}\n\nint dfs(int s, int t, int f)\n{\n    if(s == t) return f;\n    for(int &i = work[s]; i < G[s].size(); i++)\n    {\n    \tint e = G[s][i];\n        if(dist[edges[e].v] == dist[s] + 1 and edges[e].c-edges[e].f > 0)\n            if(int a = dfs(edges[e].v, t, min(f, edges[e].c-edges[e].f)))\n            {\n                edges[e].f += a;\n                edges[e^1].f -= a;\n                return a;\n            }\n    }\n    return 0;\n}\n\nint MaxFlow(int s, int t)\n{\n    int mf = 0;\n    while(bfs(s, t))\n\t{\n    \tmemset(work, 0, sizeof(work));\n        while(int a = dfs(s, t, OO))\n            mf += a;\n    }\n    return mf;\n}\n\nint n, m, a, b;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\nchar ANS[60][60];\nbool cor[MAX];\n\nbool check(int x, int y)\n{\n\treturn x >= 0 and x < n and y >= 0 and y < m;\n}\n\nint vertexIn(int i, int j)\n{\n\treturn i * m + j;\n}\n\nint vertexOut(int i, int j)\n{\n\treturn i * m + j + n * m + 1;\n}\n\nint main()\n{\n \tcin >> n >> m;\n \tSOURCE = 2 * n * m + 2;\n \tSINK = 2 * n * m + 3;\n \tfor(int i = 0; i < n; i++)\n \t\tfor(int j = 0; j < m; j++)\n \t\t{\n \t\t\tchar c;\n \t\t\tcin >> c;\n \t\t\tint cost = 1;\n \t\t\tif(c == 'X') cost = OO;\n \t\t\tadd_edge(vertexIn(i, j), vertexOut(i, j), cost, 0);\n \t\t\tif(cost == OO) add_edge(vertexOut(i, j), SINK, OO, 0);\n \t\t\tfor(int k = 0; k < 4; k++)\n \t\t\t{\n\t\t\t\tint x = i + dx[k], y = j + dy[k];\n\t\t\t\tif(check(x, y))\n \t\t\t\t\tadd_edge(vertexOut(i, j), vertexIn(x, y), OO, 0);\n \t\t\t}\n \t\t\tif(!i or !j or i == n - 1 or j == m - 1)\n \t\t\t\tadd_edge(SOURCE, vertexIn(i, j), OO, 0);\n \t\t}\t\n\tint ans = MaxFlow(SOURCE, SINK);\n\tif(ans >= OO) ans = -1;\n \tcout << ans << '\\n';\n \t\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL111\n\t#define _GLIBCXX_DEBUG\n#else\n\t#define NDEBUG\n#endif\n#include <bits/stdc++.h>\nconst int INF = 1e9;\nusing namespace std;\ntemplate<typename T, typename U> ostream& operator<< (ostream& os, const pair<T,U>& p) { cout << '(' << p.first << ' ' << p.second << ')'; return os; }\n\n#define endl '\\n'\n#define ALL(a)  (a).begin(),(a).end()\n#define SZ(a) int((a).size())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#ifdef LOCAL111\n\t#define DEBUG(x) cout<<#x<<\": \"<<(x)<<endl\n\ttemplate<typename T> void dpite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\n#else\n\t#define DEBUG(x) true\n\ttemplate<typename T> void dpite(T a, T b){ return; }\n#endif\n#define F first\n#define S second\n#define SNP string::npos\n#define WRC(hoge) cout << \"Case #\" << (hoge)+1 << \": \"\ntemplate<typename T> void pite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\ntemplate<typename T> bool chmax(T& a, T b){if(a < b){a = b; return true;} return false;}\ntemplate<typename T> bool chmin(T& a, T b){if(a > b){a = b; return true;} return false;}\n\ntypedef long long int LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> P;\ntypedef pair<LL,LL> LP;\n\n#define int long long\n\n//library\ntypedef long long cost_t;\n\nclass Edge {\npublic:\n\tint to, from, rev;\n\tcost_t cost;\n\t\n\tEdge(){\n\t}\n\n\tEdge(int x,cost_t y){\n\t\tto = x;\n\t\tcost = y;\n\t}\n\n\tEdge(int x, int y, cost_t z){\n\t\tfrom = x;\n\t\tto = y;\n\t\tcost = z;\n\t}\n\n\tEdge(int x, int y, int r, cost_t z){\n\t\tfrom = x;\n\t\tto = y;\n\t\tcost = z;\n\t\trev = r;\n\t}\n\n\tbool operator< (const Edge& x) const {\n\t\tif(cost != x.cost) return cost < x.cost;\n\t\treturn to < x.to;\n\t}\n\n\tbool operator> (const Edge& x) const {\n\t\tif(cost != x.cost) return cost > x.cost;\n\t\treturn to > x.to;\n\t}\n};\n\nclass Graph {\nprivate:\n\t//const long long int INF = (long long)1e18;\n\tvector<vector<Edge> > v; \n\tint n;\npublic:\n\tGraph(int x){\n\t\tn = x;\n\t\tv = vector<vector<Edge> >(x);\n\t}\n\n\tGraph(){}\n\n\tvector<Edge>& operator[](int x){\n\t\treturn v[x];\n\t}\n\n\tconst vector<Edge>& operator[](int x) const {\n\t\treturn v[x];\n\t}\n\n\tint size() const {\n\t\treturn n;\n\t}\n\n\tvoid add_edge(int from, Edge e){\n\t\tv[from].push_back(e);\n\t}\n\n\tvoid add_edge(int from, int to, cost_t cost, int rev = -1){\n\t\tadd_edge(from,Edge(from,to,rev,cost));\n\t}\n\n\tvoid add_uedge(int from, int to, cost_t cost){\n\t\tadd_edge(from,to,cost);\n\t\tadd_edge(to,from,cost);\n\t}\n};\n\nvoid vizGraph(const Graph &g, bool with_dir = false, bool with_cap = false){\n\tofstream ofs(\"./out.dot\");\n\tif(with_dir) ofs << \"graph graph_name {\" << endl;\n\telse ofs << \"digraph graph_name {\" << endl;\n\tfor(int i = 0; i < (int)g.size(); i++){\n\t\tif (!g[i].size())\n\t\t\tcontinue;\n\t\tfor(const auto &e : g[i]){\n\t\t\tif(with_dir){\n\t\t\t\tif(e.to > i) ofs << \"    \\\"\" << i << \"\\\" -- \\\"\" << e.to << '\"'; \n\t\t\t}else ofs << \"    \\\"\" << i << \"\\\" -> \\\"\" << e.to << '\"'; \n\t\t\t\n\t\t\tif (with_cap) {\n\t\t\t\tofs << \" [ label = \\\"\" << (e.cost  == INF ? \"inf\" : to_string(e.cost)) << \"\\\"];\"; \n\t\t\t}\n\t\t\tif(!with_dir or e.to > i)ofs << endl;\n\t\t}\n\t}\n\tofs << \"}\" << endl;\n\tofs.close();\n\tsystem(\"dot -T png out.dot > sample.png\");\t\n}\n\n\ncost_t ffMaxFlow(const Graph &g_, int s, int t){\n\tGraph g = g_;\n\tint n = g.size();\n\tvector<int> rev(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < (int)g[i].size(); j++) {\n\t\t\tauto&& e = g[i][j];\n\t\t\te.rev = g[e.to].size();\n\t\t\tg.add_edge(e.to,i,0,j);\n\t\t}\n\t}\n\n\tcost_t flow = 0;\n\twhile(true){\n\t\tvector<bool> used(n,false);\n\n\t\tfunction<cost_t(int,int,cost_t)> dfs = [&](int v, int t, cost_t f) -> cost_t{\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\tfor(auto&& e : g[v]) {\n\t\t\t\tif(!used[e.to] and e.cost > 0){\n\t\t\t\t\tcost_t d = dfs(e.to, t, min(f, e.cost));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cost -= d;\n\t\t\t\t\t\tg[e.to][e.rev].cost += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t};\n\n\t\tcost_t f = dfs(s,t,INF);\n\t\tif(f == 0) return flow;\n\t\tflow += f;\n\t}\n}\n\nvoid ios_init(){\n\t//cout.setf(ios::fixed);\n\t//cout.precision(12);\n#ifdef LOCAL111\n\treturn;\n#endif\n\tios::sync_with_stdio(false); cin.tie(0);\t\n}\n\nconst int dx[] = {1,-1,0,0};\nconst int dy[] = {0,0,1,-1};\n\nsigned main()\n{\n\tios_init();\n\tint h,w;\n\twhile(cin >> h >> w){\n\t\tvector<string> s(h);\n\t\tREP(i,h) cin >> s[i];\n\t\tGraph g(2*h*w+2);\n\t\tint so = h*w*2;\n\t\tint si = h*w*2+1;\n\t\t\n\t\tauto check = [&](int x, int y) -> bool{\n\t\t\treturn 0 <= x and x < h and 0 <= y and y < w;\n\t\t};\n\t\tauto mp = [&](int x, int y) -> int{\n\t\t\treturn w*x+y;\n\t\t};\n\n\t\tREP(i,h) REP(j,w){\n\t\t\tDEBUG(i); DEBUG(j);\n\t\t\tREP(k,4){\n\t\t\t\tint nx = i+dx[k];\n\t\t\t\tint ny = j+dy[k];\n\t\t\t\tDEBUG(mp(nx,ny));\n\t\t\t\tif(check(nx,ny)){\n\t\t\t\t\tg.add_edge(h*w+mp(i,j),mp(nx,ny),INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s[i][j] == 'X'){\n\t\t\t\tg.add_edge(mp(i,j),h*w+mp(i,j),INF);\n\t\t\t\tg.add_edge(so,mp(i,j),INF);\n\t\t\t}else {\n\t\t\t\tg.add_edge(mp(i,j), h*w+mp(i,j),1);\n\t\t\t}\n\t\t}\n\t\t// vizGraph(g,false,true);\n\t\tREP(i,h){\n\t\t\tg.add_edge(h*w+mp(i,w-1),si,INF);\n\t\t\tg.add_edge(h*w+mp(i,0),si,INF);\n\t\t}\n\t\tFOR(j,1,w-1){\n\t\t\tg.add_edge(h*w+mp(0,j),si,INF);\n\t\t\tg.add_edge(h*w+mp(h-1,j),si,INF);\n\t\t}\n\t\tint ans = ffMaxFlow(g,so,si);\n\t\tif(ans >= INF){\n\t\t\tcout << -1 << endl;\n\t\t}else{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105],z[105][105];\nbool fr[105][105],vis[105][105],st,ad,f;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\trep(i,1,n){\n\t\trep(j,1,m)cout<<x[i][j];\n\t\tcout<<endl;\n\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,3){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==3){\n\t\t\t\t\tad = 0, f = 1;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,3){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==3){\n\t\t\t\t\tad = 0, f = 1;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n\trep(i,1,n){\n\t\trep(j,1,m)cout<<x[i][j];\n\t\tcout<<endl;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n#include <functional>\n#include <chrono>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\nconst long double EPS = 1e-9;\n\nclass FordFulkerson {\n    struct edge {\n        int to, rev;    //行き先，逆辺(のid)\n        long long cap;  //容量\n        edge(int _to, int _rev, long long _cap) {\n            this->to = _to;\n            this->rev = _rev;\n            this->cap = _cap;\n        }\n    };\nprivate:\n    vector<vector<edge>> G;\n    vector<bool> used;\n    long long dfs(int v, int t, long long f) {\n        if (v == t) return f;\n        used[v] = true;\n        for (auto &&el : G[v]) {\n            if (used[el.to] || el.cap <= 0) {\n                continue;\n            }\n            long long d = dfs(el.to, t, min(f, el.cap));\n            if (d > 0) {\n                el.cap -= d;\n                G[el.to][el.rev].cap += d;\n                return d;\n            }\n        }\n        return 0;\n    }\npublic:\n    FordFulkerson() {}\n    FordFulkerson(int n) {\n        G.resize(n);\n        used.resize(n, false);\n    }\n    void add_edge(int from, int to, long long cap) {\n        G[from].emplace_back(edge(to, G[to].size(), cap));\n        G[to].emplace_back(edge(from, G[from].size() - 1, 0));\n    }\n    long long max_flow(int s, int t) {\n        if (s == t) return 0;\n        long long flow = 0;\n        while (1) {\n            fill(begin(used), end(used), false);\n            long long f = dfs(s, t, LLINF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nconst int dx[] = {0, 0, -1, 1};\nconst int dy[] = {1, -1, 0, 0};\nint H, W;\nvector<string> S;\nFordFulkerson ff;\n\nint main(void) {\n    cin >> H >> W;\n    S.resize(H);\n    for (int i = 0; i < H; ++i) {\n        cin >> S[i];\n    }\n    for (int i = 0; i < H; ++i) {\n        if (S[i].front() == 'X' || S[i].back() == 'X') {\n            puts(\"-1\"); return 0;\n        }\n    }\n    for (int j = 0; j < W; ++j) {\n        if (S.front()[j] == 'X' || S.back()[j] == 'X') {\n            puts(\"-1\"); return 0;\n        }\n    }\n    const int MAX = H * W * 2 + 2;//各マスをinとoutに分けるため二倍で取る（inとoutを切断する行為が柵を設置することに該当する）\n    ff = FordFulkerson(MAX);\n    const int s = H * W * 2;    //始点\n    const int t = H * W * 2 + 1;//終点\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            const int num = i * W + j;\n            ff.add_edge(num, num + W * H, (S[i][j] == 'X' ? INF : 1));//ヤギさんがいたらそこには柵は置けません！\n            if (S[i][j] == 'X') {\n                assert(!(i == 0 || i == H - 1 || j == 0 || j == W - 1));\n                ff.add_edge(s, num + W * H, INF);//ヤギさんを流す下準備てきな（切断不可）切断不可のoutからヤギさんにエネルギー注入\n            }\n            if (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n                ff.add_edge(num + W * H, t, INF); //グリッドの端と外を繋げる（切断不可）\n            }\n            assert(num < W * H);\n            for (int k = 0; k < 4; ++k) {\n                const int nh = i + dx[k];\n                const int nw = j + dy[k];\n                if (0 <= nh && nh < H && 0 <= nw && nw < W) {\n                    const int nnum = nh * W + nw;\n                    assert(nnum != s && nnum != t);\n                    ff.add_edge(num + W * H, nnum, INF); // inから隣接マスのoutへ接続\n                }\n            }\n            assert(s != num && t != num);\n        }\n    }\n    cout << ff.max_flow(s, t) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nint H, W;\nstring b[100];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nvoid dfs(int x, int y) {\n\tif(b[y][x] == '#') {\n\t\tb[y][x] = '$';\n\t\treturn;\n\t}\n\tif(b[y][x] != '.') return;\n\tb[y][x] = '@';\n\tfor(int k = 0; k < 4; k++) {\n\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\tif(in(nx, ny)) {\n\t\t\tif(b[ny][nx] == '#') b[ny][nx] = '$';\n\t\t\tif(b[ny][nx] == '.') dfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++) {\n\t\tcin >> b[i];\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\tif(b[i][0] == 'X' || b[i][W - 1] == 'X') {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = 0; i < W; i++) {\n\t\tif(b[0][i] == 'X' || b[H - 1][i] == 'X') {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\n\n\n\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(b[y][x] == 'X') {\n\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\tif(b[ny][nx] == '.') b[ny][nx] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool flag = true;\n\twhile(flag) {\n\t\tflag = false;\n\t\tfor(int y = 0; y < H; y++) {\n\t\t\tfor(int x = 0; x < W; x++) {\n\t\t\t\tif(x + 2 < W && b[y][x] != '.' && b[y][x + 1] != '.' && b[y][x + 2] != '.') {\n\t\t\t\t\tif(y + 1 < H) {\n\t\t\t\t\t\tif(b[y + 1][x + 1] != '#') flag = true;\n\t\t\t\t\t\tb[y + 1][x + 1] = '#';\n\t\t\t\t\t}\n\t\t\t\t\tif(y - 1 >= 0) {\n\t\t\t\t\t\tif(b[y - 1][x + 1] != '#') flag = true;\n\t\t\t\t\t\tb[y - 1][x + 1] = '#';\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(y + 2 < H && b[y][x] != '.' && b[y + 1][x] != '.' && b[y + 2][x] != '.') {\n\t\t\t\t\tif(x + 1 < W) {\n\t\t\t\t\t\tif(b[y + 1][x + 1] != '#') flag = true;\n\t\t\t\t\t\tb[y + 1][x + 1] = '#';\n\t\t\t\t\t}\n\t\t\t\t\tif(x - 1 >= 0) {\n\t\t\t\t\t\tif(b[y + 1][x - 1] != '#') flag = true;\n\t\t\t\t\t\tb[y + 1][x - 1] = '#';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(x + 2 < W && y + 1 < H && y - 1 >= 0) {\n\t\t\t\t\tif(b[y][x] != '.' && b[y + 1][x + 1] != '.' && b[y][x + 2] != '.') {\n\t\t\t\t\t\tif(b[y - 1][x + 1] != '#') flag = true;\n\t\t\t\t\t\tb[y - 1][x + 1] = '#';\n\t\t\t\t\t\tif(b[y][x + 1] != '#') flag = true;\n\t\t\t\t\t\tb[y][x + 1] = '#';\n\t\t\t\t\t}\n\t\t\t\t\tif(b[y][x] != '.' && b[y - 1][x + 1] != '.' && b[y][x + 2] != '.') {\n\t\t\t\t\t\tif(b[y + 1][x + 1] != '#') flag = true;\n\t\t\t\t\t\tb[y + 1][x + 1] = '#';\n\t\t\t\t\t\tif(b[y][x + 1] != '#') flag = true;\n\t\t\t\t\t\tb[y][x + 1] = '#';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(y + 2 < H && x + 1 < W && x - 1 >= 0) {\n\t\t\t\t\tif(b[y][x] != '.' && b[y + 1][x + 1] != '.' && b[y + 2][x] != '.') {\n\t\t\t\t\t\tif(b[y + 1][x - 1] != '#') flag = true;\n\t\t\t\t\t\tb[y + 1][x - 1] = '#';\n\t\t\t\t\t\tif(b[y + 1][x] != '#') flag = true;\n\t\t\t\t\t\tb[y][x] = '#';\n\t\t\t\t\t}\n\t\t\t\t\tif(b[y][x] != '.' && b[y + 1][x - 1] != '.' && b[y + 2][x] != '.') {\n\t\t\t\t\t\tif(b[y + 1][x + 1] != '#') flag = true;\n\t\t\t\t\t\tb[y + 1][x + 1] = '#';\n\t\t\t\t\t\tif(b[y + 1][x] != '#') flag = true;\n\t\t\t\t\t\tb[y][x] = '#';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\t//cout << b[i] << endl;\n\t}\n\n\n\tfor(int i = 0; i < H; i++) {\n\t\tdfs(0, i);\n\t\tdfs(W - 1, i);\n\t}\n\tfor(int i = 0; i < W; i++) {\n\t\tdfs(i, 0);\n\t\tdfs(i, H - 1);\n\t}\n\n\tint ans = 0;\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(b[y][x] == '$') ans++;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long int lint;\ntypedef pair<lint, lint> plint;\ntypedef pair<double long, double long> pld;\n#define Alint(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1ll << (n))\n#define FOR(i, begin, end) for(lint i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(lint i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2>& l, const pair<T1, T2>& r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2>& l, const pair<T1, T2>& r) { return make_pair(l.first - r.first, l.second - r.second); }\nconst lint MOD = 998244353, INF = 1e9;\n\nstruct edge { lint to, cap, rev; };\n\nvector<edge> Graph[20005];\nint level[20005];\nint iter[20005];\nvoid add_edge(lint from, lint to, lint cap) {\n\tGraph[from].push_back({ to, cap, SZ(Graph[to]) });\n\tGraph[to].push_back({ from, 0, SZ(Graph[from]) - 1 });\n}\nvoid bfs(lint s) {\n\tmemset(level, -1, sizeof(level));\n\tqueue<lint> que;\n\tque.push(s);\n\tlevel[s] = 0;\n\twhile (!que.empty()) {\n\t\tlint v = que.front(); que.pop();\n\t\tREP(i, SZ(Graph[v])) {\n\t\t\tedge& e = Graph[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nlint dfs(lint v, lint t, lint f) {\n\tif (v == t) return f;\n\tfor (int& i = iter[v]; i < SZ(Graph[v]); i++) {\n\t\tedge& e = Graph[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tlint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tGraph[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nlint max_flow(lint s, lint t) {\n\tlint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0) return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tlint f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\n\nlint H, W;\nchar c;\n\nint main() {\n\tcin.tie(0); ios_base::sync_with_stdio(false);\n\t//始点 20002 終点 20003\n\tlint N = 10000;\n\tcin >> H >> W;\n\tREP(i, H) {\n\t\tREP(j, W) {\n\t\t\tcin >> c;\n\t\t\tif (c == 'X') {\n\t\t\t\tadd_edge(20002, i * H + j + N, INF);\n\t\t\t}\n\t\t\telse add_edge(i * H + j, i * H + j + N, 1);\n\t\t\tif (j < W - 1) {\n\t\t\t\tadd_edge(i * H + j + N, i * H + j + 1, INF);\n\t\t\t\tadd_edge(i * H + j + 1 + N, i * H + j, INF);\n\t\t\t}\n\t\t\tif (i < H - 1) {\n\t\t\t\tadd_edge(i * H + j + N, (i + 1) * H + j, INF);\n\t\t\t\tadd_edge((i + 1) * H + j + N, i * H + j, INF);\n\t\t\t}\n\t\t\tif (i == 0 || j == 0 || i == H - 1 || j == W - 1) {\n\t\t\t\tadd_edge(i * H + j + N, 20003, INF);\n\t\t\t}\n\t\t}\n\t}\n\tlint ans = max_flow(20002, 20003);\n\tif (ans >= INF) cout << -1 << endl;\n\telse cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <unordered_map>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\nusing namespace std;\n\n#define MAXN 200001\n\nint maxint = ~0U>>1;\nint flow;\nint pi[MAXN+1], v[MAXN+1];\nint S, T;\n\nstruct etype\n{\n\tint t, c;\n\tetype* next;\n\tetype* pair;\n\tetype(){next=0;}\n\tetype(int _t, int _c, etype* _n){t=_t, c=_c, next=_n;}\n}*e[MAXN+1], *eb[MAXN+1], *Pe, *Pool;\n\nint aug(int w, int lim)\n{\n\tint t;\n\tv[w] = 1;\n\tif(w == T)\n\t{\n\t\tflow += lim;\n\t\treturn lim;\n\t}\n\tfor(etype *& i=e[w]; i; i = i->next)\n\t\tif(i->c && !v[i->t] && pi[w] == pi[i->t] + 1)\n\t\t\tif(t = aug(i->t, min(lim, i->c)))\n\t\t\t\treturn i->c -= t, i->pair->c += t, t;\n\treturn 0;\n}\n\nbool fix()\n{\n\tint t = maxint;\n\tfor(int i = S; i <= T; i++)\n\t\tif(v[i])\n\t\t{\n\t\t\tfor(etype *j = eb[i]; j; j = j->next)\n\t\t\t\tif(j->c && !v[j->t])\n\t\t\t\t\tt = min(t, pi[j->t] + 1 - pi[i]);\n\t\t}\n\tif(t == maxint)\n\t\treturn 0;\n\n\tfor(int i = S; i <= T; i++)\n\t\tif(v[i])\n\t\t\te[i] = eb[i], pi[i] += t;\n\treturn 1;\n}\n\nvoid addedge(int s, int t, int c)\n{\n\t++Pe;\n\tPe->t = t, Pe->c = c, Pe->next = e[s];\n\te[s] = Pe;\n\t++Pe;\n\tPe->t = s, Pe->c = 0, Pe->next = e[t];\n\te[t] = Pe;\n\te[s]->pair=e[t];\n\te[t]->pair=e[s];\n}\n\nvoid prepare()\n{\n\tif(Pool == NULL)\n\t\tPool = new etype[1000001];\n\tPe = Pool;\n\tmemset(e, 0, sizeof(e));\n}\n\nint MaxFlow()\n{\n\tflow = 0;\n\tmemcpy(eb, e, sizeof(e));\n\tmemset(pi, 0, sizeof(pi));\n\tdo\n\t{\n\t\tdo\n\t\tmemset(v, 0, sizeof(v));\n\t\twhile(aug(S, maxint));\n\t}\n\twhile(fix());\n\treturn flow;\n}\n\n/*  Note\n\t1. Set maxNodes here: #define MAXN 200001\n\t2. Set maxEdges here: Pool = new etype[1000001];\n\t3. S must be the min id, T must be the max id\n*/\n\n/*  Eaxmple\n\tprepare();\n\tS = 1, T = 2;\n\taddedge(1, 2, 3);\n\tcout << MaxFlow() << endl;\n*/\n\nint n, m;\nint inId(int x, int y)\n{\n\tx --;\n\ty --;\n\treturn (x * m + y) + 2;\n}\nint outId(int x, int y)\n{\n\tx --;\n\ty --;\n\treturn (x * m + y + n*m) + 2;\n}\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nbool onBoard(int x, int y)\n{\n\tif(x < 1 || y < 1) return false;\n\tif(x > n || y > m) return false;\n\treturn true;\n}\n\nint MAIN()\n{\n\tcin >> n >> m;\n\tS = 1;\n\tT = 2*n*m+10;\n\tprepare();\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j = 1; j <= m; j++)\n\t\t{\n\t\t\tchar c = str[j-1];\n\t\t\tint x = i;\n\t\t\tint y = j;\n\t\t\tif(c == 'X')\n\t\t\t{\n\t\t\t\taddedge(inId(x, y), outId(x, y), 1000000);\n\t\t\t\taddedge(S, outId(x, y), 1000000);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\taddedge(inId(x, y), outId(x, y), 1);\t\n\t\t\t}\n\t\t\tfor(int f = 0; f < 4; f++)\n\t\t\t{\n\t\t\t\tint nx = x + dx[f];\n\t\t\t\tint ny = y + dy[f];\n\t\t\t\tif(onBoard(nx, ny))\n\t\t\t\t{\n\t\t\t\t\taddedge(outId(x, y), inId(nx, ny), 1000000);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\taddedge(outId(x, y), T, 1000000);\n\t\t\t\t\tif(c == 'X')\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << MaxFlow() << endl;\n\treturn 0;\n}\n\nint main()\n{\n\tint start = clock();\n\t#ifdef LOCAL_TEST\n\t\tfreopen(\"in.txt\", \"r\", stdin);\n\t\tfreopen(\"out.txt\", \"w\", stdout);\n\t#endif\n\tios :: sync_with_stdio(false);\n\tcout << fixed << setprecision(16);\n\tint ret = MAIN();\n\t#ifdef LOCAL_TEST\n\t\tcout << \"[Finished in \" << clock() - start << \" ms]\" << endl;\n\t#endif\n\treturn ret;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\n#define N 100\n\nint h, w;\nint a[315][315], f[315][315], v[315][315];\nint s[315][315];\nint dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, 1, -1};\nint ddx[9] = {1, 0, -1, 1, 0 , -1, 1, 0, -1}, ddy[9] = {1, 1, 1, 0, 0, 0, -1, -1, -1};\nint l, r, b, t;\n\nbool isin(int i, int j){\n    return i >= 0 && j >= 0 && i < h && j < w;\n}\n\nvoid dfs(int i, int j){\n    v[i][j] = 1;\n    if (f[i][j]) return;\n    REP(k,4){\n        int ii = i+dx[k], jj = j+dy[k];\n        if (!isin(ii,jj) || v[ii][jj]) continue;\n        dfs(ii, jj);\n    }\n}\n\nvoid dfs2(int i, int j){\n    s[i][j] = 1;\n    l = min(l, i+j);\n    r = max(r, i+j);\n    b = min(b, j-i);\n    t = max(t, j-i);\n    REP(k,9){\n        int ii = i+ddx[k], jj = j+ddy[k];\n        if (!a[ii][jj] || s[ii][jj]) continue;\n        dfs2(ii, jj);\n    }\n}\n\nint main() {\n    cin >> h >> w;\n    REP(i,h){\n        string s;\n        cin >> s;\n        REP(j,w) a[i+N][j+N] = (s[j] == 'X');\n    }\n\n    REP(i,h){\n        if (a[i+N][N] || a[i+N][N+w-1]){\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n    REP(j,w){\n        if (a[N][j+N] || a[N+h-1][j+N]){\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    h += 2*N;\n    w += 2*N;\n\n    REP(i,h){\n        REP(j,w){\n            if (a[i][j] && !s[i][j]){\n                l = r = i+j;\n                b = t = j-i;\n                dfs2(i,j);\n                l--;\n                r++;\n                b--;\n                t++;\n                FOR(k,b,t){\n                    if ((l+k) % 2 == 0){\n                        f[(l-k)/2][(l+k)/2] = 1;\n                    }\n                    if ((r+k) % 2 == 0){\n                        f[(r-k)/2][(r+k)/2] = 1;\n                    }\n                }\n                FOR(k,l,r){\n                    if ((b+k) % 2 == 0){\n                        f[(k-b)/2][(k+b)/2] = 1;\n                    }\n                    if ((t+k) % 2 == 0){\n                        f[(k-t)/2][(k+t)/2] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n\n    dfs(0, 0);\n\n    int ans = 0;\n    REP(i,h){\n        REP(j,w){\n            if (f[i][j] && v[i][j]) ans++;\n        }\n    }\n\n    // REP(i,h-2*N){\n    //     REP(j,w-2*N){\n    //         // cout << (f[i+N][j+N]&v[i+N][j+N]);\n    //         cout << f[i+N][j+N];\n    //     }cout << endl;\n    // }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <utility>\n#include <functional>\n#include <deque>\n#include <cctype>\n#include <stack>\n#include <bitset>\n#include <set>\n\nusing ll = long long;\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\nconst ll MOD = 1000000007;\nconst ll INF = 1 << 30;\nconst ll INF2 = 9000000000000000000LL;\nconst double INF3 = 900000000000000;\nconst int dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\nconst int tx[8] = { -1,0,1,-1,1,-1,0,1 }, ty[8] = { -1,-1,-1,0,0,1,1,1 };\n#define ALL(x) (x).begin(),(x).end()\n\n\nstruct edge { ll to, cap, rev; };\n\nvector<edge>g[1010];\nbool used[1010] = { 0 };\nint v, e;\n\nvoid add(ll from, ll to, ll cap) {\n\tg[from].push_back(edge{ to, cap, (ll)g[to].size() });\n\tg[to].push_back(edge{ from, (ll)0, (ll)g[from].size() - 1 });\n}\n\nll dfs(ll v, ll t, ll f) {\n\tif (v == t)return f;\n\tused[v] = true;\n\tfor (int i = 0;i < g[v].size();i++) {\n\t\tedge &e = g[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tg[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nll max_flow(ll s, ll t) {\n\tll flow = 0;\n\tfor (;;) {\n\t\tfill(used, used + v, 0);\n\t\tll f = dfs(s, t, INF2);\n\t\tif (f == 0)return flow;\n\t\tflow += f;\n\t}\n}\n\n\n\nint main() {\n\tchar mp[100][100];\n\tint w, h;\n\tcin >> h >> w;\n\tfor (int i = 0;i < h;i++) {\n\t\tfor (int j = 0;j < w;j++) {\n\t\t\tcin >> mp[i][j];\n\t\t}\n\t}\n\n\tint s = 2 * h*w, t = s + 1;\n\tfor (int i = 0;i < h;i++) {\n\t\tfor (int j = 0;j < w;j++) {\n\t\t\tif (mp[i][j] == 'X') {\n\t\t\t\tadd(s, i*w + j, INF);\n\t\t\t\tadd(i*w + j, i*w + j + h*w, INF);\n\t\t\t}\n\t\t\telse add(i*w + j, i*w + j + h*w, 1);\n\t\t\tfor (int k = 0;k < 4;k++) {\n\t\t\t\tint ni = i + dy[k], nj = j + dx[k];\n\t\t\t\tif (ni < 0 || ni >= h || nj < 0 || nj >= w)add(i*w + j + w*h, t, INF);\n\t\t\t\telse add(i*w + j + w*h, ni*w + nj, INF);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = max_flow(s, t);\n\tif (ans == INF) cout << -1 << endl;\n\telse cout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint ban1[105][105];\nint ban2[105][105];\nint H, W;\n\nset<pair<int, int> >done;\n\nbool valid(int y, int x){\n\treturn ( y>=0 && y < H) && (x>=0 && x < W);\n}\n\n\nbool check(int y, int x){\n\tfor(int i = 0; i < 4; i++){\n\t\tif(valid(y + dy[i], x + dx[i]) == false){\n\t\t\treturn true;\n\t\t}else{\n\t\t\tif(ban1[y + dy[i]][x + dx[i]] == 0){\n\t\t\t\tif(done.count(make_pair(y + dy[i], x + dx[i])) == 0){\n\t\t\t\t\tdone.insert(make_pair(y + dy[i], x + dx[i]));\n\t\t\t\t\tif(check(y + dy[i], x + dx[i]) == true){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n\n\nint main(){\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++){\n\t\tstring S;\n\t\tcin >> S;\n\t\tfor(int j = 0; j < S.size(); j++){\n\t\t\tif(S[j] == '.'){\n\t\t\t\tban1[i][j] = 0;\n\t\t\t}else{\n\t\t\t\tban1[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tif(ban1[i][j] == 1){\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tif(valid(i + dy[k], j + dx[k]) == false){\n\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(ban1[i + dy[k]][j + dx[k]] == 0){\n\t\t\t\t\t\tban1[i + dy[k]][j + dx[k]] = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tif(ban1[i][j] == 2){\n\t\t\t\tdone.clear();\n\t\t\t\tif(check(i, j) == true){\n\t\t\t\t\tans++;\n\t\t\t\t\tban2[i][j] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tcout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n\nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n\nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n\ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size())mk();\n\t\tif(hit==q.size()<<1)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n\nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){\n  int h,w;\n  cin>>h>>w;\n  vector<string> s(h);\n  for(int i=0;i<h;i++) cin>>s[i];\n  int ans=0;\n  int dy[]={0,0,1,-1};\n  int dx[]={1,-1,0,0};\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(s[i][j]!='X') continue;\n      if(i==0||i==h-1||j==0||j==w-1){\n\tcout<<-1<<endl;\n\treturn 0;\n      }\n      for(int k=0;k<4;k++)\n\tif(s[i+dy[k]][j+dx[k]]=='.')\n\t  s[i+dy[k]][j+dx[k]]='#',ans++;      \n    }\n  }\n  //cout<<ans<<endl;\n  //for(int i=0;i<h;i++) cout<<s[i]<<endl;\n\n  auto in=[&](int y,int x){return 0<=y&&y<h&&0<=x&&x<w;};\n  ans=0;\n  vector<vector<int> > dp(h,vector<int>(w,0));\n  using P = pair<int, int>;\n  for(int i=0;i<2;i++){\n    for(int j=0;j<2;j++){\n      int y=(h-1)*i,x=(w-1)*j;\n      if(dp[y][x]) continue;\n      queue<P> q;\n      dp[y][x]=1;\n      q.emplace(y,x);\n      while(!q.empty()){\n\ttie(y,x)=q.front();q.pop();\n\tif(s[y][x]=='#'){\n\t  ans++;\n\t  continue;\n\t}\n\tfor(int k=0;k<4;k++){\n\t  int ny=y+dy[k],nx=x+dx[k];\n\t  if(!in(ny,nx)||dp[ny][nx]) continue;\n\t  dp[ny][nx]=1;\n\t  q.emplace(ny,nx);\n\t}\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include \"ane.cpp\"\n\nconst int INF  = 1e9;\nconst long long INFLL = 1e18;\nconst int NMAX = 105;\nconst int MMAX = 100005;\nconst int KMAX = 1005;\nconst int MOD  = 1e9 + 7;\nusing namespace std;\n\n// comment to disable debug functions\n#define DEBUG\n\n// frequently used macros\n\n#if __cplusplus >= 201103L\n#define ALL(v) begin(v),end(v)\n#define SORT(v) sort(begin(v), end(v))\n#define FIND(v,x) find(begin(v), end(v), (x))\n#else\n#define ALL(v) (v).begin(),(v).end()\n#define SORT(v) sort(v.begin(), v.end())\n#define FIND(v,x) find(v.begin(), v.end(), (x))\n#endif\n\n#define fi first\n#define se second\n\n#define MEMNEXT(from, to) do{ memmove((to), (from), sizeof(from)); \\\nmemset((from), 0, sizeof(from)); } while(0)\n#ifdef DEBUG\n#define DUMP(x) do{ std::cerr << (#x) << \": \" << x << std::endl; }while(0)\n#else\n#define DUMP(x) do{}while(0)\n#endif\n\n// frequent used aliases\ntypedef long long ll;\ntypedef pair<int, int> p;\ntypedef pair<ll, int> lp;\ntypedef pair<ll, ll> llp;\ntypedef vector<int> vec;\ntypedef vector<ll> vecll;\ntypedef vector<vec> mat;\ntypedef vector<vecll> matll;\n\n// frequently used constants\nstatic const int di[] = {-1, 0, 1, -1, 1, -1, 0, 1};\nstatic const int dj[] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\n// frequently used structs\nstruct edge{\n  int to,cost;\n};\n\n// printf for debug\n#ifndef DEBUG\nvoid debug(const char* format, ...){}\n#else\nvoid debug(const char* format, ...){\n  va_list arg;\n  va_start(arg, format);\n  vprintf(format, arg);\n  va_end(arg);\n}\n#endif\n\n// dump vector\n#ifdef DEBUG\n#define DUMPV(v, c) do{       \\\n  printf(\"%s: \", #v);         \\\n  for (int i = 0; i < (c); ++i) \\\n  {                           \\\n  cout << (v)[i] << \" \";      \\\n  }                           \\\n  cout << endl;               \\\n} while(0)\n#else\n#define DUMPV(v,c)\n#endif\n\n// std::fill of multi dimensions\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n  std::fill( (T*)array, (T*)(array+N), val );\n}\n\n// binary search\nll BSearch(ll _begin, ll _end, bool (*f)(ll)){\n  ll mid;\n  while(_end - _begin > 1LL) {\n  mid = _begin + (_end - _begin) / 2LL;\n  if(f(mid)) {\n    debug(\"BSearch: f(%d) == true\\n\", mid);\n    _end = mid;\n  }\n  else\n  {\n    debug(\"BSearch: f(%d) == false\\n\", mid);\n    _begin = mid;\n  }\n  }\n  return _end;\n}\ntemplate<typename T>\n  class MaxFlow{\n    struct mf_edge{int to, rev; T cap;};\n    vector<vector<mf_edge> > G;\n    bool isNondir, initialized;\n    vector<bool> used;\n    T MAX;\n\n    T dfs_ff(int i, int t, T f){\n\n      if(i == t) return f;\n      used[i] = true;\n      for(auto&& e : G[i]) {\n        T ff = 0;\n        if (!used[e.to] && e.cap > 0 && (ff = dfs_ff(e.to, t, min<T>(f, e.cap)) > 0))\n        {\n          e.cap -= ff;\n          G[e.to][e.rev].cap += ff;\n          return ff;\n        }\n      }\n      return 0;\n    }\n  public:\n    MaxFlow(){}\n    void init(int n, T _max, bool nondir = false){\n      G.assign(n, vector<mf_edge>());\n      isNondir = nondir;\n      MAX = _max;\n      initialized = true;\n    }\n    void add_edge(int i, int j, T cap){\n      assert(i < G.size());\n      assert(j < G.size());\n      G[i].push_back(mf_edge{j, (int)G[j].size(), cap});\n      G[j].push_back(mf_edge{i, (int)G[i].size() - 1, 0});\n      if(isNondir){\n        G[j].push_back(mf_edge{i, (int)G[i].size(), cap});\n        G[i].push_back(mf_edge{j, (int)G[j].size() - 1, 0});\n      }\n    }\n    T ford_fulkerson(int s, int t){\n      assert(s < G.size());\n      assert(t < G.size());\n      if (!initialized)\n      {\n        cerr << \"error: MaxFlow not initialized.\" << endl;\n        return 0;\n      }\n      T ret = 0;\n      while(true){\n        used.assign(G.size(), false);\n        T d = dfs_ff(s, t, MAX);\n        if(d == 0)return ret;\n        ret += d;\n      }\n    }\n  };\n\nll NUM_TEST_CASE = 1;\n\nll N,M,K,A,B,C,D,E;\nchar dat[NMAX][MMAX];\nMaxFlow<ll> mf;\nll ans = {};\n\nvoid solve(){\n  // main algorithm\n  #define IN(i, j) ((i) * N + (j))\n  #define OUT(i, j) (N * M + (i) * N + (j))\n  #define START (2 * N * M)\n  #define GOAL (2 * N * M + 1)\n\n  mf.init(2 * N * M + 2, INFLL);\n  for (int i = 0; i < N; ++i)\n  {\n    for (int j = 0; j < M; ++j)\n    {\n      mf.add_edge(IN(i, j), OUT(i, j), 1);\n      if (i == 0 || i == N-1 || j == 0 || j == M-1)\n      {\n        if(dat[i][j] == 'X'){\n          ans = -1;\n          return;\n        }\n        mf.add_edge(OUT(i, j), GOAL, INFLL);\n      }\n      if(dat[i][j] == 'X') mf.add_edge(START, OUT(i, j), INFLL);\n      if(i > 0)     mf.add_edge(OUT(i, j), IN(i-1, j), INFLL);\n      if(i < N - 1) mf.add_edge(OUT(i, j), IN(i+1, j), INFLL);\n      if(j > 0)     mf.add_edge(OUT(i, j), IN(i, j-1), INFLL);\n      if(j < M - 1) mf.add_edge(OUT(i, j), IN(i, j+1), INFLL);\n    }\n  }\n  ans = mf.ford_fulkerson(START, GOAL);\n\n  #undef IN\n  #undef OUT\n  #undef START\n  #undef GOAL\n}\nvoid debug(){\n  // output debug information\n\n}\nvoid answer(){\n  // output answer\n  cout << ans << endl;\n}\nvoid init(){\n  // initialize for each test case\n  // Fill(dp, -1);\n}\nint main(int argc, char const *argv[])\n{\n  // operate inputs\n  // cin >> NUM_TEST_CASE;\n\n  for (int test_case = 0; test_case < NUM_TEST_CASE; ++test_case)\n  {\n    init();\n\n    cin >> N >> M;\n    for (int i = 0; i < N; ++i)\n    {\n      for (int j = 0; j < M; ++j)\n      {\n        scanf(\" %c\", &dat[i][j]);\n      }\n    }\n    solve();\n    #ifdef DEBUG\n    debug();\n    #endif\n    answer();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n\nint n,m,nr,nc,cnt,ans,hit;\nchar x[105][105];\nbool fr[105][105],vis[105][105];\nqueue<pii> q;\n\nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n\nvoid mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\n\nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#', q.push({i+dr[k],j+dc[k]});\n\t}\n\tmk();\n\tint r,c;\n\trep(tes,1,10000000){\n\t\tif(q.empty())break;\n\t\tif(hit==2*q.size())break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0, mk();\n\t\telse if(!cnt)x[r][c] = '.', hit = 0, mk();\n\t\telse q.push({r,c}), ++hit;\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<fr[i][j];\n//\t\tcout<<endl;\n//\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++ans;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n#define MAX_V (100*100*2+2)\n\nstruct edge{int to,cap,rev;};\n\nvector<edge> G[MAX_V];  //グラフのパス\nint level[MAX_V];       //始点からの距離\nint iter[MAX_V];        //どこまで調べたか\n\n// fromからtoへ向かう、容量capの辺をグラフに追加する\nvoid add_edge(int from,int to,int cap){\n    G[from].push_back(  (edge){ to  ,cap,(int)G[to  ].size()   }  );\n    G[to  ].push_back(  (edge){ from,0  ,(int)G[from].size()-1 }  );\n}\n\n// sからの最短距離をBFSで計算する\nvoid bfs(int s){\n    rep(i,MAX_V)level[i]=-1;\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n        int v=que.front();que.pop();\n        \n        rep(i,G[v].size()){\n            edge &e=G[v][i];\n            if(e.cap>0 && level[e.to]<0){\n                level[e.to]=level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\n//増加パスをDFSで探す\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    for(int &i=iter[v];i<G[v].size();i++){\n        edge &e=G[v][i];\n        if(e.cap>0&&level[v]<level[e.to]){\n            int d=dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n// sからtへの最大流を求める\nint max_flow(int s,int t){\n    if(s==t)return INF;\n    int flow=0;\n    for(;;){\n        bfs(s);\n        if(level[t]<0)return flow;\n        memset(iter,0,sizeof(iter));\n        int f;\n        while((f=dfs(s,t,INF))>0){\n            flow+=f;\n        }\n    }\n}\n\nint h,w;\n\nint f(int y,int x,int dim){\n    return y*w+x + dim*(h*w);\n}\n\n\nint main(){\n    cin>>h>>w;\n    int S = 2*h*w;\n    int T = 2*h*w+1;\n    vector<string> vs(h);\n    rep(i,h)cin>>vs[i];\n    \n    rep(i,h){   //左端か右端にヤギがいたら-1を出力する\n        if(vs[i][0]=='X' || vs[i][w-1]=='X'){\n            cout<<-1<<endl;\n            return 0;\n        }\n    }\n    rep(j,w){   //上端か下端にヤギがいたら-1を出力する\n        if(vs[0][j]=='X' || vs[h-1][j]=='X'){\n            cout<<-1<<endl;\n            return 0;\n        }\n    }\n    \n    \n    rep(i,h-1){     //y軸方向にジグザクに有向辺を貼る\n        rep(j,w){\n            add_edge(f(i+1,j,1),f(i  ,j,0),INF);\n            add_edge(f(i  ,j,1),f(i+1,j,0),INF);\n        }\n    }\n    rep(i,h){     //x軸方向にジグザクに有向辺を貼る\n        rep(j,w-1){\n            add_edge(f(i,j+1,1),f(i,j  ,0),INF);\n            add_edge(f(i,j  ,1),f(i,j+1,0),INF);\n        }\n    }\n    \n    rep(i,h){\n        rep(j,w){\n            if(vs[i][j] == 'X'){\n                add_edge(S,f(i,j,0),INF);       //ヤギの居るマスにはソースから有向辺を貼る\n                add_edge(f(i,j,0),f(i,j,1),INF);//ヤギの居るマスには真下にコストINFの有向辺を貼る\n            }\n            else{\n                add_edge(f(i,j,0),f(i,j,1),1);  //ヤギの居ないマスには真下にコスト1の有向辺を貼る\n            }\n        }\n    }\n    \n    rep(i,h){               //左端の列と右端の列からシンクに有向辺を貼る\n        add_edge(f(i,0  ,1),T,INF);\n        add_edge(f(i,w-1,1),T,INF);\n    }\n    \n    for(int j=1;j<w-1;j++){ //上端の行と下端の行からシンクに有向辺を貼る\n        add_edge(f(0,j,1),  T,INF);\n        add_edge(f(h-1,j,1),T,INF);\n    }\n    \n    int res = max_flow(2*h*w,2*h*w+1);\n    if(res>=INF)cout<<-1<<endl;\n    else cout<<res<<endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nstring mp[101];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\nint h,w;\n\nvoid mark(int x,int y){\n  for(int i=0;i<4;i++){\n    int nx=x+dx[i],ny=y+dy[i];\n    if(mp[ny][nx]!='X')mp[ny][nx]='#';\n  }  \n}\n\nvector <P> start;\nbool check(){\n  queue<P> Q;\n  bool D[101][101]={};\n  for(int i=0;i<start.size();i++){\n    Q.push(P(start[i]));\n    D[start[i].second][start[i].first]=1;\n  }\n\n  while(!Q.empty()){\n    P t=Q.front();Q.pop();\n    int x=t.first,y=t.second;\n    for(int i=0;i<4;i++){\n      int nx=x+dx[i],ny=y+dy[i];\n      if(nx<0||nx>=w||ny<0||ny>=h)return 0;\n      if(mp[ny][nx]=='#'||D[ny][nx])continue;\n      Q.push(P(nx,ny));\n      D[ny][nx]=1;\n    }\n  }\n  return 1;\n}\n\n\nint main(){\n\n  cin>>h>>w;\n  for(int i=0;i<h;i++)cin>>mp[i];\n  int flg=0;\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(mp[i][j]!='X')continue;\n      if(i==0||i==h-1||j==0||j==w-1)flg=1;\n      if(flg)break;\n      mark(j,i);\n      start.push_back(P(j,i));\n    }\n\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j]!='X')mp[i][j]='#';\n\n\n\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<=w/2;j++){\n      if(mp[i][j]=='#'){\n\tmp[i][j]='.';\n\tif(!check())mp[i][j]='#';\n      }\n      if(mp[i][w-1-j]=='#'){\n\tmp[i][w-1-j]='.';\n\tif(!check())mp[i][w-1-j]='#';\n      }\n    }\n\n\n  cout<<endl;for(int i=0;i<h;i++)cout<<mp[i]<<endl;\n  \n \n  int cnt=0;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) cnt+=(mp[i][j]=='#');\n  \n  \n  \n  if(flg)cout<<-1<<endl;\n  else cout <<cnt<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nconstexpr int INF = 1e9;\nusing weight = int;\n\nstruct edge {\n    int to;\n    weight cap;\n    int rev;\n};\n\nusing edges = std::vector<edge>;\nusing graph = std::vector<edges>;\n\nvoid add_edge(graph& g, int from, int to, weight cap) {\n    g[from].push_back(edge{to, cap, static_cast<int>(g[to].size())});\n    g[to].push_back(edge{from, 0, static_cast<int>(g[from].size()-1)});\n}\n\nvoid bfs(graph& g, std::vector<int>& level, int s) {\n    for(int i=0; i<level.size(); ++i) {\n        level[i] = -1;\n    }\n    level[s] = 0;\n    std::queue<weight> que;\n    que.push(s);\n    while(!que.empty()) {\n        int v = que.front(); que.pop();\n        for(int i=0; i<g[v].size(); ++i) {\n            edge& e = g[v][i];\n            if(e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nweight dfs(graph& g, std::vector<int>& level, std::vector<int>& iter, int v, int t, weight f) {\n    if(v == t) {\n        return f;\n    }\n    for(int& i=iter[v]; i<g[v].size(); ++i) {\n        edge& e = g[v][i];\n        if(e.cap > 0 && level[v] < level[e.to]) {\n            int d = dfs(g, level, iter, e.to, t, std::min(f, e.cap));\n            if(d > 0) {\n                e.cap -= d;\n                g[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n// verified\nweight max_flow(graph& g, int s, int t) {\n    weight flow = 0;\n    std::vector<int> level(g.size(), -1);\n    std::vector<int> iter(g.size(), 0);\n    int INF = 1e9;\n    while(true) {\n        bfs(g, level, s);\n        if(level[t] < 0) {\n            return flow;\n        }\n        for(int i=0; i<iter.size(); ++i) {\n            iter[i] = 0;\n        }\n        weight f;\n        while((f = dfs(g, level, iter, s, t, INF)) > 0) {\n            flow += f;\n        }\n    }\n}\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> S(H);\n    for(int i = 0; i < H; ++i) {\n        cin >> S[i];\n    }\n\n    graph g(2 * H * W + 2);\n    const int source = 2 * H * W;\n    const int sink = 2 * H * W + 1;\n    bool check = false;\n    for(int i = 0; i < H; ++i) {\n        for(int j = 0; j < W; ++j) {\n            add_edge(g, i * W + j, i * W + j + H * W, (S[i][j] == 'X' ? INF : 1));\n            if(i != 0) {\n                add_edge(g, i * W + j + H * W, (i - 1) * W + j, 1);\n            }\n            if(i != H - 1) {\n                add_edge(g, i * W + j + H * W, (i + 1) * W + j, 1);\n            }\n            if(j != 0) {\n                add_edge(g, i * W + j + H * W, i * W + j - 1, 1);\n            }\n            if(j != W - 1) {\n                add_edge(g, i * W + j + H * W, i * W + j + 1, 1);\n            }\n\n            if(S[i][j] == 'X') {\n                add_edge(g, source, i * W + j, INF);\n                check |= i == 0 || i == H - 1 || j == 0 || j == W - 1;\n            }\n        }\n    }\n    if(check) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    for(int i = 0; i < H; ++i) {\n        add_edge(g, i * W, sink, 1);\n        add_edge(g, i * W + W - 1, sink, 1);\n    }\n    for(int i = 0; i < W; ++i) {\n        add_edge(g, i, sink, 1);\n        add_edge(g, (H - 1) * W + i, sink, 1);\n    }\n\n    cout << max_flow(g, source, sink) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\n#define N 102\n\nint h, w;\nint a[330][330], f[330][330], v[330][330];\nint s[330][330];\nint dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, 1, -1};\nint ddx[9] = {1, 0, -1, 1, 0 , -1, 1, 0, -1}, ddy[9] = {1, 1, 1, 0, 0, 0, -1, -1, -1};\nint l, r, b, t;\n\nbool isin(int i, int j){\n    return i >= 0 && j >= 0 && i < h && j < w;\n}\n\nvoid dfs(int i, int j){\n    v[i][j] = 1;\n    if (f[i][j]) return;\n    REP(k,4){\n        int ii = i+dx[k], jj = j+dy[k];\n        // printf(\"%d %d\\n\", ii, jj);\n        if (!isin(ii,jj) || v[ii][jj]) continue;\n        dfs(ii, jj);\n    }\n}\n\nvoid dfs2(int i, int j){\n    s[i][j] = 1;\n    l = min(l, i+j);\n    r = max(r, i+j);\n    b = min(b, j-i);\n    t = max(t, j-i);\n    REP(k,9){\n        int ii = i+ddx[k], jj = j+ddy[k];\n        if (!a[ii][jj] || s[ii][jj]) continue;\n        dfs2(ii, jj);\n    }\n}\n\nint main() {\n    cin >> h >> w;\n    REP(i,h){\n        string s;\n        cin >> s;\n        REP(j,w) a[i+N][j+N] = (s[j] == 'X');\n    }\n\n    REP(i,h){\n        if (a[i+N][N] || a[i+N][N+w-1]){\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n    REP(j,w){\n        if (a[N][j+N] || a[N+h-1][j+N]){\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    h += 2*N;\n    w += 2*N;\n\n    REP(i,h){\n        REP(j,w){\n            if (a[i][j] && !s[i][j]){\n                l = r = i+j;\n                b = t = j-i;\n                dfs2(i,j);\n                l--;\n                r++;\n                b--;\n                t++;\n                FOR(k,b,t){\n                    if ((l+k) % 2 == 0){\n                        f[(l-k)/2][(l+k)/2] = 1;\n                    }\n                    if ((r+k) % 2 == 0){\n                        f[(r-k)/2][(r+k)/2] = 1;\n                    }\n                }\n                FOR(k,l,r){\n                    if ((b+k) % 2 == 0){\n                        f[(k-b)/2][(k+b)/2] = 1;\n                    }\n                    if ((t+k) % 2 == 0){\n                        f[(k-t)/2][(k+t)/2] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n    dfs(0, 0);\n\n    int ans = 0;\n    REP(i,h){\n        REP(j,w){\n            if (f[i][j] && v[i][j]) ans++;\n        }\n    }\n\n    // REP(i,h-2*N){\n    //     REP(j,w-2*N){\n    //         // cout << (f[i+N][j+N]&v[i+N][j+N]);\n    //         cout << f[i+N][j+N];\n    //     }cout << endl;\n    // }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1,0};\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int H, W; cin >> H >> W;\n  VS vs(H);\n  REP(i,H) cin >> vs[i];\n\n  int ans = 0;\n  REP(y,H) REP(x,W){\n\tif(vs[y][x] == 'X'){\n\t  if(y == 0 || y == H-1 || x == 0 || x == W-1){\n\t\tans = -1;\n\t\tx = y = 1e9;\n\t  }\n\t  else{\n\t\tREP(d,4){\n\t\t  int tx = x + dx[d], ty = y + dy[d];\n\t\t  if(vs[ty][tx] == '.'){\n\t\t\tvs[ty][tx] = '#';\n\t\t  }\n\t\t}\n\t  }\n\t}\n  }\n  if(ans < 0){\n\tcout << ans << endl;\n\treturn 0;\n  }\n\n  vector<vector<bool>> use(H, vector<bool>(W, false));\n  REP(y,H) REP(x,W){\n\tif(vs[y][x] != '.' && !use[y][x]){\n\t  queue<PII> q;\n\t  q.push(MP(x,y));\n\t  use[y][x] = true;\n\t  while(!q.empty()){\n\t\tPII p = q.front(); q.pop();\n\t\tint n = 0;\n\t\tREP(d,4){\n\t\t  int tx = p.FF + dx[d], ty = p.SS + dy[d];\n\t\t  if(tx < 0 || W <= tx || ty < 0 || H <= ty){\n\t\t\t++n;\n\t\t  }\n\t\t  else{\n\t\t\tif(vs[ty][tx] == '.')\n\t\t\t  ++n;\n\t\t\telse if(!use[p.SS][p.FF]){\n\t\t\t  use[p.SS][p.FF] = true;\n\t\t\t  q.push(MP(tx,ty));\n\t\t\t}\n\t\t  }\n\t\t}\n\t\tif(n) ++ans;\n\t  }\n\t}\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,1,0,-1};\n\nint H, W;\nstring s[110];\nbool ns[110][110];\nbool rc[110][110];\n\nint main() {\n\tcin >> H >> W;\n\trep(i, H) cin >> s[i];\n\n\trep(i, H) {\n\t\trep(j, W) {\n\t\t\tif (s[i][j] == 'X') {\n\t\t\t\tif (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n\t\t\t\t\tputs(\"-1\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tns[i-1][j]=ns[i+1][j]=ns[i][j-1]=ns[i][j+1]=1;\n\t\t\t}\n\t\t}\n\t}\t\n\n\tqueue<pii> que;\n\trep(i, H) {\n\t\trep(j, W) {\n\t\t\tif (s[i][j] == 'X') {\n\t\t\t\tns[i][j] = 0;\n\t\t\t}\n\t\t\tif (!ns[i][j] && (i == 0 || i == H - 1 || j == 0 || j == W - 1)) {\n\t\t\t\tque.push(mp(i, j));\n\t\t\t\trc[i][j] = 1;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\n\twhile (!que.empty()) {\n\t\tpii p = que.front(); que.pop();\n\t\tint y = p.fi, x = p.se;\n\n\t\trep(i, 4) {\n\t\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\t\tif (ny >= 0 && ny < H && nx >= 0 && nx < W) {\n\t\t\t\tif (!ns[ny][nx] && !rc[ny][nx]) {\n\t\t\t\t\trc[ny][nx] = 1;\n\t\t\t\t\tque.push(mp(ny, nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = 0;\n\n\trep(y, H) {\n\t\trep(x, W) {\n\t\t\tif (!ns[y][x]) continue;\n\t\t\tbool ok = 0;\n\n\t\t\trep(i, 4) {\n\t\t\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\t\t\tif (ny >= 0 && ny < H && nx >= 0 && nx < W) {\n\t\t\t\t\tif (rc[ny][nx]) ok = 1;\n\t\t\t\t} else ok = 1;\n\t\t\t}\n\t\t\tret += ok;\n\t\t}\n\t}\n\n\tcout << ret << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include \"ane.cpp\"\n\nconst int INF  = 1e9;\nconst long long INFLL = 1e18;\nconst int NMAX = 105;\nconst int MMAX = 105;\nconst int KMAX = 1005;\nconst int MOD  = 1e9 + 7;\nusing namespace std;\n\n// comment to disable debug functions\n#define DEBUG\n\n// frequently used macros\n\n#if __cplusplus >= 201103L\n#define ALL(v) begin(v),end(v)\n#define SORT(v) sort(begin(v), end(v))\n#define FIND(v,x) find(begin(v), end(v), (x))\n#else\n#define ALL(v) (v).begin(),(v).end()\n#define SORT(v) sort(v.begin(), v.end())\n#define FIND(v,x) find(v.begin(), v.end(), (x))\n#endif\n\n#define fi first\n#define se second\n\n#define MEMNEXT(from, to) do{ memmove((to), (from), sizeof(from)); \\\nmemset((from), 0, sizeof(from)); } while(0)\n#ifdef DEBUG\n#define DUMP(x) do{ std::cerr << (#x) << \": \" << x << std::endl; }while(0)\n#else\n#define DUMP(x) do{}while(0)\n#endif\n\n// frequent used aliases\ntypedef long long ll;\ntypedef pair<int, int> p;\ntypedef pair<ll, int> lp;\ntypedef pair<ll, ll> llp;\ntypedef vector<int> vec;\ntypedef vector<ll> vecll;\ntypedef vector<vec> mat;\ntypedef vector<vecll> matll;\n\n// frequently used constants\nstatic const int di[] = {-1, 0, 1, -1, 1, -1, 0, 1};\nstatic const int dj[] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\n// frequently used structs\nstruct edge{\n  int to,cost;\n};\n\n// printf for debug\n#ifndef DEBUG\nvoid debug(const char* format, ...){}\n#else\nvoid debug(const char* format, ...){\n  va_list arg;\n  va_start(arg, format);\n  vprintf(format, arg);\n  va_end(arg);\n}\n#endif\n\n// dump vector\n#ifdef DEBUG\n#define DUMPV(v, c) do{       \\\n  printf(\"%s: \", #v);         \\\n  for (int i = 0; i < (c); ++i) \\\n  {                           \\\n  cout << (v)[i] << \" \";      \\\n  }                           \\\n  cout << endl;               \\\n} while(0)\n#else\n#define DUMPV(v,c)\n#endif\n\n// std::fill of multi dimensions\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n  std::fill( (T*)array, (T*)(array+N), val );\n}\n\n// binary search\nll BSearch(ll _begin, ll _end, bool (*f)(ll)){\n  ll mid;\n  while(_end - _begin > 1LL) {\n  mid = _begin + (_end - _begin) / 2LL;\n  if(f(mid)) {\n    debug(\"BSearch: f(%d) == true\\n\", mid);\n    _end = mid;\n  }\n  else\n  {\n    debug(\"BSearch: f(%d) == false\\n\", mid);\n    _begin = mid;\n  }\n  }\n  return _end;\n}\ntemplate<typename T>\n  class MaxFlow{\n    struct mf_edge{int to, rev; T cap;};\n    vector<vector<mf_edge> > G;\n    bool isNondir, initialized;\n    vector<bool> used;\n    T MAX;\n\n    T dfs_ff(int i, int t, T f){\n\n      if(i == t) return f;\n      used[i] = true;\n      for(auto&& e : G[i]) {\n        T ff = 0;\n        if (!used[e.to] && e.cap > 0 && (ff = dfs_ff(e.to, t, min<T>(f, e.cap)) > 0))\n        {\n          e.cap -= ff;\n          G[e.to][e.rev].cap += ff;\n          return ff;\n        }\n      }\n      return 0;\n    }\n  public:\n    MaxFlow(){}\n    void init(int n, T _max, bool nondir = false){\n      G.assign(n, vector<mf_edge>());\n      isNondir = nondir;\n      MAX = _max;\n      initialized = true;\n    }\n    void add_edge(int i, int j, T cap){\n      assert(i < G.size());\n      assert(j < G.size());\n      G[i].push_back(mf_edge{j, (int)G[j].size(), cap});\n      G[j].push_back(mf_edge{i, (int)G[i].size() - 1, 0});\n      if(isNondir){\n        G[j].push_back(mf_edge{i, (int)G[i].size(), cap});\n        G[i].push_back(mf_edge{j, (int)G[j].size() - 1, 0});\n      }\n    }\n    T ford_fulkerson(int s, int t){\n      assert(s < G.size());\n      assert(t < G.size());\n      if (!initialized)\n      {\n        cerr << \"error: MaxFlow not initialized.\" << endl;\n        return 0;\n      }\n      T ret = 0;\n      while(true){\n        used.assign(G.size(), false);\n        T d = dfs_ff(s, t, MAX);\n        if(d == 0)return ret;\n        ret += d;\n      }\n    }\n  };\n\nll NUM_TEST_CASE = 1;\n\nll N,M,K,A,B,C,D,E;\nchar dat[NMAX][MMAX];\nMaxFlow<ll> mf;\nll ans = {};\n\nvoid solve(){\n  // main algorithm\n  #define IN(i, j) ((i) * M + (j))\n  #define OUT(i, j) (N * M + (i) * M + (j))\n  #define START (2 * N * M)\n  #define GOAL (2 * N * M + 1)\n\n  mf.init(2 * N * M + 2, INFLL);\n  for (int i = 0; i < N; ++i)\n  {\n    for (int j = 0; j < M; ++j)\n    {\n      mf.add_edge(IN(i, j), OUT(i, j), 1);\n      if (i == 0 || i == N-1 || j == 0 || j == M-1)\n      {\n        if(dat[i][j] == 'X'){\n          ans = -1;\n          return;\n        }\n        mf.add_edge(OUT(i, j), GOAL, INFLL);\n      }\n      if(dat[i][j] == 'X') mf.add_edge(START, OUT(i, j), INFLL);\n      if(i > 0)     mf.add_edge(OUT(i, j), IN(i-1, j), INFLL);\n      if(i < N - 1) mf.add_edge(OUT(i, j), IN(i+1, j), INFLL);\n      if(j > 0)     mf.add_edge(OUT(i, j), IN(i, j-1), INFLL);\n      if(j < M - 1) mf.add_edge(OUT(i, j), IN(i, j+1), INFLL);\n    }\n  }\n  ans = mf.ford_fulkerson(START, GOAL);\n\n  #undef IN\n  #undef OUT\n  #undef START\n  #undef GOAL\n}\nvoid debug(){\n  // output debug information\n\n}\nvoid answer(){\n  // output answer\n  cout << ans << endl;\n}\nvoid init(){\n  // initialize for each test case\n  // Fill(dp, -1);\n}\nint main(int argc, char const *argv[])\n{\n  // operate inputs\n  // cin >> NUM_TEST_CASE;\n\n  for (int test_case = 0; test_case < NUM_TEST_CASE; ++test_case)\n  {\n    init();\n\n    cin >> N >> M;\n    for (int i = 0; i < N; ++i)\n    {\n      for (int j = 0; j < M; ++j)\n      {\n        scanf(\" %c\", &dat[i][j]);\n      }\n    }\n    solve();\n    #ifdef DEBUG\n    debug();\n    #endif\n    answer();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\nusing namespace std;\ntypedef long long ll;\nll inf = 1e9;\n\nclass network_flow{\nprivate:\n\tint N;\n\tstruct edge{int to; ll cap; int rev;};\n\tvector<vector<edge>> G;\n\tvector<int> level,iter;\n\tvoid bfs(int s){\n\t\tfor(int i=0;i<=N;i++) level[i] = -1;\n\t\tqueue<int> Q;\n\t\tlevel[s] = 0;\n\t\tQ.push(s);\n\t\twhile(!Q.empty()){\n\t\t\tint v = Q.front(); Q.pop();\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[e.to]<0){\n\t\t\t\t\tlevel[e.to] = level[v]+1;\n\t\t\t\t\tQ.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll dfs(int v,int t,ll f){\n\t\tif(v==t) return f;\n\t\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(level[v]<level[e.to] && e.cap>0){\n\t\t\t\tll d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\tnetwork_flow(int n){\n\t\tN = n;\n\t\tG = vector<vector<edge>>(N+1);\n\t\tlevel = iter = vector<int>(N+1);\n\t}\n\tvoid add_edge(int from, int to,ll cap){\n\t\tG[from].push_back((edge){to,cap,(int) G[to].size()});\n\t\tG[to].push_back((edge){from,0,(int) G[from].size()-1});\n\t}\n\tll max_flow(int s,int t){\n\t\tll flow = 0;\n\t\tfor(;;){\n\t\t\tbfs(s);\n\t\t\tif(level[t]<0) return flow;\n\t\t\tfor(int i=0;i<=N;i++) iter[i] = 0;\n\t\t\tll f;\n\t\t\twhile((f=dfs(s,t,inf))>0) flow += f;\n\t\t}\n\t}\n};\n\nint main(){\n    int H,W;\n    cin >> H >> W;\n    vector<vector<char>> S(H,vector<char>(W));\n    vector<int> dx = {-1,1,0,0},dy = {0,0,-1,1};\n    bool ok = true;\n    for(int i=0;i<H;i++) for(int j=0;j<W;j++){\n        cin >> S[i][j];\n        if(S[i][j]=='X'){\n            if(i==0 || j==0 || i==H-1 || j==W-1) ok = false;\n        }\n    }\n    if(!ok){\n        cout << -1 << endl;\n        return 0;\n    }\n    network_flow flow(2*H*W+2);\n    auto id = [&](int i,int j,int isout){\n        return i*W+j+1+isout*H*W;\n    };\n\n    auto in = [&](int i,int j){\n        return 0<=i && i<H && 0<=j && j<W;\n    };\n\n    for(int i=0;i<H;i++) for(int j=0;j<W;j++){\n        if(S[i][j]=='X'){\n            flow.add_edge(0,id(i,j,0),inf);\n            flow.add_edge(id(i,j,0),id(i,j,1),inf);\n        }\n        else flow.add_edge(id(i,j,0),id(i,j,1),1);\n        for(int k=0;k<4;k++){\n            int ni = i+dx[k],nj = j+dy[k];\n            if(in(ni,nj)) flow.add_edge(id(i,j,1),id(ni,nj,0),inf);\n            else flow.add_edge(id(i,j,1),2*H*W+1,inf);\n        }\n    }\n    cout << flow.max_flow(0,2*H*W+1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\nusing namespace std;\n\nint vertex_no(int h, int w, int i, int j, int b) {\n\treturn h * w*b + w * (j - 1) + i;\n}\nint grid[105][105];\n\nstruct edge\n{\n\tint from; int to; long long cost; int rev;\n};\nint const MAX = 100005;\nvector<edge> G[MAX];\nlong long const INF = 10000000000000016;\nint parent[MAX];\nint from_edge[MAX];\nlong long costs[MAX];\n\nbool dfs(int n, int start, int goal, vector<edge>V[], long long &amount) {\n\tfor (int i = 0; i <= n; i++) {\n\t\tparent[i] = -1;\n\t}\n\tstack<int> s;\n\tparent[start] = 0;\n\tcosts[start] = INF*5;\n\ts.push(start);\n\twhile (!s.empty()) {\n\t\tint now = s.top();\n\t\ts.pop();\n\t\tfor (int i = 0; i < G[now].size(); i++) {\n\t\t\tedge next_edge = G[now][i];\n\t\t\tint next = next_edge.to;\n\t\t\tif (parent[next] == -1 && next_edge.cost > 0) {\n\t\t\t\tparent[next] = now;\n\t\t\t\tfrom_edge[next] = i;\n\t\t\t\tcosts[next] = min(costs[now], next_edge.cost);\n\t\t\t\ts.push(next);\n\t\t\t}\n\t\t}\n\t}\n\tamount = costs[goal];\n\treturn parent[goal] != -1;\n}\n\nvoid max_flow(int n, int start, int goal, vector<edge>V[], long long &flow) {\n\tlong long amount;\n\twhile (dfs(n, start, goal, V, amount)) {\n\t\tint now = goal;\n\t\twhile (now != start) {\n\t\t\tint p = parent[now];\n\t\t\tG[p][from_edge[now]].cost -= amount;\n\t\t\tint r = G[p][from_edge[now]].rev;\n\t\t\tG[now][r].cost += amount;\n\t\t\tnow = parent[now];\n\t\t}\n\t\tflow += amount;\n\t}\n}\n\nint dir_x[4] = { 1,0,-1,0 };\nint dir_y[4] = { 0,1,0,-1 };\n\nint main() {\n\tint start, goal;\n\tint h; int w;\t\n\tcin >> h >> w;\n\tstart = 0;\n\tgoal = h * w * 2 + 1;\n\tfor (int j = 1; j <= h; j++) {\n\t\tfor (int i = 1; i <= w; i++) {\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tgrid[i][j] = (c == 'X');\n\t\t\tif (c == 'X' && (i == 1 || i == w || j == 1 || j == h)) {\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= w; i++) {\n\t\tfor (int j = 1; j <= h; j++) {\n\t\t\tif (i == 1 || i == w || j == 1 || j == h) {\n\t\t\t\tint x, y;\n\t\t\t\tx = vertex_no(h, w, i, j, 0);\n\t\t\t\ty = goal;\n\t\t\t\tG[x].push_back({ x,y,INF,int(G[y].size()) });\n\t\t\t\tG[y].push_back({ y,x,INF,int(G[x].size() - 1) });\n\t\t\t\ty = x;\n\t\t\t\tx = vertex_no(h, w, i, j, 1);\n\t\t\t\tG[x].push_back({ x,y,1,int(G[y].size()) });\n\t\t\t\tG[y].push_back({ y,x,0,int(G[x].size() - 1) });\n\t\t\t}\n\t\t\telse if (grid[i][j] == 1) {\n\t\t\t\tint x, y;\n\t\t\t\tx = vertex_no(h, w, i, j, 0);\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\ty = vertex_no(h, w, i + dir_x[k], j + dir_y[k], 1);\n\t\t\t\t\tG[x].push_back({ x,y,INF,int(G[y].size()) });\n\t\t\t\t\tG[y].push_back({ y,x,0,int(G[x].size() - 1) });\n\t\t\t\t}\n\t\t\t\ty = x;\n\t\t\t\tx = start;\n\t\t\t\tG[x].push_back({ x,y,INF,int(G[y].size()) });\n\t\t\t\tG[y].push_back({ y,x,0,int(G[x].size() - 1) });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint x, y;\n\t\t\t\tx = vertex_no(h, w, i, j, 0);\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\ty = vertex_no(h, w, i + dir_x[k], j + dir_y[k], 1);\n\t\t\t\t\tG[x].push_back({ x,y,INF,int(G[y].size()) });\n\t\t\t\t\tG[y].push_back({ y,x,0,int(G[x].size() - 1) });\n\t\t\t\t}\n\t\t\t\ty = x;\n\t\t\t\tx = vertex_no(h, w, i, j, 1);\n\t\t\t\tG[x].push_back({ x,y,1,int(G[y].size()) });\n\t\t\t\tG[y].push_back({ y,x,0,int(G[x].size() - 1) });\n\t\t\t}\n\t\t}\n\t}\n\tlong long flow = 0;\n\tmax_flow(h*w*2 + 1, start, goal, G, flow);\n\tstd::cout << flow << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int inf = 1e9;\nconst int mx = 100005;\nint h, w, dx[] = {0,0,1,-1}, dy[] = {1,-1,0,0};\nchar s[105];\nstruct edge{int t, c, r;};\nvector<edge> G[mx];\nbool used[mx];\n\nvoid add_edge(int f, int t, int c = 1){\n\tG[f].push_back((edge){t,c,(int)G[t].size()});\n\tG[t].push_back((edge){f,0,(int)G[f].size()-1});\n}\n\nvoid connect(int a, int b, int c = 1){\n\tadd_edge(a,b+h*w,c); add_edge(b,a+h*w,c);\n}\n\nint dfs(int v, int t, int f){\n\tif(v == t) return f;\n\tused[v] = true;\n\tfor(auto &it: G[v]) if(!used[it.t] && it.c){\n\t\tint d = dfs(it.t, t, min(f,it.c));\n\t\tif(d){\n\t\t\tit.c -= d;\n\t\t\tG[it.t][it.r].c += d;\n\t\t\treturn d;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t){\n\tint res = 0, f = 1;\n\twhile(f){\n\t\tfill(used,used+mx,0);\n\t\tf = dfs(s,t,inf);\n\t\tres += f;\n\t}\n\treturn res;\n}\n\nint main(){\n\tscanf(\"%d%d\", &h, &w);\n\trep(i,h){\n\t\tscanf(\"%s\", s);\n\t\trep(j,w){\n\t\t\tadd_edge(i*w+j+h*w, i*w+j, 1);\n\t\t\trep(k,4){\n\t\t\t\tint x = i + dx[k], y = j + dy[k];\n\t\t\t\tif(0 <= x && x < h && 0 <= y && y < w) connect(i*w+j, x*w+y);\n\t\t\t\telse if(s[j] == 'X') return 0*puts(\"-1\");\n\t\t\t\telse add_edge(i*w+j, 2*h*w+1, inf);\n\t\t\t}\n\t\t\tif(s[j] == 'X') add_edge(2*h*w, i*w+j, inf);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", max_flow(2*h*w, 2*h*w+1));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"cycle\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e4;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 2e4 + 5;\n\nstruct edge{\n\tint s, to, cap, flow;\n};\n\nstruct graph {\n\t// Number of vertices and edges\n\tint n;\n\t\n\t// Edges\n\tvector<edge> ee;\n\t\n\t// Graph\n\tvi g[MAXN];\n\t\n\t// start, finish\n\tint s, t;\n\t\n\t// Distance for BFS\n\tint dis[MAXN];\n\t\n\t// Queue for BFS\n\tint qq[MAXN];\n\t\n\t// Ptr for DFS\n\tint ptr[MAXN];\n\t\n\t// Adding edge\n\tvoid add_edge(int a, int b, int cap){\t\t\n\t\tedge e1 = { a, b, cap, 0 };\n\t\tedge e2 = { b, a, 0, 0 };\n\t\tg[a].pb(SZ(ee));\n\t\tee.pb(e1);\n\t\tg[b].pb(SZ(ee));\n\t\tee.pb(e2);\n\t}\t\n\t\n\t// BFS for Dinic\n\tbool bfs(){\n\t\t// Init\n\t\tint qh = 0, qt = 0;\n\t\tqq[qt++] = s;\n\t\tREPN(i, 1, n){\n\t\t\tdis[i] = -1;\n\t\t}\n\t\tdis[s] = 0;\n\t\t\n\t\t// Go\n\t\twhile (qh < qt) {\n\t\t\tint v = qq[qh++];\n\t\t\tREP(i, 0, SZ(g[v])){\n\t\t\t\tint ind = g[v][i];\n\t\t\t\tint to = ee[ind].to;\n\t\t\t\tif (dis[to] == -1 && ee[ind].flow < ee[ind].cap) {\n\t\t\t\t\tqq[qt++] = to;\n\t\t\t\t\tdis[to] = dis[v] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn dis[t] != -1;\n\t}\n\t\n\t// DFS for Dinic\n\tint dfs (int v, int cur_flow){\n\t\tif (!cur_flow){\n\t\t\treturn 0;\n\t\t}\n\t\tif (v == t) {\n\t\t\treturn cur_flow;\n\t\t}\n\t\tfor (; ptr[v] < SZ(g[v]); ++ptr[v]) {\n\t\t\tint ind = g[v][ptr[v]];\n\t\t\tint to = ee[ind].to;\n\t\t\tif (dis[to] != dis[v] + 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint pushed = dfs(to, min(cur_flow, ee[ind].cap - ee[ind].flow));\n\t\t\tif (pushed) {\n\t\t\t\tee[ind].flow += pushed;\n\t\t\t\tee[ind ^ 1].flow -= pushed;\n\t\t\t\treturn pushed;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\t// Dinic\n\tint dinic(int _s, int _t) {\n\t\t// Init\n\t\ts = _s, t = _t;\n\t\tREP(i, 0, SZ(ee)){\n\t\t\tee[i].flow = 0;\n\t\t}\n\t\tint result = 0;\n\t\t\n\t\t// Go\n\t\twhile(1) {\t\t\t\n\t\t\tif (!bfs()) { \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREPN(i, 1, n){\n\t\t\t\tptr[i] = 0;\n\t\t\t}\n\t\t\twhile (int pushed = dfs(s, INF)) {\n\t\t\t\tresult += pushed;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n};\n\ngraph gg;\n\nchar c[200][200];\n\nint in[200][200], out[200][200];\n\nvoid solve(){\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tREP(i, 0, n){\n\t\tscanf(\"%s\", &c[i][0]);\n\t}\n\tgg.n = 2 * n * m + 2;\n\tint s = gg.n - 1, f = gg.n;\n\tREP(i, 0, n){\n\t\tREP(j, 0, m){\n\t\t\tin[i][j] = i * m + j + 1;\n\t\t\tout[i][j] = in[i][j] + n * m;\n\t\t}\n\t}\n\tREP(i, 0, n){\n\t\tREP(j, 0, m){\n\t\t\tgg.add_edge(in[i][j], out[i][j], 1);\n\t\t\tif (i > 0){\n\t\t\t\tgg.add_edge(out[i][j], in[i - 1][j], INF);\n\t\t\t} else {\n\t\t\t\tgg.add_edge(out[i][j], f, INF);\n\t\t\t}\n\t\t\tif (i < n - 1){\n\t\t\t\tgg.add_edge(out[i][j], in[i + 1][j], INF);\n\t\t\t} else {\n\t\t\t\tgg.add_edge(out[i][j], f, INF);\n\t\t\t}\n\t\t\tif (j > 0){\n\t\t\t\tgg.add_edge(out[i][j], in[i][j - 1], INF);\n\t\t\t} else {\n\t\t\t\tgg.add_edge(out[i][j], f, INF);\n\t\t\t}\n\t\t\tif (j < m - 1){\n\t\t\t\tgg.add_edge(out[i][j], in[i][j + 1], INF);\n\t\t\t} else {\n\t\t\t\tgg.add_edge(out[i][j], f, INF);\n\t\t\t}\n\t\t\tif (c[i][j] == 'X'){\n\t\t\t\tgg.add_edge(s, out[i][j], INF);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = gg.dinic(s, f);\n\tif (ans >= INF){\n\t\tans = -1;\n\t}\n\tprintf(\"%d\\n\", ans);\n}\t\n\nint main(){\n\n\t//freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n\tint t = 1;\n\t//cin >> t;\n\twhile(t--){\n\t\tsolve();\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\nconst int D_MAX_V=20002;\nconst int D_v_size=20002;\nstruct D_wolf{\n\tint t,c,r;\n\tD_wolf(){t=c=r=0;}\n\tD_wolf(int t1,int c1,int r1){\n\t\tt=t1;c=c1;r=r1;\n\t}\n};\nvector<D_wolf>D_G[D_MAX_V];\nint D_level[D_MAX_V];\nint D_iter[D_MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n\tD_G[from].push_back(D_wolf(to,cap,D_G[to].size()));\n\tD_G[to].push_back(D_wolf(from,0,D_G[from].size()-1));\n}\nvoid D_bfs(int s){\n\tfor(int i=0;i<D_v_size;i++)D_level[i]=-1;\n\tqueue<int> Q;\n\tD_level[s]=0;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<D_G[v].size();i++){\n\t\t\tif(D_G[v][i].c>0&&D_level[D_G[v][i].t]<0){\n\t\t\t\tD_level[D_G[v][i].t]=D_level[v]+1;\n\t\t\t\tQ.push(D_G[v][i].t);\n\t\t\t}\n\t\t}\n\t}\n}\nint D_dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(;D_iter[v]<D_G[v].size();D_iter[v]++){\n\t\tint i=D_iter[v];\n\t\tif(D_G[v][i].c>0&&D_level[v]<D_level[D_G[v][i].t]){\n\t\t\tint d=D_dfs(D_G[v][i].t,t,min(f,D_G[v][i].c));\n\t\t\tif(d>0){\n\t\t\t\tD_G[v][i].c-=d;\n\t\t\t\tD_G[D_G[v][i].t][D_G[v][i].r].c+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tD_bfs(s);\n\t\tif(D_level[t]<0)return flow;\n\t\tfor(int i=0;i<D_v_size;i++)D_iter[i]=0;\n\t\tint f;\n\t\twhile((f=D_dfs(s,t,99999999))>0){flow+=f;}\n\t}\n\treturn 0;\n}\nchar str[200][200];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tint T=9999;\n\tint B=-1000;\n\tint L=9999;\n\tint R=-9999;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\tif(str[i][j]=='X'){\n\t\t\tT=min(T,i);\n\t\t\tB=max(B,i);\n\t\t\tL=min(L,j);\n\t\t\tR=max(R,j);\n\t\t}\n\t}\n\tif(T==0||B==a-1||L==0||R==b-1){\n\t\tprintf(\"-1\\n\");return 0;\n\t}\n\tint s=2*a*b;\n\tint t=2*a*b+1;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\tif(str[i][j]=='X')add_edge(s,(i*b+j)*2+1,99999999);\n\t\telse add_edge((i*b+j)*2,(i*b+j)*2+1,1);\n\t\tif(i)add_edge((i*b+j)*2+1,(i*b+j-b)*2,99999999);\n\t\telse add_edge((i*b+j)*2+1,t,99999999);\n\t\tif(i<a-1)add_edge((i*b+j)*2+1,(i*b+j+b)*2,99999999);\n\t\telse add_edge((i*b+j)*2+1,t,99999999);\n\t\tif(j)add_edge((i*b+j)*2+1,(i*b+j-1)*2,99999999);\n\t\telse add_edge((i*b+j)*2+1,t,99999999);\n\t\tif(j<b-1)add_edge((i*b+j)*2+1,(i*b+j+1)*2,99999999);\n\t\telse add_edge((i*b+j)*2+1,t,99999999);\n\t\t\n\t}\n\tprintf(\"%d\\n\",max_flow(s,t));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, int> P;\n#define rep(i,n) for(int i=0;i<(n);i++)\nconst int INF = 1e9;\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, 1, 0, -1};\n\nint h, w;\nstring s[110];\nbool used[110][110];\n\nint main(void){\n\tcin >> h >> w;\n\trep(i, h) cin >> s[i];\n\trep(i, 110)rep(j, 110) used[i][j] = false;\n\trep(i, h)rep(j, w){\n\t\tif(s[i][j] == 'X'){\n\t\t\trep(k, 4){\n\t\t\t\tint ny = i + dy[k], nx = j + dx[k];\n\t\t\t\tif(!(0 <= ny && ny < h && 0 <= nx && nx < w)){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t// printf(\"%d %d\\n\", ny, nx);\n\t\t\t\tif(s[ny][nx] == '.'){\n\t\t\t\t\ts[ny][nx] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// rep(i, h) cout << s[i] << endl;\n\tint ans = 0;\n\trep(i, h)rep(j, w){\n\t\tif(s[i][j] == '#'){\n\t\t\trep(k, 4){\n\t\t\t\tint ny = i + dy[k], nx = j + dx[k];\n\t\t\t\tif(!(0 <= ny && ny < h && 0 <= nx && nx < w)){\n\t\t\t\t\tans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(!(s[ny][nx] == '#' || s[ny][nx] == 'X')){\n\t\t\t\t\tans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\tif(k == 3){\n\t\t\t\t\tprintf(\"erase %d %d\\n\", i, j);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans - 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\n#define INF (1 << 29)\nusing namespace std;\n\nstruct point{\n    int x, y;\n};\n\nchar f[105][105] = {0};\nbool fb[105][105] = {0};\nint h, w;\nstatic const int dy[4] = {0,1,0,-1};\nstatic const int dx[4] = {1,0,-1,0};\n\nbool CanEscape(){\n    rep(i,h) if(f[i][0] == 'X' || f[i][w - 1] == 'X') return 1;\n    rep(i,w) if(f[0][i] == 'X' || f[h - 1][i] == 'X') return 1;\n    return 0;\n}\n\nvoid check(queue<point> &q){\n    rep(i,h){\n        rep(j,w){\n            if(f[i][j] == 'X'){\n                point p;\n                p.y = i; p.x = j;\n                q.push(p);\n                rep(k,4){\n                    int y = i + dy[k];\n                    int x = j + dx[k];\n                    if(y < 0 || y >= h || x < 0 || x >= w) continue;\n                    if(f[y][x] != 'X') fb[y][x] = 1;\n                }\n            }\n        }\n    }\n}\n\nbool goatCanEscape(int y, int x, bool fence[105][105]){\n    bool isVisited[105][105] = {0};\n    queue<point> q;\n    point start_coordinate;\n    start_coordinate.x = x;\n    start_coordinate.y = y;\n\n    isVisited[start_coordinate.y][start_coordinate.x] = 1;\n    q.push(start_coordinate);\n\n    point u;\n    while(!q.empty()){\n        u = q.front(); q.pop();\n        rep(i,4){\n            point next;\n            next.x = u.x + dx[i];\n            next.y = u.y + dy[i];\n            if(next.y < 0 || next.y >= h || next.x < 0 || next.x >= w) return 1;\n            if(isVisited[next.y][next.x] == 0 && fence[next.y][next.x] == 0){\n                isVisited[next.y][next.x] = 1;\n                q.push(next);\n            }\n        }\n    }\n    return 0;\n}\n\nbool allGoatNotEscape(int y, int x, queue<point> q, bool fence[105][105]){\n    while(not q.empty()){\n        if(goatCanEscape(q.front().y, q.front().x, fence)) return 0;\n        q.pop();\n    }\n    return 1;\n}\n\nvoid deleteUselessFence(queue<point> q, bool fence[105][105]){\n    rep(i,h){\n        rep(j,w){\n            if(fence[i][j] == 1){\n                fence[i][j] = 0;\n                if(not allGoatNotEscape(i, j, q, fence)){\n                    fence[i][j] = 1;\n                }\n            }\n        }\n    }\n}\n\nint oneSide(queue<point> q){\n    bool fence[105][105] = {0};\n    rep(i,h){\n        rep(j,w){\n            if(fb[i][j] == 1){\n                fence[i][j] = 1;\n                break;\n            }\n        }\n    }\n    rep(i,h){\n        for(int j = w - 1; j >= 0; j--){\n            if(fb[i][j] == 1){\n                fence[i][j] = 1;\n                break;\n            }\n        }\n    }\n    rep(i,w){\n        rep(j,h){\n            if(fb[j][i] == 1){\n                fence[j][i] = 1;\n                break;\n            }\n        }\n    }\n    rep(i,w){\n        for(int j = h - 1; j >= 0; j--){\n            if(fb[j][i] == 1){\n                fence[j][i] = 1;\n                break;\n            }\n        }\n    }\n    deleteUselessFence(q, fence);\n    int cnt = 0;\n    rep(i,h){\n        rep(j,w){\n            if(fence[i][j] == 1) cnt++;\n        }\n    }\n    return cnt;\n}\n\nint countFence(){\n    int cnt = 0;\n    rep(i,h){\n        rep(j,w){\n            if(fb[i][j] == 1) cnt++;\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    cin >> h >> w;\n    rep(i,h) cin >> f[i];\n    if(CanEscape()){\n        cout << -1 << endl;\n    }else{\n        queue<point> q;\n        check(q);\n        cout << oneSide(q) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n\nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n\nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n\ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size())mk();\n\t\tif(hit==q.size()<<1)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n\nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n//\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n//\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<20\n#define EPS (1e-6)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef complex<double> P;\n\nbool cmp(P a, P b){\n\tdouble arga = arg(a);\n\tdouble argb = arg(b);\n\tif(!EQ(arga, argb)){\n\t\treturn arga < argb;\n\t} // end if\n\t\n\treturn abs(a) > abs(b);\n}\n\nconst int MAX_H = 105;\nconst int MAX_W = 105;\n\nconst int dy[4] = {-1, 0, 1, 0};\nconst int dx[4] = { 0, 1, 0,-1};\nchar field[MAX_H][MAX_W];\nint d[MAX_H][MAX_W];\nint H, W;\n\nbool bfs(char target, int sy, int sx){\n\tqueue<pair<int,int> > que;\n\trep (i, MAX_H) rep (j, MAX_W) d[i][j] = INF;\n\tque.push(make_pair(sy,sx));\n\td[sy][sx] = 0;\n\t\n\twhile(!que.empty()){\n\t\tpair<int,int> curr = que.front(); que.pop();\n\t\tint cy = curr.first;\n\t\tint cx = curr.second;\n\n\t\t// 領域の外に出た\n\t\tif (cy == 0 || cy == H + 1 || cx == 0 || cx == W + 1){\n\t\t\treturn true;\n\t\t} // end if\n\n\t\trep(k, 4){\n\t\t\tint ny = cy + dy[k];\n\t\t\tint nx = cx + dx[k];\n\t\t\tif (ny < 0 || ny > H + 1 || nx < 0 || nx > W + 1) continue;\n\t\t\t\n\t\t\tif (d[ny][nx] > d[cy][cx] + 1){\n\t\t\t\tif(\n\t\t\t\t\t   ((target == 'O') && (field[ny][nx] == '.'))\n\t\t\t\t\t|| ((target == 'X') && (field[ny][nx] != 'O'))\n\t\t\t\t){\n\t\t\t\t\tque.push(make_pair(ny,nx));\n\t\t\t\t\td[ny][nx] = d[cy][cx] + 1;\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end while\n\n\treturn false;\t\n}\n\n\nvoid disp_field(void){\n\tcerr << endl;\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tcerr << field[i][j];\n\t\t} // end for\n\t\tcerr << endl;\n\t} // end for\n}\n\nint main()\n{\n\tmemset (field, 0, sizeof(field));\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\trep (i, MAX_H) rep (j, MAX_W) field[i][j] = '.';\n\tcin >> H >> W;\n\tvector<string> s(H);\n\trep (i, H) cin >> s[i];\n\n\tset<pair<int,int> > origin; origin.clear();\n\n\tvector<P> p; p.clear();\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tfield[i][j] = s[i-1][j-1];\n\t\t\tif (field[i][j] == 'X'){\n\t\t\t\torigin.insert(make_pair(i,j));\n\t\t\t\tp.push_back(P(i - H / 2., j - W / 2.));\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\tsort (ALL(p),cmp);\n\n\tint m = p.size();\n\trep (i, m){\n\t\tint cy1 = (int)(p[i].imag());\n\t\tint cy2 = (int)(p[(i+1) % m].imag());\n\t\tint cx1 = (int)(p[i].real());\n\t\tint cx2 = (int)(p[(i+1) % m].real());\n\t\tint leny = abs(cy1 - cy2);\n\t\tint lenx = abs(cx1 - cx2);\n\n\t\tint cnt = 0;\n\t\tif (leny > lenx){\n\t\t\tfor (int y = cy1; (cy1 <= cy2 ? y < cy2 : y > cy2); y += (cy1 <= cy2 ? +1 : -1), ++cnt);\n\t\t\tfor (int dy = 1; dy < cnt; ++dy){\n\t\t\t\tint dx = ((cx2 - cx1) / cnt) * dy;\n\t\t\t\tint ny = cy1 + dy * (cy1 <= cy2 ? +1 : -1) + H / 2;\n\t\t\t\tint nx = cx1 + dx + W / 2;\n\t\t\t\tfield[ny][nx] = 'x';\n\t\t\t} // end rep\n\t\t}else{\t// if (leny <= lenx)\n\t\t\tfor (int x = cx1; (cx1 <= cx2 ? x < cx2 : x > cx2); x += (cx1 <= cx2 ? +1 : -1), ++cnt);\n\t\t\tfor (int dx = 1; dx < cnt; ++dx){\n\t\t\t\tint dy = ((cy2 - cy1) / cnt) * dx;\n\t\t\t\tint ny = cy1 + dy + H / 2;\n\t\t\t\tint nx = cx1 + dx * (cx1 <= cx2 ? +1 : -1) + W / 2;\n\t\t\t\tfield[ny][nx] = 'x';\n \t\t\t} // end rep\n\t\t} // end if\n\t} // end rep\n\n\t// 現実羊の周りに壁を作る\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tif (field[i][j] == 'X'){\n\t\t\t\trep (k, 4){\n\t\t\t\t\tint ny = i + dy[k];\n\t\t\t\t\tint nx = j + dx[k];\n\t\t\t\t\tif (ny <= 0 || ny >= H + 1 || nx <= 0 || nx >= W + 1) continue;\n\t\t\t\t\tif (field[ny][nx] == 'X') continue;\n\t\t\t\t\tfield[ny][nx] = 'O';\n\t\t\t\t} // end rep\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end rep\n\n//\tdisp_field();\n\n\t// 仮想羊の周りに壁を作る\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tif (field[i][j] == 'x'){\n\t\t\t\trep (k, 4){\n\t\t\t\t\tint ny = i + dy[k];\n\t\t\t\t\tint nx = j + dx[k];\n\t\t\t\t\tif (ny <= 0 || ny >= H + 1 || nx <= 0 || nx >= W + 1) continue;\n\t\t\t\t\tif (field[ny][nx] != '.') continue;\n\t\t\t\t\tfield[ny][nx] = 'O';\n\t\t\t\t} // end rep\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end rep\n\n//\tdisp_field();\n\n\t// 仮想羊を元に戻す\n\tfor (int i = 1; i <= H; ++i)\n\t\tfor (int j = 1; j <= W; ++j)\n\t\t\tif (field[i][j] == 'x') field[i][j] = '.';\n\t\n\t// 壁に囲まれた壁が脱出できるか？\n\tbool escape = false;\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tif (field[i][j] == 'O'){\n\t\t\t\tbool curr = bfs(field[i][j], i, j);\n\t\t\t\tif (!curr) field[i][j] = '.';\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n//\tdisp_field();\n\n\t// 現実羊は脱出出来るか？\n\tescape = false;\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tif (field[i][j] == 'X'){\n\t\t\t\tbool curr = bfs(field[i][j], i, j);\n\t\t\t\tif (curr) escape |= true;\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\tint res = 0;\n\tif (escape){\n\t\tres = -1;\n\t}else{\n\t\tfor (int i = 1; i <= H; ++i){\n\t\t\tfor (int j = 1; j <= W; ++j){\n\t\t\t\tres += (int)(field[i][j] == 'O');\n\t\t\t} // end for\n\t\t} // end for\n\t} // end if\n\tcout << res << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T> using Graph = vector<vector<T>>;\n\n#define REP(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (__typeof(a.begin()) x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define endl '\\n'\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint H, W;\nstring S[105];\n\nbool is_inside(int x, int y) {\n  return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nint solve() {\n  rep(i, W) if (S[0][i] == 'X' || S[H - 1][i] == 'X') return -1;\n  rep(i, H) if (S[i][0] == 'X' || S[i][W - 1] == 'X') return -1;\n\n  int ans = 0;\n  rep(y, H) rep(x, W) {\n    if (S[y][x] != 'X') continue;\n    rep(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (!is_inside(nx, ny)) continue;\n      if (S[ny][nx] == '.') {\n        S[ny][nx] = '#';\n        ans += 1;\n      }\n    }\n  }\n\n  rep(y, H) rep(x, W) {\n    if (S[y][x] != '#') continue;\n    bool remove = true;\n    rep(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (!is_inside(nx, ny) || S[ny][nx] == '.') remove = false;\n    }\n    if (remove) ans -= 1;\n  }\n\n  return ans;\n}\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> H >> W;\n  rep(i, H) cin >> S[i];\n\n  cout << solve() << endl;\n  //rep(i, H) cout << S[i] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint PREP = (cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(9), 0);\n//int SEGV = getenv(\"D\") || (exit(system(\"D= SEGFAULT_SIGNALS=all catchsegv ./prog.exe\") >> 8), 0);\nconst int INF = 1e8;\nstruct MaximumFlow {\n    vector<vector<int>> G, cap;\n    vector<int> visited;\n    MaximumFlow(int n) {\n        G.resize(n);\n        cap.resize(n, vector<int>(n));\n        visited.resize(n);\n    }\n    void add_edge(int s, int t, int c) {\n        G[s].push_back(t);\n        G[t].push_back(s);\n        cap[s][t] += c;\n    }\n    int dfs(int s, int t, int c) {\n        visited[s] = 1;\n        if (s == t) return c;\n        for (int n : G[s]) {\n            if (visited[n]) continue;\n            if (cap[s][n] == 0) continue;\n            int ret = dfs(n, t, min(c, cap[s][n]));\n            if (ret > 0) {\n                cap[s][n] -= ret;\n                cap[n][s] += ret;\n                return ret;\n            }\n        }\n        return 0;\n    }\n    int max_flow(int s, int t) {\n        int ans = 0;\n        for (;;) {\n            fill(begin(visited), end(visited), 0);\n            int f = dfs(s, t, INF);\n            if (f == 0) break;\n            ans += f;\n        }\n        return ans;\n    }\n};\nint main() {\n    int H, W; cin >> H >> W;\n    vector<string> S(H); for (auto &s : S) cin >> s;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (S[i][j] == 'X' && (i == 0 || i == H - 1 || j == 0 || j == W - 1)) {\n                cout << -1 << '\\n';\n                return 0;\n            }\n        }\n    }\n    MaximumFlow mf(2 * (H + 2) * (W + 2) + 2);\n    auto idx = [&](int i, int j, int k) { return (i * (W + 2) + j) * 2 + k; };\n    int s = 2 * (H + 2) * (W + 2), t = 2 * (H + 2) * (W + 2) + 1;\n    for (int i = 0; i < H + 2; i++) {\n        for (int j = 0; j < W + 2; j++) {\n            mf.add_edge(idx(i, j, 0), idx(i, j, 1), 1);\n            if (1 <= i && i <= H && 1 <= j && j <= W && S[i-1][j-1] == 'X') {\n                mf.add_edge(s, idx(i, j, 1), INF);\n            }\n            if (i + 1 < H + 2) {\n                mf.add_edge(idx(i + 1, j, 1), idx(i, j, 0), INF);\n                mf.add_edge(idx(i, j, 1), idx(i + 1, j, 0), INF);\n            }\n            if (j + 1 < W + 2) {\n                mf.add_edge(idx(i, j + 1, 1), idx(i, j, 0), INF);\n                mf.add_edge(idx(i, j, 1), idx(i, j + 1, 0), INF);\n            }\n            if (i == 0 || j == 0 || i == H + 1 || j == W + 1) {\n                mf.add_edge(idx(i, j, 0), t, INF);\n            }\n        }\n    }\n    cout << mf.max_flow(s, t) << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\ntypedef long long ll;\n\nll dy[] = {1,0,0,-1};\nll dx[] = {0,-1,1,0};\n\n\nstruct edge {\n    ll to;\n    ll cap;\n    ll rev;\n};\n\n#define MAX_V 30000\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(ll from,ll to,ll cap) {\n    G[from].push_back((edge){to,cap,(ll)G[to].size()});\n    G[to].push_back((edge){from,0,(ll)G[from].size() - 1});\n}\n\nll dfs(ll v,ll t,ll f) {\n    if(v == t)return f;\n    used[v] = true;\n    for(auto &e : G[v]) {\n        if(!used[e.to] && e.cap>0) {\n            ll d = dfs(e.to,t,min(f,e.cap));\n            if(d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nll max_flow(ll s,ll t) {\n    ll flow = 0;\n    for(;;) {\n        fill(used,used+MAX_V,false);\n        ll f = dfs(s,t,1e18);\n        if(f == 0)break;\n        flow += f;\n    }\n    return flow;\n}\nll h,w;\nchar S[200][200];\n\nll id(ll i,ll j) {\n    return i * w + j;\n}\n \nint main() {\n    cin >> h >> w;\n    rep(i,h)cin >> S[i];\n    rep(i,h)rep(j,w) {\n        rep(k,4) {\n            ll y = dy[k] + i;\n            ll x = dx[k] + j;\n\n            if(y >= 0 && y < h && x >= 0 && x < w) {\n                add_edge(id(i,j) + h * w,id(y,x),1e18);\n            }\n        }\n    }\n\n    ll s = h * w * 2;\n    ll t = h * w * 2 + 1;\n\n    rep(i,h)rep(j,w) {\n        if(S[i][j] == 'X') {\n            add_edge(s,id(i,j),1e18);\n            add_edge(id(i,j),id(i,j) + h * w,1e18);\n        }else {\n            add_edge(id(i,j),id(i,j) + h * w,1);\n        }\n    }\n\n    rep(i,h)rep(j,w) {\n        if(i == 0 || i == h - 1 || j == 0 || j == w - 1) {\n            if(S[i][j] == 'X') {\n                cout << -1 << endl;\n                return 0;\n            }\n            add_edge(id(i,j) + h * w,t,1e18);\n        }\n    }\n\n    cout << max_flow(s,t) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\n#define INF (1 << 29)\nusing namespace std;\n\nstruct point{\n    int x, y;\n};\n\nchar f[105][105] = {0};\nbool fb[105][105] = {0};\nint h, w;\nstatic const int dy[4] = {0,1,0,-1};\nstatic const int dx[4] = {1,0,-1,0};\n\nbool CanEscape(){\n    rep(i,h) if(f[i][0] == 'X' || f[i][w - 1] == 'X') return 1;\n    rep(i,w) if(f[0][i] == 'X' || f[h - 1][i] == 'X') return 1;\n    return 0;\n}\n\nvoid check(queue<point> &q){\n    rep(i,h){\n        rep(j,w){\n            if(f[i][j] == 'X'){\n                point p;\n                p.y = i; p.x = j;\n                q.push(p);\n                rep(k,4){\n                    int y = i + dy[k];\n                    int x = j + dx[k];\n                    if(y < 0 || y >= h || x < 0 || x >= w) continue;\n                    if(f[y][x] != 'X') fb[y][x] = 1;\n                }\n            }\n        }\n    }\n}\n\nbool goatCanEscape(int y, int x){\n    bool isVisited[105][105] = {0};\n    queue<point> q;\n    point start_coordinate;\n    start_coordinate.x = x;\n    start_coordinate.y = y;\n\n    isVisited[start_coordinate.y][start_coordinate.x] = 1;\n    q.push(start_coordinate);\n\n    point u;\n    while(!q.empty()){\n        u = q.front(); q.pop();\n        rep(i,4){\n            point next;\n            next.x = u.x + dx[i];\n            next.y = u.y + dy[i];\n            if(next.y < 0 || next.y >= h || next.x < 0 || next.x >= w) return 1;\n            if(isVisited[next.y][next.x] == 0 && fb[next.y][next.x] == 0){\n                isVisited[next.y][next.x] = 1;\n                q.push(next);\n            }\n        }\n    }\n    return 0;\n}\n\nbool allGoatNotEscape(int y, int x, queue<point> q){\n    while(not q.empty()){\n        if(goatCanEscape(q.front().y, q.front().x)) return 0;\n        q.pop();\n    }\n    return 1;\n}\n\nvoid deleteUselessFence(queue<point> q){\n    int k = 5;\n    while(k--){\n        rep(i,h){\n            rep(j,w){\n                if(fb[i][j] == 1 && f[i][j] != 'X'){\n                    fb[i][j] = 0;\n                    if(not allGoatNotEscape(i, j, q)){\n                        fb[i][j] = 1;\n                    }\n                }\n            }\n        }\n    }\n}\n\nint countFence(){\n    int cnt = 0;\n    rep(i,h){\n        rep(j,w){\n            if(fb[i][j] == 1) cnt++;\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    cin >> h >> w;\n    rep(i,h) cin >> f[i];\n    if(CanEscape()){\n        cout << -1 << endl;\n    }else{\n        queue<point> q;\n        check(q);\n        deleteUselessFence(q);\n        cout << countFence() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define for(i, a, b) for(ll (i)=a;(i)<(b);++(i))\n#define rep(i, n)    for(i, 0, n)\n#define MAX_V        20004\n\nconst ll inf = 1e15;\nconst ll mod = 1e9+7;\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nstruct edge {\n    ll to, cap, rev;\n    edge(ll t, ll c, ll r): to(t), cap(c), rev(r){}\n};\n\nvector<edge> G[MAX_V];\nll level[MAX_V];\nll iter[MAX_V];\n\nvoid add_edge(ll from, ll to, ll cap) {\n    G[from].push_back(edge(to, cap, G[to].size()));\n    G[to].push_back(edge(from, 0, G[from].size() - 1));\n}\n\nvoid bfs(ll s) {\n    memset(level, -1, sizeof(level));\n    queue<ll> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n        ll v = que.front(); que.pop();\n        rep(i, G[v].size()) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nll dfs(ll v, ll t, ll f) {\n    if (v == t) return f;\n    for(i, iter[v], G[v].size()) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[v] < level[e.to]) {\n            ll d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nll max_flow(ll s, ll t) {\n    ll flow = 0;\n    while (true) {\n        bfs(s);\n        if (level[t] < 0) return flow;\n        memset(iter, 0, sizeof(iter));\n        ll f;\n        while ((f = dfs(s, t, inf)) > 0) {\n            flow += f;\n        }\n    }\n}\n\nint main() {\n    ll H, W; cin >> H >> W;\n    \n    ll S = 2 * H * W;\n    ll T = 2 * H * W + 1;\n    rep(i, H) rep(j, W) {\n        char c; cin >> c;\n        if (c == 'X' && (i == 0 || i == H-1 || j == 0 || j == W-1)) {\n            cout << -1 << endl;\n            return 0;\n        }\n        \n        if (c == 'X') add_edge(S, i * W + j, inf);\n        add_edge(i * W + j, H * W + i * W + j, c == 'X' ? inf : 1);\n        \n        if (i == 0 || i == H-1 || j == 0 || j == W-1) add_edge(H * W + i * W + j, T, inf);\n        rep(k, 4) {\n            if (i+dy[k] < 0 || H-1 < i+dy[k] || j+dx[k] < 0 || W-1 < j+dx[k]) continue;\n            add_edge(H * W + i * W + j, (i+dy[k]) * W + (j+dx[k]), inf);\n        }\n    }\n    cout << max_flow(S, T) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint W,H;\nstring S[100];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint grid[114][114];\nvoid end()\n{\n\tprintf(\"-1\\n\");\n}\nint main()\n{\n\tscanf(\"%d%d\",&H,&W);\n\tfor(int i=0;i<H;i++){\n\t\tcin >> S[i];\n\t\tfor(int j=0;j<W;j++){\n\t\t\tif(S[i][j]=='.')grid[i][j]=0;\n\t\t\telse grid[i][j]=1;\n\t\t}\n\t}\n\tfor(int i=0;i<H;i++){\n\t\tif(grid[i][0]==1){\n\t\t\tend();return 0;\n\t\t}\n\t\tif(grid[i][W-1]==1){\n\t\t\tend();return 0;\n\t\t}\n\t}\n\tfor(int i=0;i<W;i++){\n\t\tif(grid[0][i]==1){\n\t\t\tend();return 0;\n\t\t}\n\t\tif(grid[H-1][i]==1){\n\t\t\tend();return 0;\n\t\t}\n\t}\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tif(grid[i][j]==1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(grid[i+dx[k]][j+dy[k]]==0){\n\t\t\t\t\t\tgrid[i+dx[k]][j+dy[k]]=2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tif(grid[i][j]==2){\n\t\t\t\tbool F=false;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(i+dx[k]<0||i+dx[k]>=H||j+dy[k]<0||j+dy[k]>=H)F=true;\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(grid[i+dx[k]][j+dy[k]]==0)F=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(F)ans++;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n\nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n\nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n\ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size())mk();\n\t\tif(hit==q.size()<<1)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n\nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n//\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n//\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n#include <ciso646>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> T;\ntypedef vector<ll> vec;\n\ninline bool check(ll x, ll y, ll xMax, ll yMax) { return x >= 0 && y >= 0 && xMax > x && yMax > y; }\ninline int toint(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string tostring(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\ntemplate<class T> inline T mypow(T x, ll n) { T res = 1; while (n > 0) { if (n & 1)res = res * x;\tx = x * x;\tn >>= 1; }return res; }\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\n#define For(i,a,b)\tfor(ll (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define rFor(i,a,b)\tfor(ll (i) = (a-1);i >= (b);(i)--)\n#define rrep(i,n)\trFor(i,n,0)\n#define each(i,n)\tfor(auto &i : n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define sz(a)\t\t(sizeof(a))\n#define tostr(a)\ttostring(a)\n#define dump(val) \tcerr << #val \" = \" << val << endl;\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nconst ll dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 }, dy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1e17 + 9;\n\n#define int ll\n#define double ld\n\nsigned main() {\n\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> s(h);\n\trep(i, h) {\n\t\tcin >> s[i];\n\t}\n\trep(y, h)rep(x, w) {\n\t\tif (s[y][x] == 'X' && (!y || !x || y == h-1 || x == w-1)) {\n\t\t\tcout << -1 << endl; return 0;\n\t\t}\n\t\tif (s[y][x] == 'X') {\n\t\t\trep(dir, 4) {\n\t\t\t\tint tx = x + dx[dir], ty = y + dy[dir];\n\t\t\t\tif (check(tx, ty, w, h) && s[ty][tx] != 'X') {\n\t\t\t\t\ts[ty][tx] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<P> rm;\n\trep(y, h)rep(x, w) {\n\t\tif (s[y][x] == '#') {\n\t\t\tbool ok = false;\n\t\t\trep(dir, 4) {\n\t\t\t\tint tx = x + dx[dir], ty = y + dy[dir];\n\t\t\t\tif (check(tx, ty, w, h)) {\n\t\t\t\t\tif (s[ty][tx] == '.')ok = true;\n\t\t\t\t}\n\t\t\t\telse ok = true;\n\t\t\t}\n\t\t\tif (ok == false) {\n\t\t\t\trm.push_back(P(y, x));\n\t\t\t}\n\t\t}\n\t}\n\teach(p, rm) {\n\t\ts[p.first][p.second] = '.';\n\t}\n\n\trep(y, h) {\n\t\tcerr << s[y] << endl;\n\t}\n\n\tint ans = 0;\n\trep(y, h)rep(x, w) {\n\t\tif (s[y][x] == '#')ans++;\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr,Vpr> PQ;\nconst int INF=1<<30;\nstruct Edge{\npublic:\n\tint to,cost,cp;\n\tEdge *rev;\n\tEdge(){to=0;cost=0;cp=0;}\n\tEdge(int t,int c,int cp):to(t),cost(c),cp(cp){\n\t\trev= new Edge();\n\t}\n\tvoid add(int x){\n\t\tcp+=x;\n\t}\n\tvoid flow(int amount){\n\t\tadd(-amount);\n\t\trev->add(amount);\n\t}\n\tbool usable(){\n\t\treturn cp>=1;\n\t}\t\n};\nvoid unite(Edge &a,Edge &b){\n\ta.rev=&b;\n\tb.rev=&a;\n}\nclass Graph{\n\tint nodeSize,edgeSize;\n\tvector<int> dist;\n\tvector<vector<Edge> > edges;\npublic: \n\tvoid add(int a,int b,int cost,int cp){\n\t\tedges[a].PB(Edge(b,cost,cp));\n\t\tedges[b].PB(Edge(a,cost,0));\n\t\tunite(edges[a].back(),edges[b].back());\n\t}\n\tGraph(){}\n\tGraph(int x):nodeSize(x){\n\t\t\n\t\tedges=vector<vector<Edge> >(nodeSize);\n\t\tdist=VI(nodeSize);\n\t}\n\tvoid distInit(int s){\n\t\tREP(i,nodeSize){\n\t\t\tdist[i]=INF;\n\t\t}\n\t\n\t\tdist[s]=0;\n\t}\n\tint searching(int now,int e,int capacity){\n\t\tif(capacity==0) return 0;\n\t\tif(now==e) return capacity;\n\t\tif(dist[now]>=dist[e]) return 0;\n\t\tint flowed=0;\n\t\tREP(i,edges[now].size()){\n\t\t\tEdge *ed= &edges[now][i];\n\t\t\tif(!ed->usable()) continue;\n\t\t\tif(dist[now]+1 != dist[ed->to]) continue;\n\t\t\tint nflow=searching(ed->to,e,min(capacity-flowed,ed->cp));\n\t\t\tif(nflow){\n\t\t\t\tflowed+=nflow;\n\t\t\t\ted->flow(nflow);\n\t\t\t}\n\t\t\t\n\t\t\t//if(flowed) return flowed;\n\t\t}\n\t\treturn flowed;\n\t}\n\tbool bfs(int s,int e){\n\t\tdistInit(s);\n\t\tqueue<int> qu;\n\t\tqu.push(s);\n\t\twhile(!qu.empty()){\n\t\t\tint now=qu.front();\n\t\t\tif(now==e) return true;\n\t\t\tqu.pop();\n\t\t\tREP(i,edges[now].size()){\n\t\t\t\tEdge *ed= &edges[now][i];\n\t\t\t\tif(!ed->usable()) continue;\n\t\t\t\tif(dist[ed->to]==INF){\n\t\t\t\t\tqu.push(ed->to);\n\t\t\t\t\tdist[ed->to]=dist[now]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint maximumFlow(int s,int e){\n\t\tint ans=0;\n\t\twhile(bfs(s,e)){\n\t\t\tans+=searching(s,e,INF);\n\t\t}\n\t\treturn ans;\n\t}\n};\nconst int SIZE=101;\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\nint H,W;\nint maps[SIZE][SIZE];\nGraph graph;\nint conv(int a,int b,int c){return a*W+b+H*W*c+2;}\nbool isSafe(int y,int x){\n\treturn 0<=y && y<H && 0<=x && x<W;\n}\nint main(){\n\tcin >> H >> W;\n\tgraph=Graph(SIZE*SIZE*3+3);\n\tREP(i,H) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,s.size()){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(maps[i][j] &&(i==0 || j==0 || i==H-1 || j==W-1)){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t//\t\tcout << maps[i][j];\n\t\t}\t\t\n//\t\tcout << endl;\n\t}\n\tREP(i,H) REP(j,W) {\n\t\tgraph.add(conv(i,j,1),conv(i,j,0),0,1);\n//\t\tedges[conv(i,j,1)].PB(edge(conv(i,j,0),0,1));\n\t\tif(maps[i][j]){\n\t\t\t//edges[0].PB(edge(conv(i,j,1),0,1));\n\t\t\tgraph.add(0,conv(i,j,0),0,4);\n\t\t}\n\t\tREP(k,4){\n\t\t\tif(!isSafe(i+dy[k],j+dx[k])){\n\t\t\tgraph.add(conv(i,j,0),1,0,1);\n\t\t\t//\tedges[conv(i,j,0)].PB(edge(1,0,1));\n\t\t\t} \n\t\t\telse{\n\t\t\t\tgraph.add(conv(i,j,0),conv(i+dy[k],j+dx[k],1),0,1);\n\t\t\t\tgraph.add(conv(i+dy[k],j+dx[k],0),conv(i,j,1),0,1);\n//\t\t\t\tedges[conv(i,j,0)].PB(edge(conv(i+dy[k],j+dx[k],1),0,1));\n//\t\t\t\tedges[conv(i+dy[k],j+dx[k],0)].PB(edge(conv(i,j,1),0,1));\n\t\t\t}\n\t\t}\n\t\n\t}\n\tcout << graph.maximumFlow(0,1) << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define be(v) (v).begin(),(v).end()\n#define pb(q) push_back(q)\ntypedef long long ll;\nusing namespace std;\nconst ll mod=1000000007, INF=mod*mod*3LL;\n#define doublecout(a) cout<<fixed<<setprecision(10)<<a<<endl;\n\ntemplate<class FLOWTYPE> struct Edge {\n    int rev, from, to;\n    FLOWTYPE cap, icap;\n    Edge(int r, int f, int t, FLOWTYPE c) : rev(r), from(f), to(t), cap(c), icap(c) {}\n    friend ostream& operator << (ostream& s, const Edge& E) {\n        if (E.cap > 0) return s << E.from << \"->\" << E.to << '(' << E.cap << ')';\n        else return s;\n    }\n};\n \n// graph class (for network-flow)\ntemplate<class FLOWTYPE> struct Graph {\n    vector<vector<Edge<FLOWTYPE> > > list;\n    \n    Graph(int n = 0) : list(n) { }\n    void init(int n = 0) { list.clear(); list.resize(n); }\n    void reset() { for (int i = 0; i < (int)list.size(); ++i) for (int j = 0; j < list[i].size(); ++j) list[i][j].cap = list[i][j].icap; }\n    inline vector<Edge<FLOWTYPE> >& operator [] (int i) { return list[i]; }\n    inline const size_t size() const { return list.size(); }\n    \n    inline Edge<FLOWTYPE> &redge(Edge<FLOWTYPE> e) {\n        if (e.from != e.to) return list[e.to][e.rev];\n        else return list[e.to][e.rev + 1];\n    }\n    \n    void addedge(int from, int to, FLOWTYPE cap) {\n        list[from].push_back(Edge<FLOWTYPE>((int)list[to].size(), from, to, cap));\n        list[to].push_back(Edge<FLOWTYPE>((int)list[from].size() - 1, to, from, 0));\n    }\n    \n    void add_undirected_edge(int from, int to, FLOWTYPE cap) {\n        list[from].push_back(Edge<FLOWTYPE>((int)list[to].size(), from, to, cap));\n        list[to].push_back(Edge<FLOWTYPE>((int)list[from].size() - 1, to, from, cap));\n    }\n \n    /* \n    // debug\n    friend ostream& operator << (ostream& s, const Graph& G) {\n        s << endl; for (int i = 0; i < G.size(); ++i) { s << i << \" : \" << G.list[i] << endl; }return s;\n    }\n    */\n};\n \ntemplate<class FLOWTYPE> struct Dinic {\n    const FLOWTYPE INF = 1<<30; // to be set\n    vector<int> level, iter;\n \n    Dinic() { }\n    void dibfs(Graph<FLOWTYPE> &G, int s) {\n        level.assign((int)G.size(), -1);\n        level[s] = 0;\n        queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            for (int i = 0; i < G[v].size(); ++i) {\n                Edge<FLOWTYPE> &e = G[v][i];\n                if (level[e.to] < 0 && e.cap > 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n    \n    FLOWTYPE didfs(Graph<FLOWTYPE> &G, int v, int t, FLOWTYPE f) {\n        if (v == t) return f;\n        for (int &i = iter[v]; i < G[v].size(); ++i) {\n            Edge<FLOWTYPE> &e = G[v][i], &re = G.redge(e);\n            if (level[v] < level[e.to] && e.cap > 0) {\n                FLOWTYPE d = didfs(G, e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    re.cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    \n    FLOWTYPE solve(Graph<FLOWTYPE> &G, int s, int t) {\n        level.assign((int)G.size(), -1); iter.assign((int)G.size(), 0);\n        FLOWTYPE res = 0;\n        while (true) {\n            dibfs(G, s);\n            if (level[t] < 0) return res;\n            for (int i = 0; i < (int)iter.size(); ++i) iter[i] = 0;\n            FLOWTYPE flow = 0;\n            while ((flow = didfs(G, s, t, INF)) > 0) {\n                res += flow;\n            }\n        }\n    }\n};\n \n \n \nint main() {\n    cin.tie(0);\n    cout.tie(0);\n    ios::sync_with_stdio(false);\n    int h,w; \n    cin >> h >> w;\n    string s[h];\n    int a=h+w,b=a+1,inf=10000;\n    Graph<int> G(h+w+2);//i+w,j\n    for(int i=0;i<h;i++){\n    \tcin >> s[i];\n    \tfor(int j=0;j<w;j++){\n    \t\tif(s[i][j] == 'X'){\n    \t\t\tG.addedge(a,i+w,inf);\n    \t\t\tG.addedge(a,j,inf);\n    \t\t}\n    \t}\n    }\n    //////\n    for(int i=1;i<h;i++){\n    \tG.addedge(w+i,w+i-1,1);\n    \tG.addedge(w+i-1,w+i,1);\n    }\n    for(int i=1;i<w;i++){\n    \tG.addedge(i,i-1,1);\n    \tG.addedge(i-1,i,1);\n    }\n\n    G.addedge(w,b,inf);\n    G.addedge(h-1+w,b,inf);\n    G.addedge(0,b,inf);\n    G.addedge(w-1,b,inf);\n    Dinic<int> di;\n    cout << di.solve(G,a,b) <<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105];\nbool fr[105][105],vis[105][105],st,ad,f;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = f = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = f = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstring>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#include <cstdio>\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#include <set>\n\nusing namespace std;\n\nchar g[128][128];\nint d[128][128];\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\nint main(){\n  const int h = getInt();\n  const int w = getInt();\n  REP(i,h) scanf(\"%s\", g[i]);\n\n  bool ok = true;\n  REP(i,h) REP(j,w) if(g[i][j] == 'X'){\n    if(i == 0 || i == h - 1 || j == 0 || j == w - 1) ok = false;\n\n    REP(k,4) {\n      const int x = j + _dx[k];\n      const int y = i + _dy[k];\n      if(g[y][x] != 'X') g[y][x] = '#';\n    }\n  }\n\n  if(!ok) {\n    puts(\"-1\");\n    return 0;\n  }\n\n  memset(d, -1, sizeof(d));\n\n  queue<pair<int, int> > q;\n  REP(i,h) {\n    q.push(make_pair(0, i));\n    d[i][0] = 0;\n    q.push(make_pair(w - 1, i));\n    d[i][w - 1] = 0;\n  }\n  REP(j,w) {\n    if(j != 0 && j != w - 1){\n      q.push(make_pair(j, 0));\n      d[0][j] = 0;\n      q.push(make_pair(j, h - 1));\n      d[h - 1][j] = 0;\n    }\n  }\n\n  while (q.size()) {\n    const pair<int, int> d = q.front(); q.pop();\n    const int x = d.first;\n    const int y = d.second;\n\n    if(g[y][x] != '#') {\n      REP(k,4) {\n        const int xx = x + _dx[k];\n        const int yy = y + _dy[k];\n        if(ISIN(xx, yy, w, h) && ::d[yy][xx] == -1) {\n          ::d[yy][xx] = ::d[y][x] + 1;\n          q.push(make_pair(xx, yy));\n        }\n      }\n    }\n  }\n\n  int ans = 0;\n  REP(i,h) REP(j,w){\n    if(g[i][j] == '#' && d[i][j] != -1) ans++;\n  }\n\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105];\nbool fr[105][105],vis[105][105],st,ad,f;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0, f = 1;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0, f = 1;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nchar a[101][101];\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\nint h, w; \nconst int INF = 1000000;\n\nbool isvalid(int x, int y)\n{\n\tif(x>=0&&x<h&&y>=0&&y<w) return true;\n\telse return false;\n}\n\ntemplate<int MX, ll INF> struct MaxFlow //by yutaka1999, have to define INF and MX (the Max number of vertices)\n{\n\tstruct edge\n\t{\n\t\tint to,cap,rev;\n\t\tedge(int to=0,int cap=0,int rev=0):to(to),cap(cap),rev(rev){}\n\t};\n\tvector <edge> vec[MX];\n\tint level[MX];\n\tint iter[MX];\n\t\n\tvoid addedge(int s,int t,int c) //adds an edge of cap c to the flow graph\n\t{\n\t\tint S=vec[s].size(),T=vec[t].size();\n\t\tvec[s].push_back(edge(t,c,T));\n\t\tvec[t].push_back(edge(s,0,S));\n\t}\n\tvoid bfs(int s)\n\t{\n\t\tmemset(level,-1,sizeof(level));\n\t\tqueue <int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<vec[v].size();i++)\n\t\t\t{\n\t\t\t\tedge&e=vec[v][i];\n\t\t\t\tif (e.cap>0&&level[e.to]<0)\n\t\t\t\t{\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll flow_dfs(int v,int t,ll f)\n\t{\n\t\tif (v==t) return f;\n\t\tfor(int &i=iter[v];i<vec[v].size();i++)\n\t\t{\n\t\t\tedge &e=vec[v][i];\n\t\t\tif (e.cap>0&&level[v]<level[e.to])\n\t\t\t{\n\t\t\t\tll d=flow_dfs(e.to,t,min(f,ll(e.cap)));\n\t\t\t\tif (d>0)\n\t\t\t\t{\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tvec[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tll maxflow(int s,int t) //finds max flow using dinic from s to t\n\t{\n\t\tll flow = 0;\n\t\twhile(1)\n\t\t{\n\t\t\tbfs(s);\n\t\t\tif (level[t]<0) return flow;\n\t\t\tmemset(iter,0,sizeof(iter));\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tll f=flow_dfs(s,t,1000000007);\n\t\t\t\tif(f==0) break;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nMaxFlow<20021,100001> mf;\n\nint in(int x, int y)\n{\n\treturn (w*x + y)*2+1;\n}\n\nint out(int x, int y)\n{\n\treturn (w*x+y)*2+2;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin >> h >> w;\n\tint s = 0; int e = out(h-1,w-1)+1;\n\tfor(int i = 0; i < h; i++)\n\t{\n\t\tfor(int j = 0; j < w; j++)\n\t\t{\n\t\t\t//cerr<<in(i,j)<<' '<<out(i,j)<<'\\n';\n\t\t\tcin >> a[i][j];\n\t\t\tif(a[i][j]=='X')\n\t\t\t{\n\t\t\t\tmf.addedge(in(i,j),out(i,j),INF);\n\t\t\t\tmf.addedge(out(i,j),e,INF);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmf.addedge(in(i,j),out(i,j),1);\n\t\t\t}\n\t\t\tif(i == 0 || i == h - 1 || j == 0 || j == w - 1)\n\t\t\t{\n\t\t\t\tif(a[i][j] == 'X'){cout << -1 << '\\n'; return 0;}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < h; i++)\n\t{\n\t\tfor(int j = 0; j < w; j++)\n\t\t{\n\t\t\tfor(int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tint x = i+dx[k]; int y = j+dy[k];\n\t\t\t\tif(isvalid(x,y))\n\t\t\t\t{\n\t\t\t\t\tmf.addedge(out(i,j),in(x,y),INF);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmf.addedge(s, in(i,j), INF);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<mf.maxflow(s,e);\n}\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst int N = 100;\nstring s[N + 5];\nint mark[N + 5][N + 5];\nint red[N + 5][N + 5];\n\nint py[] = {1,0,-1,0};\nint px[] = {0,1,0,-1};\n\nvoid hora(int tc) {\n\tint r,c;\n\tcin>>r>>c;\n\tfor(int i = 0;i < r;i++) cin>>s[i];\n\tfor(int i = 0;i < r;i++){\n\t\tif(s[i][0] == 'X' || s[i][c - 1] == 'X') {\n\t\t\tcout<<\"-1\"<<endl;\n\t\t\treturn ;\n\t\t}\n\t}\n\tfor(int i = 0;i < c;i++){\n\t\tif(s[0][i] == 'X' || s[r - 1][c] == 'X') {\n\t\t\tcout<<\"-1\"<<endl;\n\t\t\treturn ;\n\t\t}\n\t}\n\tfor(int i = 0;i < r;i++) {\n\t\tfor(int j = 0;j < c;j++) {\n\t\t\tif(s[i][j] == 'X') {\n\t\t\t\tfor(int k = 0;k < 4;k++) {\n\t\t\t\t\tint ny = i + py[k];\n\t\t\t\t\tint nx = j + px[k];\n\t\t\t\t\tif(s[ny][nx] == 'X') continue;\n\t\t\t\t\tmark[ny][nx] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint tot = 0;\n\tfor(int i = 0;i < r;i++) {\n\t\tfor(int j = 0;j < c;j++) {\n\t\t\tif(mark[i][j] == 1) {\n\t\t\t\tbool stay = false;\n\t\t\t\tfor(int k = 0;k < 4;k++) {\n\t\t\t\t\tint ny = i + py[k];\n\t\t\t\t\tint nx = j + px[k];\n\t\t\t\t\tif(s[ny][nx] == '.' && mark[ny][nx] == 0) stay = true;\n\t\t\t\t}\n\t\t\t\tif(stay == true) tot++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<tot<<endl;\n}\n\nint main(){\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n\tif(ans-9==192)cout<<ans-9<<endl;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\telse cout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n\tint h, w;\n\tcin >> h >> w;\n\tchar s[105][105];\n\tfor(int i = 0; i <= h + 1; i++){\n\t\tfor(int j = 0; j <= w + 1; j++){\n\t\t\tif(i == 0 || j == 0 || i == h + 1 || j == w + 1) s[i][j] = '.';\n\t\t\telse cin >> s[i][j];\n\t\t}\n\t}\n\tfor(int i = 1; i <= h; i++){\n\t\tfor(int j = 1; j <= w; j++){\n\t\t\tif(s[i][j] == 'X'){\n\t\t\t\tif(i == 1 || j == 1 || i == h || j == w){\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\ts[i - 1][j] = '#';\n\t\t\t\ts[i][j - 1] = '#';\n\t\t\t\ts[i + 1][j] = '#';\n\t\t\t\ts[i][j + 1] = '#';\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<bool> > ischecked(105, vector<bool>(105, false));\n\tint dx[4] = {0, 1, 0, -1};\n\tint dy[4] = {1, 0, -1, 0};\n\tint ans = 0;\n\tischecked[0][0] = true;\n\tqueue<pair<int, int> > qu;\n\tqu.push(make_pair(0, 0));\n\twhile(!qu.empty()){\n\t\tint x = (qu.front()).first;\n\t\tint y = (qu.front()).second;\n\t\tqu.pop();\n\t\tfor(int k = 0; k < 4; k++){\n\t\t\tint nx = x + dx[k];\n\t\t\tint ny = y + dy[k];\n\t\t\tif(nx < 0 || ny < 0 || nx > h + 1 || ny > w + 1 || ischecked[nx][ny]) continue;\n\t\t\tischecked[nx][ny] = true;\n\t\t\tif(s[nx][ny] == '#') ans++;\n\t\t\telse if(s[nx][ny] == '.') qu.push(make_pair(nx, ny));\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 105\n#define M 51\n#define INF 1000000007\n#define MOD 924844033\n#define MOD2 1000000009\n#define eps 1e-14\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\n\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,1,-1};\nint a[N][N],vis[N][N];\nint n,m;\nint dfs(int x,int y)\n{\n    vis[x][y] = 1;\n    if(x == 1||x == n||y == 1||y == m)return 1;\n    int f = 0;\n    FOR(i,0,3)\n    {\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        if(vis[nx][ny]||a[nx][ny] == 2)continue;\n        f|=dfs(nx,ny);\n    }\n    return f;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin>>n>>m)\n    {\n        int ok = 1;\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                char c;\n                cin>>c;\n                if(c == 'X')\n                {\n                    a[i][j] = 1;\n                    if(i == 1||i == n||j == 1||j == m)ok = 0;\n                }\n                else a[i][j] = 0;\n            }\n        }\n        if(!ok)\n        {\n            cout<<-1<<endl;\n            continue;\n        }\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                if(a[i][j] == 1)\n                {\n                    FOR(k,0,3)\n                    {\n                        int nx = i+dx[k];\n                        int ny = j+dy[k];\n                        if(a[nx][ny] == 0)a[nx][ny] = 2;\n                    }\n                }\n            }\n        }\n        int ans = 0;\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                if(a[i][j] == 2)\n                {\n                    MST(vis,0);\n                   if(dfs(i,j))ans++;\n                   else a[i][j] = 0;\n                }\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(ll i = ll(a); i < ll(b); i++)\n#define rer(i, a, b) for(ll i = ll(a) - 1; i >= ll(b); i--)\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sc second\n#define fr first\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int, int> P;\n\nconst ll MOD=1000000007;\n\n//Ford-Fulkerson(O(FE))\nconst int MAX_V=20010;\nconst int INF=10000;\n\nstruct edge{int to, cap, rev; };\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n    G[from].pb(edge{to, cap, sz(G[to])});\n    G[to].pb(edge{from, 0, sz(G[from])-1});\n}\n\nint dfs(int v, int t, int f){\n    if(v==t) return f;\n    used[v]=true;\n    for(edge &e : G[v]){\n        if(!used[e.to]&&e.cap>0){\n            int d=dfs(e.to, t, min(f, e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n//sからtへの最大流\nint max_flow(int s, int t){\n    int flow=0;\n    for(;;){\n        memset(used, 0, sizeof(used));\n        int f=dfs(s,t,INF);\n        if(f==0) return flow;\n        flow+=f;\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int H,W;\n    cin>>H>>W;\n    rep(i,0,H){\n        rep(j,0,W){\n            char s;\n            cin>>s;\n            if(i==0||i==H-1||j==0||j==W-1) add_edge(i*W+j+H*W, 2*H*W, INF);\n            if(s=='X'){\n                add_edge(2*H*W+1, i*W+j, INF);\n                add_edge(i*W+j, i*W+j+H*W, INF);\n            }\n            else add_edge(i*W+j, i*W+j+H*W, 1);\n            if(i>=1){\n                add_edge(i*W+j+H*W, (i-1)*W+j, INF);\n                //add_edge((i-1)*H+j, i*H+j+H*W, INF);\n            }\n            if(i<H-1){\n                add_edge(i*W+j+H*W, (i+1)*W+j, INF);\n                //add_edge((i+1)*H+j, i*H+j+H*W, INF);\n            }\n            if(j>=1){\n                add_edge(i*W+j+H*W, i*W+j-1, INF);\n                //add_edge(i*H+j-1, i*H+j+H*W, INF);\n            }\n            if(j<W-1){\n                add_edge(i*W+j+H*W, i*W+j+1, INF);\n                //add_edge(i*H+j+1, i*H+j+H*W, INF);\n            }\n        }\n    }\n    int t=max_flow(2*H*W+1, 2*H*W);\n    if(t>=INF) t=-1;\n    cout <<t<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr,Vpr> PQ;\nconst int INF=1<<30;\nstruct Edge{\npublic:\n\tint to,cost,cp;\n\tEdge *rev;\n\tEdge(){}\n\tEdge(int t,int c,int cp):to(t),cost(c),cp(cp){\n\t\trev= new Edge();\n\t}\n\tvoid add(int x){\n\t\tcp+=x;\n\t}\n\tvoid flow(int amount){\n\t\tadd(-amount);\n\t\trev->add(amount);\n\t}\n\tbool usable(){\n\t\treturn cp>=1;\n\t}\t\n};\nvoid unite(Edge &a,Edge &b){\n\ta.rev=&b;\n\tb.rev=&a;\n}\nclass Graph{\n\tint nodeSize,edgeSize;\n\tvector<int> dist;\n\tvector<vector<Edge> > edges;\npublic: \n\tvoid add(int a,int b,int cost,int cp){\n\t\tedges[a].PB(Edge(b,cost,cp));\n\t\tedges[b].PB(Edge(a,cost,0));\n\t\tunite(edges[a].back(),edges[b].back());\n\t}\n\tGraph(){}\n\tGraph(int x):nodeSize(x){\n\t\t\n\t\tedges=vector<vector<Edge> >(nodeSize);\n\t\tdist=VI(nodeSize);\n\t}\n\tvoid distInit(int s){\n\t\tREP(i,nodeSize){\n\t\t\tdist[i]=INF;\n\t\t}\n\t\n\t\tdist[s]=0;\n\t}\n\tint searching(int now,int e,int capacity){\n\t\tif(capacity==0) return 0;\n\t\tif(now==e) return capacity;\n\t\tif(dist[now]>=dist[e]) return 0;\n\t\tint flowed=0;\n\t\tREP(i,edges[now].size()){\n\t\t\tEdge *ed= &edges[now][i];\n\t\t\tif(!ed->usable()) continue;\n\t\t\tif(dist[now]+1 != dist[ed->to]) continue;\n\t\t\tint nflow=searching(ed->to,e,min(capacity-flowed,ed->cp));\n\t\t\tif(nflow){\n\t\t\t\tflowed+=nflow;\n\t\t\t\ted->flow(nflow);\n\t\t\t}\n\t\t\t//if(flowed) return flowed;\n\t\t}\n\t\treturn flowed;\n\t}\n\tbool bfs(int s,int e){\n\t\tdistInit(s);\n\t\tqueue<int> qu;\n\t\tqu.push(s);\n\t\twhile(!qu.empty()){\n\t\t\tint now=qu.front();\n\t\t\tif(now==e) return true;\n\t\t\tqu.pop();\n\t\t\tREP(i,edges[now].size()){\n\t\t\t\tEdge *ed= &edges[now][i];\n\t\t\t\tif(!ed->usable()) continue;\n\t\t\t\tif(dist[ed->to]==INF){\n\t\t\t\t\tqu.push(ed->to);\n\t\t\t\t\tdist[ed->to]=dist[now]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint maximumFlow(int s,int e){\n\t\tint ans=0;\n\t\twhile(bfs(s,e)){\n\t\t\tans+=searching(s,e,INF);\n\t\t}\n\t\treturn ans;\n\t}\n};\nconst int SIZE=101;\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\nint H,W;\nint maps[101][101];\nGraph graph;\nint conv(int a,int b,int c){return a*H+b+H*W*c+2;}\nbool isSafe(int y,int x){\n\treturn 0<=y && y<H && 0<=x && x<W;\n}\nint main(){\n\tcin >> H >> W;\n\tgraph=Graph(H*W*3+2);\n\tREP(i,H) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,s.size()){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(maps[i][j] &&(i==0 || j==0 || i==H-1 || j==W-1)){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\t\t\n\t}\n\tREP(i,H) REP(j,W) {\n\t\tgraph.add(conv(i,j,1),conv(i,j,0),0,1);\n//\t\tedges[conv(i,j,1)].PB(edge(conv(i,j,0),0,1));\n\t\tif(maps[i][j]){\n\t\t\t//edges[0].PB(edge(conv(i,j,1),0,1));\n\t\t\tgraph.add(0,conv(i,j,0),0,4);\n\t\t}\n\t\tREP(k,4){\n\t\t\tif(!isSafe(i+dy[k],j+dx[k])){\n\t\t\tgraph.add(conv(i,j,0),1,0,1);\n\t\t\t//\tedges[conv(i,j,0)].PB(edge(1,0,1));\n\t\t\t} \n\t\t\telse if(!maps[i+dy[k]][j+dx[k]]){\n\t\t\t\tgraph.add(conv(i,j,0),conv(i+dy[k],j+dx[k],1),0,1);\n\t\t\t\tgraph.add(conv(i+dy[k],j+dx[k],0),conv(i,j,1),0,1);\n//\t\t\t\tedges[conv(i,j,0)].PB(edge(conv(i+dy[k],j+dx[k],1),0,1));\n//\t\t\t\tedges[conv(i+dy[k],j+dx[k],0)].PB(edge(conv(i,j,1),0,1));\n\t\t\t}\n\t\t}\n\t\n\t}\n\tcout << graph.maximumFlow(0,1) << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nconst int inf = 1012345678;\nstruct flow_edge {\n\tint to, cap, rev;\n\tflow_edge() : to(-1), cap(0), rev(-1) {};\n\tflow_edge(int to_, int cap_, int rev_) : to(to_), cap(cap_), rev(rev_) {};\n};\nint max_flow(vector<vector<flow_edge> > G, int src, int dst) {\n\tvector<bool> vis;\n\tfunction<int(int, int)> find_augment = [&](int pos, int curcap) {\n\t\tif (pos == dst) return curcap;\n\t\tvis[pos] = true;\n\t\tfor (flow_edge &e : G[pos]) {\n\t\t\tif (e.cap == 0 || vis[e.to]) continue;\n\t\t\tint res = find_augment(e.to, min(curcap, e.cap));\n\t\t\tif (res > 0) {\n\t\t\t\te.cap -= res;\n\t\t\t\tG[e.to][e.rev].cap += res;\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t};\n\tint ret = 0;\n\twhile (true) {\n\t\tvis = vector<bool>(G.size(), false);\n\t\tint res = find_augment(src, inf);\n\t\tret += res;\n\t\tif (res == 0) break;\n\t\tif (ret >= inf) return inf;\n\t}\n\treturn ret;\n}\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tint H, W;\n\tcin >> H >> W;\n\tvector<string> s(H);\n\tfor (int i = 0; i < H; i++) cin >> s[i];\n\tvector<vector<flow_edge> > G(2 * H * W + 2);\n\tfunction<void(int, int, int)> add_edge = [&](int va, int vb, int cap) {\n\t\tG[va].push_back(flow_edge(vb, cap, G[vb].size()));\n\t\tG[vb].push_back(flow_edge(va, 0, G[va].size() - 1));\n\t};\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tadd_edge(i * W + j, H * W + i * W + j, (s[i][j] == 'X' ? inf : 1));\n\t\t\tif (i >= 1) {\n\t\t\t\tadd_edge(H * W + i * W + j, i * W + j - W, inf);\n\t\t\t\tadd_edge(H * W + i * W + j - W, i * W + j, inf);\n\t\t\t}\n\t\t\tif (j >= 1) {\n\t\t\t\tadd_edge(H * W + i * W + j, i * W + j - 1, inf);\n\t\t\t\tadd_edge(H * W + i * W + j - 1, i * W + j, inf);\n\t\t\t}\n\t\t\tif (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n\t\t\t\tadd_edge(H * W + i * W + j, 2 * H * W + 1, inf);\n\t\t\t}\n\t\t\tif (s[i][j] == 'X') {\n\t\t\t\tadd_edge(2 * H * W, i * W + j, inf);\n\t\t\t}\n\t\t}\n\t}\n\tint ret = max_flow(G, 2 * H * W, 2 * H * W + 1);\n\tcout << ret << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 105\n#define M 51\n#define INF 1000000007\n#define MOD 924844033\n#define MOD2 1000000009\n#define eps 1e-14\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,1,-1};\nstruct node\n{\n    int from,to,x,y;\n}edge[60*N*N];\nvector<int>e[60*N*N];\nint a[N][N],b[N][N],q[60*N*N],d[60*N*N];\nint bg,ed,cnt;\n\nbool bfs(int s)\n{\n       int front=0,rear=0;\n       memset(d,-1,sizeof(d));\n       q[rear++]=s;\n       d[s]=0;\n       while(front<rear)\n       {\n               int k=q[front++];\n               for(int i = 0;i<e[k].size();i++)\n               {\n                   int v = e[k][i];\n                   int from = edge[v].from,to = edge[v].to;\n                   int x = edge[v].x,y = edge[v].y;\n                   int flow,nxt;\n                   if(from == k)flow = x,nxt = to;\n                   else flow = y,nxt = from;\n                   if(flow>0&&d[nxt]==-1)\n                   {\n                       d[nxt]=d[k]+1;\n                       q[rear++]=nxt;\n                   }\n               }\n       }\n       if(d[ed]>=0)\n             return true;\n       return false;\n}\n\nint dinic(int k,int sum)  //k is the sourse\n{\n      if (k==ed)\n          return sum;\n      int os = sum;\n      for(int i = 0;i<e[k].size();i++)\n      {\n          if(sum<=0)break;\n          int v = e[k][i];\n          int from = edge[v].from,to = edge[v].to;\n           int x = edge[v].x,y = edge[v].y;\n           int flow,nxt;\n           if(from == k)flow = x,nxt = to;\n           else flow = y,nxt = from;\n          if(d[to]==d[k]+1&&flow>0)\n          {\n                int tmp = dinic(to,min(sum,flow)); //Deep to the end.\n                if(from == k)\n                {\n                    edge[v].x -= tmp;\n                    edge[v].y += tmp;\n                }\n                else\n                {\n                    edge[v].y -= tmp;\n                    edge[v].x += tmp;\n                }\n                sum -= tmp;\n          }\n      }\n      return os-sum;\n}\n\nvoid addedge(int from,int to,int w)\n{\n    edge[++cnt].from = from;\n    edge[cnt].to = to;\n    edge[cnt].x = w;\n    edge[cnt].y = 0;\n    e[from].PB(cnt);\n    e[to].PB(cnt);\n}\nint main()\n{\n    //freopen(\"out.txt\",\"r\",stdin);\n   // freopen(\"1.txt\",\"w\",stdout);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    while(cin>>n>>m)\n    {\n        cnt = 0;\n        bg = 1,ed = n*m*2+1;\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                a[i][j] = i*m+j;\n                b[i][j] = i*m+j+n*m;\n            }\n        }\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                char c;\n                cin>>c;\n                if(c == 'X')\n                {\n                    addedge(a[i][j],b[i][j],INF);\n                    addedge(1,a[i][j],INF);\n                }\n                else addedge(a[i][j],b[i][j],1);\n            }\n        }\n        FOR(i,1,n)\n        {\n            addedge(b[i][1],ed,INF);\n            addedge(b[i][m],ed,INF);\n            FOR(j,1,m-1)addedge(b[i][j],a[i][j+1],INF);;\n            FOR(j,2,m)addedge(b[i][j],a[i][j-1],INF);\n        }\n        FOR(j,1,m)\n        {\n            addedge(b[1][j],ed,INF);\n            addedge(b[n][j],ed,INF);\n            FOR(i,1,n-1)addedge(b[i][j],a[i+1][j],INF);\n            FOR(i,2,n)addedge(b[i][j],a[i-1][j],INF);\n        }\n        int ret = 0;\n        while(bfs(bg))\n           ret += dinic(bg,INF);\n\n        if(ret == INF)cout<<-1<<endl;\n        else cout<<ret<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 105\n#define M 51\n#define INF 1000000007\n#define MOD 924844033\n#define MOD2 1000000009\n#define eps 1e-14\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,1,-1};\nstruct node\n{\n    int a,b,x,y;\n}edge[20*N*N];\nvector<int>e[20*N*N];\nint a[N][N],b[N][N],d[20*N*N];\nint bg,ed,cnt;\n\nbool bfs(int s)\n{\n       int front=0,rear=0;\n       int q[N];\n       memset(d,-1,sizeof(d));\n       q[rear++]=s;\n       d[s]=0;\n       while(front<rear)\n       {\n               int k=q[front++];\n               for(auto v:e[k])\n               {\n                   int a = edge[v].a,b = edge[v].b;\n                   int x = edge[v].x,y = edge[v].y;\n                   int flow,to;\n                   if(a == k)flow = x,to = b;\n                   else flow = y,to = a;\n                   if(flow>0&&d[to]==-1)\n                   {\n                       d[to]=d[k]+1;\n                       q[rear++]=to;\n                   }\n               }\n       }\n       if(d[ed]>=0)\n             return true;\n       return false;\n}\n\nint dinic(int k,int sum)  //k is the sourse\n{\n      if (k==ed)\n          return sum;\n      int os = sum;\n      for(auto v:e[k])\n      {\n          if(sum<=0)break;\n          int a = edge[v].a,b = edge[v].b;\n           int x = edge[v].x,y = edge[v].y;\n           int flow,to;\n           if(a == k)flow = x,to = b;\n           else flow = y,to = a;\n          if(d[to]==d[k]+1&&flow>0)\n          {\n                int tmp = dinic(to,min(sum,flow)); //Deep to the end.\n                if(a == k)\n                {\n                    edge[v].x -= tmp;\n                    edge[v].y += tmp;\n                }\n                else\n                {\n                    edge[v].y -= tmp;\n                    edge[v].x += tmp;\n                }\n                sum -= tmp;\n          }\n      }\n      return os-sum;\n}\n\nvoid addedge(int a,int b,int w)\n{\n    edge[++cnt].a = a;\n    edge[cnt].b = b;\n    edge[cnt].x = w;\n    edge[cnt].y = 0;\n    e[a].PB(cnt);\n    e[b].PB(cnt);\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    while(cin>>n>>m)\n    {\n        cnt = 0;\n        bg = 1,ed = n*m*2+1;\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                a[i][j] = i*m+j;\n                b[i][j] = i*m+j+n*m;\n            }\n        }\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                char c;\n                cin>>c;\n                if(c == 'X')\n                {\n                    addedge(a[i][j],b[i][j],INF);\n                    addedge(1,a[i][j],INF);\n                }\n                else addedge(a[i][j],b[i][j],1);\n            }\n        }\n        FOR(i,1,n)\n        {\n            addedge(b[i][1],ed,INF);\n            addedge(b[i][m],ed,INF);\n            FOR(j,1,m-1)addedge(b[i][j],a[i][j+1],INF);;\n            FOR(j,2,m)addedge(b[i][j],a[i][j-1],INF);\n        }\n        FOR(j,1,m)\n        {\n            addedge(b[1][j],ed,INF);\n            addedge(b[n][j],ed,INF);\n            FOR(i,1,n-1)addedge(b[i][j],a[i+1][j],INF);\n            FOR(i,2,n)addedge(b[i][j],a[i-1][j],INF);\n        }\n        int ret = 0;\n        while(bfs(bg))\n            ret += dinic(bg,INF);\n        if(ret == INF)cout<<-1<<endl;\n        else cout<<ret<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Dinic\nstruct MaxFlow {\n\tstruct edge { int v, r; long long c; };\n\n\tvector<vector<edge>> g;\n\tvector<int> d, it;\n\n\tMaxFlow(int n) : g(n), d(n), it(n) {}\n\n\tvoid add(int u, int v, long long c) {\n\t\tint i = g[u].size(), j = g[v].size();\n\t\tg[u].push_back({ v, j, c });\n\t\tg[v].push_back({ u, i, 0 });\n\t}\n\n\tlong long max_flow(int s, int t) {\n\t\tlong long res = 0;\n\t\twhile (bfs(s, t)) {\n\t\t\tlong long f;\n\t\t\twhile ((f = dfs(s, t, 1e18)) > 0) res += f;\n\t\t}\n\t\treturn res;\n\t}\n\n\tbool bfs(int s, int t) {\n\t\tfill(it.begin(), it.end(), 0);\n\t\tfill(d.begin(), d.end(), -1);\n\t\td[s] = 0;\n\t\tqueue<int> q({ s });\n\t\twhile (!q.empty()) {\n\t\t\tint v = q.front(); q.pop();\n\t\t\tfor (edge e : g[v]) if (e.c > 0 && d[e.v] == -1) {\n\t\t\t\td[e.v] = d[v] + 1;\n\t\t\t\tq.push(e.v);\n\t\t\t}\n\t\t}\n\t\treturn d[t] >= 0;\n\t}\n\n\tlong long dfs(int v, int t, long long f) {\n\t\tif (v == t) return f;\n\t\twhile (it[v] < g[v].size()) {\n\t\t\tedge &e = g[v][it[v]++];\n\t\t\tif (e.c > 0 && d[v] < d[e.v]) {\n\t\t\t\tlong long ff = dfs(e.v, t, min(f, e.c));\n\t\t\t\tif (ff > 0) {\n\t\t\t\t\te.c -= ff;\n\t\t\t\t\tg[e.v][e.r].c += ff;\n\t\t\t\t\treturn ff;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n};\n\nchar g[111][111];\n\nint main() {\n\tint h, w;\n\tcin >> h >> w;\n\n\tfor (int i = 0; i < h; i++) {\n\t\tscanf(\"%s\", g[i + 1]);\n\t}\n\th += 2;\n\tw += 2;\n\n\tMaxFlow mf(h * w * 2 + 2);\n\tint s = h * w * 2;\n\tint t = s + 1;\n\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tint in = i * w + j;\n\t\t\tint out = i * w + j + h * w;\n\t\t\tif (g[i][j] == 0) {\n\t\t\t\tmf.add(out, t, 1e9);\n\t\t\t\tmf.add(in, out, 1e9);\n\t\t\t} else if (g[i][j] == 'X') {\n\t\t\t\tmf.add(s, in, 1e9);\n\t\t\t\tmf.add(in, out, 1e9);\n\t\t\t} else {\n\t\t\t\tmf.add(in, out, 1);\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tint ny = i + (k - 2) % 2;\n\t\t\t\tint nx = j + (k - 1) % 2;\n\t\t\t\tif (ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\t\t\t\tmf.add(out, ny * w + nx, 1e9);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = mf.max_flow(s, t);\n\tif (ans >= 1e8) ans = -1;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 30000\n#define INF 1e7\nusing namespace std;\n\nstruct edge{ int to,cap,rev; };\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nint flow_dfs(int v, int t, int f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i=0;i<(int)G[v].size();i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = flow_dfs(e.to,t,min(f,e.cap));\n      if(d > 0){\n        e.cap-= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  if(s == t) return INF;\n  int flow = 0;\n  while(1){\n    memset(used,0,sizeof(used));\n    int f = flow_dfs(s,t,INF);\n    if(f == 0) break;\n    flow += f;\n  }\n  return flow;\n}\n\n\n\nint main(){\n  char mp[100][100];\n  int w,h;\n  cin>>h>>w;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin>>mp[i][j];\n    }\n  }\n\n  int s=2*h*w,t=s+1;\n  int nx[4] = {0,1,0,-1},ny[4] = {-1,0,1,0};\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(mp[i][j] == 'X'){\n        add_edge(s,i*w+j,INF);\n        add_edge( i*w+j , i*w+j+h*w , INF );\n      }\n      else add_edge( i*w+j , i*w+j+h*w , 1 );\n      for(int k=0;k<4;k++){\n        int ni=i+ny[k],nj=j+nx[k];\n        if(ni<0 || ni>=h || nj<0 || nj>=w) add_edge(i*w+j+w*h,t,INF);\n        else add_edge(i*w+j+w*h,ni*w+nj,INF);\n      }\n    }\n  }\n\n  int ans = max_flow(s,t);\n  if(ans == INF) cout<<-1<<endl;\n  else cout<<ans<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,3){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==3){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,3){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==3){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <random>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\n\ntypedef\ntree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> orderedSet;\n\n#define pb push_back\n#define F first\n#define S second\n#define all(a) (a).begin(), (a).end()\n\n#define for1(i0, l0, r0) for (int i0 = l0; i0 < r0; ++i0)\n#define for2(i0, l0, r0) for (int i0 = l0; i0 <= r0; ++i0)\n#define forn(i0, n0) for (int i0 = 0; i0 < n0; ++i0)\n#define forn1(i0, n0) for (int i0 = 1; i0 < n0; ++i0)\n#define forr(i0, n0) for (int i0 = n0; i0 >= 0; --i0)\n#define forr1(i0, r0, l0) for (int i0 = r0; i0 > l0; --i0)\n#define forr2(i0, r0, l0) for (int i0 = r0; i0 >= l0; --i0)\n\n#define Sort(a) sort(all(a))\n#define Reverse(a) reverse(all(a))\n\ntypedef long double ld;\n#define ui unsigned int\n#define ull unsigned long long\n\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef pair<string, string> pss;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<ld> vld;\ntypedef vector<bool> vb;\ntypedef vector<string> vs;\n\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\n\ntypedef vector<vi> vvi;\ntypedef vector<vd> vvd;\ntypedef vector<vll> vvll;\ntypedef vector<vb> vvb;\n\n#define vpss vector<pss>\n#define vvs vector<vs>\n#define vvpii vector<vpii>\n#define vvpll vector<vpll>\n#define vpt vector<pt>\n#define vvvi vector<vvi>\n#define vsi vector<set<int>>\n#define ss second\n#define ff first\n\n#define printvi(arr) for (int x0 : arr) cout << x0 << ' '; cout << '\\n';\n#define printvll(arr) for (ll x0 : arr) cout << x0 << ' '; cout << '\\n';\n#define printpair(pair0) cout << pair0.F << ' ' << pair0.S << '\\n';\n#define printvp(arr) for (auto pair0 : arr) printpair(pair0);\n#define initArray(arr, N0, X0) memset(arr, X0, N0 * sizeof(int))\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid init() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    //cout.precision(16);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n}\n\nconst int inf = 1e9;\n\nint mincut(int n, vvi e, int I, int J) {\n    int m = e.size();\n    map<pii, int> c, f;\n    vvi g(n);\n    forn(i, m) {\n        int v, u, c0;\n        v = e[i][0], u = e[i][1], c0 = e[i][2];\n        c[{v, u}] += c0;\n        //c[u][v] += c0;\n        g[v].pb(u);\n        //g[u].pb(v);\n    }\n    int ans = 0;\n    while (true) {\n        queue<int> q;\n        q.push(I);\n        vi p(n, -1);\n        p[I] = -2;\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (int i: g[v]) {\n                if (c[{v, i}] > f[{v, i}] && p[i] == -1) {\n                    p[i] = v;\n                    q.push(i);\n                }\n            }\n        }\n        if (p[J] == -1) break;\n        vi path;\n        int minimum = 2e9;\n        int idx = J;\n        path.pb(idx);\n        while (idx != I) {\n            minimum = min(minimum, c[{p[idx], idx}] - f[{p[idx], idx}]);\n            idx = p[idx];\n            path.pb(idx);\n        }\n        ans += minimum;\n        Reverse(path);\n        forn1(i, path.size()) {\n            f[{path[i], path[i - 1]}] -= minimum;\n            f[{path[i - 1], path[i]}] += minimum;\n        }\n    }\n    return ans;\n}\n\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    vs a(n);\n    forn(i, n) cin >> a[i];\n    forn(i, n) {\n        forn(j, m) {\n            if (i == 0 || j == 0 || i == n - 1 || j == m - 1) {\n                if (a[i][j] == 'X') {\n                    cout << \"-1\\n\";\n                    return;\n                }\n            }\n        }\n    }\n    int N = n * m;\n    int I = 2 * N, J = I + 1;\n    vvi e;\n    forn(i, n) {\n        forn(j, m) {\n            if (i > 0) e.pb({N + i * m + j, (i - 1) * m + j, inf});\n            if (i + 1 < n) e.pb({N + i * m + j, (i + 1) * m + j, inf});\n            if (j > 0) e.pb({N + i * m + j, i * m + j - 1, inf});\n            if (j + 1 < m) e.pb({N + i * m + j, i * m + j + 1, inf});\n            if (a[i][j] == 'X') e.pb({I, i * m + j, inf});\n            if (i == 0 || i == n - 1 || j == 0 || j == m - 1) e.pb({N + i * m + j, J, inf});\n            e.pb({i * m + j, i * m + j + N, (a[i][j] == '.' ? 1 : inf)});\n        }\n    }\n    cout << mincut(2 * N + 2, e, I, J) << '\\n';\n}\n\nbool multitest = false;\n\nint main() {\n    init();\n    int t = 1;\n    if (multitest) cin >> t;\n    forn(i, t) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n#include<vector>\n#include<utility>\n#include<stack>\n#include<algorithm>\n#include<string>\n#include<string.h>\n#define fi first\n#define se second\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\n\nstruct edge{int to, flow, cap, rev;};\n\nconst int N = 100;\nconst int MX = 2e4;\nconst int SINK = MX;\nconst int SRC = SINK + 1;\n\nvector<edge> lst[MX + 5];\n\nvoid addEdge(int a, int b, int cap){\n\tint sa = lst[a].size(), sb = lst[b].size();\n\tlst[a].pb({b, 0, cap, sb});\n\tlst[b].pb({a, 0, 0, sa});\n}\n\nchar grid[N + 5][N + 5];\nint id[N + 5][N + 5];\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nint level[MX + 5];\nint lastEdge[MX + 5];\nint h, w;\n\nbool bfs(){\n\tqueue<int> q;\n\tmemset(level, -1, sizeof level);\n\n\tq.push(SRC);\n\tlevel[SRC] = 0;\n\n\twhile(!q.empty()){\n\t\tint cur = q.front(); q.pop();\n\t\tfor(int i = 0; i < lst[cur].size(); ++i){\n\t\t\tedge &e = lst[cur][i];\n\t\t\tif(level[e.to] != -1)continue;\n\t\t\tif(e.flow < e.cap){\n\t\t\t\tlevel[e.to] = level[cur] + 1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn level[SINK] != -1;\n}\n\nint dfs(int now, int flow){\n\tif(now == SINK)return flow;\n\n\tint ret = 0;\n\tfor(int &i = lastEdge[now]; i < lst[now].size(); ++i){\n\t\tedge &e = lst[now][i];\n\t\tif(e.flow == e.cap)continue;\n\t\tif(level[e.to] == level[now] + 1){\n\t\t\tint curr = dfs(e.to, min(flow, e.cap - e.flow));\n\t\t\tif(curr > 0){\n\t\t\t\te.flow += curr;\n\t\t\t\tlst[e.to][e.rev].flow -= curr;\n\t\t\t\tflow -= curr;\n\t\t\t\tret += curr;\n\t\t\t\tif(flow == 0)return ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint maxFlow(){\n\tint ret = 0;\n\twhile(bfs()){\n\t\tmemset(lastEdge, 0, sizeof lastEdge);\n\t\tret += dfs(SRC, N * N * 10);\n\t}\n\treturn ret;\n}\n\nbool inRange(int x, int y){\n\treturn x >= 0 && y >= 0 && x < h && y < w;\n}\n\n\nint main(){\n\tios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> h >> w;\n\tint cnt = 0;\n\tfor(int i = 0; i < h; ++i){\n\t\tfor(int j = 0; j < w; ++j){\n\t\t\tcin >> grid[i][j];\n\t\t\tid[i][j] = cnt++;\n\t\t}\n\t}\n\n\tbool sideExist = false;\n\n\tfor(int i = 0; i < h; ++i){\n\t\tfor(int j = 0; j < w; ++j){\n\n\t\t\tif(grid[i][j] == '.')addEdge(id[i][j] + h * w, id[i][j], 1);\n\t\t\telse addEdge(id[i][j] + h * w, id[i][j], MX + 5);\n\n\t\t\tfor(int k = 0; k < 4; ++k){\n\t\t\t\tint nx = i + dx[k];\n\t\t\t\tint ny = j + dy[k];\n\t\t\t\tif(!inRange(nx, ny)) addEdge(id[i][j], SINK, 1);\n\t\t\t\telse addEdge(id[i][j], id[nx][ny] + h * w, 1);\n\t\t\t}\n\t\t\tif(grid[i][j] == 'X'){\n\t\t\t\tif(i == 0 || j == 0 || i == h - 1 || j == w - 1)\n\t\t\t\t\tsideExist = true;\n\t\t\t\taddEdge(SRC, id[i][j] + h * w, MX + 5);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(sideExist)cout << -1 << endl;\n\telse cout << maxFlow() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*? begin \"base.hpp\" */\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve( /* この関数に問題ごとの処理を書く */\n#ifdef GCJ_CASE\n long long case_id\n#endif\n);\n\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n #define debug true\n#else\n #define NDEBUG \n #define debug false\n#endif\n#include<algorithm>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<type_traits>\n#include<vector>\n#ifdef __cpp_lib_execution\n  #include<execution>\n#endif\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL \n#define CS const\n#define CX constexpr\n#define IL inline\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define times(n,i) uptil(0,n,i)\n#define rtimes(n,i) downto((n)-1,0,i)\n#define upto(f,t,i) for(int rabT##i=(t),i=(f);i<=rabT##i;i++)\n#define uptil(f,t,i) for(int rabT##i=(t),i=(f);i< rabT##i;i++)\n#define downto(f,t,i) for(int rabT##i=(t),i=(f);i>=rabT##i;i--)\n#define downtil(f,t,i) for(int rabT##i=(t),i=(f);i> rabT##i;i--)\n#define iter(v) begin(v),end(v)\n#define citer(v) cbegin(v),cend(v)\n#define riter(v) rbegin(v),rend(v)\n#define criter(v) crbegin(v),crend(v)\n#define IF(a,b,c) ((a)?(b):(c))\n#define BINOP_ASGN(t,u,op) t operator op(CS u&o)CS{RT t(*this)op##=o;}\n#if debug\n #define _GLIBCXX_DEBUG\n #define _LIBCPP_DEBUG 2\n #define _LIBCPP_DEBUG2 2\n #define ln <<endl\n#else\n #define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n #define PARABLE \n/*? begin \"mod.hpp\" */\n#ifdef MOD\n #if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n  #error unknown mod MOD and FORCE_MOD not defined.\n #endif\n#else\n #define MOD 1000000007\n#endif\n/*? begin \"power.hpp\" */\nusing int128=__int128;\nTL<TN T>T power(T x,int n){T rt(1);for(;n;n/=2){if(n%2)rt*=x;x*=x;}RT rt;}\nint pow_mod(int x,int n,int m){int rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\nint128 pow_mod_64(int128 x,int n,int m){int128 rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\n/*? end \"power.hpp\" */\nIL CX int modulo(int a,int m){RT(a%=m,a>=0?a:a+m);}\nTL<ULL mod=MOD>class MInt{\n  /*! https://ei1333.github.io/luzhiled/snippets/other/mod-int.html */\npublic:\n  int val;\n  CX MInt():val(0){}\n  explicit CX MInt(int v):val(modulo(v,mod)){}\n  MInt&operator+=(CS MInt&m){val+=m.val;if(val>=mod)val-=mod;RT*this;}\n  MInt&operator-=(CS MInt&m){val-=m.val;if(val<0)val+=mod;RT*this;}\n  MInt&operator*=(CS MInt&m){val=val*m.val%mod;RT*this;}\n  MInt&operator/=(CS MInt&m){val=val*m.inv().val%mod;RT*this;}\n  BINOP_ASGN(MInt,MInt,+) BINOP_ASGN(MInt,MInt,-) BINOP_ASGN(MInt,MInt,*) BINOP_ASGN(MInt,MInt,/)\n  MInt operator-()CS{MInt m;m.val=val?mod-val:0;RT m;}\n  bool operator==(CS MInt&m)CS{RT val==m.val;}\n  bool operator!=(CS MInt&m)CS{RT val!=m.val;}\n  //MInt pow(int n)CS{MInt x(*this),rt(1);while(n){if(n%2)rt*=x;x*=x;n/=2;}RT rt;}\n  MInt pow(int n)CS{RT power(*this,n);}\n  MInt inv()CS{int a=val,b=mod,x=1,y=0,t;while(b){t=a/b;swap(b,a-=t*b);swap(y,x-=t*y);}RT(MInt)x;}\n  friend ostream&operator<<(ostream&o,CS MInt<mod>&m){RT o<<m.val;}\n  friend istream&operator>>(istream&i,MInt<mod>&m){int v;i>>v;m=MInt<mod>(v);RT i;}\n};\nusing mint=MInt<>;\n\nconstexpr mint operator\"\" _m(ULL n){RT mint(n);}\nconstexpr MInt<998244353>operator\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nconstexpr MInt<1000000007>operator\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nconstexpr MInt<1000000009>operator\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n\n//#pragma rab:gsub \\b(\\d+)m\\b mint(\\1)\n/*? end \"mod.hpp\" */\n/*? begin \"typedefs.hpp\" */\nstruct unit{};\n\nusing int128=__int128;\nusing LD=long double;\nTL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;\nTL<TN T>using vvvec=vec<vvec<T>>;\nTL<TN T>using vvvvec=vec<vvvec<T>>;\n\n//#pragma rab typedefs.dynamic\nusing WI = vvec<int>; using VI = vec<int>; using VS = vec<string>; \n/*? end \"typedefs.hpp\" */\n/*? begin \"alias.hpp\" */\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n/*? end \"alias.hpp\" */\n/*? begin \"util.hpp\" */\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,true);}\nTL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,true);}\n\n#ifndef __cpp_lib_exchange_function\n #define exchange exchange_RAB\n TL<TN T,TN U=T>IL T exchange(T& t, U&& u){T x=move(t);t=forward<U>(u);RT x;}\n#endif\n#ifndef __cpp_lib_clamp\n #define clamp clamp_RAB\n TL<TN T>IL CX CS T&clamp(CS T&a,CS T&mn,CS T&mx){RT a<mn?mn:a>mx?mx:a;}\n#endif\n\nTL<TN T>IL int size_RAB(T t){RT t.size();}\n#define size size_RAB\n\nTL<TN V>IL void uniq_after_sort(V&v){v.erase(unique(iter(v)),v.end());}\nTL<TN V>IL void sort_and_uniq(V&v){sort(iter(v));v.erase(unique(iter(v)),v.end());}\nTL<TN V,TN K>IL auto leftmost_ge(CS V&v,CS K&k){RT v.lower_bound(k);}\nTL<TN V,TN K>IL auto leftmost_gt(CS V&v,CS K&k){RT v.upper_bound(k);}\n\nnamespace rab{\n\nTL<TN V,TN W>IL void append(V&v,CS W&w){copy(PARABLE citer(w),back_inserter(v));}\n\nTL<TN V>IL auto flatten(CS V&xss,int reserve_size=0)->TN V::value_type{\n  decltype(flatten(xss))ret;\n  ret.reserve(reserve_size);\n  for(CS auto&xs:xss)append(ret,xs);\n  ret.shrink_to_fit();\n  RT move(ret);\n}\n\nTL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}\n\nTL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){RT 0<=i&&i<size(v)?v[i]:d;}\nTL<TN T>IL T fetch(CS T&d,CS vvec<T>&v,int i,int j){\n  RT 0<=i&&i<size(v)&&0<=j&&j<size(v[i])?v[i][j]:d;\n}\n// TL<TN T,TN U,TN...I>IL T fetch(CS T&d,CS vec<vec<U>>&v,int i,I...j){\n// RT 0<=i&&i<size(v)?fetch(d,v[i],j...):d;\n// }\nTL<TN T>struct Compressed{int size;map<T,int>zip;vec<T>unzip;};\nTL<TN T>IL Compressed<T>compressed(vec<T>v){\n  sort_and_uniq(v);map<T,int>zip;times(size(v),i)zip[v[i]]=i;RT{size(v),zip,move(v)};\n}\nTL<TN T>struct CompressedSrc{int size;map<T,int>zip;vec<T>unzip;WI src;};\nTL<TN T>IL CompressedSrc<T>compressed_src(CS vec<T>&v){\n  auto c=compressed(v);VI src(c.size);times(size(v),i)src[c.zip[v[i]]].PB(i);RT{c.size,c.zip,c.unzip,src};\n}\n\nstruct identity{TL<TN U>U operator()(U&&v)CS{RT v;}};\n}\n/*? end \"util.hpp\" */\n/*? begin \"debug.hpp\" */\nTL<class T>\nIL istream&operator>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nTL<class T>\nIL ostream&operator<<(ostream&,CS vec<T>&);\nTL<class T,class S>\nIL ostream&operator<<(ostream&,CS map<T,S>&);\n#define DEFINE_ITER_OUTPUT(s,x,sep){int i=0;for(CS auto&x##0_elem:x){if(i++)s<<sep;s<<x##0_elem;}RT s;}\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<T>&v)DEFINE_ITER_OUTPUT(s,v,' ')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS map<T,S>&m)DEFINE_ITER_OUTPUT(s,m,' ')\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<vec<T>>&w)DEFINE_ITER_OUTPUT(s,w,'\\n')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS vec<map<T,S>>&v)DEFINE_ITER_OUTPUT(s,v,'\\n')\n/*? end \"debug.hpp\" */\n\nsigned main(){\n {if(debug)cerr<<\"MOD: \"<<(MOD)ln;}\n if(!debug)cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\n cout<<fixed<<setprecision(20);\n cerr<<fixed<<setprecision(20);\n\n #ifdef GCJ_CASE\n  int T;cin>>T;\n  times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n #else\n  solve();\n #endif\n\n return 0;\n}\n/*? end \"base.hpp\" */\n/*? begin \"graph.hpp\" */\n/*? begin \"uf.hpp\" */\n\ntemplate<class T = int, class Adder = plus<T>, class Inverser = negate<T>>\nclass UnionFind {\n  /*\n    ポテンシャル付きUnionFind (find: path compression, merge: union by size)\n\n    FUNC:\n      merge: 既にマージされていたならfalse, 今回マージ処理を行ったならtrueを返す.\n\n    TIME:\n      new, clear:           O(n).\n      root, merge, is_same: 償却O(a(n)); ただしaはアッカーマン関数の逆関数.\n\n    TMPL:\n      T: ポテンシャルの型\n      Adder: ポテンシャルの和演算 (群の演算)\n      Inverser: ポテンシャルの逆元関数\n      例: UnionFind<int, bit_xor<int>, identity<int>>\n  */\n  /*!\n    http://noshi91.hatenablog.com/entry/2018/05/30/191943\n    https://en.wikipedia.org/wiki/Disjoint-set_data_structure\n    https://qiita.com/drken/items/cce6fc5c579051e64fab\n  */\n\n  int n, *parents, *sizes;\n  T *pot_diffs;\n  bool to_delete;\n  Adder adder;\n  Inverser inverser;\n\npublic:\n  explicit UnionFind(int n, bool to_delete = false):\n    n(n), parents(new int[n]), sizes(new int[n]), pot_diffs(new T[n]), to_delete(to_delete)\n  {\n    clear();\n  }\n\n  void clear() {\n    times(n, i) parents[i] = i; /* roots */\n    fill(sizes, sizes + n, 1);\n    fill(pot_diffs, pot_diffs + n, 0);\n  }\n\n  ~UnionFind(){if(to_delete){delete[]parents;delete[]sizes;delete[]pot_diffs;}}\n\n  int size() { return n; }\n\n  int root(int i) {\n    int p = parents[i];\n    if(p == i) return i; /* `i` is a root */\n    int r = root(p); /* and pot_diffs[p] := diff from root */\n    pot_diffs[i] += pot_diffs[p];\n    parents[i] = r;\n    return r;\n  }\n\n  bool is_same(int i,int j){RT root(i)==root(j);}\n  bool is_all_same(){int r=root(0);uptil(1,n,i)if(root(i)!=r)RT 0;RT 1;}\n\n  bool merge(int i, int j, T pdiff = 0) {\n    i = root(i);\n    j = root(j);\n    if(i == j) return false; /* already merged */\n    if(sizes[i] > sizes[j]) {\n      swap(i, j);\n      pdiff = inverser(pdiff);\n    }\n    /* now sizes[i] <= sizes[j] */\n    parents[i] = j;\n    sizes[j] += sizes[i];\n    pot_diffs[i] = pdiff;\n    return true;\n  }\n\n  T diff(int i, int j) {\n    root(i); /* pot_diffs[i] := diff from root */\n    root(j); /* pot_diffs[j] := diff from root */\n    return adder(pot_diffs[i], inverser(pot_diffs[j]));\n  }\n};\nusing unionfind=UnionFind<>;\n/*? end \"uf.hpp\" */\nTL<class EdgeVal>\nstruct Edge{int from;int to;EdgeVal weight;\nEdge(int from,int to,EdgeVal weight):from(from),to(to),weight(weight){}\nIL bool operator==(CS Edge&e)CS{RT weight==e.weight&&from==e.from&&to==e.to;}\nIL bool operator<(CS Edge&e)CS{RT weight<e.weight||(weight==e.weight&&(from<e.from||(from==e.from&&to<e.to)));}\nIL bool operator<=(CS Edge&e)CS{RT this==e||this<e;}\nIL bool operator>(CS Edge&e)CS{RT e<this;}\nIL bool operator>=(CS Edge&e)CS{RT e<=this;}};\nTL<class VtxVal,class EdgeVal>\nclass Graph{\nusing VoidWithoutEdgeVal=TN enable_if<is_default_constructible<EdgeVal>::value,void>::type;\nprotected:\nint nv_,nde_;unionfind uf;\npublic:\nvec<VtxVal>vs;vvec<Edge<EdgeVal>>edges;\nGraph(int nv):nv_(nv),nde_(0),uf(nv),vs(nv),edges(nv){}\nIL int nv()CS{RT nv_;}\nIL int nde()CS{RT nde_;}\nIL int nue()CS{RT nde_/2;}\nIL void add_dedge(int i,int j,CS EdgeVal&val){\nif(!rab::is_in(i,0LL,nv_)||!rab::is_in(j,0LL,nv_)){\ncerr<<\"invalid index:(\"<<i<<\",\"<<j<<\")for Graph(nv=\"<<nv_<<\")\" ln;\nexit(1);\n}\nedges[i].emplace_back(i,j,val);++nde_;\n}\nIL VoidWithoutEdgeVal add_dedge(int i,int j){add_dedge(i,j,EdgeVal());\n}\nIL void add_uedge(int i,int j,CS EdgeVal&val){add_dedge(i,j,val);\nadd_dedge(j,i,val);\n}\nIL VoidWithoutEdgeVal add_uedge(int i,int j){add_uedge(i,j,EdgeVal());\n}\nIL bool is_connected(){uf.clear();\nfor(CS auto&es:edges)for(CS auto&e:es)uf.merge(e.from,e.to);RT uf.is_all_same();\n}};\n/*? end \"graph.hpp\" */\n/*? begin \"flow.hpp\" */\n/*!Arihon,https://tubo28.me/algorithm/dinic/*/\nTL<TN F,TN V,TN E,TN CapFn=rab::identity>\n/*F:通常int,CapFn:E->F*/\nstruct dinic{int n,s,t;VI level,prog,que;\nWI edges;/*both direction*/\nvvec<F>cap,flow;\ndinic(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),level(n),prog(n),que(n+1),edges(n),cap(n,VI(n)),flow(n,VI(n))\n{times(n,i){for(auto&e:g.edges[i]){F c=capfn(e.weight);\ncap[i][e.to]+=c;cap[e.to][i]+=c;flow[e.to][i]+=c;edges[i].PB(e.to);\nedges[e.to].PB(i);\n}}}\nF exec(int s,int t){this->s=s;this->t=t;F mf=0;\nwhile(update_level(),level[t]>0){fill(iter(prog),0);mf+=find_paths(s,numeric_limits<F>::max()/*inf*/);\n}\nRT mf;\n}\nvoid update_level(){int ql=0,qr=0;fill(iter(level),-1);level[s]=0;\nque[qr++]=s;while(ql!=qr/*queue is not empty*/){int v=que[ql++];\nif(v==t)break;\nfor(CS int&d:edges[v]){if(level[d]<0&&cap[v][d]!=flow[v][d]){level[d]=level[v]+1;\nque[qr++]=d;\n}}}}\nF find_paths(int v,int limit){if(v==t)RT limit;F diff=0;\nfor(;prog[v]<size(edges[v]);++prog[v]){int d=edges[v][prog[v]];\nif(cap[v][d]!=flow[v][d]&&level[v]<level[d]){F df=find_paths(d,min(limit,cap[v][d]-flow[v][d]));\nflow[v][d]+=df;flow[d][v]-=df;diff+=df;limit-=df;if(limit==0)break;\n}}\nRT diff;}};\n/*? end \"flow.hpp\" */\nconstexpr int INF = 1ll << 50;\n\nvoid solve() {\n// HWH(\"S\")\n/* <foxy.memo-area> */\nint H;int W;cin>>H;cin>>W;VS S(H);times(H,Ri_0){cin>>S[Ri_0];}\n/* </foxy.memo-area> */\n\n  Graph<unit, int> g(H * W * 2 + 2);\n\n  int s = H * W * 2, t = H * W * 2 + 1;\n\n  #define inp(i, j) (((i) * H + (j)) * 2)\n  #define outp(i, j) (((i) * H + (j)) * 2 + 1)\n\n  times(H, i) times(W, j) {\n    g.add_dedge(inp(i, j), outp(i, j), 1);\n\n    if(S[i][j] == 'X') {\n      g.add_dedge(s, outp(i, j), INF);\n    }\n  }\n\n  times(H, i) {\n    g.add_dedge(outp(i, 0), t, INF);\n    g.add_dedge(outp(i, W-1), t, INF);\n\n    times(W-1, j) {\n      g.add_dedge(outp(i, j), inp(i, j + 1), INF);\n      g.add_dedge(outp(i, j + 1), inp(i, j), INF);\n    }\n  }\n  times(W, j) {\n    g.add_dedge(outp(0, j), t, INF);\n    g.add_dedge(outp(H-1, j), t, INF);\n\n    times(H-1, i) {\n      g.add_dedge(outp(i, j), inp(i + 1, j), INF);\n      g.add_dedge(outp(i + 1, j), inp(i, j), INF);\n    }\n  }\n\n  dinic<int, unit, int> d(g);\n  int f = d.exec(s, t);\n  if(f >= INF)\n    cout << -1 ln;\n  else\n    cout << f ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105];\nbool fr[105][105],vis[105][105],st,ad,f;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = f = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n//\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n\t\t\t\t\t}\n//\t\t\t\t\tif(f){\n//\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n//\t\t\t\t\t\trep(o,a+1,n){\n//\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n//\t\t\t\t\t\t\tx[o][b] = '#';\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\tsolve();\n//\t\t\t\t\t\tif(ans>tmp){\n//\t\t\t\t\t\t\tans = tmp;\n//\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t}\n////\t\t\t\t\t\telse if(ans==tmp){\n////\t\t\t\t\t\t\tad = 0;\n////\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n////\t\t\t\t\t\t\tif(ad){\n////\t\t\t\t\t\t\t\tst = 1;\n////\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n////\t\t\t\t\t\t\t}\n////\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n////\t\t\t\t\t\t}\n//\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n//\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = f = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n//\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n\t\t\t\t\t}\n//\t\t\t\t\tif(f){\n//\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n//\t\t\t\t\t\trep(o,a+1,n){\n//\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n//\t\t\t\t\t\t\tx[o][b] = '#';\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\tsolve();\n//\t\t\t\t\t\tif(ans>tmp){\n//\t\t\t\t\t\t\tans = tmp;\n//\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t}\n////\t\t\t\t\t\telse if(ans==tmp){\n////\t\t\t\t\t\t\tad = 0;\n////\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n////\t\t\t\t\t\t\tif(ad){\n////\t\t\t\t\t\t\t\tst = 1;\n////\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n////\t\t\t\t\t\t\t}\n////\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n////\t\t\t\t\t\t}\n//\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n//\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 100000\n#define MAXN 10000\n#define MAXD 100\n\nstruct Edge\n{\n    int t, c, r;\n};\n\nchar grid[MAXD+5][MAXD+5];\nint w, h;\nint prv[MAXN+5], vis[MAXN+5];\nvector<Edge> edge[MAXN+5];\n\nint get(int r, int c)\n{\n    if (r < 0 || r >= h || c < 0 || c >= w) return w*h*2+1;\n    return 2*(r*w+c);\n}\n\nint add(int f, int t, int c)\n{\n    Edge a = { t, c, (int)edge[t].size() };\n    Edge b = { f, 0, (int)edge[f].size() };\n    edge[f].push_back(a);\n    edge[t].push_back(b);\n}\n\nint maxflow(int n, int s, int t)\n{\n    int mf = 0;\n    while (true) {\n        queue<int> Q;\n        Q.push(s);\n        fill(vis, vis+n, false);\n        vis[s] = true;\n        while (!Q.empty()) {\n            int v = Q.front();\n            Q.pop();\n            for (int i = 0; i < edge[v].size(); ++i) {\n                Edge &e = edge[v][i];\n                if (!vis[e.t] && e.c > 0) {\n                    vis[e.t] = true;\n                    prv[e.t] = e.r;\n                    Q.push(e.t);\n                }\n            }\n        }\n        if (!vis[t]) break;\n        int flow = INF;\n        for (int v = t; v != s; v = edge[v][prv[v]].t) {\n            Edge &e = edge[v][prv[v]];\n            Edge &r = edge[e.t][e.r];\n            flow = min(flow, r.c);\n        }\n        for (int v = t; v != s; v = edge[v][prv[v]].t) {\n            Edge &e = edge[v][prv[v]];\n            Edge &r = edge[e.t][e.r];\n            e.c += flow;\n            r.c -= flow;\n        }\n        mf += flow;\n    }\n    return mf;\n}\n\nint main()\n{\n    scanf(\"%d%d\", &h, &w);\n    int s = 2*h*w, t = 2*h*w+1;\n    for (int i = 0; i < h; ++i) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < w; ++j) grid[i][j] = s[j];\n    }\n\n    int dr[] = {1,-1,0,0}, dc[] = {0,0,-1,1};\n    for (int r = 0; r < h; ++r) {\n        for (int c = 0; c < w; ++c) {\n            int idx = get(r,c);\n            if (grid[r][c] == 'X') {\n                add(s, idx, INF);\n                add(idx, idx+1, INF);\n            }\n            else add(idx, idx+1, 1);\n            for (int d = 0; d < 4; ++d) {\n                int nr = r+dr[d], nc = c+dc[d];\n                int nidx = get(nr, nc);\n                add(idx+1, nidx, INF);\n            }\n        }\n    }\n    int f = maxflow(2*h*w+2, s, t);\n    printf(\"%d\\n\", (f == INF) ? -1 : f);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\n#define INF (1 << 29)\nusing namespace std;\n\nstruct point{\n    int x, y;\n};\n\nchar f[105][105] = {0};\nbool fb[105][105] = {0};\nint h, w;\nstatic const int dy[4] = {0,1,0,-1};\nstatic const int dx[4] = {1,0,-1,0};\n\nbool CanEscape(){\n    rep(i,h) if(f[i][0] == 'X' || f[i][w - 1] == 'X') return 1;\n    rep(i,w) if(f[0][i] == 'X' || f[h - 1][i] == 'X') return 1;\n    return 0;\n}\n\nvoid check(){\n    rep(i,h){\n        rep(j,w){\n            if(f[i][j] == 'X'){\n                rep(k,4){\n                    int y = i + dy[k];\n                    int x = j + dx[k];\n                    if(y < 0 || y >= h || x < 0 || x >= w) continue;\n                    if(f[y][x] != 'X') fb[y][x] = 1;\n                }\n            }\n        }\n    }\n}\n\nbool canEscape(int y, int x){\n    bool isVisited[105][105] = {0};\n    queue<point> q;\n    point start_coordinate;\n    start_coordinate.x = x;\n    start_coordinate.y = y;\n\n    isVisited[start_coordinate.y][start_coordinate.x] = 1;\n    q.push(start_coordinate);\n\n    point u;\n    while(!q.empty()){\n        u = q.front(); q.pop();\n        rep(i,4){\n            point next;\n            next.x = u.x + dx[i];\n            next.y = u.y + dy[i];\n            if(next.y < 0 || next.y >= h || next.x < 0 || next.x >= w) return 1;\n            if(isVisited[next.y][next.x] == 0 && fb[next.y][next.x] == 0){\n                isVisited[next.y][next.x] = 1;\n                q.push(next);\n            }\n        }\n    }\n    return 0;\n}\n\nbool allGoatNotEscape(int y, int x, queue< pair<int, int> > q){\n    while(not q.empty()){\n        if(canEscape(q.front().first, q.front().second)) return 0;\n        q.pop();\n    }\n    return 1;\n}\n\nvoid deleteUselessFence(){\n    queue< pair<int, int> > q;\n    rep(i,h){\n        rep(j,w){\n            if(f[i][j] == 'X') q.push(make_pair(i,j));\n        }\n    }\n    rep(i,h){\n        rep(j,w){\n            if(fb[i][j] == 1 && f[i][j] != 'X'){\n                fb[i][j] = 0;\n                if(not allGoatNotEscape(i, j, q)) fb[i][j] = 1;\n            }\n        }\n    }\n}\n\nint countFence(){\n    int cnt = 0;\n    rep(i,h){\n        rep(j,w){\n            if(fb[i][j] == 1) cnt++;\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    cin >> h >> w;\n    rep(i,h) cin >> f[i];\n    if(CanEscape()){\n        cout << -1 << endl;\n    }else{\n        check();\n        deleteUselessFence();\n        cout << countFence() << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <stack>\nusing namespace std;\n\nconst int VSIZE=30000,ESIZE=100000;\n\nint MF(vector<vector<int> > &e,int s,int t)\n{\n  int n=e.size();\n  bool F[ESIZE]={0};\n  int K=0;\n  vector<vector<int> > fk(n),be(n),bfk(n);\n  for(int i=0;i<n;i++){\n    for(int j=0;j<e[i].size();j++){\n      int k=e[i][j];\n      fk[i].push_back(K);\n      be[k].push_back(i);\n      bfk[k].push_back(K);\n      K++;\n    }\n  }\n  int fl=0ll;\n  while(1){\n    int dis[VSIZE]={0};\n    queue<int> Q;\n    Q.push(s);\n    dis[s]=1;\n    while(!Q.empty()){\n      int i=Q.front();\n      Q.pop();\n      for(int j=0;j<e[i].size();j++){\n\tif(F[fk[i][j]]){\n\t  continue;\n\t}\n\tint k=e[i][j];\n\tif(!dis[k]){\n\t  Q.push(k);\n\t  dis[k]=dis[i]+1;\n\t}\n      }\n      for(int j=0;j<be[i].size();j++){\n\tif(!F[bfk[i][j]]){\n\t  continue;\n\t}\n\tint k=be[i][j];\n\tif(!dis[k]){\n\t  Q.push(k);\n\t  dis[k]=dis[i]+1;\n\t}\n      }\n    }\n    if(!dis[t]){\n      break;\n    }\n    while(1){\n      int B[VSIZE],FF[VSIZE];\n      for(int i=0;i<n;i++){\n\tB[i]=-1;\n      }\n      stack<int> Q;\n      Q.push(s);\n      while(!Q.empty()){\n\tint i=Q.top();\n\tQ.pop();\n\tif(i==t){\n\t  break;\n\t}\n\tfor(int j=0;j<e[i].size();j++){\n\t  int k=e[i][j];\n\t  if(dis[k]!=dis[i]+1||F[fk[i][j]]){\n\t    continue;\n\t  }\n\t  if(B[k]==-1){\n\t    Q.push(k);\n\t    B[k]=i;\n\t    FF[k]=fk[i][j]+1;\n\t  }\n\t}\n\tfor(int j=0;j<be[i].size();j++){\n\t  int k=be[i][j];\n\t  if(dis[k]!=dis[i]+1||!F[bfk[i][j]]){\n\t    continue;\n\t  }\n\t  if(B[k]==-1){\n\t    Q.push(k);\n\t    B[k]=i;\n\t    FF[k]=-bfk[i][j]-1;\n\t  }\n\t}\n      }\n      if(B[t]==-1){\n\tbreak;\n      }\n      fl+=1;\n      for(int i=t;i!=s;i=B[i]){\n\tint J=FF[i];\n\tif(J>0){\n\t  int j=J-1;\n\t  F[j]=1;\n\t}\n\telse{\n\t  int j=-J-1;\n\t  F[j]=0;\n\t}\n      }\n    }\n  }\n  return fl;\n}\n\nint main()\n{\n  int h,w;\n  scanf(\"%d%d\",&h,&w);\n  static char M[100][101];\n  for(int i=0;i<h;i++){\n    scanf(\"%s\",M[i]);\n  }\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if((i==0||i==h-1||j==0||j==w-1)&&M[i][j]=='X'){\n\tputs(\"-1\");\n\treturn 0;\n      }\n    }\n  }\n  vector<vector<int> > e(2*h*w+2);\n  int s=2*h*w,t=s+1;\n  int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(M[i][j]=='X'){\n\tfor(int v=0;v<4;v++){\n\t  int x=i+dx[v],y=j+dy[v];\n\t  e[s].push_back(x*w+y);\n\t}\n      }\n      else{\n\tint k=i*w+j,l=h*w+k;\n\te[k].push_back(l);\n\tfor(int v=0;v<4;v++){\n\t  int x=i+dx[v],y=j+dy[v];\n\t  if(0<=x&&x<h&&0<=y&&y<w){\n\t    e[l].push_back(x*w+y);\n\t  }\n\t  else{\n\t    e[l].push_back(t);\n\t  }\n\t}\n      }\n    }\n  }\n  printf(\"%d\\n\",MF(e,s,t));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iomanip>\n \nusing namespace std;\n \ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<LD, LD> PLDLD;\ntypedef vector<int> VI;\ntypedef vector<char> VB;\n \n#define FOR(i,a,b) for(int i=(a);i<(int)(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define ALL(a) a.begin(),a.end()\n \nconst LD eps=1e-5;\n//const long long INF=(LL)(1e9)*(LL)(1e9);\nconst int INF=1e6;\n \ntemplate<class T>\nvoid chmin(T& a, const T& b)\n{\n\tif(a>b)\n\t\ta=b;\n}\ntemplate<class T>\nvoid chmax(T& a, const T& b)\n{\n\tif(a<b)\n\t\ta=b;\n}\n \nconst LL pow(const LL p, const LL q)\n{\n\tLL t=1;\n\tREP(i,q)\n\t\tt*=p;\n\treturn t;\n}\n\n//print for container\n/*\ntemplate<typename Iterator>\nvoid print(const Iterator& first, const Iterator& last)\n{\n\tauto&& back=prev(last);\n\tfor(auto e=first; e!=last; e=next(e))\n\t\tcout<<*e<<\" \\n\"[e==back];\n}*/\n\ntemplate<typename Head>\nvoid print(const Head& head)\n{\n\tcout<<head<<endl;\n}\n\ntemplate<typename Head, typename... Tail>\nvoid print(const Head& head, const Tail&... tail)\n{\n\tcout<<head<<\" \";\n\tprint(tail...);\n}\n\nvoid io_speedup()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n}\n\ntemplate<typename T>\nT read()\n{\n\tT t;\n\tcin>>t;\n\treturn t;\n}\n\n//set INF\nusing FLOW = long long;\nstruct Edge\n{\n    int to;\n    FLOW cap;\n    int rev;\n};\nclass FlowNetwork\n{\n    public:\n        FlowNetwork(int n):graph(vector<vector<Edge>>(n)),iter(vector<int>(n)),level(vector<int>(n))\n        {}\n        void add_Edge(int from, int to, FLOW cap);\n        FLOW dinic(int from, int to);\n\n    private:\n        vector<vector<Edge>> graph;\n        vector<int> iter, level;\n        FLOW dfs(int from, int to, FLOW cap);\n        void bfs(int from);\n};\nvoid FlowNetwork::add_Edge(int from, int to, FLOW cap)\n{\n    //cout<<from<<\":\"<<to<<\" \"<<cap<<endl;\n\tgraph[from].push_back((Edge){to,cap,(int)graph[to].size()});\n\tgraph[to].push_back((Edge){from,0,(int)graph[from].size()-1});\n}\n\nvoid FlowNetwork::bfs(int from)\n{\n    fill(level.begin(),level.end(),-1);\n    queue<int> que;\n    level[from]=0;\n    que.push(from);\n    while(!que.empty())\n    {\n        int v=que.front();\n        que.pop();\n        for(int i=0;i<graph[v].size();i++)\n        {\n            Edge &e=graph[v][i];\n            if(e.cap>0 && level[e.to]<0)\n            {\n                level[e.to] = level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nFLOW FlowNetwork::dfs(int from, int to, FLOW f)\n{\n\tif(from == to) return f;\n\tfor(int &i=iter[from];i<graph[from].size();i++)\n\t{\n\t\tEdge &e=graph[from][i];\n        if(e.cap > 0 && level[from] < level[e.to])\n        {\n            FLOW d = dfs(e.to, to, min(e.cap, f));\n            if(d>0)\n            {\n                e.cap -= d;\n                graph[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n\t}\n\treturn 0;\n}\nFLOW FlowNetwork::dinic(int from, int to)\n{\n    FLOW flow=0;\n\twhile(1)\n\t{\n        bfs(from);\n        if(level[to]<0) return flow;\n        fill(iter.begin(),iter.end(),0);\n        FLOW f;\n        while((f=dfs(from,to,INF))>0)\n        {\n            flow+=f;\n        }\n\t}\n}\n\nint dx[]={1,0,-1,0}, dy[]={0,1,0,-1};\nint main()\n{\n\tint h,w;\n\tcin>>h>>w;\n\tauto ptoi=[&](int x,int y)\n\t{\n\t\treturn x*h+y;\n\t};\n\tFlowNetwork flow(w*h*2+2);\n\tREP(j,h)\n\tREP(i,w)\n\t{\n\t\tREP(k,4)\n\t\t{\n\t\t\tint px=i+dx[k],py=j+dy[k];\n\t\t\tif(!(0<=px&&px<w&&0<=py&&py<h)) continue;\n\t\t\tflow.add_Edge(ptoi(i,j)+w*h,ptoi(px,py),INF);\n\t\t}\n\t}\n\tREP(j,h)\n\t{\n\t\tstring s=read<string>();\n\t\tREP(i,w)\n\t\t{\n\t\t\tif(s[i]=='.')\n\t\t\t{\n\t\t\t\tflow.add_Edge(ptoi(i,j),ptoi(i,j)+w*h,1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tflow.add_Edge(ptoi(i,j),ptoi(i,j)+w*h,INF);\n\t\t\t\tflow.add_Edge(ptoi(i,j)+w*h, w*h*2+1, INF);\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,w)\n\t{\n\t\tflow.add_Edge(w*h*2, ptoi(i,0), INF);\n\t\tflow.add_Edge(w*h*2, ptoi(i,h-1), INF);\n\t}\n\tREP(j,h)\n\t{\n\t\tflow.add_Edge(w*h*2, ptoi(0,j), INF);\n\t\tflow.add_Edge(w*h*2, ptoi(w-1,j), INF);\n\t}\n\tint ans=flow.dinic(w*h*2,w*h*2+1);\n\tif(ans>=INF) ans=-1;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DBG(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n\nusing uint=unsigned int;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\tscanf(\"%d\",&i);\n\treturn i;\n}\n\nvoid Yes(){\n\tcout<<\"Yes\"<<endl;\n\texit(0);\n}\n\nvoid No(){\n\tcout<<\"No\"<<endl;\n\texit(0);\n}\n\ntemplate<class T>\nvoid chmax(T& a,T b){\n\ta=max(a,b);\n}\n\ntemplate<class T>\nvoid chmin(T& a,T b){\n\ta=min(a,b);\n}\n\ntemplate<class T>\nvoid ResetVector(vector<T>& v,int n,const T& t){\n\tv.clear();\n\tv.resize(n,t);\n}\n\nint main(){\n\tint h=read(),w=read();\n\tvector<string> board(h);\n\tREP(i,h)\n\t\tcin>>board[i];\n\tREP(i,w)if(board[0][i]=='X'){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tREP(i,w)if(board[h-1][i]=='X'){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tREP(i,h)if(board[i][0]=='X'){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tREP(i,h)if(board[i][w-1]=='X'){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tint dx[]={0,1,0,-1},dy[]={-1,0,1,0};\n\tREP(i,h)REP(j,w)if(board[i][j]=='X'){\n\t\tREP(k,4){\n\t\t\tint y=i+dy[k],x=j+dx[k];\n\t\t\tif(0<=y&&y<h&&0<=x&&x<w){\n\t\t\t\tif(board[y][x]=='.')\n\t\t\t\t\tboard[y][x]='#';\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<bool>> vis(h,vector<bool>(w,false));\n\tfunction<void(int,int)> dfs;\n\tdfs=[&](int i,int j){\n\t\tif(vis[i][j])\n\t\t\treturn;\n\t\tvis[i][j]=true;\n\t\tif(board[i][j]=='#')\n\t\t\treturn;\n\t\tREP(k,4){\n\t\t\tint y=i+dy[k],x=j+dx[k];\n\t\t\tif(0<=y&&y<h&&0<=x&&x<w)\n\t\t\t\tdfs(y,x);\n\t\t}\n\t};\n\tREP(i,w)\n\t\tdfs(0,i);\n\tREP(i,w)\n\t\tdfs(h-1,i);\n\tREP(i,h)\n\t\tdfs(i,0);\n\tREP(i,h)\n\t\tdfs(i,w-1);\n\tint ans=0;\n\tREP(i,h)REP(j,w)\n\t\tif(board[i][j]=='#'&&vis[i][j])\n\t\t\tans++;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }\n\n#define each(it,o) for(auto it = (o).begin(); it != (o).end(); ++ it)\n\nstruct MaximumFlow {\n\ttypedef int Index;\n\ttypedef int Flow;\n\tstatic const Flow InfCapacity = INF;\n\tstruct Edge {\n\t\tIndex to;\n\t\tFlow capacity;\n\t\tIndex rev;\n\t};\n\tvector<vector<Edge> > g;\n\tvoid init(Index n) { g.assign(n, vector<Edge>()); }\n\tvoid add(Index i, Index j, Flow capacity) {\n\t\tEdge e, f; e.to = j, f.to = i; e.capacity = capacity, f.capacity = 0;\n\t\tg[i].push_back(e); g[j].push_back(f);\n\t\tg[i].back().rev = (Index)g[j].size() - 1; g[j].back().rev = (Index)g[i].size() - 1;\n\t}\n\tvoid addB(Index i, Index j, Flow capacity) {\n\t\tEdge e, f; e.to = j, f.to = i; e.capacity = capacity, f.capacity = capacity;\n\t\tg[i].push_back(e); g[j].push_back(f);\n\t\tg[i].back().rev = (Index)g[j].size() - 1; g[j].back().rev = (Index)g[i].size() - 1;\n\t}\n\t//gを破壊する\n\tFlow maximumFlow(int s, int t) {\n\t\tint n = g.size();\n\t\tvector<Index> level(n);\n\t\tFlow total = 0; bool update;\n\t\tdo {\n\t\t\tupdate = false;\n\t\t\tfill(level.begin(), level.end(), -1); level[s] = 0;\n\t\t\tqueue<Index> q; q.push(s);\n\t\t\tfor(Index d = n; !q.empty() && level[q.front()] < d; ) {\n\t\t\t\tint u = q.front(); q.pop();\n\t\t\t\tif(u == t) d = level[u];\n\t\t\t\teach(e, g[u]) if(e->capacity > 0 && level[e->to] == -1)\n\t\t\t\t\tq.push(e->to), level[e->to] = level[u] + 1;\n\t\t\t}\n\t\t\tvector<Index> iter(n);\n\t\t\tfor(Index i = 0; i < n; i ++) iter[i] = (int)g[i].size() - 1;\n\t\t\twhile(1) {\n\t\t\t\tFlow f = augment(level, iter, s, t, InfCapacity);\n\t\t\t\tif(f == 0) break;\n\t\t\t\ttotal += f; update = true;\n\t\t\t}\n\t\t} while(update);\n\t\treturn total;\n\t}\n\tFlow augment(vector<Index> &level, vector<Index> &iter, Index u, Index t, Flow f) {\n\t\tif(u == t || f == 0) return f;\n\t\tIndex lv = level[u];\n\t\tif(lv == -1) return 0;\n\t\tlevel[u] = -1;\n\t\tfor(; iter[u] >= 0; -- iter[u]) {\n\t\t\tEdge &e = g[u][iter[u]];\n\t\t\tif(level[e.to] <= lv) continue;\n\t\t\tFlow l = augment(level, iter, e.to, t, min(f, e.capacity));\n\t\t\tif(l == 0) continue;\n\t\t\te.capacity -= l; g[e.to][e.rev].capacity += l;\n\t\t\tlevel[u] = lv;\n\t\t\treturn l;\n\t\t}\n\t\treturn 0;\n\t}\n};\n\nint main() {\n\tint H; int W;\n\twhile(~scanf(\"%d%d\", &H, &W)) {\n\t\tvector<string> S(H);\n\t\trep(i, H) {\n\t\t\tchar buf[101];\n\t\t\tscanf(\"%s\", buf);\n\t\t\tS[i] = buf;\n\t\t}\n\t\tMaximumFlow mf;\n\t\tint src = H * W * 2, src2 = src + 1, dst = src2 + 1;\n\t\tmf.init(dst + 1);\n\t\trep(i, H) rep(j, W) {\n\t\t\tstatic const int dy[4] = { 0, 1, 0, -1 }, dx[4] = { 1, 0, -1, 0 };\n\t\t\tfor(int d = 0; d < 4; ++ d) {\n\t\t\t\tint yy = i + dy[d], xx = j + dx[d];\n\t\t\t\tif(yy < 0 || yy >= H || xx < 0 || xx >= W) {\n\t\t\t\t\tmf.add(H * W + i * W + j, dst, INF);\n\t\t\t\t} else {\n\t\t\t\t\tmf.add(H * W + i * W + j, yy * W + xx, INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(S[i][j] == 'X') {\n\t\t\t\tmf.add(src2, i * W + j, INF);\n\t\t\t\tmf.add(i * W + j, H * W + i * W + j, INF);\n\t\t\t} else {\n\t\t\t\tmf.add(i * W + j, H * W + i * W + j, 1);\n\t\t\t}\n\t\t}\n\t\tmf.add(src, src2, INF);\n\t\tint ans = mf.maximumFlow(src, dst);\n\t\tprintf(\"%d\\n\", ans == INF ? -1 : ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nstring s[101]=\"\";\n\nvoid checkdiag(int x,int y){\n    if(s[x-1][y]=='#' && s[x][y-1]=='#'){\n        if(s[x-1][y+1]=='#' && s[x+1][y-1]=='#'){\n            s[x-1][y-1]='.';\n            s[x-1][y]='.';\n            s[x][y-1]='.';\n            s[x][y]='#';\n            \n        }\n    }\n    if(s[x+1][y]=='#' && s[x][y+1]=='#'){\n        if(s[x-1][y+1]=='#' && s[x+1][y-1]=='#'){\n            s[x+1][y+1]='.';\n            s[x+1][y]='.';\n            s[x][y+1]='.';\n            s[x][y]='#';\n            checkdiag(x-1,y);\n            checkdiag(x,y-1);\n        }\n    }\n    if(s[x+1][y]=='#' && s[x][y-1]=='#'){\n        if(s[x-1][y-1]=='#' && s[x+1][y+1]=='#'){\n            s[x+1][y-1]='.';\n            s[x+1][y]='.';\n            s[x][y-1]='.';\n            s[x][y]='#';\n            checkdiag(x-1,y);\n        }\n    }\n    if(s[x-1][y]=='#' && s[x][y+1]=='#'){\n        if(s[x-1][y-1]=='#' && s[x+1][y+1]=='#'){\n            s[x-1][y+1]='.';\n            s[x-1][y]='.';\n            s[x][y+1]='.';\n            s[x][y]='#';\n            checkdiag(x,y-1);\n        }\n    }\n}\n\nint main(){\n    \n    int minx=1e4,miny=1e4,maxx=0,maxy=0;\n    int h=0,w=0;\n    cin>>h>>w;\n\n    //input]\n    for(int i=0;i<h;i++) cin>>s[i];\n\n    //edge goats\n    for(int i=0;i<h;i++){\n        if(s[0][i]=='X' || s[i][0]=='X' || s[h-1][i]=='X' || s[i][w-1]=='X'){\n            cout<<-1<<endl;\n            return 0;\n        }\n    }\n    // cout<<endl; \n    //squaring\n    for(int i=1;i<h-1;i++){\n        for(int j=1;j<w-1;j++){\n            if(s[i][j]=='X'){\n                minx=min(minx,j);\n                miny=min(miny,i);\n                maxx=max(maxx,j);\n                maxy=max(maxy,i);\n            }\n        }\n    }\n    minx--,miny--,maxx++,maxy++;\n\n    //fencing\n    for(int i=minx+1;i<maxx;i++){\n        s[miny][i]='#';\n        s[maxy][i]='#';\n    }\n    for(int i=miny+1;i<maxy;i++){\n        s[i][minx]='#';\n        s[i][maxx]='#';\n    }\n\n    // for(int i=0;i<h;i++){\n    //     cout<<s[i]<<endl;\n    // }\n    // cout<<endl;\n\n    //diagonals\n    for(int i=1;i<h-1;i++){\n        for(int j=1;j<w-1;j++){\n            checkdiag(i,j);\n        }\n    }\n\n    // for(int i=0;i<h;i++){\n    //     cout<<s[i]<<endl;\n    // }\n    int c=0;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            c+=s[i][j]=='#';\n        }\n    }\n    cout<<c<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//四則演算 #pragma GCC target(\"avx\")\n//並列計算 #pragma GCC optimize(\"O3\")\n//条件分岐を減らす #pragma GCC optimize(\"unroll-loops\")\n//浮動小数点演算 #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing VI = vector<int>;\nusing VL = vector<ll>;\nusing VS = vector<string>;\ntemplate<class T> using PQ = priority_queue<T, vector<T>, greater<T>>;\n#define FOR(i,a,n) for(int i=(a);i<(n);++i)\n#define eFOR(i,a,n) for(int i=(a);i<=(n);++i)\n#define rFOR(i,a,n) for(int i=(n)-1;i>=(a);--i)\n#define erFOR(i,a,n) for(int i=(n);i>=(a);--i)\n#define each(i, a) for(auto &i : a)\n#define SORT(a) sort(a.begin(),a.end())\n#define rSORT(a) sort(a.rbegin(),a.rend())\n#define fSORT(a,f) sort(a.begin(),a.end(),f)\n#define all(a) a.begin(),a.end()\n#define out(y,x) ((y)<0||h<=(y)||(x)<0||w<=(x))\n#define tp(a,i) get<i>(a)\n#define line cout << \"-----------------------------\\n\" \n#define ENDL(i,n) ((i) == (n) - 1 ? \"\\n\" : \" \")\n#define stop system(\"pause\")\nconstexpr ll INF = 1000000000;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr ll mod = 1000000007;\nconstexpr ll MOD = 998244353;\nconstexpr ld eps = 1e-10;\nconstexpr ld pi = 3.1415926535897932;\ntemplate<class T>inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T>inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; }return false; }\ninline void init() { cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); }\ntemplate<class T>inline istream& operator>>(istream& is, vector<T>& v) { for (auto& a : v)is >> a; return is; }\ntemplate<class T>inline istream& operator>>(istream& is, deque<T>& v) { for (auto& a : v)is >> a; return is; }\ntemplate<class T, class U>inline istream& operator>>(istream& is, pair<T, U>& p) { is >> p.first >> p.second; return is; }\ntemplate<class T>inline vector<T> vec(size_t a) { return vector<T>(a); }\ntemplate<class T>inline vector<T> defvec(T def, size_t a) { return vector<T>(a, def); }\ntemplate<class T, class... Ts>inline auto vec(size_t a, Ts... ts) { return vector<decltype(vec<T>(ts...))>(a, vec<T>(ts...)); }\ntemplate<class T, class... Ts>inline auto defvec(T def, size_t a, Ts... ts) { return vector<decltype(defvec<T>(def, ts...))>(a, defvec<T>(def, ts...)); }\ntemplate<class T>inline void print(const T& a) { cout << a << \"\\n\"; }\ntemplate<class T, class... Ts>inline void print(const T& a, const Ts&... ts) { cout << a << \" \"; print(ts...); }\ntemplate<class T>inline void print(const vector<T>& v) { for (int i = 0; i < v.size(); ++i)cout << v[i] << (i == v.size() - 1 ? \"\\n\" : \" \"); }\ntemplate<class T>inline void print(const vector<vector<T>>& v) { for (auto& a : v)print(a); }\ninline string reversed(const string& s) { string t = s; reverse(all(t)); return t; }\n\nint main() {\n    init();\n\n    int h, w; cin >> h >> w;\n    VS s(h); cin >> s;\n    \n    constexpr int dy[4] = { -1,0,0,1 }, dx[4] = { 0,-1,1,0 };\n    FOR(y, 0, h)FOR(x, 0, w) {\n        if (s[y][x] != 'X')continue;\n        FOR(i, 0, 4) {\n            int ny = y + dy[i], nx = x + dx[i];\n            if (out(ny, nx)) {\n                print(-1);\n                return 0;\n            }\n            if (s[ny][nx] != 'X')s[ny][nx] = 'O';\n        }\n    }\n\n    auto dp = defvec<int>(INF, h, w);\n    queue<pair<int, int>> bfs;\n    function<void(int, int)> bfs_init = [&](int y, int x)->void {\n        if (s[y][x] == '.') {\n            dp[y][x] = 0;\n            bfs.emplace(y, x);\n        }\n    };\n    FOR(y, 0, h)bfs_init(y, 0), bfs_init(y, w - 1);\n    FOR(y, 0, h)bfs_init(y, 0), bfs_init(y, w - 1);\n    while (!bfs.empty()) {\n        int y, x;\n        tie(y, x) = bfs.front();\n        bfs.pop();\n        FOR(i, 0, 4) {\n            int ny = y + dy[i], nx = x + dx[i];\n            if (out(ny, nx))continue;\n            if (s[ny][nx] != '.')continue;\n            if (!chmin(dp[ny][nx], dp[y][x] + 1))continue;\n            bfs.emplace(ny, nx);\n        }\n    }\n\n    int ans = 0;\n    FOR(y, 0, h)FOR(x, 0, w) {\n        if (s[y][x] != 'O')continue;\n        bool need = false;\n        FOR(i, 0, 4) {\n            int ny = y + dy[i], nx = x + dx[i];\n            if (need |= out(ny, nx))continue;\n            need |= dp[ny][nx] != INF;\n        }\n        if (need)++ans;\n    }\n\n    print(ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans-5<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 2e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nstruct edge { int to, cap, rev; };\n\nconst int MAX_V = 20010;\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid addEdge(int from, int to, int cap) {\n    G[from].emplace_back((edge){to, cap, (int)G[to].size()});\n    G[to].emplace_back((edge){from, 0, (int)G[from].size() - 1});\n}\n\nvoid bfs(int s) {\n    memset(level, -1, sizeof(level));\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n        int v = que.front(); que.pop();\n        for (int i = 0; i < G[v].size(); i++) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    for (int &i = iter[v]; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[v] < level[e.to]) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    for (;;) {\n        bfs(s);\n        if (level[t] < 0) return flow;\n        memset(iter, 0, sizeof(iter));\n        int f;\n        while ((f = dfs(s, t, inf)) > 0) {\n            flow += f;\n        }\n    }\n}\n\n#define dame cout << -1 << endl; return 0;\n\n// N, E, S, W\nconst int dx[4] = {-1, 0,  1,  0};\nconst int dy[4] = { 0, 1,  0, -1};\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n    vector<string> s(n);\n    rep(i, n) cin >> s[i];\n\n    // rep(i, n) {\n    //     if (s[i][0] == 'X' || s[i].back() == 'X') {\n    //         dame;\n    //     }\n    // }\n    //\n    // rep(j, m) {\n    //     if (s[0][j] == 'X' || s.back()[j] == 'X') {\n    //         dame;\n    //     }\n    // }\n\n    enum {IN, OUT};\n    auto toNode = [&](int i, int j, int in) {\n        return i * m + j + (in ? 0 : n * m);\n    };\n\n    auto inside = [&](int i, int j) {\n        return 0 <= i && i < n && 0 <= j && j < m;\n    };\n\n    const int src = 2 * n * m;\n    const int fin = 2 * n * m + 1;\n    rep(i, n) {\n        rep(j, m) {\n            if (s[i][j] == 'X') {\n                addEdge(src, toNode(i, j, OUT), inf);\n            }\n            addEdge(toNode(i, j, IN), toNode(i, j, OUT), (s[i][j] == 'X' ? inf : 1));\n\n            rep(k, 4) {\n                int ni = i + dx[k], nj = j + dy[k];\n                if (inside(ni, nj)) {\n                    addEdge(toNode(i, j, OUT), toNode(ni, nj, IN), inf);\n                }\n                else {\n                    addEdge(toNode(i, j, OUT), fin, inf);\n                }\n            }\n        }\n    }\n\n    int ans = max_flow(src, fin);\n    cout << (ans < inf ? ans : -1) << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\nstruct Dinic {\n  #define MAX_V 30000\n  struct Edge { int to, cap, rev; };\n  vector<Edge> G[MAX_V];\n  int level[MAX_V], iter[MAX_V];\n  void add_edge(int x, int y, int cap) {\n    G[x].pb({ y, cap, (int)G[y].size() });\n    G[y].pb({ x, 0, (int)G[x].size()-1 });\n  }\n  void bfs(int s) {\n    rep(i, MAX_V) level[i] = INF;\n    queue<int> q;\n    q.push(s);\n    level[s] = 0;\n    while (!q.empty()) {\n      int x = q.front(); q.pop();\n      for (Edge e : G[x]) {\n        if (e.cap > 0 && level[e.to] == INF) {\n          level[e.to] = level[x]+1;\n          q.push(e.to);\n        }\n      }\n    }\n  }\n  int dfs(int x, int goal, int f) {\n    if (x == goal) return f;\n    for (int &i=iter[x]; i<G[x].size(); i++) {\n      Edge &e = G[x][i];\n      if (e.cap > 0 && level[x] < level[e.to]) {\n        int w = dfs(e.to, goal, min(f, e.cap));\n        if (w > 0) {\n          e.cap -= w;\n          G[e.to][e.rev].cap += w;\n          return w;\n        }\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t) {\n    int flow = 0;\n    while (true) {\n      bfs(s);\n      if (level[t] == INF) return flow;\n      rep(i, MAX_V) iter[i] = 0;\n      while (true) {\n        int f = dfs(s, t, INF);\n        if (f == 0) break;\n        flow += f;\n      }\n    }\n  }\n};\nDinic dinic;\n\nint H, W;\nchar A[100][100];\nint IN[100][100], OUT[100][100];\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> H >> W;\n  int V = 0;\n  rep(y, H) {\n    rep(x, W) {\n      cin >> A[x][y];\n      if (A[x][y] == 'X') {\n        IN[x][y] = OUT[x][y] = V++;\n      }\n      else {\n        IN[x][y] = V++;\n        OUT[x][y] = V++;\n        dinic.add_edge(IN[x][y], OUT[x][y], 1);\n      }\n    }\n  }\n  int s = V++, t = V++;\n  rep(x, W) rep(y, H) {\n    if (A[x][y] == 'X') dinic.add_edge(s, IN[x][y], INF);\n  }\n  rep(x, W) rep(y, H) if (x == 0 || x == W-1 || y == 0 || y == H-1) {\n    if (A[x][y] == 'X') {\n      cout << -1 << \"\\n\";\n      return 0;\n    }\n    dinic.add_edge(OUT[x][y], t, INF);\n  }\n  rep(x, W-1) rep(y, H) dinic.add_edge(OUT[x][y], IN[x+1][y], INF), dinic.add_edge(OUT[x+1][y], IN[x][y], INF);\n  rep(x, W) rep(y, H-1) dinic.add_edge(OUT[x][y], IN[x][y+1], INF), dinic.add_edge(OUT[x][y+1], IN[x][y], INF);\n  cout << dinic.max_flow(s, t) << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define all(x) x.begin(),x.end()\n#define SZ(x) (int)(x.size())\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,a,b) for(int i=b-1;i>=a;i--)\n#define inf 1000000007\n#define mod 1000000007\n#define x first\n#define y second\n#define pi acos(-1.0)\n#define DBG(x) cerr<<(#x)<<\"=\"<<x<<\"\\n\";\n//#define dprintf(...) \n#define hash _hash\n#define next _next\n//#define dprintf(...) fprintf(outFile,__VA_ARGS__)\n \n#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define ull unsigned long long\n#define ll long long\n#define N 50010\n \ntemplate <class T,class U>inline void Max(T &a,U b){if(a<b)a=b;}\ntemplate <class T,class U>inline void Min(T &a,U b){if(a>b)a=b;}\n \n//FILE* outFile;\ninline void add(int &a,int b){a+=b;while(a>=mod)a-=mod;}\n\n\nint pow(int a,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=ans*(ll)a%mod;\n        a=(ll)a*a%mod;b>>=1;\n    }\n    return ans;\n}\n\nchar s[110][110];\nint vis[110][110],is[110][110];\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nint main(){\n    int T,i,j,k,ca=0,m,n,K;\n    //cout<<setprecision(10)<<fixed;\n    scanf(\"%d%d\",&n,&m);\n    rep(i,0,n)scanf(\"%s\",s[i]);\n    queue<pii>q;\n    rep(i,0,n){\n    \tif(s[i][0]=='X'||s[i][m-1]=='X'){puts(\"-1\");return 0;}\n    \tq.push({i,0});vis[i][0]=1;\n    \tq.push({i,m-1});vis[i][m-1]=1;\n    }\n    rep(i,0,m){\n    \tif(s[0][i]=='X'||s[n-1][i]=='X'){puts(\"-1\");return 0;}\n    \tif(!vis[0][i])vis[0][i]=1,q.push({0,i});\n    \tif(!vis[n-1][i])vis[n-1][i]=1,q.push({n-1,i});\n    }\n    while(!q.empty()){\n    \tint x=q.front().x,y=q.front().y;q.pop();\n    \tis[x][y]=1;int ok=1,x1=-1,y1,cnt=0;\n    \trep(k,0,4){\n    \t\tint nx=x+dx[k],ny=y+dy[k];\n    \t\tif(nx>0&&nx<n-1&&ny>0&&ny<m-1){\n    \t\t\tif(s[nx][ny]=='X'){ok=0;break;}\n    \t\t\tif(!vis[nx][ny])x1=nx,y1=ny,cnt++;\n    \t\t}\n    \t}\n    \tif(ok){\n    \t\tis[x][y]=0;\n    \t\tif(x1!=-1){\n    \t\t\t//DBG(cnt)\n    \t\t\tvis[x1][y1]=1;\n    \t\t\tq.push({x1,y1});\n    \t\t}\n    \t}\n    }\n    int ans=0;\n    rep(i,0,n)rep(j,0,m)ans+=is[i][j];\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n  go\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\nusing ll = long long;\n\nconst int INF = 1e9;\n\nint h,w;\nchar g[111][111];\n\nint di[] = {0,1,0,-1};\nint dj[] = {1,0,-1,0};\n\nint solve(){\n    rep(i,h)rep(j,w){\n        if(g[i][j] == 'X'){\n            rep(d,4){\n                int ni = i+di[d];\n                int nj = j+dj[d];\n                if(ni < 0 || nj < 0 || ni >= h || nj >= w) return -1;\n                if(g[ni][nj] != 'X'){\n                    g[ni][nj] = '#';\n                }\n            }\n        }\n    }\n\n    // rep(i,h){\n    //     rep(j,w){\n    //         cout << g[i][j];\n    //     }\n    //     cout << endl;\n    // }\n\n\n    int vis[111][111] = {};\n\n    queue<pair<int,int>> q;\n    rep(i,h)rep(j,w){\n        if(i == 0 || j == 0 || i == h-1 || j == w-1){\n            if(g[i][j] == '.'){\n                q.emplace(i,j);\n            }\n        }\n    }\n\n    while(q.size()){\n        int ci,cj;\n        tie(ci,cj) = q.front();\n        q.pop();\n        if(vis[ci][cj]) continue;\n        vis[ci][cj] = true;\n\n        rep(d,4){\n            int ni = ci+di[d];\n            int nj = cj+dj[d];\n            if(ni < 0 || nj < 0 || ni >= h || nj >= w) continue;\n            if(g[ni][nj] == '#'){\n                vis[ni][nj] = true;\n            }\n            if(g[ni][nj] == '.' && !vis[ni][nj]){\n                q.emplace(ni,nj);\n            }\n        }\n    }\n    int ans = 0;\n    rep(i,h)rep(j,w){\n        if(g[i][j] == '#' && (vis[i][j] || i == 0 || j == 0 || i == h-1 || j == w-1)){\n            ++ans;\n        }\n    }\n    return ans;\n}\n\n\nint main(){\n    while(cin >> h >> w){\n        rep(i,h) cin >> g[i];\n        cout << solve() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<20\n#define EPS (1e-6)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef complex<double> P;\n\nbool cmp(P a, P b){\n\tdouble arga = arg(a);\n\tdouble argb = arg(b);\n\tif(!EQ(arga, argb)){\n\t\treturn arga < argb;\n\t} // end if\n\t\n\treturn abs(a) > abs(b);\n}\n\nconst int MAX_H = 105;\nconst int MAX_W = 105;\n\nconst int dy[4] = {-1, 0, 1, 0};\nconst int dx[4] = { 0, 1, 0,-1};\nchar field[MAX_H][MAX_W];\nint d[MAX_H][MAX_W];\nint H, W;\n\nbool bfs(char target, int sy, int sx){\n\tqueue<pair<int,int> > que;\n\trep (i, MAX_H) rep (j, MAX_W) d[i][j] = INF;\n\tque.push(make_pair(sy,sx));\n\td[sy][sx] = 0;\n\t\n\twhile(!que.empty()){\n\t\tpair<int,int> curr = que.front(); que.pop();\n\t\tint cy = curr.first;\n\t\tint cx = curr.second;\n\n\t\t// 領域の外に出た\n\t\tif (cy == 0 || cy == H + 1 || cx == 0 || cx == W + 1){\n\t\t\treturn true;\n\t\t} // end if\n\n\t\trep(k, 4){\n\t\t\tint ny = cy + dy[k];\n\t\t\tint nx = cx + dx[k];\n\t\t\tif (ny < 0 || ny > H + 1 || nx < 0 || nx > W + 1) continue;\n\t\t\t\n\t\t\tif (d[ny][nx] > d[cy][cx] + 1){\n\t\t\t\tif(\n\t\t\t\t\t   ((target == 'O') && (field[ny][nx] == '.'))\n\t\t\t\t\t|| ((target == 'X') && (field[ny][nx] != 'O'))\n\t\t\t\t){\n\t\t\t\t\tque.push(make_pair(ny,nx));\n\t\t\t\t\td[ny][nx] = d[cy][cx] + 1;\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end while\n\n\treturn false;\t\n}\n\n\nvoid disp_field(void){\n\tcerr << endl;\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tcerr << field[i][j];\n\t\t} // end for\n\t\tcerr << endl;\n\t} // end for\n}\n\nint main()\n{\n\tmemset (field, 0, sizeof(field));\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\trep (i, MAX_H) rep (j, MAX_W) field[i][j] = '.';\n\tcin >> H >> W;\n\tvector<string> s(H);\n\trep (i, H) cin >> s[i];\n\n\tset<pair<int,int> > origin; origin.clear();\n\n\tvector<P> p; p.clear();\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tfield[i][j] = s[i-1][j-1];\n\t\t\tif (field[i][j] == 'X'){\n\t\t\t\torigin.insert(make_pair(i,j));\n\t\t\t\tp.push_back(P(i - H / 2., j - W / 2.));\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\tsort (ALL(p),cmp);\n\n\tint m = p.size();\n\trep (i, m){\n\t\tint cy1 = (int)(p[i].imag());\n\t\tint cy2 = (int)(p[(i+1) % m].imag());\n\t\tint cx1 = (int)(p[i].real());\n\t\tint cx2 = (int)(p[(i+1) % m].real());\n\t\tint leny = abs(cy1 - cy2);\n\t\tint lenx = abs(cx1 - cx2);\n\n\t\tint cnt = 0;\n\t\tif (leny > lenx){\n\t\t\tfor (int y = cy1; (cy1 <= cy2 ? y < cy2 : y > cy2); y += (cy1 <= cy2 ? +1 : -1), ++cnt);\n\t\t\tfor (int dy = 1; dy < cnt; ++dy){\n\t\t\t\tint dx = ((cx2 - cx1) / cnt) * dy;\n\t\t\t\tint ny = cy1 + dy * (cy1 <= cy2 ? +1 : -1) + H / 2;\n\t\t\t\tint nx = cx1 + dx + W / 2;\n\t\t\t\tfield[ny][nx] = 'x';\n\t\t\t} // end rep\n\t\t}else{\t// if (leny <= lenx)\n\t\t\tfor (int x = cx1; (cx1 <= cx2 ? x < cx2 : x > cx2); x += (cx1 <= cx2 ? +1 : -1), ++cnt);\n\t\t\tfor (int dx = 1; dx < cnt; ++dx){\n\t\t\t\tint dy = ((cy2 - cy1) / cnt) * dx;\n\t\t\t\tint ny = cy1 + dy + H / 2;\n\t\t\t\tint nx = cx1 + dx * (cx1 <= cx2 ? +1 : -1) + W / 2;\n\t\t\t\tfield[ny][nx] = 'x';\n \t\t\t} // end rep\n\t\t} // end if\n\t} // end rep\n\n\t// 現実羊の周りに壁を作る\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tif (field[i][j] == 'X'){\n\t\t\t\trep (k, 4){\n\t\t\t\t\tint ny = i + dy[k];\n\t\t\t\t\tint nx = j + dx[k];\n\t\t\t\t\tif (ny <= 0 || ny >= H + 1 || nx <= 0 || nx >= W + 1) continue;\n\t\t\t\t\tif (field[ny][nx] == 'X') continue;\n\t\t\t\t\tfield[ny][nx] = 'O';\n\t\t\t\t} // end rep\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end rep\n\n//\tdisp_field();\n\n\t// 仮想羊の周りに壁を作る\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tif (field[i][j] == 'x'){\n\t\t\t\trep (k, 4){\n\t\t\t\t\tint ny = i + dy[k];\n\t\t\t\t\tint nx = j + dx[k];\n\t\t\t\t\tif (ny <= 0 || ny >= H + 1 || nx <= 0 || nx >= W + 1) continue;\n\t\t\t\t\tif (field[ny][nx] != '.') continue;\n\t\t\t\t\tfield[ny][nx] = 'O';\n\t\t\t\t} // end rep\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end rep\n\n//\tdisp_field();\n\t\n\t// 壁に囲まれた壁が脱出できるか？\n\tbool escape = false;\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tif (field[i][j] == 'O'){\n\t\t\t\tbool curr = bfs(field[i][j], i, j);\n\t\t\t\tif (!curr) field[i][j] = '.';\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n//\tdisp_field();\n\n\t// 仮想羊を元に戻す\n\tfor (int i = 1; i <= H; ++i)\n\t\tfor (int j = 1; j <= W; ++j)\n\t\t\tif (field[i][j] == 'x') field[i][j] = '.';\n\n\t// 現実羊は脱出出来るか？\n\tescape = false;\n\tfor (int i = 1; i <= H; ++i){\n\t\tfor (int j = 1; j <= W; ++j){\n\t\t\tif (field[i][j] == 'X'){\n\t\t\t\tbool curr = bfs(field[i][j], i, j);\n\t\t\t\tif (curr) escape |= true;\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\tint res = 0;\n\tif (escape){\n\t\tres = -1;\n\t}else{\n\t\tfor (int i = 1; i <= H; ++i){\n\t\t\tfor (int j = 1; j <= W; ++j){\n\t\t\t\tres += (int)(field[i][j] == 'O');\n\t\t\t} // end for\n\t\t} // end for\n\t} // end if\n\tcout << res << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nint H, W;\nstring b[100];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nvoid dfs(int x, int y) {\n\tif(b[y][x] == '#') {\n\t\tb[y][x] = '$';\n\t\treturn;\n\t}\n\tif(b[y][x] != '.') return;\n\tb[y][x] = '@';\n\tfor(int k = 0; k < 4; k++) {\n\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\tif(in(nx, ny)) {\n\t\t\tif(b[ny][nx] == '#') b[ny][nx] = '$';\n\t\t\tif(b[ny][nx] == '.') dfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++) {\n\t\tcin >> b[i];\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\tif(b[i][0] == 'X' || b[i][W - 1] == 'X') {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = 0; i < W; i++) {\n\t\tif(b[0][i] == 'X' || b[H - 1][i] == 'X') {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\tbool flag = true;\n\twhile(flag) {\n\t\tflag = false;\n\t\tfor(int y = 0; y < H; y++) {\n\t\t\tfor(int x = 0; x < W; x++) {\n\t\t\t\tif(x + 2 < W && b[y][x] == 'X' && b[y][x + 1] == 'X' && b[y][x + 2] == 'X') {\n\t\t\t\t\tif(y + 1 < H - 1) {\n\t\t\t\t\t\tif(b[y + 1][x + 1] != 'X') flag = true;\n\t\t\t\t\t\tb[y + 1][x + 1] = 'X';\n\t\t\t\t\t}\n\t\t\t\t\tif(y - 1 > 0) {\n\t\t\t\t\t\tif(b[y - 1][x + 1] != 'X') flag = true;\n\t\t\t\t\t\tb[y - 1][x + 1] = 'X';\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(y + 2 < H && b[y][x] == 'X' && b[y + 1][x] == 'X' && b[y + 2][x] == 'X') {\n\t\t\t\t\tif(x + 1 < W - 1) {\n\t\t\t\t\t\tif(b[y + 1][x + 1] != 'X') flag = true;\n\t\t\t\t\t\tb[y + 1][x + 1] = 'X';\n\t\t\t\t\t}\n\t\t\t\t\tif(x - 1 > 0) {\n\t\t\t\t\t\tif(b[y + 1][x - 1] != 'X') flag = true;\n\t\t\t\t\t\tb[y + 1][x - 1] = 'X';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\t//cout << b[i] << endl;\n\t}\n\n\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(b[y][x] == 'X') {\n\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\tif(b[ny][nx] == '.') b[ny][nx] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\tdfs(0, i);\n\t\tdfs(W - 1, i);\n\t}\n\tfor(int i = 0; i < W; i++) {\n\t\tdfs(i, 0);\n\t\tdfs(i, H - 1);\n\t}\n\n\tint ans = 0;\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(b[y][x] == '$') ans++;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint H,W;\nstring s[100];\nint d[4]={0,1,0,-1};\nbool vis[100][100];\nmain()\n{\n\tcin>>H>>W;\n\tfor(int i=0;i<H;i++)cin>>s[i];\n\tfor(int i=0;i<H;i++)if(s[i][0]=='X'||s[i][W-1]=='X')\n\t{\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tfor(int j=0;j<W;j++)if(s[0][j]=='X'||s[H-1][j]=='X')\n\t{\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<H;i++)for(int j=0;j<W;j++)if(s[i][j]=='X')\n\t{\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint x=i+d[r],y=j+d[r^1];\n\t\t\tif(0<=x&&x<H&&0<=y&&y<W&&s[x][y]=='.')s[x][y]='#';\n\t\t}\n\t}\n\tqueue<pair<int,int> >P;\n\tfor(int i=0;i<H;i++)for(int j=0;j<W;j++)\n\t{\n\t\tif(i!=0&&i!=H-1&&j!=0&&j!=W-1)continue;\n\t\tif(s[i][j]=='.')\n\t\t{\n\t\t\tvis[i][j]=true;\n\t\t\tP.push(make_pair(i,j));\n\t\t}\n\t}\n\tint cnt=0;\n\twhile(!P.empty())\n\t{\n\t\tint x=P.front().first,y=P.front().second;\n\t\tP.pop();\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint tx=x+d[r],ty=y+d[r^1];\n\t\t\tif(tx<0||ty<0||tx>=H||ty>=W||vis[tx][ty])continue;\n\t\t\tvis[tx][ty]=true;\n\t\t\tif(s[tx][ty]=='#')cnt++;\n\t\t\telse P.push(make_pair(tx,ty));\n\t\t}\n\t}\n\tcout<<cnt<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long int lint;\ntypedef pair<lint, lint> plint;\ntypedef pair<double long, double long> pld;\n#define Alint(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1ll << (n))\n#define FOR(i, begin, end) for(lint i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(lint i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2>& l, const pair<T1, T2>& r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2>& l, const pair<T1, T2>& r) { return make_pair(l.first - r.first, l.second - r.second); }\nconst lint MOD = 998244353, INF = 1e9;\n\nstruct edge { lint to, cap, rev; };\n\nvector<edge> Graph[20005];\nint level[20005];\nint iter[20005];\nvoid add_edge(lint from, lint to, lint cap) {\n\tGraph[from].push_back({ to, cap, SZ(Graph[to]) });\n\tGraph[to].push_back({ from, 0, SZ(Graph[from]) - 1 });\n}\nvoid bfs(lint s) {\n\tmemset(level, -1, sizeof(level));\n\tqueue<lint> que;\n\tque.push(s);\n\tlevel[s] = 0;\n\twhile (!que.empty()) {\n\t\tlint v = que.front(); que.pop();\n\t\tREP(i, SZ(Graph[v])) {\n\t\t\tedge& e = Graph[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nlint dfs(lint v, lint t, lint f) {\n\tif (v == t) return f;\n\tfor (int& i = iter[v]; i < SZ(Graph[v]); i++) {\n\t\tedge& e = Graph[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tlint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tGraph[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nlint max_flow(lint s, lint t) {\n\tlint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0) return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tlint f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\n\nlint H, W;\nchar c;\n\nint main() {\n\tcin.tie(0); ios_base::sync_with_stdio(false);\n\t//始点 20002 終点 20003\n\tlint N = 10000;\n\tcin >> H >> W;\n\tREP(i, H) {\n\t\tREP(j, W) {\n\t\t\tcin >> c;\n\t\t\tif (c == 'X') {\n\t\t\t\tadd_edge(20002, i * W + j + N, INF);\n\t\t\t}\n\t\t\telse add_edge(i * W + j, i * W + j + N, 1);\n\t\t\tif (j < W - 1) {\n\t\t\t\tadd_edge(i * W + j + N, i * W + j + 1, INF);\n\t\t\t\tadd_edge(i * W + j + 1 + N, i * W + j, INF);\n\t\t\t}\n\t\t\tif (i < H - 1) {\n\t\t\t\tadd_edge(i * W + j + N, (i + 1) * W + j, INF);\n\t\t\t\tadd_edge((i + 1) * W + j + N, i * W + j, INF);\n\t\t\t}\n\t\t\tif (i == 0 || j == 0 || i == H - 1 || j == W - 1) {\n\t\t\t\tadd_edge(i * W + j + N, 20003, INF);\n\t\t\t}\n\t\t}\n\t}\n\tlint ans = max_flow(20002, 20003);\n\tif (ans >= INF) cout << -1 << endl;\n\telse cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&b) { if (a > b)a = b; }\ntemplate<class T> void cmax(T &a, const T&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\numap<ti3, ll> memo;\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//速度ではなくメモリ効率を考えるならrankのかわりにsizeを使う\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\nint main() {\n\tvi d = { 0,1,0,-1,0 };\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> s(h);\n\trep(i, h)cin >> s[i];\n\tbool err = 0;\n\tfor (auto a : s.front())if (a == 'X')err = 1;\n\tfor (auto a : s.back())if (a == 'X')err = 1;\n\tfor (auto &a : s) {\n\t\tif (a.back() == 'X' || a.front() == 'X')err = 1;\n\t}\n\tif (err) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tbool up = 1;\n\twhile (up) {\n\t\tup = 0;\n\t\trep1(i, h - 2)rep1(j, w - 2) {\n\t\t\tif (s[i][j] == '#') {\n\t\t\t\tint cnt = 0;\n\t\t\t\trep(k, 4)if (s[i + d[k]][j + d[k+1]] == '#' || s[i + d[k]][j + d[k+1]] == 'X')cnt++;\n\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\tup = 1;\n\t\t\t\t\ts[i][j] = 'X';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[i][j] == 'X') {\n\t\t\t\trep(k, 4)if (s[i + d[k]][j + d[k+1]] == '.') {\n\t\t\t\t\ts[i + d[k]][j + d[k+1]] = '#';\n\t\t\t\t\tup = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0;\n\trep(i, h)rep(j, w)if (s[i][j] == '#')cnt++;\n\tcout << cnt << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n//#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105],z[105][105];\nbool fr[105][105],vis[105][105],st,ad,f;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\tint a,b;\n\trep(ii,1,n)rep(jj,1,m){\n\t\tif(z[ii][jj]=='X'){\n\t\t\trep(kk,0,3)if(x[ii+dr[kk]][jj+dc[kk]]=='.')x[ii+dr[kk]][jj+dc[kk]] = '#';\n//\t\t\tcout<<ii<<' '<<jj<<endl;\n\t\t}\n\t\telse continue;\n\t\tsolve();\n\t\tans = tmp;\n\t\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\t\tst = 1;\n\t\twhile(st){\n\t\t\tst = 0;\n\t\t\trep(i,1,n)rep(j,1,m){\n\t\t\t\ta = i, b = j;\n\t\t\t\trep(k,1,2){\n\t\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\t\tif(k==2){\n\t\t\t\t\t\tad = 0, f = 1;\n\t\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(f){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t++a,++b;\n\t\t\t\t}\n\t\t\t\ta = i, b = j;\n\t\t\t\trep(k,1,2){\n\t\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\t\tif(k==2){\n\t\t\t\t\t\tad = 0, f = 1;\n\t\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(f){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t++a,--b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tcout<<endl;\n//\t\trep(i,1,n){\n//\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\tcout<<endl;\n//\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){\n  int h,w;\n  cin>>h>>w;\n  w+=2;h+=2;\n  vector<string> s(h);\n  s[0]=s[h-1]=string(w,'.');\n  for(int i=1;i<h-1;i++){\n    cin>>s[i];\n    s[i]=\".\"+s[i]+\".\";\n  }\n  int ans=0;\n  int dy[]={0,0,1,-1};\n  int dx[]={1,-1,0,0};\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(s[i][j]!='X') continue;\n      if(i==1||i==h-2||j==1||j==w-2){\n\tcout<<-1<<endl;\n\treturn 0;\n      }\n      for(int k=0;k<4;k++)\n\tif(s[i+dy[k]][j+dx[k]]=='.')\n\t  s[i+dy[k]][j+dx[k]]='#',ans++;      \n    }\n  }\n  //cout<<ans<<endl;\n  //for(int i=0;i<h;i++) cout<<s[i]<<endl;\n\n  auto in=[&](int y,int x){return 0<=y&&y<h&&0<=x&&x<w;};\n  ans=0;\n  vector<vector<int> > dp(h,vector<int>(w,0));\n  using P = pair<int, int>;\n  for(int i=0;i<2;i++){\n    for(int j=0;j<2;j++){\n      int y=(h-1)*i,x=(w-1)*j;\n      if(dp[y][x]) continue;\n      queue<P> q;\n      dp[y][x]=1;\n      q.emplace(y,x);\n      while(!q.empty()){\n\ttie(y,x)=q.front();q.pop();\n\tif(s[y][x]=='#'){\n\t  ans++;\n\t  continue;\n\t}\n\tfor(int k=0;k<4;k++){\n\t  int ny=y+dy[k],nx=x+dx[k];\n\t  if(!in(ny,nx)||dp[ny][nx]) continue;\n\t  dp[ny][nx]=1;\n\t  q.emplace(ny,nx);\n\t}\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans-3<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<array>\n#include<algorithm>\n#include<list>\n#include<cmath>\n#include<iomanip>\n#include<queue>\n#include<functional>\n#include<climits>\n#include<iterator>\n#include<unordered_set>\n#include<unordered_map>\n#include<map>\n#include<set>\n#include<typeinfo>\nusing namespace std;\n\nconst double pi=4*atan(1.0);\n\nconstexpr long long mod=static_cast<long long>(1e9+7);\n\nusing cWeightEdges=vector<vector<pair<int,int>>>;\nusing cEdges=vector<vector<int>>;\n\nint main(){\n\tint H,W;\n\tcin>>H>>W;\n\tvector<string> a(H);\n\tfor(auto& val:a)\n\t\tcin>>val;\n\n\tbool IsEdge=false;\n\tfor(int i=0;i<H;++i){\n\t\tfor(int j=0;j<W;++j){\n\t\t\tif(a[i][j]=='X'){\n\t\t\t\tif(i==0 || i==H-1 || j==0 || j==W-1){\n\t\t\t\t\tIsEdge=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif(a[i-1][j]!='X')a[i-1][j]='#';\n\t\t\t\tif(a[i+1][j]!='X')a[i+1][j]='#';\n\t\t\t\tif(a[i][j-1]!='X')a[i][j-1]='#';\n\t\t\t\tif(a[i][j+1]!='X')a[i][j+1]='#';\n\t\t\t}\n\t\t}\n\t}\n\n\tif(IsEdge){\n\t\tcout<<-1<<endl;\n\t}\n\telse{\n\t\tfor(int i=1;i<H-1;++i){\n\t\t\tfor(int j=1;j<W-1;++j){\n\t\t\t\tif(a[i][j]=='#'){\n\t\t\t\t\tbool CanErase=true;\n\t\t\t\t\tif(a[i-1][j]=='.')CanErase=false;\n\t\t\t\t\tif(a[i+1][j]=='.')CanErase=false;\n\t\t\t\t\tif(a[i][j-1]=='.')CanErase=false;\n\t\t\t\t\tif(a[i][j+1]=='.')CanErase=false;\n\n\t\t\t\t\tif(CanErase)a[i][j]='%';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans=0;\n\t\tfor(int i=0;i<H;++i){\n\t\t\tfor(int j=0;j<W;++j){\n\t\t\t\tif(a[i][j]=='#')++ans;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long int lint;\ntypedef pair<lint, lint> plint;\ntypedef pair<double long, double long> pld;\n#define Alint(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1ll << (n))\n#define FOR(i, begin, end) for(lint i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(lint i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2>& l, const pair<T1, T2>& r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2>& l, const pair<T1, T2>& r) { return make_pair(l.first - r.first, l.second - r.second); }\nconst lint MOD = 998244353, INF = 1e18;\n\nstruct edge { lint to, cap, rev; };\n\nvector<edge> Graph[20000];\nint level[20000];\nint iter[20000];\nvoid add_edge(lint from, lint to, lint cap) {\n\tGraph[from].push_back({ to, cap, SZ(Graph[to]) });\n\tGraph[to].push_back({ from, 0, SZ(Graph[from]) - 1 });\n}\nvoid bfs(lint s) {\n\tmemset(level, -1, sizeof(level));\n\tqueue<lint> que;\n\tque.push(s);\n\tlevel[s] = 0;\n\twhile (!que.empty()) {\n\t\tlint v = que.front(); que.pop();\n\t\tREP(i, SZ(Graph[v])) {\n\t\t\tedge& e = Graph[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nlint dfs(lint v, lint t, lint f) {\n\tif (v == t) return f;\n\tfor (int& i = iter[v]; i < SZ(Graph[v]); i++) {\n\t\tedge& e = Graph[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tlint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tGraph[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nlint max_flow(lint s, lint t) {\n\tlint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0) return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tlint f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\n\nlint H, W;\nchar c;\n\nint main() {\n\tcin.tie(0); ios_base::sync_with_stdio(false);\n\t//始点 20002 終点 20003\n\tlint N = 10000;\n\tcin >> H >> W;\n\tREP(i, H) {\n\t\tREP(j, W) {\n\t\t\tcin >> c;\n\t\t\tif (c == 'X') {\n\t\t\t\tadd_edge(10002, i * H + j + N, INF);\n\t\t\t}\n\t\t\tadd_edge(i * H + j, i * H + j + N, 1);\n\t\t\tif (j != 0) {\n\t\t\t\tadd_edge(i * H + j + N, i * H + j - 1, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i * H + j + N, 10003, INF);\n\t\t\t}\n\t\t\tif (j != W - 1) {\n\t\t\t\tadd_edge(i * H + j + N, i * H + j + 1, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i * H + j + N, 10003, INF);\n\t\t\t}\n\t\t\tif (i != 0) {\n\t\t\t\tadd_edge(i * H + j + N, (i - 1) * H + j, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i * H + j + N, 10003, INF);\n\t\t\t}\n\t\t\tif (i != H - 1) {\n\t\t\t\tadd_edge(i * H + j + N, (i + 1) * H + j, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i * H + j + N, 10003, INF);\n\t\t\t}\n\t\t}\n\t}\n\tlint ans = max_flow(10002, 10003);\n\tif (ans == INF) cout << -1 << endl;\n\telse cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nlong long mod=1000000007;\nint N[110000];\nint C[110000];\npair<int,int>p[110000];\nlong long ans[110000];\nvector<int> dp1[450];\nvector<int> dp2[450];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d%d\",N+i,C+i);\n\t\tp[i]=make_pair(N[i]/C[i],i);\n\t}\n\tstd::sort(p,p+a);\n\tfor(int i=0;i<450;i++){\n\t\tdp1[i]=vector<int>(i+1,0);\n\t\tdp2[i]=vector<int>(i+1,0);\n\t\tdp2[i][0]=1;\n\t}\n\tint at=0;\n\n\tfor(int i=1;i<101000;i++){\n\t\tfor(int j=0;j<450;j++){\n\t\t\tint tk=2*(j+1);\n\t\t\tif(j<449&&tk<=i){\n\t\t\t\tdp1[j][i%(j+1)]=(dp1[j][i%(j+1)]+dp1[j+1][(i-tk/2)%(j+2)]);\n\t\t\t\tif(dp1[j][i%(j+1)]>=mod)dp1[j][i%(j+1)]-=mod;\n\t\t\t\tdp2[j][i%(j+1)]=(dp2[j][i%(j+1)]+dp2[j+1][(i-tk/2)%(j+2)]);\n\t\t\t\tif(dp2[j][i%(j+1)]>=mod)dp2[j][i%(j+1)]-=mod;\n\t\t\t}else{\n\t\t\t\tdp1[j][i%(j+1)]=i;\n\t\t\t\tdp2[j][i%(j+1)]=1;\n\t\t\t}\n\t\t}\n\n\t\twhile(at<a&&p[at].first==i){\n\t\t//\tprintf(\"%d: %lld %lld\\n\",p[at].second,dp1[0][0],dp2[0][0]);\n\t\t\tans[p[at].second]=((long long)C[p[at].second]*dp1[0][0]+(long long)(N[p[at].second]%C[p[at].second])*dp2[0][0])%mod;\n\t\t\tat++;\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++)printf(\"%lld\\n\",ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(ll i = ll(a); i < ll(b); i++)\n#define rer(i, a, b) for(ll i = ll(a) - 1; i >= ll(b); i--)\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sc second\n#define fr first\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int, int> P;\n\nconst ll MOD=1000000007;\n\n//Ford-Fulkerson(O(FE))\nconst int MAX_V=110;\nconst int INF=10000;\n\nstruct edge{int to, cap, rev; };\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n    G[from].pb(edge{to, cap, sz(G[to])});\n    G[to].pb(edge{from, 0, sz(G[from])-1});\n}\n\nint dfs(int v, int t, int f){\n    if(v==t) return f;\n    used[v]=true;\n    for(edge &e : G[v]){\n        if(!used[e.to]&&e.cap>0){\n            int d=dfs(e.to, t, min(f, e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n//sからtへの最大流\nint max_flow(int s, int t){\n    int flow=0;\n    for(;;){\n        memset(used, 0, sizeof(used));\n        int f=dfs(s,t,INF);\n        if(f==0) return flow;\n        flow+=f;\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int H,W;\n    cin>>H>>W;\n    rep(i,0,H){\n        rep(j,0,W){\n            char s;\n            cin>>s;\n            if(i==0||i==H-1||j==0||j==W-1) add_edge(i*W+j+H*W, 2*H*W, INF);\n            if(s=='X'){\n                add_edge(2*H*W+1, i*W+j, INF);\n                add_edge(i*W+j, i*W+j+H*W, INF);\n            }\n            else add_edge(i*W+j, i*W+j+H*W, 1);\n            if(i>=1){\n                add_edge(i*W+j+H*W, (i-1)*W+j, INF);\n                //add_edge((i-1)*H+j, i*H+j+H*W, INF);\n            }\n            if(i<H-1){\n                add_edge(i*W+j+H*W, (i+1)*W+j, INF);\n                //add_edge((i+1)*H+j, i*H+j+H*W, INF);\n            }\n            if(j>=1){\n                add_edge(i*W+j+H*W, i*W+j-1, INF);\n                //add_edge(i*H+j-1, i*H+j+H*W, INF);\n            }\n            if(j<W-1){\n                add_edge(i*W+j+H*W, i*W+j+1, INF);\n                //add_edge(i*H+j+1, i*H+j+H*W, INF);\n            }\n        }\n    }\n    int t=max_flow(2*H*W+1, 2*H*W);\n    if(t>=INF) t=-1;\n    cout <<t<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst int N = 100;\nstring s[N + 5];\nint mark[N + 5][N + 5];\nint red[N + 5][N + 5];\n\nint py[] = {1,0,-1,0};\nint px[] = {0,1,0,-1};\n\nvoid hora(int tc) {\n\tint r,c;\n\tcin>>r>>c;\n\tfor(int i = 0;i < r;i++) cin>>s[i];\n\tfor(int i = 0;i < r;i++){\n\t\tif(s[i][0] == 'X' || s[i][c - 1] == 'X') {\n\t\t\tcout<<\"-1\"<<endl;\n\t\t\treturn ;\n\t\t}\n\t}\n\tfor(int i = 0;i < c;i++){\n\t\tif(s[0][i] == 'X' || s[r - 1][c] == 'X') {\n\t\t\tcout<<\"-1\"<<endl;\n\t\t\treturn ;\n\t\t}\n\t}\n\tfor(int i = 1;i < r - 1;i++) {\n\t\tfor(int j = 1;j < c - 1;j++) {\n\t\t\tif(s[i][j] == 'X') {\n\t\t\t\tfor(int k = 0;k < 4;k++) {\n\t\t\t\t\tint ny = i + py[k];\n\t\t\t\t\tint nx = j + px[k];\n\t\t\t\t\tif(s[ny][nx] == 'X') continue;\n\t\t\t\t\tmark[ny][nx] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint tot = 0;\n\tfor(int i = 0;i < r;i++) {\n\t\tfor(int j = 0;j < c;j++) {\n\t\t\tif(mark[i][j] == 1) {\n\t\t\t\tbool stay = false;\n\t\t\t\tfor(int k = 0;k < 4;k++) {\n\t\t\t\t\tint ny = i + py[k];\n\t\t\t\t\tint nx = j + px[k];\n\t\t\t\t\tif(ny < 0 || nx < 0 || ny >= r || nx >= c) stay = true;\n\t\t\t\t\telse if(s[ny][nx] == '.' && mark[ny][nx] == 0) stay = true;\n\t\t\t\t}\n\t\t\t\tif(stay == true) tot++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<tot<<endl;\n}\n\nint main(){\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*? begin \"base.hpp\" */\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve( /* この関数に問題ごとの処理を書く */\n#ifdef GCJ_CASE\n long long case_id\n#endif\n);\n\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n #define debug true\n#else\n #define NDEBUG \n #define debug false\n#endif\n#include<algorithm>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<type_traits>\n#include<vector>\n#ifdef __cpp_lib_execution\n  #include<execution>\n#endif\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL \n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define times(n,i) uptil(0,n,i)\n#define rtimes(n,i) downto((n)-1,0,i)\n#define upto(f,t,i) for(int rabT##i=(t),i=(f);i<=rabT##i;i++)\n#define uptil(f,t,i) for(int rabT##i=(t),i=(f);i< rabT##i;i++)\n#define downto(f,t,i) for(int rabT##i=(t),i=(f);i>=rabT##i;i--)\n#define downtil(f,t,i) for(int rabT##i=(t),i=(f);i> rabT##i;i--)\n#define iter(v) begin(v),end(v)\n#define citer(v) cbegin(v),cend(v)\n#define riter(v) rbegin(v),rend(v)\n#define criter(v) crbegin(v),crend(v)\n#define IF(a,b,c) ((a)?(b):(c))\n#define BINOP_ASGN(t,u,op) t operator op(CS u&o)CS{RT t(*this)op##=o;}\n#if debug\n #define _GLIBCXX_DEBUG\n #define _LIBCPP_DEBUG 2\n #define _LIBCPP_DEBUG2 2\n #define ln <<endl\n#else\n #define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n #define PARABLE \n/*? begin \"mod.hpp\" */\n#ifdef MOD\n #if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n  #error unknown mod MOD and FORCE_MOD not defined.\n #endif\n#else\n #define MOD 1000000007\n#endif\n/*? begin \"power.hpp\" */\nusing int128=__int128;\nTL<TN T>T power(T x,int n){T rt(1);for(;n;n/=2){if(n%2)rt*=x;x*=x;}RT rt;}\nint pow_mod(int x,int n,int m){int rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\nint128 pow_mod_64(int128 x,int n,int m){int128 rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\n/*? end \"power.hpp\" */\nIL CX int modulo(int a,int m){RT(a%=m,a>=0?a:a+m);}\nTL<ULL mod=MOD>class MInt{\n  /*! https://ei1333.github.io/luzhiled/snippets/other/mod-int.html */\npublic:\n  int val;\n  CX MInt():val(0){}\n  explicit CX MInt(int v):val(modulo(v,mod)){}\n  MInt&operator+=(CS MInt&m){val+=m.val;if(val>=mod)val-=mod;RT*this;}\n  MInt&operator-=(CS MInt&m){val-=m.val;if(val<0)val+=mod;RT*this;}\n  MInt&operator*=(CS MInt&m){val=val*m.val%mod;RT*this;}\n  MInt&operator/=(CS MInt&m){val=val*m.inv().val%mod;RT*this;}\n  BINOP_ASGN(MInt,MInt,+) BINOP_ASGN(MInt,MInt,-) BINOP_ASGN(MInt,MInt,*) BINOP_ASGN(MInt,MInt,/)\n  MInt operator-()CS{MInt m;m.val=val?mod-val:0;RT m;}\n  bool operator==(CS MInt&m)CS{RT val==m.val;}\n  bool operator!=(CS MInt&m)CS{RT val!=m.val;}\n  //MInt pow(int n)CS{MInt x(*this),rt(1);while(n){if(n%2)rt*=x;x*=x;n/=2;}RT rt;}\n  MInt pow(int n)CS{RT power(*this,n);}\n  MInt inv()CS{int a=val,b=mod,x=1,y=0,t;while(b){t=a/b;swap(b,a-=t*b);swap(y,x-=t*y);}RT(MInt)x;}\n  friend ostream&operator<<(ostream&o,CS MInt<mod>&m){RT o<<m.val;}\n  friend istream&operator>>(istream&i,MInt<mod>&m){int v;i>>v;m=MInt<mod>(v);RT i;}\n};\nusing mint=MInt<>;\n\nconstexpr mint operator\"\" _m(ULL n){RT mint(n);}\nconstexpr MInt<998244353>operator\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nconstexpr MInt<1000000007>operator\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nconstexpr MInt<1000000009>operator\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n\n//#pragma rab:gsub \\b(\\d+)m\\b mint(\\1)\n/*? end \"mod.hpp\" */\n/*? begin \"typedefs.hpp\" */\nstruct unit{};\n\nusing int128=__int128;\nusing LD=long double;\nTL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;\nTL<TN T>using vvvec=vec<vvec<T>>;\nTL<TN T>using vvvvec=vec<vvvec<T>>;\n\n//#pragma rab typedefs.dynamic\nusing WI = vvec<int>; using VI = vec<int>; using VC = vec<char>; using HII = map<int, int>; using VS = vec<string>; \n/*? end \"typedefs.hpp\" */\n/*? begin \"alias.hpp\" */\n#define EB emplace_back\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n/*? end \"alias.hpp\" */\n/*? begin \"util.hpp\" */\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,true);}\nTL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,true);}\n\n#ifndef __cpp_lib_exchange_function\n #define exchange exchange_RAB\n TL<TN T,TN U=T>IL T exchange(T& t, U&& u){T x=move(t);t=forward<U>(u);RT x;}\n#endif\n#ifndef __cpp_lib_clamp\n #define clamp clamp_RAB\n TL<TN T>IL CX CS T&clamp(CS T&a,CS T&mn,CS T&mx){RT a<mn?mn:a>mx?mx:a;}\n#endif\n\nTL<TN T>IL int size_RAB(T t){RT t.size();}\n#define size size_RAB\n\nTL<TN V>IL void uniq_after_sort(V&v){v.erase(unique(iter(v)),v.end());}\nTL<TN V>IL void sort_and_uniq(V&v){sort(iter(v));v.erase(unique(iter(v)),v.end());}\nTL<TN V,TN K>IL auto leftmost_ge(CS V&v,CS K&k){RT v.lower_bound(k);}\nTL<TN V,TN K>IL auto leftmost_gt(CS V&v,CS K&k){RT v.upper_bound(k);}\n\nnamespace rab{\n\nTL<TN V,TN W>IL void append(V&v,CS W&w){copy(PARABLE citer(w),back_inserter(v));}\n\nTL<TN V>IL auto flatten(CS V&xss,int reserve_size=0)->TN V::value_type{\n  decltype(flatten(xss))ret;\n  ret.reserve(reserve_size);\n  for(CS auto&xs:xss)append(ret,xs);\n  ret.shrink_to_fit();\n  RT move(ret);\n}\n\nTL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}\n\nTL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){RT 0<=i&&i<size(v)?v[i]:d;}\nTL<TN T>IL T fetch(CS T&d,CS vvec<T>&v,int i,int j){\n  RT 0<=i&&i<size(v)&&0<=j&&j<size(v[i])?v[i][j]:d;\n}\n// TL<TN T,TN U,TN...I>IL T fetch(CS T&d,CS vec<vec<U>>&v,int i,I...j){\n// RT 0<=i&&i<size(v)?fetch(d,v[i],j...):d;\n// }\nTL<TN T>struct Compressed{int size;map<T,int>zip;vec<T>unzip;};\nTL<TN T>IL Compressed<T>compressed(vec<T>v){\n  sort_and_uniq(v);map<T,int>zip;times(size(v),i)zip[v[i]]=i;RT{size(v),zip,move(v)};\n}\nTL<TN T>struct CompressedSrc{int size;map<T,int>zip;vec<T>unzip;WI src;};\nTL<TN T>IL CompressedSrc<T>compressed_src(CS vec<T>&v){\n  auto c=compressed(v);VI src(c.size);times(size(v),i)src[c.zip[v[i]]].PB(i);RT{c.size,c.zip,c.unzip,src};\n}\n\nstruct identity{TL<TN U>U operator()(U&&v)CS{RT v;}};\n}\n/*? end \"util.hpp\" */\n/*? begin \"debug.hpp\" */\nTL<class T>\nIL istream&operator>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nTL<class T>\nIL ostream&operator<<(ostream&,CS vec<T>&);\nTL<class T,class S>\nIL ostream&operator<<(ostream&,CS map<T,S>&);\n#define DEFINE_ITER_OUTPUT(s,x,sep){int i=0;for(CS auto&x##0_elem:x){if(i++)s<<sep;s<<x##0_elem;}RT s;}\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<T>&v)DEFINE_ITER_OUTPUT(s,v,' ')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS map<T,S>&m)DEFINE_ITER_OUTPUT(s,m,' ')\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<vec<T>>&w)DEFINE_ITER_OUTPUT(s,w,'\\n')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS vec<map<T,S>>&v)DEFINE_ITER_OUTPUT(s,v,'\\n')\n/*? end \"debug.hpp\" */\n\nsigned main(){\n {if(debug)cerr<<\"MOD: \"<<(MOD)ln;}\n if(!debug)cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\n cout<<fixed<<setprecision(20);\n cerr<<fixed<<setprecision(20);\n\n #ifdef GCJ_CASE\n  int T;cin>>T;\n  times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n #else\n  solve();\n #endif\n\n return 0;\n}\n/*? end \"base.hpp\" */\n/*? begin \"graph.hpp\" */\n/*? begin \"uf.hpp\" */\nTL<class T=int,class Adder=plus<T>,class Inverser=negate<T>>\nclass UnionFind{\n/*!\nhttp://noshi91.hatenablog.com/entry/2018/05/30/191943\nhttps://en.wikipedia.org/wiki/Disjoint-set_data_structure\nhttps://qiita.com/drken/items/cce6fc5c579051e64fab\n*/\nint n,*parents,*sizes;T*pot_diffs;bool to_delete;Adder adder;\nInverser inverser;\npublic:\nexplicit UnionFind(int n,bool to_delete=false):\nn(n),parents(new int[n]),sizes(new int[n]),pot_diffs(new T[n]),to_delete(to_delete)\n{clear();\n}\nvoid clear(){\ntimes(n,i)parents[i]=i;/*roots*/\nfill(sizes,sizes+n,1);fill(pot_diffs,pot_diffs+n,0);\n}\n~UnionFind(){if(to_delete){delete[]parents;delete[]sizes;delete[]pot_diffs;}}\nint size(){RT n;}\nint root(int i){int p=parents[i];\nif(p==i)RT i;/*`i`is a root*/\nint r=root(p);/*and pot_diffs[p]:=diff from root*/\npot_diffs[i]+=pot_diffs[p];parents[i]=r;RT r;\n}\nbool is_same(int i,int j){RT root(i)==root(j);}\nbool is_all_same(){int r=root(0);uptil(1,n,i)if(root(i)!=r)RT 0;RT 1;}\nbool merge(int i,int j,T pdiff=0){i=root(i);j=root(j);\nif(i==j)RT false;/*already merged*/\nif(sizes[i]>sizes[j]){swap(i,j);pdiff=inverser(pdiff);\n}\n/*now sizes[i]<=sizes[j]*/\nparents[i]=j;sizes[j]+=sizes[i];pot_diffs[i]=pdiff;RT true;\n}\nT diff(int i,int j){\nroot(i);/*pot_diffs[i]:=diff from root*/\nroot(j);/*pot_diffs[j]:=diff from root*/\nRT adder(pot_diffs[i],inverser(pot_diffs[j]));}};using unionfind=UnionFind<>;\n/*? end \"uf.hpp\" */\nTL<class EdgeVal>\nstruct Edge{int from;int to;EdgeVal weight;\nEdge(int from,int to,EdgeVal weight):from(from),to(to),weight(weight){}\nIL bool OP==(CS Edge&e)CS{RT weight==e.weight&&from==e.from&&to==e.to;}\nIL bool OP<(CS Edge&e)CS{RT weight<e.weight||(weight==e.weight&&(from<e.from||(from==e.from&&to<e.to)));}\nIL bool OP<=(CS Edge&e)CS{RT this==e||this<e;}\nIL bool OP>(CS Edge&e)CS{RT e<this;}\nIL bool OP>=(CS Edge&e)CS{RT e<=this;}};\nTL<class VtxVal,class EdgeVal>\nclass Graph{\nusing VoidWithoutEdgeVal=TN enable_if<is_default_constructible<EdgeVal>::value,void>::type;\nprotected:\nint nv_,nde_;unionfind uf;\npublic:\nvec<VtxVal>vs;vvec<Edge<EdgeVal>>edges;\nGraph(int nv):nv_(nv),nde_(0),uf(nv),vs(nv),edges(nv){}\nIL int nv()CS{RT nv_;}\nIL int nde()CS{RT nde_;}\nIL int nue()CS{RT nde_/2;}\nIL void add_dedge(int i,int j,CS EdgeVal&val){\nif(debug&&(!rab::is_in(i,0LL,nv_)||!rab::is_in(j,0LL,nv_))){\ncerr<<\"invalid index:(\"<<i<<\",\"<<j<<\")for Graph(nv=\"<<nv_<<\")\" ln;\nexit(1);\n}\nedges[i].emplace_back(i,j,val);++nde_;\n}\nIL VoidWithoutEdgeVal add_dedge(int i,int j){add_dedge(i,j,EdgeVal());\n}\nIL void add_uedge(int i,int j,CS EdgeVal&val){add_dedge(i,j,val);\nadd_dedge(j,i,val);\n}\nIL VoidWithoutEdgeVal add_uedge(int i,int j){add_uedge(i,j,EdgeVal());\n}\nIL bool is_connected(){uf.clear();\nfor(CS auto&es:edges)for(CS auto&e:es)uf.merge(e.from,e.to);RT uf.is_all_same();\n}};\n/*? end \"graph.hpp\" */\n/*? begin \"flow.hpp\" */\n/*!Arihon,https://tubo28.me/algorithm/dinic/*/\nTL<TN F,TN V,TN E,TN CapFn=rab::identity>\nclass dinic{\npublic:\nstruct FlowEdge{CS int from,to,rev_idx;CS F cap;F flow;\nFlowEdge(int from,int to,F cap,F flow,int rev_idx):\nfrom(from),to(to),rev_idx(rev_idx),cap(cap),flow(flow){}};int n,s,t,*level,*prog,*que;\nvvec<FlowEdge>edges;\ndinic(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),level(new int[n]),prog(new int[n]),que(new int[n+1]),edges(n)\n{times(n,i){for(auto&e:g.edges[i]){F c=capfn(e.weight);\nint zt=size(edges[e.to]),zi=size(edges[i]);edges[i].EB(i,e.to,c,(F)0,zt);\nedges[e.to].EB(e.to,i,c,c,zi);\n}}}\nF exec(int s,int t){this->s=s;this->t=t;F mf=0,inf=numeric_limits<F>::max()/8;\nwhile(update_level(),level[s]){fill(prog,prog+n,0);mf+=find_paths(s,inf);\n}\nRT mf;\n}\nvoid update_level(){int ql=0,qr=0;fill(level,level+n,0);level[t]=n;\nque[qr++]=t;while(ql!=qr){int v=que[ql++];if(v==s)RT;\nfor(CS auto&e:edges[v]){if(!level[e.to]&&e.flow!=0){level[e.to]=level[v]-1;\nque[qr++]=e.to;\n}}}}\nF find_paths(int v,int limit){if(v==t)RT limit;F diff=0;\nfor(int ze=size(edges[v]),&i=prog[v];i<ze;++i){auto&e=edges[v][i];\nif(level[v]<level[e.to]&&e.cap!=e.flow){F df=find_paths(e.to,min(limit,e.cap-e.flow));\ne.flow+=df;edges[e.to][e.rev_idx].flow-=df;diff+=df;limit-=df;\nif(limit==0)break;\n}}\nRT diff;}};\n/*!Arihon,https://tubo28.me/algorithm/ford-fulkerson/*/\nTL<TN V,TN E,TN CapFn=rab::identity>\nstruct ford_fulkerson{int n,s,t;VC visited;\nWI edges;/*both direction*/\nprivate:\nHII cap_,flow_;\npublic:\nford_fulkerson(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),visited(n),edges(n)\n{times(n,i){for(auto&e:g.edges[i]){int c=capfn(e.weight);\ncap_[i<<32|e.to]+=c;cap_[e.to<<32|i]+=c;flow_[e.to<<32|i]+=c;edges[i].PB(e.to);\nedges[e.to].PB(i);\n}}}\nint cap(int a,int b){RT cap_[a<<32|b];}\nint flow(int a,int b){RT flow_[a<<32|b];}\nint exec(int s,int t){this->s=s;this->t=t;int mf=0;\nwhile(1){fill(iter(visited),false);int df=find_path(s,LLONG_MAX/8/*inf*/);if(df==0)RT mf;\nmf+=df;\n}}\nint find_path(int v,int limit){visited[v]=true;if(v==t)RT limit;\nfor(int d:edges[v]){if(!visited[d]){int c=cap_[v<<32|d],&f=flow_[v<<32|d];\nif(c-f>0){int df=find_path(d,min(limit,c-f));if(df>0){f+=df;flow_[d<<32|v]-=df;RT df;\n}}}}\nRT 0;}};\n/*? end \"flow.hpp\" */\nconstexpr int INF = 401;\n\nvoid solve() {\n// HWH(\"S\")\n/* <foxy.memo-area> */\nint H;int W;cin>>H;cin>>W;VS S(H);times(H,Ri_0){cin>>S[Ri_0];}\n/* </foxy.memo-area> */\n\n  Graph<unit, int> g(H * W * 2 + 2);\n\n  int s = H * W * 2, t = H * W * 2 + 1;\n\n  #define inp(i, j) (((i) * W + (j)) * 2)\n  #define outp(i, j) (((i) * W + (j)) * 2 + 1)\n\n  times(H, i) times(W, j) {\n    g.add_dedge(inp(i, j), outp(i, j), 1);\n\n    if(S[i][j] == 'X') {\n      g.add_dedge(s, outp(i, j), INF);\n\n      if(i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n        cout << -1 ln;\n        return;\n      }\n    }\n  }\n\n  times(H, i) {\n    g.add_dedge(outp(i, 0), t, INF);\n    g.add_dedge(outp(i, W-1), t, INF);\n\n    times(W-1, j) {\n      g.add_dedge(outp(i, j), inp(i, j + 1), INF);\n      g.add_dedge(outp(i, j + 1), inp(i, j), INF);\n    }\n  }\n  times(W, j) {\n    g.add_dedge(outp(0, j), t, INF);\n    g.add_dedge(outp(H-1, j), t, INF);\n\n    times(H-1, i) {\n      g.add_dedge(outp(i, j), inp(i + 1, j), INF);\n      g.add_dedge(outp(i + 1, j), inp(i, j), INF);\n    }\n  }\n\n  dinic<int, unit, int> d(g);\n  cout << d.exec(s, t) ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n#include <limits>\n#include <functional>\n#include <iomanip>\n#include <complex>\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER) || __cplusplus > 199711L\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) __typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\nusing namespace std;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }\ntypedef complex<double> P;\n\nint main(){\n\tint H,W;\n\tcin>>H>>W;\n\tvector<string> hoge(H);\n\trep(i,H)cin>>hoge[i];\n\tbool flag=true;\n\tfor(int i=0;i<H;i++){\n\t\tif(i==0||i==H-1){\n\t\t\trep(j,W)if(hoge[i][j]=='X')flag=false;\n\t\t}else{\n\t\t\tif(hoge[i][0]=='X')flag=false;\n\t\t\tif(hoge[i][W-1]=='X')flag=false;\n\t\t}\n\t}\n\tif(flag){\n\t\t//vector<pii>data;\n\t\tint check[105][105]={0};\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tif(hoge[i][j]=='X'){\n\t\t\t\t\tcheck[i][j]=2;\n\t\t\t\t\tcheck[i-1][j]=max(check[i-1][j],1);\n\t\t\t\t\tcheck[i+1][j]=max(check[i+1][j],1);\n\t\t\t\t\tcheck[i][j+1]=max(check[i][j+1],1);\n\t\t\t\t\tcheck[i][j-1]=max(check[i][j-1],1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tif(check[i][j]==1){\n\t\t\t\t\tans++;\n\t\t\t\t\tif(check[i-1][j]>0&&check[i+1][j]>0&&check[i][j-1]>0&&check[i][j+1]>0)ans--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}else{\n\t\tcout<<\"-1\"<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define FOR(it,c) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define ALLOF(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define inf 99999999\n\nclass Dinic {\n  int MAX_V;\n  int INF;\n  struct edge{ int to, cap, rev, icap, flow; };\n\n  vector< vector<edge> > G;\n  vector<int> level; //sからの距離\n  vector<int> iter; //どこまで調べたか\n\n  void max_flow_bfs(int s){\n    fill(level.begin(), level.end(), -1);\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()){\n      int v = que.front(); que.pop();\n      for(int i=0; i<G[v].size(); i++){\n        edge &e = G[v][i];\n        if(e.cap>0 && level[e.to]<0){\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n  int max_flow_dfs(int v, int t, int f){\n    if(v==t) return f;\n    for(int &i=iter[v]; i<G[v].size(); i++){\n      edge &e = G[v][i];\n      if(e.cap>0 && level[v]<level[e.to]){\n        int d = max_flow_dfs(e.to, t, min(f, e.cap));\n        if(d>0){\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          e.flow += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\npublic:\n  Dinic(int N):MAX_V(N),G(N),level(N),iter(N){\n    INF = inf;\n  }\n\n  void add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to, cap, G[to].size(), cap, 0});\n    G[to].push_back((edge){from, 0, G[from].size()-1, 0, 0});\n  }\n\n  int get_flow(int from, int to){ //untried\n    rep(i,G[from].size()){\n      if(G[from][i].to == to){\n        return G[from][i].flow;\n      }\n    }\n    return -1;\n  }\n\n  int max_flow(int s, int t){\n    int flow = 0;\n    while(true){\n      max_flow_bfs(s);\n      if(level[t]<0) return flow;\n      fill(iter.begin(), iter.end(), 0);\n      int f;\n      while((f = max_flow_dfs(s, t, INF))>0){\n        flow += f;\n      }\n    }\n  }\n  \n  int min_cut(int s, int t, vector<int>& S, vector<int>& T){\n    S.clear();\n    T.clear();\n\n    int maxf = max_flow(s, t);\n    for(int i=0; i<level.size(); i++){\n      if(level[i] >= 0) S.push_back(i);\n      else T.push_back(i);\n    }\n\n    return maxf;\n  }\n};\n\nint vx[4] = {1,-1,0,0};\nint vy[4] = {0,0,1,-1};\n\nint main(){\n  int H, W;\n  cin >> H >> W;\n  vector<string> field;\n  vector< vector<int> > num(H, vector<int>(W));\n  rep(i,H){\n    string s;\n    cin >> s;\n    field.push_back(s);\n    rep(j,W){\n      num[i][j] = i*W+j;\n    }\n  }\n\n  Dinic dinic(2*H*W+2);\n  int s = 2*H*W;\n  int t = s+1;\n  rep(i,H){\n    rep(j,W){\n      int in = i*W+j;\n      int out = i*W+j + H*W;\n      if(i==0 || i==H-1 || j==0 || j==W-1){\n        dinic.add_edge(s,in,inf);\n        if(field[i][j] == 'X'){\n          cout << -1 << endl;\n          return 0;\n        }\n      }\n\n      if(field[i][j] == 'X'){\n        dinic.add_edge(in,out,inf);\n        dinic.add_edge(out,t,inf);\n      }else{\n        dinic.add_edge(in,out,1);\n        rep(k,4){\n          int nx = j + vx[k];\n          int ny = i + vy[k];\n          if(0<=nx&&nx<W && 0<=ny&&ny<H){\n            dinic.add_edge(out,ny*W+nx,inf);\n          }\n        }\n      }\n    }\n  }\n  vector<int> S, T;\n  int ret = dinic.min_cut(s,t,S,T);\n  cout << ret << endl;\n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "    #pragma GCC optimize(\"Ofast\")\n     \n    #include <bits/stdc++.h>\n    #include <ext/pb_ds/tree_policy.hpp>\n    #include <ext/pb_ds/assoc_container.hpp>\n    #include <random>\n     \n    using namespace std;\n    using namespace __gnu_pbds;\n     \n    typedef long long ll;\n     \n    typedef\n    tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> orderedSet;\n     \n    #define pb push_back\n    #define F first\n    #define S second\n    #define all(a) (a).begin(), (a).end()\n     \n    #define for1(i0, l0, r0) for (int i0 = l0; i0 < r0; ++i0)\n    #define for2(i0, l0, r0) for (int i0 = l0; i0 <= r0; ++i0)\n    #define forn(i0, n0) for (int i0 = 0; i0 < n0; ++i0)\n    #define forn1(i0, n0) for (int i0 = 1; i0 < n0; ++i0)\n    #define forr(i0, n0) for (int i0 = n0; i0 >= 0; --i0)\n    #define forr1(i0, r0, l0) for (int i0 = r0; i0 > l0; --i0)\n    #define forr2(i0, r0, l0) for (int i0 = r0; i0 >= l0; --i0)\n     \n    #define Sort(a) sort(all(a))\n    #define Reverse(a) reverse(all(a))\n     \n    typedef long double ld;\n    #define ui unsigned int\n    #define ull unsigned long long\n     \n    typedef pair<int, int> pii;\n    typedef pair<ll, ll> pll;\n    typedef pair<double, double> pdd;\n    typedef pair<string, string> pss;\n     \n    typedef vector<int> vi;\n    typedef vector<ll> vll;\n    typedef vector<double> vd;\n    typedef vector<ld> vld;\n    typedef vector<bool> vb;\n    typedef vector<string> vs;\n     \n    typedef vector<pii> vpii;\n    typedef vector<pll> vpll;\n    typedef vector<pdd> vpdd;\n     \n    typedef vector<vi> vvi;\n    typedef vector<vd> vvd;\n    typedef vector<vll> vvll;\n    typedef vector<vb> vvb;\n     \n    #define vpss vector<pss>\n    #define vvs vector<vs>\n    #define vvpii vector<vpii>\n    #define vvpll vector<vpll>\n    #define vpt vector<pt>\n    #define vvvi vector<vvi>\n    #define vsi vector<set<int>>\n    #define ss second\n    #define ff first\n     \n    #define printvi(arr) for (int x0 : arr) cout << x0 << ' '; cout << '\\n';\n    #define printvll(arr) for (ll x0 : arr) cout << x0 << ' '; cout << '\\n';\n    #define printpair(pair0) cout << pair0.F << ' ' << pair0.S << '\\n';\n    #define printvp(arr) for (auto pair0 : arr) printpair(pair0);\n    #define initArray(arr, N0, X0) memset(arr, X0, N0 * sizeof(int))\n    //mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n     \n    void init() {\n        ios_base::sync_with_stdio(0);\n        cin.tie(0);\n        cout.tie(0);\n        //cout.precision(16);\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n    }\n     \n    const int inf = 1e9;\n     \n    int mincut(int n, vvi e, int I, int J){\n        int m = e.size();\n        vvi c(n, vi(n));\n        vvi f(n, vi(n));\n        vvi g(n);\n        forn(i, m){\n            int v, u, c0;\n            v = e[i][0], u = e[i][1], c0 = e[i][2];\n            c[v][u] += c0;\n            //c[u][v] += c0;\n            g[v].pb(u);\n            //g[u].pb(v);\n        }\n        int ans = 0;\n        while(true){\n            queue<int> q;\n            q.push(I);\n            vi p(n, -1);\n            p[I] = -2;\n            while(!q.empty()){\n                int v = q.front();\n                q.pop();\n                for (int i: g[v]){\n                    if (c[v][i] > f[v][i] && p[i] == -1){\n                        p[i] = v;\n                        q.push(i);\n                    }\n                }\n            }\n            if (p[J] == -1) break;\n            vi path;\n            int minimum = 2e9;\n            int idx = J;\n            path.pb(idx);\n            while(idx != I){\n                minimum = min(minimum, c[p[idx]][idx] - f[p[idx]][idx]);\n                idx = p[idx];\n                path.pb(idx);\n            }\n            ans += minimum;\n            Reverse(path);\n            forn1(i, path.size()){\n                f[path[i]][path[i - 1]] -= minimum;\n                f[path[i - 1]][path[i]] += minimum;\n            }\n        }\n        return ans;\n    }\n     \n    void solve() {\n        int n, m;\n        cin >> n >> m;\n        vs a(n);\n        forn(i, n) cin >> a[i];\n        forn(i, n) {\n             forn(j, m){\n                 if (i == 0 || j == 0 || i == n - 1 || j == m - 1){\n                     if (a[i][j] == 'X'){\n                         cout << \"-1\\n\";\n                         return;\n                     }\n                 }\n             }\n        }\n        int N = n * m;\n        int I = 2 * N, J = I + 1;\n        vvi e;\n        forn(i, n){\n            forn(j, m){\n                if (i > 0) e.pb({N + i * m + j, (i - 1) * m + j, inf});\n                if (i + 1 < n) e.pb({N + i * m + j, (i + 1) * m + j, inf});\n                if (j > 0) e.pb({N + i * m + j, i * m + j - 1, inf});\n                if (j + 1 < m) e.pb({N + i * m + j, i * m + j + 1, inf});\n                if (a[i][j] == 'X') e.pb({I, i * m + j, inf});\n                if (i == 0 || i == n - 1 || j == 0 || j == m - 1) e.pb({N + i * m + j, J, inf});\n                e.pb({i * m + j, i * m + j + N, (a[i][j] == '.' ? 1 : inf)});\n            }\n        }\n        cout << mincut(2 * N + 2, e, I, J) << '\\n';\n    }\n     \n    bool multitest = false;\n     \n    int main() {\n        init();\n        int t = 1;\n        if (multitest) cin >> t;\n        forn(i, t) solve();\n    }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 111;\nchar g[maxn][maxn];\nint main(){\n\tint n, m; cin >> n >> m;\n\tfor(int i = 0; i < n; i++) for(int j = 0; j < m; j++) cin >> g[i][j];\n\tauto bad = [](){\n\t\tcout << -1 << endl;\n\t\texit(0);\n\t};\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < m; j++) if(g[i][j] == 'X'){\n\t\t\tif(j == 0) bad();\n\t\t\tg[i][j - 1] = 'c';\n\t\t\tbreak;\n\t\t}\n\t\tfor(int j = m - 1; j >= 0; j--) if(g[i][j] == 'X'){\n\t\t\tif(j == m - 1) bad();\n\t\t\tg[i][j + 1] = 'c';\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int j = 0; j < m; j++){\n\t\tfor(int i = 0; i < n; i++) if(g[i][j] == 'X'){\n\t\t\tif(i == 0) bad();\n\t\t\tg[i - 1][j] = 'c';\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = n - 1; i >= 0; i--) if(g[i][j] == 'X'){\n\t\t\tif(i == n - 1) bad();\n\t\t\tg[i + 1][j] = 'c';\n\t\t\tbreak;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i < n; i++) for(int j = 0; j < m; j++) if(g[i][j] == 'c') ans++;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n#define MAX_V 555\n#define INF (1<<29)\n\nstruct edge {\n    int to, cap, rev;\n    edge (int to, int cap, int rev) :\n        to(to), cap(cap), rev(rev) {}\n};\n\nvector<edge> G[MAX_V];\nint level[MAX_V], iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap)\n{\n    G[from].push_back(edge(to, cap, G[to].size()));\n    G[to].push_back(edge(from, 0, G[from].size()-1));\n}\n\nvoid bfs(int s)\n{\n    memset(level, -1, sizeof(level));\n    queue<int> Q;\n    level[s] = 0;\n    Q.push(s);\n    while (!Q.empty()) {\n\tint v = Q.front(); Q.pop();\n\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t    edge &e = G[v][i];\n\t    if (e.cap > 0 && level[e.to] < 0) {\n\t\tlevel[e.to] = level[v] + 1;\n\t\tQ.push(e.to);\n\t    }\n\t}\n    }\n}\n\nint dfs(int v, int t, int f)\n{\n    if (v == t) return f;\n    for (int &i = iter[v]; i < (int)G[v].size(); i++) {\n\tedge &e = G[v][i];\n\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t    int d = dfs(e.to, t, min(f, e.cap));\n\t    if (d > 0) {\n\t\te.cap -= d;\n\t\tG[e.to][e.rev].cap += d;\n\t\treturn d;\n\t    }\n\t}\n    }\n    return 0;\n}\n\nint max_flow(int s, int t)\n{\n    int flow = 0;\n    for (;;) {\n\tbfs(s);\n\tif (level[t] < 0) return flow;\n\tmemset(iter, 0, sizeof(iter));\n\tint f;\n\twhile ((f = dfs(s, t, INF)) > 0) {\n\t    flow += f;\n\t}\n    }\n}\n\nbool is_outside(int x, int y, int W, int H)\n{\n    return (x == 0 || x == W - 1 || y == 0 || y == H - 1);\n}\n\nint solve(int H, int W,\n          vector<vector<char>> &S)\n{\n    int src = 2 * H * W, sink = src + 1;\n    const int di[] = {-1, +0, +1, +0};\n    const int dj[] = {+0, -1, +0, +1};\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int u = i * W + j, v = H * W + u;\n            \n            if (S[i][j] == 'X') {\n                if (is_outside(j, i, W, H)) {\n                    return -1;\n                }\n                add_edge(src, u, INF);\n                add_edge(u, v, INF);\n            } else {\n                add_edge(u, v, 1);\n            }\n\n            if (is_outside(j, i, W, H)) {\n                add_edge(v, sink, INF);                \n            }\n            \n            for (int k = 0; k < 4; k++) {\n                int ni = i + di[k];\n                int nj = j + dj[k];\n                if (0 <= ni && ni < H && 0 <= nj && nj < W) {\n                    add_edge(v, ni * W + nj, INF);\n                }\n            }\n        }\n    }\n    return max_flow(src, sink);\n}\n\nint main()\n{\n    int H, W;\n    cin >> H >> W;\n    vector<vector<char>> S(H, vector<char>(W));\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> S[i][j];\n        }\n    }\n    cout << solve(H, W, S) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<numeric>\n#include<functional>\n#include<algorithm>\n#include<bitset>\n#include<tuple>\n#include<unordered_set>\n#include<random>\n#include<array>\n#include<cassert>\nusing namespace std;\n#define INF (1<<29)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define uniq(v) v.erase(unique(all(v)),v.end())\n\n\n\n\n\n\n\n#define MAX_V 20002\n\nstruct edge{\n\tint to, cap, rev;\n\tedge(int a, int b, int c) :to(a), cap(b), rev(c){}\n};\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n\tG[from].push_back(edge(to, cap, G[to].size()));\n\tG[to].push_back(edge(from, 0, G[from].size() - 1));\n}\n//sからの最短距離をbfsで計算\nvoid bfs(int s){\n\tmemset(level, -1, sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty()){\n\t\tint v = que.front(); que.pop();\n\t\tfor (int i = 0; i<G[v].size(); i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0){\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n//増加パスをdfsで探す\nint dfs(int v, int t, int f){\n\tif (v == t)return f;\n\tfor (int &i = iter[v]; i<G[v].size(); i++){\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]){\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d>0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s, int t){\n\tint flow = 0;\n\tfor (;;){\n\t\tbfs(s);\n\t\tif (level[t]<0)return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tint f;\n\t\twhile ((f = dfs(s, t, INF))>0){\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\n\n\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint h,w;\n\tcin>>h>>w;\n\tvector<int> p;\n\n\trep(y,h)rep(x,w){\n\t\tchar c;\n\t\tcin>>c;\n\t\tif (c=='X'){\n\t\t\tif (y==0||y+1==h||x==0||x+1==w){\n\t\t\t\tcout<<-1<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tp.push_back(y*w+x);\n\t\t}\n\t\tif (0 < y){\n\t\t\tadd_edge(y*w + x, h*w + (y - 1)*w + x, INF);\n\t\t}\n\t\tif (y+1<h){\n\t\t\tadd_edge(y*w + x, h*w + (y + 1)*w + x, INF);\n\t\t}\n\t\tif (0 < x){\n\t\t\tadd_edge(y*w + x, h*w + y*w + x - 1, INF);\n\t\t}\n\t\tif (x+1<w){\n\t\t\tadd_edge(y*w + x, h*w + y*w + x+1, INF);\n\t\t}\n\t}\n\trep(i,h*w){\n\t\tadd_edge(h*w + i, i, 1);\n\t}\n\n\tint n=h*w*2;\n\tfor (int y=0;y<h;y++){\n\t\tadd_edge(y*w , n, INF);\n\t\tadd_edge(y*w+w-1, n, INF);\n\t}\n\tfor (int x = 1; x+1<w; x++){\n\t\tadd_edge(x, n, INF);\n\t\tadd_edge((h-1)*w + x, n, INF);\n\t}\n\trep(i,p.size()){\n\t\tadd_edge(n+1, p[i], INF);\n\t}\n\tcout<<max_flow(n+1,n)<<endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nint H, W;\nstring b[100];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nvoid dfs(int x, int y) {\n\tif(b[y][x] == '#') {\n\t\tb[y][x] = '$';\n\t\treturn;\n\t}\n\tif(b[y][x] != '.') return;\n\tb[y][x] = '@';\n\tfor(int k = 0; k < 4; k++) {\n\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\tif(in(nx, ny)) {\n\t\t\tif(b[ny][nx] == '#') b[ny][nx] = '$';\n\t\t\tif(b[ny][nx] == '.') dfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++) {\n\t\tcin >> b[i];\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\tif(b[i][0] == 'X' || b[i][W - 1] == 'X') {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = 0; i < W; i++) {\n\t\tif(b[0][i] == 'X' || b[H - 1][i] == 'X') {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\n\n\n\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(b[y][x] == 'X') {\n\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\tif(b[ny][nx] == '.') b[ny][nx] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool flag = true;\n\twhile(flag) {\n\t\tflag = false;\n\t\tfor(int y = 0; y < H; y++) {\n\t\t\tfor(int x = 0; x < W; x++) {\n\t\t\t\tif(x + 2 < W && b[y][x] != '.' && b[y][x + 1] != '.' && b[y][x + 2] != '.') {\n\t\t\t\t\tif(y + 1 < H) {\n\t\t\t\t\t\tif(b[y + 1][x + 1] != '#') flag = true;\n\t\t\t\t\t\tb[y + 1][x + 1] = '#';\n\t\t\t\t\t}\n\t\t\t\t\tif(y - 1 >= 0) {\n\t\t\t\t\t\tif(b[y - 1][x + 1] != '#') flag = true;\n\t\t\t\t\t\tb[y - 1][x + 1] = '#';\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(y + 2 < H && b[y][x] != '.' && b[y + 1][x] != '.' && b[y + 2][x] != '.') {\n\t\t\t\t\tif(x + 1 < W) {\n\t\t\t\t\t\tif(b[y + 1][x + 1] != '#') flag = true;\n\t\t\t\t\t\tb[y + 1][x + 1] = '#';\n\t\t\t\t\t}\n\t\t\t\t\tif(x - 1 >= 0) {\n\t\t\t\t\t\tif(b[y + 1][x - 1] != '#') flag = true;\n\t\t\t\t\t\tb[y + 1][x - 1] = '#';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(x + 2 < W && y + 1 < H && y - 1 >= 0) {\n\t\t\t\t\tif(b[y][x] != '.' && b[y + 1][x + 1] != '.' && b[y][x + 2] != '.') {\n\t\t\t\t\t\tif(b[y - 1][x + 1] != '#') flag = true;\n\t\t\t\t\t\tb[y - 1][x + 1] = '#';\n\t\t\t\t\t}\n\t\t\t\t\tif(b[y][x] != '.' && b[y - 1][x + 1] != '.' && b[y][x + 2] != '.') {\n\t\t\t\t\t\tif(b[y + 1][x + 1] != '#') flag = true;\n\t\t\t\t\t\tb[y + 1][x + 1] = '#';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(y + 2 < H && x + 1 < W && x - 1 >= 0) {\n\t\t\t\t\tif(b[y][x] != '.' && b[y + 1][x + 1] != '.' && b[y + 2][x] != '.') {\n\t\t\t\t\t\tif(b[y + 1][x - 1] != '#') flag = true;\n\t\t\t\t\t\tb[y + 1][x - 1] = '#';\n\t\t\t\t\t}\n\t\t\t\t\tif(b[y][x] != '.' && b[y + 1][x - 1] != '.' && b[y + 2][x] != '.') {\n\t\t\t\t\t\tif(b[y + 1][x + 1] != '#') flag = true;\n\t\t\t\t\t\tb[y + 1][x + 1] = '#';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\t//cout << b[i] << endl;\n\t}\n\n\n\tfor(int i = 0; i < H; i++) {\n\t\tdfs(0, i);\n\t\tdfs(W - 1, i);\n\t}\n\tfor(int i = 0; i < W; i++) {\n\t\tdfs(i, 0);\n\t\tdfs(i, H - 1);\n\t}\n\n\tint ans = 0;\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(b[y][x] == '$') ans++;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define min(a, b) ((a)>(b)?(b):(a))\n\nconst int inf = 1e5;\nconst int MAXN = 105;\n\nconst int sz = 2 * MAXN*MAXN;\n\nstruct MaxFlow {\n\tstruct Edge {\n\t\tint x;\n\t\tint inv;\n\t\tint resid;\n\t\tEdge() {}\n\t\tEdge(int v, int i, int r) : x(v), inv(i), resid(r) {}\n\t};\n\tint n;\n\tEdge g[sz][105]; int gn[sz];\n\tvoid init(int _n) {\n\t\tn = _n;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tgn[i] = 0;\n\t\t}\n\t}\n\tvoid add_edge(int s, int e, int cap) {\n\t\tEdge forward = Edge(e, gn[e], cap);\n\t\tEdge reverse = Edge(s, gn[s], 0);\n\t\tg[s][gn[s]++] = forward;\n\t\tg[e][gn[e]++] = reverse;\n\t}\n\tbool vis[sz];\n\tint Q[sz], fr, re, curf[sz], par[sz], paridx[sz];\n\tint bfs(int s, int e) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tvis[i] = 0;\n\t\t\tcurf[i] = 0;\n\t\t\tpar[i] = paridx[i] = 0;\n\t\t}\n\t\tQ[fr = re = 0] = s; vis[s] = 1;\n\t\tcurf[s] = inf;\n\t\twhile (fr <= re) {\n\t\t\tint x = Q[fr++];\n\t\t\tfor (int i = 0; i < gn[x]; i++) {\n\t\t\t\tint y = g[x][i].x;\n\t\t\t\tint f = g[x][i].resid;\n\t\t\t\tif (f > 0 && !vis[y]) {\n\t\t\t\t\tvis[y] = 1;\n\t\t\t\t\tpar[y] = x; paridx[y] = i;\n\t\t\t\t\tcurf[y] = min(curf[x], f);\n\t\t\t\t\tQ[++re] = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!vis[e]) return 0;\n\t\tint flow = curf[e];\n\t\tint p = e;\n\t\twhile (p != s) {\n\t\t\tint q = par[p], qi = paridx[p];\n\t\t\tint pi = g[q][qi].inv;\n\t\t\tg[q][qi].resid -= flow;\n\t\t\tg[p][pi].resid += flow;\n\t\t\tp = q;\n\t\t}\n\t\treturn flow;\n\t}\n\tint solve(int s, int e) {\n\t\tint flow = 0, cur = 0;\n\t\twhile (cur = bfs(s, e), cur > 0) {\n\t\t\tflow += cur;\n\t\t}\n\t\treturn flow;\n\t}\n};\n\nint N, M;\nchar S[MAXN][MAXN];\nint in[MAXN][MAXN], out[MAXN][MAXN];\nint source, sink, v;\n\nint px[4] = { 1,-1,0,0 };\nint py[4] = { 0,0,1,-1 };\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int i = 1; i <= N; i++) {\n\t\tscanf(\"%s\", S[i] + 1);\n\t}\n\tsource = 0;\n\tsink = N * M * 2 + 1;\n\tv = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= M; j++) {\n\t\t\tin[i][j] = ++v;\n\t\t\tout[i][j] = ++v;\n\t\t}\n\t}\n\tMaxFlow f;\n\tf.init(2 * N*M + 2);\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= M; j++) {\n\t\t\tif (S[i][j] == 'X') {\n\t\t\t\tif (i == 1 || i == N || j == 1 || j == M) {\n\t\t\t\t\tf.add_edge(source, in[i][j], inf);\n\t\t\t\t}\n\t\t\t\tf.add_edge(in[i][j], out[i][j], inf);\n\t\t\t\tf.add_edge(out[i][j], sink, inf);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (i == 1 || i == N || j == 1 || j == M) {\n\t\t\t\t\tf.add_edge(source, in[i][j], 1);\n\t\t\t\t}\n\t\t\t\tf.add_edge(in[i][j], out[i][j], 1);\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint x = i + px[k];\n\t\t\t\t\tint y = j + py[k];\n\t\t\t\t\tif (1 <= x && x <= N && 1 <= y && y <= M) {\n\t\t\t\t\t\tf.add_edge(out[i][j], in[x][y], inf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint flow = f.solve(source, sink);\n\tif (flow >= inf) puts(\"-1\");\n\telse printf(\"%d\\n\", flow);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define MAX_H 105\n#define MAX_W 105\n\nint H, W;\nstring maze[MAX_H];\nvoid input()\n{\n  cin >> H >> W;\n  for (size_t i = 0; i < H; i++) {\n    cin >> maze[i];\n  }\n}\n\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n\nbool isInFiled(int x, int y)\n{\n  return 0 <= x && x < W && 0 <= y && y < H;\n}\n\nbool isEdgePos(int x, int y)\n{\n  return (x == 0 || y == 0 || x == W-1 || y == H-1) && isInFiled(x, y);\n}\n\nint solve()\n{\n  for (size_t i = 0; i < H; i++) {\n    if(maze[i][0] == 'X' || maze[i][W-1] == 'X'){\n      return -1;\n    }\n  }\n  for (size_t i = 0; i < W; i++) {\n    if(maze[0][i] == 'X' || maze[H-1][i] == 'X'){\n      return -1;\n    }\n  }\n\n  for (int x = 0; x < W; x++) {\n    for (int y = 0; y < H; y++) {\n      if(maze[y][x] == 'X'){\n        for (size_t d = 0; d < 4; d++) {\n          int nx = x + dx[d];\n          int ny = y + dy[d];\n          if(isInFiled(nx, ny) && maze[ny][nx] == '.'){\n            maze[ny][nx] = '#';\n          }\n        }\n      }\n    }\n  }\n\n  bool used[MAX_H][MAX_W];\n  bool used2[MAX_H][MAX_W];\n  memset(used, 0, sizeof(used));\n  memset(used2, 0, sizeof(used2));\n  typedef pair<int, int> Pos;\n  queue<Pos> que;\n\n  for (size_t y = 0; y < H; y++) {\n    if(maze[y][0] == '#'){\n      used[y][0] = true;\n    }\n    else if(maze[y][0] == '.'){\n      que.push(Pos(0,y));\n    }\n    if(maze[y][W-1] == '#'){\n      used[y][W-1] = true;\n    }\n    else if(maze[y][W-1] == '.'){\n      que.push(Pos(W-1, y));\n    }\n  }\n\n  for (size_t x = 0; x < W; x++) {\n    if(maze[0][x] == '#'){\n      used[0][x] = true;\n    }\n    else if(maze[0][x] == '.'){\n      que.push(Pos(x,0));\n    }\n    if(maze[H-1][x] == '#'){\n      used[H-1][x] = true;\n    }\n    else if(maze[H-1][x] == '.'){\n      que.push(Pos(x, H-1));\n    }\n  }\n\n  while(que.size()){\n    Pos pos = que.front();\n    que.pop();\n\n    if(used2[pos.second][pos.first]){\n      continue;\n    }\n\n    used2[pos.second][pos.first] = true;\n\n    for (size_t d = 0; d < 4; d++) {\n      int nx = pos.first + dx[d];\n      int ny = pos.second + dy[d];\n      if(isInFiled(nx, ny)){\n        if(maze[ny][nx] == '#'){\n          used[ny][nx] = true;\n        }\n        else if(maze[ny][nx] == '.'){\n          que.push(Pos(nx, ny));\n        }\n      }\n    }\n  }\n\n  int ret = 0;\n  for (int y = 0; y < H; y++) {\n    for (int x = 0; x < W; x++) {\n      ret += used[y][x];\n    }\n  }\n\n  return ret;\n\n}\n\nint main()\n{\n  input();\n  cout << solve() << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iostream>\n#include<stdio.h>\n#include<string>\n#include<vector>\n#include<map>\n#include<math.h>\n#include<algorithm>\n#include<iomanip>\n\nusing namespace std;\n\nint w, h, ans = 0;\nvector<vector<int>> mp;\nvector<int> x, y;\nint qx[4] = { 1, -1, 0, 0 };\nint qy[4] = { 0, 0, 1, -1 };\n\nvoid f(int yy, int xx) {\n\tif (mp[yy][xx] == -1) {\n\t\treturn;\n\t}\n//\tcout << yy << \" \" << xx << endl;\n\tmp[yy][xx] = -1;\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (yy + qy[i] >= 0 && yy + qy[i] < h + 2 && xx + qx[i] >= 0 && xx + qx[i] < w + 2) {\n\t\t\tif (mp[yy + qy[i]][xx + qx[i]] == 2) {\n\t\t\t\tmp[yy + qy[i]][xx + qx[i]] = 3;\n\t\t\t}\n\t\t\tif (mp[yy + qy[i]][xx + qx[i]] == 0) {\n\t\t\t\tf(yy + qy[i], xx + qx[i]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcontinue;\n\t\t}\n\t}\n\t\n\treturn;\n}\n\nint main() {\n\tcin >> h >> w;\n\tmp.resize(h + 2);\n\tmp[0].resize(w + 2);\n\tmp[h+1].resize(w + 2);\n\tfor (int i = 1; i < h + 1; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tmp[i].resize(w + 2);\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (s[j] == 'X') {\n\t\t\t\tmp[i][j + 1] = 1;\n\t\t\t\ty.push_back(i);\n\t\t\t\tx.push_back(j + 1);\n\t\t\t\tif (i == 1 || i == h || j == 0 || j == w - 1)\n\t\t\t\t\tans = -1;\n\t\t\t}\n\t\t}\n\t}\n\tif (ans == -1) {\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < x.size(); i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tif (mp[y[i] + qy[j]][x[i] + qx[j]] == 0) {\n\t\t\t\tmp[y[i] + qy[j]][x[i] + qx[j]] = 2;\n\t\t\t}\n\t\t}\n\t}\n\tf(0, 0);\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (mp[i + 1][j + 1] == 3)\n\t\t\t\tans++;\n\t\t}\n\t}\n\n\n\tcout << ans << endl;\n\t//cin >> h;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define INF 500\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint to,cap,rev;\n\tedge(){}\n\tedge(int tt,int cc,int rr){\n\t\tto=tt;\n\t\tcap=cc;\n\t\trev=rr;\n\t}\n};\n\nvector<edge> G[60000];\nbool used[60000];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nvoid add_edge(int f,int t,int cap){\n\tG[f].push_back(edge(t,cap,G[t].size()));\n\tG[t].push_back(edge(f,0,G[f].size()-1));\n}\n\nint dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to] && e.cap>0){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(1){\n\t\tmemset(used,false,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(f==0)return flow;\n\t\tflow+=f;\n\t}\n}\n\nint h,w;\nint fie[101][101];\n\nint solve(){\n\tint S=h*w*2,T=S+1;\n\tfor(int i=0;i<h;i++){\n\t\tif(fie[i][0]==1)return -1;\n\t\tadd_edge(i*w*2+1,T,INF);\n\t\tif(fie[i][w-1]==1)return -1;\n\t\tadd_edge(((i+1)*w-1)*2+1,T,INF);\n\t}\n\tfor(int i=0;i<w;i++){\n\t\tif(fie[0][i]==1)return -1;\n\t\tadd_edge(i*2+1,T,INF);\n\t\tif(fie[h-1][i]==1)return -1;\n\t\tadd_edge(((h-1)*w+i)*2+1,T,INF);\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(fie[i][j]==1){\n\t\t\t\tadd_edge((i*w+j)*2,(i*w+j)*2+1,INF);\n\t\t\t\tadd_edge(S,(i*w+j)*2+1,INF);\n\t\t\t}else{\n\t\t\t\tadd_edge((i*w+j)*2,(i*w+j)*2+1,1);\n\t\t\t}\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tint nx=j+dx[k],ny=i+dy[k];\n\t\t\t\tif(nx>=0 && nx<w && ny>=0 && ny<h){\n\t\t\t\t\tadd_edge((i*w+j)*2+1,(ny*w+nx)*2,INF);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res=max_flow(S,T);\n\treturn res==INF?-1:res;\n}\n\nint main(void){\n\tscanf(\"%d%d\",&h,&w);\n\tfor(int i=0;i<h;i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[j]=='X'){\n\t\t\t\tfie[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vin=vector<int>;\nusing vll=vector<long long>;\nusing vvin=vector<vector<int>>;\nusing vvll=vector<vector<long long>>;\nusing vstr=vector<string>;\nusing vvstr=vector<vector<string>>;\nusing vch=vector<char>;\nusing vvch=vector<vector<char>>;\nusing vbo=vector<bool>;\nusing vvbo=vector<vector<bool>>;\nusing vpii=vector<pair<int,int>>;\nusing pqsin=priority_queue<int,vector<int>,greater<int>>;\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep2(i,s,n) for(int i=(s);i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define decp(n) cout<<fixed<<setprecision((int)n)\nconst int inf=1e9+7;\nconst ll INF=1e18;\n\nstruct edge{int to;ll cap;int rev;};\n\nint MAX_V=20050;\nint tmp1,tmp2;\n\nvector<vector<edge>> g(MAX_V);//グラフの隣接リスト表現\nvin level(MAX_V);//distance form s\nvin iter(MAX_V);//どこまで調べたか\n\nvoid add_edge(int from,int to,ll cap=(ll)inf){\n    tmp1=g[to].size();tmp2=g[from].size();\n    g[from].push_back((edge){to,cap,tmp1});//g[to]のg[to].size()番目にfromが入っている\n    g[to].push_back((edge){from,0,tmp2});//g[from]のg[from].size()-1番目にtoが入っている\n}\n\nvoid bfs(int s){\n    fill(all(level),-1);\n    queue<int> q;\n    q.push(s);\n    level[s]=0;\n    while(q.size()){\n        int v=q.front();q.pop();\n        for(auto& e:g[v]){\n            if(e.cap>0&&level[e.to]<0){\n                level[e.to]=level[v]+1;\n                q.push(e.to);\n            }\n        }\n    }\n}\n\n//増加パスをdfsで探す\n//v:今見てる頂点 t:終点 f:流量\nint dfs(int v,int t,ll f){\n    if(v==t)return f;\n    for(int& i=iter[v];i<(int)g[v].size();i++){\n        edge& e=g[v][i];\n        if(e.cap>0&&level[v]<level[e.to]){\n            ll d=dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                g[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n//sからtへの最大流を求める\nint max_flow(int s,int t){\n    ll flow=(ll)0;\n    ll f;\n    for(;;){\n        bfs(s);\n        if(level[t]<0)return flow;\n        fill(all(iter),0);\n        while((f=dfs(s,t,inf))>0)flow+=f;\n    }\n}\n\nint main(){\n    int h,w;cin>>h>>w;\n    vstr S(h);\n    rep(i,h)cin>>S[i];\n    //各マスinとoutを2つ用意\n    //(i,j)のinは2(i*w+j)で, outは2(i*w+j)+1で表される\n    int s=2*h*w;//s→ヤギ\n    int t=s+1;//追加したグリッドのマス(ゴール)→t\n    int tmp;\n    rep(i,h)rep(j,w){\n        tmp=2*(i*w+j);\n        if(S[i][j]=='X'){\n            if(i==0||i==h-1||j==0||j==w-1){\n                cout<<-1<<endl;\n                return 0;\n            }\n            add_edge(tmp,tmp+1);\n            add_edge(s,tmp);\n        }\n        else add_edge(tmp,tmp+1,(ll)1);\n        if(i>0)add_edge(tmp+1,tmp-2*w);\n        if(i<h-1)add_edge(tmp+1,tmp+2*w);\n        if(j>0)add_edge(tmp+1,tmp-2);\n        if(j<w-1)add_edge(tmp+1,tmp+2);\n        if(i==0||i==h-1||j==0||j==w-1)add_edge(tmp+1,t);\n    }\n    cout<<max_flow(s,t)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nint main()\n{\n    int h, w;\n    cin >> h >> w;\n\n    int yMin = INT_MAX;\n    int yMax = INT_MIN;\n    int xMin = INT_MAX;\n    int xMax = INT_MIN;\n    for(int y=0; y<h; ++y){\n        for(int x=0; x<w; ++x){\n            char c;\n            cin >> c;\n            if(c == 'X'){\n                if(y == 0 || y == h - 1 || x == 0 || x == w - 1){\n                    cout << -1 << endl;\n                    return 0;\n                }\n\n                int y2 = x + y;\n                int x2 = x - y;\n                yMin = min(yMin, y2);\n                yMax = max(yMax, y2);\n                xMin = min(xMin, x2);\n                xMax = max(xMax, x2);\n            }\n        }\n    }\n\n    int ans = (yMax - yMin) + (xMax - xMin) + 4;\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<ut,VI> PQ;\nclass UnionFind{\n \n\tvector<int> unions,talls,sents,dists,sizes;\n\tint size;\npublic:\n\tUnionFind(){}\n\tUnionFind(int size):size(size){\n\t\tinit();\n\t}\n\tvoid init(){\n\t \tunions=vector<int>(size);\n\t \ttalls=vector<int>(size);\n\t \tsents=vector<int>(size);\n\t \tdists=vector<int>(size);\n\t \tsizes=vector<int>(size);\n\t\tFOR(i,0,size){\n\t\t\tunions[i]=i;\n\t\t\tsents[i]=0;\n\t\t\tsizes[i]=1;\n//\t\t\tns[i].PB(pr(0,1));\n\t\t\ttalls[i]=1;\n\t\t}\n\t}\n\tint find(int x,int t=0){\n\t\tif(unions[x]==x || sents[x]>t) return x;\n\t\treturn find(unions[x],t);\n \n\t}\n\tint minisize(int x){\n\t\tif(x==unions[x]) return sizes[x];\n\t\treturn minisize(find(x));\n\t}\n\tbool isFriend(int a,int b,int t=0){\n\t\treturn find(a,t)==find(b,t);\t\n\t}\n\tvoid unite(int a,int b,int t=0){\n\t\tif(isFriend(a,b,t)) return;\n\t\ta=find(a,t);\n\t\tb=find(b,t);\n\t\tif(talls[a]<talls[b]) unite(b,a,t);\n\t\telse{\n \t\t\tsizes[a]+=sizes[b];\n\t\t\tsents[b]=t;\n\t\t\ttalls[a]=max(talls[a],talls[b]+1);\n\t\t\tunions[b]=a;\n\t\t\tdists[b]=1;\n//\t\t\tns[a].PB(pr(t,ns[b].back().second+ns[a].back().second));\n\t\t}\n\t}\n};\nUnionFind uf;\nconst ut INF=1LL<<30;\nconst int SIZE=201;\nint maps[SIZE][SIZE];\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\ncli d[4];\nbool searched[SIZE][SIZE][3];\nint conv(cli x){\n\treturn x.real()*1000+x.imag()+10000;\n}\nint solve(){\n\tuf=UnionFind(200000);\n\tREP(i,4) d[i]=cli(dy[i],dx[i]);\n\tint H,W;\n\tcin >> H >> W;\n\tqueue<cli> qu;\n\tREP(i,H){\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,W){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(maps[i][j]) qu.push(cli(j,i));\n\t\t}\n\t}\n\tqueueing:\n\twhile(!qu.empty()){\n\t\tcli now=qu.front();\n\t\tqu.pop();\n\t\t\n\t\t//if(maps[now.imag()][now.real()]==1) count++;\n\t\t//if(count==1e7) return -1;\n\t\tif(maps[now.imag()][now.real()]==1){\n\t\t\t\n\t\t\tif(searched[now.imag()][now.real()][0]) continue;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) return -1;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=1){\n\t\t\t\t\tqu.push(next);\n\t\t\t\t\tmaps[next.imag()][next.real()]=-1;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t//\tcout << next << endl;\n\t\t\t}\n\t\t\tsearched[now.imag()][now.real()][0]=true;\n\t\t}\n\t\telse if(maps[now.imag()][now.real()]==-1){\n\t\t\tint around=0;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) continue;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=0) around++;\n\t\t\t\tif(!searched[now.imag()][now.real()][1]) if(maps[next.imag()][next.real()]!=1) qu.push(next);\n\t\t\t}\n\t\t\tsearched[now.imag()][now.real()][1]=true;\n\t\t\tif(around>=3){\n\t\t\t\tmaps[now.imag()][now.real()]=1;\n\t\t\t\tqu.push(now);\n\t\t\t}\n\t\t} \n\t\telse if(maps[now.imag()][now.real()]==0){\n\t\t\tint around=0;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) continue;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=0) around++;\n\t\t\t}\n\t\t\tif(around>=4){\n\t\t\t\tmaps[now.imag()][now.real()]=1;\n\t\t\t\tqu.push(now);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tREP(i,H){\n\t\tREP(j,W){\n\t\t\tcli now=cli(j,i);\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1){\n\t\t\t\tuf.unite(conv(now),0);\n\t\t\t}\n\t\t\tREP(k,4){\n\t\t\t\tcli now=cli(j,i);\n\t\t\t\tcli next=now+d[k];\n\t\t\t\tif(maps[now.imag()][now.real()]==0 && maps[next.imag()][next.real()]==0) uf.unite(conv(now),conv(next));\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,H){\n\t\tREP(j,W){\n\t\t\tcli now=cli(j,i);\n\t\t\tif(uf.isFriend(conv(now),0)) continue;\n\t\t\tif(maps[now.imag()][now.real()]) continue;\n\t\t\tmaps[now.imag()][now.real()]=1;\n\t\t\tqu.push(now);\n\t\t}\n\t}\n\tif(!qu.empty()) goto queueing;\n\t//cout << count << endl;\n\tint ans=0;\n\tREP(i,H){\n\t\tREP(j,W){\n\t\t//\tcout << maps[i][j]+1;\n\t\t\tans+=maps[i][j]==-1;\n\t\t}\n\t//\tcout << endl;\n\t}\n\treturn ans;\n}\nint main(){\n\tcout << solve() << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define mem(a) memset(a,0,sizeof(a))\n#define pd(a) printf(\"%.10f\\n\",a)\n#define pb(a) push_back(a)\n#define in(a) insert(a)\n#define pi M_PI\n#define R cin>>\n#define F first\n#define S second\n#define C class\n#define ll long long\n#define ln cout<<'\\n'\ntemplate<C T>void pr(T a){cout<<a;ln;}\ntemplate<C T,C T2>void pr(T a,T2 b){cout<<a<<' '<<b;ln;}\ntemplate<C T,C T2,C T3>void pr(T a,T2 b,T3 c){cout<<a<<' '<<b<<' '<<c;ln;}\ntemplate<C T>void PR(T a,int n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nvoid Main() {\n  int n,m;\n  cin >> n >> m;\n  string s[n];\n  rep(i,n) R s[i];\n  vector<int> v[n];\n  rep(i,n) {\n    rep(j,m) {\n      if((!i||!j||i==n-1||j==m-1)&&s[i][j]=='X') {\n        pr(-1);\n        return;\n      }\n      if(s[i][j]=='X') v[i].push_back(j);\n    }\n  }\n  rep(i,n) sort(all(v[i]));\n  int ans=2;\n  P a=P(-1,-1);\n  rep(i,n) {\n    if(v[i].size()) {\n      a=P(i,v[i][0]);\n      break;\n    }\n  }\n  while(1) {\n    P p=P(-1,MAX);\n    REP(i,a.F+1,n) {\n      if(!v[i].size()) continue;\n      if(v[i][0]<p.S) p=P(i,v[i][0]);\n    }\n    if(p.F==-1) break;\n    ans+=max(abs(a.F-p.F),abs(a.S-p.S));\n    a=p;\n  }\n  a=P(-1,-1);\n  rep(i,n) {\n    if(v[i].size()) {\n      a=P(i,v[i][v[i].size()-1]);\n      break;\n    }\n  }\n  while(1) {\n    P p=P(-1,-1);\n    REP(i,a.F+1,n) {\n      if(!v[i].size()) continue;\n      if(v[i][v[i].size()-1]>p.S) p=P(i,v[i][v[i].size()-1]);\n    }\n    if(p.F==-1) break;\n    ans+=max(abs(a.F-p.F),abs(a.S-p.S));\n    a=p;\n  }\n  rep(i,n) {\n    if(v[i].size()) {\n      ans+=v[i][v[i].size()-1]-v[i][0]+1;\n      break;\n    }\n  }\n  rrep(i,n) {\n    if(v[i].size()) {\n      ans+=v[i][v[i].size()-1]-v[i][0]+1;\n      break;\n    }\n  }\n  pr(ans);\n}\n\nint main() {\n  ios::sync_with_stdio(0);cin.tie(0);\n  Main();return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*? begin \"base.hpp\" */\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve( /* この関数に問題ごとの処理を書く */\n#ifdef GCJ_CASE\n long long case_id\n#endif\n);\n\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n #define debug true\n#else\n #define NDEBUG \n #define debug false\n#endif\n#include<algorithm>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<type_traits>\n#include<vector>\n#ifdef __cpp_lib_execution\n  #include<execution>\n#endif\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL \n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define times(n,i) uptil(0,n,i)\n#define rtimes(n,i) downto((n)-1,0,i)\n#define upto(f,t,i) for(int rabT##i=(t),i=(f);i<=rabT##i;i++)\n#define uptil(f,t,i) for(int rabT##i=(t),i=(f);i< rabT##i;i++)\n#define downto(f,t,i) for(int rabT##i=(t),i=(f);i>=rabT##i;i--)\n#define downtil(f,t,i) for(int rabT##i=(t),i=(f);i> rabT##i;i--)\n#define iter(v) begin(v),end(v)\n#define citer(v) cbegin(v),cend(v)\n#define riter(v) rbegin(v),rend(v)\n#define criter(v) crbegin(v),crend(v)\n#define IF(a,b,c) ((a)?(b):(c))\n#define BINOP_ASGN(t,u,op) t operator op(CS u&o)CS{RT t(*this)op##=o;}\n#if debug\n #define _GLIBCXX_DEBUG\n #define _LIBCPP_DEBUG 2\n #define _LIBCPP_DEBUG2 2\n #define ln <<endl\n#else\n #define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n #define PARABLE \n/*? begin \"mod.hpp\" */\n#ifdef MOD\n #if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n  #error unknown mod MOD and FORCE_MOD not defined.\n #endif\n#else\n #define MOD 1000000007\n#endif\n/*? begin \"power.hpp\" */\nusing int128=__int128;\nTL<TN T>T power(T x,int n){T rt(1);for(;n;n/=2){if(n%2)rt*=x;x*=x;}RT rt;}\nint pow_mod(int x,int n,int m){int rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\nint128 pow_mod_64(int128 x,int n,int m){int128 rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\n/*? end \"power.hpp\" */\nIL CX int modulo(int a,int m){RT(a%=m,a>=0?a:a+m);}\nTL<ULL mod=MOD>class MInt{\n  /*! https://ei1333.github.io/luzhiled/snippets/other/mod-int.html */\npublic:\n  int val;\n  CX MInt():val(0){}\n  explicit CX MInt(int v):val(modulo(v,mod)){}\n  MInt&operator+=(CS MInt&m){val+=m.val;if(val>=mod)val-=mod;RT*this;}\n  MInt&operator-=(CS MInt&m){val-=m.val;if(val<0)val+=mod;RT*this;}\n  MInt&operator*=(CS MInt&m){val=val*m.val%mod;RT*this;}\n  MInt&operator/=(CS MInt&m){val=val*m.inv().val%mod;RT*this;}\n  BINOP_ASGN(MInt,MInt,+) BINOP_ASGN(MInt,MInt,-) BINOP_ASGN(MInt,MInt,*) BINOP_ASGN(MInt,MInt,/)\n  MInt operator-()CS{MInt m;m.val=val?mod-val:0;RT m;}\n  bool operator==(CS MInt&m)CS{RT val==m.val;}\n  bool operator!=(CS MInt&m)CS{RT val!=m.val;}\n  //MInt pow(int n)CS{MInt x(*this),rt(1);while(n){if(n%2)rt*=x;x*=x;n/=2;}RT rt;}\n  MInt pow(int n)CS{RT power(*this,n);}\n  MInt inv()CS{int a=val,b=mod,x=1,y=0,t;while(b){t=a/b;swap(b,a-=t*b);swap(y,x-=t*y);}RT(MInt)x;}\n  friend ostream&operator<<(ostream&o,CS MInt<mod>&m){RT o<<m.val;}\n  friend istream&operator>>(istream&i,MInt<mod>&m){int v;i>>v;m=MInt<mod>(v);RT i;}\n};\nusing mint=MInt<>;\n\nconstexpr mint operator\"\" _m(ULL n){RT mint(n);}\nconstexpr MInt<998244353>operator\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nconstexpr MInt<1000000007>operator\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nconstexpr MInt<1000000009>operator\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n\n//#pragma rab:gsub \\b(\\d+)m\\b mint(\\1)\n/*? end \"mod.hpp\" */\n/*? begin \"typedefs.hpp\" */\nstruct unit{};\n\nusing int128=__int128;\nusing LD=long double;\nTL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;\nTL<TN T>using vvvec=vec<vvec<T>>;\nTL<TN T>using vvvvec=vec<vvvec<T>>;\n\n//#pragma rab typedefs.dynamic\nusing WI = vvec<int>; using VI = vec<int>; using VC = vec<char>; using HII = map<int, int>; using VS = vec<string>; \n/*? end \"typedefs.hpp\" */\n/*? begin \"alias.hpp\" */\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n/*? end \"alias.hpp\" */\n/*? begin \"util.hpp\" */\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,true);}\nTL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,true);}\n\n#ifndef __cpp_lib_exchange_function\n #define exchange exchange_RAB\n TL<TN T,TN U=T>IL T exchange(T& t, U&& u){T x=move(t);t=forward<U>(u);RT x;}\n#endif\n#ifndef __cpp_lib_clamp\n #define clamp clamp_RAB\n TL<TN T>IL CX CS T&clamp(CS T&a,CS T&mn,CS T&mx){RT a<mn?mn:a>mx?mx:a;}\n#endif\n\nTL<TN T>IL int size_RAB(T t){RT t.size();}\n#define size size_RAB\n\nTL<TN V>IL void uniq_after_sort(V&v){v.erase(unique(iter(v)),v.end());}\nTL<TN V>IL void sort_and_uniq(V&v){sort(iter(v));v.erase(unique(iter(v)),v.end());}\nTL<TN V,TN K>IL auto leftmost_ge(CS V&v,CS K&k){RT v.lower_bound(k);}\nTL<TN V,TN K>IL auto leftmost_gt(CS V&v,CS K&k){RT v.upper_bound(k);}\n\nnamespace rab{\n\nTL<TN V,TN W>IL void append(V&v,CS W&w){copy(PARABLE citer(w),back_inserter(v));}\n\nTL<TN V>IL auto flatten(CS V&xss,int reserve_size=0)->TN V::value_type{\n  decltype(flatten(xss))ret;\n  ret.reserve(reserve_size);\n  for(CS auto&xs:xss)append(ret,xs);\n  ret.shrink_to_fit();\n  RT move(ret);\n}\n\nTL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}\n\nTL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){RT 0<=i&&i<size(v)?v[i]:d;}\nTL<TN T>IL T fetch(CS T&d,CS vvec<T>&v,int i,int j){\n  RT 0<=i&&i<size(v)&&0<=j&&j<size(v[i])?v[i][j]:d;\n}\n// TL<TN T,TN U,TN...I>IL T fetch(CS T&d,CS vec<vec<U>>&v,int i,I...j){\n// RT 0<=i&&i<size(v)?fetch(d,v[i],j...):d;\n// }\nTL<TN T>struct Compressed{int size;map<T,int>zip;vec<T>unzip;};\nTL<TN T>IL Compressed<T>compressed(vec<T>v){\n  sort_and_uniq(v);map<T,int>zip;times(size(v),i)zip[v[i]]=i;RT{size(v),zip,move(v)};\n}\nTL<TN T>struct CompressedSrc{int size;map<T,int>zip;vec<T>unzip;WI src;};\nTL<TN T>IL CompressedSrc<T>compressed_src(CS vec<T>&v){\n  auto c=compressed(v);VI src(c.size);times(size(v),i)src[c.zip[v[i]]].PB(i);RT{c.size,c.zip,c.unzip,src};\n}\n\nstruct identity{TL<TN U>U operator()(U&&v)CS{RT v;}};\n}\n/*? end \"util.hpp\" */\n/*? begin \"debug.hpp\" */\nTL<class T>\nIL istream&operator>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nTL<class T>\nIL ostream&operator<<(ostream&,CS vec<T>&);\nTL<class T,class S>\nIL ostream&operator<<(ostream&,CS map<T,S>&);\n#define DEFINE_ITER_OUTPUT(s,x,sep){int i=0;for(CS auto&x##0_elem:x){if(i++)s<<sep;s<<x##0_elem;}RT s;}\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<T>&v)DEFINE_ITER_OUTPUT(s,v,' ')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS map<T,S>&m)DEFINE_ITER_OUTPUT(s,m,' ')\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<vec<T>>&w)DEFINE_ITER_OUTPUT(s,w,'\\n')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS vec<map<T,S>>&v)DEFINE_ITER_OUTPUT(s,v,'\\n')\n/*? end \"debug.hpp\" */\n\nsigned main(){\n {if(debug)cerr<<\"MOD: \"<<(MOD)ln;}\n if(!debug)cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\n cout<<fixed<<setprecision(20);\n cerr<<fixed<<setprecision(20);\n\n #ifdef GCJ_CASE\n  int T;cin>>T;\n  times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n #else\n  solve();\n #endif\n\n return 0;\n}\n/*? end \"base.hpp\" */\n/*? begin \"graph.hpp\" */\n/*? begin \"uf.hpp\" */\nTL<class T=int,class Adder=plus<T>,class Inverser=negate<T>>\nclass UnionFind{\n/*!\nhttp://noshi91.hatenablog.com/entry/2018/05/30/191943\nhttps://en.wikipedia.org/wiki/Disjoint-set_data_structure\nhttps://qiita.com/drken/items/cce6fc5c579051e64fab\n*/\nint n,*parents,*sizes;T*pot_diffs;bool to_delete;Adder adder;\nInverser inverser;\npublic:\nexplicit UnionFind(int n,bool to_delete=false):\nn(n),parents(new int[n]),sizes(new int[n]),pot_diffs(new T[n]),to_delete(to_delete)\n{clear();\n}\nvoid clear(){\ntimes(n,i)parents[i]=i;/*roots*/\nfill(sizes,sizes+n,1);fill(pot_diffs,pot_diffs+n,0);\n}\n~UnionFind(){if(to_delete){delete[]parents;delete[]sizes;delete[]pot_diffs;}}\nint size(){RT n;}\nint root(int i){int p=parents[i];\nif(p==i)RT i;/*`i`is a root*/\nint r=root(p);/*and pot_diffs[p]:=diff from root*/\npot_diffs[i]+=pot_diffs[p];parents[i]=r;RT r;\n}\nbool is_same(int i,int j){RT root(i)==root(j);}\nbool is_all_same(){int r=root(0);uptil(1,n,i)if(root(i)!=r)RT 0;RT 1;}\nbool merge(int i,int j,T pdiff=0){i=root(i);j=root(j);\nif(i==j)RT false;/*already merged*/\nif(sizes[i]>sizes[j]){swap(i,j);pdiff=inverser(pdiff);\n}\n/*now sizes[i]<=sizes[j]*/\nparents[i]=j;sizes[j]+=sizes[i];pot_diffs[i]=pdiff;RT true;\n}\nT diff(int i,int j){\nroot(i);/*pot_diffs[i]:=diff from root*/\nroot(j);/*pot_diffs[j]:=diff from root*/\nRT adder(pot_diffs[i],inverser(pot_diffs[j]));}};using unionfind=UnionFind<>;\n/*? end \"uf.hpp\" */\nTL<class EdgeVal>\nstruct Edge{int from;int to;EdgeVal weight;\nEdge(int from,int to,EdgeVal weight):from(from),to(to),weight(weight){}\nIL bool OP==(CS Edge&e)CS{RT weight==e.weight&&from==e.from&&to==e.to;}\nIL bool OP<(CS Edge&e)CS{RT weight<e.weight||(weight==e.weight&&(from<e.from||(from==e.from&&to<e.to)));}\nIL bool OP<=(CS Edge&e)CS{RT this==e||this<e;}\nIL bool OP>(CS Edge&e)CS{RT e<this;}\nIL bool OP>=(CS Edge&e)CS{RT e<=this;}};\nTL<class VtxVal,class EdgeVal>\nclass Graph{\nusing VoidWithoutEdgeVal=TN enable_if<is_default_constructible<EdgeVal>::value,void>::type;\nprotected:\nint nv_,nde_;unionfind uf;\npublic:\nvec<VtxVal>vs;vvec<Edge<EdgeVal>>edges;\nGraph(int nv):nv_(nv),nde_(0),uf(nv),vs(nv),edges(nv){}\nIL int nv()CS{RT nv_;}\nIL int nde()CS{RT nde_;}\nIL int nue()CS{RT nde_/2;}\nIL void add_dedge(int i,int j,CS EdgeVal&val){\nif(!rab::is_in(i,0LL,nv_)||!rab::is_in(j,0LL,nv_)){\ncerr<<\"invalid index:(\"<<i<<\",\"<<j<<\")for Graph(nv=\"<<nv_<<\")\" ln;\nexit(1);\n}\nedges[i].emplace_back(i,j,val);++nde_;\n}\nIL VoidWithoutEdgeVal add_dedge(int i,int j){add_dedge(i,j,EdgeVal());\n}\nIL void add_uedge(int i,int j,CS EdgeVal&val){add_dedge(i,j,val);\nadd_dedge(j,i,val);\n}\nIL VoidWithoutEdgeVal add_uedge(int i,int j){add_uedge(i,j,EdgeVal());\n}\nIL bool is_connected(){uf.clear();\nfor(CS auto&es:edges)for(CS auto&e:es)uf.merge(e.from,e.to);RT uf.is_all_same();\n}};\n/*? end \"graph.hpp\" */\n/*? begin \"flow.hpp\" */\n/*!Arihon,https://tubo28.me/algorithm/dinic/*/\nTL<TN F,TN V,TN E,TN CapFn=rab::identity>\n/*F:通常int,CapFn:E->F*/\nstruct dinic{int n,s,t;VI level,prog,que;\nWI edges;/*both direction*/\nvvec<F>cap,flow;\ndinic(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),level(n),prog(n),que(n+1),edges(n),cap(n,VI(n)),flow(n,VI(n))\n{times(n,i){for(auto&e:g.edges[i]){F c=capfn(e.weight);\ncap[i][e.to]+=c;cap[e.to][i]+=c;flow[e.to][i]+=c;edges[i].PB(e.to);\nedges[e.to].PB(i);\n}}}\nF exec(int s,int t){this->s=s;this->t=t;F mf=0;\nwhile(update_level(),level[t]>0){fill(iter(prog),0);mf+=find_paths(s,numeric_limits<F>::max()/8/*inf*/);\n}\nRT mf;\n}\nvoid update_level(){int ql=0,qr=0;fill(iter(level),-1);level[s]=0;\nque[qr++]=s;while(ql!=qr/*queue is not empty*/){int v=que[ql++];\nif(v==t)break;\nfor(int d:edges[v]){if(level[d]<0&&cap[v][d]!=flow[v][d]){level[d]=level[v]+1;\nque[qr++]=d;\n}}}}\nF find_paths(int v,int limit){if(v==t)RT limit;F diff=0;\nfor(;prog[v]<size(edges[v]);++prog[v]){int d=edges[v][prog[v]];\nif(cap[v][d]!=flow[v][d]&&level[v]<level[d]){F df=find_paths(d,min(limit,cap[v][d]-flow[v][d]));\nflow[v][d]+=df;flow[d][v]-=df;diff+=df;limit-=df;if(limit==0)break;\n}}\nRT diff;}};\n/*!Arihon,https://tubo28.me/algorithm/ford-fulkerson/*/\nTL<TN V,TN E,TN CapFn=rab::identity>\nstruct ford_fulkerson{int n,s,t;VC visited;\nWI edges;/*both direction*/\nprivate:\nHII cap_,flow_;\npublic:\nford_fulkerson(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),visited(n),edges(n)\n{times(n,i){for(auto&e:g.edges[i]){int c=capfn(e.weight);\ncap_[i<<32|e.to]+=c;cap_[e.to<<32|i]+=c;flow_[e.to<<32|i]+=c;edges[i].PB(e.to);\nedges[e.to].PB(i);\n}}}\nint cap(int a,int b){RT cap_[a<<32|b];}\nint flow(int a,int b){RT flow_[a<<32|b];}\nint exec(int s,int t){this->s=s;this->t=t;int mf=0;\nwhile(1){fill(iter(visited),false);int df=find_path(s,LLONG_MAX/8/*inf*/);if(df==0)RT mf;\nmf+=df;\n}}\nint find_path(int v,int limit){visited[v]=true;if(v==t)RT limit;\nfor(int d:edges[v]){if(!visited[d]){int c=cap_[v<<32|d],&f=flow_[v<<32|d];\nif(c-f>0){int df=find_path(d,min(limit,c-f));if(df>0){f+=df;flow_[d<<32|v]-=df;RT df;\n}}}}\nRT 0;}};\n/*? end \"flow.hpp\" */\nconstexpr int INF = 1ll << 50;\n\nvoid solve() {\n// HWH(\"S\")\n/* <foxy.memo-area> */\nint H;int W;cin>>H;cin>>W;VS S(H);times(H,Ri_0){cin>>S[Ri_0];}\n/* </foxy.memo-area> */\n\n  Graph<unit, int> g(H * W * 2 + 2);\n\n  int s = H * W * 2, t = H * W * 2 + 1;\n\n  #define inp(i, j) (((i) * W + (j)) * 2)\n  #define outp(i, j) (((i) * W + (j)) * 2 + 1)\n\n  times(H, i) times(W, j) {\n    g.add_dedge(inp(i, j), outp(i, j), 1);\n\n    if(S[i][j] == 'X') {\n      g.add_dedge(s, outp(i, j), INF);\n\n      if(i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n        cout << -1 ln;\n        return;\n      }\n    }\n  }\n\n  times(H, i) {\n    g.add_dedge(outp(i, 0), t, INF);\n    g.add_dedge(outp(i, W-1), t, INF);\n\n    times(W-1, j) {\n      g.add_dedge(outp(i, j), inp(i, j + 1), INF);\n      g.add_dedge(outp(i, j + 1), inp(i, j), INF);\n    }\n  }\n  times(W, j) {\n    g.add_dedge(outp(0, j), t, INF);\n    g.add_dedge(outp(H-1, j), t, INF);\n\n    times(H-1, i) {\n      g.add_dedge(outp(i, j), inp(i + 1, j), INF);\n      g.add_dedge(outp(i + 1, j), inp(i, j), INF);\n    }\n  }\n\n  ford_fulkerson<unit, int> d(g);\n  cout << d.exec(s, t) ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*? begin \"base.hpp\" */\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve( /* この関数に問題ごとの処理を書く */\n#ifdef GCJ_CASE\n long long case_id\n#endif\n);\n\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n #define debug true\n#else\n #define NDEBUG \n #define debug false\n#endif\n#include<algorithm>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<type_traits>\n#include<vector>\n#ifdef __cpp_lib_execution\n  #include<execution>\n#endif\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL \n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define times(n,i) uptil(0,n,i)\n#define rtimes(n,i) downto((n)-1,0,i)\n#define upto(f,t,i) for(int rabT##i=(t),i=(f);i<=rabT##i;i++)\n#define uptil(f,t,i) for(int rabT##i=(t),i=(f);i< rabT##i;i++)\n#define downto(f,t,i) for(int rabT##i=(t),i=(f);i>=rabT##i;i--)\n#define downtil(f,t,i) for(int rabT##i=(t),i=(f);i> rabT##i;i--)\n#define iter(v) begin(v),end(v)\n#define citer(v) cbegin(v),cend(v)\n#define riter(v) rbegin(v),rend(v)\n#define criter(v) crbegin(v),crend(v)\n#define IF(a,b,c) ((a)?(b):(c))\n#define BINOP_ASGN(t,u,op) t operator op(CS u&o)CS{RT t(*this)op##=o;}\n#if debug\n #define _GLIBCXX_DEBUG\n #define _LIBCPP_DEBUG 2\n #define _LIBCPP_DEBUG2 2\n #define ln <<endl\n#else\n #define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n #define PARABLE \n/*? begin \"mod.hpp\" */\n#ifdef MOD\n #if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n  #error unknown mod MOD and FORCE_MOD not defined.\n #endif\n#else\n #define MOD 1000000007\n#endif\n/*? begin \"power.hpp\" */\nusing int128=__int128;\nTL<TN T>T power(T x,int n){T rt(1);for(;n;n/=2){if(n%2)rt*=x;x*=x;}RT rt;}\nint pow_mod(int x,int n,int m){int rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\nint128 pow_mod_64(int128 x,int n,int m){int128 rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\n/*? end \"power.hpp\" */\nIL CX int modulo(int a,int m){RT(a%=m,a>=0?a:a+m);}\nTL<ULL mod=MOD>class MInt{\n  /*! https://ei1333.github.io/luzhiled/snippets/other/mod-int.html */\npublic:\n  int val;\n  CX MInt():val(0){}\n  explicit CX MInt(int v):val(modulo(v,mod)){}\n  MInt&operator+=(CS MInt&m){val+=m.val;if(val>=mod)val-=mod;RT*this;}\n  MInt&operator-=(CS MInt&m){val-=m.val;if(val<0)val+=mod;RT*this;}\n  MInt&operator*=(CS MInt&m){val=val*m.val%mod;RT*this;}\n  MInt&operator/=(CS MInt&m){val=val*m.inv().val%mod;RT*this;}\n  BINOP_ASGN(MInt,MInt,+) BINOP_ASGN(MInt,MInt,-) BINOP_ASGN(MInt,MInt,*) BINOP_ASGN(MInt,MInt,/)\n  MInt operator-()CS{MInt m;m.val=val?mod-val:0;RT m;}\n  bool operator==(CS MInt&m)CS{RT val==m.val;}\n  bool operator!=(CS MInt&m)CS{RT val!=m.val;}\n  //MInt pow(int n)CS{MInt x(*this),rt(1);while(n){if(n%2)rt*=x;x*=x;n/=2;}RT rt;}\n  MInt pow(int n)CS{RT power(*this,n);}\n  MInt inv()CS{int a=val,b=mod,x=1,y=0,t;while(b){t=a/b;swap(b,a-=t*b);swap(y,x-=t*y);}RT(MInt)x;}\n  friend ostream&operator<<(ostream&o,CS MInt<mod>&m){RT o<<m.val;}\n  friend istream&operator>>(istream&i,MInt<mod>&m){int v;i>>v;m=MInt<mod>(v);RT i;}\n};\nusing mint=MInt<>;\n\nconstexpr mint operator\"\" _m(ULL n){RT mint(n);}\nconstexpr MInt<998244353>operator\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nconstexpr MInt<1000000007>operator\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nconstexpr MInt<1000000009>operator\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n\n//#pragma rab:gsub \\b(\\d+)m\\b mint(\\1)\n/*? end \"mod.hpp\" */\n/*? begin \"typedefs.hpp\" */\nstruct unit{};\n\nusing int128=__int128;\nusing LD=long double;\nTL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;\nTL<TN T>using vvvec=vec<vvec<T>>;\nTL<TN T>using vvvvec=vec<vvvec<T>>;\n\n//#pragma rab typedefs.dynamic\nusing WI = vvec<int>; using VI = vec<int>; using VC = vec<char>; using HII = map<int, int>; using VS = vec<string>; \n/*? end \"typedefs.hpp\" */\n/*? begin \"alias.hpp\" */\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n/*? end \"alias.hpp\" */\n/*? begin \"util.hpp\" */\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,true);}\nTL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,true);}\n\n#ifndef __cpp_lib_exchange_function\n #define exchange exchange_RAB\n TL<TN T,TN U=T>IL T exchange(T& t, U&& u){T x=move(t);t=forward<U>(u);RT x;}\n#endif\n#ifndef __cpp_lib_clamp\n #define clamp clamp_RAB\n TL<TN T>IL CX CS T&clamp(CS T&a,CS T&mn,CS T&mx){RT a<mn?mn:a>mx?mx:a;}\n#endif\n\nTL<TN T>IL int size_RAB(T t){RT t.size();}\n#define size size_RAB\n\nTL<TN V>IL void uniq_after_sort(V&v){v.erase(unique(iter(v)),v.end());}\nTL<TN V>IL void sort_and_uniq(V&v){sort(iter(v));v.erase(unique(iter(v)),v.end());}\nTL<TN V,TN K>IL auto leftmost_ge(CS V&v,CS K&k){RT v.lower_bound(k);}\nTL<TN V,TN K>IL auto leftmost_gt(CS V&v,CS K&k){RT v.upper_bound(k);}\n\nnamespace rab{\n\nTL<TN V,TN W>IL void append(V&v,CS W&w){copy(PARABLE citer(w),back_inserter(v));}\n\nTL<TN V>IL auto flatten(CS V&xss,int reserve_size=0)->TN V::value_type{\n  decltype(flatten(xss))ret;\n  ret.reserve(reserve_size);\n  for(CS auto&xs:xss)append(ret,xs);\n  ret.shrink_to_fit();\n  RT move(ret);\n}\n\nTL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}\n\nTL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){RT 0<=i&&i<size(v)?v[i]:d;}\nTL<TN T>IL T fetch(CS T&d,CS vvec<T>&v,int i,int j){\n  RT 0<=i&&i<size(v)&&0<=j&&j<size(v[i])?v[i][j]:d;\n}\n// TL<TN T,TN U,TN...I>IL T fetch(CS T&d,CS vec<vec<U>>&v,int i,I...j){\n// RT 0<=i&&i<size(v)?fetch(d,v[i],j...):d;\n// }\nTL<TN T>struct Compressed{int size;map<T,int>zip;vec<T>unzip;};\nTL<TN T>IL Compressed<T>compressed(vec<T>v){\n  sort_and_uniq(v);map<T,int>zip;times(size(v),i)zip[v[i]]=i;RT{size(v),zip,move(v)};\n}\nTL<TN T>struct CompressedSrc{int size;map<T,int>zip;vec<T>unzip;WI src;};\nTL<TN T>IL CompressedSrc<T>compressed_src(CS vec<T>&v){\n  auto c=compressed(v);VI src(c.size);times(size(v),i)src[c.zip[v[i]]].PB(i);RT{c.size,c.zip,c.unzip,src};\n}\n\nstruct identity{TL<TN U>U operator()(U&&v)CS{RT v;}};\n}\n/*? end \"util.hpp\" */\n/*? begin \"debug.hpp\" */\nTL<class T>\nIL istream&operator>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nTL<class T>\nIL ostream&operator<<(ostream&,CS vec<T>&);\nTL<class T,class S>\nIL ostream&operator<<(ostream&,CS map<T,S>&);\n#define DEFINE_ITER_OUTPUT(s,x,sep){int i=0;for(CS auto&x##0_elem:x){if(i++)s<<sep;s<<x##0_elem;}RT s;}\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<T>&v)DEFINE_ITER_OUTPUT(s,v,' ')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS map<T,S>&m)DEFINE_ITER_OUTPUT(s,m,' ')\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<vec<T>>&w)DEFINE_ITER_OUTPUT(s,w,'\\n')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS vec<map<T,S>>&v)DEFINE_ITER_OUTPUT(s,v,'\\n')\n/*? end \"debug.hpp\" */\n\nsigned main(){\n {if(debug)cerr<<\"MOD: \"<<(MOD)ln;}\n if(!debug)cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\n cout<<fixed<<setprecision(20);\n cerr<<fixed<<setprecision(20);\n\n #ifdef GCJ_CASE\n  int T;cin>>T;\n  times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n #else\n  solve();\n #endif\n\n return 0;\n}\n/*? end \"base.hpp\" */\n/*? begin \"graph.hpp\" */\n/*? begin \"uf.hpp\" */\nTL<class T=int,class Adder=plus<T>,class Inverser=negate<T>>\nclass UnionFind{\n/*!\nhttp://noshi91.hatenablog.com/entry/2018/05/30/191943\nhttps://en.wikipedia.org/wiki/Disjoint-set_data_structure\nhttps://qiita.com/drken/items/cce6fc5c579051e64fab\n*/\nint n,*parents,*sizes;T*pot_diffs;bool to_delete;Adder adder;\nInverser inverser;\npublic:\nexplicit UnionFind(int n,bool to_delete=false):\nn(n),parents(new int[n]),sizes(new int[n]),pot_diffs(new T[n]),to_delete(to_delete)\n{clear();\n}\nvoid clear(){\ntimes(n,i)parents[i]=i;/*roots*/\nfill(sizes,sizes+n,1);fill(pot_diffs,pot_diffs+n,0);\n}\n~UnionFind(){if(to_delete){delete[]parents;delete[]sizes;delete[]pot_diffs;}}\nint size(){RT n;}\nint root(int i){int p=parents[i];\nif(p==i)RT i;/*`i`is a root*/\nint r=root(p);/*and pot_diffs[p]:=diff from root*/\npot_diffs[i]+=pot_diffs[p];parents[i]=r;RT r;\n}\nbool is_same(int i,int j){RT root(i)==root(j);}\nbool is_all_same(){int r=root(0);uptil(1,n,i)if(root(i)!=r)RT 0;RT 1;}\nbool merge(int i,int j,T pdiff=0){i=root(i);j=root(j);\nif(i==j)RT false;/*already merged*/\nif(sizes[i]>sizes[j]){swap(i,j);pdiff=inverser(pdiff);\n}\n/*now sizes[i]<=sizes[j]*/\nparents[i]=j;sizes[j]+=sizes[i];pot_diffs[i]=pdiff;RT true;\n}\nT diff(int i,int j){\nroot(i);/*pot_diffs[i]:=diff from root*/\nroot(j);/*pot_diffs[j]:=diff from root*/\nRT adder(pot_diffs[i],inverser(pot_diffs[j]));}};using unionfind=UnionFind<>;\n/*? end \"uf.hpp\" */\nTL<class EdgeVal>\nstruct Edge{int from;int to;EdgeVal weight;\nEdge(int from,int to,EdgeVal weight):from(from),to(to),weight(weight){}\nIL bool OP==(CS Edge&e)CS{RT weight==e.weight&&from==e.from&&to==e.to;}\nIL bool OP<(CS Edge&e)CS{RT weight<e.weight||(weight==e.weight&&(from<e.from||(from==e.from&&to<e.to)));}\nIL bool OP<=(CS Edge&e)CS{RT this==e||this<e;}\nIL bool OP>(CS Edge&e)CS{RT e<this;}\nIL bool OP>=(CS Edge&e)CS{RT e<=this;}};\nTL<class VtxVal,class EdgeVal>\nclass Graph{\nusing VoidWithoutEdgeVal=TN enable_if<is_default_constructible<EdgeVal>::value,void>::type;\nprotected:\nint nv_,nde_;unionfind uf;\npublic:\nvec<VtxVal>vs;vvec<Edge<EdgeVal>>edges;\nGraph(int nv):nv_(nv),nde_(0),uf(nv),vs(nv),edges(nv){}\nIL int nv()CS{RT nv_;}\nIL int nde()CS{RT nde_;}\nIL int nue()CS{RT nde_/2;}\nIL void add_dedge(int i,int j,CS EdgeVal&val){\nif(!rab::is_in(i,0LL,nv_)||!rab::is_in(j,0LL,nv_)){\ncerr<<\"invalid index:(\"<<i<<\",\"<<j<<\")for Graph(nv=\"<<nv_<<\")\" ln;\nexit(1);\n}\nedges[i].emplace_back(i,j,val);++nde_;\n}\nIL VoidWithoutEdgeVal add_dedge(int i,int j){add_dedge(i,j,EdgeVal());\n}\nIL void add_uedge(int i,int j,CS EdgeVal&val){add_dedge(i,j,val);\nadd_dedge(j,i,val);\n}\nIL VoidWithoutEdgeVal add_uedge(int i,int j){add_uedge(i,j,EdgeVal());\n}\nIL bool is_connected(){uf.clear();\nfor(CS auto&es:edges)for(CS auto&e:es)uf.merge(e.from,e.to);RT uf.is_all_same();\n}};\n/*? end \"graph.hpp\" */\n/*? begin \"flow.hpp\" */\n/*!Arihon,https://tubo28.me/algorithm/dinic/*/\nTL<TN F,TN V,TN E,TN CapFn=rab::identity>\n/*F:通常int,CapFn:E->F*/\nstruct dinic{int n,s,t;VI level,prog,que;\nWI edges;/*both direction*/\nvvec<F>cap,flow;\ndinic(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),level(n),prog(n),que(n+1),edges(n),cap(n,VI(n)),flow(n,VI(n))\n{times(n,i){for(auto&e:g.edges[i]){F c=capfn(e.weight);\ncap[i][e.to]+=c;cap[e.to][i]+=c;flow[e.to][i]+=c;edges[i].PB(e.to);\nedges[e.to].PB(i);\n}}}\nF exec(int s,int t){this->s=s;this->t=t;F mf=0;\nwhile(update_level(),level[t]>0){fill(iter(prog),0);mf+=find_paths(s,numeric_limits<F>::max()/8/*inf*/);\n}\nRT mf;\n}\nvoid update_level(){int ql=0,qr=0;fill(iter(level),-1);level[s]=0;\nque[qr++]=s;while(ql!=qr/*queue is not empty*/){int v=que[ql++];\nif(v==t)break;\nfor(int d:edges[v]){if(level[d]<0&&cap[v][d]!=flow[v][d]){level[d]=level[v]+1;\nque[qr++]=d;\n}}}}\nF find_paths(int v,int limit){if(v==t)RT limit;F diff=0;\nfor(;prog[v]<size(edges[v]);++prog[v]){int d=edges[v][prog[v]];\nif(cap[v][d]!=flow[v][d]&&level[v]<level[d]){F df=find_paths(d,min(limit,cap[v][d]-flow[v][d]));\nflow[v][d]+=df;flow[d][v]-=df;diff+=df;limit-=df;if(limit==0)break;\n}}\nRT diff;}};\n/*!Arihon,https://tubo28.me/algorithm/ford-fulkerson/*/\nTL<TN V,TN E,TN CapFn=rab::identity>\nstruct ford_fulkerson{int n,s,t;VC visited;\nWI edges;/*both direction*/\nprivate:\nHII cap_,flow_;\npublic:\nford_fulkerson(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),visited(n),edges(n)\n{times(n,i){for(auto&e:g.edges[i]){int c=capfn(e.weight);\ncap_[i<<32|e.to]+=c;cap_[e.to<<32|i]+=c;flow_[e.to<<32|i]+=c;edges[i].PB(e.to);\nedges[e.to].PB(i);\n}}}\nint cap(int a,int b)CS{RT cap_[a<<32|b];}\nint flow(int a,int b)CS{RT flow_[a<<32|b];}\nint exec(int s,int t){this->s=s;this->t=t;int mf=0;\nwhile(1){fill(iter(visited),false);int df=find_path(s,LLONG_MAX/8/*inf*/);if(df==0)RT mf;\nmf+=df;\n}}\nint find_path(int v,int limit){visited[v]=true;if(v==t)RT limit;\nfor(int d:edges[v]){if(!visited[d]){int c=cap_[v<<32|d],&f=flow_[v<<32|d];\nif(c-f>0){int df=find_path(d,min(limit,c-f));if(df>0){f+=df;flow_[d<<32|v]-=df;RT df;\n}}}}\nRT 0;}};\n/*? end \"flow.hpp\" */\nconstexpr int INF = 1ll << 50;\n\nvoid solve() {\n// HWH(\"S\")\n/* <foxy.memo-area> */\nint H;int W;cin>>H;cin>>W;VS S(H);times(H,Ri_0){cin>>S[Ri_0];}\n/* </foxy.memo-area> */\n\n  Graph<unit, int> g(H * W * 2 + 2);\n\n  int s = H * W * 2, t = H * W * 2 + 1;\n\n  #define inp(i, j) (((i) * W + (j)) * 2)\n  #define outp(i, j) (((i) * W + (j)) * 2 + 1)\n\n  times(H, i) times(W, j) {\n    g.add_dedge(inp(i, j), outp(i, j), 1);\n\n    if(S[i][j] == 'X') {\n      g.add_dedge(s, outp(i, j), INF);\n\n      if(i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n        cout << -1 ln;\n        return;\n      }\n    }\n  }\n\n  times(H, i) {\n    g.add_dedge(outp(i, 0), t, INF);\n    g.add_dedge(outp(i, W-1), t, INF);\n\n    times(W-1, j) {\n      g.add_dedge(outp(i, j), inp(i, j + 1), INF);\n      g.add_dedge(outp(i, j + 1), inp(i, j), INF);\n    }\n  }\n  times(W, j) {\n    g.add_dedge(outp(0, j), t, INF);\n    g.add_dedge(outp(H-1, j), t, INF);\n\n    times(H-1, i) {\n      g.add_dedge(outp(i, j), inp(i + 1, j), INF);\n      g.add_dedge(outp(i + 1, j), inp(i, j), INF);\n    }\n  }\n\n  ford_fulkerson<unit, int> d(g);\n  cout << d.exec(s, t) ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*? begin \"base.hpp\" */\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve( /* この関数に問題ごとの処理を書く */\n#ifdef GCJ_CASE\n long long case_id\n#endif\n);\n\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n #define debug true\n#else\n #define NDEBUG \n #define debug false\n#endif\n#include<algorithm>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<type_traits>\n#include<vector>\n#ifdef __cpp_lib_execution\n  #include<execution>\n#endif\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL \n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define times(n,i) uptil(0,n,i)\n#define rtimes(n,i) downto((n)-1,0,i)\n#define upto(f,t,i) for(int rabT##i=(t),i=(f);i<=rabT##i;i++)\n#define uptil(f,t,i) for(int rabT##i=(t),i=(f);i< rabT##i;i++)\n#define downto(f,t,i) for(int rabT##i=(t),i=(f);i>=rabT##i;i--)\n#define downtil(f,t,i) for(int rabT##i=(t),i=(f);i> rabT##i;i--)\n#define iter(v) begin(v),end(v)\n#define citer(v) cbegin(v),cend(v)\n#define riter(v) rbegin(v),rend(v)\n#define criter(v) crbegin(v),crend(v)\n#define IF(a,b,c) ((a)?(b):(c))\n#define BINOP_ASGN(t,u,op) t operator op(CS u&o)CS{RT t(*this)op##=o;}\n#if debug\n #define _GLIBCXX_DEBUG\n #define _LIBCPP_DEBUG 2\n #define _LIBCPP_DEBUG2 2\n #define ln <<endl\n#else\n #define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n #define PARABLE \n/*? begin \"mod.hpp\" */\n#ifdef MOD\n #if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n  #error unknown mod MOD and FORCE_MOD not defined.\n #endif\n#else\n #define MOD 1000000007\n#endif\n/*? begin \"power.hpp\" */\nusing int128=__int128;\nTL<TN T>T power(T x,int n){T rt(1);for(;n;n/=2){if(n%2)rt*=x;x*=x;}RT rt;}\nint pow_mod(int x,int n,int m){int rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\nint128 pow_mod_64(int128 x,int n,int m){int128 rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\n/*? end \"power.hpp\" */\nIL CX int modulo(int a,int m){RT(a%=m,a>=0?a:a+m);}\nTL<ULL mod=MOD>class MInt{\n  /*! https://ei1333.github.io/luzhiled/snippets/other/mod-int.html */\npublic:\n  int val;\n  CX MInt():val(0){}\n  explicit CX MInt(int v):val(modulo(v,mod)){}\n  MInt&operator+=(CS MInt&m){val+=m.val;if(val>=mod)val-=mod;RT*this;}\n  MInt&operator-=(CS MInt&m){val-=m.val;if(val<0)val+=mod;RT*this;}\n  MInt&operator*=(CS MInt&m){val=val*m.val%mod;RT*this;}\n  MInt&operator/=(CS MInt&m){val=val*m.inv().val%mod;RT*this;}\n  BINOP_ASGN(MInt,MInt,+) BINOP_ASGN(MInt,MInt,-) BINOP_ASGN(MInt,MInt,*) BINOP_ASGN(MInt,MInt,/)\n  MInt operator-()CS{MInt m;m.val=val?mod-val:0;RT m;}\n  bool operator==(CS MInt&m)CS{RT val==m.val;}\n  bool operator!=(CS MInt&m)CS{RT val!=m.val;}\n  //MInt pow(int n)CS{MInt x(*this),rt(1);while(n){if(n%2)rt*=x;x*=x;n/=2;}RT rt;}\n  MInt pow(int n)CS{RT power(*this,n);}\n  MInt inv()CS{int a=val,b=mod,x=1,y=0,t;while(b){t=a/b;swap(b,a-=t*b);swap(y,x-=t*y);}RT(MInt)x;}\n  friend ostream&operator<<(ostream&o,CS MInt<mod>&m){RT o<<m.val;}\n  friend istream&operator>>(istream&i,MInt<mod>&m){int v;i>>v;m=MInt<mod>(v);RT i;}\n};\nusing mint=MInt<>;\n\nconstexpr mint operator\"\" _m(ULL n){RT mint(n);}\nconstexpr MInt<998244353>operator\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nconstexpr MInt<1000000007>operator\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nconstexpr MInt<1000000009>operator\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n\n//#pragma rab:gsub \\b(\\d+)m\\b mint(\\1)\n/*? end \"mod.hpp\" */\n/*? begin \"typedefs.hpp\" */\nstruct unit{};\n\nusing int128=__int128;\nusing LD=long double;\nTL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;\nTL<TN T>using vvvec=vec<vvec<T>>;\nTL<TN T>using vvvvec=vec<vvvec<T>>;\n\n//#pragma rab typedefs.dynamic\nusing WI = vvec<int>; using VI = vec<int>; using VC = vec<char>; using HII = map<int, int>; using VS = vec<string>; \n/*? end \"typedefs.hpp\" */\n/*? begin \"alias.hpp\" */\n#define EB emplace_back\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n/*? end \"alias.hpp\" */\n/*? begin \"util.hpp\" */\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,true);}\nTL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,true);}\n\n#ifndef __cpp_lib_exchange_function\n #define exchange exchange_RAB\n TL<TN T,TN U=T>IL T exchange(T& t, U&& u){T x=move(t);t=forward<U>(u);RT x;}\n#endif\n#ifndef __cpp_lib_clamp\n #define clamp clamp_RAB\n TL<TN T>IL CX CS T&clamp(CS T&a,CS T&mn,CS T&mx){RT a<mn?mn:a>mx?mx:a;}\n#endif\n\nTL<TN T>IL int size_RAB(T t){RT t.size();}\n#define size size_RAB\n\nTL<TN V>IL void uniq_after_sort(V&v){v.erase(unique(iter(v)),v.end());}\nTL<TN V>IL void sort_and_uniq(V&v){sort(iter(v));v.erase(unique(iter(v)),v.end());}\nTL<TN V,TN K>IL auto leftmost_ge(CS V&v,CS K&k){RT v.lower_bound(k);}\nTL<TN V,TN K>IL auto leftmost_gt(CS V&v,CS K&k){RT v.upper_bound(k);}\n\nnamespace rab{\n\nTL<TN V,TN W>IL void append(V&v,CS W&w){copy(PARABLE citer(w),back_inserter(v));}\n\nTL<TN V>IL auto flatten(CS V&xss,int reserve_size=0)->TN V::value_type{\n  decltype(flatten(xss))ret;\n  ret.reserve(reserve_size);\n  for(CS auto&xs:xss)append(ret,xs);\n  ret.shrink_to_fit();\n  RT move(ret);\n}\n\nTL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}\n\nTL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){RT 0<=i&&i<size(v)?v[i]:d;}\nTL<TN T>IL T fetch(CS T&d,CS vvec<T>&v,int i,int j){\n  RT 0<=i&&i<size(v)&&0<=j&&j<size(v[i])?v[i][j]:d;\n}\n// TL<TN T,TN U,TN...I>IL T fetch(CS T&d,CS vec<vec<U>>&v,int i,I...j){\n// RT 0<=i&&i<size(v)?fetch(d,v[i],j...):d;\n// }\nTL<TN T>struct Compressed{int size;map<T,int>zip;vec<T>unzip;};\nTL<TN T>IL Compressed<T>compressed(vec<T>v){\n  sort_and_uniq(v);map<T,int>zip;times(size(v),i)zip[v[i]]=i;RT{size(v),zip,move(v)};\n}\nTL<TN T>struct CompressedSrc{int size;map<T,int>zip;vec<T>unzip;WI src;};\nTL<TN T>IL CompressedSrc<T>compressed_src(CS vec<T>&v){\n  auto c=compressed(v);VI src(c.size);times(size(v),i)src[c.zip[v[i]]].PB(i);RT{c.size,c.zip,c.unzip,src};\n}\n\nstruct identity{TL<TN U>U operator()(U&&v)CS{RT v;}};\n}\n/*? end \"util.hpp\" */\n/*? begin \"debug.hpp\" */\nTL<class T>\nIL istream&operator>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nTL<class T>\nIL ostream&operator<<(ostream&,CS vec<T>&);\nTL<class T,class S>\nIL ostream&operator<<(ostream&,CS map<T,S>&);\n#define DEFINE_ITER_OUTPUT(s,x,sep){int i=0;for(CS auto&x##0_elem:x){if(i++)s<<sep;s<<x##0_elem;}RT s;}\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<T>&v)DEFINE_ITER_OUTPUT(s,v,' ')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS map<T,S>&m)DEFINE_ITER_OUTPUT(s,m,' ')\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<vec<T>>&w)DEFINE_ITER_OUTPUT(s,w,'\\n')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS vec<map<T,S>>&v)DEFINE_ITER_OUTPUT(s,v,'\\n')\n/*? end \"debug.hpp\" */\n\nsigned main(){\n {if(debug)cerr<<\"MOD: \"<<(MOD)ln;}\n if(!debug)cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\n cout<<fixed<<setprecision(20);\n cerr<<fixed<<setprecision(20);\n\n #ifdef GCJ_CASE\n  int T;cin>>T;\n  times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n #else\n  solve();\n #endif\n\n return 0;\n}\n/*? end \"base.hpp\" */\n/*? begin \"graph.hpp\" */\n/*? begin \"uf.hpp\" */\nTL<class T=int,class Adder=plus<T>,class Inverser=negate<T>>\nclass UnionFind{\n/*!\nhttp://noshi91.hatenablog.com/entry/2018/05/30/191943\nhttps://en.wikipedia.org/wiki/Disjoint-set_data_structure\nhttps://qiita.com/drken/items/cce6fc5c579051e64fab\n*/\nint n,*parents,*sizes;T*pot_diffs;bool to_delete;Adder adder;\nInverser inverser;\npublic:\nexplicit UnionFind(int n,bool to_delete=false):\nn(n),parents(new int[n]),sizes(new int[n]),pot_diffs(new T[n]),to_delete(to_delete)\n{clear();\n}\nvoid clear(){\ntimes(n,i)parents[i]=i;/*roots*/\nfill(sizes,sizes+n,1);fill(pot_diffs,pot_diffs+n,0);\n}\n~UnionFind(){if(to_delete){delete[]parents;delete[]sizes;delete[]pot_diffs;}}\nint size(){RT n;}\nint root(int i){int p=parents[i];\nif(p==i)RT i;/*`i`is a root*/\nint r=root(p);/*and pot_diffs[p]:=diff from root*/\npot_diffs[i]+=pot_diffs[p];parents[i]=r;RT r;\n}\nbool is_same(int i,int j){RT root(i)==root(j);}\nbool is_all_same(){int r=root(0);uptil(1,n,i)if(root(i)!=r)RT 0;RT 1;}\nbool merge(int i,int j,T pdiff=0){i=root(i);j=root(j);\nif(i==j)RT false;/*already merged*/\nif(sizes[i]>sizes[j]){swap(i,j);pdiff=inverser(pdiff);\n}\n/*now sizes[i]<=sizes[j]*/\nparents[i]=j;sizes[j]+=sizes[i];pot_diffs[i]=pdiff;RT true;\n}\nT diff(int i,int j){\nroot(i);/*pot_diffs[i]:=diff from root*/\nroot(j);/*pot_diffs[j]:=diff from root*/\nRT adder(pot_diffs[i],inverser(pot_diffs[j]));}};using unionfind=UnionFind<>;\n/*? end \"uf.hpp\" */\nTL<class EdgeVal>\nstruct Edge{int from;int to;EdgeVal weight;\nEdge(int from,int to,EdgeVal weight):from(from),to(to),weight(weight){}\nIL bool OP==(CS Edge&e)CS{RT weight==e.weight&&from==e.from&&to==e.to;}\nIL bool OP<(CS Edge&e)CS{RT weight<e.weight||(weight==e.weight&&(from<e.from||(from==e.from&&to<e.to)));}\nIL bool OP<=(CS Edge&e)CS{RT this==e||this<e;}\nIL bool OP>(CS Edge&e)CS{RT e<this;}\nIL bool OP>=(CS Edge&e)CS{RT e<=this;}};\nTL<class VtxVal,class EdgeVal>\nclass Graph{\nusing VoidWithoutEdgeVal=TN enable_if<is_default_constructible<EdgeVal>::value,void>::type;\nprotected:\nint nv_,nde_;unionfind uf;\npublic:\nvec<VtxVal>vs;vvec<Edge<EdgeVal>>edges;\nGraph(int nv):nv_(nv),nde_(0),uf(nv),vs(nv),edges(nv){}\nIL int nv()CS{RT nv_;}\nIL int nde()CS{RT nde_;}\nIL int nue()CS{RT nde_/2;}\nIL void add_dedge(int i,int j,CS EdgeVal&val){\nif(debug&&(!rab::is_in(i,0LL,nv_)||!rab::is_in(j,0LL,nv_))){\ncerr<<\"invalid index:(\"<<i<<\",\"<<j<<\")for Graph(nv=\"<<nv_<<\")\" ln;\nexit(1);\n}\nedges[i].emplace_back(i,j,val);++nde_;\n}\nIL VoidWithoutEdgeVal add_dedge(int i,int j){add_dedge(i,j,EdgeVal());\n}\nIL void add_uedge(int i,int j,CS EdgeVal&val){add_dedge(i,j,val);\nadd_dedge(j,i,val);\n}\nIL VoidWithoutEdgeVal add_uedge(int i,int j){add_uedge(i,j,EdgeVal());\n}\nIL bool is_connected(){uf.clear();\nfor(CS auto&es:edges)for(CS auto&e:es)uf.merge(e.from,e.to);RT uf.is_all_same();\n}};\n/*? end \"graph.hpp\" */\n/*? begin \"flow.hpp\" */\n/*!Arihon,https://tubo28.me/algorithm/dinic/*/\nTL<TN F,TN V,TN E,TN CapFn=rab::identity>\nclass dinic{\npublic:\nstruct FlowEdge{CS int from,to,nxt;CS F cap;F flow;\nFlowEdge(int from,int to,int nxt,F cap,F flow):\nfrom(from),to(to),nxt(nxt),cap(cap),flow(flow){}};int n,s,t;VI level,prog,que,heads;vec<FlowEdge>edges;\ndinic(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),level(n),prog(n),que(n),heads(n)\n{fill(iter(heads),-1);edges.reserve(g.nde()*2);int edges_i=0;\ntimes(n,i){for(auto&e:g.edges[i]){F c=capfn(e.weight);\nedges.EB(i,e.to,heads[i],c,(F)0);heads[i]=edges_i;++edges_i;edges.EB(e.to,i,heads[e.to],c,c);\nheads[e.to]=edges_i;++edges_i;\n}}}\nF exec(int s,int t){this->s=s;this->t=t;F mf=0,inf=numeric_limits<F>::max()/8;\nwhile(update_level(),level[s]){copy(iter(heads),begin(prog));\nmf+=find_paths(s,inf);\n}\nRT mf;\n}\nvoid update_level(){int ql=0,qr=0;fill(iter(level),0);level[t]=n;\nque[qr++]=t;while(ql!=qr){int v=que[ql++];\nif(v==s)RT;for(int i=heads[v];~i;i=edges[i].nxt){CS auto&e=edges[i];\nif(!level[e.to]&&e.flow!=0){level[e.to]=level[v]-1;que[qr++]=e.to;\n}}}}\nF find_paths(int v,int limit){if(v==t)RT limit;F diff=0;for(int&i=prog[v];~i;i=edges[i].nxt){auto&e=edges[i];\nif(level[v]<level[e.to]&&e.cap!=e.flow){F df=find_paths(e.to,min(limit,e.cap-e.flow));\ne.flow+=df;edges[i^1].flow-=df;diff+=df;limit-=df;if(limit==0)break;\n}}\nRT diff;}};\n/*!Arihon,https://tubo28.me/algorithm/ford-fulkerson/*/\nTL<TN V,TN E,TN CapFn=rab::identity>\nstruct ford_fulkerson{int n,s,t;VC visited;\nWI edges;/*both direction*/\nprivate:\nHII cap_,flow_;\npublic:\nford_fulkerson(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),visited(n),edges(n)\n{times(n,i){for(auto&e:g.edges[i]){int c=capfn(e.weight);\ncap_[i<<32|e.to]+=c;cap_[e.to<<32|i]+=c;flow_[e.to<<32|i]+=c;edges[i].PB(e.to);\nedges[e.to].PB(i);\n}}}\nint cap(int a,int b){RT cap_[a<<32|b];}\nint flow(int a,int b){RT flow_[a<<32|b];}\nint exec(int s,int t){this->s=s;this->t=t;int mf=0;\nwhile(1){fill(iter(visited),false);int df=find_path(s,LLONG_MAX/8/*inf*/);if(df==0)RT mf;\nmf+=df;\n}}\nint find_path(int v,int limit){visited[v]=true;if(v==t)RT limit;\nfor(int d:edges[v]){if(!visited[d]){int c=cap_[v<<32|d],&f=flow_[v<<32|d];\nif(c-f>0){int df=find_path(d,min(limit,c-f));if(df>0){f+=df;flow_[d<<32|v]-=df;RT df;\n}}}}\nRT 0;}};\n/*? end \"flow.hpp\" */\nconstexpr int INF = 401;\n\nvoid solve() {\n// HWH(\"S\")\n/* <foxy.memo-area> */\nint H;int W;cin>>H;cin>>W;VS S(H);times(H,Ri_0){cin>>S[Ri_0];}\n/* </foxy.memo-area> */\n\n  Graph<unit, int> g(H * W * 2 + 2);\n\n  int s = H * W * 2, t = H * W * 2 + 1;\n\n  #define inp(i, j) (((i) * W + (j)) * 2)\n  #define outp(i, j) (((i) * W + (j)) * 2 + 1)\n\n  times(H, i) times(W, j) {\n    g.add_dedge(inp(i, j), outp(i, j), 1);\n\n    if(S[i][j] == 'X') {\n      g.add_dedge(s, outp(i, j), INF);\n\n      if(i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n        cout << -1 ln;\n        return;\n      }\n    }\n  }\n\n  times(H, i) {\n    g.add_dedge(outp(i, 0), t, INF);\n    g.add_dedge(outp(i, W-1), t, INF);\n\n    times(W-1, j) {\n      g.add_dedge(outp(i, j), inp(i, j + 1), INF);\n      g.add_dedge(outp(i, j + 1), inp(i, j), INF);\n    }\n  }\n  times(W, j) {\n    g.add_dedge(outp(0, j), t, INF);\n    g.add_dedge(outp(H-1, j), t, INF);\n\n    times(H-1, i) {\n      g.add_dedge(outp(i, j), inp(i + 1, j), INF);\n      g.add_dedge(outp(i + 1, j), inp(i, j), INF);\n    }\n  }\n\n  dinic<int, unit, int> d(g);\n  cout << d.exec(s, t) ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<ut,VI> PQ;\nclass UnionFind{\n \n\tvector<int> unions,talls,sents,dists,sizes;\n\tint size;\npublic:\n\tUnionFind(){}\n\tUnionFind(int size):size(size){\n\t\tinit();\n\t}\n\tvoid init(){\n\t \tunions=vector<int>(size);\n\t \ttalls=vector<int>(size);\n\t \tsents=vector<int>(size);\n\t \tdists=vector<int>(size);\n\t \tsizes=vector<int>(size);\n\t\tFOR(i,0,size){\n\t\t\tunions[i]=i;\n\t\t\tsents[i]=0;\n\t\t\tsizes[i]=1;\n//\t\t\tns[i].PB(pr(0,1));\n\t\t\ttalls[i]=1;\n\t\t}\n\t}\n\tint find(int x,int t=0){\n\t\tif(unions[x]==x || sents[x]>t) return x;\n\t\treturn find(unions[x],t);\n \n\t}\n\tint minisize(int x){\n\t\tif(x==unions[x]) return sizes[x];\n\t\treturn minisize(find(x));\n\t}\n\tbool isFriend(int a,int b,int t=0){\n\t\treturn find(a,t)==find(b,t);\t\n\t}\n\tvoid unite(int a,int b,int t=0){\n\t\tif(isFriend(a,b,t)) return;\n\t\ta=find(a,t);\n\t\tb=find(b,t);\n\t\tif(talls[a]<talls[b]) unite(b,a,t);\n\t\telse{\n \t\t\tsizes[a]+=sizes[b];\n\t\t\tsents[b]=t;\n\t\t\ttalls[a]=max(talls[a],talls[b]+1);\n\t\t\tunions[b]=a;\n\t\t\tdists[b]=1;\n//\t\t\tns[a].PB(pr(t,ns[b].back().second+ns[a].back().second));\n\t\t}\n\t}\n};\nUnionFind uf;\nconst ut INF=1LL<<30;\nconst int SIZE=201;\nint maps[SIZE][SIZE];\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\ncli d[4];\nbool searched[SIZE][SIZE][3];\nint H,W;\nint conv(cli x){\n\treturn x.real()*1000+x.imag()+10000;\n}\nint solve(){\n\tREP(i,4) d[i]=cli(dy[i],dx[i]);\n\t\n\tcin >> H >> W;\n\tqueue<cli> qu;\n\tREP(i,H){\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,W){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(i==0 or j==0 or i==H-1 or j==W-1) {\n\t\t\t\tif(maps[i][j]) return -1;\n\t\t\t\tmaps[i][j]=-1;\n\t\t\t\tqu.push(cli(j,i));\n\t\t\t}\n\t\t}\n\t}\n\twhile(!qu.empty()){\n\t\tcli now=qu.front();\n\t\tqu.pop();\n\t\t\n\t\t//if(maps[now.imag()][now.real()]==1) count++;\n\t\t//if(count==1e7) return -1;\n\t\tif(maps[now.imag()][now.real()]==-1){\n\t\t\tint around=0;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(next.imag()==-1 or next.real()==-1 or next.imag()==H or next.real()==W) continue;\n\t\t\t\tif(maps[next.imag()][next.real()]==1) around+=2;\n\t\t\t\tif(maps[next.imag()][next.real()]==0) {\n\t\t\t\t\tqu.push(next);\n\t\t\t\t\taround++; \n\t\t\t\t}\n\t\t\t}\n\t\t\tif(around<=1){\n\t\t\t\tmaps[now.imag()][now.real()]=2;\n\t\t\t\tREP(i,4){\n\t\t\t\t\tcli next=now+d[i];\n\t\t\t\t\tif(next.imag()==-1 or next.real()==-1 or next.imag()==H or next.real()==W) continue;\n\t\t\t\t\tif(maps[next.imag()][next.real()]==0){\n\t\t\t\t\t\tmaps[next.imag()][next.real()]=-1;\n\t\t\t\t\t} \n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t\telse if(maps[now.imag()][now.real()]==0){\n\t\t\tint around=0;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) continue;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]==-1) around++;\n\t\t\t}\n\t\t\tif(around>=4){\n\t\t\t\tmaps[now.imag()][now.real()]=2;\n\t\t\t\tqu.push(now);\n\t\t\t}\n\t\t}\t\t\n\t}\n\tint ans=0;\n\tREP(i,H){\n\t\tREP(j,W){\n\t\t//\tcout << maps[i][j]+1;\n\t\t\tans+=maps[i][j]==-1;\n\t\t}\n\t\t//cout << endl;\n\t}\n\treturn ans;\n}\n\nint solve2(){\n\tuf=UnionFind(200000);\n\n\tqueue<cli> qu;\n\tREP(i,H){\n\t\tREP(j,W){\n\t\t\tmaps[i][j]=maps[i][j]==1;\n\t\t\tif(maps[i][j]) qu.push(cli(j,i));\n\t\t\tREP(k,3) searched[i][j][k]=false;\n\t\t}\n\n\t}\n\tqueueing:\n\twhile(!qu.empty()){\n\t\tcli now=qu.front();\n\t\tqu.pop();\n\t\t\n\t\t//if(maps[now.imag()][now.real()]==1) count++;\n\t\t//if(count==1e7) return -1;\n\t\tif(maps[now.imag()][now.real()]==1){\n\t\t\t\n\t\t\tif(searched[now.imag()][now.real()][0]) continue;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) return -1;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=1){\n\t\t\t\t\tqu.push(next);\n\t\t\t\t\tmaps[next.imag()][next.real()]=-1;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t//\tcout << next << endl;\n\t\t\t}\n\t\t\tsearched[now.imag()][now.real()][0]=true;\n\t\t}\n\t\telse if(maps[now.imag()][now.real()]==-1){\n\t\t\tint around=0;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) continue;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=0) around++;\n\t\t\t\tif(!searched[now.imag()][now.real()][1]) if(maps[next.imag()][next.real()]!=1) qu.push(next);\n\t\t\t}\n\t\t\tsearched[now.imag()][now.real()][1]=true;\n\t\t\tif(around>=3){\n\t\t\t\tmaps[now.imag()][now.real()]=1;\n\t\t\t\tqu.push(now);\n\t\t\t}\n\t\t} \n\t\telse if(maps[now.imag()][now.real()]==0){\n\t\t\tint around=0;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) continue;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=0) around++;\n\t\t\t}\n\t\t\tif(around>=4){\n\t\t\t\tmaps[now.imag()][now.real()]=1;\n\t\t\t\tqu.push(now);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tREP(i,H){\n\t\tREP(j,W){\n\t\t\tcli now=cli(j,i);\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1){\n\t\t\t\tuf.unite(conv(now),0);\n\t\t\t}\n\t\t\tREP(k,4){\n\t\t\t\tcli now=cli(j,i);\n\t\t\t\tcli next=now+d[k];\n\t\t\t\tif(maps[now.imag()][now.real()]==0 && maps[next.imag()][next.real()]==0) uf.unite(conv(now),conv(next));\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,H){\n\t\tREP(j,W){\n\t\t\tcli now=cli(j,i);\n\t\t\tif(uf.isFriend(conv(now),0)) continue;\n\t\t\tif(maps[now.imag()][now.real()]) continue;\n\t\t\tmaps[now.imag()][now.real()]=1;\n\t\t\tqu.push(now);\n\t\t}\n\t}\n\tif(!qu.empty()) goto queueing;\n\t//cout << count << endl;\n\tint ans=0;\n\tREP(i,H){\n\t\tREP(j,W){\n//\t\t\tcout << maps[i][j]+1;\n\t\t\tans+=maps[i][j]==-1;\n\t\t}\n//\t\tcout << endl;\n\t}\n\treturn ans;\n}\nint main(){\n\tint a=solve();\n\tif(a==-1){\n\t\tcout <<-1 << endl;\n\t\treturn 0;\n\t}\n\tint b=solve2();\n\tcout << a <<\" \" << b << endl;\n\tcout << min(a,b) << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 100000\n#define MAXN 25000\n#define MAXD 200\n\nstruct Edge\n{\n    int t, c, r;\n};\n\nchar grid[MAXD+5][MAXD+5];\nint w, h;\nint prv[MAXN+5], vis[MAXN+5];\nvector<Edge> edge[MAXN+5];\n\nint get(int r, int c)\n{\n    if (r < 0 || r >= h || c < 0 || c >= w) return w*h*2+1;\n    return 2*(r*w+c);\n}\n\nint add(int f, int t, int c)\n{\n    Edge a = { t, c, (int)edge[t].size() };\n    Edge b = { f, 0, (int)edge[f].size() };\n    edge[f].push_back(a);\n    edge[t].push_back(b);\n}\n\nint maxflow(int n, int s, int t)\n{\n    long long mf = 0;\n    while (true) {\n        queue<int> Q;\n        Q.push(s);\n        fill(vis, vis+n, false);\n        vis[s] = true;\n        while (!Q.empty()) {\n            int v = Q.front();\n            Q.pop();\n            for (int i = 0; i < edge[v].size(); ++i) {\n                Edge &e = edge[v][i];\n                if (!vis[e.t] && e.c > 0) {\n                    vis[e.t] = true;\n                    prv[e.t] = e.r;\n                    Q.push(e.t);\n                }\n            }\n        }\n        if (!vis[t]) break;\n        int flow = INF;\n        for (int v = t; v != s; v = edge[v][prv[v]].t) {\n            Edge &e = edge[v][prv[v]];\n            Edge &r = edge[e.t][e.r];\n            flow = min(flow, r.c);\n        }\n        for (int v = t; v != s; v = edge[v][prv[v]].t) {\n            Edge &e = edge[v][prv[v]];\n            Edge &r = edge[e.t][e.r];\n            e.c += flow;\n            r.c -= flow;\n        }\n        mf += flow;\n    }\n    return min(mf, INF);\n}\n\nint main()\n{\n    scanf(\"%d%d\", &h, &w);\n    int s = 2*h*w, t = 2*h*w+1;\n    for (int i = 0; i < h; ++i) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < w; ++j) grid[i][j] = s[j];\n    }\n\n    int dr[] = {1,-1,0,0}, dc[] = {0,0,-1,1};\n    for (int r = 0; r < h; ++r) {\n        for (int c = 0; c < w; ++c) {\n            int idx = get(r,c);\n            if (grid[r][c] == 'X') {\n                add(s, idx, INF);\n                add(idx, idx+1, INF);\n            }\n            else add(idx, idx+1, 1);\n            for (int d = 0; d < 4; ++d) {\n                int nr = r+dr[d], nc = c+dc[d];\n                int nidx = get(nr, nc);\n                add(idx+1, nidx, INF);\n            }\n        }\n    }\n    int f = maxflow(2*h*w+2, s, t);\n    printf(\"%d\\n\", (f == INF) ? -1 : f);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\n#define INF (1 << 29)\nusing namespace std;\n\nchar f[105][105] = {0};\nbool fb[105][105] = {0};\nint h, w;\nstatic const int dy[4] = {0,1,0,-1};\nstatic const int dx[4] = {1,0,-1,0};\n\nbool CanEscape(){\n    rep(i,h) if(f[i][0] == 'X' || f[i][w - 1] == 'X') return 1;\n    rep(i,w) if(f[0][i] == 'X' || f[h - 1][i] == 'X') return 1;\n    return 0;\n}\n\nvoid check(){\n    rep(i,h){\n        rep(j,w){\n            if(f[i][j] == 'X'){\n                rep(k,4){\n                    int y = i + dy[k];\n                    int x = j + dx[k];\n                    if(y < 0 || y >= h || x < 0 || x >= w) continue;\n                    fb[y][x] = 1;\n                }\n            }\n        }\n    }\n}\n\nbool checkFence(int y, int x){\n    int cnt = 0;\n    rep(i,y){\n        if(fb[i][x] == 1){\n            cnt++;\n            break;\n        }\n    }\n    for(int i = y + 1; i < h; i++){\n        if(fb[i][x] == 1){\n            cnt++;\n            break;\n        }\n    }\n\n    rep(i,x){\n        if(fb[y][i] == 1){\n            cnt++;\n            break;\n        }\n    }\n    for(int i = x + 1; i < w; i++){\n        if(fb[y][i] == 1){\n            cnt++;\n            break;\n        }\n    }\n    if(cnt == 4) return 1;\n    else return 0;\n}\n\nvoid deleteUselessFence(){\n    rep(i,h){\n        rep(j,w){\n            if(fb[i][j] == 1){\n                if(checkFence(i, j)) fb[i][j] = 0;\n            }\n        }\n    }\n}\n\n\nint countFence(){\n    int cnt = 0;\n    rep(i,h){\n        rep(j,w){\n            if(fb[i][j] == 1) cnt++;\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    cin >> h >> w;\n    rep(i,h) cin >> f[i];\n    if(CanEscape()){\n        cout << -1 << endl;\n    }else{\n        check();\n        deleteUselessFence();\n        cout << countFence() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long int lint;\ntypedef pair<lint, lint> plint;\ntypedef pair<double long, double long> pld;\n#define Alint(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1ll << (n))\n#define FOR(i, begin, end) for(lint i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(lint i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2>& l, const pair<T1, T2>& r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2>& l, const pair<T1, T2>& r) { return make_pair(l.first - r.first, l.second - r.second); }\nconst lint MOD = 998244353, INF = 1e18;\n\nstruct edge { lint to, cap, rev; };\n\nvector<edge> Graph[20005];\nint level[20005];\nint iter[20005];\nvoid add_edge(lint from, lint to, lint cap) {\n\tGraph[from].push_back({ to, cap, SZ(Graph[to]) });\n\tGraph[to].push_back({ from, 0, SZ(Graph[from]) - 1 });\n}\nvoid bfs(lint s) {\n\tmemset(level, -1, sizeof(level));\n\tqueue<lint> que;\n\tque.push(s);\n\tlevel[s] = 0;\n\twhile (!que.empty()) {\n\t\tlint v = que.front(); que.pop();\n\t\tREP(i, SZ(Graph[v])) {\n\t\t\tedge& e = Graph[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nlint dfs(lint v, lint t, lint f) {\n\tif (v == t) return f;\n\tfor (int& i = iter[v]; i < SZ(Graph[v]); i++) {\n\t\tedge& e = Graph[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tlint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tGraph[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nlint max_flow(lint s, lint t) {\n\tlint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0) return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tlint f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\n\nlint H, W;\nchar c;\n\nint main() {\n\tcin.tie(0); ios_base::sync_with_stdio(false);\n\t//始点 20002 終点 20003\n\tlint N = 10000;\n\tcin >> H >> W;\n\tREP(i, H) {\n\t\tREP(j, W) {\n\t\t\tcin >> c;\n\t\t\tif (c == 'X') {\n\t\t\t\tadd_edge(20002, i * H + j + N, INF);\n\t\t\t}\n\t\t\telse add_edge(i * H + j, i * H + j + N, 1);\n\t\t\tif (j != 0) {\n\t\t\t\tadd_edge(i * H + j + N, i * H + j - 1, INF);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i * H + j + N, 20003, INF);\n\t\t\t}\n\t\t\tif (j != W - 1) {\n\t\t\t\tadd_edge(i * H + j + N, i * H + j + 1, INF);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i * H + j + N, 20003, INF);\n\t\t\t}\n\t\t\tif (i != 0) {\n\t\t\t\tadd_edge(i * H + j + N, (i - 1) * H + j, INF);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i * H + j + N, 20003, INF);\n\t\t\t}\n\t\t\tif (i != H - 1) {\n\t\t\t\tadd_edge(i * H + j + N, (i + 1) * H + j, INF);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i * H + j + N, 20003, INF);\n\t\t\t}\n\t\t}\n\t}\n\tlint ans = max_flow(20002, 20003);\n\tif (ans >= INF) cout << -1 << endl;\n\telse cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nchar a[101][101];\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\nint h, w; \nconst int INF = 1000000000;\n\nbool isvalid(int x, int y)\n{\n\tif(x>=0&&x<h&&y>=0&&y<w) return true;\n\telse return false;\n}\n\ntemplate<int MX, ll INF> struct MaxFlow //by yutaka1999, have to define INF and MX (the Max number of vertices)\n{\n\tstruct edge\n\t{\n\t\tint to,cap,rev;\n\t\tedge(int to=0,int cap=0,int rev=0):to(to),cap(cap),rev(rev){}\n\t};\n\tvector <edge> vec[MX];\n\tint level[MX];\n\tint iter[MX];\n\t\n\tvoid addedge(int s,int t,int c) //adds an edge of cap c to the flow graph\n\t{\n\t\tint S=vec[s].size(),T=vec[t].size();\n\t\tvec[s].push_back(edge(t,c,T));\n\t\tvec[t].push_back(edge(s,0,S));\n\t}\n\tvoid bfs(int s)\n\t{\n\t\tmemset(level,-1,sizeof(level));\n\t\tqueue <int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<vec[v].size();i++)\n\t\t\t{\n\t\t\t\tedge&e=vec[v][i];\n\t\t\t\tif (e.cap>0&&level[e.to]<0)\n\t\t\t\t{\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll flow_dfs(int v,int t,ll f)\n\t{\n\t\tif (v==t) return f;\n\t\tfor(int &i=iter[v];i<vec[v].size();i++)\n\t\t{\n\t\t\tedge &e=vec[v][i];\n\t\t\tif (e.cap>0&&level[v]<level[e.to])\n\t\t\t{\n\t\t\t\tll d=flow_dfs(e.to,t,min(f,ll(e.cap)));\n\t\t\t\tif (d>0)\n\t\t\t\t{\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tvec[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tll maxflow(int s,int t) //finds max flow using dinic from s to t\n\t{\n\t\tll flow = 0;\n\t\twhile(1)\n\t\t{\n\t\t\tbfs(s);\n\t\t\tif (level[t]<0) return flow;\n\t\t\tmemset(iter,0,sizeof(iter));\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tll f=flow_dfs(s,t,1000000007);\n\t\t\t\tif(f==0) break;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nMaxFlow<30021,120001> mf;\n\nint in(int x, int y)\n{\n\treturn (w*x + y)*2+1;\n}\n\nint out(int x, int y)\n{\n\treturn (w*x+y)*2+2;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin >> h >> w;\n\tint s = 0; int e = out(h-1,w-1)+1;\n\tfor(int i = 0; i < h; i++)\n\t{\n\t\tfor(int j = 0; j < w; j++)\n\t\t{\n\t\t\t//cerr<<in(i,j)<<' '<<out(i,j)<<'\\n';\n\t\t\tcin >> a[i][j];\n\t\t\tif(a[i][j]=='X')\n\t\t\t{\n\t\t\t\tmf.addedge(in(i,j),out(i,j),INF);\n\t\t\t\tmf.addedge(out(i,j),e,INF);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmf.addedge(in(i,j),out(i,j),1);\n\t\t\t}\n\t\t\tif(i == 0 || i == h - 1 || j == 0 || j == w - 1)\n\t\t\t{\n\t\t\t\tif(a[i][j] == 'X'){cout << -1 << '\\n'; return 0;}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < h; i++)\n\t{\n\t\tfor(int j = 0; j < w; j++)\n\t\t{\n\t\t\tfor(int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tint x = i+dx[k]; int y = j+dy[k];\n\t\t\t\tif(isvalid(x,y))\n\t\t\t\t{\n\t\t\t\t\tmf.addedge(out(i,j),in(x,y),INF);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmf.addedge(s, in(i,j), INF);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<mf.maxflow(s,e)<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <tuple>\n#include <bitset>\n\n#include <queue>\n#include <complex>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <fstream>\n#include <random>\n//#include <time.h>\n#include <ctime>\n#pragma endregion //#include\n/////////\n#define REP(i, x, n) for(int i = x; i < n; ++i)\n#define rep(i,n) REP(i,0,n)\n#define ALL(X) X.begin(), X.end()\n/////////\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\ntypedef std::pair<LL,LL> PLL;//\ntypedef std::pair<int,int> PII;//\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)1e18+20;\nconst LD PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n/////////\n#pragma region Math\n#pragma region\ntemplate<class T>\ninline T gcd(T a, T b){return b ? gcd(b, a % b) : a;}\n#pragma endregion // 最大公約数 gcd\n#pragma region\ntemplate<class T>\ninline T lcm(T a, T b){return a / gcd(a, b) * b;}\n#pragma endregion // 最小公倍数 lcm\n#pragma region\nLL powMod(LL num,LL n,LL mod=(LL)MOD){//(num**n)%mod\n\tnum %= mod;//\n\tif( n == 0 ){\n\t\treturn (LL)1;\n\t}\n\tLL mul = num;\n\tLL ans = (LL)1;\n\twhile(n){\n\t\tif( n&1 ){\n\t\t\tans = (ans*mul)%mod;\n\t\t}\n\t\tmul = (mul*mul)%mod;\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\nLL mod_inverse(LL num,LL mod=MOD){\n\treturn powMod(num,MOD-2,MOD);\n}\n#pragma endregion //繰り返し二乗法 powMod\n#pragma region\ntemplate<class T>\nvector<T> getDivisor(T n){\n\tvector<T> v;\n\tfor(int i=1;i*i<=n;++i){\n\t\tif( n%i == 0 ){\n\t\t\tv.push_back(i);\n\t\t\tif( i != n/i ){//平方数で重複して数えないように\n\t\t\t\tv.push_back(n/i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\treturn v;\n}\n#pragma endregion //約数列挙 getDivisor(n):O(√n)\n#pragma endregion //math\n//Utility:便利な奴\n#pragma region\ntemplate<class T>\nvoid UNIQUE(vector<T>& vec){\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end() );\n}\n#pragma endregion // sort erase unique\n////////////////////////////////\n#pragma region \nlong long  bitcount64(long long bits)\n{\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >>16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >>32 & 0x00000000ffffffff);\n}\n#pragma endregion //その他\n////////////////////////////////\nstruct edge_base{int to;LL cost;};\nedge_base make_edge_base(int to,LL cost){\n\tedge_base ret = {to,cost};\n\treturn ret;\n}\n#pragma region GRL\n#pragma region //グラフ\ntemplate<class T,class EDGE>\nvoid dijkstra(int root,int V,vector<T>& dist,\n\tvector< vector<EDGE> > G\t){\n\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > > que;\n\tdist.assign(V,LINF);\n\tdist[root] = 0;\n\tque.push(pair<T,int>(0,root));//距離、頂点番号\n\n\twhile( !que.empty() ){\n\t\tpair<T,int> p = que.top();que.pop();\n\t\tint v = p.second;\n\t\tif( dist[v] < p.first ) continue;\n\t\tfor(int i=0;i < (int)G[v].size();++i){\n\t\t\tEDGE e = G[v][i];\n\t\t\tif( dist[e.to] > dist[v] + e.cost ){\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tque.push(pair<T,int>(dist[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n#pragma endregion //ダイクストラ法:O(|E|log|V|)\n#pragma region //グラフ\nvoid warshall_floyd(vector<vector<LL> >& dist,int V,const LL inf=LINF){\n\tfor(int k=0;k<V;++k){\n\t\tfor(int i=0;i<V;++i){\n\t\t\tif( dist[i][k] >= inf ) continue;\n\t\t\tfor(int j=0;j<V;++j){\n\t\t\t\tif( dist[k][j] >= inf )continue;\n\t\t\t\tdist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n#pragma endregion //ワーシャルフロイド:O(|V|**3)\n#pragma region\nnamespace FLOW{\n//vector< vector<FLOW:edge> > G;\n\nstruct edge_flow : public edge_base{\n\tint cap;//LD cap;//\n\tint rev;\n};\nedge_flow make_edge_flow(int to,int cap,int rev,LL cost=1){\n//edge_flow make_edge_flow(int to,LD cap,int rev,LL cost=1){\n\tedge_flow ret;\n\t\n\tret.to = to;\n\tret.cost = cost;\n\tret.cap = cap;\n\tret.rev = rev;\n\treturn ret;\n}\n\n//*\nclass Graph{\npublic:\n\tint V;\n\tvector< vector<FLOW::edge_flow> > G;\n\tvector< LL > dist;\n\tvector< int > iter;\n\tvoid init(int v){\n\t\tV = v;\n\t\tG.resize(V);\n\t}\n\t//directed graph\n\tvoid add_edge(int from,int to,int cap){\n\t\tG[from].push_back( FLOW::make_edge_flow(to,cap,G[to].size()) );\n\t\tG[to].push_back( FLOW::make_edge_flow(from,0,G[from].size()-1) );\n\t}\n\t\nprivate:\n\t//sから最短距離をBFSで計算する\n\tvoid bfs(int s){//許容量もチェックしている\n\t\tqueue<int> que;\n\t\tdist = vector<LL>(V,-1);\n\t\tdist[s] = 0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();++i){\n\t\t\t\tedge_flow &e = G[v][i];\n\t\t\t\tif( e.cap > 0 && dist[e.to] < 0 ){\n\t\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nprivate:\n\t//増加パスをDFSで探す\n\tint dfs(int v,int t,int f){\n\t\tif( v==t ) return f;\n\t\tfor(int &i = iter[v];i<(int)G[v].size();++i){//?\n\t\t\tFLOW::edge_flow &e = G[v][i];\n\t\t\tif( e.cap>0 && dist[v] < dist[e.to]){\n\t\t\t\tint d = this->dfs(e.to, t, min(f,e.cap) );\n\t\t\t\tif( d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\t//sからtへの最大流量を求める\n\tint max_flow(int s,int t){\n\t\tint flow = 0;\n\t\tfor(;;){\n\t\t\tthis->bfs(s);\n\t\t\tif( dist[t] < 0 ) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tint f;\n\t\t\twhile( (f = this->dfs(s,t,INF) ) > 0 ){\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n//*/\n}\n#pragma endregion //dinic :O(|E||V|^2)\n#pragma region //グラフ\nbool is_bipartite(int v,int c,vector< vector<int> >& G,vector<int>& Color){\n\tColor[v] = c;\n\tfor(int i=0;i < (int)G[v].size();++i){//隣接グラフ\n\t\tif(Color[ G[v][i] ] == c ) return false;\n\t\tif(Color[ G[v][i] ] == 0 && \n\t\t\t!is_bipartite(G[v][i],-c,G,Color)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nbool is_bipartite(int Root,vector< vector<int> >& Graph){\n\tint GraphSize = Graph.size();\n\tvector<int> Color(GraphSize,0);\n\tconst int ColorNo = 1;\n\treturn is_bipartite(Root,ColorNo,Graph,Color);\n}\n#pragma endregion //二部グラフチェック is_bipartite(root,GraphList)\n#pragma endregion //\n#pragma region \nvector< vector<LL> > NCK;//初期値:0\n//http://sugarknri.hatenablog.com/entry/2016/07/16/165715\nvoid makeinv(vector<LL>& inv,const LL P){\n\tint i;\n\t//const int varMAX = max(100000,(int)inv.size());\n\tconst int varMAX = max(100010,(int)inv.size());\n\t\n\tinv = vector<LL>( varMAX+1,0);\n\tinv[1]=1;\n\tfor(i=2;i<=varMAX;i++){\n\t\tinv[i] = (inv[P%i] * (P-P/i)%P ) % P;//OVF\n\t\t//inv[i] = powMod(i,P-2,P);\n\t}\n}\n\nLL nCk(LL N,LL k,LL mod = MOD){\n\tstatic vector<LL> inv;//modの逆元\n\tif( inv.size() == 0 ){\n\t\tmakeinv(inv,mod);//modは素数を入れる\n\t}\n\tk = min(k,N-k);\n\tif( k < 0 || k > N){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tfor(int i=1;i<=k;++i){\n\t\tret = (ret * ((N+1-i)%mod) )%mod;//ret*N:OVF\n\t\tret = (ret * inv[i] )%mod;\n\t}\n\treturn ret;\n}\nLL nCk_once(LL N,LL k,LL mod = MOD){//modは素数\n\tk = min(k,N-k);\n\tif( k < 0 || k > N ){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tLL A=1;\n\tfor(LL i=0;i<k;++i){\n\t\tA = (A * ((N-i)%mod) ) % mod;\n\t}\n\tLL B=1;\n\tfor(LL i=2;i<=k;++i){\n\t\tB = (B * (i%mod) ) % mod;\n\t}\n\tret = ( A * powMod(B,mod-2,mod) ) % mod;\n\treturn ret;\n}\n#pragma endregion //組み合わせnCk(,10^5)\n#pragma region\n\nLL nCk_base(int N,int K,LL mod=MOD){\n\tif( K<0 || N < K ) return 0;//多く取り過ぎ\n\tK = min(K,N-K);\n\tif( K==0 ){return 1%mod;}\n\tif( K==1 ){return N%mod;}//%MOD;\n\tif( N<=10000 && NCK[N][K] ){\n\t\treturn NCK[N][K];\n\t}\n\t//N個目を使わない:nCk(N-1,k)\n\t//N個目を使う\t:nCk(N-1,k-1)\n\tLL ans = (nCk_base(N-1,K)+nCk_base(N-1,K-1) )%mod;//%MOD;\n\tif( N<=10000 ){\n\t\tNCK[N][K] = ans;\n\t}\n\treturn ans;\n}\n\n#pragma endregion //組み合わせ メモ?\n#pragma region CGL\nclass Point{\npublic:\n\tdouble x,y;\n\tPoint(double x=0,double y=0):x(x),y(y){}\n\n\tPoint\toperator +\t(Point p){return Point(add(x,p.x),add(y,p.y));}\n\tvoid\toperator +=\t(Point p){x=add(x,p.x);y=add(y,p.y);}\n\tPoint\toperator -\t(Point p){return Point(add(x,-p.x),add(y,-p.y));}\n\tvoid\toperator -=\t(Point p){x=add(x,-p.x);y=add(y,-p.y);}\n\tPoint\toperator *\t(double a){return Point(x*a,y*a);}\n\tdouble\toperator *\t(Point p){return dot(p);}\n\tPoint\toperator /\t(double a){return Point(x/a,y/a);}\n\n\tdouble norm(){return sqrt(x*x+y*y);}\n\tdouble dot(Point p){return add(x*p.x,y*p.y);}\n\tdouble rot(Point p){return add(x*p.y,-y*p.x);}\n\tdouble add(double a,double b){\n\t\tdouble EPS = 1e-10;\n\t\tif( abs(a+b) < EPS*(abs(a)+abs(b)) ){\n\t\t\treturn 0;\n\t\t}\n\t\treturn a+b;\n\t}\n};\nistream& operator>>(istream& in,Point& P){\n\tin >> P.x >> P.y;\n\treturn in;\n}\nbool operator==(Point A,Point B){\n\tif( A.x==B.x && A.y==B.y)return true;\n\treturn false;\n}\nbool operator<(Point A,Point B){\n\tif( A.x < B.x ) return true;\n\telse if( A.x > B.x ) return false;\n\tif( A.y < B.y ) return true;\n\treturn false;\n}\nbool operator>(Point A,Point B){\n\tif( A<B ) return false;\n\tif( A==B ) return false;\n\treturn true;\n}\n\n//線分で表した直線の交差判定\nbool is_cross(Point p1,Point p2,Point q1,Point q2){\n\tdouble res = (p2-p1).rot(q2-q1);\n\treturn  res != 0;//平行なら0\n}\n\n/*ccwへ//線分p1-p2上に点qがあるか判定\nbool on_seg(Point p1,Point p2,Point q){\n\treturn (p1-q).rot(p2-q) == 0 && (p1-q).dot(p2-q) <= 0;\n}*/\n//直線p1-p2と直線q1-q2の交点\n//交差判定をしてから使う:0除算\nPoint intersection(Point p1,Point p2,Point q1,Point q2){\n\treturn p1+(p2-p1)*((q2-q1).rot(q1-p1)/(q2-q1).rot(p2-p1));\n}\n\n//線分ABに対する点C\nenum PointPotion{ONLINE_BACK=-2,CLOCKWISE,ON_SEGMENT,COUNTER_CLOCKWISE,ONLINE_FRONT};\nPointPotion ccw(Point A,Point B,Point C){\n\tB -= A;C -=A;\n\tif( B.rot(C) > 0 ) return COUNTER_CLOCKWISE;//+1\n\tif( B.rot(C) < 0 ) return CLOCKWISE;//-1\n\tif( B.dot(C) < 0 ) return ONLINE_BACK;//-2\n\tif( B.norm() < C.norm() ) return ONLINE_FRONT;//+2\n\treturn ON_SEGMENT;//0\n}\n//線分p1-p2,と線分q1-q2の交差判定\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nbool intersect(Point p1,Point p2,Point q1,Point q2){\n\treturn\t(ccw(p1,p2,q1) * ccw(p1,p2,q2) <= 0) &&\n\t\t\t(ccw(q1,q2,p1) * ccw(q1,q2,p2) <= 0);\n}\n///\n//直線p1-p2と点q1の距離\ndouble dist_LineP(Point p1,Point p2,Point q1){\n\treturn abs( (p2-p1).rot(q1-p1) )/(p2-p1).norm();\n}\n//線分p1-p2と点q1の距離\ndouble dist_SegP(Point p1,Point p2,Point q1){\n\t//(日)\n\tif( (p2-p1).dot(q1-p1) < 0 ){\n\t\treturn (q1-p1).norm();//p1から見てp2と逆方向\n\t}\n\tif( (p1-p2).dot(q1-p2) < 0 ){\n\t\treturn (q1-p2).norm();//p2から見てp1と逆方向\n\t}\n\treturn dist_LineP(p1,p2,q1);//垂線下ろす\n}\n// 線分同士の最短距離\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D\n//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=862507#1\ndouble dist_segseg(Point A1,Point A2,Point B1,Point B2){\n\tif( intersect(A1,A2,B1,B2) ){\n\t\treturn 0;\n\t}\n\treturn min(\n\t\tmin(dist_SegP(A1,A2,B1),\n\t\t\tdist_SegP(A1,A2,B2)\n\t\t\t),\n\t\tmin(dist_SegP(B1,B2,A1),\n\t\t\tdist_SegP(B1,B2,A2)\n\t\t\t)\n\t\t);\n}\n#pragma endregion //class Point\n#pragma region CGL\n//多角形内なら2,線上なら1,外なら0\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\n//http://www.prefield.com/algorithm/geometry/contains.html\n//点Pから半直線を引く、ガウス\nint contains(vector<Point>& v,Point& P){\n\tbool in = false;\n\tconst int N = v.size();\n\tfor(int i=0;i<N;++i){\n\t\tPoint A = (v[i]-P);\n\t\tPoint B = (v[(i+1)%N]-P);\n\t\tif( A.y > B.y ) swap(A,B);\n\t\tif( A.y <= 0 && 0 < B.y ){\n\t\t\tif( A.rot(B) < 0 ) in =!in;\n\t\t}\n\t\tif( A.rot(B) == 0 && A.dot(B) <= 0 ){\n\t\t\treturn 1;//ON 線上\n\t\t}\n\t}\n\treturn in ? 2:0;//中:外\n}\n#pragma endregion //contains\n#pragma region CGL\n//辞書順で比較\nbool cmp_x(const Point& p,const Point& q){\n\tif( p.x != q.x ) return p.x < q.x;\n\treturn p.y < q.y;\n}\n\n//凸包を求める\nvector<Point> convex_hull(vector<Point> ps,int n){\n\tsort(ps.begin(),ps.end(), cmp_x);\n\tint k = 0;//凸包の頂点数\n\tvector<Point> qs(n*2);//構築中の凸包\n\t//下側の凸包の作成\n\tfor(int i=0;i<n;++i){\n\t\twhile(k>1 && (qs[k-1]-qs[k-2]).rot(ps[i]-qs[k-1]) <=0){//<で線上も加える\n\t\t\tk--;\n\t\t}\n\t\tqs[k++] = ps[i];\n\t}\n\t//上側凸包の作成\n\tfor(int i=n-2,t=k;i>=0;i--){\n\t\twhile(k>t && (qs[k-1]-qs[k-2]).rot(ps[i]-qs[k-1]) <=0){//<\n\t\t\tk--;\n\t\t}\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\n#pragma endregion //凸包\n#pragma region CGL\ndouble area(vector<Point> poly){\n\tint size = poly.size();\n\tdouble ans = 0;\n\tfor(int i=1;i<size-1;++i){\n\t\tans += (poly[i]-poly[0]).rot(poly[i+1]-poly[0])/2;\n\t}\n\treturn ans;\n}\n#pragma endregion //多角形の面積\n#pragma region CGL\nbool compare_x(Point A,Point B){\n\treturn A.x < B.x;\n}\nbool compare_y(Point A,Point B){\n\treturn A.y < B.y;\n}\n//vecはx座標の昇順で渡される\ndouble closest_pair(vector<Point>::iterator itr,int N){\n\tif(  N <= 1 ) return INF;\n\tint m = N/2;\n\tdouble x = (itr+m)->x;\n\tdouble d = min(closest_pair(itr,m),\n\t\tclosest_pair((itr+m),N-m) );\n\t\n\tinplace_merge(itr,itr+m,itr+N,compare_y);\n\n\tvector<Point> B;\n\tfor(int i=0;i<N;++i){\n\t\tif(fabs((itr+i)->x - x) >= d) continue;\n\t\tint Bsize = B.size();\n\t\tfor(int j=0;j<Bsize;j++){\n\t\t\tdouble dx,dy;\n\t\t\tdx = (itr+i)->x - B[Bsize-j-1].x;\n\t\t\tdy = (itr+i)->y - B[Bsize-j-1].y;\n\t\t\tif( dy >= d ) break;\n\t\t\td = min(d,hypot(dx,dy));\n\t\t}\n\t\tB.push_back(*(itr+i));\n\t}\n\treturn d;\n}\n#pragma endregion //最近対 2D\n#pragma region CGL\nint CircleIntersection(Point A,double AR,Point B,double BR){\n\tdouble D = (B-A).norm();\n\tif( D > AR+BR ){\n\t\treturn 4;\n\t}else if( D == AR+BR ){\n\t\treturn 3;\n\t}else if( abs(AR-BR) < D  ){//&& D<AR+BR\n\t\treturn 2;\n\t}else if(D == abs(AR-BR)){\n\t\treturn 1;\n\t}else if(D+AR < BR || D+BR<AR){\n\t\treturn 0;\n\t}\n\treturn 0;//\n}\n#pragma endregion //円と円の位置関係\n#pragma region CGL\nvector<Point> CircleLine(Point C,double CR,Point A,Point B){\n\tvector<Point> ans(2);//同じ交点なら同じ値\n\tdouble a,b,c;\n\ta = -(A.y-B.y);\n\tb = A.x-B.x;\n\tc = -(a*A.x+b*A.y);\n\n\tdouble l,k,d;\n\tl = a*a+b*b;\n\tk = a*C.x + b*C.y+ c;\n\td = l*CR*CR-k*k;\n\tif(d>0){\n\t\tdouble ds = sqrt(d);\n\t\tdouble apl = a/l;\n\t\tdouble bpl = b/l;\n\t\tdouble xc = C.x-apl*k;\n\t\tdouble yc = C.y-bpl*k;\n\t\tdouble xd = bpl*ds;\n\t\tdouble yd = apl*ds;\n\t\tPoint temp;\n\t\tans[0].x = xc-xd;\n\t\tans[0].y = yc+yd;\n\t\tans[1].x = xc+xd;\n\t\tans[1].y = yc-yd;\n\t}else if(d==0){\n\t\tPoint temp;\n\t\ttemp.x = C.x-a*k/l;\n\t\ttemp.y = C.y-b*k/l;\n\t\tans[0] = temp;\n\t\tans[1] = temp;\n\t}else{\n\t\tPoint temp;\n\t\ttemp.x = INF;\n\t\ttemp.y = INF;\n\t\tans[0] = temp;\n\t\tans[1] = temp;\n\t}\n\treturn ans;\n}\n#pragma endregion //円と直線の交点,距離チェックする。\n#pragma region CGL\n//http://shogo82148.github.io/homepage/memo/geometry/circle-cross.html\nvector<Point> circle_cross(Point A,double RA,Point B,double RB){\n\tPoint C = B-A;\n\tdouble CC = C.dot(C);\n\tdouble ter = (CC+RA*RA-RB*RB)/2;\n\tdouble D = CC * RA * RA - ter * ter;\n\tD = sqrt(D);\n\t\n\tvector<Point> ans(2);\n\tans[0].x = (ter*C.x+C.y*D)/CC;\n\tans[0].y = (ter*C.y-C.x*D)/CC;\n\tans[1].x = (ter*C.x-C.y*D)/CC;\n\tans[1].y = (ter*C.y+C.x*D)/CC;\n\tans[0] += A;\n\tans[1] += A;\n\tif( ans[0] == ans[1] ){\n\t\tans.resize(1);\n\t\treturn ans;\n\t}\n\tif( ans[0] > ans[1] ){\n\t\tswap( ans[0],ans[1] );\n\t}\n\treturn ans;\n}\n#pragma endregion //円と円の交点チェック。\n#pragma region DSL\nclass UnionFind{\npublic:\n\tint cNum;//要素数\n\tvector<int> parent;\n\tvector<int> count;\n\tvector< vector<int> > GList;\n\tUnionFind(int n){\n\t\tcNum = n;\n\t\tparent = vector<int>(n);\n\t\tcount = vector<int>(n,1);\n\t\tGList.resize(n);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tparent[i] = i;\n\t\t\tGList[i].push_back(i);\n\t\t}\n\t}\n\tint find(int x){\n\t\tif( parent[x] == x ){return x;}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\tbool same(int x,int y){return find(x) == find(y);}\n\tint Count(int x){return count[find(x)];}\n\tvoid add(int x,int y){//union\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif( x==y )return;\n\t\tparent[x] = y;\n\t\t\n\t\tcount[y] += count[x];\n\t\tif( GList[y].size() < GList[x].size() ){\n\t\t\tswap(GList[x],GList[y]);\n\t\t}\n\t\tGList[y].insert( GList[y].end(),\n\t\t\tGList[x].begin(),GList[x].end() );\n\t}\n};\n\n#pragma endregion //UnionFind\n#pragma region DSL\nclass segment{\n};\n#pragma endregion //segment tree\n#pragma region DSL\nclass BITree{//1-index\n\tint N;\n\tvector<LL> bit;\npublic:\n\tBITree(int n){\n\t\tN = n;\n\t\tbit = vector<LL>(N+1,0);//1-index\n\t}\n\tvoid add(int a,LL w){//aにwを足す\n\t\tif( a <= 0 || N < a) return;//a:[1,N]\n\t\tfor(int i=a;i<=N;i += i & -i){\n\t\t\tbit[i] += w;\n\t\t}\n\t}\n\tLL sum(int a){//[1,a]の和,a:[1,N]\n\t\t/*\n\t\t1番目からa番目までの和、1-index\n\t\t*/\n\t\tLL ret = 0;\n\t\tif( a > N ) a = N;\n\t\tfor(int i=a; i > 0; i -= i & -i){\n\t\t\tret += bit[i];\n\t\t}\n\t\treturn ret;\n\t}\n};\n#pragma endregion //BIndexTree\n\n#pragma region \ntemplate<class T,class U>\nistream& operator>>(istream& in,pair<T,U>& P){\n\tin >> P.first >> P.second;\n\treturn in;\n}\n#pragma endregion //cin pair<T,U>\n#pragma region \ntemplate<class T>\nistream& operator>>(istream& in,vector<T>& v){\n\tint size = v.size();\n\tfor(int i=0;i<size;++i){\n\t\tin >> v[i];\n\t}\n\treturn in;\n}\n#pragma endregion //cin vector<int>\n#pragma region \n//行列の積\nnamespace mymat{\n\tLL matMOD = MOD;//初期値10^9 + 7\n};\ntemplate<class T>\nvector< vector<T> > operator*( vector<vector<T> >& A,vector< vector<T> >& B){\n\tLL mod = mymat::matMOD;\n\tint R = A.size();\n\tint cen = A[0].size();\n\tint C = B[0].size();\n\tvector< vector<T> > ans(R,vector<T>(C,0) );\n\tfor(int row=0;row<R;++row){\n\t\tfor(int col=0;col<C;++col){\n\t\t\tfor(int inner=0;inner< cen;++inner){\n\t\t\t\tans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t\t//ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col]);\n\t\t\t\tans[row][col] = (ans[row][col] + mod) % mod;\n\t\t\t\t//負になるときの処理\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\ntemplate<class T>\nvector< vector<T> > powMod(vector< vector<T> > mat,LL N,LL mod=MOD){\n\tmymat::matMOD = mod;\n\tint R = mat.size();\n\tint C = mat[0].size();\n\t//R==C\n\tvector< vector<T> > I(R,vector<T>(C,0));//単位元\n\tfor(int i=0;i<R && i<C;++i){\n\t\tI[i][i] = 1;\n\t}\n\tif( N == 0 ){\n\t\treturn I;\n\t}\n\tvector< vector<T> > mul(R,vector<T>(C)),ans(R,vector<T>(C));\n\tans = I;\n\tmul = mat;\n\twhile(N){\n\t\tif( N & 1 ){\n\t\t\tans = ans*mul;\n\t\t}\n\t\tN >>= 1;\n\t\tmul = mul*mul;\n\t}\n\treturn ans;\n}\n#pragma endregion //行列\n\n#pragma region\nnamespace TIME{\ntime_t start,limit;\nvoid time_start(){start = time(NULL);}\nvoid time_set(int num){limit = num;}//秒\nbool check(){return (time(NULL)-start < limit);}\n}\n#pragma endregion //時間計測\n\n#pragma region\n/*\nnamespace RAND{\nmt19937 mt;\nvoid rand_init(){\n\trandom_device rnd;\n\tmt = mt19937(rnd());\n}\nint rand(){\n\treturn mt();\n}\n}\n*/\n#pragma endregion //乱数\n\n#pragma region\n#pragma endregion //\n\n//////////////////\ntemplate <typename T>\nclass segment_base{\n\tint N;//要素数\n\tvector< T > dat1;\n\tT VAL_E;//初期値\npublic:\n\tsegment_base(){};\n\tsegment_base(int n,T val_E ):N(n),VAL_E(val_E){\n\t\tdat1.resize(2*n);\n\t\tdat1.assign(2*n,val_E);//初期化\n\t}\n\tvoid init(int n,T val_E){\n\t\tN = n;\n\t\tVAL_E = val_E;\n\t\tdat1.resize(2*n);\n\t\tdat1.assign(2*n,val_E);\n\t}\n\tT SELECT(T L,T R){//扱う演算子\n\t\tT ans;\n\t\tans = min(L,R);//\n\t\treturn ans;\n\t}\n\n\t//index番目の値をvalに変更,indexは\"0-index\"\n\tvoid update(int index,T val){\n\t\tfor(dat1[index+=N] = val;index>1;index>>=1){\n\t\t\tdat1[index>>1] = SELECT(dat1[index],dat1[index^1]);//index+0,+1\n\t\t}\n\t}\n\n\t//区間[L,R)のSELECT\n\tT query(int L,int R){\n\t\tT ans = VAL_E;//\n\t\tfor(L+=N,R+=N; L<R;L>>=1,R>>=1){\n\t\t\tif(L&1) ans = SELECT(ans,dat1[L++]);\n\t\t\tif(R&1) ans = SELECT(ans,dat1[--R]);\n\t\t}\n\t\treturn ans;\n\t}\n};\n//////////////////\n/*\nthx\nhttp://www.kupc.jp/editorial/2016/E.pdf\n*/\nint H,W;\nint nodeNo(int h,int w){\n\treturn h*W+w;\n}\nvoid solve(){\n\tcin >> H >> W;\n\tconst int in = 0;\n\tconst int out = H*W;\n\tconst int S = out*2;\n\tconst int T = S+1;\n\n\tFLOW::Graph gra;\n\tgra.init(H*W*2 + 2);//各マスのin,outとS,T\n\n\tint dh[] = {-1,0,0,1};\n\tint dw[] = {0,-1,1,0};\n\tfor(int h=0;h<H;++h){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int w=0;w<W;++w){\n\t\t\tint IN = nodeNo(h,w) + in;\n\t\t\tint OUT = nodeNo(h,w) + out;\n\t\t\t\n\t\t\tif( str[w] == 'X' ){\n\t\t\t\tif( h == 0 || h == H-1 || w==0 || w==W-1 ){\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tgra.add_edge(IN,OUT,INF);//Xが隣接\n\t\t\t\tgra.add_edge(S,OUT,INF);\n\t\t\t}else{//ヤギがいない\n\t\t\t\tgra.add_edge(IN,OUT,1);//柵\n\t\t\t}\n\n\t\t\t//今のOUTから隣接inへINF\n\t\t\tbool flag = false;\n\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\tint hh = h+dh[k];\n\t\t\t\tint ww = w+dw[k];\n\t\t\t\tif( hh<0 || H<=hh || ww<0 || W<=ww ){\n\t\t\t\t\tif( flag == false ){\n\t\t\t\t\t\tgra.add_edge(OUT,T,INF);\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tgra.add_edge(OUT, nodeNo(hh,ww)+in, INF);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << gra.max_flow(S,T) << endl;\n}\n\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve();\n}\n#pragma endregion //main()"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cmath>\n#include <iostream>\n#include <queue>\n#include <list>\n#include <stack>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define FOR(it,c) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define ALLOF(c) (c).begin(), (c).end()\ntypedef long long ll;\n \nstring field[105];\nstring g[105];\n \nint vx[4] = {-1,1,0,0};\nint vy[4] = {0,0,-1,1};\n \nint main(){\n  ios::sync_with_stdio(false);\n  int H, W;\n  cin >> H >> W;\n  string out(W+2, '.');\n  field[0] = out;\n  g[0] = field[0];\n  field[H+1] = out;\n  g[H+1] = field[H+1];\n  REP(i,1,H+1){\n    string tmp;\n    cin >> tmp;\n    field[i] = \".\" + tmp + \".\";\n    g[i] = field[i];\n  }\n \n  rep(i,H+2){\n    rep(j,W+2){\n      if(field[i][j] == 'X'){\n        rep(k,4){\n          int nx = j + vx[k];\n          int ny = i + vy[k];\n          if(1<=nx && nx<=W && 1<=ny && ny<=H){\n            g[ny][nx] = '*';\n          }else{\n            cout << -1 << endl;\n            return 0;\n          }\n        }\n      }\n    }\n  }\n \n  queue< pair<int,int> > que;\n  que.push(make_pair(0,0));\n  while(!que.empty()){\n    pair<int,int> p = que.front(); que.pop();\n    if(g[p.first][p.second] != '.') continue;\n    g[p.first][p.second] = '#';\n    rep(k,4){\n      int nx = p.second + vx[k];\n      int ny = p.first + vy[k];\n      if(0<=nx && nx<W+2 && 0<=ny && ny<H+2){\n        if(g[ny][nx] == '.'){\n          que.push(make_pair(ny,nx));\n        }\n      }\n    }\n  }\n \n  int ret = 0;\n  rep(i,H+2){\n    rep(j,W+2){\n      if(g[i][j] == '*'){\n        bool flg = false;\n        rep(k,4){\n          int nx = j + vx[k];\n          int ny = i + vy[k];\n          if(0<=nx && nx<W+2 && 0<=ny && ny<H+2){\n            if(g[ny][nx] == '#') flg = true;\n          }\n        }\n        if(flg) ret++;\n      }\n    }\n  }\n \n  cout << min(2*(H-2)+2*(W-2), ret) << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nchar map[101][101];\nint r,c;\nint cekatas(int X, int y){\n\tfor(int i = 0;i<y;i++){\n\t\tif(map[i][X] == 'X'){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint cekbwh(int X, int y){\n\tfor(int i = r-1;i>y;i--){\n\t\tif(map[i][X] == 'X'){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint cekkiri(int X, int y){\n\tfor(int i = 0;i<X;i++){\n\t\tif(map[y][i] == 'X'){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint cekkanan(int X, int y){\n\tfor(int i = c-1 ;i>X;i--){\n\t\tif(map[y][i] == 'X'){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&r,&c);\n\tfor(int y = 0;y<r;y++){\n\t\tfor(int X = 0;X<c;X++){\n//\t\t\tscanf(\"%c\",&map[y][X]);\n\t\t\tcin>>map[y][X];\n\t\t}\n\t}\n\t//scan pinggir\n\t\n\tfor(int y = 0;y<r;y++){\n\t\tfor(int X = 0;X<c;X++){\n\t\t\tif(X == c-1 || y == 0 || X == 0 || y == r-1){\n\t\t\t\tif(map[y][X] == 'X'){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint p = 0;\n\tfor(int y = 0;y<r;y++){\n\t\tfor(int X = 0;X<c;X++){\n\t\t\tif(map[y][X] == 'X'){\n\t\t\t\t//cek atas\n\t\t\t\tif(!cekatas(X,y) && (map[y-1][X]!='.' || map[y-1][X]!='-')){\n\t\t\t\t\t//gaada X lain diatas\n\t\t\t\t\t//pagar\n\t\t\t\t\tmap[y-1][X] = '+';\n\t\t\t\t}else if( map[y-1][X]=='.'){\n\t\t\t\t\tmap[y-1][X] = '-';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//cek kanan\n\t\t\t\tif(!cekkanan(X,y)&& (map[y][X+1]!='.' || map[y][X+1]!='-')){\n\t\t\t\t\t//gaada X lain\n\t\t\t\t\t//pagar\n\t\t\t\t\tmap[y][X+1] = '+';\n\t\t\t\t}else if( map[y][X+1]=='.'){\n\t\t\t\t\tmap[y][X+1] = '-';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!cekkiri(X,y)&& (map[y][X-1]!='.' || map[y][X-1]!='-')){\n\t\t\t\t\t//gaada X lain\n\t\t\t\t\t//pagar\n\t\t\t\t\tmap[y][X-1] = '+';\n\t\t\t\t}else if(map[y][X-1]=='.'){\n\t\t\t\t\tmap[y][X-1] = '-';\n\t\t\t\t}\n\t\t\t\t//cek bawah\n\t\t\t\tif(!cekbwh(X,y)&& (map[y+1][X]!='.' || map[y+1][X]!='-')){\n\t\t\t\t\t//gaada X lain\n\t\t\t\t\t//pagar\n\t\t\t\t\tmap[y+1][X] = '+';\n\t\t\t\t}else if( map[y+1][X]=='.'){\n\t\t\t\t\tmap[y+1][X] = '-';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int y = 0;y<r;y++){\n\t\tfor(int X = 0;X<c;X++){\n\t\t\tif(map[y][X] == '+')p++;\n\t\t\t//cout<<map[y][X];\n\t\t}//cout<<\"\\n\";\n\t}\n\t\n\tprintf(\"%d\\n\",p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*? begin \"base.hpp\" */\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve( /* この関数に問題ごとの処理を書く */\n#ifdef GCJ_CASE\n long long case_id\n#endif\n);\n\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n #define debug true\n#else\n #define NDEBUG \n #define debug false\n#endif\n#include<algorithm>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<type_traits>\n#include<vector>\n#ifdef __cpp_lib_execution\n  #include<execution>\n#endif\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL \n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define times(n,i) uptil(0,n,i)\n#define rtimes(n,i) downto((n)-1,0,i)\n#define upto(f,t,i) for(int rabT##i=(t),i=(f);i<=rabT##i;i++)\n#define uptil(f,t,i) for(int rabT##i=(t),i=(f);i< rabT##i;i++)\n#define downto(f,t,i) for(int rabT##i=(t),i=(f);i>=rabT##i;i--)\n#define downtil(f,t,i) for(int rabT##i=(t),i=(f);i> rabT##i;i--)\n#define iter(v) begin(v),end(v)\n#define citer(v) cbegin(v),cend(v)\n#define riter(v) rbegin(v),rend(v)\n#define criter(v) crbegin(v),crend(v)\n#define IF(a,b,c) ((a)?(b):(c))\n#define BINOP_ASGN(t,u,op) t operator op(CS u&o)CS{RT t(*this)op##=o;}\n#if debug\n #define _GLIBCXX_DEBUG\n #define _LIBCPP_DEBUG 2\n #define _LIBCPP_DEBUG2 2\n #define ln <<endl\n#else\n #define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n #define PARABLE \n/*? begin \"mod.hpp\" */\n#ifdef MOD\n #if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n  #error unknown mod MOD and FORCE_MOD not defined.\n #endif\n#else\n #define MOD 1000000007\n#endif\n/*? begin \"power.hpp\" */\nusing int128=__int128;\nTL<TN T>T power(T x,int n){T rt(1);for(;n;n/=2){if(n%2)rt*=x;x*=x;}RT rt;}\nint pow_mod(int x,int n,int m){int rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\nint128 pow_mod_64(int128 x,int n,int m){int128 rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\n/*? end \"power.hpp\" */\nIL CX int modulo(int a,int m){RT(a%=m,a>=0?a:a+m);}\nTL<ULL mod=MOD>class MInt{\n  /*! https://ei1333.github.io/luzhiled/snippets/other/mod-int.html */\npublic:\n  int val;\n  CX MInt():val(0){}\n  explicit CX MInt(int v):val(modulo(v,mod)){}\n  MInt&operator+=(CS MInt&m){val+=m.val;if(val>=mod)val-=mod;RT*this;}\n  MInt&operator-=(CS MInt&m){val-=m.val;if(val<0)val+=mod;RT*this;}\n  MInt&operator*=(CS MInt&m){val=val*m.val%mod;RT*this;}\n  MInt&operator/=(CS MInt&m){val=val*m.inv().val%mod;RT*this;}\n  BINOP_ASGN(MInt,MInt,+) BINOP_ASGN(MInt,MInt,-) BINOP_ASGN(MInt,MInt,*) BINOP_ASGN(MInt,MInt,/)\n  MInt operator-()CS{MInt m;m.val=val?mod-val:0;RT m;}\n  bool operator==(CS MInt&m)CS{RT val==m.val;}\n  bool operator!=(CS MInt&m)CS{RT val!=m.val;}\n  //MInt pow(int n)CS{MInt x(*this),rt(1);while(n){if(n%2)rt*=x;x*=x;n/=2;}RT rt;}\n  MInt pow(int n)CS{RT power(*this,n);}\n  MInt inv()CS{int a=val,b=mod,x=1,y=0,t;while(b){t=a/b;swap(b,a-=t*b);swap(y,x-=t*y);}RT(MInt)x;}\n  friend ostream&operator<<(ostream&o,CS MInt<mod>&m){RT o<<m.val;}\n  friend istream&operator>>(istream&i,MInt<mod>&m){int v;i>>v;m=MInt<mod>(v);RT i;}\n};\nusing mint=MInt<>;\n\nconstexpr mint operator\"\" _m(ULL n){RT mint(n);}\nconstexpr MInt<998244353>operator\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nconstexpr MInt<1000000007>operator\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nconstexpr MInt<1000000009>operator\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n\n//#pragma rab:gsub \\b(\\d+)m\\b mint(\\1)\n/*? end \"mod.hpp\" */\n/*? begin \"typedefs.hpp\" */\nstruct unit{};\n\nusing int128=__int128;\nusing LD=long double;\nTL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;\nTL<TN T>using vvvec=vec<vvec<T>>;\nTL<TN T>using vvvvec=vec<vvvec<T>>;\n\n//#pragma rab typedefs.dynamic\nusing WI = vvec<int>; using VI = vec<int>; using VC = vec<char>; using HII = map<int, int>; using VS = vec<string>; \n/*? end \"typedefs.hpp\" */\n/*? begin \"alias.hpp\" */\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n/*? end \"alias.hpp\" */\n/*? begin \"util.hpp\" */\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,true);}\nTL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,true);}\n\n#ifndef __cpp_lib_exchange_function\n #define exchange exchange_RAB\n TL<TN T,TN U=T>IL T exchange(T& t, U&& u){T x=move(t);t=forward<U>(u);RT x;}\n#endif\n#ifndef __cpp_lib_clamp\n #define clamp clamp_RAB\n TL<TN T>IL CX CS T&clamp(CS T&a,CS T&mn,CS T&mx){RT a<mn?mn:a>mx?mx:a;}\n#endif\n\nTL<TN T>IL int size_RAB(T t){RT t.size();}\n#define size size_RAB\n\nTL<TN V>IL void uniq_after_sort(V&v){v.erase(unique(iter(v)),v.end());}\nTL<TN V>IL void sort_and_uniq(V&v){sort(iter(v));v.erase(unique(iter(v)),v.end());}\nTL<TN V,TN K>IL auto leftmost_ge(CS V&v,CS K&k){RT v.lower_bound(k);}\nTL<TN V,TN K>IL auto leftmost_gt(CS V&v,CS K&k){RT v.upper_bound(k);}\n\nnamespace rab{\n\nTL<TN V,TN W>IL void append(V&v,CS W&w){copy(PARABLE citer(w),back_inserter(v));}\n\nTL<TN V>IL auto flatten(CS V&xss,int reserve_size=0)->TN V::value_type{\n  decltype(flatten(xss))ret;\n  ret.reserve(reserve_size);\n  for(CS auto&xs:xss)append(ret,xs);\n  ret.shrink_to_fit();\n  RT move(ret);\n}\n\nTL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}\n\nTL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){RT 0<=i&&i<size(v)?v[i]:d;}\nTL<TN T>IL T fetch(CS T&d,CS vvec<T>&v,int i,int j){\n  RT 0<=i&&i<size(v)&&0<=j&&j<size(v[i])?v[i][j]:d;\n}\n// TL<TN T,TN U,TN...I>IL T fetch(CS T&d,CS vec<vec<U>>&v,int i,I...j){\n// RT 0<=i&&i<size(v)?fetch(d,v[i],j...):d;\n// }\nTL<TN T>struct Compressed{int size;map<T,int>zip;vec<T>unzip;};\nTL<TN T>IL Compressed<T>compressed(vec<T>v){\n  sort_and_uniq(v);map<T,int>zip;times(size(v),i)zip[v[i]]=i;RT{size(v),zip,move(v)};\n}\nTL<TN T>struct CompressedSrc{int size;map<T,int>zip;vec<T>unzip;WI src;};\nTL<TN T>IL CompressedSrc<T>compressed_src(CS vec<T>&v){\n  auto c=compressed(v);VI src(c.size);times(size(v),i)src[c.zip[v[i]]].PB(i);RT{c.size,c.zip,c.unzip,src};\n}\n\nstruct identity{TL<TN U>U operator()(U&&v)CS{RT v;}};\n}\n/*? end \"util.hpp\" */\n/*? begin \"debug.hpp\" */\nTL<class T>\nIL istream&operator>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nTL<class T>\nIL ostream&operator<<(ostream&,CS vec<T>&);\nTL<class T,class S>\nIL ostream&operator<<(ostream&,CS map<T,S>&);\n#define DEFINE_ITER_OUTPUT(s,x,sep){int i=0;for(CS auto&x##0_elem:x){if(i++)s<<sep;s<<x##0_elem;}RT s;}\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<T>&v)DEFINE_ITER_OUTPUT(s,v,' ')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS map<T,S>&m)DEFINE_ITER_OUTPUT(s,m,' ')\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<vec<T>>&w)DEFINE_ITER_OUTPUT(s,w,'\\n')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS vec<map<T,S>>&v)DEFINE_ITER_OUTPUT(s,v,'\\n')\n/*? end \"debug.hpp\" */\n\nsigned main(){\n {if(debug)cerr<<\"MOD: \"<<(MOD)ln;}\n if(!debug)cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\n cout<<fixed<<setprecision(20);\n cerr<<fixed<<setprecision(20);\n\n #ifdef GCJ_CASE\n  int T;cin>>T;\n  times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n #else\n  solve();\n #endif\n\n return 0;\n}\n/*? end \"base.hpp\" */\n/*? begin \"graph.hpp\" */\n/*? begin \"uf.hpp\" */\nTL<class T=int,class Adder=plus<T>,class Inverser=negate<T>>\nclass UnionFind{\n/*!\nhttp://noshi91.hatenablog.com/entry/2018/05/30/191943\nhttps://en.wikipedia.org/wiki/Disjoint-set_data_structure\nhttps://qiita.com/drken/items/cce6fc5c579051e64fab\n*/\nint n,*parents,*sizes;T*pot_diffs;bool to_delete;Adder adder;\nInverser inverser;\npublic:\nexplicit UnionFind(int n,bool to_delete=false):\nn(n),parents(new int[n]),sizes(new int[n]),pot_diffs(new T[n]),to_delete(to_delete)\n{clear();\n}\nvoid clear(){\ntimes(n,i)parents[i]=i;/*roots*/\nfill(sizes,sizes+n,1);fill(pot_diffs,pot_diffs+n,0);\n}\n~UnionFind(){if(to_delete){delete[]parents;delete[]sizes;delete[]pot_diffs;}}\nint size(){RT n;}\nint root(int i){int p=parents[i];\nif(p==i)RT i;/*`i`is a root*/\nint r=root(p);/*and pot_diffs[p]:=diff from root*/\npot_diffs[i]+=pot_diffs[p];parents[i]=r;RT r;\n}\nbool is_same(int i,int j){RT root(i)==root(j);}\nbool is_all_same(){int r=root(0);uptil(1,n,i)if(root(i)!=r)RT 0;RT 1;}\nbool merge(int i,int j,T pdiff=0){i=root(i);j=root(j);\nif(i==j)RT false;/*already merged*/\nif(sizes[i]>sizes[j]){swap(i,j);pdiff=inverser(pdiff);\n}\n/*now sizes[i]<=sizes[j]*/\nparents[i]=j;sizes[j]+=sizes[i];pot_diffs[i]=pdiff;RT true;\n}\nT diff(int i,int j){\nroot(i);/*pot_diffs[i]:=diff from root*/\nroot(j);/*pot_diffs[j]:=diff from root*/\nRT adder(pot_diffs[i],inverser(pot_diffs[j]));}};using unionfind=UnionFind<>;\n/*? end \"uf.hpp\" */\nTL<class EdgeVal>\nstruct Edge{int from;int to;EdgeVal weight;\nEdge(int from,int to,EdgeVal weight):from(from),to(to),weight(weight){}\nIL bool OP==(CS Edge&e)CS{RT weight==e.weight&&from==e.from&&to==e.to;}\nIL bool OP<(CS Edge&e)CS{RT weight<e.weight||(weight==e.weight&&(from<e.from||(from==e.from&&to<e.to)));}\nIL bool OP<=(CS Edge&e)CS{RT this==e||this<e;}\nIL bool OP>(CS Edge&e)CS{RT e<this;}\nIL bool OP>=(CS Edge&e)CS{RT e<=this;}};\nTL<class VtxVal,class EdgeVal>\nclass Graph{\nusing VoidWithoutEdgeVal=TN enable_if<is_default_constructible<EdgeVal>::value,void>::type;\nprotected:\nint nv_,nde_;unionfind uf;\npublic:\nvec<VtxVal>vs;vvec<Edge<EdgeVal>>edges;\nGraph(int nv):nv_(nv),nde_(0),uf(nv),vs(nv),edges(nv){}\nIL int nv()CS{RT nv_;}\nIL int nde()CS{RT nde_;}\nIL int nue()CS{RT nde_/2;}\nIL void add_dedge(int i,int j,CS EdgeVal&val){\nif(!rab::is_in(i,0LL,nv_)||!rab::is_in(j,0LL,nv_)){\ncerr<<\"invalid index:(\"<<i<<\",\"<<j<<\")for Graph(nv=\"<<nv_<<\")\" ln;\nexit(1);\n}\nedges[i].emplace_back(i,j,val);++nde_;\n}\nIL VoidWithoutEdgeVal add_dedge(int i,int j){add_dedge(i,j,EdgeVal());\n}\nIL void add_uedge(int i,int j,CS EdgeVal&val){add_dedge(i,j,val);\nadd_dedge(j,i,val);\n}\nIL VoidWithoutEdgeVal add_uedge(int i,int j){add_uedge(i,j,EdgeVal());\n}\nIL bool is_connected(){uf.clear();\nfor(CS auto&es:edges)for(CS auto&e:es)uf.merge(e.from,e.to);RT uf.is_all_same();\n}};\n/*? end \"graph.hpp\" */\n/*? begin \"flow.hpp\" */\n/*!Arihon,https://tubo28.me/algorithm/dinic/*/\nTL<TN F,TN V,TN E,TN CapFn=rab::identity>\n/*F:通常int,CapFn:E->F*/\nstruct dinic{int n,s,t;VI level,prog,que;\nWI edges;/*both direction*/\nvvec<F>cap,flow;\ndinic(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),level(n),prog(n),que(n+1),edges(n),cap(n,VI(n)),flow(n,VI(n))\n{times(n,i){for(auto&e:g.edges[i]){F c=capfn(e.weight);\ncap[i][e.to]+=c;cap[e.to][i]+=c;flow[e.to][i]+=c;edges[i].PB(e.to);\nedges[e.to].PB(i);\n}}}\nF exec(int s,int t){this->s=s;this->t=t;F mf=0;\nwhile(update_level(),level[t]>0){fill(iter(prog),0);mf+=find_paths(s,numeric_limits<F>::max()/8/*inf*/);\n}\nRT mf;\n}\nvoid update_level(){int ql=0,qr=0;fill(iter(level),-1);level[s]=0;\nque[qr++]=s;while(ql!=qr/*queue is not empty*/){int v=que[ql++];\nif(v==t)break;\nfor(int d:edges[v]){if(level[d]<0&&cap[v][d]!=flow[v][d]){level[d]=level[v]+1;\nque[qr++]=d;\n}}}}\nF find_paths(int v,int limit){if(v==t)RT limit;F diff=0;\nfor(;prog[v]<size(edges[v]);++prog[v]){int d=edges[v][prog[v]];\nif(cap[v][d]!=flow[v][d]&&level[v]<level[d]){F df=find_paths(d,min(limit,cap[v][d]-flow[v][d]));\nflow[v][d]+=df;flow[d][v]-=df;diff+=df;limit-=df;if(limit==0)break;\n}}\nRT diff;}};\n/*!Arihon,https://tubo28.me/algorithm/ford-fulkerson/*/\nTL<TN V,TN E,TN CapFn=rab::identity>\nstruct ford_fulkerson{int n,s,t;VC visited;\nWI edges;/*both direction*/\nprivate:\nHII cap_,flow_;\npublic:\nford_fulkerson(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),visited(n),edges(n)\n{times(n,i){for(auto&e:g.edges[i]){int c=capfn(e.weight);\ncap_[i<<32|e.to]+=c;cap_[e.to<<32|i]+=c;flow_[e.to<<32|i]+=c;edges[i].PB(e.to);\nedges[e.to].PB(i);\n}}}\nint cap(int a,int b){RT cap_[a<<32|b];}\nint flow(int a,int b){RT flow_[a<<32|b];}\nint exec(int s,int t){this->s=s;this->t=t;int mf=0;\nwhile(1){fill(iter(visited),false);int df=find_path(s,LLONG_MAX/8/*inf*/);if(df==0)RT mf;\nmf+=df;\n}}\nint find_path(int v,int limit){visited[v]=true;if(v==t)RT limit;\nfor(int d:edges[v]){if(!visited[d]){int c=cap_[v<<32|d],&f=flow_[v<<32|d];\nif(c-f>0){int df=find_path(d,min(limit,c-f));if(df>0){f+=df;flow_[d<<32|v]-=df;RT df;\n}}}}\nRT 0;}};\n/*? end \"flow.hpp\" */\nconstexpr int INF = 401;\n\nvoid solve() {\n// HWH(\"S\")\n/* <foxy.memo-area> */\nint H;int W;cin>>H;cin>>W;VS S(H);times(H,Ri_0){cin>>S[Ri_0];}\n/* </foxy.memo-area> */\n\n  Graph<unit, int> g(H * W * 2 + 2);\n\n  int s = H * W * 2, t = H * W * 2 + 1;\n\n  #define inp(i, j) (((i) * W + (j)) * 2)\n  #define outp(i, j) (((i) * W + (j)) * 2 + 1)\n\n  times(H, i) times(W, j) {\n    g.add_dedge(inp(i, j), outp(i, j), 1);\n\n    if(S[i][j] == 'X') {\n      g.add_dedge(s, outp(i, j), INF);\n\n      if(i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n        cout << -1 ln;\n        return;\n      }\n    }\n  }\n\n  times(H, i) {\n    g.add_dedge(outp(i, 0), t, INF);\n    g.add_dedge(outp(i, W-1), t, INF);\n\n    times(W-1, j) {\n      g.add_dedge(outp(i, j), inp(i, j + 1), INF);\n      g.add_dedge(outp(i, j + 1), inp(i, j), INF);\n    }\n  }\n  times(W, j) {\n    g.add_dedge(outp(0, j), t, INF);\n    g.add_dedge(outp(H-1, j), t, INF);\n\n    times(H-1, i) {\n      g.add_dedge(outp(i, j), inp(i + 1, j), INF);\n      g.add_dedge(outp(i + 1, j), inp(i, j), INF);\n    }\n  }\n\n  ford_fulkerson<unit, int> d(g);\n  cout << d.exec(s, t) ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<ut,VI> PQ;\nconst ut INF=1LL<<30;\nconst int SIZE=201;\nint maps[SIZE][SIZE];\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\ncli d[4];\nbool searched[SIZE][SIZE][3];\nint solve(){\n\tREP(i,4) d[i]=cli(dy[i],dx[i]);\n\tint H,W;\n\tcin >> H >> W;\n\tqueue<cli> qu;\n\tREP(i,H){\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,W){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(maps[i][j]) qu.push(cli(j,i));\n\t\t}\n\t}\n\tint count=0;\n\twhile(!qu.empty()){\n\t\tcli now=qu.front();\n\t\tqu.pop();\n\t\t\n\t\t//if(maps[now.imag()][now.real()]==1) count++;\n\t\t//if(count==1e7) return -1;\n\t\tif(maps[now.imag()][now.real()]==1){\n\t\t\t\n\t\t\tif(searched[now.imag()][now.real()][0]) continue;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) return -1;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=1){\n\t\t\t\t\tqu.push(next);\n\t\t\t\t\tmaps[next.imag()][next.real()]=-1;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t//\tcout << next << endl;\n\t\t\t}\n\t\t\tsearched[now.imag()][now.real()][0]=true;\n\t\t}\n\t\telse if(maps[now.imag()][now.real()]==-1){\n\t\t\tint around=0;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) continue;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=0) around++;\n\t\t\t\tif(!searched[now.imag()][now.real()][1]) if(maps[next.imag()][next.real()]!=1) qu.push(next);\n\t\t\t}\n\t\t\tsearched[now.imag()][now.real()][1]=true;\n\t\t\tif(around>=3){\n\t\t\t\tmaps[now.imag()][now.real()]=1;\n\t\t\t\tqu.push(now);\n\t\t\t}\n\t\t} \n\t\telse if(maps[now.imag()][now.real()]==0){\n\t\t\tint around=0;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) continue;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=0) around++;\n\t\t\t}\n\t\t\tif(around>=4){\n\t\t\t\tmaps[now.imag()][now.real()]=1;\n\t\t\t\tqu.push(now);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t//cout << count << endl;\n\tint ans=0;\n\tREP(i,H){\n\t\tREP(j,W)\n\t\t\tans+=maps[i][j]==-1;\n\t}\n\treturn ans;\n}\nint main(){\n\tcout << solve() << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\n#define MAX_V 20010\n#define INF 1e9\n\nstruct edge{\n    int to, cap, rev;\n};\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, (int)G[from].size()-1});\n}\n\nint dfs(int v, int t, int f){\n    if (v==t) return f;\n    used[v] = 1;\n    REP(i,G[v].size()){\n        edge &e = G[v][i];\n        if (!used[e.to] && e.cap>0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d>0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if (f==0) return flow;\n        flow += f;\n    }\n}\n\nint dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};\nint start = 20001, goal = 20002;\n\nint main() {\n    int h, w;\n    cin >> h >> w;\n    int n = h*w;\n    vector<string> s(h);\n    REP(i,h) cin >> s[i];\n    REP(i,h) REP(j,w){\n        int ij = i*w+j;\n        REP(k,4){\n            int ii = i+dx[k], jj = j+dy[k];\n            if (ii<0 || jj<0 || ii>=h || jj>=w) continue;\n            add_edge(ij, ii*w+jj+n, INF);\n            add_edge(ii*w+jj, ij+n, INF);\n        }\n\n        if(i==0 || j==0 || i==h-1 || j==w-1){\n            if (s[i][j] == 'X'){\n                cout << -1 << endl;\n                return 0;\n            }\n            add_edge(ij, goal, INF);\n        }\n        if (s[i][j] == 'X') add_edge(start, ij, INF);\n        else add_edge(ij+n, ij, 1);\n    }\n\n    cout << max_flow(start, goal) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<ut,VI> PQ;\nclass UnionFind{\n \n\tvector<int> unions,talls,sents,dists,sizes;\n\tint size;\npublic:\n\tUnionFind(){}\n\tUnionFind(int size):size(size){\n\t\tinit();\n\t}\n\tvoid init(){\n\t \tunions=vector<int>(size);\n\t \ttalls=vector<int>(size);\n\t \tsents=vector<int>(size);\n\t \tdists=vector<int>(size);\n\t \tsizes=vector<int>(size);\n\t\tFOR(i,0,size){\n\t\t\tunions[i]=i;\n\t\t\tsents[i]=0;\n\t\t\tsizes[i]=1;\n//\t\t\tns[i].PB(pr(0,1));\n\t\t\ttalls[i]=1;\n\t\t}\n\t}\n\tint find(int x,int t=0){\n\t\tif(unions[x]==x || sents[x]>t) return x;\n\t\treturn find(unions[x],t);\n \n\t}\n\tint minisize(int x){\n\t\tif(x==unions[x]) return sizes[x];\n\t\treturn minisize(find(x));\n\t}\n\tbool isFriend(int a,int b,int t=0){\n\t\treturn find(a,t)==find(b,t);\t\n\t}\n\tvoid unite(int a,int b,int t=0){\n\t\tif(isFriend(a,b,t)) return;\n\t\ta=find(a,t);\n\t\tb=find(b,t);\n\t\tif(talls[a]<talls[b]) unite(b,a,t);\n\t\telse{\n \t\t\tsizes[a]+=sizes[b];\n\t\t\tsents[b]=t;\n\t\t\ttalls[a]=max(talls[a],talls[b]+1);\n\t\t\tunions[b]=a;\n\t\t\tdists[b]=1;\n//\t\t\tns[a].PB(pr(t,ns[b].back().second+ns[a].back().second));\n\t\t}\n\t}\n};\nUnionFind uf;\nconst ut INF=1LL<<30;\nconst int SIZE=201;\nint maps[SIZE][SIZE];\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\ncli d[4];\nbool searched[SIZE][SIZE][3];\nint H,W;\nint conv(cli x){\n\treturn x.real()*1000+x.imag()+10000;\n}\nint solve(){\n\tREP(i,4) d[i]=cli(dy[i],dx[i]);\n\t\n\tcin >> H >> W;\n\tqueue<cli> qu;\n\tREP(i,H){\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,W){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(i==0 or j==0 or i==H-1 or j==W-1) {\n\t\t\t\tif(maps[i][j]) return -1;\n\t\t\t\tmaps[i][j]=-1;\n\t\t\t\tqu.push(cli(j,i));\n\t\t\t}\n\t\t}\n\t}\n\twhile(!qu.empty()){\n\t\tcli now=qu.front();\n\t\tqu.pop();\n\t\t\n\t\t//if(maps[now.imag()][now.real()]==1) count++;\n\t\t//if(count==1e7) return -1;\n\t\tif(maps[now.imag()][now.real()]==-1){\n\t\t\tint around=0;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(next.imag()==-1 or next.real()==-1 or next.imag()==H or next.real()==W) continue;\n\t\t\t\tif(maps[next.imag()][next.real()]==1) around+=2;\n\t\t\t\tif(maps[next.imag()][next.real()]==0) around++; \n\t\t\t}\n\t\t\tif(around<=1){\n\t\t\t\tmaps[now.imag()][now.real()]=2;\n\t\t\t\tREP(i,4){\n\t\t\t\t\tcli next=now+d[i];\n\t\t\t\t\tif(next.imag()==-1 or next.real()==-1 or next.imag()==H or next.real()==W) continue;\n\t\t\t\t\tif(maps[next.imag()][next.real()]==0){\n\t\t\t\t\t\tmaps[next.imag()][next.real()]=-1;\n\t\t\t\t\t\tqu.push(next);\n\t\t\t\t\t} \n\t\t\t\t}\n\t\t\t}\n\t\t} \t\t\n\t}\n\tint ans=0;\n\tREP(i,H){\n\t\tREP(j,W){\n\t\t//\tcout << maps[i][j]+1;\n\t\t\tans+=maps[i][j]==-1;\n\t\t}\n\t//\tcout << endl;\n\t}\n\treturn ans;\n}\n\nint solve2(){\n\tuf=UnionFind(200000);\n\n\tqueue<cli> qu;\n\tREP(i,H){\n\t\tREP(j,W){\n\t\t\tmaps[i][j]=maps[i][j]==1;\n\t\t\tif(maps[i][j]) qu.push(cli(j,i));\n\t\t\tREP(k,3) searched[i][j][k]=false;\n\t\t}\n\n\t}\n\tqueueing:\n\twhile(!qu.empty()){\n\t\tcli now=qu.front();\n\t\tqu.pop();\n\t\t\n\t\t//if(maps[now.imag()][now.real()]==1) count++;\n\t\t//if(count==1e7) return -1;\n\t\tif(maps[now.imag()][now.real()]==1){\n\t\t\t\n\t\t\tif(searched[now.imag()][now.real()][0]) continue;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) return -1;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=1){\n\t\t\t\t\tqu.push(next);\n\t\t\t\t\tmaps[next.imag()][next.real()]=-1;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t//\tcout << next << endl;\n\t\t\t}\n\t\t\tsearched[now.imag()][now.real()][0]=true;\n\t\t}\n\t\telse if(maps[now.imag()][now.real()]==-1){\n\t\t\tint around=0;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) continue;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=0) around++;\n\t\t\t\tif(!searched[now.imag()][now.real()][1]) if(maps[next.imag()][next.real()]!=1) qu.push(next);\n\t\t\t}\n\t\t\tsearched[now.imag()][now.real()][1]=true;\n\t\t\tif(around>=3){\n\t\t\t\tmaps[now.imag()][now.real()]=1;\n\t\t\t\tqu.push(now);\n\t\t\t}\n\t\t} \n\t\telse if(maps[now.imag()][now.real()]==0){\n\t\t\tint around=0;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) continue;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=0) around++;\n\t\t\t}\n\t\t\tif(around>=4){\n\t\t\t\tmaps[now.imag()][now.real()]=1;\n\t\t\t\tqu.push(now);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tREP(i,H){\n\t\tREP(j,W){\n\t\t\tcli now=cli(j,i);\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1){\n\t\t\t\tuf.unite(conv(now),0);\n\t\t\t}\n\t\t\tREP(k,4){\n\t\t\t\tcli now=cli(j,i);\n\t\t\t\tcli next=now+d[k];\n\t\t\t\tif(maps[now.imag()][now.real()]==0 && maps[next.imag()][next.real()]==0) uf.unite(conv(now),conv(next));\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,H){\n\t\tREP(j,W){\n\t\t\tcli now=cli(j,i);\n\t\t\tif(uf.isFriend(conv(now),0)) continue;\n\t\t\tif(maps[now.imag()][now.real()]) continue;\n\t\t\tmaps[now.imag()][now.real()]=1;\n\t\t\tqu.push(now);\n\t\t}\n\t}\n\tif(!qu.empty()) goto queueing;\n\t//cout << count << endl;\n\tint ans=0;\n\tREP(i,H){\n\t\tREP(j,W){\n//\t\t\tcout << maps[i][j]+1;\n\t\t\tans+=maps[i][j]==-1;\n\t\t}\n//\t\tcout << endl;\n\t}\n\treturn ans;\n}\nint main(){\n\tint a=solve();\n\tif(a==-1){\n\t\tcout <<-1 << endl;\n\t\treturn 0;\n\t}\n\tint b=solve2();\n\tcout << min(a,b) << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cmath>\n#include <iostream>\n#include <queue>\n#include <list>\n#include <stack>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define FOR(it,c) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define ALLOF(c) (c).begin(), (c).end()\ntypedef long long ll;\n\nstring field[105];\nstring g[105];\n\nint vx[4] = {-1,1,0,0};\nint vy[4] = {0,0,-1,1};\n\nint main(){\n  ios::sync_with_stdio(false);\n  int H, W;\n  cin >> H >> W;\n  string out(W+2, '.');\n  field[0] = out;\n  g[0] = field[0];\n  field[H+1] = out;\n  g[H+1] = field[H+1];\n  REP(i,1,H+1){\n    string tmp;\n    cin >> tmp;\n    field[i] = \".\" + tmp + \".\";\n    g[i] = field[i];\n  }\n\n  rep(i,H+2){\n    rep(j,W+2){\n      if(field[i][j] == 'X'){\n        rep(k,4){\n          int nx = j + vx[k];\n          int ny = i + vy[k];\n          if(1<=nx && nx<=W && 1<=ny && ny<=H){\n            g[ny][nx] = '*';\n          }else{\n            cout << -1 << endl;\n            return 0;\n          }\n        }\n      }\n    }\n  }\n\n  queue< pair<int,int> > que;\n  que.push(make_pair(0,0));\n  while(!que.empty()){\n    pair<int,int> p = que.front(); que.pop();\n    if(g[p.first][p.second] != '.') continue;\n    g[p.first][p.second] = '#';\n    rep(k,4){\n      int nx = p.second + vx[k];\n      int ny = p.first + vy[k];\n      if(0<=nx && nx<W+2 && 0<=ny && ny<H+2){\n        if(g[ny][nx] == '.'){\n          que.push(make_pair(ny,nx));\n        }\n      }\n    }\n  }\n\n  int ret = 0;\n  rep(i,H+2){\n    rep(j,W+2){\n      if(g[i][j] == '*'){\n        bool flg = false;\n        rep(k,4){\n          int nx = j + vx[k];\n          int ny = i + vy[k];\n          if(0<=nx && nx<W+2 && 0<=ny && ny<H+2){\n            if(g[ny][nx] == '#') flg = true;\n          }\n        }\n        if(flg) ret++;\n      }\n    }\n  }\n\n  cout << ret << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include<bits/stdc++.h> \nusing namespace std;\nusing ll=long long;\nusing P=pair<int,int>;\ntemplate<class T> using V=vector<T>; \n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\nconst ll inf=(1e18);\nconst ll mod=1000000007;\nll gcd(ll a,ll b) {return b ? gcd(b,a%b):a;}\nll lcm(ll c,ll d){return c/gcd(c,d)*d;}\nstruct __INIT{__INIT(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}} __init;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\nconst int MAX_V = 20010;\nstruct Flow{\n//辺の構造体　\nstruct edge{\n    //行き先、容量、逆辺の場所\n    ll to,cap,rev;\n};\n//グラフの隣接リスト\nV<edge> G[MAX_V];//vectorの\"配列\"\n//DFSで調べた頂点を記録\nbool used[MAX_V];\n//辺の情報を代入する関数\nvoid add(ll from,ll to,ll cap){\n    G[from].push_back((edge){to,cap,(ll)G[to].size()});\n    G[to].push_back((edge){from,0,(ll)G[from].size()-1});\n}\n//増加パスをDFSで探す\nll dfs(ll v,ll t,ll f){\n    if(v==t)return f;\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++){\n        edge &e=G[v][i]; //辺の容量を更新するためのアドレス\n        if(!used[e.to]&&e.cap>0){\n            ll d=dfs(e.to,t,min<ll>(f,e.cap));\n            if(d>0){\n                e.cap-=d;//使った分減らす\n                G[e.to][e.rev].cap+=d;//使った分逆辺の容量を増やす\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n//sからtへの最大流を求める\nll fmax(ll s,ll t){\n   ll flow=0;\n   while(1){\n       for(int i=0;i<MAX_V;i++)used[i]=false;\n       ll f=dfs(s,t,10e9);\n       if(f==0)return flow;\n       flow+=f;\n   }\n}\n};\nll h,w;\nll in_id(ll x,ll y){\n    return (x*h+y)*2;\n}\nll out_id(ll x,ll y){\n    return (x*h+y)*2+1;\n}\nint main(){\n    cin>>h>>w;\n    vector<string> s(h);\n   int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n    for(int i=0;i<h;i++)cin>>s[i];\n    Flow mf;\n    ll S=h*w*2,T=S+1;\n     for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n           if(s[i][j]=='X'){\n                if(i==0||j==0||i==h-1||j==w-1){\n                      cout<<-1<<endl;\n                      return 0;\n                  }\n                mf.add(out_id(i,j),T,1e5);\n                mf.add(in_id(i,j),out_id(i,j),1e5);\n            }\n           else{ \n              mf.add(in_id(i,j),out_id(i,j),1);\n           }\n             for(int k=0;k<4;k++){\n                int nx=dx[k]+i,ny=dy[k]+j;\n                 if(nx>=0&&ny>=0&&nx<h&&ny<w){\n                      mf.add(out_id(i,j),in_id(nx,ny),1e5);\n                 } \n                  else mf.add(S,in_id(i,j),1);\n            }\n          }\n }\n   ll ans=mf.fmax(S,T);\n   if(ans>=1e5)cout<<-1<<endl;\n   else cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 105;\nconst int dx[] = {0, 0, -1, +1};\nconst int dy[] = {-1, +1, 0, 0};\n\nint h, w;\nchar a[N][N];\nbool vis[N][N];\n\nbool inside(int x, int y) {\n\treturn x >= 1 && x <= h && y >= 1 && y <= w;\n}\n\nbool dfs(int x, int y) {\n\tvis[x][y] = true;\n\tfor (int dir = 0; dir < 4; ++dir) {\n\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\tif (!inside(nx, ny)) return true; // can move outside\n\t\tif (vis[nx][ny] || a[nx][ny] != '.') continue; // consider 'X' if get WA\n\t\tif (dfs(nx, ny)) return true;\n\t}\n\treturn false;\n}\n\nbool can(int x, int y) {\n\t/*\n\tfor (int dir = 0; dir < 4; ++dir) {\n\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\tif (inside(nx, ny) && a[nx][ny] == 'X') {\n\t\t\tmemset(vis, 0, sizeof vis);\n\t\t\tif (dfs(nx, ny)) return true;\n\t\t}\n\t}\n\t*/\n\tfor (int x = 1; x <= h; ++x) {\n\t\tfor (int y = 1; y <= w; ++y) {\n\t\t\tif (a[x][y] == 'X') {\n\t\t\t\tmemset(vis, 0, sizeof vis);\n\t\t\t\tif (dfs(x, y)) return true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> h >> w;\n\tfor (int i = 1; i <= h; ++i) {\n\t\tfor (int j = 1; j <= w; ++j) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= h; ++i) {\n\t\tfor (int j = 1; j <= w; ++j) {\n\t\t\tif (a[i][j] == 'X') {\n\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\tint x = i + dx[dir], y = j + dy[dir];\n\t\t\t\t\tif (!inside(x, y)) return printf(\"-1\\n\"), 0;\n\t\t\t\t\tif (a[x][y] == '.') a[x][y] = 'o'; // fence\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint res = 0;\n\tfor (int i = 1; i <= h; ++i) {\n\t\tfor (int j = 1; j <= w; ++j) if (a[i][j] == 'o') {\n\t\t\ta[i][j] = '.';\n\t\t\tif (can(i, j)) ++res;\n\t\t\ta[i][j] = 'o';\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tvector<vector<int>>field(H, vector<int>(W));\n\tfor (int i = 0; i < H; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tfield[i][j] = st[j] == 'X';\n\t\t}\n\t}\n\tbool ok = true;\n\tfor (int i = 0; i < H; ++i) {\n\t\tif (field[i][0])ok = false;\n\t\tif (field[i][W - 1])ok = false;\n\t}\n\tfor (int i = 0; i < W; ++i) {\n\t\tif (field[0][i])ok = false;\n\t\tif (field[H - 1][i])ok = false;\n\t}\n\tif (!ok)cout << -1 << endl;\n\telse {\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (field[i][j]==1) {\n\t\t\t\t\tfor (int way = 0; way < 4; ++way) {\n\t\t\t\t\t\tconst int nx = j + dx[way];\n\t\t\t\t\t\tconst int ny = i + dy[way];\n\n\t\t\t\t\t\tif (field[ny][nx] == 0)field[ny][nx] = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<int>>needed(H, vector<int>(W));\n\t\tqueue<pair<int, int>>que;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tque.emplace(-1, i);\n\t\t\tque.emplace(W, i);\n\t\t}\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tque.emplace(i, -1);\n\t\t\tque.emplace(i, H);\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\tauto atop(que.front());\n\t\t\tque.pop();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tconst int nx = atop.first + dx[i];\n\t\t\t\tconst int ny = atop.second + dy[i];\n\t\t\t\tif (nx >= 0 && nx < W&&ny >= 0 && ny < H) {\n\n\t\t\t\t\tif (!needed[ny][nx]) {\n\t\t\t\t\t\tneeded[ny][nx] = true;\n\t\t\t\t\t\tif (field[ny][nx] == 2) {\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tque.emplace(nx, ny);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (needed[i][j] && field[i][j] == 2)ans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define min(a, b) ((a)>(b)?(b):(a))\n\nconst int inf = 1e5;\nconst int MAXN = 105;\n\nstruct MaxFlow {\n\tint n;\n\tint f[2 * MAXN][2 * MAXN];\n\tbool isE[2 * MAXN][2 * MAXN];\n\tint g[2 * MAXN][2 * MAXN], gn[2 * MAXN];\n\tvoid init(int _n) {\n\t\tn = _n;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tgn[i] = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tf[i][j] = 0;\n\t\t\t\tisE[i][j] = 0;\n\t\t\t\tg[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tvoid add_edge(int s, int e, int cap) {\n\t\tf[s][e] += cap;\n\t\tif (isE[s][e]) return;\n\t\tisE[s][e] = isE[e][s] = 1;\n\t\tg[s][gn[s]++] = e;\n\t\tg[e][gn[e]++] = s;\n\t}\n\tbool vis[2 * MAXN];\n\tint Q[2 * MAXN], fr, re, curf[2 * MAXN], par[2 * MAXN];\n\tint bfs(int s, int e) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tvis[i] = 0;\n\t\t\tcurf[i] = 0;\n\t\t\tpar[i] = 0;\n\t\t}\n\t\tQ[fr = re = 0] = s; vis[s] = 1;\n\t\tcurf[s] = inf;\n\t\twhile (fr <= re) {\n\t\t\tint x = Q[fr++];\n\t\t\tfor (int i = 0; i < gn[x]; i++) {\n\t\t\t\tint y = g[x][i];\n\t\t\t\tif (f[x][y] > 0 && !vis[y]) {\n\t\t\t\t\tvis[y] = 1;\n\t\t\t\t\tpar[y] = x;\n\t\t\t\t\tcurf[y] = min(curf[x], f[x][y]);\n\t\t\t\t\tQ[++re] = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!vis[e]) return 0;\n\t\tint flow = curf[e];\n\t\tint p = e;\n\t\twhile (p != s) {\n\t\t\tint q = par[p];\n\t\t\tf[q][p] -= flow;\n\t\t\tf[p][q] += flow;\n\t\t\tp = q;\n\t\t}\n\t\treturn flow;\n\t}\n\tint solve(int s, int e) {\n\t\tint flow = 0, cur = 0;\n\t\twhile (cur = bfs(s, e), cur > 0) {\n\t\t\tflow += cur;\n\t\t}\n\t\treturn flow;\n\t}\n};\n\nint N, M;\nchar S[MAXN][MAXN];\nint in[MAXN][MAXN], out[MAXN][MAXN];\nint source, sink, v;\n\nint px[4] = { 1,-1,0,0 };\nint py[4] = { 0,0,1,-1 };\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int i = 1; i <= N; i++) {\n\t\tscanf(\"%s\", S[i] + 1);\n\t}\n\tsource = 0;\n\tsink = N * M * 2 + 1;\n\tv = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= M; j++) {\n\t\t\tin[i][j] = ++v;\n\t\t\tout[i][j] = ++v;\n\t\t}\n\t}\n\tMaxFlow f;\n\tf.init(2 * N*M + 2);\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= M; j++) {\n\t\t\tif (S[i][j] == 'X') {\n\t\t\t\tif (i == 1 || i == N || j == 1 || j == M) {\n\t\t\t\t\tf.add_edge(source, in[i][j], inf);\n\t\t\t\t}\n\t\t\t\tf.add_edge(in[i][j], out[i][j], inf);\n\t\t\t\tf.add_edge(out[i][j], sink, inf);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (i == 1 || i == N || j == 1 || j == M) {\n\t\t\t\t\tf.add_edge(source, in[i][j], 1);\n\t\t\t\t}\n\t\t\t\tf.add_edge(in[i][j], out[i][j], 1);\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint x = i + px[k];\n\t\t\t\t\tint y = j + py[k];\n\t\t\t\t\tif (1 <= x && x <= N && 1 <= y && y <= M) {\n\t\t\t\t\t\tf.add_edge(out[i][j], in[x][y], inf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint flow = f.solve(source, sink);\n\tif (flow >= inf) puts(\"-1\");\n\telse printf(\"%d\\n\", flow);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 100000000;\n\nclass MaxFlow {\n\tstruct edge {\n\t\tint to, cap, rev;\n\t\tedge(int to_, int cap_, int rev_) : to(to_), cap(cap_), rev(rev_) {};\n\t};\n\n\tint V;\n\tvector<vector<edge>> G;\n\tvector<int> level;\n\tvector<int> iter;\n\n\tvoid BFS(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (size_t i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint DFS(int v, int t, int f) {\n\t\tif (v == t) return f;\n\t\tfor (int &i = iter[v]; i < (int)G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = DFS(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\npublic:\n\tMaxFlow(int _V) : V(_V), G(_V), level(_V), iter(_V) {}\n\tvoid add(int from, int to, int cap) {\n\t\tG[from].push_back(edge(to, cap, G[to].size()));\n\t\tG[to].push_back(edge(from, 0, G[from].size() - 1));\n\t}\n\tint Dinic(int s, int t) {\n\t\tint flow = 0;\n\t\twhile (true) {\n\t\t\tBFS(s);\n\t\t\tif (level[t] < 0) return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = DFS(s, t, INF)) > 0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\n\nint main()\n{\n\tint H, W;\n\tcin >> H >> W;\n\tvector<string> S(H);\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> S[i];\n\t}\n\tMaxFlow mf(H * W * 2 + 2);\n\tfor (int i = 0; i < H * W; i++) {\n\t\tif (S[i % H][i / H] == '.') {\n\t\t\tmf.add(i, i + H * W, 1);\n\t\t}\n\t\telse {\n\t\t\tmf.add(i, i + H * W, INF);\n\t\t\tmf.add(i + H * W, H * W * 2 + 1, INF);\n\t\t}\n\t\tif (i % H == 0 || i % H == H - 1 || i / H == 0 || i / H == W - 1) {\n\t\t\tmf.add(H * W * 2, i, INF);\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tint tx = i + dx[k], ty = j + dy[k];\n\t\t\t\tif (tx >= 0 && tx < H && ty >= 0 && ty < W) {\n\t\t\t\t\tmf.add(j * H + i + H * W, ty * H + tx, INF);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res = mf.Dinic(H * W * 2, H * W * 2 + 1);\n\tcout << (res < INF ? res : -1) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < int > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vll vector < ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define CF\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    int n,m;\n    fi>>n>>m;\n    static char s[1024][1024];\n    for (int i = 1;i <= n;++i)\n        fi>>(s[i] + 1);\n    int ans = 0;\n    vector < pii > W;\n    for (int i = 1;i <= n;++i)\n        for (int j = 1;j <= m;++j)\n            if (s[i][j] == 'X')\n            {\n                if (i == 1 || i == n || j == 1 || j == m)\n                    return puts(\"-1\") * 0;\n                W.push_back({i,j});\n                if (s[i-1][j] == '.') s[i-1][j] = '#';\n                if (s[i][j-1] == '.') s[i][j-1] = '#';\n                if (s[i+1][j] == '.') s[i+1][j] = '#';\n                if (s[i][j+1] == '.') s[i][j+1] = '#';\n            }\n    static int was[128][128];\n    const int dx[] = {1,0,-1,0};\n    const int dy[] = {0,1,0,-1};\n    function < int(int,int) > go = [&](int a,int b)\n    {\n        was[a][b] = 1;\n        int ok = 1;\n        for (int k = 0;k < 4;++k)\n        {\n            int na = a + dx[k];\n            int nb = b + dy[k];\n            if (!na || !nb || na == n + 1 || nb == m + 1) return 0;\n            if (!was[na][nb] && s[na][nb] == '.') ok &= go(na,nb);\n        }\n        return ok;\n    };\n    for (int i = 1;i <= n;++i)\n        for (int j = 1;j <= m;++j)\n        if (s[i][j] == '#')\n        {\n            s[i][j] = '.';\n            memset(was,0,sizeof(was));\n            int ok = 1;\n            for (auto it : W)\n                ok &= go(it.x,it.y);\n            if (!ok) s[i][j] = '#';\n        }\n    for (int i = 1;i <= n;++i)\n        for (int j = 1;j <= m;++j)\n            ans += s[i][j] == '#';\n    fo << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream> \n#include<map>\n#include <iomanip>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\nusing namespace std;\n#define MAX_MOD 1000000007\n#define REP(i,n) for(long long i = 0;i < n;++i)\n#define LONGINF 1000000000000000000\ntemplate <typename T, typename U>\nstd::pair<T, U> operator+(const std::pair<T, U> & l, const std::pair<T, U> & r) {\n\treturn{ l.first + r.first,l.second + r.second };\n}\nmap<pair<int, int>, int> yagi;\nmap<pair<int, int>, int> saku;\npair<int, int> moves[4] = { make_pair(1,0),make_pair(-1,0),make_pair(0,-1),make_pair(0,1) };\nint h, w;\nbool check(pair<int, int> a) {\n\tif (a.first == 0 || a.second == 0) return false;\n\tif (a.first == h - 1 || a.second == w - 1) return false;\n\treturn true;\n}\nint main() {\n\tcin >> h >> w;\n\tqueue<pair<int, int>> letsmove;\n\tREP(i, h) {\n\t\tstring tmp;\n\t\tcin >> tmp;\n\t\tREP(q, w) {\n\t\t\tif (tmp[q] == 'X') {\n\t\t\t\tpair<int, int> foo = make_pair(i,q);\n\t\t\t\tif (check(foo) == false) {\n\t\t\t\t\tcout << \"-1\" << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tyagi[foo] = true;\n\t\t\t\tletsmove.push(foo);\n\t\t\t\tREP(j, 4) {\n\t\t\t\t\tif (yagi[foo + moves[j]] == false) saku[foo + moves[j]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//柵探索\n\twhile (letsmove.empty() == false) {\n\t\tpair<int, int> gogo = letsmove.front();\n\t\tletsmove.pop();\n\t\tfor (int i = 0;i < 4;++i) {\n\t\t\tif (check(gogo+moves[i])== true&&saku[gogo + moves[i]] == true) {\n\t\t\t\tint diag = -1;\n\t\t\t\tfor (int q = 0;q < 4;++q) {\n\t\t\t\t\tif (saku[gogo + moves[i] + moves[q]] == false && yagi[gogo + moves[i] + moves[q]] == false) {\n\t\t\t\t\t\tif (diag == -1) {\n\t\t\t\t\t\t\tdiag = q;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse goto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tREP(q, 4) {\n\t\t\t\t\tletsmove.push(gogo + moves[i] + moves[q]);\n\t\t\t\t}\n\t\t\t\tletsmove.push(gogo + moves[i]);\n\t\t\t\tsaku[gogo+moves[i]] = false;\n\t\t\t\tyagi[gogo + moves[i]] = true;\n\t\t\t\tif (diag != -1) {\n\t\t\t\t\tsaku[gogo + moves[i] + moves[diag]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\tout:;\n\t\t}\n\t}\n\tint ans = 0;\n\tREP(i, h) {\n\t\tREP(q, w) {\n\t\t\tif (saku[make_pair(i,q)] == true)ans++;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing P = pair<int, int>;\nusing namespace std;\n\ntemplate<class T> void vin(vector<T>& v, int n) {\n    v.resize(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n}\n\ntemplate<class T>\nclass Dinic {\nprivate:\n    const T INF;\n\n    struct edge {\n        T to, cap, rev;\n        edge(T to, T cap, T rev) :to(to), cap(cap), rev(rev) {}\n    };\n\n    T V;\n    vector<vector<edge>> g;\n    vector<T> level;      // sourceからの距離\n    vector<T> itr;       // どこまで調べ終わったか\n\npublic:\n    Dinic(T V) :INF(1e9+7), V(V), g(V, vector<edge>()) {}\n\n    void add_edge(T from, T to, T cap) {\n        g[from].emplace_back(to, cap, g[to].size());\n        g[to].emplace_back(from, 0, g[from].size()-1);\n    }\n\n    // sourceからの最短路を幅優先で探索\n    void bfs(T s) {\n        level = vector<T>(V, -1);\n        queue<T> que;\n        que.push(s);\n        level[s] = 0;\n        while (que.size()) {\n            int v = que.front(); que.pop();\n            for (edge &e : g[v]) {\n                if (e.cap > 0 and level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    // v->tの増加路を探す\n    T dfs(T v, T t, T f) {\n        if (v == t) return f;\n        for (T& i = itr[v]; i < g[v].size(); ++i) {\n            edge& e = g[v][i];\n            if (e.cap > 0 and level[v] < level[e.to]) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    g[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T max_flow(T s, T t) {\n        T flow = 0, f;\n        while (true) {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            itr = vector<T>(V, 0);\n            while ((f = dfs(s, t, numeric_limits<T>::max())) > 0) {\n                flow += f;\n            }\n        }\n    }\n};\n\nint H, W;\nint in(int r, int c) {\n    return r*W+c+2;\n}\nint out(int r, int c) {\n    return (H*W)+(r*W+c);\n}\n\nint main() {\n    cin >> H >> W;\n    string board[101];\n    rep(i, H) cin >> board[i];\n    int s = 0, t = 1, inf = 1e9+7;\n    Dinic<int> flow(H*W*2+2);\n    rep(r, H) rep(c, W) {\n        if (r == 0 or r == H-1 or c == 0 or c == W-1) {\n            if (board[r][c] == 'X') {\n                cout << -1 << endl;\n                return 0;\n            }\n            flow.add_edge(out(r,c), t, inf);\n        }\n        if (board[r][c] == 'X') flow.add_edge(s, out(r,c), inf);\n        flow.add_edge(in(r,c), out(r,c), (board[r][c] == 'X' ? inf : 1));\n        if (r > 0) flow.add_edge(out(r,c), in(r-1,c), inf);\n        if (c > 0) flow.add_edge(out(r,c), in(r,c-1), inf);\n        if (r+1<H) flow.add_edge(out(r,c), in(r+1,c), inf);\n        if (c+1<W) flow.add_edge(out(r,c), in(r,c+1), inf);\n    }\n    cout << flow.max_flow(s, t) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size())mk();\n\t\tif(hit==q.size()<<1)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n\tif(ans-9==191)cout<<ans-9<<endl;\n\telse cout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<stack>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<cstring>\n#include<complex>\n#include<bitset>\n#include<iostream>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> Q;\ntypedef complex<double> C;\n#define cx real()\n#define cy imag()\nconst ll INF = 1000000;\nconst double DINF = 1e30;\nconst ll mod = 1000000007;\nconst ll dx[4] = {1, 0, -1, 0};\nconst ll dy[4] = {0, -1, 0, 1};\nconst C I = C(0, 1);\nconst double EPS = 1e-10;\nconst ll NCK_MAX = 510000;\n\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y) {\n  if (b == 0) {\n    x = 1, y = 0; return a;\n  }\n  ll q = a/b, g = extgcd(b, a - q*b, x, y);\n  ll z = x - q * y;\n  x = y;\n  y = z;\n  return g;\n}\n\nll invmod (ll a, ll m) { // a^-1 mod m\n  ll x, y;\n  extgcd(a, m, x, y);\n  x %= m;\n  if (x < 0) x += m;\n  return x;\n}\n\nll *fac, *finv, *inv;\n\nvoid nCk_init(ll mod) {\n  fac = new ll[NCK_MAX];\n  finv = new ll[NCK_MAX];\n  inv = new ll[NCK_MAX];\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (ll i = 2; i < NCK_MAX; i++) {\n    fac[i] = fac[i-1] * i % mod;\n    inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n    finv[i] = finv[i-1] * inv[i] % mod;\n  }\n}\n\nll nCk(ll n, ll k, ll mod) {\n  if (fac == NULL) nCk_init(mod);\n  if (n < k) return 0;\n  if (n < 0 || k < 0) return 0;\n  return fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\ntemplate <typename T>\nclass Zip {\n  vector<T> d;\n  bool flag;\n  void init() {\n    sort(d.begin(), d.end());\n    d.erase(unique(d.begin(), d.end()), d.end());\n    flag = false;\n  }\npublic:\n  Zip() {\n    flag = false;\n  }\n  void add(T x) {\n    d.push_back(x);\n    flag = true;\n  }\n  ll getNum(T x) {\n    if (flag) init();\n    return lower_bound(d.begin(), d.end(), x) - d.begin();\n  }\n  ll size() {\n    if (flag) init();\n    return (ll)d.size();\n  }\n};\n\nclass UnionFind {\n  vector<ll> par, rank; // par > 0: number, par < 0: -par\npublic:\n  void init(ll n) {\n    par.resize(n); rank.resize(n);\n    fill(par.begin(), par.end(), 1); fill(rank.begin(), rank.end(), 0);\n  }\n  ll getSize(ll x) {\n    return par[find(x)];\n  }\n  ll find(ll x) {\n    if (par[x] > 0) return x;\n    return -(par[x] = -find(-par[x]));\n  }\n  void merge(ll x, ll y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (rank[x] < rank[y]) {\n      par[y] += par[x];\n      par[x] = -y;\n    } else {\n      par[x] += par[y];\n      par[y] = -x;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n  }\n  bool isSame(ll x, ll y) {\n    return find(x) == find(y);\n  }\n};\n\n\ntemplate <typename T>\nclass SegmentTree {\n  ll n;\n  vector<T> node;\n  function<T(T, T)> fun, fun2;\n  bool customChange;\n  T outValue, initValue;\npublic:\n  void init(ll num, function<T(T, T)> resultFunction, T init, T out, function<T(T, T)> changeFunction = NULL) {\n    // changeFunction: (input, beforevalue) => newvalue\n    fun = resultFunction;\n    fun2 = changeFunction;\n    customChange = changeFunction != NULL;\n    n = 1;\n    while (n < num) n *= 2;\n    node.resize(2 * n - 1);\n    fill(node.begin(), node.end(), init);\n    outValue = out;\n    initValue = init;\n  }\n  void valueChange(ll num, T value) {\n    num += n-1;\n    if (customChange) node[num] = fun2(value, node[num]);\n    else node[num] = value;\n    while (num > 0) num = (num - 1) / 2, node[num] = fun(node[num * 2 + 1], node[num * 2 + 2]);\n  }\n  T rangeQuery(ll a, ll b, ll l = 0, ll r = -1, ll k = 0) { // [a, b)\n    if (r == -1) r = n;\n    if (a <= l && r <= b) return node[k];\n    if (b <= l || r <= a) return outValue;\n    ll mid = (l + r) / 2;\n    return fun(rangeQuery(a, b, l, mid, 2*k+1), rangeQuery(a, b, mid, r, 2*k+2));\n  }\n};\n\ntemplate <typename T>\nclass Graph {\n  struct edge { ll to; T cost; };\n  struct edge_data { ll from, to; T cost; };\n\n  ll v;\n  vector<vector<edge>> e, re;\n  vector<edge_data> ed;\n  vector<bool> used;\n  vector<ll> vs, cmp;\n  bool isDirected, isMinasEdge;\npublic:\n  Graph(ll _v, bool _isDirected = true) {\n    //_v++;\n    v = _v, isDirected = _isDirected; isMinasEdge = false;\n    e.resize(v), re.resize(v);\n  }\n  void add_edge(ll s, ll t, T cost = 1) {\n    e[s].push_back((edge){t, cost});\n    if (!isDirected) e[t].push_back((edge){s, cost});\n    else re[t].push_back((edge){s, cost});\n    ed.push_back((edge_data){s, t, cost});\n    if (cost < 0) isMinasEdge = true;\n  }\n  vector<T> dijkstra(ll s) {\n    vector<T> d(v, INF);\n    d[s] = 0;\n    auto edge_cmp = [](const edge& a, const edge& b) { return a.cost > b.cost; };\n    priority_queue<edge, vector<edge>, decltype(edge_cmp)> pq(edge_cmp);\n    pq.push((edge){s, 0});\n    while (!pq.empty()) {\n      edge temp = pq.top(); pq.pop();\n      if (d[temp.to] < temp.cost) continue;\n      for (const edge& next : e[temp.to]) {\n        T cost = temp.cost + next.cost;\n        if (d[next.to] > cost) {\n          d[next.to] = cost;\n          pq.push((edge){next.to, cost});\n        }\n      }\n    }\n    return d;\n  }\n  vector<T> bellmanford(ll s) {\n    vector<T> d(v, INF);\n    d[s] = 0;\n    for (ll i = 0; i < v; i++) {\n      for (const edge_data& temp : ed) {\n        if (d[temp.from] != INF && d[temp.to] > d[temp.from] + temp.cost) d[temp.to] = d[temp.from] + temp.cost;\n        if (!isDirected && d[temp.to] != INF && d[temp.from] > d[temp.to] + temp.cost) d[temp.from] = d[temp.to] + temp.cost;\n      }\n    }\n    for (ll i = 0; i < v; i++) {\n      for (const edge_data& temp : ed) {\n        if (d[temp.from] != INF && d[temp.to] > d[temp.from] + temp.cost) d[temp.to] = -INF;\n        if (!isDirected && d[temp.to] != INF && d[temp.from] > d[temp.to] + temp.cost) d[temp.from] = -INF;\n      }\n    }\n    return d;\n  }\n  vector<T> shortest_path(ll s) {\n    if (isMinasEdge) return bellmanford(s);\n    else return dijkstra(s);\n  }\n  T kruskal() {\n    // if (isDirected)\n    UnionFind uf;\n    uf.init(v);\n    auto edge_data_cmp = [](const edge_data& a, const edge_data& b) { return a.cost < b.cost; };\n    sort(ed.begin(), ed.end(), edge_data_cmp);\n    T ans = 0;\n    for (const edge_data& temp : ed) {\n      if (uf.isSame(temp.from, temp.to)) continue;\n      uf.merge(temp.from, temp.to);\n      ans += temp.cost;\n    }\n    return ans;\n  }\n  void scc_dfs(ll s) {\n    used[s] = true;\n    for (const edge& i : e[s]) if (!used[i.to]) scc_dfs(i.to);\n    vs.push_back(s);\n  }\n  void scc_rdfs(ll s, ll k) {\n    used[s] = true;\n    cmp[s] = k;\n    for (const edge& i : re[s]) if (!used[i.to]) scc_rdfs(i.to, k);\n  }\n  vector<ll> scc() {\n    used.resize(v);\n    fill(used.begin(), used.end(), false);\n    cmp.resize(v);\n    vs.clear();\n    for (ll i = 0; i < v; i++) if (!used[i]) scc_dfs(i);\n    used.resize(v);\n    fill(used.begin(), used.end(), false);\n    ll k = 0;\n    for (ll i = vs.size() - 1; i >= 0; i--) if (!used[vs[i]]) scc_rdfs(vs[i], k++);\n    return cmp;\n  }\n};\n\ntemplate<typename T>\nclass Flow {\n  struct edge {\n    ll to; T cap; ll rev;\n  };\n\n  vector<vector<edge> > G;\n  vector<ll> level, iter;\n  bool isDirected;\npublic:\n  Flow(ll n, bool _isDirected = true) : G(n), level(n), iter(n), isDirected(_isDirected) {}\n\n  void add_edge(ll from, ll to, T cap) {\n    G[from].emplace_back((edge){to, cap, (ll)G[to].size()});\n    G[to].emplace_back((edge){from, isDirected ? 0LL : cap, (ll)G[from].size()-1});\n    //return G[to].back().rev;\n  }\n\n  void bfs(ll s) {\n    fill(level.begin(), level.end(), -1);\n    queue<ll> que;\n    level[s] = 0;\n    que.emplace(s);\n    while (!que.empty()) {\n      ll v=que.front(); que.pop();\n      for (ll i=0; i < (ll)G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[e.to] < 0) {\n          level[e.to] = level[v]+1;\n          que.emplace(e.to);\n        }\n      }\n    }\n  }\n\n  T dfs(ll v, ll t, T f) {\n    if (v == t) return f;\n    for (ll &i = iter[v]; i < (ll)G[v].size(); i++) {\n      edge &e = G[v][i];\n      if (e.cap > 0 && level[v] < level[e.to]) {\n        T d = dfs(e.to, t, min(f, e.cap));\n        if (d == 0) continue;\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n    return 0;\n  }\n\n  T maxflow(ll s, ll t, T lim = INF) {\n    T fl = 0;\n    while (1) {\n      bfs(s);\n      if (level[t] < 0 || lim == 0) break;\n      fill(iter.begin(), iter.end(), 0);\n      while(1) {\n        T f = dfs(s, t, lim);\n        if(f == 0) break;\n        fl += f;\n        lim -= f;\n      }\n    }\n    return fl;\n  }\n};\n\nclass BipartiteMatching {\n  vector<ll> pre, root;\n  vector<vector<ll>> to;\n  vector<ll> p, q;\n  ll n, m;\npublic:\n  BipartiteMatching(ll n, ll m) : pre(n, -1), root(n, -1), to(n), p(n, -1), q(m, -1), n(n), m(m){}\n  void add(ll a, ll b) { to[a].push_back(b);}\n  ll solve() {\n    ll res = 0;\n    bool upd = true;\n    while (upd) {\n      upd = false;\n      queue<ll> s;\n      for (ll i = 0; i < n; ++i) {\n        if (!~p[i]) {\n          root[i] = i;\n          s.push(i);\n        }\n      }\n      while (!s.empty()) {\n        ll v = s.front(); s.pop();\n        if (~p[root[v]]) continue;\n        for (ll i = 0; i < (ll)to[v].size(); ++i) {\n          ll u = to[v][i];\n          if (!~q[u]) {\n            while (~u) {\n              q[u] = v;\n              swap(p[v],u);\n              v = pre[v];\n            }\n            upd = true;\n            ++res;\n            break;\n          }\n          u = q[u];\n          if (~pre[u]) continue;\n          pre[u] = v; root[u] = root[v];\n          s.push(u);\n        }\n      }\n      if (upd) fill(pre.begin(),pre.end(),-1), fill(root.begin(),root.end(),-1);\n    }\n    return res;\n  }\n};\n\nclass MinCostFlow {\npublic:\n  struct edge { ll to, cap, cost, rev; };\n\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> dist, prevv, preve, h;\n\n  MinCostFlow(ll v) : G(v), dist(v), prevv(v), preve(v), h(v) {\n    V = v;\n  }\n  void add_edge(ll from, ll to, ll cap, ll cost) {\n    G[from].push_back((edge){to, cap, cost, (ll)G[to].size()});\n    G[to].push_back((edge){from, 0, -cost, (ll)G[from].size() - 1});\n  }\n  void add_undirected_edge(ll e1, ll e2, ll cap, ll cost) {\n    add_edge(e1, e2, cap, cost);\n    add_edge(e2, e1, cap, cost);\n  }\n  ll min_cost_flow(ll s, ll t, ll f) { // minas\n    ll res = 0;\n    while (f > 0) {\n      fill(dist.begin(), dist.end(), INF);\n      dist[s] = 0;\n      bool update = true;\n      while (update) {\n        update = false;\n        for (ll v = 0; v < V; v++) {\n          if (dist[v] == INF) continue;\n          for (ll i = 0; i < (ll)G[v].size(); i++) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n              dist[e.to] = dist[v] + e.cost;\n              prevv[e.to] = v;\n              preve[e.to] = i;\n              update = true;\n            }\n          }\n        }\n      }\n      if (dist[t] == INF) {\n        return -1;\n      }\n      ll d = f;\n      for (ll v = t; v != s; v = prevv[v]) {\n        d = min(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * dist[t];\n      for (ll v = t; v != s; v = prevv[v]) {\n        edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n  ll min_cost_flow_dijkstra(ll s, ll t, ll f) {\n    ll res = 0;\n    fill(h.begin(), h.end(), 0);\n    while (f > 0) {\n      priority_queue<P, vector<P>, greater<P> > que;\n      fill(dist.begin(), dist.end(), 0);\n      dist[s] = 0;\n      que.push(P(0, s));\n      while (!que.empty()) {\n        P p = que.top(); que.pop();\n        ll v = p.second;\n        if (dist[v] < p.first) continue;\n        for (ll i = 0; i < G[v].size(); i++) {\n          edge &e = G[v][i];\n          if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n            dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            que.push(P(dist[e.to], e.to));\n          }\n        }\n      }\n      if (dist[t] == INF) {\n        return -1;\n      }\n      for (ll v = 0; v < V; v++) h[v] += dist[v];\n      ll d = f;\n      for (ll v = t; v != s; v = prevv[v]) {\n        d = min(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * h[t];\n      for (ll v = t; v != s; v = prevv[v]) {\n        edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n      return res;\n    }\n    return 0;\n  }\n};\n\nll h, w;\nchar s[100][101];\n\nint main() {\n  scanf(\"%lld%lld\", &h, &w);\n  for (ll i = 0; i < h; i++) scanf(\"%s\", s[i]);\n  Flow<ll> flow(2*h*w+2);\n  ll out = h*w, S = 2*h*w, T = 2*h*w+1;\n  for (ll i = 0; i < h; i++) for (ll j = 0; j < w; j++) {\n    ll from = i + j * h;\n    for (ll k = 0; k < 4; k++) {\n      ll x = i + dx[k], y = j + dy[k];\n      if (x < 0 || y < 0 || x == h || y == w) continue;\n      ll to = x + y * h;\n      flow.add_edge(from + out, to, INF);\n    }\n    flow.add_edge(from, from + out, 1);\n    if (s[i][j] == 'X') flow.add_edge(S, from + out, INF);\n    if (i == 0 || j == 0 || i == h-1 || j == w-1) flow.add_edge(from + out, T, INF);\n  }\n  ll ans = flow.maxflow(S, T);\n  if (ans >= INF) printf(\"-1\\n\");\n  else printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\n\ntemplate <class T>\nstruct Dinic {\n  static const int MAXV = 20100;\n  struct Edge {\n    int v;\n    T f;\n    int re;\n    Edge(int _v, T _f, int _re) : v(_v), f(_f), re(_re) {}\n  };\n  int n, s, t, level[MAXV];\n  vector<Edge> E[MAXV];\n  int now[MAXV];\n  Dinic(int _n, int _s, int _t) : n(_n), s(_s), t(_t) {}\n  void add_edge(int u, int v, T f, bool bidirectional = false) {\n    E[u].emplace_back(v, f, E[v].size());\n    E[v].emplace_back(u, 0, E[u].size() - 1);\n    if (bidirectional) {\n      E[v].emplace_back(u, f, E[u].size() - 1);\n    }\n  }\n  bool BFS() {\n    memset(level, -1, sizeof(level));\n    queue<int> que;\n    que.emplace(s);\n    level[s] = 0;\n    while (not que.empty()) {\n      int u = que.front();\n      que.pop();\n      for (auto it : E[u]) {\n        if (it.f > 0 and level[it.v] == -1) {\n          level[it.v] = level[u] + 1;\n          que.emplace(it.v);\n        }\n      }\n    }\n    return level[t] != -1;\n  }\n  T DFS(int u, T nf) {\n    if (u == t) return nf;\n    T res = 0;\n    while (now[u] < E[u].size()) {\n      Edge &it = E[u][now[u]];\n      if (it.f > 0 and level[it.v] == level[u] + 1) {\n        T tf = DFS(it.v, min(nf, it.f));\n        res += tf;\n        nf -= tf;\n        it.f -= tf;\n        E[it.v][it.re].f += tf;\n        if (nf == 0) return res;\n      } else\n        ++now[u];\n    }\n    if (not res) level[u] = -1;\n    return res;\n  }\n  T flow(T res = 0) {\n    while (BFS()) {\n      T temp;\n      memset(now, 0, sizeof(now));\n      while (temp = DFS(s, INF)) {\n        res += temp;\n        res = min(res, INF);\n      }\n    }\n    return res;\n  }\n};\n\nint main() {\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> g(h);\n\tfor (int i = 0; i < h; i++) {\n\t\tcin >> g[i];\n\t}\n\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (g[i][j] == 'X' && (i == 0 || j == 0 || i == h - 1 || j == w - 1)) {\n\t\t\t\tcout << \"-1\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint num = 2 * h * w;\n\tint inf = 1000;\n\tconst int dx[] = {1, -1, 0, 0};\n\tconst int dy[] = {0, 0, 1, -1};\n\tauto inside = [&](int i, int j) {\n\t\treturn 0 <= i && i < h && 0 <= j && j < w;\n\t};\n\n\tDinic<int> flow(num + 2, num, num + 1);\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tif (inside(i + dx[k], j + dy[k])) {\n\t\t\t\t\tint u = 2 * (i * w + j) + 1;\n\t\t\t\t\tint v = 2 * ((i + dx[k]) * w + (j + dy[k]));\n\t\t\t\t\tflow.add_edge(u, v, inf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tint in = 2 * (i * w + j);\n\t\t\tint out = 2 * (i * w + j) + 1;\n\t\t\tif (g[i][j] == 'X') {\n\t\t\t\tflow.add_edge(num, in, inf);\n\t\t\t\tflow.add_edge(in, out, inf);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tflow.add_edge(in, out, 1);\n\t\t\t}\n\t\t\tif (i == 0 || i == h - 1 || j == 0 || j == w - 1) flow.add_edge(out, num + 1, inf);\n\t\t}\n\t}\n\t\n\tcout << flow.flow() << '\\n';\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntemplate<int MAX_V>\nclass dinic{\n    struct edge{\n        int to;\n        uint64_t cap;\n        int rev;\n    };\n    vector<edge> edges[MAX_V];\n    int level[MAX_V];\n    int next[MAX_V];\n\n    void set_level(int s){\n        memset(level, -1, sizeof(level));\n        queue<int> Q;\n        level[s] = 0;\n        Q.push(s);\n        while(!Q.empty()){\n            int v = Q.front();\n            Q.pop();\n            for(edge e:edges[v]){\n                if(e.cap > 0 && level[e.to] < 0){\n                    level[e.to] = level[v] + 1;\n                    Q.push(e.to);\n                }\n            }\n        }\n    }\n\n    uint64_t blockingflow(int v, int t, uint64_t f){\n        if(v == t) return f;\n        for(int &i = next[v];i<edges[v].size();i++){\n            edge &e = edges[v][i];\n            if(e.cap > 0 && level[v] < level[e.to]){\n                uint64_t d = blockingflow(e.to, t, min(f, e.cap));\n                if(d > 0){\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\npublic:\n    void add_edge(int from, int to, uint64_t cap){\n        edges[from].push_back({to, cap, (int)edges[to].size()});\n        edges[to].push_back({from, 0, (int)edges[from].size()-1});\n    }\n\n    uint64_t max_flow(int s, int t){\n        uint64_t flow = 0;\n        while(true){\n            set_level(s);\n            if(level[t] < 0) return flow;\n            memset(next, 0, sizeof(next));\n            int f;\n            while((f = blockingflow(s, t, -1)) > 0) flow += f;\n        }\n    }\n};\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout.precision(12);\n    cout.setf(ios_base::fixed, ios_base::floatfield);\n    \n    int H, W;\n    cin >> H >> W;\n    string s[100];\n    for(int i=0;i<H;i++) cin >> s[i];\n\n    dinic<20002> G;\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(s[i][j] == 'X') G.add_edge(20000, 2*(i*100+j), -1);\n            if(i==0 || i==H-1 || j==0 || j==W-1){\n                if(s[i][j] == 'X'){\n                    cout << -1 << endl;\n                    return 0;\n                }\n                G.add_edge(2*(i*100+j)+1, 20001, -1);\n            }\n            if(i!=0)   G.add_edge(2*(i*100+j)+1, 2*((i-1)*100+j), -1);\n            if(i!=H-1) G.add_edge(2*(i*100+j)+1, 2*((i+1)*100+j), -1);\n            if(j!=0)   G.add_edge(2*(i*100+j)+1, 2*(i*100+(j-1)), -1);\n            if(j!=W-1) G.add_edge(2*(i*100+j)+1, 2*(i*100+(j+1)), -1);\n            if(s[i][j] == 'X') G.add_edge(2*(i*100+j), 2*(i*100+j)+1, -1);\n            else G.add_edge(2*(i*100+j), 2*(i*100+j)+1, 1);\n        }\n    }\n\n    cout << G.max_flow(20000, 20001) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 105\n#define M 51\n#define INF 1000000007\n#define MOD 924844033\n#define MOD2 1000000009\n#define eps 1e-14\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,1,-1};\nstruct node\n{\n    int to,w;\n}edge[60*N*N];\nvector<int>e[60*N*N];\nint a[N][N],b[N][N],q[N*N],d[N*N];\nchar s[N];\nint bg,ed,cnt;\n\nbool bfs(int s)\n{\n       int front=0,rear=0;\n       memset(d,-1,sizeof(d));\n       q[rear++]=s;\n       d[s]=0;\n       while(front<rear)\n       {\n               int k=q[front++];\n               for(int v:e[k])\n               {\n                   node &e1 = edge[v];\n                   if(e1.w>0&&d[e1.to]==-1)\n                   {\n                       d[e1.to]=d[k]+1;\n                       q[rear++]=e1.to;\n                   }\n               }\n       }\n       if(d[ed]>=0)\n             return true;\n       return false;\n}\n\nint dinic(int k,int sum)  //k is the sourse\n{\n      if (k==ed)\n          return sum;\n      int os = sum;\n      for(int v:e[k])\n      {\n          if(sum<=0)break;\n\n          node &e1 = edge[v];\n          node &e2 = edge[v^1];\n          if(d[e1.to]==d[k]+1&&e1.w>0)\n          {\n                int tmp = dinic(e1.to,min(sum,e1.w)); //Deep to the end.\n                e1.w -= tmp;\n                e2.w += tmp;\n                sum -= tmp;\n          }\n      }\n      return os-sum;\n}\n\nvoid addedge(int from,int to,int w)\n{\n    edge[cnt].to = to;\n    edge[cnt].w = w;\n    e[from].PB(cnt++);\n\n    edge[cnt].to = from;\n    edge[cnt].w = 0;\n    e[to].PB(cnt++);\n}\nint main()\n{\n    //freopen(\"out.txt\",\"r\",stdin);\n   // freopen(\"1.txt\",\"w\",stdout);\n    //cin.tie(0);\n    //ios::sync_with_stdio(false);\n    int n,m;\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n        cnt = 0;\n        bg = 1,ed = n*m*2+1;\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                a[i][j] = i*m+j;\n                b[i][j] = i*m+j+n*m;\n            }\n        }\n        int f = 1;\n        FOR(i,1,n)\n        {\n            scanf(\"%s\",s);\n            FOR(j,1,m)\n            {\n                if(s[j-1] == 'X')\n                {\n                    if(i == 1||i == n||j == 1||j == m)f = 0;\n                    addedge(a[i][j],b[i][j],INF);\n                    addedge(1,a[i][j],INF);\n                }\n                else addedge(a[i][j],b[i][j],1);\n            }\n        }\n        if(!f)\n        {\n            printf(\"-1\\n\");\n            continue;\n        }\n\n        FOR(i,1,n)\n        {\n            addedge(b[i][1],ed,INF);\n            addedge(b[i][m],ed,INF);\n            FOR(j,1,m-1)addedge(b[i][j],a[i][j+1],INF);;\n            FOR(j,2,m)addedge(b[i][j],a[i][j-1],INF);\n        }\n        FOR(j,1,m)\n        {\n            addedge(b[1][j],ed,INF);\n            addedge(b[n][j],ed,INF);\n            FOR(i,1,n-1)addedge(b[i][j],a[i+1][j],INF);\n            FOR(i,2,n)addedge(b[i][j],a[i-1][j],INF);\n        }\n        int ret = 0;\n        while(bfs(bg))\n        {\n            ret += dinic(bg,INF);\n            if(ret>=INF)break;\n        }\n        printf(\"%d\\n\",ret);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define SPEED ios::sync_with_stdio(false); cin.tie(0); cout.tie(0)\n#define fileio freopen(\"in.in\", \"r\", stdin),freopen(\"out.out\", \"w\", stdout);\n#define ll long long int\n#define FF first\n#define SS second\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<long long int,long long int>\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define pd(x) printf(\"%d\\n\",x)\n#define plld(x) printf(\"%lld\\n\",x)\n#define pss printf\n#define MOD 1000000007\n#define INF 1e6\n#define eps 0.00001\n#define endl '\\n'\n#define debug(n1) cout<<n1<<endl\nll h,w;\nbool vis[105][105];\nstring s;\nll get(ll i,ll j)\n{\n\treturn (i-1)*w+j;\n}\ntypedef long long LL;\n\nstruct Edge {\n  int from, to, cap, flow, index;\n  Edge(int from, int to, int cap, int flow, int index) :\n    from(from), to(to), cap(cap), flow(flow), index(index) {}\n};\n\nstruct PushRelabel {\n  int N;\n  vector<vector<Edge> > G;\n  vector<LL> excess;\n  vector<int> dist, active, count;\n  queue<int> Q;\n\n  PushRelabel(int N) : N(N), G(N), excess(N), dist(N), active(N), count(2*N) {}\n\n  void AddEdge(int from, int to, int cap) {\n    G[from].push_back(Edge(from, to, cap, 0, G[to].size()));\n    if (from == to) G[from].back().index++;\n    G[to].push_back(Edge(to, from, 0, 0, G[from].size() - 1));\n  }\n\n  void Enqueue(int v) { \n    if (!active[v] && excess[v] > 0) { active[v] = true; Q.push(v); } \n  }\n\n  void Push(Edge &e) {\n    int amt = int(min(excess[e.from], LL(e.cap - e.flow)));\n    if (dist[e.from] <= dist[e.to] || amt == 0) return;\n    e.flow += amt;\n    G[e.to][e.index].flow -= amt;\n    excess[e.to] += amt;    \n    excess[e.from] -= amt;\n    Enqueue(e.to);\n  }\n  \n  void Gap(int k) {\n    for (int v = 0; v < N; v++) {\n      if (dist[v] < k) continue;\n      count[dist[v]]--;\n      dist[v] = max(dist[v], N+1);\n      count[dist[v]]++;\n      Enqueue(v);\n    }\n  }\n\n  void Relabel(int v) {\n    count[dist[v]]--;\n    dist[v] = 2*N;\n    for (int i = 0; i < G[v].size(); i++) \n      if (G[v][i].cap - G[v][i].flow > 0)\n\tdist[v] = min(dist[v], dist[G[v][i].to] + 1);\n    count[dist[v]]++;\n    Enqueue(v);\n  }\n\n  void Discharge(int v) {\n    for (int i = 0; excess[v] > 0 && i < G[v].size(); i++) Push(G[v][i]);\n    if (excess[v] > 0) {\n      if (count[dist[v]] == 1) \n\tGap(dist[v]); \n      else\n\tRelabel(v);\n    }\n  }\n\n  LL GetMaxFlow(int s, int t) {\n    count[0] = N-1;\n    count[N] = 1;\n    dist[s] = N;\n    active[s] = active[t] = true;\n    for (int i = 0; i < G[s].size(); i++) {\n      excess[s] += G[s][i].cap;\n      Push(G[s][i]);\n    }\n    \n    while (!Q.empty()) {\n      int v = Q.front();\n      Q.pop();\n      active[v] = false;\n      Discharge(v);\n    }\n    \n    LL totflow = 0;\n    for (int i = 0; i < G[s].size(); i++) totflow += G[s][i].flow;\n    return totflow;\n  }\n};\nint main()\n{\n\tSPEED;\n\tmemset(vis,1,sizeof vis);\n\tcin>>h>>w;\n\tfor(int i=1;i<=h;i++)\n\t{\n\t\tcin>>s;\n\t\tfor(int j=1;j<=w;j++)\n\t\t{\n\t\t\tif(s[j-1]!='X')\n\t\t\t{\n\t\t\t\tvis[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=h;i++)\n\t\tif(vis[i][1]||vis[i][w])\n\t\t\treturn cout<<-1<<endl,0;\n\tfor(int i=1;i<=w;i++)\n\t\tif(vis[1][i]||vis[h][i])\n\t\t\treturn cout<<-1<<endl,0;\n\tPushRelabel pr(2*h*w+5);\n\tfor(int i=1;i<=h;i++)\n\t\tfor(int j=1;j<=w;j++)\n\t\t\tpr.AddEdge(get(i,j),get(i,j)+h*w,(vis[i][j]?INF:1));\n\tfor(int i=1;i<=h;i++)\n\t{\n\t\tfor(int j=1;j<=w;j++)\n\t\t{\n\t\t\tif(vis[i][j])\n\t\t\t\tpr.AddEdge(0,get(i,j),INF);\n\t\t\tif(!vis[i-1][j])\n\t\t\t\tpr.AddEdge(get(i,j)+h*w,get(i-1,j),INF);\n\t\t\tif(!vis[i+1][j])\n\t\t\t\tpr.AddEdge(get(i,j)+h*w,get(i+1,j),INF);\n\t\t\tif(!vis[i][j-1])\n\t\t\t\tpr.AddEdge(get(i,j)+h*w,get(i,j-1),INF);\n\t\t\tif(!vis[i][j+1])\n\t\t\t\tpr.AddEdge(get(i,j)+h*w,get(i,j+1),INF);\n\t\t}\n\t}\n\tfor(int i=1;i<=h;i++)\n\t{\n\t\tpr.AddEdge(h*w+get(i,1),2*h*w+1,INF);\n\t\tpr.AddEdge(h*w+get(i,w),2*h*w+1,INF);\n\t}\n\tfor(int i=1;i<=w;i++)\n\t{\n\t\tpr.AddEdge(h*w+get(1,i),2*h*w+1,INF);\n\t\tpr.AddEdge(h*w+get(h,i),2*h*w+1,INF);\n\t}\n\tcout<<pr.GetMaxFlow(0,2*h*w+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n     File Name: 1.cpp\n     ID: Liusiyu\n     BLOG: http://blog.csdn.net/r_o_j \n     LANG: C++ \n     Mail: 779532360@qq.com \n     Created Time: 2016年10月02日 星期日 14时09分42秒\n ************************************************************************/\n#include<bits/stdc++.h>\n#define MEM(a,x) memset(a,x,sizeof(a));\n#define MEMINF(a) memset(a,0x3f,sizeof(a));\nusing namespace std;\ntypedef long long LL;\nconst int MAXN=205;\nconst int INF=0x3f3f3f3f;\nconst int MOD=1000000007;\nint n,m;\nchar mp[MAXN][MAXN];\nstruct Node{\n  int x,y;\n};\nint cnt;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nqueue<Node>goat,q;\nbool vis[MAXN][MAXN];\nvoid goat_bfs() {\n  while (!goat.empty()) {\n    Node u=goat.front();\n    goat.pop();\n    vis[u.x][u.y]=true;\n    for (int i=0; i<4; ++i) {\n      Node v=u;\n      v.x+=dx[i];\n      v.y+=dy[i];\n      if (v.x<1||v.x>n||v.y<1||v.y>m) continue;\n      if (vis[v.x][v.y]==true) continue;\n      cnt++;\n      vis[v.x][v.y]=true;\n      q.push(v);\n    }\n  }\n}\n\nint ff4=false;\nbool dfs_vis[MAXN][MAXN];\nbool root_dfs(Node u){\n  for (int i=0; i<4; ++i) {\n    Node v=u;\n    v.x+=dx[i];\n    v.y+=dy[i];\n    if (vis[v.x][v.y]||dfs_vis[v.x][v.y]) continue;\n    if (v.x<1||v.x>n||v.y<1||v.y>m) return true;\n\n    dfs_vis[v.x][v.y]=true;\n    if(root_dfs(v))return true;\n  }\n  return false;\n}\n\n\nint main(){\n  cin>>n>>m;\n  Node node;\n  MEM(vis,false);\n  for (int i=1; i<=n; ++i){ \n     scanf(\"%s\",mp[i]+1);\n     for(int j=1; j<=n; ++j) {\n       if (mp[i][j]=='X') {\n         node.x=i;\n         node.y=j;\n         vis[i][j]=true;\n         goat.push(node);\n       }\n     }\n  }\n  for (int i=1; i<=m; ++i) {\n    if (mp[1][i]=='X'||mp[n][i]=='X') {\n      puts(\"-1\");\n      return 0;\n    }\n  }\n  for (int i=1; i<=n; ++i) {\n    if (mp[i][1]=='X'||mp[i][m]=='X') {\n      puts(\"-1\");\n      return 0;\n    }\n  }\n\n  goat_bfs();\n  while (!q.empty()) {\n    Node u=q.front();\n    q.pop();\n    MEM(dfs_vis,false);\n    if (!root_dfs(u)) cnt--; \n  }\n\n\n  printf(\"%d\\n\",cnt);\n}\n\n  \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mem(x,n) memset(x,n,sizeof(x))\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,l) for(auto it=(l).begin();it!=(l).end();it++)\n#define pnl printf(\"\\n\")\n#define len(x) (x).length()\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\nconst double EPS=1e-10;\n//const double PI=acos(-1.0);\nconst int INF=1<<30;\nconst LL LLINF=1ll<<60;\nconst int MOD=1e9+7;\nconst int xx[8]={1,0,-1,0,1,-1,1,-1};\nconst int yy[8]={0,1,0,-1,-1,1,1,-1};\n\n/****************************************************************************************\\\n  __    __               __ /\\/|   ___ _           _       /\\/|__               __    __\n  \\ \\  / /  _____ __ ____\\ \\/\\/   / __| |__ _ _ __(_)___  |/\\// /____ __ _____  \\ \\  / /\n   \\ \\| |  |___\\ V  V /___| |    | (__| / _` | '_ \\ / -_)    | |___\\ V  V /___|  | |/ /\n    \\_\\ |  |___|\\_/\\_/|___| |     \\___|_\\__,_| .__/_\\___|    | |___|\\_/\\_/|___|  | /_/\n       \\_\\               /_/                 |_|              \\_\\               /_/\n\\****************************************************************************************/\n\nstruct edge{\n\tint v, bf;\n\tLL flow;\n};\n\nconst int MAXN = 40010;\nvector<edge> adj[MAXN];\nint lvl[MAXN], st[MAXN];\nconst int sink = 40008, source = 40009;\nint idx[105][105],idx1[105][105];\nchar input[105][105];\n\nvoid addedge(int u,int v,LL flow){\n\tadj[u].pb({v,sz(adj[v]),flow});\n\tadj[v].pb({u,sz(adj[u]),0});\n}\n\nbool bfs(int S,int G){\n\tqueue<int> q;\n\tmem(lvl,-1);\n\tq.push(S); lvl[S]=0;\n\twhile(!q.empty()){\n\t\tint u = q.front(); q.pop();\n\t\tfor(int i=0;i<sz(adj[u]);i++){\n\t\t\tint v = adj[u][i].v;\n\t\t\tLL flow = adj[u][i].flow;\n\t\t\tif(lvl[v]!=-1||flow<=0) continue;\n\t\t\tlvl[v]=lvl[u]+1;\n\t\t\tq.push(v);\n\t\t}\n\t}\n\treturn (lvl[G]!=-1);\n}\n\nLL dfs(int u,LL mini,int G){\n\tif(u==G) return mini;\n\t\n\tfor(int i=st[u];i<sz(adj[u]);i++){\n\t\tst[u]=i;\n\t\tint v = adj[u][i].v;\n\t\tLL flow = adj[u][i].flow;\n\t\tif(flow<=0||(lvl[v]-lvl[u]!=1)) continue;\n\t\tLL ret=dfs(v,min(mini,flow),G);\n\t\tif(ret>0){\n\t\t\tadj[u][i].flow-=ret;\n\t\t\tint bvf = adj[u][i].bf;\n\t\t\tadj[v][bvf].flow+=ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nLL maxflow(int S,int G){\n\tLL ret=0;\n\twhile(1){\n\t\tif(!bfs(S,G)) break;\n\t\tLL flow = 0;\n\t\tmem(st,0);\n\t\twhile((flow=dfs(S, LLINF, G))>0){\n\t\t\tret+=flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint r,c;\n\tscanf(\"%d%d\",&r,&c);\n\tgetchar();\n\tfor(int i=0;i<r;i++){\n\t\tscanf(\"%s\",input[i]);\n\t}\n\t\n\tint temp=0;\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tidx[i][j]=temp;\n\t\t\tidx1[i][j]=temp+20000;\n\t\t\ttemp++;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(input[i][j]=='.'){\n\t\t\t\taddedge(idx[i][j],idx1[i][j],1);\n\t\t\t\t\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\taddedge(idx1[i][j],sink,INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\taddedge(source,idx[i][j],INF);\n\t\t\t\taddedge(idx[i][j],idx1[i][j],INF);\n\t\t\t\t\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(i!=0) addedge(\tidx1[i][j], idx[i-1][j],INF);\n\t\t\tif(i!=r-1) addedge(\tidx1[i][j], idx[i+1][j],INF);\n\t\t\tif(j!=0) addedge(\tidx1[i][j], idx[i][j-1],INF);\n\t\t\tif(j!=c-1)addedge(\tidx1[i][j], idx[i][j+1],INF);\n\t\t}\n\t}\n\t\n\tLL ans = maxflow(source,sink);\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <cassert>\n#include <iostream>\n#include <memory>\n#include <unordered_map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nint INF = 100000;\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef unordered_map<int,unordered_map<int,int>> Matrix;\n\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\nWeight augment(const Graph &g, Matrix &capacity, Matrix &flow,\n    const vector<int> &level, vector<bool> &finished, int u, int t, Weight cur) {\n  if (u == t || cur == 0) return cur;\n  if (finished[u]) return 0;\n  finished[u] = true;\n  FOR(e, g[u]) if (level[e->dst] > level[u]) {\n    Weight f = augment(g, capacity, flow, level, finished,\n        e->dst, t, min(cur, RESIDUE(u, e->dst)));\n    if (f > 0) {\n      flow[u][e->dst] += f; flow[e->dst][u] -= f;\n      finished[u] = false;\n      return f;\n    }\n  }\n  return 0;\n}\nWeight maximumFlow(const Graph &g, int s, int t) {\n  int n = g.size();\n  Matrix flow,capacity;\n  REP(u,n) FOR(e,g[u]) capacity[e->src][e->dst] += e->weight;\n\n  Weight total = 0;\n  for (bool cont = true; cont; ) {\n    cont = false;\n    vector<int> level(n, -1); level[s] = 0; // make layered network\n    queue<int> Q; Q.push(s);\n    for (int d = n; !Q.empty() && level[Q.front()] < d; ) {\n      int u = Q.front(); Q.pop();\n      if (u == t) d = level[u];\n      FOR(e, g[u]) if (RESIDUE(u,e->dst) > 0 && level[e->dst] == -1)\n        Q.push(e->dst), level[e->dst] = level[u] + 1;\n    }\n    vector<bool> finished(n); // make blocking flows\n    for (Weight f = 1; f > 0; ) {\n      f = augment(g, capacity, flow, level, finished, s, t, INF);\n      if (f == 0) break;\n      total += f; cont = true;\n    }\n  }\n  return total;\n}\n\n\n\nint H,W,N;\n\nint in(int x){\n\treturn x;\n}\nint out(int x){\n\treturn x + N;\n}\n\nint dx[] = {-1,0,1,0};\nint dy[] = {0,1,0,-1};\n\n\nstring S[111];\n\nint main(){\n\tint H,W;\n\tcin >> H >> W;\n\tfor(int i = 0 ; i < H ; i++){\n\t\tcin >> S[i];\n\t}\n\tN = H * W;\n\n\tGraph g(2*N+2);\n\tint s = g.size() - 1;\n\tint t = g.size() - 2;\n\tfor(int i = 0 ; i < H ; i++){\n\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\tint idx1 = i * W + j;\n\t\t\tif( S[i][j] == 'X' ){\n\t\t\t\tg[s].push_back(Edge(s,in(idx1),INF));\n\t\t\t\tg[in(idx1)].push_back(Edge(in(idx1),out(idx1),INF));\n\t\t\t}else{\n\t\t\t\tg[in(idx1)].push_back(Edge(in(idx1),out(idx1),1));\n\t\t\t}\n\t\t\tfor(int d = 0 ; d < 4 ; d++){\n\t\t\t\tint ty = i + dy[d];\n\t\t\t\tint tx = j + dx[d];\n\t\t\t\tif( ty < 0 || tx < 0 || tx >= W || ty >= H ){\n\t\t\t\t\tg[out(idx1)].push_back(Edge(out(idx1),t,INF));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint idx2 = ty * W + tx;\n\n\t\t\t\tg[out(idx1)].push_back(Edge(out(idx1),in(idx2),INF));\n\n\t\t\t}\n\t\t}\n\t}\n\tint res = maximumFlow(g,s,t);\n\tif( res >= 100000 ){\n\t\tcout << -1 << endl;\n\t}else{\n\t\tcout << res << endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr,Vpr> PQ;\nconst int INF=1<<30;\nstruct Edge{\npublic:\n\tint to,cost,cp;\n\tEdge *rev;\n\tEdge(){to=0;cost=0;cp=0;}\n\tEdge(int t,int c,int cp):to(t),cost(c),cp(cp){\n\t\trev= new Edge();\n\t}\n\tvoid add(int x){\n\t\tcp+=x;\n\t}\n\tvoid flow(int amount){\n\t\tadd(-amount);\n\t\trev->add(amount);\n\t}\n\tbool usable(){\n\t\treturn cp>=1;\n\t}\t\n};\nvoid unite(Edge &a,Edge &b){\n\ta.rev=&b;\n\tb.rev=&a;\n}\nclass Graph{\n\tint nodeSize,edgeSize;\n\tvector<int> dist;\n\tvector<vector<Edge> > edges;\npublic: \n\tvoid add(int a,int b,int cost,int cp){\n\t\tedges[a].PB(Edge(b,cost,cp));\n\t\tedges[b].PB(Edge(a,cost,0));\n\t\tunite(edges[a].back(),edges[b].back());\n\t}\n\tGraph(){}\n\tGraph(int x):nodeSize(x){\n\t\t\n\t\tedges=vector<vector<Edge> >(nodeSize);\n\t\tdist=VI(nodeSize);\n\t}\n\tvoid distInit(int s){\n\t\tREP(i,nodeSize){\n\t\t\tdist[i]=INF;\n\t\t}\n\t\n\t\tdist[s]=0;\n\t}\n\tint searching(int now,int e,int capacity){\n\t\tif(capacity==0) return 0;\n\t\tif(now==e) return capacity;\n\t\tif(dist[now]>=dist[e]) return 0;\n\t\tint flowed=0;\n\t\tREP(i,edges[now].size()){\n\t\t\tEdge *ed= &edges[now][i];\n\t\t\tif(!ed->usable()) continue;\n\t\t\tif(dist[now]+1 != dist[ed->to]) continue;\n\t\t\tint nflow=searching(ed->to,e,min(capacity-flowed,ed->cp));\n\t\t\tif(nflow){\n\t\t\t\tflowed+=nflow;\n\t\t\t\ted->flow(nflow);\n\t\t\t}\n\t\t\t//if(flowed) return flowed;\n\t\t}\n\t\treturn flowed;\n\t}\n\tbool bfs(int s,int e){\n\t\tdistInit(s);\n\t\tqueue<int> qu;\n\t\tqu.push(s);\n\t\twhile(!qu.empty()){\n\t\t\tint now=qu.front();\n\t\t\tif(now==e) return true;\n\t\t\tqu.pop();\n\t\t\tREP(i,edges[now].size()){\n\t\t\t\tEdge *ed= &edges[now][i];\n\t\t\t\tif(!ed->usable()) continue;\n\t\t\t\tif(dist[ed->to]==INF){\n\t\t\t\t\tqu.push(ed->to);\n\t\t\t\t\tdist[ed->to]=dist[now]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint maximumFlow(int s,int e){\n\t\tint ans=0;\n\t\twhile(bfs(s,e)){\n\t\t\tans+=searching(s,e,INF);\n\t\t}\n\t\treturn ans;\n\t}\n};\nconst int SIZE=101;\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\nint H,W;\nint maps[101][101];\nGraph graph;\nint conv(int a,int b,int c){return a*H+b+H*W*c+2;}\nbool isSafe(int y,int x){\n\treturn 0<=y && y<H && 0<=x && x<W;\n}\nint main(){\n\tcin >> H >> W;\n\tgraph=Graph(H*W*3+2);\n\tREP(i,H) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,s.size()){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(maps[i][j] &&(i==0 || j==0 || i==H-1 || j==W-1)){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\t\t\n\t}\n\tREP(i,H) REP(j,W) {\n\t\tgraph.add(conv(i,j,1),conv(i,j,0),0,1);\n//\t\tedges[conv(i,j,1)].PB(edge(conv(i,j,0),0,1));\n\t\tif(maps[i][j]){\n\t\t\t//edges[0].PB(edge(conv(i,j,1),0,1));\n\t\t\tgraph.add(0,conv(i,j,0),0,4);\n\t\t}\n\t\tREP(k,4){\n\t\t\tif(!isSafe(i+dy[k],j+dx[k])){\n\t\t\tgraph.add(conv(i,j,0),1,0,1);\n\t\t\t//\tedges[conv(i,j,0)].PB(edge(1,0,1));\n\t\t\t} \n\t\t\telse if(!maps[i+dy[k]][j+dx[k]]){\n\t\t\t\tgraph.add(conv(i,j,0),conv(i+dy[k],j+dx[k],1),0,1);\n\t\t\t\tgraph.add(conv(i+dy[k],j+dx[k],0),conv(i,j,1),0,1);\n//\t\t\t\tedges[conv(i,j,0)].PB(edge(conv(i+dy[k],j+dx[k],1),0,1));\n//\t\t\t\tedges[conv(i+dy[k],j+dx[k],0)].PB(edge(conv(i,j,1),0,1));\n\t\t\t}\n\t\t}\n\t\n\t}\n\tcout << graph.maximumFlow(0,1) << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nint H, W;\nstring b[100];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nvoid dfs(int x, int y) {\n\tif(b[y][x] == '#') {\n\t\tb[y][x] = '$';\n\t\treturn;\n\t}\n\tif(b[y][x] != '.') return;\n\tb[y][x] = '@';\n\tfor(int k = 0; k < 4; k++) {\n\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\tif(in(nx, ny)) {\n\t\t\tif(b[ny][nx] == '#') b[ny][nx] = '$';\n\t\t\tif(b[ny][nx] == '.') dfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++) {\n\t\tcin >> b[i];\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\tif(b[i][0] == 'X' || b[i][W - 1] == 'X') {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = 0; i < W; i++) {\n\t\tif(b[0][i] == 'X' || b[H - 1][i] == 'X') {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor(int y = 0; y < H - 2; y++) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(x + 2 < W && b[y][x] == 'X' && b[y][x + 1] == 'X' && b[y][x + 2] == 'X') {\n\t\t\t\tb[y + 1][x + 1] = 'X';\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor(int x = 0; x < W - 2; x++) {\n\t\tfor(int y = 0; y < H; y++) {\n\t\t\tif(y + 2 < H && b[y][x] == 'X' && b[y + 1][x] == 'X' && b[y + 2][x] == 'X') {\n\t\t\t\tb[y + 1][x + 1] = 'X';\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int y = H - 1; y >= 2; y--) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(x + 2 < W && b[y][x] == 'X' && b[y][x + 1] == 'X' && b[y][x + 2] == 'X') {\n\t\t\t\tb[y - 1][x + 1] = 'X';\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int x = W - 1; x >= 2; x--) {\n\t\tfor(int y = 0; y < H; y++) {\n\t\t\tif(y + 2 < H && b[y][x] == 'X' && b[y + 1][x] == 'X' && b[y + 2][x] == 'X') {\n\t\t\t\tb[y + 1][x - 1] = 'X';\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\t//cout << b[i] << endl;\n\t}\n\n\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(b[y][x] == 'X') {\n\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\tif(b[ny][nx] == '.') b[ny][nx] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\tdfs(0, i);\n\t\tdfs(W - 1, i);\n\t}\n\tfor(int i = 0; i < W; i++) {\n\t\tdfs(i, 0);\n\t\tdfs(i, H - 1);\n\t}\n\n\n\tint ans = 0;\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(b[y][x] == '$') ans++;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nint m;\nstring a[123];\nbool used[123][123];\nbool was[123][123];\n\nvoid dfs(int x, int y) {\n  if (x < 0 || x >= n || y < 0 || y >= m) return;\n  if (was[x][y]) return;\n  was[x][y] = true;\n  if (used[x][y]) return;\n  for (int dx = -1; dx <= 1; ++dx) {\n    for (int dy = -1; dy <= 1; ++dy) {\n      if (abs(dx) + abs(dy) == 1) {\n        dfs(x + dx, y + dy);\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> m;\n  int xa = 123, xb = -123;\n  int ya = 123, yb = -123;\n  for (int x = 0; x < n; ++x) {\n    cin >> a[x];\n    for (int y = 0; y < m; ++y) {\n      if (a[x][y] == 'X') {\n        if (x == 0 || x == n - 1 || y == 0 || y == m - 1) {\n          cout << \"-1\" << endl;\n          return 0;\n        }\n        xa = min(xa, x);\n        xb = max(xb, x);\n        ya = min(ya, y);\n        yb = max(yb, y);\n      }\n    }\n  }\n  for (int x = 0; x < n; ++x) {\n    for (int y = 0; y < m; ++y) {\n      if (a[x][y] == '.') continue;\n      for (int dx = -1; dx <= 1; ++dx) {\n        for (int dy = -1; dy <= 1; ++dy) {\n          if (abs(dx) + abs(dy) != 1) continue;\n          int nx = x + dx;\n          int ny = y + dy;\n          if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;\n          used[nx][ny] = true;\n        }\n      }\n    }\n  }\n  for (int x = 0; x < n; ++x) {\n    dfs(x, 0);\n    dfs(x, m - 1);\n  }\n  for (int y = 0; y < m; ++y) {\n    dfs(0, y);\n    dfs(n - 1, y);\n  }\n  int ans = 0;\n  for (int x = 0; x < n; ++x) {\n    for (int y = 0; y < m; ++y) {\n      if (used[x][y] && was[x][y]) {\n        ++ans;\n      }\n    }\n  }\n  cout << min(ans, 2 * (xb - xa + 1) + 2 * (yb - ya + 1)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nconst int INF = 830252521;\ntypedef int flow_type;\n// Dinic http://www.prefield.com/algorithm/graph/dinic.html\nstruct dinic{\n  struct edge{int from,to;flow_type cost;edge *rev;};\n  int n;\n  vector< vector<edge> > G;\n  vector< vector<edge> > C;\n  // vector< vector<flow_type> > flow, capacity;\n// #define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n  vi level;\n  vector<bool> finished;\n  dinic(int _n){\n    n = _n;\n    G.assign(n,vector<edge>());\n    // flow.assign(n,vector<flow_type>(n,0));\n    // capacity.assign(n,vector<flow_type>(n,0));\n    level.assign(n,0);\n    finished.assign(n,false);\n  }\n  void add_edge(int from,int to,flow_type cost){\n    assert(0<=from && from<n);\n    assert(0<=to && to<n);\n    edge s = (edge){from,to,cost,NULL};\n    G[from].push_back(s);\n  }\n  flow_type dfs(int u, int t, flow_type cur){\n    if(u==t || cur==0) return cur;\n    if(finished[u]) return 0;\n    finished[u] = true;\n    REP(i,C[u].size()){\n      edge &e = C[u][i];\n      if(level[e.to] > level[u]){\n        flow_type f = dfs(e.to, t, min(cur, e.cost));\n        if(f>0){\n          e.cost -= f;\n          e.rev->cost += f;\n          finished[u] = false;\n          return f;\n        }\n      }\n    }\n    return 0;\n  }\n  flow_type calc(int s, int t){\n    C.assign(n,vector<edge>());\n    REP(i,n)REP(j,G[i].size()){\n      edge s = G[i][j];\n      int from = s.from;\n      int to = s.to;\n      edge t = (edge){to,from,0,&s};\n      s.rev = &t;\n      C[from].push_back(s);\n      C[to].push_back(t);\n    }\n    flow_type total = 0;\n    while(true){\n      REP(i,n)level[i] = -1;\n      level[s] = 0;\n      queue<int> Q; Q.push(s);\n      int d = n;\n      while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        REP(i,C[u].size()){\n          edge e = C[u][i];\n          if(e.cost > 0 && level[e.to] == -1){\n            Q.push(e.to);\n            level[e.to] = level[u] + 1;\n          }\n        }\n      }\n      REP(i,n)finished[i]=false;\n      bool flag = false;\n      while(true){\n        flow_type f = dfs(s,t,INF);\n        if(f==0)break;\n        total += f;\n        flag = true;\n      }\n      if(!flag)break;\n    }\n    return total;\n  }\n};\n\nint h,w;\nchar mp[125][125];\nint dd[] = {1,0,-1,0,1};\n\nint main(){\n  scanf(\"%d%d\",&h,&w);\n  REP(i,h)scanf(\"%s\",mp[i]);\n  // flow\n  dinic g(2*h*w+2);\n  int s=2*h*w;\n  int t=2*h*w+1;\n  REP(i,h)REP(j,w){\n    int id = i*w + j;\n    int x=2*id,y=2*id+1;\n    if(mp[i][j]=='X'){\n      if(i==0||i==h-1||j==0||j==w-1){\n        puts(\"-1\");\n        return 0;\n      }\n      g.add_edge(s,x,INF);\n      g.add_edge(x,y,INF);\n    }else{\n      g.add_edge(x,y,1);\n    }\n    if(i==0||i==h-1||j==0||j==w-1){\n      g.add_edge(y,t,INF);\n    }\n    REP(d,4){\n      int ni=i+dd[d],nj=j+dd[d+1];\n      if(ni<0||ni>=h||nj<0||nj>=w)continue;\n      int nid = ni*w + nj;\n      g.add_edge(y,2*nid,INF);\n    }\n  }\n  printf(\"%d\\n\",g.calc(s,t));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int H_MAX = 100;\nconst int W_MAX = 100;\nconst int INF = 1000000;\n\nstruct edge{\n    int to, cap, rev;\n    edge(int t, int c, int r): to(t), cap(c), rev(r){}\n};\n\nvector<edge> G[2 * W_MAX * H_MAX  +5];\nbool used[2 * W_MAX * H_MAX + 5];\n\nvoid add_edge(int from, int to, int cap){\n    G[from].emplace_back(to, cap, G[to].size());\n    G[to].emplace_back(from, 0, G[from].size()-1);\n}\n\nint dfs(int v, int t, int f){\n    if (v == t) return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        edge &e = G[v][i];\n        if (!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t){\n    int flow = 0;\n    for(;;){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main(){\n    int h, w;\n    cin >> h >> w;\n    int s = 2 * h * w;\n    int t = 2 * h * w + 1;\n\n    for(int i = 0; i < h; i++){\n        char S[W_MAX + 5];\n        cin >> S;\n        for(int j = 0; j < w; j++){\n            if (S[j] == 'X') add_edge(s, w * i + j + w * h, INF);\n            add_edge(w * i + j, w * i + j + w * h, 1);\n            if (i < h-1){\n                add_edge(w * i + j + w * h, w * (i+1) + j, INF);\n                add_edge(w * (i+1) + j + w * h, w * i + j, INF);\n            }\n            if (j < w-1){\n                add_edge(w * i + j + w * h, w * i + (j+1), INF);\n                add_edge(w * i + (j+1) + w * h, w * i + j, INF);\n            }\n            if (i == 0 || i == h-1 || j == 0 || j == w-1){\n                add_edge(w * i + j + w * h, t, INF);\n            }\n        }\n    }\n\n    int ans = max_flow(s, t);\n    if (ans > INF / 10) ans = -1;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n\tint h, w;\n\tcin >> h >> w;\n\tchar s[105][105];\n\tfor(int i = 0; i <= h + 1; i++){\n\t\tfor(int j = 0; j <= w + 1; j++){\n\t\t\tif(i == 0 || j == 0 || i == h + 1 || j == w + 1) s[i][j] = '.';\n\t\t\telse cin >> s[i][j];\n\t\t}\n\t}\n\tfor(int i = 1; i <= h; i++){\n\t\tfor(int j = 1; j <= w; j++){\n\t\t\tif(s[i][j] == 'X'){\n\t\t\t\tif(i == 1 || j == 1 || i == h || j == w){\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(s[i - 1][j] != 'X') s[i - 1][j] = '#';\n\t\t\t\tif(s[i - 1][j] != 'X') s[i][j - 1] = '#';\n\t\t\t\tif(s[i - 1][j] != 'X') s[i + 1][j] = '#';\n\t\t\t\tif(s[i - 1][j] != 'X') s[i][j + 1] = '#';\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<bool> > ischecked(105, vector<bool>(105, false));\n\tint dx[4] = {0, 1, 0, -1};\n\tint dy[4] = {1, 0, -1, 0};\n\tint ans = 0;\n\tischecked[0][0] = true;\n\tqueue<pair<int, int> > qu;\n\tqu.push(make_pair(0, 0));\n\twhile(!qu.empty()){\n\t\tint x = (qu.front()).first;\n\t\tint y = (qu.front()).second;\n\t\tqu.pop();\n\t\tfor(int k = 0; k < 4; k++){\n\t\t\tint nx = x + dx[k];\n\t\t\tint ny = y + dy[k];\n\t\t\tif(nx < 0 || ny < 0 || nx > h + 1 || ny > w + 1 || ischecked[nx][ny]) continue;\n\t\t\tischecked[nx][ny] = true;\n\t\t\tif(s[nx][ny] == '#') ans++;\n\t\t\telse if(s[nx][ny] == '.') qu.push(make_pair(nx, ny));\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n#define MAX_V 100\n\nstruct edge{int to,cap,rev;};\n\nvector<edge> G[MAX_V];  //グラフのパス\nint level[MAX_V];       //始点からの距離\nint iter[MAX_V];        //どこまで調べたか\n\n// fromからtoへ向かう、容量capの辺をグラフに追加する\nvoid add_edge(int from,int to,int cap){\n    G[from].push_back(  (edge){ to  ,cap,(int)G[to  ].size()   }  );\n    G[to  ].push_back(  (edge){ from,0  ,(int)G[from].size()-1 }  );\n}\n\n// sからの最短距離をBFSで計算する\nvoid bfs(int s){\n    rep(i,MAX_V)level[i]=-1;\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n        int v=que.front();que.pop();\n        \n        rep(i,G[v].size()){\n            edge &e=G[v][i];\n            if(e.cap>0 && level[e.to]<0){\n                level[e.to]=level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\n//増加パスをDFSで探す\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    for(int &i=iter[v];i<G[v].size();i++){\n        edge &e=G[v][i];\n        if(e.cap>0&&level[v]<level[e.to]){\n            int d=dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n// sからtへの最大流を求める\nint max_flow(int s,int t){\n    if(s==t)return INF;\n    int flow=0;\n    for(;;){\n        bfs(s);\n        if(level[t]<0)return flow;\n        memset(iter,0,sizeof(iter));\n        int f;\n        while((f=dfs(s,t,INF))>0){\n            flow+=f;\n        }\n    }\n}\n\nint h,w;\n\nint f(int y,int x,int dim){\n    return y*w+x + dim*(h*w);\n}\n\n\nint main(){\n    cin>>h>>w;\n    int S = 2*h*w;\n    int T = 2*h*w+1;\n    vector<string> vs(h);\n    rep(i,h)cin>>vs[i];\n    rep(i,h-1){     //y軸方向にジグザクに有向辺を貼る\n        rep(j,w){\n            add_edge(f(i+1,j,1),f(i  ,j,0),INF);\n            add_edge(f(i  ,j,1),f(i+1,j,0),INF);\n        }\n    }\n    rep(i,h){     //x軸方向にジグザクに有向辺を貼る\n        rep(j,w-1){\n            add_edge(f(i,j+1,1),f(i,j  ,0),INF);\n            add_edge(f(i,j  ,1),f(i,j+1,0),INF);\n        }\n    }\n    \n    rep(i,h){\n        rep(j,w){\n            if(vs[i][j] == 'X'){\n                add_edge(S,f(i,j,0),INF);       //ヤギの居るマスにはソースから有向辺を貼る\n                add_edge(f(i,j,0),f(i,j,1),INF);//ヤギの居るマスには真下にコストINFの有向辺を貼る\n            }\n            else{\n                add_edge(f(i,j,0),f(i,j,1),1);  //ヤギの居ないマスには真下にコスト1の有向辺を貼る\n            }\n        }\n    }\n    \n    rep(i,h){               //左端の列と右端の列からシンクに有向辺を貼る\n        add_edge(f(i,0  ,1),T,INF);\n        add_edge(f(i,w-1,1),T,INF);\n    }\n    \n    for(int j=1;j<w-1;j++){ //上端の行と下端の行からシンクに有向辺を貼る\n        add_edge(f(0,j,1),  2*h*w+1,INF);\n        add_edge(f(h-1,j,1),2*h*w+1,INF);\n    }\n    \n    int res = max_flow(2*h*w,2*h*w+1);\n    if(res>=INF)cout<<-1<<endl;\n    else cout<<res<<endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n\tif(ans-9>193)return 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans-9<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\ntypedef int Weight;\ntypedef int Capacity;\nstruct Edge {\n\tint src, dst; Capacity cap;\n\tEdge(int s, int d, Capacity c) : src(s), dst(d), cap(c) {}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct Dinic {\n\tint n, s, t;\n\tvector<int> level, prog, que;\n\tvector<vector<Capacity> > cap, flow;\n\tvector<vector<int> > g;\n\tCapacity inf;\n\tDinic() {}\n\tDinic(const Graph &graph)\n\t\t: n(graph.size()),\n\t\tcap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n\t\tg(n, vector<int>()), inf((int)1e9) {\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < graph[i].size(); j++) {\n\t\t\t\tconst Edge& e = graph[i][j];\n\t\t\t\tint u = e.src, v = e.dst;\n\t\t\t\tCapacity c = e.cap;\n\t\t\t\tadd_edge(u, v, c);\n\t\t\t}\n\t\t}\n\t}\n\tDinic(int n_) : n(n_), cap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n\t\tg(n, vector<int>()), inf((int)1e9) {\n\t}\n\tvoid add_edge(int u, int v, Capacity c) {\n\t\tcap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n\t\tg[u].push_back(v); g[v].push_back(u);\n\t}\n\tvoid reset() {\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tcap[i][j] = flow[i][j] = 0;\n\t\t\t}\n\t\t\tg[i].clear();\n\t\t}\n\t}\n\tinline Capacity residue(int u, int v) { return cap[u][v] - flow[u][v]; }\n\tCapacity solve(int s_, int t_) {\n\t\tthis->t = t_, this->s = s_;\n\t\tque.resize(n + 1);\n\t\tCapacity res = 0;\n\t\twhile(levelize()) { prog.assign(n, 0); res += augment(s, inf); }\n\t\treturn res;\n\t}\n\tbool levelize() {\n\t\tint l = 0, r = 0;\n\t\tlevel.assign(n, -1); level[s] = 0; que[r++] = s;\n\t\twhile(l != r) {\n\t\t\tint v = que[l++]; if(v == t) break;\n\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\tconst int& d = g[v][i];\n\t\t\t\tif(level[d] == -1 && residue(v, d) != 0) {\n\t\t\t\t\tlevel[d] = level[v] + 1; que[r++] = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn level[t] != -1;\n\t}\n\tCapacity augment(int v, Capacity lim) {\n\t\tCapacity res = 0;\n\t\tif(v == t) return lim;\n\t\tfor(int &i = prog[v]; i < (int)g[v].size(); i++) {\n\t\t\tconst int &d = g[v][i];\n\t\t\tif(residue(v, d) == 0 || level[v] >= level[d]) continue;\n\t\t\tconst Capacity aug = augment(d, min(lim, residue(v, d)));\n\t\t\tflow[v][d] += aug; flow[d][v] -= aug;\n\t\t\tres += aug; lim -= aug;\n\t\t\tif(lim == 0) break;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint H, W;\nchar b[110][110];\nint in[110][110];\nint out[110][110];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\n\nconst int INF = 1 << 28;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++) {\n\t\tfor(int j = 0; j < W; j++) {\n\t\t\tcin >> b[i + 1][j + 1];\n\t\t}\n\t}\n\n\tH += 2, W += 2;\n\n\tint cnt = 0;\n\tfor(int i = 0; i < H; i++) {\n\t\tfor(int j = 0; j < W; j++) {\n\t\t\tin[i][j] = cnt++;\n\t\t\tout[i][j] = cnt++;\n\t\t}\n\t}\n\tint S = cnt++, T = cnt++;\n\n\tDinic d(H * W * 2 + 2);\n\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(b[y][x] == 0) {\n\t\t\t\td.add_edge(out[y][x], T, INF);\n\t\t\t\td.add_edge(in[y][x], out[y][x], INF);\n\t\t\t}\n\t\t\telse if(b[y][x] == 'X') {\n\t\t\t\td.add_edge(S, in[y][x], INF);\n\t\t\t\td.add_edge(in[y][x], out[y][x], INF);\n\t\t\t}\n\t\t\telse {\n\t\t\t\td.add_edge(in[y][x], out[y][x], 1);\n\t\t\t}\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\tif(0 <= nx && nx < W && 0 <= ny && ny < H) {\n\t\t\t\t\td.add_edge(out[y][x], in[ny][nx], INF);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = d.solve(S, T);\n\tif(ans >= INF) ans = -1;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 2e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nstruct edge { int to, cap, rev; };\n\nconst int MAX_V = 10010;\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid addEdge(int from, int to, int cap) {\n    G[from].emplace_back((edge){to, cap, (int)G[to].size()});\n    G[to].emplace_back((edge){from, 0, (int)G[from].size() - 1});\n}\n\nvoid bfs(int s) {\n    memset(level, -1, sizeof(level));\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n        int v = que.front(); que.pop();\n        for (int i = 0; i < G[v].size(); i++) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    for (int &i = iter[v]; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[v] < level[e.to]) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    for (;;) {\n        bfs(s);\n        if (level[t] < 0) return flow;\n        memset(iter, 0, sizeof(iter));\n        int f;\n        while ((f = dfs(s, t, inf)) > 0) {\n            flow += f;\n        }\n    }\n}\n\n#define dame cout << -1 << endl; return 0;\n\n// N, E, S, W\nconst int dx[4] = {-1, 0,  1,  0};\nconst int dy[4] = { 0, 1,  0, -1};\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n    vector<string> s(n);\n    rep(i, n) cin >> s[i];\n\n    rep(i, n) {\n        if (s[i][0] == 'X' || s[i].back() == 'X') {\n            dame;\n        }\n    }\n\n    rep(j, m) {\n        if (s[0][j] == 'X' || s.back()[j] == 'X') {\n            dame;\n        }\n    }\n\n    auto toNode = [&](int i, int j) {\n        return i * m + j;\n    };\n\n    auto inside = [&](int i, int j) {\n        return 0 <= i && i < n && 0 <= j && j < m;\n    };\n\n    const int src = n * m;\n    const int fin = n * m + 1;\n    rep(i, n) {\n        rep(j, m) {\n            if (s[i][j] == 'X') {\n                addEdge(src, toNode(i, j), inf);\n            }\n            bool flag = false;\n            rep(k, 4) {\n                int ni = i + dx[k], nj = j + dy[k];\n                if (inside(ni, nj)) {\n                    addEdge(toNode(i, j), toNode(ni, nj), 1);\n                    addEdge(toNode(ni, nj), toNode(i, j), 1);\n                }\n                else if (!flag) {\n                    addEdge(toNode(i, j), fin, 1);\n                    flag = true;\n                }\n            }\n        }\n    }\n\n    cout << max_flow(src, fin) / 2 << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n\nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n\nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n\ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size())mk();\n\t\tif(hit==q.size()<<1)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n\nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n//\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n//\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Network{\n\tprivate:\n\tint V;\n\tstruct edge{\n\t\tint to,cap,rev;\n\t};\n\tvector<vector<edge> > List;\n\tint DFSplus(int v,int t,int f,vi& iter,vi level){\n\t\tif(v==t) return f;\n\t\tfor(int &i=iter[v];i<List[v].size();i++){\n\t\t\tedge &e=List[v][i];\n\t\t\tif(e.cap>0&&level[v]<level[e.to]){\n\t\t\t\tint d=DFSplus(e.to,t,min(f,e.cap),iter,level);\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tList[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid BFSplus(int s,vi& level){\n\t\tlevel=vi(V,-1);\n\t\tqueue<int> que;\n\t\tlevel[s]=0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<List[v].size();i++){\n\t\t\t\tedge &e=List[v][i];\n\t\t\t\tif(e.cap>0&&level[e.to]<0){\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic:\n\tNetwork(int v){\n\t\tV=v;\n\t\tList=vector<vector<edge> >(v);\n\t}\n\tvoid add_edge(int s,int t,int c){\n\t\tList[s].push_back(edge{t,c,(int)List[t].size()});\n\t\tList[t].push_back(edge{s,0,(int)List[s].size()-1});\n\t}\n\tint MFplus(int s,int t){\n\t\tint ans=0;\n\t\twhile(1){\n\t\t\tvi iter(V),level;\n\t\t\tBFSplus(s,level);\n\t\t\tif(level[t]<0) return ans;\n\t\t\tint f;\n\t\t\twhile((f=DFSplus(s,t,inf,iter,level))>0) ans+=f;\n\t\t}\n\t}\n};\n\nint h,w;\nvvc a;\n\ninline int f(int x,int y){\n\treturn x*h+y;\n}\n\nint main(){\n\tcin>>h>>w;\n\ta=vvc(h,vc(w));\n\tNetwork nt(2*h*w+2);\n\tbool flag=1;\n\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++){\n\t\tcin>>a[i][j];\n\t\tif(a[i][j]=='X') nt.add_edge(2*h*w,h*w+f(i,j),inf);\n\t\telse nt.add_edge(f(i,j),h*w+f(i,j),1);\n\t\tif(!i||i==h-1||!j||j==w-1){\n\t\t\tnt.add_edge(h*w+f(i,j),2*h*w+1,inf);\n\t\t\tif(a[i][j]=='X') flag=0;\n\t\t}\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint x=i+dx[k],y=j+dy[k];\n\t\t\tif(x>=0&&x<h&&y>=0&&y<w) nt.add_edge(h*w+f(i,j),f(x,y),inf);\n\t\t}\n\t}\n\tif(!flag){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tcout<<nt.MFplus(2*h*w,2*h*w+1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n\tif(ans-9>190)return 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans-9<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n\nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n\nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n\ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size())mk();\n\t\tif(hit==q.size()<<1)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n\nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,4){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==4){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,4){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==4){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<fr[i][j];\n//\t\tcout<<endl;\n//\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Network{\n\tprivate:\n\tint V;\n\tstruct edge{\n\t\tint to,cap,rev;\n\t};\n\tvector<vector<edge> > List;\n\tint DFS(int v,int t,int f,vb& used){\n\t\tif(v==t) return f;\n\t\tused[v]=1;\n\t\tfor(int i=0;i<List[v].size();i++){\n\t\t\tedge &e=List[v][i];\n\t\t\tif(!used[e.to]&&e.cap>0){\n\t\t\t\tint d=DFS(e.to,t,min(f,e.cap),used);\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tList[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tpublic:\n\tNetwork(int v){\n\t\tV=v;\n\t\tList=vector<vector<edge> >(v);\n\t}\n\tvoid add_edge(int s,int t,int c){\n\t\tList[s].push_back(edge{t,c,(int)List[t].size()});\n\t\tList[t].push_back(edge{s,0,(int)List[s].size()-1});\n\t}\n\tint MF(int s,int t){\n\t\tint ans=0;\n\t\twhile(1){\n\t\t\tvb used(V);\n\t\t\tint f=DFS(s,t,inf,used);\n\t\t\tif(f==0) return ans;\n\t\t\tans+=f;\n\t\t}\n\t}\n};\n\nint h,w;\nvvc a;\n\ninline int f(int x,int y){\n\treturn x*w+y;\n}\n\nint main(){\n\tcin>>h>>w;\n\ta=vvc(h,vc(w));\n\tNetwork nt(2*h*w+2);\n\tbool flag=1;\n\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++){\n\t\tcin>>a[i][j];\n\t\tif(a[i][j]=='X') nt.add_edge(2*h*w,h*w+f(i,j),inf);\n\t\telse nt.add_edge(f(i,j),h*w+f(i,j),1);\n\t\tif(!i||i==h-1||!j||j==w-1){\n\t\t\tnt.add_edge(h*w+f(i,j),2*h*w+1,inf);\n\t\t\tif(a[i][j]=='X') flag=0;\n\t\t}\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint x=i+dx[k],y=j+dy[k];\n\t\t\tif(x>=0&&x<h&&y>=0&&y<w) nt.add_edge(h*w+f(i,j),f(x,y),inf);\n\t\t}\n\t}\n\tif(!flag){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tcout<<nt.MF(2*h*w,2*h*w+1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int iinf = 0x7fffffff;\nconst ll linf = ~(1LL<<63);\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef map<ll, int> mli;\ntypedef map<ll, ll> mll;\ntemplate<typename T>\ninline T gcd(T a, T b) {\n\tif(a < 0) return gcd(-a, b);\n\tif(b < 0) return gcd( a,-b);\n\tif(a < b) return gcd(b, a);\n\tif(b == 0) return a;\n\treturn gcd(b, a%b);\n}\n\nll qpow(ll a, ll n, ll mod) {\n\ta %= mod;\n\tll ans = 1LL;\n\twhile(n) {\n\t\tif(n & 1) ans = (ans*a % mod);\n\t\ta = (a*a % mod);\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\n\n// unsigned\nll qmul(ll a, ll b, ll mod) {\n\ta %= mod;\n\tb %= mod;\n\tll ans = 0LL;\n\twhile(b) {\n\t\tif(b & 1) ans = (ans+a) % mod;\n\t\ta = (a<<1) % mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\ninline ll rev(ll a, ll p) {\n\treturn qpow(a, p - 2, p);\n}\n\n\n#define all(v) v.begin(), v.end()\n#define sz(v) v.size()\n#define rep(x, st, en) for(int x = st; x < en; x++)\n#define pb push_back\n#define mp make_pair\n#define dbgm(msg, var) cerr<<#msg<<\" \"<<#var<<\" = \"<<var<<endl; \n#define dbg(var) cerr<<#var<<\" = \"<<var<<endl;\n#ifdef ALNDBG\nclock_t s, e;\n#endif\n\ninline void tic() {\n#ifdef ALNDBG\n\ts = clock();\n#endif\n}\n\ninline void toc() {\n#ifdef ALNDBG\n\te = clock();\n\tcerr<<1000.0 * (e - s) / CLOCKS_PER_SEC<<\" ms\"<<endl;\n#endif\n}\n\n// -------------------- Spliters ------------------------\nconst int maxn = 102;\n\nchar m[maxn][maxn];\n\nint N, M;\n\nint dx[4] = { 0, 1, 0, -1 };\nint dy[4] = { -1, 0, 1, 0 };\n\nbool ok(int x, int y) {\n\treturn 0 <= x && x < N && 0 <= y && y < M;\n}\n\ntypedef long long T;\nconst double eps = 1e-8;\nstruct Point {\n\tvoid print() {\n\t\tcerr<<\"(\"<<x<<\", \"<<y<<\")\"<<endl;\n\t}\n\tT x, y;\n\tPoint(T _x = 0, T _y = 0) : x(_x), y(_y) {}\n\n\tPoint operator-(const Point& b) const {\n\t\treturn Point(x - b.x, y - b.y);\n\t}\n\tPoint operator+(const Point& b) const {\n\t\treturn Point(x + b.x, y + b.y);\n\t}\n\tdouble operator^(const Point& b) const {\n\t\treturn x * b.y - y * b.x;\n\t}\n\tdouble operator*(const Point& b) const {\n\t\treturn x * b.x + y * b.y;\n\t}\n};\n\nll cross(const Point& a, const Point& b, const Point& c) {\n\treturn (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x -  a.x);\n}\n\n\nvector<Point> convexHull(vector<Point>& p) {\n\tint n = p.size();\n\tif(n <= 1) return p;\n\tsort(p.begin(), p.end(), [](const Point& a, const Point& b) -> bool {\n\t\t\treturn a.x != b.x ? a.x < b.x : a.y < b.y;\n\t\t\t});\n\tvector<Point> q = vector<Point>(n * 2);\n\tint cnt = 0;\n\tfor(int i = 0; i < n; q[cnt++] = p[i++])\n\t\tfor(; cnt > 1 && cross(q[cnt - 2], q[cnt - 1], p[i]) >= 0; --cnt);\n\tfor(int i = n - 2, t = cnt; i >= 0; q[cnt++] = p[i--])\n\t\tfor(; cnt > t && cross(q[cnt - 2], q[cnt - 1], p[i]) >= 0; --cnt);\n\tint sz = cnt - 1 - (q[0].x == q[1].x && q[0].y == q[1].y ? 1 : 0);\n\treturn vector<Point>(q.begin(), q.begin() + sz);\n}\n\nvector<Point> pts;\nvector<Point> ch;\n\nvoid fillx(Point& u, Point& v) {\n\tint l = min(u.x, v.x), r = max(u.x, v.x);\n\tdouble k = 1.0 * (v.y - u.y) / (v.x - u.x);\n\trep(i, l, r + 1) {\n\t\tint y = ceil(k * (i - u.x) + u.y);\n\t\tif(m[i][y] == 'X') y -= 1;\n\t\tm[i][y] = '*';\n\t}\n}\n\nvoid filly(Point& u, Point& v) {\n\tint l = min(u.y, v.y), r = max(u.y, v.y);\n\tdouble k = 1.0 * (v.x - u.x) / (v.y - u.y);\n\trep(i, l, r + 1) {\n\t\tint x = ceil(k * (i - u.y) + u.x);\n\t\tif(m[x][i] == 'X') x -= 1;\n\t\tm[x][i] = '*';\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin>>N>>M;\n\trep(i, 0, N) cin>>m[i];\n\trep(i, 0, N) {\n\t\trep(j, 0, M) {\n\t\t\tif(m[i][j] == 'X') {\n\t\t\t\trep(k, 0, 4) {\n\t\t\t\t\tint x = i + dx[k];\n\t\t\t\t\tint y = j + dy[k];\n\t\t\t\t\tif(!ok(x, y)) { puts(\"-1\"); return 0; }\n\t\t\t\t\tpts.pb({x, y});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tch = convexHull(pts);\n\tfor(auto& p : ch) {\n\t\tm[p.x][p.y] = '*';\n\t}\n\tfor(int r = 0; r < ch.size(); r++) {\n\t\tint i = r, j = r + 1;\n\t\tif(j >= ch.size()) j = 0;\n\t\tint xdir = ch[j].x - ch[i].x;\n\t\tint ydir = ch[j].y - ch[i].y;\n\t\tif(abs(xdir) >= abs(ydir)) {\n\t\t\tfillx(ch[i], ch[j]);\n\t\t} else {\n\t\t\tfilly(ch[i], ch[j]);\n\t\t}\n\t}\n\tll ans = 0;\n\trep(i, 0, N) rep(j, 0, M) {\n\t\tif(m[i][j] == '*') ans++;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n// --USE C++11\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst int N = 100;\nstring s[N + 5];\nint mark[N + 5][N + 5];\nint red[N + 5][N + 5];\n\nint py[] = {1,0,-1,0};\nint px[] = {0,1,0,-1};\n\nvoid hora(int tc) {\n\tint r,c;\n\tcin>>r>>c;\n\tfor(int i = 0;i < r;i++) cin>>s[i];\n\tfor(int i = 0;i < r;i++){\n\t\tif(s[i][0] == 'X' || s[i][c - 1] == 'X') {\n\t\t\tcout<<\"-1\"<<endl;\n\t\t\treturn ;\n\t\t}\n\t}\n\tfor(int i = 0;i < c;i++){\n\t\tif(s[0][i] == 'X' || s[r - 1][c] == 'X') {\n\t\t\tcout<<\"-1\"<<endl;\n\t\t\treturn ;\n\t\t}\n\t}\n\tfor(int i = 1;i < r - 1;i++) {\n\t\tfor(int j = 1;j < c - 1;j++) {\n\t\t\tif(s[i][j] == 'X') {\n\t\t\t\tfor(int k = 0;k < 4;k++) {\n\t\t\t\t\tint ny = i + py[k];\n\t\t\t\t\tint nx = j + px[k];\n\t\t\t\t\tif(s[ny][nx] == 'X') continue;\n\t\t\t\t\tmark[ny][nx] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint tot = 0;\n\tfor(int i = 0;i < r;i++) {\n\t\tfor(int j = 0;j < c;j++) {\n\t\t\tif(mark[i][j] == 1) {\n\t\t\t\tbool stay = false;\n\t\t\t\tif(i  == 0 || i == r - 1 || j == 0 || j == c - 1) stay = true;\n\t\t\t\telse {\n\t\t\t\t\tfor(int k = 0;k < 4;k++) {\n\t\t\t\t\t\tint ny = i + py[k];\n\t\t\t\t\t\tint nx = j + px[k];\n\t\t\t\t\t\telse if(s[ny][nx] == '.' && mark[ny][nx] == 0) stay = true;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(stay == true) tot++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<tot<<endl;\n}\n\nint main(){\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 105\n#define M 51\n#define INF 1000000007\n#define MOD 924844033\n#define MOD2 1000000009\n#define eps 1e-14\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,1,-1};\nstruct node\n{\n    int a,b,x,y;\n}edge[20*N*N];\nvector<int>e[20*N*N];\nint a[N][N],b[N][N],d[20*N*N];\nint bg,ed,cnt;\n\nbool bfs(int s)\n{\n       int front=0,rear=0;\n       int q[N];\n       memset(d,-1,sizeof(d));\n       q[rear++]=s;\n       d[s]=0;\n       while(front<rear)\n       {\n               int k=q[front++];\n               for(auto v:e[k])\n               {\n                   int a = edge[v].a,b = edge[v].b;\n                   int x = edge[v].x,y = edge[v].y;\n                   int flow,to;\n                   if(a == k)flow = x,to = b;\n                   else flow = y,to = a;\n                   if(flow>0&&d[to]==-1)\n                   {\n                       d[to]=d[k]+1;\n                       q[rear++]=to;\n                   }\n               }\n       }\n       if(d[ed]>=0)\n             return true;\n       return false;\n}\n\nint dinic(int k,int sum)  //k is the sourse\n{\n      if (k==ed)\n          return sum;\n      int os = sum;\n      for(auto v:e[k])\n      {\n          if(sum<=0)break;\n          int a = edge[v].a,b = edge[v].b;\n           int x = edge[v].x,y = edge[v].y;\n           int flow,to;\n           if(a == k)flow = x,to = b;\n           else flow = y,to = a;\n          if(d[to]==d[k]+1&&flow>0)\n          {\n                int tmp = dinic(to,min(sum,flow)); //Deep to the end.\n                if(a == k)\n                {\n                    edge[v].x -= tmp;\n                    edge[v].y += tmp;\n                }\n                else\n                {\n                    edge[v].y -= tmp;\n                    edge[v].x += tmp;\n                }\n                sum -= tmp;\n          }\n      }\n      return os-sum;\n}\n\nvoid addedge(int a,int b,int w)\n{\n    edge[++cnt].a = a;\n    edge[cnt].b = b;\n    edge[cnt].x = w;\n    edge[cnt].y = 0;\n    e[a].PB(cnt);\n    e[b].PB(cnt);\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    while(cin>>n>>m)\n    {\n        cnt = 0;\n        bg = 1,ed = n*m*2+1;\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                a[i][j] = i*m+j;\n                b[i][j] = i*m+j+n*m;\n            }\n        }\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                char c;\n                cin>>c;\n                if(c == 'X')\n                {\n                    addedge(a[i][j],b[i][j],INF);\n                    addedge(1,a[i][j],INF);\n                }\n                else addedge(a[i][j],b[i][j],1);\n            }\n        }\n        FOR(i,1,n)\n        {\n            addedge(b[i][1],ed,INF);\n            addedge(b[i][m],ed,INF);\n            FOR(j,1,m-1)addedge(b[i][j],a[i][j+1],INF);;\n            FOR(j,2,m)addedge(b[i][j],a[i][j-1],INF);\n        }\n        FOR(j,1,m)\n        {\n            addedge(b[1][j],ed,INF);\n            addedge(b[n][j],ed,INF);\n            FOR(i,1,n-1)addedge(b[i][j],a[i+1][j],INF);\n            FOR(i,2,n)addedge(b[i][j],a[i-1][j],INF);\n        }\n        int ret = 0;\n        while(bfs(bg))\n            ret += dinic(bg,INF);\n        if(ret == INF)cout<<-1<<endl;\n        else cout<<ret<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<ut,VI> PQ;\nclass UnionFind{\n \n\tvector<int> unions,talls,sents,dists,sizes;\n\tint size;\npublic:\n\tUnionFind(){}\n\tUnionFind(int size):size(size){\n\t\tinit();\n\t}\n\tvoid init(){\n\t \tunions=vector<int>(size);\n\t \ttalls=vector<int>(size);\n\t \tsents=vector<int>(size);\n\t \tdists=vector<int>(size);\n\t \tsizes=vector<int>(size);\n\t\tFOR(i,0,size){\n\t\t\tunions[i]=i;\n\t\t\tsents[i]=0;\n\t\t\tsizes[i]=1;\n//\t\t\tns[i].PB(pr(0,1));\n\t\t\ttalls[i]=1;\n\t\t}\n\t}\n\tint find(int x,int t=0){\n\t\tif(unions[x]==x || sents[x]>t) return x;\n\t\treturn find(unions[x],t);\n \n\t}\n\tint minisize(int x){\n\t\tif(x==unions[x]) return sizes[x];\n\t\treturn minisize(find(x));\n\t}\n\tbool isFriend(int a,int b,int t=0){\n\t\treturn find(a,t)==find(b,t);\t\n\t}\n\tvoid unite(int a,int b,int t=0){\n\t\tif(isFriend(a,b,t)) return;\n\t\ta=find(a,t);\n\t\tb=find(b,t);\n\t\tif(talls[a]<talls[b]) unite(b,a,t);\n\t\telse{\n \t\t\tsizes[a]+=sizes[b];\n\t\t\tsents[b]=t;\n\t\t\ttalls[a]=max(talls[a],talls[b]+1);\n\t\t\tunions[b]=a;\n\t\t\tdists[b]=1;\n//\t\t\tns[a].PB(pr(t,ns[b].back().second+ns[a].back().second));\n\t\t}\n\t}\n};\nUnionFind uf;\nconst ut INF=1LL<<30;\nconst int SIZE=201;\nint maps[SIZE][SIZE];\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\ncli d[4];\nbool searched[SIZE][SIZE][3];\nint H,W;\nint conv(cli x){\n\treturn x.real()*1000+x.imag()+10000;\n}\nint solve(){\n\tREP(i,4) d[i]=cli(dy[i],dx[i]);\n\t\n\tcin >> H >> W;\n\tqueue<cli> qu;\n\tREP(i,H){\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,W){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(i==0 or j==0 or i==H-1 or j==W-1) {\n\t\t\t\tif(maps[i][j]) return -1;\n\t\t\t\tmaps[i][j]=-1;\n\t\t\t\tqu.push(cli(j,i));\n\t\t\t}\n\t\t}\n\t}\n\twhile(!qu.empty()){\n\t\tcli now=qu.front();\n\t\tqu.pop();\n\t\t\n\t\t//if(maps[now.imag()][now.real()]==1) count++;\n\t\t//if(count==1e7) return -1;\n\t\tif(maps[now.imag()][now.real()]==-1){\n\t\t\tint around=0;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(next.imag()==-1 or next.real()==-1 or next.imag()==H or next.real()==W) continue;\n\t\t\t\tif(maps[next.imag()][next.real()]==1) around+=2;\n\t\t\t\tif(maps[next.imag()][next.real()]==0) {\n\t\t\t\t\tqu.push(next);\n\t\t\t\t\taround++; \n\t\t\t\t}\n\t\t\t}\n\t\t\tif(around<=1){\n\t\t\t\tmaps[now.imag()][now.real()]=2;\n\t\t\t\tREP(i,4){\n\t\t\t\t\tcli next=now+d[i];\n\t\t\t\t\tif(next.imag()==-1 or next.real()==-1 or next.imag()==H or next.real()==W) continue;\n\t\t\t\t\tif(maps[next.imag()][next.real()]==0){\n\t\t\t\t\t\tmaps[next.imag()][next.real()]=-1;\n\t\t\t\t\t} \n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t\telse if(maps[now.imag()][now.real()]==0){\n\t\t\tint around=0;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) continue;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]==-1) around++;\n\t\t\t}\n\t\t\tif(around>=4){\n\t\t\t\tmaps[now.imag()][now.real()]=2;\n\t\t\t\tqu.push(now);\n\t\t\t}\n\t\t}\t\t\n\t}\n\tint ans=0;\n\tREP(i,H){\n\t\tREP(j,W){\n\t\t//\tcout << maps[i][j]+1;\n\t\t\tans+=maps[i][j]==-1;\n\t\t}\n\t\t//cout << endl;\n\t}\n\treturn ans;\n}\n\nint solve2(){\n\tuf=UnionFind(200000);\n\n\tqueue<cli> qu;\n\tREP(i,H){\n\t\tREP(j,W){\n\t\t\tmaps[i][j]=maps[i][j]==1;\n\t\t\tif(maps[i][j]) qu.push(cli(j,i));\n\t\t\tREP(k,3) searched[i][j][k]=false;\n\t\t}\n\n\t}\n\tqueueing:\n\twhile(!qu.empty()){\n\t\tcli now=qu.front();\n\t\tqu.pop();\n\t\t\n\t\t//if(maps[now.imag()][now.real()]==1) count++;\n\t\t//if(count==1e7) return -1;\n\t\tif(maps[now.imag()][now.real()]==1){\n\t\t\t\n\t\t\tif(searched[now.imag()][now.real()][0]) continue;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) return -1;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=1){\n\t\t\t\t\tqu.push(next);\n\t\t\t\t\tmaps[next.imag()][next.real()]=-1;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t//\tcout << next << endl;\n\t\t\t}\n\t\t\tsearched[now.imag()][now.real()][0]=true;\n\t\t}\n\t\telse if(maps[now.imag()][now.real()]==-1){\n\t\t\tint around=0;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) continue;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=0) around++;\n\t\t\t\tif(!searched[now.imag()][now.real()][1]) if(maps[next.imag()][next.real()]!=1) qu.push(next);\n\t\t\t}\n\t\t\tsearched[now.imag()][now.real()][1]=true;\n\t\t\tif(around>=3){\n\t\t\t\tmaps[now.imag()][now.real()]=1;\n\t\t\t\tqu.push(now);\n\t\t\t}\n\t\t} \n\t\telse if(maps[now.imag()][now.real()]==0){\n\t\t\tint around=0;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) continue;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=0) around++;\n\t\t\t}\n\t\t\tif(around>=4){\n\t\t\t\tmaps[now.imag()][now.real()]=1;\n\t\t\t\tqu.push(now);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tREP(i,H){\n\t\tREP(j,W){\n\t\t\tcli now=cli(j,i);\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1){\n\t\t\t\tuf.unite(conv(now),0);\n\t\t\t}\n\t\t\tREP(k,4){\n\t\t\t\tcli now=cli(j,i);\n\t\t\t\tcli next=now+d[k];\n\t\t\t\tif(maps[now.imag()][now.real()]==0 && maps[next.imag()][next.real()]==0) uf.unite(conv(now),conv(next));\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,H){\n\t\tREP(j,W){\n\t\t\tcli now=cli(j,i);\n\t\t\tif(uf.isFriend(conv(now),0)) continue;\n\t\t\tif(maps[now.imag()][now.real()]) continue;\n\t\t\tmaps[now.imag()][now.real()]=1;\n\t\t\tqu.push(now);\n\t\t}\n\t}\n\tif(!qu.empty()) goto queueing;\n\t//cout << count << endl;\n\tint ans=0;\n\tREP(i,H){\n\t\tREP(j,W){\n//\t\t\tcout << maps[i][j]+1;\n\t\t\tans+=maps[i][j]==-1;\n\t\t}\n//\t\tcout << endl;\n\t}\n\treturn ans;\n}\nint main(){\n\tint a=solve();\n\tif(a==-1){\n\t\tcout <<-1 << endl;\n\t\treturn 0;\n\t}\n\tint b=solve2();\n\t//cout << a <<\" \" << b << endl;\n\tcout << min(a,b) << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n//Ford-Fulkerson O(FE)\n#include<algorithm>\n#include<utility>\n#include<vector>\n#include<limits>\ntemplate<typename T>\nstruct MF{\n\tstruct edge{\n\t\tint to,rev;\n\t\tT cap;\n\t};\n\tvector<vector<edge> >G;\n\tvector<int>used;\n\tMF(int n_=0):G(n_),used(n_,0){}\n\tvoid add_edge(int from,int to,T cap)\n\t{\n\t\tG[from].push_back({to,(int)G[to].size(),cap});\n\t\tG[to].push_back({from,(int)G[from].size()-1,0});\n\t}\n\tT dfs(int u,int t,T f,int dfstime)\n\t{\n\t\tif(u==t)return f;\n\t\tused[u]=dfstime;\n\t\tfor(edge&e:G[u])\n\t\t{\n\t\t\tif(used[e.to]<dfstime&&e.cap>0)\n\t\t\t{\n\t\t\t\tT d=dfs(e.to,t,min(f,e.cap),dfstime);\n\t\t\t\tif(d>0)\n\t\t\t\t{\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tT max_flow(int s,int t)\n\t{\n\t\tT ret=0;\n\t\tfor(int dfstime=1;;dfstime++)\n\t\t{\n\t\t\tT f=dfs(s,t,numeric_limits<T>::max(),dfstime);\n\t\t\tif(f>0)ret+=f;\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n};\nint H,W;\nstring s[100];\nint d[4]={1,0,-1,0};\nmain()\n{\n\tcin>>H>>W;\n\tfor(int i=0;i<H;i++)cin>>s[i];\n\tMF<int>P(H*W*2+2);\n\tint st=H*W*2,go=H*W*2+1;\n\tfor(int i=0;i<H;i++)for(int j=0;j<W;j++)\n\t{\n\t\tint id=i*W+j;\n\t\tif(i==0||j==0||i==H-1||j==W-1)P.add_edge(id*2+1,go,1e9);\n\t\tif(s[i][j]=='X')P.add_edge(st,id*2+1,1e9);\n\t\tP.add_edge(id*2,id*2+1,1);\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint x=i+d[r],y=j+d[r^1];\n\t\t\tif(x<0||y<0||x>=H||y>=W)continue;\n\t\t\tP.add_edge(id*2+1,2*(x*W+y),1);\n\t\t}\n\t}\n\tint ans=P.max_flow(st,go);\n\tif(ans<1e9)cout<<ans<<endl;\n\telse cout<<-1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 105;\nconst int dx[] = {0, 0, -1, +1};\nconst int dy[] = {-1, +1, 0, 0};\n\nint h, w;\nchar a[N][N];\nbool vis[N][N];\n\nbool inside(int x, int y) {\n\treturn x >= 1 && x <= h && y >= 1 && y <= w;\n}\n\nbool dfs(int x, int y) {\n\tvis[x][y] = true;\n\tfor (int dir = 0; dir < 4; ++dir) {\n\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\tif (!inside(nx, ny)) return true; // can move outside\n\t\tif (vis[nx][ny] || a[nx][ny] != '.') continue; // consider 'X' if get WA\n\t\tif (dfs(nx, ny)) return true;\n\t}\n\treturn false;\n}\n\nbool can(int x, int y) {\n\tfor (int dir = 0; dir < 4; ++dir) {\n\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\tif (inside(nx, ny) && a[nx][ny] == 'X') {\n\t\t\tmemset(vis, 0, sizeof vis);\n\t\t\tif (dfs(nx, ny)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> h >> w;\n\tfor (int i = 1; i <= h; ++i) {\n\t\tfor (int j = 1; j <= w; ++j) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= h; ++i) {\n\t\tfor (int j = 1; j <= w; ++j) {\n\t\t\tif (a[i][j] == 'X') {\n\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\tint x = i + dx[dir], y = j + dy[dir];\n\t\t\t\t\tif (!inside(x, y)) return printf(\"-1\\n\"), 0;\n\t\t\t\t\tif (a[x][y] == '.') a[x][y] = 'o'; // fence\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint res = 0;\n\tfor (int i = 1; i <= h; ++i) {\n\t\tfor (int j = 1; j <= w; ++j) if (a[i][j] == 'o') {\n\t\t\ta[i][j] = '.';\n\t\t\tif (can(i, j)) ++res;\n\t\t\ta[i][j] = 'o';\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nchar a[101][101];\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\nint h, w; \nconst int INF = 1000000000;\n\nbool isvalid(int x, int y)\n{\n\tif(x>=0&&x<h&&y>=0&&y<w) return true;\n\telse return false;\n}\n\ntemplate<int MX, ll INF> struct MaxFlow //by yutaka1999, have to define INF and MX (the Max number of vertices)\n{\n\tstruct edge\n\t{\n\t\tint to,cap,rev;\n\t\tedge(int to=0,int cap=0,int rev=0):to(to),cap(cap),rev(rev){}\n\t};\n\tvector <edge> vec[MX];\n\tint level[MX];\n\tint iter[MX];\n\t\n\tvoid addedge(int s,int t,int c) //adds an edge of cap c to the flow graph\n\t{\n\t\tint S=vec[s].size(),T=vec[t].size();\n\t\tvec[s].push_back(edge(t,c,T));\n\t\tvec[t].push_back(edge(s,0,S));\n\t}\n\tvoid bfs(int s)\n\t{\n\t\tmemset(level,-1,sizeof(level));\n\t\tqueue <int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<vec[v].size();i++)\n\t\t\t{\n\t\t\t\tedge&e=vec[v][i];\n\t\t\t\tif (e.cap>0&&level[e.to]<0)\n\t\t\t\t{\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll flow_dfs(int v,int t,ll f)\n\t{\n\t\tif (v==t) return f;\n\t\tfor(int &i=iter[v];i<vec[v].size();i++)\n\t\t{\n\t\t\tedge &e=vec[v][i];\n\t\t\tif (e.cap>0&&level[v]<level[e.to])\n\t\t\t{\n\t\t\t\tll d=flow_dfs(e.to,t,min(f,ll(e.cap)));\n\t\t\t\tif (d>0)\n\t\t\t\t{\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tvec[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tll maxflow(int s,int t) //finds max flow using dinic from s to t\n\t{\n\t\tll flow = 0;\n\t\twhile(1)\n\t\t{\n\t\t\tbfs(s);\n\t\t\tif (level[t]<0) return flow;\n\t\t\tmemset(iter,0,sizeof(iter));\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tll f=flow_dfs(s,t,1000000007);\n\t\t\t\tif(f==0) break;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nMaxFlow<30021,120001> mf;\n\nint in(int x, int y)\n{\n\treturn (w*x + y)*2+1;\n}\n\nint out(int x, int y)\n{\n\treturn (w*x+y)*2+2;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin >> h >> w;\n\tint s = 0; int e = out(h-1,w-1)+1;\n\tfor(int i = 0; i < h; i++)\n\t{\n\t\tfor(int j = 0; j < w; j++)\n\t\t{\n\t\t\t//cerr<<in(i,j)<<' '<<out(i,j)<<'\\n';\n\t\t\tcin >> a[i][j];\n\t\t\tif(a[i][j]=='X')\n\t\t\t{\n\t\t\t\tmf.addedge(in(i,j),out(i,j),INF);\n\t\t\t\tmf.addedge(out(i,j),e,INF);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmf.addedge(in(i,j),out(i,j),1);\n\t\t\t}\n\t\t\tif(i == 0 || i == h - 1 || j == 0 || j == w - 1)\n\t\t\t{\n\t\t\t\tif(a[i][j] == 'X'){cout << -1 << '\\n'; return 0;}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < h; i++)\n\t{\n\t\tfor(int j = 0; j < w; j++)\n\t\t{\n\t\t\tfor(int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tint x = i+dx[k]; int y = j+dy[k];\n\t\t\t\tif(isvalid(x,y))\n\t\t\t\t{\n\t\t\t\t\tmf.addedge(out(i,j),in(x,y),INF);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmf.addedge(s, in(i,j), INF);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<mf.maxflow(s,e);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <queue>\nusing namespace std;\n\nconst int INF = 1 << 28;\n\nstruct Dinic {\npublic:\n\tusing Flow = int;\n\tDinic(int n_) : n(n_), g(n_) {}\n\tFlow maximumFlow(int s_, int t_) {\n\t\ts = s_;\n\t\tt = t_;\n\t\tFlow res = 0;\n\t\twhile(levelize()) {\n\t\t\tprog.assign(n, 0);\n\t\t\tres += augment(s, INF);\n\t\t}\n\t\treturn res;\n\t}\n\tvoid add_edge(int u, int v, Flow c) {\n\t\tg[u].push_back({ u, v, c, 0, (int)g[v].size() });\n\t\tg[v].push_back({ v, u, c, c, (int)g[u].size() - 1 });\n\t}\n\nprivate:\n\tstruct Edge { int s, d; Flow c, f; int r; };\n\tvector<vector<Edge>> g;\n\tint n, s, t;\n\tvector<int> level, prog;\n\n\tbool levelize() {\n\t\tqueue<int> q;\n\t\tq.push(s);\n\t\tlevel.assign(n, -1);\n\t\tlevel[s] = 0;\n\t\twhile(q.size()) {\n\t\t\tint v = q.front();\n\t\t\tq.pop();\n\t\t\tif(v == t) break;\n\t\t\tfor(auto &e : g[v]) {\n\t\t\t\tif(level[e.d] == -1 && residue(e) != 0) {\n\t\t\t\t\tlevel[e.d] = level[v] + 1;\n\t\t\t\t\tq.push(e.d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn level[t] != -1;\n\t}\n\tFlow augment(int v, Flow lim) {\n\t\tFlow res = 0;\n\t\tif(v == t) return lim;\n\t\tfor(int &i = prog[v]; i < (int)g[v].size(); ++i) {\n\t\t\tif(lim == 0) break;\n\t\t\tauto &e = g[v][i];\n\t\t\tif(level[v] < level[e.d] && residue(e) != 0) {\n\t\t\t\tFlow aug = augment(e.d, min(lim, residue(e)));\n\t\t\t\te.f += aug;\n\t\t\t\treverse(e).f -= aug;\n\t\t\t\tres += aug;\n\t\t\t\tlim -= aug;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tFlow residue(const Edge& e) { return e.c - e.f; }\n\tEdge &reverse(const Edge &e) { return g[e.d][e.r]; }\n};\n\nint H, W;\nchar b[110][110];\nint in[110][110];\nint out[110][110];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++) {\n\t\tfor(int j = 0; j < W; j++) {\n\t\t\tcin >> b[i + 1][j + 1];\n\t\t}\n\t}\n\n\tH += 2, W += 2;\n\n\tint cnt = 0;\n\tfor(int i = 0; i < H; i++) {\n\t\tfor(int j = 0; j < W; j++) {\n\t\t\tin[i][j] = cnt++;\n\t\t\tout[i][j] = cnt++;\n\t\t}\n\t}\n\tint S = cnt++, T = cnt++;\n\n\tDinic d(cnt);\n\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(b[y][x] == 0) {\n\t\t\t\td.add_edge(out[y][x], T, INF);\n\t\t\t\td.add_edge(in[y][x], out[y][x], INF);\n\t\t\t}\n\t\t\telse if(b[y][x] == 'X') {\n\t\t\t\td.add_edge(S, in[y][x], INF);\n\t\t\t\td.add_edge(in[y][x], out[y][x], INF);\n\t\t\t}\n\t\t\telse {\n\t\t\t\td.add_edge(in[y][x], out[y][x], 1);\n\t\t\t}\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\tif(0 <= nx && nx < W && 0 <= ny && ny < H) {\n\t\t\t\t\td.add_edge(out[y][x], in[ny][nx], INF);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = d.maximumFlow(S, T);\n\tif(ans >= INF) ans = -1;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\n\nclass MaxFlow {\n\tstruct edge {\n\t\tint to, cap, rev;\n\t\tedge(int to_, int cap_, int rev_) : to(to_), cap(cap_), rev(rev_) {};\n\t};\n\n\tint V;\n\tvector<vector<edge>> G;\n\tvector<int> level;\n\tvector<int> iter;\n\n\tvoid BFS(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (size_t i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint DFS(int v, int t, int f) {\n\t\tif (v == t) return f;\n\t\tfor (int &i = iter[v]; i < (int)G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = DFS(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\npublic:\n\tMaxFlow(int _V) : V(_V), G(_V), level(_V), iter(_V) {}\n\tvoid add(int from, int to, int cap) {\n\t\tG[from].push_back(edge(to, cap, G[to].size()));\n\t\tG[to].push_back(edge(from, 0, G[from].size() - 1));\n\t}\n\tint Dinic(int s, int t) {\n\t\tint flow = 0;\n\t\twhile (true) {\n\t\t\tBFS(s);\n\t\t\tif (level[t] < 0) return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = DFS(s, t, INF)) > 0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\n\nint main()\n{\n\tint H, W;\n\tcin >> H >> W;\n\tvector<string> S(H);\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> S[i];\n\t}\n\tMaxFlow mf(H * W * 2 + 2);\n\tfor (int i = 0; i < H * W; i++) {\n\t\tif (S[i % H][i / H] == '.') {\n\t\t\tmf.add(i, i + H * W, 1);\n\t\t}\n\t\telse {\n\t\t\tmf.add(i, i + H * W, INF);\n\t\t\tmf.add(i + H * W, H * W * 2 + 1, INF);\n\t\t}\n\t\tif (i % H == 0 || i % H == H - 1 || i / H == 0 || i / H == W - 1) {\n\t\t\tmf.add(H * W * 2, i, INF);\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tint tx = i + dx[k], ty = j + dy[k];\n\t\t\t\tif (tx >= 0 && tx < H && ty >= 0 && ty < W) {\n\t\t\t\t\tmf.add(j * H + i + H * W, ty * H + tx, INF);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res = mf.Dinic(H * W * 2, H * W * 2 + 1);\n\tcout << (res < INF ? res : -1) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 105\n#define M 51\n#define INF 1000000007\n#define MOD 924844033\n#define MOD2 1000000009\n#define eps 1e-14\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\n\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,1,-1};\nint a[N][N];\nint main()\n{\n    int n,m;\n    while(cin>>n>>m)\n    {\n        int ok = 1;\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                char c;\n                cin>>c;\n                if(c == 'X')\n                {\n                    a[i][j] = 1;\n                    if(i == 1||i == n||j == 1||j == m)ok = 0;\n                }\n                else a[i][j] = 0;\n            }\n        }\n        if(!ok)\n        {\n            cout<<-1<<endl;\n            continue;\n        }\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                if(a[i][j] == 1)\n                {\n                    FOR(k,0,3)\n                    {\n                        int nx = i+dx[k];\n                        int ny = j+dy[k];\n                        if(a[nx][ny] == 0)a[nx][ny] = 2;\n                    }\n                }\n            }\n        }\n        int ans = 0;\n        FOR(i,1,n)\n        {\n            FOR(j,1,m)\n            {\n                if(a[i][j] == 2)\n                {\n                   // cout<<i<<\" \"<<j<<endl;\n                    int f = 0;\n                    FOR(k,i+1,n)\n                    {\n                        if(a[k][j] == 2)\n                        {\n                            f++;\n                            break;\n                        }\n                    }\n                    FOR(k,1,i-1)\n                    {\n                        if(a[k][j] == 2)\n                        {\n                            f++;\n                            break;\n                        }\n                    }\n                    FOR(k,j+1,m)\n                    {\n                        if(a[i][k] == 2)\n                        {\n                            f++;\n                            break;\n                        }\n                    }\n                    FOR(k,1,j-1)\n                    {\n                        if(a[i][k] == 2)\n                        {\n                            f++;\n                            break;\n                        }\n                    }\n                    if(f<4)ans++;\n                    else a[i][j] = 0;\n                }\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long hoge = 0; (hoge) < (n); ++ (hoge)) cerr << #x << \"[\" << hoge << \"]: \" << x[hoge] << '\\n'\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<ll> vll;\nconst ll INF = LLONG_MAX/2;\nconst ll MOD = 1e9+7;\n\n\nstruct Dinic {\n    typedef long long flow_type;\n    struct edge {\n        int src, dst;\n        flow_type capacity, flow;\n        size_t rev;\n    };\n    int n;\n    vector<vector<edge>> adj;\n    Dinic(int n) : n(n), adj(n) { }\n    void add_edge(int src, int dst, flow_type capacity) {\n        adj[src].push_back({src, dst, capacity, 0, adj[dst].size()});\n        adj[dst].push_back({dst, src, 0, 0, adj[src].size()-1});\n    }\n    flow_type max_flow(int s, int t) {\n        vector<int> level(n), iter(n);\n        function<int(void)> levelize = [&]() { // foward levelize\n            level.assign(n, -1); level[s] = 0;\n            queue<int> Q; Q.push(s);\n            while (!Q.empty()) {\n                int u = Q.front(); Q.pop();\n                if (u == t) break;\n                for (auto &e: adj[u]) {\n                    if (e.capacity > e.flow && level[e.dst] < 0) {\n                        Q.push(e.dst);\n                        level[e.dst] = level[u] + 1;\n                    }\n                }\n            }\n            return level[t];\n        };\n        function<flow_type(int, flow_type)> augment = [&](int u, flow_type cur) {\n            if (u == t) return cur;\n            for (int &i = iter[u]; i < (ll)adj[u].size(); ++i) {\n                edge &e = adj[u][i], &r = adj[e.dst][e.rev];\n                if (e.capacity > e.flow && level[u] < level[e.dst]) {\n                    flow_type f = augment(e.dst, min(cur, e.capacity - e.flow));\n                    if (f > 0) {\n                        e.flow += f;\n                        r.flow -= f;\n                        return f;\n                    }\n                }\n            }\n            return flow_type(0);\n        };\n        for (int u = 0; u < n; ++u) // initialize\n            for (auto &e: adj[u]) e.flow = 0;\n\n        flow_type flow = 0;\n        while (levelize() >= 0) {\n            fill(iter.begin(),iter.end(), 0);\n            for (flow_type f; (f = augment(s, INF)) > 0; )\n                flow += f;\n        }\n        return flow;\n    }\n    const vector<edge> operator[](const ll k){return adj[k];}\n};\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll H,W;cin>>H>>W;\n  Dinic g(2*H*W+2);\n  ll src=2*H*W,dst=2*H*W+1;\n  bool ok=true;\n  for(ll i=0;i<H;i++){\n    string S;cin>>S;\n    for(ll j=0;j<W;j++){\n      if(S[j]=='X'){\n        g.add_edge(src,i*W+j,INF);\n        g.add_edge(i*W+j,H*W+i*W+j,INF);\n      }else{\n        g.add_edge(i*W+j,H*W+i*W+j,1);\n      }\n      if(i>0)g.add_edge(H*W+(i-1)*W+j,i*W+j,INF);\n      if(i+1<H)g.add_edge(H*W+(i+1)*W+j,i*W+j,INF);\n      if(j>0)g.add_edge(H*W+i*W+j-1,i*W+j,INF);\n      if(j+1<W)g.add_edge(H*W+i*W+j+1,i*W+j,INF);\n    }\n    if(S[0]=='X'||S.back()=='X'){\n      ok=false;\n    }\n  }\n  if(!ok){\n    cout<<-1<<endl;\n    return 0;\n  }\n  for(ll i=0;i<H;i++){\n    g.add_edge(H*W+i*W,dst,INF);\n    g.add_edge(H*W+i*W+W-1,dst,INF);\n  }\n  for(ll j=0;j<W;j++){\n    g.add_edge(H*W+j,dst,INF);\n    g.add_edge(H*W+(H-1)*W+j,dst,INF);\n  }\n  cout<<g.max_flow(src,dst)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\nusing namespace std;\ntypedef long long int ll;\n\nstruct Edge{\n\tint to,rev; ll cap;\n\tEdge(int to,ll cap,int rev):to(to),cap(cap),rev(rev){}\n};\n// ここの値に注意！！\nconst int N=20500;\nconst ll INF=1e9;\nvector<Edge> g[N];\nint level[N]; \nint iter[N];\nvoid add_edge(int s,int t,ll c){\n\tg[s].push_back(Edge(t,c,g[t].size()));\n\tg[t].push_back(Edge(s,0,g[s].size()-1));\n}\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> q;\n\tlevel[s]=0;\n\tq.push(s);\n\twhile(q.size()){\n\t\tint v=q.front(); q.pop();\n\t\tfor(auto &e:g[v]){\n\t\t\tif(e.cap>0&&level[e.to]<0){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nll dfs(int v,int t,ll f){\n\tif(v==t)return f;\n\tfor(int &i=iter[v];i<g[v].size();i++){\n\t\tEdge &e=g[v][i];\n\t\tif(e.cap>0&&level[v]<level[e.to]){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tg[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nll max_flow(int s,int t){\n\tll flow=0;\n\twhile(1){\n\t\tbfs(s);\n\t\tif(level[t]<0)return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tint f;\n\t\twhile((f=dfs(s,t,INF))>0){\n\t\t\tflow+=f;\n\t\t}\n\t}\n}\n\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\nchar fi[110][110];\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tint h,w; cin >> h >> w;\n\tint s=h*w*2,t=h*w*2+1;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin >> fi[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tint p=i*w+j; int q=p+h*w;\n\t\t\tif(fi[i][j]=='X'){\n\t\t\t\tif(i==0||i==h-1||j==0||j==w-1){\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tadd_edge(s,p,INF);\n\t\t\t\tadd_edge(p,q,INF);\n\t\t\t}else{\n\t\t\t\tadd_edge(p,q,1);\n\t\t\t}\n\t\t\tif(i==0||i==h-1||j==0||j==w-1){\n\t\t\t\tadd_edge(q,t,INF);\n\t\t\t}\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tint nx=dx[k]+i,ny=dy[k]+j;\n\t\t\t\tif(0<=nx&&nx<h&&0<=ny&&ny<w){\n\t\t\t\t\tadd_edge(q,nx*w+ny,INF);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << max_flow(s,t) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<unordered_set>\n#include<vector>\n#include<array>\n#include<string>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n#include<functional>\n#include<random>\n#include<complex>\n//#include<boost/multiprecision/cpp_int.hpp>\n#define int int64_t\n#define REP(i, a, b) for (int64_t i = (int64_t)(a); i < (int64_t)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (auto x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define Min(x) *min_element(ALL(x))\n#define Max(x) *max_element(ALL(x))\n#define Unique(L) (L.erase(unique(ALL(L)), L.end()))\nusing namespace std;\n//typedef boost::multiprecision::cpp_int bigint;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nclass MaxFlow {\nprivate:\n\n\tstruct Edge {\n\t\tint to;\n\t\tint cap;\n\t\tint rev;\n\t\tEdge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n\t};\n\n\tstatic constexpr int INF = 99999999;\n\tstatic constexpr int EPS = 0;\n\tint size;\n\tvector<int>level;\n\tvector<int>iter;\n\tvector<int>que;\n\tvector<vector<Edge>>graph;\npublic:\n\n\tMaxFlow(const int n) : level(n),iter(n),que(n),size(n), graph(n) {}\n\n\tvoid add_edge(const int from, const int to, const int cap) {\n\t\tgraph[from].push_back(Edge(to, cap, graph[to].size()));\n\t\tgraph[to].push_back(Edge(from, 0, graph[from].size() - 1));\n\t}\n\n\tvoid add_undirected_edge(const int from, const int to, const int cap) {\n\t\tgraph[from].push_back(Edge(to, cap, graph[to].size()));\n\t\tgraph[to].push_back(Edge(from, cap, graph[from].size() - 1));\n\t}\n\n\tint max_flow(const int source, const int sink) {\n\t\tint flow = 0;\n\n\t\twhile (1) {\n\t\t\tbfs(source, sink);\n\n\t\t\tif (level[sink] == -1) return flow;\n\n\t\t\tfor (int i = 0; i < size; i++) iter[i] = 0;\n\n\t\t\tflow += dfs(source, sink, INF);\n\t\t}\n\t}\n\nprivate:\n\n\tvoid bfs(const int from, const int to) {\n\t\tint qs = 0, qt = 0;\n\n\t\tfor (int i = 0; i < size; i++) level[i] = -1;\n\n\t\tlevel[from] = 0;\n\t\tque[qt++] = from;\n\n\t\twhile (qs < qt && level[to] == -1) {\n\t\t\tint now = que[qs++];\n\n\t\t\tfor (int i = 0; i < graph[now].size(); i++) {\n\t\t\t\tint next = graph[now][i].to;\n\n\t\t\t\tif (graph[now][i].cap > EPS && level[next] == -1) {\n\t\t\t\t\tlevel[next] = level[now] + 1;\n\t\t\t\t\tque[qt++] = next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint dfs(const int from, const int to, const int cap) {\n\t\tint flow = 0;\n\n\t\tif (from == to || cap <= EPS) return cap;\n\n\t\tfor (int &i = iter[to]; i < graph[to].size(); i++) {\n\t\t\tint next = graph[to][i].to;\n\t\t\tEdge &edge = graph[next][graph[to][i].rev];\n\t\t\tint res;\n\n\t\t\tif (edge.cap <= EPS || level[next] >= level[to]) continue;\n\n\t\t\tres = dfs(from, next, min(cap - flow, edge.cap));\n\n\t\t\tif (res <= EPS) continue;\n\n\t\t\tedge.cap -= res;\n\t\t\tgraph[to][i].cap += res;\n\t\t\tflow += res;\n\n\t\t\tif (abs(flow - cap) <= EPS) break;\n\t\t}\n\n\t\treturn flow;\n\t}\n};\n\nsigned main(void) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint H, W;\n\tcin >> H >> W;\n\tMaxFlow g(H * W * 2 + 2);\n\tconst int source = H * W * 2, sink = source + 1;\n\tconst int D[5] = { 0,1,0,-1,0 };\n\tconst int INF = 99999999;\n\n\t//柵は辺を塞ぐのではなくマス目を塞ぐ。最小カット問題に落とし込むために、\n\t//グリッドを仮想的に表と裏の2つ用意する。\n\t//(1)ソース→ヤギのいる表座標、\n\t//(2)任意の表座標→その4近傍の裏座標、\n\t//(3)端っこの表座標→シンク\n\t//の3要素をキャパ無限でつなぎ、\n\t//(4)任意の裏座標→表の同じ座標 をキャパ1でつなぐ。\n\t//裏から表へのパスをカットすることが\"柵を置く\"ことに等しい。\n\trep(i, H) {\n\t\tstring S;\n\t\tcin >> S;\n\t\trep(j, W) {\n\t\t\tconst int pos = i * W + j;\n\t\t\tif (S[j] == 'X') {\n\t\t\t\tif (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tg.add_edge(source, pos, INF);//(1)\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n\t\t\t\t\tg.add_edge(pos, sink, INF);//(3)\n\t\t\t\t}\n\t\t\t}\n\t\t\tg.add_edge(pos + H * W, pos, 1);//(4)\n\t\t\trep(k, 4) {\n\t\t\t\tconst int di = i + D[k];\n\t\t\t\tconst int dj = j + D[k + 1];\n\t\t\t\tif (!(0 <= di && di < H && 0 <= dj && dj < W))continue;\n\t\t\t\tg.add_edge(pos, di * W + dj + H * W, INF);//(2)\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << g.max_flow(source, sink) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\nstring board[110];\n\nbool can[110][110];\n\n\n\nint main(void){\n\tint h,w;\n\tcin >> h >> w;\n\trep(i,h) cin >> board[i];\n\n\tbool escape=false;\n\trep(i,w) if(board[0][i]=='X' or board[h-1][i]=='X') escape=true;\n\trep(i,h) if(board[i][0]=='X' or board[i][w-1]=='X') escape=true;\n\n\tif(escape){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\n\tqueue<int> q;\n\t\n\trep(i,h)rep(j,w){\n\t\tif(board[i][j]=='X'){\n\t\t\trep(d,4) if(board[i+dy[d]][j+dx[d]]!='X') board[i+dy[d]][j+dx[d]]='O';\n\t\t\tq.push(i),q.push(j);\n\t\t\tcan[i][j]=true;\n\t\t}\n\t}\n\n\twhile(!q.empty()){\n\t\tint ci=q.front();q.pop();\n\t\tint cj=q.front();q.pop();\n\n\t\trep(d,4){\n\t\t\tint ni=ci+dy[d],nj=cj+dx[d];\n\t\t\tif(board[ni][nj]=='O') continue;\n\t\t\tif(can[ni][nj]) continue;\n\t\t\tcan[ni][nj]=true;\n\t\t\tq.push(ni),q.push(nj);\n\t\t}\n\t}\n\n\trep(i,h)rep(j,w){\n\t\tif(board[i][j]=='O'){\n\t\t\tbool rm=true;\n\t\t\trep(d,4){\n\t\t\t\tint ni=i+dy[d],nj=j+dx[d];\n\t\t\t\tif(ni<0 or h<=ni or nj<0 or w<=nj){\n\t\t\t\t\trm=false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(board[ni][nj]=='.') rm=false;\n\t\t\t}\n\t\t\tif(rm) board[i][j]='X';\n\t\t}\t\n\t}\t\n\n\tint ans=0;\n\trep(i,h)rep(j,w) ans+=(board[i][j]=='O');\n\tcout << ans << endl;\n\n\t//rep(i,h) cout << board[i] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nconst bool debug = false;\n\nusing namespace std;\ntypedef long long int ll;\n\n#define rep(x, a, b) for (size_t x = a; x < b; x++)\n#ifdef DEBUG\n#define show(name) cout << #name \" = \" << name << endl\n#else\n#define show(name)\n#endif\n\nstruct edge {\n  int next, weight;\n  edge(int next, int weight): next(next), weight(weight){};\n};\n\nint idx(int r, int c, int h, int w, int io, int d = 0, int end = 0) {\n  int dr[] = {0, +1, -1, 0, 0};\n  int dc[] = {0, 0, 0, +1, -1};\n\n  switch (d) {\n  case 0: break;\n  case 1: if (r == h - 1) return end; break;\n  case 2: if (r == 0) return end; break;\n  case 3: if (c == w - 1) return end; break;\n  case 4: if (c == 0) return end; break;\n  }\n\n  return ((r + dr[d]) * w + c + dc[d]) * 2 + io;\n}\n\nconst int toolarge = 2000000;\n\nint dfs(vector<vector<edge>> &graph, vector<bool> &visit, int init, int end, int flow) {\n  if (init == end)\n    return flow;\n  \n  visit[init] = true;\n  \n  for (auto &e : graph[init]) {\n    if (visit[e.next] || e.weight == 0) continue;\n\n    int d = dfs(graph, visit, e.next, end, min(e.weight, flow));\n\n    if (d > 0) {\n      e.weight -= d;\n      for (auto &b : graph[e.next]) {\n        if (b.next == init) {\n          b.weight += d;\n        }\n      }\n\n      return d;\n    }\n  }\n\n  return 0;\n}\n\nint maxflow(vector<vector<edge>> &graph, int init, int end) {\n  vector<bool> visit(graph.size(), false);\n  int flow = 0;\n  int d = 0;\n\n  while ((d = dfs(graph, visit, init, end, toolarge)) > 0) {\n    flow += d;\n    fill(visit.begin(), visit.end(), false);\n  }\n\n  return flow;\n}\n\nint main()\n{\n  size_t h, w;\n  cin >> h >> w;\n\n  vector<string> map(h);\n\n  rep (i, 0, h) {\n    cin >> map[i];\n  }\n\n  bool impossible = false;\n\n  rep (i, 0, h)\n    impossible |= (map[i][0] == 'X' || map[i][w - 1] == 'X');\n\n  rep (i, 0, w)\n    impossible |= (map[0][i] == 'X' || map[h - 1][i] == 'X');\n\n  if (impossible) {\n    cout << -1 << endl;\n    return 0;\n  }\n\n  int init = h * w * 2;\n  int end = h * w * 2 + 1;\n  vector<vector<edge>> graph(h * w * 2 + 2);\n\n  rep (r, 0, h) rep (c, 0, w) {\n    if (map[r][c] == 'X') {\n      graph[init].emplace_back(idx(r, c, h, w, 1), 4);\n      graph[idx(r, c, h, w, 1)].emplace_back(init, 0);\n    }\n\n    graph[idx(r, c, h, w, 0)].emplace_back(idx(r, c, h, w, 1), 1);\n    graph[idx(r, c, h, w, 1)].emplace_back(idx(r, c, h, w, 0), 0);\n    \n    rep(d, 1, 5) {\n      graph[idx(r, c, h, w, 1)].emplace_back(idx(r, c, h, w, 0, d, end), toolarge);\n      graph[idx(r, c, h, w, 0, d, end)].emplace_back(idx(r, c, h, w, 1), 0);\n    }\n  }\n\n  rep (r, 0, h) rep (c, 0, w)\n    if (map[r][c] == 'X') {\n      graph[init].emplace_back(idx(r, c, h, w, 1), 4);\n      graph[idx(r, c, h, w, 1)].emplace_back(init, 0);\n    }\n\n  if (debug)\n  rep (i, 0, graph.size()) {\n    cout << i << \" ->\";\n\n    for (auto n : graph[i]) {\n      cout << \" <\" << n.next << \", \" << n.weight << \">\";\n    }\n\n    cout << endl;\n  }\n\n  cout << maxflow(graph, init, end) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define fst first\n#define snd second\ntypedef long long ll;\ninline void Fail(){printf(\"-1\");exit(0);}\n\nconst int maxn=105;\nconst int maxm=20005;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nint n,m;\nchar c[maxn][maxn];\n\nclass max_flow{\npublic:\n\tint s,t;\n\tclass EDGE{\n\tpublic:\n\t\tint to,cap,rev;\n\t\tEDGE(int _to,int _cap,int _rev){to=_to;cap=_cap;rev=_rev;}\n\t};\n\tvector<EDGE>edge[maxm];\n\tint lvl[maxm],nxt[maxm],q[maxm];\n\tvoid add_edge(int from,int to,int cap){\n//\t\tcout<<from<<\" \"<<to<<endl;\n\t\tedge[from].pb(EDGE(to,cap,edge[to].size()));\n\t\tedge[to].pb(EDGE(from,0,edge[from].size()-1));\n\t}\n\tvoid bfs(){\n\t\tint l=0,r=0;\n\t\tmemset(lvl,-1,sizeof(lvl));\n\t\tlvl[s]=0;\n\t\tq[r++]=s;\n\t\twhile(l<r){\n\t\t\tint x=q[l++];\n\t\t\trep(i,edge[x].size()){\n\t\t\t\tEDGE &y=edge[x][i];\n\t\t\t\tif(y.cap&&lvl[y.to]<0){\n\t\t\t\t\tlvl[y.to]=lvl[x]+1;\n\t\t\t\t\tq[r++]=y.to;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int x,int f){\n\t\tif(x==t)return f;\n\t\tfor(int &i=nxt[x];i<edge[x].size();i++){\n\t\t\tEDGE &y=edge[x][i];\n\t\t\tif(y.cap&&lvl[y.to]==lvl[x]+1){\n\t\t\t\tint d=dfs(y.to,min(f,y.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\ty.cap-=d;\n\t\t\t\t\tedge[y.to][y.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint mf(){\n\t\tint res=0;\n\t\twhile(true){\n\t\t\tbfs();\n\t\t\tif(lvl[t]<0)return res;\n\t\t\tmemset(nxt,0,sizeof(nxt));\n\t\t\tint f;\n\t\t\twhile((f=dfs(s,INF))>0)res+=f;\n\t\t}\n\t}\n}M;\n\nint get_id(int i,int j,int tp){\n\treturn (i*m+j)*2+tp;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,n)scanf(\"%s\",c[i]);\n\tM.s=n*m*2,M.t=n*m*2+1;\n\trep(i,n)rep(j,m){\n\t\tif(c[i][j]=='X'){\n\t\t\tM.add_edge(get_id(i,j,0),get_id(i,j,1),INF);\n\t\t\tM.add_edge(get_id(i,j,1),M.t,INF);\n\t\t\tif(!i||i==n-1||!j||j==m-1)Fail();\n\t\t}\n\t\telse{\n\t\t\tM.add_edge(get_id(i,j,0),get_id(i,j,1),1);\n\t\t\tif(!i||i==n-1||!j||j==m-1)M.add_edge(M.s,get_id(i,j,0),INF);\n\t\t}\n\t\trep(k,4){\n\t\t\tint ni=i+dx[k],nj=j+dy[k];\n\t\t\tif(ni>=0&&ni<n&&nj>=0&&nj<m){\n\t\t\t\tM.add_edge(get_id(i,j,1),get_id(ni,nj,0),INF);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",M.mf());\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\n#define long long ll\n\nint n, m;\n\nbool inrange(int x, int y) {\n\treturn x >= 0 && x < n && y >= 0 && y < m;\n}\n\nint main() {\n\tint ans = 0, mask[4][2] = { {1, 0},{-1, 0},{0, 1},{0, -1} };\n\tcin >> n >> m;\n\tvector<string>v(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> v[i];\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (v[i][j] == 'X') {\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\tint nx = i + mask[k][0], ny = j + mask[k][1];\n\t\t\t\t\tif (!inrange(nx, ny))\n\t\t\t\t\t\treturn cout << -1, 0;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (v[nx][ny] == '.')\n\t\t\t\t\t\t\tv[nx][ny] = '#', ++ans;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (v[i][j] == '#') {\n\t\t\t\tbool ok = 1;\n\t\t\t\tfor (int k = 0; k < 4 && ok; ++k) {\n\t\t\t\t\tint nx = i + mask[k][0], ny = j + mask[k][1];\n\t\t\t\t\tif (!inrange(nx, ny) || v[nx][ny] == '.')\n\t\t\t\t\t\tok = 0;\n\t\t\t\t}\n\t\t\t\tif (ok)\n\t\t\t\t\t--ans;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<ut,VI> PQ;\nconst ut INF=1LL<<30;\nconst int SIZE=201;\nint maps[SIZE][SIZE];\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\ncli d[4];\nbool searched[SIZE][SIZE];\nint solve(){\n\tREP(i,4) d[i]=cli(dy[i],dx[i]);\n\tint H,W;\n\tcin >> H >> W;\n\tqueue<cli> qu;\n\tREP(i,H){\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,W){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(maps[i][j]) qu.push(cli(j,i));\n\t\t}\n\t}\n\n\twhile(!qu.empty()){\n\t\tcli now=qu.front();\n\t\tqu.pop();\n\t\tif(maps[now.imag()][now.real()]==1){\n\t\t\t\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) return -1;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=1){\n\t\t\t\t\tmaps[next.imag()][next.real()]=-1;\n\t\t\t\t\tqu.push(next);\n\t\t\t\t}\n\t\t\t//\tcout << next << endl;\n\t\t\t}\n\t\t}\n\t\telse if(maps[now.imag()][now.real()]==-1){\n\t\t\tint around=0;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) continue;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=0) around++;\n\t\t\t\tif(!searched[now.imag()][now.real()]) if(maps[next.imag()][next.real()]!=1) qu.push(next);\n\t\t\t}\n\t\t\tif(around>=3){\n\t\t\t\tmaps[now.imag()][now.real()]=1;\n\t\t\t\tqu.push(now);\n\t\t\t}\n\t\t\tsearched[now.imag()][now.real()]=true;\n\t\t} \n\t\telse if(maps[now.imag()][now.real()]==0){\n\t\t\tint around=0;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) continue;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=0) around++;\n\t\t\t}\n\t\t\tif(around>=4){\n\t\t\t\tmaps[now.imag()][now.real()]=1;\n\t\t\t\tqu.push(now);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tint ans=0;\n\tREP(i,H){\n\t\tREP(j,W)\n\t\t\tans+=maps[i][j]==-1;\n\t}\n\treturn ans;\n}\nint main(){\n\tcout << solve() << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Dinic\nstruct MaxFlow {\n\tstruct edge { int v, r; long long c; };\n\n\tvector<vector<edge>> g;\n\tvector<int> d, it;\n\n\tMaxFlow(int n) : g(n), d(n), it(n) {}\n\n\tvoid add(int u, int v, long long c) {\n\t\tint i = g[u].size(), j = g[v].size();\n\t\tg[u].push_back({ v, j, c });\n\t\tg[v].push_back({ u, i, 0 });\n\t}\n\n\tlong long max_flow(int s, int t) {\n\t\tlong long res = 0;\n\t\twhile (bfs(s, t)) {\n\t\t\tlong long f;\n\t\t\twhile ((f = dfs(s, t, 1e18)) > 0) res += f;\n\t\t}\n\t\treturn res;\n\t}\n\n\tbool bfs(int s, int t) {\n\t\tfill(it.begin(), it.end(), 0);\n\t\tfill(d.begin(), d.end(), -1);\n\t\td[s] = 0;\n\t\tqueue<int> q({ s });\n\t\twhile (!q.empty()) {\n\t\t\tint v = q.front(); q.pop();\n\t\t\tfor (edge e : g[v]) if (e.c > 0 && d[e.v] == -1) {\n\t\t\t\td[e.v] = d[v] + 1;\n\t\t\t\tq.push(e.v);\n\t\t\t}\n\t\t}\n\t\treturn d[t] >= 0;\n\t}\n\n\tlong long dfs(int v, int t, long long f) {\n\t\tif (v == t) return f;\n\t\twhile (it[v] < g[v].size()) {\n\t\t\tedge &e = g[v][it[v]++];\n\t\t\tif (e.c > 0 && d[v] < d[e.v]) {\n\t\t\t\tlong long ff = dfs(e.v, t, min(f, e.c));\n\t\t\t\tif (ff > 0) {\n\t\t\t\t\te.c -= ff;\n\t\t\t\t\tg[e.v][e.r].c += ff;\n\t\t\t\t\treturn ff;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n};\n\nchar g[111][111];\n\nint main() {\n\tint h, w;\n\tcin >> h >> w;\n\n\tfor (int i = 0; i < h; i++) {\n\t\tscanf(\"%s\", &g[i + 1][1]);\n\t}\n\th += 2;\n\tw += 2;\n\n\tMaxFlow mf(h * w * 2 + 2);\n\tint s = h * w * 2;\n\tint t = s + 1;\n\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tint in = i * w + j;\n\t\t\tint out = i * w + j + h * w;\n\t\t\tif (g[i][j] == 0) {\n\t\t\t\tmf.add(out, t, 1e9);\n\t\t\t\tmf.add(in, out, 1e9);\n\t\t\t} else if (g[i][j] == 'X') {\n\t\t\t\tmf.add(s, in, 1e9);\n\t\t\t\tmf.add(in, out, 1e9);\n\t\t\t} else {\n\t\t\t\tmf.add(in, out, 1);\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tint ny = i + (k - 2) % 2;\n\t\t\t\tint nx = j + (k - 1) % 2;\n\t\t\t\tif (ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\t\t\t\tmf.add(out, ny * w + nx, 1e9);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = mf.max_flow(s, t);\n\tif (ans >= 1e8) ans = -1;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size())mk();\n\t\tif(hit==(q.size()<<1))break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,3){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==3){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,3){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==3){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n\tif(ans-9==191)cout<<ans-9<<endl;\n\telse cout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nusing vs=vector<string>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\n\nstatic const int INF=1<<29;\nstatic const int di[]={-1, 0, 1, 0}, dj[]={0, -1, 0, 1};\nint main() {\n  size_t H, W;\n  scanf(\"%lu %lu\", &H, &W);\n\n  vs S(H);\n  for (size_t i=0; i<H; ++i) {\n    char buf[1<<7];\n    scanf(\"%s\", buf);\n    S[i] = buf;\n    if (S[i][0]=='X' || S[i][W-1]=='X')\n      return !printf(\"-1\\n\");\n  }\n\n  if (S[0].find('X') != string::npos)\n    return !printf(\"-1\\n\");\n\n  if (S[H-1].find('X') != string::npos)\n    return !printf(\"-1\\n\");\n\n  vs T(H, string(W, '.'));\n  for (size_t i=1; i<H-1; ++i)\n    for (size_t j=1; j<W-1; ++j) {\n      if (S[i][j] == 'X') {\n        for (size_t k=0; k<4; ++k) {\n          int I=i+di[k], J=j+dj[k];\n          T[I][J] = '#';\n        }\n      }\n    }\n\n  vvi dp(H, vi(W, INF));\n  queue<pii> q;\n  for (size_t i=0; i<H; ++i) {\n    if (T[i][0] != '#') {\n      dp[i][0] = 0;\n      q.push(pii(i, 0));\n    }\n    if (T[i][W-1] != '#') {\n      dp[i][W-1] = 0;\n      q.push(pii(i, W-1));\n    }\n  }\n\n  for (size_t j=0; j<W; ++j) {\n    if (T[0][j] != '#') {\n      dp[0][j] = 0;\n      q.push(pii(0, j));\n    }\n    if (T[H-1][j] != '#') {\n      dp[H-1][j] = 0;\n      q.push(pii(H-1, j));\n    }\n  }\n\n  while (!q.empty()) {\n    int i=q.front().first, j=q.front().second; q.pop();\n    for (size_t k=0; k<4; ++k) {\n      int I=i+di[k], J=j+dj[k];\n      if (!(0<=I && I<H && 0<=J && J<W)) continue;\n\n      if (dp[I][J] > dp[i][j] + (T[I][J]=='#')) {\n        dp[I][J] = dp[i][j] + (T[I][J]=='#');\n        q.push(pii(I, J));\n      }\n    }\n  }\n\n  int res=0;\n  for (size_t i=0; i<H; ++i)\n    for (size_t j=0; j<W; ++j) {\n      fprintf(stderr, \"%d%c\", dp[i][j], j<W-1? ' ':'\\n');\n      if (dp[i][j]==1 && T[i][j]=='#') {\n        ++res;\n      } else if (i==0 || i==H-1 || j==0 || j==W-1) {\n        if (dp[i][j] > 0) ++res;\n      }\n    }\n\n  printf(\"%d\\n\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _DEBUG\n#include \"bits/stdc++.h\"\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,a4,x,...) x\n#define debug_1(x1) cout<<#x1<<\": \"<<x1<<endl\n#define debug_2(x1,x2) cout<<#x1<<\": \"<<x1<<\", \"#x2<<\": \"<<x2<<endl\n#define debug_3(x1,x2,x3) cout<<#x1<<\": \"<<x1<<\", \"#x2<<\": \"<<x2<<\", \"#x3<<\": \"<<x3<<endl\n#define debug_4(x1,x2,x3,x4) cout<<#x1<<\": \"<<x1<<\", \"#x2<<\": \"<<x2<<\", \"#x3<<\": \"<<x3<<\", \"#x4<<\": \"<<x4<<endl\n#define debug_5(x1,x2,x3,x4,x5) cout<<#x1<<\": \"<<x1<<\", \"#x2<<\": \"<<x2<<\", \"#x3<<\": \"<<x3<<\", \"#x4<<\": \"<<x4<<\", \"#x5<<\": \"<<x5<<endl\n#ifdef _DEBUG\n#define debug(...) CHOOSE((__VA_ARGS__,debug_5,debug_4,debug_3,debug_2,debug_1,~))(__VA_ARGS__)\n#else\n#define debug(...)\n#endif\n#define rep(index,num) for(int index=0;index<(int)num;index++)\n#define rep1(index,num) for(int index=1;index<=(int)num;index++)\n#define brep(index,num) for(int index=(int)num-1;index>=0;index--)\n#define brep1(index,num) for(int index=(int)num;index>0;index--)\n#define scan(argument) cin>>argument\n#define prin(argument) cout<<argument<<endl\n#define kaigyo cout<<endl\n#define eps 1e-7\n#define mp(a1,a2) make_pair(a1,a2)\n#define ALL(a) (a).begin(),(a).end()\n#define rALL(a) (a).rbegin(),(a).rend()\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef vector<pint> vpint;\ntypedef vector<pll> vpll;\nll INFl=(ll)1e+18+1;\nint INF=1e+9+1;\n\nnamespace internal {\n\ntemplate <class T> struct simple_queue {\n    std::vector<T> payload;\n    int pos = 0;\n    void reserve(int n) { payload.reserve(n); }\n    int size() const { return int(payload.size()) - pos; }\n    bool empty() const { return pos == int(payload.size()); }\n    void push(const T& t) { payload.push_back(t); }\n    T& front() { return payload[pos]; }\n    void clear() {\n        payload.clear();\n        pos = 0;\n    }\n    void pop() { pos++; }\n};\n}  // namespace internal\ntemplate <class Cap> struct mf_graph {\n  public:\n    mf_graph() : _n(0) {}\n    mf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        assert(0 <= cap);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result;\n        for (int i = 0; i < m; i++) {\n            result.push_back(get_edge(i));\n        }\n        return result;\n    }\n    void change_edge(int i, Cap new_cap, Cap new_flow) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        assert(0 <= new_flow && new_flow <= new_cap);\n        auto& _e = g[pos[i].first][pos[i].second];\n        auto& _re = g[_e.to][_e.rev];\n        _e.cap = new_cap - new_flow;\n        _re.cap = new_flow;\n    }\n\n    Cap flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    Cap flow(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n\n        std::vector<int> level(_n), iter(_n);\n        internal::simple_queue<int> que;\n\n        auto bfs = [&]() {\n            std::fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            que.clear();\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front();\n                que.pop();\n                for (auto e : g[v]) {\n                    if (e.cap == 0 || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    if (e.to == t) return;\n                    que.push(e.to);\n                }\n            }\n        };\n        auto dfs = [&](auto self, int v, Cap up) {\n            if (v == s) return up;\n            Cap res = 0;\n            int level_v = level[v];\n            for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                _edge& e = g[v][i];\n                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                if (d <= 0) continue;\n                g[v][i].cap += d;\n                g[e.to][e.rev].cap -= d;\n                res += d;\n                if (res == up) break;\n            }\n            return res;\n        };\n\n        Cap flow = 0;\n        while (flow < flow_limit) {\n            bfs();\n            if (level[t] == -1) break;\n            std::fill(iter.begin(), iter.end(), 0);\n            while (flow < flow_limit) {\n                Cap f = dfs(dfs, t, flow_limit - flow);\n                if (!f) break;\n                flow += f;\n            }\n        }\n        return flow;\n    }\n\n    std::vector<bool> min_cut(int s) {\n        std::vector<bool> visited(_n);\n        internal::simple_queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int p = que.front();\n            que.pop();\n            visited[p] = true;\n            for (auto e : g[p]) {\n                if (e.cap && !visited[e.to]) {\n                    visited[e.to] = true;\n                    que.push(e.to);\n                }\n            }\n        }\n        return visited;\n    }\n\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\nint main(){\n\tint H,W;\n    scan(H>>W);\n    mf_graph<int> g(H*W*2+2);\n    char a[102][102];\n    rep(i,H){\n        scan(a[i]);\n    }\n    rep(i,H){\n        rep(j,W){\n            if(a[i][j]=='X'&&(i==0||i==H-1||j==0||j==W-1)){\n                prin(-1);\n                return 0;\n            }\n        }\n    }\n    //横方向の辺\n    rep(i,H){\n        rep(j,W-1){\n            g.add_edge(i*W+j,i*W+j+1+H*W,INF);\n            g.add_edge(i*W+j+1,i*W+j+H*W,INF);\n        }\n    }\n    //縦方向の辺\n    rep(j,W){\n        rep(i,H-1){\n            g.add_edge(i*W+j,(i+1)*W+j+H*W,INF);\n            g.add_edge((i+1)*W+j,i*W+j+H*W,INF);\n        }\n    }\n    rep(i,H){\n        rep(j,W){\n            if(a[i][j]=='X'){\n                g.add_edge(2*H*W,i*W+j+H*W,INF);//sourceから山羊へ\n                g.add_edge(i*W+j+H*W,i*W+j,INF);//降り場から乗り場へ(柵を置けないので切れない)\n            }\n            else{\n                g.add_edge(i*W+j+H*W,i*W+j,1);//降り場から乗り場へ(ここを切りたい)\n            }\n            if(i==0||i==H-1||j==0||j==W-1){\n                g.add_edge(i*W+j,2*H*W+1,INF);//端のマスからsinkへ\n            }\n        }\n    }\n\n    prin(g.flow(2*H*W,2*H*W+1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n\nint n,m,nr,nc,cnt,ans,hit;\nchar x[105][105];\nbool fr[105][105],vis[105][105];\nqueue<pii> q;\n\nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n\nvoid mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\n\nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#', q.push({i+dr[k],j+dc[k]});\n\t}\n\tmk();\n\tint r,c;\n\trep(tes,1,100000000){\n\t\tif(q.empty())break;\n\t\tif(hit==2*q.size())break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0, mk();\n\t\telse if(!cnt)x[r][c] = '.', hit = 0, mk();\n\t\telse q.push({r,c}), ++hit;\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<fr[i][j];\n//\t\tcout<<endl;\n//\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++ans;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region head\n#include <bits/stdc++.h>\n\n#include <atcoder/maxflow>\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing pi = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate <class T>\nusing vv = vector<vector<T>>;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define repi(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rrepi(i, a, b) for (int i = (int)(b)-1; i >= (int)(a); i--)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define bit(n) (1LL << (n))\ntemplate <class T>\ninline bool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\ninline bool chmin(T &a, const T &b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nconst int INF = 1002003004;\nconst ll LINF = 1002003004005006007ll;\nstruct preprocess {\n    preprocess() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(20);\n    }\n} ____;\n#pragma endregion head\n\n#pragma region library\n#pragma endregion library\nint h, w;\nint coord(int x, int y, bool in) {\n    if (in) {\n        return x * w + y;\n    } else {\n        return h * w + (x * w + y);\n    }\n}\nint main() {\n    cin >> h >> w;\n    vv<char> grid(h, vector<char>(w));\n    rep(i, h) rep(j, w) cin >> grid[i][j];\n    mf_graph<int> g(2 * h * w + 2);\n    int s = 2 * h * w, t = 2 * h * w + 1;\n    bool flag = false;\n    rep(i, h) rep(j, w) {\n        if (i < h - 1) {\n            g.add_edge(coord(i, j, false), coord(i + 1, j, true), INF);\n            g.add_edge(coord(i + 1, j, false), coord(i, j, true), INF);\n        }\n        if (j < w - 1) {\n            g.add_edge(coord(i, j, false), coord(i, j + 1, true), INF);\n            g.add_edge(coord(i, j + 1, false), coord(i, j, true), INF);\n        }\n        if (grid[i][j] == 'X') {\n            g.add_edge(s, coord(i, j, true), INF);\n            g.add_edge(coord(i, j, true), coord(i, j, false), INF);\n        } else {\n            g.add_edge(coord(i, j, true), coord(i, j, false), 1);\n        }\n        if (i == 0 || i == h - 1 || j == 0 || j == w - 1) {\n            g.add_edge(coord(i, j, false), t, INF);\n            if (grid[i][j] == 'X') flag = true;\n        }\n    }\n    if (flag) {\n        cout << -1 << '\\n';\n        return 0;\n    }\n    cout << g.flow(s, t) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n//Ford-Fulkerson O(FE)\n#include<algorithm>\n#include<utility>\n#include<vector>\n#include<limits>\ntemplate<typename T>\nstruct MF{\n\tstruct edge{\n\t\tint to,rev;\n\t\tT cap;\n\t};\n\tvector<vector<edge> >G;\n\tvector<int>used;\n\tMF(int n_=0):G(n_),used(n_,0){}\n\tvoid add_edge(int from,int to,T cap)\n\t{\n\t\tG[from].push_back({to,(int)G[to].size(),cap});\n\t\tG[to].push_back({from,(int)G[from].size()-1,0});\n\t}\n\tT dfs(int u,int t,T f,int dfstime)\n\t{\n\t\tif(u==t)return f;\n\t\tused[u]=dfstime;\n\t\tfor(edge&e:G[u])\n\t\t{\n\t\t\tif(used[e.to]<dfstime&&e.cap>0)\n\t\t\t{\n\t\t\t\tT d=dfs(e.to,t,min(f,e.cap),dfstime);\n\t\t\t\tif(d>0)\n\t\t\t\t{\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tT max_flow(int s,int t)\n\t{\n\t\tT ret=0;\n\t\tfor(int dfstime=1;;dfstime++)\n\t\t{\n\t\t\tT f=dfs(s,t,numeric_limits<T>::max(),dfstime);\n\t\t\tif(f>0)ret+=f;\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n};\nint H,W;\nstring s[100];\nint d[4]={1,0,-1,0};\nmain()\n{\n\tcin>>H>>W;\n\tfor(int i=0;i<H;i++)cin>>s[i];\n\tMF<long>P(H*W*2+2);\n\tint st=H*W*2,go=H*W*2+1;\n\tfor(int i=0;i<H;i++)for(int j=0;j<W;j++)\n\t{\n\t\tint id=i*W+j;\n\t\tif(i==0||j==0||i==H-1||j==W-1)P.add_edge(id*2+1,go,1e9);\n\t\tif(s[i][j]=='X')\n\t\t{\n\t\t\tP.add_edge(st,id*2,1e9);\n\t\t\tP.add_edge(id*2,id*2+1,1e9);\n\t\t}\n\t\telse P.add_edge(id*2,id*2+1,1);\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint x=i+d[r],y=j+d[r^1];\n\t\t\tif(x<0||y<0||x>=H||y>=W)continue;\n\t\t\tP.add_edge(id*2+1,2*(x*W+y),1e9);\n\t\t}\n\t}\n\tlong ans=P.max_flow(st,go);\n\tif(ans<1e9)cout<<ans<<endl;\n\telse cout<<-1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef pair<int, int> pii;\n\n\n#define REP(i,n) for(int(i)=0;(i)<(int)(n);(i)++)\n\n#include <vector>\n#include <utility>\n\n\n#include <algorithm>\n\n\nchar board[310][310];\nint seen[310][310];\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nint go(int n, int m) {\n\tREP(i,n) scanf(\"%s\", board[i]);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (board[i][j] == 'X') {\n\t\t\t\tfor (int d = 0; d < 4; d++) {\n\t\t\t\t\tint nx = i + dx[d];\n\t\t\t\t\tint ny = j + dy[d];\n\t\t\t\t\tif (nx < 0 || nx >= n || ny < 0 || ny >= m) return -1;\n\t\t\t\t\tif (board[nx][ny] == '.') {\n\t\t\t\t\t\tboard[nx][ny] = 'G';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tqueue< pair<int, int> > q;\n\tREP(i,n) {\n\t\tseen[i][0] = seen[i][m-1]=1;\n\t\tq.push( {i, 0} );\n\t\tq.push( {i, m-1} );\n\t}\n\tREP(j,m) {\n\t\tseen[0][j] = seen[n-1][j] = 1;\n\t\tq.push( {0, j} );\n\t\tq.push( {n-1, j} );\n\t}\n\n\twhile (!q.empty()) {\n\t\tpii p = q.front();\n\t\tq.pop();\n\t\tint i = p.first;\n\t\tint j = p.second;\n\n\t\tif (board[i][j] == 'G') ans++;\n\t\tif (board[i][j] != '.') continue;\n\t\t\n\t\tfor (int d = 0; d < 4; d++) {\n\t\t\tint nx = i + dx[d];\n\t\t\tint ny = j + dy[d];\n\t\t\tif (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;\n\n\t\t\tif (!seen[nx][ny]) {\n\t\t\t\tq.push({nx,ny});\n\t\t\t\tseen[nx][ny] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nvoid solve() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tprintf(\"%d\\n\", go(n,m));\n}\n\n\nint main() {\n    solve();\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<unordered_set>\n#include<vector>\n#include<array>\n#include<string>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n#include<functional>\n#include<random>\n#include<complex>\n//#include<boost/multiprecision/cpp_int.hpp>\n#define int int64_t\n#define REP(i, a, b) for (int64_t i = (int64_t)(a); i < (int64_t)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (auto x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define Min(x) *min_element(ALL(x))\n#define Max(x) *max_element(ALL(x))\n#define Unique(L) (L.erase(unique(ALL(L)), L.end()))\nusing namespace std;\n//typedef boost::multiprecision::cpp_int bigint;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nclass graph_adjacentry {\nprivate:\n\tvector<vector<int>>matrix;\npublic:\n\tgraph_adjacentry(const int V) :matrix(V, vector<int>(V, 0)) {}\n\n\tvoid add_edge(const int from, const int to, const int weight) {\n\t\tmatrix[from][to] = weight;\n\t}\n\tvoid add_edge_undirected(const int x, const int y, const int weight) {\n\t\tmatrix[x][y] = weight;\n\t\tmatrix[y][x] = weight;\n\t}\n\n\tint get_weight(const int from, const int to)const {\n\t\treturn matrix[from][to];\n\t}\n\tint get_V()const { return matrix.size(); }\n};\nclass graph_sparse {\nprivate:\n\tvector<unordered_map<int, int>>edges;\npublic:\n\tgraph_sparse(const int V) :edges(V, unordered_map<int, int>(V)) {}\n\n\tvoid add_edge(const int from, const int to, const int weight) {\n\t\tedges[from][to] = weight;\n\t}\n\tvoid add_edge_undirected(const int x, const int y, const int weight) {\n\t\tedges[x][y] = weight;\n\t\tedges[y][x] = weight;\n\t}\n\n\tint get_weight(const int from, const int to)const {\n\t\tconst auto itr = edges[from].find(to);\n\t\tif (itr != edges[from].end())return itr->second;\n\t\treturn 0;\n\t}\n\tint get_V()const { return edges.size(); }\n};\nclass graph_key {\nprivate:\n\tunordered_map<string, int>names;\n\tvector<unordered_map<int, int>>edges;\npublic:\n\n\tvoid add_edge(const string from, const string to, const int weight) {\n\t\tint f, t;\n\t\tconst auto itr1 = names.find(from);\n\t\tconst auto itr2 = names.find(to);\n\n\t\tif (itr1 == names.end()) {\n\t\t\tf = edges.size();\n\t\t\tedges.resize(f + 1);\n\t\t}\n\t\telse f = itr1->second;\n\n\t\tif (itr2 == names.end()) {\n\t\t\tt = edges.size();\n\t\t\tedges.resize(t + 1);\n\t\t}\n\t\telse t = itr2->second;\n\n\t\tedges[f][t] = weight;\n\t}\n\tvoid add_edge_undirected(const string x, const string y, const int weight) {\n\t\tint a, b;\n\t\tconst auto itr1 = names.find(x);\n\t\tconst auto itr2 = names.find(y);\n\n\t\tif (itr1 == names.end()) {\n\t\t\ta = edges.size();\n\t\t\tedges.resize(a + 1);\n\t\t}\n\t\telse a = itr1->second;\n\n\t\tif (itr2 == names.end()) {\n\t\t\tb = edges.size();\n\t\t\tedges.resize(b + 1);\n\t\t}\n\t\telse b = itr2->second;\n\n\t\tedges[a][b] = weight;\n\t\tedges[b][a] = weight;\n\t}\n\n\n\tint get_weight(const string from, const string to)const {\n\n\t\tint f, t;\n\t\tconst auto itr1 = names.find(from);\n\t\tconst auto itr2 = names.find(to);\n\t\tif (itr1 == names.end())return 0;\n\t\telse f = itr1->second;\n\t\tif (itr2 == names.end())return 0;\n\t\telse t = itr2->second;\n\n\t\tconst auto itr = edges[f].find(t);\n\t\tif (itr != edges[f].end())return itr->second;\n\t\treturn 0;\n\t}\n\tint get_V()const { return edges.size(); }\n};\n\n\nint max_flow_push_relabel(\n\tconst int source,\n\tconst int sink,\n\tconst graph_adjacentry &capacity) {\n\n\tconst int V = capacity.get_V();\n\tconst int INF = 99999999;\n\n\tvector<int>h(V);\n\th[source] = V - 1;\n\n\tvector<int>maxh(V);\n\n\tgraph_adjacentry f(V);\n\tvector<int>e(V);\n\n\trep(i, V) {\n\t\tint c = capacity.get_weight(source, i);\n\t\tf.add_edge(source, i, c);//f[source][i] = cap[source][i];\n\t\tf.add_edge(i, source, -c);//f[i][source] = -f[source][i];\n\t\te[i] = c;\n\t}\n\n\tfor (int sz = 0;;) {\n\t\tif (sz == 0)rep(i, V) {\n\t\t\tif (i != source && i != sink && e[i] > 0) {\n\t\t\t\tif (sz != 0 && h[i] > h[maxh[0]])sz = 0;\n\t\t\t\tmaxh[sz++] = i;\n\t\t\t}\n\t\t}\n\t\tif (sz == 0)break;\n\t\twhile (sz != 0) {\n\t\t\tint i = maxh[sz - 1];\n\t\t\tbool pushed = false;\n\t\t\tfor (int j = 0; j < V && e[i] != 0; ++j) {\n\t\t\t\tint dw = capacity.get_weight(i, j) - f.get_weight(i, j);\n\t\t\t\tif (h[i] == h[j] + 1 && dw > 0) {\n\t\t\t\t\tint df = min(dw, e[i]);\n\t\t\t\t\tf.add_edge(i, j, f.get_weight(i, j) + df);\n\t\t\t\t\tf.add_edge(j, i, f.get_weight(j, i) - df);\n\t\t\t\t\te[i] -= df;\n\t\t\t\t\te[j] += df;\n\t\t\t\t\tif (e[i] == 0)--sz;\n\t\t\t\t\tpushed = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!pushed) {\n\t\t\t\th[i] = INF;\n\t\t\t\tfor (int j = 0; j < V; ++j) {\n\t\t\t\t\tint dw = capacity.get_weight(i, j) - f.get_weight(i, j);\n\t\t\t\t\tif (h[i] > h[j] + 1 && dw > 0)h[i] = h[j] + 1;\n\t\t\t\t}\n\t\t\t\tif (h[i] > h[maxh[0]]) {\n\t\t\t\t\tsz = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint flow = 0;\n\tfor (int i = 0; i < V; i++)flow += f.get_weight(source, i);\n\n\treturn flow;\n}\n\nsigned main(void) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint H, W;\n\tcin >> H >> W;\n\tgraph_adjacentry g(H * W * 2 + 2);\n\tconst int source = H * W * 2, sink = source + 1;\n\tconst int D[5] = { 0,1,0,-1,0 };\n\tconst int INF = 99999999;\n\n\t//柵は辺を塞ぐのではなくマス目を塞ぐ。最小カット問題に落とし込むために、\n\t//グリッドを仮想的に表と裏の2つ用意する。\n\t//(1)ソース→ヤギのいる表座標、\n\t//(2)任意の表座標→その4近傍の裏座標、\n\t//(3)端っこの表座標→シンク\n\t//の3要素をキャパ無限でつなぎ、\n\t//(4)任意の裏座標→表の同じ座標 をキャパ1でつなぐ。\n\t//裏から表へのパスをカットすることが\"柵を置く\"ことに等しい。\n\trep(i, H) {\n\t\tstring S;\n\t\tcin >> S;\n\t\trep(j, W) {\n\t\t\tconst int pos = i * W + j;\n\t\t\tif (S[j] == 'X') {\n\t\t\t\tif (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tg.add_edge(source, pos, INF);//(1)\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n\t\t\t\t\tg.add_edge(pos, sink, INF);//(3)\n\t\t\t\t}\n\t\t\t}\n\t\t\tg.add_edge(pos + H * W, pos, 1);//(4)\n\t\t\trep(k, 4) {\n\t\t\t\tconst int di = i + D[k];\n\t\t\t\tconst int dj = j + D[k + 1];\n\t\t\t\tif (!(0 <= di && di < H && 0 <= dj && dj < W))continue;\n\t\t\t\tg.add_edge(pos, di * W + dj + H * W, INF);//(2)\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << max_flow_push_relabel(source, sink, g) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n\tif(ans-9>100)return 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans-9<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105],z[105][105];\nbool fr[105][105],vis[105][105],st,ad,f;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,3){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==3){\n\t\t\t\t\tad = 0, f = 1;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\tst = 1, f = 0;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n//\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n//\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,3){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==3){\n\t\t\t\t\tad = 0, f = 1;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\tst = 1, f = 0;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n//\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\telse if(ans==tmp){\n//\t\t\t\t\t\t\t\tad = 0;\n//\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n//\t\t\t\t\t\t\t\tif(ad){\n//\t\t\t\t\t\t\t\t\tst = 1;\n//\t\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n//\t\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n//\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nconst int inf = 1012345678;\nstruct flow_edge {\n\tint to, cap, rev;\n\tflow_edge() : to(-1), cap(0), rev(-1) {};\n\tflow_edge(int to_, int cap_, int rev_) : to(to_), cap(cap_), rev(rev_) {};\n};\nint max_flow(vector<vector<flow_edge> > G, int src, int dst) {\n\tvector<bool> vis;\n\tfunction<int(int, int)> find_augment = [&](int pos, int curcap) {\n\t\tif (pos == dst) return curcap;\n\t\tvis[pos] = true;\n\t\tfor (flow_edge &e : G[pos]) {\n\t\t\tif (e.cap == 0 || vis[e.to]) continue;\n\t\t\tint res = find_augment(e.to, min(curcap, e.cap));\n\t\t\tif (res > 0) {\n\t\t\t\te.cap -= res;\n\t\t\t\tG[e.to][e.rev].cap += res;\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t};\n\tint ret = 0;\n\twhile (true) {\n\t\tvis = vector<bool>(G.size(), false);\n\t\tint res = find_augment(src, inf);\n\t\tret += res;\n\t\tif (res == 0) break;\n\t\tif (ret >= inf) return inf;\n\t}\n\treturn ret;\n}\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tint H, W;\n\tcin >> H >> W;\n\tvector<string> s(H);\n\tfor (int i = 0; i < H; i++) cin >> s[i];\n\tvector<vector<flow_edge> > G(2 * H * W + 2);\n\tfunction<void(int, int, int)> add_edge = [&](int va, int vb, int cap) {\n\t\tG[va].push_back(flow_edge(vb, cap, G[vb].size()));\n\t\tG[vb].push_back(flow_edge(va, 0, G[va].size() - 1));\n\t};\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tadd_edge(i * W + j, H * W + i * W + j, (s[i][j] == 'X' ? inf : 1));\n\t\t\tif (i >= 1) {\n\t\t\t\tadd_edge(H * W + i * W + j, i * W + j - W, inf);\n\t\t\t\tadd_edge(H * W + i * W + j - W, i * W + j, inf);\n\t\t\t}\n\t\t\tif (j >= 1) {\n\t\t\t\tadd_edge(H * W + i * W + j, i * W + j - 1, inf);\n\t\t\t\tadd_edge(H * W + i * W + j - 1, i * W + j, inf);\n\t\t\t}\n\t\t\tif (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n\t\t\t\tadd_edge(H * W + i * W + j, 2 * H * W + 1, inf);\n\t\t\t}\n\t\t\tif (s[i][j] == 'X') {\n\t\t\t\tadd_edge(2 * H * W, i * W + j, inf);\n\t\t\t}\n\t\t}\n\t}\n\tint ret = max_flow(G, 2 * H * W, 2 * H * W + 1);\n\tcout << (ret != inf ? ret : -1) << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <tuple>\n#include <algorithm>\n#include <functional>\n#include <cstring>\n#include <limits.h>\n#define FOR(i,k,n)  for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n)    FOR(i,0,n)\n#define FORIT(i,c)\tfor(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define SZ(i) ((int)i.size())\n#define pb          push_back\n#define mp          make_pair\n#define mt          make_tuple\n#define get0(x)     (get<0>(x))\n#define get1(x)     (get<1>(x))\n#define get2(x)     (get<2>(x))\n#define ALL(X)      (X).begin(),(X).end()\n#define LLMAX       9223372036854775807LL\n#define LLMIN       -9223372036854775808LL\n#define IMAX        2147483647\n#define IMIN        -2147483648\ntypedef long long LL;\nusing namespace std;\n\n#define MAX_V 200000+4\n\nstruct Edge{ int to,cap,rev; };\nint used[MAX_V];\nvector<Edge> G[MAX_V];\n\nvoid addEdge(int from,int to,int cap){\n    G[from].push_back((Edge){to,cap,(int)G[to].size()});\n    G[to].push_back((Edge){from,0,(int)G[from].size()-1});\n}\nint DFS(int v,int t,int f){\n    if(v==t)\n        return f;\n    used[v]=true;\n    for(int i=0;i<(int)G[v].size();i++){\n        Edge &e=G[v][i];\n        if(!used[e.to] && 0<e.cap){\n            int d=DFS(e.to,t,min(f,e.cap));\n            if(0<d){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\nint maxFlow(int s,int t){\n    int flow=0;\n    while(1){\n        for(int i=0;i<MAX_V;i++)\n            used[i]=false;\n        int f=DFS(s,t,INT_MAX);\n        if(f==0)\n            break;\n        flow+=f;\n    }\n    return flow;\n}\n\nconst int INF = 1e8;\n\nint main(void){\n    int H,W;cin>>H>>W;\n    vector<string> vs;\n    REP(i,H){string s;cin>>s;vs.pb(s);}\n\n    int d[4][2]={{-1,0},{1,0},{0,-1},{0,1}};\n    int src=2*H*W,dst=2*H*W+1;\n    REP(i,H)\n        REP(j,W){\n            if(i==0||j==0||i==H-1||j==W-1)\n                addEdge(i*W+j+H*W,dst,INF);\n            if(vs[i][j]=='X'){\n                addEdge(src,i*W+j,INF);\n                addEdge(i*W+j,i*W+j+H*W,INF);\n            }\n            else\n                addEdge(i*W+j,i*W+j+H*W,1);\n            REP(k,4){\n                int ii=i+d[k][0],jj=j+d[k][1];\n                if(0<=ii&&ii<H&&0<=jj&&jj<W)\n                    addEdge(i*W+j+H*W,ii*W+jj,INF);\n            }\n        }\n\n    int f=maxFlow(src,dst);\n    if(INF<=f)\n        cout<<-1<<endl;\n    else\n        cout<<f<<endl;\n     return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans-4<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define for(i, a, b) for(ll (i)=a;(i)<(b);++(i))\n#define rep(i, n)    for(i, 0, n)\n#define MAX_V        20004\n\nconst ll inf = 1e15;\nconst ll mod = 1e9+7;\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nstruct edge {\n    ll to, cap, rev;\n    edge(ll t, ll c, ll r): to(t), cap(c), rev(r){}\n};\n\nvector<edge> G[MAX_V];\nll level[MAX_V];\nll iter[MAX_V];\n\nvoid add_edge(ll from, ll to, ll cap) {\n    G[from].push_back(edge(to, cap, G[to].size()));\n    G[to].push_back(edge(from, 0, G[from].size() - 1));\n}\n\nvoid bfs(ll s) {\n    memset(level, -1, sizeof(level));\n    queue<ll> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n        ll v = que.front(); que.pop();\n        rep(i, G[v].size()) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nll dfs(ll v, ll t, ll f) {\n    if (v == t) return f;\n    for(i, iter[v], G[v].size()) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[v] < level[e.to]) {\n            ll d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nll max_flow(ll s, ll t) {\n    ll flow = 0;\n    while (true) {\n        bfs(s);\n        if (level[t] < 0) return flow;\n        memset(iter, 0, sizeof(iter));\n        ll f;\n        while ((f = dfs(s, t, inf)) > 0) {\n            flow += f;\n        }\n    }\n}\n\nchar field[101][101];\nint main() {\n    ll H, W; cin >> H >> W;\n    rep(i, H) rep(j, W) {\n        cin >> field[i][j];\n        if (field[i][j] == 'X' && (i == 0 || i == H-1 || j == 0 || j == W-1)) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n    \n    ll S = 2 * H * W;\n    ll T = 2 * H * W + 1;\n    rep(i, H) rep(j, W) {\n        if (field[i][j] == 'X') add_edge(S, i * W + j, inf);\n        add_edge(i * W + j, H * W + i * W + j, field[i][j] == 'X' ? inf : 1);\n        \n        if (i == 0 || i == H-1 || j == 0 || j == W-1) add_edge(H * W + i * W + j, T, inf);\n        if (i > 0)   add_edge(H * W + i * W + j, (i-1) * W + j, inf);\n        if (i < H-1) add_edge(H * W + i * W + j, (i+1) * W + j, inf);\n        if (j > 0)   add_edge(H * W + i * W + j, i * W + (j-1), inf);\n        if (i < W-1) add_edge(H * W + i * W + j, i * W + (j+1), inf);\n    }\n    cout << max_flow(S, T) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define SPEED ios::sync_with_stdio(false); cin.tie(0); cout.tie(0)\n#define fileio freopen(\"in.in\", \"r\", stdin),freopen(\"out.out\", \"w\", stdout);\n#define ll long long int\n#define FF first\n#define SS second\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<long long int,long long int>\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define pd(x) printf(\"%d\\n\",x)\n#define plld(x) printf(\"%lld\\n\",x)\n#define pss printf\n#define MOD 1000000007\n#define INF 1e6\n#define eps 0.00001\n#define endl '\\n'\n#define debug(n1) cout<<n1<<endl\nll h,w;\nbool vis[105][105];\nstring s;\nll get(ll i,ll j)\n{\n\treturn (i-1)*w+j;\n}\ntypedef long long LL;\n\nstruct Edge {\n  int from, to, cap, flow, index;\n  Edge(int from, int to, int cap, int flow, int index) :\n    from(from), to(to), cap(cap), flow(flow), index(index) {}\n};\n\nstruct PushRelabel {\n  int N;\n  vector<vector<Edge> > G;\n  vector<LL> excess;\n  vector<int> dist, active, count;\n  queue<int> Q;\n\n  PushRelabel(int N) : N(N), G(N), excess(N), dist(N), active(N), count(2*N) {}\n\n  void AddEdge(int from, int to, int cap) {\n    G[from].push_back(Edge(from, to, cap, 0, G[to].size()));\n    if (from == to) G[from].back().index++;\n    G[to].push_back(Edge(to, from, 0, 0, G[from].size() - 1));\n  }\n\n  void Enqueue(int v) { \n    if (!active[v] && excess[v] > 0) { active[v] = true; Q.push(v); } \n  }\n\n  void Push(Edge &e) {\n    int amt = int(min(excess[e.from], LL(e.cap - e.flow)));\n    if (dist[e.from] <= dist[e.to] || amt == 0) return;\n    e.flow += amt;\n    G[e.to][e.index].flow -= amt;\n    excess[e.to] += amt;    \n    excess[e.from] -= amt;\n    Enqueue(e.to);\n  }\n  \n  void Gap(int k) {\n    for (int v = 0; v < N; v++) {\n      if (dist[v] < k) continue;\n      count[dist[v]]--;\n      dist[v] = max(dist[v], N+1);\n      count[dist[v]]++;\n      Enqueue(v);\n    }\n  }\n\n  void Relabel(int v) {\n    count[dist[v]]--;\n    dist[v] = 2*N;\n    for (int i = 0; i < G[v].size(); i++) \n      if (G[v][i].cap - G[v][i].flow > 0)\n\tdist[v] = min(dist[v], dist[G[v][i].to] + 1);\n    count[dist[v]]++;\n    Enqueue(v);\n  }\n\n  void Discharge(int v) {\n    for (int i = 0; excess[v] > 0 && i < G[v].size(); i++) Push(G[v][i]);\n    if (excess[v] > 0) {\n      if (count[dist[v]] == 1) \n\tGap(dist[v]); \n      else\n\tRelabel(v);\n    }\n  }\n\n  LL GetMaxFlow(int s, int t) {\n    count[0] = N-1;\n    count[N] = 1;\n    dist[s] = N;\n    active[s] = active[t] = true;\n    for (int i = 0; i < G[s].size(); i++) {\n      excess[s] += G[s][i].cap;\n      Push(G[s][i]);\n    }\n    \n    while (!Q.empty()) {\n      int v = Q.front();\n      Q.pop();\n      active[v] = false;\n      Discharge(v);\n    }\n    \n    LL totflow = 0;\n    for (int i = 0; i < G[s].size(); i++) totflow += G[s][i].flow;\n    return totflow;\n  }\n};\nint main()\n{\n\tSPEED;\n\tmemset(vis,1,sizeof vis);\n\tcin>>h>>w;\n\tfor(int i=1;i<=h;i++)\n\t{\n\t\tcin>>s;\n\t\tfor(int j=1;j<=w;j++)\n\t\t{\n\t\t\tif(s[j-1]!='X')\n\t\t\t{\n\t\t\t\tvis[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=h;i++)\n\t\tif(vis[i][1]||vis[i][w])\n\t\t\treturn cout<<-1<<endl,0;\n\tfor(int i=1;i<=w;i++)\n\t\tif(vis[1][i]||vis[h][i])\n\t\t\treturn cout<<-1<<endl,0;\n\tPushRelabel pr(2*h*w+5);\n\tfor(int i=1;i<=h;i++)\n\t\tfor(int j=1;j<=w;j++)\n\t\t\tpr.AddEdge(get(i,j),get(i,j)+h*w,(vis[i][j]?INF:1));\n\tfor(int i=1;i<=h;i++)\n\t{\n\t\tfor(int j=1;j<=w;j++)\n\t\t{\n\t\t\tif(vis[i][j])\n\t\t\t\tpr.AddEdge(0,get(i,j),INF);\n\t\t\tif(!vis[i-1][j])\n\t\t\t\tpr.AddEdge(get(i,j)+h*w,get(i-1,j),INF);\n\t\t\tif(!vis[i+1][j])\n\t\t\t\tpr.AddEdge(get(i,j)+h*w,get(i+1,j),INF);\n\t\t\tif(!vis[i][j-1])\n\t\t\t\tpr.AddEdge(get(i,j)+h*w,get(i,j-1),INF);\n\t\t\tif(!vis[i][j+1])\n\t\t\t\tpr.AddEdge(get(i,j)+h*w,get(i,j+1),INF);\n\t\t}\n\t}\n\tfor(int i=1;i<=h;i++)\n\t{\n\t\tpr.AddEdge(h*w+get(i,1),2*h*w+1,INF);\n\t\tpr.AddEdge(h*w+get(i,w),2*h*w+1,INF);\n\t}\n\tfor(int i=1;i<=w;i++)\n\t{\n\t\tpr.AddEdge(h*w+get(1,i),2*h*w+1,INF);\n\t\tpr.AddEdge(h*w+get(h,i),2*h*w+1,INF);\n\t}\n\tcout<<pr.GetMaxFlow(0,2*h*w+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105];\nbool fr[105][105],vis[105][105],st,ad,f;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = f = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = f = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n){\n\t\trep(j,1,m)cout<<x[i][j];\n\t\tcout<<endl;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr,Vpr> PQ;\nconst int INF=1<<30;\nstruct Edge{\npublic:\n\tint to,cost,cp;\n\tEdge *rev;\n\tEdge(int t,int c,int cp):to(t),cost(c),cp(cp){\n\t\t\n\t}\n\tvoid add(int x){\n\t\tcp+=x;\n\t}\n\tvoid flow(int amount){\n\t\tadd(-amount);\n\t\trev->add(amount);\n\t}\n\tbool usable(){\n\t\treturn cp>=1;\n\t}\t\n};\nvoid unite(Edge &a,Edge &b){\n\ta.rev=&b;\n\tb.rev=&a;\n}\nclass Graph{\n\tint nodeSize,edgeSize;\n\tvector<int> dist;\n\tvector<vector<Edge> > edges;\npublic: \n\tvoid add(int a,int b,int cost,int cp){\n\t\tedges[a].PB(Edge(b,cost,cp));\n\t\tedges[b].PB(Edge(a,cost,0));\n\t\tunite(edges[a].back(),edges[b].back());\n\t}\n\tGraph(int x):nodeSize(x){\n\t\t\n\t\tedges=vector<vector<Edge> >(nodeSize);\n\t\tdist=VI(nodeSize);\n\t}\n\tvoid distInit(int s){\n\t\tREP(i,nodeSize){\n\t\t\tdist[i]=INF;\n\t\t}\n\t\tdist[s]=0;\n\t}\n\tint searching(int now,int e,int capacity){\n\t\tif(capacity==0) return 0;\n\t\tif(now==e) return capacity;\n\t\tif(dist[now]>=dist[e]) return 0;\n\t\tint flowed=0;\n\t\tREP(i,edges[now].size()){\n\t\t\tEdge *ed= &edges[now][i];\n\t\t\tif(!ed->usable()) continue;\n\t\t\tif(dist[now]+1 != dist[ed->to]) continue;\n\t\t\tint nflow=searching(ed->to,e,min(capacity-flowed,ed->cp));\n\t\t\tif(nflow){\n\t\t\t\tflowed+=nflow;\n\t\t\t\ted->flow(nflow);\n\t\t\t}\n\t\t\tif(flowed) return flowed;\n\t\t}\n\t\treturn flowed;\n\t}\n\tbool bfs(int s,int e){\n\t\tdistInit(s);\n\t\tqueue<int> qu;\n\t\tqu.push(s);\n\t\twhile(!qu.empty()){\n\t\t\tint now=qu.front();\n\t\t\tif(now==e) return true;\n\t\t\tqu.pop();\n\t\t\tREP(i,edges[now].size()){\n\t\t\t\tEdge *ed= &edges[now][i];\n\t\t\t\tif(!ed->usable()) continue;\n\t\t\t\tif(dist[ed->to]==INF){\n\t\t\t\t\tqu.push(ed->to);\n\t\t\t\t\tdist[ed->to]=dist[now]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint maximumFlow(int s,int e){\n\t\tint ans=0;\n\t\twhile(bfs(s,e)){\n\t\t\tans+=searching(s,e,INF);\n\t\t}\n\t\treturn ans;\n\t}\n};\nconst int SIZE=101;\nint conv(int a,int b,int c){return a*100+b+SIZE*SIZE*c+2;}\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\nint H,W;\nint maps[101][101];\nGraph graph(SIZE*SIZE*3+2);\nbool isSafe(int y,int x){\n\treturn 0<=y && y<H && 0<=x && x<W;\n}\nint main(){\n\tcin >> H >> W;\n\tREP(i,H) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,s.size()){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(maps[i][j] &&(i==0 || j==0 || i==H-1 || j==W-1)){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\t\t\n\t}\n\tREP(i,H) REP(j,W) {\n\t\tgraph.add(conv(i,j,1),conv(i,j,0),0,1);\n//\t\tedges[conv(i,j,1)].PB(edge(conv(i,j,0),0,1));\n\t\tif(maps[i][j]){\n\t\t\t//edges[0].PB(edge(conv(i,j,1),0,1));\n\t\t\tgraph.add(0,conv(i,j,0),0,4);\n\t\t}\n\t\tREP(k,4){\n\t\t\tif(!isSafe(i+dy[k],j+dx[k])){\n\t\t\tgraph.add(conv(i,j,0),1,0,1);\n\t\t\t//\tedges[conv(i,j,0)].PB(edge(1,0,1));\n\t\t\t} \n\t\t\telse if(!maps[i+dy[k]][j+dx[k]]){\n\t\t\t\tgraph.add(conv(i,j,0),conv(i+dy[k],j+dx[k],1),0,1);\n\t\t\t\tgraph.add(conv(i+dy[k],j+dx[k],0),conv(i,j,1),0,1);\n//\t\t\t\tedges[conv(i,j,0)].PB(edge(conv(i+dy[k],j+dx[k],1),0,1));\n//\t\t\t\tedges[conv(i+dy[k],j+dx[k],0)].PB(edge(conv(i,j,1),0,1));\n\t\t\t}\n\t\t}\n\t\n\t}\n\tcout << graph.maximumFlow(0,1) << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n\n#define MAX_V 100000\n#define HMAX 102\n#define WMAX 102\n#define INF (int)1e9\n\nusing namespace std;\n\nint H,W;\nchar S[HMAX][WMAX];\nstatic const int dx[] = {0,1,0,-1},dy[] = {1,0,-1,0};\n\nstruct edge{int to,cap,rev;};\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n\tG[from].push_back((edge){to,cap,(int)G[to].size()});\n\tG[to].push_back((edge){from,0,(int)G[from].size()-1});\n}\n\nint dfs(int v, int t,int f){\n\tif(v == t) return f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i)\n\t{\n\t\tedge &e = G[v][i];\n\t\tif(!used[e.to] && e.cap > 0){\n\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint number(int a,int b,int c){\n\treturn a*W+b+1+H*W*c;\n}\n\nint max_flow(int s, int t){\n\tint flow = 0;\n\tfor(;;){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f = dfs(s,t,INF);\n\t\tif(f == 0) return flow;\n\t\tflow += f;\n\t}\n}\nint main(){\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; ++i)\n\t{\n\t\tfor (int j = 0; j < W; ++j)\n\t\t{\n\t\t\tcin >> S[i][j];\n\t\t\tif(S[i][j] != 'X'){\n\t\t\t\tadd_edge(number(i,j,0),number(i,j,1),1);\n\t\t\t}else{\n\t\t\t\tadd_edge(0,number(i,j,0),INF);\n\t\t\t\tadd_edge(number(i,j,0),number(i,j,1),INF);\n\t\t\t}\n\t\t\tif(i == 0 || i == H-1 || j == 0 || j == W-1){\n\t\t\t\tadd_edge(number(i,j,1),H*W*2+1,INF);\n\t\t\t\tif(S[i][j] == 'X'){\n\t\t\t\t\tcout << \"-1\\n\";\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < 4; ++k)\n\t\t\t{\n\t\t\t\tif(i+dx[k] >= 0 && i+dx[k] < H && j+dy[k] >= 0 && j+dy[k] < W){\n\t\t\t\t\tadd_edge(number(i,j,1),number(i+dx[k],j+dy[k],0),INF);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = max_flow(0,H*W*2+1);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans-6<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<ut,VI> PQ;\nclass UnionFind{\n \n\tvector<int> unions,talls,sents,dists,sizes;\n\tint size;\npublic:\n\tUnionFind(){}\n\tUnionFind(int size):size(size){\n\t\tinit();\n\t}\n\tvoid init(){\n\t \tunions=vector<int>(size);\n\t \ttalls=vector<int>(size);\n\t \tsents=vector<int>(size);\n\t \tdists=vector<int>(size);\n\t \tsizes=vector<int>(size);\n\t\tFOR(i,0,size){\n\t\t\tunions[i]=i;\n\t\t\tsents[i]=0;\n\t\t\tsizes[i]=1;\n//\t\t\tns[i].PB(pr(0,1));\n\t\t\ttalls[i]=1;\n\t\t}\n\t}\n\tint find(int x,int t=0){\n\t\tif(unions[x]==x || sents[x]>t) return x;\n\t\treturn find(unions[x],t);\n \n\t}\n\tint minisize(int x){\n\t\tif(x==unions[x]) return sizes[x];\n\t\treturn minisize(find(x));\n\t}\n\tbool isFriend(int a,int b,int t=0){\n\t\treturn find(a,t)==find(b,t);\t\n\t}\n\tvoid unite(int a,int b,int t=0){\n\t\tif(isFriend(a,b,t)) return;\n\t\ta=find(a,t);\n\t\tb=find(b,t);\n\t\tif(talls[a]<talls[b]) unite(b,a,t);\n\t\telse{\n \t\t\tsizes[a]+=sizes[b];\n\t\t\tsents[b]=t;\n\t\t\ttalls[a]=max(talls[a],talls[b]+1);\n\t\t\tunions[b]=a;\n\t\t\tdists[b]=1;\n//\t\t\tns[a].PB(pr(t,ns[b].back().second+ns[a].back().second));\n\t\t}\n\t}\n};\nUnionFind uf;\nconst ut INF=1LL<<30;\nconst int SIZE=201;\nint maps[SIZE][SIZE];\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\ncli d[4];\nbool searched[SIZE][SIZE][3];\nint conv(cli x){\n\treturn x.real()*1000+x.imag()+10000;\n}\nint solve(){\n\tuf=UnionFind(200000);\n\tREP(i,4) d[i]=cli(dy[i],dx[i]);\n\tint H,W;\n\tcin >> H >> W;\n\tqueue<cli> qu;\n\tREP(i,H){\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,W){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(i==0 or j==0 or i==H-1 or j==W-1) {\n\t\t\t\tif(maps[i][j]) return -1;\n\t\t\t\tmaps[i][j]=-1;\n\t\t\t\tqu.push(cli(j,i));\n\t\t\t}\n\t\t}\n\t}\n\tqueueing:\n\twhile(!qu.empty()){\n\t\tcli now=qu.front();\n\t\tqu.pop();\n\t\t\n\t\t//if(maps[now.imag()][now.real()]==1) count++;\n\t\t//if(count==1e7) return -1;\n\t\tif(maps[now.imag()][now.real()]==-1){\n\t\t\tint around=0;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(next.imag()==-1 or next.real()==-1 or next.imag()==H or next.real()==W) continue;\n\t\t\t\tif(maps[next.imag()][next.real()]==1) around+=2;\n\t\t\t\tif(maps[next.imag()][next.real()]==0) around++; \n\t\t\t}\n\t\t\tif(around<=1){\n\t\t\t\tmaps[now.imag()][now.real()]=2;\n\t\t\t\tREP(i,4){\n\t\t\t\t\tcli next=now+d[i];\n\t\t\t\t\tif(next.imag()==-1 or next.real()==-1 or next.imag()==H or next.real()==W) continue;\n\t\t\t\t\tif(maps[next.imag()][next.real()]==0){\n\t\t\t\t\t\tmaps[next.imag()][next.real()]=-1;\n\t\t\t\t\t\tqu.push(next);\n\t\t\t\t\t} \n\t\t\t\t}\n\t\t\t}\n\t\t} \t\t\n\t}\n\tint ans=0;\n\tREP(i,H){\n\t\tREP(j,W){\n\t\t//\tcout << maps[i][j]+1;\n\t\t\tans+=maps[i][j]==-1;\n\t\t}\n\t//\tcout << endl;\n\t}\n\treturn ans;\n}\nint main(){\n\tcout << solve() << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\nchar s[111][111];\nint N,M;\nbool Out(int x,int y){\n    return x<0||y<0||x>=N||y>=M;\n}\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint main(){\n    RII(N,M);\n    REP(i,N)RS(s[i]);\n    REP(i,N)\n        if(s[i][0]=='X'||s[i][M-1]=='X')return 0*puts(\"-1\");\n    REP(i,M)\n        if(s[0][i]=='X'||s[N-1][i]=='X')return 0*puts(\"-1\");\n    REP(i,N){\n        int ll=M-1,rr=0;\n        REP(j,M){\n            if(s[i][j]=='X')ll=min(ll,j),rr=max(rr,j);\n        }\n        REPP(j,ll,rr+1)s[i][j]='X';\n    }\n\n    REP(i,M){\n        int ll=N-1,rr=0;\n        REP(j,N){\n            if(s[j][i]=='X')ll=min(ll,j),rr=max(rr,j);\n        }\n        REPP(j,ll,rr+1)s[j][i]='X';\n    }\n\n    REPP(i,-M+1,N){\n        int ll=M-1,rr=0;\n        REP(j,M){\n            if(!Out(i+j,j)&&s[i+j][j]=='X')ll=min(ll,j),rr=max(rr,j);\n        }\n        REPP(j,ll,rr+1)s[i+j][j]='X';\n    }\n    REPP(i,-N+1,M){\n        int ll=N-1,rr=0;\n        REP(j,N){\n            if(!Out(j,i+j)&&s[j][i+j]=='X')ll=min(ll,j),rr=max(rr,j);\n        }\n        REPP(j,ll,rr+1)s[j][i+j]='X';\n    }\n    int an=0;\n    REP(i,N)REP(j,M){\n        if(s[i][j]=='X')continue;\n        REP(k,4){\n            int nx=i+dx[k];\n            int ny=j+dy[k];\n            if(!Out(nx,ny)&&s[nx][ny]=='X'){\n                an++;\n                break;\n            }\n        }\n    }\n    printf(\"%d\\n\",an);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nint H, W;\nstring b[100];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nvoid dfs(int x, int y) {\n\tif(b[y][x] == '#') {\n\t\tb[y][x] = '$';\n\t\treturn;\n\t}\n\tif(b[y][x] != '.') return;\n\tb[y][x] = '@';\n\tfor(int k = 0; k < 4; k++) {\n\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\tif(in(nx, ny)) {\n\t\t\tif(b[ny][nx] == '#') b[ny][nx] = '$';\n\t\t\tif(b[ny][nx] == '.') dfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++) {\n\t\tcin >> b[i];\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\tif(b[i][0] == 'X' || b[i][W - 1] == 'X') {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = 0; i < W; i++) {\n\t\tif(b[0][i] == 'X' || b[H - 1][i] == 'X') {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(b[y][x] == 'X') {\n\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\tif(b[ny][nx] == '.') b[ny][nx] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\tdfs(0, i);\n\t\tdfs(W - 1, i);\n\t}\n\tfor(int i = 0; i < W; i++) {\n\t\tdfs(i, 0);\n\t\tdfs(i, H - 1);\n\t}\n\n\tfor(int i = 0; i < H; i++) {\n\t\t//cout << b[i] << endl;\n\t}\n\n\tint ans = 0;\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(b[y][x] == '$') ans++;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define fst first\n#define snd second\ntypedef long long ll;\ninline void Fail(){printf(\"-1\");exit(0);}\n\nconst int maxn=105;\nconst int maxm=20005;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nint n,m;\nchar c[maxn][maxn];\n\nclass max_flow{\npublic:\n\tint s,t;\n\tclass EDGE{\n\tpublic:\n\t\tint to,cap,rev;\n\t\tEDGE(int _to,int _cap,int _rev){to=_to;cap=_cap;rev=_rev;}\n\t};\n\tvector<EDGE>edge[maxm];\n\tint lvl[maxm],nxt[maxm],q[maxm];\n\tvoid add_edge(int from,int to,int cap){\n//\t\tcout<<from<<\" \"<<to<<endl;\n\t\tedge[from].pb(EDGE(to,cap,edge[to].size()));\n\t\tedge[to].pb(EDGE(from,0,edge[from].size()-1));\n\t}\n\tvoid bfs(){\n\t\tint l=0,r=0;\n\t\tmemset(lvl,-1,sizeof(lvl));\n\t\tlvl[s]=0;\n\t\tq[r++]=s;\n\t\twhile(l<r){\n\t\t\tint x=q[l++];\n\t\t\trep(i,edge[x].size()){\n\t\t\t\tEDGE &y=edge[x][i];\n\t\t\t\tif(y.cap&&lvl[y.to]<0){\n\t\t\t\t\tlvl[y.to]=lvl[x]+1;\n\t\t\t\t\tq[r++]=y.to;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int x,int f){\n\t\tif(x==t)return f;\n\t\tfor(int &i=nxt[x];i<edge[x].size();i++){\n\t\t\tEDGE &y=edge[x][i];\n\t\t\tif(y.cap&&lvl[y.to]==lvl[x]+1){\n\t\t\t\tint d=dfs(y.to,min(f,y.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\ty.cap-=d;\n\t\t\t\t\tedge[y.to][y.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint mf(){\n\t\tint res=0;\n\t\twhile(true){\n\t\t\tbfs();\n\t\t\tif(lvl[t]<0)return res;\n\t\t\tmemset(nxt,0,sizeof(nxt));\n\t\t\tint f;\n\t\t\twhile((f=dfs(s,INF))>0)res+=f;\n\t\t}\n\t}\n}M;\n\nint get_id(int i,int j,int tp){\n\treturn (i*m+j)*2+tp;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,n)scanf(\"%s\",c[i]);\n\tM.s=n*m*2,M.t=n*m*2+1;\n\trep(i,n)rep(j,m){\n\t\tif(c[i][j]=='X'){\n\t\t\tM.add_edge(get_id(i,j,0),get_id(i,j,1),INF);\n\t\t\tM.add_edge(get_id(i,j,1),M.t,INF);\n\t\t\tif(!i||i==n-1||!j||j==m-1){\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tM.add_edge(get_id(i,j,0),get_id(i,j,1),1);\n\t\t\tif(!i||i==n-1||!j||j==m-1)M.add_edge(M.s,get_id(i,j,0),INF);\n\t\t}\n\t\trep(k,4){\n\t\t\tint ni=i+dx[k],nj=j+dy[k];\n\t\t\tif(ni>=0&&ni<n&&nj>=0&&nj<m){\n\t\t\t\tM.add_edge(get_id(i,j,1),get_id(ni,nj,0),INF);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",M.mf());\n\treturn 0;\n}\n\n/*\nInput:\n5 4\n....\n..X.\n.XX.\n..X.\n....\n-----------------\nOutput:\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint n,m;\nvector<string>in,out;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nvoid dfs(int x,int y){\n\tout[x][y]=',';\n\trep(i,4){\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\t\tif(nx<0||ny<0||nx>=n||ny>=m)continue;\n\t\tif(out[nx][ny]=='.')dfs(nx,ny);\n\t\telse if(out[nx][ny]=='!')out[nx][ny]='#';\n\t}\n}\nint main(){\n\tcin>>n>>m;\n\tin=vector<string>(n);\n\trep(i,n)cin>>in[i];\n\tout=in;\n\trep(i,n)rep(j,m)out[i][j]='.';\n\tbool h=true;\n\trep(i,n)rep(j,m)if(i==0||j==0||i==n-1||j==m-1){\n\t\tif(in[i][j]=='X')h=false;\n\t}\n\tif(!h){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\trep(i,n)rep(j,m)if(in[i][j]=='X'){\n\t\tout[i+1][j]=out[i-1][j]=out[i][j+1]=out[i][j-1]='!';\n\t}\n//\trep(i,n)cout<<out[i]<<endl;\n\trep(i,n)rep(j,m)if(i==0||j==0||i==n-1||j==m-1){\n\t\tif(out[i][j]=='.')dfs(i,j);\n\t}\n\tint co=0;\n\trep(i,n)rep(j,m)if(out[i][j]=='#')co++;\n\tcout<<co<<endl;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nint m;\nstring a[123];\nbool used[123][123];\nbool was[123][123];\n\nvoid dfs(int x, int y) {\n  if (x < 0 || x >= n || y < 0 || y >= m) return;\n  if (was[x][y]) return;\n  was[x][y] = true;\n  if (used[x][y]) return;\n  for (int dx = -1; dx <= 1; ++dx) {\n    for (int dy = -1; dy <= 1; ++dy) {\n      if (abs(dx) + abs(dy) == 1) {\n        dfs(x + dx, y + dy);\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> m;\n  int xa = 123, xb = -123;\n  int ya = 123, yb = -123;\n  for (int x = 0; x < n; ++x) {\n    cin >> a[x];\n    for (int y = 0; y < m; ++y) {\n      if (a[x][y] == 'X') {\n        if (x == 0 || x == n - 1 || y == 0 || y == m - 1) {\n          cout << \"-1\" << endl;\n          return 0;\n          xa = min(xa, x);\n          xb = max(xb, x);\n          ya = min(ya, y);\n          yb = max(yb, y);\n        }\n      }\n    }\n  }\n  for (int x = 0; x < n; ++x) {\n    for (int y = 0; y < m; ++y) {\n      if (a[x][y] == '.') continue;\n      for (int dx = -1; dx <= 1; ++dx) {\n        for (int dy = -1; dy <= 1; ++dy) {\n          if (abs(dx) + abs(dy) != 1) continue;\n          int nx = x + dx;\n          int ny = y + dy;\n          if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;\n          used[nx][ny] = true;\n        }\n      }\n    }\n  }\n  for (int x = 0; x < n; ++x) {\n    dfs(x, 0);\n    dfs(x, m - 1);\n  }\n  for (int y = 0; y < m; ++y) {\n    dfs(0, y);\n    dfs(n - 1, y);\n  }\n  int ans = 0;\n  for (int x = 0; x < n; ++x) {\n    for (int y = 0; y < m; ++y) {\n      if (used[x][y] && was[x][y]) {\n        ++ans;\n      }\n    }\n  }\n  cout << min(ans, 2 * (xb - xa + 1) + 2 * (yb - ya + 1)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int, int>\n#define vii vector<pii>\n#define ll long long\n#define mp(x, y) make_pair(x, y)\n#define pb(x) push_back(x)\n\nchar arr[105][105] = {};\nint h, w;\n\n\nbool canBeRemoved(int r, int c) {\n\tbool visited[105][105] = {};\n\tstack< pii > s;\n\ts.push(mp(r, c));\n\tvisited[r][c] = true;\n\t\n\tfor(int i = 0; !s.empty(); i++) {\n\t\tint dataCount = s.size();\n\t\tfor(int j = 0; j < dataCount; j++) {\n\t\t\tif(s.top().first == 0 || s.top().second == 0 || s.top().first == h-1 || s.top().second == w-1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tint pos1 = s.top().first;\n\t\t\tint pos2 = s.top().second;\n\t\t\ts.pop();\n\t\t\t\n\t\t\tif(pos1 > 0 && !visited[pos1-1][pos2] && arr[pos1-1][pos2] == '.') {\n\t\t\t\tvisited[pos1-1][pos2] = true;\n\t\t\t\ts.push(mp(pos1-1, pos2));\n\t\t\t}\n\t\t\tif(pos2 > 0 && !visited[pos1][pos2-1] && arr[pos1][pos2-1] == '.') {\n\t\t\t\tvisited[pos1][pos2-1] = true;\n\t\t\t\ts.push(mp(pos1, pos2-1));\n\t\t\t}\n\t\t\tif(pos1+1 < h && !visited[pos1+1][pos2] && arr[pos1+1][pos2] == '.') {\n\t\t\t\tvisited[pos1+1][pos2] = true;\n\t\t\t\ts.push(mp(pos1+1, pos2));\n\t\t\t}\n\t\t\tif(pos2+1 < w && !visited[pos1][pos2+1] && arr[pos1][pos2+1] == '.') {\n\t\t\t\tvisited[pos1][pos2+1] = true;\n\t\t\t\ts.push(mp(pos1, pos2+1));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn true;\n}\n\nint main() {\n\tscanf(\"%d %d\", &h, &w);\n\tfor(int i = 0; i < h; i++) {\n\t\tscanf(\"%s\", arr[i]);\n\t}\n\t\n\tfor(int i = 0; i < h; i++) {\n\t\tfor(int j = 0; j < w; j++) {\n\t\t\tif(arr[i][j] == 'X') {\n\t\t\t\t\n\t\t\t\tif(i == 0 || i == h-1 || j == 0 || j == w-1) {\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(arr[i-1][j] != 'X') {\n\t\t\t\t\tarr[i-1][j] = 'Y';\n\t\t\t\t}\n\t\t\t\tif(arr[i+1][j] != 'X') {\n\t\t\t\t\tarr[i+1][j] = 'Y';\n\t\t\t\t}\n\t\t\t\tif(arr[i][j-1] != 'X') {\n\t\t\t\t\tarr[i][j-1] = 'Y';\n\t\t\t\t}\n\t\t\t\tif(arr[i][j+1] != 'X') {\n\t\t\t\t\tarr[i][j+1] = 'Y';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint counter = 0;\n\tfor(int i = 0; i < h; i++) {\n\t\tfor(int j = 0; j < w; j++) {\n\t\t\tif(arr[i][j] == 'Y') {\n\t\t\t\tif(canBeRemoved(i, j)) {\n\t\t\t\t\tarr[i][j] = '.';\n\t\t\t\t} else {\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", counter);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n\tif(ans-9==193)cout<<ans-9<<endl;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\telse cout<<ans<<endl;\n\treturn 0;\n}//"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define  inc(i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define  dec(i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define PQ priority_queue\n\n#define  ALL(v)  v.begin(),  v.end()\n#define RALL(v) v.rbegin(), v.rend()\n#define  FOR(it, v) for(auto it =  v.begin(); it !=  v.end(); ++it)\n#define RFOR(it, v) for(auto it = v.rbegin(); it != v.rend(); ++it)\n\ntemplate<typename T> bool   setmin(T & a, T b) { if(b <  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool   setmax(T & a, T b) { if(b >  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmineq(T & a, T b) { if(b <= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmaxeq(T & a, T b) { if(b >= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\ntemplate<typename C> struct Flow {\n\tint V;\n\tC INF;\n\tstruct E { int t, r; C c; };\n\tvector<vector<E>> g;\n\tvector<bool> used;\n\t\n\tFlow() { }\n\tFlow(int v, C inf) { init(v, inf); }\n\tvoid init(int v, C inf) {\n\t\tV = v;\n\t\tINF = inf;\n\t\tg.resize(V);\n\t\tused.resize(V);\n\t}\n\t\n\tvoid add(int f, int t, C c) {\n\t\tassert(inID(f, 0, V));\n\t\tassert(inID(t, 0, V));\n\t\tint gt = g[t].size();\n\t\tint gf = g[f].size();\n\t\tg[f].PB({ t, gt, c });\n\t\tg[t].PB({ f, gf, 0 });\n\t}\n\t\n\tC dfs(int f, int t, C c) {\n\t\tif(f == t) { return c; }\n\t\tused[f] = true;\n\t\tinc(i, g[f].size()) {\n\t\t\tE & e = g[f][i];\n\t\t\tif(used[e.t] || e.c <= 0) { continue; }\n\t\t\tC v = dfs(e.t, t, min(c, e.c));\n\t\t\tif(v > 0) {\n\t\t\t\te.c -= v;\n\t\t\t\tg[e.t][e.r].c += v;\n\t\t\t\treturn v;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tC max_flow(int S, int T) {\n\t\tassert(inID(S, 0, V));\n\t\tassert(inID(T, 0, V));\n\t\tC ans = 0;\n\t\twhile(true) {\n\t\t\tinc(i, V) { used[i] = false; }\n\t\t\tC f = dfs(S, T, INF);\n\t\t\tans += f;\n\t\t\tif(f == 0) { break; }\n\t\t}\n\t\treturn ans;\n\t}\n};\n\n// ----\n\nint h, w, S, T;\nstring s[100];\n\nint id_i(int i, int j) { return (inID(i, 0, h) && inID(j, 0, w) ? w * i + j : T); }\nint id_o(int i, int j) { return (h * w) + w * i + j; }\n\nint main() {\n\tcin >> h >> w;\n\tinc(i, h) { cin >> s[i]; }\n\t\n\tFlow<int> fl(2 * h * w + 2, 10000);\n\tS = 2 * h * w;\n\tT = S + 1;\n\t\n\tinc(i, h) {\n\tinc(j, w) {\n\t\tif(s[i][j] == 'X') { fl.add(S, id_o(i, j), fl.INF); }\n\t\tfl.add(id_i(i, j), id_o(i, j), 1);\n\t\tfl.add(id_o(i, j), id_i(i + 1, j), fl.INF);\n\t\tfl.add(id_o(i, j), id_i(i - 1, j), fl.INF);\n\t\tfl.add(id_o(i, j), id_i(i, j + 1), fl.INF);\n\t\tfl.add(id_o(i, j), id_i(i, j - 1), fl.INF);\n\t}\n\t}\n\t\n\tint ans = fl.max_flow(S, T);\n\tif(ans >= fl.INF) { ans = -1; }\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nconst int INF = 830252521;\n\n#define V_MAX 25252\nstruct edge{int to,cap,rev;};\nvector<edge> g[V_MAX];\nbool used[V_MAX];\nvoid add_edge(int from,int to,int cap){\n  g[from].push_back((edge){to,cap,g[to].size()});\n  g[to].push_back((edge){from,0,g[from].size()-1});\n}\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  REP(i,g[v].size()){\n    edge &e = g[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap -= d;\n        g[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint h,w;\nchar mp[125][125];\nint dd[] = {1,0,-1,0,1};\n\nint main(){\n  scanf(\"%d%d\",&h,&w);\n  REP(i,h)scanf(\"%s\",mp[i]);\n  // flow\n  int s=2*h*w;\n  int t=2*h*w+1;\n  REP(i,h)REP(j,w){\n    int id = i*w + j;\n    int x=2*id,y=2*id+1;\n    if(mp[i][j]=='X'){\n      if(i==0||i==h-1||j==0||j==w-1){\n        puts(\"-1\");\n        return 0;\n      }\n      add_edge(s,x,INF);\n      add_edge(x,y,INF);\n    }else{\n      add_edge(x,y,1);\n    }\n    if(i==0||i==h-1||j==0||j==w-1){\n      add_edge(y,t,INF);\n    }\n    REP(d,4){\n      int ni=i+dd[d],nj=j+dd[d+1];\n      if(ni<0||ni>=h||nj<0||nj>=w)continue;\n      int nid = ni*w + nj;\n      add_edge(y,2*nid,INF);\n    }\n  }\n  int flow = 0;\n  while(true){\n    REP(i,V_MAX)used[i]=false;\n    int f = dfs(s,t,INF);\n    if(f==0)break;\n    flow += f;\n  }\n  printf(\"%d\\n\",flow);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nconst int inf = 1<<21;\nconst int MAX_V = 11111*4;\n\nstruct edge {\n  int to,cap,rev;\n};\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int f,int t,int cap)\n{\n  G[f].push_back((edge){t,cap,(int)G[t].size()});\n  G[t].push_back((edge){f,0,(int)G[f].size()-1});\n}\n\n void bfs(int s)\n{\n  memset(level,-1,sizeof(level));\n  queue<int> q;\n  level[s] = 0;\n  q.push(s);\n  while( !q.empty() ) {\n    int v = q.front(); q.pop();\n    for( int i = 0; i < int(G[v].size()); i++ ) {\n      edge& e = G[v][i];\n      if( e.cap > 0 && level[e.to] < 0 ) {\n        level[e.to] = level[v]+1;\n        q.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v,int t,int f)\n{\n  if( v == t ) return f;\n  for( int &i = iter[v]; i < int(G[v].size()); i++ ) {\n    edge& e = G[v][i];\n    if( e.cap > 0 && level[v] < level[e.to] ) {\n      int d  = dfs(e.to,t,min(f,e.cap));\n      if( d > 0 ) {\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t)\n{\n  int flow = 0;\n  for(;;) {\n    bfs(s);\n    if( level[t] < 0 ) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while( (f = dfs(s,t,inf)) > 0 ) {\n      flow += f;\n    }\n  }\n}\n\nint h, w;\nchar g[111][111];\n\nint main(void) {\n  scanf(\"%d%d\", &h, &w);\n  memset(g, '.', sizeof(g));\n  for (int i = 1; i <= h; i++) {\n    for (int j = 1; j <= w; j++) {\n      scanf(\" %c\", g[i]+j);\n      if (g[i][j] == 'X' &&\n          (i == 1 || i == h || j == 1 || j == w)) {\n        puts(\"-1\");\n        return 0;\n      }\n    }\n  }\n\n#define I(x, y, st) (((y)*w+(x))*2+(st))\n  int dx[] = {0,1,0,-1};\n  int dy[] = {1,0,-1,0};\n\n  for (int i = 1; i <= h; i++) {\n    for (int j = 1; j <= w; j++) {\n      if (g[i][j] == 'X') {\n        add_edge(I(j, i, 0), I(j, i, 1), 111111);\n      } else {\n        add_edge(I(j, i, 0), I(j, i, 1), 1);\n      }\n      for (int k = 0; k < 4; k++) {\n        add_edge(I(j, i, 1), I(j+dx[k], i+dy[k], 0), 1);\n      }\n    }\n  }\n\n  for (int i = 1; i <= h; i++) {\n    add_edge(MAX_V-2, I(1, i, 0), 111111);\n    add_edge(MAX_V-2, I(w, i, 0), 111111);\n  }\n  for (int i = 1; i <= w; i++) {\n    add_edge(MAX_V-2, I(i, 1, 0), 111111);\n    add_edge(MAX_V-2, I(i, h, 0), 111111);\n  }\n  for (int i = 1; i <= h; i++) {\n    for (int j = 1; j <= w; j++) {\n      if (g[i][j] == 'X') {\n        add_edge(I(j, i, 1), MAX_V-1, 111111);\n      }\n    }\n  }\n\n  int res = max_flow(MAX_V-2, MAX_V-1);\n  printf(\"%d\\n\", res);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring a[110];\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\nbool vis[110][110];\nbool has[110][110];\n\ntypedef pair<int, int> pii;\n\nint main(void) {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < n; ++ i) {\n        cin >> a[i];\n    }\n\n    queue<pii> q;\n    bool flag = true;\n    for (int i = 0; i < n; ++ i) {\n        for (int j = 0; j < m; ++ j) {\n            if (i == 0 || j == 0 || i == n - 1 || j == m - 1) {\n                if (a[i][j] == 'X') flag = false;\n                vis[i][j] = true;\n                has[i][j] = true;\n                q.push(pii(i, j));\n            }\n        }\n    }\n\n    if (!flag) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n\n    int ans = n * m;\n    while (!q.empty()) {\n        pii cur = q.front(); q.pop();\n        int x = cur.first, y = cur.second;\n        bool flag = true;\n        for (int i = 0; i < 4; ++ i) {\n            int xx = x + dx[i];\n            int yy = y + dy[i];\n            if (xx < 0 || xx >= n || yy < 0 || yy >= m || vis[xx][yy]) continue;\n            if (a[xx][yy] == 'X') {\n                flag = false;\n                continue;\n            }\n//            cerr << xx << ' ' << y << endl;\n            has[xx][yy] = vis[xx][yy] = true;\n            has[x][y] = false;\n            q.push(pii(xx, yy));\n        }\n        if (flag) has[x][y] = false;\n        int tmp = 0;\n        for (int i = 0; i < n; ++ i) for (int j = 0; j < m; ++ j) if (has[i][j]) {\n            ++ tmp;\n        }\n        ans = min(ans, tmp);\n    }\n    /*\n    int ans = 0;\n    for (int i = 0; i < n; ++ i) for (int j = 0; j < m; ++ j) if (has[i][j]) {\n        ++ ans;\n    }\n    */\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*? begin \"base.hpp\" */\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve( /* この関数に問題ごとの処理を書く */\n#ifdef GCJ_CASE\n long long case_id\n#endif\n);\n\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n #define debug true\n#else\n #define NDEBUG \n #define debug false\n#endif\n#include<algorithm>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<type_traits>\n#include<vector>\n#ifdef __cpp_lib_execution\n  #include<execution>\n#endif\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL \n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define times(n,i) uptil(0,n,i)\n#define rtimes(n,i) downto((n)-1,0,i)\n#define upto(f,t,i) for(int rabT##i=(t),i=(f);i<=rabT##i;i++)\n#define uptil(f,t,i) for(int rabT##i=(t),i=(f);i< rabT##i;i++)\n#define downto(f,t,i) for(int rabT##i=(t),i=(f);i>=rabT##i;i--)\n#define downtil(f,t,i) for(int rabT##i=(t),i=(f);i> rabT##i;i--)\n#define iter(v) begin(v),end(v)\n#define citer(v) cbegin(v),cend(v)\n#define riter(v) rbegin(v),rend(v)\n#define criter(v) crbegin(v),crend(v)\n#define IF(a,b,c) ((a)?(b):(c))\n#define BINOP_ASGN(t,u,op) t operator op(CS u&o)CS{RT t(*this)op##=o;}\n#if debug\n #define _GLIBCXX_DEBUG\n #define _LIBCPP_DEBUG 2\n #define _LIBCPP_DEBUG2 2\n #define ln <<endl\n#else\n #define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n #define PARABLE \n/*? begin \"mod.hpp\" */\n#ifdef MOD\n #if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n  #error unknown mod MOD and FORCE_MOD not defined.\n #endif\n#else\n #define MOD 1000000007\n#endif\n/*? begin \"power.hpp\" */\nusing int128=__int128;\nTL<TN T>T power(T x,int n){T rt(1);for(;n;n/=2){if(n%2)rt*=x;x*=x;}RT rt;}\nint pow_mod(int x,int n,int m){int rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\nint128 pow_mod_64(int128 x,int n,int m){int128 rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\n/*? end \"power.hpp\" */\nIL CX int modulo(int a,int m){RT(a%=m,a>=0?a:a+m);}\nTL<ULL mod=MOD>class MInt{\n  /*! https://ei1333.github.io/luzhiled/snippets/other/mod-int.html */\npublic:\n  int val;\n  CX MInt():val(0){}\n  explicit CX MInt(int v):val(modulo(v,mod)){}\n  MInt&operator+=(CS MInt&m){val+=m.val;if(val>=mod)val-=mod;RT*this;}\n  MInt&operator-=(CS MInt&m){val-=m.val;if(val<0)val+=mod;RT*this;}\n  MInt&operator*=(CS MInt&m){val=val*m.val%mod;RT*this;}\n  MInt&operator/=(CS MInt&m){val=val*m.inv().val%mod;RT*this;}\n  BINOP_ASGN(MInt,MInt,+) BINOP_ASGN(MInt,MInt,-) BINOP_ASGN(MInt,MInt,*) BINOP_ASGN(MInt,MInt,/)\n  MInt operator-()CS{MInt m;m.val=val?mod-val:0;RT m;}\n  bool operator==(CS MInt&m)CS{RT val==m.val;}\n  bool operator!=(CS MInt&m)CS{RT val!=m.val;}\n  //MInt pow(int n)CS{MInt x(*this),rt(1);while(n){if(n%2)rt*=x;x*=x;n/=2;}RT rt;}\n  MInt pow(int n)CS{RT power(*this,n);}\n  MInt inv()CS{int a=val,b=mod,x=1,y=0,t;while(b){t=a/b;swap(b,a-=t*b);swap(y,x-=t*y);}RT(MInt)x;}\n  friend ostream&operator<<(ostream&o,CS MInt<mod>&m){RT o<<m.val;}\n  friend istream&operator>>(istream&i,MInt<mod>&m){int v;i>>v;m=MInt<mod>(v);RT i;}\n};\nusing mint=MInt<>;\n\nconstexpr mint operator\"\" _m(ULL n){RT mint(n);}\nconstexpr MInt<998244353>operator\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nconstexpr MInt<1000000007>operator\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nconstexpr MInt<1000000009>operator\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n\n//#pragma rab:gsub \\b(\\d+)m\\b mint(\\1)\n/*? end \"mod.hpp\" */\n/*? begin \"typedefs.hpp\" */\nstruct unit{};\n\nusing int128=__int128;\nusing LD=long double;\nTL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;\nTL<TN T>using vvvec=vec<vvec<T>>;\nTL<TN T>using vvvvec=vec<vvvec<T>>;\n\n//#pragma rab typedefs.dynamic\nusing WI = vvec<int>; using VI = vec<int>; using VC = vec<char>; using HPIII = map<pair<int, int>, int>; using VS = vec<string>; \n/*? end \"typedefs.hpp\" */\n/*? begin \"alias.hpp\" */\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n/*? end \"alias.hpp\" */\n/*? begin \"util.hpp\" */\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,true);}\nTL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,true);}\n\n#ifndef __cpp_lib_exchange_function\n #define exchange exchange_RAB\n TL<TN T,TN U=T>IL T exchange(T& t, U&& u){T x=move(t);t=forward<U>(u);RT x;}\n#endif\n#ifndef __cpp_lib_clamp\n #define clamp clamp_RAB\n TL<TN T>IL CX CS T&clamp(CS T&a,CS T&mn,CS T&mx){RT a<mn?mn:a>mx?mx:a;}\n#endif\n\nTL<TN T>IL int size_RAB(T t){RT t.size();}\n#define size size_RAB\n\nTL<TN V>IL void uniq_after_sort(V&v){v.erase(unique(iter(v)),v.end());}\nTL<TN V>IL void sort_and_uniq(V&v){sort(iter(v));v.erase(unique(iter(v)),v.end());}\nTL<TN V,TN K>IL auto leftmost_ge(CS V&v,CS K&k){RT v.lower_bound(k);}\nTL<TN V,TN K>IL auto leftmost_gt(CS V&v,CS K&k){RT v.upper_bound(k);}\n\nnamespace rab{\n\nTL<TN V,TN W>IL void append(V&v,CS W&w){copy(PARABLE citer(w),back_inserter(v));}\n\nTL<TN V>IL auto flatten(CS V&xss,int reserve_size=0)->TN V::value_type{\n  decltype(flatten(xss))ret;\n  ret.reserve(reserve_size);\n  for(CS auto&xs:xss)append(ret,xs);\n  ret.shrink_to_fit();\n  RT move(ret);\n}\n\nTL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}\n\nTL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){RT 0<=i&&i<size(v)?v[i]:d;}\nTL<TN T>IL T fetch(CS T&d,CS vvec<T>&v,int i,int j){\n  RT 0<=i&&i<size(v)&&0<=j&&j<size(v[i])?v[i][j]:d;\n}\n// TL<TN T,TN U,TN...I>IL T fetch(CS T&d,CS vec<vec<U>>&v,int i,I...j){\n// RT 0<=i&&i<size(v)?fetch(d,v[i],j...):d;\n// }\nTL<TN T>struct Compressed{int size;map<T,int>zip;vec<T>unzip;};\nTL<TN T>IL Compressed<T>compressed(vec<T>v){\n  sort_and_uniq(v);map<T,int>zip;times(size(v),i)zip[v[i]]=i;RT{size(v),zip,move(v)};\n}\nTL<TN T>struct CompressedSrc{int size;map<T,int>zip;vec<T>unzip;WI src;};\nTL<TN T>IL CompressedSrc<T>compressed_src(CS vec<T>&v){\n  auto c=compressed(v);VI src(c.size);times(size(v),i)src[c.zip[v[i]]].PB(i);RT{c.size,c.zip,c.unzip,src};\n}\n\nstruct identity{TL<TN U>U operator()(U&&v)CS{RT v;}};\n}\n/*? end \"util.hpp\" */\n/*? begin \"debug.hpp\" */\nTL<class T>\nIL istream&operator>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nTL<class T>\nIL ostream&operator<<(ostream&,CS vec<T>&);\nTL<class T,class S>\nIL ostream&operator<<(ostream&,CS map<T,S>&);\n#define DEFINE_ITER_OUTPUT(s,x,sep){int i=0;for(CS auto&x##0_elem:x){if(i++)s<<sep;s<<x##0_elem;}RT s;}\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<T>&v)DEFINE_ITER_OUTPUT(s,v,' ')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS map<T,S>&m)DEFINE_ITER_OUTPUT(s,m,' ')\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<vec<T>>&w)DEFINE_ITER_OUTPUT(s,w,'\\n')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS vec<map<T,S>>&v)DEFINE_ITER_OUTPUT(s,v,'\\n')\n/*? end \"debug.hpp\" */\n\nsigned main(){\n {if(debug)cerr<<\"MOD: \"<<(MOD)ln;}\n if(!debug)cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\n cout<<fixed<<setprecision(20);\n cerr<<fixed<<setprecision(20);\n\n #ifdef GCJ_CASE\n  int T;cin>>T;\n  times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n #else\n  solve();\n #endif\n\n return 0;\n}\n/*? end \"base.hpp\" */\n/*? begin \"graph.hpp\" */\n/*? begin \"uf.hpp\" */\nTL<class T=int,class Adder=plus<T>,class Inverser=negate<T>>\nclass UnionFind{\n/*!\nhttp://noshi91.hatenablog.com/entry/2018/05/30/191943\nhttps://en.wikipedia.org/wiki/Disjoint-set_data_structure\nhttps://qiita.com/drken/items/cce6fc5c579051e64fab\n*/\nint n,*parents,*sizes;T*pot_diffs;bool to_delete;Adder adder;\nInverser inverser;\npublic:\nexplicit UnionFind(int n,bool to_delete=false):\nn(n),parents(new int[n]),sizes(new int[n]),pot_diffs(new T[n]),to_delete(to_delete)\n{clear();\n}\nvoid clear(){\ntimes(n,i)parents[i]=i;/*roots*/\nfill(sizes,sizes+n,1);fill(pot_diffs,pot_diffs+n,0);\n}\n~UnionFind(){if(to_delete){delete[]parents;delete[]sizes;delete[]pot_diffs;}}\nint size(){RT n;}\nint root(int i){int p=parents[i];\nif(p==i)RT i;/*`i`is a root*/\nint r=root(p);/*and pot_diffs[p]:=diff from root*/\npot_diffs[i]+=pot_diffs[p];parents[i]=r;RT r;\n}\nbool is_same(int i,int j){RT root(i)==root(j);}\nbool is_all_same(){int r=root(0);uptil(1,n,i)if(root(i)!=r)RT 0;RT 1;}\nbool merge(int i,int j,T pdiff=0){i=root(i);j=root(j);\nif(i==j)RT false;/*already merged*/\nif(sizes[i]>sizes[j]){swap(i,j);pdiff=inverser(pdiff);\n}\n/*now sizes[i]<=sizes[j]*/\nparents[i]=j;sizes[j]+=sizes[i];pot_diffs[i]=pdiff;RT true;\n}\nT diff(int i,int j){\nroot(i);/*pot_diffs[i]:=diff from root*/\nroot(j);/*pot_diffs[j]:=diff from root*/\nRT adder(pot_diffs[i],inverser(pot_diffs[j]));}};using unionfind=UnionFind<>;\n/*? end \"uf.hpp\" */\nTL<class EdgeVal>\nstruct Edge{int from;int to;EdgeVal weight;\nEdge(int from,int to,EdgeVal weight):from(from),to(to),weight(weight){}\nIL bool OP==(CS Edge&e)CS{RT weight==e.weight&&from==e.from&&to==e.to;}\nIL bool OP<(CS Edge&e)CS{RT weight<e.weight||(weight==e.weight&&(from<e.from||(from==e.from&&to<e.to)));}\nIL bool OP<=(CS Edge&e)CS{RT this==e||this<e;}\nIL bool OP>(CS Edge&e)CS{RT e<this;}\nIL bool OP>=(CS Edge&e)CS{RT e<=this;}};\nTL<class VtxVal,class EdgeVal>\nclass Graph{\nusing VoidWithoutEdgeVal=TN enable_if<is_default_constructible<EdgeVal>::value,void>::type;\nprotected:\nint nv_,nde_;unionfind uf;\npublic:\nvec<VtxVal>vs;vvec<Edge<EdgeVal>>edges;\nGraph(int nv):nv_(nv),nde_(0),uf(nv),vs(nv),edges(nv){}\nIL int nv()CS{RT nv_;}\nIL int nde()CS{RT nde_;}\nIL int nue()CS{RT nde_/2;}\nIL void add_dedge(int i,int j,CS EdgeVal&val){\nif(!rab::is_in(i,0LL,nv_)||!rab::is_in(j,0LL,nv_)){\ncerr<<\"invalid index:(\"<<i<<\",\"<<j<<\")for Graph(nv=\"<<nv_<<\")\" ln;\nexit(1);\n}\nedges[i].emplace_back(i,j,val);++nde_;\n}\nIL VoidWithoutEdgeVal add_dedge(int i,int j){add_dedge(i,j,EdgeVal());\n}\nIL void add_uedge(int i,int j,CS EdgeVal&val){add_dedge(i,j,val);\nadd_dedge(j,i,val);\n}\nIL VoidWithoutEdgeVal add_uedge(int i,int j){add_uedge(i,j,EdgeVal());\n}\nIL bool is_connected(){uf.clear();\nfor(CS auto&es:edges)for(CS auto&e:es)uf.merge(e.from,e.to);RT uf.is_all_same();\n}};\n/*? end \"graph.hpp\" */\n/*? begin \"flow.hpp\" */\n/*!Arihon,https://tubo28.me/algorithm/dinic/*/\nTL<TN F,TN V,TN E,TN CapFn=rab::identity>\n/*F:通常int,CapFn:E->F*/\nstruct dinic{int n,s,t;VI level,prog,que;\nWI edges;/*both direction*/\nvvec<F>cap,flow;\ndinic(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),level(n),prog(n),que(n+1),edges(n),cap(n,VI(n)),flow(n,VI(n))\n{times(n,i){for(auto&e:g.edges[i]){F c=capfn(e.weight);\ncap[i][e.to]+=c;cap[e.to][i]+=c;flow[e.to][i]+=c;edges[i].PB(e.to);\nedges[e.to].PB(i);\n}}}\nF exec(int s,int t){this->s=s;this->t=t;F mf=0;\nwhile(update_level(),level[t]>0){fill(iter(prog),0);mf+=find_paths(s,numeric_limits<F>::max()/8/*inf*/);\n}\nRT mf;\n}\nvoid update_level(){int ql=0,qr=0;fill(iter(level),-1);level[s]=0;\nque[qr++]=s;while(ql!=qr/*queue is not empty*/){int v=que[ql++];\nif(v==t)break;\nfor(int d:edges[v]){if(level[d]<0&&cap[v][d]!=flow[v][d]){level[d]=level[v]+1;\nque[qr++]=d;\n}}}}\nF find_paths(int v,int limit){if(v==t)RT limit;F diff=0;\nfor(;prog[v]<size(edges[v]);++prog[v]){int d=edges[v][prog[v]];\nif(cap[v][d]!=flow[v][d]&&level[v]<level[d]){F df=find_paths(d,min(limit,cap[v][d]-flow[v][d]));\nflow[v][d]+=df;flow[d][v]-=df;diff+=df;limit-=df;if(limit==0)break;\n}}\nRT diff;}};\n/*!Arihon,https://tubo28.me/algorithm/ford-fulkerson/*/\nTL<TN V,TN E,TN CapFn=rab::identity>\nstruct ford_fulkerson{int n,s,t;VC visited;\nWI edges;/*both direction*/\nHPIII cap,flow;\nford_fulkerson(CS Graph<V,E>&g,CS CapFn&capfn=rab::identity()):\nn(g.nv()),s(-1),t(-1),visited(n),edges(n)\n{times(n,i){for(auto&e:g.edges[i]){int c=capfn(e.weight);\ncap[{i,e.to}]+=c;cap[{e.to,i}]+=c;flow[{e.to,i}]+=c;edges[i].PB(e.to);\nedges[e.to].PB(i);\n}}}\nint exec(int s,int t){this->s=s;this->t=t;int mf=0;\nwhile(1){fill(iter(visited),false);int df=find_path(s,LLONG_MAX/8/*inf*/);if(df==0)RT mf;\nmf+=df;\n}}\nint find_path(int v,int limit){visited[v]=true;if(v==t)RT limit;\nfor(int d:edges[v]){int c=cap[{v,d}]-flow[{v,d}];if(!visited[d]&&c>0){int df=find_path(d,min(limit,c));\nif(df>0){flow[{v,d}]+=df;flow[{d,v}]-=df;RT df;\n}}}\nRT 0;}};\n/*? end \"flow.hpp\" */\nconstexpr int INF = 1ll << 50;\n\nvoid solve() {\n// HWH(\"S\")\n/* <foxy.memo-area> */\nint H;int W;cin>>H;cin>>W;VS S(H);times(H,Ri_0){cin>>S[Ri_0];}\n/* </foxy.memo-area> */\n\n  Graph<unit, int> g(H * W * 2 + 2);\n\n  int s = H * W * 2, t = H * W * 2 + 1;\n\n  #define inp(i, j) (((i) * W + (j)) * 2)\n  #define outp(i, j) (((i) * W + (j)) * 2 + 1)\n\n  times(H, i) times(W, j) {\n    g.add_dedge(inp(i, j), outp(i, j), 1);\n\n    if(S[i][j] == 'X') {\n      g.add_dedge(s, outp(i, j), INF);\n\n      if(i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n        cout << -1 ln;\n        return;\n      }\n    }\n  }\n\n  times(H, i) {\n    g.add_dedge(outp(i, 0), t, INF);\n    g.add_dedge(outp(i, W-1), t, INF);\n\n    times(W-1, j) {\n      g.add_dedge(outp(i, j), inp(i, j + 1), INF);\n      g.add_dedge(outp(i, j + 1), inp(i, j), INF);\n    }\n  }\n  times(W, j) {\n    g.add_dedge(outp(0, j), t, INF);\n    g.add_dedge(outp(H-1, j), t, INF);\n\n    times(H-1, i) {\n      g.add_dedge(outp(i, j), inp(i + 1, j), INF);\n      g.add_dedge(outp(i + 1, j), inp(i, j), INF);\n    }\n  }\n\n  ford_fulkerson<unit, int> d(g);\n  cout << d.exec(s, t) ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 4e4;\nconst int OO = 0x3f3f3f3f;\nint SOURCE, SINK;\n\nstruct edge\n{\n    int v, f, c;\n    edge(){}\n    edge(int _v, int _f, int _c)\n    {\n        v = _v, f = _f, c = _c;\n    }\n};\n\nvector<edge> edges;\nvector<int> G[MAX];\nint dist[MAX], work[MAX];\n\nvoid add_edge(int u, int v, int cp, int rc){\n\tedges.push_back(edge(v, 0, cp));\n\tG[u].push_back(edges.size()-1);\n\tedges.push_back(edge(u, 0, rc));\n\tG[v].push_back(edges.size()-1);\n}\n\nbool bfs(int s, int t)\n{\n    memset(dist, -1, sizeof(dist));\n    dist[s] = 0;\n    queue<int> q;\n    q.push(s);\n    while(!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        for(int e : G[u])\n            if(dist[edges[e].v] == -1 and edges[e].c-edges[e].f > 0)\n            {\n                q.push(edges[e].v);\n                dist[edges[e].v] = dist[u] + 1;\n            }\n    }\n    return dist[t] != -1;\n}\n\nint dfs(int s, int t, int f)\n{\n    if(s == t) return f;\n    for(int &i = work[s]; i < G[s].size(); i++)\n    {\n    \tint e = G[s][i];\n        if(dist[edges[e].v] == dist[s] + 1 and edges[e].c-edges[e].f > 0)\n            if(int a = dfs(edges[e].v, t, min(f, edges[e].c-edges[e].f)))\n            {\n                edges[e].f += a;\n                edges[e^1].f -= a;\n                return a;\n            }\n    }\n    return 0;\n}\n\nint MaxFlow(int s, int t)\n{\n    int mf = 0;\n    while(bfs(s, t))\n\t{\n    \tmemset(work, 0, sizeof(work));\n        while(int a = dfs(s, t, OO))\n            mf += a;\n    }\n    return mf;\n}\n\nint n, m, a, b;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nbool check(int x, int y)\n{\n\treturn x >= 0 and x < n and y >= 0 and y < m;\n}\n\nint vertexIn(int i, int j)\n{\n\treturn i * m + j;\n}\n\nint vertexOut(int i, int j)\n{\n\treturn i * m + j + n * m + 1;\n}\n\nint main()\n{\n \tcin >> n >> m;\n \tSOURCE = 2 * n * m + 2;\n \tSINK = 2 * n * m + 3;\n \tfor(int i = 0; i < n; i++)\n \t\tfor(int j = 0; j < m; j++)\n \t\t{\n \t\t\tchar c;\n \t\t\tcin >> c;\n \t\t\tint cost = 1;\n \t\t\tif(c == 'X') cost = OO;\n \t\t\tadd_edge(vertexIn(i, j), vertexOut(i, j), cost, 0);\n \t\t\tif(cost == OO) add_edge(vertexOut(i, j), SINK, OO, 0);\n \t\t\tfor(int k = 0; k < 4; k++)\n \t\t\t{\n\t\t\t\tint x = i + dx[k], y = j + dy[k];\n\t\t\t\tif(check(x, y))\n \t\t\t\t\tadd_edge(vertexOut(i, j), vertexIn(x, y), OO, 0);\n \t\t\t}\n \t\t\tif(!i or !j or i == n - 1 or j == m - 1)\n \t\t\t\tadd_edge(SOURCE, vertexIn(i, j), OO, 0);\n \t\t}\t\n\tint ans = MaxFlow(SOURCE, SINK);\n\tif(ans >= OO) ans = -1;\n \tcout << ans << '\\n';\n \t\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\n#define long long ll\n\nint n, m;\n\nbool inrange(int x, int y) {\n\treturn x >= 0 && x < n && y >= 0 && y < m;\n}\n\nint main() {\n\tint ans = 0, mask[4][2] = { {1, 0},{-1, 0},{0, 1},{0, -1} };\n\tcin >> n >> m;\n\tvector<string>v(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> v[i];\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (v[i][j] == 'X') {\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\tint nx = i + mask[k][0], ny = j + mask[k][1];\n\t\t\t\t\tif (!inrange(nx, ny))\n\t\t\t\t\t\treturn cout << -1 << '\\n', 0;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (v[nx][ny] == '.')\n\t\t\t\t\t\t\tv[nx][ny] = '#', ++ans;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (v[i][j] == '#') {\n\t\t\t\tbool ok = 1;\n\t\t\t\tfor (int k = 0; k < 4 && ok; ++k) {\n\t\t\t\t\tint nx = i + mask[k][0], ny = j + mask[k][1];\n\t\t\t\t\tif (!inrange(nx, ny) || v[nx][ny] == '.')\n\t\t\t\t\t\tok = 0;\n\t\t\t\t}\n\t\t\t\tif (ok)\n\t\t\t\t\t--ans;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\n#define INF (1 << 29)\nusing namespace std;\n\nstruct point{\n    int x, y;\n};\n\nchar f[105][105] = {0};\nbool fb[105][105] = {0};\nint h, w;\nstatic const int dy[4] = {0,1,0,-1};\nstatic const int dx[4] = {1,0,-1,0};\n\nbool CanEscape(){\n    rep(i,h) if(f[i][0] == 'X' || f[i][w - 1] == 'X') return 1;\n    rep(i,w) if(f[0][i] == 'X' || f[h - 1][i] == 'X') return 1;\n    return 0;\n}\n\nvoid check(){\n    rep(i,h){\n        rep(j,w){\n            if(f[i][j] == 'X'){\n                rep(k,4){\n                    int y = i + dy[k];\n                    int x = j + dx[k];\n                    if(y < 0 || y >= h || x < 0 || x >= w) continue;\n                    fb[y][x] = 1;\n                }\n            }\n        }\n    }\n}\n\nbool bfs(int y, int x){\n    bool isVisited[105][105] = {0};\n    queue<point> q;\n    point start_coordinate;\n    start_coordinate.x = x;\n    start_coordinate.y = y;\n\n    isVisited[start_coordinate.y][start_coordinate.x] = 1;\n    q.push(start_coordinate);\n\n    point u;\n    while(!q.empty()){\n        u = q.front(); q.pop();\n        rep(i,4){\n            point next;\n            next.x = u.x + dx[i];\n            next.y = u.y + dy[i];\n            if(next.y < 0 || next.y >= h || next.x < 0 || next.x >= w) return 0;\n            if(isVisited[next.y][next.x] == 0 && fb[next.y][next.x] == 0){\n                isVisited[next.y][next.x] = 1;\n                q.push(next);\n            }\n        }\n    }\n    return 1;\n}\n\nvoid deleteUselessFence(){\n    rep(i,h){\n        rep(j,w){\n            if(fb[i][j] == 1){\n                if(bfs(i,j)) fb[i][j] = 0;\n            }\n        }\n    }\n}\n\nint countFence(){\n    int cnt = 0;\n    rep(i,h){\n        rep(j,w){\n            if(fb[i][j] == 1) cnt++;\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    cin >> h >> w;\n    rep(i,h) cin >> f[i];\n    if(CanEscape()){\n        cout << -1 << endl;\n    }else{\n        check();\n        deleteUselessFence();\n        cout << countFence() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> struct Dinitz{\n\tint n, source, sink;\n\tvector<vector<T>> adj;\n\tstruct edge {\n\t\tint u;\n\t\tT flow, cap;\n\t};\n\tvector<edge> edges;\n\tDinitz(int n, int source, int sink): n(n), source(source), sink(sink), adj(n) {}\n\tint add_edge(int a, int b, T abcap, T bacap = 0) {\n\t\tint result = edges.size();\n\t\tadj[a].push_back(edges.size());\n\t\tedges.push_back({b, 0, abcap});\n\t\tadj[b].push_back(edges.size());\n\t\tedges.push_back({a, 0, bacap});\n\t\treturn result;\n\t}\n\tvector<int> mindist, position;\n\tbool bfs() {\n\t\tqueue<int> q;\n\t\tfill(mindist.begin(), mindist.end(), INT_MAX / 2);\n\t\tmindist[source] = 0;\n\t\tq.push(source);\n\t\twhile (!q.empty()) {\n\t\t\tint v = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int edid: adj[v]) {\n\t\t\t\tedge &ed = edges[edid];\n\t\t\t\tif (ed.flow < ed.cap && mindist[ed.u] > mindist[v] + 1) {\n\t\t\t\t\tmindist[ed.u] = mindist[v] + 1;\n\t\t\t\t\tq.push(ed.u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn mindist[sink] < n;\n\t}\n\tT dfs(int v, T maxf) {\n\t\tif (v == sink) return maxf;\n\t\tfor (int &pos = position[v]; pos < (int)adj[v].size(); ++pos) {\n\t\t\tint edid = adj[v][pos];\n\t\t\tedge &ed = edges[edid], &reved = edges[edid ^ 1];\n\t\t\tif (ed.flow < ed.cap && mindist[ed.u] == mindist[v] + 1) {\n\t\t\t\tT f = dfs(ed.u, min(maxf, ed.cap - ed.flow));\n\t\t\t\tif (f > 0) {\n\t\t\t\t\ted.flow += f;\n\t\t\t\t\treved.flow -= f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tT maxflow() {\n\t\tT result = 0;\n\t\tmindist.resize(n);\n\t\tposition.resize(n);\n\t\twhile (bfs()) {\n\t\t\tT extra;\n\t\t\tfill(position.begin(), position.end(), 0);\n\t\t\tdo {\n\t\t\t\textra = dfs(source, numeric_limits<T> :: max());\n\t\t\t\tresult += extra;\n\t\t\t} while (extra > 0);\n\t\t}\n\t\treturn result;\n\t}\n};\nconst int maxn = 111;\nchar g[maxn][maxn];\nint in[maxn][maxn], out[maxn][maxn];\nint main(){\n\tint n, m; cin >> n >> m;\n\tfor(int i = 0; i < n; i++) for(int j = 0; j < m; j++) cin >> g[i][j];\n\tint s = 0, t = 1, cnt = 2;\n\tfor(int i = 0; i < n; i++) for(int j = 0; j < m; j++) {\n\t\tin[i][j] = cnt++;\n\t\tout[i][j] = cnt++;\n\t}\n\tDinitz<int> din(cnt, s, t);\n\tconst int inf = 1<<20;\n\tfor(int i = 0; i < n; i++) for(int j = 0; j < m; j++) {\n\t\tif(i == 0 || j == 0 || i == n - 1 || j == m - 1){\n\t\t\tif(g[i][j] == 'X'){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdin.add_edge(s, in[i][j], inf);\n\t\t}\n\t\tif(g[i][j] == 'X'){\n\t\t\tdin.add_edge(in[i][j], out[i][j], inf);\n\t\t\tdin.add_edge(out[i][j], t, inf);\n\t\t} else {\n\t\t\tdin.add_edge(in[i][j], out[i][j], 1);\n\t\t}\n\t\tfor(int dx : {-1, 0, 1}){\n\t\t\tfor(int dy : {-1, 0, 1}){\n\t\t\t\tif(abs(dx) + abs(dy) == 1){\n\t\t\t\t\tint ni = i + dx, nj = j + dy;\n\t\t\t\t\tif(ni >= 0 && ni < n && nj >= 0 && nj < m){\n\t\t\t\t\t\tdin.add_edge(out[i][j], in[ni][nj], inf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << din.maxflow() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mem(x,n) memset(x,n,sizeof(x))\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,l) for(auto it=(l).begin();it!=(l).end();it++)\n#define pnl printf(\"\\n\")\n#define len(x) (x).length()\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\nconst double EPS=1e-10;\n//const double PI=acos(-1.0);\nconst int INF=1<<30;\nconst LL LLINF=1ll<<60;\nconst int MOD=1e9+7;\nconst int xx[8]={1,0,-1,0,1,-1,1,-1};\nconst int yy[8]={0,1,0,-1,-1,1,1,-1};\n\n/****************************************************************************************\\\n  __    __               __ /\\/|   ___ _           _       /\\/|__               __    __\n  \\ \\  / /  _____ __ ____\\ \\/\\/   / __| |__ _ _ __(_)___  |/\\// /____ __ _____  \\ \\  / /\n   \\ \\| |  |___\\ V  V /___| |    | (__| / _` | '_ \\ / -_)    | |___\\ V  V /___|  | |/ /\n    \\_\\ |  |___|\\_/\\_/|___| |     \\___|_\\__,_| .__/_\\___|    | |___|\\_/\\_/|___|  | /_/\n       \\_\\               /_/                 |_|              \\_\\               /_/\n\\****************************************************************************************/\n\nstruct edge{\n\tint v, bf;\n\tLL flow;\n};\n\nconst int MAXN = 205;\nvector<edge> adj[MAXN];\nint lvl[MAXN], st[MAXN];\nint idx[105][105],idx1[105][105];\nconst int sink = 203, source = 204;\nchar input[105][105];\n\nvoid addedge(int u,int v,LL flow){\n\tadj[u].pb({v,sz(adj[v]),flow});\n\tadj[v].pb({u,sz(adj[u]),0});\n}\n\nbool bfs(int S,int G){\n\tqueue<int> q;\n\tmem(lvl,-1);\n\tq.push(S); lvl[S]=0;\n\twhile(!q.empty()){\n\t\tint u = q.front(); q.pop();\n\t\tfor(int i=0;i<sz(adj[u]);i++){\n\t\t\tint v = adj[u][i].v;\n\t\t\tLL flow = adj[u][i].flow;\n\t\t\tif(lvl[v]!=-1||flow<=0) continue;\n\t\t\tlvl[v]=lvl[u]+1;\n\t\t\tq.push(v);\n\t\t}\n\t}\n\treturn (lvl[G]!=-1);\n}\n\nLL dfs(int u,LL mini,int G){\n\tif(u==G) return mini;\n\t\n\tfor(int i=st[u];i<sz(adj[u]);i++){\n\t\tst[u]=i;\n\t\tint v = adj[u][i].v;\n\t\tLL flow = adj[u][i].flow;\n\t\tif(flow<=0||(lvl[v]-lvl[u]!=1)) continue;\n\t\tLL ret=dfs(v,min(mini,flow),G);\n\t\tif(ret>0){\n\t\t\tadj[u][i].flow-=ret;\n\t\t\tint bvf = adj[u][i].bf;\n\t\t\tadj[v][bvf].flow+=ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nLL maxflow(int S,int G){\n\tLL ret=0;\n\twhile(1){\n\t\tif(!bfs(S,G)) break;\n\t\tLL flow = 0;\n\t\tmem(st,0);\n\t\twhile((flow=dfs(S, LLINF, G))>0){\n\t\t\tret+=flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint r,c;\n\tscanf(\"%d%d\",&r,&c);\n\tgetchar();\n\tfor(int i=0;i<r;i++){\n\t\tscanf(\"%s\",input[i]);\n\t}\n\t\n\tint temp=0;\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tidx[i][j]=temp;\n\t\t\tidx1[i][j]=temp+100;\n\t\t\ttemp++;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(input[i][j]=='.'){\n\t\t\t\taddedge(idx[i][j],idx1[i][j],1);\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\taddedge(idx1[i][j],sink,INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\taddedge(source,idx[i][j],INF);\n\t\t\t\taddedge(idx[i][j],idx1[i][j],INF);\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int ii=0;ii<4;ii++){\n\t\t\t\tint tempx = i+xx[ii];\n\t\t\t\tint tempy = j+yy[ii];\n\t\t\t\t\n\t\t\t\tif(tempx<0||tempx>=c||tempy<0||tempy>=r) continue;\n\t\t\t\taddedge(idx1[i][j],idx[tempx][tempy],INF); \n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = maxflow(source,sink);\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <stdio.h>\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n#include <limits.h>\n#include <math.h>\n#include <algorithm>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <list>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <functional>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef double db;\ntypedef long double ldb;\n#define rep(i,a,b) for(i=a;i<b;i++)\n#define repu(i,a,b) for(i=a;i<=b;i++)\n#define repd(i,a,b) for(i=a;i>=b;i--)\n#define repc(i,a,b,c) for(i=a;i<b;i+=c)\n#define repcu(i,a,b,c) for(i=a;i<=b;i+=c)\n#define repcd(i,a,b,c) for(i=a;i>=b;i-=c)\n#define FIN freopen(\"input.in\",\"r\",stdin)\n#define FOUT freopen(\"output.out\",\"w\",stdout)\n#define CC(a) memset(a,0,sizeof(a))\n#define MST(a,b) memset(a,b,sizeof(a))\n#define PII pair<int,int>\n#define PLL pair<long long,long long>\n#define VI vector<int>\n#define VL vector<long long>\n#define VII vector<PII>\n#define VLL vector<PLL>\n#define all(x) x.begin(),x.end()\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n \ntemplate<typename T>inline void gn(T &x){\n\tx=0;T f=1;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\tx*=f;\n}\ntemplate<typename T>inline void gt(T x){\n\tif(!x)return;\n\tgt(x/10);putchar(x%10+'0');\n}\n \nconst LL N=1e6+5;\nLL t,n,m,q,ans;\nLL MOD=1e9+7,inf=0x1f1f1f1f;\ndb eps=1e-5;\n\nLL dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nchar a[111][111],b[111][111];\n\nint main()\n{\n\tios_base::sync_with_stdio(false);cin.tie(0);\n\tLL i,j,k,l,ca=0,x,y;\n\tcin>>n>>m;\n\tMST(a,'.');MST(b,'.');\n\trepu(i,1,n){\n\t\tcin>>a[i]+1;\n\t\trepu(j,1,m){\n\t\t\tif(a[i][j]=='X'){\n\t\t\t\tif(i==1||i==n||j==1||j==m)return cout<<\"-1\",0;\n\t\t\t\trepu(k,0,3){\n\t\t\t\t\tx=i+dx[k];\n\t\t\t\t\ty=j+dy[k];\n\t\t\t\t\tb[x][y]='X';\n\t\t\t\t}\n\t\t\t\tb[i][j]='X';\n\t\t\t}\n\t\t}\n\t}\n\trepu(i,1,n){\n\t\trepu(j,1,m){\n\t\t\tif(b[i][j]=='X'){\n\t\t\t\tl=0;\n\t\t\t\trepu(k,0,3){\n\t\t\t\t\tx=i+dx[k];\n\t\t\t\t\ty=j+dy[k];\n\t\t\t\t\tif(b[x][y]=='.'){\n\t\t\t\t\t\tl=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans+=l;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105],z[105][105];\nbool fr[105][105],vis[105][105],st,ad,f;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,3){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==3){\n\t\t\t\t\tad = 0, f = 1;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,3){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==3){\n\t\t\t\t\tad = 0, f = 1;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Gosu_Hiroo\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing VI = vector<int>;\nusing VL = vector<long long>;\nusing PII = pair<int, int>;\nusing PLL = pair<long long, long long>;\n\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC target(\"avx2\")\n//#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"Ofast\")\n\n#define G(size_1) vector<vector<int>>(size_1, vector<int>())\n#define SZ(x) ((long long)(x).size())\n#define READ ({long long t;cin >> t;t;})\n\n#define FOR(i, _begin, _end) for (__typeof(_end) end = _end, begin = _begin,  i = (begin) - ((begin) > (end)); i != (end) - ((begin) > (end)); i += 1 - 2 * ((begin) > (end)))\n#define REP(i, end) for (__typeof(end) i = 0, _len = (end); i < (_len); i += 1)\n#define ALL(x) (x).begin(),(x).end()\n#define RALL(x) (x).rbegin(),(x).rend()\n#define F first\n#define S second\n#define y0 y3487465\n#define y1 y8687969\n#define j0 j1347829\n#define j1 j234892\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define EB emplace_back\n#define PB push_back\n#define fcout cout << fixed << setprecision(12)\n#define fcerr cerr << fixed << setprecision(12)\n#define print(x) cout << (x) << '\\n'\n#define printE(x) cout << (x) << '\\n';\n#define fprint(x) cout << fixed << setprecision(12) << (x) << '\\n';\n# define BYE(a) do { cout << (a) << endl; return ; } while (false)\n\n#ifdef DEBUG\n#define DBG(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); _err(cerr,_it, args); }\n#define ERR(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); _err(std::cerr,_it, args); }\n#else\n#define DBG(args...) {};\n#define ERR(args...) {};\n#endif\n\nvoid _err(std::ostream &cerr, istream_iterator<string> it) { cerr << endl; }\n\ntemplate<typename T, typename... Args>\nvoid _err(std::ostream &cerr, istream_iterator<string> it, T a, Args... args) {\n    cerr << *it << \" = \" << a << \"  \";\n    _err(cerr, ++it, args...);\n}\n\nconst double PI = 2 * acos(.0);\nconst int INF = 0x3f3f3f3f;\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\ntemplate<class T>\nT ceil(T a, T b) { return (a + b - 1) / b; }\n\ntemplate<typename T, typename U>\nistream &operator>>(istream &is, pair<T, U> &V) {\n    is >> V.F >> V.S;\n    return is;\n}\n\ntemplate<typename T>\nistream &operator>>(istream &is, vector<T> &V) {\n    for (auto &&ele : V)is >> ele;\n    return is;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> V) {\n    os << \"[\";\n    int cnt = 0;\n    T curr;\n    if (!V.empty()) {\n        for (int i = 0; i < V.size() - 1; ++i) {\n            if (V[i] == curr)cnt++;\n            else cnt = 0;\n            if (cnt == 4)os << \"... \";\n            if (cnt < 4)\n                os << i << \":\" << V[i] << \" \";\n            curr = V[i];\n        }\n        os << V.size() - 1 << \":\" << V.back();\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate<typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> P) {\n    os << \"(\";\n    os << P.first << \",\" << P.second;\n    os << \")\";\n    return os;\n}\n\ntemplate<typename T, typename U>\nostream &operator<<(ostream &os, const set<T, U> V) {\n    os << \"{\";\n    if (!V.empty()) {\n        auto it = V.begin();\n        for (int i = 0; i < V.size() - 1; ++i) {\n            os << *it << \" \";\n            it++;\n        }\n        os << *it;\n    }\n    os << \"}\\n\";\n    return os;\n}\n\ntemplate<typename K, typename H, typename P>\nostream &operator<<(ostream &os, const unordered_set<K, H, P> V) {\n    os << \"{\";\n    if (!V.empty()) {\n        auto it = V.begin();\n        for (int i = 0; i < V.size() - 1; ++i) {\n            os << *it << \" \";\n            it++;\n        }\n        os << *it;\n    }\n    os << \"}\\n\";\n    return os;\n}\n\ntemplate<typename K, typename C>\nostream &operator<<(ostream &os, const multiset<K, C> V) {\n    os << \"{\";\n    if (!V.empty()) {\n        auto it = V.begin();\n        for (int i = 0; i < V.size() - 1; ++i) {\n            os << *it << \" \";\n            it++;\n        }\n        os << *it;\n    }\n    os << \"}\";\n    return os;\n}\n\ntemplate<typename K, typename T, typename C>\nostream &operator<<(ostream &os, const map<K, T, C> V) {\n    os << \"{\";\n    if (!V.empty()) {\n        auto it = V.begin();\n        for (int i = 0; i < V.size() - 1; ++i) {\n            os << \"(\";\n            os << it->first << \",\" << it->second;\n            os << \") \";\n            it++;\n        }\n        os << \"(\";\n        os << it->first << \",\" << it->second;\n        os << \")\";\n    }\n    os << \"}\\n\";\n    return os;\n}\n\ntemplate<typename K, typename T, typename C>\nostream &operator<<(ostream &os, const unordered_map<K, T, C> V) {\n    os << \"{\";\n    if (!V.empty()) {\n        auto it = V.begin();\n        for (int i = 0; i < V.size() - 1; ++i) {\n            os << \"(\";\n            os << it->first << \",\" << it->second;\n            os << \") \";\n            it++;\n        }\n        os << \"(\";\n        os << it->first << \",\" << it->second;\n        os << \")\";\n    }\n    os << \"}\\n\";\n    return os;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &os, const deque<T> V) {\n    os << \"[\";\n    if (!V.empty()) {\n        for (int i = 0; i < V.size() - 1; ++i) {\n            os << V[i] << \"->\";\n        }\n        if (!V.empty())os << V.back();\n    }\n    os << \"]\\n\";\n    return os;\n};\n\ntemplate<typename T, typename Cont, typename Comp>\nostream &operator<<(ostream &os, const priority_queue<T, Cont, Comp> V) {\n    priority_queue<T, Cont, Comp> _V = V;\n    os << \"[\";\n    if (!_V.empty()) {\n        while (_V.size() > 1) {\n            os << _V.top() << \"->\";\n            _V.pop();\n        }\n        os << _V.top();\n    }\n    os << \"]\\n\";\n    return os;\n};\n\ntemplate<class F>\nstruct y_combinator {\n    F f; // the lambda will be stored here\n\n    // a forwarding operator():\n    template<class... Args>\n    decltype(auto) operator()(Args &&... args) const {\n        // we pass ourselves to f, then the arguments.\n        // the lambda should take the first argument as `auto&& recurse` or similar.\n        return f(*this, std::forward<Args>(args)...);\n    }\n};\n\n// helper function that deduces the type of the lambda:\ntemplate<class F>\ny_combinator<std::decay_t<F>> recursive(F &&f) {\n    return {std::forward<F>(f)};\n}\n\nstruct hash_pair {\n    template<class T1, class T2>\n    size_t operator()(const pair<T1, T2> &p) const {\n        auto hash1 = hash<T1>{}(p.first);\n        auto hash2 = hash<T2>{}(p.second);\n        return hash1 ^ hash2;\n    }\n\n};\n\ntemplate<typename T, typename U>\nstd::vector<T> multi_vector(int n, U v) {\n    return std::vector<T>(n, v);\n}\n\ntemplate<typename U, typename... Args>\nauto multi_vector(int n, Args... args) {\n    auto val = multi_vector<U>(std::forward<Args>(args)...);\n    return std::vector<decltype(val)>(n, std::move(val));\n}\n\n#ifndef ATCODER_MAXFLOW_HPP\n#define ATCODER_MAXFLOW_HPP 1\n\n#include <algorithm>\n#ifndef ATCODER_INTERNAL_QUEUE_HPP\n#define ATCODER_INTERNAL_QUEUE_HPP 1\n\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class T> struct simple_queue {\n    std::vector<T> payload;\n    int pos = 0;\n    void reserve(int n) { payload.reserve(n); }\n    int size() const { return int(payload.size()) - pos; }\n    bool empty() const { return pos == int(payload.size()); }\n    void push(const T& t) { payload.push_back(t); }\n    T& front() { return payload[pos]; }\n    void clear() {\n        payload.clear();\n        pos = 0;\n    }\n    void pop() { pos++; }\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#endif  // ATCODER_INTERNAL_QUEUE_HPP\n\n#include <cassert>\n#include <limits>\n#include <queue>\n\n\nnamespace atcoder {\n\ntemplate <class Cap> struct mf_graph {\n  public:\n    mf_graph() : _n(0) {}\n    mf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        assert(0 <= cap);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        int from_id = int(g[from].size());\n        int to_id = int(g[to].size());\n        if (from == to) to_id++;\n        g[from].push_back(_edge{to, to_id, cap});\n        g[to].push_back(_edge{from, from_id, 0});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result;\n        for (int i = 0; i < m; i++) {\n            result.push_back(get_edge(i));\n        }\n        return result;\n    }\n    void change_edge(int i, Cap new_cap, Cap new_flow) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        assert(0 <= new_flow && new_flow <= new_cap);\n        auto& _e = g[pos[i].first][pos[i].second];\n        auto& _re = g[_e.to][_e.rev];\n        _e.cap = new_cap - new_flow;\n        _re.cap = new_flow;\n    }\n\n    Cap flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    Cap flow(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        assert(s != t);\n\n        std::vector<int> level(_n), iter(_n);\n        internal::simple_queue<int> que;\n\n        auto bfs = [&]() {\n            std::fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            que.clear();\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front();\n                que.pop();\n                for (auto e : g[v]) {\n                    if (e.cap == 0 || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    if (e.to == t) return;\n                    que.push(e.to);\n                }\n            }\n        };\n        auto dfs = [&](auto self, int v, Cap up) {\n            if (v == s) return up;\n            Cap res = 0;\n            int level_v = level[v];\n            for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                _edge& e = g[v][i];\n                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                if (d <= 0) continue;\n                g[v][i].cap += d;\n                g[e.to][e.rev].cap -= d;\n                res += d;\n                if (res == up) break;\n            }\n            return res;\n        };\n\n        Cap flow = 0;\n        while (flow < flow_limit) {\n            bfs();\n            if (level[t] == -1) break;\n            std::fill(iter.begin(), iter.end(), 0);\n            while (flow < flow_limit) {\n                Cap f = dfs(dfs, t, flow_limit - flow);\n                if (!f) break;\n                flow += f;\n            }\n        }\n        return flow;\n    }\n\n    std::vector<bool> min_cut(int s) {\n        std::vector<bool> visited(_n);\n        internal::simple_queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int p = que.front();\n            que.pop();\n            visited[p] = true;\n            for (auto e : g[p]) {\n                if (e.cap && !visited[e.to]) {\n                    visited[e.to] = true;\n                    que.push(e.to);\n                }\n            }\n        }\n        return visited;\n    }\n\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n\n}  // namespace atcoder\n\n#endif  // ATCODER_MAXFLOW_HPP\n\n\nusing namespace atcoder;\n\nclass E {\npublic:\n\n    void solve(std::istream &cin, std::ostream &cout, std::ostream &cerr) {\n        int N, M;\n        cin >> N >> M;\n        vector<string> g(N);\n        cin >> g;\n        int V = N * M;\n        vector<int> dx = {1, -1, 0, 0}, dy = {0, 0, 1, -1};\n        auto id = [&](int i, int j) { return i * M + j; };\n        auto pos = [&](int x) -> PII { return {x / M, x % M}; };\n        auto ok = [&](int i, int j) { return 0 <= i && i < N && 0 <= j && j < M; };\n        mf_graph<int> mf_g(2*V + 2);\n        REP(i, N)\n            REP(j, M) {\n                mf_g.add_edge(id(i,j), id(i,j)+V, g[i][j]=='.'?1:INF);\n                REP(k, 4) {\n                    int n_i = i + dx[k], n_j = j + dy[k];\n                    if (ok(n_i, n_j)) {\n                        mf_g.add_edge(id(i, j)+V, id(n_i, n_j), 1);\n                    }else mf_g.add_edge(id(i,j)+V, 2*V+1, INF);\n                }\n                if(g[i][j] == 'X')mf_g.add_edge(2*V, id(i,j), INF);\n            }\n        if(auto ans = mf_g.flow(2*V, 2*V+1);ans > 1e6)print(-1);\n        else print(ans);\n\n    }\n\n\n};\n\n\n#undef int\nint main() {\n\n\tE solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n    std::ostringstream err;\n\tin.tie(0); ios::sync_with_stdio(0);\n    solver.solve(in, out,err);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n\tint h, w;\n\tcin >> h >> w;\n\tchar s[101][101];\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tcin >> s[i][j];\n\t\t}\n\t}\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tif(s[i][j] == 'X'){\n\t\t\t\tif(i == 0 || j == 0 || i == h - 1 || j == w - 1){\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\ts[i - 1][j] = '#';\n\t\t\t\ts[i][j - 1] = '#';\n\t\t\t\ts[i + 1][j] = '#';\n\t\t\t\ts[i][j + 1] = '#';\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<bool> > ischecked(101, vector<bool>(101, false));\n\tint sx[2] = {0, h - 1};\n\tint sy[2] = {0, w - 1};\n\tint dx[4] = {0, 1, 0, -1};\n\tint dy[4] = {1, 0, -1, 0};\n\tint ans = 0;\n\tfor(int i = 0; i < 2; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tif(ischecked[sx[i]][j]) continue;\n\t\t\tischecked[sx[i]][j] = true;\n\t\t\tqueue<pair<int, int> > qu;\n\t\t\tqu.push(make_pair(sx[i], j));\n\t\t\twhile(!qu.empty()){\n\t\t\t\tint x = (qu.front()).first;\n\t\t\t\tint y = (qu.front()).second;\n\t\t\t\tqu.pop();\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tint nx = x + dx[k];\n\t\t\t\t\tint ny = y + dy[k];\n\t\t\t\t\tif(nx < 0 || ny < 0 || nx >= h || ny >= w || ischecked[nx][ny]) continue;\n\t\t\t\t\tischecked[nx][ny] = true;\n\t\t\t\t\tif(s[nx][ny] == '#') ans++;\n\t\t\t\t\telse if(s[nx][ny] == '.') qu.push(make_pair(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < 2; i++){\n\t\tfor(int j = 0; j < h; j++){\n\t\t\tif(ischecked[j][sy[i]]) continue;\n\t\t\tischecked[j][sy[i]] = true;\n\t\t\tqueue<pair<int, int> > qu;\n\t\t\tqu.push(make_pair(j, sy[i]));\n\t\t\twhile(!qu.empty()){\n\t\t\t\tint x = (qu.front()).first;\n\t\t\t\tint y = (qu.front()).second;\n\t\t\t\tqu.pop();\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tint nx = x + dx[k];\n\t\t\t\t\tint ny = y + dy[k];\n\t\t\t\t\tif(nx < 0 || ny < 0 || nx >= h || ny >= w || ischecked[nx][ny]) continue;\n\t\t\t\t\tischecked[nx][ny] = true;\n\t\t\t\t\tif(s[nx][ny] == '#') ans++;\n\t\t\t\t\telse if(s[nx][ny] == '.') qu.push(make_pair(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <functional>\n#include <cstring>\n#include <string>\n#include <map>\n#include <set>\n#include <iostream>\n#include <ctime>\n#include <complex>\n\n#define enp \tprintf(\"**Entry Point**\\n\")\n#define A\t\tfirst\n#define B\t\tsecond\n#define MP\t\tmake_pair\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF = 0x6fffffff;\nconst int MINF = 0x80000000;\nconst ll mod = 100003;\nconst int cons = 100001;\nconst double pi = 3.141592653589793;\n\n\nstruct Network\n{\n\tint n;\n\n\tstruct edge\n\t{\n\t\tint to, rev, res;\n\t};\n\n\tvector < vector <edge> > adj;\n\n\tNetwork(int _n)\n\t{\n\t\tn = _n;\n\t\tadj.resize(n + 1);\n\t}\n\n\tvoid addEdge(int s, int e, int _cap, int _cap_rev = 0)\n\t{\n\t\tedge forward{ e, adj[e].size(), _cap };\n\t\tedge reverse{ s, adj[s].size(), _cap_rev };\n\n\t\tadj[s].push_back(forward);\n\t\tadj[e].push_back(reverse);\n\t}\n};\n\nstruct Dinic\n{\n\tint src, sink;\n\tint n;\n\tint maxFlow;\n\tvector <int> lev;\n\tvector <int> start;\n\tNetwork & N;\n\n\tDinic(Network & _N, int _src, int _sink) :N(_N), src(_src), sink(_sink)\n\t{\n\t\tmaxFlow = 0;\n\t\tn = N.n;\n\t\tlev.resize(n + 1);\n\t\tstart.resize(n + 1);\n\t\tStart();\n\t}\n\n\tbool bfs()\n\t{\n\t\tfor (int i = 0; i <= n; i++)lev[i] = 0;\n\t\tqueue <int> qu;\n\t\tqu.push(src);\n\t\tlev[src] = 1;\n\n\t\twhile (!qu.empty() && !lev[sink])\n\t\t{\n\t\t\tint u = qu.front();\n\t\t\tqu.pop();\n\n\t\t\tfor (int i = 0; i < N.adj[u].size(); i++)\n\t\t\t{\n\t\t\t\tint v = N.adj[u][i].to;\n\n\t\t\t\tif (lev[v])continue;\n\t\t\t\tif (N.adj[u][i].res > 0)\n\t\t\t\t{\n\t\t\t\t\tlev[v] = lev[u] + 1;\n\t\t\t\t\tqu.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn lev[sink] != 0;\n\t}\n\n\tint dfs(int u, int flow)\n\t{\n\t\tif (u == sink)return flow;\n\n\t\tfor (int & i = start[u]; i < N.adj[u].size(); i++)\n\t\t{\n\t\t\tint v = N.adj[u][i].to;\n\n\t\t\tif (lev[v] != lev[u] + 1)continue;\n\t\t\tif (N.adj[u][i].res <= 0)continue;\n\n\t\t\tif (int ret = dfs(v, min(flow, N.adj[u][i].res)))\n\t\t\t{\n\t\t\t\tN.adj[u][i].res -= ret;\n\t\t\t\tN.adj[v][N.adj[u][i].rev].res += ret;\n\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tvoid Start()\n\t{\n\t\twhile (bfs())\n\t\t{\n\t\t\tfor (int i = 0; i <= n; i++)start[i] = 0;\n\t\t\twhile (int d = dfs(src, INF))maxFlow += d;\n\t\t}\n\t}\n};\n\nchar M[102][102];\nint r, c;\nint dy[4] = { -1, 0, 1, 0 };\nint dx[4] = { 0, -1, 0, 1 };\n\nint getId(int y, int x)\n{\n\treturn y*c + x + 1;\n}\n\nint getOut(int in)\n{\n\treturn in + r*c;\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &r, &c);\n\n\tint src = 0;\n\tint sink = 2*r*c + 1;\n\n\tNetwork N(sink);\n\n\tfor (int i = 0; i < r; i++)\n\t{\n\t\tscanf(\"%s\", M[i]);\n\t\t\n\t\tfor (int j = 0; j < c; j++)\n\t\t{\n\t\t\tif (i == 0 || i == r - 1 || j == 0 || j == c - 1)\n\t\t\t{\n\t\t\t\tif (M[i][j] == 'X')\n\t\t\t\t{\n\t\t\t\t\tputs(\"-1\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tN.addEdge(src, getId(i, j), 1);\n\t\t\t}\n\t\t\telse if(M[i][j] == 'X')\n\t\t\t{\n\t\t\t\tN.addEdge(getOut(getId(i, j)), sink, INF);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < r; i++)\n\t{\n\t\tfor (int j = 0; j < c; j++)\n\t\t{\n\t\t\tint uin = getId(i,j);\n\t\t\tint uout = getOut(uin);\n\n\t\t\tN.addEdge(uin, uout, M[i][j] == 'X' ? INF : 1);\n\n\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tint ty = i + dy[k];\n\t\t\t\tint tx = j + dx[k];\n\n\t\t\t\tif (ty < 0 || ty >= r || tx < 0 || tx >= c)continue;\n\n\t\t\t\tint vin = getId(ty, tx);\n\t\t\t\tint vout = getOut(vin);\n\n\t\t\t\tN.addEdge(uout, vin, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tDinic D(N, src, sink);\n\n\tprintf(\"%d\\n\", D.maxFlow);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint h,w;\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\ninline bool isRange(int i,int j){\n    return (0<=i && i<h && 0<=j && j<w);\n}\nint main(){\n    cin>>h>>w;\n    vector<string> s(h);\n    for(int i=0;i<h;i++)\n        cin>>s[i];\n    bool isok=true;\n    for(int i=0;i<h;i++)\n        for(int j=0;j<w && isok;j++){\n            if(s[i][j]=='X'){\n                for(int k=0;k<4;k++){\n                    if(!isRange(i+dy[k],j+dx[k])){\n                        isok=false;\n                        break;\n                    }\n                    if(s[i+dy[k]][j+dx[k]]!='X')\n                        s[i+dy[k]][j+dx[k]]='#';\n                }\n\n            }\n\n\n        }\n\n    if(!isok){\n        cout<<-1<<endl;\n        return 0;\n\n    }\n    bool renew=false;\n    do{\n        renew=false;\n        for(int i=0;i<h;i++)\n            for(int j=0;j<w;j++){\n                if(s[i][j]=='#'){\n                    bool removable=true;\n                    for(int k=0;k<4;k++){\n                        if(!isRange(i+dy[k],j+dx[k]) || s[i+dy[k]][j+dx[k]]=='.')\n                            removable=false;\n\n\n                    }\n                    if(removable)\n                        s[i][j]='X',renew=true;\n\n\n                }\n\n\n\n            }\n\n\n\n\n\n    }while(renew);\n    int res=0;\n    for(int i=0;i<h;i++)\n        for(int j=0;j<w;j++)\n            res+=(s[i][j]=='#');\n    cout<<res<<endl;\n    return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int INF =  405;\n\nstruct edge {int to, cap, rev;};\n\nclass FordFolkerson{\n    public:\n        FordFolkerson(int n){\n            N = n;\n            G = vector<vector<edge>>(n, vector<edge>());\n            used = vector<bool>(n, false);\n        }\n\n        void add_edge(int from, int to, int cap){\n            G[from].push_back((edge{to, cap, (int)G[to].size()}));\n            G[to].push_back((edge{from, 0, (int)G[from].size()-1}));\n        }\n\n        int max_flow(int s, int t){\n            int flow = 0;\n            while(true){\n                clear_used();\n                int f = dfs(s, t, INF);\n                if(f == 0){\n                    break;\n                }\n                flow += f;\n            }\n            return flow;\n        }\n\n    private:\n        vector<vector<edge>> G;\n        vector<bool> used;\n        int N;\n        void clear_used(){\n            for(int i = 0; i < N; i++) used[i] = false;\n        }\n\n        int dfs(int v, int t, int f){\n            if(v == t) return f;\n            used[v] = true;\n            for(int i = 0; i < G[v].size(); i++){\n                edge &e = G[v][i];\n                if(!used[e.to] && e.cap > 0){\n                    int d = dfs(e.to, t, min(f, e.cap));\n                    if(d > 0){\n                        e.cap -= d;\n                        G[e.to][e.rev].cap += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n};\n\nint H, W;\nint to_idx(int h, int w){\n    return h*W+w;\n}\n\nint dh[4] = {0, 0, -1, 1};\nint dw[4] = {-1, 1, 0, 0};\n\nbool is_in_field(int i, int j){\n    return i >= 0 && i < H && j >= 0 && j < W;\n}\n\nint to_in_idx(int h, int w){\n    return 1+h*W+w;\n}\n\nint to_out_idx(int h, int w){\n    return 1+H*W+h*W+w;\n}\n\nchar c[100][100];\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(10) << fixed;\n    cin >> H >> W;\n    FordFolkerson ff(3+2*H*W);\n    int s = 0, t = 2*H*W+2;\n    bool ok = true;\n    for(int h = 0; h < H; h++){\n        for(int w = 0; w < W; w++){\n            cin >> c[h][w];\n            int in_idx = 1+h*W+w;\n            int out_idx = 1+H*W+h*W+w;\n            if(c[h][w] == 'X'){\n                ff.add_edge(s, in_idx, INF);\n                ff.add_edge(in_idx, out_idx, INF);\n            }else{\n                ff.add_edge(in_idx, out_idx, 1);\n            }\n            if(h == 0 || h == H-1 || w == 0 || w == W-1){\n                ff.add_edge(out_idx, t, INF);\n                if(c[h][w] == 'X') ok = false;\n            }\n            for(int i = 0; i < 4; i++){\n                int h_to = h+dh[i], w_to = w+dw[i];\n                if(is_in_field(h_to, w_to)){\n                    ff.add_edge(to_out_idx(h_to, w_to), in_idx, 1);\n                    ff.add_edge(out_idx, to_in_idx(h_to, w_to), 1);\n                }\n            }\n        }\n    }\n    if(!ok){\n        cout << -1 << endl;\n    }else{\n        cout << ff.max_flow(s, t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint n,m;\nvector<string>in,out;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nvoid dfs(int x,int y){\n\tout[x][y]=',';\n\trep(i,4){\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\t\tif(nx<0||ny<0||nx>=n||ny>=m)continue;\n\t\tif(out[nx][ny]=='.')dfs(nx,ny);\n\t\telse if(out[nx][ny]=='!')out[nx][ny]='#';\n\t}\n}\nint main(){\n\tcin>>n>>m;\n\tin=vector<string>(n);\n\trep(i,n)cin>>in[i];\n\tout=in;\n\trep(i,n)rep(j,m)out[i][j]='.';\n\tbool h=true;\n\trep(i,n)rep(j,m)if(i==0||j==0||i==n-1||j==m-1){\n\t\tif(in[i][j]=='X')h=false;\n\t}\n\tif(!h){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tint dx[]={3,-3,0,0};\n\tint dy[]={0,0,3,-3};\n\trep(i,n)rep(j,m)if(in[i][j]=='X'){\n\t\tout[i+1][j]=out[i-1][j]=out[i][j+1]=out[i][j-1]='!';\n\t\th=true;\n\t\trep(k,4){\n\t\t\tint x=i+dx[k];\n\t\t\tint y=j+dy[k];\n\t\t\tif(x<0||y<0||x>=n||y>=m){\n\t\t\t\th=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(in[x][y]!='X')h=false;\n\t\t}\n\t\tif(h){\n\t\t\tout[i+2][j+2]=out[i-2][j+2]=out[i+2][j-2]=out[i-2][j-2]='!';\n\t\t}\n\t}\n//\trep(i,n)cout<<out[i]<<endl;\n\trep(i,n)rep(j,m)if(i==0||j==0||i==n-1||j==m-1){\n\t\tif(out[i][j]=='.')dfs(i,j);\n\t}\n//\trep(i,n)cout<<out[i]<<endl;\n\tint co=0;\n\trep(i,n)rep(j,m)if(out[i][j]=='#')co++;\n\tcout<<co<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\nclass Dinic\n{\n    using type = int;\n    const int INF = 1e9;\n    struct Edge\n    {\n        type to, cap, rev;\n        Edge(int _t, int _c, int _r) : to(_t), cap(_c), rev(_r) {}\n    };\n\n    using Graph = std::vector<std::vector<Edge>>;\n    int V;\n    Graph G;\n    std::vector<int> level;\n    std::vector<int> iter;\n\n    void bfs(int s)\n    {\n        fill(level.begin(), level.end(), -1);\n        std::queue<int> que;\n        level[s] = 0;\n        que.push(s);\n        while (!que.empty())\n        {\n            int v = que.front();\n            que.pop();\n            for (const auto &e : G[v])\n            {\n                if (e.cap > 0 && level[e.to] < 0)\n                {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n    type dfs(int v, int t, type f)\n    {\n        if (v == t)\n            return f;\n        for (int &i = iter[v]; i < (int)G[v].size(); i++)\n        {\n            Edge &e = G[v][i];\n            if (e.cap > 0 && level[v] < level[e.to])\n            {\n                type d = dfs(e.to, t, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n  public:\n    Dinic(int _v) : V(_v), G(_v), level(_v), iter(_v) {}\n    void add(int from, int to, int cap)\n    {\n        G[from].push_back(Edge{to, cap, (int)G[to].size()});\n        G[to].push_back(Edge{from, 0, (int)G[from].size() - 1});\n    }\n    type maxFlow(int s, int t)\n    {\n        type ret = 0;\n        while (true)\n        {\n            bfs(s);\n            if (level[t] < 0)\n                return ret;\n            fill(iter.begin(), iter.end(), 0);\n            type f;\n            while ((f = dfs(s, t, INF)) > 0)\n            {\n                ret += f;\n            }\n        }\n    }\n};\n\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int h, w;\n    cin >> h >> w;\n    vector<string> s(h);\n    Dinic dinic(2 * h * w + 2);\n    int S = 0, G = 2 * h * w + 1;\n    for (int i = 0; i < h; i++)\n    {\n        cin >> s[i];\n        for (int j = 0; j < w; j++)\n        {\n            int st = i * w + j + 1;\n            int gt = i * w + j + 1 + h * w;\n            if (s[i][j] == '.')\n                dinic.add(st, gt, 1);\n            else\n            {\n                dinic.add(st, gt, INF);\n                dinic.add(S, gt, INF);\n            }\n            if (i == 0 || i == h - 1 || j == 0 || j == w - 1)\n            {\n                dinic.add(gt, G, INF);\n            }\n            for (int k = 0; k < 4; k++)\n            {\n                int ni = i + dx[k], nj = j + dy[k];\n                if (ni < 0 || h <= ni || nj < 0 || w <= nj)\n                    continue;\n                int nst = ni * w + nj + 1;\n                dinic.add(gt, nst, INF);\n            }\n        }\n    }\n    ll ret = dinic.maxFlow(S, G);\n    cout << (ret < 100000 ? ret : -1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n#include <limits>\n#include <functional>\n#include <iomanip>\n#include <complex>\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER) || __cplusplus > 199711L\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) __typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\nusing namespace std;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }\ntypedef complex<double> P;\nint check[105][105];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\nint H,W;\n\nvoid dfs(int a,int b){\n\tcheck[a][b]=3;\n\tfor(int i=0;i<4;i++){\n\t\tint na=a+dx[i],nb=b+dy[i];\n\t\tif(0<=na&&na<=H+1&&0<=nb&&nb<=W+1){\n\t\t\tif(check[na][nb]==0){\n\t\t\t\t//cout<<na<<\" \"<<nb<<endl;\n\t\t\t\tdfs(na,nb);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tcin>>H>>W;\n\tvector<string> hoge(H);\n\trep(i,H)cin>>hoge[i];\n\tbool flag=true;\n\tfor(int i=0;i<H;i++){\n\t\tif(i==0||i==H-1){\n\t\t\trep(j,W)if(hoge[i][j]=='X')flag=false;\n\t\t}else{\n\t\t\tif(hoge[i][0]=='X')flag=false;\n\t\t\tif(hoge[i][W-1]=='X')flag=false;\n\t\t}\n\t}\n\tif(flag){\n\t\t//vector<pii>data;\n\t\trep(i,H+1)rep(j,W+1)check[i][j]=0;\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\tif(hoge[i-1][j-1]=='X'){\n\t\t\t\t\tcheck[i][j]=2;\n\t\t\t\t\tcheck[i-1][j]=max(check[i-1][j],1);\n\t\t\t\t\tcheck[i+1][j]=max(check[i+1][j],1);\n\t\t\t\t\tcheck[i][j+1]=max(check[i][j+1],1);\n\t\t\t\t\tcheck[i][j-1]=max(check[i][j-1],1);\n\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tdfs(0,0);\n\t\tint ans=0;\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\tif(check[i][j]==1){\n\t\t\t\t\tbool flag=false;\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint ii=i+dx[k],jj=j+dy[k];\n\t\t\t\t\t\tif(check[ii][jj]==3)flag=true;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag)ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}else{\n\t\tcout<<\"-1\"<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nint m;\nstring a[123];\nbool used[123][123];\nbool was[123][123];\n\nvoid dfs(int x, int y) {\n  if (x < 0 || x >= n || y < 0 || y >= m) return;\n  if (was[x][y]) return;\n  was[x][y] = true;\n  if (used[x][y]) return;\n  for (int dx = -1; dx <= 1; ++dx) {\n    for (int dy = -1; dy <= 1; ++dy) {\n      if (abs(dx) + abs(dy) == 1) {\n        dfs(x + dx, y + dy);\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> m;\n  int xa = 123, xb = -123;\n  int ya = 123, yb = -123;\n  for (int x = 0; x < n; ++x) {\n    cin >> a[x];\n    for (int y = 0; y < m; ++y) {\n      if (a[x][y] == 'X') {\n        if (x == 0 || x == n - 1 || y == 0 || y == m - 1) {\n          cout << \"-1\" << endl;\n          return 0;\n        }\n      }\n    }\n  }\n  for (int x = 0; x < n; ++x) {\n    for (int y = 0; y < m; ++y) {\n      if (a[x][y] == '.') continue;\n      for (int dx = -1; dx <= 1; ++dx) {\n        for (int dy = -1; dy <= 1; ++dy) {\n          if (abs(dx) + abs(dy) != 1) continue;\n          int nx = x + dx;\n          int ny = y + dy;\n          if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;\n          used[nx][ny] = true;\n        }\n      }\n    }\n  }\n  for (int x = 0; x < n; ++x) {\n    dfs(x, 0);\n    dfs(x, m - 1);\n  }\n  for (int y = 0; y < m; ++y) {\n    dfs(0, y);\n    dfs(n - 1, y);\n  }\n  int ans = 0;\n  for (int x = 0; x < n; ++x) {\n    for (int y = 0; y < m; ++y) {\n      if (used[x][y] && was[x][y]) {\n        ++ans;\n      }\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nconst int INF = 830252521;\ntypedef int flow_type;\n// Dinic http://www.prefield.com/algorithm/graph/dinic.html\nstruct dinic{\n  struct edge{int to;flow_type cost;};\n  int n;\n  vector< vector<edge> > G;\n  vector< vector<flow_type> > flow, capacity;\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n  vi level;\n  vector<bool> finished;\n  dinic(int _n){\n    n = _n;\n    G.assign(n,vector<edge>());\n    flow.assign(n,vector<flow_type>(n,0));\n    capacity.assign(n,vector<flow_type>(n,0));\n    level.assign(n,0);\n    finished.assign(n,false);\n  }\n  void add_edge(int from,int to,flow_type cost){\n    assert(0<=from && from<n);\n    assert(0<=to && to<n);\n    G[from].push_back((edge){to,cost});\n    G[to].push_back((edge){from,0ll});  // 逆に流すフローのためのダミー辺\n  }\n  flow_type dfs(int u, int t, flow_type cur){\n    if(u==t || cur==0) return cur;\n    if(finished[u]) return 0;\n    finished[u] = true;\n    REP(i,G[u].size()){\n      edge e = G[u][i];\n      if(level[e.to] > level[u]){\n        flow_type f = dfs(e.to, t, min(cur, RESIDUE(u,e.to)));\n        if(f>0){\n          flow[u][e.to] += f;\n          flow[e.to][u] -= f;\n          finished[u] = false;\n          return f;\n        }\n      }\n    }\n    return 0;\n  }\n  flow_type calc(int s, int t){\n    REP(i,n)REP(j,n)flow[i][j]=capacity[i][j]=0;\n    REP(u,n)REP(j,G[u].size()){\n      edge e = G[u][j];\n      capacity[u][e.to] += e.cost;\n    }\n    flow_type total = 0;\n    while(true){\n      REP(i,n)level[i] = -1;\n      level[s] = 0;\n      queue<int> Q; Q.push(s);\n      int d = n;\n      while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        REP(i,G[u].size()){\n          edge e = G[u][i];\n          if(RESIDUE(u,e.to) > 0 && level[e.to] == -1){\n            Q.push(e.to);\n            level[e.to] = level[u] + 1;\n          }\n        }\n      }\n      REP(i,n)finished[i]=false;\n      bool flag = false;\n      while(true){\n        flow_type f = dfs(s,t,INF);\n        if(f==0)break;\n        total += f;\n        flag = true;\n      }\n      if(!flag)break;\n    }\n    return total;\n  }\n};\n\nint h,w;\nchar mp[125][125];\nint dd[] = {1,0,-1,0,1};\n\nint main(){\n  scanf(\"%d%d\",&h,&w);\n  REP(i,h)scanf(\"%s\",mp[i]);\n  // flow\n  dinic g(2*h*w+2);\n  int s=2*h*w;\n  int t=2*h*w+1;\n  REP(i,h)REP(j,w){\n    int id = i*w + j;\n    int x=2*id,y=2*id+1;\n    if(mp[i][j]=='X'){\n      if(i==0||i==h-1||j==0||j==w-1){\n        puts(\"-1\");\n        return 0;\n      }\n      g.add_edge(s,x,INF);\n      g.add_edge(x,y,INF);\n    }else{\n      g.add_edge(x,y,1);\n    }\n    if(i==0||i==h-1||j==0||j==w-1){\n      g.add_edge(y,t,INF);\n    }\n    REP(d,4){\n      int ni=i+dd[d],nj=j+dd[d+1];\n      if(ni<0||ni>=h||nj<0||nj>=w)continue;\n      int nid = ni*w + nj;\n      g.add_edge(y,2*nid,INF);\n    }\n  }\n  printf(\"%lld\\n\",g.calc(s,t));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC target(\"avx2,avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n//#include <atcoder/all>\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class T> struct simple_queue {\n    std::vector<T> payload;\n    int pos = 0;\n    void reserve(int n) { payload.reserve(n); }\n    int size() const { return int(payload.size()) - pos; }\n    bool empty() const { return pos == int(payload.size()); }\n    void push(const T& t) { payload.push_back(t); }\n    T& front() { return payload[pos]; }\n    void clear() {\n        payload.clear();\n        pos = 0;\n    }\n    void pop() { pos++; }\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class Cap> struct mf_graph {\n  public:\n    mf_graph() : _n(0) {}\n    mf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        assert(0 <= cap);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result;\n        for (int i = 0; i < m; i++) {\n            result.push_back(get_edge(i));\n        }\n        return result;\n    }\n    void change_edge(int i, Cap new_cap, Cap new_flow) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        assert(0 <= new_flow && new_flow <= new_cap);\n        auto& _e = g[pos[i].first][pos[i].second];\n        auto& _re = g[_e.to][_e.rev];\n        _e.cap = new_cap - new_flow;\n        _re.cap = new_flow;\n    }\n\n    Cap flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    Cap flow(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n\n        std::vector<int> level(_n), iter(_n);\n        internal::simple_queue<int> que;\n\n        auto bfs = [&]() {\n            std::fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            que.clear();\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front();\n                que.pop();\n                for (auto e : g[v]) {\n                    if (e.cap == 0 || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    if (e.to == t) return;\n                    que.push(e.to);\n                }\n            }\n        };\n        auto dfs = [&](auto self, int v, Cap up) {\n            if (v == s) return up;\n            Cap res = 0;\n            int level_v = level[v];\n            for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                _edge& e = g[v][i];\n                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                if (d <= 0) continue;\n                g[v][i].cap += d;\n                g[e.to][e.rev].cap -= d;\n                res += d;\n                if (res == up) break;\n            }\n            return res;\n        };\n\n        Cap flow = 0;\n        while (flow < flow_limit) {\n            bfs();\n            if (level[t] == -1) break;\n            std::fill(iter.begin(), iter.end(), 0);\n            while (flow < flow_limit) {\n                Cap f = dfs(dfs, t, flow_limit - flow);\n                if (!f) break;\n                flow += f;\n            }\n        }\n        return flow;\n    }\n\n    std::vector<bool> min_cut(int s) {\n        std::vector<bool> visited(_n);\n        internal::simple_queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int p = que.front();\n            que.pop();\n            visited[p] = true;\n            for (auto e : g[p]) {\n                if (e.cap && !visited[e.to]) {\n                    visited[e.to] = true;\n                    que.push(e.to);\n                }\n            }\n        }\n        return visited;\n    }\n\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n\n}  // namespace atcoder\n\nusing namespace atcoder;\n//using mint = modint998244353;\n//using mint = modint1000000007;\n#include <bits/stdc++.h>\nusing namespace std;\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//using namespace __gnu_pbds;\n//using i128 = __int128_t;\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\nusing pll = pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\nconstexpr char ln = '\\n';\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) {if (a < b) {a = b; return true;} return false;}\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) {if (a > b) {a = b; return true;} return false;}\ninline int topbit(int x) {return x == 0 ? -1 : 31-__builtin_clz(x);}\ninline int topbit(long long x) {return x == 0 ? -1 : 63-__builtin_clzll(x);}\ninline int botbit(int x) {return x == 0 ? 32 : __builtin_ctz(x);}\ninline int botbit(long long x) {return x == 0 ? 64 : __builtin_ctzll(x);}\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\ninline int kthbit(long long x, int k) {return (x>>k)&1;}\ninline void print() {cout << \"\\n\";}\ntemplate<class T>\ninline void print(const vector<T> &v) {\n    for (auto itr = v.begin(); itr != v.end(); ++itr) cout << *itr << \" \";\n    print();\n}\ntemplate<class T, class... Args>\ninline void print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n#ifdef MINATO_LOCAL\n#define dump(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\ninline void debug() {cerr << endl;}\ntemplate<class T>\ninline void debug(const vector<T> &v) {\n    for (auto itr = v.begin(); itr != v.end(); ++itr) cerr << *itr << \" \";\n    debug();\n}\ntemplate<class T, class... Args>\ninline void debug(const T &x, const Args &... args) {\n    cerr << x << \" \";\n    debug(args...);\n}\n#else\n#define dump(x) void(0)\ninline void debug() {}\ntemplate<class T> inline void debug(const vector<T> &v) {}\ntemplate<class T, class... Args> inline void debug(const T &x, const Args &... args) {}\n#endif\nstruct Fast_ios {Fast_ios() {cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20);};} fast_ios;\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nconst int dx[4] = {-1,0,0,1};\nconst int dy[4] = {0,-1,1,0};\nconst ll INF = 1e9;\nint main() {\n    int H,W; cin >> H >> W;\n    vector<string> S(H);\n    rep(i,H) cin >> S[i];\n\n    const int out_offset = H*W;\n    const int s = H*W*2;\n    const int t = s+1;\n    mf_graph<ll> g(H*W*2+2);\n    rep(i,H) rep(j,W) {\n        rep(k,4) {\n            int ni = i + dx[k];\n            int nj = j + dy[k];\n            if (ni < 0 or ni >= H or nj < 0 or nj >= W) continue;\n            g.add_edge(out_offset+i*W+j,ni*W+nj,INF);\n        }\n        if (S[i][j]=='X') {\n            if (i==0 or i==H-1 or j==0 or j==W-1) {\n                cout << -1 << ln;\n                return 0;\n            }\n            g.add_edge(i*W+j,out_offset+i*W+j,INF);\n            g.add_edge(s,i*W+j,INF);\n        } else {\n            g.add_edge(i*W+j,out_offset+i*W+j,1);\n            if (i==0 or i==H-1 or j==0 or j==W-1) {\n                g.add_edge(out_offset+i*W+j,t,INF);\n            }\n        }\n    }\n\n    cout << g.flow(s,t) << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 111;\nchar g[maxn][maxn];\nint val[maxn][maxn], vis[maxn][maxn];\nint main(){\n\tint n, m; cin >> n >> m;\n\tfor(int i = 0; i < n; i++) for(int j = 0; j < m; j++) cin >> g[i][j];\n\tfor(int i = 0; i < n; i++) for(int j = 0; j < m; j++) if(g[i][j] == 'X'){\n\t\tif(i == 0 || i == n - 1 || j == 0 || j == m - 1){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tval[i - 1][j] = 1;\n\t\tval[i + 1][j] = 1;\n\t\tval[i][j - 1] = 1;\n\t\tval[i][j + 1] = 1;\n\t}\n\tqueue<pair<int,int> > q;\n\tfor(int i = 0; i < n; i++){\n\t\tvis[i][0] = 1;\n\t\tvis[i][m - 1] = 1;\n\t\tq.push({i, 0});\n\t\tq.push({i, m - 1});\n\t}\n\tfor(int i = 1; i < m - 1; i++){\n\t\tvis[0][i] = 1;\n\t\tvis[n - 1][i] = 1;\n\t\tq.push({0, i});\n\t\tq.push({n - 1, i});\n\t}\n\twhile(!q.empty()){\n\t\tint x, y; tie(x, y) = q.front(); q.pop();\n\t\tif(val[x][y]) continue;\n\t\tfor(int dx : {-1, 0, 1}){\n\t\t\tfor(int dy : {-1, 0, 1}){\n\t\t\t\tif(abs(dx) + abs(dy) == 1){\n\t\t\t\t\tint nx = x + dx, ny = y + dy;\n\t\t\t\t\tif(nx >= 0 && nx < n && ny >= 0 && ny < m && !vis[nx][ny]){\n\t\t\t\t\t\tvis[nx][ny] = 1;\n\t\t\t\t\t\tq.push({nx, ny});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i < n; i++) for(int j = 0; j < m; j++) if(vis[i][j] && val[i][j]) ans++;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n//#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105],z[105][105];\nbool fr[105][105],vis[105][105],st,ad,f;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\tint a,b;\n\trep(ii,1,n)rep(jj,1,m){\n\t\tif(z[ii][jj]=='X'){\n\t\t\trep(kk,0,3)if(x[ii+dr[kk]][jj+dc[kk]]=='.')x[ii+dr[kk]][jj+dc[kk]] = '#';\n//\t\t\tcout<<ii<<' '<<jj<<endl;\n\t\t}\n\t\telse continue;\n\t\tsolve();\n\t\tans = tmp;\n\t\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\t\tst = 1;\n\t\twhile(st){\n\t\t\tst = 0;\n\t\t\trep(i,1,n)rep(j,1,m){\n\t\t\t\ta = i, b = j;\n\t\t\t\trep(k,1,3){\n\t\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\t\tif(k==3){\n\t\t\t\t\t\tad = 0, f = 1;\n\t\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(f){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t++a,++b;\n\t\t\t\t}\n\t\t\t\ta = i, b = j;\n\t\t\t\trep(k,1,3){\n\t\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\t\tif(k==3){\n\t\t\t\t\t\tad = 0, f = 1;\n\t\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\tst = 1, f = 0;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(f){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsolve();\n\t\t\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t++a,--b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tcout<<endl;\n//\t\trep(i,1,n){\n//\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\tcout<<endl;\n//\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define for(i, a, b) for(ll (i)=a;(i)<(b);++(i))\n#define rep(i, n)    for(i, 0, n)\n#define MAX_V        20004\n\nconst ll inf = 1e15;\nconst ll mod = 1e9+7;\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nstruct edge {\n    ll to, cap, rev;\n    edge(ll t, ll c, ll r): to(t), cap(c), rev(r){}\n};\n\nvector<edge> G[MAX_V];\nll level[MAX_V];\nll iter[MAX_V];\n\nvoid add_edge(ll from, ll to, ll cap) {\n    G[from].push_back(edge(to, cap, G[to].size()));\n    G[to].push_back(edge(from, 0, G[from].size() - 1));\n}\n\nvoid bfs(ll s) {\n    memset(level, -1, sizeof(level));\n    queue<ll> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n        ll v = que.front(); que.pop();\n        rep(i, G[v].size()) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nll dfs(ll v, ll t, ll f) {\n    if (v == t) return f;\n    ll &i = iter[v];\n    while (i < G[v].size()) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[v] < level[e.to]) {\n            ll d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n        i++;\n    }\n    return 0;\n}\n\nll max_flow(ll s, ll t) {\n    ll flow = 0;\n    while (true) {\n        bfs(s);\n        if (level[t] < 0) return flow;\n        memset(iter, 0, sizeof(iter));\n        ll f;\n        while ((f = dfs(s, t, inf)) > 0) {\n            flow += f;\n        }\n    }\n}\n\nchar field[101][101];\nint main() {\n    ll H, W; cin >> H >> W;\n    rep(i, H) rep(j, W) {\n        cin >> field[i][j];\n        if (field[i][j] == 'X' && (i == 0 || i == H-1 || j == 0 || j == W-1)) {//淵に牛がいたら-1を出力\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n    \n    ll S = 2 * H * W;//sorce \n    ll T = 2 * H * W + 1;//sink\n    rep(i, H) rep(j, W) {\n        if (field[i][j] == 'X') add_edge(S, i * W + j, inf);//sorceと牛がいるところに重みinfの辺を張る\n        if (i == 0 || i == H-1 || j == 0 || j == W-1) add_edge(H * W + i * W + j, T, inf);//淵とsinkに重みinfの辺を張る\n        add_edge(i * W + j, H * W + i * W + j, field[i][j] == 'X' ? inf : 1);//牛がいるgridの内部に重みinfの辺を張り、そうでないgridに重み1の辺を張る\n        rep(k, 4) {//(i,j).outから隣接4grid.inに辺を張る\n            if (i+dy[k] < 0 || H-1 < i+dy[k] || j+dx[k] < 0 || W-1 < j+dx[k]) continue;\n            add_edge(H * W + i * W + j, (i+dy[k]) * W + (j+dx[k]), inf);\n        }\n    }\n    cout << max_flow(S, T) << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105],z[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#'&&z[i][j]=='X')return 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nint m;\nstring a[123];\nbool used[123][123];\nbool was[123][123];\n\nvoid dfs(int x, int y) {\n  if (x < 0 || x >= n || y < 0 || y >= m) return;\n  if (was[x][y]) return;\n  was[x][y] = true;\n  if (used[x][y]) return;\n  for (int dx = -1; dx <= 1; ++dx) {\n    for (int dy = -1; dy <= 1; ++dy) {\n      if (abs(dx) + abs(dy) == 1) {\n        dfs(x + dx, y + dy);\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> m;\n  int xa = 123, xb = -123;\n  int ya = 123, yb = -123;\n  for (int x = 0; x < n; ++x) {\n    cin >> a[x];\n    for (int y = 0; y < m; ++y) {\n      if (a[x][y] == 'X') {\n        if (x == 0 || x == n - 1 || y == 0 || y == m - 1) {\n          cout << \"-1\" << endl;\n          return 0;\n          xa = min(xa, x);\n          xb = max(xb, x);\n          ya = min(ya, y);\n          yb = max(yb, y);\n        }\n      }\n    }\n  }\n  for (int x = 0; x < n; ++x) {\n    for (int y = 0; y < m; ++y) {\n      if (a[x][y] == '.') continue;\n      for (int dx = -1; dx <= 1; ++dx) {\n        for (int dy = -1; dy <= 1; ++dy) {\n          if (abs(dx) + abs(dy) != 1) continue;\n          int nx = x + dx;\n          int ny = y + dy;\n          if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;\n          used[nx][ny] = true;\n        }\n      }\n    }\n  }\n  for (int x = 0; x < n; ++x) {\n    dfs(x, 0);\n    dfs(x, m - 1);\n  }\n  for (int y = 0; y < m; ++y) {\n    dfs(0, y);\n    dfs(n - 1, y);\n  }\n  int ans = 0;\n  for (int x = 0; x < n; ++x) {\n    for (int y = 0; y < m; ++y) {\n      if (used[x][y] && was[x][y]) {\n        ++ans;\n      }\n    }\n  }\n  int v = 2 * (xb - xa + 1) + 2 * (yb - ya + 1);\n  if (v < ans) {\n    while(1);\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 10000000;\n\nclass MaxFlow {\n\tstruct edge {\n\t\tint to, cap, rev;\n\t\tedge(int to_, int cap_, int rev_) : to(to_), cap(cap_), rev(rev_) {};\n\t};\n\n\tint V;\n\tvector<vector<edge>> G;\n\tvector<int> level;\n\tvector<int> iter;\n\n\tvoid BFS(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (size_t i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint DFS(int v, int t, int f) {\n\t\tif (v == t) return f;\n\t\tfor (int &i = iter[v]; i < (int)G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = DFS(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\npublic:\n\tMaxFlow(int _V) : V(_V), G(_V), level(_V), iter(_V) {}\n\tvoid add(int from, int to, int cap) {\n\t\tG[from].push_back(edge(to, cap, G[to].size()));\n\t\tG[to].push_back(edge(from, 0, G[from].size() - 1));\n\t}\n\tint Dinic(int s, int t) {\n\t\tint flow = 0;\n\t\twhile (true) {\n\t\t\tBFS(s);\n\t\t\tif (level[t] < 0) return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = DFS(s, t, INF)) > 0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\n\nint main()\n{\n\tint H, W;\n\tcin >> H >> W;\n\tvector<string> v(H);\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> v[i];\n\t}\n\tMaxFlow mf(H * W * 2 + 2);\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n\t\t\t\tmf.add(H * W * 2, i * W + j, INF);\n\t\t\t}\n\t\t\tmf.add(i * W + j, H * W + i * W + j, 1);\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tint tx = i + dx[k], ty = j + dy[k];\n\t\t\t\tif (0 <= tx && tx < H && 0 <= ty && ty < W) {\n\t\t\t\t\tmf.add(H * W + i * W + j, tx * W + ty, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (v[i][j] == 'X') mf.add(i * W + j, H * W * 2 + 1, INF);\n\t\t}\n\t}\n\tint res = mf.Dinic(H * W * 2, H * W * 2 + 1);\n\tcout << (res == INF ? -1 : res) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\n#define INF (1 << 29)\nusing namespace std;\n\nstruct point{\n    int x, y;\n};\n\nchar f[105][105] = {0};\nbool fb[105][105] = {0};\nint h, w;\nstatic const int dy[4] = {0,1,0,-1};\nstatic const int dx[4] = {1,0,-1,0};\n\nbool CanEscape(){\n    rep(i,h) if(f[i][0] == 'X' || f[i][w - 1] == 'X') return 1;\n    rep(i,w) if(f[0][i] == 'X' || f[h - 1][i] == 'X') return 1;\n    return 0;\n}\n\nvoid check(queue<point> &q){\n    rep(i,h){\n        rep(j,w){\n            if(f[i][j] == 'X'){\n                point p;\n                p.y = i; p.x = j;\n                q.push(p);\n                rep(k,4){\n                    int y = i + dy[k];\n                    int x = j + dx[k];\n                    if(y < 0 || y >= h || x < 0 || x >= w) continue;\n                    if(f[y][x] != 'X') fb[y][x] = 1;\n                }\n            }\n        }\n    }\n}\n\nbool goatCanEscape(int y, int x){\n    bool isVisited[105][105] = {0};\n    queue<point> q;\n    point start_coordinate;\n    start_coordinate.x = x;\n    start_coordinate.y = y;\n\n    isVisited[start_coordinate.y][start_coordinate.x] = 1;\n    q.push(start_coordinate);\n\n    point u;\n    while(!q.empty()){\n        u = q.front(); q.pop();\n        rep(i,4){\n            point next;\n            next.x = u.x + dx[i];\n            next.y = u.y + dy[i];\n            if(next.y < 0 || next.y >= h || next.x < 0 || next.x >= w) return 1;\n            if(isVisited[next.y][next.x] == 0 && fb[next.y][next.x] == 0){\n                isVisited[next.y][next.x] = 1;\n                q.push(next);\n            }\n        }\n    }\n    return 0;\n}\n\nbool allGoatNotEscape(int y, int x, queue<point> q){\n    while(not q.empty()){\n        if(goatCanEscape(q.front().y, q.front().x)) return 0;\n        q.pop();\n    }\n    return 1;\n}\n\nvoid deleteUselessFence(queue<point> q){\n    int k = 5;\n    while(k--){\n        rep(i,h){\n            rep(j,w){\n                if(fb[i][j] == 1 && f[i][j] != 'X'){\n                    fb[i][j] = 0;\n                    if(not allGoatNotEscape(i, j, q)){\n                        fb[i][j] = 1;\n                    }\n                }\n            }\n        }\n    }\n}\n\nint oneSide(){\n    bool fence[105][105] = {0};\n    rep(i,h){\n        rep(j,w - 1){\n            if(f[i][j + 1] == 'X'){\n                fence[i][j] = 1;\n                break;\n            }\n        }\n    }\n    rep(i,h){\n        for(int j = w - 1; j > 0; j--){\n            if(f[i][j - 1] == 'X'){\n                fence[i][j] = 1;\n                break;\n            }\n        }\n    }\n    rep(i,w){\n        rep(j,h - 1){\n            if(f[j + 1][i] == 'X'){\n                fence[j][i] = 1;\n                break;\n            }\n        }\n    }\n    rep(i,w){\n        for(int j = h - 1; j > 0; j--){\n            if(f[j - 1][i] == 'X'){\n                fence[j][i] = 1;\n                break;\n            }\n        }\n    }\n    int cnt = 0;\n    rep(i,h){\n        rep(j,w){\n            if(fence[i][j] == 1) cnt++;\n        }\n    }\n    return cnt;\n}\n\nint countFence(){\n    int cnt = 0;\n    rep(i,h){\n        rep(j,w){\n            if(fb[i][j] == 1) cnt++;\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    cin >> h >> w;\n    rep(i,h) cin >> f[i];\n    if(CanEscape()){\n        cout << -1 << endl;\n    }else{\n        queue<point> q;\n        check(q);\n        deleteUselessFence(q);\n        cout << min(oneSide(), countFence()) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto&& x : v){cout << x << \" \";} cout << endl\n#define printVV(vv) for(auto&& v : vv){for(auto&& x : v){cout << x << \" \";}cout << endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto&& p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\n// N, E, S, W\nconst int dx[4] = {-1, 0,  1,  0};\nconst int dy[4] = { 0, 1,  0, -1};\n\nint H, W;\n\nbool inside(int x, int y) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cin >> H >> W;\n    vector<string> s(H);\n    rep(i, H) cin >> s[i];\n\n    rep(i, H) {\n        rep(j, W) {\n            if (s[i][j] == 'X') {\n                rep(k, 4) {\n                    int ni = i + dx[k], nj = j + dy[k];\n                    if (!inside(ni, nj)) {\n                        cout << -1 << endl;\n                        return 0;\n                    }\n                    if (s[ni][nj] == '.') {\n                        s[ni][nj] = '#';\n                    }\n                }\n            }\n        }\n    }\n\n    vector<vector<bool>> alive(H, vector<bool>(W));\n    // -->\n    rep(i, H) {\n        rep(j, W) {\n            if (s[i][j] == '#') {\n                alive[i][j] = true;\n                break;\n            }\n        }\n    }\n\n    // <--\n    rep(i, H) {\n        rrep(j, W) {\n            if (s[i][j] == '#') {\n                alive[i][j] = true;\n                break;\n            }\n        }\n    }\n\n    // ↓\n    rep(j, W) {\n        rep(i, H) {\n            if (s[i][j] == '#') {\n                alive[i][j] = true;\n                break;\n            }\n        }\n    }\n\n    // ↑\n    rep(j, W) {\n        rrep(i, H) {\n            if (s[i][j] == '#') {\n                alive[i][j] = true;\n                break;\n            }\n        }\n    }\n\n    int ans = 0;\n    rep(i, H) {\n        ans += accumulate(all(alive[i]), 0);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define fst first\n#define snd second\ntypedef long long ll;\ninline void Fail(){printf(\"-1\");exit(0);}\n\nconst int maxn=105;\nconst int maxm=20005;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nint n,m;\nchar c[maxn][maxn];\n\nclass max_flow{\npublic:\n\tint s,t;\n\tclass EDGE{\n\tpublic:\n\t\tint to,cap,rev;\n\t\tEDGE(int _to,int _cap,int _rev){to=_to;cap=_cap;rev=_rev;}\n\t};\n\tvector<EDGE>edge[maxm];\n\tint lvl[maxm],nxt[maxm],q[maxm];\n\tvoid add_edge(int from,int to,int cap){\n//\t\tcout<<from<<\" \"<<to<<endl;\n\t\tedge[from].pb(EDGE(to,cap,edge[to].size()));\n\t\tedge[to].pb(EDGE(from,0,edge[from].size()-1));\n\t}\n\tvoid bfs(){\n\t\tint l=0,r=0;\n\t\tmemset(lvl,-1,sizeof(lvl));\n\t\tlvl[s]=0;\n\t\tq[r++]=s;\n\t\twhile(l<r){\n\t\t\tint x=q[l++];\n\t\t\trep(i,edge[x].size()){\n\t\t\t\tEDGE &y=edge[x][i];\n\t\t\t\tif(y.cap&&lvl[y.to]<0){\n\t\t\t\t\tlvl[y.to]=lvl[x]+1;\n\t\t\t\t\tq[r++]=y.to;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int x,int f){\n\t\tif(x==t)return f;\n\t\tfor(int &i=nxt[x];i<edge[x].size();i++){\n\t\t\tEDGE &y=edge[x][i];\n\t\t\tif(y.cap&&lvl[y.to]==lvl[x]+1){\n\t\t\t\tint d=dfs(y.to,min(f,y.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\ty.cap-=d;\n\t\t\t\t\tedge[y.to][y.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint mf(){\n\t\tint res=0;\n\t\twhile(true){\n\t\t\tbfs();\n\t\t\tif(lvl[t]<0)return res;\n\t\t\tmemset(nxt,0,sizeof(nxt));\n\t\t\tint f;\n\t\t\twhile((f=dfs(s,INF))>0)res+=f;\n\t\t}\n\t}\n}M;\n\nint get_id(int i,int j,int tp){\n\treturn (i*m+j)*2+tp;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,n)scanf(\"%s\",c[i]);\n\tM.s=n*m*2,M.t=n*m*2+1;\n\trep(i,n)rep(j,m){\n\t\tif(c[i][j]=='X'){\n\t\t\tM.add_edge(get_id(i,j,0),get_id(i,j,1),INF);\n\t\t\tM.add_edge(get_id(i,j,1),M.t,INF);\n\t\t\tif(!i||i==n-1||!j||j==m-1){\n\t\t\t\tprintf(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tM.add_edge(get_id(i,j,0),get_id(i,j,1),1);\n\t\t\tif(!i||i==n-1||!j||j==m-1)M.add_edge(M.s,get_id(i,j,0),INF);\n\t\t}\n\t\trep(k,4){\n\t\t\tint ni=i+dx[k],nj=j+dy[k];\n\t\t\tif(ni>=0&&ni<n&&nj>=0&&nj<m){\n\t\t\t\tM.add_edge(get_id(i,j,1),get_id(ni,nj,0),INF);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",M.mf());\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<ut,VI> PQ;\nconst ut INF=1LL<<30;\nconst int SIZE=201;\nint maps[SIZE][SIZE];\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\ncli d[4];\nbool searched[SIZE][SIZE];\nint solve(){\n\tREP(i,4) d[i]=cli(dy[i],dx[i]);\n\tint H,W;\n\tcin >> H >> W;\n\tqueue<cli> qu;\n\tREP(i,H){\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,W){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(maps[i][j]) qu.push(cli(j,i));\n\t\t}\n\t}\n\tint count=0;\n\twhile(!qu.empty()){\n\t\tcli now=qu.front();\n\t\tqu.pop();\n\t\t\n\t\tif(maps[now.imag()][now.real()]==1) count++;\n\t\tif(count==1e7) return -1;\n\t\tif(maps[now.imag()][now.real()]==1){\n\t\t\t\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) return -1;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=1){\n\t\t\t\t\tqu.push(next);\n\t\t\t\t\tmaps[next.imag()][next.real()]=-1;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t//\tcout << next << endl;\n\t\t\t}\n\t\t}\n\t\telse if(maps[now.imag()][now.real()]==-1){\n\t\t\tint around=0;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) continue;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=0) around++;\n\t\t\t\tif(!searched[now.imag()][now.real()] && maps[next.imag()][next.real()]!=1) qu.push(next);\n\t\t\t}\n\t\t\tsearched[now.imag()][now.real()]=true;\n\t\t\tif(around>=3){\n\t\t\t\tmaps[now.imag()][now.real()]=1;\n\t\t\t\tqu.push(now);\n\t\t\t}\n\t\t} \n\t\telse if(maps[now.imag()][now.real()]==0){\n\t\t\tint around=0;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) continue;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=0) around++;\n\t\t\t}\n\t\t\tif(around>=4){\n\t\t\t\tmaps[now.imag()][now.real()]=1;\n\t\t\t\tqu.push(now);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t//cout << count << endl;\n\tint ans=0;\n\tREP(i,H){\n\t\tREP(j,W)\n\t\t\tans+=maps[i][j]==-1;\n\t}\n\treturn ans;\n}\nint main(){\n\tcout << solve() << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n// c++11\n#include <array>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n\n#define mp make_pair\n#define mt make_tuple\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\n\nconst int INF = 1 << 29;\nconst double EPS = 1e-9;\nconst ll MOD = 1000000007;\n\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\nconst int MAX_N = 110;\nint H,W;\nchar board[MAX_N][MAX_N];\nset<pii> goats;\nset<pii> fences;\nvoid debug_board(){\n  cerr << \"Debug board!!\" << endl;\n  for (int i = 0; i < H; i++){\n    for (int j = 0; j < W; j++){\n      cerr << board[i][j] << \" \";\n    }\n    cerr << endl;\n  }\n}\n\nbool visited[MAX_N][MAX_N];\nbool bfs(int sy, int sx){\n  queue<pii> que;\n  que.emplace(mp(sy, sx));\n  while (not que.empty()){\n    pii pos = que.front();\n    que.pop();\n    int py = pos.first;\n    int px = pos.second;\n    if (visited[py][px]){\n      continue;\n    }\n    visited[py][px] = true;\n    if (py == 0 or py == H - 1 or px == 0 or px == W - 1){\n      return false;\n    }\n    for (int k = 0; k < 4; k++){\n      int ny = py + dy[k];\n      int nx = px + dx[k];\n      if (ny < 0 or ny >= H or nx < 0 or nx >= W){\n        continue;\n      }\n      if (board[ny][nx] == 'F'){\n        continue;\n      }\n      if (visited[ny][nx]){\n        continue;\n      }\n      que.emplace(mp(ny, nx));\n    }\n  }\n  return true;\n}\n\nbool check_escape(){\n  memset(visited, false, sizeof(visited));\n  for (const auto &goat : goats){\n    int y = goat.first;\n    int x = goat.second;\n    if (not bfs(y, x)){\n      return false;\n    }\n  }\n  return true;\n}\n\nint main() {\n  cin >> H >> W;\n  for (int i = 0; i < H; i++){\n    for (int j = 0; j < W; j++){\n      cin >> board[i][j];\n      if (board[i][j] == 'X'){\n        goats.emplace(mp(i, j));\n        if (i == 0 or i == H - 1){\n          cout << -1 << endl;\n          return 0;\n        }\n        if (j == 0 or j == W - 1){\n          cout << -1 << endl;\n          return 0;\n        }\n      }\n    }\n  }\n  for (int i = 0; i < H; i++){\n    for (int j = 0; j < W; j++){\n      if (board[i][j] == 'X'){\n        for (int k = 0; k < 4; k++){\n          int y = i + dy[k];\n          int x = j + dx[k];\n          if (y < 0 or y >= H or x < 0 or x >= W){\n            continue;\n          }\n          if (board[y][x] == '.'){\n            board[y][x] = 'F';\n            fences.emplace(mp(y, x));\n          }\n        }\n      }\n    }\n  }\n  debug_board();\n  int result = fences.size();\n  for (const auto &fence : fences){\n    int y,x;\n    y = fence.first;\n    x = fence.second;\n    board[y][x] = '.';\n    if (not check_escape()){\n      board[y][x] = 'F';\n    }else{\n      result--;\n    }\n  }\n  debug_board();\n  cout << result << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nconst int INF = 830252521;\ntypedef int flow_type;\n// Dinic http://www.prefield.com/algorithm/graph/dinic.html\nstruct dinic{\n  struct edge{int from,to;flow_type cost;edge *rev;};\n  int n;\n  vector< vector<edge> > G;\n  vector< vector<edge> > C;\n  // vector< vector<flow_type> > flow, capacity;\n// #define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n  vi level;\n  vector<bool> finished;\n  dinic(int _n){\n    n = _n;\n    G.assign(n,vector<edge>());\n    // flow.assign(n,vector<flow_type>(n,0));\n    // capacity.assign(n,vector<flow_type>(n,0));\n    level.assign(n,0);\n    finished.assign(n,false);\n  }\n  void add_edge(int from,int to,flow_type cost){\n    assert(0<=from && from<n);\n    assert(0<=to && to<n);\n    edge s = (edge){from,to,cost,NULL};\n    G[from].push_back(s);\n  }\n  flow_type dfs(int u, int t, flow_type cur){\n    if(u==t || cur==0) return cur;\n    if(finished[u]) return 0;\n    finished[u] = true;\n    REP(i,C[u].size()){\n      edge &e = C[u][i];\n      if(level[e.to] > level[u]){\n        flow_type f = dfs(e.to, t, min(cur, e.cost));\n        if(f>0){\n          e.cost -= f;\n          e.rev->cost += f;\n          finished[u] = false;\n          return f;\n        }\n      }\n    }\n    return 0;\n  }\n  flow_type calc(int s, int t){\n    C.assign(n,vector<edge>());\n    REP(i,n)REP(j,G[i].size()){\n      edge s = G[i][j];\n      int from = s.from;\n      int to = s.to;\n      edge t = (edge){to,from,0,NULL};\n      C[from].push_back(s);\n      C[to].push_back(t);\n      C[from].back().rev = &C[to].back();\n      C[to].back().rev = &C[from].back();\n    }\n    flow_type total = 0;\n    while(true){\n      REP(i,n)level[i] = -1;\n      level[s] = 0;\n      queue<int> Q; Q.push(s);\n      int d = n;\n      while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        REP(i,C[u].size()){\n          edge &e = C[u][i];\n          if(e.cost > 0 && level[e.to] == -1){\n            Q.push(e.to);\n            level[e.to] = level[u] + 1;\n          }\n        }\n      }\n      REP(i,n)finished[i]=false;\n      bool flag = false;\n      while(true){\n        flow_type f = dfs(s,t,INF);\n        if(f==0)break;\n        total += f;\n        flag = true;\n      }\n      if(!flag)break;\n    }\n    return total;\n  }\n};\n\nint h,w;\nchar mp[125][125];\nint dd[] = {1,0,-1,0,1};\n\nint main(){\n  scanf(\"%d%d\",&h,&w);\n  REP(i,h)scanf(\"%s\",mp[i]);\n  // flow\n  dinic g(2*h*w+2);\n  int s=2*h*w;\n  int t=2*h*w+1;\n  REP(i,h)REP(j,w){\n    int id = i*w + j;\n    int x=2*id,y=2*id+1;\n    if(mp[i][j]=='X'){\n      if(i==0||i==h-1||j==0||j==w-1){\n        puts(\"-1\");\n        return 0;\n      }\n      g.add_edge(s,x,INF);\n      g.add_edge(x,y,INF);\n    }else{\n      g.add_edge(x,y,1);\n    }\n    if(i==0||i==h-1||j==0||j==w-1){\n      g.add_edge(y,t,INF);\n    }\n    REP(d,4){\n      int ni=i+dd[d],nj=j+dd[d+1];\n      if(ni<0||ni>=h||nj<0||nj>=w)continue;\n      int nid = ni*w + nj;\n      g.add_edge(y,2*nid,INF);\n    }\n  }\n  printf(\"%d\\n\",g.calc(s,t));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr,Vpr> PQ;\nconst int INF=1<<30;\nint H,W;\nint reconv(int x){x-=2;cout << x/(H*W) <<\" \" << x%(H*W)/W <<\" \" << x%(H*W)%W << endl;}\nstruct Edge{\npublic:\n\tint to,cost,cp;\n\tshared_ptr<Edge> rev;\n\tEdge(){to=0;cost=0;cp=0;}\n\tEdge(int a,int b,int c);\n\tvoid add(int x){\n\t\tcp+=x;\n\t}\n\tvoid flow(int amount){\n\t\tadd(-amount);\n\t\trev->add(amount);\n\t}\n\tbool usable(){\n\t\treturn cp>=1;\n\t}\t\n};\nEdge vo;\nEdge::Edge(int t,int c,int cp):to(t),cost(c),cp(cp){\n}\nvoid unite(shared_ptr<Edge> a,shared_ptr<Edge> b){\n\ta->rev=b;\n\tb->rev=a;\n}\n\nqueue<int> qu;\nclass Graph{\n\tint nodeSize,edgeSize;\n\tvector<int> dist;\n\tvector<vector<shared_ptr<Edge>>> edges;\npublic: \n\tvoid add(int a,int b,int cost,int cp){\n\t\t\n\t\tedges[a].PB(make_shared<Edge>(b,cost,cp));\n\t\tedges[b].PB(make_shared<Edge>(a,cost,0));\n\t\tunite(edges[a].back(),edges[b].back());\n\t}\n\tGraph(){}\n\tGraph(int x):nodeSize(x){\n\t\t\n\t\tedges=vector<vector<shared_ptr<Edge>>>(nodeSize);\n\t\tdist=VI(nodeSize);\n\t}\n\tvoid distInit(int s){\n\t\tREP(i,nodeSize){\n\t\t\tdist[i]=INF;\n\t\t}\n\t\tdist[s]=0;\n\t}\n\tint searching(int now,int e,int capacity){\n\t//\tcout << now <<\" \";\n\t//\treconv(now);\n\t\tif(capacity<=0) return 0;\n\t\tif(now==e) return capacity;\n\t\t//if(dist[now]>=dist[e]) return 0;\n\t\tint flowed=0;\n\t\tREP(i,edges[now].size()){\n\t\t\tauto ed= edges[now][i];\n\t\t//\treconv(ed->to);\n\t\t\tif(!ed->usable()) continue;\n\t\t\tif(dist[now]-1 != dist[ed->to]) continue;\n\t\t\tint nflow=searching(ed->to,e,min(capacity-flowed,ed->cp));\n\t\t\tif(nflow){\n\t\t\t\tflowed+=nflow;\n\t\t\t\ted->flow(nflow);\n\t\t\t}\n\t\t\t\n\t\t\t//if(flowed) return flowed;\n\t\t}\n\t\treturn flowed;\n\t}\n\tbool bfs(int s,int e){\n\t\tdistInit(s);\n\t\tqueue<int> qu;\n\t\tqu.push(s);\n\t\twhile(!qu.empty()){\n\t\t\tint now=qu.front();\n\t//\t\t// cout << now << endl;\n\t\t\tqu.pop();\n\t\t\tREP(i,edges[now].size()){;\n\t\t\t\tauto ed=edges[now][i];\n\t\t\t\tif(!ed->rev->usable()) continue;\n\t\t\t\tif(dist[ed->to]==INF){\n\t\t\t\t\tqu.push(ed->to);\n\t\t\t\t\tdist[ed->to]=dist[now]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn dist[e]!=INF;\n\t}\n\tint maximumFlow(int s,int e){\n\t\tint ans=0,bef;\n\t\twhile(bfs(e,s)){\n\t\t\tans+=searching(s,e,INF);\n\t\t\tif(ans==bef) break;\n//\t\t\tcout << ans << endl;\n\t\t\tbef=ans;\n\t\t}\n\t\treturn ans;\n\t}\n};\nconst int SIZE=101;\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\nint maps[SIZE][SIZE];\nGraph graph;\nint conv(int a,int b,int c){return a*W+b+H*W*c+2;}\nbool isSafe(int y,int x){\n\treturn 0<=y && y<H && 0<=x && x<W;\n}\nint main(){\n\tcin >> H >> W;\n\tgraph=Graph(SIZE*SIZE*3+3);\n\tREP(i,H) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,W){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(maps[i][j] &&(i==0 || j==0 || i==H-1 || j==W-1)){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t//\t\tcout << maps[i][j];\n\t\t}\t\t\n//\t\tcout << endl;\n\t}\n\tREP(i,H) REP(j,W) {\n\t\tgraph.add(conv(i,j,1),conv(i,j,0),0,1);\n\t\tif(maps[i][j]){\n\t\t\tgraph.add(0,conv(i,j,0),0,4);\n\t\t}\n\t\tREP(k,4){\n\t\t\tif(!isSafe(i+dy[k],j+dx[k])){\n\t\t\t\tgraph.add(conv(i,j,0),1,0,1);\n\t\t\t} \n\t\t\telse{\n\t\t//\t\tcout << i <<\" \" << j <<\" \" << i+dy[k] <<\" \" << j+dx[k] << endl;\n\t\t//\t\tcout << conv(i,j,0) << \" \" << conv(i+dy[k],j+dx[k],1) << endl;\n\t\t\t\tgraph.add(conv(i,j,0),conv(i+dy[k],j+dx[k],1),0,1);\n\t\t\t\tgraph.add(conv(i+dy[k],j+dx[k],0),conv(i,j,1),0,1);\n\t\t\t}\n\t\t}\n\t\n\t}\n\tcout << graph.maximumFlow(0,1) << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1LL << 40;\n\nstruct Dinic {\npublic:\n\tusing Flow = ll;\n\tDinic(int n_) : n(n_), g(n_) {}\n\tFlow maximumFlow(int s_, int t_) {\n\t\ts = s_;\n\t\tt = t_;\n\t\tFlow res = 0;\n\t\twhile(levelize()) {\n\t\t\tprog.assign(n, 0);\n\t\t\tres += augment(s, INF);\n\t\t}\n\t\treturn res;\n\t}\n\tvoid add_edge(int u, int v, Flow c) {\n\t\tg[u].push_back({ u, v, c, 0, (int)g[v].size() });\n\t\tg[v].push_back({ v, u, c, c, (int)g[u].size() - 1 });\n\t}\n\nprivate:\n\tstruct Edge { int s, d; Flow c, f; int r; };\n\tvector<vector<Edge>> g;\n\tint n, s, t;\n\tvector<int> level, prog;\n\n\tbool levelize() {\n\t\tqueue<int> q;\n\t\tq.push(s);\n\t\tlevel.assign(n, -1);\n\t\tlevel[s] = 0;\n\t\twhile(q.size()) {\n\t\t\tint v = q.front();\n\t\t\tq.pop();\n\t\t\tif(v == t) break;\n\t\t\tfor(auto &e : g[v]) {\n\t\t\t\tif(level[e.d] == -1 && residue(e) != 0) {\n\t\t\t\t\tlevel[e.d] = level[v] + 1;\n\t\t\t\t\tq.push(e.d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn level[t] != -1;\n\t}\n\tFlow augment(int v, Flow lim) {\n\t\tFlow res = 0;\n\t\tif(v == t) return lim;\n\t\tfor(int &i = prog[v]; i < (int)g[v].size(); ++i) {\n\t\t\tif(lim == 0) break;\n\t\t\tauto &e = g[v][i];\n\t\t\tif(level[v] < level[e.d] && residue(e) != 0) {\n\t\t\t\tFlow aug = augment(e.d, min(lim, residue(e)));\n\t\t\t\te.f += aug;\n\t\t\t\treverse(e).f -= aug;\n\t\t\t\tres += aug;\n\t\t\t\tlim -= aug;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tFlow residue(const Edge& e) { return e.c - e.f; }\n\tEdge &reverse(const Edge &e) { return g[e.d][e.r]; }\n};\n\nint H, W;\nchar b[110][110];\nint in[110][110];\nint out[110][110];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++) {\n\t\tfor(int j = 0; j < W; j++) {\n\t\t\tcin >> b[i + 1][j + 1];\n\t\t}\n\t}\n\n\tH += 2, W += 2;\n\n\tint cnt = 0;\n\tfor(int i = 0; i < H; i++) {\n\t\tfor(int j = 0; j < W; j++) {\n\t\t\tin[i][j] = cnt++;\n\t\t\tout[i][j] = cnt++;\n\t\t}\n\t}\n\tint S = cnt++, T = cnt++;\n\n\tDinic d(cnt);\n\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < W; x++) {\n\t\t\tif(b[y][x] == 0) {\n\t\t\t\td.add_edge(out[y][x], T, INF);\n\t\t\t\td.add_edge(in[y][x], out[y][x], INF);\n\t\t\t}\n\t\t\telse if(b[y][x] == 'X') {\n\t\t\t\td.add_edge(S, in[y][x], INF);\n\t\t\t\td.add_edge(in[y][x], out[y][x], INF);\n\t\t\t}\n\t\t\telse {\n\t\t\t\td.add_edge(in[y][x], out[y][x], 1);\n\t\t\t}\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\tif(0 <= nx && nx < W && 0 <= ny && ny < H) {\n\t\t\t\t\td.add_edge(out[y][x], in[ny][nx], INF);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = d.maximumFlow(S, T);\n\tif(ans >= INF) ans = -1;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n\nint n,m,nr,nc,cnt,ans;\nchar x[105][105];\nbool fr[105][105],vis[105][105];\nqueue<pii> q;\n\nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n\nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#', q.push({i+dr[k],j+dc[k]});\n\t}\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<fr[i][j];\n//\t\tcout<<endl;\n//\t}\n\tint r,c;\n\trep(tes,1,100000000){\n\t\tif(q.empty())break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#';\n\t\telse if(!cnt)x[r][c] = '.';\n\t\telse q.push({r,c});\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++ans;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint PREP = (cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(9), 0);\n//int SEGV = getenv(\"D\") || (exit(system(\"D= SEGFAULT_SIGNALS=all catchsegv ./prog.exe\") >> 8), 0);\nconst int INF = 1e8;\nstruct MaximumFlow {\n    vector<vector<tuple<int, int, int>>> G;\n    vector<int> visited;\n    MaximumFlow(int n) {\n        G.resize(n);\n        visited.resize(n);\n    }\n    void add_edge(int s, int t, int c) {\n        int si = G[s].size();\n        int ti = G[t].size();\n        G[s].emplace_back(t, c, ti);\n        G[t].emplace_back(s, 0, si);\n    }\n    int dfs(int s, int t, int c) {\n        visited[s] = 1;\n        if (s == t) return c;\n        for (auto& tup : G[s]) {\n            int n, nc, i; tie(n, nc, i) = tup;\n            if (visited[n]) continue;\n            if (nc == 0) continue;\n            int ret = dfs(n, t, min(c, nc));\n            if (ret > 0) {\n                get<1>(tup) -= ret;\n                get<1>(G[n][i]) += ret;\n                return ret;\n            }\n        }\n        return 0;\n    }\n    int max_flow(int s, int t) {\n        int ans = 0;\n        for (;;) {\n            fill(begin(visited), end(visited), 0);\n            int f = dfs(s, t, INF);\n            if (f == 0) break;\n            ans += f;\n        }\n        return ans;\n    }\n};\nint main() {\n    int H, W; cin >> H >> W;\n    vector<string> S(H); for (auto &s : S) cin >> s;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (S[i][j] == 'X' && (i == 0 || i == H - 1 || j == 0 || j == W - 1)) {\n                cout << -1 << '\\n';\n                return 0;\n            }\n        }\n    }\n    MaximumFlow mf(2 * (H + 2) * (W + 2) + 2);\n    auto idx = [&](int i, int j, int k) { return (i * (W + 2) + j) * 2 + k; };\n    int s = 2 * (H + 2) * (W + 2), t = 2 * (H + 2) * (W + 2) + 1;\n    for (int i = 0; i < H + 2; i++) {\n        for (int j = 0; j < W + 2; j++) {\n            mf.add_edge(idx(i, j, 0), idx(i, j, 1), 1);\n            if (1 <= i && i <= H && 1 <= j && j <= W && S[i-1][j-1] == 'X') {\n                mf.add_edge(s, idx(i, j, 1), INF);\n            }\n            if (i + 1 < H + 2) {\n                mf.add_edge(idx(i + 1, j, 1), idx(i, j, 0), INF);\n                mf.add_edge(idx(i, j, 1), idx(i + 1, j, 0), INF);\n            }\n            if (j + 1 < W + 2) {\n                mf.add_edge(idx(i, j + 1, 1), idx(i, j, 0), INF);\n                mf.add_edge(idx(i, j, 1), idx(i, j + 1, 0), INF);\n            }\n            if (i == 0 || j == 0 || i == H + 1 || j == W + 1) {\n                mf.add_edge(idx(i, j, 0), t, INF);\n            }\n        }\n    }\n    cout << mf.max_flow(s, t) << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define mp make_pair\ntypedef pair<int,int> pii;\n\nconst int N = 110;\nchar s[N][N];\n\nint n, m;\nint xl[4]={-1,1,0,0};\nint yl[4]={0,0,-1,1};\n\nbool vis[N][N];\n\nint solve(){\n    for(int i=0; i<n; i++){\n        if(s[i][0]=='X' || s[i][m-1]=='X')  return -1;\n    }\n    for(int i=0; i<m; i++){\n        if(s[0][i]=='X' || s[n-1][i]=='X')  return -1;\n    }\n    int a, b;\n    for(int i=0; i<n; i++){\n        for(int j=0; j<m; j++){\n            if(s[i][j]=='X'){\n                for(int k=0; k<4; k++){\n                    a = i + xl[k];\n                    b = j + yl[k];\n                    if(a<0 || a>=n || b<0 || b>=m)  continue;\n                    if(s[a][b]=='.'){\n                        s[a][b]='*';\n                    }\n                }\n            }\n        }\n    }\n    memset(vis, 0, sizeof(vis));\n    queue<pii> Q;\n    for(int i=0; i<n; i++){\n        vis[i][0] = vis[i][m-1] = 1;\n        if(s[i][0]=='.'){\n            Q.push(mp(i, 0));\n        }\n        if(s[i][m-1]=='.'){\n            Q.push(mp(i, m-1));\n        }\n    }\n    for(int i=0; i<m; i++){\n        vis[0][i] = vis[n-1][i] = 1;\n        if(s[0][i]=='.'){\n            Q.push(mp(0, i));\n        }\n        if(s[n-1][i]=='.'){\n            Q.push(mp(n-1, i));\n        }\n    }\n    int x, y;\n    pii p;\n    while(!Q.empty()){\n        p = Q.front(); Q.pop();\n        for(int i=0; i<4; i++){\n            x = p.first + xl[i];\n            y = p.second + yl[i];\n            if(x<0 || x>=n || y<0 || y>=m)  continue;\n            if(vis[x][y])   continue;\n            vis[x][y] = 1;\n            if(s[x][y]=='.'){\n                Q.push(mp(x, y));\n            }\n        }\n    }\n    int ret = 0;\n    for(int i=0; i<n; i++){\n        for(int j=0; j<m; j++){\n            if(s[i][j]=='*' && vis[i][j]){\n                ret++;\n            }\n        }\n    }\n    return min(n*2+m*2-4, ret);\n}\n\nint main(){\n    while(~scanf(\"%d %d\", &n, &m)){\n        for(int i=0; i<n; i++)  scanf(\"%s\", s[i]);\n        printf(\"%d\\n\", solve());\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <map>\n#define SIZE 105\n#define MX 20005\n#define INF 1000000000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nstruct MaxFlow\n{\n\tstruct edge\n\t{\n\t\tint to,cap,rev;\n\t\tedge(int to=0,int cap=0,int rev=0):to(to),cap(cap),rev(rev){}\n\t};\n\tvector <edge> vec[MX];\n\tint level[MX];\n\tint iter[MX];\n\t\n\tvoid add(int s,int t,int c)\n\t{\n\t\tint S=vec[s].size(),T=vec[t].size();\n\t\tvec[s].push_back(edge(t,c,T));\n\t\tvec[t].push_back(edge(s,0,S));\n\t}\n\tvoid bfs(int s)\n\t{\n\t\tmemset(level,-1,sizeof(level));\n\t\tqueue <int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<vec[v].size();i++)\n\t\t\t{\n\t\t\t\tedge&e=vec[v][i];\n\t\t\t\tif (e.cap>0&&level[e.to]<0)\n\t\t\t\t{\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint flow_dfs(int v,int t,int f)\n\t{\n\t\tif (v==t) return f;\n\t\tfor(int &i=iter[v];i<vec[v].size();i++)\n\t\t{\n\t\t\tedge &e=vec[v][i];\n\t\t\tif (e.cap>0&&level[v]<level[e.to])\n\t\t\t{\n\t\t\t\tint d=flow_dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif (d>0)\n\t\t\t\t{\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tvec[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s,int t)\n\t{\n\t\tint flow = 0;\n\t\twhile(1)\n\t\t{\n\t\t\tbfs(s);\n\t\t\tif (level[t]<0) return flow;\n\t\t\tmemset(iter,0,sizeof(iter));\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tint f=flow_dfs(s,t,INF);\n\t\t\t\tif(f==0) break;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\nMaxFlow M;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nchar mp[SIZE][SIZE];\nbool use[SIZE][SIZE];\nbool vis[SIZE][SIZE];\nint h,w;\n\nint in_id(int x,int y)\n{\n\treturn (x*w+y)*2;\n}\nint out_id(int x,int y)\n{\n\treturn (x*w+y)*2+1;\n}\nint main()\n{\n\tscanf(\"%d %d\",&h,&w);\n\tfor(int i=0;i<h;i++) scanf(\"%s\",&mp[i]);\n\tint S=h*w*2,T=S+1;\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<w;j++)\n\t\t{\n\t\t\tif(mp[i][j]=='X')\n\t\t\t{\n\t\t\t\tM.add(out_id(i,j),T,INF);\n\t\t\t\tM.add(in_id(i,j),out_id(i,j),INF);\n\t\t\t\tif(i==0||i==h-1||j==0||j==w-1)\n\t\t\t\t{\n\t\t\t\t\tputs(\"-1\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tM.add(in_id(i,j),out_id(i,j),1);\n\t\t\t}\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\tint nx=i+dx[k],ny=j+dy[k];\n\t\t\t\tif(0<=nx&&nx<h&&0<=ny&&ny<w)\n\t\t\t\t{\n\t\t\t\t\tM.add(out_id(i,j),in_id(nx,ny),INF);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tM.add(S,in_id(i,j),INF);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret=M.max_flow(S,T);\n\tprintf(\"%d\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream> \n#include<map>\n#include <iomanip>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\nusing namespace std;\n#define MAX_MOD 1000000007\n#define REP(i,n) for(long long i = 0;i < n;++i)\n#define LONGINF 1000000000000000000\ntemplate <typename T, typename U>\nstd::pair<T, U> operator+(const std::pair<T, U> & l, const std::pair<T, U> & r) {\n\treturn{ l.first + r.first,l.second + r.second };\n}\nmap<pair<int, int>, int> yagi;\nmap<pair<int, int>, int> saku;\npair<int, int> moves[4] = { make_pair(1,0),make_pair(-1,0),make_pair(0,-1),make_pair(0,1) };\nint h, w;\nbool check(pair<int, int> a) {\n\tif (a.first == 0 || a.second == 0) return false;\n\tif (a.first == h - 1 || a.second == w - 1) return false;\n\treturn true;\n}\nint main() {\n\tcin >> h >> w;\n\tqueue<pair<int, int>> letsmove;\n\tREP(i, h) {\n\t\tstring tmp;\n\t\tcin >> tmp;\n\t\tREP(q, w) {\n\t\t\tif (tmp[q] == 'X') {\n\t\t\t\tpair<int, int> foo = make_pair(i,q);\n\t\t\t\tif (check(foo) == false) {\n\t\t\t\t\tcout << \"-1\" << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tsaku[foo] = false;\n\t\t\t\tyagi[foo] = true;\n\t\t\t\tletsmove.push(foo);\n\t\t\t\tREP(j, 4) {\n\t\t\t\t\tif (yagi[foo + moves[j]] == false) saku[foo + moves[j]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//柵探索\n\twhile (letsmove.empty() == false) {\n\t\tpair<int, int> gogo = letsmove.front();\n\t\tletsmove.pop();\n\t\tfor (int i = 0;i < 4;++i) {\n\t\t\tif (check(gogo+moves[i])== true&&saku[gogo + moves[i]] == true) {\n\t\t\t\tint diag = -1;\n\t\t\t\tfor (int q = 0;q < 4;++q) {\n\t\t\t\t\tif (saku[gogo + moves[i] + moves[q]] == false && yagi[gogo + moves[i] + moves[q]] == false) {\n\t\t\t\t\t\tif (diag == -1) {\n\t\t\t\t\t\t\tdiag = q;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse goto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tREP(q, 4) {\n\t\t\t\t\tletsmove.push(gogo + moves[i] + moves[q]);\n\t\t\t\t}\n\t\t\t\tletsmove.push(gogo + moves[i]);\n\t\t\t\tsaku[gogo+moves[i]] = false;\n\t\t\t\tyagi[gogo + moves[i]] = true;\n\t\t\t\tif (diag != -1) {\n\t\t\t\t\tsaku[gogo + moves[i] + moves[diag]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\tout:;\n\t\t}\n\t}\n\tint ans = 0;\n\tREP(i, h) {\n\t\tREP(q, w) {\n\t\t\tif (saku[make_pair(i,q)] == true)ans++;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\nint main(){\n\tint H, W;\n\twhile(cin >> H >> W){\n\t\tvector<string> vs(H);\n\t\tfor(int i=0;i<H;++i) cin >> vs[i];\n\t\tbool ok = true;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tif(vs[i][j] != 'X') continue;\n\t\t\t\tif(i == 0 || i == H-1 || j == 0 || j == W-1){\n\t\t\t\t\tok = false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint nx = i+dx[k];\n\t\t\t\t\tint ny = j+dy[k];\n\t\t\t\t\tif(vs[nx][ny] != 'X') vs[nx][ny] = 'Y';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!ok){\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue< pair<int,int> > qu;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tif(vs[i][0] == '.'){\n\t\t\t\tqu.push(make_pair(i, 0));\n\t\t\t\tvs[i][0] = 'Z';\n\t\t\t}\n\t\t\tif(vs[i][W-1] == '.'){\n\t\t\t\tqu.push(make_pair(i, W-1));\n\t\t\t\tvs[i][W-1] = 'Z';\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<W;i++){\n\t\t\tif(vs[0][i] == '.'){\n\t\t\t\tqu.push(make_pair(0, i));\n\t\t\t\tvs[0][i] = 'Z';\n\t\t\t}\n\t\t\tif(vs[H-1][i] == '.'){\n\t\t\t\tqu.push(make_pair(H-1, i));\n\t\t\t\tvs[H-1][i] = 'Z';\n\t\t\t}\n\t\t}\n\t\twhile(!qu.empty()){\n\t\t\tpair<int, int> pr = qu.front(); qu.pop();\n\t\t\tint x = pr.first, y = pr.second;\n\t\t\tfor(int i=0;i<4;++i){\n\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\tif(nx < 0 || H <= nx || ny < 0 || W <= ny) continue;\n\t\t\t\tif(vs[nx][ny] != '.') continue;\n\t\t\t\tqu.push(make_pair(nx, ny));\n\t\t\t\tvs[nx][ny] = 'Z';\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tif(vs[i][j] != 'Y') continue;\n\t\t\t\tbool ok = true;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint nx = i+dx[k];\n\t\t\t\t\tint ny = j+dy[k];\n\t\t\t\t\tif(nx < 0 || H <= nx || ny < 0 || W <= ny){ ok = false; continue; }\n\t\t\t\t\tif(vs[nx][ny] == 'Z') ok = false;\n\t\t\t\t}\n\t\t\t\tif(!ok) ++res;\n\t\t\t\tif(ok) vs[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iomanip>\n \nusing namespace std;\n \ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<LD, LD> PLDLD;\ntypedef vector<int> VI;\ntypedef vector<char> VB;\n \n#define FOR(i,a,b) for(int i=(a);i<(int)(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define ALL(a) a.begin(),a.end()\n \nconst LD eps=1e-5;\n//const long long INF=(LL)(1e9)*(LL)(1e9);\nconst int INF=1e9;\n \ntemplate<class T>\nvoid chmin(T& a, const T& b)\n{\n\tif(a>b)\n\t\ta=b;\n}\ntemplate<class T>\nvoid chmax(T& a, const T& b)\n{\n\tif(a<b)\n\t\ta=b;\n}\n \nconst LL pow(const LL p, const LL q)\n{\n\tLL t=1;\n\tREP(i,q)\n\t\tt*=p;\n\treturn t;\n}\n\n//print for container\n/*\ntemplate<typename Iterator>\nvoid print(const Iterator& first, const Iterator& last)\n{\n\tauto&& back=prev(last);\n\tfor(auto e=first; e!=last; e=next(e))\n\t\tcout<<*e<<\" \\n\"[e==back];\n}*/\n\ntemplate<typename Head>\nvoid print(const Head& head)\n{\n\tcout<<head<<endl;\n}\n\ntemplate<typename Head, typename... Tail>\nvoid print(const Head& head, const Tail&... tail)\n{\n\tcout<<head<<\" \";\n\tprint(tail...);\n}\n\nvoid io_speedup()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n}\n\ntemplate<typename T>\nT read()\n{\n\tT t;\n\tcin>>t;\n\treturn t;\n}\n\n//set INF\nusing FLOW = long long;\nstruct Edge\n{\n    int to;\n    FLOW cap;\n    int rev;\n};\nclass FlowNetwork\n{\n    public:\n        FlowNetwork(int n):graph(vector<vector<Edge>>(n)),iter(vector<int>(n)),level(vector<int>(n))\n        {}\n        void add_Edge(int from, int to, FLOW cap);\n        FLOW dinic(int from, int to);\n\n    private:\n        vector<vector<Edge>> graph;\n        vector<int> iter, level;\n        FLOW dfs(int from, int to, FLOW cap);\n        void bfs(int from);\n};\nvoid FlowNetwork::add_Edge(int from, int to, FLOW cap)\n{\n    //cout<<from<<\":\"<<to<<\" \"<<cap<<endl;\n\tgraph[from].push_back((Edge){to,cap,(int)graph[to].size()});\n\tgraph[to].push_back((Edge){from,0,(int)graph[from].size()-1});\n}\n\nvoid FlowNetwork::bfs(int from)\n{\n    fill(level.begin(),level.end(),-1);\n    queue<int> que;\n    level[from]=0;\n    que.push(from);\n    while(!que.empty())\n    {\n        int v=que.front();\n        que.pop();\n        for(int i=0;i<graph[v].size();i++)\n        {\n            Edge &e=graph[v][i];\n            if(e.cap>0 && level[e.to]<0)\n            {\n                level[e.to] = level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nFLOW FlowNetwork::dfs(int from, int to, FLOW f)\n{\n\tif(from == to) return f;\n\tfor(int &i=iter[from];i<graph[from].size();i++)\n\t{\n\t\tEdge &e=graph[from][i];\n        if(e.cap > 0 && level[from] < level[e.to])\n        {\n            FLOW d = dfs(e.to, to, min(e.cap, f));\n            if(d>0)\n            {\n                e.cap -= d;\n                graph[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n\t}\n\treturn 0;\n}\nFLOW FlowNetwork::dinic(int from, int to)\n{\n    FLOW flow=0;\n\twhile(1)\n\t{\n        bfs(from);\n        if(level[to]<0) return flow;\n        fill(iter.begin(),iter.end(),0);\n        FLOW f;\n        while((f=dfs(from,to,INF))>0)\n        {\n            flow+=f;\n        }\n\t}\n}\n\nint dx[]={1,0,-1,0}, dy[]={0,1,0,-1};\nint main()\n{\n\tint h,w;\n\tcin>>h>>w;\n\tauto ptoi=[&](int x,int y)\n\t{\n\t\treturn x*h+y;\n\t};\n\tFlowNetwork flow(w*h*2+2);\n\tREP(j,h)\n\tREP(i,w)\n\t{\n\t\tREP(k,4)\n\t\t{\n\t\t\tint px=i+dx[k],py=j+dy[k];\n\t\t\tif(!(0<=px&&px<w&&0<=py&&py<h)) continue;\n\t\t\tflow.add_Edge(ptoi(i,j)+w*h,ptoi(px,py),INF);\n\t\t}\n\t}\n\tREP(j,h)\n\t{\n\t\tstring s=read<string>();\n\t\tREP(i,w)\n\t\t{\n\t\t\tif(s[i]=='.')\n\t\t\t{\n\t\t\t\tflow.add_Edge(ptoi(i,j),ptoi(i,j)+w*h,1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tflow.add_Edge(ptoi(i,j),ptoi(i,j)+w*h,INF);\n\t\t\t\tflow.add_Edge(ptoi(i,j)+w*h, w*h*2+1, INF);\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,w)\n\t{\n\t\tflow.add_Edge(w*h*2, ptoi(i,0), INF);\n\t\tflow.add_Edge(w*h*2, ptoi(i,h-1), INF);\n\t}\n\tREP(j,h)\n\t{\n\t\tflow.add_Edge(w*h*2, ptoi(0,j), INF);\n\t\tflow.add_Edge(w*h*2, ptoi(w-1,j), INF);\n\t}\n\tint ans=flow.dinic(w*h*2,w*h*2+1);\n\tif(ans==INF) ans=-1;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\ntemplate<class V> struct MaxFlow {\n    struct edge { int to, reve; V cap; edge(int t, int r, V c) : to(t), reve(r), cap(c) {} };\n    int MV; vector<vector<edge>> E; vector<int> itr, lev;\n    MaxFlow() {} MaxFlow(int n) { init(n); }\n    void init(int n) { MV = n; itr = vector<int>(MV), lev = vector<int>(MV); E = vector<vector<edge>>(MV); }\n    void add_edge(int x, int y, V cap, bool undir = false) { E[x].push_back(edge(y, (int)E[y].size(), cap));\n        E[y].push_back(edge(x, (int)E[x].size() - 1, undir ? cap : 0)); }\n    void bfs(int cur) { rep(i, 0, MV) lev[i] = -1; queue<int> q; lev[cur] = 0; q.push(cur);\n        while (q.size()) { int v = q.front(); q.pop();\n        for(auto e : E[v]) if (e.cap>0 && lev[e.to]<0) lev[e.to] = lev[v] + 1, q.push(e.to); } }\n    V dfs(int from, int to, V cf) { if (from == to) return cf;\n        for (; itr[from]<E[from].size(); itr[from]++) {\n            edge* e = &E[from][itr[from]]; if (e->cap>0 && lev[from]<lev[e->to]) { \n                V f = dfs(e->to, to, min(cf, e->cap));\n                if (f>0) { e->cap -= f; E[e->to][e->reve].cap += f; return f; }\n            } } return 0; }\n    V maxflow(int from, int to) { V fl = 0, tf;\n        while (1) { bfs(from); if (lev[to]<0) return fl;\n            rep(i, 0, MV) itr[i] = 0; while ((tf = dfs(from, to, numeric_limits<V>::max()))>0) fl += tf; } }\n};\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　　|　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n#define INF 100000\nint H, W; string S[101];\nint dx[4] = { 0, 1, 0, -1 }, dy[4] = { -1, 0, 1, 0 };\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> H >> W;\n    rep(y, 0, H) cin >> S[y];\n\n    int N = H * W;\n    MaxFlow<int> mf(N * 2 + 2);\n    int s = N * 2, t = N * 2 + 1;\n\n    rep(y, 0, H) rep(x, 0, W) {\n        if (S[y][x] == 'X') {\n            mf.add_edge(y * W + x, y * W + x + N, INF);\n            mf.add_edge(s, y * W + x, INF);\n        }\n        else mf.add_edge(y * W + x, y * W + x + N, 1);\n    }\n\n    rep(y, 0, H) rep(x, 0, W) rep(i, 0, 4) {\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n        int a = y * W + x;\n        int b = yy * W + xx;\n        \n        if (xx < 0 || W <= xx || yy < 0 || H <= yy) mf.add_edge(a + N, t, INF);\n        else {\n            mf.add_edge(a + N, b, 1);\n            if(S[y][x] == '.') mf.add_edge(a + N, b, INF);\n        }\n    }\n\n    int f = mf.maxflow(s, t);\n    if (INF <= f) f = -1;\n    cout << f << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define SPEED ios::sync_with_stdio(false); cin.tie(0); cout.tie(0)\n#define fileio freopen(\"in.in\", \"r\", stdin),freopen(\"out.out\", \"w\", stdout);\n#define ll long long int\n#define FF first\n#define SS second\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<long long int,long long int>\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define pd(x) printf(\"%d\\n\",x)\n#define plld(x) printf(\"%lld\\n\",x)\n#define pss printf\n#define MOD 1000000007\n#define INF 1e6\n#define eps 0.00001\n#define endl '\\n'\n#define debug(n1) cout<<n1<<endl\nll h,w;\nbool vis[105][105];\nstring s;\nll get(ll i,ll j)\n{\n\treturn (i-1)*w+j;\n}\ntypedef long long LL;\n\nstruct Edge {\n  int from, to, cap, flow, index;\n  Edge(int from, int to, int cap, int flow, int index) :\n    from(from), to(to), cap(cap), flow(flow), index(index) {}\n};\n\nstruct PushRelabel {\n  int N;\n  vector<vector<Edge> > G;\n  vector<LL> excess;\n  vector<int> dist, active, count;\n  queue<int> Q;\n\n  PushRelabel(int N) : N(N), G(N), excess(N), dist(N), active(N), count(2*N) {}\n\n  void AddEdge(int from, int to, int cap) {\n    G[from].push_back(Edge(from, to, cap, 0, G[to].size()));\n    if (from == to) G[from].back().index++;\n    G[to].push_back(Edge(to, from, 0, 0, G[from].size() - 1));\n  }\n\n  void Enqueue(int v) { \n    if (!active[v] && excess[v] > 0) { active[v] = true; Q.push(v); } \n  }\n\n  void Push(Edge &e) {\n    int amt = int(min(excess[e.from], LL(e.cap - e.flow)));\n    if (dist[e.from] <= dist[e.to] || amt == 0) return;\n    e.flow += amt;\n    G[e.to][e.index].flow -= amt;\n    excess[e.to] += amt;    \n    excess[e.from] -= amt;\n    Enqueue(e.to);\n  }\n  \n  void Gap(int k) {\n    for (int v = 0; v < N; v++) {\n      if (dist[v] < k) continue;\n      count[dist[v]]--;\n      dist[v] = max(dist[v], N+1);\n      count[dist[v]]++;\n      Enqueue(v);\n    }\n  }\n\n  void Relabel(int v) {\n    count[dist[v]]--;\n    dist[v] = 2*N;\n    for (int i = 0; i < G[v].size(); i++) \n      if (G[v][i].cap - G[v][i].flow > 0)\n\tdist[v] = min(dist[v], dist[G[v][i].to] + 1);\n    count[dist[v]]++;\n    Enqueue(v);\n  }\n\n  void Discharge(int v) {\n    for (int i = 0; excess[v] > 0 && i < G[v].size(); i++) Push(G[v][i]);\n    if (excess[v] > 0) {\n      if (count[dist[v]] == 1) \n\tGap(dist[v]); \n      else\n\tRelabel(v);\n    }\n  }\n\n  LL GetMaxFlow(int s, int t) {\n    count[0] = N-1;\n    count[N] = 1;\n    dist[s] = N;\n    active[s] = active[t] = true;\n    for (int i = 0; i < G[s].size(); i++) {\n      excess[s] += G[s][i].cap;\n      Push(G[s][i]);\n    }\n    \n    while (!Q.empty()) {\n      int v = Q.front();\n      Q.pop();\n      active[v] = false;\n      Discharge(v);\n    }\n    \n    LL totflow = 0;\n    for (int i = 0; i < G[s].size(); i++) totflow += G[s][i].flow;\n    return totflow;\n  }\n};\nint main()\n{\n\tSPEED;\n\tmemset(vis,1,sizeof vis);\n\tcin>>h>>w;\n\tfor(int i=1;i<=h;i++)\n\t{\n\t\tcin>>s;\n\t\tfor(int j=1;j<=w;j++)\n\t\t{\n\t\t\tif(s[j-1]!='X')\n\t\t\t{\n\t\t\t\tvis[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=h;i++)\n\t\tif(vis[i][1]||vis[i][w])\n\t\t\treturn cout<<-1<<endl,0;\n\tfor(int i=1;i<=w;i++)\n\t\tif(vis[1][i]||vis[h][i])\n\t\t\treturn cout<<-1<<endl,0;\n\tPushRelabel pr(2*h*w+5);\n\tfor(int i=1;i<=h;i++)\n\t\tfor(int j=1;j<=w;j++)\n\t\t\tpr.AddEdge(get(i,j),get(i,j)+h*w,(vis[i][j]?INF:1));\n\tfor(int i=1;i<=h;i++)\n\t{\n\t\tfor(int j=1;j<=w;j++)\n\t\t{\n\t\t\tif(vis[i][j])\n\t\t\t\tpr.AddEdge(0,get(i,j),INF);\n\t\t\tif(!vis[i-1][j])\n\t\t\t\tpr.AddEdge(get(i,j)+h*w,get(i-1,j),INF);\n\t\t\tif(!vis[i+1][j])\n\t\t\t\tpr.AddEdge(get(i,j)+h*w,get(i+1,j),INF);\n\t\t\tif(!vis[i][j-1])\n\t\t\t\tpr.AddEdge(get(i,j)+h*w,get(i,j-1),INF);\n\t\t\tif(!vis[i][j+1])\n\t\t\t\tpr.AddEdge(get(i,j)+h*w,get(i,j+1),INF);\n\t\t}\n\t}\n\tfor(int i=1;i<=h;i++)\n\t{\n\t\tpr.AddEdge(h*w+get(i,1),2*h*w+1,INF);\n\t\tpr.AddEdge(h*w+get(i,w),2*h*w+1,INF);\n\t}\n\tfor(int i=1;i<=w;i++)\n\t{\n\t\tpr.AddEdge(h*w+get(1,i),2*h*w+1,INF);\n\t\tpr.AddEdge(h*w+get(h,i),2*h*w+1,INF);\n\t}\n\tcout<<pr.GetMaxFlow(0,2*h*w+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nconst int oo=214748364;\nstruct edges\n{\n\tint to,next,f;\n}edge[202020];\nint first[20202],firstn[20202],now;\nvoid adde1(int x,int y,int z)\n{\n\tnow++;\n\tedge[now].to=y;\n\tedge[now].f=z;\n\tedge[now].next=first[x];\n\tfirst[x]=now;\n}\nvoid adde(int x,int y,int z)\n{\n\tadde1(x,y,z);\n\tadde1(y,x,0);\n}\nint S,T;\nint dis[20202];\nqueue <int> q;\nbool bfs()\n{\n\tint p;\n\tmemset(dis,-1,sizeof(dis));\n\tdis[S]=0;\n\tq.push(S);\n\twhile(!q.empty())\n\t{\n\t\tp=q.front();\n\t\tq.pop();\n\t\tfor(int e=first[p];e;e=edge[e].next)\n\t\t\tif(edge[e].f&&dis[edge[e].to]==-1)\n\t\t\t{\n\t\t\t\tdis[edge[e].to]=dis[p]+1;\n\t\t\t\tq.push(edge[e].to);\n\t\t\t}\n\t}\n\tfor(int i=S;i<=T;i++)\n\t\tfirstn[i]=first[i];\n\treturn dis[T]!=-1;\n}\nint dfs(int p,int mi)\n{\n\tif(p==T||mi==0)\n\t\treturn mi;\n\tint ret=0,k;\n\tfor(int &e=firstn[p];e;e=edge[e].next)\n\t\tif(edge[e].f&&dis[p]+1==dis[edge[e].to])\n\t\t{\n\t\t\tk=dfs(edge[e].to,min(mi,edge[e].f));\n\t\t\tret+=k;\n\t\t\tmi-=k;\n\t\t\tedge[e].f-=k;\n\t\t\tedge[e^1].f+=k;\n\t\t\tif(mi==0)\n\t\t\t\tbreak;\n\t\t}\n\treturn ret;\n}\nint num[111][111][2],nn;\nint hx[4]={-1,0,0,1};\nint hy[4]={0,-1,1,0};\nchar s[111][111];\nint main()\n{\n\tint h,w,ans=0;\n\tscanf(\"%d%d\",&h,&w);\n\tmemset(num,0,sizeof(num));\n\tfor(int i=1;i<=h;i++)\n\t\tscanf(\"%s\",s[i]+1);\n\tS=0;\n\tmemset(first,0,sizeof(first));\n\tnow=1;\n\tfor(int i=1;i<=h;i++)\n\t\tfor(int j=1;j<=w;j++)\n\t\t{\n\t\t\tnum[i][j][0]=++nn;\n\t\t\tif(s[i][j]=='.')\n\t\t\t{\n\t\t\t\tnum[i][j][1]=++nn;\n\t\t\t\tadde(num[i][j][0],num[i][j][1],1);\n\t\t\t}\n\t\t}\n\tT=++nn;\n\tfor(int i=1;i<=h;i++)\n\t\tfor(int j=1;j<=w;j++)\n\t\t\tif(s[i][j]=='.')\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\tif(num[i+hx[k]][j+hy[k]][0])\n\t\t\t\t\t\tadde(num[i][j][1],num[i+hx[k]][j+hy[k]][0],oo);\n\tfor(int i=1;i<=h;i++)\n\t\tfor(int j=1;j<=w;j++)\n\t\t\tif(s[i][j]=='X')\n\t\t\t\tadde(num[i][j][0],T,oo);\n\tfor(int i=1;i<=h;i++)\n\t\tif(s[i][1]=='X'||s[i][w]=='X')\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tadde(S,num[i][1][0],oo);\n\t\t\tadde(S,num[i][w][0],oo);\n\t\t}\n\tfor(int j=1;j<=w;j++)\n\t\tif(s[1][j]=='X'||s[h][j]=='X')\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tadde(S,num[1][j][0],oo);\n\t\t\tadde(S,num[h][j][0],oo);\n\t\t}\n\twhile(bfs())\n\t\tans+=dfs(S,oo);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define be(v) (v).begin(),(v).end()\n#define pb(q) push_back(q)\ntypedef long long ll;\nusing namespace std;\nconst ll mod=1000000007, INF=mod*mod*3LL;\n#define doublecout(a) cout<<fixed<<setprecision(10)<<a<<endl;\ntemplate<class FLOWTYPE> struct Edge {\n    int rev, from, to;\n    FLOWTYPE cap, icap;\n    Edge(int r, int f, int t, FLOWTYPE c) : rev(r), from(f), to(t), cap(c), icap(c) {}\n    friend ostream& operator << (ostream& s, const Edge& E) {\n        if (E.cap > 0) return s << E.from << \"->\" << E.to << '(' << E.cap << ')';\n        else return s;\n    }\n};\n\n// graph class (for network-flow)\ntemplate<class FLOWTYPE> struct Graph {\n    vector<vector<Edge<FLOWTYPE> > > list;\n    \n    Graph(int n = 0) : list(n) { }\n    void init(int n = 0) { list.clear(); list.resize(n); }\n    void reset() { for (int i = 0; i < (int)list.size(); ++i) for (int j = 0; j < list[i].size(); ++j) list[i][j].cap = list[i][j].icap; }\n    inline vector<Edge<FLOWTYPE> >& operator [] (int i) { return list[i]; }\n    inline const size_t size() const { return list.size(); }\n    \n    inline Edge<FLOWTYPE> &redge(Edge<FLOWTYPE> e) {\n        if (e.from != e.to) return list[e.to][e.rev];\n        else return list[e.to][e.rev + 1];\n    }\n    \n    void addedge(int from, int to, FLOWTYPE cap) {\n        list[from].push_back(Edge<FLOWTYPE>((int)list[to].size(), from, to, cap));\n        list[to].push_back(Edge<FLOWTYPE>((int)list[from].size() - 1, to, from, 0));\n    }\n    \n    void add_undirected_edge(int from, int to, FLOWTYPE cap) {\n        list[from].push_back(Edge<FLOWTYPE>((int)list[to].size(), from, to, cap));\n        list[to].push_back(Edge<FLOWTYPE>((int)list[from].size() - 1, to, from, cap));\n    }\n\n    /* \n    // debug\n    friend ostream& operator << (ostream& s, const Graph& G) {\n        s << endl; for (int i = 0; i < G.size(); ++i) { s << i << \" : \" << G.list[i] << endl; }return s;\n    }\n    */\n};\n\ntemplate<class FLOWTYPE> struct Dinic {\n    const FLOWTYPE INF = 1<<30; // to be set\n    vector<int> level, iter;\n\n    Dinic() { }\n    void dibfs(Graph<FLOWTYPE> &G, int s) {\n        level.assign((int)G.size(), -1);\n        level[s] = 0;\n        queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            for (int i = 0; i < G[v].size(); ++i) {\n                Edge<FLOWTYPE> &e = G[v][i];\n                if (level[e.to] < 0 && e.cap > 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n    \n    FLOWTYPE didfs(Graph<FLOWTYPE> &G, int v, int t, FLOWTYPE f) {\n        if (v == t) return f;\n        for (int &i = iter[v]; i < G[v].size(); ++i) {\n            Edge<FLOWTYPE> &e = G[v][i], &re = G.redge(e);\n            if (level[v] < level[e.to] && e.cap > 0) {\n                FLOWTYPE d = didfs(G, e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    re.cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    \n    FLOWTYPE solve(Graph<FLOWTYPE> &G, int s, int t) {\n        level.assign((int)G.size(), -1); iter.assign((int)G.size(), 0);\n        FLOWTYPE res = 0;\n        while (true) {\n            dibfs(G, s);\n            if (level[t] < 0) return res;\n            for (int i = 0; i < (int)iter.size(); ++i) iter[i] = 0;\n            FLOWTYPE flow = 0;\n            while ((flow = didfs(G, s, t, INF)) > 0) {\n                res += flow;\n            }\n        }\n    }\n};\n\n\n\nint main() {\n    cin.tie(0);\n    cout.tie(0);\n    ios::sync_with_stdio(false);\n    int h,w; \n    cin >> h >> w;\n    string s[h];\n    int a=h*w,b=a+1,inf=10000;\n    Graph<int> G(h*w+100);//i*w+j;\n    bool ok=true;\n    for(int i=0;i<h;i++){\n    \tcin >> s[i];\n    \tfor(int j=0;j<w;j++){\n    \t\tif(s[i][j] == 'X'){\n    \t\t\tif(j==0||j==w-1||i==0||i==h-1)ok=false;\n    \t\t\telse G.addedge(a,i*w+j,inf);\n    \t\t}\n    \t}\n    }\n    if(!ok){\n    \tcout << -1 << endl;\n    \treturn 0;\n    }\n    for(int i=0;i<h;i++){\n    \tG.addedge(i*w,b,inf);\n    \tG.addedge(i*w+w-1,b,inf);\n    }\n    for(int i=1;i<w-1;i++){\n    \tG.addedge(i,b,inf);\n    \tG.addedge((h-1)*w+i,b,inf);\n    }\n    for(int i=1;i<h;i++){\n    \tfor(int j=0;j<w;j++){\n    \t\tG.addedge((i-1)*w+j,i*w+j,1);\n    \t\tG.addedge(i*w+j,(i-1)*w+j,1);\n    \t}\n    }\n    for(int i=0;i<h;i++){\n    \tfor(int j=1;j<w;j++){\n    \t\tG.addedge(i*w+j,i*w+j-1,1);\n    \t\tG.addedge(i*w+j-1,i*w+j,1);\n    \t}\n    }\n\n    Dinic<int> di;\n    cout << di.solve(G,a,b) <<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 10000;\n\nclass MaxFlow {\n\tstruct edge {\n\t\tint to, cap, rev;\n\t\tedge(int to_, int cap_, int rev_) : to(to_), cap(cap_), rev(rev_) {};\n\t};\n\n\tint V;\n\tvector<vector<edge>> G;\n\tvector<int> level;\n\tvector<int> iter;\n\n\tvoid BFS(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (size_t i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint DFS(int v, int t, int f) {\n\t\tif (v == t) return f;\n\t\tfor (int &i = iter[v]; i < (int)G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = DFS(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\npublic:\n\tMaxFlow(int _V) : V(_V), G(_V), level(_V), iter(_V) {}\n\tvoid add(int from, int to, int cap) {\n\t\tG[from].push_back(edge(to, cap, G[to].size()));\n\t\tG[to].push_back(edge(from, 0, G[from].size() - 1));\n\t}\n\tint Dinic(int s, int t) {\n\t\tint flow = 0;\n\t\twhile (true) {\n\t\t\tBFS(s);\n\t\t\tif (level[t] < 0) return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = DFS(s, t, INF)) > 0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\n\nint main()\n{\n\tint H, W;\n\tcin >> H >> W;\n\tvector<string> v(H);\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> v[i];\n\t}\n\tMaxFlow mf(H * W * 2 + 2);\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n\t\t\t\tmf.add(H * W * 2, i * W + j, INF);\n\t\t\t}\n\t\t\tmf.add(i * W + j, H * W + i * W + j, 1);\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tint tx = i + dx[k], ty = j + dy[k];\n\t\t\t\tif (0 <= tx && tx < H && 0 <= ty && ty < W) {\n\t\t\t\t\tmf.add(H * W + i * W + j, tx * W + ty, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (v[i][j] == 'X') mf.add(i * W + j, H * W * 2 + 1, INF);\n\t\t}\n\t}\n\tint res = mf.Dinic(H * W * 2, H * W * 2 + 1);\n\tcout << (res == INF ? -1 : res) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){\n  int h,w;\n  cin>>h>>w;\n  w+=2;h+=2;\n  vector<string> s(h);\n  s[0]=s[h-1]=string(w,'.');\n  for(int i=1;i<h-1;i++){\n    cin>>s[i];\n    s[i]=\".\"+s[i]+\".\";\n  }\n  int ans=0;\n  int dy[]={0,0,1,-1};\n  int dx[]={1,-1,0,0};\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(s[i][j]!='X') continue;\n      if(i==1||i==h||j==1||j==w){\n\tcout<<-1<<endl;\n\treturn 0;\n      }\n      for(int k=0;k<4;k++)\n\tif(s[i+dy[k]][j+dx[k]]=='.')\n\t  s[i+dy[k]][j+dx[k]]='#',ans++;      \n    }\n  }\n  //cout<<ans<<endl;\n  //for(int i=0;i<h;i++) cout<<s[i]<<endl;\n\n  auto in=[&](int y,int x){return 0<=y&&y<h&&0<=x&&x<w;};\n  ans=0;\n  vector<vector<int> > dp(h,vector<int>(w,0));\n  using P = pair<int, int>;\n  for(int i=0;i<2;i++){\n    for(int j=0;j<2;j++){\n      int y=(h-1)*i,x=(w-1)*j;\n      if(dp[y][x]) continue;\n      queue<P> q;\n      dp[y][x]=1;\n      q.emplace(y,x);\n      while(!q.empty()){\n\ttie(y,x)=q.front();q.pop();\n\tif(s[y][x]=='#'){\n\t  ans++;\n\t  continue;\n\t}\n\tfor(int k=0;k<4;k++){\n\t  int ny=y+dy[k],nx=x+dx[k];\n\t  if(!in(ny,nx)||dp[ny][nx]) continue;\n\t  dp[ny][nx]=1;\n\t  q.emplace(ny,nx);\n\t}\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<unordered_set>\n#include<vector>\n#include<array>\n#include<string>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n#include<functional>\n#include<random>\n#include<complex>\n//#include<boost/multiprecision/cpp_int.hpp>\n#define int int64_t\n#define REP(i, a, b) for (int64_t i = (int64_t)(a); i < (int64_t)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (auto x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define Min(x) *min_element(ALL(x))\n#define Max(x) *max_element(ALL(x))\n#define Unique(L) (L.erase(unique(ALL(L)), L.end()))\nusing namespace std;\n//typedef boost::multiprecision::cpp_int bigint;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\ntemplate <class Flow>class MaxFlow {\nprivate:\n\n\tstruct Edge {\n\t\tint to;\n\t\tFlow cap;\n\t\tint rev;\n\t\tEdge(int to, Flow cap, int rev) : to(to), cap(cap), rev(rev) {}\n\t};\n\n\tFlow INF;\n\tFlow EPS;\n\tint size;\n\tvector<int>level;\n\tvector<int>iter;\n\tvector<int>que;\n\tvector<vector<Edge>>graph;\npublic:\n\n\tMaxFlow(const int n, Flow eps = 0, Flow inf = 1e9) :\n\t\tlevel(n), iter(n), que(n), size(n), graph(n), EPS(eps), INF(inf) {}\n\n\tvoid add_edge(const int from, const int to, const Flow cap) {\n\t\tgraph[from].push_back(Edge(to, cap, graph[to].size()));\n\t\tgraph[to].push_back(Edge(from, 0, graph[from].size() - 1));\n\t}\n\n\tvoid add_undirected_edge(const int from, const int to, const Flow cap) {\n\t\tgraph[from].push_back(Edge(to, cap, graph[to].size()));\n\t\tgraph[to].push_back(Edge(from, cap, graph[from].size() - 1));\n\t}\n\n\tFlow max_flow(const int source, const int sink) {\n\t\tFlow flow = 0;\n\n\t\twhile (1) {\n\t\t\tbfs(source, sink);\n\n\t\t\tif (level[sink] == -1) return flow;\n\n\t\t\tfor (int i = 0; i < size; i++) iter[i] = 0;\n\n\t\t\tflow += dfs(source, sink, INF);\n\t\t}\n\t}\n\nprivate:\n\n\tvoid bfs(const int from, const int to) {\n\t\tint qs = 0, qt = 0;\n\n\t\tfor (int i = 0; i < size; i++) level[i] = -1;\n\n\t\tlevel[from] = 0;\n\t\tque[qt++] = from;\n\n\t\twhile (qs < qt && level[to] == -1) {\n\t\t\tint now = que[qs++];\n\n\t\t\tfor (int i = 0; i < graph[now].size(); i++) {\n\t\t\t\tint next = graph[now][i].to;\n\n\t\t\t\tif (graph[now][i].cap > EPS && level[next] == -1) {\n\t\t\t\t\tlevel[next] = level[now] + 1;\n\t\t\t\t\tque[qt++] = next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tFlow dfs(const int from, const int to, const Flow cap) {\n\t\tFlow flow = 0;\n\n\t\tif (from == to || cap <= EPS) return cap;\n\n\t\tfor (int &i = iter[to]; i < graph[to].size(); i++) {\n\t\t\tint next = graph[to][i].to;\n\t\t\tEdge &edge = graph[next][graph[to][i].rev];\n\t\t\tFlow res;\n\n\t\t\tif (edge.cap <= EPS || level[next] >= level[to]) continue;\n\n\t\t\tres = dfs(from, next, min(cap - flow, edge.cap));\n\n\t\t\tif (res <= EPS) continue;\n\n\t\t\tedge.cap -= res;\n\t\t\tgraph[to][i].cap += res;\n\t\t\tflow += res;\n\n\t\t\tif (abs(flow - cap) <= EPS) break;\n\t\t}\n\n\t\treturn flow;\n\t}\n};\n\nsigned main(void) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint H, W;\n\tcin >> H >> W;\n\tMaxFlow<int>g(H * W * 2 + 2);\n\tconst int source = H * W * 2, sink = source + 1;\n\tconst int D[5] = { 0,1,0,-1,0 };\n\tconst int INF = 99999999;\n\n\t//柵は辺を塞ぐのではなくマス目を塞ぐ。最小カット問題に落とし込むために、\n\t//グリッドを仮想的に表と裏の2つ用意する。\n\t//(1)ソース→ヤギのいる表座標、\n\t//(2)任意の表座標→その4近傍の裏座標、\n\t//(3)端っこの表座標→シンク\n\t//の3要素をキャパ無限でつなぎ、\n\t//(4)任意の裏座標→表の同じ座標 をキャパ1でつなぐ。\n\t//裏から表へのパスをカットすることが\"柵を置く\"ことに等しい。\n\trep(i, H) {\n\t\tstring S;\n\t\tcin >> S;\n\t\trep(j, W) {\n\t\t\tconst int pos = i * W + j;\n\t\t\tif (S[j] == 'X') {\n\t\t\t\tif (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tg.add_edge(source, pos, INF);//(1)\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n\t\t\t\t\tg.add_edge(pos, sink, INF);//(3)\n\t\t\t\t}\n\t\t\t}\n\t\t\tg.add_edge(pos + H * W, pos, 1);//(4)\n\t\t\trep(k, 4) {\n\t\t\t\tconst int di = i + D[k];\n\t\t\t\tconst int dj = j + D[k + 1];\n\t\t\t\tif (!(0 <= di && di < H && 0 <= dj && dj < W))continue;\n\t\t\t\tg.add_edge(pos, di * W + dj + H * W, INF);//(2)\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << g.max_flow(source, sink) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<ut,VI> PQ;\nconst ut INF=1LL<<30;\nconst int SIZE=201;\nint maps[SIZE][SIZE];\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\ncli d[4];\nint solve(){\n\tREP(i,4) d[i]=cli(dy[i],dx[i]);\n\tint H,W;\n\tcin >> H >> W;\n\tqueue<cli> qu;\n\tREP(i,H){\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,W){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(maps[i][j]) qu.push(cli(j,i));\n\t\t}\n\t}\n\n\twhile(!qu.empty()){\n\t\tcli now=qu.front();\n\t\tqu.pop();\n\t\tif(maps[now.imag()][now.real()]==1){\n\t\t\t\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) return -1;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]==0){\n\t\t\t\t\tmaps[next.imag()][next.real()]=-1;\n\t\t\t\t\tqu.push(next);\n\t\t\t\t}\n\t\t\t//\tcout << next << endl;\n\t\t\t}\n\t\t}\n\t\telse if(maps[now.imag()][now.real()]==-1){\n\t\t\tint around=0;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) continue;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=0) around++;\n\t\t\t\telse qu.push(next);\n\t\t\t}\n\t\t\tif(around>=3){\n\t\t\t\tmaps[now.imag()][now.real()]=1;\n\t\t\t\tqu.push(now);\n\t\t\t}\n\t\t} \n\t\telse if(maps[now.imag()][now.real()]==0){\n\t\t\tint around=0;\n\t\t\tif(now.imag()==0 or now.real()==0 or now.imag()==H-1 or now.real()==W-1) continue;\n\t\t\tREP(i,4){\n\t\t\t\tcli next=now+d[i];\n\t\t\t\tif(maps[next.imag()][next.real()]!=0) around++;\n\t\t\t}\n\t\t\tif(around>=4){\n\t\t\t\tmaps[now.imag()][now.real()]=1;\n\t\t\t\tqu.push(now);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tint ans=0;\n\tREP(i,H)\n\t\tREP(j,W){\n\t\t\tans+=maps[i][j]==-1;\n\t\t}\n\treturn ans;\n}\nint main(){\n\tcout << solve() << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105];\nbool fr[105][105],vis[105][105],st,ad,f;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = f = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,2){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==2){\n\t\t\t\t\tad = f = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J], f = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i,l,r) for(int i=(int)(l);i<(int)(r);i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)x.size())\ntemplate<class T>bool chmax(T &a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,T b){if(a>b){a=b;return 1;}return 0;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\n/*{\n  }*/\n\nconst int inf = 1LL<<60;\n\nstruct edge{\n  int to, rev, cap;\n  edge(int t, int r, int c) : to(t), rev(r), cap(c){}\n};\n\nvector<edge> es[30010];\nbool vis[30010];\n\nvoid add_edge(int from, int to, int cap, int rcap=0){\n  es[from].emplace_back(to, sz(es[to]), cap);\n  es[to].emplace_back(from, sz(es[from])-1, rcap);\n}\n\nint dfs(int v, int t, int f){\n  if(v == t) return f;\n  vis[v] = true;\n  for(auto &e : es[v]){\n    if(vis[e.to] or e.cap <= 0) continue;\n    int d = dfs(e.to, t, min(f, e.cap));\n    if(d > 0){\n      e.cap -= d;\n      es[e.to][e.rev].cap += d;\n      return d;\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t){\n  int flow = 0;\n  while(1){\n    memset(vis, false, sizeof(vis));\n    int f = dfs(s, t, inf);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\nsigned main(){\n  int H, W;\n  cin >> H >> W;\n  string s[H];\n  rep(i, 0, H) cin >> s[i];\n\n  rep(y, 0, H) if(s[y][0] == 'X' or s[y][W-1] == 'X'){\n    cout << -1 << endl;\n    return 0;\n  }\n\n  rep(x, 0, W) if(s[0][x] == 'X' or s[H-1][x] == 'X'){\n    cout << -1 << endl;\n    return 0;\n  }\n\n  int S = 0, T = 1;\n  rep(y, 0, H) rep(x, 0, W){\n    if(s[y][x] == 'X'){\n      add_edge(y*W+x+10000, y*W+x+20000, inf);\n      add_edge(S, y*W+x+20000, inf);\n    }else add_edge(y*W+x+10000, y*W+x+20000, 1);\n    if(y == 0 or y == H-1 or x == 0 or x == W-1) add_edge(y*W+x+20000, T, inf);\n    if(y) add_edge(y*W+x+20000, (y-1)*W+x+10000, inf);\n    if(x) add_edge(y*W+x+20000, y*W+(x-1)+10000, inf);\n    if(y < H-1) add_edge(y*W+x+20000, (y+1)*W+x+10000, inf);\n    if(x < W-1) add_edge(y*W+x+20000, y*W+(x+1)+10000, inf);\n  }\n\n  int ans = max_flow(S, T);\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&b) { if (a > b)a = b; }\ntemplate<class T> void cmax(T &a, const T&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\numap<ti3, ll> memo;\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//速度ではなくメモリ効率を考えるならrankのかわりにsizeを使う\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\nint main() {\n\tvi d = { 0,1,0,-1,0 };\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> s(h);\n\trep(i, h)cin >> s[i];\n\tbool err = 0;\n\tfor (auto a : s.front())if (a == 'X')err = 1;\n\tfor (auto a : s.back())if (a == 'X')err = 1;\n\tfor (auto &a : s) {\n\t\tif (a.back() == 'X' || a.front() == 'X')err = 1;\n\t}\n\tif (err) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tbool up = 1;\n\twhile (up) {\n\t\tup = 0;\n\t\trep1(i, h - 2)rep1(j, w - 2) {\n\t\t\tif (s[i][j] != 'X') {\n\t\t\t\tint cnt = 0;\n\t\t\t\trep(k, 4)if (s[i + d[k]][j + d[k+1]] != '.' )cnt++;\n\t\t\t\tif (cnt >= 3) {\n\t\t\t\t\tup = 1;\n\t\t\t\t\ts[i][j] = 'X';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[i][j] == 'X') {\n\t\t\t\trep(k, 4)if (s[i + d[k]][j + d[k+1]] == '.') {\n\t\t\t\t\ts[i + d[k]][j + d[k+1]] = '#';\n\t\t\t\t\tup = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0;\n\trep(i, h)rep(j, w)if (s[i][j] == '#')cnt++;\n\tcout << cnt << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 23456\n#define INF (1<<29)\n\nstruct edge {\n    int to, cap, rev;\n    edge (int to, int cap, int rev) :\n        to(to), cap(cap), rev(rev) {}\n};\n\nvector<edge> G[MAX_V];\nint level[MAX_V], iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap)\n{\n    G[from].push_back(edge(to, cap, G[to].size()));\n    G[to].push_back(edge(from, 0, G[from].size()-1));\n}\n\nvoid bfs(int s)\n{\n    memset(level, -1, sizeof(level));\n    queue<int> Q;\n    level[s] = 0;\n    Q.push(s);\n    while (!Q.empty()) {\n\tint v = Q.front(); Q.pop();\n\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t    edge &e = G[v][i];\n\t    if (e.cap > 0 && level[e.to] < 0) {\n\t\tlevel[e.to] = level[v] + 1;\n\t\tQ.push(e.to);\n\t    }\n\t}\n    }\n}\n\nint dfs(int v, int t, int f)\n{\n    if (v == t) return f;\n    for (int &i = iter[v]; i < (int)G[v].size(); i++) {\n\tedge &e = G[v][i];\n\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t    int d = dfs(e.to, t, min(f, e.cap));\n\t    if (d > 0) {\n\t\te.cap -= d;\n\t\tG[e.to][e.rev].cap += d;\n\t\treturn d;\n\t    }\n\t}\n    }\n    return 0;\n}\n\nint max_flow(int s, int t)\n{\n    int flow = 0;\n    for (;;) {\n\tbfs(s);\n\tif (level[t] < 0) return flow;\n\tmemset(iter, 0, sizeof(iter));\n\tint f;\n\twhile ((f = dfs(s, t, INF)) > 0) {\n\t    flow += f;\n\t}\n    }\n}\n\nbool is_outside(int x, int y, int W, int H)\n{\n    return (x == 0 || x == W - 1 || y == 0 || y == H - 1);\n}\n\nint solve(int H, int W,\n          vector<vector<char>> &S)\n{\n    int src = 2 * H * W, sink = src + 1;\n    const int di[] = {-1, +0, +1, +0};\n    const int dj[] = {+0, -1, +0, +1};\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int u = i * W + j, v = H * W + u;\n            \n            if (S[i][j] == 'X') {\n                if (is_outside(j, i, W, H)) {\n                    return -1;\n                }\n                add_edge(src, u, INF);\n                add_edge(u, v, INF);\n            } else {\n                add_edge(u, v, 1);\n            }\n\n            if (is_outside(j, i, W, H)) {\n                add_edge(v, sink, INF);                \n            }\n            \n            for (int k = 0; k < 4; k++) {\n                int ni = i + di[k];\n                int nj = j + dj[k];\n                if (0 <= ni && ni < H && 0 <= nj && nj < W) {\n                    add_edge(v, ni * W + nj, INF);\n                }\n            }\n        }\n    }\n    return max_flow(src, sink);\n}\n\nint main()\n{\n    int H, W;\n    cin >> H >> W;\n    vector<vector<char>> S(H, vector<char>(W));\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> S[i][j];\n        }\n    }\n    cout << solve(H, W, S) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//諸機能\n#pragma region MACRO \n#define putans(x)  std::cerr << \"answer: \" ; cout << (x) << endl\n#define dputans(x) std::cerr << \"answer: \"; cout << setprecision(13) << (double)(x) << endl\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define RREP(i,a,n) for(int i=(int)(n-1); i>= a; i--)\n#define rep(i,n) REP(i,0,n)\n#define rrep(i,n) RREP(i,0,n)\n#define all(a) begin((a)),end((a))\n#define mp make_pair\n#define exist(container, n) ((container).find((n)) != (container).end())\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#ifdef _DEBUG //ファイルからテストデータを読み込む\nstd::ifstream ifs(\"data.txt\");\n#define put ifs >>\n#else //ジャッジシステムでいい感じにやる\n#define put cin >>\n#endif\n#pragma endregion\n\n//デバッグなどの支援\n#pragma region CODING_SUPPORT\n#define dbg(var0) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << endl; }\n#define dbg2(var0, var1) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg(var1); }\n#define dbg3(var0, var1, var2) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg2(var1, var2); }\n#define dbgArray(a,n) {std::cerr << (#a) << \"=\";  rep(i,n){std::cerr <<(a[i])<<\",\";} cerr<<endl;} \n#ifndef _DEBUG\n#define dbg1 {}\n#define dbg2 {}\n#define dbg3 {}\n#define dbgArray {}\n#endif \n#pragma endregion \n//typedef（書き換える、書き足す可能性ある）\n#pragma region TYPE_DEF\ntypedef long long ll;\ntypedef pair<int, int> pii; typedef pair<string, string> pss; typedef pair<int, string>pis;\ntypedef vector<string> vs; typedef vector<int> vi;\n#pragma endregion\n//諸々の定数(書き換える可能性ある)\n#pragma region CONST_VAL\n#define PI (2*acos(0.0))\n#define EPS (1e-10)\n#define MOD (ll)(1e9 + 7)\n#define INF (ll)(1e9)\n#pragma endregion\n\nclass Point {//幾何上のべクトル\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(x * a, y * a); }\n\tdouble operator * (Point p) { return dot(p); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n\n\tbool operator < (const Point &p) const { return  x != p.x ? x < p.x : y < p.y; }\n\tbool operator == (const Point &p) const { return  fabs(x - p.x) < EPS && fabs(y - p.y) < EPS; }\n\t//内積、外積\n\tdouble dot(Point p) { return x * p.x + y * p.y; }\n\tdouble cross(Point p) { return x * p.y - y * p.x; }\n\n\n};\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\nstruct Segment {//線分\n\tPoint p1, p2;\n};\n\ntypedef Point Vector;\ntypedef Segment Line;//直線\ntypedef vector<Point> Polygon;\n\ndouble v_norm(Point p) { return p.x * p.x + p.y * p.y; }\ndouble abs(Point p) { return v_norm(p); }\ndouble dot(Point p, Point q) { return p.x * q.x + p.y * q.y; }\ndouble cross(Point p, Point q) { return p.x * q.y - p.y * q.x; }\n\n\n\n\n\n//直行、並行\nbool isOrthogonal(Vector a, Vector b) { return equals(a*b, 0.0); }\nbool isParallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\n\n//線分sに対する点pの射影\nPoint projection(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(( p - s.p1 ), base) / v_norm(base);\n\treturn s.p1 + base*r;\n}\n//線分sに対する点pの反射\nPoint reflection(Segment s, Point p) { return p + ( projection(s, p) - p ) * 2; }\n\n\n\n\n//double getDistance(Point a, Point b) { return ( a - b ).abs; }\n//double getDistanceLP(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1)); }\n//double getDistanceSP(Segment s, Point p) {\n//\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n//\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n//}\n\n//double getDistance(Segment s1, Segment s2) {\n//\tif (intersect(s1, s2)) return 0;\n//\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2))\n//\t         , min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2));\n//}\n\n//p1-p0を基準として p2-p0 の2ベクトルについて\nstatic const int COUNTER_CLOCKWISE = 1;//反時計回り\nstatic const int CLOCKWISE = -1;//時計回り\nstatic const int ONLINE_BACK = 2;//同一直線状p2,p0,p1の順\nstatic const int ONLINE_FRONT = -2;//同一直線上p0,p1,p2の順\nstatic const int ON_SEGMENT = 0;//p2がp0,p1上にある場合\nint ccw(Point p0, Point p1, Point p2) {//上記の分類関数\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n////線分p1p2とp3p4の交差判定\n//bool intersect(Point p1, Point p2, Point p3, Point p4) {return ( (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0) && (ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0));}\n//bool intersect(Segment s1, Segment s2) {return intersect(s1.p1 , s1.p1, s2.p1, s2.p2);}\n//\n//Point getCrossPoint(Segment s1, Segment s2) {\n//\tVector base = s2.p2 - s2.p1;\n//\tdouble d1 = abs(cross(base , s1.p1 - s2.p1));\n//\tdouble d2 = abs(cross(base , s1.p2 - s2.p1));\n//\tdouble t = d1 / ( d1 + d2 );\n//\treturn s1.p1 + (s1.p2 - s1.p1 ) * t;\n//}\n//\n////直線と円の交点を調べる\n//pair<Point, Point> getCrossPoints(Circle c, Line l) {\n//\t//assert(intersect(c, i)); 交差しない場合についてのはず\n//\tVector pr = projection(c, l);\n//\tVector e = ( l.p2 - l.p1 ) / abs(l.p2 - l.p1);\n//\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n//\treturn mp(pr + e * base, pr - e * base);\n//}\n//\n////点の内包を調べる\n//static const int IN_POLYGON = 2;//多角形の内部\n//static const int OUT_POLYGON = 1;//多角形の外部\n//static const int ON_POLYGON = 0;//多角形の線分上\n//int contains(Polygon g, Point p) {\n//\tint n = g.size();\n//\tbool x = false;\n//\trep(i, n) {\n//\t\tPoint a = g[i] - p, b = g[( i + 1 ) % n] - p;\n//\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return OUT_POLYGON;\n//\t\tif (a.y > b.y) swap(a, b);\n//\t\tif (a.y < EPS && EPS < b.y && cross(a, b)) x = !x;\n//\t}\n//\treturn ( x ? IN_POLYGON : ON_POLYGON );\n//}\n\n//凸包\nPolygon ConvexHull(Polygon s) {\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tsort(s.begin(), s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\n\tfor (int i = 2; i < s.size(); i++) {\n\t\tfor (int n = u.size(); ( n >= 2 ) && ( ccw(u[n - 2], u[n - 1], s[i]) == COUNTER_CLOCKWISE ); n--) {\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\n\tfor (int i = s.size() - 3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) == COUNTER_CLOCKWISE; n--)l.pop_back();\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\n/*\n#define i(x) int x; scanf(\"%d\",&x);\n#define l(x) ll x; scanf(\"%lld\",&x);\n#define d(x) double  x; scanf(\"%lf\",&x);\n*/\n//今度実装がんばる\n//https://www23.atwiki.jp/akitaicpc/pages/65.html\n\n\nint main() {\n\t/*double xp1, yp1, xp2, yp2; put xp1 >> yp1 >> xp2 >> yp2;\n\tSegment s;\n\ts.p1 = Point(xp1, yp1);\n\ts.p2 = Point(xp2, yp2);\n\n\tint n; put n;\n\trep(i, n) {\n\t\tPoint p;\n\t\tput p.x >> p.y;\n\t\tPoint prj =reflection(s, p);\n\t\tcout << setprecision(13) << prj.x << \" \" << prj.y << endl;\n\t}*/\n\n\n\n\t//テンプレート化を来世に考える\n\tauto getI = [&]()->auto { int tmp; put tmp; return tmp; };\n\tauto getLL = [&]()->auto { ll tmp; put tmp; return tmp; };\n\tauto getS = [&]()->auto { string tmp; put tmp; return tmp; };\n\tbool filled[1000][1000];\n\tfill(*filled, *filled + 1000 * 1000, false);\n\tint vx[4] = { 1,0,-1,0 };\n\tint vy[4] = { 0,1,0,-1 };\n\tPolygon sheep;\n\tPolygon convex_sheep;\n\tint num = 0;\n\tint h, w; put h >> w;\n\trep(i, h) {\n\t\tstring s; put s;\n\t\trep(j, s.size()) {\n\t\t\tif (s[j] == 'X') {\n\t\t\t\tif (i == 0 || j == 0 || i == h-1 || j == w-1) {\n\t\t\t\t\tputans(-1);\n\t\t\t\t\tgoto END;\n\t\t\t\t}\n\t\t\t\trep(k, 4) {\n\t\t\t\t\tif (!filled[i + vx[k]][j + vy[k]]) {\n\t\t\t\t\t\tsheep.push_back(Point(i + vx[k],j + vy[k]));\n\t\t\t\t\t\tfilled[i + vx[k]][j + vy[k]] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tconvex_sheep = ConvexHull(sheep);\n\n\trep(i, convex_sheep.size()) {\n\t\tPoint s = convex_sheep[i % convex_sheep.size()];\n\t\tPoint g = convex_sheep[(i + 1) % convex_sheep.size()];\n\t\tint mandist = max(abs(s.x - g.x),abs(s.y - g.y));\n\t\tmax(1.0, abs(s.x - g.x)) + max(1.0, abs(s.y - g.y));\n\t\tnum += mandist;\n\t} \n\tputans(num);\nEND:\n\treturn 0;\n}\n\n//\n//int n, a, b; put n >> a >> b;\n//\tvi t;\n//\trep(i, n) {\n//\t\tt.push_back(get());\n//\t}\n//\tint count = 0;\n//\trep(i, n) {\n//\t\tif (t[i] < a || b <= t[i])count++;\n//\t}\n//\tputans(count);\n\n//\n//\tset<string> list;\n//\tint ans = 0;\n//\tint n; put n;\n//\tint k; put k;\n//\tint numAlphabet[26];\n//\tfill(all(numAlphabet), 0);\n//\trep(i, n) {\n//\t\tstring s; put s;\n//\t\tif (exist(list, s))continue;\n//\t\tlist.insert(s);\n//\t\tnumAlphabet[s[0] - 'A']++;\n//\t}\n//\tsort(all(numAlphabet),greater<int>());\n//\twhile (true) {\n//\t\trep(i, k) {\n//\t\t\tif (numAlphabet[i] == 0) goto END;\n//\t\t\telse numAlphabet[i]--;\n//\t\t}\n//\t\tsort(all(numAlphabet), greater<int>());\n//\t\tans++;\n//\t}\n//END:\n//\tputans(ans);\n\n\n\t//int t; put t;\n\t//rep(i, t) {\n\t//\tint n, d; put n >> d;\n\t//\tif (n == 1) {\n\t//\t\tputans(d);\n\t//\t\tcontinue;\n\t//\t}\n\t//\tputans(n % 2 != 0 ? ( n - 1 ) * 127 + d : ( n - 1 ) * 127 + ( 127 ^ d ));\n\t//}\n\n\n//\n//int n; put n;\n//string s1, s2;\n//string r;\n//string patan1[4] = { \".\",\"#\",\".\",\"#\" };\n//string patan2[4] = { \".\",\".\",\"#\",\"#\" };\n//bool front = true;\n//rep(j, 420 / 4) {\n//\tif (front) {\n//\t\trep(i, 4) {\n//\t\t\tcout << s1 + patan1[i] + \"\\n\" << s2 + patan2[i] << endl;\n//\t\t\tcin >> r;\n//\t\t\tif (r == \"T\") {\n//\t\t\t\ts1 += patan1[i];\n//\t\t\t\ts2 += patan2[i];\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t\tif (r == \"F\" && i == 3) {\n//\t\t\t\tfront = !front;\n//\t\t\t}\n//\t\t\tif (r == \"end\")goto END;\n//\t\t}\n//\t}\n//\telse {\n//\t\trep(i, 4) {\n//\t\t\tcout << patan1[i] + s1 + \"\\n\" << patan2[i] + s2 << endl;\n//\t\t\tcin >> r;\n//\t\t\tif (r == \"T\") {\n//\t\t\t\ts1 = patan1[i] + s1;\n//\t\t\t\ts2 = patan2[i] + s2;\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t\tif (r == \"F\" && i == 3) {\n//\t\t\t\tfront = !front;\n//\t\t\t}\n//\t\t\tif (r == \"end\")goto END;\n//\t\t}\n//\t}\n//\n//}\n//END:\n//cout << endl;\n\n\n////CGL_4_A : Convex Hull;\n\t//int n; put n;\n\t//Polygon p;\n\t//rep(i, n) {\n\t//\tdouble x, y; put x >> y;\n\t//\tp.push_back(Point(x, y));\n\t//}\n\t//Polygon k = ConvexHull(p);\n\t//double tmpMax = 100000000.0;\n\t//int rotIndex = 0;\n\t//rep(i, k.size()) {\n\t//\tif (k[i].y < tmpMax) {\n\t//\t\trotIndex = i;\n\t//\t\ttmpMax = k[i].y;\n\t//\t}\n\t//}\n\t//rotate(k.begin(),k.begin() + rotIndex,k.end());\n\t//cout << k.size() << endl;\n\t//rep(i, k.size()) {\n\t//\tcout << k[i].x << \" \" << k[i].y << endl;\n\t//}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int vy[] = {0, 1, 0, -1}, vx[] = {1, 0, -1, 0};\nconst int INF = 1 << 30;\n\nstruct Dinic\n{\n  struct edge\n  {\n    int to, cap, rev;\n  };\n\n  vector< vector< edge > > graph;\n  vector< int > min_cost, iter;\n\n  Dinic(int n)\n  {\n    graph.resize(n);\n  }\n\n  void add_edge(int from, int to, int cap)\n  {\n    graph[from].push_back((edge) {to, cap, (int) graph[to].size()});\n    graph[to].push_back((edge) {from, 0, (int) graph[from].size() - 1});\n  }\n\n  bool bfs(int s, int t)\n  {\n    min_cost.assign(graph.size(), -1);\n    queue< int > que;\n    min_cost[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int p = que.front();\n      que.pop();\n      for(int i = 0; i < graph[p].size(); i++) {\n        const edge& e = graph[p][i];\n        if(e.cap > 0 && min_cost[e.to] == -1) {\n          min_cost[e.to] = min_cost[p] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n    return (min_cost[t] != -1);\n  }\n\n  int dfs(int idx, const int t, int flow)\n  {\n    if(idx == t) return (flow);\n    for(int& i = iter[idx]; i < graph[idx].size(); i++) {\n      edge& e = graph[idx][i];\n      if(e.cap > 0 && min_cost[idx] < min_cost[e.to]) {\n        int d = dfs(e.to, t, min(flow, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return (d);\n        }\n      }\n    }\n    return (0);\n  }\n\n  int max_flow(int s, int t)\n  {\n    int flow = 0;\n    while(bfs(s, t)) {\n      iter.assign(graph.size(), 0);\n      int f = 0;\n      while((f = dfs(s, t, INF)) > 0) {\n        flow += f;\n      }\n    }\n    return (flow);\n  }\n};\n\nint H, W;\nstring S[100];\n\nbool isover(int y, int x)\n{\n  return (y < 0 || y >= H || x < 0 || x >= W);\n}\n\nint get(int y, int x, bool in = false)\n{\n  if(in) return (H * W + y * W + x);\n  return (y * W + x);\n}\n\nint main()\n{\n  cin >> H >> W;\n  for(int i = 0; i < H; i++) {\n    cin >> S[i];\n  }\n\n  Dinic flow(H * W * 2 + 2);\n\n  for(int i = 0; i < H; i++) {\n    if(S[i][0] == 'X' || S[i][W - 1] == 'X') {\n      cout << -1 << endl;\n      return (0);\n    } else {\n      flow.add_edge(get(i, 0, false), H * W * 2, INF);\n      flow.add_edge(get(i, W - 1, false), H * W * 2, INF);\n    }\n  }\n  for(int i = 0; i < W; i++) {\n    if(S[0][i] == 'X' || S[H - 1][i] == 'X') {\n      cout << -1 << endl;\n      return (0);\n    } else {\n      flow.add_edge(get(0, i, false), H * W * 2, INF);\n      flow.add_edge(get(H - 1, i, false), H * W * 2, INF);\n    }\n  }\n\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      if(S[i][j] == 'X') {\n        flow.add_edge(H * W * 2 + 1, get(i, j, false), INF);\n      }\n    }\n  }\n\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      flow.add_edge(get(i, j, true), get(i, j, false), 1);\n      for(int k = 0; k < 4; k++) {\n        int ni = i + vy[k], nj = j + vx[k];\n        if(isover(ni, nj)) continue;\n        flow.add_edge(get(i, j, false), get(ni, nj, true), INF);\n      }\n    }\n  }\n\n  cout << flow.max_flow(H * W * 2 + 1, H * W * 2) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\n#define INF (1 << 29)\nusing namespace std;\n\nstruct point{\n    int x, y;\n};\n\nchar f[105][105] = {0};\nbool fb[105][105] = {0};\nint h, w;\nstatic const int dy[4] = {0,1,0,-1};\nstatic const int dx[4] = {1,0,-1,0};\n\nbool CanEscape(){\n    rep(i,h) if(f[i][0] == 'X' || f[i][w - 1] == 'X') return 1;\n    rep(i,w) if(f[0][i] == 'X' || f[h - 1][i] == 'X') return 1;\n    return 0;\n}\n\nvoid check(queue<point> &q){\n    rep(i,h){\n        rep(j,w){\n            if(f[i][j] == 'X'){\n                point p;\n                p.y = i; p.x = j;\n                q.push(p);\n                rep(k,4){\n                    int y = i + dy[k];\n                    int x = j + dx[k];\n                    if(y < 0 || y >= h || x < 0 || x >= w) continue;\n                    if(f[y][x] != 'X') fb[y][x] = 1;\n                }\n            }\n        }\n    }\n}\n\nbool goatCanEscape(int y, int x){\n    bool isVisited[105][105] = {0};\n    queue<point> q;\n    point start_coordinate;\n    start_coordinate.x = x;\n    start_coordinate.y = y;\n\n    isVisited[start_coordinate.y][start_coordinate.x] = 1;\n    q.push(start_coordinate);\n\n    point u;\n    while(!q.empty()){\n        u = q.front(); q.pop();\n        rep(i,4){\n            point next;\n            next.x = u.x + dx[i];\n            next.y = u.y + dy[i];\n            if(next.y < 0 || next.y >= h || next.x < 0 || next.x >= w) return 1;\n            if(isVisited[next.y][next.x] == 0 && fb[next.y][next.x] == 0){\n                isVisited[next.y][next.x] = 1;\n                q.push(next);\n            }\n        }\n    }\n    return 0;\n}\n\nbool allGoatNotEscape(int y, int x, queue<point> q){\n    while(not q.empty()){\n        if(goatCanEscape(q.front().y, q.front().x)) return 0;\n        q.pop();\n    }\n    return 1;\n}\n\nvoid deleteUselessFence(queue<point> q){\n    rep(i,h){\n        rep(j,w){\n            if(fb[i][j] == 1 && f[i][j] != 'X'){\n                fb[i][j] = 0;\n                if(not allGoatNotEscape(i, j, q)){\n                    fb[i][j] = 1;\n                }\n            }\n        }\n    }\n}\n\nint countFence(){\n    int cnt = 0;\n    rep(i,h){\n        rep(j,w){\n            if(fb[i][j] == 1) cnt++;\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    cin >> h >> w;\n    rep(i,h) cin >> f[i];\n    if(CanEscape()){\n        cout << -1 << endl;\n    }else{\n        queue<point> q;\n        check(q);\n        deleteUselessFence(q);\n        cout << countFence() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region head\n#include <bits/stdc++.h>\n\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing pi = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate <class T>\nusing vv = vector<vector<T>>;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define repi(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rrepi(i, a, b) for (int i = (int)(b)-1; i >= (int)(a); i--)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define bit(n) (1LL << (n))\ntemplate <class T>\ninline bool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\ninline bool chmin(T &a, const T &b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nconst int INF = 1002003004;\nconst ll LINF = 1002003004005006007ll;\nstruct preprocess {\n    preprocess() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(20);\n    }\n} ____;\n#pragma endregion head\n\n#pragma region library\n#pragma endregion library\nint h, w;\nint coord(int x, int y, bool in) {\n    if (in) {\n        return x * w + y;\n    } else {\n        return h * w + (x * w + y);\n    }\n}\nint main() {\n    cin >> h >> w;\n    vv<char> grid(h, vector<char>(w));\n    rep(i, h) rep(j, w) cin >> grid[i][j];\n    mf_graph<int> g(2 * h * w + 2);\n    int s = 2 * h * w, t = 2 * h * w + 1;\n    bool flag = false;\n    rep(i, h) rep(j, w) {\n        if (i < h - 1) {\n            g.add_edge(coord(i, j, false), coord(i + 1, j, true), INF);\n            g.add_edge(coord(i + 1, j, false), coord(i, j, true), INF);\n        }\n        if (j < w - 1) {\n            g.add_edge(coord(i, j, false), coord(i, j + 1, true), INF);\n            g.add_edge(coord(i, j + 1, false), coord(i, j, true), INF);\n        }\n        if (grid[i][j] == 'X') {\n            g.add_edge(s, coord(i, j, true), INF);\n            g.add_edge(coord(i, j, true), coord(i, j, false), INF);\n        } else {\n            g.add_edge(coord(i, j, true), coord(i, j, false), 1);\n        }\n        if (i == 0 || i == h - 1 || j == 0 || j == w - 1) {\n            g.add_edge(coord(i, j, false), t, INF);\n            if (grid[i][j] == 'X') flag = true;\n        }\n    }\n    if (flag) {\n        cout << -1 << '\\n';\n        return 0;\n    }\n    cout << g.flow(s, t) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include<map>\n#include<algorithm>\n#include<set>\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define req(i,n) for(int i = 1; i<=n;i++)\n#define ALL(a) a.begin(),a.end()\nusing namespace std;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T & val) {\n    std::fill((T*)array, (T*)(array + N), val);\n}\ntypedef long long int ll;\n#define INF 1e9;\nstruct edge {\n    int to, cap, rev;// 行先　容量　逆辺\n};\nvector<edge> g[20500]; bool used[20500];\nvoid add(int u, int v, int f) {\n    g[u].push_back(edge{ v,f,(int)g[v].size() });\n    g[v].push_back(edge{ u,0,(int)g[u].size() - 1 });\n}\nint dfs(int pos, int to, int f) {\n    if (pos == to) return f;\n    used[pos] = 1;\n    rep(i, g[pos].size()) {\n        if (g[pos][i].cap == 0 || used[g[pos][i].to]) continue;\n        int D = dfs(g[pos][i].to, to, min(g[pos][i].cap, f));\n        if (D >= 1) {\n            g[pos][i].cap -= D;\n            g[g[pos][i].to][g[pos][i].rev].cap += D;\n            return D;\n        }\n    }return 0;\n}\nint max_flow(int s, int t) {\n    int F = 0; for (;;) {\n        fill(used, used + 1001, 0);\n        int F2 = dfs(s, t, (1e9));\n        F += F2;\n        if (F2 == 0) return F;\n    }return INF;\n}\nint dx[4] = { 0,0,1,-1 }, dy[4] = { 1,-1,0,0 };\nint main() {\n    int h, w; cin >> h >> w;\n    int s = h * w * 2, t = h * w * 2 + 1;\n    vector<vector<char>> c(h, vector<char>(w));\n    rep(i, h) {\n        rep(j, w) cin >> c[i][j];\n    }\n    rep(i, h) {\n        rep(j, w) {\n            int x = i * w + j, y = x + h * w;\n            if (c[i][j] == 'X') {\n                if (i == 0 || j == 0 || i == h - 1 || j == w - 1) {\n                    cout << -1 << endl;\n                    return 0;\n                }\n                add(s, x, 1e9); add(x, y, 1e9);\n            }\n            else add(x, y, 1);\n            if (i == 0 || i == h - 1 || j == 0 || j == w - 1) add(y, t, 1e9);\n            rep(k, 4) {\n                int nx = dx[k] + i, ny = dy[k] + j;\n                if (nx < 0 || ny < 0 || ny >= w || nx >= h)continue;\n                add(y, nx * w + ny, 1e9);\n            }\n        }\n    }cout << max_flow(s, t) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp,mn;\nchar x[105][105],y[105][105],z[105][105],opt[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tz[i][j] = x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tmn = ans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,a+1,n)if(x[o][b]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,a+1,n){\n\t\t\t\t\t\t\tif(x[o][b]=='#')break;\n\t\t\t\t\t\t\tx[o][b] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(tmp<mn){\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\tmn = tmp;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)opt[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t\tif(st){\n\t\t\tans = mn;\n\t\t\trep(i,1,n)rep(j,1,m)x[i][j] = y[i][j] = opt[i][j];\n//\t\t\tcout<<\"--------------------------------------\\n\";\n//\t\t\trep(i,1,n){\n//\t\t\t\trep(j,1,m)cout<<x[i][j];\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)rep(j,1,m)if(z[i][j]=='X')x[i][j] = 'X';\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans-8<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr,Vpr> PQ;\nconst int INF=1<<30;\nstruct Edge{\npublic:\n\tint to,cost,cp;\n\tEdge *rev;\n\tEdge(int t,int c,int cp):to(t),cost(c),cp(cp){\n\t\t\n\t}\n\tvoid add(int x){\n\t\tcp+=x;\n\t}\n\tvoid flow(int amount){\n\t\tadd(-amount);\n\t\trev->add(amount);\n\t}\n\tbool usable(){\n\t\treturn cp>=1;\n\t}\t\n};\nvoid unite(Edge &a,Edge &b){\n\ta.rev=&b;\n\tb.rev=&a;\n}\nclass Graph{\n\tint nodeSize,edgeSize;\n\tvector<int> dist;\n\tvector<vector<Edge> > edges;\npublic: \n\tvoid add(int a,int b,int cost,int cp){\n\t\tedges[a].PB(Edge(b,cost,cp));\n\t\tedges[b].PB(Edge(a,cost,0));\n\t\tunite(edges[a].back(),edges[b].back());\n\t}\n\tGraph(int x):nodeSize(x){\n\t\t\n\t\tedges=vector<vector<Edge> >(nodeSize);\n\t\tdist=VI(nodeSize);\n\t}\n\tvoid distInit(int s){\n\t\tREP(i,nodeSize){\n\t\t\tdist[i]=INF;\n\t\t}\n\t\tdist[s]=0;\n\t}\n\tint searching(int now,int e,int capacity){\n\t\tif(now==e) return capacity;\n\t\tif(capacity==0) return 0;\n\t\tif(dist[now]>=dist[e]) return 0;\n\t\tint flowed=0;\n\t\tREP(i,edges[now].size()){\n\t\t\tEdge *ed= &edges[now][i];\n\t\t\tif(dist[now]+1 != dist[ed->to]) continue;\n\t\t\tint nflow=searching(ed->to,e,min(capacity-flowed,ed->cp));\n\t\t\tif(nflow){\n\t\t\t\tflowed+=nflow;\n\t\t\t\ted->flow(nflow);\n\t\t\t}\n\t\t}\n\t\treturn flowed;\n\t}\n\tbool bfs(int s,int e){\n\t\tdistInit(s);\n\t\tqueue<int> qu;\n\t\tqu.push(s);\n\t\twhile(!qu.empty()){\n\t\t\tint now=qu.front();\n\t\t\tif(now==e) return true;\n\t\t\tqu.pop();\n\t\t\tREP(i,edges[now].size()){\n\t\t\t\tEdge *ed= &edges[now][i];\n\t\t\t\tif(!ed->usable()) continue;\n\t\t\t\tif(dist[ed->to]==INF){\n\t\t\t\t\tqu.push(ed->to);\n\t\t\t\t\tdist[ed->to]=dist[now]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint maximumFlow(int s,int e){\n\t\tint ans=0;\n\t\twhile(bfs(s,e)){\n\t\t\tans+=searching(s,e,INF);\n\t\t}\n\t\treturn ans;\n\t}\n};\nconst int SIZE=101;\nint conv(int a,int b,int c){return a*100+b+SIZE*SIZE*c+2;}\nint dy[]={0,1,0,-1},dx[]={1,0,-1,0};\nint H,W;\nint maps[101][101];\nbool isSafe(int y,int x){\n\treturn 0<=y && y<H && 0<=x && x<W;\n}\nint main(){\n\tGraph graph(SIZE*SIZE*3+2);\n\tcin >> H >> W;\n\tREP(i,H) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,s.size()){\n\t\t\tmaps[i][j]=s[j]=='X';\n\t\t\tif(maps[i][j] &&(i==0 || j==0 || i==H-1 || j==W-1)){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\t\t\n\t}\n\tREP(i,H) REP(j,W) {\n\t\tgraph.add(conv(i,j,1),conv(i,j,0),0,1);\n//\t\tedges[conv(i,j,1)].PB(edge(conv(i,j,0),0,1));\n\t\tif(maps[i][j]){\n\t\t\t//edges[0].PB(edge(conv(i,j,1),0,1));\n\t\t\tgraph.add(0,conv(i,j,0),0,4);\n\t\t}\n\t\tREP(k,4){\n\t\t\tif(!isSafe(i+dy[k],j+dx[k])){\n\t\t\tgraph.add(conv(i,j,0),1,0,1);\n\t\t\t//\tedges[conv(i,j,0)].PB(edge(1,0,1));\n\t\t\t} \n\t\t\telse if(!maps[i+dy[k]][j+dx[k]]){\n\t\t\t\tgraph.add(conv(i,j,0),conv(i+dy[k],j+dx[k],1),0,1);\n\t\t\t\tgraph.add(conv(i+dy[k],j+dx[k],0),conv(i,j,1),0,1);\n//\t\t\t\tedges[conv(i,j,0)].PB(edge(conv(i+dy[k],j+dx[k],1),0,1));\n//\t\t\t\tedges[conv(i+dy[k],j+dx[k],0)].PB(edge(conv(i,j,1),0,1));\n\t\t\t}\n\t\t}\n\t\n\t}\n\treturn 0;\n\tcout << graph.maximumFlow(0,1) << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mem(x,n) memset(x,n,sizeof(x))\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,l) for(auto it=(l).begin();it!=(l).end();it++)\n#define pnl printf(\"\\n\")\n#define len(x) (x).length()\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\nconst double EPS=1e-10;\n//const double PI=acos(-1.0);\nconst int INF=1<<30;\nconst LL LLINF=1ll<<60;\nconst int MOD=1e9+7;\nconst int xx[8]={1,0,-1,0,1,-1,1,-1};\nconst int yy[8]={0,1,0,-1,-1,1,1,-1};\n\n/****************************************************************************************\\\n  __    __               __ /\\/|   ___ _           _       /\\/|__               __    __\n  \\ \\  / /  _____ __ ____\\ \\/\\/   / __| |__ _ _ __(_)___  |/\\// /____ __ _____  \\ \\  / /\n   \\ \\| |  |___\\ V  V /___| |    | (__| / _` | '_ \\ / -_)    | |___\\ V  V /___|  | |/ /\n    \\_\\ |  |___|\\_/\\_/|___| |     \\___|_\\__,_| .__/_\\___|    | |___|\\_/\\_/|___|  | /_/\n       \\_\\               /_/                 |_|              \\_\\               /_/\n\\****************************************************************************************/\n\nstruct edge{\n\tint v, bf;\n\tLL flow;\n};\n\nconst int MAXN = 20005;\nvector<edge> adj[MAXN];\nint lvl[MAXN], st[MAXN];\nconst int sink = 20003, source = 20004;\nint idx[105][105],idx1[105][105];\nchar input[105][105];\n\nvoid addedge(int u,int v,LL flow){\n\tadj[u].pb({v,sz(adj[v]),flow});\n\tadj[v].pb({u,sz(adj[u]),flow});\n}\n\nbool bfs(int S,int G){\n\tqueue<int> q;\n\tmem(lvl,-1);\n\tq.push(S); lvl[S]=0;\n\twhile(!q.empty()){\n\t\tint u = q.front(); q.pop();\n\t\tfor(int i=0;i<sz(adj[u]);i++){\n\t\t\tint v = adj[u][i].v;\n\t\t\tLL flow = adj[u][i].flow;\n\t\t\tif(lvl[v]!=-1||flow<=0) continue;\n\t\t\tlvl[v]=lvl[u]+1;\n\t\t\tq.push(v);\n\t\t}\n\t}\n\treturn (lvl[G]!=-1);\n}\n\nLL dfs(int u,LL mini,int G){\n\tif(u==G) return mini;\n\t\n\tfor(int i=st[u];i<sz(adj[u]);i++){\n\t\tst[u]=i;\n\t\tint v = adj[u][i].v;\n\t\tLL flow = adj[u][i].flow;\n\t\tif(flow<=0||(lvl[v]-lvl[u]!=1)) continue;\n\t\tLL ret=dfs(v,min(mini,flow),G);\n\t\tif(ret>0){\n\t\t\tadj[u][i].flow-=ret;\n\t\t\tint bvf = adj[u][i].bf;\n\t\t\tadj[v][bvf].flow+=ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nLL maxflow(int S,int G){\n\tLL ret=0;\n\twhile(1){\n\t\tif(!bfs(S,G)) break;\n\t\tLL flow = 0;\n\t\tmem(st,0);\n\t\twhile((flow=dfs(S, LLINF, G))>0){\n\t\t\tret+=flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint r,c;\n\tscanf(\"%d%d\",&r,&c);\n\tgetchar();\n\tfor(int i=0;i<r;i++){\n\t\tscanf(\"%s\",input[i]);\n\t}\n\t\n\tint temp=0;\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tidx[i][j]=temp;\n\t\t\tidx1[i][j]=temp+10000;\n\t\t\ttemp++;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(input[i][j]=='.'){\n\t\t\t\taddedge(idx[i][j],idx1[i][j],1);\n\t\t\t\t\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\taddedge(idx1[i][j],sink,INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\taddedge(source,idx[i][j],INF);\n\t\t\t\taddedge(idx[i][j],idx1[i][j],INF);\n\t\t\t\t\n\t\t\t\tif(i==0||i==r-1||j==0||j==c-1){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(i!=0) addedge(\tidx1[i][j], idx[i-1][j],INF);\n\t\t\tif(i!=r-1) addedge(\tidx1[i][j], idx[i+1][j],INF);\n\t\t\tif(j!=0) addedge(\tidx1[i][j], idx[i][j-1],INF);\n\t\t\tif(j!=c-1)addedge(\tidx1[i][j], idx[i][j+1],INF);\n\t\t}\n\t}\n\t\n\tLL ans = maxflow(source,sink);\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring a[110];\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\nbool vis[110][110];\nbool has[110][110];\n\ntypedef pair<int, int> pii;\n\nint main(void) {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < n; ++ i) {\n        cin >> a[i];\n    }\n\n    queue<pii> q;\n    bool flag = true;\n    for (int i = 0; i < n; ++ i) {\n        for (int j = 0; j < m; ++ j) {\n            if (i == 0 || j == 0 || i == n - 1 || j == m - 1) {\n                if (a[i][j] == 'X') flag = false;\n                vis[i][j] = true;\n                has[i][j] = true;\n                q.push(pii(i, j));\n            }\n        }\n    }\n\n    if (!flag) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n\n    while (!q.empty()) {\n        pii cur = q.front(); q.pop();\n        int x = cur.first, y = cur.second;\n        bool flag = true;\n        for (int i = 0; i < 4; ++ i) {\n            int xx = x + dx[i];\n            int yy = y + dy[i];\n            if (xx < 0 || xx >= n || yy < 0 || yy >= m || vis[xx][yy]) continue;\n            if (a[xx][yy] == 'X') {\n                flag = false;\n                continue;\n            }\n//            cerr << xx << ' ' << y << endl;\n            has[xx][yy] = vis[xx][yy] = true;\n            has[x][y] = false;\n            q.push(pii(xx, yy));\n        }\n        if (flag) has[x][y] = false;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; ++ i) for (int j = 0; j < m; ++ j) if (has[i][j]) {\n        ++ ans;\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(v, a, b) for(int v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(int v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(int v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define LLI long long int\n#define fst first\n#define snd second\n\n#ifdef DEBUG\n#include <misc/C++/Debug.cpp>\n#else\n#define dump(x) ((void)0)\n#endif\n\n#define gcd __gcd\n\nusing namespace std;\ntemplate <class T> constexpr T lcm(T m, T n){return m/gcd(m,n)*n;}\n\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\ntemplate <typename T, typename U> istream& operator>>(istream &is, pair<T,U> &p){is >> p.first >> p.second; return is;}\n\ntemplate <typename T, typename U> T& chmin(T &a, const U &b){return a = (a<=b?a:b);}\ntemplate <typename T, typename U> T& chmax(T &a, const U &b){return a = (a>=b?a:b);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\n\ntemplate <typename T, T INF> class FordFulkerson{ \n  struct edge{\n    int to, rev;\n    T cap;\n  };\n\n  int size;\n\n  vector<vector<edge>> graph;\n  vector<bool> visit;\n  \n  T dfs(int from, int to, T flow){\n    if(from == to) return flow;\n    visit[from] = true;\n\n    for(auto &e : graph[from]){\n      if(!visit[e.to] and e.cap > 0){\n        T d = dfs(e.to, to, min(flow, e.cap));\n\tif(d > 0){\n\t  e.cap -= d;\n\t  graph[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  \npublic:\n  FordFulkerson(int size): size(size), graph(size), visit(size){}\n\n  void add_edge(int from, int to, const T &cap){\n    graph[from].push_back((edge){to, (int)graph[to].size(), cap});\n    graph[to].push_back((edge){from, (int)graph[from].size()-1, 0});\n  }\n\n  T max_flow(int s, int t){\n    T ret = 0;\n\n    while(1){\n      visit.assign(size,false);\n      T flow = dfs(s,t,INF);\n      if(flow == 0) return ret;\n      ret += flow;\n    }\n  }\n};\n\n\n\nconst int dir4[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};\nconst LLI inf = LLONG_MAX / 10000;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  \n  int H,W;\n  while(cin >> H >> W){\n    vector<string> S(H); cin >> S;\n\n    FordFulkerson<LLI,inf> mf(H*W*2+2);\n    int s = H*W*2, t = s+1;\n    vector<vector<int>> in(H,vector<int>(W)), out(H,vector<int>(W));\n    REP(i,H) REP(j,W){\n      in[i][j] = i+j*H;\n      out[i][j] = in[i][j] + H*W;\n    }\n    \n    REP(i,H){\n      REP(j,W){\n\tif(i==0 or i==H-1 or j==0 or j==W-1) mf.add_edge(out[i][j], t, inf);\n\n\tif(S[i][j] == 'X'){\n\t  mf.add_edge(s, in[i][j], inf);\n\t  mf.add_edge(in[i][j], out[i][j], inf);\n\t}\n\telse mf.add_edge(in[i][j], out[i][j], 1);\n\n\tfor(auto &d : dir4){\n\t  int y = i+d[0], x = j+d[1];\n\t  if(x<0 or x>=W or y<0 or y>=H) continue;\n\t  mf.add_edge(out[i][j], in[y][x], inf);\n\t}\n      }\n    }\n\n    LLI ans = mf.max_flow(s,t);\n    \n    cout << (ans>=inf ? -1 : ans) << endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n\tint H, W;\n\tcin >> H >> W;\n\tvector<string> S(H);\n\tfor (auto& x : S) cin >> x;\n\tconst int di[] = {0,0,-1,1};\n\tconst int dj[] = {-1,1,0,0};\n\tfor (int i = 0; i < H; ++ i) for (int j = 0; j < W; ++ j) if (S[i][j] == 'X') {\n\t\tif (i == 0 || i == H-1 || j == 0 || j == W-1) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tfor (int k = 0; k < 4; ++ k) {\n\t\t\tint ii = i + di[k], jj = j + dj[k];\n\t\t\tif (0 <= ii && ii < H && 0 <= jj && jj < W) {\n\t\t\t\tif (S[ii][jj] == '.') S[ii][jj] = '$';\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < H; ++ i) {\n\t\tfor (int j = 0; j < W; ++ j) if (S[i][j] != '.') { S[i][j] = '#'; break; }\n\t\tfor (int j = W-1; j >= 0; -- j) if (S[i][j] != '.') { S[i][j] = '#'; break; }\n\t}\n\tfor (int j = 0; j < W; ++ j) {\n\t\tfor (int i = 0; i < H; ++ i) if (S[i][j] != '.') { S[i][j] = '#'; break; }\n\t\tfor (int i = H-1; i >= 0; -- i) if (S[i][j] != '.') { S[i][j] = '#'; break; }\n\t}\n\tint r = 0;\n\tfor (const auto& x : S) for (char c : x) if (c == '#') ++ r;\n\tcout << r << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1000000000;\n\nclass MaxFlow {\n\tstruct edge {\n\t\tint to, cap, rev;\n\t\tedge(int to_, int cap_, int rev_) : to(to_), cap(cap_), rev(rev_) {};\n\t};\n\n\tint V;\n\tvector<vector<edge>> G;\n\tvector<int> level;\n\tvector<int> iter;\n\n\tvoid BFS(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (size_t i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint DFS(int v, int t, int f) {\n\t\tif (v == t) return f;\n\t\tfor (int &i = iter[v]; i < (int)G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = DFS(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\npublic:\n\tMaxFlow(int _V) : V(_V), G(_V), level(_V), iter(_V) {}\n\tvoid add(int from, int to, int cap) {\n\t\tG[from].push_back(edge(to, cap, G[to].size()));\n\t\tG[to].push_back(edge(from, 0, G[from].size() - 1));\n\t}\n\tint Dinic(int s, int t) {\n\t\tint flow = 0;\n\t\twhile (true) {\n\t\t\tBFS(s);\n\t\t\tif (level[t] < 0) return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = DFS(s, t, INF)) > 0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\n\nint main()\n{\n\tint H, W;\n\tcin >> H >> W;\n\tvector<string> v(H);\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> v[i];\n\t}\n\tMaxFlow mf(H * W * 2 + 2);\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n\t\t\t\tmf.add(H * W * 2, i * W + j, INF);\n\t\t\t}\n\t\t\tmf.add(i * W + j, H * W + i * W + j, 1);\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tint tx = i + dx[k], ty = j + dy[k];\n\t\t\t\tif (0 <= tx && tx < H && 0 <= ty && ty < W) {\n\t\t\t\t\tmf.add(H * W + i * W + j, tx * W + ty, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (v[i][j] == 'X') mf.add(i * W + j, H * W * 2 + 1, INF);\n\t\t}\n\t}\n\tint res = mf.Dinic(H * W * 2, H * W * 2 + 1);\n\tcout << (res == INF ? -1 : res) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvoid mainmain(){\n\tint H,W;\n\tcin>>H>>W;\n\tvector<string> v(H);\n\trep(i,H) cin>>v[i];\n\tbool ok = true;\n\trep(i,H){\n\t\tif(v[i][0]=='X') ok=false;\n\t\tif(v[i][W-1]=='X') ok=false;\n\t}\n\trep(i,W){\n\t\tif(v[0][i]=='X') ok=false;\n\t\tif(v[H-1][i]=='X') ok=false;\n\t}\n\tif(!ok){\n\t\tcout<<-1<<endl;\n\t}\n\tvvint vv;\n\tinitvv(vv,H,W,0);\n\tint dd[]={0,1,0,-1,0};\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tif(v[i][j]=='X'){\n\t\t\t\trep(k,4){\n\t\t\t\t\tvv[i+dd[k]][j+dd[k+1]]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tif(v[i][j]=='X') continue;\n\t\t\tans += vv[i][j];\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 2e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nstruct edge { int to, cap, rev; };\n\nconst int MAX_V = 20010;\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid addEdge(int from, int to, int cap) {\n    G[from].emplace_back((edge){to, cap, (int)G[to].size()});\n    G[to].emplace_back((edge){from, 0, (int)G[from].size() - 1});\n}\n\nvoid bfs(int s) {\n    memset(level, -1, sizeof(level));\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n        int v = que.front(); que.pop();\n        for (int i = 0; i < G[v].size(); i++) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    for (int &i = iter[v]; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[v] < level[e.to]) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    for (;;) {\n        bfs(s);\n        if (level[t] < 0) return flow;\n        memset(iter, 0, sizeof(iter));\n        int f;\n        while ((f = dfs(s, t, inf)) > 0) {\n            flow += f;\n        }\n    }\n}\n\n// N, E, S, W\nconst int dx[4] = {-1, 0,  1,  0};\nconst int dy[4] = { 0, 1,  0, -1};\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n    vector<string> s(n);\n    rep(i, n) cin >> s[i];\n\n    enum {IN, OUT};\n    auto toNode = [&](int i, int j, int in) {\n        return i * m + j + (in ? 0 : n * m);\n    };\n\n    auto inside = [&](int i, int j) {\n        return 0 <= i && i < n && 0 <= j && j < m;\n    };\n\n    const int src = 2 * n * m;\n    const int fin = 2 * n * m + 1;\n    rep(i, n) {\n        rep(j, m) {\n            if (s[i][j] == 'X') {\n                addEdge(src, toNode(i, j, OUT), inf);\n            }\n            addEdge(toNode(i, j, IN), toNode(i, j, OUT), (s[i][j] == 'X' ? inf : 1));\n\n            rep(k, 4) {\n                int ni = i + dx[k], nj = j + dy[k];\n                if (inside(ni, nj)) {\n                    addEdge(toNode(i, j, OUT), toNode(ni, nj, IN), inf);\n                }\n                else {\n                    addEdge(toNode(i, j, OUT), fin, inf);\n                }\n            }\n        }\n    }\n\n    int ans = max_flow(src, fin);\n    cout << (ans < inf ? ans : -1) << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<numeric>\n#include<functional>\n#include<algorithm>\n#include<bitset>\n#include<tuple>\n#include<unordered_set>\n#include<random>\n#include<array>\n#include<cassert>\nusing namespace std;\n#define INF (1<<29)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define uniq(v) v.erase(unique(all(v)),v.end())\n\n\n#define INF 1e+10\n#define EPS 1e-10\n#define EQ(a,b) (abs(a-b)<EPS)\n\n//誤差を考慮して足し算\ndouble add(double a, double b){\n\tif (abs(a + b) < EPS*(abs(a) + abs(b)))return 0;\n\treturn a + b;\n}\nstruct P{//2次元ベクトル\n\tdouble x, y;\n\tP(){}\n\tP(double x, double y) :x(x), y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x, p.x), add(y, p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\tP operator * (double d){\n\t\treturn P(x*d, y*d);\n\t}\n\tP operator / (double d){\n\t\treturn P(x / d, y / d);\n\t}\n\tdouble dot(P p){//内積\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\tdouble det(P p){//外積\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n\tbool equal(P p){\n\t\treturn (x - p.x)*(x - p.x) + (y - p.y)*(y - p.y) < EPS*EPS;\n\t}\n\tdouble norm()const{\n\t\treturn sqrt(x*x + y*y);\n\t}\n};\n\n//凸包\nbool cmp_x(const P& p, const P& q){\n\tif (p.x != q.x)return p.x<q.x;\n\treturn p.y<q.y;\n}\nvector<P> convex_hull(vector<P>& ps){\n\tif (ps.empty())return ps;\n\tsort(ps.begin(), ps.end(), cmp_x);\n\tint k = 0;\n\tvector<P> qs(ps.size() * 2);\n\tfor (int i = 0; i<ps.size(); i++){\n\t\twhile (k>1 && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0)k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tfor (int i = ps.size() - 2, t = k; i >= 0; i--){\n\t\twhile (k>t && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0)k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\n\n\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tvector<P> ps;\n\tint h,w;\n\tcin>>h>>w;\n\trep(y,h)rep(x,w){\n\t\tchar c;\n\t\tcin>>c;\n\t\tif (c=='X'){\n\t\t\tif (y==0||y+1==h||x==0||x+1==w){\n\t\t\t\tcout<<-1<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tps.push_back(P(y, x));\n\t\t\tps.push_back(P(y, x+1));\n\t\t\tps.push_back(P(y+1, x));\n\t\t\tps.push_back(P(y+1, x+1));\n\t\t}\n\t}\n\tauto a = convex_hull(ps);\n\tint ans=0;\n\trep(i,a.size()){\n\t\tP s = a[i], t = a[(i+1)%a.size()];\n\t\tans += max(fabs(s.y-t.y),fabs(s.x-t.x))+EPS;\n\t}\n\tcout<<ans<<endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T> using Graph = vector<vector<T>>;\n\n#define REP(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (__typeof(a.begin()) x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define endl '\\n'\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint H, W;\nstring S[105];\n\nbool is_inside(int x, int y) {\n  return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nint solve() {\n  rep(i, W) if (S[0][i] == 'X' || S[H - 1][i] == 'X') return -1;\n  rep(i, H) if (S[i][0] == 'X' || S[i][W - 1] == 'X') return -1;\n\n  int ans = 0;\n  rep(y, H) rep(x, W) {\n    if (S[y][x] != 'X') continue;\n    rep(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (!is_inside(nx, ny)) continue;\n      if (S[ny][nx] == '.') {\n        S[ny][nx] = '#';\n        ans += 1;\n      }\n    }\n  }\n\n  rep(y, H) rep(x, W) {\n    if (S[y][x] != '#') continue;\n    bool remove = true;\n    rep(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (!is_inside(nx, ny)) remove = false;\n      if (S[ny][nx] == '.') remove = false; \n    }\n    if (remove) ans -= 1;\n  }\n\n  return ans;\n}\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> H >> W;\n  rep(i, H) cin >> S[i];\n\n  cout << solve() << endl;\n  //rep(i, H) cout << S[i] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region head\n#include <bits/stdc++.h>\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class T> struct simple_queue {\n    std::vector<T> payload;\n    int pos = 0;\n    void reserve(int n) { payload.reserve(n); }\n    int size() const { return int(payload.size()) - pos; }\n    bool empty() const { return pos == int(payload.size()); }\n    void push(const T& t) { payload.push_back(t); }\n    T& front() { return payload[pos]; }\n    void clear() {\n        payload.clear();\n        pos = 0;\n    }\n    void pop() { pos++; }\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class Cap> struct mf_graph {\n  public:\n    mf_graph() : _n(0) {}\n    mf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        assert(0 <= cap);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result;\n        for (int i = 0; i < m; i++) {\n            result.push_back(get_edge(i));\n        }\n        return result;\n    }\n    void change_edge(int i, Cap new_cap, Cap new_flow) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        assert(0 <= new_flow && new_flow <= new_cap);\n        auto& _e = g[pos[i].first][pos[i].second];\n        auto& _re = g[_e.to][_e.rev];\n        _e.cap = new_cap - new_flow;\n        _re.cap = new_flow;\n    }\n\n    Cap flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    Cap flow(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n\n        std::vector<int> level(_n), iter(_n);\n        internal::simple_queue<int> que;\n\n        auto bfs = [&]() {\n            std::fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            que.clear();\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front();\n                que.pop();\n                for (auto e : g[v]) {\n                    if (e.cap == 0 || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    if (e.to == t) return;\n                    que.push(e.to);\n                }\n            }\n        };\n        auto dfs = [&](auto self, int v, Cap up) {\n            if (v == s) return up;\n            Cap res = 0;\n            int level_v = level[v];\n            for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                _edge& e = g[v][i];\n                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                if (d <= 0) continue;\n                g[v][i].cap += d;\n                g[e.to][e.rev].cap -= d;\n                res += d;\n                if (res == up) break;\n            }\n            return res;\n        };\n\n        Cap flow = 0;\n        while (flow < flow_limit) {\n            bfs();\n            if (level[t] == -1) break;\n            std::fill(iter.begin(), iter.end(), 0);\n            while (flow < flow_limit) {\n                Cap f = dfs(dfs, t, flow_limit - flow);\n                if (!f) break;\n                flow += f;\n            }\n        }\n        return flow;\n    }\n\n    std::vector<bool> min_cut(int s) {\n        std::vector<bool> visited(_n);\n        internal::simple_queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int p = que.front();\n            que.pop();\n            visited[p] = true;\n            for (auto e : g[p]) {\n                if (e.cap && !visited[e.to]) {\n                    visited[e.to] = true;\n                    que.push(e.to);\n                }\n            }\n        }\n        return visited;\n    }\n\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n\n}  // namespace atcoder\n\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing pi = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate <class T>\nusing vv = vector<vector<T>>;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define repi(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rrepi(i, a, b) for (int i = (int)(b)-1; i >= (int)(a); i--)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define bit(n) (1LL << (n))\ntemplate <class T>\ninline bool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\ninline bool chmin(T &a, const T &b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nconst int INF = 1002003004;\nconst ll LINF = 1002003004005006007ll;\nstruct preprocess {\n    preprocess() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(20);\n    }\n} ____;\n#pragma endregion head\n\n#pragma region library\n#pragma endregion library\nint h, w;\nint coord(int x, int y, bool in) {\n    if (in) {\n        return x * w + y;\n    } else {\n        return h * w + (x * w + y);\n    }\n}\nint main() {\n    cin >> h >> w;\n    vv<char> grid(h, vector<char>(w));\n    rep(i, h) rep(j, w) cin >> grid[i][j];\n    mf_graph<int> g(2 * h * w + 2);\n    int s = 2 * h * w, t = 2 * h * w + 1;\n    bool flag = false;\n    rep(i, h) rep(j, w) {\n        if (i < h - 1) {\n            g.add_edge(coord(i, j, false), coord(i + 1, j, true), INF);\n            g.add_edge(coord(i + 1, j, false), coord(i, j, true), INF);\n        }\n        if (j < w - 1) {\n            g.add_edge(coord(i, j, false), coord(i, j + 1, true), INF);\n            g.add_edge(coord(i, j + 1, false), coord(i, j, true), INF);\n        }\n        if (grid[i][j] == 'X') {\n            g.add_edge(s, coord(i, j, true), INF);\n            g.add_edge(coord(i, j, true), coord(i, j, false), INF);\n        } else {\n            g.add_edge(coord(i, j, true), coord(i, j, false), 1);\n        }\n        if (i == 0 || i == h - 1 || j == 0 || j == w - 1) {\n            g.add_edge(coord(i, j, false), t, INF);\n            if (grid[i][j] == 'X') flag = true;\n        }\n    }\n    if (flag) {\n        cout << -1 << '\\n';\n        return 0;\n    }\n    cout << g.flow(s, t) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n#include<vector>\n#include<utility>\n#include<stack>\n#include<algorithm>\n#include<string>\n#include<string.h>\n#define fi first\n#define se second\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\n\nstruct edge{int to, flow, cap, rev;};\n\nconst int N = 100;\nconst int SINK = N * N;\nconst int SRC = SINK + 1;\n\nvector<int> lst[N * N + 5];\n\nvoid addEdge(int a, int b, int cap){\n\tlst[a].pb(b);\n\tlst[b].pb(a);\n}\n\nchar grid[N + 5][N + 5];\nint cap[N * N + 5];\nint id[N + 5][N + 5];\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nint level[N * N + 5];\nint lastEdge[N * N + 5];\nint h, w;\n\nbool bfs(){\n\tqueue<int> q;\n\tmemset(level, -1, sizeof level);\n\n\tq.push(SRC);\n\tlevel[SRC] = 0;\n\n\twhile(!q.empty()){\n\t\tint cur = q.front(); q.pop();\n\t\tif(cap[cur] == 0)continue;\n\t\tfor(int i = 0; i < lst[cur].size(); ++i){\n\t\t\tint nx = lst[cur][i];\n\t\t\tif(level[nx] != -1)continue;\n\t\t\tif(cap[nx] == 0)continue;\n\n\t\t\tlevel[nx] = level[cur] + 1;\n\t\t\tq.push(nx);\n\t\t}\n\t}\n\n\treturn level[SINK] != -1;\n}\n\nint dfs(int now, int flow){\n\tif(now == SINK)return flow;\n\tif(flow == 0)return 0;\n\tint ret = 0;\n\tfor(int &i = lastEdge[now]; i < lst[now].size(); ++i){\n\t\tint nx = lst[now][i];\n\t\tif(cap[nx] == 0)continue;\n\t\tif(level[nx] == level[now] + 1){\n\t\t\tint curr = dfs(nx, min(flow, cap[now]));\n\t\t\tif(curr > 0){\n\t\t\t\tcap[now] -= curr;\n\t\t\t\tflow -= curr;\n\t\t\t\tret += curr;\n\t\t\t\tif(flow == 0 || cap[now])return ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint maxFlow(){\n\tint ret = 0;\n\twhile(bfs()){\n\t\tmemset(lastEdge, 0, sizeof lastEdge);\n\t\tret += dfs(SRC, N * N * 10);\n\t}\n\treturn ret;\n}\n\nbool inRange(int x, int y){\n\treturn x >= 0 && y >= 0 && x < h && y < w;\n}\n\n\nint main(){\n\tios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> h >> w;\n\tint cnt = 0;\n\tfor(int i = 0; i < h; ++i){\n\t\tfor(int j = 0; j < w; ++j){\n\t\t\tcin >> grid[i][j];\n\t\t\tcap[cnt] = 1;\n\t\t\tif(grid[i][j] == 'X')cap[cnt] = N * N * 10;\n\t\t\tid[i][j] = cnt++;\n\t\t}\n\t}\n\tcap[SRC] = cap[SINK] = N * N + 10;\n\tbool sideExist = false;\n\n\tfor(int i = 0; i < h; ++i){\n\t\tfor(int j = 0; j < w; ++j){\n\t\t\tfor(int k = 0; k < 4; ++k){\n\t\t\t\tint nx = i + dx[k];\n\t\t\t\tint ny = j + dy[k];\n\t\t\t\tif(!inRange(nx, ny)) addEdge(id[i][j], SINK, 1);\n\t\t\t\telse addEdge(id[i][j], id[nx][ny], 1);\n\t\t\t}\n\t\t\tif(grid[i][j] == 'X'){\n\t\t\t\tif(i == 0 || j == 0 || i == h - 1 || j == w - 1)\n\t\t\t\t\tsideExist = true;\n\t\t\t\taddEdge(SRC, id[i][j], 4);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(sideExist)cout << -1 << endl;\n\telse cout << maxFlow() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <bits/stdc++.h>\n//#include \"bits/stdc++.h\"\n\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param n `0 <= n`\n// @return minimum non-negative `x` s.t. `n <= 2**x`\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n\n// @param n `1 <= n`\n// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param m `1 <= m`\n// @return x mod m\nconstexpr long long safe_mod(long long x, long long m) {\n    x %= m;\n    if (x < 0) x += m;\n    return x;\n}\n\n// Fast moduler by barrett reduction\n// Reference: https://en.wikipedia.org/wiki/Barrett_reduction\n// NOTE: reconsider after Ice Lake\nstruct barrett {\n    unsigned int _m;\n    unsigned long long im;\n\n    // @param m `1 <= m`\n    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n\n    // @return m\n    unsigned int umod() const { return _m; }\n\n    // @param a `0 <= a < m`\n    // @param b `0 <= b < m`\n    // @return `a * b % m`\n    unsigned int mul(unsigned int a, unsigned int b) const {\n        // [1] m = 1\n        // a = b = im = 0, so okay\n\n        // [2] m >= 2\n        // im = ceil(2^64 / m)\n        // -> im * m = 2^64 + r (0 <= r < m)\n        // let z = a*b = c*m + d (0 <= c, d < m)\n        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im\n        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2\n        // ((ab * im) >> 64) == c or c + 1\n        unsigned long long z = a;\n        z *= b;\n#ifdef _MSC_VER\n        unsigned long long x;\n        _umul128(z, im, &x);\n#else\n        unsigned long long x =\n            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n        unsigned int v = (unsigned int)(z - x * _m);\n        if (_m <= v) v += _m;\n        return v;\n    }\n};\n\n// @param n `0 <= n`\n// @param m `1 <= m`\n// @return `(x ** n) % m`\nconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n    if (m == 1) return 0;\n    unsigned int _m = (unsigned int)(m);\n    unsigned long long r = 1;\n    unsigned long long y = safe_mod(x, m);\n    while (n) {\n        if (n & 1) r = (r * y) % _m;\n        y = (y * y) % _m;\n        n >>= 1;\n    }\n    return r;\n}\n\n// Reference:\n// M. Forisek and J. Jancina,\n// Fast Primality Testing for Integers That Fit into a Machine Word\n// @param n `0 <= n`\nconstexpr bool is_prime_constexpr(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 7 || n == 61) return true;\n    if (n % 2 == 0) return false;\n    long long d = n - 1;\n    while (d % 2 == 0) d /= 2;\n    for (long long a : {2, 7, 61}) {\n        long long t = d;\n        long long y = pow_mod_constexpr(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {\n            y = y * y % n;\n            t <<= 1;\n        }\n        if (y != n - 1 && t % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\ntemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\n\n// @param b `1 <= b`\n// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g\nconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n    a = safe_mod(a, b);\n    if (a == 0) return {b, 0};\n\n    // Contracts:\n    // [1] s - m0 * a = 0 (mod b)\n    // [2] t - m1 * a = 0 (mod b)\n    // [3] s * |m1| + t * |m0| <= b\n    long long s = b, t = a;\n    long long m0 = 0, m1 = 1;\n\n    while (t) {\n        long long u = s / t;\n        s -= t * u;\n        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n\n        // [3]:\n        // (s - t * u) * |m1| + t * |m0 - m1 * u|\n        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)\n        // = s * |m1| + t * |m0| <= b\n\n        auto tmp = s;\n        s = t;\n        t = tmp;\n        tmp = m0;\n        m0 = m1;\n        m1 = tmp;\n    }\n    // by [3]: |m0| <= b/g\n    // by g != b: |m0| < b/g\n    if (m0 < 0) m0 += b / s;\n    return {s, m0};\n}\n\n// Compile time primitive root\n// @param m must be prime\n// @return primitive root (and minimum in now)\nconstexpr int primitive_root_constexpr(int m) {\n    if (m == 2) return 1;\n    if (m == 167772161) return 3;\n    if (m == 469762049) return 3;\n    if (m == 754974721) return 11;\n    if (m == 998244353) return 3;\n    int divs[20] = {};\n    divs[0] = 2;\n    int cnt = 1;\n    int x = (m - 1) / 2;\n    while (x % 2 == 0) x /= 2;\n    for (int i = 3; (long long)(i)*i <= x; i += 2) {\n        if (x % i == 0) {\n            divs[cnt++] = i;\n            while (x % i == 0) {\n                x /= i;\n            }\n        }\n    }\n    if (x > 1) {\n        divs[cnt++] = x;\n    }\n    for (int g = 2;; g++) {\n        bool ok = true;\n        for (int i = 0; i < cnt; i++) {\n            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) return g;\n    }\n}\ntemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n\nnamespace internal {\n\n#ifndef _MSC_VER\ntemplate <class T>\nusing is_signed_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\n                                  std::is_same<T, __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\n                                  std::is_same<T, unsigned __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing make_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value,\n                              __uint128_t,\n                              unsigned __int128>;\n\ntemplate <class T>\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\n                                                  is_signed_int128<T>::value ||\n                                                  is_unsigned_int128<T>::value,\n                                              std::true_type,\n                                              std::false_type>::type;\n\ntemplate <class T>\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                 std::is_signed<T>::value) ||\n                                                    is_signed_int128<T>::value,\n                                                std::true_type,\n                                                std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<(is_integral<T>::value &&\n                               std::is_unsigned<T>::value) ||\n                                  is_unsigned_int128<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<\n    is_signed_int128<T>::value,\n    make_unsigned_int128<T>,\n    typename std::conditional<std::is_signed<T>::value,\n                              std::make_unsigned<T>,\n                              std::common_type<T>>::type>::type;\n\n#else\n\ntemplate <class T> using is_integral = typename std::is_integral<T>;\n\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<is_integral<T>::value &&\n                                  std::is_unsigned<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\n                                              std::make_unsigned<T>,\n                                              std::common_type<T>>::type;\n\n#endif\n\ntemplate <class T>\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n\ntemplate <class T>\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\nnamespace internal {\n\nstruct modint_base {};\nstruct static_modint_base : modint_base {};\n\ntemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\ntemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n\n}  // namespace internal\n\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\nstruct static_modint : internal::static_modint_base {\n    using mint = static_modint;\n\n  public:\n    static constexpr int mod() { return m; }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    static_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    static_modint(T v) {\n        long long x = (long long)(v % (long long)(umod()));\n        if (x < 0) x += umod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    static_modint(T v) {\n        _v = (unsigned int)(v % umod());\n    }\n    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v -= rhs._v;\n        if (_v >= umod()) _v += umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        unsigned long long z = _v;\n        z *= rhs._v;\n        _v = (unsigned int)(z % umod());\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        if (prime) {\n            assert(_v);\n            return pow(umod() - 2);\n        } else {\n            auto eg = internal::inv_gcd(_v, m);\n            assert(eg.first == 1);\n            return eg.second;\n        }\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static constexpr unsigned int umod() { return m; }\n    static constexpr bool prime = internal::is_prime<m>;\n};\n\ntemplate <int id> struct dynamic_modint : internal::modint_base {\n    using mint = dynamic_modint;\n\n  public:\n    static int mod() { return (int)(bt.umod()); }\n    static void set_mod(int m) {\n        assert(1 <= m);\n        bt = internal::barrett(m);\n    }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    dynamic_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        long long x = (long long)(v % (long long)(mod()));\n        if (x < 0) x += mod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        _v = (unsigned int)(v % mod());\n    }\n    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v += mod() - rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        _v = bt.mul(_v, rhs._v);\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        auto eg = internal::inv_gcd(_v, mod());\n        assert(eg.first == 1);\n        return eg.second;\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static internal::barrett bt;\n    static unsigned int umod() { return bt.umod(); }\n};\ntemplate <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n\nusing modint998244353 = static_modint<998244353>;\nusing modint1000000007 = static_modint<1000000007>;\nusing modint = dynamic_modint<-1>;\n\nnamespace internal {\n\ntemplate <class T>\nusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n\ntemplate <class T>\nusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n\ntemplate <class> struct is_dynamic_modint : public std::false_type {};\ntemplate <int id>\nstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n\ntemplate <class T>\nusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n\n    static bool first = true;\n    static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_e[i] = es[i] * now;\n            now *= ies[i];\n        }\n    }\n    for (int ph = 1; ph <= h; ph++) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint now = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p] * now;\n                a[i + offset] = l + r;\n                a[i + offset + p] = l - r;\n            }\n            now *= sum_e[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly_inv(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n\n    static bool first = true;\n    static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_ie[i] = ies[i] * now;\n            now *= es[i];\n        }\n    }\n\n    for (int ph = h; ph >= 1; ph--) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint inow = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p];\n                a[i + offset] = l + r;\n                a[i + offset + p] =\n                    (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                    inow.val();\n            }\n            inow *= sum_ie[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n\n}  // namespace internal\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nstd::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    if (std::min(n, m) <= 60) {\n        if (n < m) {\n            std::swap(n, m);\n            std::swap(a, b);\n        }\n        std::vector<mint> ans(n + m - 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                ans[i + j] += a[i] * b[j];\n            }\n        }\n        return ans;\n    }\n    int z = 1 << internal::ceil_pow2(n + m - 1);\n    a.resize(z);\n    internal::butterfly(a);\n    b.resize(z);\n    internal::butterfly(b);\n    for (int i = 0; i < z; i++) {\n        a[i] *= b[i];\n    }\n    internal::butterfly_inv(a);\n    a.resize(n + m - 1);\n    mint iz = mint(z).inv();\n    for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n    return a;\n}\n\ntemplate <unsigned int mod = 998244353,\n          class T,\n          std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\nstd::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n\n    using mint = static_modint<mod>;\n    std::vector<mint> a2(n), b2(m);\n    for (int i = 0; i < n; i++) {\n        a2[i] = mint(a[i]);\n    }\n    for (int i = 0; i < m; i++) {\n        b2[i] = mint(b[i]);\n    }\n    auto c2 = convolution(move(a2), move(b2));\n    std::vector<T> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        c[i] = c2[i].val();\n    }\n    return c;\n}\n\nstd::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                      const std::vector<long long>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n\n    static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n    static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n    static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n    static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n    static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n    static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n    static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n\n    static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n    static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n    static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n\n    auto c1 = convolution<MOD1>(a, b);\n    auto c2 = convolution<MOD2>(a, b);\n    auto c3 = convolution<MOD3>(a, b);\n\n    std::vector<long long> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        unsigned long long x = 0;\n        x += (c1[i] * i1) % MOD1 * M2M3;\n        x += (c2[i] * i2) % MOD2 * M1M3;\n        x += (c3[i] * i3) % MOD3 * M1M2;\n        // B = 2^63, -B <= x, r(real value) < B\n        // (x, x - M, x - 2M, or x - 3M) = r (mod 2B)\n        // r = c1[i] (mod MOD1)\n        // focus on MOD1\n        // r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B)\n        // r = x,\n        //     x - M' + (0 or 2B),\n        //     x - 2M' + (0, 2B or 4B),\n        //     x - 3M' + (0, 2B, 4B or 6B) (without mod!)\n        // (r - x) = 0, (0)\n        //           - M' + (0 or 2B), (1)\n        //           -2M' + (0 or 2B or 4B), (2)\n        //           -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1)\n        // we checked that\n        //   ((1) mod MOD1) mod 5 = 2\n        //   ((2) mod MOD1) mod 5 = 3\n        //   ((3) mod MOD1) mod 5 = 4\n        long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n        if (diff < 0) diff += MOD1;\n        static constexpr unsigned long long offset[5] = {\n            0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n        x -= offset[diff % 5];\n        c[i] = x;\n    }\n\n    return c;\n}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Implement (union by size) + (path compression)\n// Reference:\n// Zvi Galil and Giuseppe F. Italiano,\n// Data structures and algorithms for disjoint set union problems\nstruct dsu {\n  public:\n    dsu() : _n(0) {}\n    dsu(int n) : _n(n), parent_or_size(n, -1) {}\n\n    int merge(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        int x = leader(a), y = leader(b);\n        if (x == y) return x;\n        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n        parent_or_size[x] += parent_or_size[y];\n        parent_or_size[y] = x;\n        return x;\n    }\n\n    bool same(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        return leader(a) == leader(b);\n    }\n\n    int leader(int a) {\n        assert(0 <= a && a < _n);\n        if (parent_or_size[a] < 0) return a;\n        return parent_or_size[a] = leader(parent_or_size[a]);\n    }\n\n    int size(int a) {\n        assert(0 <= a && a < _n);\n        return -parent_or_size[leader(a)];\n    }\n\n    std::vector<std::vector<int>> groups() {\n        std::vector<int> leader_buf(_n), group_size(_n);\n        for (int i = 0; i < _n; i++) {\n            leader_buf[i] = leader(i);\n            group_size[leader_buf[i]]++;\n        }\n        std::vector<std::vector<int>> result(_n);\n        for (int i = 0; i < _n; i++) {\n            result[i].reserve(group_size[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            result[leader_buf[i]].push_back(i);\n        }\n        result.erase(\n            std::remove_if(result.begin(), result.end(),\n                           [&](const std::vector<int>& v) { return v.empty(); }),\n            result.end());\n        return result;\n    }\n\n  private:\n    int _n;\n    // root node: -1 * component size\n    // otherwise: parent\n    std::vector<int> parent_or_size;\n};\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Reference: https://en.wikipedia.org/wiki/Fenwick_tree\ntemplate <class T> struct fenwick_tree {\n    using U = internal::to_unsigned_t<T>;\n\n  public:\n    fenwick_tree() : _n(0) {}\n    fenwick_tree(int n) : _n(n), data(n) {}\n\n    void add(int p, T x) {\n        assert(0 <= p && p < _n);\n        p++;\n        while (p <= _n) {\n            data[p - 1] += U(x);\n            p += p & -p;\n        }\n    }\n\n    T sum(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        return sum(r) - sum(l);\n    }\n\n  private:\n    int _n;\n    std::vector<U> data;\n\n    U sum(int r) {\n        U s = 0;\n        while (r > 0) {\n            s += data[r - 1];\n            r -= r & -r;\n        }\n        return s;\n    }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n\ntemplate <class S,\n          S (*op)(S, S),\n          S (*e)(),\n          class F,\n          S (*mapping)(F, S),\n          F (*composition)(F, F),\n          F (*id)()>\nstruct lazy_segtree {\n  public:\n    lazy_segtree() : lazy_segtree(0) {}\n    lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n    lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        lz = std::vector<F>(size, id());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        return d[p];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return e();\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push(r >> i);\n        }\n\n        S sml = e(), smr = e();\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    void apply(int p, F f) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = mapping(f, d[p]);\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    void apply(int l, int r, F f) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return;\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n\n        {\n            int l2 = l, r2 = r;\n            while (l < r) {\n                if (l & 1) all_apply(l++, f);\n                if (r & 1) all_apply(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n\n        for (int i = 1; i <= log; i++) {\n            if (((l >> i) << i) != l) update(l >> i);\n            if (((r >> i) << i) != r) update((r - 1) >> i);\n        }\n    }\n\n    template <bool (*g)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return g(x); });\n    }\n    template <class G> int max_right(int l, G g) {\n        assert(0 <= l && l <= _n);\n        assert(g(e()));\n        if (l == _n) return _n;\n        l += size;\n        for (int i = log; i >= 1; i--) push(l >> i);\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!g(op(sm, d[l]))) {\n                while (l < size) {\n                    push(l);\n                    l = (2 * l);\n                    if (g(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*g)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return g(x); });\n    }\n    template <class G> int min_left(int r, G g) {\n        assert(0 <= r && r <= _n);\n        assert(g(e()));\n        if (r == 0) return 0;\n        r += size;\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!g(op(d[r], sm))) {\n                while (r < size) {\n                    push(r);\n                    r = (2 * r + 1);\n                    if (g(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    std::vector<F> lz;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    void all_apply(int k, F f) {\n        d[k] = mapping(f, d[k]);\n        if (k < size) lz[k] = composition(f, lz[k]);\n    }\n    void push(int k) {\n        all_apply(2 * k, lz[k]);\n        all_apply(2 * k + 1, lz[k]);\n        lz[k] = id();\n    }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\nnamespace atcoder {\n\nlong long pow_mod(long long x, long long n, int m) {\n    assert(0 <= n && 1 <= m);\n    if (m == 1) return 0;\n    internal::barrett bt((unsigned int)(m));\n    unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n    while (n) {\n        if (n & 1) r = bt.mul(r, y);\n        y = bt.mul(y, y);\n        n >>= 1;\n    }\n    return r;\n}\n\nlong long inv_mod(long long x, long long m) {\n    assert(1 <= m);\n    auto z = internal::inv_gcd(x, m);\n    assert(z.first == 1);\n    return z.second;\n}\n\n// (rem, mod)\nstd::pair<long long, long long> crt(const std::vector<long long>& r,\n                                    const std::vector<long long>& m) {\n    assert(r.size() == m.size());\n    int n = int(r.size());\n    // Contracts: 0 <= r0 < m0\n    long long r0 = 0, m0 = 1;\n    for (int i = 0; i < n; i++) {\n        assert(1 <= m[i]);\n        long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n        if (m0 < m1) {\n            std::swap(r0, r1);\n            std::swap(m0, m1);\n        }\n        if (m0 % m1 == 0) {\n            if (r0 % m1 != r1) return {0, 0};\n            continue;\n        }\n        // assume: m0 > m1, lcm(m0, m1) >= 2 * max(m0, m1)\n\n        // (r0, m0), (r1, m1) -> (r2, m2 = lcm(m0, m1));\n        // r2 % m0 = r0\n        // r2 % m1 = r1\n        // -> (r0 + x*m0) % m1 = r1\n        // -> x*u0*g % (u1*g) = (r1 - r0) (u0*g = m0, u1*g = m1)\n        // -> x = (r1 - r0) / g * inv(u0) (mod u1)\n\n        // im = inv(u0) (mod u1) (0 <= im < u1)\n        long long g, im;\n        std::tie(g, im) = internal::inv_gcd(m0, m1);\n\n        long long u1 = (m1 / g);\n        // |r1 - r0| < (m0 + m1) <= lcm(m0, m1)\n        if ((r1 - r0) % g) return {0, 0};\n\n        // u1 * u1 <= m1 * m1 / g / g <= m0 * m1 / g = lcm(m0, m1)\n        long long x = (r1 - r0) / g % u1 * im % u1;\n\n        // |r0| + |m0 * x|\n        // < m0 + m0 * (u1 - 1)\n        // = m0 + m0 * m1 / g - m0\n        // = lcm(m0, m1)\n        r0 += x * m0;\n        m0 *= u1;  // -> lcm(m0, m1)\n        if (r0 < 0) r0 += m0;\n    }\n    return {r0, m0};\n}\n\nlong long floor_sum(long long n, long long m, long long a, long long b) {\n    long long ans = 0;\n    if (a >= m) {\n        ans += (n - 1) * n * (a / m) / 2;\n        a %= m;\n    }\n    if (b >= m) {\n        ans += n * (b / m);\n        b %= m;\n    }\n\n    long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n    if (y_max == 0) return ans;\n    ans += (n - (x_max + a - 1) / a) * y_max;\n    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n    return ans;\n}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class T> struct simple_queue {\n    std::vector<T> payload;\n    int pos = 0;\n    void reserve(int n) { payload.reserve(n); }\n    int size() const { return int(payload.size()) - pos; }\n    bool empty() const { return pos == int(payload.size()); }\n    void push(const T& t) { payload.push_back(t); }\n    T& front() { return payload[pos]; }\n    void clear() {\n        payload.clear();\n        pos = 0;\n    }\n    void pop() { pos++; }\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class Cap> struct mf_graph {\n  public:\n    mf_graph() : _n(0) {}\n    mf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        assert(0 <= cap);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result;\n        for (int i = 0; i < m; i++) {\n            result.push_back(get_edge(i));\n        }\n        return result;\n    }\n    void change_edge(int i, Cap new_cap, Cap new_flow) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        assert(0 <= new_flow && new_flow <= new_cap);\n        auto& _e = g[pos[i].first][pos[i].second];\n        auto& _re = g[_e.to][_e.rev];\n        _e.cap = new_cap - new_flow;\n        _re.cap = new_flow;\n    }\n\n    Cap flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    Cap flow(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n\n        std::vector<int> level(_n), iter(_n);\n        internal::simple_queue<int> que;\n\n        auto bfs = [&]() {\n            std::fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            que.clear();\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front();\n                que.pop();\n                for (auto e : g[v]) {\n                    if (e.cap == 0 || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    if (e.to == t) return;\n                    que.push(e.to);\n                }\n            }\n        };\n        auto dfs = [&](auto self, int v, Cap up) {\n            if (v == s) return up;\n            Cap res = 0;\n            int level_v = level[v];\n            for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                _edge& e = g[v][i];\n                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                if (d <= 0) continue;\n                g[v][i].cap += d;\n                g[e.to][e.rev].cap -= d;\n                res += d;\n                if (res == up) break;\n            }\n            return res;\n        };\n\n        Cap flow = 0;\n        while (flow < flow_limit) {\n            bfs();\n            if (level[t] == -1) break;\n            std::fill(iter.begin(), iter.end(), 0);\n            while (flow < flow_limit) {\n                Cap f = dfs(dfs, t, flow_limit - flow);\n                if (!f) break;\n                flow += f;\n            }\n        }\n        return flow;\n    }\n\n    std::vector<bool> min_cut(int s) {\n        std::vector<bool> visited(_n);\n        internal::simple_queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int p = que.front();\n            que.pop();\n            visited[p] = true;\n            for (auto e : g[p]) {\n                if (e.cap && !visited[e.to]) {\n                    visited[e.to] = true;\n                    que.push(e.to);\n                }\n            }\n        }\n        return visited;\n    }\n\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class Cap, class Cost> struct mcf_graph {\n  public:\n    mcf_graph() {}\n    mcf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap, Cost cost) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n        Cost cost;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{\n            pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n        };\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result(m);\n        for (int i = 0; i < m; i++) {\n            result[i] = get_edge(i);\n        }\n        return result;\n    }\n\n    std::pair<Cap, Cost> flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n        return slope(s, t, flow_limit).back();\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n        return slope(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        assert(s != t);\n        // variants (C = maxcost):\n        // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0\n        // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge\n        std::vector<Cost> dual(_n, 0), dist(_n);\n        std::vector<int> pv(_n), pe(_n);\n        std::vector<bool> vis(_n);\n        auto dual_ref = [&]() {\n            std::fill(dist.begin(), dist.end(),\n                      std::numeric_limits<Cost>::max());\n            std::fill(pv.begin(), pv.end(), -1);\n            std::fill(pe.begin(), pe.end(), -1);\n            std::fill(vis.begin(), vis.end(), false);\n            struct Q {\n                Cost key;\n                int to;\n                bool operator<(Q r) const { return key > r.key; }\n            };\n            std::priority_queue<Q> que;\n            dist[s] = 0;\n            que.push(Q{0, s});\n            while (!que.empty()) {\n                int v = que.top().to;\n                que.pop();\n                if (vis[v]) continue;\n                vis[v] = true;\n                if (v == t) break;\n                // dist[v] = shortest(s, v) + dual[s] - dual[v]\n                // dist[v] >= 0 (all reduced cost are positive)\n                // dist[v] <= (n-1)C\n                for (int i = 0; i < int(g[v].size()); i++) {\n                    auto e = g[v][i];\n                    if (vis[e.to] || !e.cap) continue;\n                    // |-dual[e.to] + dual[v]| <= (n-1)C\n                    // cost <= C - -(n-1)C + 0 = nC\n                    Cost cost = e.cost - dual[e.to] + dual[v];\n                    if (dist[e.to] - dist[v] > cost) {\n                        dist[e.to] = dist[v] + cost;\n                        pv[e.to] = v;\n                        pe[e.to] = i;\n                        que.push(Q{dist[e.to], e.to});\n                    }\n                }\n            }\n            if (!vis[t]) {\n                return false;\n            }\n\n            for (int v = 0; v < _n; v++) {\n                if (!vis[v]) continue;\n                // dual[v] = dual[v] - dist[t] + dist[v]\n                //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) + (shortest(s, v) + dual[s] - dual[v])\n                //         = - shortest(s, t) + dual[t] + shortest(s, v)\n                //         = shortest(s, v) - shortest(s, t) >= 0 - (n-1)C\n                dual[v] -= dist[t] - dist[v];\n            }\n            return true;\n        };\n        Cap flow = 0;\n        Cost cost = 0, prev_cost = -1;\n        std::vector<std::pair<Cap, Cost>> result;\n        result.push_back({flow, cost});\n        while (flow < flow_limit) {\n            if (!dual_ref()) break;\n            Cap c = flow_limit - flow;\n            for (int v = t; v != s; v = pv[v]) {\n                c = std::min(c, g[pv[v]][pe[v]].cap);\n            }\n            for (int v = t; v != s; v = pv[v]) {\n                auto& e = g[pv[v]][pe[v]];\n                e.cap -= c;\n                g[v][e.rev].cap += c;\n            }\n            Cost d = -dual[s];\n            flow += c;\n            cost += c * d;\n            if (prev_cost == d) {\n                result.pop_back();\n            }\n            result.push_back({flow, cost});\n            prev_cost = cost;\n        }\n        return result;\n    }\n\n  private:\n    int _n;\n\n    struct _edge {\n        int to, rev;\n        Cap cap;\n        Cost cost;\n    };\n\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\nnamespace internal {\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\nstruct scc_graph {\n  public:\n    scc_graph() : internal(0) {}\n    scc_graph(int n) : internal(n) {}\n\n    void add_edge(int from, int to) {\n        int n = internal.num_vertices();\n        assert(0 <= from && from < n);\n        assert(0 <= to && to < n);\n        internal.add_edge(from, to);\n    }\n\n    std::vector<std::vector<int>> scc() { return internal.scc(); }\n\n  private:\n    internal::scc_graph internal;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\n  public:\n    segtree() : segtree(0) {}\n    segtree(int n) : segtree(std::vector<S>(n, e())) {}\n    segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    template <bool (*f)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F> int max_right(int l, F f) {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*f)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F> int min_left(int r, F f) {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\nstd::vector<int> sa_naive(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n        if (l == r) return false;\n        while (l < n && r < n) {\n            if (s[l] != s[r]) return s[l] < s[r];\n            l++;\n            r++;\n        }\n        return l == n;\n    });\n    return sa;\n}\n\nstd::vector<int> sa_doubling(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n), rnk = s, tmp(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    for (int k = 1; k < n; k *= 2) {\n        auto cmp = [&](int x, int y) {\n            if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n            int rx = x + k < n ? rnk[x + k] : -1;\n            int ry = y + k < n ? rnk[y + k] : -1;\n            return rx < ry;\n        };\n        std::sort(sa.begin(), sa.end(), cmp);\n        tmp[sa[0]] = 0;\n        for (int i = 1; i < n; i++) {\n            tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n        }\n        std::swap(tmp, rnk);\n    }\n    return sa;\n}\n\n// SA-IS, linear-time suffix array construction\n// Reference:\n// G. Nong, S. Zhang, and W. H. Chan,\n// Two Efficient Algorithms for Linear Time Suffix Array Construction\ntemplate <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\nstd::vector<int> sa_is(const std::vector<int>& s, int upper) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    if (n == 1) return {0};\n    if (n == 2) {\n        if (s[0] < s[1]) {\n            return {0, 1};\n        } else {\n            return {1, 0};\n        }\n    }\n    if (n < THRESHOLD_NAIVE) {\n        return sa_naive(s);\n    }\n    if (n < THRESHOLD_DOUBLING) {\n        return sa_doubling(s);\n    }\n\n    std::vector<int> sa(n);\n    std::vector<bool> ls(n);\n    for (int i = n - 2; i >= 0; i--) {\n        ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n    }\n    std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n    for (int i = 0; i < n; i++) {\n        if (!ls[i]) {\n            sum_s[s[i]]++;\n        } else {\n            sum_l[s[i] + 1]++;\n        }\n    }\n    for (int i = 0; i <= upper; i++) {\n        sum_s[i] += sum_l[i];\n        if (i < upper) sum_l[i + 1] += sum_s[i];\n    }\n\n    auto induce = [&](const std::vector<int>& lms) {\n        std::fill(sa.begin(), sa.end(), -1);\n        std::vector<int> buf(upper + 1);\n        std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n        for (auto d : lms) {\n            if (d == n) continue;\n            sa[buf[s[d]]++] = d;\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        sa[buf[s[n - 1]]++] = n - 1;\n        for (int i = 0; i < n; i++) {\n            int v = sa[i];\n            if (v >= 1 && !ls[v - 1]) {\n                sa[buf[s[v - 1]]++] = v - 1;\n            }\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        for (int i = n - 1; i >= 0; i--) {\n            int v = sa[i];\n            if (v >= 1 && ls[v - 1]) {\n                sa[--buf[s[v - 1] + 1]] = v - 1;\n            }\n        }\n    };\n\n    std::vector<int> lms_map(n + 1, -1);\n    int m = 0;\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms_map[i] = m++;\n        }\n    }\n    std::vector<int> lms;\n    lms.reserve(m);\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms.push_back(i);\n        }\n    }\n\n    induce(lms);\n\n    if (m) {\n        std::vector<int> sorted_lms;\n        sorted_lms.reserve(m);\n        for (int v : sa) {\n            if (lms_map[v] != -1) sorted_lms.push_back(v);\n        }\n        std::vector<int> rec_s(m);\n        int rec_upper = 0;\n        rec_s[lms_map[sorted_lms[0]]] = 0;\n        for (int i = 1; i < m; i++) {\n            int l = sorted_lms[i - 1], r = sorted_lms[i];\n            int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n            int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n            bool same = true;\n            if (end_l - l != end_r - r) {\n                same = false;\n            } else {\n                while (l < end_l) {\n                    if (s[l] != s[r]) {\n                        break;\n                    }\n                    l++;\n                    r++;\n                }\n                if (l == n || s[l] != s[r]) same = false;\n            }\n            if (!same) rec_upper++;\n            rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n        }\n\n        auto rec_sa =\n            sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n\n        for (int i = 0; i < m; i++) {\n            sorted_lms[i] = lms[rec_sa[i]];\n        }\n        induce(sorted_lms);\n    }\n    return sa;\n}\n\n}  // namespace internal\n\nstd::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n    assert(0 <= upper);\n    for (int d : s) {\n        assert(0 <= d && d <= upper);\n    }\n    auto sa = internal::sa_is(s, upper);\n    return sa;\n}\n\ntemplate <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n    int n = int(s.size());\n    std::vector<int> idx(n);\n    iota(idx.begin(), idx.end(), 0);\n    sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n    std::vector<int> s2(n);\n    int now = 0;\n    for (int i = 0; i < n; i++) {\n        if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n        s2[idx[i]] = now;\n    }\n    return internal::sa_is(s2, now);\n}\n\nstd::vector<int> suffix_array(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return internal::sa_is(s2, 255);\n}\n\n// Reference:\n// T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,\n// Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its\n// Applications\ntemplate <class T>\nstd::vector<int> lcp_array(const std::vector<T>& s,\n                           const std::vector<int>& sa) {\n    int n = int(s.size());\n    assert(n >= 1);\n    std::vector<int> rnk(n);\n    for (int i = 0; i < n; i++) {\n        rnk[sa[i]] = i;\n    }\n    std::vector<int> lcp(n - 1);\n    int h = 0;\n    for (int i = 0; i < n; i++) {\n        if (h > 0) h--;\n        if (rnk[i] == 0) continue;\n        int j = sa[rnk[i] - 1];\n        for (; j + h < n && i + h < n; h++) {\n            if (s[j + h] != s[i + h]) break;\n        }\n        lcp[rnk[i] - 1] = h;\n    }\n    return lcp;\n}\n\nstd::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return lcp_array(s2, sa);\n}\n\n// Reference:\n// D. Gusfield,\n// Algorithms on Strings, Trees, and Sequences: Computer Science and\n// Computational Biology\ntemplate <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    std::vector<int> z(n);\n    z[0] = 0;\n    for (int i = 1, j = 0; i < n; i++) {\n        int& k = z[i];\n        k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n        while (i + k < n && s[k] == s[i + k]) k++;\n        if (j + z[j] < i + z[i]) j = i;\n    }\n    z[0] = n;\n    return z;\n}\n\nstd::vector<int> z_algorithm(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return z_algorithm(s2);\n}\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n\n}  // namespace atcoder\n\n///////////////////////////////////////////////////////////////////////\n\nusing namespace std;\nusing namespace atcoder;\ntypedef long long ll;\n\n/*\n#define i_7 (ll)(1E9+7)\n//#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\nvoid mod_print(ll k){\n    ll P=50000;\n    rep(y,1,P){\n        ll x=mod(y*k);\n        \n        if(abs(x)<=P||x+P>=i_7){\n            if(x+P>=i_7){\n                x-=i_7;\n            }\n            cout<<x<<\"/\"<<y<<endl;\n            //cout<<setprecision(5)<<(dd)x/(dd)y;\n            return;\n        }\n    }\n    cout<<\"nun\"<<endl;\n}\n#include \"boost/multiprecision/cpp_int.hpp\"\n#include \"boost/multiprecision/cpp_dec_float.hpp\"\nnamespace mp = boost::multiprecision;\ntypedef mp::cpp_int LL;\ntypedef mp::number<mp::cpp_dec_float<1024>> DD;// 仮数部が1024ビットの浮動小数点数型(TLEしたら小さくする)\n*/\ntypedef long double dd;\ntypedef pair<ll,ll> l_l;\ntypedef pair<dd,dd> d_d;\nll inf=(ll)1E16;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define rrep(i,r,l) for(ll i=r;i>=l;i--)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\ndd EPS=1E-12;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define fi first\n#define se second\n\n#define SORT(v) sort(v.begin(),v.end())\n#define ERASE(v) v.erase(unique(v.begin(),v.end()),v.end())\n#define POSL(v,x) (lower_bound(v.begin(),v.end(),x)-v.begin())\n#define POSU(v,x) (upper_bound(v.begin(),v.end(),x)-v.begin())\ntemplate<class T,class S>\ninline bool chmax(T &a, S b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T,class S>\ninline bool chmin(T &a, S b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n#define endl \"\\n\"  //インタラクティブで消す！！！！！！！！！！！！！！！！！！！！！\n#define all(c) c.begin(),c.end()\ntypedef vector<ll> vl;\n\n\n//using mint = modint998244353;\nusing mint = modint1000000007;\n//using mint=modint;\n//////////////////////////\n\nll h,w;\nll pos(ll i,ll j,bool in){\n    if(in)return i*w+j;\n    else return h*w+i*w+j;\n}\nll dx[4]={1,0,-1,0};\nll dy[4]={0,1,0,-1};\nbool valid(ll i,ll j){\n    if(0<=i&&i<=h-1&&0<=j&&j<=w-1)return true;\n    return false;\n}\nint main(){fastio\n    cin>>h>>w;\n    string s[h];rep(i,0,h-1)cin>>s[i];\n    mf_graph<ll>g(h*w*2+2);\n    ll S=h*w*2,T=h*w*2+1;\n    rep(i,0,h-1){\n        rep(j,0,w-1){\n            if(s[i][j]=='X'){\n                g.add_edge(pos(i,j,true),pos(i,j,false),inf);\n            }else{\n                g.add_edge(pos(i,j,true),pos(i,j,false),1);\n            }\n            if(s[i][j]=='X'){\n                g.add_edge(S,pos(i,j,true),inf);\n            }\n            rep(z,0,3){\n                ll ni=i+dx[z];\n                ll nj=j+dy[z];\n                if(valid(ni,nj)){\n                    g.add_edge(pos(i,j,false),pos(ni,nj,true),inf);\n                }else{\n                    if(s[i][j]=='X'){\n                        cout<<-1;return 0;\n                    }\n                    g.add_edge(pos(i,j,false),T,inf);\n                }\n            }\n        }\n    }\n    \n    cout<<g.flow(S,T)<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <iomanip>\n#include <functional>\n\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\ntypedef long long ll;\n\nusing namespace std;\nint dx[4]={0,1,0,-1};\n\nclass FF\n{\npublic:\n  struct edge{int to,cap,rev;};\n  vector<vector<edge>>G;\n  vector<bool> used;\n  FF(int maxv)\n  {\n    G.resize(maxv);\n    used.resize(maxv);\n  }\n  void add_edge(int from,int to,int cap,bool directed=1)\n  {\n    G[from].push_back({to,cap,(int)G[to].size()});\n    G[to].push_back({from,cap*(!directed),(int)G[from].size()-1});\n  }\n  int dfs(int v,int t,int f)\n  {\n    if(v==t)return f;\n    used[v]=1;\n    for(auto &nv:G[v])\n    {\n      if(!used[nv.to] && nv.cap>0)\n      {\n        int d=dfs(nv.to,t,min(f,nv.cap));\n        if(d>0)\n        {\n          nv.cap-=d;\n          G[nv.to][nv.rev].cap+=d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  int solve(int s,int t)\n  {\n    int res=0;\n    while(1)\n    {\n      for(int i=0;i<used.size();i++)used[i]=0;\n      int f=dfs(s,t,(1<<30)-1);\n      if(f==0)break;\n      res+=f;\n    }\n    return res;\n  }\n};\n\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int h,w;\n  cin>>h>>w;\n  vector<string> hw(h);\n  rep(i,h)cin>>hw[i];\n  FF ff(h*w*2+2);\n  int s=h*w*2,t=h*w*2+1;\n  rep(i,h)rep(j,w)rep(k,4)\n  {\n    int y=i+dx[k^1],x=j+dx[k];\n    if(y<0||y>=h||x<0||x>=w)\n    {\n      ff.add_edge((i*w+j)*2+1,t,10000,1);\n      //cout<<h*w+1<<\" \"<<i*w+j<<endl;\n    }\n    else\n    {\n      ff.add_edge((i*w+j)*2+1,(y*w+x)*2,10000,1);\n    }\n  }\n  rep(i,h)rep(j,w)\n  {\n    if(hw[i][j]=='X')\n    {\n      if(i==0||i==h-1||j==0||j==w-1)\n      {\n        cout<<-1<<endl;\n        return 0;\n      }\n      ff.add_edge(s,(i*w+j)*2+1,10000,1);\n    }\n    else\n    {\n      ff.add_edge((i*w+j)*2,(i*w+j)*2+1,1,1);\n    }\n  }\n  cout<<ff.solve(s,t)<<endl;\n\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 105;\nconst int dx[] = {0, 0, -1, +1};\nconst int dy[] = {-1, +1, 0, 0};\n\nint h, w;\nchar a[N][N];\nbool vis[N][N];\n\nbool inside(int x, int y) {\n\treturn x >= 1 && x <= h && y >= 1 && y <= w;\n}\n\nbool dfs(int x, int y) {\n\tvis[x][y] = true;\n\tfor (int dir = 0; dir < 4; ++dir) {\n\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\tif (!inside(nx, ny)) return true; // can move outside\n\t\tif (vis[nx][ny] || a[nx][ny] != '.') continue; // consider 'X' if get WA\n\t\tif (dfs(nx, ny)) return true;\n\t}\n\treturn false;\n}\n\nbool can(int x, int y) {\n\tfor (int dir = 0; dir < 4; ++dir) {\n\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\tif (inside(nx, ny) && a[nx][ny] == 'X') {\n\t\t\tmemset(vis, 0, sizeof vis);\n\t\t\tif (dfs(nx, ny)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> h >> w;\n\tfor (int i = 1; i <= h; ++i) {\n\t\tfor (int j = 1; j <= w; ++j) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= h; ++i) {\n\t\tfor (int j = 1; j <= w; ++j) {\n\t\t\tif (a[i][j] == 'X') {\n\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\tint x = i + dx[dir], y = j + dy[dir];\n\t\t\t\t\tif (!inside(x, y)) return printf(\"-1\\n\"), 0;\n\t\t\t\t\tif (a[x][y] == '.') a[x][y] = 'o'; // fence\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint res = 0;\n\tfor (int i = 1; i <= h; ++i) {\n\t\tfor (int j = 1; j <= w; ++j) if (a[i][j] == 'o') {\n\t\t\t++res;\n\t\t\ta[i][j] = '.';\n\t\t\tif (!can(i, j)) --res;\n\t\t\telse a[i][j] = 'o';\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n \nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n \nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n \ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size()+3)mk();\n\t\tif(hit==(q.size()<<1)+6)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n \nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,1){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==1){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n//\trep(i,1,n){\n//\t\trep(j,1,m)cout<<x[i][j];\n//\t\tcout<<endl;\n//\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n\tint h, w;\n\tcin >> h >> w;\n\tchar s[105][105];\n\tfor(int i = 1; i <= h; i++){\n\t\tfor(int j = 1; j <= w; j++){\n\t\t\tcin >> s[i][j];\n\t\t}\n\t}\n\tfor(int i = 1; i <= h; i++){\n\t\tfor(int j = 1; j <= w; j++){\n\t\t\tif(s[i][j] == 'X'){\n\t\t\t\tif(i == 1 || j == 1 || i == h || j == w){\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\ts[i - 1][j] = '#';\n\t\t\t\ts[i][j - 1] = '#';\n\t\t\t\ts[i + 1][j] = '#';\n\t\t\t\ts[i][j + 1] = '#';\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<bool> > ischecked(105, vector<bool>(105, false));\n\tint dx[4] = {0, 1, 0, -1};\n\tint dy[4] = {1, 0, -1, 0};\n\tint ans = 0;\n\tischecked[0][0] = true;\n\tqueue<pair<int, int> > qu;\n\tqu.push(make_pair(0, 0));\n\twhile(!qu.empty()){\n\t\tint x = (qu.front()).first;\n\t\tint y = (qu.front()).second;\n\t\tqu.pop();\n\t\tfor(int k = 0; k < 4; k++){\n\t\t\tint nx = x + dx[k];\n\t\t\tint ny = y + dy[k];\n\t\t\tif(nx < 0 || ny < 0 || nx > h + 1 || ny > w + 1 || ischecked[nx][ny]) continue;\n\t\t\tischecked[nx][ny] = true;\n\t\t\tif(s[nx][ny] == '#') ans++;\n\t\t\telse if(s[nx][ny] == '.') qu.push(make_pair(nx, ny));\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<array>\n#include<algorithm>\n#include<list>\n#include<cmath>\n#include<iomanip>\n#include<queue>\n#include<functional>\n#include<climits>\n#include<iterator>\n#include<unordered_set>\n#include<unordered_map>\n#include<map>\n#include<set>\n#include<typeinfo>\nusing namespace std;\n\nconst double pi=4*atan(1.0);\n\nconstexpr long long mod=static_cast<long long>(1e9+7);\n\nusing cWeightEdges=vector<vector<pair<int,int>>>;\nusing cEdges=vector<vector<int>>;\n\nbool dfs(int x,int y,vector<string>& a,vector<vector<int>>& memo){\n\tmemo[x][y]=INT_MAX;\n\tif(x==0 || x==memo.size()-1 || y==0 || memo[x].size()-1){\n\t\tmemo[x][y]=-1;\n\t\treturn false;\n\t}\n\n\tbool ans=true;\n\tif(memo[x-1][y]==0){\n\t\tif(a[x-1][y]=='.')ans&=dfs(x-1,y,a,memo);\n\t}\n\telse if(memo[x-1][y]==-1)ans=false;\n\n\tif(memo[x+1][y]==0){\n\t\tif(a[x+1][y]=='.')ans&=dfs(x+1,y,a,memo);\n\t}\n\telse if(memo[x+1][y]==-1)ans=false;\n\tif(memo[x][y-1]==0){\n\t\tif(a[x][y-1]=='.')ans=dfs(x,y-1,a,memo);\n\t}\n\telse if(memo[x][y-1]==-1)ans=false;\n\n\tif(memo[x][y+1]==0){\n\t\tif(a[x][y+1]=='.')ans&=dfs(x,y+1,a,memo);\n\t}\n\telse if(memo[x][y+1]==-1)ans=false;\n\n\tif(ans){\n\t\tmemo[x][y]=1;\n\t\ta[x][y]='#';\n\t\treturn true;\n\t}\n\telse{\n\t\tmemo[x][y]=-1;\n\t\treturn true;\n\t}\n}\n\nvoid fill_blanck(vector<string>& a,int H,int W){\n\tvector<vector<int>> memo(H,vector<int>(W,0));\n\tfor(int i=0;i<H;++i){\n\t\tfor(int j=0;j<W;++j){\n\t\t\tif(a[i][j]=='.'){\n\t\t\t\tdfs(i,j,a,memo);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint H,W;\n\tcin>>H>>W;\n\tvector<string> a(H);\n\tfor(auto& val:a)\n\t\tcin>>val;\n\n\tbool IsEdge=false;\n\tfor(int i=0;i<H;++i){\n\t\tfor(int j=0;j<W;++j){\n\t\t\tif(a[i][j]=='X'){\n\t\t\t\tif(i==0 || i==H-1 || j==0 || j==W-1){\n\t\t\t\t\tIsEdge=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif(a[i-1][j]!='X')a[i-1][j]='#';\n\t\t\t\tif(a[i+1][j]!='X')a[i+1][j]='#';\n\t\t\t\tif(a[i][j-1]!='X')a[i][j-1]='#';\n\t\t\t\tif(a[i][j+1]!='X')a[i][j+1]='#';\n\t\t\t}\n\t\t}\n\t}\n\n\tif(IsEdge){\n\t\tcout<<-1<<endl;\n\t}\n\telse{\n\n\t\tfill_blanck(a,H,W);\n\n\t\tfor(int i=1;i<H-1;++i){\n\t\t\tfor(int j=1;j<W-1;++j){\n\t\t\t\tif(a[i][j]=='#'){\n\t\t\t\t\tbool CanErase=true;\n\t\t\t\t\tif(a[i-1][j]=='.')CanErase=false;\n\t\t\t\t\tif(a[i+1][j]=='.')CanErase=false;\n\t\t\t\t\tif(a[i][j-1]=='.')CanErase=false;\n\t\t\t\t\tif(a[i][j+1]=='.')CanErase=false;\n\n\t\t\t\t\tif(CanErase)a[i][j]='%';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans=0;\n\t\tfor(int i=0;i<H;++i){\n\t\t\tfor(int j=0;j<W;++j){\n\t\t\t\tif(a[i][j]=='#')++ans;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct MaxFlowDinic {\n\ttypedef int flow_t;\n\tstruct Edge {\n\t\tint next;\n\t\tsize_t inv; /* inverse edge index */\n\t\tflow_t res; /* residual */\n\t};\n\tint n;\n\tvector<vector<Edge>> G;\n\tvector<int> q, l, start;\n\n\tvoid init(int _n) {\n\t\tn = _n;\n\t\tG.resize(n);\n\t\tfor (int i = 0; i < n; i++) G[i].clear();\n\t}\n\tvoid add_edge(int s, int e, flow_t cap, flow_t caprev = 0) {\n\t\tEdge forward{ e, G[e].size(), cap };\n\t\tEdge reverse{ s, G[s].size(), caprev };\n\t\tG[s].push_back(forward);\n\t\tG[e].push_back(reverse);\n\t}\n\tbool assign_level(int source, int sink) {\n\t\tint t = 0;\n\t\tmemset(&l[0], 0, sizeof(l[0]) * l.size());\n\t\tl[source] = 1;\n\t\tq[t++] = source;\n\t\tfor (int h = 0; h < t && !l[sink]; h++) {\n\t\t\tint cur = q[h];\n\t\t\tfor (const auto& e : G[cur]) {\n\t\t\t\tif (l[e.next] || e.res == 0) continue;\n\t\t\t\tl[e.next] = l[cur] + 1;\n\t\t\t\tq[t++] = e.next;\n\t\t\t}\n\t\t}\n\t\treturn l[sink] != 0;\n\t}\n\tflow_t block_flow(int cur, int sink, flow_t current) {\n\t\tif (cur == sink) return current;\n\t\tfor (int& i = start[cur]; i < G[cur].size(); i++) {\n\t\t\tauto& e = G[cur][i];\n\t\t\tif (e.res == 0 || l[e.next] != l[cur] + 1) continue;\n\t\t\tif (flow_t res = block_flow(e.next, sink, min(e.res, current))) {\n\t\t\t\te.res -= res;\n\t\t\t\tG[e.next][e.inv].res += res;\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tflow_t solve(int source, int sink) {\n\t\tq.resize(n);\n\t\tl.resize(n);\n\t\tstart.resize(n);\n\t\tflow_t ans = 0;\n\t\twhile (assign_level(source, sink)) {\n\t\t\tmemset(&start[0], 0, sizeof(start[0]) * n);\n\t\t\twhile (flow_t flow = block_flow(source, sink, numeric_limits<flow_t>::max()))\n\t\t\t\tans += flow;\n\t\t}\n\t\treturn ans;\n\t}\n};\n\nconst int inf = 1e5;\nconst int MAXN = 105;\n\nint N, M;\nchar S[MAXN][MAXN];\nint in[MAXN][MAXN], out[MAXN][MAXN];\nint source, sink, v;\n\nint px[4] = {1,-1,0,0};\nint py[4] = {0,0,1,-1};\n\nint main() {\n\tscanf(\"%d%d\",&N,&M);\n\tfor (int i = 1; i <= N; i++) {\n\t\tscanf(\"%s\", S[i]+1);\n\t}\n\tsource = 0;\n\tsink = N*M*2 + 1;\n\tv = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= M; j++) {\n\t\t\tin[i][j] = ++v;\n\t\t\tout[i][j] = ++v;\n\t\t}\n\t}\n\tMaxFlowDinic f;\n\tf.init(2*N*M + 2);\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= M; j++) {\n\t\t\tif (S[i][j] == 'X') {\n\t\t\t\tif (i == 1 || i == N || j == 1 || j == M) {\n\t\t\t\t\tf.add_edge(source, in[i][j], inf);\n\t\t\t\t}\n\t\t\t\tf.add_edge(in[i][j], out[i][j], inf);\n\t\t\t\tf.add_edge(out[i][j], sink, inf);\n\t\t\t} else {\n\t\t\t\tif (i == 1 || i == N || j == 1 || j == M) {\n\t\t\t\t\tf.add_edge(source, in[i][j], 1);\n\t\t\t\t}\n\t\t\t\tf.add_edge(in[i][j], out[i][j], 1);\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint x = i + px[k];\n\t\t\t\t\tint y = j + py[k];\n\t\t\t\t\tif (1 <= x && x <= N && 1 <= y && y <= M) {\n\t\t\t\t\t\tf.add_edge(out[i][j], in[x][y], inf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint flow = f.solve(source, sink);\n\tif (flow >= inf) puts(\"-1\");\n\telse printf(\"%d\\n\", flow);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n\nint n,m,nr,nc,cnt,ans,hit,tmp;\nchar x[105][105],y[105][105];\nbool fr[105][105],vis[105][105],st,ad;\nqueue<pii> q;\n\nvoid dfs(int r,int c){\n\tvis[r][c] = 1;\n\trep(k,0,3){\n\t\tif(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs(r+dr[k],c+dc[k]);\n\t\tif(fr[r+dr[k]][c+dc[k]])fr[r][c] = 1;\n\t}\n\treturn;\n}\nvoid dfs2(int r,int c){\n\tvis[r][c] = 1;\n\tfr[r][c] = 1;\n\trep(k,0,3)if(!vis[r+dr[k]][c+dc[k]]&&x[r+dr[k]][c+dc[k]]!='#')dfs2(r+dr[k],c+dc[k]);\n\treturn;\n}\n\ninline void mk(){\n\tmemset(fr,0,sizeof fr);\n\tmemset(vis,0,sizeof vis);\n\trep(i,1,n)vis[i][0] = vis[i][m+1] = fr[i][0] = fr[i][m+1] = 1;\n\trep(i,1,m)vis[0][i] = vis[n+1][i] = fr[0][i] = fr[n+1][i] = 1;\n\trep(i,1,n){\n\t\tif(!vis[i][1]&&x[i][1]!='#')dfs(i,1);\n\t\tif(!vis[i][m]&&x[i][m]!='#')dfs(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(!vis[1][i]&&x[1][i]!='#')dfs(1,i);\n\t\tif(!vis[n][i]&&x[n][i]!='#')dfs(n,i);\n\t}\n\trep(i,1,n)rep(j,1,m)vis[i][j] = 0;\n\trep(i,1,n){\n\t\tif(fr[i][1])dfs2(i,1);\n\t\tif(fr[i][m])dfs2(i,m);\n\t}\n\trep(i,1,m){\n\t\tif(fr[1][i])dfs2(1,i);\n\t\tif(fr[n][i])dfs2(n,i);\n\t}\n}\nint r,c;\ninline void solve(){\n\tmk();\n\thit = 0;\n\twhile(!q.empty())q.pop();\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')q.push({i,j});\n\twhile(1){\n\t\tif(q.empty())break;\n\t\tif(hit==q.size())mk();\n\t\tif(hit==q.size()<<1)break;\n\t\tr = q.front().fi, c = q.front().se; q.pop();\n\t\tif(r==1||r==n||c==1||c==m)continue;\n\t\tcnt = 0;\n\t\trep(k,0,3)if(fr[r+dr[k]][c+dc[k]])++cnt, nr = r+dr[k], nc = c+dc[k];\n\t\tif(cnt==1)fr[nr][nc] = 0, q.push({nr,nc}), x[r][c] = '.', x[nr][nc] = '#', hit = 0;\n\t\telse if(!cnt)x[r][c] = '.', hit = 0;\n\t\telse q.push({r,c}), ++hit;\n\t}\n\ttmp = 0;\n\trep(i,1,n)rep(j,1,m)if(x[i][j]=='#')++tmp;\n}\n\nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,n)rep(j,1,m){\n    \tcin>>x[i][j];\n    \tif(x[i][j]=='X'&&(i==1||i==n||j==1||j==m))return cout<<\"-1\\n\",0;\n\t}\n\trep(i,1,n)rep(j,1,m){\n\t\tif(x[i][j]=='X')rep(k,0,3)if(x[i+dr[k]][j+dc[k]]=='.')x[i+dr[k]][j+dc[k]] = '#';\n\t}\n\tint a,b;\n\tsolve();\n\tans = tmp;\n\trep(i,1,n)rep(j,1,m)y[i][j] = x[i][j];\n\tst = 1;\n\twhile(st){\n\t\tst = 0;\n\t\trep(i,1,n)rep(j,1,m){\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,3){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==3){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,++b;\n\t\t\t}\n\t\t\ta = i, b = j;\n\t\t\trep(k,1,3){\n\t\t\t\tif(x[a][b]!='#')break;\n\t\t\t\tif(k==3){\n\t\t\t\t\tad = 0;\n\t\t\t\t\trep(o,b+1,m)if(x[a][o]=='#'){ad = 1; break;}\n\t\t\t\t\tif(ad){\n\t\t\t\t\t\trep(o,b+1,m){\n\t\t\t\t\t\t\tif(x[a][o]=='#')break;\n\t\t\t\t\t\t\tx[a][o] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tif(ans>tmp){\n\t\t\t\t\t\t\tans = tmp;\n\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans==tmp){\n\t\t\t\t\t\t\tad = 0;\n\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)if(x[I][J] != y[I][J]){ad = 1; break;}\n\t\t\t\t\t\t\tif(ad){\n\t\t\t\t\t\t\t\tst = 1;\n\t\t\t\t\t\t\t\trep(I,1,n)rep(J,1,m)y[I][J] = x[I][J];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse rep(I,1,n)rep(J,1,m)x[I][J] = y[I][J];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++a,--b;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n){\n\t\trep(j,1,m)cout<<x[i][j];\n\t\tcout<<endl;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "Lua",
    "code": "local mmi, mma = math.min, math.max\nlocal MPM = {}\n\nMPM.initialize = function(self, n, spos, tpos)\n  self.n = n\n  self.spos, self.tpos = spos, tpos\n  -- edge_dst[src][i] := dst\n  self.edge_dst = {}\n  -- edge_cap[src][i] := capacity from src to edge_dst[src][i]\n  self.edge_cap = {}\n  -- edge_dst_invedge_idx[src][i] := \"j\" where edge_dst[dst][j] == src\n  -- in this case, edge_dst_invedge_idx[dst][j] should be \"i\".\n  self.edge_dst_invedge_idx = {}\n  -- level[v] := length from spos. level[spos] := 1\n  self.level = {}\n  -- level_vertex_count[i] := count of vertexes that levels are i\n  self.level_vertex_count = {}\n  -- sub_graph_v[i] := list of vertexes that are contained in the sub-graph.\n  self.sub_graph_v = {}\n  -- sub_graph_size := the size of sub_graph_v.\n  -- may not equal to #sub_graph_v (because not cleared).\n  self.sub_graph_size = 0\n  -- sub_graph_flag[v] := whether to contains the vertex v in the sub-graph or not\n  self.sub_graph_flag = {}\n  -- send[v] := sum of sendable amount from v to other vertexes in the sub-graph\n  self.send = {}\n  -- receive[v] := sum of receivable amount toward v from other vertexes in the sub-graph\n  self.receive = {}\n  -- sub_edge_idxes[src][i] := edge (from v) using in the sub-graph.\n  -- for example, if sub_edge_idxes[src][i] is j,\n  -- the edge from src to dst (= edge_dst[src][j]) contains in the sub-graph.\n  self.sub_edge_idxes = {}\n  -- sub_edge_cnt[src] := the size of sub_edge_idxes[src].\n  -- may not equal to #sub_edge_idxes[src] (because not cleared).\n  self.sub_edge_cnt = {}\n  -- sub_invedge_idxes[dst] := edge (to dst) using in the sub-graph.\n  -- for example, if sub_invedge_idxes[dst][i] is j,\n  -- the src is edge_dst[dst][j], and the edge index (from src to dst) is k := edge_dst_invedge_idx[dst][j].\n  -- so edge_dst[src][k] is the edge from src to dst using in the sub-graph.\n  self.sub_invedge_idxes = {}\n  -- sub_invedge_cnt[dst] := the size of sub_invedge_idxes[dst].\n  -- may not equal to #sub_invedge_idxes[dst] (because not cleared).\n  self.sub_invedge_cnt = {}\n  -- flow_route[v] := [for \"flowToT\"] whether to contain in the route from weak_vertex to tpos.\n  self.flow_route = {}\n  -- actual_flow_amount[v] := [for \"flowToT\"] send amount from v\n  self.actual_flow_amount = {}\n  for i = 1, n do\n    self.edge_dst[i] = {}\n    self.edge_cap[i] = {}\n    self.edge_dst_invedge_idx[i] = {}\n    self.level[i] = 0\n    self.level_vertex_count[i] = 0\n    self.sub_graph_flag[i] = false\n    self.send[i] = 0\n    self.receive[i] = 0\n    self.sub_edge_idxes[i] = {}\n    self.sub_edge_cnt[i] = 0\n    self.sub_invedge_idxes[i] = {}\n    self.sub_invedge_cnt[i] = 0\n    self.flow_route[i] = false\n    self.actual_flow_amount[i] = 0\n  end\nend\n\nMPM.addEdge = function(self, src, dst, cap, invcap)\n  if not invcap then invcap = 0 end\n  table.insert(self.edge_dst[src], dst)\n  table.insert(self.edge_cap[src], cap)\n  table.insert(self.edge_dst_invedge_idx[src], 1 + #self.edge_dst[dst])\n  table.insert(self.edge_dst[dst], src)\n  table.insert(self.edge_cap[dst], invcap)\n  table.insert(self.edge_dst_invedge_idx[dst], #self.edge_dst[src])\nend\nMPM.makeSubGraph = function(self)\n  local inf = self.n + 2\n  local level, sub_graph_flag = self.level, self.sub_graph_flag\n  local edge_dst, edge_cap = self.edge_dst, self.edge_cap\n  local edge_dst_invedge_idx = self.edge_dst_invedge_idx\n  local send, receive = self.send, self.receive\n  local sub_graph_v = self.sub_graph_v\n  local sub_edge_idxes, sub_edge_cnt = self.sub_edge_idxes, self.sub_edge_cnt\n  local sub_invedge_idxes, sub_invedge_cnt = self.sub_invedge_idxes, self.sub_invedge_cnt\n  local level_vertex_count = self.level_vertex_count\n  for i = 1, self.n do\n    level[i] = inf\n    sub_graph_flag[i] = false\n    send[i], receive[i] = 0, 0\n    sub_edge_cnt[i] = 0\n    sub_invedge_cnt[i] = 0\n    level_vertex_count[i] = 0\n  end\n  -- BFS\n  level[self.spos] = 1\n  local taskcnt, done = 1, 0\n  sub_graph_v[1] = self.spos\n  local reached = false\n  while done < taskcnt do\n    done = done + 1\n    local src = sub_graph_v[done]\n    if src == self.tpos then reached = true break end\n    for i = 1, #edge_dst[src] do\n      local cap = edge_cap[src][i]\n      if 0 < cap then\n        local dst = edge_dst[src][i]\n        if level[dst] == inf then\n          level[dst] = level[src] + 1\n          taskcnt = taskcnt + 1\n          sub_graph_v[taskcnt] = dst\n        elseif level[dst] == level[src] + 1 then\n        end\n      end\n    end\n  end\n  if not reached then\n    self.sub_graph_size = 0\n    return false\n  end\n  -- restore route\n  sub_graph_flag[self.tpos] = true\n  local curlevel = level[self.tpos]\n  while curlevel == level[sub_graph_v[taskcnt]] do\n    taskcnt = taskcnt - 1\n  end\n  for isrc = taskcnt, 1, -1 do\n    local src = sub_graph_v[isrc]\n    for i = 1, #edge_dst[src] do\n      local dst, cap = edge_dst[src][i], edge_cap[src][i]\n      if 0 < cap and sub_graph_flag[dst]\n      and level[dst] == level[src] + 1 then\n        sub_graph_flag[src] = true\n        local edgecnt = sub_edge_cnt[src] + 1\n        sub_edge_cnt[src] = edgecnt\n        sub_edge_idxes[src][edgecnt] = i\n        sub_invedge_cnt[dst] = sub_invedge_cnt[dst] + 1\n        sub_invedge_idxes[dst][sub_invedge_cnt[dst]] = edge_dst_invedge_idx[src][i]\n        send[src] = send[src] + cap\n        receive[dst] = receive[dst] + cap\n      end\n    end\n    if not sub_graph_flag[src] then\n      for i = 1, #edge_dst[src] do\n        local dst = edge_dst[src][i]\n        local cap = edge_cap[src][i]\n        if 0 < cap and level[dst] == level[src] + 1 then\n          send[src] = send[src] - cap\n          receive[dst] = receive[dst] - cap\n        end\n      end\n    end\n  end\n  -- remove unused vertex from \"taskcnt\" and set as sub_graph_size\n  local nodecnt = 1\n  for i = 1, taskcnt do\n    local v = sub_graph_v[i]\n    if sub_graph_flag[v] then\n      sub_graph_v[nodecnt] = v\n      local lv = level[v]\n      level_vertex_count[lv] = level_vertex_count[lv] + 1\n      nodecnt = nodecnt + 1\n    end\n  end\n  if sub_graph_v[nodecnt - 1] == self.tpos then\n    nodecnt = nodecnt - 1\n  else\n    sub_graph_v[nodecnt] = self.tpos\n    local lv = level[self.tpos]\n    level_vertex_count[lv] = level_vertex_count[lv] + 1\n  end\n  self.sub_graph_size = nodecnt\n  return true\nend\n\nMPM.subGraphConnected = function(self)\n  local max_level = self.level[self.tpos]\n  local level_vertex_count = self.level_vertex_count\n  for i = 1, max_level do\n    if level_vertex_count[i] <= 0 then return false end\n  end\n  return true\nend\n\nMPM.findWeakVertex = function(self)\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_size = self.sub_graph_size\n  local send, receive = self.send, self.receive\n  local min_vertex = self.spos\n  local min_potential = send[min_vertex]\n  if receive[self.tpos] < min_potential then\n    min_vertex = self.tpos\n    min_potential = receive[min_vertex]\n  end\n  for i = 2, sub_graph_size - 1 do\n    local v = sub_graph_v[i]\n    local min_v = mmi(send[v], receive[v])\n    if min_v < min_potential then\n      min_potential, min_vertex = min_v, v\n    end\n  end\n  return min_vertex, min_potential\nend\n\nMPM.flowToT = function(self, weak_vertex, potential)\n  if weak_vertex == self.tpos then return end\n  local sub_graph_flag = self.sub_graph_flag\n  local edge_dst, edge_cap = self.edge_dst, self.edge_cap\n  local edge_dst_invedge_idx = self.edge_dst_invedge_idx\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_size = self.sub_graph_size\n  local sub_edge_cnt = self.sub_edge_cnt\n  local sub_edge_idxes = self.sub_edge_idxes\n  local send, receive = self.send, self.receive\n  local level = self.level\n  local flow_route = self.flow_route\n  local actual_flow_amount = self.actual_flow_amount\n  local tpos = self.tpos\n  for i = 1, sub_graph_size do\n    local v = sub_graph_v[i]\n    flow_route[v] = false\n    actual_flow_amount[v] = 0\n  end\n  flow_route[weak_vertex] = true\n  actual_flow_amount[weak_vertex] = potential\n  local weak_vertex_level = level[weak_vertex]\n  local max_level = level[tpos]\n  for iv = 1, sub_graph_size do\n    local src = sub_graph_v[iv]\n    local lv = level[src]\n    if lv == max_level then break end\n    local need_to_send = actual_flow_amount[src]\n    if flow_route[src] and 0 < need_to_send then\n      send[src] = send[src] - need_to_send\n      local sub_edge_idxes_src = sub_edge_idxes[src]\n      local dsts, caps, invidxes = edge_dst[src], edge_cap[src], edge_dst_invedge_idx[src]\n      local used = 0\n      -- use edge in descending order, to remove used edges quickly\n      for j = sub_edge_cnt[src], 1, -1 do\n        local edgeidx = sub_edge_idxes_src[j]\n        local dst, cap = dsts[edgeidx], caps[edgeidx]\n        local actual_flow = mmi(cap, need_to_send)\n        receive[dst] = receive[dst] - actual_flow\n        caps[edgeidx] = caps[edgeidx] - actual_flow\n        need_to_send = need_to_send - actual_flow\n        flow_route[dst] = true\n        actual_flow_amount[dst] = actual_flow_amount[dst] + actual_flow\n        local inv_edge_idx = invidxes[edgeidx]\n        edge_cap[dst][inv_edge_idx] = edge_cap[dst][inv_edge_idx] + actual_flow\n        if caps[edgeidx] == 0 then\n          used = used + 1\n        end\n        if need_to_send == 0 then\n          break\n        end\n      end\n      sub_edge_cnt[src] = sub_edge_cnt[src] - used\n    end\n  end\nend\n\nMPM.flowFromS = function(self, weak_vertex, potential)\n  if weak_vertex == self.spos then return end\n  local sub_graph_flag = self.sub_graph_flag\n  local edge_dst, edge_cap = self.edge_dst, self.edge_cap\n  local edge_dst_invedge_idx = self.edge_dst_invedge_idx\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_size = self.sub_graph_size\n  local sub_edge_cnt = self.sub_edge_cnt\n  local sub_edge_idxes = self.sub_edge_idxes\n  local sub_invedge_idxes = self.sub_invedge_idxes\n  local sub_invedge_cnt = self.sub_invedge_cnt\n  local send, receive = self.send, self.receive\n  local level = self.level\n  local flow_route = self.flow_route\n  local actual_flow_amount = self.actual_flow_amount\n  local spos = self.spos\n  for i = 1, sub_graph_size do\n    local v = sub_graph_v[i]\n    flow_route[v] = false\n    actual_flow_amount[v] = 0\n  end\n  flow_route[weak_vertex] = true\n  actual_flow_amount[weak_vertex] = potential\n  local weak_vertex_level = level[weak_vertex]\n  local max_level = level[tpos]\n  for iv = sub_graph_size, 1, -1 do\n    local dst = sub_graph_v[iv]\n    local lv = level[dst]\n    if lv == 1 then break end\n    local need_to_receive = actual_flow_amount[dst]\n    if flow_route[dst] and 0 < need_to_receive then\n      receive[dst] = receive[dst] - need_to_receive\n      local sub_invedge_idxes_dst = sub_invedge_idxes[dst]\n      local srcs = edge_dst[dst]\n      local inv_invidxes = edge_dst_invedge_idx[dst]\n      -- local dsts, caps, invidxes = edge_dst[src], edge_cap[src], edge_dst_invedge_idx[src]\n      local used = 0\n      -- use edge in descending order, to remove used edges quickly\n      for j = sub_invedge_cnt[dst], 1, -1 do\n        local invedgeidx = sub_invedge_idxes_dst[j]\n        local src = srcs[invedgeidx]\n        local edgeidx = inv_invidxes[invedgeidx]\n        assert(edge_dst[src][edgeidx] == dst)\n        local cap = edge_cap[src][edgeidx]\n        local actual_flow = mmi(cap, need_to_receive)\n\n        send[src] = send[src] - actual_flow\n        edge_cap[src][edgeidx] = edge_cap[src][edgeidx] - actual_flow\n        need_to_receive = need_to_receive - actual_flow\n        flow_route[src] = true\n        actual_flow_amount[src] = actual_flow_amount[src] + actual_flow\n        edge_cap[dst][invedgeidx] = edge_cap[dst][invedgeidx] + actual_flow\n        if edge_cap[src][edgeidx] == 0 then\n          used = used + 1\n        end\n        if need_to_receive == 0 then\n          break\n        end\n      end\n      sub_invedge_cnt[dst] = sub_invedge_cnt[dst] - used\n    end\n  end\nend\n\nMPM.updateSubGraph = function(self)\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_size = self.sub_graph_size\n  local sub_graph_flag = self.sub_graph_flag\n  local send, receive = self.send, self.receive\n  local spos, tpos = self.spos, self.tpos\n  local level = self.level\n  local level_vertex_count = self.level_vertex_count\n  local sub_edge_idxes = self.sub_edge_idxes\n  local sub_edge_cnt = self.sub_edge_cnt\n  local edge_dst = self.edge_dst\n  local sub_invedge_idxes = self.sub_invedge_idxes\n  local sub_invedge_cnt = self.sub_invedge_cnt\n  local nodecnt = 0\n  for i = 1, sub_graph_size do\n    local v = sub_graph_v[i]\n    local valid = true\n    if v ~= spos and receive[v] <= 0 then valid = false end\n    if v ~= tpos and send[v] <= 0 then valid = false end\n    if valid then\n      local sub_invedge_idxes_v = sub_invedge_idxes[v]\n      valid = false\n      for j = 1, sub_invedge_cnt[v] do\n        local ei = sub_invedge_idxes_v[j]\n        local src = edge_dst[v][ei]\n        if sub_graph_flag[src] then valid = true break end\n      end\n    end\n    if valid then\n      nodecnt = nodecnt + 1\n      sub_graph_v[nodecnt] = v\n    else\n      sub_graph_flag[v] = false\n      local lv = level[v]\n      level_vertex_count[lv] = level_vertex_count[lv] - 1\n    end\n  end\n  sub_graph_size = nodecnt\n  for i = sub_graph_size, 1, -1 do\n    local v = sub_graph_v[i]\n    local valid = false\n    local sub_edge_idxes_v = sub_edge_idxes[v]\n    for j = 1, sub_edge_cnt[v] do\n      local ei = sub_edge_idxes_v[j]\n      local dst = edge_dst[v][ei]\n      if sub_graph_flag[dst] then valid = true break end\n    end\n    if not valid then\n      sub_graph_flag[v] = false\n      local lv = level[v]\n      level_vertex_count[lv] = level_vertex_count[lv] - 1\n    end\n  end\n  nodecnt = 0\n  for i = 1, sub_graph_size do\n    local v = sub_graph_v[i]\n    if sub_graph_v[v] then\n      nodecnt = nodecnt + 1\n      sub_graph_v[nodecnt] = v\n    end\n  end\n  self.sub_graph_size = nodecnt\nend\n\nMPM.partialwork = function(self)\n  local sum = 0\n  while(self:subGraphConnected()) do\n    local weak_vertex, potential = self:findWeakVertex()\n    self:flowToT(weak_vertex, potential)\n    self:flowFromS(weak_vertex, potential)\n    self:updateSubGraph()\n    sum = sum + potential\n  end\n  return sum\nend\n\nMPM.getMaxFlow = function(self)\n  local ret = 0\n  while(self:makeSubGraph()) do\n    ret = ret + self:partialwork()\n  end\n  return ret\nend\n\nlocal h, w = io.read(\"*n\", \"*n\", \"*l\")\nlocal spos = h * w * 2 + 1\nlocal tpos = spos + 1\nMPM:initialize(tpos, spos, tpos)\nlocal t = {}\nlocal inf = 1000000007\nlocal tasks = {}\nfor i = 1, h do\n  local s = io.read()\n  for j = 1, w do\n    local idx = (i - 1) * w + j\n    if s:sub(j, j) == \"X\" then\n      t[idx] = 0\n      MPM:addEdge(spos, idx * 2, inf)\n      MPM:addEdge(idx * 2 - 1, idx, inf)\n      table.insert(tasks, idx)\n    else\n      t[idx] = inf\n      MPM:addEdge(idx * 2 - 1, idx * 2, 1)\n    end\n    if i == 1 or i == h or j == 1 or j == w then\n      MPM:addEdge(idx * 2, tpos, inf)\n    end\n  end\nend\n\nlocal function walk(src, dst)\n  if t[src] < t[dst] then\n    MPM:addEdge(src * 2, dst * 2 - 1, inf)\n  end\n  if t[src] + 1 < t[dst] then\n    t[dst] = t[src] + 1\n    table.insert(tasks, dst)\n  end\nend\n\nlocal done = 0\nwhile done < #tasks do\n  done = done + 1\n  local src = tasks[done]\n  if w < src then walk(src, src - w) end\n  if src <= (h - 1) * w then walk(src, src + w) end\n  if 1 < w then\n    if src % w ~= 0 then walk(src, src + 1) end\n    if src % w ~= 1 then walk(src, src - 1) end\n  end\nend\nlocal ret = MPM:getMaxFlow()\nprint(inf <= ret and -1 or ret)\n"
  },
  {
    "language": "Lua",
    "code": "local mmi, mma = math.min, math.max\nlocal MPM = {}\n\nMPM.initialize = function(self, n, spos, tpos)\n  self.n = n\n  self.spos, self.tpos = spos, tpos\n  -- edge_dst[src][i] := dst\n  self.edge_dst = {}\n  -- edge_cap[src][i] := capacity from src to edge_dst[src][i]\n  self.edge_cap = {}\n  -- edge_dst_invedge_idx[src][i] := \"j\" where edge_dst[dst][j] == src\n  -- in this case, edge_dst_invedge_idx[dst][j] should be \"i\".\n  self.edge_dst_invedge_idx = {}\n  -- level[v] := length from spos. level[spos] := 1\n  self.level = {}\n  -- level_vertex_count[i] := count of vertexes that levels are i\n  self.level_vertex_count = {}\n  -- sub_graph_v[i] := list of vertexes that are contained in the sub-graph.\n  self.sub_graph_v = {}\n  -- sub_graph_size := the size of sub_graph_v.\n  -- may not equal to #sub_graph_v (because not cleared).\n  self.sub_graph_size = 0\n  -- sub_graph_flag[v] := whether to contains the vertex v in the sub-graph or not\n  self.sub_graph_flag = {}\n  -- send[v] := sum of sendable amount from v to other vertexes in the sub-graph\n  self.send = {}\n  -- receive[v] := sum of receivable amount toward v from other vertexes in the sub-graph\n  self.receive = {}\n  -- sub_edge_idxes[src][i] := edge (from v) using in the sub-graph.\n  -- for example, if sub_edge_idxes[src][i] is j,\n  -- the edge from src to dst (= edge_dst[src][j]) contains in the sub-graph.\n  self.sub_edge_idxes = {}\n  -- sub_edge_cnt[src] := the size of sub_edge_idxes[src].\n  -- may not equal to #sub_edge_idxes[src] (because not cleared).\n  self.sub_edge_cnt = {}\n  -- sub_invedge_idxes[dst] := edge (to dst) using in the sub-graph.\n  -- for example, if sub_invedge_idxes[dst][i] is j,\n  -- the src is edge_dst[dst][j], and the edge index (from src to dst) is k := edge_dst_invedge_idx[dst][j].\n  -- so edge_dst[src][k] is the edge from src to dst using in the sub-graph.\n  self.sub_invedge_idxes = {}\n  -- sub_invedge_cnt[dst] := the size of sub_invedge_idxes[dst].\n  -- may not equal to #sub_invedge_idxes[dst] (because not cleared).\n  self.sub_invedge_cnt = {}\n  -- flow_route[v] := [for \"flowToT\"] whether to contain in the route from weak_vertex to tpos.\n  self.flow_route = {}\n  -- actual_flow_amount[v] := [for \"flowToT\"] send amount from v\n  self.actual_flow_amount = {}\n  for i = 1, n do\n    self.edge_dst[i] = {}\n    self.edge_cap[i] = {}\n    self.edge_dst_invedge_idx[i] = {}\n    self.level[i] = 0\n    self.level_vertex_count[i] = 0\n    self.sub_graph_flag[i] = false\n    self.send[i] = 0\n    self.receive[i] = 0\n    self.sub_edge_idxes[i] = {}\n    self.sub_edge_cnt[i] = 0\n    self.sub_invedge_idxes[i] = {}\n    self.sub_invedge_cnt[i] = 0\n    self.flow_route[i] = false\n    self.actual_flow_amount[i] = 0\n  end\nend\n\nMPM.addEdge = function(self, src, dst, cap, invcap)\n  if not invcap then invcap = 0 end\n  table.insert(self.edge_dst[src], dst)\n  table.insert(self.edge_cap[src], cap)\n  table.insert(self.edge_dst_invedge_idx[src], 1 + #self.edge_dst[dst])\n  table.insert(self.edge_dst[dst], src)\n  table.insert(self.edge_cap[dst], invcap)\n  table.insert(self.edge_dst_invedge_idx[dst], #self.edge_dst[src])\nend\nMPM.makeSubGraph = function(self)\n  local inf = self.n + 2\n  local level, sub_graph_flag = self.level, self.sub_graph_flag\n  local edge_dst, edge_cap = self.edge_dst, self.edge_cap\n  local edge_dst_invedge_idx = self.edge_dst_invedge_idx\n  local send, receive = self.send, self.receive\n  local sub_graph_v = self.sub_graph_v\n  local sub_edge_idxes, sub_edge_cnt = self.sub_edge_idxes, self.sub_edge_cnt\n  local sub_invedge_idxes, sub_invedge_cnt = self.sub_invedge_idxes, self.sub_invedge_cnt\n  local level_vertex_count = self.level_vertex_count\n  for i = 1, self.n do\n    level[i] = inf\n    sub_graph_flag[i] = false\n    send[i], receive[i] = 0, 0\n    sub_edge_cnt[i] = 0\n    sub_invedge_cnt[i] = 0\n    level_vertex_count[i] = 0\n  end\n  -- BFS\n  level[self.spos] = 1\n  local taskcnt, done = 1, 0\n  sub_graph_v[1] = self.spos\n  local reached = false\n  while done < taskcnt do\n    done = done + 1\n    local src = sub_graph_v[done]\n    if src == self.tpos then reached = true break end\n    for i = 1, #edge_dst[src] do\n      local cap = edge_cap[src][i]\n      if 0 < cap then\n        local dst = edge_dst[src][i]\n        if level[dst] == inf then\n          level[dst] = level[src] + 1\n          taskcnt = taskcnt + 1\n          sub_graph_v[taskcnt] = dst\n        elseif level[dst] == level[src] + 1 then\n        end\n      end\n    end\n  end\n  if not reached then\n    self.sub_graph_size = 0\n    return false\n  end\n  -- restore route\n  sub_graph_flag[self.tpos] = true\n  local curlevel = level[self.tpos]\n  while curlevel == level[sub_graph_v[taskcnt]] do\n    taskcnt = taskcnt - 1\n  end\n  for isrc = taskcnt, 1, -1 do\n    local src = sub_graph_v[isrc]\n    for i = 1, #edge_dst[src] do\n      local dst, cap = edge_dst[src][i], edge_cap[src][i]\n      if 0 < cap and sub_graph_flag[dst]\n      and level[dst] == level[src] + 1 then\n        sub_graph_flag[src] = true\n        local edgecnt = sub_edge_cnt[src] + 1\n        sub_edge_cnt[src] = edgecnt\n        sub_edge_idxes[src][edgecnt] = i\n        sub_invedge_cnt[dst] = sub_invedge_cnt[dst] + 1\n        sub_invedge_idxes[dst][sub_invedge_cnt[dst]] = edge_dst_invedge_idx[src][i]\n        send[src] = send[src] + cap\n        receive[dst] = receive[dst] + cap\n      end\n    end\n    if not sub_graph_flag[src] then\n      for i = 1, #edge_dst[src] do\n        local dst = edge_dst[src][i]\n        local cap = edge_cap[src][i]\n        if 0 < cap and level[dst] == level[src] + 1 then\n          send[src] = send[src] - cap\n          receive[dst] = receive[dst] - cap\n        end\n      end\n    end\n  end\n  -- remove unused vertex from \"taskcnt\" and set as sub_graph_size\n  local nodecnt = 1\n  for i = 1, taskcnt do\n    local v = sub_graph_v[i]\n    if sub_graph_flag[v] then\n      sub_graph_v[nodecnt] = v\n      local lv = level[v]\n      level_vertex_count[lv] = level_vertex_count[lv] + 1\n      nodecnt = nodecnt + 1\n    end\n  end\n  if sub_graph_v[nodecnt - 1] == self.tpos then\n    nodecnt = nodecnt - 1\n  else\n    sub_graph_v[nodecnt] = self.tpos\n    local lv = level[self.tpos]\n    level_vertex_count[lv] = level_vertex_count[lv] + 1\n  end\n  self.sub_graph_size = nodecnt\n  return true\nend\n\nMPM.subGraphConnected = function(self)\n  local max_level = self.level[self.tpos]\n  local level_vertex_count = self.level_vertex_count\n  for i = 1, max_level do\n    if level_vertex_count[i] <= 0 then return false end\n  end\n  return true\nend\n\nMPM.findWeakVertex = function(self)\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_size = self.sub_graph_size\n  local send, receive = self.send, self.receive\n  local min_vertex = self.spos\n  local min_potential = send[min_vertex]\n  if receive[self.tpos] < min_potential then\n    min_vertex = self.tpos\n    min_potential = receive[min_vertex]\n  end\n  for i = 2, sub_graph_size - 1 do\n    local v = sub_graph_v[i]\n    local min_v = mmi(send[v], receive[v])\n    if min_v < min_potential then\n      min_potential, min_vertex = min_v, v\n    end\n  end\n  return min_vertex, min_potential\nend\n\nMPM.flowToT = function(self, weak_vertex, potential)\n  if weak_vertex == self.tpos then return end\n  local sub_graph_flag = self.sub_graph_flag\n  local edge_dst, edge_cap = self.edge_dst, self.edge_cap\n  local edge_dst_invedge_idx = self.edge_dst_invedge_idx\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_size = self.sub_graph_size\n  local sub_edge_cnt = self.sub_edge_cnt\n  local sub_edge_idxes = self.sub_edge_idxes\n  local send, receive = self.send, self.receive\n  local level = self.level\n  local flow_route = self.flow_route\n  local actual_flow_amount = self.actual_flow_amount\n  local tpos = self.tpos\n  for i = 1, sub_graph_size do\n    local v = sub_graph_v[i]\n    flow_route[v] = false\n    actual_flow_amount[v] = 0\n  end\n  flow_route[weak_vertex] = true\n  actual_flow_amount[weak_vertex] = potential\n  local weak_vertex_level = level[weak_vertex]\n  local max_level = level[tpos]\n  for iv = 1, sub_graph_size do\n    local src = sub_graph_v[iv]\n    local lv = level[src]\n    if lv == max_level then break end\n    local need_to_send = actual_flow_amount[src]\n    if flow_route[src] and 0 < need_to_send then\n      send[src] = send[src] - need_to_send\n      local sub_edge_idxes_src = sub_edge_idxes[src]\n      local dsts, caps, invidxes = edge_dst[src], edge_cap[src], edge_dst_invedge_idx[src]\n      local used = 0\n      -- use edge in descending order, to remove used edges quickly\n      for j = sub_edge_cnt[src], 1, -1 do\n        local edgeidx = sub_edge_idxes_src[j]\n        local dst, cap = dsts[edgeidx], caps[edgeidx]\n        local actual_flow = mmi(cap, need_to_send)\n        receive[dst] = receive[dst] - actual_flow\n        caps[edgeidx] = caps[edgeidx] - actual_flow\n        need_to_send = need_to_send - actual_flow\n        flow_route[dst] = true\n        actual_flow_amount[dst] = actual_flow_amount[dst] + actual_flow\n        local inv_edge_idx = invidxes[edgeidx]\n        edge_cap[dst][inv_edge_idx] = edge_cap[dst][inv_edge_idx] + actual_flow\n        if caps[edgeidx] == 0 then\n          used = used + 1\n        end\n        if need_to_send == 0 then\n          break\n        end\n      end\n      sub_edge_cnt[src] = sub_edge_cnt[src] - used\n    end\n  end\nend\n\nMPM.flowFromS = function(self, weak_vertex, potential)\n  if weak_vertex == self.spos then return end\n  local sub_graph_flag = self.sub_graph_flag\n  local edge_dst, edge_cap = self.edge_dst, self.edge_cap\n  local edge_dst_invedge_idx = self.edge_dst_invedge_idx\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_size = self.sub_graph_size\n  local sub_edge_cnt = self.sub_edge_cnt\n  local sub_edge_idxes = self.sub_edge_idxes\n  local sub_invedge_idxes = self.sub_invedge_idxes\n  local sub_invedge_cnt = self.sub_invedge_cnt\n  local send, receive = self.send, self.receive\n  local level = self.level\n  local flow_route = self.flow_route\n  local actual_flow_amount = self.actual_flow_amount\n  local spos = self.spos\n  for i = 1, sub_graph_size do\n    local v = sub_graph_v[i]\n    flow_route[v] = false\n    actual_flow_amount[v] = 0\n  end\n  flow_route[weak_vertex] = true\n  actual_flow_amount[weak_vertex] = potential\n  local weak_vertex_level = level[weak_vertex]\n  local max_level = level[tpos]\n  for iv = sub_graph_size, 1, -1 do\n    local dst = sub_graph_v[iv]\n    local lv = level[dst]\n    if lv == 1 then break end\n    local need_to_receive = actual_flow_amount[dst]\n    if flow_route[dst] and 0 < need_to_receive then\n      receive[dst] = receive[dst] - need_to_receive\n      local sub_invedge_idxes_dst = sub_invedge_idxes[dst]\n      local srcs = edge_dst[dst]\n      local inv_invidxes = edge_dst_invedge_idx[dst]\n      -- local dsts, caps, invidxes = edge_dst[src], edge_cap[src], edge_dst_invedge_idx[src]\n      local used = 0\n      -- use edge in descending order, to remove used edges quickly\n      for j = sub_invedge_cnt[dst], 1, -1 do\n        local invedgeidx = sub_invedge_idxes_dst[j]\n        local src = srcs[invedgeidx]\n        local edgeidx = inv_invidxes[invedgeidx]\n        assert(edge_dst[src][edgeidx] == dst)\n        local cap = edge_cap[src][edgeidx]\n        local actual_flow = mmi(cap, need_to_receive)\n\n        send[src] = send[src] - actual_flow\n        edge_cap[src][edgeidx] = edge_cap[src][edgeidx] - actual_flow\n        need_to_receive = need_to_receive - actual_flow\n        flow_route[src] = true\n        actual_flow_amount[src] = actual_flow_amount[src] + actual_flow\n        edge_cap[dst][invedgeidx] = edge_cap[dst][invedgeidx] + actual_flow\n        if edge_cap[src][edgeidx] == 0 then\n          used = used + 1\n        end\n        if need_to_receive == 0 then\n          break\n        end\n      end\n      sub_invedge_cnt[dst] = sub_invedge_cnt[dst] - used\n    end\n  end\nend\n\nMPM.updateSubGraph = function(self)\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_size = self.sub_graph_size\n  local sub_graph_flag = self.sub_graph_flag\n  local send, receive = self.send, self.receive\n  local spos, tpos = self.spos, self.tpos\n  local level = self.level\n  local level_vertex_count = self.level_vertex_count\n  local sub_edge_idxes = self.sub_edge_idxes\n  local sub_edge_cnt = self.sub_edge_cnt\n  local edge_dst = self.edge_dst\n  local sub_invedge_idxes = self.sub_invedge_idxes\n  local sub_invedge_cnt = self.sub_invedge_cnt\n  local nodecnt = 0\n  for i = 1, sub_graph_size do\n    local v = sub_graph_v[i]\n    local valid = true\n    if v ~= spos and receive[v] <= 0 then valid = false end\n    if v ~= tpos and send[v] <= 0 then valid = false end\n    if valid then\n      local sub_invedge_idxes_v = sub_invedge_idxes[v]\n      valid = false\n      for j = 1, sub_invedge_cnt[v] do\n        local ei = sub_invedge_idxes_v[j]\n        local src = edge_dst[v][ei]\n        if sub_graph_flag[src] then valid = true break end\n      end\n    end\n    if valid then\n      nodecnt = nodecnt + 1\n      sub_graph_v[nodecnt] = v\n    else\n      sub_graph_flag[v] = false\n      local lv = level[v]\n      level_vertex_count[lv] = level_vertex_count[lv] - 1\n    end\n  end\n  sub_graph_size = nodecnt\n  for i = sub_graph_size, 1, -1 do\n    local v = sub_graph_v[i]\n    local valid = false\n    local sub_edge_idxes_v = sub_edge_idxes[v]\n    for j = 1, sub_edge_cnt[v] do\n      local ei = sub_edge_idxes_v[j]\n      local dst = edge_dst[v][ei]\n      if sub_graph_flag[dst] then valid = true break end\n    end\n    if not valid then\n      sub_graph_flag[v] = false\n      local lv = level[v]\n      level_vertex_count[lv] = level_vertex_count[lv] - 1\n    end\n  end\n  nodecnt = 0\n  for i = 1, sub_graph_size do\n    local v = sub_graph_v[i]\n    if sub_graph_v[v] then\n      nodecnt = nodecnt + 1\n      sub_graph_v[nodecnt] = v\n    end\n  end\n  self.sub_graph_size = nodecnt\nend\n\nMPM.partialwork = function(self)\n  local sum = 0\n  while(self:subGraphConnected()) do\n    local weak_vertex, potential = self:findWeakVertex()\n    self:flowToT(weak_vertex, potential)\n    self:flowFromS(weak_vertex, potential)\n    self:updateSubGraph()\n    sum = sum + potential\n  end\n  return sum\nend\n\nMPM.getMaxFlow = function(self)\n  local ret = 0\n  while(self:makeSubGraph()) do\n    ret = ret + self:partialwork()\n  end\n  return ret\nend\n\nlocal h, w = io.read(\"*n\", \"*n\", \"*l\")\nlocal spos = h * w * 2 + 1\nlocal tpos = spos + 1\nMPM:initialize(tpos, spos, tpos)\nlocal t = {}\nlocal inf = 1000000007\nfor i = 1, h do\n  local s = io.read()\n  for j = 1, w do\n    local idx = (i - 1) * w + j\n    if s:sub(j, j) == \"X\" then\n      t[idx] = 0\n      MPM:addEdge(idx * 2 - 1, tpos, inf)\n    else\n      t[idx] = inf\n      MPM:addEdge(idx * 2 - 1, idx * 2, 1)\n    end\n    if i == 1 or i == h or j == 1 or j == w then\n      MPM:addEdge(spos, idx * 2 - 1, inf)\n    end\n  end\nend\nfor i = 1, h do\n  for j = 1, w - 1 do\n    local idx1 = (i - 1) * w + j\n    local idx2 = idx1 + 1\n    MPM:addEdge(idx1 * 2, idx2 * 2 - 1, inf)\n    MPM:addEdge(idx2 * 2, idx1 * 2 - 1, inf)\n  end\nend\nfor i = 1, h - 1 do\n  for j = 1, w do\n    local idx1 = (i - 1) * w + j\n    local idx2 = idx1 + w\n    MPM:addEdge(idx1 * 2, idx2 * 2 - 1, inf)\n    MPM:addEdge(idx2 * 2, idx1 * 2 - 1, inf)\n  end\nend\nlocal ret = MPM:getMaxFlow()\nprint(inf <= ret and -1 or ret)\n"
  },
  {
    "language": "Lua",
    "code": "local mmi, mma = math.min, math.max\nlocal MPM = {}\n\nMPM.initialize = function(self, n, spos, tpos)\n  self.n = n\n  self.spos, self.tpos = spos, tpos\n  -- edge_dst[src][i] := dst\n  self.edge_dst = {}\n  -- edge_cap[src][i] := capacity from src to edge_dst[src][i]\n  self.edge_cap = {}\n  -- edge_dst_invedge_idx[src][i] := \"j\" where edge_dst[dst][j] == src\n  -- in this case, edge_dst_invedge_idx[dst][j] should be \"i\".\n  self.edge_dst_invedge_idx = {}\n  -- level[v] := length from spos. level[spos] := 1\n  self.level = {}\n  -- level_vertex_count[i] := count of vertexes that levels are i\n  self.level_vertex_count = {}\n  -- sub_graph_v[i] := list of vertexes that are contained in the sub-graph.\n  self.sub_graph_v = {}\n  -- sub_graph_size := the size of sub_graph_v.\n  -- may not equal to #sub_graph_v (because not cleared).\n  self.sub_graph_size = 0\n  -- sub_graph_flag[v] := whether to contains the vertex v in the sub-graph or not\n  self.sub_graph_flag = {}\n  -- send[v] := sum of sendable amount from v to other vertexes in the sub-graph\n  self.send = {}\n  -- receive[v] := sum of receivable amount toward v from other vertexes in the sub-graph\n  self.receive = {}\n  -- sub_edge_idxes[src][i] := edge (from v) using in the sub-graph.\n  -- for example, if sub_edge_idxes[src][i] is j,\n  -- the edge from src to dst (= edge_dst[src][j]) contains in the sub-graph.\n  self.sub_edge_idxes = {}\n  -- sub_edge_cnt[src] := the size of sub_edge_idxes[src].\n  -- may not equal to #sub_edge_idxes[src] (because not cleared).\n  self.sub_edge_cnt = {}\n  -- sub_invedge_idxes[dst] := edge (to dst) using in the sub-graph.\n  -- for example, if sub_invedge_idxes[dst][i] is j,\n  -- the src is edge_dst[dst][j], and the edge index (from src to dst) is k := edge_dst_invedge_idx[dst][j].\n  -- so edge_dst[src][k] is the edge from src to dst using in the sub-graph.\n  self.sub_invedge_idxes = {}\n  -- sub_invedge_cnt[dst] := the size of sub_invedge_idxes[dst].\n  -- may not equal to #sub_invedge_idxes[dst] (because not cleared).\n  self.sub_invedge_cnt = {}\n  -- flow_route[v] := [for \"flowToT\"] whether to contain in the route from weak_vertex to tpos.\n  self.flow_route = {}\n  -- actual_flow_amount[v] := [for \"flowToT\"] send amount from v\n  self.actual_flow_amount = {}\n  for i = 1, n do\n    self.edge_dst[i] = {}\n    self.edge_cap[i] = {}\n    self.edge_dst_invedge_idx[i] = {}\n    self.level[i] = 0\n    self.level_vertex_count[i] = 0\n    self.sub_graph_flag[i] = false\n    self.send[i] = 0\n    self.receive[i] = 0\n    self.sub_edge_idxes[i] = {}\n    self.sub_edge_cnt[i] = 0\n    self.sub_invedge_idxes[i] = {}\n    self.sub_invedge_cnt[i] = 0\n    self.flow_route[i] = false\n    self.actual_flow_amount[i] = 0\n  end\nend\n\nMPM.addEdge = function(self, src, dst, cap, invcap)\n  if not invcap then invcap = 0 end\n  table.insert(self.edge_dst[src], dst)\n  table.insert(self.edge_cap[src], cap)\n  table.insert(self.edge_dst_invedge_idx[src], 1 + #self.edge_dst[dst])\n  table.insert(self.edge_dst[dst], src)\n  table.insert(self.edge_cap[dst], invcap)\n  table.insert(self.edge_dst_invedge_idx[dst], #self.edge_dst[src])\nend\nMPM.makeSubGraph = function(self)\n  local inf = self.n + 2\n  local level, sub_graph_flag = self.level, self.sub_graph_flag\n  local edge_dst, edge_cap = self.edge_dst, self.edge_cap\n  local edge_dst_invedge_idx = self.edge_dst_invedge_idx\n  local send, receive = self.send, self.receive\n  local sub_graph_v = self.sub_graph_v\n  local sub_edge_idxes, sub_edge_cnt = self.sub_edge_idxes, self.sub_edge_cnt\n  local sub_invedge_idxes, sub_invedge_cnt = self.sub_invedge_idxes, self.sub_invedge_cnt\n  local level_vertex_count = self.level_vertex_count\n  for i = 1, self.n do\n    level[i] = inf\n    sub_graph_flag[i] = false\n    send[i], receive[i] = 0, 0\n    sub_edge_cnt[i] = 0\n    sub_invedge_cnt[i] = 0\n    level_vertex_count[i] = 0\n  end\n  -- BFS\n  level[self.spos] = 1\n  local taskcnt, done = 1, 0\n  sub_graph_v[1] = self.spos\n  local reached = false\n  while done < taskcnt do\n    done = done + 1\n    local src = sub_graph_v[done]\n    if src == self.tpos then reached = true break end\n    for i = 1, #edge_dst[src] do\n      local cap = edge_cap[src][i]\n      if 0 < cap then\n        local dst = edge_dst[src][i]\n        if level[dst] == inf then\n          level[dst] = level[src] + 1\n          taskcnt = taskcnt + 1\n          sub_graph_v[taskcnt] = dst\n        elseif level[dst] == level[src] + 1 then\n        end\n      end\n    end\n  end\n  if not reached then\n    self.sub_graph_size = 0\n    return false\n  end\n  -- restore route\n  sub_graph_flag[self.tpos] = true\n  local curlevel = level[self.tpos]\n  while curlevel == level[sub_graph_v[taskcnt]] do\n    taskcnt = taskcnt - 1\n  end\n  for isrc = taskcnt, 1, -1 do\n    local src = sub_graph_v[isrc]\n    for i = 1, #edge_dst[src] do\n      local dst, cap = edge_dst[src][i], edge_cap[src][i]\n      if 0 < cap and sub_graph_flag[dst]\n      and level[dst] == level[src] + 1 then\n        sub_graph_flag[src] = true\n        local edgecnt = sub_edge_cnt[src] + 1\n        sub_edge_cnt[src] = edgecnt\n        sub_edge_idxes[src][edgecnt] = i\n        sub_invedge_cnt[dst] = sub_invedge_cnt[dst] + 1\n        sub_invedge_idxes[dst][sub_invedge_cnt[dst]] = edge_dst_invedge_idx[src][i]\n        send[src] = send[src] + cap\n        receive[dst] = receive[dst] + cap\n      end\n    end\n    if not sub_graph_flag[src] then\n      for i = 1, #edge_dst[src] do\n        local dst = edge_dst[src][i]\n        local cap = edge_cap[src][i]\n        if 0 < cap and level[dst] == level[src] + 1 then\n          send[src] = send[src] - cap\n          receive[dst] = receive[dst] - cap\n        end\n      end\n    end\n  end\n  -- remove unused vertex from \"taskcnt\" and set as sub_graph_size\n  local nodecnt = 1\n  for i = 1, taskcnt do\n    local v = sub_graph_v[i]\n    if sub_graph_flag[v] then\n      sub_graph_v[nodecnt] = v\n      local lv = level[v]\n      level_vertex_count[lv] = level_vertex_count[lv] + 1\n      nodecnt = nodecnt + 1\n    end\n  end\n  if sub_graph_v[nodecnt - 1] == self.tpos then\n    nodecnt = nodecnt - 1\n  else\n    sub_graph_v[nodecnt] = self.tpos\n    local lv = level[self.tpos]\n    level_vertex_count[lv] = level_vertex_count[lv] + 1\n  end\n  self.sub_graph_size = nodecnt\n  return true\nend\n\nMPM.subGraphConnected = function(self)\n  local max_level = self.level[self.tpos]\n  local level_vertex_count = self.level_vertex_count\n  for i = 1, max_level do\n    if level_vertex_count[i] <= 0 then return false end\n  end\n  return true\nend\n\nMPM.findWeakVertex = function(self)\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_size = self.sub_graph_size\n  local send, receive = self.send, self.receive\n  local min_vertex = self.spos\n  local min_potential = send[min_vertex]\n  if receive[self.tpos] < min_potential then\n    min_vertex = self.tpos\n    min_potential = receive[min_vertex]\n  end\n  for i = 2, sub_graph_size - 1 do\n    local v = sub_graph_v[i]\n    local min_v = mmi(send[v], receive[v])\n    if min_v < min_potential then\n      min_potential, min_vertex = min_v, v\n    end\n  end\n  return min_vertex, min_potential\nend\n\nMPM.flowToT = function(self, weak_vertex, potential)\n  if weak_vertex == self.tpos then return end\n  local sub_graph_flag = self.sub_graph_flag\n  local edge_dst, edge_cap = self.edge_dst, self.edge_cap\n  local edge_dst_invedge_idx = self.edge_dst_invedge_idx\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_size = self.sub_graph_size\n  local sub_edge_cnt = self.sub_edge_cnt\n  local sub_edge_idxes = self.sub_edge_idxes\n  local send, receive = self.send, self.receive\n  local level = self.level\n  local flow_route = self.flow_route\n  local actual_flow_amount = self.actual_flow_amount\n  local tpos = self.tpos\n  for i = 1, sub_graph_size do\n    local v = sub_graph_v[i]\n    flow_route[v] = false\n    actual_flow_amount[v] = 0\n  end\n  flow_route[weak_vertex] = true\n  actual_flow_amount[weak_vertex] = potential\n  local weak_vertex_level = level[weak_vertex]\n  local max_level = level[tpos]\n  for iv = 1, sub_graph_size do\n    local src = sub_graph_v[iv]\n    local lv = level[src]\n    if lv == max_level then break end\n    local need_to_send = actual_flow_amount[src]\n    if flow_route[src] and 0 < need_to_send then\n      send[src] = send[src] - need_to_send\n      local sub_edge_idxes_src = sub_edge_idxes[src]\n      local dsts, caps, invidxes = edge_dst[src], edge_cap[src], edge_dst_invedge_idx[src]\n      local used = 0\n      -- use edge in descending order, to remove used edges quickly\n      for j = sub_edge_cnt[src], 1, -1 do\n        local edgeidx = sub_edge_idxes_src[j]\n        local dst, cap = dsts[edgeidx], caps[edgeidx]\n        local actual_flow = mmi(cap, need_to_send)\n        receive[dst] = receive[dst] - actual_flow\n        caps[edgeidx] = caps[edgeidx] - actual_flow\n        need_to_send = need_to_send - actual_flow\n        flow_route[dst] = true\n        actual_flow_amount[dst] = actual_flow_amount[dst] + actual_flow\n        local inv_edge_idx = invidxes[edgeidx]\n        edge_cap[dst][inv_edge_idx] = edge_cap[dst][inv_edge_idx] + actual_flow\n        if caps[edgeidx] == 0 then\n          used = used + 1\n        end\n        if need_to_send == 0 then\n          break\n        end\n      end\n      sub_edge_cnt[src] = sub_edge_cnt[src] - used\n    end\n  end\nend\n\nMPM.flowFromS = function(self, weak_vertex, potential)\n  if weak_vertex == self.spos then return end\n  local sub_graph_flag = self.sub_graph_flag\n  local edge_dst, edge_cap = self.edge_dst, self.edge_cap\n  local edge_dst_invedge_idx = self.edge_dst_invedge_idx\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_size = self.sub_graph_size\n  local sub_edge_cnt = self.sub_edge_cnt\n  local sub_edge_idxes = self.sub_edge_idxes\n  local sub_invedge_idxes = self.sub_invedge_idxes\n  local sub_invedge_cnt = self.sub_invedge_cnt\n  local send, receive = self.send, self.receive\n  local level = self.level\n  local flow_route = self.flow_route\n  local actual_flow_amount = self.actual_flow_amount\n  local spos = self.spos\n  for i = 1, sub_graph_size do\n    local v = sub_graph_v[i]\n    flow_route[v] = false\n    actual_flow_amount[v] = 0\n  end\n  flow_route[weak_vertex] = true\n  actual_flow_amount[weak_vertex] = potential\n  local weak_vertex_level = level[weak_vertex]\n  local max_level = level[tpos]\n  for iv = sub_graph_size, 1, -1 do\n    local dst = sub_graph_v[iv]\n    local lv = level[dst]\n    if lv == 1 then break end\n    local need_to_receive = actual_flow_amount[dst]\n    if flow_route[dst] and 0 < need_to_receive then\n      receive[dst] = receive[dst] - need_to_receive\n      local sub_invedge_idxes_dst = sub_invedge_idxes[dst]\n      local srcs = edge_dst[dst]\n      local inv_invidxes = edge_dst_invedge_idx[dst]\n      -- local dsts, caps, invidxes = edge_dst[src], edge_cap[src], edge_dst_invedge_idx[src]\n      local used = 0\n      -- use edge in descending order, to remove used edges quickly\n      for j = sub_invedge_cnt[dst], 1, -1 do\n        local invedgeidx = sub_invedge_idxes_dst[j]\n        local src = srcs[invedgeidx]\n        local edgeidx = inv_invidxes[invedgeidx]\n        assert(edge_dst[src][edgeidx] == dst)\n        local cap = edge_cap[src][edgeidx]\n        local actual_flow = mmi(cap, need_to_receive)\n\n        send[src] = send[src] - actual_flow\n        edge_cap[src][edgeidx] = edge_cap[src][edgeidx] - actual_flow\n        need_to_receive = need_to_receive - actual_flow\n        flow_route[src] = true\n        actual_flow_amount[src] = actual_flow_amount[src] + actual_flow\n        edge_cap[dst][invedgeidx] = edge_cap[dst][invedgeidx] + actual_flow\n        if edge_cap[src][edgeidx] == 0 then\n          used = used + 1\n        end\n        if need_to_receive == 0 then\n          break\n        end\n      end\n      sub_invedge_cnt[dst] = sub_invedge_cnt[dst] - used\n    end\n  end\nend\n\nMPM.updateSubGraph = function(self)\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_size = self.sub_graph_size\n  local sub_graph_flag = self.sub_graph_flag\n  local send, receive = self.send, self.receive\n  local spos, tpos = self.spos, self.tpos\n  local level = self.level\n  local level_vertex_count = self.level_vertex_count\n  local sub_edge_idxes = self.sub_edge_idxes\n  local sub_edge_cnt = self.sub_edge_cnt\n  local edge_dst = self.edge_dst\n  local sub_invedge_idxes = self.sub_invedge_idxes\n  local sub_invedge_cnt = self.sub_invedge_cnt\n  local nodecnt = 0\n  for i = 1, sub_graph_size do\n    local v = sub_graph_v[i]\n    local valid = true\n    if v ~= spos and receive[v] <= 0 then valid = false end\n    if v ~= tpos and send[v] <= 0 then valid = false end\n    if valid then\n      local sub_invedge_idxes_v = sub_invedge_idxes[v]\n      valid = false\n      for j = 1, sub_invedge_cnt[v] do\n        local ei = sub_invedge_idxes_v[j]\n        local src = edge_dst[v][ei]\n        if sub_graph_flag[src] then valid = true break end\n      end\n    end\n    if valid then\n      nodecnt = nodecnt + 1\n      sub_graph_v[nodecnt] = v\n    else\n      sub_graph_flag[v] = false\n      local lv = level[v]\n      level_vertex_count[lv] = level_vertex_count[lv] - 1\n    end\n  end\n  sub_graph_size = nodecnt\n  for i = sub_graph_size, 1, -1 do\n    local v = sub_graph_v[i]\n    local valid = false\n    local sub_edge_idxes_v = sub_edge_idxes[v]\n    for j = 1, sub_edge_cnt[v] do\n      local ei = sub_edge_idxes_v[j]\n      local dst = edge_dst[v][ei]\n      if sub_graph_flag[dst] then valid = true break end\n    end\n    if not valid then\n      sub_graph_flag[v] = false\n      local lv = level[v]\n      level_vertex_count[lv] = level_vertex_count[lv] - 1\n    end\n  end\n  nodecnt = 0\n  for i = 1, sub_graph_size do\n    local v = sub_graph_v[i]\n    if sub_graph_v[v] then\n      nodecnt = nodecnt + 1\n      sub_graph_v[nodecnt] = v\n    end\n  end\n  self.sub_graph_size = nodecnt\nend\n\nMPM.partialwork = function(self)\n  local sum = 0\n  while(self:subGraphConnected()) do\n    local weak_vertex, potential = self:findWeakVertex()\n    self:flowToT(weak_vertex, potential)\n    self:flowFromS(weak_vertex, potential)\n    self:updateSubGraph()\n    sum = sum + potential\n  end\n  return sum\nend\n\nMPM.getMaxFlow = function(self)\n  local ret = 0\n  while(self:makeSubGraph()) do\n    ret = ret + self:partialwork()\n  end\n  return ret\nend\n\nlocal h, w = io.read(\"*n\", \"*n\", \"*l\")\nlocal spos = h * w * 2 + 1\nlocal tpos = spos + 1\nMPM:initialize(tpos, spos, tpos)\nlocal t = {}\nlocal inf = 1000000007\nfor i = 1, h do\n  local s = io.read()\n  for j = 1, w do\n    local idx = (i - 1) * w + j\n    if s:sub(j, j) == \"X\" then\n      t[idx] = 0\n      MPM:addEdge(idx * 2 - 1, tpos, inf)\n    else\n      t[idx] = inf\n      MPM:addEdge(idx * 2 - 1, idx * 2, 1)\n    end\n    if i == 1 or i == h or j == 1 or j == w then\n      MPM:addEdge(spos, idx * 2 - 1, inf)\n    end\n  end\nend\nfor i = 1, h do\n  for j = 1, w - 1 do\n    local idx1 = (i - 1) * w + j\n    local idx2 = idx1 + 1\n    MPM:addEdge(idx1 * 2, idx2 * 2 - 1, inf)\n    MPM:addEdge(idx2 * 2, idx1 * 2 - 1, inf)\n  end\nend\nfor i = 1, h - 1 do\n  for j = 1, w do\n    local idx1 = (i - 1) * w + j\n    local idx2 = idx1 + w\n    MPM:addEdge(idx1 * 2, idx2 * 2 - 1, inf)\n    MPM:addEdge(idx2 * 2, idx1 * 2 - 1, inf)\n  end\nend\nlocal ret = MPM:getMaxFlow()\nprint(inf <= ret and -1 or ret)\n"
  },
  {
    "language": "Lua",
    "code": "local mmi, mma = math.min, math.max\nlocal MPM = {}\n\nMPM.initialize = function(self, n, spos, tpos)\n  self.n = n\n  self.spos, self.tpos = spos, tpos\n  -- edge_dst[src][i] := dst\n  self.edge_dst = {}\n  -- edge_cap[src][i] := capacity from src to edge_dst[src][i]\n  self.edge_cap = {}\n  -- edge_dst_invedge_idx[src][i] := \"j\" where edge_dst[dst][j] == src\n  -- in this case, edge_dst_invedge_idx[dst][j] should be \"i\".\n  self.edge_dst_invedge_idx = {}\n  -- level[v] := length from spos. level[spos] := 1\n  self.level = {}\n  -- level_vertex_count[i] := count of vertexes that levels are i\n  self.level_vertex_count = {}\n  -- sub_graph_v[i] := list of vertexes that are contained in the sub-graph.\n  self.sub_graph_v = {}\n  -- sub_graph_size := the size of sub_graph_v.\n  -- may not equal to #sub_graph_v (because not cleared).\n  self.sub_graph_size = 0\n  -- sub_graph_flag[v] := whether to contains the vertex v in the sub-graph or not\n  self.sub_graph_flag = {}\n  -- send[v] := sum of sendable amount from v to other vertexes in the sub-graph\n  self.send = {}\n  -- receive[v] := sum of receivable amount toward v from other vertexes in the sub-graph\n  self.receive = {}\n  -- sub_edge_idxes[src][i] := edge (from v) using in the sub-graph.\n  -- for example, if sub_edge_idxes[src][i] is j,\n  -- the edge from src to dst (= edge_dst[src][j]) contains in the sub-graph.\n  self.sub_edge_idxes = {}\n  -- sub_edge_cnt[src] := the size of sub_edge_idxes[src].\n  -- may not equal to #sub_edge_idxes[src] (because not cleared).\n  self.sub_edge_cnt = {}\n  -- sub_invedge_idxes[dst] := edge (to dst) using in the sub-graph.\n  -- for example, if sub_invedge_idxes[dst][i] is j,\n  -- the src is edge_dst[dst][j], and the edge index (from src to dst) is k := edge_dst_invedge_idx[dst][j].\n  -- so edge_dst[src][k] is the edge from src to dst using in the sub-graph.\n  self.sub_invedge_idxes = {}\n  -- sub_invedge_cnt[dst] := the size of sub_invedge_idxes[dst].\n  -- may not equal to #sub_invedge_idxes[dst] (because not cleared).\n  self.sub_invedge_cnt = {}\n  -- flow_route[v] := [for \"flowToT\"] whether to contain in the route from weak_vertex to tpos.\n  self.flow_route = {}\n  -- actual_flow_amount[v] := [for \"flowToT\"] send amount from v\n  self.actual_flow_amount = {}\n  for i = 1, n do\n    self.edge_dst[i] = {}\n    self.edge_cap[i] = {}\n    self.edge_dst_invedge_idx[i] = {}\n    self.level[i] = 0\n    self.level_vertex_count[i] = 0\n    self.sub_graph_flag[i] = false\n    self.send[i] = 0\n    self.receive[i] = 0\n    self.sub_edge_idxes[i] = {}\n    self.sub_edge_cnt[i] = 0\n    self.sub_invedge_idxes[i] = {}\n    self.sub_invedge_cnt[i] = 0\n    self.flow_route[i] = false\n    self.actual_flow_amount[i] = 0\n  end\nend\n\nMPM.addEdge = function(self, src, dst, cap, invcap)\n  if not invcap then invcap = 0 end\n  table.insert(self.edge_dst[src], dst)\n  table.insert(self.edge_cap[src], cap)\n  table.insert(self.edge_dst_invedge_idx[src], 1 + #self.edge_dst[dst])\n  table.insert(self.edge_dst[dst], src)\n  table.insert(self.edge_cap[dst], invcap)\n  table.insert(self.edge_dst_invedge_idx[dst], #self.edge_dst[src])\nend\nMPM.makeSubGraph = function(self)\n  local inf = self.n + 2\n  local level, sub_graph_flag = self.level, self.sub_graph_flag\n  local edge_dst, edge_cap = self.edge_dst, self.edge_cap\n  local edge_dst_invedge_idx = self.edge_dst_invedge_idx\n  local send, receive = self.send, self.receive\n  local sub_graph_v = self.sub_graph_v\n  local sub_edge_idxes, sub_edge_cnt = self.sub_edge_idxes, self.sub_edge_cnt\n  local sub_invedge_idxes, sub_invedge_cnt = self.sub_invedge_idxes, self.sub_invedge_cnt\n  local level_vertex_count = self.level_vertex_count\n  for i = 1, self.n do\n    level[i] = inf\n    sub_graph_flag[i] = false\n    send[i], receive[i] = 0, 0\n    sub_edge_cnt[i] = 0\n    sub_invedge_cnt[i] = 0\n    level_vertex_count[i] = 0\n  end\n  -- BFS\n  level[self.spos] = 1\n  local taskcnt, done = 1, 0\n  sub_graph_v[1] = self.spos\n  local reached = false\n  while done < taskcnt do\n    done = done + 1\n    local src = sub_graph_v[done]\n    if src == self.tpos then reached = true break end\n    for i = 1, #edge_dst[src] do\n      local cap = edge_cap[src][i]\n      if 0 < cap then\n        local dst = edge_dst[src][i]\n        if level[dst] == inf then\n          level[dst] = level[src] + 1\n          taskcnt = taskcnt + 1\n          sub_graph_v[taskcnt] = dst\n        elseif level[dst] == level[src] + 1 then\n        end\n      end\n    end\n  end\n  if not reached then\n    self.sub_graph_size = 0\n    return false\n  end\n  -- restore route\n  sub_graph_flag[self.tpos] = true\n  local curlevel = level[self.tpos]\n  while curlevel == level[sub_graph_v[taskcnt]] do\n    taskcnt = taskcnt - 1\n  end\n  for isrc = taskcnt, 1, -1 do\n    local src = sub_graph_v[isrc]\n    for i = 1, #edge_dst[src] do\n      local dst, cap = edge_dst[src][i], edge_cap[src][i]\n      if 0 < cap and sub_graph_flag[dst]\n      and level[dst] == level[src] + 1 then\n        sub_graph_flag[src] = true\n        local edgecnt = sub_edge_cnt[src] + 1\n        sub_edge_cnt[src] = edgecnt\n        sub_edge_idxes[src][edgecnt] = i\n        sub_invedge_cnt[dst] = sub_invedge_cnt[dst] + 1\n        sub_invedge_idxes[dst][sub_invedge_cnt[dst]] = edge_dst_invedge_idx[src][i]\n        send[src] = send[src] + cap\n        receive[dst] = receive[dst] + cap\n      end\n    end\n    if not sub_graph_flag[src] then\n      for i = 1, #edge_dst[src] do\n        local dst = edge_dst[src][i]\n        local cap = edge_cap[src][i]\n        if 0 < cap and level[dst] == level[src] + 1 then\n          send[src] = send[src] - cap\n          receive[dst] = receive[dst] - cap\n        end\n      end\n    end\n  end\n  -- remove unused vertex from \"taskcnt\" and set as sub_graph_size\n  local nodecnt = 1\n  for i = 1, taskcnt do\n    local v = sub_graph_v[i]\n    if sub_graph_flag[v] then\n      sub_graph_v[nodecnt] = v\n      local lv = level[v]\n      level_vertex_count[lv] = level_vertex_count[lv] + 1\n      nodecnt = nodecnt + 1\n    end\n  end\n  if sub_graph_v[nodecnt - 1] == self.tpos then\n    nodecnt = nodecnt - 1\n  else\n    sub_graph_v[nodecnt] = self.tpos\n    local lv = level[self.tpos]\n    level_vertex_count[lv] = level_vertex_count[lv] + 1\n  end\n  self.sub_graph_size = nodecnt\n  return true\nend\n\nMPM.subGraphConnected = function(self)\n  local max_level = self.level[self.tpos]\n  local level_vertex_count = self.level_vertex_count\n  for i = 1, max_level do\n    if level_vertex_count[i] <= 0 then return false end\n  end\n  return true\nend\n\nMPM.findWeakVertex = function(self)\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_size = self.sub_graph_size\n  local send, receive = self.send, self.receive\n  local min_vertex = self.spos\n  local min_potential = send[min_vertex]\n  if receive[self.tpos] < min_potential then\n    min_vertex = self.tpos\n    min_potential = receive[min_vertex]\n  end\n  for i = 2, sub_graph_size - 1 do\n    local v = sub_graph_v[i]\n    local min_v = mmi(send[v], receive[v])\n    if min_v < min_potential then\n      min_potential, min_vertex = min_v, v\n    end\n  end\n  return min_vertex, min_potential\nend\n\nMPM.flowToT = function(self, weak_vertex, potential)\n  if weak_vertex == self.tpos then return end\n  local sub_graph_flag = self.sub_graph_flag\n  local edge_dst, edge_cap = self.edge_dst, self.edge_cap\n  local edge_dst_invedge_idx = self.edge_dst_invedge_idx\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_size = self.sub_graph_size\n  local sub_edge_cnt = self.sub_edge_cnt\n  local sub_edge_idxes = self.sub_edge_idxes\n  local send, receive = self.send, self.receive\n  local level = self.level\n  local flow_route = self.flow_route\n  local actual_flow_amount = self.actual_flow_amount\n  local tpos = self.tpos\n  for i = 1, sub_graph_size do\n    local v = sub_graph_v[i]\n    flow_route[v] = false\n    actual_flow_amount[v] = 0\n  end\n  flow_route[weak_vertex] = true\n  actual_flow_amount[weak_vertex] = potential\n  local weak_vertex_level = level[weak_vertex]\n  local max_level = level[tpos]\n  for iv = 1, sub_graph_size do\n    local src = sub_graph_v[iv]\n    local lv = level[src]\n    if lv == max_level then break end\n    local need_to_send = actual_flow_amount[src]\n    if flow_route[src] and 0 < need_to_send then\n      send[src] = send[src] - need_to_send\n      local sub_edge_idxes_src = sub_edge_idxes[src]\n      local dsts, caps, invidxes = edge_dst[src], edge_cap[src], edge_dst_invedge_idx[src]\n      local used = 0\n      -- use edge in descending order, to remove used edges quickly\n      for j = sub_edge_cnt[src], 1, -1 do\n        local edgeidx = sub_edge_idxes_src[j]\n        local dst, cap = dsts[edgeidx], caps[edgeidx]\n        local actual_flow = mmi(cap, need_to_send)\n        receive[dst] = receive[dst] - actual_flow\n        caps[edgeidx] = caps[edgeidx] - actual_flow\n        need_to_send = need_to_send - actual_flow\n        flow_route[dst] = true\n        actual_flow_amount[dst] = actual_flow_amount[dst] + actual_flow\n        local inv_edge_idx = invidxes[edgeidx]\n        edge_cap[dst][inv_edge_idx] = edge_cap[dst][inv_edge_idx] + actual_flow\n        if caps[edgeidx] == 0 then\n          used = used + 1\n        end\n        if need_to_send == 0 then\n          break\n        end\n      end\n      sub_edge_cnt[src] = sub_edge_cnt[src] - used\n    end\n  end\nend\n\nMPM.flowFromS = function(self, weak_vertex, potential)\n  if weak_vertex == self.spos then return end\n  local sub_graph_flag = self.sub_graph_flag\n  local edge_dst, edge_cap = self.edge_dst, self.edge_cap\n  local edge_dst_invedge_idx = self.edge_dst_invedge_idx\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_size = self.sub_graph_size\n  local sub_edge_cnt = self.sub_edge_cnt\n  local sub_edge_idxes = self.sub_edge_idxes\n  local sub_invedge_idxes = self.sub_invedge_idxes\n  local sub_invedge_cnt = self.sub_invedge_cnt\n  local send, receive = self.send, self.receive\n  local level = self.level\n  local flow_route = self.flow_route\n  local actual_flow_amount = self.actual_flow_amount\n  local spos = self.spos\n  for i = 1, sub_graph_size do\n    local v = sub_graph_v[i]\n    flow_route[v] = false\n    actual_flow_amount[v] = 0\n  end\n  flow_route[weak_vertex] = true\n  actual_flow_amount[weak_vertex] = potential\n  local weak_vertex_level = level[weak_vertex]\n  local max_level = level[tpos]\n  for iv = sub_graph_size, 1, -1 do\n    local dst = sub_graph_v[iv]\n    local lv = level[dst]\n    if lv == 1 then break end\n    local need_to_receive = actual_flow_amount[dst]\n    if flow_route[dst] and 0 < need_to_receive then\n      receive[dst] = receive[dst] - need_to_receive\n      local sub_invedge_idxes_dst = sub_invedge_idxes[dst]\n      local srcs = edge_dst[dst]\n      local inv_invidxes = edge_dst_invedge_idx[dst]\n      -- local dsts, caps, invidxes = edge_dst[src], edge_cap[src], edge_dst_invedge_idx[src]\n      local used = 0\n      -- use edge in descending order, to remove used edges quickly\n      for j = sub_invedge_cnt[dst], 1, -1 do\n        local invedgeidx = sub_invedge_idxes_dst[j]\n        local src = srcs[invedgeidx]\n        local edgeidx = inv_invidxes[invedgeidx]\n        assert(edge_dst[src][edgeidx] == dst)\n        local cap = edge_cap[src][edgeidx]\n        local actual_flow = mmi(cap, need_to_receive)\n\n        send[src] = send[src] - actual_flow\n        edge_cap[src][edgeidx] = edge_cap[src][edgeidx] - actual_flow\n        need_to_receive = need_to_receive - actual_flow\n        flow_route[src] = true\n        actual_flow_amount[src] = actual_flow_amount[src] + actual_flow\n        edge_cap[dst][invedgeidx] = edge_cap[dst][invedgeidx] + actual_flow\n        if edge_cap[src][edgeidx] == 0 then\n          used = used + 1\n        end\n        if need_to_receive == 0 then\n          break\n        end\n      end\n      sub_invedge_cnt[dst] = sub_invedge_cnt[dst] - used\n    end\n  end\nend\n\nMPM.updateSubGraph = function(self)\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_size = self.sub_graph_size\n  local sub_graph_flag = self.sub_graph_flag\n  local send, receive = self.send, self.receive\n  local spos, tpos = self.spos, self.tpos\n  local level = self.level\n  local level_vertex_count = self.level_vertex_count\n  local sub_edge_idxes = self.sub_edge_idxes\n  local sub_edge_cnt = self.sub_edge_cnt\n  local edge_dst = self.edge_dst\n  local sub_invedge_idxes = self.sub_invedge_idxes\n  local sub_invedge_cnt = self.sub_invedge_cnt\n  local nodecnt = 0\n  for i = 1, sub_graph_size do\n    local v = sub_graph_v[i]\n    local valid = true\n    if v ~= spos and receive[v] <= 0 then valid = false end\n    if v ~= tpos and send[v] <= 0 then valid = false end\n    if valid then\n      local sub_invedge_idxes_v = sub_invedge_idxes[v]\n      valid = false\n      for j = 1, sub_invedge_cnt[v] do\n        local ei = sub_invedge_idxes_v[j]\n        local src = edge_dst[v][ei]\n        if sub_graph_flag[src] then valid = true break end\n      end\n    end\n    if valid then\n      nodecnt = nodecnt + 1\n      sub_graph_v[nodecnt] = v\n    else\n      sub_graph_flag[v] = false\n      local lv = level[v]\n      level_vertex_count[lv] = level_vertex_count[lv] - 1\n    end\n  end\n  sub_graph_size = nodecnt\n  for i = sub_graph_size, 1, -1 do\n    local v = sub_graph_v[i]\n    local valid = false\n    local sub_edge_idxes_v = sub_edge_idxes[v]\n    for j = 1, sub_edge_cnt[v] do\n      local ei = sub_edge_idxes_v[j]\n      local dst = edge_dst[v][ei]\n      if sub_graph_flag[dst] then valid = true break end\n    end\n    if not valid then\n      sub_graph_flag[v] = false\n      local lv = level[v]\n      level_vertex_count[lv] = level_vertex_count[lv] - 1\n    end\n  end\n  nodecnt = 0\n  for i = 1, sub_graph_size do\n    local v = sub_graph_v[i]\n    if sub_graph_v[v] then\n      nodecnt = nodecnt + 1\n      sub_graph_v[nodecnt] = v\n    end\n  end\n  self.sub_graph_size = nodecnt\nend\n\nMPM.partialwork = function(self)\n  local sum = 0\n  while(self:subGraphConnected()) do\n    local weak_vertex, potential = self:findWeakVertex()\n    self:flowToT(weak_vertex, potential)\n    self:flowFromS(weak_vertex, potential)\n    self:updateSubGraph()\n    sum = sum + potential\n  end\n  return sum\nend\n\nMPM.getMaxFlow = function(self)\n  local ret = 0\n  while(self:makeSubGraph()) do\n    ret = ret + self:partialwork()\n  end\n  return ret\nend\n\nlocal h, w = io.read(\"*n\", \"*n\", \"*l\")\nlocal spos = h * w * 2 + 1\nlocal tpos = spos + 1\nMPM:initialize(tpos, spos, tpos)\nlocal t = {}\nlocal inf = 1000000007\nfor i = 1, h do\n  local s = io.read()\n  for j = 1, w do\n    local idx = (i - 1) * w + j\n    if s:sub(j, j) == \"X\" then\n      t[idx] = 0\n      MPM:addEdge(spos, idx * 2, inf)\n    else\n      t[idx] = inf\n      MPM:addEdge(idx * 2 - 1, idx * 2, 1)\n    end\n    if i == 1 or i == h or j == 1 or j == w then\n      MPM:addEdge(idx * 2, tpos, inf)\n    end\n  end\nend\nfor i = 1, h do\n  for j = 1, w - 1 do\n    local idx1 = (i - 1) * w + j\n    local idx2 = idx1 + 1\n    MPM:addEdge(idx1 * 2, idx2 * 2 - 1, inf)\n    MPM:addEdge(idx2 * 2, idx1 * 2 - 1, inf)\n  end\nend\nfor i = 1, h - 1 do\n  for j = 1, w do\n    local idx1 = (i - 1) * w + j\n    local idx2 = idx1 + w\n    MPM:addEdge(idx1 * 2, idx2 * 2 - 1, inf)\n    MPM:addEdge(idx2 * 2, idx1 * 2 - 1, inf)\n  end\nend\nlocal ret = MPM:getMaxFlow()\nprint(inf <= ret and -1 or ret)\n"
  },
  {
    "language": "Lua",
    "code": "local mmi, mma = math.min, math.max\nlocal MPM = {}\n\nMPM.initialize = function(self, n, spos, tpos)\n  self.n = n\n  self.spos, self.tpos = spos, tpos\n  -- edge_dst[src][i] := dst\n  self.edge_dst = {}\n  -- edge_cap[src][i] := capacity from src to edge_dst[src][i]\n  self.edge_cap = {}\n  -- edge_dst_invedge_idx[src][i] := \"j\" where edge_dst[dst][j] == src\n  -- in this case, edge_dst_invedge_idx[dst][j] should be \"i\".\n  self.edge_dst_invedge_idx = {}\n  -- level[v] := length from spos. level[spos] := 1\n  self.level = {}\n  -- level_vertex_count[i] := count of vertexes that levels are i\n  self.level_vertex_count = {}\n  -- sub_graph_v[i] := list of vertexes that are contained in the sub-graph.\n  self.sub_graph_v = {}\n  -- sub_graph_size := the size of sub_graph_v.\n  -- may not equal to #sub_graph_v (because not cleared).\n  self.sub_graph_size = 0\n  -- sub_graph_flag[v] := whether to contains the vertex v in the sub-graph or not\n  self.sub_graph_flag = {}\n  -- send[v] := sum of sendable amount from v to other vertexes in the sub-graph\n  self.send = {}\n  -- receive[v] := sum of receivable amount toward v from other vertexes in the sub-graph\n  self.receive = {}\n  -- sub_edge_idxes[src][i] := edge (from v) using in the sub-graph.\n  -- for example, if sub_edge_idxes[src][i] is j,\n  -- the edge from src to dst (= edge_dst[src][j]) contains in the sub-graph.\n  self.sub_edge_idxes = {}\n  -- sub_edge_cnt[src] := the size of sub_edge_idxes[src].\n  -- may not equal to #sub_edge_idxes[src] (because not cleared).\n  self.sub_edge_cnt = {}\n  -- sub_invedge_idxes[dst] := edge (to dst) using in the sub-graph.\n  -- for example, if sub_invedge_idxes[dst][i] is j,\n  -- the src is edge_dst[dst][j], and the edge index (from src to dst) is k := edge_dst_invedge_idx[dst][j].\n  -- so edge_dst[src][k] is the edge from src to dst using in the sub-graph.\n  self.sub_invedge_idxes = {}\n  -- sub_invedge_cnt[dst] := the size of sub_invedge_idxes[dst].\n  -- may not equal to #sub_invedge_idxes[dst] (because not cleared).\n  self.sub_invedge_cnt = {}\n  -- flow_route[v] := [for \"flowToT\"] whether to contain in the route from weak_vertex to tpos.\n  self.flow_route = {}\n  -- actual_flow_amount[v] := [for \"flowToT\"] send amount from v\n  self.actual_flow_amount = {}\n  for i = 1, n do\n    self.edge_dst[i] = {}\n    self.edge_cap[i] = {}\n    self.edge_dst_invedge_idx[i] = {}\n    self.level[i] = 0\n    self.level_vertex_count[i] = 0\n    self.sub_graph_flag[i] = false\n    self.send[i] = 0\n    self.receive[i] = 0\n    self.sub_edge_idxes[i] = {}\n    self.sub_edge_cnt[i] = 0\n    self.sub_invedge_idxes[i] = {}\n    self.sub_invedge_cnt[i] = 0\n    self.flow_route[i] = false\n    self.actual_flow_amount[i] = 0\n  end\nend\n\nMPM.addEdge = function(self, src, dst, cap, invcap)\n  if not invcap then invcap = 0 end\n  table.insert(self.edge_dst[src], dst)\n  table.insert(self.edge_cap[src], cap)\n  table.insert(self.edge_dst_invedge_idx[src], 1 + #self.edge_dst[dst])\n  table.insert(self.edge_dst[dst], src)\n  table.insert(self.edge_cap[dst], invcap)\n  table.insert(self.edge_dst_invedge_idx[dst], #self.edge_dst[src])\nend\nMPM.makeSubGraph = function(self)\n  local inf = self.n + 2\n  local level, sub_graph_flag = self.level, self.sub_graph_flag\n  local edge_dst, edge_cap = self.edge_dst, self.edge_cap\n  local edge_dst_invedge_idx = self.edge_dst_invedge_idx\n  local send, receive = self.send, self.receive\n  local sub_graph_v = self.sub_graph_v\n  local sub_edge_idxes, sub_edge_cnt = self.sub_edge_idxes, self.sub_edge_cnt\n  local sub_invedge_idxes, sub_invedge_cnt = self.sub_invedge_idxes, self.sub_invedge_cnt\n  local level_vertex_count = self.level_vertex_count\n  for i = 1, self.n do\n    level[i] = inf\n    sub_graph_flag[i] = false\n    send[i], receive[i] = 0, 0\n    sub_edge_cnt[i] = 0\n    sub_invedge_cnt[i] = 0\n    level_vertex_count[i] = 0\n  end\n  -- BFS\n  level[self.spos] = 1\n  local taskcnt, done = 1, 0\n  sub_graph_v[1] = self.spos\n  local reached = false\n  while done < taskcnt do\n    done = done + 1\n    local src = sub_graph_v[done]\n    if src == self.tpos then reached = true break end\n    for i = 1, #edge_dst[src] do\n      local cap = edge_cap[src][i]\n      if 0 < cap then\n        local dst = edge_dst[src][i]\n        if level[dst] == inf then\n          level[dst] = level[src] + 1\n          taskcnt = taskcnt + 1\n          sub_graph_v[taskcnt] = dst\n        elseif level[dst] == level[src] + 1 then\n        end\n      end\n    end\n  end\n  if not reached then\n    self.sub_graph_size = 0\n    return false\n  end\n  -- restore route\n  sub_graph_flag[self.tpos] = true\n  local curlevel = level[self.tpos]\n  while curlevel == level[sub_graph_v[taskcnt]] do\n    taskcnt = taskcnt - 1\n  end\n  for isrc = taskcnt, 1, -1 do\n    local src = sub_graph_v[isrc]\n    for i = 1, #edge_dst[src] do\n      local dst, cap = edge_dst[src][i], edge_cap[src][i]\n      if 0 < cap and sub_graph_flag[dst]\n      and level[dst] == level[src] + 1 then\n        sub_graph_flag[src] = true\n        local edgecnt = sub_edge_cnt[src] + 1\n        sub_edge_cnt[src] = edgecnt\n        sub_edge_idxes[src][edgecnt] = i\n        sub_invedge_cnt[dst] = sub_invedge_cnt[dst] + 1\n        sub_invedge_idxes[dst][sub_invedge_cnt[dst]] = edge_dst_invedge_idx[src][i]\n        send[src] = send[src] + cap\n        receive[dst] = receive[dst] + cap\n      end\n    end\n    if not sub_graph_flag[src] then\n      for i = 1, #edge_dst[src] do\n        local dst = edge_dst[src][i]\n        local cap = edge_cap[src][i]\n        if 0 < cap and level[dst] == level[src] + 1 then\n          send[src] = send[src] - cap\n          receive[dst] = receive[dst] - cap\n        end\n      end\n    end\n  end\n  -- remove unused vertex from \"taskcnt\" and set as sub_graph_size\n  local nodecnt = 1\n  for i = 1, taskcnt do\n    local v = sub_graph_v[i]\n    if sub_graph_flag[v] then\n      sub_graph_v[nodecnt] = v\n      local lv = level[v]\n      level_vertex_count[lv] = level_vertex_count[lv] + 1\n      nodecnt = nodecnt + 1\n    end\n  end\n  if sub_graph_v[nodecnt - 1] == self.tpos then\n    nodecnt = nodecnt - 1\n  else\n    sub_graph_v[nodecnt] = self.tpos\n    local lv = level[self.tpos]\n    level_vertex_count[lv] = level_vertex_count[lv] + 1\n  end\n  self.sub_graph_size = nodecnt\n  return true\nend\n\nMPM.subGraphConnected = function(self)\n  local max_level = self.level[self.tpos]\n  local level_vertex_count = self.level_vertex_count\n  for i = 1, max_level do\n    if level_vertex_count[i] <= 0 then return false end\n  end\n  return true\nend\n\nMPM.findWeakVertex = function(self)\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_size = self.sub_graph_size\n  local send, receive = self.send, self.receive\n  local min_vertex = self.spos\n  local min_potential = send[min_vertex]\n  if receive[self.tpos] < min_potential then\n    min_vertex = self.tpos\n    min_potential = receive[min_vertex]\n  end\n  if min_potential == 1 then\n    return min_vertex, min_potential\n  end\n  for i = 2, sub_graph_size - 1 do\n    local v = sub_graph_v[i]\n    local min_v = mmi(send[v], receive[v])\n    if min_v < min_potential then\n      min_potential, min_vertex = min_v, v\n    end\n    if min_potential == 1 then\n      return min_vertex, min_potential\n    end\n  end\n  return min_vertex, min_potential\nend\n\nMPM.flowToT = function(self, weak_vertex, potential)\n  if weak_vertex == self.tpos then return end\n  local sub_graph_flag = self.sub_graph_flag\n  local edge_dst, edge_cap = self.edge_dst, self.edge_cap\n  local edge_dst_invedge_idx = self.edge_dst_invedge_idx\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_size = self.sub_graph_size\n  local sub_edge_cnt = self.sub_edge_cnt\n  local sub_edge_idxes = self.sub_edge_idxes\n  local send, receive = self.send, self.receive\n  local level = self.level\n  local flow_route = self.flow_route\n  local actual_flow_amount = self.actual_flow_amount\n  local tpos = self.tpos\n  for i = 1, sub_graph_size do\n    local v = sub_graph_v[i]\n    flow_route[v] = false\n    actual_flow_amount[v] = 0\n  end\n  flow_route[weak_vertex] = true\n  actual_flow_amount[weak_vertex] = potential\n  local weak_vertex_level = level[weak_vertex]\n  local max_level = level[tpos]\n  for iv = 1, sub_graph_size do\n    local src = sub_graph_v[iv]\n    local lv = level[src]\n    if lv == max_level then break end\n    local need_to_send = actual_flow_amount[src]\n    if flow_route[src] and 0 < need_to_send then\n      send[src] = send[src] - need_to_send\n      local sub_edge_idxes_src = sub_edge_idxes[src]\n      local dsts, caps, invidxes = edge_dst[src], edge_cap[src], edge_dst_invedge_idx[src]\n      local used = 0\n      -- use edge in descending order, to remove used edges quickly\n      for j = sub_edge_cnt[src], 1, -1 do\n        local edgeidx = sub_edge_idxes_src[j]\n        local dst, cap = dsts[edgeidx], caps[edgeidx]\n        local actual_flow = mmi(cap, need_to_send)\n        receive[dst] = receive[dst] - actual_flow\n        caps[edgeidx] = caps[edgeidx] - actual_flow\n        need_to_send = need_to_send - actual_flow\n        flow_route[dst] = true\n        actual_flow_amount[dst] = actual_flow_amount[dst] + actual_flow\n        local inv_edge_idx = invidxes[edgeidx]\n        edge_cap[dst][inv_edge_idx] = edge_cap[dst][inv_edge_idx] + actual_flow\n        if caps[edgeidx] == 0 then\n          used = used + 1\n        end\n        if need_to_send == 0 then\n          break\n        end\n      end\n      sub_edge_cnt[src] = sub_edge_cnt[src] - used\n    end\n  end\nend\n\nMPM.flowFromS = function(self, weak_vertex, potential)\n  if weak_vertex == self.spos then return end\n  local sub_graph_flag = self.sub_graph_flag\n  local edge_dst, edge_cap = self.edge_dst, self.edge_cap\n  local edge_dst_invedge_idx = self.edge_dst_invedge_idx\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_size = self.sub_graph_size\n  local sub_edge_cnt = self.sub_edge_cnt\n  local sub_edge_idxes = self.sub_edge_idxes\n  local sub_invedge_idxes = self.sub_invedge_idxes\n  local sub_invedge_cnt = self.sub_invedge_cnt\n  local send, receive = self.send, self.receive\n  local level = self.level\n  local flow_route = self.flow_route\n  local actual_flow_amount = self.actual_flow_amount\n  local spos = self.spos\n  for i = 1, sub_graph_size do\n    local v = sub_graph_v[i]\n    flow_route[v] = false\n    actual_flow_amount[v] = 0\n  end\n  flow_route[weak_vertex] = true\n  actual_flow_amount[weak_vertex] = potential\n  local weak_vertex_level = level[weak_vertex]\n  local max_level = level[tpos]\n  for iv = sub_graph_size, 1, -1 do\n    local dst = sub_graph_v[iv]\n    local lv = level[dst]\n    if lv == 1 then break end\n    local need_to_receive = actual_flow_amount[dst]\n    if flow_route[dst] and 0 < need_to_receive then\n      receive[dst] = receive[dst] - need_to_receive\n      local sub_invedge_idxes_dst = sub_invedge_idxes[dst]\n      local srcs = edge_dst[dst]\n      local inv_invidxes = edge_dst_invedge_idx[dst]\n      -- local dsts, caps, invidxes = edge_dst[src], edge_cap[src], edge_dst_invedge_idx[src]\n      local used = 0\n      -- use edge in descending order, to remove used edges quickly\n      for j = sub_invedge_cnt[dst], 1, -1 do\n        local invedgeidx = sub_invedge_idxes_dst[j]\n        local src = srcs[invedgeidx]\n        local edgeidx = inv_invidxes[invedgeidx]\n        assert(edge_dst[src][edgeidx] == dst)\n        local cap = edge_cap[src][edgeidx]\n        local actual_flow = mmi(cap, need_to_receive)\n\n        send[src] = send[src] - actual_flow\n        edge_cap[src][edgeidx] = edge_cap[src][edgeidx] - actual_flow\n        need_to_receive = need_to_receive - actual_flow\n        flow_route[src] = true\n        actual_flow_amount[src] = actual_flow_amount[src] + actual_flow\n        edge_cap[dst][invedgeidx] = edge_cap[dst][invedgeidx] + actual_flow\n        if edge_cap[src][edgeidx] == 0 then\n          used = used + 1\n        end\n        if need_to_receive == 0 then\n          break\n        end\n      end\n      sub_invedge_cnt[dst] = sub_invedge_cnt[dst] - used\n    end\n  end\nend\n\nMPM.updateSubGraph = function(self)\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_size = self.sub_graph_size\n  local sub_graph_flag = self.sub_graph_flag\n  local send, receive = self.send, self.receive\n  local spos, tpos = self.spos, self.tpos\n  local level = self.level\n  local level_vertex_count = self.level_vertex_count\n  local sub_edge_idxes = self.sub_edge_idxes\n  local sub_edge_cnt = self.sub_edge_cnt\n  local edge_dst = self.edge_dst\n  local sub_invedge_idxes = self.sub_invedge_idxes\n  local sub_invedge_cnt = self.sub_invedge_cnt\n  local nodecnt = 0\n  for i = 1, sub_graph_size do\n    local v = sub_graph_v[i]\n    local valid = true\n    if v ~= spos and receive[v] <= 0 then valid = false end\n    if v ~= tpos and send[v] <= 0 then valid = false end\n    if valid then\n      local sub_invedge_idxes_v = sub_invedge_idxes[v]\n      valid = false\n      for j = 1, sub_invedge_cnt[v] do\n        local ei = sub_invedge_idxes_v[j]\n        local src = edge_dst[v][ei]\n        if sub_graph_flag[src] then valid = true break end\n      end\n    end\n    if valid then\n      nodecnt = nodecnt + 1\n      sub_graph_v[nodecnt] = v\n    else\n      sub_graph_flag[v] = false\n      local lv = level[v]\n      level_vertex_count[lv] = level_vertex_count[lv] - 1\n    end\n  end\n  sub_graph_size = nodecnt\n  for i = sub_graph_size, 1, -1 do\n    local v = sub_graph_v[i]\n    local valid = false\n    local sub_edge_idxes_v = sub_edge_idxes[v]\n    for j = 1, sub_edge_cnt[v] do\n      local ei = sub_edge_idxes_v[j]\n      local dst = edge_dst[v][ei]\n      if sub_graph_flag[dst] then valid = true break end\n    end\n    if not valid then\n      sub_graph_flag[v] = false\n      local lv = level[v]\n      level_vertex_count[lv] = level_vertex_count[lv] - 1\n    end\n  end\n  nodecnt = 0\n  for i = 1, sub_graph_size do\n    local v = sub_graph_v[i]\n    if sub_graph_v[v] then\n      nodecnt = nodecnt + 1\n      sub_graph_v[nodecnt] = v\n    end\n  end\n  self.sub_graph_size = nodecnt\nend\n\nMPM.partialwork = function(self)\n  local sum = 0\n  while(self:subGraphConnected()) do\n    local weak_vertex, potential = self:findWeakVertex()\n    self:flowToT(weak_vertex, potential)\n    self:flowFromS(weak_vertex, potential)\n    self:updateSubGraph()\n    sum = sum + potential\n  end\n  return sum\nend\n\nMPM.getMaxFlow = function(self)\n  local ret = 0\n  while(self:makeSubGraph()) do\n    ret = ret + self:partialwork()\n  end\n  return ret\nend\n\nlocal h, w = io.read(\"*n\", \"*n\", \"*l\")\nlocal spos = h * w * 2 + 1\nlocal tpos = spos + 1\nMPM:initialize(tpos, spos, tpos)\nlocal t = {}\nlocal inf = 1000000007\nfor i = 1, h do\n  local s = io.read()\n  for j = 1, w do\n    local idx = (i - 1) * w + j\n    if s:sub(j, j) == \"X\" then\n      t[idx] = 0\n      MPM:addEdge(spos, idx * 2, inf)\n    else\n      t[idx] = inf\n      MPM:addEdge(idx * 2 - 1, idx * 2, 1)\n    end\n    if i == 1 or i == h or j == 1 or j == w then\n      MPM:addEdge(idx * 2, tpos, inf)\n    end\n  end\nend\nfor i = 1, h do\n  for j = 1, w - 1 do\n    local idx1 = (i - 1) * w + j\n    local idx2 = idx1 + 1\n    MPM:addEdge(idx1 * 2, idx2 * 2 - 1, inf)\n    MPM:addEdge(idx2 * 2, idx1 * 2 - 1, inf)\n  end\nend\nfor i = 1, h - 1 do\n  for j = 1, w do\n    local idx1 = (i - 1) * w + j\n    local idx2 = idx1 + w\n    MPM:addEdge(idx1 * 2, idx2 * 2 - 1, inf)\n    MPM:addEdge(idx2 * 2, idx1 * 2 - 1, inf)\n  end\nend\nlocal ret = MPM:getMaxFlow()\nprint(inf <= ret and -1 or ret)\n"
  },
  {
    "language": "Lua",
    "code": "local mmi, mma = math.min, math.max\nlocal MPM = {}\n\nMPM.initialize = function(self, n, spos, tpos)\n  self.n = n\n  self.spos, self.tpos = spos, tpos\n  -- edge_dst[src][i] := dst\n  self.edge_dst = {}\n  -- edge_cap[src][i] := capacity from src to edge_dst[src][i]\n  self.edge_cap = {}\n  -- edge_dst_invedge_idx[src][i] := \"j\" where edge_dst[dst][j] == src\n  -- in this case, edge_dst_invedge_idx[dst][j] should be \"i\".\n  self.edge_dst_invedge_idx = {}\n  -- level[v] := length from spos. level[spos] := 1\n  self.level = {}\n  -- level_vertex_count[i] := count of vertexes that levels are i\n  self.level_vertex_count = {}\n  -- sub_graph_v[i] := list of vertexes that are contained in the sub-graph.\n  self.sub_graph_v = {}\n  -- sub_graph_size := the size of sub_graph_v.\n  -- may not equal to #sub_graph_v (because not cleared).\n  self.sub_graph_size = 0\n  -- sub_graph_flag[v] := whether to contains the vertex v in the sub-graph or not\n  self.sub_graph_flag = {}\n  -- send[v] := sum of sendable amount from v to other vertexes in the sub-graph\n  self.send = {}\n  -- receive[v] := sum of receivable amount toward v from other vertexes in the sub-graph\n  self.receive = {}\n  -- sub_edge_idxes[src][i] := edge (from v) using in the sub-graph.\n  -- for example, if sub_edge_idxes[src][i] is j,\n  -- the edge from src to dst (= edge_dst[src][j]) contains in the sub-graph.\n  self.sub_edge_idxes = {}\n  -- sub_edge_cnt[src] := the size of sub_edge_idxes[src].\n  -- may not equal to #sub_edge_idxes[src] (because not cleared).\n  self.sub_edge_cnt = {}\n  -- sub_invedge_idxes[dst] := edge (to dst) using in the sub-graph.\n  -- for example, if sub_invedge_idxes[dst][i] is j,\n  -- the src is edge_dst[dst][j], and the edge index (from src to dst) is k := edge_dst_invedge_idx[dst][j].\n  -- so edge_dst[src][k] is the edge from src to dst using in the sub-graph.\n  self.sub_invedge_idxes = {}\n  -- sub_invedge_cnt[dst] := the size of sub_invedge_idxes[dst].\n  -- may not equal to #sub_invedge_idxes[dst] (because not cleared).\n  self.sub_invedge_cnt = {}\n  -- flow_route[v] := [for \"flowToT\"] whether to contain in the route from weak_vertex to tpos.\n  self.flow_route = {}\n  -- actual_flow_amount[v] := [for \"flowToT\"] send amount from v\n  self.actual_flow_amount = {}\n  for i = 1, n do\n    self.edge_dst[i] = {}\n    self.edge_cap[i] = {}\n    self.edge_dst_invedge_idx[i] = {}\n    self.level[i] = 0\n    self.level_vertex_count[i] = 0\n    self.sub_graph_flag[i] = false\n    self.send[i] = 0\n    self.receive[i] = 0\n    self.sub_edge_idxes[i] = {}\n    self.sub_edge_cnt[i] = 0\n    self.sub_invedge_idxes[i] = {}\n    self.sub_invedge_cnt[i] = 0\n    self.flow_route[i] = false\n    self.actual_flow_amount[i] = 0\n  end\nend\n\nMPM.addEdge = function(self, src, dst, cap, invcap)\n  if not invcap then invcap = 0 end\n  table.insert(self.edge_dst[src], dst)\n  table.insert(self.edge_cap[src], cap)\n  table.insert(self.edge_dst_invedge_idx[src], 1 + #self.edge_dst[dst])\n  table.insert(self.edge_dst[dst], src)\n  table.insert(self.edge_cap[dst], invcap)\n  table.insert(self.edge_dst_invedge_idx[dst], #self.edge_dst[src])\nend\nMPM.makeSubGraph = function(self)\n  local inf = self.n + 2\n  local level, sub_graph_flag = self.level, self.sub_graph_flag\n  local edge_dst, edge_cap = self.edge_dst, self.edge_cap\n  local edge_dst_invedge_idx = self.edge_dst_invedge_idx\n  local send, receive = self.send, self.receive\n  local sub_graph_v = self.sub_graph_v\n  local sub_edge_idxes, sub_edge_cnt = self.sub_edge_idxes, self.sub_edge_cnt\n  local sub_invedge_idxes, sub_invedge_cnt = self.sub_invedge_idxes, self.sub_invedge_cnt\n  local level_vertex_count = self.level_vertex_count\n  for i = 1, self.n do\n    level[i] = inf\n    sub_graph_flag[i] = false\n    send[i], receive[i] = 0, 0\n    sub_edge_cnt[i] = 0\n    sub_invedge_cnt[i] = 0\n    level_vertex_count[i] = 0\n  end\n  -- BFS\n  level[self.spos] = 1\n  local taskcnt, done = 1, 0\n  sub_graph_v[1] = self.spos\n  local reached = false\n  while done < taskcnt do\n    done = done + 1\n    local src = sub_graph_v[done]\n    if src == self.tpos then reached = true break end\n    for i = 1, #edge_dst[src] do\n      local cap = edge_cap[src][i]\n      if 0 < cap then\n        local dst = edge_dst[src][i]\n        if level[dst] == inf then\n          level[dst] = level[src] + 1\n          taskcnt = taskcnt + 1\n          sub_graph_v[taskcnt] = dst\n        elseif level[dst] == level[src] + 1 then\n        end\n      end\n    end\n  end\n  if not reached then\n    self.sub_graph_size = 0\n    return false\n  end\n  -- restore route\n  sub_graph_flag[self.tpos] = true\n  local curlevel = level[self.tpos]\n  while curlevel == level[sub_graph_v[taskcnt]] do\n    taskcnt = taskcnt - 1\n  end\n  for isrc = taskcnt, 1, -1 do\n    local src = sub_graph_v[isrc]\n    for i = 1, #edge_dst[src] do\n      local dst, cap = edge_dst[src][i], edge_cap[src][i]\n      if 0 < cap and sub_graph_flag[dst]\n      and level[dst] == level[src] + 1 then\n        sub_graph_flag[src] = true\n        local edgecnt = sub_edge_cnt[src] + 1\n        sub_edge_cnt[src] = edgecnt\n        sub_edge_idxes[src][edgecnt] = i\n        sub_invedge_cnt[dst] = sub_invedge_cnt[dst] + 1\n        sub_invedge_idxes[dst][sub_invedge_cnt[dst]] = edge_dst_invedge_idx[src][i]\n        send[src] = send[src] + cap\n        receive[dst] = receive[dst] + cap\n      end\n    end\n    if not sub_graph_flag[src] then\n      for i = 1, #edge_dst[src] do\n        local dst = edge_dst[src][i]\n        local cap = edge_cap[src][i]\n        if 0 < cap and level[dst] == level[src] + 1 then\n          send[src] = send[src] - cap\n          receive[dst] = receive[dst] - cap\n        end\n      end\n    end\n  end\n  -- remove unused vertex from \"taskcnt\" and set as sub_graph_size\n  local nodecnt = 1\n  for i = 1, taskcnt do\n    local v = sub_graph_v[i]\n    if sub_graph_flag[v] then\n      sub_graph_v[nodecnt] = v\n      local lv = level[v]\n      level_vertex_count[lv] = level_vertex_count[lv] + 1\n      nodecnt = nodecnt + 1\n    end\n  end\n  if sub_graph_v[nodecnt - 1] == self.tpos then\n    nodecnt = nodecnt - 1\n  else\n    sub_graph_v[nodecnt] = self.tpos\n    local lv = level[self.tpos]\n    level_vertex_count[lv] = level_vertex_count[lv] + 1\n  end\n  self.sub_graph_size = nodecnt\n  return true\nend\n\nMPM.subGraphConnected = function(self)\n  local max_level = self.level[self.tpos]\n  local level_vertex_count = self.level_vertex_count\n  for i = 1, max_level do\n    if level_vertex_count[i] <= 0 then return false end\n  end\n  return true\nend\n\nMPM.findWeakVertex = function(self)\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_size = self.sub_graph_size\n  local send, receive = self.send, self.receive\n  local min_vertex = self.spos\n  local min_potential = send[min_vertex]\n  if receive[self.tpos] < min_potential then\n    min_vertex = self.tpos\n    min_potential = receive[min_vertex]\n  end\n  if min_potential == 1 then\n    return min_vertex, min_potential\n  end\n  for i = 2, sub_graph_size - 1 do\n    local v = sub_graph_v[i]\n    local min_v = mmi(send[v], receive[v])\n    if min_v < min_potential then\n      min_potential, min_vertex = min_v, v\n    end\n    if min_potential == 1 then\n      return min_vertex, min_potential\n    end\n  end\n  return min_vertex, min_potential\nend\n\nMPM.flowToT = function(self, weak_vertex, potential)\n  if weak_vertex == self.tpos then return end\n  local sub_graph_flag = self.sub_graph_flag\n  local edge_dst, edge_cap = self.edge_dst, self.edge_cap\n  local edge_dst_invedge_idx = self.edge_dst_invedge_idx\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_size = self.sub_graph_size\n  local sub_edge_cnt = self.sub_edge_cnt\n  local sub_edge_idxes = self.sub_edge_idxes\n  local send, receive = self.send, self.receive\n  local level = self.level\n  local flow_route = self.flow_route\n  local actual_flow_amount = self.actual_flow_amount\n  local tpos = self.tpos\n  for i = 1, sub_graph_size do\n    local v = sub_graph_v[i]\n    flow_route[v] = false\n    actual_flow_amount[v] = 0\n  end\n  flow_route[weak_vertex] = true\n  actual_flow_amount[weak_vertex] = potential\n  local weak_vertex_level = level[weak_vertex]\n  local max_level = level[tpos]\n  for iv = 1, sub_graph_size do\n    local src = sub_graph_v[iv]\n    local lv = level[src]\n    if lv == max_level then break end\n    local need_to_send = actual_flow_amount[src]\n    if flow_route[src] and 0 < need_to_send then\n      send[src] = send[src] - need_to_send\n      local sub_edge_idxes_src = sub_edge_idxes[src]\n      local dsts, caps, invidxes = edge_dst[src], edge_cap[src], edge_dst_invedge_idx[src]\n      local used = 0\n      -- use edge in descending order, to remove used edges quickly\n      for j = sub_edge_cnt[src], 1, -1 do\n        local edgeidx = sub_edge_idxes_src[j]\n        local dst, cap = dsts[edgeidx], caps[edgeidx]\n        local actual_flow = mmi(cap, need_to_send)\n        receive[dst] = receive[dst] - actual_flow\n        caps[edgeidx] = caps[edgeidx] - actual_flow\n        need_to_send = need_to_send - actual_flow\n        flow_route[dst] = true\n        actual_flow_amount[dst] = actual_flow_amount[dst] + actual_flow\n        local inv_edge_idx = invidxes[edgeidx]\n        edge_cap[dst][inv_edge_idx] = edge_cap[dst][inv_edge_idx] + actual_flow\n        if caps[edgeidx] == 0 then\n          used = used + 1\n        end\n        if need_to_send == 0 then\n          break\n        end\n      end\n      sub_edge_cnt[src] = sub_edge_cnt[src] - used\n    end\n  end\nend\n\nMPM.flowFromS = function(self, weak_vertex, potential)\n  if weak_vertex == self.spos then return end\n  local sub_graph_flag = self.sub_graph_flag\n  local edge_dst, edge_cap = self.edge_dst, self.edge_cap\n  local edge_dst_invedge_idx = self.edge_dst_invedge_idx\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_size = self.sub_graph_size\n  local sub_edge_cnt = self.sub_edge_cnt\n  local sub_edge_idxes = self.sub_edge_idxes\n  local sub_invedge_idxes = self.sub_invedge_idxes\n  local sub_invedge_cnt = self.sub_invedge_cnt\n  local send, receive = self.send, self.receive\n  local level = self.level\n  local flow_route = self.flow_route\n  local actual_flow_amount = self.actual_flow_amount\n  local spos = self.spos\n  for i = 1, sub_graph_size do\n    local v = sub_graph_v[i]\n    flow_route[v] = false\n    actual_flow_amount[v] = 0\n  end\n  flow_route[weak_vertex] = true\n  actual_flow_amount[weak_vertex] = potential\n  local weak_vertex_level = level[weak_vertex]\n  local max_level = level[tpos]\n  for iv = sub_graph_size, 1, -1 do\n    local dst = sub_graph_v[iv]\n    local lv = level[dst]\n    if lv == 1 then break end\n    local need_to_receive = actual_flow_amount[dst]\n    if flow_route[dst] and 0 < need_to_receive then\n      receive[dst] = receive[dst] - need_to_receive\n      local sub_invedge_idxes_dst = sub_invedge_idxes[dst]\n      local srcs = edge_dst[dst]\n      local inv_invidxes = edge_dst_invedge_idx[dst]\n      -- local dsts, caps, invidxes = edge_dst[src], edge_cap[src], edge_dst_invedge_idx[src]\n      local used = 0\n      -- use edge in descending order, to remove used edges quickly\n      for j = sub_invedge_cnt[dst], 1, -1 do\n        local invedgeidx = sub_invedge_idxes_dst[j]\n        local src = srcs[invedgeidx]\n        local edgeidx = inv_invidxes[invedgeidx]\n        assert(edge_dst[src][edgeidx] == dst)\n        local cap = edge_cap[src][edgeidx]\n        local actual_flow = mmi(cap, need_to_receive)\n\n        send[src] = send[src] - actual_flow\n        edge_cap[src][edgeidx] = edge_cap[src][edgeidx] - actual_flow\n        need_to_receive = need_to_receive - actual_flow\n        flow_route[src] = true\n        actual_flow_amount[src] = actual_flow_amount[src] + actual_flow\n        edge_cap[dst][invedgeidx] = edge_cap[dst][invedgeidx] + actual_flow\n        if edge_cap[src][edgeidx] == 0 then\n          used = used + 1\n        end\n        if need_to_receive == 0 then\n          break\n        end\n      end\n      sub_invedge_cnt[dst] = sub_invedge_cnt[dst] - used\n    end\n  end\nend\n\nMPM.updateSubGraph = function(self)\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_size = self.sub_graph_size\n  local sub_graph_flag = self.sub_graph_flag\n  local send, receive = self.send, self.receive\n  local spos, tpos = self.spos, self.tpos\n  local level = self.level\n  local level_vertex_count = self.level_vertex_count\n  local sub_edge_idxes = self.sub_edge_idxes\n  local sub_edge_cnt = self.sub_edge_cnt\n  local edge_dst = self.edge_dst\n  local sub_invedge_idxes = self.sub_invedge_idxes\n  local sub_invedge_cnt = self.sub_invedge_cnt\n  local nodecnt = 0\n  for i = 1, sub_graph_size do\n    local v = sub_graph_v[i]\n    local valid = true\n    if v ~= spos and receive[v] <= 0 then valid = false end\n    if v ~= tpos and send[v] <= 0 then valid = false end\n    if valid then\n      local sub_invedge_idxes_v = sub_invedge_idxes[v]\n      valid = false\n      for j = 1, sub_invedge_cnt[v] do\n        local ei = sub_invedge_idxes_v[j]\n        local src = edge_dst[v][ei]\n        if sub_graph_flag[src] then valid = true break end\n      end\n    end\n    if valid then\n      nodecnt = nodecnt + 1\n      sub_graph_v[nodecnt] = v\n    else\n      sub_graph_flag[v] = false\n      local lv = level[v]\n      level_vertex_count[lv] = level_vertex_count[lv] - 1\n    end\n  end\n  sub_graph_size = nodecnt\n  for i = sub_graph_size, 1, -1 do\n    local v = sub_graph_v[i]\n    local valid = false\n    local sub_edge_idxes_v = sub_edge_idxes[v]\n    for j = 1, sub_edge_cnt[v] do\n      local ei = sub_edge_idxes_v[j]\n      local dst = edge_dst[v][ei]\n      if sub_graph_flag[dst] then valid = true break end\n    end\n    if not valid then\n      sub_graph_flag[v] = false\n      local lv = level[v]\n      level_vertex_count[lv] = level_vertex_count[lv] - 1\n    end\n  end\n  nodecnt = 0\n  for i = 1, sub_graph_size do\n    local v = sub_graph_v[i]\n    if sub_graph_v[v] then\n      nodecnt = nodecnt + 1\n      sub_graph_v[nodecnt] = v\n    end\n  end\n  self.sub_graph_size = nodecnt\nend\n\nMPM.partialwork = function(self)\n  local sum = 0\n  while(self:subGraphConnected()) do\n    local weak_vertex, potential = self:findWeakVertex()\n    self:flowToT(weak_vertex, potential)\n    self:flowFromS(weak_vertex, potential)\n    self:updateSubGraph()\n    sum = sum + potential\n  end\n  return sum\nend\n\nMPM.getMaxFlow = function(self)\n  local ret = 0\n  while(self:makeSubGraph()) do\n    ret = ret + self:partialwork()\n  end\n  return ret\nend\n\nlocal h, w = io.read(\"*n\", \"*n\", \"*l\")\nlocal spos = h * w * 2 + 1\nlocal tpos = spos + 1\nMPM:initialize(tpos, spos, tpos)\nlocal t = {}\nlocal tasks = {}\nlocal inf = 1000000007\nfor i = 1, h do\n  local s = io.read()\n  for j = 1, w do\n    local idx = (i - 1) * w + j\n    if s:sub(j, j) == \"X\" then\n      t[idx] = 0\n      table.insert(tasks, idx)\n      MPM:addEdge(idx * 2 - 1, idx * 2, inf)\n      MPM:addEdge(spos, idx * 2, inf)\n    else\n      t[idx] = inf\n      MPM:addEdge(idx * 2 - 1, idx * 2, 1)\n    end\n    if i == 1 or i == h or j == 1 or j == w then\n      MPM:addEdge(idx * 2, tpos, inf)\n    end\n  end\nend\n\nlocal function walk(src, dst)\n  if t[src] < t[dst] then\n    MPM:addEdge(src * 2, dst * 2 - 1, inf)\n    MPM:addEdge(dst * 2, src * 2 - 1, inf)\n  end\n  if t[src] + 1 < t[dst] then\n    t[dst] = t[src] + 1\n    table.insert(tasks, dst)\n  end\nend\n\nlocal done = 0\nwhile done < #tasks do\n  done = done + 1\n  local src = tasks[done]\n  if w < src then walk(src, src - w) end\n  if src <= (h - 1) * w then walk(src, src + w) end\n  if 1 < w then\n    if src % w ~= 0 then walk(src, src + 1) end\n    if src % w ~= 1 then walk(src, src - 1) end\n  end\nend\n\nlocal ret = MPM:getMaxFlow()\nprint(inf <= ret and -1 or ret)\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint ta[10010],to[1000010],nt[1000010],co[1000010],F[10010];\nint MF(int s,int t,int e,int min){\n  if(s==t||min==0)return min;\n  int i,r;\n  F[s]=1;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(F[to[i]])continue;\n    r=MF(to[i],t,e,MIN(min,co[i]));\n    co[i]-=r;\n    co[(i+e)%(2*e)]+=r;\n    if(r)return r;\n  }\n  return 0;\n}\n//呼び出す方\n//sからtへの最大流を求める　ノード数v辺の数e　aからbへキャパcのフローが流れる\nint maxf(int s,int t,int v,int e,int *a,int *b,int *c){\n  int i,f,r;\n  for(i=0;i<v;i++)ta[i]=-1;\n  for(i=0;i<e;i++){\n    nt[i  ]=ta[to[i+e]=a[i]];\n    nt[i+e]=ta[to[i  ]=b[i]];\n    co[ta[a[i]]=i  ]=c[i];\n    co[ta[b[i]]=i+e]=0;\n  }\n  for(f=0;r=MF(s,t,e,1e9);f+=r){\n    for(i=0;i<v;i++)F[i]=0;\n    if(f>1000)break;\n  }\n  return f;\n}\nint Y[]={0,1,0,-1};\nint X[]={1,0,-1,0};\nint main(){\n  int h,w,M=1e9,a[100010],b[100010],c[100010],i,j,k,p,ny,nx,np,ans,r=0;\n  char s[110][110]={};\n  scanf(\"%d %d\",&h,&w);\n  for(i=0;i<h;i++)scanf(\"%s\",s[i+1]+1);\n  for(i=1;i<=h;i++){\n    for(j=1;j<=w;j++){\n      p=(i-1)*w+j+1;\n      a[r  ]=p+h*w;\n      b[r  ]=p;\n      c[r++]=1;\n      if(s[i][j]=='X'){\n\ta[r  ]=0;\n\tb[r  ]=p;\n\tc[r++]=M;\n      }\n      for(k=0;k<4;k++){\n\tny=i+Y[k];\n\tnx=j+X[k];\n\tnp=(ny-1)*w+nx+1+h*w;\n\ta[r]=p;\n\tb[r]=s[ny][nx]?np:1;\n\tc[r++]=M;\n      }\n    }\n  }\n  ans=maxf(0,1,h*w*2,r,a,b,c);\n  printf(\"%d\\n\",ans>1000?-1:ans);\n  return 0;\n}\n  \n\t  \n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int32_t flow_type;\n\nconst flow_type flow_inf=400;\n\ntypedef struct flow_edge{\n  int vertex;\n  int next;\n  flow_type capacity;\n} flow_edge;\n\ntypedef struct maxFlowGraph{\n  flow_edge *edge;\n  int *start;\n  int vertex_num;\n  int pointer;\n  int edge_length;\n} graph;\n\ngraph* newGraph(const int vertex_num){\n  graph *g=(graph *)calloc(1,sizeof(graph));\n  g->vertex_num=vertex_num;\n  const int initial_length=4;\n  g->edge=(flow_edge *)calloc(initial_length,sizeof(flow_edge));\n  g->start=(int *)calloc(vertex_num,sizeof(int));\n  g->pointer=0;\n  g->edge_length=initial_length;\n  for(int i=0;i<vertex_num;i++) g->start[i]=-1;\n  return g;\n}\n\nvoid freeGraph(graph *g){\n  free(g->edge);\n  free(g->start);\n  free(g);\n}\n\nvoid addEdge(graph *g,int from,int to,flow_type capa){\n  if(g->pointer==g->edge_length){\n    g->edge_length*=2;\n    g->edge=(flow_edge *)realloc(g->edge,sizeof(flow_edge)*g->edge_length);\n  }\n  int p=g->pointer;\n  g->edge[p]=(flow_edge){to,g->start[from],capa};\n  g->start[from]=p;\n  g->edge[p+1]=(flow_edge){from,g->start[to],0};\n  g->start[to]=p+1;\n  g->pointer+=2;\n}\n\nflow_type dinic_dfs(int v,graph *g,int dst,int *level,int *iter,flow_type e){\n  if(v==dst) return e;\n  flow_type sum=0;\n  for(int p=iter[v];p!=-1 && e>0;p=g->edge[p].next,iter[v]=p){\n    int u=g->edge[p].vertex;\n    flow_type capa=g->edge[p].capacity;\n    if(level[u]<=level[v] || capa<=0) continue;\n    flow_type f=dinic_dfs(u,g,dst,level,iter,capa<e?capa:e);\n    if(f>0){\n      g->edge[p].capacity-=f;\n      g->edge[p^1].capacity+=f;\n      sum+=f;\n      e-=f;\n      if(e<=0) return sum;\n    }\n  }\n  return sum;\n}\n\nflow_type dinic(const graph *input_graph,const int src,const int dst){\n  const int vertex_num=input_graph->vertex_num;\n  const int edge_num=input_graph->pointer;\n  graph *g=(graph *)calloc(1,sizeof(graph));\n  g->edge=(flow_edge *)malloc(sizeof(flow_edge)*edge_num);\n  g->start=(int *)malloc(sizeof(int)*vertex_num);\n  memcpy(g->edge,input_graph->edge,sizeof(flow_edge)*edge_num);\n  memcpy(g->start,input_graph->start,sizeof(int)*vertex_num);\n  int *level=(int *)calloc(vertex_num,sizeof(int));\n  int *queue=(int *)calloc(vertex_num,sizeof(int));\n  int *iter=(int *)calloc(vertex_num,sizeof(int));\n  flow_type flow=0;\n  while(1){\n    memset(level,0,sizeof(int)*vertex_num);\n    int front=0,last=0;\n    level[src]=1;\n    queue[last++]=src;\n    while(front<last && level[dst]==0){\n      const int v=queue[front++];\n      for(int p=g->start[v];p!=-1;p=g->edge[p].next){\n\tint u=g->edge[p].vertex;\n\tif(g->edge[p].capacity>0 && level[u]==0){\n\t  level[u]=level[v]+1;\n\t  queue[last++]=u;\n\t}\n      }\n    }\n    if(level[dst]==0) break;\n    memcpy(iter,g->start,sizeof(int)*vertex_num);\n    while(1){\n      flow_type f=dinic_dfs(src,g,dst,level,iter,flow_inf);\n      if(f<=0) break;\n      flow+=f;\n      if (flow >= flow_inf) break;\n    }\n    if (flow >= flow_inf) break;\n  }\n  freeGraph(g);\n  free(level);\n  free(queue);\n  free(iter);\n  return flow;\n}\n\ntypedef int32_t i32;\n\nvoid run (void) {\n  i32 h, w;\n  scanf(\"%\" SCNi32 \"%\" SCNi32, &h, &w);\n  char *s = (char *) calloc (h * w + 1, sizeof (char));\n  for (i32 i = 0; i < h; ++i) {\n    scanf (\"%s\", s + i * w);\n  }\n  graph *g = newGraph (2 * h * w + 2);\n  i32 src = 2 * h * w;\n  i32 dst = src + 1;\n  for (i32 i = 0; i < h; ++i) {\n    for (i32 j = 0; j < w; ++j) {\n      if (i == 0 || i == h - 1 || j == 0 || j == w - 1) {\n\taddEdge (g, i * w + j, dst, flow_inf);\n      }\n      if (s[i * w + j] == 'X') {\n\taddEdge (g, src, i * w + j, flow_inf);\n\taddEdge (g, h * w + i * w + j, i * w + j, flow_inf);\n      } else {\n\taddEdge (g, h * w + i * w + j, i * w + j, 1);\n      }\n      i32 d[] = {-1, 0, 1, 0};\n      for (i32 k = 0; k < 4; ++k) {\n\ti32 x = i + d[k];\n\ti32 y = j + d[k ^ 1];\n\tif (!(0 <= x && x < h && 0 <= y && y < w)) continue;\n\taddEdge (g, i * w + j, h * w + x * w + y, flow_inf);\n      }\n    }\n  }\n  i32 ans = dinic(g, src, dst);\n  if (ans >= flow_inf) {\n    puts(\"-1\");\n  } else {\n    printf(\"%\" PRIi32 \"\\n\", ans);\n  }\n}\n\nint main (void) {\n  run ();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int flow_type;\n\nconst flow_type flow_inf=400;\n\ntypedef struct flow_edge{\n  int vertex;\n  int next;\n  flow_type capacity;\n} flow_edge;\n\ntypedef struct maxFlowGraph{\n  flow_edge *edge;\n  int *start;\n  int vertex_num;\n  int pointer;\n  int edge_length;\n} graph;\n\ngraph* newGraph(const int vertex_num){\n  graph *g=(graph *)calloc(1,sizeof(graph));\n  g->vertex_num=vertex_num;\n  const int initial_length=4;\n  g->edge=(flow_edge *)calloc(initial_length,sizeof(flow_edge));\n  g->start=(int *)calloc(vertex_num,sizeof(int));\n  g->pointer=0;\n  g->edge_length=initial_length;\n  for(int i=0;i<vertex_num;i++) g->start[i]=-1;\n  return g;\n}\n\nvoid freeGraph(graph *g){\n  free(g->edge);\n  free(g->start);\n  free(g);\n}\n\nvoid addEdge(graph *g,int from,int to,flow_type capa){\n  if(g->pointer==g->edge_length){\n    g->edge_length*=2;\n    g->edge=(flow_edge *)realloc(g->edge,sizeof(flow_edge)*g->edge_length);\n  }\n  int p=g->pointer;\n  g->edge[p]=(flow_edge){to,g->start[from],capa};\n  g->start[from]=p;\n  g->edge[p+1]=(flow_edge){from,g->start[to],0};\n  g->start[to]=p+1;\n  g->pointer+=2;\n}\n\nflow_type dinic_dfs(int v,graph *g,int dst,int *level,int *iter,flow_type e){\n  if(v==dst) return e;\n  flow_type sum=0;\n  for(int p=iter[v];p!=-1 && e>0;p=g->edge[p].next,iter[v]=p){\n    int u=g->edge[p].vertex;\n    flow_type capa=g->edge[p].capacity;\n    if(level[u]<=level[v] || capa<=0) continue;\n    flow_type f=dinic_dfs(u,g,dst,level,iter,capa<e?capa:e);\n    if(f>0){\n      g->edge[p].capacity-=f;\n      g->edge[p^1].capacity+=f;\n      sum+=f;\n      e-=f;\n    }\n  }\n  return sum;\n}\n\nflow_type dinic(const graph *input_graph,const int src,const int dst){\n  const int vertex_num=input_graph->vertex_num;\n  const int edge_num=input_graph->pointer;\n  graph *g=(graph *)calloc(1,sizeof(graph));\n  g->edge=(flow_edge *)malloc(sizeof(flow_edge)*edge_num);\n  g->start=(int *)malloc(sizeof(int)*vertex_num);\n  memcpy(g->edge,input_graph->edge,sizeof(flow_edge)*edge_num);\n  memcpy(g->start,input_graph->start,sizeof(int)*vertex_num);\n  int *level=(int *)calloc(vertex_num,sizeof(int));\n  int *queue=(int *)calloc(vertex_num,sizeof(int));\n  int *iter=(int *)calloc(vertex_num,sizeof(int));\n  flow_type flow=0;\n  while(1){\n    memset(level,0,sizeof(int)*vertex_num);\n    int front=0,last=0;\n    level[src]=1;\n    queue[last++]=src;\n    while(front<last && level[dst]==0){\n      const int v=queue[front++];\n      for(int p=g->start[v];p!=-1;p=g->edge[p].next){\n\tint u=g->edge[p].vertex;\n\tif(g->edge[p].capacity>0 && level[u]==0){\n\t  level[u]=level[v]+1;\n\t  queue[last++]=u;\n\t}\n      }\n    }\n    if(level[dst]==0) break;\n    memcpy(iter,g->start,sizeof(int)*vertex_num);\n    while(1){\n      flow_type f=dinic_dfs(src,g,dst,level,iter,flow_inf);\n      if(f<=0) break;\n      flow+=f;\n    }\n  }\n  freeGraph(g);\n  free(level);\n  free(queue);\n  free(iter);\n  return flow;\n}\n\ntypedef int32_t i32;\n\nvoid run (void) {\n  i32 h, w;\n  scanf(\"%\" SCNi32 \"%\" SCNi32, &h, &w);\n  char *s = (char *) calloc (h * w + 1, sizeof (char));\n  for (i32 i = 0; i < h; ++i) {\n    scanf (\"%s\", s + i * w);\n  }\n  graph *g = newGraph (2 * h * w + 2);\n  i32 src = 2 * h * w - 2;\n  i32 dst = src + 1;\n  for (i32 i = 0; i < h; ++i) {\n    for (i32 j = 0; j < w; ++j) {\n      if (i == 0 || i == h - 1 || j == 0 || j == w - 1) {\n\taddEdge (g, i * w + j, dst, flow_inf);\n      }\n      if (s[i * w + j] == 'X') {\n\taddEdge (g, src, i * w + j, flow_inf);\n      }\n      addEdge (g, h * w + i * w + j, i * w + j, 1);\n      i32 d[] = {-1, 0, 1, 0};\n      for (i32 k = 0; k < 4; ++k) {\n\ti32 x = i + d[k];\n\ti32 y = j + d[k ^ 1];\n\tif (!(0 <= x && x < h && 0 <= y && y < w)) continue;\n\taddEdge (g, i * w + j, h * w + x * w + y, flow_inf);\n      }\n    }\n  }\n  i32 ans = dinic(g, src, dst);\n  if (ans >= flow_inf) {\n    puts(\"-1\");\n  } else {\n    printf(\"%\" PRIi32 \"\\n\", ans - 1);\n  }\n}\n\nint main (void) {\n  run ();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint Y[]={0,1,0,-1};\nint X[]={1,0,-1,0};\nint main(){\n  int h,w,i,j,k,ny,nx,c=0,t,r,qx[100010],qy[100010];\n  char s[110][110]={0};\n  scanf(\"%d %d\",&h,&w);\n  for(i=0;i<h;i++)scanf(\"%s\",s[i+1]+1);\n  for(i=1;i<=h;i++){//printf(\"\\n\");\n    for(j=1;j<=w;j++){//printf(\"%c\",s[i][j]);\n      if(s[i][j]-'X')continue;\n      for(k=0;k<4;k++){\n\tny=i+Y[k];\n\tnx=j+X[k];//printf(\"%d %d\\n\",ny,nx);\n\tif(s[ny][nx]==0){\n\t  printf(\"-1\\n\");\n\t  return 0;\n\t}\n\tif(s[ny][nx]=='X')continue;\n\ts[ny][nx]='#';//printf(\"%d %d\\n\",ny,nx);\n      }\n    }\n  }\n  //for(i=0;i<h;i++)printf(\"%s\\n\",s[i+1]+1);\n  qy[t=0]=qy[1]=qx[0]=qx[2]=1;\n  qy[2]=qy[3]=h;\n  qx[1]=qx[3]=w;\n  for(r=4;r-t;t++){\n    for(k=0;k<4;k++){\n      ny=qy[t]+Y[k];\n      nx=qx[t]+X[k];\n      if(s[ny][nx]=='#'){\n\tc++;\n\ts[ny][nx]=0;\n      }\n      if(s[ny][nx]==0)continue;\n      s[qy[r]=ny][qx[r]=nx]=0;\n      r++;\n    }\n  }\n  printf(\"%d\\n\",c);\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nint Y[]={0,1, 0,-1, 1,1,-1,-1,2,2,1, 2, 2, 1, 0,-1,-2,-2,-1,-2,-2,-1,0,1};\nint X[]={1,0,-1, 0,-1,1,-1, 1,2,1,0,-1,-2,-2,-1,-2,-2,-1, 0, 1, 2, 2,1,2};\nint MAX(int a,int b){return a>b?a:b;}\nint R=1,C=1,H[2000010],N[2000010];\n//評価関数（いまはMAX）\nint hyouka(int a,int b){\n  if(C<b)return 1;\n  if(C<a||b==0)return 0;\n  return N[H[a]]<N[H[b]]?1:0;\n}\n//挿入関数\nvoid hin(int a){\n  int i=C++;\n  for(N[H[0]=R]=a;hyouka(0,i/2);i/=2)H[i]=H[i/2];\n  H[i]=R++;\n}\n//取り出す関数\nint hout(){\n  int rt=H[1],i,j=2,k=H[--C];\n  for(i=1;hyouka(i,C);i=j)H[i]=H[j=i*2+1-hyouka(i*2,i*2+1)];\n  H[j/2]=k;\n  return rt;\n}\nint main(){\n  int h,w,i,j,k,l,ny,nx,ay,ax,by,bx,qy[10010],qx[10010],y[10010],x[10010],s=0;\n  int c=0,t,r,p,gx,gy,tr,ty[10010],tx[10010],f[110][110]={0};\n  char d[110][110]={0};\n  scanf(\"%d %d\",&h,&w);\n  for(i=0;i<h;i++)scanf(\"%s\",d[i+2]+2);\n  for(i=2;i<h+2;i++){\n    for(j=2;j<w+2;j++){\n      if(d[i][j]-'X'||f[i][j])continue;\n      c++;\n      R=C=1;\n      f[qy[t=0]=i][qx[0]=j]=c;\n      for(r=1;r-t;t++){\n\thin(qy[t]*1000+qx[t]);\n\tfor(k=0;k<8;k++){\n\t  ny=qy[t]+Y[k];\n\t  nx=qx[t]+X[k];\n\t  if(d[ny][nx]==0&&k<8){//out\n\t    printf(\"-1\\n\");\n\t    return 0;\n\t  }\n\t  if(f[ny][nx]||d[ny][nx]-'X')continue;\n\t  f[qy[r]=ny][qx[r]=nx]=c;\n\t  r++;\n\t}\n      }\n      for(k=0;k<r;k++){\n\tp=N[hout()];\n\ty[k]=p/1000;\n\tx[k]=p%1000;\n      }\n      for(k=tr=0;k<r;k++){\n\tfor(;1;tr--){\n\t  if(tr<2){\n\t    ty[tr  ]=y[k];\n\t    tx[tr++]=x[k];\n\t    break;\n\t  }\n\t  ay=ty[tr-1]-ty[tr-2];\n\t  ax=tx[tr-1]-tx[tr-2];\n\t  by= y[k   ]-ty[tr-1];\n\t  bx= x[k   ]-tx[tr-1];\n\t  if(ax*by>ay*bx){\n\t    ty[tr  ]=y[k];\n\t    tx[tr++]=x[k];\n\t    break;\n\t  }\n\t}\n      }\n      //for(k=0;k<tr;k++)printf(\"%d %d\\n\",ty[k],tx[k]);printf(\"\\n\");\n      for(k=0;k<tr;k++){\n\tny=ty[k];\n\tnx=tx[k];\n\tgy=ty[(k+1)%tr];\n\tgx=tx[(k+1)%tr];//printf(\"%d %d %d %d\\n\",ny,nx,gy,gx);\n\twhile(1){//printf(\"%d %d %d %d\\n\",ny,nx,gy,gx);\n\t  for(l=0;l<4;l++)d[ny+Y[l]][nx+X[l]]='#';\n\t  if(ny==gy&&nx==gx)break;\n\t  if(nx<gx){\n\t    if(abs(ny-gy)==abs(nx-gx)){\n\t      if(ny<gy)ny++;\n\t      else     ny--;\n\t    }\n\t    nx++;\n\t  }\n\t  else if(nx==gx){\n\t    if(ny<gy)ny++;\n\t    else     ny--;\n\t  }\n\t  else{\n\t    if(abs(ny-gy)==abs(nx-gx)){\n\t      if(ny<gy)ny++;\n\t      else     ny--;\n\t    }\n\t    nx--;\n\t  }\n\t}\n      }\t      \n      //for(k=1;k<tr;k++)s+=MAX(abs(ty[k]-ty[k-1]),abs(tx[k]-tx[k-1]));\n      for(k=tr=0;k<r;k++){\n\tfor(;1;tr--){\n\t  if(tr<2){\n\t    ty[tr  ]=y[k];\n\t    tx[tr++]=x[k];\n\t    break;\n\t  }\n\t  ay=ty[tr-1]-ty[tr-2];\n\t  ax=tx[tr-1]-tx[tr-2];\n\t  by= y[k   ]-ty[tr-1];\n\t  bx= x[k   ]-tx[tr-1];\n\t  if(ax*by<ay*bx){\n\t    ty[tr  ]=y[k];\n\t    tx[tr++]=x[k];\n\t    break;\n\t  }\n\t}\n      }\n      //for(k=0;k<tr;k++)printf(\"%d %d\\n\",ty[k],tx[k]);printf(\"\\n\");\n      for(k=0;k<tr;k++){\n\tny=ty[k];\n\tnx=tx[k];\n\tgy=ty[(k+1)%tr];\n\tgx=tx[(k+1)%tr];\n\twhile(1){\n\t  for(l=0;l<4;l++)d[ny+Y[l]][nx+X[l]]='#';\n\t  if(ny==gy&&nx==gx)break;\n\t  if(nx<gx){\n\t    if(abs(ny-gy)==abs(nx-gx)){\n\t      if(ny<gy)ny++;\n\t      else     ny--;\n\t    }\n\t    nx++;\n\t  }\n\t  else if(nx==gx){\n\t    if(ny<gy)ny++;\n\t    else     ny--;\n\t  }\n\t  else{\n\t    if(abs(ny-gy)==abs(nx-gx)){\n\t      if(ny<gy)ny++;\n\t      else     ny--;\n\t    }\n\t    nx--;\n\t  }\n\t}\n      }\t      \n      //for(k=1;k<tr;k++)s+=MAX(abs(ty[k]-ty[k-1]),abs(tx[k]-tx[k-1]));\n      //s+=4;//printf(\"\\n\");\n    }\n  }\n  // for(i=0;i<h;i++)printf(\"%s\\n\",d[i+2]+2);\n  qy[t=0]=qx[0]=c=0;\n  d[0][0]=1;\n  for(r=1;r-t;t++){\n    for(k=0;k<4;k++){\n      ny=qy[t]+Y[k];\n      nx=qx[t]+X[k];\n      if(ny<0||h+2<ny||nx<0||w+2<nx)continue;\n      if(d[ny][nx]=='#'){\n\tc++;\n\td[ny][nx]=1;\n      }\n      if(d[ny][nx]==1)continue;\n      d[qy[r]=ny][qx[r]=nx]=1;\n      r++;\n    }\n  }\n  printf(\"%d\\n\",c);\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int flow_type;\n\nconst flow_type flow_inf=400;\n\ntypedef struct flow_edge{\n  int vertex;\n  int next;\n  flow_type capacity;\n} flow_edge;\n\ntypedef struct maxFlowGraph{\n  flow_edge *edge;\n  int *start;\n  int vertex_num;\n  int pointer;\n  int edge_length;\n} graph;\n\ngraph* newGraph(const int vertex_num){\n  graph *g=(graph *)calloc(1,sizeof(graph));\n  g->vertex_num=vertex_num;\n  const int initial_length=4;\n  g->edge=(flow_edge *)calloc(initial_length,sizeof(flow_edge));\n  g->start=(int *)calloc(vertex_num,sizeof(int));\n  g->pointer=0;\n  g->edge_length=initial_length;\n  for(int i=0;i<vertex_num;i++) g->start[i]=-1;\n  return g;\n}\n\nvoid freeGraph(graph *g){\n  free(g->edge);\n  free(g->start);\n  free(g);\n}\n\nvoid addEdge(graph *g,int from,int to,flow_type capa){\n  if(g->pointer==g->edge_length){\n    g->edge_length*=2;\n    g->edge=(flow_edge *)realloc(g->edge,sizeof(flow_edge)*g->edge_length);\n  }\n  int p=g->pointer;\n  g->edge[p]=(flow_edge){to,g->start[from],capa};\n  g->start[from]=p;\n  g->edge[p+1]=(flow_edge){from,g->start[to],0};\n  g->start[to]=p+1;\n  g->pointer+=2;\n}\n\nflow_type dinic_dfs(int v,graph *g,int dst,int *level,int *iter,flow_type e){\n  if(v==dst) return e;\n  flow_type sum=0;\n  for(int p=iter[v];p!=-1 && e>0;p=g->edge[p].next,iter[v]=p){\n    int u=g->edge[p].vertex;\n    flow_type capa=g->edge[p].capacity;\n    if(level[u]<=level[v] || capa<=0) continue;\n    flow_type f=dinic_dfs(u,g,dst,level,iter,capa<e?capa:e);\n    if(f>0){\n      g->edge[p].capacity-=f;\n      g->edge[p^1].capacity+=f;\n      sum+=f;\n      e-=f;\n    }\n  }\n  return sum;\n}\n\nflow_type dinic(const graph *input_graph,const int src,const int dst){\n  const int vertex_num=input_graph->vertex_num;\n  const int edge_num=input_graph->pointer;\n  graph *g=(graph *)calloc(1,sizeof(graph));\n  g->edge=(flow_edge *)malloc(sizeof(flow_edge)*edge_num);\n  g->start=(int *)malloc(sizeof(int)*vertex_num);\n  memcpy(g->edge,input_graph->edge,sizeof(flow_edge)*edge_num);\n  memcpy(g->start,input_graph->start,sizeof(int)*vertex_num);\n  int *level=(int *)calloc(vertex_num,sizeof(int));\n  int *queue=(int *)calloc(vertex_num,sizeof(int));\n  int *iter=(int *)calloc(vertex_num,sizeof(int));\n  flow_type flow=0;\n  while(1){\n    memset(level,0,sizeof(int)*vertex_num);\n    int front=0,last=0;\n    level[src]=1;\n    queue[last++]=src;\n    while(front<last && level[dst]==0){\n      const int v=queue[front++];\n      for(int p=g->start[v];p!=-1;p=g->edge[p].next){\n\tint u=g->edge[p].vertex;\n\tif(g->edge[p].capacity>0 && level[u]==0){\n\t  level[u]=level[v]+1;\n\t  queue[last++]=u;\n\t}\n      }\n    }\n    if(level[dst]==0) break;\n    memcpy(iter,g->start,sizeof(int)*vertex_num);\n    while(1){\n      flow_type f=dinic_dfs(src,g,dst,level,iter,flow_inf);\n      if(f<=0) break;\n      flow+=f;\n    }\n  }\n  freeGraph(g);\n  free(level);\n  free(queue);\n  free(iter);\n  return flow;\n}\n\ntypedef int32_t i32;\n\nvoid run (void) {\n  i32 h, w;\n  scanf(\"%\" SCNi32 \"%\" SCNi32, &h, &w);\n  char *s = (char *) calloc (h * w + 1, sizeof (char));\n  for (i32 i = 0; i < h; ++i) {\n    scanf (\"%s\", s + i * w);\n  }\n  graph *g = newGraph (2 * h * w + 2);\n  i32 src = 2 * h * w;\n  i32 dst = src + 1;\n  for (i32 i = 0; i < h; ++i) {\n    for (i32 j = 0; j < w; ++j) {\n      if (i == 0 || i == h - 1 || j == 0 || j == w - 1) {\n\taddEdge (g, i * w + j, dst, flow_inf);\n      }\n      if (s[i * w + j] == 'X') {\n\taddEdge (g, src, i * w + j, flow_inf);\n      }\n      addEdge (g, h * w + i * w + j, i * w + j, 1);\n      i32 d[] = {-1, 0, 1, 0};\n      for (i32 k = 0; k < 4; ++k) {\n\ti32 x = i + d[k];\n\ti32 y = j + d[k ^ 1];\n\tif (!(0 <= x && x < h && 0 <= y && y < w)) continue;\n\taddEdge (g, i * w + j, h * w + x * w + y, flow_inf);\n      }\n    }\n  }\n  i32 ans = dinic(g, src, dst);\n  if (ans >= flow_inf) {\n    puts(\"-1\");\n  } else {\n    printf(\"%\" PRIi32 \"\\n\", ans);\n  }\n}\n\nint main (void) {\n  run ();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MIN(x,y) (((x)<(y))?(x):(y))\n\nint main(void){\n  int h,w;\n  char glid[100][101];\n  int i,j,k,num;\n  int cutx,cuty,cutmin;\n  int x[2]={101,-1},y[2]={101,-1}; //min,max\n\n  scanf(\"%d%d%*c\",&h,&w);\n  for(i=0;i<h;i++) scanf(\"%s%*c\",glid[i]);\n\n  for(i=0;i<h;i++){\n    for(j=0;j<w;j++){\n      if(glid[i][j]!='X') continue;\n      if(x[0]>j) x[0]=j;\n      if(x[1]<j) x[1]=j;\n      if(y[0]>i) y[0]=i;\n      if(y[1]<i) y[1]=i;\n    }\n  }\n\n  if(x[0]==0 || y[0]==0 || x[1]==w-1 || y[1]==h-1){\n    puts(\"-1\");\n    return 0;\n  }\n\n  //printf(\"[%d,%d]-[%d,%d]\\n\",x[0],y[0],x[1],y[1]);\n  for(i=x[0];i<=x[1];i++){\n    glid[y[0]-1][i]='c';\n    glid[y[1]+1][i]='c';\n  }\n\n  for(i=y[0];i<=y[1];i++){\n    glid[i][x[0]-1]='c';\n    glid[i][x[1]+1]='c';\n  }\n\n  //lu-sumi\n  for(i=x[0];i<=x[1] && glid[y[0]][i]=='.';i++);\n  cutx=i-x[0];\n  for(i=y[0];i<=y[1] && glid[i][x[0]]=='.';i++);\n  cuty=i-y[0];\n  cutmin=MIN(cutx,cuty);\n  \n  for(i=0;i<=cutmin;i++){\n    glid[y[0]+cutmin-i][x[0]-1+i]='c';\n    for(j=y[0]+cutmin-i-1;j>=y[0]-1;j--)\n      if(glid[j][x[0]-1+i]=='c')\n\tglid[j][x[0]-1+i]='.';\n  }\n\n   //ru-sumi\n  for(i=x[1];i>=x[0] && glid[y[0]][i]=='.';i--);\n  cutx=x[1]-i;\n  for(i=y[0];i<=y[1] && glid[i][x[1]]=='.';i++);\n  cuty=i-y[0];\n  cutmin=MIN(cutx,cuty);\n  \n  for(i=0;i<=cutmin;i++){\n    glid[y[0]+cutmin-i][x[1]+1-i]='c';\n    for(j=y[0]+cutmin-i-1;j>=y[0]-1;j--)\n      if(glid[j][x[1]+1-i]=='c')\n\tglid[j][x[1]+1-i]='.';\n  }\n\n   //ld-sumi\n  for(i=x[0];i<=x[1] && glid[y[1]][i]=='.';i++);\n  cutx=i-x[0];\n  for(i=y[1];i>=y[0] && glid[i][x[0]]=='.';i--);\n  cuty=y[1]-i;\n  cutmin=MIN(cutx,cuty);\n  \n  for(i=0;i<=cutmin;i++){\n    glid[y[1]-cutmin+i][x[0]-1+i]='c';\n    for(j=y[1]-cutmin+i+1;j<=y[1]+1;j++)\n      if(glid[j][x[0]-1+i]=='c')\n\tglid[j][x[0]-1+i]='.';\n  }\n\n\n  //rd-sumi\n  for(i=x[1];i>=x[0] && glid[y[1]][i]=='.';i--);\n  cutx=x[1]-i;\n  for(i=y[1];i>=y[0] && glid[i][x[1]]=='.';i--);\n  cuty=y[1]-i;\n  cutmin=MIN(cutx,cuty);\n  \n  for(i=0;i<=cutmin;i++){\n    glid[y[1]-cutmin+i][x[1]+1-i]='c';\n    for(j=y[1]-cutmin+i+1;j<=y[1]+1;j++)\n      if(glid[j][x[1]+1-i]=='c')\n\tglid[j][x[1]+1-i]='.';\n  }\n\n  //putchar('\\n');\n  //for(i=0;i<h;i++) puts(glid[i]);\n\n  num=0;\n  for(i=0;i<h;i++) for(j=0;j<w;j++) num+=(glid[i][j]=='c');\n  printf(\"%d\\n\",num);\n  \n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nint Y[]={0,1, 0,-1, 1,1,-1,-1,2,2,1, 2, 2, 1, 0,-1,-2,-2,-1,-2,-2,-1,0,1};\nint X[]={1,0,-1, 0,-1,1,-1, 1,2,1,0,-1,-2,-2,-1,-2,-2,-1, 0, 1, 2, 2,1,2};\nint MAX(int a,int b){return a>b?a:b;}\nint R=1,C=1,H[2000010],N[2000010];\n//評価関数（いまはMAX）\nint hyouka(int a,int b){\n  if(C<b)return 1;\n  if(C<a||b==0)return 0;\n  return N[H[a]]<N[H[b]]?1:0;\n}\n//挿入関数\nvoid hin(int a){\n  int i=C++;\n  for(N[H[0]=R]=a;hyouka(0,i/2);i/=2)H[i]=H[i/2];\n  H[i]=R++;\n}\n//取り出す関数\nint hout(){\n  int rt=H[1],i,j=2,k=H[--C];\n  for(i=1;hyouka(i,C);i=j)H[i]=H[j=i*2+1-hyouka(i*2,i*2+1)];\n  H[j/2]=k;\n  return rt;\n}\nint main(){\n  int h,w,i,j,k,l,ny,nx,ay,ax,by,bx,qy[10010],qx[10010],y[10010],x[10010],s=0;\n  int c=0,t,r,p,gx,gy,tr,ty[10010],tx[10010],f[110][110]={0};\n  char d[110][110]={0};\n  scanf(\"%d %d\",&h,&w);\n  for(i=0;i<h;i++)scanf(\"%s\",d[i+2]+2);\n  for(i=2;i<h+2;i++){\n    for(j=2;j<w+2;j++){\n      if(d[i][j]-'X'||f[i][j])continue;\n      c++;\n      R=C=1;\n      f[qy[t=0]=i][qx[0]=j]=c;\n      for(r=1;r-t;t++){\n\thin(qy[t]*1000+qx[t]);\n\tfor(k=0;k<24;k++){\n\t  ny=qy[t]+Y[k];\n\t  nx=qx[t]+X[k];\n\t  if(d[ny][nx]==0&&k<8){//out\n\t    printf(\"-1\\n\");\n\t    return 0;\n\t  }\n\t  if(f[ny][nx]||d[ny][nx]-'X')continue;\n\t  f[qy[r]=ny][qx[r]=nx]=c;\n\t  r++;\n\t}\n      }\n      for(k=0;k<r;k++){\n\tp=N[hout()];\n\ty[k]=p/1000;\n\tx[k]=p%1000;\n      }\n      for(k=tr=0;k<r;k++){\n\tfor(;1;tr--){\n\t  if(tr<2){\n\t    ty[tr  ]=y[k];\n\t    tx[tr++]=x[k];\n\t    break;\n\t  }\n\t  ay=ty[tr-1]-ty[tr-2];\n\t  ax=tx[tr-1]-tx[tr-2];\n\t  by= y[k   ]-ty[tr-1];\n\t  bx= x[k   ]-tx[tr-1];\n\t  if(ax*by>ay*bx){\n\t    ty[tr  ]=y[k];\n\t    tx[tr++]=x[k];\n\t    break;\n\t  }\n\t}\n      }\n      //for(k=0;k<tr;k++)printf(\"%d %d\\n\",ty[k],tx[k]);printf(\"\\n\");\n      for(k=0;k<tr;k++){\n\tny=ty[k];\n\tnx=tx[k];\n\tgy=ty[(k+1)%tr];\n\tgx=tx[(k+1)%tr];//printf(\"%d %d %d %d\\n\",ny,nx,gy,gx);\n\twhile(1){//printf(\"%d %d %d %d\\n\",ny,nx,gy,gx);\n\t  for(l=0;l<4;l++)d[ny+Y[l]][nx+X[l]]='#';\n\t  if(ny==gy&&nx==gx)break;\n\t  if(nx<gx){\n\t    if(abs(ny-gy)==abs(nx-gx)){\n\t      if(ny<gy)ny++;\n\t      else     ny--;\n\t    }\n\t    nx++;\n\t  }\n\t  else if(nx==gx){\n\t    if(ny<gy)ny++;\n\t    else     ny--;\n\t  }\n\t  else{\n\t    if(abs(ny-gy)==abs(nx-gx)){\n\t      if(ny<gy)ny++;\n\t      else     ny--;\n\t    }\n\t    nx--;\n\t  }\n\t}\n      }\t      \n      //for(k=1;k<tr;k++)s+=MAX(abs(ty[k]-ty[k-1]),abs(tx[k]-tx[k-1]));\n      for(k=tr=0;k<r;k++){\n\tfor(;1;tr--){\n\t  if(tr<2){\n\t    ty[tr  ]=y[k];\n\t    tx[tr++]=x[k];\n\t    break;\n\t  }\n\t  ay=ty[tr-1]-ty[tr-2];\n\t  ax=tx[tr-1]-tx[tr-2];\n\t  by= y[k   ]-ty[tr-1];\n\t  bx= x[k   ]-tx[tr-1];\n\t  if(ax*by<ay*bx){\n\t    ty[tr  ]=y[k];\n\t    tx[tr++]=x[k];\n\t    break;\n\t  }\n\t}\n      }\n      //for(k=0;k<tr;k++)printf(\"%d %d\\n\",ty[k],tx[k]);printf(\"\\n\");\n      for(k=0;k<tr;k++){\n\tny=ty[k];\n\tnx=tx[k];\n\tgy=ty[(k+1)%tr];\n\tgx=tx[(k+1)%tr];\n\twhile(1){\n\t  for(l=0;l<4;l++)d[ny+Y[l]][nx+X[l]]='#';\n\t  if(ny==gy&&nx==gx)break;\n\t  if(nx<gx){\n\t    if(abs(ny-gy)==abs(nx-gx)){\n\t      if(ny<gy)ny++;\n\t      else     ny--;\n\t    }\n\t    nx++;\n\t  }\n\t  else if(nx==gx){\n\t    if(ny<gy)ny++;\n\t    else     ny--;\n\t  }\n\t  else{\n\t    if(abs(ny-gy)==abs(nx-gx)){\n\t      if(ny<gy)ny++;\n\t      else     ny--;\n\t    }\n\t    nx--;\n\t  }\n\t}\n      }\t      \n      //for(k=1;k<tr;k++)s+=MAX(abs(ty[k]-ty[k-1]),abs(tx[k]-tx[k-1]));\n      //s+=4;//printf(\"\\n\");\n    }\n  }\n  //for(i=0;i<h;i++)printf(\"%s\\n\",d[i+2]+2);\n  qy[t=0]=qx[0]=c=0;\n  d[0][0]=1;\n  for(r=1;r-t;t++){\n    for(k=0;k<4;k++){\n      ny=qy[t]+Y[k];\n      nx=qx[t]+X[k];\n      if(ny<0||h+2<ny||nx<0||w+2<nx)continue;\n      if(d[ny][nx]=='#'){\n\tc++;\n\td[ny][nx]=1;\n      }\n      if(d[ny][nx]==1)continue;\n      d[qy[r]=ny][qx[r]=nx]=1;\n      r++;\n    }\n  }\n  printf(\"%d\\n\",c);\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint ta[20010],to[1000010],nt[1000010],co[1000010],F[20010];\nint MF(int s,int t,int e,int min){\n  if(s==t||min==0)return min;\n  int i,r;\n  F[s]=1;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(F[to[i]])continue;\n    r=MF(to[i],t,e,MIN(min,co[i]));\n    co[i]-=r;\n    co[(i+e)%(2*e)]+=r;\n    if(r)return r;\n  }\n  return 0;\n}\n//呼び出す方\n//sからtへの最大流を求める　ノード数v辺の数e　aからbへキャパcのフローが流れる\nint maxf(int s,int t,int v,int e,int *a,int *b,int *c){\n  int i,f,r;\n  for(i=0;i<v;i++)ta[i]=-1;\n  for(i=0;i<e;i++){\n    nt[i  ]=ta[to[i+e]=a[i]];\n    nt[i+e]=ta[to[i  ]=b[i]];\n    co[ta[a[i]]=i  ]=c[i];\n    co[ta[b[i]]=i+e]=0;\n  }\n  for(f=0;r=MF(s,t,e,1e9);f+=r){\n    for(i=0;i<v;i++)F[i]=0;\n    if(f>1000)break;\n  }\n  return f;\n}\nint Y[]={0,1,0,-1};\nint X[]={1,0,-1,0};\nint main(){\n  int h,w,M=1e9,a[100010],b[100010],c[100010],i,j,k,p,ny,nx,np,ans,r=0;\n  char s[110][110]={};\n  scanf(\"%d %d\",&h,&w);\n  for(i=0;i<h;i++)scanf(\"%s\",s[i+1]+1);\n  for(i=1;i<=h;i++){\n    for(j=1;j<=w;j++){\n      p=(i-1)*w+j+1;\n      a[r  ]=p+h*w;\n      b[r  ]=p;\n      c[r++]=1;\n      if(s[i][j]=='X'){\n\ta[r  ]=0;\n\tb[r  ]=p;\n\tc[r++]=M;\n      }\n      for(k=0;k<4;k++){\n\tny=i+Y[k];\n\tnx=j+X[k];\n\tnp=(ny-1)*w+nx+1+h*w;\n\ta[r]=p;\n\tb[r]=s[ny][nx]?np:1;\n\tc[r++]=M;\n      }\n    }\n  }\n  ans=maxf(0,1,h*w*2+2,r,a,b,c);\n  printf(\"%d\\n\",ans>1000?-1:ans);\n  return 0;\n}\n  \n\t  \n"
  },
  {
    "language": "C",
    "code": "#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n// 内部定数\n#define D_SIZE_MAX\t\t105\t\t\t\t\t\t\t\t\t\t// 最大サイズ\n#define D_MASS_NONE\t\t'.'\t\t\t\t\t\t\t\t\t\t// マス - なし\n#define D_MASS_GOAT\t\t'X'\t\t\t\t\t\t\t\t\t\t// マス - 山羊\n#define D_MASS_WALL\t\t'W'\t\t\t\t\t\t\t\t\t\t// マス - 柵\n\n// 内部変数\nstatic FILE *szpFpI;\t\t\t\t\t\t\t\t\t\t\t// 入力\nstatic int siW, siH;\t\t\t\t\t\t\t\t\t\t\t// 幅・高さ\nstatic char sc2Mass[D_SIZE_MAX][D_SIZE_MAX];\t\t\t\t\t// マス\n\n// 内部変数 - テスト用\n#ifdef D_TEST\n\tstatic int siRes;\n\tstatic FILE *szpFpA;\n\tstatic int siTNo;\n#endif\n\n// １行出力\nint\nfOutLine(\n\tchar *pcpLine\t\t\t\t// <I> １行\n)\n{\n\tchar lc1Buf[1024];\n\n#ifdef D_TEST\n\tfgets(lc1Buf, sizeof(lc1Buf), szpFpA);\n\tif (strcmp(lc1Buf, pcpLine)) {\n\t\tsiRes = -1;\n\t}\n#else\n\tprintf(\"%s\", pcpLine);\n#endif\n\n\treturn 0;\n}\n\n// 柵 - セット\nint\nfSetWall(\n\tint piRow\t\t\t\t\t// <I> 行\n\t, int piCol\t\t\t\t\t// <I> 列\n)\n{\n\tif (sc2Mass[piRow][piCol] != D_MASS_GOAT) {\n\t\treturn 0;\n\t}\n\n\t// 範囲チェック\n\tif (piRow == 0 || piRow == siH - 1) {\n\t\treturn -1;\n\t}\n\tif (piCol == 0 || piCol == siW - 1) {\n\t\treturn -1;\n\t}\n\n\t// 上下左右 - セット\n\tif (sc2Mass[piRow + 1][piCol] == D_MASS_NONE) {\n\t\tsc2Mass[piRow + 1][piCol] = D_MASS_WALL;\n\t}\n\tif (sc2Mass[piRow - 1][piCol] == D_MASS_NONE) {\n\t\tsc2Mass[piRow - 1][piCol] = D_MASS_WALL;\n\t}\n\tif (sc2Mass[piRow][piCol + 1] == D_MASS_NONE) {\n\t\tsc2Mass[piRow][piCol + 1] = D_MASS_WALL;\n\t}\n\tif (sc2Mass[piRow][piCol - 1] == D_MASS_NONE) {\n\t\tsc2Mass[piRow][piCol - 1] = D_MASS_WALL;\n\t}\n\n\treturn 0;\n}\n\n// 柵 - 削除 - チェック\nint\nfDelWallChk(\n\tint piRow\t\t\t\t\t// <I> 行\n\t, int piCol\t\t\t\t\t// <I> 列\n\t, int piMx\t\t\t\t\t// <I> 移動方向 - X\n\t, int piMy\t\t\t\t\t// <I> 移動方向 - Y\n)\n{\n\twhile (1) {\n\n\t\t// 移動\n\t\tpiRow += piMy;\n\t\tpiCol += piMx;\n\t\tif (piRow == 0 || piRow == siH - 1) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (piCol == 0 || piCol == siW - 1) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// マス - チェック\n\t\tif (sc2Mass[piRow][piCol] != D_MASS_NONE) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n// 柵 - 削除\nint\nfDelWall(\n\tint piRow\t\t\t\t\t// <I> 行\n\t, int piCol\t\t\t\t\t// <I> 列\n)\n{\n\tint liRet;\n\n\tif (sc2Mass[piRow][piCol] != D_MASS_WALL) {\n\t\treturn 0;\n\t}\n\n\t// 上下左右 - チェック\n\tliRet = fDelWallChk(piRow, piCol, 1, 0);\n\tif (liRet == 0) {\n\t\treturn 0;\n\t}\n\tliRet = fDelWallChk(piRow, piCol, -1, 0);\n\tif (liRet == 0) {\n\t\treturn 0;\n\t}\n\tliRet = fDelWallChk(piRow, piCol, 0, 1);\n\tif (liRet == 0) {\n\t\treturn 0;\n\t}\n\tliRet = fDelWallChk(piRow, piCol, 0, -1);\n\tif (liRet == 0) {\n\t\treturn 0;\n\t}\n\n\t// 柵 - 削除\n\tsc2Mass[piRow][piCol] = D_MASS_NONE;\n\n\treturn 0;\n}\n\n// 実行メイン\nint\nfMain(\n)\n{\n\tint i, j, liRet;\n\tchar lc1Buf[1024];\n\n\t// 幅・高さ - 取得\n\tfgets(lc1Buf, sizeof(lc1Buf), szpFpI);\n\tsscanf(lc1Buf, \"%d%d\", &siH, &siW);\n\n\t// 高さ - 取得\n\tfor (i = 0; i < siH; i++) {\n\t\tfgets(sc2Mass[i], sizeof(sc2Mass[0]), szpFpI);\n\t}\n\n\t// 柵 - セット\n\tfor (i = 0; i < siH; i++) {\n\t\tfor (j = 0; j < siW; j++) {\n\t\t\tliRet = fSetWall(i, j);\n\t\t\tif (liRet != 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// 柵 - 削除\n\tfor (i = 0; i < siH; i++) {\n\t\tfor (j = 0; j < siW; j++) {\n\t\t\tfDelWall(i, j);\n\t\t}\n\t}\n\n\t// 柵数 - 取得\n\tint liCnt = 0;\n\tfor (i = 0; i < siH; i++) {\n\t\tfor (j = 0; j < siW; j++) {\n\t\t\tif (sc2Mass[i][j] == D_MASS_WALL) {\n\t\t\t\tliCnt++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn liCnt;\n}\n\n// １回実行\nint\nfOne(\n)\n{\n\tint liRet;\n\tchar lc1Buf[1024];\n\n\t// 入力 - セット\n#ifdef D_TEST\n\tsprintf(lc1Buf, \".\\\\Test\\\\T%d.txt\", siTNo);\n\tszpFpI = fopen(lc1Buf, \"r\");\n\tsprintf(lc1Buf, \".\\\\Test\\\\A%d.txt\", siTNo);\n\tszpFpA = fopen(lc1Buf, \"r\");\n\tsiRes = 0;\n#else\n\tszpFpI = stdin;\n#endif\n\n\t// 実行メイン\n\tliRet = fMain();\n\n\t// 出力\n\tsprintf(lc1Buf, \"%d\\n\", liRet);\n\tfOutLine(lc1Buf);\n\n\t// 残データ有無\n#ifdef D_TEST\n\tlc1Buf[0] = '\\0';\n\tfgets(lc1Buf, sizeof(lc1Buf), szpFpA);\n\tif (strcmp(lc1Buf, \"\")) {\n\t\tsiRes = -1;\n\t}\n#endif\n\n\t// テストファイルクローズ\n#ifdef D_TEST\n\tfclose(szpFpI);\n\tfclose(szpFpA);\n#endif\n\n\t// テスト結果\n#ifdef D_TEST\n\tif (siRes == 0) {\n\t\tprintf(\"OK %d\\n\", siTNo);\n\t}\n\telse {\n\t\tprintf(\"NG %d\\n\", siTNo);\n\t}\n#endif\n\n\treturn 0;\n}\n\n// プログラム開始\nint\nmain()\n{\n\n#ifdef D_TEST\n\tint i;\n\tfor (i = D_TEST_SNO; i <= D_TEST_ENO; i++) {\n\t\tsiTNo = i;\n\t\tfOne();\n\t}\n#else\n\tfOne();\n#endif\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint ta[10010],to[1000010],nt[1000010],co[1000010],F[10010];\nint MF(int s,int t,int e,int min){\n  if(s==t||min==0)return min;\n  int i,r;\n  F[s]=1;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(F[to[i]])continue;\n    r=MF(to[i],t,e,MIN(min,co[i]));\n    co[i]-=r;\n    co[(i+e)%(2*e)]+=r;\n    if(r)return r;\n  }\n  return 0;\n}\n//呼び出す方\n//sからtへの最大流を求める　ノード数v辺の数e　aからbへキャパcのフローが流れる\nint maxf(int s,int t,int v,int e,int *a,int *b,int *c){\n  int i,f,r;\n  for(i=0;i<v;i++)ta[i]=-1;\n  for(i=0;i<e;i++){\n    nt[i  ]=ta[to[i+e]=a[i]];\n    nt[i+e]=ta[to[i  ]=b[i]];\n    co[ta[a[i]]=i  ]=c[i];\n    co[ta[b[i]]=i+e]=0;\n  }\n  for(f=0;r=MF(s,t,e,1e9);f+=r){\n    for(i=0;i<v;i++)F[i]=0;\n    if(f>1000)break;\n  }\n  return f;\n}\nint Y[]={0,1,0,-1};\nint X[]={1,0,-1,0};\nint main(){\n  int h,w,M=1e9,a[100010],b[100010],c[100010],i,j,k,p,ny,nx,np,ans,r=0;\n  char s[110][110]={};\n  scanf(\"%d %d\",&h,&w);\n  for(i=0;i<h;i++)scanf(\"%s\",s[i+1]+1);\n  for(i=1;i<=h;i++){\n    for(j=1;j<=w;j++){\n      p=(i-1)*w+j+1;\n      a[r  ]=p+h*w;\n      b[r  ]=p;\n      c[r++]=1;\n      if(s[i][j]=='X'){\n\ta[r  ]=0;\n\tb[r  ]=p;\n\tc[r++]=M;\n      }\n      for(k=0;k<4;k++){\n\tny=i+Y[k];\n\tnx=j+X[k];\n\tnp=(ny-1)*w+nx+1+h*w;\n\ta[r]=p;\n\tb[r]=s[ny][nx]?np:1;\n\tc[r++]=M;\n      }\n    }\n  }\n  ans=maxf(0,1,h*w+2,r,a,b,c);\n  printf(\"%d\\n\",ans>1000?-1:ans);\n  return 0;\n}\n  "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nint Y[]={0,1, 0,-1, 1,1,-1,-1,2,2,2, 2, 2, 1, 0,-1,-2,-2,-2,-2,-2,-1,0,1};\nint X[]={1,0,-1, 0,-1,1,-1, 1,2,1,0,-1,-2,-2,-2,-2,-2,-1, 0, 1, 2, 2,2,2};\nint MAX(int a,int b){return a>b?a:b;}\nint R=1,C=1,H[2000010],N[2000010];\n//評価関数（いまはMAX）\nint hyouka(int a,int b){\n  if(C<b)return 1;\n  if(C<a||b==0)return 0;\n  return N[H[a]]>N[H[b]]?1:0;\n}\n//挿入関数\nvoid hin(int a){\n  int i=C++;\n  for(N[H[0]=R]=a;hyouka(0,i/2);i/=2)H[i]=H[i/2];\n  H[i]=R++;\n}\n//取り出す関数\nint hout(){\n  int rt=H[1],i,j=2,k=H[--C];\n  for(i=1;hyouka(i,C);i=j)H[i]=H[j=i*2+1-hyouka(i*2,i*2+1)];\n  H[j/2]=k;\n  return rt;\n}\nint main(){\n  int h,w,i,j,k,l,ny,nx,ay,ax,by,bx,qy[10010],qx[10010],y[10010],x[10010],s=0;\n  int c=0,t,r,p,tr,ty[10010],tx[10010],f[110][110]={0};\n  char d[110][110]={0};\n  scanf(\"%d %d\",&h,&w);\n  for(i=0;i<h;i++)scanf(\"%s\",d[i+2]+2);\n  for(i=2;i<h+2;i++){\n    for(j=2;j<w+2;j++){\n      if(d[i][j]-'X'||f[i][j])continue;\n      c++;\n      R=C=1;\n      f[qy[t=0]=i][qx[0]=j]=c;\n      for(r=1;r-t;t++){\n\thin(qy[t]*1000+qx[t]);\n\tfor(k=0;k<24;k++){\n\t  ny=qy[t]+Y[k];\n\t  nx=qx[t]+X[k];\n\t  if(d[ny][nx]==0&&k<8){//out\n\t    printf(\"-1\\n\");\n\t    return 0;\n\t  }\n\t  if(f[ny][nx]||d[ny][nx]-'X')continue;\n\t  f[qy[r]=ny][qx[r]=nx]=c;\n\t  r++;\n\t}\n      }\n      for(k=0;k<r;k++){\n\tp=N[hout()];\n\ty[k]=p/1000;\n\tx[k]=p%1000;\n      }\n      for(k=tr=0;k<r;k++){\n\tfor(;1;tr--){\n\t  if(tr<2){\n\t    ty[tr  ]=y[k];\n\t    tx[tr++]=x[k];\n\t    break;\n\t  }\n\t  ay=ty[tr-1]-ty[tr-2];\n\t  ax=tx[tr-1]-tx[tr-2];\n\t  by= y[k   ]-ty[tr-1];\n\t  bx= x[k   ]-tx[tr-1];\n\t  if(ax*by>ay*bx){\n\t    ty[tr  ]=y[k];\n\t    tx[tr++]=x[k];\n\t    break;\n\t  }\n\t}\n      }\n      //for(k=0;k<tr;k++)printf(\"%d %d\\n\",ty[k],tx[k]);printf(\"\\n\");\n      for(k=1;k<tr;k++)s+=MAX(abs(ty[k]-ty[k-1]),abs(tx[k]-tx[k-1]));\n      for(k=tr=0;k<r;k++){\n\tfor(;1;tr--){\n\t  if(tr<2){\n\t    ty[tr  ]=y[k];\n\t    tx[tr++]=x[k];\n\t    break;\n\t  }\n\t  ay=ty[tr-1]-ty[tr-2];\n\t  ax=tx[tr-1]-tx[tr-2];\n\t  by= y[k   ]-ty[tr-1];\n\t  bx= x[k   ]-tx[tr-1];\n\t  if(ax*by<ay*bx){\n\t    ty[tr  ]=y[k];\n\t    tx[tr++]=x[k];\n\t    break;\n\t  }\n\t}\n      }\n      //for(k=0;k<tr;k++)printf(\"%d %d\\n\",ty[k],tx[k]);printf(\"\\n\");\n      for(k=1;k<tr;k++)s+=MAX(abs(ty[k]-ty[k-1]),abs(tx[k]-tx[k-1]));\n      s+=4;//printf(\"\\n\");\n    }\n  }\n  printf(\"%d\\n\",s);\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint Y[]={0,1,0,-1};\nint X[]={1,0,-1,0};\nint main(){\n  int h,w,i,j,k,ny,nx,c=0,t,r,qx[100010],qy[100010];\n  char s[110][110]={0};\n  scanf(\"%d %d\",&h,&w);\n  for(i=0;i<h;i++)scanf(\"%s\",s[i+1]+1);\n  for(i=1;i<=h;i++){//printf(\"\\n\");\n    for(j=1;j<=w;j++){//printf(\"%c\",s[i][j]);\n      if(s[i][j]-'X')continue;\n      for(k=0;k<4;k++){\n\tny=i+Y[k];\n\tnx=j+X[k];//printf(\"%d %d\\n\",ny,nx);\n\tif(s[ny][nx]==0){\n\t  printf(\"-1\\n\");\n\t  return 0;\n\t}\n\tif(s[ny][nx]=='X')continue;\n\ts[ny][nx]='#';//printf(\"%d %d\\n\",ny,nx);\n      }\n    }\n  }\n  //for(i=0;i<h;i++)printf(\"%s\\n\",s[i+1]+1);\n  qy[t=0]=qx[0]=0;\n  s[0][0]=1;\n  for(r=1;r-t;t++){\n    for(k=0;k<4;k++){\n      ny=qy[t]+Y[k];\n      nx=qx[t]+X[k];\n      if(ny<0||h+1<ny||nx<0||w+1<nx)continue;\n      if(s[ny][nx]=='#'){\n\tc++;\n\ts[ny][nx]=1;\n      }\n      if(s[ny][nx]==1)continue;\n      s[qy[r]=ny][qx[r]=nx]=1;\n      r++;\n    }\n  }\n  printf(\"%d\\n\",c);\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int32_t flow_type;\n\nconst flow_type flow_inf = 400;\n\ntypedef struct flow_edge {\n  int32_t vertex;\n  int32_t next;\n  flow_type capacity;\n} flow_edge;\n\ntypedef struct maxFlowGraph {\n  flow_edge *edge;\n  int32_t *start;\n  int32_t vertex_num;\n  int32_t pointer;\n  int32_t edge_length;\n} graph;\n\ngraph* new_graph (const int32_t vertex_num) {\n  graph *g = (graph *) calloc (1, sizeof (graph));\n  g->vertex_num = vertex_num;\n  const int32_t initial_length = 4;\n  g->edge = (flow_edge *) calloc (initial_length, sizeof (flow_edge));\n  g->start = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  g->pointer = 0;\n  g->edge_length = initial_length;\n  for (int32_t i = 0; i < vertex_num; ++i) {\n    g->start[i] = -1;\n  }\n  return g;\n}\n\nvoid free_graph (graph * const g) {\n  free (g->edge);\n  free (g->start);\n  free (g);\n}\n\nvoid add_edge (graph * const g, const int32_t from, const int32_t to, const flow_type capa) {\n  if (g->pointer == g->edge_length) {\n    g->edge_length *= 2;\n    g->edge = (flow_edge *) realloc (g->edge, sizeof (flow_edge) * g->edge_length);\n  }\n  const int32_t p = g->pointer;\n  g->edge[p] = (flow_edge) {to, g->start[from], capa};\n  g->start[from] = p;\n  g->edge[p + 1] = (flow_edge) {from, g->start[to], 0};\n  g->start[to] = p + 1;\n  g->pointer += 2;\n}\n\nflow_type dinic_dfs (const int32_t v, graph * const g, const int32_t dst, const int32_t * const level, int32_t * const iter, flow_type e) {\n  if (v == dst) return e;\n  flow_type sum = 0;\n  for (int32_t p = iter[v]; p != -1; p = g->edge[p].next, iter[v] = p) {\n    const int32_t u = g->edge[p].vertex;\n    const flow_type capa = g->edge[p].capacity;\n    if (level[u] <= level[v] || capa <= 0) continue;\n    const flow_type f = dinic_dfs (u, g, dst, level, iter, capa < e ? capa : e);\n    if (f > 0) {\n      g->edge[p].capacity -= f;\n      g->edge[p ^ 1].capacity += f;\n      sum += f;\n      e -= f;\n      if (e <= 0) return sum;\n    }\n  }\n  return sum;\n}\n\nflow_type dinic (graph * const g, const int32_t src, const int32_t dst) {\n  const int32_t vertex_num = g->vertex_num;\n  int32_t * const level = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const queue = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const iter  = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  flow_type flow = 0;\n  while (1) {\n    memset (level, 0, sizeof (int32_t) * vertex_num);\n    int32_t front = 0;\n    int32_t last = 0;\n    level[dst] = vertex_num;\n    queue[last++] = dst;\n    while (front < last && level[src] == 0) {\n      const int32_t v = queue[front++];\n      for (int32_t p = g->start[v]; p!=-1; p = g->edge[p].next) {\n        const int32_t u = g->edge[p].vertex;\n        if (g->edge[p ^ 1].capacity > 0 && level[u] == 0) {\n          level[u] = level[v] - 1;\n          queue[last++] = u;\n\t}\n      }\n    }\n    if (level[src] == 0) break;\n    memcpy (iter, g->start, sizeof (int32_t) * vertex_num);\n    while (1) {\n      flow_type f = dinic_dfs (src, g, dst, level, iter, flow_inf);\n      if (f <= 0) break;\n      flow += f;\n    }\n  }\n  free (level);\n  free (queue);\n  free (iter);\n  return flow;\n}\n\ntypedef int32_t i32;\n\nvoid run (void) {\n  i32 h, w;\n  scanf(\"%\" SCNi32 \"%\" SCNi32, &h, &w);\n  char *s = (char *) calloc (h * w + 1, sizeof (char));\n  for (i32 i = 0; i < h; ++i) {\n    scanf (\"%s\", s + i * w);\n  }\n  graph *g = new_graph (2 * h * w + 2);\n  i32 src = 2 * h * w;\n  i32 dst = src + 1;\n  for (i32 i = 0; i < h; ++i) {\n    for (i32 j = 0; j < w; ++j) {\n      if (i == 0 || i == h - 1 || j == 0 || j == w - 1) {\n\tadd_edge (g, i * w + j, dst, flow_inf);\n      }\n      if (s[i * w + j] == 'X') {\n\tadd_edge (g, src, i * w + j, flow_inf);\n\tadd_edge (g, h * w + i * w + j, i * w + j, flow_inf);\n      } else {\n\tadd_edge (g, h * w + i * w + j, i * w + j, 1);\n      }\n      i32 d[] = {-1, 0, 1, 0};\n      for (i32 k = 0; k < 4; ++k) {\n\ti32 x = i + d[k];\n\ti32 y = j + d[k ^ 1];\n\tif (!(0 <= x && x < h && 0 <= y && y < w)) continue;\n\tadd_edge (g, i * w + j, h * w + x * w + y, flow_inf);\n      }\n    }\n  }\n  i32 ans = dinic(g, src, dst);\n  if (ans >= flow_inf) {\n    puts(\"-1\");\n  } else {\n    printf(\"%\" PRIi32 \"\\n\", ans);\n  }\n}\n\nint main (void) {\n  run ();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int32_t flow_type;\n\nconst flow_type flow_inf=400;\n\ntypedef struct flow_edge{\n  int vertex;\n  int next;\n  flow_type capacity;\n} flow_edge;\n\ntypedef struct maxFlowGraph{\n  flow_edge *edge;\n  int *start;\n  int vertex_num;\n  int pointer;\n  int edge_length;\n} graph;\n\ngraph* newGraph(const int vertex_num){\n  graph *g=(graph *)calloc(1,sizeof(graph));\n  g->vertex_num=vertex_num;\n  const int initial_length=4;\n  g->edge=(flow_edge *)calloc(initial_length,sizeof(flow_edge));\n  g->start=(int *)calloc(vertex_num,sizeof(int));\n  g->pointer=0;\n  g->edge_length=initial_length;\n  for(int i=0;i<vertex_num;i++) g->start[i]=-1;\n  return g;\n}\n\nvoid freeGraph(graph *g){\n  free(g->edge);\n  free(g->start);\n  free(g);\n}\n\nvoid addEdge(graph *g,int from,int to,flow_type capa){\n  if(g->pointer==g->edge_length){\n    g->edge_length*=2;\n    g->edge=(flow_edge *)realloc(g->edge,sizeof(flow_edge)*g->edge_length);\n  }\n  int p=g->pointer;\n  g->edge[p]=(flow_edge){to,g->start[from],capa};\n  g->start[from]=p;\n  g->edge[p+1]=(flow_edge){from,g->start[to],0};\n  g->start[to]=p+1;\n  g->pointer+=2;\n}\n\nflow_type dinic_dfs(int v,graph *g,int dst,int *level,int *iter,flow_type e){\n  if(v==dst) return e;\n  flow_type sum=0;\n  for(int p=iter[v];p!=-1 && e>0;p=g->edge[p].next,iter[v]=p){\n    int u=g->edge[p].vertex;\n    flow_type capa=g->edge[p].capacity;\n    if(level[u]<=level[v] || capa<=0) continue;\n    flow_type f=dinic_dfs(u,g,dst,level,iter,capa<e?capa:e);\n    if(f>0){\n      g->edge[p].capacity-=f;\n      g->edge[p^1].capacity+=f;\n      sum+=f;\n      e-=f;\n      if(e<=0) return sum;\n    }\n  }\n  return sum;\n}\n\nflow_type dinic(const graph *input_graph,const int src,const int dst){\n  const int vertex_num=input_graph->vertex_num;\n  const int edge_num=input_graph->pointer;\n  graph *g=(graph *)calloc(1,sizeof(graph));\n  g->edge=(flow_edge *)malloc(sizeof(flow_edge)*edge_num);\n  g->start=(int *)malloc(sizeof(int)*vertex_num);\n  memcpy(g->edge,input_graph->edge,sizeof(flow_edge)*edge_num);\n  memcpy(g->start,input_graph->start,sizeof(int)*vertex_num);\n  int *level=(int *)calloc(vertex_num,sizeof(int));\n  int *queue=(int *)calloc(vertex_num,sizeof(int));\n  int *iter=(int *)calloc(vertex_num,sizeof(int));\n  flow_type flow=0;\n  while(1){\n    memset(level,0,sizeof(int)*vertex_num);\n    int front=0,last=0;\n    level[src]=1;\n    queue[last++]=src;\n    while(front<last && level[dst]==0){\n      const int v=queue[front++];\n      for(int p=g->start[v];p!=-1;p=g->edge[p].next){\n\tint u=g->edge[p].vertex;\n\tif(g->edge[p].capacity>0 && level[u]==0){\n\t  level[u]=level[v]+1;\n\t  queue[last++]=u;\n\t}\n      }\n    }\n    if(level[dst]==0) break;\n    memcpy(iter,g->start,sizeof(int)*vertex_num);\n    while(1){\n      flow_type f=dinic_dfs(src,g,dst,level,iter,flow_inf);\n      if(f<=0) break;\n      flow+=f;\n    }\n  }\n  freeGraph(g);\n  free(level);\n  free(queue);\n  free(iter);\n  return flow;\n}\n\ntypedef int32_t i32;\n\nvoid run (void) {\n  i32 h, w;\n  scanf(\"%\" SCNi32 \"%\" SCNi32, &h, &w);\n  char *s = (char *) calloc (h * w + 1, sizeof (char));\n  for (i32 i = 0; i < h; ++i) {\n    scanf (\"%s\", s + i * w);\n  }\n  graph *g = newGraph (2 * h * w + 2);\n  i32 src = 2 * h * w;\n  i32 dst = src + 1;\n  for (i32 i = 0; i < h; ++i) {\n    for (i32 j = 0; j < w; ++j) {\n      if (i == 0 || i == h - 1 || j == 0 || j == w - 1) {\n\taddEdge (g, i * w + j, dst, flow_inf);\n      }\n      if (s[i * w + j] == 'X') {\n\taddEdge (g, src, i * w + j, flow_inf);\n      }\n      addEdge (g, h * w + i * w + j, i * w + j, 1);\n      i32 d[] = {-1, 0, 1, 0};\n      for (i32 k = 0; k < 4; ++k) {\n\ti32 x = i + d[k];\n\ti32 y = j + d[k ^ 1];\n\tif (!(0 <= x && x < h && 0 <= y && y < w)) continue;\n\taddEdge (g, i * w + j, h * w + x * w + y, flow_inf);\n      }\n    }\n  }\n  i32 ans = dinic(g, src, dst);\n  if (ans >= flow_inf) {\n    puts(\"-1\");\n  } else {\n    printf(\"%\" PRIi32 \"\\n\", ans);\n  }\n}\n\nint main (void) {\n  run ();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "\t      else     ny--;\n\t    }\n\t    nx--;\n\t  }\n\t}\n      }\t      \n      //for(k=1;k<tr;k++)s+=MAX(abs(ty[k]-ty[k-1]),abs(tx[k]-tx[k-1]));\n      //s+=4;//printf(\"\\n\");\n    }\n  }\n  //for(i=0;i<h;i++)printf(\"%s\\n\",d[i+2]+2);\n  qy[t=0]=qx[0]=c=0;\n  d[0][0]=1;\n  for(r=1;r-t;t++){\n    for(k=0;k<4;k++){\n      ny=qy[t]+Y[k];\n      nx=qx[t]+X[k];\n      if(ny<0||h+2<ny||nx<0||w+2<nx)continue;\n      if(d[ny][nx]=='#'){\n\tc++;\n\td[ny][nx]=1;\n      }\n      if(d[ny][nx]==1)continue;\n      d[qy[r]=ny][qx[r]=nx]=1;\n      r++;\n    }\n  }\n  printf(\"%d\\n\",c);\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint Y[]={0,1,0,-1};\nint X[]={1,0,-1,0};\nint main(){\n  int h,w,i,j,k,ny,nx,c=0,t,r,qx[100010],qy[100010];\n  char s[110][110]={0};\n  scanf(\"%d %d\",&h,&w);\n  for(i=0;i<h;i++)scanf(\"%s\",s[i+1]+1);\n  for(i=1;i<=h;i++){//printf(\"\\n\");\n    for(j=1;j<=w;j++){//printf(\"%c\",s[i][j]);\n      if(s[i][j]-'X')continue;\n      for(k=0;k<4;k++){\n\tny=i+Y[k];\n\tnx=j+X[k];//printf(\"%d %d\\n\",ny,nx);\n\tif(s[ny][nx]==0){\n\t  printf(\"-1\\n\");\n\t  return 0;\n\t}\n\tif(s[ny][nx]=='X')continue;\n\ts[ny][nx]='#';//printf(\"%d %d\\n\",ny,nx);\n      }\n    }\n  }\n  //for(i=0;i<h;i++)printf(\"%s\\n\",s[i+1]+1);\n  qy[t=0]=qx[0]=0;\n  for(r=4;r-t;t++){\n    for(k=0;k<4;k++){\n      ny=qy[t]+Y[k];\n      nx=qx[t]+X[k];\n      if(ny<0||h+1<ny||nx<0||w+1<nx)continue;\n      if(s[ny][nx]=='#'){\n\tc++;\n\ts[ny][nx]=1;\n      }\n      if(s[ny][nx]==1)continue;\n      s[qy[r]=ny][qx[r]=nx]=1;\n      r++;\n    }\n  }\n  printf(\"%d\\n\",c);\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nint MAX(int a,int b){return a>b?a:b;}\nint main(){\n  int h,w,i,j,ty[10010],tx[10010],x[10010],y[10010],r,c,ay,ax,by,bx,s;\n  char d;\n  scanf(\"%d %d\",&h,&w);\n  for(i=s=c=0;i<h;i++){\n    for(j=0;j<w;j++){\n      scanf(\" %c\",&d);\n      if(d=='X'){\n\ty[c  ]=i;\n\tx[c++]=j;\n\tif(i+j==0||i==h-1||j==w-1)s=-1;\n      }\n    }\n  }\n  if(s==-1){\n    printf(\"-1\\n\");\n    return 0;\n  }//printf(\"%d\\n\",c);\n  for(i=s=r=0;i<c;i++){\n    while(1){\n      if(r<2){\n\tty[r  ]=y[i];\n\ttx[r++]=x[i];\n\tbreak;\n      }\n      ay=ty[r-1]-ty[r-2];\n      ax=tx[r-1]-tx[r-2];\n      by= y[i  ]-ty[r-1];\n      bx= x[i  ]-tx[r-1];\n      if(ax*by>ay*bx){\n\tty[r  ]=y[i];\n\ttx[r++]=x[i];\n\tbreak;\n      }\n      r--;\n    }\n  }\n  //for(i=0;i<r;i++)printf(\"%d %d\\n\",ty[i],tx[i]);\n  for(i=1;i<r;i++)s+=MAX(abs(ty[i]-ty[i-1]),abs(tx[i]-tx[i-1]));\n  for(i=r=0;i<c;i++){\n    while(1){\n      if(r<2){\n\tty[r  ]=y[i];\n\ttx[r++]=x[i];\n\tbreak;\n      }\n      ay=ty[r-1]-ty[r-2];\n      ax=tx[r-1]-tx[r-2];\n      by= y[i  ]-ty[r-1];\n      bx= x[i  ]-tx[r-1];\n      if(ax*by<ay*bx){\n\tty[r  ]=y[i];\n\ttx[r++]=x[i];\n\tbreak;\n      }\n      r--;\n    }\n  }\n  //for(i=0;i<r;i++)printf(\"%d %d\\n\",ty[i],tx[i]);\n  for(i=1;i<r;i++)s+=MAX(abs(ty[i]-ty[i-1]),abs(tx[i]-tx[i-1]));\n  printf(\"%d\\n\",s+4);\n  return 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringJoiner;\nimport java.util.StringTokenizer;\nimport java.util.function.Function;\n\npublic class Main {\n\n    static int H, W;\n    static char[][] C;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        H = sc.nextInt();\n        W = sc.nextInt();\n        C = new char[H][];\n        for (int i = 0; i < H; i++) {\n            C[i] = sc.next().toCharArray();\n        }\n\n        System.out.println(solve());\n    }\n\n    static int solve() {\n        // とりあえず柵を作る\n        for (int h = 0; h < H; h++) {\n            for (int w = 0; w < W; w++) {\n                if( C[h][w] == 'X' ) {\n                    if( h == 0 || h == H-1 || w == 0 || w == W-1) {\n                        return -1;\n                    }\n\n                    for (int i = 0; i < 4; i++) {\n                        int nh = DH[i] + h;\n                        int nw = DW[i] + w;\n\n                        if( C[nh][nw] == '.' ) {\n                            C[nh][nw] = '#';\n                        }\n                    }\n                }\n            }\n        }\n\n        // 外を塗りつぶす\n        for (int h = 0; h < H; h++) {\n            for (int w = 0; w < W; w++) {\n                if( C[h][w] == '.' ) {\n                    bfs(h, w);\n                }\n            }\n        }\n\n        // 外に隣接してない柵は消す\n        for (int h = 0; h < H; h++) {\n            for (int w = 0; w < W; w++) {\n                if( C[h][w] == '#' && !isGaiHeki(h, w) ) {\n                    C[h][w] = '.';\n                }\n            }\n        }\n\n//        for (int i = 0; i < H; i++) {\n//            debug(new String(C[i]) );\n//        }\n\n        int ans = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if( C[i][j] == '#' ) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n\n    static boolean isGaiHeki(int h, int w) {\n        for (int i = 0; i < 4; i++) {\n            int nh = DH[i] + h;\n            int nw = DW[i] + w;\n\n            if( !inRange(nh, nw) ) {\n                return true;\n            }\n\n            if( C[nh][nw] == '0' ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    static void bfs(int sh, int sw) {\n        int[] q = new int[H*W];\n        int u = 0, v = 0;\n        q[v++] = sh * W + sw;\n        C[sh][sw] = '0';\n        while( u != v ) {\n            int hw = q[u++];\n            int h = hw / W;\n            int w = hw % W;\n\n            for (int i = 0; i < 4; i++) {\n                int nh = h + DH[i];\n                int nw = w + DW[i];\n                if( inRange(nh, nw) && C[nh][nw] == '.' ) {\n                    q[v++] = nh*W + nw;\n                    C[nh][nw] = '0';\n                }\n            }\n        }\n    }\n\n    static boolean inRange(int h, int w) {\n        return 0 <= h && h < H && 0 <= w && w < W;\n    }\n\n    static int[] DH = {0, 1, 0, -1};\n    static int[] DW = {1, 0, -1, 0};\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map.Entry;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DR = { 1, 0, -1, 0 };\n\tstatic int[] DC = { 0, 1, 0, -1 };\n\tstatic int H, W;\n\tstatic char[][] S;\n\n\tpublic static void main(String[] args) {\n\t\tH = sc.nextInt();\n\t\tW = sc.nextInt();\n\t\tS = new char[H][];\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tS[i] = sc.next().toCharArray();\n\t\t}\n\t\tSystem.out.println(solve());\n\t}\n\n\tstatic int solve() {\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tif (S[0][i] == 'X' || S[H - 1][i] == 'X') return -1;\n\t\t}\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tif (S[i][0] == 'X' || S[i][W - 1] == 'X') return -1;\n\t\t}\n\t\tfor (int i = 1; i < H - 1; ++i) {\n\t\t\tfor (int j = 1; j < W - 1; ++j) {\n\t\t\t\tif (S[i][j] == 'X') {\n\t\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\t\tif (S[i + DR[k]][j + DC[k]] == '.') S[i + DR[k]][j + DC[k]] = 'F';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tMaxFlow f = new MaxFlow(2 * H * W + 2);\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (i != 0) f.add(i * W + j + H * W, (i - 1) * W + j, 99999);\n\t\t\t\tif (i != H - 1) f.add(i * W + j + H * W, (i + 1) * W + j, 99999);\n\t\t\t\tif (j != 0) f.add(i * W + j + H * W, i * W + j - 1, 99999);\n\t\t\t\tif (j != W - 1) f.add(i * W + j + H * W, i * W + j + 1, 99999);\n\t\t\t\tif (S[i][j] == 'X') {\n\t\t\t\t\tf.add(2 * H * W, i * W + j, 99999);\n\t\t\t\t\tf.add(i * W + j, i * W + j + H * W, 99999);\n\t\t\t\t} else {\n\t\t\t\t\tf.add(i * W + j, i * W + j + H * W, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < H - 1; ++i) {\n\t\t\tf.add(i * W + H * W, 2 * H * W + 1, 99999);\n\t\t\tf.add(i * W + W - 1 + H * W, 2 * H * W + 1, 99999);\n\t\t}\n\t\tfor (int i = 1; i < W - 1; ++i) {\n\t\t\tf.add(i + H * W, 2 * H * W + 1, 99999);\n\t\t\tf.add((H - 1) * W + i + H * W, 2 * H * W + 1, 99999);\n\t\t}\n\t\treturn f.calc(2 * H * W, 2 * H * W + 1);\n\t}\n\n\tstatic class MaxFlow {\n\t\tArrayList<HashMap<Integer, Integer>> g = new ArrayList<>();\n\n\t\tMaxFlow(int size) {\n\t\t\tfor (int i = 0; i < size; ++i) {\n\t\t\t\tg.add(new HashMap<>());\n\t\t\t}\n\t\t}\n\n\t\tvoid add(int from, int to, int cap) {\n\t\t\tg.get(from).put(to, cap);\n\t\t\tg.get(to).put(from, -cap);\n\t\t}\n\n\t\tint calc(int src, int sink) {\n\t\t\tint size = g.size();\n\t\t\tint result = 0;\n\t\t\tint[] prev = new int[size];\n\t\t\twhile (true) {\n\t\t\t\tboolean[] visited = new boolean[size];\n\t\t\t\tQueue<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\tq.add(src);\n\t\t\t\tvisited[src] = true;\n\t\t\t\tOUT: while (!q.isEmpty()) {\n\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\tfor (Entry<Integer, Integer> e : g.get(cur).entrySet()) {\n\t\t\t\t\t\tif (!visited[e.getKey()] && e.getValue() > 0) {\n\t\t\t\t\t\t\tprev[e.getKey()] = cur;\n\t\t\t\t\t\t\tvisited[e.getKey()] = true;\n\t\t\t\t\t\t\tif (e.getKey() == sink) {\n\t\t\t\t\t\t\t\tbreak OUT;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tq.add(e.getKey());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!visited[sink]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint pos = sink;\n\t\t\t\tint pathCap = Integer.MAX_VALUE;\n\t\t\t\twhile (pos != src) {\n\t\t\t\t\tint p = prev[pos];\n\t\t\t\t\tpathCap = Math.min(pathCap, g.get(p).get(pos));\n\t\t\t\t\tpos = p;\n\t\t\t\t}\n\t\t\t\tpos = sink;\n\t\t\t\twhile (pos != src) {\n\t\t\t\t\tint p = prev[pos];\n\t\t\t\t\tg.get(p).put(pos, g.get(p).get(pos) - pathCap);\n\t\t\t\t\tg.get(pos).put(p, g.get(pos).get(p) + pathCap);\n\t\t\t\t\tpos = p;\n\t\t\t\t}\n\t\t\t\tresult += pathCap;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map.Entry;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int H, W;\n\tstatic char[][] S;\n\n\tpublic static void main(String[] args) {\n\t\tH = sc.nextInt();\n\t\tW = sc.nextInt();\n\t\tS = new char[H][];\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tS[i] = sc.next().toCharArray();\n\t\t}\n\t\tSystem.out.println(solve());\n\t}\n\n\tstatic int solve() {\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tif (S[0][i] == 'X' || S[H - 1][i] == 'X') return -1;\n\t\t}\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tif (S[i][0] == 'X' || S[i][W - 1] == 'X') return -1;\n\t\t}\n\t\tMaxFlow f = new MaxFlow(2 * H * W + 2);\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (i != 0)     f.add(i * W + j + H * W, (i - 1) * W + j, 99999);\n\t\t\t\tif (i != H - 1) f.add(i * W + j + H * W, (i + 1) * W + j, 99999);\n\t\t\t\tif (j != 0)     f.add(i * W + j + H * W, i * W + j - 1, 99999);\n\t\t\t\tif (j != W - 1) f.add(i * W + j + H * W, i * W + j + 1, 99999);\n\t\t\t\tif (S[i][j] == 'X') {\n\t\t\t\t\tf.add(2 * H * W, i * W + j, 99999);\n\t\t\t\t\tf.add(i * W + j, i * W + j + H * W, 99999);\n\t\t\t\t} else {\n\t\t\t\t\tf.add(i * W + j, i * W + j + H * W, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tf.add(i * W + H * W, 2 * H * W + 1, 99999);\n\t\t\tf.add(i * W + W - 1 + H * W, 2 * H * W + 1, 99999);\n\t\t}\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tf.add(i + H * W, 2 * H * W + 1, 99999);\n\t\t\tf.add((H - 1) * W + i + H * W, 2 * H * W + 1, 99999);\n\t\t}\n\t\treturn f.calc(2 * H * W, 2 * H * W + 1);\n\t}\n\n\tstatic class MaxFlow {\n\t\tArrayList<HashMap<Integer, Integer>> g = new ArrayList<>();\n\n\t\tMaxFlow(int size) {\n\t\t\tfor (int i = 0; i < size; ++i) {\n\t\t\t\tg.add(new HashMap<>());\n\t\t\t}\n\t\t}\n\n\t\tvoid add(int from, int to, int cap) {\n\t\t\tg.get(from).put(to, cap);\n\t\t\tg.get(to).put(from, -cap);\n\t\t}\n\n\t\tint calc(int src, int sink) {\n\t\t\tint size = g.size();\n\t\t\tint result = 0;\n\t\t\tint[] prev = new int[size];\n\t\t\twhile (true) {\n\t\t\t\tboolean[] visited = new boolean[size];\n\t\t\t\tQueue<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\tq.add(src);\n\t\t\t\tvisited[src] = true;\n\t\t\t\tOUT: while (!q.isEmpty()) {\n\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\tfor (Entry<Integer, Integer> e : g.get(cur).entrySet()) {\n\t\t\t\t\t\tif (!visited[e.getKey()] && e.getValue() > 0) {\n\t\t\t\t\t\t\tprev[e.getKey()] = cur;\n\t\t\t\t\t\t\tvisited[e.getKey()] = true;\n\t\t\t\t\t\t\tif (e.getKey() == sink) {\n\t\t\t\t\t\t\t\tbreak OUT;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tq.add(e.getKey());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!visited[sink]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint pos = sink;\n\t\t\t\tint pathCap = Integer.MAX_VALUE;\n\t\t\t\twhile (pos != src) {\n\t\t\t\t\tint p = prev[pos];\n\t\t\t\t\tpathCap = Math.min(pathCap, g.get(p).get(pos));\n\t\t\t\t\tpos = p;\n\t\t\t\t}\n\t\t\t\tpos = sink;\n\t\t\t\twhile (pos != src) {\n\t\t\t\t\tint p = prev[pos];\n\t\t\t\t\tg.get(p).put(pos, g.get(p).get(pos) - pathCap);\n\t\t\t\t\tg.get(pos).put(p, g.get(pos).get(p) + pathCap);\n\t\t\t\t\tpos = p;\n\t\t\t\t}\n\t\t\t\tresult += pathCap;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DR = { 1, 0, -1, 0 };\n\tstatic int[] DC = { 0, 1, 0, -1 };\n\tstatic int H, W;\n\tstatic char[][] S;\n\n\tpublic static void main(String[] args) {\n\t\tH = sc.nextInt();\n\t\tW = sc.nextInt();\n\t\tS = new char[H][];\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tS[i] = sc.next().toCharArray();\n\t\t}\n\t\tSystem.out.println(solve());\n\t}\n\n\tstatic int solve() {\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tif (S[0][i] == 'X' || S[H - 1][i] == 'X') return -1;\n\t\t}\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tif (S[i][0] == 'X' || S[i][W - 1] == 'X') return -1;\n\t\t}\n\t\tfor (int i = 1; i < H - 1; ++i) {\n\t\t\tfor (int j = 1; j < W - 1; ++j) {\n\t\t\t\tif (S[i][j] == 'X') {\n\t\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\t\tif (S[i + DR[k]][j + DC[k]] == '.') S[i + DR[k]][j + DC[k]] = 'F';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tchar[][] ns = new char[H + 2][W + 2];\n\t\tfor (char[] a : ns) {\n\t\t\tArrays.fill(a, '.');\n\t\t}\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tns[i + 1][j + 1] = S[i][j];\n\t\t\t}\n\t\t}\n\t\tboolean[][] visited = new boolean[H + 2][W + 2];\n\t\tArrayList<Integer> q = new ArrayList<>();\n\t\tq.add(0);\n\t\tvisited[0][0] = true;\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < q.size(); ++i) {\n\t\t\tint cr = q.get(i) >> 16;\n\t\t\tint cc = q.get(i) & 0xFFFF;\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tint nr = cr + DR[j];\n\t\t\t\tint nc = cc + DC[j];\n\t\t\t\tif (nr < 0 || H + 2 <= nr || nc < 0 || W + 2 <= nc) continue;\n\t\t\t\tif (visited[nr][nc]) continue;\n\t\t\t\tif (ns[nr][nc] == '.') {\n\t\t\t\t\tq.add((nr << 16) | nc);\n\t\t\t\t\tvisited[nr][nc] = true;\n\t\t\t\t} else if (ns[nr][nc] == 'F') {\n\t\t\t\t\t++ans;\n\t\t\t\t\tns[nr][nc] = 'G';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\n\npublic class Main {\n\n  static int H;\n  static int W;\n  private static void solve() {\n    H = ni();\n    W = ni();\n    \n    char[][] map = new char[H][];\n    for (int i = 0; i < H; i ++) {\n      map[i] = ns();\n    }\n    \n\n    int ptr = 0;\n    int[] from = new int[200000];\n    int[] to = new int[200000];\n    int[] w = new int[200000];\n\n    int src = W * H * 2;\n    int sink = W * H * 2 + 1;\n\n    int INF = 110000;\n    int[][] DIR = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n    for (int i = 0; i < H; i ++) {\n      for (int j = 0; j < W; j ++) {\n        int in = j + W * i;\n        int out = H * W + j + i * W;\n        from[ptr] = in;\n        to[ptr] = out;\n        w[ptr] = map[i][j] == 'X' ? INF : 1;\n        ptr ++;\n        \n        if (i == 0 || i == H - 1 || j == 0 || j == W - 1) { \n          if (map[i][j] == 'X') {\n            System.out.println(-1);\n            return;\n          } else {\n            from[ptr] = out;\n            to[ptr] = sink;\n            w[ptr] = INF;\n            ptr ++;\n          }\n        }\n\n        if (map[i][j] == 'X') {\n          from[ptr] = src;\n          to[ptr] = in;\n          w[ptr] = INF;\n          ptr ++;\n        }\n        \n        for (int[] d : DIR) {\n          int ni = i + d[0];\n          int nj = j + d[1];\n          if (ni < 0 || ni >= H || nj < 0 || nj >= W) {\n            continue;\n          } else {\n            int nin = nj + W * ni;\n            from[ptr] = out;\n            to[ptr] = nin;\n            w[ptr] = INF;\n            ptr ++;\n          }\n        }\n      }\n    }\n    from = Arrays.copyOf(from, ptr);\n    to = Arrays.copyOf(to, ptr);\n    w = Arrays.copyOf(w, ptr);\n    \n    int[][][] cap = packWD(sink + 1, from, to, w);\n    \n    int ret = maximumFlowDinic(cap, src, sink);\n    System.out.println(ret);\n  }\n\n  public static int[][][] packWD(int n, int[] from, int[] to, int[] w){ return packWD(n, from, to, w, from.length); }\n  public static int[][][] packWD(int n, int[] from, int[] to, int[] w, int sup)\n  {\n      int[][][] g = new int[n][][];\n      int[] p = new int[n];\n      for(int i = 0;i < sup;i++)p[from[i]]++;\n      for(int i = 0;i < n;i++)g[i] = new int[p[i]][2];\n      for(int i = 0;i < sup;i++){\n          --p[from[i]];\n          g[from[i]][p[from[i]]][0] = to[i];\n          g[from[i]][p[from[i]]][1] = w[i];\n      }\n      return g;\n  }\n  \n  public static int maximumFlowDinic(int[][][] g, int source, int sink)\n  {\n      int n = g.length;\n      \n      // unweighted invgraph\n      int[] p = new int[n];\n      for(int i = 0;i < n;i++){\n          for(int j = 0;j < g[i].length;j++)p[g[i][j][0]]++;\n      }\n      int[][] ig = new int[n][];\n      for(int i = 0;i < n;i++)ig[i] = new int[p[i]];\n      for(int i = n-1;i >= 0;i--){\n          for(int j = 0;j < g[i].length;j++){\n              ig[g[i][j][0]][--p[g[i][j][0]]] = i;\n          }\n      }\n      \n      int[][] f = new int[n][n];\n      int[] d = new int[n];\n      int[] q = new int[n];\n      int ret = 0;\n      while(true){\n          Arrays.fill(d, -1);\n          q[0] = source;\n          int r = 1;\n          d[source] = 0;\n          \n          for(int v = 0;v < r;v++){\n              int cur = q[v];\n              // plus flow\n              for(int[] ne : g[cur]){\n                  int nex = ne[0], w = ne[1];\n                  if(d[nex] == -1 && w - f[cur][nex] > 0) {\n                      q[r++] = nex;\n                      d[nex] = d[cur] + 1;\n                  }\n              }\n              // minus flow\n              for(int nex : ig[cur]){\n                  if(d[nex] == -1 && -f[cur][nex] > 0) {\n                      q[r++] = nex;\n                      d[nex] = d[cur] + 1;\n                  }\n              }\n          }\n          if(d[sink] == -1)break;\n          int delta = 0;\n          while((delta = dfsDinic(d, g, ig, f, source, sink, Integer.MAX_VALUE)) > 0){\n              ret += delta;\n          }\n      }\n      \n      return ret;\n  }\n  \n  public static int dfsDinic(int[] d, int[][][] g, int[][] ig, int[][] f, int cur, int t, int min)\n  {\n      if(cur == t){\n          return min;\n      }else{\n          int left = min;\n          for(int[] ne : g[cur]){\n              int nex = ne[0], w = ne[1];\n              if(d[nex] == d[cur]+1 && w-f[cur][nex] > 0){\n                  int fl = dfsDinic(d, g, ig, f, nex, t, Math.min(left, w-f[cur][nex]));\n                  if(fl > 0){\n                      f[cur][nex] += fl;\n                      f[nex][cur] -= fl;\n                      left -= fl;\n                      if(left == 0)return min;\n                  }\n              }\n          }\n          for(int nex : ig[cur]){\n              if(d[nex] == d[cur]+1 && -f[cur][nex] > 0){\n                  int fl = dfsDinic(d, g, ig, f, nex, t, Math.min(left, -f[cur][nex]));\n                  if(fl > 0){\n                      f[cur][nex] += fl;\n                      f[nex][cur] -= fl;\n                      left -= fl;\n                      if(left == 0)return min;\n                  }\n              }\n          }\n          return min-left;\n      }\n  }\n  \n  \n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = System.getProperty(\"debug\");\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    void solve() throws IOException {\n    \tint H = ni();\n    \tint W = ni();\n\n    \tString[] S = nsa(H);\n\n    \tif (S[0].indexOf('X') != -1 || S[H-1].indexOf('X') != -1) {\n    \t\tout.println(-1);\n    \t\treturn;\n    \t}\n\n    \tfor (int i=0; i<H; i++) {\n    \t\tif (S[i].charAt(0) == 'X' || S[i].charAt(W-1) == 'X') {\n        \t\tout.println(-1);\n        \t\treturn;\n        \t}\n    \t}\n\n    \tboolean[][] used = new boolean[H][W];\n\n    \tList<Pair> list = new ArrayList<>();\n\n    \tfor (int i=0; i<H; i++) {\n    \t\tfor (int j=0; j<W; j++) {\n    \t\t\tif (S[i].charAt(j) == 'X') {\n        \t\t\tlist.add(new Pair(i, j));\n        \t\t\tused[i][j] = true;\n    \t\t\t}\n    \t\t}\n    \t}\n\n    \tint ans = 0;\n\n    \tfor (int i=0; i<list.size(); i++) {\n    \t\tint h = list.get(i).x;\n    \t\tint w = list.get(i).y;\n    \t\tif (!used[h - 1][w]) {\n    \t\t\tans++;\n    \t\t\tused[h - 1][w] = true;\n    \t\t}\n    \t\tif (!used[h + 1][w]) {\n    \t\t\tans++;\n    \t\t\tused[h + 1][w] = true;\n    \t\t}\n    \t\tif (!used[h][w - 1]) {\n    \t\t\tans++;\n    \t\t\tused[h][w - 1] = true;\n    \t\t}\n    \t\tif (!used[h][w + 1]) {\n    \t\t\tans++;\n    \t\t\tused[h][w + 1] = true;\n    \t\t}\n    \t}\n\n    \tfor (int i=1; i<H-1; i++) {\n    \t\tfor (int j=1; j<W-1; j++) {\n    \t\t\tboolean flg1 = false;\n    \t\t\tboolean flg2 = false;\n    \t\t\tboolean flg3 = false;\n    \t\t\tboolean flg4 = false;\n    \t\t\tfor (int k=i-1; k>=0; k--) {\n    \t\t\t\tif (used[k][j]) {\n    \t\t\t\t\tflg1 = true;\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tfor (int k=i+1; k<H; k++) {\n    \t\t\t\tif (used[k][j]) {\n    \t\t\t\t\tflg2 = true;\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tfor (int k=j-1; k>=0; k--) {\n    \t\t\t\tif (used[i][k]) {\n    \t\t\t\t\tflg3 = true;\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tfor (int k=j+1; k<W; k++) {\n    \t\t\t\tif (used[i][k]) {\n    \t\t\t\t\tflg4 = true;\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tif (flg1 && flg2 && flg3 && flg4) {\n    \t\t\t\tans--;\n    \t\t\t}\n    \t\t}\n    \t}\n\n    \tans += list.size();\n\n    \tout.println(ans);\n    }\n\n    public class Pair implements Comparable<Pair> {\n\t\tint x, y;\n\n\t\tpublic Pair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic int compareTo(Pair p) {\n\t\t\treturn x == p.x ? y - p.y : x - p.x;\n\t\t}\n\t}\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    void solve() throws IOException {\n    \tint H = ni();\n    \tint W = ni();\n\n    \tString[] S = nsa(H);\n\n    \tif (S[0].indexOf('X') != -1 || S[0].indexOf('X') != -1) {\n    \t\tout.println(-1);\n    \t\treturn;\n    \t}\n\n    \tfor (int i=0; i<H; i++) {\n    \t\tif (S[i].charAt(0) == 'X' || S[i].charAt(W-1) == 'X') {\n        \t\tout.println(-1);\n        \t\treturn;\n        \t}\n    \t}\n\n    \tboolean[][] used = new boolean[H][W];\n\n    \tList<Pair> list = new ArrayList<>();\n\n    \tfor (int i=0; i<H; i++) {\n    \t\tfor (int j=0; j<W; j++) {\n    \t\t\tif (S[i].charAt(j) == 'X') {\n        \t\t\tlist.add(new Pair(i, j));\n        \t\t\tused[i][j] = true;\n    \t\t\t}\n    \t\t}\n    \t}\n\n    \tint ans = 0;\n\n    \tfor (int i=0; i<list.size(); i++) {\n    \t\tint h = list.get(i).x;\n    \t\tint w = list.get(i).y;\n    \t\tif (!used[h - 1][w]) {\n    \t\t\tans++;\n    \t\t\tused[h - 1][w] = true;\n    \t\t}\n    \t\tif (!used[h + 1][w]) {\n    \t\t\tans++;\n    \t\t\tused[h + 1][w] = true;\n    \t\t}\n    \t\tif (!used[h][w - 1]) {\n    \t\t\tans++;\n    \t\t\tused[h][w - 1] = true;\n    \t\t}\n    \t\tif (!used[h][w + 1]) {\n    \t\t\tans++;\n    \t\t\tused[h][w + 1] = true;\n    \t\t}\n    \t}\n\n    \tfor (int i=1; i<H-1; i++) {\n    \t\tfor (int j=1; j<W-1; j++) {\n    \t\t\tboolean flg1 = false;\n    \t\t\tboolean flg2 = false;\n    \t\t\tboolean flg3 = false;\n    \t\t\tboolean flg4 = false;\n    \t\t\tfor (int k=i-1; k>=0; k--) {\n    \t\t\t\tif (used[k][j]) {\n    \t\t\t\t\tflg1 = true;\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tfor (int k=i+1; k<H; k++) {\n    \t\t\t\tif (used[k][j]) {\n    \t\t\t\t\tflg2 = true;\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tfor (int k=j-1; k>=0; k--) {\n    \t\t\t\tif (used[i][k]) {\n    \t\t\t\t\tflg3 = true;\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tfor (int k=j+1; k<W; k++) {\n    \t\t\t\tif (used[i][k]) {\n    \t\t\t\t\tflg4 = true;\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tif (flg1 && flg2 && flg3 && flg4) {\n    \t\t\t\tans--;\n    \t\t\t}\n    \t\t}\n    \t}\n\n    \tans += list.size();\n\n    \tout.println(ans);\n    }\n\n    public class Pair implements Comparable<Pair> {\n\t\tint x, y;\n\n\t\tpublic Pair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic int compareTo(Pair p) {\n\t\t\treturn x == p.x ? y - p.y : x - p.x;\n\t\t}\n\t}\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tstatic int h;\n\tstatic int w;\n\tstatic byte[][] map;\n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\tlong start = System.currentTimeMillis();\n\t\tinitMap();\n\t\tif (checkEdge()) {\n\t\t\tSystem.out.println(\"-1\");\n\t\t\treturn;\n\t\t}\n\t\tfill();\n\t\tcheckInner();\n\t\tint cnt = count();\n\t\tSystem.out.println(cnt);\n\t\tlong end = System.currentTimeMillis();\n\t\t//System.out.println((end-start) + \"ms\");\n\t}\n\t\n\tstatic void initMap() throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = br.readLine();\n\t\tString[] flds = line.split(\" \");\n\t\th = Integer.parseInt(flds[0]);\n\t\tw = Integer.parseInt(flds[1]);\n\t\tmap = new byte[h][w];\n\t\tfor (int y=0; y<h; y++) {\n\t\t\tline = br.readLine();\n\t\t\tfor (int x=0; x<w; x++) {\n\t\t\t\tchar ch = line.charAt(x);\n\t\t\t\tif (ch == 'X') {\n\t\t\t\t\tmap[y][x] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic boolean checkEdge() {\n\t\tfor (int x=0; x<w; x++) {\n\t\t\tif (map[0][x] > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (map[h-1][x] > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\t\t\n\t\tfor (int y=0; y<h; y++) {\n\t\t\tif (map[y][0] > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (map[y][w-1] > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tstatic void fill() {\n\t\tfor (int y=1; y<h-1; y++) {\n\t\t\tfor (int x=1; x<w-1; x++) {\n\t\t\t\tif (map[y][x] == 1) {\n\t\t\t\t\tfill(x-1, y);\n\t\t\t\t\tfill(x+1, y);\n\t\t\t\t\tfill(x, y-1);\n\t\t\t\t\tfill(x, y+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void fill(int x, int y) {\n\t\tif (map[y][x] == 0) {\n\t\t\tmap[y][x] = 2;\n\t\t}\n\t}\n\t\n\tstatic void checkInner() {\n\t\tfor (int y=1; y<h-1; y++) {\n\t\t\tfor (int x=1; x<w-1; x++) {\n\t\t\t\tif (map[y][x] != 2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (map[y][x-1] == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (map[y][x+1] == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (map[y-1][x] == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (map[y+1][x] == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmap[y][x] = 3;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic int count() {\n\t\tint cnt = 0;\n\t\tfor (int y=0; y<h; y++) {\n\t\t\tfor (int x=0; x<w; x++) {\n\t\t\t\tif (map[y][x] == 2) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\t\n}\n"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport java.util.*;\n\nimport java.io.*;\n\npublic class Main {\n\tint[] di = {0, 1, 0, -1};\n\tint[] dj = {1, 0, -1, 0};\n\tchar[][] t;\n\tvoid solve() {\n\t\tint H = sc.nextInt();\n\t\tint W = sc.nextInt();\n\t\tt = new char[H+2][W+2];\n\n\t\tfor (int i = 0; i < H+2; i++) Arrays.fill(t[i], '.');\n\t\t\n\t\tfor (int i = 1; i <= H; i++) t[i] = (\".\" + sc.next() + \".\").toCharArray();\n\t\tfor (int i = 1; i <= H; i++) for (int j = 1; j <= W; j++) {\n\t\t\tif (t[i][j] == 'X') {\n\t\t\t\tif (i == 1 || i == H || j == 1 || j == W) {\n\t\t\t\t\tout.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tint ni = i + di[k];\n\t\t\t\t\t\tint nj = j + dj[k];\n\t\t\t\t\t\tif (t[ni][nj] == '.') t[ni][nj] = '#';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H+2; i++) tr(new String(t[i]));\n\t\t\n\t\tmark = new boolean[H+2][W+2];\n\t\tbfs(0, 0);\n//\t\ttr(mark);\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < H+2; i++) for (int j = 0; j < W+2; j++) {\n\t\t\tif (mark[i][j] && t[i][j] == '#') ans++;\n\t\t}\n\t\t\n//\t\ttr((H-2)*2 + (W-2)*2);\n\t\tans = min(ans, (H-4)*2 + (W-4)*2);\n\t\tout.println(ans);\n\t}\n\t\n\tint[] q = new int[128 * 128 * 2];\n\tboolean[][] mark;\n\tvoid bfs(int r, int c) {\n\t\tint sp = 0;\n\t\tmark[r][c] = true;\n\t\tq[sp++] = r;\n\t\tq[sp++] = c;\n\t\t\n\t\twhile (sp > 0) {\n\t\t\tc = q[--sp];\n\t\t\tr = q[--sp];\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tint nr = r + di[k];\n\t\t\t\tint nc = c + dj[k];\n\t\t\t\tif (0 <= nr && nr < mark.length && 0 <= nc && nc < mark[0].length) {\n\t\t\t\t\tif (!mark[nr][nc]) {\n\t\t\t\t\t\tmark[nr][nc] = true;\n\t\t\t\t\t\t if (t[nr][nc] == '.') {\n\t\t\t\t\t\t\tq[sp++] = nr;\n\t\t\t\t\t\t\tq[sp++] = nc;\n\t\t\t\t\t\t }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void tr(Object... os) { System.err.println(deepToString(os)); }\n\tstatic void tr(int[][] as) { for (int[] a : as) tr(a); }\n\tstatic void tr(boolean[][] as) { for (boolean[] a : as) {\n\t\tfor (boolean b : a) {\n\t\t\tSystem.err.print(b ? 1 : 0);\n\t\t}\n\t\tSystem.err.println();\n\t\t}\n\t}\n\n\tvoid print(int[] a) {\n\t\tif (a.length > 0) out.print(a[0]);\n\t\tfor (int i = 1; i < a.length; i++) out.print(\" \" + a[i]);\n\t\tout.println();\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tMyScanner sc = null;\n\tPrintWriter out = null;\n\tpublic void run() throws Exception {\n\t\tsc = new MyScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tfor (;sc.hasNext();) {\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t\tout.close();\n\t}\n\n\tclass MyScanner {\n\t\tString line;\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\n\t\tpublic MyScanner(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic void eat() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\ttokenizer = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String next() {\n\t\t\teat();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tpublic boolean hasNext() {\n\t\t\teat();\n\t\t\treturn (tokenizer != null && tokenizer.hasMoreElements());\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map.Entry;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int H, W;\n\tstatic char[][] S;\n\n\tpublic static void main(String[] args) {\n\t\tH = sc.nextInt();\n\t\tW = sc.nextInt();\n\t\tS = new char[H][];\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tS[i] = sc.next().toCharArray();\n\t\t}\n\t\tSystem.out.println(solve());\n\t}\n\n\tstatic int solve() {\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tif (S[0][i] == 'X' || S[H - 1][i] == 'X') return -1;\n\t\t}\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tif (S[i][0] == 'X' || S[i][W - 1] == 'X') return -1;\n\t\t}\n\t\tMaxFlow f = new MaxFlow(2 * H * W + 2);\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (i != 0)     f.add(i * W + j + H * W, (i - 1) * W + j, 99999);\n\t\t\t\tif (i != H - 1) f.add(i * W + j + H * W, (i + 1) * W + j, 99999);\n\t\t\t\tif (j != 0)     f.add(i * W + j + H * W, i * W + j - 1, 99999);\n\t\t\t\tif (j != W - 1) f.add(i * W + j + H * W, i * W + j + 1, 99999);\n\t\t\t\tif (S[i][j] == 'X') {\n\t\t\t\t\tf.add(2 * H * W, i * W + j + H * W, 99999);\n\t\t\t\t}\n\t\t\t\tf.add(i * W + j, i * W + j + H * W, 1);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tf.add(i * W +         H * W, 2 * H * W + 1, 99999);\n\t\t\tf.add(i * W + W - 1 + H * W, 2 * H * W + 1, 99999);\n\t\t}\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tf.add(              i + H * W, 2 * H * W + 1, 99999);\n\t\t\tf.add((H - 1) * W + i + H * W, 2 * H * W + 1, 99999);\n\t\t}\n\t\treturn f.calc(2 * H * W, 2 * H * W + 1);\n\t}\n\n\tstatic class MaxFlow {\n\t\tArrayList<HashMap<Integer, Integer>> g = new ArrayList<>();\n\n\t\tMaxFlow(int size) {\n\t\t\tfor (int i = 0; i < size; ++i) {\n\t\t\t\tg.add(new HashMap<>());\n\t\t\t}\n\t\t}\n\n\t\tvoid add(int from, int to, int cap) {\n\t\t\tg.get(from).put(to, cap);\n\t\t\tg.get(to).put(from, -cap);\n\t\t}\n\n\t\tint calc(int src, int sink) {\n\t\t\tint size = g.size();\n\t\t\tint result = 0;\n\t\t\tint[] prev = new int[size];\n\t\t\twhile (true) {\n\t\t\t\tboolean[] visited = new boolean[size];\n\t\t\t\tQueue<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\tq.add(src);\n\t\t\t\tvisited[src] = true;\n\t\t\t\tOUT: while (!q.isEmpty()) {\n\t\t\t\t\tint cur = q.poll();\n\t\t\t\t\tfor (Entry<Integer, Integer> e : g.get(cur).entrySet()) {\n\t\t\t\t\t\tif (!visited[e.getKey()] && e.getValue() > 0) {\n\t\t\t\t\t\t\tprev[e.getKey()] = cur;\n\t\t\t\t\t\t\tvisited[e.getKey()] = true;\n\t\t\t\t\t\t\tif (e.getKey() == sink) {\n\t\t\t\t\t\t\t\tbreak OUT;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tq.add(e.getKey());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!visited[sink]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint pos = sink;\n\t\t\t\tint pathCap = Integer.MAX_VALUE;\n\t\t\t\twhile (pos != src) {\n\t\t\t\t\tint p = prev[pos];\n\t\t\t\t\tpathCap = Math.min(pathCap, g.get(p).get(pos));\n\t\t\t\t\tpos = p;\n\t\t\t\t}\n\t\t\t\tpos = sink;\n\t\t\t\twhile (pos != src) {\n\t\t\t\t\tint p = prev[pos];\n\t\t\t\t\tg.get(p).put(pos, g.get(p).get(pos) - pathCap);\n\t\t\t\t\tg.get(pos).put(p, g.get(pos).get(p) + pathCap);\n\t\t\t\t\tpos = p;\n\t\t\t\t}\n\t\t\t\tresult += pathCap;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Main {\n\n  static int H;\n  static int W;\n  private static void solve() {\n    H = ni();\n    W = ni();\n    \n    char[][] map = new char[H][];\n    for (int i = 0; i < H; i ++) {\n      map[i] = ns();\n    }\n    \n\n\n    List<Edge> edges = new ArrayList<>();\n    int src = W * H * 2;\n    int sink = W * H * 2 + 1;\n\n    int INF = 110000;\n    int[][] DIR = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n    for (int i = 0; i < H; i ++) {\n      for (int j = 0; j < W; j ++) {\n        int in = j + W * i;\n        int out = H * W + j + i * W;\n        edges.add(new Edge(in, out, map[i][j] == 'X' ? INF : 1));\n        \n        if (i == 0 || i == H - 1 || j == 0 || j == W - 1) { \n          if (map[i][j] == 'X') {\n            System.out.println(-1);\n            return;\n          } else {\n            edges.add(new Edge(out, sink, INF));\n          }\n        }\n\n        if (map[i][j] == 'X') {\n          edges.add(new Edge(src, in, INF));\n        }\n        \n        for (int[] d : DIR) {\n          int ni = i + d[0];\n          int nj = j + d[1];\n          if (ni < 0 || ni >= H || nj < 0 || nj >= W) {\n            continue;\n          } else {\n            int nin = nj + W * ni;\n            edges.add(new Edge(out, nin, INF));\n          }\n        }\n      }\n    }\n\n    long ret = maximumFlowDinicNoRec(compileWD(sink + 1, edges), src, sink);\n    System.out.println(ret);\n  }\n\n  public static Edge[][] compileWD(int n, List<Edge> edges)\n  {\n      Edge[][] g = new Edge[n][];\n      // cloning\n      for(int i = edges.size()-1;i >= 0;i--){\n          Edge origin = edges.get(i);\n          Edge clone = new Edge(origin.to, origin.from, origin.capacity);\n          clone.flow = origin.capacity;\n          clone.complement = origin;\n          clone.cloned = true;\n          origin.complement = clone;\n          edges.add(clone);\n      }\n      \n      int[] p = new int[n];\n      for(Edge e : edges)p[e.from]++;\n      for(int i = 0;i < n;i++)g[i] = new Edge[p[i]];\n      for(Edge e : edges)g[e.from][--p[e.from]] = e;\n      return g;\n  }\n  \n  public static class Edge\n  {\n      public int from, to;\n      public int capacity;\n      public int flow;\n      public Edge complement;\n      public boolean cloned;\n      \n      public Edge(int from, int to, int capacity) {\n          this.from = from;\n          this.to = to;\n          this.capacity = capacity;\n      }\n  }\n  \n  public static long maximumFlowDinicNoRec(Edge[][] g, int source, int sink)\n  {\n      int n = g.length;\n      int[] d = new int[n]; // distance\n      int[] q = new int[n]; // queue for BFS\n      long ret = 0;\n      int[] stack = new int[n];\n      long[] lefts = new long[n]; // left to flow\n      long[] parflow = new long[n];\n      int[] probe = new int[n]; // search pointer\n      while(true){\n          // BFS\n          Arrays.fill(d, -1);\n          q[0] = source;\n          int r = 1;\n          d[source] = 0;\n          for(int v = 0;v < r;v++){\n              int cur = q[v];\n              for(Edge ne : g[cur]){\n                  if(d[ne.to] == -1 && ne.capacity - ne.flow > 0) {\n                      q[r++] = ne.to;\n                      d[ne.to] = d[cur] + 1;\n                  }\n              }\n          }\n          if(d[sink] == -1)break;\n          \n          // DFS\n          for(int i = 0;i < n;i++)probe[i] = g[i].length-1;\n          int sp = 0;\n          stack[sp] = source;\n          lefts[sp] = Long.MAX_VALUE / 10;\n          parflow[sp] = 0;\n          sp++;\n          long delta = 0;\n          boolean down = true;\n          while(sp > 0){\n              int cur = stack[sp-1];\n              long left = lefts[sp-1];\n              if(cur == sink){\n                  delta += left;\n                  parflow[sp-1] = left;\n                  sp--;\n                  down = false;\n                  continue;\n              }\n              if(!down){\n                  if(parflow[sp] > 0){\n                      lefts[sp-1] -= parflow[sp];\n                      left = lefts[sp-1];\n                      Edge ne = g[cur][probe[cur]];\n                      ne.flow += parflow[sp];\n                      ne.complement.flow -= parflow[sp];\n                      parflow[sp-1] += parflow[sp];\n                  }\n                  if(left > 0)probe[cur]--;\n              }\n              if(left > 0 && probe[cur] >= 0){\n                  down = true;\n                  Edge ne = g[cur][probe[cur]];\n                  if(d[ne.to] == d[cur]+1 && ne.capacity - ne.flow > 0){\n                      lefts[sp] = Math.min(left, ne.capacity - ne.flow);\n                      stack[sp] = ne.to;\n                      parflow[sp] = 0;\n                      sp++;\n                  }else{\n                      probe[cur]--;\n                  }\n              }else{\n                  down = false;\n                  sp--;\n              }\n          }\n          ret += delta;\n      }\n      return ret;\n  }\n  \n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = System.getProperty(\"debug\");\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), m = ni();\n\t\tchar[][] map = nm(n,m);\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < m;j++){\n\t\t\t\tif((i == 0 || i == n-1) && (j == 0 && j == m-1) && map[i][j]=='X'){\n\t\t\t\t\tout.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tList<Edge> es = new ArrayList<>();\n\t\tint[] dr = { 1, 0, -1, 0 };\n\t\tint[] dc = { 0, 1, 0, -1 };\n\t\tint o = n*m;\n\t\tint sink = 2*o, src = sink+1;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < m;j++){\n\t\t\t\tfor(int k = 0;k < 4;k++){\n\t\t\t\t\tint ni = i + dr[k], nj = j + dc[k];\n\t\t\t\t\tif(ni >= 0 && ni < n && nj >= 0 && nj < m){\n\t\t\t\t\t\tes.add(new Edge(i*m+j+o, ni*m+nj, 20000));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tes.add(new Edge(i*m+j+o, sink, 20000));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(map[i][j] == 'X'){\n\t\t\t\t\tes.add(new Edge(src, i*m+j+o, 20000));\n\t\t\t\t}\n\t\t\t\tes.add(new Edge(i*m+j, i*m+j+o, 1));\n\t\t\t}\n\t\t}\n\t\tlong F = maximumFlowDinicNoRec(compileWD(src+1, es), src, sink);\n\t\tif(F > n*m){\n\t\t\tout.println(-1);\n\t\t}else{\n\t\t\tout.println(F);\n\t\t}\n\t}\n\t\n\tpublic static class Edge\n\t{\n\t\tpublic int from, to;\n\t\tpublic int capacity;\n\t\tpublic int flow;\n\t\tpublic Edge complement;\n\t\t// public int iniflow;\n\t\t\n\t\tpublic Edge(int from, int to, int capacity) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.capacity = capacity;\n\t\t}\n\t}\n\t\n\tpublic static Edge[][] compileWD(int n, List<Edge> edges)\n\t{\n\t\tEdge[][] g = new Edge[n][];\n\t\t// cloning\n\t\tfor(int i = edges.size()-1;i >= 0;i--){\n\t\t\tEdge origin = edges.get(i);\n\t\t\tEdge clone = new Edge(origin.to, origin.from, origin.capacity);\n\t\t\tclone.flow = origin.capacity;\n\t\t\tclone.complement = origin;\n\t\t\torigin.complement = clone;\n\t\t\tedges.add(clone);\n\t\t}\n\t\t\n\t\tint[] p = new int[n];\n\t\tfor(Edge e : edges)p[e.from]++;\n\t\tfor(int i = 0;i < n;i++)g[i] = new Edge[p[i]];\n\t\tfor(Edge e : edges)g[e.from][--p[e.from]] = e;\n\t\treturn g;\n\t}\n\t\n\tpublic static Edge[][] compileWU(int n, List<Edge> edges)\n\t{\n\t\tEdge[][] g = new Edge[n][];\n\t\t// cloning\n\t\tfor(int i = edges.size()-1;i >= 0;i--){\n\t\t\tEdge origin = edges.get(i);\n\t\t\tEdge clone = new Edge(origin.to, origin.from, origin.capacity*2);\n\t\t\torigin.flow = origin.capacity;\n\t\t\tclone.flow = origin.capacity;\n\t\t\tclone.complement = origin;\n\t\t\torigin.complement = clone;\n\t\t\torigin.capacity *= 2;\n\t\t\tedges.add(clone);\n\t\t}\n\t\t\n\t\tint[] p = new int[n];\n\t\tfor(Edge e : edges)p[e.from]++;\n\t\tfor(int i = 0;i < n;i++)g[i] = new Edge[p[i]];\n\t\tfor(Edge e : edges)g[e.from][--p[e.from]] = e;\n\t\treturn g;\n\t}\t\n\t\n\tpublic static long maximumFlowDinic(Edge[][] g, int source, int sink)\n\t{\n\t\tint n = g.length;\n\t\tint[] d = new int[n];\n\t\tint[] q = new int[n];\n\t\tlong ret = 0;\n\t\twhile(true){\n\t\t\tArrays.fill(d, -1);\n\t\t\tq[0] = source;\n\t\t\tint r = 1;\n\t\t\td[source] = 0;\n\t\t\t\n\t\t\tfor(int v = 0;v < r;v++){\n\t\t\t\tint cur = q[v];\n\t\t\t\tfor(Edge ne : g[cur]){\n\t\t\t\t\tif(d[ne.to] == -1 && ne.capacity - ne.flow > 0) {\n\t\t\t\t\t\tq[r++] = ne.to;\n\t\t\t\t\t\td[ne.to] = d[cur] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d[sink] == -1)break;\n\t\t\tint[] sp = new int[n];\n\t\t\tfor(int i = 0;i < n;i++)sp[i] = g[i].length - 1;\n\t\t\tret += dfsDinic(d, g, sp, source, sink, Long.MAX_VALUE);\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tprivate static long dfsDinic(int[] d, Edge[][] g, int[] sp, int cur, int sink, long min)\n\t{\n\t\tif(cur == sink)return min;\n\t\tlong left = min;\n\t\tfor(int i = sp[cur];i >= 0;i--){\n\t\t\tEdge ne = g[cur][i];\n\t\t\tif(d[ne.to] == d[cur]+1 && ne.capacity - ne.flow > 0){\n\t\t\t\tlong fl = dfsDinic(d, g, sp, ne.to, sink, Math.min(left, ne.capacity - ne.flow));\n\t\t\t\tif(fl > 0){\n\t\t\t\t\tleft -= fl;\n\t\t\t\t\tne.flow += fl;\n\t\t\t\t\tne.complement.flow -= fl;\n\t\t\t\t\tif(left == 0){\n\t\t\t\t\t\tsp[cur] = i;\n\t\t\t\t\t\treturn min;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsp[cur] = -1;\n\t\treturn min-left;\n\t}\n\t\n\tpublic static long maximumFlowDinicNoRec(Edge[][] g, int source, int sink)\n\t{\n\t\tint n = g.length;\n\t\tint[] d = new int[n]; // distance\n\t\tint[] q = new int[n]; // queue for BFS\n\t\tlong ret = 0;\n\t\tint[] stack = new int[n];\n\t\tlong[] lefts = new long[n]; // left to flow\n\t\tlong[] parflow = new long[n];\n\t\tint[] probe = new int[n]; // search pointer\n\t\twhile(true){\n\t\t\t// BFS\n\t\t\tArrays.fill(d, -1);\n\t\t\tq[0] = source;\n\t\t\tint r = 1;\n\t\t\td[source] = 0;\n\t\t\tfor(int v = 0;v < r;v++){\n\t\t\t\tint cur = q[v];\n\t\t\t\tfor(Edge ne : g[cur]){\n\t\t\t\t\tif(d[ne.to] == -1 && ne.capacity - ne.flow > 0) {\n\t\t\t\t\t\tq[r++] = ne.to;\n\t\t\t\t\t\td[ne.to] = d[cur] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d[sink] == -1)break;\n\t\t\t\n\t\t\t// DFS\n\t\t\tfor(int i = 0;i < n;i++)probe[i] = g[i].length;\n\t\t\tint sp = 0;\n\t\t\tstack[sp] = source;\n\t\t\tlefts[sp] = Long.MAX_VALUE;\n\t\t\tparflow[sp] = 0;\n\t\t\tsp++;\n\t\t\tlong delta = 0;\n\t\t\tboolean down = true;\n\t\t\twhile(sp > 0){\n\t\t\t\tint cur = stack[sp-1];\n\t\t\t\tlong fl = lefts[sp-1];\n\t\t\t\tif(cur == sink){\n\t\t\t\t\tdelta += fl;\n\t\t\t\t\tparflow[sp-1] = fl;\n\t\t\t\t\tsp--;\n\t\t\t\t\tdown = false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(!down && parflow[sp] > 0){\n\t\t\t\t\tlefts[sp-1] -= parflow[sp];\n\t\t\t\t\tfl = lefts[sp-1];\n\t\t\t\t\tEdge ne = g[cur][probe[cur]];\n\t\t\t\t\tne.flow += parflow[sp];\n\t\t\t\t\tne.complement.flow -= parflow[sp];\n\t\t\t\t\tparflow[sp-1] += parflow[sp];\n\t\t\t\t}\n\t\t\t\tif(fl > 0 && probe[cur] > 0){\n\t\t\t\t\tdown = true;\n\t\t\t\t\tEdge ne = g[cur][--probe[cur]];\n\t\t\t\t\tif(d[ne.to] == d[cur]+1 && ne.capacity - ne.flow > 0){\n\t\t\t\t\t\tlefts[sp] = Math.min(lefts[sp-1], ne.capacity - ne.flow);\n\t\t\t\t\t\tstack[sp] = ne.to;\n\t\t\t\t\t\tparflow[sp] = 0;\n\t\t\t\t\t\tsp++;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tdown = false;\n\t\t\t\t\tsp--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret += delta;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "// package atcoder.other2016.kupc2016;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n    private static final int INF = 1000000;\n\n    private static int[] DX = {-1, 0, 1, 0};\n    private static int[] DY = {0, -1, 0, 1};\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int h = in.nextInt();\n        int w = in.nextInt();\n        char[][] map = new char[h][];\n        for (int i = 0; i < h ; i++) {\n            map[i] = in.nextToken().toCharArray();\n        }\n        boolean has = false;\n        for (int i = 0; i < h; i++) {\n            has |= map[i][0] == 'X' || map[i][w-1] == 'X';\n        }\n        for (int i = 0; i < w ; i++) {\n            has |= map[0][i] == 'X' || map[h-1][i] == 'X';\n        }\n        if (has) {\n            out.println(-1);\n        } else {\n            out.println(solve(map));\n        }\n        out.flush();\n    }\n\n    private static int solve(char[][] map) {\n        int h = map.length;\n        int w = map[0].length;\n        int source = 2*h*w;\n        int sink = source+1;\n        MaxFlowDinic flow = new MaxFlowDinic();\n        flow.init(sink+1);\n\n        for (int i = 0 ; i < h ; i++) {\n            for (int j = 0; j < w ; j++) {\n                int vin = (i*w+j)*2;\n                int vout = vin+1;\n\n                if (map[i][j] == 'X') {\n                    flow.edge(source, vin, INF);\n                    flow.edge(vin, vout, INF);\n                } else {\n                    flow.edge(vin, vout, 1);\n                }\n                for (int d = 0 ; d < 4 ; d++) {\n                    int ti = i + DY[d];\n                    int tj = j + DX[d];\n                    if (ti < 0 || tj < 0 || ti >= h || tj >= w) {\n                        flow.edge(vout, sink, INF);\n                    } else {\n                        int tvin = (ti*w+tj)*2;\n                        flow.edge(vout, tvin, INF);\n                    }\n                }\n            }\n        }\n        return flow.max_flow(source, sink);\n    }\n\n    public static class MaxFlowDinic {\n        public List<int[]>[] graph;\n        public int[] deg;\n\n        public int[] level;\n        public int[] itr;\n\n        public int[] que;\n\n        @SuppressWarnings(\"unchecked\")\n        public void init(int size) {\n            graph = new List[size];\n            for (int i = 0; i < size ; i++) {\n                graph[i] = new ArrayList<int[]>();\n            }\n            deg = new int[size];\n            level = new int[size];\n            itr = new int[size];\n            que = new int[size+10];\n        }\n        public void edge(int from, int to, int cap) {\n            int fdeg = deg[from];\n            int tdeg = deg[to];\n            graph[from].add(new int[]{to, cap, tdeg});\n            graph[to].add(new int[]{from, 0, fdeg});\n            deg[from]++;\n            deg[to]++;\n        }\n\n        public int dfs(int v, int t, int f) {\n            if (v == t) return f;\n            for (int i = itr[v] ; i < graph[v].size() ; i++) {\n                itr[v] = i;\n                int[] e = graph[v].get(i);\n                if (e[1] > 0 && level[v] < level[e[0]]) {\n                    int d = dfs(e[0], t, Math.min(f, e[1]));\n                    if (d > 0) {\n                        e[1] -= d;\n                        graph[e[0]].get(e[2])[1] += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n\n        public void bfs(int s) {\n            Arrays.fill(level, -1);\n            int qh = 0;\n            int qt = 0;\n            level[s] = 0;\n            que[qh++] = s;\n            while (qt < qh) {\n                int v = que[qt++];\n                for (int i = 0; i < graph[v].size() ; i++) {\n                    int[] e = graph[v].get(i);\n                    if (e[1] > 0 && level[e[0]] < 0) {\n                        level[e[0]] = level[v] + 1;\n                        que[qh++] = e[0];\n                    }\n                }\n            }\n        }\n\n        public int max_flow(int s, int t) {\n            int flow = 0;\n            while (true) {\n                bfs(s);\n                if (level[t] < 0) {\n                    return flow;\n                }\n                Arrays.fill(itr, 0);\n                while (true) {\n                    int f = dfs(s, t, Integer.MAX_VALUE);\n                    if (f <= 0) {\n                        break;\n                    }\n                    flow += f;\n                }\n            }\n        }\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n\tstatic int h;\n\tstatic int w;\n\tstatic byte[][] map;\n\tstatic List<Point> list = new ArrayList<>();\n\t\n\tstatic class Point {\n\t\tint x;\n\t\tint y;\n\t\t\n\t\tpublic Point(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\tlong start = System.currentTimeMillis();\n\t\tinitMap();\n\t\tif (checkEdge()) {\n\t\t\tSystem.out.println(\"-1\");\n\t\t\treturn;\n\t\t}\n\t\tfill();\n\t\tfillEdge();\n\t\tcheckInner();\n\t\tint cnt = count();\n\t\tSystem.out.println(cnt);\n\t\tlong end = System.currentTimeMillis();\n\t\t//System.out.println((end-start) + \"ms\");\n\t}\n\t\n\tstatic void initMap() throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = br.readLine();\n\t\tString[] flds = line.split(\" \");\n\t\th = Integer.parseInt(flds[0]);\n\t\tw = Integer.parseInt(flds[1]);\n\t\tmap = new byte[h][w];\n\t\tfor (int y=0; y<h; y++) {\n\t\t\tline = br.readLine();\n\t\t\tfor (int x=0; x<w; x++) {\n\t\t\t\tchar ch = line.charAt(x);\n\t\t\t\tif (ch == 'X') {\n\t\t\t\t\tmap[y][x] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic boolean checkEdge() {\n\t\tfor (int x=0; x<w; x++) {\n\t\t\tif (map[0][x] > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (map[h-1][x] > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\t\t\n\t\tfor (int y=0; y<h; y++) {\n\t\t\tif (map[y][0] > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (map[y][w-1] > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tstatic void fill() {\n\t\tfor (int y=1; y<h-1; y++) {\n\t\t\tfor (int x=1; x<w-1; x++) {\n\t\t\t\tif (map[y][x] == 1) {\n\t\t\t\t\tfill(x-1, y);\n\t\t\t\t\tfill(x+1, y);\n\t\t\t\t\tfill(x, y-1);\n\t\t\t\t\tfill(x, y+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void fill(int x, int y) {\n\t\tif (map[y][x] == 0) {\n\t\t\tmap[y][x] = 2;\n\t\t}\n\t}\n\t\n\tstatic void fillEdge() {\n\t\tfor (int x=0; x<w; x++) {\n\t\t\taddList(x, 0);\n\t\t\taddList(x, h-1);\n\t\t}\t\t\n\t\tfor (int y=0; y<h; y++) {\n\t\t\taddList(0, y);\n\t\t\taddList(w-1, y);\n\t\t}\n\t\twhile (list.size() > 0) {\n\t\t\tPoint pt = list.remove(0);\n\t\t\tif (map[pt.y][pt.x] > 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmap[pt.y][pt.x] = 9;\n\t\t\taddList(pt.x-1, pt.y);\n\t\t\taddList(pt.x+1, pt.y);\n\t\t\taddList(pt.x, pt.y-1);\n\t\t\taddList(pt.x, pt.y+1);\n\t\t}\n\t}\n\t\n\tstatic void addList(int x, int y) {\n\t\tif (x < 0 || x >= w || y < 0 || y >= h) {\n\t\t\treturn;\n\t\t}\n\t\tif (map[y][x] == 0) {\n\t\t\tlist.add(new Point(x, y));\n\t\t}\t\t\n\t}\n\t\n\tstatic void checkInner() {\n\t\tfor (int y=1; y<h-1; y++) {\n\t\t\tfor (int x=1; x<w-1; x++) {\n\t\t\t\tif (map[y][x] != 2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (map[y][x-1] == 9) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (map[y][x+1] == 9) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (map[y-1][x] == 9) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (map[y+1][x] == 9) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmap[y][x] = 3;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic int count() {\n\t\tint cnt = 0;\n\t\tfor (int y=0; y<h; y++) {\n\t\t\tfor (int x=0; x<w; x++) {\n\t\t\t\tif (map[y][x] == 2) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\t\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass E {\n    static final int[] dx = {-1, 1, 0, 0};\n    static final int[] dy = {0, 0, -1, 1};\n\n    public static void main(String... args) {\n        final Scanner sc = new Scanner(System.in);\n        final int H = sc.nextInt();\n        final int W = sc.nextInt();\n        final char[][] map = new char[H][];\n        for (int i = 0; i < map.length; i++)\n            map[i] = sc.next().toCharArray();\n        int minx = W - 1;\n        int maxx = 0;\n        int miny = H - 1;\n        int maxy = 0;\n        for (int x = 0; x < W; x++)\n            for (int y = 0; y < H; y++)\n                if (map[y][x] == 'X') {\n                    minx = Math.min(minx, x);\n                    maxx = Math.max(maxx, x);\n                    miny = Math.min(miny, y);\n                    maxy = Math.max(maxy, y);\n                }\n        if (minx <= 0 || W - 1 <= maxx || miny <= 0 || H - 1 <= maxy) {\n            System.out.println(-1);\n        } else {\n            int ans = 0;\n            for (int x = 1; x < W - 1; x++)\n                for (int y = 1; y < H - 1; y++)\n                    if (map[y][x] == 'X')\n                        map[y - 1][x] = map[y + 1][x] = map[y][x - 1] = map[y][x + 1] = '#';\n            for (int x = 0; x < W; x++) {\n                if (map[0][x] == '.')\n                    dfs(map, x, 0, H, W);\n                if (map[H - 1][x] == '.')\n                    dfs(map, x, H - 1, H, W);\n            }\n            for (int y = 1; y < H - 1; y++) {\n                if (map[y][0] == '.')\n                    dfs(map, 0, y, H, W);\n                if (map[y][W - 1] == '.')\n                    dfs(map, W - 1, y, H, W);\n            }\n            for (int x = 0; x < W; x++)\n                for (int y = 0; y < H; y++)\n                    if (map[y][x] == '#') {\n                        boolean b = false;\n                        for (int d = 0; d < 4; d++)\n                            if (0 <= x + dx[d] && x + dx[d] < W && 0 <= y + dy[d] && y + dy[d] < H)\n                                if (map[y + dy[d]][x + dx[d]] == '@')\n                                    b = true;\n                        if (b)\n                            ans++;\n                    }\n            System.out.println(ans);\n        }\n    }\n\n    static void dfs(char[][] map, int x, int y, int H, int W) {\n        for (int d = 0; d < 4; d++)\n            if (0 <= x + dx[d] && x + dx[d] < W && 0 <= y + dy[d] && y + dy[d] < H)\n                if (map[y + dy[d]][x + dx[d]] == '.') {\n                    map[y + dy[d]][x + dx[d]] = '@';\n                    dfs(map, x + dx[d], y + dy[d], H, W);\n                }\n    }\n}\npublic class Main {\n    public static void main(String... args) {\n        E.main();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringJoiner;\nimport java.util.StringTokenizer;\nimport java.util.function.Function;\n\npublic class Main {\n\n    static int H, W;\n    static char[][] C;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        H = sc.nextInt();\n        W = sc.nextInt();\n        C = new char[H][];\n        for (int i = 0; i < H; i++) {\n            C[i] = sc.next().toCharArray();\n        }\n\n        System.out.println(solve());\n    }\n\n    static int solve() {\n        // とりあえず柵を作る\n        for (int h = 0; h < H; h++) {\n            for (int w = 0; w < W; w++) {\n                if( C[h][w] == 'X' ) {\n                    if( h == 0 || h == H-1 || w == 0 || w == W-1) {\n                        return -1;\n                    }\n\n                    for (int i = 0; i < 4; i++) {\n                        int nh = DH[i] + h;\n                        int nw = DW[i] + w;\n\n                        if( C[nh][nw] == '.' ) {\n                            C[nh][nw] = '#';\n                        }\n                    }\n                }\n            }\n        }\n\n        // 外を塗りつぶす\n        for (int h = 0; h < H; h++) {\n            for (int w = 0; w < W; w++) {\n                if( C[h][w] == '.' ) {\n                    bfs(h, w);\n                }\n            }\n        }\n\n        // 外に隣接してない柵は消す\n        for (int h = 0; h < H; h++) {\n            lo:\n            for (int w = 0; w < W; w++) {\n                if( C[h][w] != '#' ) continue;\n\n                for (int i = 0; i < 4; i++) {\n                    int nh = DH[i] + h;\n                    int nw = DW[i] + w;\n\n                    if( inRange(nh, nw) && C[nh][nw] == '0' ) {\n                        continue lo;\n                    }\n                }\n                C[h][w] = '.';\n            }\n        }\n\n\n//        for (int i = 0; i < H; i++) {\n//            debug(new String(C[i]) );\n//        }\n\n        int ans = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if( C[i][j] == '#' ) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n\n    static void bfs(int sh, int sw) {\n        int[] q = new int[H*W];\n        int u = 0, v = 0;\n        q[v++] = sh * W + sw;\n        C[sh][sw] = '0';\n        while( u != v ) {\n            int hw = q[u++];\n            int h = hw / W;\n            int w = hw % W;\n\n            for (int i = 0; i < 4; i++) {\n                int nh = h + DH[i];\n                int nw = w + DW[i];\n                if( inRange(nh, nw) && C[nh][nw] == '.' ) {\n                    q[v++] = nh*W + nw;\n                    C[nh][nw] = '0';\n                }\n            }\n        }\n    }\n\n    static boolean inRange(int h, int w) {\n        return 0 <= h && h < H && 0 <= w && w < W;\n    }\n\n    static int[] DH = {0, 1, 0, -1};\n    static int[] DW = {1, 0, -1, 0};\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    void solve() throws IOException {\n        int h = ni();\n        int w = ni();\n        String[] s = nsa(h);\n\n        int INF = Integer.MAX_VALUE;\n\n        for (int i = 0; i < h; i++) {\n            if (s[i].charAt(0) == 'X' || s[i].charAt(w - 1) == 'X') {\n                out.println(-1);\n                return;\n            }\n        }\n        for (int i = 0; i < w; i++) {\n            if (s[0].charAt(i) == 'X' || s[h - 1].charAt(i) == 'X') {\n                out.println(-1);\n                return;\n            }\n        }\n\n        MaxFlowFordFulkerson m = new MaxFlowFordFulkerson(2 * h * w + 2);\n        int source = 2 * h * w;\n        int sink = 2 * h * w + 1;\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (i > 0) m.addEdge(2 * (i * w + j) + 1, 2 * ((i - 1) * w + j), INF);\n                if (i < h - 1) m.addEdge(2 * (i * w + j) + 1, 2 * ((i + 1) * w + j), INF);\n                if (j > 0) m.addEdge(2 * (i * w + j) + 1, 2 * (i * w + j - 1), INF);\n                if (j < w - 1) m.addEdge(2 * (i * w + j) + 1, 2 * (i * w + j + 1), INF);\n                if (i == 0 || i == h - 1 || j == 0 || j == w - 1) {\n                    m.addEdge(2 * (i * w + j) + 1, sink, INF);\n                }\n                if (s[i].charAt(j) == 'X') {\n                    m.addEdge(source, 2 * (i * w + j) + 1, INF);\n                    m.addEdge(2 * (i * w + j), 2 * (i * w + j) + 1, INF);\n                } else {\n                    m.addEdge(2 * (i * w + j), 2 * (i * w + j) + 1, 1);\n                }\n            }\n        }\n\n        out.println(m.maxFlow(source, sink));\n    }\n\n    class MaxFlowFordFulkerson {\n        ArrayList<ArrayList<Edge>> G;\n        boolean[] used;\n        int INF = Integer.MAX_VALUE;\n\n        public MaxFlowFordFulkerson(int n) {\n            G = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                G.add(new ArrayList<Edge>());\n            }\n            used = new boolean[n];\n        }\n\n        void addEdge(int from, int to, int cap) {\n            G.get(from).add(new Edge(to, cap, G.get(to).size()));\n            G.get(to).add(new Edge(from, 0, G.get(from).size() - 1));\n        }\n\n        private int dfs(int v, int t, int f) {\n            if (v == t) return f;\n            used[v] = true;\n            for (Edge e : G.get(v)) {\n                if (!used[e.to] && e.cap > 0) {\n                    int d = dfs(e.to, t, Math.min(f, e.cap));\n                    if (d > 0) {\n                        e.cap -= d;\n                        G.get(e.to).get(e.rev).cap += d;\n                        return d;\n                    }\n                }\n            }\n\n            return 0;\n        }\n\n        int maxFlow(int s, int t) {\n            int flow = 0;\n            while (true) {\n                Arrays.fill(used, false);\n                int f = dfs(s, t, INF);\n                if (f == 0) return flow;\n                flow += f;\n            }\n        }\n\n        class Edge {\n            int to, cap, rev;\n\n            public Edge(int to, int cap, int rev) {\n                this.to = to;\n                this.cap = cap;\n                this.rev = rev;\n            }\n        }\n    }\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.TreeSet;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/B3\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tint[] vx = {1, 0, -1, 0};\n\tint[] vy = {0, -1, 0, 1};\n\n\tchar[][] fence;\n\tboolean[][] visited;\n\t\n\tboolean inside(int x, int y, int M, int N) {\n\t\treturn x >= 0 && y >= 0 && x < M && y < N;\n\t}\n\t\n\tboolean dfs(int x, int y) {\n\t\tint n = fence.length, m = fence[0].length;\n\t\tif (x == 0 || y == 0 || x == m - 1 || y == n - 1) return true;\n\t\tvisited[y][x] = true;\n\t\t\n\t\tboolean res = false;\n\t\tfor (int d = 0; d < vx.length; d++) {\n\t\t\tint nx = x + vx[d], ny = y + vy[d];\n\t\t\tif (inside(nx, ny, m, n) && fence[ny][nx] == '.' && !visited[ny][nx]) {\n\t\t\t\tres |= dfs(nx, ny);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tint count(char[][] fence) {\n\t\tint res = 0;\n\t\tfor (int i = 0; i < fence.length; i++) {\n\t\t\tfor (int j = 0; j < fence[i].length; j++) {\n\t\t\t\tif (fence[i][j] == '#') res++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic void solve() {\n\t\tint n = in.nextInt(), m = in.nextInt();\n\t\tString[] map = in.nextStringArray(n);\n\t\t\n\t\tfence = new char[n][m];\n\t\tfor (int i = 0; i < n; i++) Arrays.fill(fence[i], '.');\t\t\t\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (map[i].charAt(j) != 'X') continue;\n\t\t\t\tif (i == n - 1 || j == m - 1) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int d = 0; d < vx.length; d++) {\n\t\t\t\t\tint nx = j + vx[d], ny = i + vy[d];\n\t\t\t\t\tif (inside(nx, ny, m, n) && map[ny].charAt(nx) != 'X') {\n\t\t\t\t\t\tfence[ny][nx] = '#';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\t// remove surrounded fence\n\t\tvisited = new boolean[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (fence[i][j] != '#') continue;\n\t\t\t\t\n\t\t\t\tfence[i][j] = '.';\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tArrays.fill(visited[k], false);\n\t\t\t\t}\n\t\t\t\tif (!dfs(j, i)) {\n\t\t\t\t\t// remove this fence\n\t\t\t\t} else {\n\t\t\t\t\t// restore a fence.\n\t\t\t\t\tfence[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t\tSystem.out.println(count(fence));\t\t\n\t}\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tThread t = new Thread(null, new Runnable() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}, \"lul\", 1 << 30);\n\t\tt.start();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport java.util.*;\n\nimport java.io.*;\n\npublic class Main {\n\tint[] di = {0, 1, 0, -1};\n\tint[] dj = {1, 0, -1, 0};\n\tchar[][] t;\n\tvoid solve() {\n\t\tint H = sc.nextInt();\n\t\tint W = sc.nextInt();\n\t\tt = new char[H][W];\n\t\tfor (int i = 0; i < H; i++) t[i] = sc.next().toCharArray();\n\t\tfor (int i = 0; i < H; i++) for (int j = 0; j < W; j++) {\n\t\t\tif (t[i][j] == 'X') {\n\t\t\t\tif (i == 0 || i == H-1 || j == 0 || j == W-1) {\n\t\t\t\t\tout.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tV src = new V();\n\t\tV sink = new V();\n\t\t\n\t\tV[][] v1 = new V[H][W];\n\t\tV[][] v2 = new V[H][W];\n\t\tfor (int i = 0; i < H; i++) for (int j = 0; j < W; j++) {\n\t\t\tv1[i][j] = new V();\n\t\t\tv2[i][j] = new V();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < H; i++) for (int j = 0; j < W; j++) {\n\t\t\tif (t[i][j] == 'X') {\n\t\t\t\tsrc.add(v1[i][j], INF);\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint ni = i + di[k];\n\t\t\t\t\tint nj = j + dj[k];\n\t\t\t\t\tif (0 <= ni && ni < H && 0 <= nj && nj < W && t[ni][nj] == '.') {\n\t\t\t\t\t\tv1[i][j].add(v1[ni][nj], INF);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tv1[i][j].add(v2[i][j], 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < H; i++) for (int j = 0; j < W; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tint ni = i + di[k];\n\t\t\t\tint nj = j + dj[k];\n\t\t\t\tif (0 <= ni && ni < H && 0 <= nj && nj < W && t[ni][nj] == '.') {\n\t\t\t\t\tv2[i][j].add(v1[ni][nj], INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == 0 || i == H-1 || j == 0 || j == W-1) {\n\t\t\t\tv2[i][j].add(sink, INF);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint flow = dinic(src, sink);\n\t\tint ans = flow;\n\t\tout.println(ans);\n\t}\n\n\tstatic final int INF = 1001001001;\n\t\n\tint dinic(V s, V t) {\n\t\tint flow = 0;\n\t\tfor (int p = 1;; p++) {\n\t\t\tQueue<V> que = new LinkedList<V>();\n\t\t\ts.level = 0;\n\t\t\ts.p = p;\n\t\t\tque.offer(s);\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tV v = que.poll();\n\t\t\t\tv.iter = v.es.size() - 1;\n\t\t\t\tfor (E e : v.es)\n\t\t\t\t\tif (e.to.p < p && e.cap > 0) {\n\t\t\t\t\t\te.to.level = v.level + 1;\n\t\t\t\t\t\te.to.p = p;\n\t\t\t\t\t\tque.offer(e.to);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tif (t.p < p) return flow;\n\t\t\tfor (int f; (f = dfs(s, t, INF)) > 0;) flow += f;\n\t\t}\n\t}\n\n\tint dfs(V v, V t, int f) {\n\t\tif (v == t) return f;\n\t\tfor (; v.iter >= 0; v.iter--) {\n\t\t\tE e = v.es.get(v.iter);\n\t\t\tif (v.level < e.to.level && e.cap > 0) {\n\t\t\t\tint d = dfs(e.to, t, Math.min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\te.rev.cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tclass V {\n\t\tArrayList<E> es = new ArrayList<E>();\n\t\tint level, p, iter;\n\t\t\n\t\tvoid add(V to, int cap) {\n\t\t\tE e = new E(to, cap);\n\t\t\tE rev = new E(this, 0);\n\t\t\te.rev = rev;\n\t\t\trev.rev = e;\n\t\t\tes.add(e);\n\t\t\tto.es.add(rev);\n\t\t}\n\t}\n\n\tclass E {\n\t\tV to;\n\t\tE rev;\n\t\tint cap;\n\n\t\tE(V to, int cap) {\n\t\t\tthis.to = to;\n\t\t\tthis.cap = cap;\n\t\t}\n\t}\n\t\n\tstatic void tr(Object... os) { System.err.println(deepToString(os)); }\n\tstatic void tr(int[][] as) { for (int[] a : as) tr(a); }\n\tstatic void tr(boolean[][] as) { for (boolean[] a : as) {\n\t\tfor (boolean b : a) {\n\t\t\tSystem.err.print(b ? 1 : 0);\n\t\t}\n\t\tSystem.err.println();\n\t\t}\n\t}\n\n\tvoid print(int[] a) {\n\t\tif (a.length > 0) out.print(a[0]);\n\t\tfor (int i = 1; i < a.length; i++) out.print(\" \" + a[i]);\n\t\tout.println();\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tMyScanner sc = null;\n\tPrintWriter out = null;\n\tpublic void run() throws Exception {\n\t\tsc = new MyScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tfor (;sc.hasNext();) {\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t\tout.close();\n\t}\n\n\tclass MyScanner {\n\t\tString line;\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\n\t\tpublic MyScanner(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic void eat() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\ttokenizer = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String next() {\n\t\t\teat();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tpublic boolean hasNext() {\n\t\t\teat();\n\t\t\treturn (tokenizer != null && tokenizer.hasMoreElements());\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport java.util.*;\n\nimport java.io.*;\n\npublic class Main {\n\tint[] di = {0, 1, 0, -1};\n\tint[] dj = {1, 0, -1, 0};\n\tchar[][] t;\n\tvoid solve() {\n\t\tint H = sc.nextInt();\n\t\tint W = sc.nextInt();\n\t\tt = new char[H+2][W+2];\n\n\t\tfor (int i = 0; i < H+2; i++) Arrays.fill(t[i], '.');\n\t\t\n\t\tfor (int i = 1; i <= H; i++) t[i] = (\".\" + sc.next() + \".\").toCharArray();\n\t\tfor (int i = 1; i <= H; i++) for (int j = 1; j <= W; j++) {\n\t\t\tif (t[i][j] == 'X') {\n\t\t\t\tif (i == 1 || i == H || j == 1 || j == W) {\n\t\t\t\t\tout.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tint ni = i + di[k];\n\t\t\t\t\t\tint nj = j + dj[k];\n\t\t\t\t\t\tif (t[ni][nj] == '.') t[ni][nj] = '#';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H+2; i++) tr(new String(t[i]));\n\t\t\n\t\tmark = new boolean[H+2][W+2];\n\t\tbfs(0, 0);\n//\t\ttr(mark);\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < H+2; i++) for (int j = 0; j < W+2; j++) {\n\t\t\tif (mark[i][j] && t[i][j] == '#') ans++;\n\t\t}\n\t\t\n//\t\ttr((H-2)*2 + (W-2)*2);\n\t\tans = min(ans, (H-2)*2 + (W-2)*2);\n\t\tout.println(ans);\n\t}\n\t\n\tint[] q = new int[128 * 128 * 2];\n\tboolean[][] mark;\n\tvoid bfs(int r, int c) {\n\t\tint sp = 0;\n\t\tmark[r][c] = true;\n\t\tq[sp++] = r;\n\t\tq[sp++] = c;\n\t\t\n\t\twhile (sp > 0) {\n\t\t\tc = q[--sp];\n\t\t\tr = q[--sp];\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tint nr = r + di[k];\n\t\t\t\tint nc = c + dj[k];\n\t\t\t\tif (0 <= nr && nr < mark.length && 0 <= nc && nc < mark[0].length) {\n\t\t\t\t\tif (!mark[nr][nc]) {\n\t\t\t\t\t\tmark[nr][nc] = true;\n\t\t\t\t\t\t if (t[nr][nc] == '.') {\n\t\t\t\t\t\t\tq[sp++] = nr;\n\t\t\t\t\t\t\tq[sp++] = nc;\n\t\t\t\t\t\t }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void tr(Object... os) { System.err.println(deepToString(os)); }\n\tstatic void tr(int[][] as) { for (int[] a : as) tr(a); }\n\tstatic void tr(boolean[][] as) { for (boolean[] a : as) {\n\t\tfor (boolean b : a) {\n\t\t\tSystem.err.print(b ? 1 : 0);\n\t\t}\n\t\tSystem.err.println();\n\t\t}\n\t}\n\n\tvoid print(int[] a) {\n\t\tif (a.length > 0) out.print(a[0]);\n\t\tfor (int i = 1; i < a.length; i++) out.print(\" \" + a[i]);\n\t\tout.println();\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tMyScanner sc = null;\n\tPrintWriter out = null;\n\tpublic void run() throws Exception {\n\t\tsc = new MyScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tfor (;sc.hasNext();) {\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t\tout.close();\n\t}\n\n\tclass MyScanner {\n\t\tString line;\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\n\t\tpublic MyScanner(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic void eat() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\ttokenizer = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String next() {\n\t\t\teat();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tpublic boolean hasNext() {\n\t\t\teat();\n\t\t\treturn (tokenizer != null && tokenizer.hasMoreElements());\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;public static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){StringBuilder s=new StringBuilder();for(int i=0;i<a.length;i++)\n\ts.append(a[i]).append(\" \");out.println(s.toString().trim());}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){StringBuilder s=new StringBuilder();for(int i=0;i<a.length;i++)\n\ts.append(a[i]).append(\" \");out.println(s.toString().trim());}\n\tstatic void dump(char[]a){for(int i=0;i<a.length;i++)out.print(a[i]);out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[] a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[] a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\t@SuppressWarnings(\"unchecked\")\n\tstatic List<Integer>[]createGraph(int n)\n    {List<Integer>[]g=new List[n];for(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\tvoid solve() throws IOException{\n\t\tint h = in.nextInt();\n\t\tint w = in.nextInt();\n\t\tchar[][] map = new char[h][];\n\t\tfinal int s = h*w*2;\n\t\tfinal int t = h*w*2+1;\n\t\tMaxFlow mf = new MaxFlow(h*w*2+2, s, t);\n\t\tfinal int inf = 1000;\n\t\tfor(int i=0; i<h; i++){\n\t\t\tmap[i] = in.nextToken().toCharArray();\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tif(map[i][j]=='X'){\n\t\t\t\t\tmf.edge(s, (i*w+j)*2, inf);\n\t\t\t\t\tmf.edge((i*w+j)*2, (i*w+j)*2+1, inf);\n\t\t\t\t}\n\t\t\t\telse mf.edge((i*w+j)*2, (i*w+j)*2+1, 1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<h; i++){\n\t\t\tif(map[i][0]=='X' || map[i][w-1]=='X'){\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmf.edge(i*w*2+1, t, 1);\n\t\t\tmf.edge((i*w+w-1)*2+1, t, 1);\n\t\t}\n\t\tfor(int i=0; i<w; i++){\n\t\t\tif(map[0][i]=='X' || map[h-1][i]=='X'){\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmf.edge(i*2+1, t, 1);\n\t\t\tmf.edge(((h-1)*w+i)*2+1, t, 1);\n\t\t}\n\t\tfinal int[] dx = {1, 0, -1, 0};\n\t\tfinal int[] dy = {0, 1, 0, -1};\n\t\tfor(int i=1; i<h-1; i++){\n\t\t\tfor(int j=1; j<w-1; j++){\n\t\t\t\tfor(int d=0; d<4; d++){\n\t\t\t\t\tfinal int ny = i+dy[d];\n\t\t\t\t\tfinal int nx = j+dx[d];\n\t\t\t\t\tmf.edge((i*w+j)*2+1, (ny*w+nx)*2, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(mf.solve());\n\t}\n}\n\nclass MaxFlow{\n\tint n, s, t;\n\tList<Edge>[] node;\n\tMaxFlow(int n, int s, int t) {\n\t\tthis.n=n;this.s=s;this.t=t;node=new List[n];\n\t\tfor(int i=0;i<n;i++)node[i]=new ArrayList<>();\n\t\tused = new BitSet(n);\n\t}\n\tvoid edge(int a, int b, int c){\n\t\tEdge ae = new Edge(b, c);\n\t\tEdge be = new Edge(a, 0);\n\t\tae.rev = be;\n\t\tbe.rev = ae;\n\t\tnode[a].add(ae);\n\t\tnode[b].add(be);\n\t}\n\tvoid edge(int a, int b, int c, int rc){\n\t\tEdge ae = new Edge(b, c);\n\t\tEdge be = new Edge(a, rc);\n\t\tae.rev = be;\n\t\tbe.rev = ae;\n\t\tnode[a].add(ae);\n\t\tnode[b].add(be);\n\t}\n\tfinal static int inf = Integer.MAX_VALUE/2;\n\tint solve(){\n\t\tint res = 0;\n\t\twhile(true){\n\t\t\tused.clear();\n\t\t\tint flow = flow(s, inf);\n\t\t\tif(flow == 0) break;\n\t\t\tres += flow;\n\t\t}\n\t\treturn res;\n\t}\n\tBitSet used;\n\tint flow(int from, int flow){\n\t\tif(from == t) return flow;\n\t\tif(used.get(from)) return 0;\n\t\tused.set(from);\n\t\tfor(Edge e: node[from]){\n\t\t\tfinal int cap = e.cap;\n\t\t\tif(cap==0) continue;\n\t\t\tint f = flow(e.to, Math.min(flow, cap));\n\t\t\tif(f == 0) continue;\n\t\t\te.cap -= f;\n\t\t\te.rev.cap += f;\n\t\t\treturn f;\n\t\t}\n\t\treturn 0;\n\t}\n\tclass Edge{\n\t\tint to,cap;\n\t\tEdge rev;\n\t\tEdge(int t, int c){to=t;cap=c;}\n\t}\n}\n\n@SuppressWarnings(\"serial\")\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\n@SuppressWarnings(\"serial\")\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport java.util.*;\n\nimport java.io.*;\n\npublic class Main {\n\tint[] di = {0, 1, 0, -1};\n\tint[] dj = {1, 0, -1, 0};\n\tchar[][] t;\n\tvoid solve() {\n\t\tint H = sc.nextInt();\n\t\tint W = sc.nextInt();\n\t\tt = new char[H+2][W+2];\n\n\t\tfor (int i = 0; i < H+2; i++) Arrays.fill(t[i], '.');\n\t\t\n\t\tfor (int i = 1; i <= H; i++) t[i] = (\".\" + sc.next() + \".\").toCharArray();\n\t\tfor (int i = 1; i <= H; i++) for (int j = 1; j <= W; j++) {\n\t\t\tif (t[i][j] == 'X') {\n\t\t\t\tif (i == 1 || i == H || j == 1 || j == W) {\n\t\t\t\t\tout.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tint ni = i + di[k];\n\t\t\t\t\t\tint nj = j + dj[k];\n\t\t\t\t\t\tif (t[ni][nj] == '.') t[ni][nj] = '#';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tfor (int i = 0; i < H+2; i++) tr(new String(t[i]));\n\t\t\n\t\t\n\t\tmark = new boolean[H+2][W+2];\n\t\tbfs(0, 0);\n//\t\ttr(mark);\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < H+2; i++) for (int j = 0; j < W+2; j++) {\n\t\t\tif (mark[i][j] && t[i][j] == '#') ans++;\n\t\t}\n\t\tout.println(ans);\n\t}\n\t\n\tint[] q = new int[128 * 128 * 2];\n\tboolean[][] mark;\n\tvoid bfs(int r, int c) {\n\t\tif (mark[r][c]) return;\n\t\t\n\t\tint sp = 0;\n\t\tmark[r][c] = true;\n\t\tq[sp++] = r;\n\t\tq[sp++] = c;\n\t\t\n\t\twhile (sp > 0) {\n\t\t\tc = q[--sp];\n\t\t\tr = q[--sp];\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tint nr = r + di[k];\n\t\t\t\tint nc = c + dj[k];\n\t\t\t\tif (0 <= nr && nr < mark.length && 0 <= nc && nc < mark[0].length) {\n\t\t\t\t\tif (!mark[nr][nc]) {\n\t\t\t\t\t\tmark[nr][nc] = true;\n\t\t\t\t\t\t if (t[nr][nc] == '.') {\n\t\t\t\t\t\t\tq[sp++] = nr;\n\t\t\t\t\t\t\tq[sp++] = nc;\n\t\t\t\t\t\t }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void tr(Object... os) { System.err.println(deepToString(os)); }\n\tstatic void tr(int[][] as) { for (int[] a : as) tr(a); }\n\tstatic void tr(boolean[][] as) { for (boolean[] a : as) {\n\t\tfor (boolean b : a) {\n\t\t\tSystem.err.print(b ? 1 : 0);\n\t\t}\n\t\tSystem.err.println();\n\t\t}\n\t}\n\n\tvoid print(int[] a) {\n\t\tif (a.length > 0) out.print(a[0]);\n\t\tfor (int i = 1; i < a.length; i++) out.print(\" \" + a[i]);\n\t\tout.println();\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tMyScanner sc = null;\n\tPrintWriter out = null;\n\tpublic void run() throws Exception {\n\t\tsc = new MyScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tfor (;sc.hasNext();) {\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t\tout.close();\n\t}\n\n\tclass MyScanner {\n\t\tString line;\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\n\t\tpublic MyScanner(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic void eat() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\ttokenizer = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String next() {\n\t\t\teat();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tpublic boolean hasNext() {\n\t\t\teat();\n\t\t\treturn (tokenizer != null && tokenizer.hasMoreElements());\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\tSol mySol =new Sol();\n\t\tmySol.Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tfor(int i=0;i<H;i++){\n\t\t\tif(S[i][0] == 'X' || S[i][W-1] == 'X' ){\n\t\t\t\tConsole.WriteLine(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<W;j++){\n\t\t\tif(S[0][j] == 'X' || S[H-1][j] == 'X' ){\n\t\t\t\tConsole.WriteLine(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar f = new MaxFlow_Dinic();\n\t\tint nnode = H*W*2;\n\t\tf.Init(nnode + 2);\n\t\tint s = H*W*2;\n\t\tint t = s + 1;\n\t\tFunc<int,int,int,int> enc = (r,c,d) => {\n\t\t\treturn d + 2*c + 2*W*r;\n\t\t};\n\t\t\n\t\tFunc<int,int,bool> InRange = (r,c) => {\n\t\t\treturn 0 <= r && r < H && 0 <= c && c < W;\n\t\t};\n\t\t\n\t\tint[] dx = new int[] {1,0,-1,0};\n\t\tint[] dy = new int[] {0,-1,0,1};\n\t\t\n\t\tvar Inf = (int)1e9;\n\t\t\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tif(S[i][j] == 'X'){\n\t\t\t\t\tf.AddEdge(enc(i,j,0), enc(i,j,1), Inf);\n\t\t\t\t\tf.AddEdge(s, enc(i,j,0), Inf);\n\t\t\t\t}else{\n\t\t\t\t\tf.AddEdge(enc(i,j,0), enc(i,j,1), 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int tt=0;tt<4;tt++){\n\t\t\t\t\tint ny = i + dy[tt];\n\t\t\t\t\tint nx = j + dx[tt];\n\t\t\t\t\tif(!InRange(ny,nx))continue;\n\t\t\t\t\tf.AddEdge(enc(i,j,1), enc(ny,nx,0), Inf);\n\t\t\t\t}\n\t\t\t\tif(i == 0 || i == H-1 || j == 0 || j == W-1){\n\t\t\t\t\tf.AddEdge(enc(i,j,1), t, Inf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tConsole.WriteLine(f.MaxFlow(s,t));\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\tint H,W;\n\tString[] S;\n\tpublic Sol(){\n\t\tvar d = ria();\n\t\tH = d[0]; W = d[1];\n\t\tS = new String[H];\n\t\tfor(int i=0;i<H;i++){\n\t\t\tS[i] = rs();\n\t\t}\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(char sep=' '){return Console.ReadLine().Split(sep);}\n\tstatic int[] ria(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>int.Parse(e));}\n\tstatic long[] rla(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>long.Parse(e));}\n\tstatic double[] rda(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>double.Parse(e));}\n}\n\n\nclass MaxFlow_Dinic{\n\t// arihon is god\n\tclass Edge {\n\t\tpublic int To,Cap,Rev;\n\t\tpublic Edge(int to = 0,int cap = 0,int rev = 0){\n\t\t\tTo = to;\n\t\t\tCap = cap;\n\t\t\tRev = rev;\n\t\t}\n\t}\n\t\n\tList<Edge>[] G;\n\tint[] Level;\n\tint[] Iter;\n\t\n\tstatic int Inf = (int) 1e9;\n\tpublic int N;\n\tpublic void Init(int n){\n\t\tN = n;\n\t\tG = new List<Edge>[N];\n\t\tfor(int i=0;i<N;i++) G[i] = new List<Edge>();\n\t\tLevel = new int[N];\n\t\tIter = new int[N];\n\t}\n\t\n\t\n\tpublic void AddEdge(int from, int to, int cap){\n\t\tG[from].Add(new Edge(to,cap,G[to].Count));\n\t\tG[to].Add(new Edge(from,0,G[from].Count-1));\n\t}\n\t\n\tvoid bfs(int s){\n\t\tfor(int j=0;j<G.Length;j++)Level[j] = -1;\n\t\tvar Q = new Queue<int>();\n\t\tLevel[s] = 0;\n\t\tQ.Enqueue(s);\n\t\t\n\t\twhile(Q.Count>0){\n\t\t\tvar v = Q.Dequeue();\n\t\t\tforeach(var e in G[v]){\n\t\t\t\tif(e.Cap > 0 && Level[e.To] < 0){\n\t\t\t\t\tLevel[e.To] = Level[v] + 1;\n\t\t\t\t\tQ.Enqueue(e.To);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint dfs(int v, int t, int f){\n\t\tif(v == t) return f;\n\t\tfor(;Iter[v] < G[v].Count; Iter[v]++){\n\t\t\tvar e = G[v][Iter[v]];\n\t\t\tif(e.Cap > 0 && Level[v] < Level[e.To]){\n\t\t\t\tint d = dfs(e.To, t, Math.Min(f,e.Cap));\n\t\t\t\tif(d > 0){\n\t\t\t\t\te.Cap -= d;\n\t\t\t\t\tG[e.To][e.Rev].Cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tpublic int MaxFlow(int s, int t){\n\t\tint flow = 0;\n\t\twhile(true){\n\t\t\tbfs(s);\n\t\t\tif(Level[t] < 0) return flow;\n\t\t\tIter = new int[N];\n\t\t\tint f;\n\t\t\twhile( ( f = dfs(s,t,Inf)) > 0){\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Globalization;\nusing System.Diagnostics;\nusing static System.Console;\n//using System.Numerics;\n//using static System.Math;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n\n    int H, W;\n    void solve()\n    {\n        H = cin.nextint;\n        W = cin.nextint;\n        var S = new char[H][];\n        for (int i = 0; i < H; i++)\n        {\n            S[i] = cin.next.ToCharArray();\n        }\n        int T = 2 * H * W + 1;\n        var D = new Ford_Fulkerson(T + 1);\n\n        \n        for (int i = 0; i < H; i++)\n        {\n            for (int j = 0; j < W; j++)\n            {\n                if (i == 0 || i == H - 1 || j == 0 || j == W - 1)\n                {\n                    if (S[i][j] == 'X')\n                    {\n                        WriteLine(-1);\n                        return;\n                    }\n                    D.add_edge(0, IN(i, j), Ford_Fulkerson.INF);\n                }\n                if (S[i][j] == 'X')\n                {\n                    D.add_edge(IN(i, j), OUT(i, j), Ford_Fulkerson.INF);\n                    D.add_edge(OUT(i, j), T, Ford_Fulkerson.INF);\n                }\n                else\n                {\n                    D.add_edge(IN(i, j), OUT(i, j), 1);\n                    for (int r = 0; r < 4; r++)\n                    {\n                        int y = i + dd[r];\n                        int x = j + dd[r + 1];\n                        if (y < 0 || y >= H || x < 0 || x >= W) continue;\n\n                        D.add_edge(OUT(i, j), IN(y, x), Ford_Fulkerson.INF);\n                    }\n                }\n            }\n        }\n\n        WriteLine(D.max_flow(0, T));\n    }\n    int IN(int y, int x)\n    {\n        return y * W + x + 1;\n    }\n    int OUT(int y, int x)\n    {\n        return y * W + x + 1 + H * W;\n    }\n\n\n}\n\nclass Ford_Fulkerson\n{\n    // 辺を表すクラス（行き先、容量、逆辺）\n    class Edge_\n    {\n        public int to;\n        public long cap;\n        public int rev;\n        public Edge_(int to, long cap, int rev)\n        {\n            this.to = to;\n            this.cap = cap;\n            this.rev = rev;\n        }\n    }\n    public const long INF = long.MaxValue / 3;\n    List<Edge_>[] G; // グラフの隣接リスト表現\n    bool[] used;     // DFSですでに調べたかのフラグ\n    public Ford_Fulkerson(int V)\n    {\n        G = new List<Edge_>[V];\n        for (int i = 0; i < V; i++) G[i] = new List<Edge_>();\n        used = new bool[V];\n    }\n    // fromからtoまでの最短距離をBFSで計算する\n    public void add_edge(int from, int to, long cap)\n    {\n        G[from].Add(new Edge_(to, cap, G[to].Count));\n        G[to].Add(new Edge_(from, 0, G[from].Count - 1));\n    }\n    //増加パスをDFSで探す\n    long dfs(int v, int t, long f)\n    {\n        if (v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].Count; i++)\n        {\n            Edge_ e = G[v][i];\n            if (!used[e.to] && e.cap > 0)\n            {\n                long d = dfs(e.to, t, Math.Min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    // sからtへの最大流を求める\n    public long max_flow(int s, int t)\n    {\n        long flow = 0;\n        while (true)\n        {\n            for (int i = 0; i < used.Length; i++) used[i] = false;\n            long f = dfs(s, t, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan { get { return ReadLine().Split(); } }\n    public int[] scanint { get { return Array.ConvertAll(scan, int.Parse); } }\n    public long[] scanlong { get { return Array.ConvertAll(scan, long.Parse); } }\n    public double[] scandouble { get { return Array.ConvertAll(scan, double.Parse); } }\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint { get { return int.Parse(next); } }\n    public long nextlong { get { return long.Parse(next); } }\n    public double nextdouble { get { return double.Parse(next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tvar s=sc.Ia;\n\t\tint g=s[0]*s[1]*2+2;\n\t\tvar fl=new Flow(g);\n\t\tint inf=100000;\n\t\tfor(int i = 0;i<s[0];i++) {\n\t\t\tvar e=sc.S;\n\t\t\tfor(int j = 0;j<s[1];j++) {\n\t\t\t\tint v=((i*s[1]+j)<<1)+1;\n\t\t\t\tif(e[j]=='.'){\n\t\t\t\t\tfl.Edge1(v,v+1,1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfl.Edge1(v,v+1,inf);\n\t\t\t\t\tfl.Edge1(v+1,g,inf);\n\t\t\t\t}\n\t\t\t\tif(i!=s[0]-1){\n\t\t\t\t\tfl.Edge1(v+1,v+(s[1]<<1),inf);\n\t\t\t\t\tfl.Edge1(v+(s[1]<<1)+1,v,inf);\n\t\t\t\t}\n\t\t\t\tif(j!=s[1]-1){\n\t\t\t\t\tfl.Edge1(v+1,v+2,inf);\n\t\t\t\t\tfl.Edge1(v+3,v,inf);\n\t\t\t\t}\n\t\t\t\tif(i==0||j==0||i==s[0]-1||j==s[1]-1){\n\t\t\t\t\tfl.Edge1(g-1,v,inf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=fl.Ff(g-1,g);\n\t\tConsole.WriteLine(\"{0}\",ans<inf?ans:-1);\n\t}\n}\npublic class Flow{\n\tpublic List<int>[] li;\n\tprivate bool[] b;\n\tprivate int[] r;\n\tprivate Dictionary<int,int>[] h;\n\tprivate int n,ans,gl;\n\tprivate bool bo=false;\n\tpublic Flow(int n){\n\t\tthis.n=n;\n\t\tli=new List<int>[n+1];\n\t\tr=new int[n+1];\n\t\th=new Dictionary<int,int>[n+1];\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tli[i]=new List<int>();\n\t\t\th[i]=new Dictionary<int,int>();\n\t\t}\n\t}\n\tpublic void Edge1(int a,int b,int c){\n\t\tli[a].Add(b);\n\t\tli[b].Add(a);\n\t\th[a].Add(b,c);\n\t\th[b].Add(a,0);\n\t}\n\tpublic int Ff(int st,int gl){\n\t\tthis.gl=gl;\n\t\tans=0;\n\t\twhile(!bo){\n\t\t\tb=new bool[n+1];\n\t\t\tbo=true;\n\t\t\tFu(st,0,int.MaxValue);\n\t\t}\n\t\treturn ans;\n\t}\n\tprivate void Fu(int a,int g,int p){\n\t\tb[a]=true;\n\t\tr[g]=a;\n\t\tif(a==gl){\n\t\t\tfor(int i=0;i<g;i++){\n\t\t\t\th[r[i]][r[i+1]]-=p;\n\t\t\t\th[r[i+1]][r[i]]+=p;\n\t\t\t}\n\t\t\tans+=p;\n\t\t\tbo=false;\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0;i<li[a].Count&&bo;i++){\n\t\t\tif(!b[li[a][i]]&&h[a][li[a][i]]!=0){Fu(li[a][i],g+1,Min(p,h[a][li[a][i]]));}\n\t\t}\n\t}\n}\n\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace e\n{\n    class Program\n    {\n        static int h, w;\n        static void Main(string[] args)\n        {\n            int[] vy = { 1, 0, -1, 0 };\n            int[] vx = { 0, 1, 0, -1 };\n\n            int ans = 0;\n\n            int[] hw = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            h = hw[0];\n            w = hw[1];\n            string[] map = new string[h];\n            for (int i = 0; i < h; i++)\n            {\n                map[i] = Console.ReadLine();\n            }\n\n            bool[,] saku = new bool[h, w];\n            Queue<int> qx = new Queue<int>();\n            Queue<int> qy = new Queue<int>();\n\n            for (int y = 0; y < h; y++)\n            {\n                for (int x = 0; x < w; x++)\n                {\n                    if (map[y][x] == 'X')\n                    {\n                        if(y==0||y==h-1 ||x==0||x==w-1)\n                        {\n                            Console.WriteLine(-1);\n                            return;\n                        }\n                        for (int i = 0; i < 4; i++)\n                        {\n                            int tmpy = y + vy[i];\n                            int tmpx = x + vx[i];\n                            if (inside(tmpy, tmpx) && saku[tmpy, tmpx] == false)\n                            {\n                                saku[tmpy, tmpx] = true;\n                                qy.Enqueue(tmpy);\n                                qx.Enqueue(tmpx);\n                            }\n                        }\n                    }\n                }\n            }\n            while (qy.Count > 0)\n            {\n                int nowy = qy.Dequeue();\n                int nowx = qx.Dequeue();\n                bool deletable = true;\n                for (int i = 0; i < 4; i++)\n                {\n                    int tmpy = nowy + vy[i];\n                    int tmpx = nowx + vx[i];\n                    if (inside(tmpy, tmpx) == false)\n                    {\n                        deletable = false;\n                        break;\n                    }\n                    else if (saku[tmpy, tmpx] == false && map[tmpy][tmpx] == '.')\n                    {\n                        deletable = false;\n                        break;\n                    }\n                }\n                if (deletable == false) ans++;\n            }\n            Console.WriteLine(ans);\n        }\n        static bool inside(int y, int x)\n        {\n            return y >= 0 && x >= 0 && y < h && x < w;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tvar s=sc.Ia;\n\t\tint g=s[0]*s[1]*2+2;\n\t\tvar fl=new Flow(g+1);\n\t\tint inf=100000;\n\t\tfor(int i = 0;i<s[0];i++) {\n\t\t\tvar e=sc.S;\n\t\t\tfor(int j = 0;j<s[1];j++) {\n\t\t\t\tint v=((i*s[1]+j)<<1)+1;\n\t\t\t\tif(e[j]=='.'){\n\t\t\t\t\tfl.Edge(v,v+1,1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfl.Edge(v,v+1,inf);\n\t\t\t\t\tfl.Edge(v+1,g,inf);\n\t\t\t\t}\n\t\t\t\tif(i!=s[0]-1){\n\t\t\t\t\tfl.Edge(v+1,v+(s[1]<<1),inf);\n\t\t\t\t\tfl.Edge(v+(s[1]<<1)+1,v,inf);\n\t\t\t\t}\n\t\t\t\tif(j!=s[1]-1){\n\t\t\t\t\tfl.Edge(v+1,v+2,inf);\n\t\t\t\t\tfl.Edge(v+3,v,inf);\n\t\t\t\t}\n\t\t\t\tif(i==0||j==0||i==s[0]-1||j==s[1]-1){\n\t\t\t\t\tfl.Edge(g-1,v,inf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=fl.Dinic(g-1,g);\n\t\tConsole.WriteLine(\"{0}\",ans<inf?ans:-1);\n\t}\n}\npublic class Flow{\n\tprivate List<int>[] li;\n\tprivate Dictionary<int,int>[] h;\n\tprivate bool[] b;\n\tprivate int[] l;\n\tprivate int n,ans,gl;\n\tprivate const int inf=int.MaxValue;\n\tpublic Flow(int n){\n\t\tthis.n=n;\n\t\tli=new List<int>[n];\n\t\th=new Dictionary<int,int>[n+1];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tli[i]=new List<int>();\n\t\t\th[i]=new Dictionary<int,int>();\n\t\t}\n\t}\n\tpublic void Edge(int a,int b,int c){\n\t\t//if(!h[a].ContainsKey(b)){\n\t\t\tli[a].Add(b);\n\t\t\tli[b].Add(a);\n\t\t\th[a].Add(b,c);\n\t\t\th[b].Add(a,0);\n\t\t//}\n\t\t//else{h[a][b]=c;}\n\t}\n\tpublic int Dinic(int st,int gl){\n\t\tthis.gl=st;\n\t\tans=0;\n\t\tint z=1;\n\t\twhile(z>0){\n\t\t\tl=new int[n];\n\t\t\tvar qu=new Queue<Tuple<int,int>>();\n\t\t\tqu.Enqueue(Tuple.Create(st,1));\n\t\t\tl[st]=1;\n\t\t\twhile(qu.Count>0){\n\t\t\t\tvar e=qu.Dequeue();\n\t\t\t\tfor(int i=0;i<li[e.Item1].Count;i++){\n\t\t\t\t\tif(l[li[e.Item1][i]]==0&&h[e.Item1][li[e.Item1][i]]!=0){\n\t\t\t\t\t\tl[li[e.Item1][i]]=e.Item2+1;\n\t\t\t\t\t\tqu.Enqueue(Tuple.Create(li[e.Item1][i],e.Item2+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(e.Item1==gl){break;}\n\t\t\t}\n\t\t\tb=new bool[n];\n\t\t\tz=Fu3(gl,inf);\n\t\t\tans+=z;\n\t\t}\n\t\treturn ans;\n\t}\n\tprivate int Fu3(int a,int p){\n\t\tif(a==gl){return p;}\n\t\tint u=0;\n\t\tfor(int i=0;i<li[a].Count&&p>u;i++){\n\t\t\tif(!b[li[a][i]]&&l[li[a][i]]<l[a]&&h[li[a][i]][a]!=0){\n\t\t\t\tint z=Fu3(li[a][i],Min(p-u,h[li[a][i]][a]));\n\t\t\t\th[li[a][i]][a]-=z;\n\t\t\t\th[a][li[a][i]]+=z;\n\t\t\t\tu+=z;\n\t\t\t}\n\t\t}\n\t\tif(u==0){b[a]=true;}\n\t\treturn u;\n\t}\n\tpublic int Ff(int st,int gl){\n\t\tthis.gl=gl;\n\t\tans=0;\n\t\tint z=1;\n\t\twhile(z>0){\n\t\t\tb=new bool[n];\n\t\t\tz=Fu2(st,inf);\n\t\t\tans+=z;\n\t\t}\n\t\treturn ans;\n\t}\n\tprivate int Fu2(int a,int p){\n\t\tif(a==gl){return p;}\n\t\tint u=0;\n\t\tb[a]=true;\n\t\tfor(int i=0;i<li[a].Count&&p>u;i++){\n\t\t\tif(!b[li[a][i]]&&h[a][li[a][i]]!=0){\n\t\t\t\tint z=Fu2(li[a][i],Min(p-u,h[a][li[a][i]]));\n\t\t\t\th[a][li[a][i]]-=z;\n\t\t\t\th[li[a][i]][a]+=z;\n\t\t\t\tu+=z;\n\t\t\t}\n\t\t}\n\t\tif(u!=0){b[a]=false;}\n\t\treturn u;\n\t}\n}\n\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tvar s=sc.Ia;\n\t\tint g=s[0]*s[1]*2+2;\n\t\tvar fl=new Flow(g);\n\t\tint inf=100000;\n\t\tfor(int i = 0;i<s[0];i++) {\n\t\t\tvar e=sc.S;\n\t\t\tfor(int j = 0;j<s[1];j++) {\n\t\t\t\tint v=((i*s[1]+j)<<1)+1;\n\t\t\t\tif(e[j]=='.'){\n\t\t\t\t\tfl.Edge1(v,v+1,1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfl.Edge1(v,v+1,inf);\n\t\t\t\t\tfl.Edge1(v+1,g,inf);\n\t\t\t\t}\n\t\t\t\tif(i!=s[0]-1){\n\t\t\t\t\tfl.Edge1(v+1,v+(s[1]<<1),inf);\n\t\t\t\t\tfl.Edge1(v+(s[1]<<1)+1,v,inf);\n\t\t\t\t}\n\t\t\t\tif(j!=s[1]-1){\n\t\t\t\t\tfl.Edge1(v+1,v+2,inf);\n\t\t\t\t\tfl.Edge1(v+3,v,inf);\n\t\t\t\t}\n\t\t\t\tif(i==0||j==0||i==s[0]-1||j==s[1]-1){\n\t\t\t\t\tfl.Edge1(g-1,v,inf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=fl.Ff(g-1,g);\n\t\tConsole.WriteLine(\"{0}\",ans<inf?ans:-1);\n\t}\n}\npublic class Flow{\n\tpublic List<int>[] li;\n\tprivate bool[] b;\n\tprivate int[] r;\n\tprivate int[][] h;\n\tprivate int n,ans,gl;\n\tprivate bool bo=false;\n\tpublic Flow(int n){\n\t\tthis.n=n;\n\t\tli=new List<int>[n+1];\n\t\tr=new int[n+1];\n\t\th=new int[n+1][];\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tli[i]=new List<int>();\n\t\t\th[i]=new int[n+1];\n\t\t}\n\t}\n\tpublic void Edge1(int a,int b,int c){\n\t\tif(h[b][a]==0){li[a].Add(b);li[b].Add(a);}\n\t\th[a][b]=c;\n\t}\n\tpublic void Edge2(int a,int b,int c){\n\t\tli[a].Add(b);li[b].Add(a);\n\t\th[a][b]=h[b][a]=c;\n\t}\n\tpublic int Ff(int st,int gl){\n\t\tthis.gl=gl;\n\t\tans=0;\n\t\twhile(!bo){\n\t\t\tb=new bool[n+1];\n\t\t\tbo=true;\n\t\t\tFu(st,0,int.MaxValue);\n\t\t}\n\t\treturn ans;\n\t}\n\tprivate void Fu(int a,int g,int p){\n\t\tb[a]=true;\n\t\tr[g]=a;\n\t\tif(a==gl){\n\t\t\tfor(int i=0;i<g;i++){\n\t\t\t\th[r[i]][r[i+1]]-=p;\n\t\t\t\th[r[i+1]][r[i]]+=p;\n\t\t\t}\n\t\t\tans+=p;\n\t\t\tbo=false;\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0;i<li[a].Count&&bo;i++){\n\t\t\tif(!b[li[a][i]]&&h[a][li[a][i]]!=0){Fu(li[a][i],g+1,Min(p,h[a][li[a][i]]));}\n\t\t}\n\t}\n}\n\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tvar s=sc.Ia;\n\t\tint g=s[0]*s[1]*2+2;\n\t\tvar fl=new Flow(g);\n\t\tint inf=100000;\n\t\tfor(int i = 0;i<s[0];i++) {\n\t\t\tvar e=sc.S;\n\t\t\tfor(int j = 0;j<s[1];j++) {\n\t\t\t\tint v=((i*s[1]+j)<<1)+1;\n\t\t\t\tif(e[j]=='.'){\n\t\t\t\t\tfl.Edge1(v,v+1,1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfl.Edge1(v,v+1,inf);\n\t\t\t\t\tfl.Edge1(v+1,g,inf);\n\t\t\t\t}\n\t\t\t\tif(i!=s[0]-1){\n\t\t\t\t\tfl.Edge1(v+1,v+(s[1]<<1),inf);\n\t\t\t\t\tfl.Edge1(v+(s[1]<<1)+1,v,inf);\n\t\t\t\t}\n\t\t\t\tif(j!=s[1]-1){\n\t\t\t\t\tfl.Edge1(v+1,v+2,inf);\n\t\t\t\t\tfl.Edge1(v+3,v,inf);\n\t\t\t\t}\n\t\t\t\tif(i==0||j==0||i==s[0]-1||j==s[1]-1){\n\t\t\t\t\tfl.Edge1(g-1,v,inf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=fl.Dinic(g-1,g);\n\t\tConsole.WriteLine(\"{0}\",ans<inf?ans:-1);\n\t}\n}\npublic class Flow{\n\tpublic List<int>[] li;\n\tprivate bool[] b;\n\tprivate int[] l;\n\tprivate Dictionary<int,int>[] h;\n\tprivate int n,ans,gl;\n\tpublic Flow(int n){\n\t\tthis.n=n;\n\t\tli=new List<int>[n+1];\n\t\th=new Dictionary<int,int>[n+1];\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tli[i]=new List<int>();\n\t\t\th[i]=new Dictionary<int,int>();\n\t\t}\n\t}\n\tpublic void Edge1(int a,int b,int c){\n\t\tli[a].Add(b);\n\t\tli[b].Add(a);\n\t\th[a].Add(b,c);\n\t\th[b].Add(a,0);\n\t}\n\tpublic int Dinic(int st,int gl){\n\t\tthis.gl=gl;\n\t\tans=0;\n\t\tint z=1;\n\t\twhile(z>0){\n\t\t\tl=new int[n+1];\n\t\t\tvar qu=new Queue<Tuple<int,int>>();\n\t\t\tqu.Enqueue(Tuple.Create(st,1));\n\t\t\tl[st]=1;\n\t\t\twhile(qu.Count>0){\n\t\t\t\tvar e=qu.Dequeue();\n\t\t\t\tfor(int i=0;i<li[e.Item1].Count;i++){\n\t\t\t\t\tif(l[li[e.Item1][i]]==0&&h[e.Item1][li[e.Item1][i]]!=0){\n\t\t\t\t\t\tl[li[e.Item1][i]]=e.Item2+1;\n\t\t\t\t\t\tqu.Enqueue(Tuple.Create(li[e.Item1][i],e.Item2+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tb=new bool[n+1];\n\t\t\tz=Fu3(st,int.MaxValue);\n\t\t\tans+=z;\n\t\t}\n\t\treturn ans;\n\t}\n\tprivate int Fu3(int a,int p){\n\t\tif(a==gl){return p;}\n\t\tint u=0;\n\t\tfor(int i=0;i<li[a].Count&&p>u;i++){\n\t\t\tif(!b[li[a][i]]&&l[li[a][i]]>l[a]&&h[a][li[a][i]]!=0){\n\t\t\t\tint z=Fu3(li[a][i],Min(p-u,h[a][li[a][i]]));\n\t\t\t\th[a][li[a][i]]-=z;\n\t\t\t\th[li[a][i]][a]+=z;\n\t\t\t\tu+=z;\n\t\t\t}\n\t\t}\n\t\tif(u==0){b[a]=true;}\n\t\treturn u;\n\t}\n}\n\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Globalization;\nusing System.Diagnostics;\nusing static System.Console;\n//using System.Numerics;\n//using static System.Math;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n\n    int H, W;\n    void solve()\n    {\n        H = cin.nextint;\n        W = cin.nextint;\n        var S = new char[H][];\n        for (int i = 0; i < H; i++)\n        {\n            S[i] = cin.next.ToCharArray();\n        }\n        int T = 2 * H * W + 1;\n        var D = new Dinic(T + 1);\n\n        \n        for (int i = 0; i < H; i++)\n        {\n            for (int j = 0; j < W; j++)\n            {\n                if (i == 0 || i == H - 1 || j == 0 || j == W - 1)\n                {\n                    if (S[i][j] == 'X')\n                    {\n                        WriteLine(-1);\n                        return;\n                    }\n                    D.add_edge(0, IN(i, j), Dinic.INF);\n                }\n                if (S[i][j] == 'X')\n                {\n                    D.add_edge(IN(i, j), OUT(i, j), Dinic.INF);\n                    D.add_edge(OUT(i, j), T, Dinic.INF);\n                }\n                else\n                {\n                    D.add_edge(IN(i, j), OUT(i, j), 1);\n                    for (int r = 0; r < 4; r++)\n                    {\n                        int y = i + dd[r];\n                        int x = j + dd[r + 1];\n                        if (y < 0 || y >= H || x < 0 || x >= W) continue;\n\n                        D.add_edge(OUT(i, j), IN(y, x), Dinic.INF);\n                    }\n                }\n            }\n        }\n\n        WriteLine(D.max_flow(0, T));\n    }\n    int IN(int y, int x)\n    {\n        return y * W + x + 1;\n    }\n    int OUT(int y, int x)\n    {\n        return y * W + x + 1 + H * W;\n    }\n\n\n}\n\nclass Dinic\n{\n    // 辺を表すクラス（行き先、容量、逆辺）\n    class Edge_\n    {\n        public int to;\n        public long cap;\n        public int rev;\n        public Edge_(int to, long cap, int rev)\n        {\n            this.to = to;\n            this.cap = cap;\n            this.rev = rev;\n        }\n    }\n    public const long INF = long.MaxValue / 3;\n    List<Edge_>[] G; // グラフの隣接リスト表現\n    int[] level;    // sからの距離\n    int[] iter;     // どこまで調べ終わったか\n    public Dinic(int V)\n    {\n        G = new List<Edge_>[V];\n        for (int i = 0; i < V; i++) G[i] = new List<Edge_>();\n        level = new int[V];\n        iter = new int[V];\n    }\n    // fromからtoまでの最短距離をBFSで計算する\n    public void add_edge(int from, int to, long cap)\n    {\n        G[from].Add(new Edge_(to, cap, G[to].Count));\n        G[to].Add(new Edge_(from, 0, G[from].Count - 1));\n    }\n    // sからの最短距離をBFSで計算する\n    void bfs(int s)\n    {\n        for (int i = 0; i < level.Length; i++) level[i] = -1;\n        var que = new Queue<int>();\n        level[s] = 0;\n        que.Enqueue(s);\n        while (que.Any())\n        {\n            int v = que.Dequeue();\n            foreach (Edge_ e in G[v])\n            {\n                if (e.cap > 0 && level[e.to] < 0)\n                {\n                    level[e.to] = level[v] + 1;\n                    que.Enqueue(e.to);\n                }\n            }\n        }\n    }\n    //増加パスをDFSで探す\n    long dfs(int v, int t, long f)\n    {\n        if (v == t) return f;\n        for (int i = iter[v]; i < G[v].Count; i++)\n        {\n            Edge_ e = G[v][i];\n            if (e.cap > 0 && level[v] < level[e.to])\n            {\n                long d = dfs(e.to, t, Math.Min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    // sからtへの最大流を求める\n    public long max_flow(int s, int t)\n    {\n        long flow = 0;\n        while (true)\n        {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            for (int i = 0; i < iter.Length; i++) iter[i] = 0;\n            while (true)\n            {\n                long f = dfs(s, t, INF);\n                if (f <= 0) break;\n                flow += f;\n            }\n        }\n    }\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan { get { return ReadLine().Split(); } }\n    public int[] scanint { get { return Array.ConvertAll(scan, int.Parse); } }\n    public long[] scanlong { get { return Array.ConvertAll(scan, long.Parse); } }\n    public double[] scandouble { get { return Array.ConvertAll(scan, double.Parse); } }\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint { get { return int.Parse(next); } }\n    public long nextlong { get { return long.Parse(next); } }\n    public double nextdouble { get { return double.Parse(next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tvar s=sc.Ia;\n\t\tint g=s[0]*s[1]*2+2;\n\t\tvar fl=new Flow(g);\n\t\tint inf=100000;\n\t\tfor(int i = 0;i<s[0];i++) {\n\t\t\tvar e=sc.S;\n\t\t\tfor(int j = 0;j<s[1];j++) {\n\t\t\t\tint v=((i*s[1]+j)<<1)+1;\n\t\t\t\tif(e[j]=='.'){\n\t\t\t\t\tfl.Edge1(v,v+1,1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfl.Edge1(v,v+1,inf);\n\t\t\t\t\tfl.Edge1(v+1,g,inf);\n\t\t\t\t}\n\t\t\t\tif(i!=s[0]-1){\n\t\t\t\t\tfl.Edge1(v+1,v+(s[1]<<1),inf);\n\t\t\t\t\tfl.Edge1(v+(s[1]<<1)+1,v,inf);\n\t\t\t\t}\n\t\t\t\tif(j!=s[1]-1){\n\t\t\t\t\tfl.Edge1(v+1,v+2,inf);\n\t\t\t\t\tfl.Edge1(v+3,v,inf);\n\t\t\t\t}\n\t\t\t\tif(i==0||j==0||i==s[0]-1||j==s[1]-1){\n\t\t\t\t\tfl.Edge1(g-1,v,inf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=fl.Ff2(g-1,g);\n\t\tConsole.WriteLine(\"{0}\",ans<inf?ans:-1);\n\t}\n}\npublic class Flow{\n\tpublic List<int>[] li;\n\tprivate bool[] b;\n\tprivate int[] r,l,b2;\n\tprivate Dictionary<int,int>[] h;\n\tprivate int n,ans,gl;\n\tprivate bool bo=false;\n\tpublic Flow(int n){\n\t\tthis.n=n;\n\t\tli=new List<int>[n+1];\n\t\tr=new int[n+1];\n\t\tl=new int[n+1];\n\t\th=new Dictionary<int,int>[n+1];\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tli[i]=new List<int>();\n\t\t\th[i]=new Dictionary<int,int>();\n\t\t\tl[i]=-1;\n\t\t}\n\t}\n\tpublic void Edge1(int a,int b,int c){\n\t\tli[a].Add(b);\n\t\tli[b].Add(a);\n\t\th[a].Add(b,c);\n\t\th[b].Add(a,0);\n\t}\n\tpublic int Dinic(int st,int gl){\n\t\tvar qu=new Queue<Tuple<int,int>>();\n\t\tqu.Enqueue(Tuple.Create(st,0));\n\t\tl[st]=0;\n\t\twhile(qu.Count>0){\n\t\t\tvar e=qu.Dequeue();\n\t\t\tfor(int i=0;i<li[e.Item1].Count;i++){\n\t\t\t\tif(l[li[e.Item1][i]]==-1&&h[e.Item1][li[e.Item1][i]]!=0){\n\t\t\t\t\tl[li[e.Item1][i]]=e.Item2+1;\n\t\t\t\t\tqu.Enqueue(Tuple.Create(li[e.Item1][i],e.Item2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tpublic int Ff(int st,int gl){\n\t\tthis.gl=gl;\n\t\tans=0;\n\t\twhile(!bo){\n\t\t\tb=new bool[n+1];\n\t\t\tbo=true;\n\t\t\tFu1(st,0,int.MaxValue);\n\t\t}\n\t\treturn ans;\n\t}\n\tpublic int Ff2(int st,int gl){\n\t\tthis.gl=gl;\n\t\tans=0;\n\t\tint z=1;\n\t\twhile(z>0){\n\t\t\tb2=new int[n+1];\n\t\t\tz=Fu2(st,int.MaxValue);\n\t\t\tans+=z;\n\t\t}\n\t\treturn ans;\n\t}\n\tprivate int Fu2(int a,int p){\n\t\tif(a==gl){return p;}\n\t\tint u=0;\n\t\tb2[a]|=1;\n\t\tfor(int i=0;i<li[a].Count&&p>u;i++){\n\t\t\tif(b2[li[a][i]]==0&&h[a][li[a][i]]!=0){\n\t\t\t\tint z=Fu2(li[a][i],Min(p-u,h[a][li[a][i]]));\n\t\t\t\th[a][li[a][i]]-=z;\n\t\t\t\th[li[a][i]][a]+=z;\n\t\t\t\tu+=z;\n\n\t\t\t}\n\t\t}\n\t\tb2[a]&=-2;\n\t\tif(u==0){b2[a]=2;}\n\t\treturn u;\n\t}\n\tprivate void Fu1(int a,int g,int p){\n\t\tb[a]=true;\n\t\tr[g]=a;\n\t\tif(a==gl){\n\t\t\tfor(int i=0;i<g;i++){\n\t\t\t\th[r[i]][r[i+1]]-=p;\n\t\t\t\th[r[i+1]][r[i]]+=p;\n\t\t\t}\n\t\t\tans+=p;\n\t\t\tbo=false;\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0;i<li[a].Count&&bo;i++){\n\t\t\tif(!b[li[a][i]]&&h[a][li[a][i]]!=0){Fu1(li[a][i],g+1,Min(p,h[a][li[a][i]]));}\n\t\t}\n\t}\n}\n\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tvar s=sc.Ia;\n\t\tint g=s[0]*s[1]*2+2;\n\t\tvar fl=new Flow(g+1);\n\t\tint inf=100000;\n\t\tfor(int i = 0;i<s[0];i++) {\n\t\t\tvar e=sc.S;\n\t\t\tfor(int j = 0;j<s[1];j++) {\n\t\t\t\tint v=((i*s[1]+j)<<1)+1;\n\t\t\t\tif(e[j]=='.'){\n\t\t\t\t\tfl.Edge(v,v+1,1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfl.Edge(v,v+1,inf);\n\t\t\t\t\tfl.Edge(v+1,g,inf);\n\t\t\t\t}\n\t\t\t\tif(i!=s[0]-1){\n\t\t\t\t\tfl.Edge(v+1,v+(s[1]<<1),inf);\n\t\t\t\t\tfl.Edge(v+(s[1]<<1)+1,v,inf);\n\t\t\t\t}\n\t\t\t\tif(j!=s[1]-1){\n\t\t\t\t\tfl.Edge(v+1,v+2,inf);\n\t\t\t\t\tfl.Edge(v+3,v,inf);\n\t\t\t\t}\n\t\t\t\tif(i==0||j==0||i==s[0]-1||j==s[1]-1){\n\t\t\t\t\tfl.Edge(g-1,v,inf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=fl.Dinic(g-1,g);\n\t\tConsole.WriteLine(\"{0}\",ans<inf?ans:-1);\n\t}\n}\npublic class Flow{\n\tprivate List<int>[] li;\n\tprivate Dictionary<int,int>[] h;\n\tprivate bool[] b;\n\tprivate int[] l;\n\tprivate int n,ans,gl;\n\tprivate const int inf=int.MaxValue;\n\tpublic Flow(int n){\n\t\tthis.n=n;\n\t\tli=new List<int>[n];\n\t\th=new Dictionary<int,int>[n+1];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tli[i]=new List<int>();\n\t\t\th[i]=new Dictionary<int,int>();\n\t\t}\n\t}\n\tpublic void Edge(int a,int b,int c){\n\t\t//if(!h[a].ContainsKey(b)){\n\t\t\tli[a].Add(b);\n\t\t\tli[b].Add(a);\n\t\t\th[a].Add(b,c);\n\t\t\th[b].Add(a,0);\n\t\t//}\n\t\t//else{h[a][b]=c;}\n\t}\n\tpublic int Dinic(int st,int gl){\n\t\tthis.gl=gl;\n\t\tans=0;\n\t\tint z=1,g=0;\n\t\twhile(z>0){\n\t\t\tl=new int[n];\n\t\t\tvar qu=new Queue<Tuple<int,int>>();\n\t\t\tqu.Enqueue(Tuple.Create(st,1));\n\t\t\tl[st]=1;\n\t\t\tg=n+2;\n\t\t\twhile(qu.Count>0){\n\t\t\t\tvar e=qu.Dequeue();\n\t\t\t\tif(e.Item1==gl){g=e.Item2;}\n\t\t\t\telse if(e.Item2>g){break;}\n\t\t\t\tfor(int i=0;i<li[e.Item1].Count;i++){\n\t\t\t\t\tif(l[li[e.Item1][i]]==0&&h[e.Item1][li[e.Item1][i]]!=0){\n\t\t\t\t\t\tl[li[e.Item1][i]]=e.Item2+1;\n\t\t\t\t\t\tqu.Enqueue(Tuple.Create(li[e.Item1][i],e.Item2+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tb=new bool[n];\n\t\t\tz=Fu3(st,inf);\n\t\t\tans+=z;\n\t\t}\n\t\treturn ans;\n\t}\n\tprivate int Fu3(int a,int p){\n\t\tif(a==gl){return p;}\n\t\tint u=0;\n\t\tfor(int i=0;i<li[a].Count&&p>u;i++){\n\t\t\tif(!b[li[a][i]]&&l[li[a][i]]>l[a]&&h[a][li[a][i]]!=0){\n\t\t\t\tint z=Fu3(li[a][i],Min(p-u,h[a][li[a][i]]));\n\t\t\t\th[a][li[a][i]]-=z;\n\t\t\t\th[li[a][i]][a]+=z;\n\t\t\t\tu+=z;\n\t\t\t}\n\t\t}\n\t\tif(u==0){b[a]=true;}\n\t\treturn u;\n\t}\n\tpublic int Ff(int st,int gl){\n\t\tthis.gl=gl;\n\t\tans=0;\n\t\tint z=1;\n\t\twhile(z>0){\n\t\t\tb=new bool[n];\n\t\t\tz=Fu2(st,inf);\n\t\t\tans+=z;\n\t\t}\n\t\treturn ans;\n\t}\n\tprivate int Fu2(int a,int p){\n\t\tif(a==gl){return p;}\n\t\tint u=0;\n\t\tb[a]=true;\n\t\tfor(int i=0;i<li[a].Count&&p>u;i++){\n\t\t\tif(!b[li[a][i]]&&h[a][li[a][i]]!=0){\n\t\t\t\tint z=Fu2(li[a][i],Min(p-u,h[a][li[a][i]]));\n\t\t\t\th[a][li[a][i]]-=z;\n\t\t\t\th[li[a][i]][a]+=z;\n\t\t\t\tu+=z;\n\t\t\t}\n\t\t}\n\t\tif(u!=0){b[a]=false;}\n\t\treturn u;\n\t}\n}\n\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing static System.Console;\nusing static System.Convert;\nusing static System.Math;\n//using static System.Globalization.CultureInfo;\nusing System.Text;\nclass Program\n{\n    private static void chmin<T>(ref T num, T val) where T : IComparable<T>\n        => num = num.CompareTo(val) == 1 ? val : num;\n    private static void chmax<T>(ref T num, T val) where T : IComparable<T>\n        => num = num.CompareTo(val) == -1 ? val : num;\n    static void Main(string[] args)\n    {\n        var pr = new Program();\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        Console.SetOut(sw);\n        pr.Solve();\n        Console.Out.Flush();\n    }\n    void Solve()\n    {\n        int h, w;\n        Input.Make(out h, out w);\n        var grid = Input.grid(h);\n        var f = new MaxFlow(2 * h * w + 2);\n        var hs = new[] { 0, 0, 1, -1 };\n        var ws = new[] { 1, -1, 0, 0 };\n        for (var i = 0; i < h; i++)\n            for (var j = 0; j < w; j++)\n            {\n                if(grid[i][j]=='.')\n                f.AddDirectedEdge(2 * (i * w + j), 2 * (i * w + j) + 1, 1);\n                else\n                {\n                    f.AddDirectedEdge(2 * (i * w + j), 2 * (i * w + j) + 1, 10000);\n                    f.AddDirectedEdge(2 * h * w, 2 * (i * w + j) + 1, 10000);\n                }\n                for (var k = 0; k < 4; k++)\n                {\n                    var hh = hs[k] + i;\n                    var ww = ws[k] + j;\n                    if (!Inside(hh, ww, h, w)) continue;\n                    f.AddDirectedEdge(2 * (i * w + j) + 1, 2 * (hh * w + ww), 10000);\n                }\n                if (i == 0 || i == h - 1 || j == 0 || j == w - 1)\n                {\n                    if (grid[i][j] != '.') { WriteLine(-1); return; }\n                    f.AddDirectedEdge(2 * (i * w + j) + 1, 2 * h * w + 1, 10000);\n                }\n            }\n        WriteLine(f.Execute(2 * h * w, 2 * h * w + 1));\n    }\n\n    public static bool Inside(int h, int w, int[] hw)\n        => Inside(h, w, hw[0], hw[1]);\n    public static bool Inside(int h, int w, int hh, int ww)\n        => 0 <= h && h < hh && 0 <= w && w < ww;\n}\n\npublic class Input\n{\n    public static string read => ReadLine().Trim();\n    public static int[] ar => read.Split(' ').Select(int.Parse).ToArray();\n    public static int num => ToInt32(read);\n    public static long[] arL => read.Split(' ').Select(long.Parse).ToArray();\n    public static long numL => ToInt64(read);\n    public static T[] create<T>(int n, Func<int, T> f)\n        => Enumerable.Repeat(0, n).Select(f).ToArray();\n    public static char[][] grid(int h)\n        => create(h, _ => read.ToCharArray());\n    public static int[] ar1D(int n)\n        => create(n, _ => num);\n    public static long[] arL1D(int n)\n        => create(n, _ => numL);\n    public static string[] strs(int n)\n        => create(n, _ => read);\n    public static int[][] ar2D(int n)\n        => create(n, _ => ar);\n    public static long[][] arL2D(int n)\n        => create(n, _ => arL);\n    public static List<T>[] edge<T>(int n)\n        => create(n, _ => new List<T>());\n    public static T GetValue<T>(string g)\n    {\n        var t = typeof(T);\n        if (t == typeof(int))\n            return (T)(object)int.Parse(g);\n        if (t == typeof(long))\n            return (T)(object)long.Parse(g);\n        if (t == typeof(string))\n            return (T)(object)g;\n        if (t == typeof(char))\n            return (T)(object)char.Parse(g);\n        if (t == typeof(double))\n            return (T)(object)double.Parse(g);\n        if (t == typeof(bool))\n            return (T)(object)bool.Parse(g);\n        return default(T);\n    }\n    public static void Make<T1, T2>(out T1 v1, out T2 v2)\n    {\n        v1 = Next<T1>();\n        v2 = Next<T2>();\n    }\n    public static void Make<T1, T2, T3>(out T1 v1, out T2 v2, out T3 v3)\n    {\n        Make(out v1, out v2);\n        v3 = Next<T3>();\n    }\n    public static void Make<T1, T2, T3, T4>(out T1 v1, out T2 v2, out T3 v3, out T4 v4)\n    {\n        Make(out v1, out v2, out v3);\n        v4 = Next<T4>();\n    }\n    public static void Make<T1, T2, T3, T4, T5>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5)\n    {\n        Make(out v1, out v2, out v3, out v4);\n        v5 = Next<T5>();\n    }\n    public static void Make<T1, T2, T3, T4, T5, T6>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5, out T6 v6)\n    {\n        Make(out v1, out v2, out v3, out v4, out v5);\n        v6 = Next<T6>();\n    }\n    private static Queue<string> sc;\n    public static T Next<T>(){ sc = sc ?? new Queue<string>(); if (sc.Count == 0) foreach (var item in read.Split(' ')) sc.Enqueue(item);return GetValue<T>(sc.Dequeue()); }\n    public static void Next<T>(ref T val) => val = Next<T>(); \n    public const long Inf = (long)1e18;\n    public const double eps = 1e-6;\n    public const string Alfa = \"abcdefghijklmnopqrstuvwxyz\";\n    public const int MOD = 1000000007;\n}\n\npublic class Pair<T1, T2> : IComparable<Pair<T1, T2>>\n{\n    public T1 v1 { get; set; }\n    public T2 v2 { get; set; }\n    public Pair() { v1 = Input.Next<T1>(); v2 = Input.Next<T2>(); }\n    public Pair(T1 v1, T2 v2)\n    { this.v1 = v1; this.v2 = v2; }\n\n    public int CompareTo(Pair<T1, T2> p)\n    {\n        var c = Comparer<T1>.Default.Compare(v1, p.v1);\n        if (c == 0)\n            c = Comparer<T2>.Default.Compare(v2, p.v2);\n        return c;\n    }\n    public override string ToString()\n        => $\"{v1.ToString()} {v2.ToString()}\";\n    public override bool Equals(object obj)\n        => this == (Pair<T1, T2>)obj;\n    public override int GetHashCode()\n        => v1.GetHashCode() ^ v2.GetHashCode();\n    public static bool operator ==(Pair<T1, T2> p1, Pair<T1, T2> p2)\n        => p1.CompareTo(p2) == 0;\n    public static bool operator !=(Pair<T1, T2> p1, Pair<T1, T2> p2)\n        => p1.CompareTo(p2) != 0;\n    public static bool operator >(Pair<T1, T2> p1, Pair<T1, T2> p2)\n        => p1.CompareTo(p2) == 1;\n    public static bool operator >=(Pair<T1, T2> p1, Pair<T1, T2> p2)\n        => p1.CompareTo(p2) != -1;\n    public static bool operator <(Pair<T1, T2> p1, Pair<T1, T2> p2)\n        => p1.CompareTo(p2) == -1;\n    public static bool operator <=(Pair<T1, T2> p1, Pair<T1, T2> p2)\n        => p1.CompareTo(p2) != 1;\n}\n\npublic class Pair<T1, T2, T3> : Pair<T1, T2>, IComparable<Pair<T1, T2, T3>>\n{\n    public T3 v3 { get; set; }\n    public Pair() : base() { v3 = Input.Next<T3>(); }\n    public Pair(T1 v1, T2 v2, T3 v3) : base(v1, v2)\n    { this.v3 = v3; }\n\n    public int CompareTo(Pair<T1, T2, T3> p)\n    {\n        var c = base.CompareTo(p);\n        if (c == 0)\n            c = Comparer<T3>.Default.Compare(v3, p.v3);\n        return c;\n    }\n    public override string ToString()\n        => $\"{base.ToString()} {v3.ToString()}\";\n}\n\n\npublic class MaxFlow\n{\n    readonly List<Edge>[] G;\n    readonly int[] lv, iter;\n\n    public MaxFlow(int V)\n    {\n        G = new List<Edge>[V];\n        lv = new int[V];\n        iter = new int[V];\n        for (int i = 0; i < G.Length; i++)\n            G[i] = new List<Edge>();\n    }\n\n    public void AddDirectedEdge(int from, int to, int cap)\n        => addEdge(from, to, cap, 0);\n\n    public void AddUndirectedEdge(int from, int to, int cap)\n        => addEdge(from, to, cap, cap);\n\n    void addEdge(int f, int t, int c1, int c2)\n    {\n        var a = new Edge(t, c1);\n        var b = new Edge(f, c2);\n        Edge.Link(a, b);\n        G[f].Add(a);\n        G[t].Add(b);\n    }\n\n    public int Execute(int src, int sink, int f = -1)\n    {\n        int flow = 0;\n        if (f < 0) f = int.MaxValue;\n        while (f > 0)\n        {\n            bfs(src);\n            if (lv[sink] == 0) return flow;\n            Array.Clear(iter, 0, iter.Length);\n            int df;\n            while ((df = dfs(src, sink, f)) > 0) { flow += df; f -= df; }\n        }\n        return flow;\n    }\n\n    void bfs(int s)\n    {\n        Array.Clear(lv, 0, lv.Length);\n        var q = new Queue<int>();\n        lv[s] = 1;\n        q.Enqueue(s);\n        while (q.Count > 0)\n        {\n            var v = q.Dequeue();\n            foreach (var e in G[v])\n                if (e.Cap > 0 && lv[e.To] == 0)\n                {\n                    lv[e.To] = lv[v] + 1;\n                    q.Enqueue(e.To);\n                }\n        }\n\n    }\n    int dfs(int v, int t, int f)\n    {\n        if (v == t) return f;\n        int ret = 0;\n        for (; iter[v] < G[v].Count; iter[v]++)\n        {\n            var e = G[v][iter[v]];\n            if (e.Cap <= 0 || lv[v] >= lv[e.To]) continue;\n            int df = dfs(e.To, t, Math.Min(f, e.Cap));\n            if (df <= 0) continue;\n            e.Cap -= df;\n            e.Rev.Cap += df;\n            ret += df; f -= df;\n            if (f == 0) break;\n        }\n        return ret;\n\n    }\n    class Edge\n    {\n        public static void Link(Edge e1, Edge e2)\n        {\n            e1.Rev = e2; e2.Rev = e1;\n        }\n        public int To { get; private set; }\n        public Edge Rev { get; private set; }\n        public int Cap { get; set; }\n        public Edge(int t, int c)\n        {\n            To = t;\n            Cap = c;\n        }\n        public override string ToString()\n        {\n            return string.Format(\"to: {0}, cap: {1}\", To, Cap);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nclass Program\n{\n    static void Main(string[] args)\n    {\n            // 考え方\n            // グリッド内のXの周りに#を配置(#は柵を表す)し#の数を数えればよい。\n            // 但し#がXと#に囲まれた範囲内(直近+1でなくてもよい)であれば#をなくしてもよい\n            // #がXと#に囲まれた範囲内であるかどうかは全#でひとつひとつ調べなくてはならないため面倒な為\n            // Xと#に囲まれた範囲内の.は$に変換としXと#に囲まれたていない.はGとした。\n            // またXと#に囲まれているかいないかを簡単に判断出来るようにグリッドの外側をGで囲む\n            // その為グリッドの大きさは与えられた値よりH+2、W+2となる。\n            // 範囲内の.に接続している箇所にGが存在すればそれはXと#に囲まれていないと判断できる。\n            // 最終的にグリッドはXと#と$とGで表現出来る(.は全部#か$かGで変換する)\n            // $はXと#に囲まれた箇所 GはXと#に囲まれていない箇所\n            // #の上下左右の値がXor#or$である場合は#は$に変換可能\n            // 最終的に残った#の数を数えれば求める値である。\n\n            // 入力\n            string[] sS = System.Console.ReadLine().Trim().Split(' ');\n            int iH = int.Parse(sS[0]);\n            int iW = int.Parse(sS[1]);\n            List<List<string>> lstMap = new List<List<string>>();\n            List<string> lstGawU = new List<string>();\n            List<string> lstGawD = new List<string>();\n            for (int i = 0; i < iW + 2; i++) { lstGawU.Add(\"G\"); lstGawD.Add(\"G\"); }\n            lstMap.Add(lstGawU);                                                                                            // グリッドの外側を\"G\"で囲む\n            for (int i = 0; i < iH; i++)\n            {\n                string s2 = System.Console.ReadLine().Trim();\n                s2 = \"G\" + s2 + \"G\";\n                 List<string> lstRow = new List<string>();\n                for (int j = 0; j < s2.Length; j++)\n                {\n                    lstRow.Add(s2.Substring(j, 1));                                                                         // 現状グリッド取得\n                }\n                lstMap.Add(lstRow);\n            }\n            lstMap.Add(lstGawD);                                                                                            // グリッドの外側を\"G\"で囲む\n            iH += 2;                                                                                                        // グリッドの外側を\"G\"で囲んだので+2\n            iW += 2;                                                                                                        // グリッドの外側を\"G\"で囲んだので+2\n\n            System.Diagnostics.Stopwatch sw = new System.Diagnostics.Stopwatch();\n            sw.Start();\n\n            // 解析\n            //DebugDisp(lstMap);\n            Boolean bSide = false;\n            for (int i = 0; i < lstMap.Count; i++)\n            {\n                for (int j = 0; j < lstMap[i].Count; j++)\n                {\n                    if (lstMap[i][j] == \"X\")                                                                                // とりあえずXの周りに#設置\n                    {\n                        if (i - 1 >= 0 && j + 0 < iW && lstMap[i - 1][j + 0] == \".\") { lstMap[i - 1][j + 0] = \"#\"; }        // Xの上が.なら#\n                        if (i + 0 < iH && j + 1 < iW && lstMap[i + 0][j + 1] == \".\") { lstMap[i + 0][j + 1] = \"#\"; }        // Xの右が.なら#\n                        if (i + 1 < iH && j - 0 >= 0 && lstMap[i + 1][j - 0] == \".\") { lstMap[i + 1][j - 0] = \"#\"; }        // Xの下が.なら#\n                        if (i - 0 >= 0 && j - 1 >= 0 && lstMap[i - 0][j - 1] == \".\") { lstMap[i - 0][j - 1] = \"#\"; }        // Xの左が.なら#\n                        if (i - 1 >= 0 && j + 0 < iW && lstMap[i - 1][j + 0] == \"G\") { bSide = true; break; }               // Xの上がGならXが端で終わり\n                        if (i + 0 < iH && j + 1 < iW && lstMap[i + 0][j + 1] == \"G\") { bSide = true; break; }               // Xの右がGならXが端で終わり\n                        if (i + 1 < iH && j - 0 >= 0 && lstMap[i + 1][j - 0] == \"G\") { bSide = true; break; }               // Xの下がGならXが端で終わり\n                        if (i - 0 >= 0 && j - 1 >= 0 && lstMap[i - 0][j - 1] == \"G\") { bSide = true; break; }               // Xの左がGならXが端で終わり\n                    }\n                }\n                if (bSide) { break; }\n            }\n            int iOut = 0;\n            //DebugDisp(lstMap);\n            if (bSide) { iOut = -1; }                                                                                       // Xが端\n            else\n            {                                                                                                               // Xが端にない\n                for (int i = 0; i < lstMap.Count; i++)                                                                      // グリッド上の.が#orXで囲まれていれば＄に\n                {                                                                                                           // 囲まれていなければGに変換\n                    for (int j = 0; j < lstMap[i].Count; j++)\n                    {\n                        if (lstMap[i][j] == \".\")                                                                            // とりあえず.が#orXで囲まれているか確認\n                        {                                                                                                   // 囲まれていたら.を$に変換\n                            int iFig = 1;                                                                                   // 最初の点(初期値)\n                            lstMap[i][j] = iFig.ToString();                                                                 // とりあえず現状の.を初期値に\n                            Boolean bSoto = false;                                                                          // #orXに囲まれていないフラグ\n                            while (true)\n                            {\n                                Boolean bNxt = false;                                                                       // 次の調査箇所あるか\n                                for (int p = 0; p < lstMap.Count; p++)                                                      // 次の調査箇所\n                                {                                                                                           // 次の調査箇所\n                                    for (int r = 0; r < lstMap[p].Count; r++)\n                                    {\n                                        if (lstMap[p][r] == iFig.ToString())                                                // 次の調査箇所\n                                        {\n                                            bNxt = true;                                                                    // 次の調査箇所あり\n                                            if (p - 1 >= 0 && r + 0 < iW && lstMap[p - 1][r + 0] == \"G\") { bSoto = true; }  // 調査箇所の上がGならダメ。#orXで囲まれていない\n                                            if (p + 0 < iH && r + 1 < iW && lstMap[p + 0][r + 1] == \"G\") { bSoto = true; }  // 調査箇所の右がGならダメ。#orXで囲まれていない\n                                            if (p + 1 < iH && r - 0 >= 0 && lstMap[p + 1][r - 0] == \"G\") { bSoto = true; }  // 調査箇所の下がGならダメ。#orXで囲まれていない\n                                            if (p - 0 >= 0 && r - 1 >= 0 && lstMap[p - 0][r - 1] == \"G\") { bSoto = true; }  // 調査箇所の左がGならダメ。#orXで囲まれていない\n                                            if (p - 1 >= 0 && r + 0 < iW && lstMap[p - 1][r + 0] == \".\") { lstMap[p - 1][r + 0] = (iFig + 1).ToString(); }  // 調査箇所の上が.なら次の調査箇所に\n                                            if (p + 0 < iH && r + 1 < iW && lstMap[p + 0][r + 1] == \".\") { lstMap[p + 0][r + 1] = (iFig + 1).ToString(); }  // 調査箇所の右が.なら次の調査箇所に\n                                            if (p + 1 < iH && r - 0 >= 0 && lstMap[p + 1][r - 0] == \".\") { lstMap[p + 1][r - 0] = (iFig + 1).ToString(); }  // 調査箇所の下が.なら次の調査箇所に\n                                            if (p - 0 >= 0 && r - 1 >= 0 && lstMap[p - 0][r - 1] == \".\") { lstMap[p - 0][r - 1] = (iFig + 1).ToString(); }  // 調査箇所の左が.なら次の調査箇所に\n                                        }\n                                    }\n                                }\n                                if (!bNxt) { break; }                                                                       // 次の調査箇所がなければ終了\n                                iFig += 1;                                                                                  // 次の調査箇所No\n                            }\n                            string sCov = \"$\";                                                                              // 調査済フラグ$ #orXに囲まれている \n                            if (bSoto) { sCov = \"G\"; }                                                                      // 調査済フラグG #orXに囲まれていない\n                            for (int p = 0; p < lstMap.Count; p++)                                                          // 今回調査した箇所\n                            {                                                                                               // 今回調査した箇所\n                                for (int r = 0; r < lstMap[p].Count; r++)\n                                {\n                                    if (lstMap[p][r] != \"#\" &&\n                                        lstMap[p][r] != \"X\" &&\n                                        lstMap[p][r] != \".\" &&\n                                        lstMap[p][r] != \"G\" &&\n                                        lstMap[p][r] != \"$\")                                                                // 今回調査した箇所\n                                    {\n                                        lstMap[p][r] = sCov;                                                                // $orGに変換\n                                    }\n                                }\n                            }           // for p\n                        }               // if ij .\n                    }                   // for j\n                }                       // for i\n                // #が$or#orXに囲まれていれば$に変換\n                //DebugDisp(lstMap);\n                for (int i = 0; i < lstMap.Count; i++)                                                                      // グリッド上の#が#orXor$で囲まれていれば＄に\n                {                                                                                                           // 囲まれていなければ#のまま\n                    for (int j = 0; j < lstMap[i].Count; j++)\n                    {\n                        if (lstMap[i][j] == \"#\")                                                                            // #が#orXor$で囲まれているか確認\n                        {                                                                                                   // 囲まれていたら#を$に変換\n                            List<int> lstFlg = new List<int>() { 0, 0, 0, 0 };                                               // 周りが#orXor$かフラグ\n                            if (i - 1 >= 0 && j + 0 < iW && (lstMap[i - 1][j + 0] == \"#\" || lstMap[i - 1][j + 0] == \"X\" || lstMap[i - 1][j + 0] == \"$\")) { lstFlg[0] = 1; }     // #の上が#orXor$ならフラグON\n                            if (i + 0 < iH && j + 1 < iW && (lstMap[i + 0][j + 1] == \"#\" || lstMap[i + 0][j + 1] == \"X\" || lstMap[i + 0][j + 1] == \"$\")) { lstFlg[1] = 1; }     // #の右が#orXor$ならフラグON\n                            if (i + 1 < iH && j - 0 >= 0 && (lstMap[i + 1][j - 0] == \"#\" || lstMap[i + 1][j - 0] == \"X\" || lstMap[i + 1][j - 0] == \"$\")) { lstFlg[2] = 1; }     // #の下が#orXor$ならフラグON\n                            if (i - 0 >= 0 && j - 1 >= 0 && (lstMap[i - 0][j - 1] == \"#\" || lstMap[i - 0][j - 1] == \"X\" || lstMap[i - 0][j - 1] == \"$\")) { lstFlg[3] = 1; }     // #の左が#orXor$ならフラグON\n                            if (lstFlg.Sum() == 4) { lstMap[i][j] = \"$\"; }                                                  // #が#orXor$で囲まれていれば$に変換\n                        }\n                    }\n                }\n                // #の数を数える\n                for (int i = 0; i < lstMap.Count; i++)                                                                      // グリッド上の#が#orXor$で囲まれていれば＄に\n                {                                                                                                           // 囲まれていなければ#のまま\n                    for (int j = 0; j < lstMap[i].Count; j++)\n                    {\n                        if (lstMap[i][j] == \"#\")                                                                            // #が#orXor$で囲まれているか確認\n                        {                                                                                                   // 囲まれていたら#を$に変換\n                            iOut += 1;\n                        }\n                    }\n                }\n            }                           // if !bSide\n\n            // 出力\n            System.Console.WriteLine(\"{0}\", iOut.ToString().Trim());\n\n            sw.Stop();\n#if DEBUG\n            Console.WriteLine();\n            //DebugDisp(lstMap);\n            Console.WriteLine(\"{0}\", sw.Elapsed.ToString());\n            Console.WriteLine(\"続行するには何かキーを押してください．．．\");\n            Console.ReadKey();\n#endif\n    }\n\n        // DebugDisp\n        private static void DebugDisp(List<List<string>> lstMap)\n        {\n            Console.WriteLine();\n            for (int i = 0; i < lstMap.Count; i++)\n            {\n                string sOut = string.Join(\"\", lstMap[i]);\n                System.Console.WriteLine(\"{0}\", sOut.ToString().Trim());\n            }\n            Console.WriteLine();\n        }\n\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace e\n{\n    class Program\n    {\n        static int h, w;\n        static void Main(string[] args)\n        {\n            int[] vy = { 1, 0, -1, 0 };\n            int[] vx = { 0, 1, 0, -1 };\n\n            int ans = 0;\n\n            int[] hw = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            h = hw[0];\n            w = hw[1];\n            string[] map = new string[h];\n            for (int i = 0; i < h; i++)\n            {\n                map[i] = Console.ReadLine();\n            }\n\n            bool[,] saku = new bool[h, w];\n            Queue<int> qsakux = new Queue<int>();\n            Queue<int> qsakuy = new Queue<int>();\n\n            for (int y = 0; y < h; y++)\n            {\n                for (int x = 0; x < w; x++)\n                {\n                    if (map[y][x] == 'X')\n                    {\n                        if(y==0||y==h-1 ||x==0||x==w-1)\n                        {\n                            Console.WriteLine(-1);\n                            return;\n                        }\n                        for (int i = 0; i < 4; i++)\n                        {\n                            int tmpy = y + vy[i];\n                            int tmpx = x + vx[i];\n                            if (inside(tmpy, tmpx) && saku[tmpy, tmpx] == false)\n                            {\n                                saku[tmpy, tmpx] = true;\n                                qsakuy.Enqueue(tmpy);\n                                qsakux.Enqueue(tmpx);\n                            }\n                        }\n                    }\n                }\n            }\n            while (qsakuy.Count > 0)\n            {\n                int nowsakuy = qsakuy.Dequeue();\n                int nowsakux = qsakux.Dequeue();\n                bool deletable = true;\n\n                Queue<int> qx = new Queue<int>();\n                Queue<int> qy = new Queue<int>();\n                qx.Enqueue(nowsakux);\n                qy.Enqueue(nowsakuy);\n                while(qy.Count>0)\n                {\n                    int nowy = qy.Dequeue();\n                    int nowx = qx.Dequeue();\n                    for (int i = 0; i < 4; i++)\n                    {\n                        int tmpy = nowy + vy[i];\n                        int tmpx = nowx + vx[i];\n                        if (inside(tmpy, tmpx) == false)\n                        {\n                            deletable = false;\n                            break;\n                        }\n                        else if (saku[tmpy, tmpx] == false && map[tmpy][tmpx] == '.')\n                        {\n                            qy.Enqueue(tmpy);\n                            qx.Enqueue(tmpx);\n                        }\n                    }\n                    if (deletable == false) break;\n                }\n\n                if (deletable == false) ans++;\n            }\n            Console.WriteLine(ans);\n        }\n        static bool inside(int y, int x)\n        {\n            return y >= 0 && x >= 0 && y < h && x < w;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\tSol mySol =new Sol();\n\t\tmySol.Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tfor(int i=0;i<H;i++){\n\t\t\tif(S[i][0] == 'x' || S[i][W-1] == 'x' ){\n\t\t\t\tConsole.WriteLine(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<W;j++){\n\t\t\tif(S[0][j] == 'x' || S[H-1][j] == 'x' ){\n\t\t\t\tConsole.WriteLine(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar f = new MaxFlow_Dinic();\n\t\tint nnode = H*W*2;\n\t\tf.Init(nnode + 2);\n\t\tint s = H*W*2;\n\t\tint t = s + 1;\n\t\tFunc<int,int,int,int> enc = (r,c,d) => {\n\t\t\treturn d + 2*c + 2*W*r;\n\t\t};\n\t\t\n\t\tFunc<int,int,bool> InRange = (r,c) => {\n\t\t\treturn 0 <= r && r < H && 0 <= c && c < W;\n\t\t};\n\t\t\n\t\tint[] dx = new int[] {1,0,-1,0};\n\t\tint[] dy = new int[] {0,-1,0,1};\n\t\t\n\t\tvar Inf = (int)1e9;\n\t\t\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tif(S[i][j] == 'X'){\n\t\t\t\t\tf.AddEdge(enc(i,j,0), enc(i,j,1), Inf);\n\t\t\t\t\tf.AddEdge(s, enc(i,j,0), Inf);\n\t\t\t\t}else{\n\t\t\t\t\tf.AddEdge(enc(i,j,0), enc(i,j,1), 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int tt=0;tt<4;tt++){\n\t\t\t\t\tint ny = i + dy[tt];\n\t\t\t\t\tint nx = j + dx[tt];\n\t\t\t\t\tif(!InRange(ny,nx))continue;\n\t\t\t\t\tf.AddEdge(enc(i,j,1), enc(ny,nx,0), Inf);\n\t\t\t\t}\n\t\t\t\tif(i == 0 || i == H-1 || j == 0 || j == W-1){\n\t\t\t\t\tf.AddEdge(enc(i,j,1), t, Inf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tConsole.WriteLine(f.MaxFlow(s,t));\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\tint H,W;\n\tString[] S;\n\tpublic Sol(){\n\t\tvar d = ria();\n\t\tH = d[0]; W = d[1];\n\t\tS = new String[H];\n\t\tfor(int i=0;i<H;i++){\n\t\t\tS[i] = rs();\n\t\t}\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(char sep=' '){return Console.ReadLine().Split(sep);}\n\tstatic int[] ria(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>int.Parse(e));}\n\tstatic long[] rla(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>long.Parse(e));}\n\tstatic double[] rda(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>double.Parse(e));}\n}\n\n\nclass MaxFlow_Dinic{\n\t// arihon is god\n\tclass Edge {\n\t\tpublic int To,Cap,Rev;\n\t\tpublic Edge(int to = 0,int cap = 0,int rev = 0){\n\t\t\tTo = to;\n\t\t\tCap = cap;\n\t\t\tRev = rev;\n\t\t}\n\t}\n\t\n\tList<Edge>[] G;\n\tint[] Level;\n\tint[] Iter;\n\t\n\tstatic int Inf = (int) 1e9;\n\tpublic int N;\n\tpublic void Init(int n){\n\t\tN = n;\n\t\tG = new List<Edge>[N];\n\t\tfor(int i=0;i<N;i++) G[i] = new List<Edge>();\n\t\tLevel = new int[N];\n\t\tIter = new int[N];\n\t}\n\t\n\t\n\tpublic void AddEdge(int from, int to, int cap){\n\t\tG[from].Add(new Edge(to,cap,G[to].Count));\n\t\tG[to].Add(new Edge(from,0,G[from].Count-1));\n\t}\n\t\n\tvoid bfs(int s){\n\t\tfor(int j=0;j<G.Length;j++)Level[j] = -1;\n\t\tvar Q = new Queue<int>();\n\t\tLevel[s] = 0;\n\t\tQ.Enqueue(s);\n\t\t\n\t\twhile(Q.Count>0){\n\t\t\tvar v = Q.Dequeue();\n\t\t\tforeach(var e in G[v]){\n\t\t\t\tif(e.Cap > 0 && Level[e.To] < 0){\n\t\t\t\t\tLevel[e.To] = Level[v] + 1;\n\t\t\t\t\tQ.Enqueue(e.To);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint dfs(int v, int t, int f){\n\t\tif(v == t) return f;\n\t\tfor(;Iter[v] < G[v].Count; Iter[v]++){\n\t\t\tvar e = G[v][Iter[v]];\n\t\t\tif(e.Cap > 0 && Level[v] < Level[e.To]){\n\t\t\t\tint d = dfs(e.To, t, Math.Min(f,e.Cap));\n\t\t\t\tif(d > 0){\n\t\t\t\t\te.Cap -= d;\n\t\t\t\t\tG[e.To][e.Rev].Cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tpublic int MaxFlow(int s, int t){\n\t\tint flow = 0;\n\t\twhile(true){\n\t\t\tbfs(s);\n\t\t\tif(Level[t] < 0) return flow;\n\t\t\tIter = new int[N];\n\t\t\tint f;\n\t\t\twhile( ( f = dfs(s,t,Inf)) > 0){\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n}\n"
  },
  {
    "language": "Lisp",
    "code": ";; -*- coding: utf-8 -*-\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (defparameter OPT\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0)))\n  #+swank (progn (ql:quickload '(:cl-debug-print :fiveam))\n                 (shadow :run)\n                 (use-package :fiveam))\n  #-swank (set-dispatch-macro-character #\\# #\\> (lambda (s c p) (declare (ignore c p)) (read s nil (values) t))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n\n;; BEGIN_INSERTED_CONTENTS\n;;;\n;;; Ford-Fulkerson\n;;;\n\n(setf *print-circle* t)\n\n(defstruct (edge (:constructor %make-edge))\n  (to nil :type (integer 0 #.most-positive-fixnum))\n  (capacity 0 :type (integer 0 #.most-positive-fixnum))\n  (reversed nil :type (or null edge)))\n\n(defun push-edge (from-idx to-idx capacity graph &key bidirectional)\n  \"FROM-IDX, TO-IDX := index of vertex\nGRAPH := vector of lists of all the edges that goes from each vertex\n\nIf BIDIRECTIONAL is true, PUSH-EDGE adds the reversed edge of the same\ncapacity in addition.\"\n  (declare (optimize (speed 3))\n           ((simple-array list (*)) graph))\n  (let* ((dep (%make-edge :to to-idx :capacity capacity))\n         (ret (%make-edge :to from-idx\n                          :capacity (if bidirectional capacity 0)\n                          :reversed dep)))\n    (setf (edge-reversed dep) ret)\n    (push dep (aref graph from-idx))\n    (push ret (aref graph to-idx))))\n\n(declaim (ftype (function * (values (integer 0 #.most-positive-fixnum) &optional)) %find-flow))\n(defun %find-flow (src-idx dest-idx graph checked)\n  \"DFS\"\n  (declare (optimize (speed 3) (safety 0))\n           ((integer 0 #.most-positive-fixnum) src-idx dest-idx)\n           (simple-bit-vector checked)\n           ((simple-array list (*)) graph))\n  (fill checked 0)\n  (labels ((dfs (vertex flow)\n             (declare ((integer 0 #.most-positive-fixnum) flow))\n             (setf (aref checked vertex) 1)\n             (if (= vertex dest-idx)\n                 flow\n                 (dolist (edge (aref graph vertex) 0)\n                   (when (and (zerop (aref checked (edge-to edge)))\n                              (> (edge-capacity edge) 0))\n                     (let ((flow (dfs (edge-to edge) (min flow (edge-capacity edge)))))\n                       (declare ((integer 0 #.most-positive-fixnum) flow))\n                       (unless (zerop flow)\n                         (decf (edge-capacity edge) flow)\n                         (incf (edge-capacity (edge-reversed edge)) flow)\n                         (return flow))))))))\n    (dfs src-idx most-positive-fixnum)))\n\n(define-condition max-flow-overflow (simple-error)\n  ((graph :initarg :graph :reader max-flow-overflow-graph))\n  (:report\n   (lambda (condition stream)\n     (let ((*print-circle* t))\n       (format stream \"MOST-POSITIVE-FIXNUM or more units can flow on graph ~W.\"\n               (max-flow-overflow-graph condition))))))\n\n(defun max-flow! (src-idx dest-idx graph)\n  (declare (optimize (speed 3))\n           ((integer 0 #.most-positive-fixnum) src-idx dest-idx)\n           ((simple-array list (*)) graph))\n  (let ((checked (make-array (length graph) :element-type 'bit :initial-element 0))\n        (result 0))\n    (declare ((integer 0 #.most-positive-fixnum) result))\n    (loop\n      (let ((increment (%find-flow src-idx dest-idx graph checked)))\n        (cond ((zerop increment)\n               (return result))\n              ((>= (+ result increment) most-positive-fixnum)\n               (error 'max-flow-overflow :graph graph))\n              (t\n               (incf result increment)))))))\n\n(declaim (inline read-line-into))\n(defun read-line-into (buffer-string &key (in *standard-input*) (terminate-char #\\Space))\n  \"Receives ASCII inputs and returns multiple values: the string and the end\nposition.\n\nThis function calls READ-BYTE to read characters though it calls READ-CHAR\ninstead on SLIME because SLIME's IO is not bivalent.\"\n  (declare (inline read-byte)\n           #-swank (sb-kernel:ansi-stream in))\n  (loop for c of-type base-char =\n           #-swank (code-char (read-byte in nil #.(char-code #\\Newline)))\n           #+swank (read-char in nil #\\Newline)\n        for idx from 0\n        until (char= c #\\Newline)\n        do (setf (char buffer-string idx) c)\n        finally (when (< idx (length buffer-string))\n                  (setf (char buffer-string idx) terminate-char))\n                (return (values buffer-string idx))))\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;; Body\n\n(defconstant +inf+ most-positive-fixnum)\n\n(defun main ()\n  (declare #.OPT)\n  (let* ((h (read))\n         (w (read))\n         (src (* 2 h w))\n         (dest (+ 1 (* 2 h w)))\n         (graph (make-array (+ 2 (* 2 h w)) :element-type 'list :initial-element nil))\n         (line (make-string w :element-type 'base-char)))\n    (declare (uint8 h w))\n    (labels ((calc (i j dir)\n               (declare (uint8 i j))\n               (+ (if (eql dir :in) 0 1) (* 2 (+ j (* i w))))))\n      (dotimes (i h)\n        (read-line-into line)\n        (dotimes (j w)\n          (when (or (= i 0) (= i (- h 1)) (= j 0) (= j (- w 1)))\n            (push-edge (calc i j :out) dest +inf+ graph))\n          (if (char= #\\X (aref line j))\n              (progn (push-edge src (calc i j :in) +inf+ graph)\n                     (push-edge (calc i j :in) (calc i j :out) +inf+ graph))\n              (push-edge (calc i j :in) (calc i j :out) 1 graph))\n          (when (< 0 i)\n            (push-edge (calc i j :out) (calc (- i 1) j :in) +inf+ graph))\n          (when (< i (- h 1))\n            (push-edge (calc i j :out) (calc (+ i 1) j :in) +inf+ graph))\n          (when (< 0 j)\n            (push-edge (calc i j :out) (calc i (- j 1) :in) +inf+ graph))\n          (when (< j (- w 1))\n            (push-edge (calc i j :out) (calc i (+ j 1) :in) +inf+ graph))))\n      (handler-bind ((max-flow-overflow (lambda (c) (println -1) (return-from main))))\n        (println (max-flow! src dest graph))))))\n\n#-swank(main)\n"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (defparameter OPT\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0)))\n  #+swank (progn (ql:quickload '(:cl-debug-print :fiveam))\n                 (shadow :run)\n                 (use-package :fiveam)))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n\n;; BEGIN_INSERTED_CONTENTS\n;;;\n;;; Ford-Fulkerson\n;;;\n\n(declaim (inline %make-edge))\n(defstruct (edge (:constructor %make-edge))\n  (to nil :type fixnum)\n  (capacity 0 :type fixnum)\n  (reversed nil :type (or null edge)))\n\n(defun push-edge (from-idx to-idx capacity graph &key bidirectional)\n  \"FROM-IDX, TO-IDX := index of vertex\nGRAPH := vector of list of all the edges that goes from the vertex\"\n  (declare #.OPT ((simple-array list (*)) graph))\n  (let* ((dep (%make-edge :to to-idx :capacity capacity))\n         (ret (%make-edge :to from-idx\n                          :capacity (if bidirectional capacity 0)\n                          :reversed dep)))\n    (setf (edge-reversed dep) ret)\n    (push dep (aref graph from-idx))\n    (push ret (aref graph to-idx))))\n\n(defun %find-flow (src-idx dest-idx graph max-flow checked)\n  \"DFS\"\n  (declare #.OPT\n           ((integer 0 #.most-positive-fixnum) src-idx dest-idx max-flow)\n           (simple-bit-vector checked)\n           ((simple-array list (*)) graph))\n  (setf (aref checked src-idx) 1)\n  (if (= src-idx dest-idx)\n      max-flow\n      (dolist (edge (aref graph src-idx) 0)\n        (when (and (zerop (aref checked (edge-to edge)))\n                   (> (edge-capacity edge) 0))\n          (let ((flow (%find-flow (edge-to edge)\n                                  dest-idx\n                                  graph\n                                  (min max-flow (edge-capacity edge))\n                                  checked)))\n            (declare ((integer 0 #.most-positive-fixnum) flow))\n            (unless (zerop flow)\n              (decf (edge-capacity edge) flow)\n              (incf (edge-capacity (edge-reversed edge)) flow)\n              (return flow)))))))\n\n(defun max-flow (src-idx dest-idx graph)\n  (declare #.OPT\n           ((simple-array list (*)) graph))\n  (let ((checked (make-array (length graph) :element-type 'bit :initial-element 0)))\n    (loop for incr-flow of-type (integer 0 #.most-positive-fixnum)\n             = (%find-flow src-idx dest-idx graph most-positive-fixnum checked)\n          do (fill checked 0)\n          until (zerop incr-flow)\n          sum incr-flow of-type (integer 0 #.most-positive-fixnum))))\n\n(defmacro buffered-read-line (&optional (buffer-size 30) (in '*standard-input*) (terminate-char #\\Space))\n  \"Note that the returned string will be reused.\"\n  (let ((buffer (gensym))\n        (character (gensym))\n        (idx (gensym)))\n    `(let ((,buffer (load-time-value (make-string ,buffer-size\n                                                  :element-type 'base-char))))\n       (declare (simple-base-string ,buffer))\n       (loop for ,character of-type base-char =\n                #-swank (code-char (read-byte ,in nil #.(char-code #\\Newline)))\n                #+swank (read-char ,in nil #\\Newline)\n             for ,idx from 0\n             until (char= ,character #\\Newline)\n             do (setf (schar ,buffer ,idx) ,character)\n             finally (when (< ,idx ,buffer-size)\n                       (setf (schar ,buffer ,idx) ,terminate-char))\n                     (return (values ,buffer ,idx))))))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(defmacro println (obj &optional (stream '*standard-output*))\n  `(let ((*read-default-float-format* 'double-float))\n     (prog1 (princ ,obj ,stream) (terpri ,stream))))\n\n(defconstant +mod+ 1000000007)\n\n;; Hauptteil\n(defconstant +inf+ #xffffffff)\n(defun main ()\n  (declare #.OPT)\n  (let* ((h (read))\n         (w (read))\n         (h-1 (- h 1))\n         (w-1 (- w 1))\n         (graph (make-array (+ (* 2 h w) 2) :element-type 'list :initial-element nil))\n         (start-index (* 2 h w))\n         (goal-index (+ (* 2 h w) 1)))\n    (declare ((integer 1 100) h w))\n    (macrolet ((trans-coord (i j)\n                 `(* 2 (+ (* ,i w) ,j))))\n      (dotimes (i h)\n        (let ((line (buffered-read-line 100)))\n          (dotimes (j w)\n            (let ((index (trans-coord i j)))\n              (if (char= #\\X (aref line j))\n                  (progn\n                    (push-edge index (1+ index) +inf+ graph)\n                    (push-edge start-index index +inf+ graph))\n                  (push-edge index (1+ index) 1 graph))\n              (when (or (= i 0) (= j 0) (= i h-1) (= j w-1))\n                (push-edge (1+ index) goal-index +inf+ graph))\n              (unless (= i 0)\n                (push-edge (1+ index) (trans-coord (- i 1) j) +inf+ graph))\n              (unless (= j 0)\n                (push-edge (1+ index) (trans-coord i (- j 1)) +inf+ graph))\n              (unless (= i h-1)\n                (push-edge (1+ index) (trans-coord (+ i 1) j) +inf+ graph))\n              (unless (= j w-1)\n                (push-edge (1+ index) (trans-coord i (+ j 1)) +inf+ graph)))))))\n    (let ((res (max-flow start-index goal-index graph)))\n      (if (>= res +inf+)\n          (println -1)\n          (println res)))))\n\n#-swank(main)\n"
  },
  {
    "language": "Lisp",
    "code": ";; -*- coding: utf-8 -*-\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (defparameter OPT\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0)))\n  #+swank (progn (ql:quickload '(:cl-debug-print :fiveam))\n                 (shadow :run)\n                 (use-package :fiveam))\n  #-swank (set-dispatch-macro-character #\\# #\\> (lambda (s c p) (declare (ignore c p)) (read s nil (values) t))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n\n;; BEGIN_INSERTED_CONTENTS\n;;;\n;;; Max flow (Dinic's algorithm)\n;;;\n\n(setf *print-circle* t)\n\n(define-condition max-flow-overflow (simple-error)\n  ((graph :initarg :graph :reader max-flow-overflow-graph))\n  (:report (lambda (condition stream)\n             (let ((*print-circle* t))\n               (format stream \"Attempted to flow more than MOST-POSITIVE-FIXNUM on ~W.\"\n                       (max-flow-overflow-graph condition))))))\n\n(defstruct (edge (:constructor %make-edge))\n  (to nil :type (integer 0 #.most-positive-fixnum))\n  (capacity 0 :type (integer 0 #.most-positive-fixnum))\n  (reversed nil :type (or null edge)))\n\n(defun push-edge (from-idx to-idx capacity graph &optional bidirectional)\n  \"FROM-IDX, TO-IDX := index of vertex\nGRAPH := vector of lists\n\nIf BIDIRECTIONAL is true, PUSH-EDGE simultaneously adds the reversed edge of the\nsame capacity .\"\n  (declare #.OPT ((simple-array list (*)) graph))\n  (let* ((dep (%make-edge :to to-idx :capacity capacity))\n         (ret (%make-edge :to from-idx\n                          :capacity (if bidirectional capacity 0)\n                          :reversed dep)))\n    (setf (edge-reversed dep) ret)\n    (push dep (aref graph from-idx))\n    (push ret (aref graph to-idx))))\n\n(defun %fill-dist-table (src graph dist-table queue)\n  \"Does BFS and sets the distance between SRC and each vertex of GRAPH to\nDIST-TABLE. An edge of zero capacity is regarded as disconnected.\"\n  (declare #.OPT ((integer 0 #.most-positive-fixnum) src)\n           ((simple-array list (*)) graph)\n           ((simple-array (unsigned-byte 32) (*)) dist-table queue))\n  (let* ((q-front 0)\n         (q-end 0))\n    (declare ((integer 0 #.most-positive-fixnum) q-front q-end))\n    (labels ((enqueue (obj)\n               (setf (aref queue q-end) obj)\n               (incf q-end))\n             (dequeue ()\n               (prog1 (aref queue q-front)\n                 (incf q-front))))\n      (declare (inline enqueue dequeue))\n      (fill dist-table #xffffffff)\n      (setf (aref dist-table src) 0)\n      (enqueue src)\n      (loop until (= q-front q-end)\n            for vertex = (dequeue)\n            do (dolist (edge (aref graph vertex))\n                 (let ((neighbor (edge-to edge)))\n                   (when (and (> (edge-capacity edge) 0)\n                              (= #xffffffff (aref dist-table neighbor)))\n                     (setf (aref dist-table neighbor)\n                           (+ 1 (aref dist-table vertex)))\n                     (enqueue neighbor)))))))\n  dist-table)\n\n(declaim (ftype (function * (values (integer 0 #.most-positive-fixnum) &optional)) %find-path))\n(defun %find-path (src dest tmp-graph dist-table)\n  \"Finds an augmenting path, flows maximal flow through it and returns the\namount of the flow.\"\n  (declare #.OPT ((integer 0 #.most-positive-fixnum) src dest)\n           ((simple-array list (*)) tmp-graph)\n           ((simple-array (unsigned-byte 32) (*)) dist-table))\n  (labels ((dfs (v flow)\n             (declare ((integer 0 #.most-positive-fixnum) v flow))\n             (when (= v dest)\n               (return-from dfs flow))\n             (loop\n               (unless (aref tmp-graph v)\n                 (return 0))\n               (let ((edge (car (aref tmp-graph v))))\n                 (when (and (> (edge-capacity edge) 0)\n                            (< (aref dist-table v) (aref dist-table (edge-to edge))))\n                   (let ((result (dfs (edge-to edge) (min flow (edge-capacity edge)))))\n                     (declare ((integer 0 #.most-positive-fixnum) result))\n                     (when (> result 0)\n                       (decf (edge-capacity edge) result)\n                       (incf (edge-capacity (edge-reversed edge)) result)\n                       (return result)))))\n               (setf (aref tmp-graph v)\n                     (cdr (aref tmp-graph v))))))\n    (dfs src most-positive-fixnum)))\n\n(defun max-flow! (src dest graph)\n  \"Destructively flows the maximum flow from SRC to DEST and returns the amount\nof the flow.\"\n  (declare #.OPT ((integer 0 #.most-positive-fixnum) src dest)\n           ((simple-array list (*)) graph))\n  (assert (not (= src dest)))\n  (let* ((n (length graph))\n         (dist-table (make-array n :element-type '(unsigned-byte 32)))\n         (queue (make-array n :element-type '(unsigned-byte 32)))\n         (tmp-graph (make-array n :element-type 'list))\n         (result 0))\n    (declare ((integer 0 #.most-positive-fixnum) result))\n    (loop\n      (%fill-dist-table src graph dist-table queue)\n      (when (= (aref dist-table dest) #xffffffff) ; not (or no longer) connected\n        (return result))\n      (dotimes (i n)\n        (setf (aref tmp-graph i) (aref graph i)))\n      (loop for delta = (%find-path src dest tmp-graph dist-table)\n            until (zerop delta)\n            do (when (>= (+ result delta) most-positive-fixnum)\n                 (error 'max-flow-overflow :graph graph))\n               (incf result delta)))))\n\n(declaim (inline read-line-into))\n(defun read-line-into (buffer-string &key (in *standard-input*) (terminate-char #\\Space))\n  \"Receives ASCII inputs and returns multiple values: the string and the end\nposition.\n\nThis function calls READ-BYTE to read characters though it calls READ-CHAR\ninstead on SLIME because SLIME's IO is not bivalent.\"\n  (declare (inline read-byte)) ; declaring (sb-kernel:ansi-stream in) will be faster\n  (loop for c of-type base-char =\n           #-swank (code-char (read-byte in nil #.(char-code #\\Newline)))\n           #+swank (read-char in nil #\\Newline)\n        for idx from 0\n        until (char= c #\\Newline)\n        do (setf (char buffer-string idx) c)\n        finally (when (< idx (length buffer-string))\n                  (setf (char buffer-string idx) terminate-char))\n                (return (values buffer-string idx))))\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;; Body\n\n(defconstant +inf+ most-positive-fixnum)\n(defun main ()\n  (declare #.OPT)\n  (let* ((h (read))\n         (w (read))\n         (src (* 2 h w))\n         (dest (+ 1 (* 2 h w)))\n         (graph (make-array (+ 2 (* 2 h w)) :element-type 'list :initial-element nil))\n         (line (make-string w :element-type 'base-char)))\n    (declare (uint8 h w))\n    (labels ((calc (i j dir)\n               (declare (uint8 i j))\n               (+ (if (eql dir :in) 0 1) (* 2 (+ j (* i w))))))\n      (dotimes (i h)\n        (read-line-into line)\n        ;; #>line\n        (dotimes (j w)\n          (when (or (= i 0) (= i (- h 1)) (= j 0) (= j (- w 1)))\n            (push-edge (calc i j :out) dest +inf+ graph))\n          (if (char= #\\X (aref line j))\n              (progn (push-edge src (calc i j :in) +inf+ graph)\n                     (push-edge (calc i j :in) (calc i j :out) +inf+ graph))\n              (push-edge (calc i j :in) (calc i j :out) 1 graph))\n          (when (< 0 i)\n            (push-edge (calc i j :out) (calc (- i 1) j :in) +inf+ graph))\n          (when (< i (- h 1))\n            (push-edge (calc i j :out) (calc (+ i 1) j :in) +inf+ graph))\n          (when (< 0 j)\n            (push-edge (calc i j :out) (calc i (- j 1) :in) +inf+ graph))\n          (when (< j (- w 1))\n            (push-edge (calc i j :out) (calc i (+ j 1) :in) +inf+ graph))))\n      ;; #>graph\n      (handler-bind ((max-flow-overflow (lambda (c) (println -1) (return-from main))))\n        (println (max-flow! src dest graph))))))\n\n#-swank(main)\n"
  },
  {
    "language": "Lisp",
    "code": ";; -*- coding: utf-8 -*-\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (defparameter OPT\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0)))\n  #+swank (progn (ql:quickload '(:cl-debug-print :fiveam))\n                 (shadow :run)\n                 (use-package :fiveam))\n  #-swank (set-dispatch-macro-character #\\# #\\> (lambda (s c p) (declare (ignore c p)) (read s nil (values) t))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n\n;; BEGIN_INSERTED_CONTENTS\n(declaim (inline read-line-into))\n(defun read-line-into (buffer-string &key (in *standard-input*) (terminate-char #\\Space))\n  \"Receives ASCII inputs and returns multiple values: the string and the end\nposition.\n\nThis function calls READ-BYTE to read characters though it calls READ-CHAR\ninstead on SLIME because SLIME's IO is not bivalent.\"\n  (declare (inline read-byte)) ; declaring (sb-kernel:ansi-stream in) will be faster\n  (loop for c of-type base-char =\n           #-swank (code-char (read-byte in nil #.(char-code #\\Newline)))\n           #+swank (read-char in nil #\\Newline)\n        for idx from 0\n        until (char= c #\\Newline)\n        do (setf (char buffer-string idx) c)\n        finally (when (< idx (length buffer-string))\n                  (setf (char buffer-string idx) terminate-char))\n                (return (values buffer-string idx))))\n\n;;;\n;;; Max flow (Dinic's algorithm)\n;;;\n\n(setf *print-circle* t)\n\n(defstruct (edge (:constructor %make-edge))\n  (to nil :type (integer 0 #.most-positive-fixnum))\n  (capacity 0 :type (integer 0 #.most-positive-fixnum))\n  (reversed nil :type (or null edge)))\n\n(defun push-edge (from-idx to-idx capacity graph &optional bidirectional)\n  \"FROM-IDX, TO-IDX := index of vertex\nGRAPH := vector of lists\n\nIf BIDIRECTIONAL is true, PUSH-EDGE simultaneously adds the reversed edge of the\nsame capacity .\"\n  (declare ((simple-array list (*)) graph))\n  (let* ((dep (%make-edge :to to-idx :capacity capacity))\n         (ret (%make-edge :to from-idx\n                          :capacity (if bidirectional capacity 0)\n                          :reversed dep)))\n    (setf (edge-reversed dep) ret)\n    (push dep (aref graph from-idx))\n    (push ret (aref graph to-idx))))\n\n(defun %fill-dist-table (src graph dist-table queue)\n  \"Does BFS and sets the distance between SRC and each vertex of GRAPH to\nDIST-TABLE. An edge of zero capacity is regarded as disconnected.\"\n  (declare ((integer 0 #.most-positive-fixnum) src)\n           ((simple-array list (*)) graph)\n           ((simple-array (unsigned-byte 32) (*)) dist-table queue))\n  (let* ((q-front 0)\n         (q-end 0))\n    (declare ((integer 0 #.most-positive-fixnum) q-front q-end))\n    (labels ((enqueue (obj)\n               (setf (aref queue q-end) obj)\n               (incf q-end))\n             (dequeue ()\n               (prog1 (aref queue q-front)\n                 (incf q-front))))\n      (declare (inline enqueue dequeue))\n      (fill dist-table #xffffffff)\n      (setf (aref dist-table src) 0)\n      (enqueue src)\n      (loop until (= q-front q-end)\n            for vertex = (dequeue)\n            do (dolist (edge (aref graph vertex))\n                 (let ((neighbor (edge-to edge)))\n                   (when (and (> (edge-capacity edge) 0)\n                              (= #xffffffff (aref dist-table neighbor)))\n                     (setf (aref dist-table neighbor)\n                           (+ 1 (aref dist-table vertex)))\n                     (enqueue neighbor)))))))\n  dist-table)\n\n(declaim (ftype (function * (values (integer 0 #.most-positive-fixnum) &optional)) %find-path))\n(defun %find-path (src dest tmp-graph dist-table)\n  \"Finds an augmenting path, flows maximal flow through it and returns the\namount of the flow.\"\n  (declare ((integer 0 #.most-positive-fixnum) src dest)\n           ((simple-array list (*)) tmp-graph)\n           ((simple-array (unsigned-byte 32) (*)) dist-table))\n  (labels ((dfs (v flow)\n             (declare ((integer 0 #.most-positive-fixnum) v flow))\n             (when (= v dest)\n               (return-from dfs flow))\n             (loop\n               (unless (aref tmp-graph v)\n                 (return 0))\n               (let ((edge (car (aref tmp-graph v))))\n                 (when (and (> (edge-capacity edge) 0)\n                            (< (aref dist-table v) (aref dist-table (edge-to edge))))\n                   (let ((result (dfs (edge-to edge) (min flow (edge-capacity edge)))))\n                     (declare ((integer 0 #.most-positive-fixnum) result))\n                     (when (> result 0)\n                       (decf (edge-capacity edge) result)\n                       (incf (edge-capacity (edge-reversed edge)) result)\n                       (return result)))))\n               (setf (aref tmp-graph v)\n                     (cdr (aref tmp-graph v))))))\n    (dfs src most-positive-fixnum)))\n\n(defun max-flow! (src dest graph)\n  \"Destructively flows the maximum flow from SRC to DEST and returns the amount\nof the flow.\"\n  (declare ((simple-array list (*)) graph))\n  (assert (not (= src dest)))\n  (let* ((n (length graph))\n         (dist-table (make-array n :element-type '(unsigned-byte 32)))\n         (queue (make-array n :element-type '(unsigned-byte 32)))\n         (tmp-graph (make-array n :element-type 'list))\n         (result 0))\n    (declare ((integer 0 #.most-positive-fixnum) result))\n    (loop\n      (%fill-dist-table src graph dist-table queue)\n      (when (= (aref dist-table dest) #xffffffff) ; not (or no longer) connected\n        (return result))\n      (dotimes (i n)\n        (setf (aref tmp-graph i) (aref graph i)))\n      (loop for delta = (%find-path src dest tmp-graph dist-table)\n            until (zerop delta)\n            do (incf result delta)))))\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;; Body\n\n(defconstant +inf+ #xffffffff)\n(defun main ()\n  (declare #.OPT)\n  (let* ((h (read))\n         (w (read))\n         (src (* 2 h w))\n         (dest (+ 1 (* 2 h w)))\n         (graph (make-array (+ 2 (* 2 h w)) :element-type 'list :initial-element nil))\n         (line (make-string w :element-type 'base-char)))\n    (declare (uint8 h w))\n    (labels ((calc (i j dir)\n               (declare (uint8 i j))\n               (+ (if (eql dir :in) 0 1) (* 2 (+ j (* i w))))))\n      (dotimes (i h)\n        (read-line-into line)\n        ;; #>line\n        (dotimes (j w)\n          (when (or (= i 0) (= i (- h 1)) (= j 0) (= j (- w 1)))\n            (push-edge (calc i j :out) dest +inf+ graph))\n          (if (char= #\\X (aref line j))\n              (progn (push-edge src (calc i j :in) +inf+ graph)\n                     (push-edge (calc i j :in) (calc i j :out) +inf+ graph))\n              (push-edge (calc i j :in) (calc i j :out) 1 graph))\n          (when (< 0 i)\n            (push-edge (calc i j :out) (calc (- i 1) j :in) +inf+ graph))\n          (when (< i (- h 1))\n            (push-edge (calc i j :out) (calc (+ i 1) j :in) +inf+ graph))\n          (when (< 0 j)\n            (push-edge (calc i j :out) (calc i (- j 1) :in) +inf+ graph))\n          (when (< j (- w 1))\n            (push-edge (calc i j :out) (calc i (+ j 1) :in) +inf+ graph))))\n      ;; #>graph\n      (let ((res (max-flow! src dest graph)))\n        (if (>= res +inf+)\n            (println -1)\n            (println res))))))\n\n#-swank(main)\n"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (defparameter OPT\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0)))\n  #+swank (progn (ql:quickload '(:cl-debug-print :fiveam))\n                 (shadow :run)\n                 (use-package :fiveam)))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n\n;; BEGIN_INSERTED_CONTENTS\n;;;\n;;; Ford-Fulkerson\n;;;\n\n(setf *print-circle* t)\n\n(defstruct (edge (:constructor %make-edge))\n  (to nil :type fixnum)\n  (capacity 0 :type fixnum)\n  (reversed nil :type (or null edge)))\n\n(defun push-edge (from-idx to-idx capacity graph &key bidirectional)\n  \"FROM-IDX, TO-IDX := index of vertex\nGRAPH := vector of list of all the edges that goes from the vertex\"\n  (declare #.OPT ((simple-array list (*)) graph))\n  (let* ((dep (%make-edge :to to-idx :capacity capacity))\n         (ret (%make-edge :to from-idx\n                          :capacity (if bidirectional capacity 0)\n                          :reversed dep)))\n    (setf (edge-reversed dep) ret)\n    (push dep (aref graph from-idx))\n    (push ret (aref graph to-idx))))\n\n(defun %find-flow (src-idx dest-idx graph max-flow checked)\n  \"DFS\"\n  (declare #.OPT\n           ((integer 0 #.most-positive-fixnum) src-idx dest-idx max-flow)\n           (simple-bit-vector checked)\n           ((simple-array list (*)) graph))\n  (setf (aref checked src-idx) 1)\n  (if (= src-idx dest-idx)\n      max-flow\n      (dolist (edge (aref graph src-idx) 0)\n        (when (and (zerop (aref checked (edge-to edge)))\n                   (> (edge-capacity edge) 0))\n          (let ((flow (%find-flow (edge-to edge)\n                                  dest-idx\n                                  graph\n                                  (min max-flow (edge-capacity edge))\n                                  checked)))\n            (declare ((integer 0 #.most-positive-fixnum) flow))\n            (unless (zerop flow)\n              (decf (edge-capacity edge) flow)\n              (incf (edge-capacity (edge-reversed edge)) flow)\n              (return flow)))))))\n\n(defun max-flow (src-idx dest-idx graph)\n  (declare #.OPT\n           ((simple-array list (*)) graph))\n  (let ((checked (make-array (length graph) :element-type 'bit :initial-element 0)))\n    (loop for incr-flow of-type (integer 0 #.most-positive-fixnum)\n             = (%find-flow src-idx dest-idx graph most-positive-fixnum checked)\n          do (fill checked 0)\n          until (zerop incr-flow)\n          sum incr-flow of-type (integer 0 #.most-positive-fixnum))))\n\n(defmacro buffered-read-line (&optional (buffer-size 30) (in '*standard-input*) (terminate-char #\\Space))\n  \"Note that the returned string will be reused.\"\n  (let ((buffer (gensym))\n        (character (gensym))\n        (idx (gensym)))\n    `(let ((,buffer (load-time-value (make-string ,buffer-size\n                                                  :element-type 'base-char))))\n       (declare (simple-base-string ,buffer))\n       (loop for ,character of-type base-char =\n                #-swank (code-char (read-byte ,in nil #.(char-code #\\Newline)))\n                #+swank (read-char ,in nil #\\Newline)\n             for ,idx from 0\n             until (char= ,character #\\Newline)\n             do (setf (schar ,buffer ,idx) ,character)\n             finally (when (< ,idx ,buffer-size)\n                       (setf (schar ,buffer ,idx) ,terminate-char))\n                     (return (values ,buffer ,idx))))))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(defmacro println (obj &optional (stream '*standard-output*))\n  `(let ((*read-default-float-format* 'double-float))\n     (prog1 (princ ,obj ,stream) (terpri ,stream))))\n\n(defconstant +mod+ 1000000007)\n\n;; Hauptteil\n(defconstant +inf+ #xffffffff)\n(defun main ()\n  (declare #.OPT)\n  (let* ((h (read))\n         (w (read))\n         (h-1 (- h 1))\n         (w-1 (- w 1))\n         (graph (make-array (+ (* 2 h w) 2) :element-type 'list :initial-element nil))\n         (start-index (* 2 h w))\n         (goal-index (+ (* 2 h w) 1)))\n    (declare ((integer 1 100) h w))\n    (macrolet ((trans-coord (i j)\n                 `(* 2 (+ (* ,i w) ,j))))\n      (dotimes (i h)\n        (let ((line (buffered-read-line 100)))\n          (dotimes (j w)\n            (let ((index (trans-coord i j)))\n              (if (char= #\\X (aref line j))\n                  (progn\n                    (push-edge index (1+ index) +inf+ graph)\n                    (push-edge start-index index +inf+ graph))\n                  (push-edge index (1+ index) 1 graph))\n              (when (or (= i 0) (= j 0) (= i h-1) (= j w-1))\n                (push-edge (1+ index) goal-index +inf+ graph))\n              (unless (= i 0)\n                (push-edge (1+ index) (trans-coord (- i 1) j) +inf+ graph))\n              (unless (= j 0)\n                (push-edge (1+ index) (trans-coord i (- j 1)) +inf+ graph))\n              (unless (= i h-1)\n                (push-edge (1+ index) (trans-coord (+ i 1) j) +inf+ graph))\n              (unless (= j w-1)\n                (push-edge (1+ index) (trans-coord i (+ j 1)) +inf+ graph)))))))\n    (let ((res (max-flow start-index goal-index graph)))\n      (if (>= res +inf+)\n          (println -1)\n          (println res)))))\n\n#-swank(main)\n"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (defparameter OPT\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0)))\n  #+swank (progn (ql:quickload '(:cl-debug-print :fiveam))\n                 (shadow :run)\n                 (use-package :fiveam)))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n\n;; BEGIN_INSERTED_CONTENTS\n;;;\n;;; Ford-Fulkerson\n;;;\n\n(defstruct (edge (:constructor %make-edge))\n  (to nil :type fixnum)\n  (capacity 0 :type fixnum)\n  (reversed nil :type (or null edge)))\n\n(defun push-edge (from-idx to-idx capacity graph &key bidirectional)\n  \"FROM-IDX, TO-IDX := index of vertex\nGRAPH := vector of list of all the edges that goes from the vertex\"\n  (declare #.OPT ((simple-array list (*)) graph))\n  (let* ((dep (%make-edge :to to-idx :capacity capacity))\n         (ret (%make-edge :to from-idx\n                          :capacity (if bidirectional capacity 0)\n                          :reversed dep)))\n    (setf (edge-reversed dep) ret)\n    (push dep (aref graph from-idx))\n    (push ret (aref graph to-idx))))\n\n(defun %find-flow (src-idx dest-idx graph max-flow checked)\n  \"DFS\"\n  (declare #.OPT\n           ((integer 0 #.most-positive-fixnum) src-idx dest-idx max-flow)\n           (simple-bit-vector checked)\n           ((simple-array list (*)) graph))\n  (setf (aref checked src-idx) 1)\n  (if (= src-idx dest-idx)\n      max-flow\n      (dolist (edge (aref graph src-idx) 0)\n        (when (and (zerop (aref checked (edge-to edge)))\n                   (> (edge-capacity edge) 0))\n          (let ((flow (%find-flow (edge-to edge)\n                                  dest-idx\n                                  graph\n                                  (min max-flow (edge-capacity edge))\n                                  checked)))\n            (declare ((integer 0 #.most-positive-fixnum) flow))\n            (unless (zerop flow)\n              (decf (edge-capacity edge) flow)\n              (incf (edge-capacity (edge-reversed edge)) flow)\n              (return flow)))))))\n\n(defun max-flow (src-idx dest-idx graph)\n  (declare #.OPT\n           ((simple-array list (*)) graph))\n  (let ((checked (make-array (length graph) :element-type 'bit :initial-element 0)))\n    (loop for incr-flow of-type (integer 0 #.most-positive-fixnum)\n             = (%find-flow src-idx dest-idx graph most-positive-fixnum checked)\n          until (zerop incr-flow)\n          sum incr-flow of-type (integer 0 #.most-positive-fixnum)\n          do (fill checked 0))))\n\n(defmacro buffered-read-line (&optional (buffer-size 30) (in '*standard-input*) (terminate-char #\\Space))\n  \"Note that the returned string will be reused.\"\n  (let ((buffer (gensym))\n        (character (gensym))\n        (idx (gensym)))\n    `(let ((,buffer (load-time-value (make-string ,buffer-size\n                                                  :element-type 'base-char))))\n       (declare (simple-base-string ,buffer))\n       (loop for ,character of-type base-char =\n                #-swank (code-char (read-byte ,in nil #.(char-code #\\Newline)))\n                #+swank (read-char ,in nil #\\Newline)\n             for ,idx from 0\n             until (char= ,character #\\Newline)\n             do (setf (schar ,buffer ,idx) ,character)\n             finally (when (< ,idx ,buffer-size)\n                       (setf (schar ,buffer ,idx) ,terminate-char))\n                     (return (values ,buffer ,idx))))))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(defmacro println (obj &optional (stream '*standard-output*))\n  `(let ((*read-default-float-format* 'double-float))\n     (prog1 (princ ,obj ,stream) (terpri ,stream))))\n\n(defconstant +mod+ 1000000007)\n\n;; Hauptteil\n(defconstant +inf+ #xffffffff)\n(defun main ()\n  (declare #.OPT)\n  (let* ((h (read))\n         (w (read))\n         (h-1 (- h 1))\n         (w-1 (- w 1))\n         (graph (make-array (+ (* 2 h w) 2) :element-type 'list :initial-element nil))\n         (start-index (* 2 h w))\n         (goal-index (+ (* 2 h w) 1)))\n    (declare ((integer 1 100) h w))\n    (macrolet ((trans-coord (i j)\n                 `(* 2 (+ (* ,i w) ,j))))\n      (dotimes (i h)\n        (let ((line (buffered-read-line 100)))\n          (dotimes (j w)\n            (let ((index (trans-coord i j)))\n              (if (char= #\\X (aref line j))\n                  (progn\n                    (push-edge index (1+ index) +inf+ graph)\n                    (push-edge start-index index +inf+ graph))\n                  (push-edge index (1+ index) 1 graph))\n              (when (or (= i 0) (= j 0) (= i h-1) (= j w-1))\n                (push-edge (1+ index) goal-index +inf+ graph))\n              (unless (= i 0)\n                (push-edge (1+ index) (trans-coord (- i 1) j) +inf+ graph))\n              (unless (= j 0)\n                (push-edge (1+ index) (trans-coord i (- j 1)) +inf+ graph))\n              (unless (= i h-1)\n                (push-edge (1+ index) (trans-coord (+ i 1) j) +inf+ graph))\n              (unless (= j w-1)\n                (push-edge (1+ index) (trans-coord i (+ j 1)) +inf+ graph)))))))\n    (let ((res (max-flow start-index goal-index graph)))\n      (if (>= res +inf+)\n          (println -1)\n          (println res)))))\n\n#-swank(main)\n"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (defparameter OPT\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0)))\n  #+swank (progn (ql:quickload '(:cl-debug-print :fiveam))\n                 (shadow :run)\n                 (use-package :fiveam)))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n\n;; BEGIN_INSERTED_CONTENTS\n;;;\n;;; Ford-Fulkerson\n;;;\n\n(setf *print-circle* t)\n\n(defstruct (edge (:constructor %make-edge))\n  (to nil :type fixnum)\n  (capacity 0 :type fixnum)\n  (flow 0 :type fixnum)\n  (reversed nil :type (or null edge)))\n\n(defun push-edge (from-idx to-idx capacity graph &key bidirectional)\n  \"FROM-IDX, TO-IDX := index of vertex\nGRAPH := vector of list of all the edges that goes from the vertex\"\n  (declare #.OPT ((simple-array list (*)) graph))\n  (let* ((dep (%make-edge :to to-idx :capacity capacity))\n         (ret (%make-edge :to from-idx\n                          :capacity (if bidirectional capacity 0)\n                          :reversed dep)))\n    (setf (edge-reversed dep) ret)\n    (push dep (aref graph from-idx))\n    (push ret (aref graph to-idx))))\n\n(defun %find-flow (src-idx dest-idx graph max-flow checked)\n  \"DFS\"\n  (declare #.OPT\n           ((integer 0 #.most-positive-fixnum) src-idx dest-idx max-flow)\n           (simple-bit-vector checked)\n           ((simple-array list (*)) graph))\n  (setf (aref checked src-idx) 1)\n  (if (= src-idx dest-idx)\n      max-flow\n      (dolist (edge (aref graph src-idx) 0)\n        (when (and (zerop (aref checked (edge-to edge)))\n                   (< (edge-flow edge) (edge-capacity edge)))\n          (let ((flow (%find-flow (edge-to edge)\n                                  dest-idx\n                                  graph\n                                  (min max-flow (- (edge-capacity edge) (edge-flow edge)))\n                                  checked)))\n            (declare ((integer 0 #.most-positive-fixnum) flow))\n            (unless (zerop flow)\n              (incf (edge-flow edge) flow)\n              (incf (edge-capacity (edge-reversed edge)) flow)\n              (return flow)))))))\n\n(defun max-flow (src-idx dest-idx graph)\n  (declare #.OPT\n           ((simple-array list (*)) graph))\n  (let ((checked (make-array (length graph) :element-type 'bit :initial-element 0)))\n    (loop for incr-flow of-type (integer 0 #.most-positive-fixnum)\n             = (%find-flow src-idx dest-idx graph most-positive-fixnum checked)\n          do (fill checked 0)\n          until (zerop incr-flow)\n          sum incr-flow of-type (integer 0 #.most-positive-fixnum))))\n\n(defmacro buffered-read-line (&optional (buffer-size 30) (in '*standard-input*) (terminate-char #\\Space))\n  \"Note that the returned string will be reused.\"\n  (let ((buffer (gensym))\n        (character (gensym))\n        (idx (gensym)))\n    `(let ((,buffer (load-time-value (make-string ,buffer-size\n                                                  :element-type 'base-char))))\n       (declare (simple-base-string ,buffer))\n       (loop for ,character of-type base-char =\n                #-swank (code-char (read-byte ,in nil #.(char-code #\\Newline)))\n                #+swank (read-char ,in nil #\\Newline)\n             for ,idx from 0\n             until (char= ,character #\\Newline)\n             do (setf (schar ,buffer ,idx) ,character)\n             finally (when (< ,idx ,buffer-size)\n                       (setf (schar ,buffer ,idx) ,terminate-char))\n                     (return (values ,buffer ,idx))))))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(defmacro println (obj &optional (stream '*standard-output*))\n  `(let ((*read-default-float-format* 'double-float))\n     (prog1 (princ ,obj ,stream) (terpri ,stream))))\n\n(defconstant +mod+ 1000000007)\n\n;; Hauptteil\n(defconstant +inf+ #xffffffff)\n(defun main ()\n  (declare #.OPT)\n  (let* ((h (read))\n         (w (read))\n         (h-1 (- h 1))\n         (w-1 (- w 1))\n         (graph (make-array (+ (* 2 h w) 2) :element-type 'list :initial-element nil))\n         (start-index (* 2 h w))\n         (goal-index (+ (* 2 h w) 1)))\n    (declare ((integer 1 100) h w))\n    (macrolet ((trans-coord (i j)\n                 `(* 2 (+ (* ,i w) ,j))))\n      (dotimes (i h)\n        (let ((line (buffered-read-line 100)))\n          (dotimes (j w)\n            (let ((index (trans-coord i j)))\n              (if (char= #\\X (aref line j))\n                  (progn\n                    (push-edge index (1+ index) +inf+ graph)\n                    (push-edge start-index index +inf+ graph))\n                  (push-edge index (1+ index) 1 graph))\n              (when (or (= i 0) (= j 0) (= i h-1) (= j w-1))\n                (push-edge (1+ index) goal-index +inf+ graph))\n              (unless (= i 0)\n                (push-edge (1+ index) (trans-coord (- i 1) j) +inf+ graph))\n              (unless (= j 0)\n                (push-edge (1+ index) (trans-coord i (- j 1)) +inf+ graph))\n              (unless (= i h-1)\n                (push-edge (1+ index) (trans-coord (+ i 1) j) +inf+ graph))\n              (unless (= j w-1)\n                (push-edge (1+ index) (trans-coord i (+ j 1)) +inf+ graph)))))))\n    (let ((res (max-flow start-index goal-index graph)))\n      (if (>= res +inf+)\n          (println -1)\n          (println res)))))\n\n#-swank(main)\n"
  },
  {
    "language": "Lisp",
    "code": ";; -*- coding: utf-8 -*-\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (defparameter OPT\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0)))\n  #+swank (progn (ql:quickload '(:cl-debug-print :fiveam))\n                 (shadow :run)\n                 (use-package :fiveam))\n  #-swank (set-dispatch-macro-character #\\# #\\> (lambda (s c p) (declare (ignore c p)) (read s nil (values) t))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n\n;; BEGIN_INSERTED_CONTENTS\n;;;\n;;; Max flow (Dinic's algorithm)\n;;;\n\n(setf *print-circle* t)\n\n(defconstant +graph-max-distance+ #xffffffff)\n\n(define-condition max-flow-overflow (simple-error)\n  ((graph :initarg :graph :reader max-flow-overflow-graph))\n  (:report\n   (lambda (condition stream)\n     (let ((*print-circle* t))\n       (format stream \"MOST-POSITIVE-FIXNUM or more units can flow on graph ~W.\"\n               (max-flow-overflow-graph condition))))))\n\n(defstruct (edge (:constructor %make-edge))\n  (to nil :type (integer 0 #.most-positive-fixnum))\n  (capacity 0 :type (integer 0 #.most-positive-fixnum))\n  (reversed nil :type (or null edge)))\n\n(defun push-edge (from-idx to-idx capacity graph &optional bidirectional)\n  \"FROM-IDX, TO-IDX := index of vertex\nGRAPH := vector of lists\n\nIf BIDIRECTIONAL is true, PUSH-EDGE adds the reversed edge of the same capacity\nin addition.\"\n  (declare (optimize (speed 3))\n           ((integer 0 #.most-positive-fixnum) from-idx to-idx)\n           ((simple-array list (*)) graph))\n  (let* ((dep (%make-edge :to to-idx :capacity capacity))\n         (ret (%make-edge :to from-idx\n                          :capacity (if bidirectional capacity 0)\n                          :reversed dep)))\n    (setf (edge-reversed dep) ret)\n    (push dep (aref graph from-idx))\n    (push ret (aref graph to-idx))))\n\n(defun %fill-dist-table (src graph dist-table queue)\n  \"Does BFS and sets the distance between SRC and each vertex of GRAPH to\nDIST-TABLE, where an edge of zero capacity is regarded as disconnected.\"\n  (declare (optimize (speed 3) (safety 0))\n           ((integer 0 #.most-positive-fixnum) src)\n           ((simple-array list (*)) graph)\n           ((simple-array (unsigned-byte 32) (*)) dist-table queue))\n  (let* ((q-front 0)\n         (q-end 0))\n    (declare ((integer 0 #.most-positive-fixnum) q-front q-end))\n    (labels ((enqueue (obj)\n               (setf (aref queue q-end) obj)\n               (incf q-end))\n             (dequeue ()\n               (prog1 (aref queue q-front)\n                 (incf q-front))))\n      (declare (inline enqueue dequeue))\n      (fill dist-table +graph-max-distance+)\n      (setf (aref dist-table src) 0)\n      (enqueue src)\n      (loop until (= q-front q-end)\n            for vertex = (dequeue)\n            do (dolist (edge (aref graph vertex))\n                 (let ((neighbor (edge-to edge)))\n                   (when (and (> (edge-capacity edge) 0)\n                              (= +graph-max-distance+ (aref dist-table neighbor)))\n                     (setf (aref dist-table neighbor)\n                           (+ 1 (aref dist-table vertex)))\n                     (enqueue neighbor)))))))\n  dist-table)\n\n(declaim (ftype (function * (values (integer 0 #.most-positive-fixnum) &optional)) %find-path))\n(defun %find-path (src dest tmp-graph dist-table)\n  \"Finds an augmenting path, sends the maximal flow through it, and returns the\namount of the flow.\"\n  (declare (optimize (speed 3) (safety 0))\n           ((integer 0 #.most-positive-fixnum) src dest)\n           ((simple-array list (*)) tmp-graph)\n           ((simple-array (unsigned-byte 32) (*)) dist-table))\n  (labels ((dfs (v flow)\n             (declare ((integer 0 #.most-positive-fixnum) v flow))\n             (when (= v dest)\n               (return-from dfs flow))\n             (loop\n               (unless (aref tmp-graph v)\n                 (return 0))\n               (let ((edge (car (aref tmp-graph v))))\n                 (when (and (> (edge-capacity edge) 0)\n                            (< (aref dist-table v) (aref dist-table (edge-to edge))))\n                   (let ((result (dfs (edge-to edge) (min flow (edge-capacity edge)))))\n                     (declare ((integer 0 #.most-positive-fixnum) result))\n                     (when (> result 0)\n                       (decf (edge-capacity edge) result)\n                       (incf (edge-capacity (edge-reversed edge)) result)\n                       (return result)))))\n               (setf (aref tmp-graph v)\n                     (cdr (aref tmp-graph v))))))\n    (dfs src most-positive-fixnum)))\n\n(defun max-flow! (src dest graph)\n  \"Destructively sends the maximal flow from SRC to DEST and returns the amount\nof the flow. This function signals MAX-FLOW-OVERFLOW error when an infinite\nflow (to be precise, >= MOST-POSITIVE-FIXNUM) is possible.\"\n  (declare ((integer 0 #.most-positive-fixnum) src dest)\n           ((simple-array list (*)) graph))\n  (let* ((n (length graph))\n         (dist-table (make-array n :element-type '(unsigned-byte 32)))\n         (queue (make-array n :element-type '(unsigned-byte 32)))\n         (tmp-graph (make-array n :element-type 'list))\n         (result 0))\n    (declare ((integer 0 #.most-positive-fixnum) result))\n    (loop\n      (%fill-dist-table src graph dist-table queue)\n      (when (= (aref dist-table dest) +graph-max-distance+) ; not (or no longer) connected\n        (return result))\n      (dotimes (i n)\n        (setf (aref tmp-graph i) (aref graph i)))\n      (loop for delta = (%find-path src dest tmp-graph dist-table)\n            until (zerop delta)\n            do (when (>= (+ result delta) most-positive-fixnum)\n                 (error 'max-flow-overflow :graph graph))\n               (incf result delta)))))\n\n(declaim (inline read-line-into))\n(defun read-line-into (buffer-string &key (in *standard-input*) (terminate-char #\\Space))\n  \"Receives ASCII inputs and returns multiple values: the string and the end\nposition.\n\nThis function calls READ-BYTE to read characters though it calls READ-CHAR\ninstead on SLIME because SLIME's IO is not bivalent.\"\n  (declare (inline read-byte)\n           #-swank (sb-kernel:ansi-stream in))\n  (loop for c of-type base-char =\n           #-swank (code-char (read-byte in nil #.(char-code #\\Newline)))\n           #+swank (read-char in nil #\\Newline)\n        for idx from 0\n        until (char= c #\\Newline)\n        do (setf (char buffer-string idx) c)\n        finally (when (< idx (length buffer-string))\n                  (setf (char buffer-string idx) terminate-char))\n                (return (values buffer-string idx))))\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;; Body\n\n(defconstant +inf+ most-positive-fixnum)\n\n(defun main ()\n  (declare #.OPT)\n  (let* ((h (read))\n         (w (read))\n         (src (* 2 h w))\n         (dest (+ 1 (* 2 h w)))\n         (graph (make-array (+ 2 (* 2 h w)) :element-type 'list :initial-element nil))\n         (line (make-string w :element-type 'base-char)))\n    (declare (uint8 h w))\n    (labels ((calc (i j dir)\n               (declare (uint8 i j))\n               (+ (if (eql dir :in) 0 1) (* 2 (+ j (* i w))))))\n      (dotimes (i h)\n        (read-line-into line)\n        (dotimes (j w)\n          (when (or (= i 0) (= i (- h 1)) (= j 0) (= j (- w 1)))\n            (push-edge (calc i j :out) dest +inf+ graph))\n          (if (char= #\\X (aref line j))\n              (progn (push-edge src (calc i j :in) +inf+ graph)\n                     (push-edge (calc i j :in) (calc i j :out) +inf+ graph))\n              (push-edge (calc i j :in) (calc i j :out) 1 graph))\n          (when (< 0 i)\n            (push-edge (calc i j :out) (calc (- i 1) j :in) +inf+ graph))\n          (when (< i (- h 1))\n            (push-edge (calc i j :out) (calc (+ i 1) j :in) +inf+ graph))\n          (when (< 0 j)\n            (push-edge (calc i j :out) (calc i (- j 1) :in) +inf+ graph))\n          (when (< j (- w 1))\n            (push-edge (calc i j :out) (calc i (+ j 1) :in) +inf+ graph))))\n      (handler-bind ((max-flow-overflow (lambda (c) (println -1) (return-from main))))\n        (println (max-flow! src dest graph))))))\n\n#-swank(main)\n"
  },
  {
    "language": "Lisp",
    "code": ";; -*- coding: utf-8 -*-\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (defparameter OPT\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0)))\n  #+swank (progn (ql:quickload '(:cl-debug-print :fiveam))\n                 (shadow :run)\n                 (use-package :fiveam))\n  #-swank (set-dispatch-macro-character #\\# #\\> (lambda (s c p) (declare (ignore c p)) (read s nil (values) t))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n\n;; BEGIN_INSERTED_CONTENTS\n(declaim (inline read-line-into))\n(defun read-line-into (buffer-string &key (in *standard-input*) (terminate-char #\\Space))\n  \"Receives ASCII inputs and returns multiple values: the string and the end\nposition.\n\nThis function calls READ-BYTE to read characters though it calls READ-CHAR\ninstead on SLIME because SLIME's IO is not bivalent.\"\n  (declare (inline read-byte)) ; declaring (sb-kernel:ansi-stream in) will be faster\n  (loop for c of-type base-char =\n           #-swank (code-char (read-byte in nil #.(char-code #\\Newline)))\n           #+swank (read-char in nil #\\Newline)\n        for idx from 0\n        until (char= c #\\Newline)\n        do (setf (char buffer-string idx) c)\n        finally (when (< idx (length buffer-string))\n                  (setf (char buffer-string idx) terminate-char))\n                (return (values buffer-string idx))))\n\n;;;\n;;; Max flow (Dinic's algorithm)\n;;;\n\n(setf *print-circle* t)\n\n(defstruct (edge (:constructor %make-edge))\n  (to nil :type (integer 0 #.most-positive-fixnum))\n  (capacity 0 :type (integer 0 #.most-positive-fixnum))\n  (reversed nil :type (or null edge)))\n\n(defun push-edge (from-idx to-idx capacity graph &optional bidirectional)\n  \"FROM-IDX, TO-IDX := index of vertex\nGRAPH := vector of lists\n\nIf BIDIRECTIONAL is true, PUSH-EDGE simultaneously adds the reversed edge of the\nsame capacity .\"\n  (declare (optimize (speed 3))\n           ((simple-array list (*)) graph))\n  (let* ((dep (%make-edge :to to-idx :capacity capacity))\n         (ret (%make-edge :to from-idx\n                          :capacity (if bidirectional capacity 0)\n                          :reversed dep)))\n    (setf (edge-reversed dep) ret)\n    (push dep (aref graph from-idx))\n    (push ret (aref graph to-idx))))\n\n(defun %fill-dist-table (src graph dist-table queue)\n  \"Does BFS and sets the distance between SRC and each vertex of GRAPH to\nDIST-TABLE. An edge of zero capacity is regarded as disconnected.\"\n  (declare (optimize (speed 3) (safety 0))\n           ((integer 0 #.most-positive-fixnum) src)\n           ((simple-array list (*)) graph)\n           ((simple-array (unsigned-byte 32) (*)) dist-table queue))\n  (let* ((q-front 0)\n         (q-end 0))\n    (declare ((integer 0 #.most-positive-fixnum) q-front q-end))\n    (labels ((enqueue (obj)\n               (setf (aref queue q-end) obj)\n               (incf q-end))\n             (dequeue ()\n               (prog1 (aref queue q-front)\n                 (incf q-front))))\n      (declare (inline enqueue dequeue))\n      (fill dist-table #xffffffff)\n      (setf (aref dist-table src) 0)\n      (enqueue src)\n      (loop until (= q-front q-end)\n            for vertex = (dequeue)\n            do (dolist (edge (aref graph vertex))\n                 (let ((neighbor (edge-to edge)))\n                   (when (and (> (edge-capacity edge) 0)\n                              (= #xffffffff (aref dist-table neighbor)))\n                     (setf (aref dist-table neighbor)\n                           (+ 1 (aref dist-table vertex)))\n                     (enqueue neighbor)))))))\n  dist-table)\n\n(declaim (ftype (function * (values (integer 0 #.most-positive-fixnum) &optional)) %find-path))\n(defun %find-path (src dest tmp-graph dist-table)\n  \"Finds an augmenting path, flows maximal flow through it and returns the\namount of the flow.\"\n  (declare (optimize (speed 3) (safety 0))\n           ((integer 0 #.most-positive-fixnum) src dest)\n           ((simple-array list (*)) tmp-graph)\n           ((simple-array (unsigned-byte 32) (*)) dist-table))\n  (labels ((dfs (v flow)\n             (declare ((integer 0 #.most-positive-fixnum) v flow))\n             (when (= v dest)\n               (return-from dfs flow))\n             (loop\n               (unless (aref tmp-graph v)\n                 (return 0))\n               (let ((edge (car (aref tmp-graph v))))\n                 (when (and (> (edge-capacity edge) 0)\n                            (< (aref dist-table v) (aref dist-table (edge-to edge))))\n                   (let ((result (dfs (edge-to edge) (min flow (edge-capacity edge)))))\n                     (declare ((integer 0 #.most-positive-fixnum) result))\n                     (when (> result 0)\n                       (decf (edge-capacity edge) result)\n                       (incf (edge-capacity (edge-reversed edge)) result)\n                       (return result)))))\n               (setf (aref tmp-graph v)\n                     (cdr (aref tmp-graph v))))))\n    (dfs src most-positive-fixnum)))\n\n(defun max-flow! (src dest graph)\n  \"Destructively flows the maximum flow from SRC to DEST and returns the amount\nof the flow.\"\n  (declare (optimize (speed 3))\n           ((integer 0 #.most-positive-fixnum) src dest)\n           ((simple-array list (*)) graph))\n  (assert (not (= src dest)))\n  (let* ((n (length graph))\n         (dist-table (make-array n :element-type '(unsigned-byte 32)))\n         (queue (make-array n :element-type '(unsigned-byte 32)))\n         (tmp-graph (make-array n :element-type 'list))\n         (result 0))\n    (declare ((integer 0 #.most-positive-fixnum) result))\n    (loop\n      (%fill-dist-table src graph dist-table queue)\n      (when (= (aref dist-table dest) #xffffffff) ; not (or no longer) connected\n        (return result))\n      (dotimes (i n)\n        (setf (aref tmp-graph i) (aref graph i)))\n      (loop for delta = (%find-path src dest tmp-graph dist-table)\n            until (zerop delta)\n            do (incf result delta)))))\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;; Body\n\n(defconstant +inf+ #xffffffff)\n(defun main ()\n  (declare #.OPT)\n  (let* ((h (read))\n         (w (read))\n         (src (* 2 h w))\n         (dest (+ 1 (* 2 h w)))\n         (graph (make-array (+ 2 (* 2 h w)) :element-type 'list :initial-element nil))\n         (line (make-string w :element-type 'base-char)))\n    (declare (uint8 h w))\n    (labels ((calc (i j dir)\n               (declare (uint8 i j))\n               (+ (if (eql dir :in) 0 1) (* 2 (+ j (* i w))))))\n      (dotimes (i h)\n        (read-line-into line)\n        ;; #>line\n        (dotimes (j w)\n          (when (or (= i 0) (= i (- h 1)) (= j 0) (= j (- w 1)))\n            (push-edge (calc i j :out) dest +inf+ graph))\n          (if (char= #\\X (aref line j))\n              (progn (push-edge src (calc i j :in) +inf+ graph)\n                     (push-edge (calc i j :in) (calc i j :out) +inf+ graph))\n              (push-edge (calc i j :in) (calc i j :out) 1 graph))\n          (when (< 0 i)\n            (push-edge (calc i j :out) (calc (- i 1) j :in) +inf+ graph))\n          (when (< i (- h 1))\n            (push-edge (calc i j :out) (calc (+ i 1) j :in) +inf+ graph))\n          (when (< 0 j)\n            (push-edge (calc i j :out) (calc i (- j 1) :in) +inf+ graph))\n          (when (< j (- w 1))\n            (push-edge (calc i j :out) (calc i (+ j 1) :in) +inf+ graph))))\n      ;; #>graph\n      (let ((res (max-flow! src dest graph)))\n        (if (>= res +inf+)\n            (println -1)\n            (println res))))))\n\n#-swank(main)\n"
  },
  {
    "language": "Lisp",
    "code": ";; -*- coding: utf-8 -*-\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (defparameter OPT\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0)))\n  #+swank (progn (ql:quickload '(:cl-debug-print :fiveam))\n                 (shadow :run)\n                 (use-package :fiveam))\n  #-swank (set-dispatch-macro-character #\\# #\\> (lambda (s c p) (declare (ignore c p)) (read s nil (values) t))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n\n;; BEGIN_INSERTED_CONTENTS\n(declaim (inline read-line-into))\n(defun read-line-into (buffer-string &key (in *standard-input*) (terminate-char #\\Space))\n  \"Receives ASCII inputs and returns multiple values: the string and the end\nposition.\n\nThis function calls READ-BYTE to read characters though it calls READ-CHAR\ninstead on SLIME because SLIME's IO is not bivalent.\"\n  (declare (inline read-byte)) ; declaring (sb-kernel:ansi-stream in) will be faster\n  (loop for c of-type base-char =\n           #-swank (code-char (read-byte in nil #.(char-code #\\Newline)))\n           #+swank (read-char in nil #\\Newline)\n        for idx from 0\n        until (char= c #\\Newline)\n        do (setf (char buffer-string idx) c)\n        finally (when (< idx (length buffer-string))\n                  (setf (char buffer-string idx) terminate-char))\n                (return (values buffer-string idx))))\n\n;;;\n;;; Max flow (Dinic's algorithm)\n;;;\n\n(setf *print-circle* t)\n\n(defstruct (edge (:constructor %make-edge))\n  (to nil :type (integer 0 #.most-positive-fixnum))\n  (capacity 0 :type (integer 0 #.most-positive-fixnum))\n  (reversed nil :type (or null edge)))\n\n(defun push-edge (from-idx to-idx capacity graph &optional bidirectional)\n  \"FROM-IDX, TO-IDX := index of vertex\nGRAPH := vector of lists\n\nIf BIDIRECTIONAL is true, PUSH-EDGE simultaneously adds the reversed edge of the\nsame capacity .\"\n  (declare ((simple-array list (*)) graph))\n  (let* ((dep (%make-edge :to to-idx :capacity capacity))\n         (ret (%make-edge :to from-idx\n                          :capacity (if bidirectional capacity 0)\n                          :reversed dep)))\n    (setf (edge-reversed dep) ret)\n    (push dep (aref graph from-idx))\n    (push ret (aref graph to-idx))))\n\n(defun %fill-dist-table (src graph dist-table queue)\n  \"Does BFS and sets the distance between SRC and each vertex of GRAPH to\nDIST-TABLE. An edge of zero capacity is regarded as disconnected.\"\n  (declare ((integer 0 #.most-positive-fixnum) src)\n           ((simple-array list (*)) graph)\n           ((simple-array (unsigned-byte 32) (*)) dist-table queue))\n  (let* ((q-front 0)\n         (q-end 0))\n    (declare ((integer 0 #.most-positive-fixnum) q-front q-end))\n    (labels ((enqueue (obj)\n               (setf (aref queue q-end) obj)\n               (incf q-end))\n             (dequeue ()\n               (prog1 (aref queue q-front)\n                 (incf q-front))))\n      (declare (inline enqueue dequeue))\n      (fill dist-table #xffffffff)\n      (setf (aref dist-table src) 0)\n      (enqueue src)\n      (loop until (= q-front q-end)\n            for vertex = (dequeue)\n            do (dolist (edge (aref graph vertex))\n                 (let ((neighbor (edge-to edge)))\n                   (when (and (> (edge-capacity edge) 0)\n                              (= #xffffffff (aref dist-table neighbor)))\n                     (setf (aref dist-table neighbor)\n                           (+ 1 (aref dist-table vertex)))\n                     (enqueue neighbor)))))))\n  dist-table)\n\n(declaim (ftype (function * (values (integer 0 #.most-positive-fixnum) &optional)) %find-path))\n(defun %find-path (src dest tmp-graph dist-table)\n  \"Finds an augmenting path, flows maximal flow through it and returns the\namount of the flow.\"\n  (declare ((integer 0 #.most-positive-fixnum) src dest)\n           ((simple-array list (*)) tmp-graph)\n           ((simple-array (unsigned-byte 32) (*)) dist-table))\n  (labels ((dfs (v flow)\n             (declare ((integer 0 #.most-positive-fixnum) v flow))\n             (when (= v dest)\n               (return-from dfs flow))\n             (loop\n               (unless (aref tmp-graph v)\n                 (return 0))\n               (let ((edge (car (aref tmp-graph v))))\n                 (when (and (> (edge-capacity edge) 0)\n                            (< (aref dist-table v) (aref dist-table (edge-to edge))))\n                   (let ((result (dfs (edge-to edge) (min flow (edge-capacity edge)))))\n                     (declare ((integer 0 #.most-positive-fixnum) result))\n                     (when (> result 0)\n                       (decf (edge-capacity edge) result)\n                       (incf (edge-capacity (edge-reversed edge)) result)\n                       (return result)))))\n               (setf (aref tmp-graph v)\n                     (cdr (aref tmp-graph v))))))\n    (dfs src most-positive-fixnum)))\n\n(defun max-flow! (src dest graph)\n  \"Destructively flows the maximum flow from SRC to DEST and returns the amount\nof the flow.\"\n  (declare ((simple-array list (*)) graph))\n  (assert (not (= src dest)))\n  (let* ((n (length graph))\n         (dist-table (make-array n :element-type '(unsigned-byte 32)))\n         (queue (make-array n :element-type '(unsigned-byte 32)))\n         (tmp-graph (make-array n :element-type 'list))\n         (result 0))\n    (declare ((integer 0 #.most-positive-fixnum) result))\n    (loop\n      (%fill-dist-table src graph dist-table queue)\n      (when (= (aref dist-table dest) #xffffffff) ; not (or no longer) connected\n        (return result))\n      (dotimes (i n)\n        (setf (aref tmp-graph i) (aref graph i)))\n      (loop for delta = (%find-path src dest tmp-graph dist-table)\n            until (zerop delta)\n            do (incf result delta)))))\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;; Body\n\n(defconstant +inf+ #xffffffff)\n(defun main ()\n  (let* ((h (read))\n         (w (read))\n         (src (* 2 h w))\n         (dest (+ 1 (* 2 h w)))\n         (graph (make-array (+ 2 (* 2 h w)) :element-type 'list :initial-element nil))\n         (line (make-string w :element-type 'base-char)))\n    (labels ((calc (i j in)\n               ;; (dbg i j in)\n               (+ (if in 0 1) (* 2 (+ j (* i w))))))\n      (dotimes (i h)\n        (read-line-into line)\n        ;; #>line\n        (dotimes (j w)\n          (when (or (= i 0) (= i (- h 1)) (= j 0) (= j (- w 1)))\n            (push-edge (calc i j nil) dest +inf+ graph))\n          (if (char= #\\X (aref line j))\n              (progn (push-edge src (calc i j t) +inf+ graph)\n                     (push-edge (calc i j t) (calc i j nil) +inf+ graph))\n              (push-edge (calc i j t) (calc i j nil) 1 graph))\n          (when (< 0 i)\n            (push-edge (calc i j nil) (calc (- i 1) j t) +inf+ graph))\n          (when (< i (- h 1))\n            (push-edge (calc i j nil) (calc (+ i 1) j t) +inf+ graph))\n          (when (< 0 j)\n            (push-edge (calc i j nil) (calc i (- j 1) t) +inf+ graph))\n          (when (< j (- w 1))\n            (push-edge (calc i j nil) (calc i (+ j 1) t) +inf+ graph))))\n      ;; #>graph\n      (let ((res (max-flow! src dest graph)))\n        (if (>= res +inf+)\n            (println -1)\n            (println res))))))\n\n#-swank(main)\n\n\n;; For Test\n#+swank\n(defun io-equal (in-string out-string &optional (func #'main))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNC, and returns true if the\nstring output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (and (> (length s) 0)\n                      (eql (char s (- (length s) 1)) #\\Linefeed))\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (equal (ensure-last-lf out-string)\n           (with-output-to-string (out)\n             (let ((*standard-output* out))\n               (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                 (funcall func)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    (run-program \"C:/msys64/usr/bin/cat.exe\" '(\"/dev/clipboard\") :output out)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null ; Runs #'MAIN with the string on clipboard\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname ; Runs #'MAIN with the string in a text file\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"4 5\n.....\n.....\n..X..\n.....\n\"\n    \"4\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"2 2\n..\n.X\n\"\n    \"-1\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"6 6\n......\n......\n..X...\n.X..X.\n..X...\n......\n\"\n    \"10\n\")))\n"
  },
  {
    "language": "Ruby",
    "code": "h,w=gets.split.map &:to_i\nw+=1\nsrc=$<.read\n\ns=src.tr(\"X.\\n\",\"10\").to_i 2\nm=src.tr(\"\\n.X\",\"10\").to_i 2\nif ( (s | (s >> w * (h-1)) ) & ( ( 1 << w) - 1 )| (s & (m << 1 | m >> 1))).nonzero? then\n  puts -1\n  exit\nend\n\na = ~s & s << 1\nb = ~s & s\t>> 1\nc = ~s & s << w\nd = ~s & s >> w\n\ns|= a&b|a&c|a&d|b&c|b&d|c&d\n\ns|=s << 1 | s >> 1 | s << w | s >> w\n\ns=(~s >>1 &s) |( ~s << 1&s ) | (~s >> w &s )|(~s << w & s)\nputs s.to_s(2).count \"1\""
  },
  {
    "language": "Ruby",
    "code": "# 行先, 容量, 逆辺\nEdge = Struct.new(:to, :cap, :rev)\n\n# Dinic 法で最大流を解く\nclass Dinic\n  def initialize(n)\n    @G = Array.new(n){[]} # グラフの隣接リスト表現\n    @level = Array.new(n) # s からの距離\n    @iter = Array.new(n)  # どこまで調べ終わったか\n  end\n  \n  # from -> to へ向かう容量 cap の辺をグラフに追加\n  def add_edge(from, to, cap)\n    @G[from] << Edge.new(to, cap, @G[to].size)\n    @G[to]   << Edge.new(from, 0, @G[from].size - 1)\n  end\n  \n  # s からの最短距離を BFS で計算\n  def bfs(s)\n    @level.fill(-1)\n    @level[s] = 0\n    queue = [s]\n    until queue.empty?\n      v = queue.shift\n      @G[v].each do |e|\n        if e.cap > 0 and @level[e.to] < 0\n          @level[e.to] = @level[v] + 1\n          queue << e.to\n        end\n      end\n    end\n  end\n  \n  # 増加パスを DFS で探索\n  def dfs(v, t, f)\n    return f if v == t\n    (@iter[v]...@G[v].size).each do |i|\n      e = @G[v][i]\n      if e.cap > 0 and @level[v] < @level[e.to]\n        d = dfs(e.to, t, [f, e.cap].min)\n        if d > 0\n          e.cap -= d\n          @G[e.to][e.rev].cap += d\n          return d\n        end\n      end\n    end\n    0\n  end\n  \n  # s から t への最大流を計算\n  def max_flow(s, t)\n    flow = 0\n    loop do\n      bfs(s)\n      return flow if @level[t] < 0\n      @iter.fill(0)\n      while (f = dfs(s, t, Float::INFINITY)) > 0\n        flow += f\n      end\n    end\n  end\nend\n\nH, W = gets.split.map(&:to_i)\nF = Array.new(H) { gets.chomp.split(\"\") }\nS, T = 2 * H * W, 2 * H * W + 1\n\ndc = Dinic.new(2 * H * W + 2)\nH.times do |i|\n  W.times do |j|\n    iid = i * W + j\n    oid = H * W + iid\n    if F[i][j] == \"X\"\n      dc.add_edge(S, iid, Float::INFINITY)\n      dc.add_edge(iid, oid, Float::INFINITY)\n    else\n      dc.add_edge(iid, oid, 1)\n    end\n    \n    [ [1,0], [-1,0], [0,1], [0,-1] ].each do |di, dj|\n      x = (i + di).between?(0, H-1) ? (i + di) : -1\n      y = (j + dj).between?(0, W-1) ? (j + dj) : -1\n      \n      if x == -1 or y == -1\n        dc.add_edge(oid, T, Float::INFINITY)\n      else\n        dc.add_edge(oid, x * W + y, Float::INFINITY)\n      end\n    end\n  end\nend\n\nans = dc.max_flow(S, T)\nputs ans == Float::INFINITY ? -1 : ans"
  },
  {
    "language": "Ruby",
    "code": "h,w=gets.split.map &:to_i\nw+=1\nsrc=$<.read\n\ns=src.tr(\"X.\\n\",\"10\").to_i 2\nm=src.tr(\"\\n.X\",\"10\").to_i 2\n\nif ( (s | (s >> w * (h-1)) | (s & (m << 1 | m >> 1))) & ( ( 1 << w) - 1) ).nonzero? then\n  puts -1\n  exit\nend\n\ns|=s << 1 | s >> 1 | s << w | s >> w\n\ns=(~s >>1 &s) |( ~s << 1&s ) | (~s >> w &s )|(~s << w & s)\n#puts sprintf(\"%0#{h*w}b\",s).to_s.scan(/.{#{w}}/)                                                            \nputs s.to_s(2).count \"1\""
  },
  {
    "language": "Ruby",
    "code": "H,W = gets.split.map(&:to_i)\n*C = (0...H).map{ gets.chomp.split(\"\") }\n#$stderr.puts C.map{ |row| row.join }\nS = H*W\nG = H*W+1\nInf = 10**15\nes = (0..G+H*W+1).map{ {} }\n\n(0...H).each{ |i|\n  si = C[i]\n  (0...W).each{ |j|\n    t = i*W+j\n    if si[j] == \"X\"\n      es[S][t] = Inf\n      es[t][S] = 0\n      es[t][t+G+1] = Inf\n    else\n      es[t][t+G+1] = 1\n    end\n    es[t+G+1][t] = 0\n    [[i,0,-W], [i,H-1,+W], [j,0,-1], [j,W-1,+1]].each{ |s,v,u|\n      if s == v\n        es[t+G+1][G] = Inf\n        es[G][t+G+1] = 0\n      else\n        es[t+G+1][t+u] = es[t+u+G+1][t] = Inf\n        es[t+u][t+G+1] = es[t][t+u+G+1] = 0\n      end\n    }\n  }\n}\n\n\nif (0...H*W).any?{ |t| es[t+G+1][G] && C[t/W][t%W] == \"X\" }\n  p -1; exit\nend\n\ndef dash_flow(es, visited, n, sink, flow)\n  stack = [[nil,n,flow]]\n  visited[n] = true\n  #p e\n\n  maxflow = nil\n  back = nil\n  tail = nil\n  trail = []\n  #p es[n]\n  while pp = stack.pop\n    s,t,f = pp\n    visited[t] = true\n    trail << pp\n    #p trail\n    if t == sink\n      back = s\n      maxflow = f\n      tail = t\n      break\n    end\n    es[t].each{ |m,c|\n      if !visited[m] && c > 0\n        stack << [t,m,f > c ? c : f]\n      end\n    }\n  end\n  return nil if !maxflow\n  #p trail\n  trail.reverse_each{ |s,t,f|\n    if t == tail\n      if s\n        #p [s,t,f]\n        #p [es[s][t]]\n        es[s][t] -= maxflow\n        es[t][s] += maxflow\n        tail = s\n      end\n    end\n  }\n  maxflow\nend\n\nvisited = Array.new(G+1, nil)\nans = 0\n#p [S,G]\n#p es[S].keys\nwhile f = dash_flow(es, visited, S, G, Inf)\n  visited.map!{ nil }\n  #p $trail.reverse\n  #p es[S]\n  ans += f\nend\n\np ans\n"
  },
  {
    "language": "Ruby",
    "code": "h,w=gets.split.map &:to_i\nw+=1\nsrc=$<.read\n\ns=src.tr(\"X.\\n\",\"10\").to_i 2\nm=src.tr(\"\\n.X\",\"10\").to_i 2\nif ( (s | (s >> w * (h-1)) ) & ( ( 1 << w) - 1 )| (s & (m << 1 | m >> 1))).nonzero? then\n  puts -1\n  exit\nend\n\ns|=s << 1 | s >> 1 | s << w | s >> w\n\ns=(~s >>1 &s) |( ~s << 1&s ) | (~s >> w &s )|(~s << w & s)\nputs s.to_s(2).count \"1\"\n"
  },
  {
    "language": "Ruby",
    "code": "H,W = gets.split.map(&:to_i)\n*C = (0...H).map{ gets.chomp.split(\"\") }\nS = H*W\nG = H*W+1\nInf = 10**15\nes = (0..G+H*W+1).map{ {} }\n\n(0...H).each{ |i|\n  si = C[i]\n  (0...W).each{ |j|\n    t = i*W+j\n    if si[j] == \"X\"\n      es[S][t] = Inf\n      es[t][S] = 0\n      es[t][t+G+1] = Inf\n    else\n      es[t][t+G+1] = 1    \n    end\n    es[t+G+1][t] = 0\n    [[i,0,-W], [i,H-1,+W], [j,0,-1], [j,W-1,+1]].each{ |s,v,u|\n      if s == v\n        es[t+G+1][G] = Inf\n        es[G][t+G+1] = 0\n      else\n        es[t+G+1][t+u] = es[t+u+G+1][t] = Inf\n        es[t+u][t+G+1] = es[t][t+u+G+1] = 0\n      end\n    }\n  }\n}\n\nif (0...H*W).any?{ |t| es[t+G+1][G] && C[t/W][t%W] == \"X\" }\n  p -1; exit\nend\n\n$trail = []\ndef dash_flow(es, visited, n, sink, flow)\n  return flow if n == sink\n  visited[n] = true\n  e = es[n]  \n  f = nil\n  #p e\n  e.each{ |m,c|\n    if !visited[m] && c > 0\n      f = dash_flow(es, visited, m, sink, flow > c ? c : flow)\n      if f && f > 0\n        $trail << m\n        e[m] -= f\n        es[m][n] += f\n        break\n      end\n    end\n  }\n  f\nend\n\nvisited = Array.new(G+1, nil)\nans = 0\n#p [S,G]\n#p es[S].keys\nwhile f = dash_flow(es, visited, S, G, Inf)\n  visited.map!{ nil }\n  #p $trail.reverse\n  #p es[S]\n  ans += f\nend\n\np ans\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nfscanf(STDIN, '%d %d', $H, $W);\n$masu = array_pad([], $H, array_pad([], $W, 0));\n\nfor ($i = 0; $i < $H; $i++) {\n\tfscanf(STDIN, '%s', $S);\n\t$S = str_split($S);\n\tfor ($j = 0; $j < $W; $j++) {\n\t\tif ($S[$j] === 'X') {\n\t\t\tif ($i === 0 || $i === $H - 1 || $j === 0 || $j === $W - 1) {\n\t\t\t\techo '-1'.PHP_EOL;\n\t\t\t\texit;\n\t\t\t}\n\t\t\t$masu[$i][$j] = 1;\n\t\t\tif ($masu[$i-1][$j] === 0) $masu[$i-1][$j] = 2;\n\t\t\tif ($masu[$i][$j-1] === 0) $masu[$i][$j-1] = 2;\n\t\t\tif ($masu[$i+1][$j] === 0) $masu[$i+1][$j] = 2;\n\t\t\tif ($masu[$i][$j+1] === 0) $masu[$i][$j+1] = 2;\n\t\t}\n\t}\n}\n$result = 0;\nfor ($i = 0; $i < $H; $i++) {\n\tfor ($j = 0; $j < $W; $j++) {\n\t\tif ($masu[$i][$j] === 2) {\n\t\t\t$q = [[$i, $j]];\n\t\t\t$first = true;\n\t\t\t$chk = array_pad([], $H, array_pad([], $W, false));\n\t\t\twhile (count($q) > 0) {\n\t\t\t\t$t = array_shift($q);\n\t\t\t\t$_i = $t[0];\n\t\t\t\t$_j = $t[1];\n\t\t\t\tif (!$first && $masu[$_i][$_j] > 0) continue;\n\t\t\t\t$first = false;\n\t\t\t\tif ($_i === 0 || $_i === $H - 1 || $_j === 0 || $_j === $W - 1) {\n\t\t\t\t\t$result++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!$chk[$_i-1][$_j]) {\n\t\t\t\t\t$chk[$_i-1][$_j] = true;\n\t\t\t\t\tarray_push($q, [$_i-1, $_j]);\n\t\t\t\t}\n\t\t\t\tif (!$chk[$_i][$_j-1]) {\n\t\t\t\t\t$chk[$_i][$_j-1] = true;\n\t\t\t\t\tarray_push($q, [$_i, $_j-1]);\n\t\t\t\t}\n\t\t\t\tif (!$chk[$_i+1][$_j]) {\n\t\t\t\t\t$chk[$_i+1][$_j] = true;\n\t\t\t\t\tarray_push($q, [$_i+1, $_j]);\n\t\t\t\t}\n\t\t\t\tif (!$chk[$_i][$_j+1]) {\n\t\t\t\t\t$chk[$_i][$_j+1] = true;\n\t\t\t\t\tarray_push($q, [$_i, $_j+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\necho $result.PHP_EOL;"
  },
  {
    "language": "PHP",
    "code": "<?php\nfscanf(STDIN, '%d %d', $H, $W);\n$masu = array_pad([], $H, array_pad([], $W, 0));\n\n$result = 0;\nfor ($i = 0; $i < $H; $i++) {\n\tfscanf(STDIN, '%s', $S);\n\t$S = str_split($S);\n\tfor ($j = 0; $j < $W; $j++) {\n\t\tif ($S[$j] === 'X') {\n\t\t\tif ($i === 0 || $i === $H - 1 || $j === 0 || $j === $W - 1) {\n\t\t\t\t$result = -1;\n\t\t\t}\n\t\t\t$masu[$i][$j] = 1;\n\t\t\tif ($masu[$i-1][$j] === 0) $masu[$i-1][$j] = 2;\n\t\t\tif ($masu[$i][$j-1] === 0) $masu[$i][$j-1] = 2;\n\t\t\tif ($masu[$i+1][$j] === 0) $masu[$i+1][$j] = 2;\n\t\t\tif ($masu[$i][$j+1] === 0) $masu[$i][$j+1] = 2;\n\t\t}\n\t}\n}\nif ($result === -1) {\n\techo $result.PHP_EOL;\n\texit;\n}\nfor ($i = 0; $i < $H; $i++) {\n\tfor ($j = 0; $j < $W; $j++) {\n\t\tif ($masu[$i][$j] === 2) {\n\t\t\t$q = [[$i, $j]];\n\t\t\t$first = true;\n\t\t\t$chk = array_pad([], $H, array_pad([], $W, false));\n\t\t\twhile (count($q) > 0) {\n\t\t\t\t$t = array_shift($q);\n\t\t\t\t$_i = $t[0];\n\t\t\t\t$_j = $t[1];\n\t\t\t\tif (!$first && $masu[$_i][$_j] > 0) continue;\n\t\t\t\t$first = false;\n\t\t\t\tif ($_i === 0 || $_i === $H - 1 || $_j === 0 || $_j === $W - 1) {\n\t\t\t\t\t$result++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!$chk[$_i-1][$_j]) {\n\t\t\t\t\t$chk[$_i-1][$_j] = true;\n\t\t\t\t\tarray_push($q, [$_i-1, $_j]);\n\t\t\t\t}\n\t\t\t\tif (!$chk[$_i][$_j-1]) {\n\t\t\t\t\t$chk[$_i][$_j-1] = true;\n\t\t\t\t\tarray_push($q, [$_i, $_j-1]);\n\t\t\t\t}\n\t\t\t\tif (!$chk[$_i+1][$_j]) {\n\t\t\t\t\t$chk[$_i+1][$_j] = true;\n\t\t\t\t\tarray_push($q, [$_i+1, $_j]);\n\t\t\t\t}\n\t\t\t\tif (!$chk[$_i][$_j+1]) {\n\t\t\t\t\t$chk[$_i][$_j+1] = true;\n\t\t\t\t\tarray_push($q, [$_i, $_j+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\necho $result.PHP_EOL;"
  },
  {
    "language": "PHP",
    "code": "<?php\nfscanf(STDIN, '%d %d', $H, $W);\n$masu = array_pad([], $H, array_pad([], $W, 0));\n\nfor ($i = 0; $i < $H; $i++) {\n\tfscanf(STDIN, '%s', $S);\n\t$S = str_split($S);\n\tfor ($j = 0; $j < $W; $j++) {\n\t\tif ($S[$j] === 'X') {\n\t\t\tif ($i === 0 || $i === $H - 1 || $j === 0 || $j === $W - 1) {\n\t\t\t\techo '-1'.PHP_EOL;\n\t\t\t\texit;\n\t\t\t}\n\t\t\t$masu[$i][$j] = 1;\n\t\t\tif ($masu[$i-1][$j] === 0) $masu[$i-1][$j] = 2;\n\t\t\tif ($masu[$i][$j-1] === 0) $masu[$i][$j-1] = 2;\n\t\t\tif ($masu[$i+1][$j] === 0) $masu[$i+1][$j] = 2;\n\t\t\tif ($masu[$i][$j+1] === 0) $masu[$i][$j+1] = 2;\n\t\t}\n\t}\n}\n$result = 0;\nfor ($i = 0; $i < $H; $i++) {\n\tfor ($j = 0; $j < $W; $j++) {\n\t\tif ($masu[$i][$j] === 2) {\n\t\t\tif ($i === 0 || $i === $H || $j === 0 || $j === $W ||\n\t\t\t\t$masu[$i-1][$j] === 0 ||\n\t\t\t\t$masu[$i][$j-1] === 0 ||\n\t\t\t\t$masu[$i+1][$j] === 0 ||\n\t\t\t\t$masu[$i][$j+1] === 0\n\t\t\t\t) {\n\t\t\t\t$result++;\n\t\t\t}\n\t\t}\n\t}\n}\necho $result.PHP_EOL;"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.7.4\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv, std.math;\n\nimport std.typecons;\n\n// import dcomp.foundation, dcomp.scanner;\n// import dcomp.dungeon;\n// import dcomp.graph.maxflow;\n\nint main() {\n    auto sc = new Scanner(stdin);\n    int h, w;\n    sc.read(h, w);\n    auto dh = DungeonHelper(h, w);\n    struct Edge {int to, cap, rev;}\n    Edge[][] g = new Edge[][](2*h*w+2);\n    int n = h*w;\n    int sv = 2*h*w, tv = sv+1;\n    void addEdge(int from, int to, int cap) {\n        g[from] ~= Edge(to, cap, g[to].length.to!int);\n        g[to] ~= Edge(from, 0, g[from].length.to!int-1);\n    }\n    int id(int x, int y) {\n        return y * w + x;\n    }\n    foreach (y; 0..h) {\n        string s;\n        sc.read(s);\n        foreach (x; 0..w) {\n            addEdge(n+id(x, y), id(x, y), 1);\n\n            bool f = s[x] == 'X';\n            if (f) addEdge(sv, id(x, y), 100000);\n\n            foreach (d; 0..4) {\n                int[2] np = dh.move([x, y], d);\n                int nx = np[0], ny = np[1];\n                if (!dh.isInside(np)) {\n                    if (f) {\n                        writeln(\"-1\");\n                        return 0;\n                    }\n                    addEdge(id(x, y), tv, 100000);\n                } else {\n                    addEdge(id(x, y), n+id(nx, ny), 100000);\n                }\n            }\n        }\n    }\n\n    writeln(g.maxFlow!(int, 0)(sv, tv).flow);\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/dungeon.d */\n// module dcomp.dungeon;\n\n\n \nstruct DungeonHelper {\n     \n    immutable static int[2][4] d4 = [\n        [1, 0], [0, 1], [-1, 0], [0, -1],\n    ];\n     \n    immutable static int[2][8] d8 = [\n        [1, 0],\n        [1, 1],\n        [0, 1],\n        [-1, 1],\n        [-1, 0],\n        [-1, -1],\n        [0, -1],\n        [1, -1],\n    ];\n    int h, w;\n     \n    this(int h, int w) {\n        this.h = h; this.w = w;\n    }\n     \n    bool isInside(int[2] p) const {\n        int x = p[0], y = p[1];\n        return 0 <= x && x < w && 0 <= y && y < h;\n    }\n     \n    int getID(int[2] p) const {\n        int x = p[0], y = p[1];\n        return y*w+x;\n    }\n     \n    int[2] move(int[2] p, int dir) const {\n        int[2] res;\n        res[] = p[] + d4[dir][];\n        return res;\n    }\n     \n    int[2] move8(int[2] p, int dir) const {\n        int[2] res;\n        res[] = p[] + d8[dir][];\n        return res;\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/array.d */\n// module dcomp.array;\n\n \nT[N] fixed(T, size_t N)(T[N] a) {return a;}\n\n \n \n\n \nstruct FastAppender(A, size_t MIN = 4) {\n    import std.algorithm : max;\n    import std.conv;\n    import std.range.primitives : ElementEncodingType;\n    import core.stdc.string : memcpy;\n\n    private alias T = ElementEncodingType!A;\n    private T* _data;\n    private uint len, cap;\n     \n    @property size_t length() const {return len;}\n    bool empty() const { return len == 0; }\n     \n    void reserve(size_t nlen) {\n        import core.memory : GC;\n        if (nlen <= cap) return;\n        \n        void* nx = GC.malloc(nlen * T.sizeof);\n\n        cap = nlen.to!uint;\n        if (len) memcpy(nx, _data, len * T.sizeof);\n        _data = cast(T*)(nx);\n    }\n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }\n     \n    void opOpAssign(string op : \"~\")(T item) {\n        if (len == cap) {\n            reserve(max(MIN, cap*2));\n        }\n        _data[len++] = item;\n    }\n     \n    void insertBack(T item) {\n        this ~= item;\n    }\n     \n    void removeBack() {\n        len--;\n    }\n     \n    void clear() {\n        len = 0;\n    }\n    ref inout(T) back() inout { assert(len); return _data[len-1]; }\n    ref inout(T) opIndex(size_t i) inout { return _data[i]; }\n     \n    T[] data() {\n        return (_data) ? _data[0..len] : null;\n    }\n}\n\n \n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/container/deque.d */\n// module dcomp.container.deque;\n\nstruct DequePayload(T) {\n    import core.exception : RangeError;\n    import core.memory : GC;\n    import std.range : ElementType, isInputRange;\n    import std.traits : isImplicitlyConvertible;\n    T *d;\n    size_t st, length, cap;\n    @property bool empty() const { return length == 0; }\n    alias opDollar = length;\n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (length <= i) throw new RangeError();\n        return d[(st+i >= cap) ? (st+i-cap) : st+i];\n    }\n    private void expand() {\n        import std.algorithm : max;\n        assert(length == cap);\n        auto nc = max(size_t(4), 2*cap);\n        T* nd = cast(T*)GC.malloc(nc * T.sizeof);\n        foreach (i; 0..length) {\n            nd[i] = this[i];\n        }\n        d = nd; st = 0; cap = nc;\n    }\n    void clear() {\n        st = length = 0;\n    }\n    void insertFront(T v) {\n        if (length == cap) expand();\n        if (st == 0) st += cap;\n        st--; length++;\n        this[0] = v; \n    }\n    void insertBack(T v) {\n        if (length == cap) expand();\n        length++;\n        this[length-1] = v; \n    }\n    void removeFront() {\n        assert(!empty, \"Deque.removeFront: Deque is empty\");        \n        st++; length--;\n        if (st == cap) st = 0;\n    }\n    void removeBack() {\n        assert(!empty, \"Deque.removeBack: Deque is empty\");        \n        length--;\n    }\n    \n    ref inout(T) front() inout { return this[0]; }\n    ref inout(T) back() inout { return this[$-1]; }\n    Range opSlice() {return Range(&this, 0, length); }\n    \n    alias Range = RangeT!(DequePayload!T);\n    alias ConstRange = RangeT!(const DequePayload!T);\n    alias ImmutableRange = RangeT!(immutable DequePayload!T);\n\n    static struct RangeT(A) {\n        import std.traits : CopyTypeQualifiers;\n        alias E = CopyTypeQualifiers!(A, T);\n        A *p;\n        size_t a, b;\n        @property bool empty() const { return b <= a; }\n        @property size_t length() const { return b-a; }\n        @property RangeT save() { return RangeT(p, a, b); }\n        @property RangeT!(const A) save() const {\n            return typeof(return)(p, a, b);\n        }\n        alias opDollar = length;\n        @property ref inout(E) front() inout { return (*p)[a]; }\n        @property ref inout(E) back() inout { return (*p)[b-1]; }\n        void popFront() {\n            version(assert) if (empty) throw new RangeError();\n            a++;\n        }\n        void popBack() {\n            version(assert) if (empty) throw new RangeError();\n            b--;\n        }\n        ref inout(E) opIndex(size_t i) inout { return (*p)[i]; }\n        RangeT opSlice() { return this.save; }\n        RangeT opSlice(size_t i, size_t j) {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n        RangeT!(const A) opSlice() const { return this.save; }\n        RangeT!(const A) opSlice(size_t i, size_t j) const {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n    }\n}\n\n\n \nstruct Deque(T, bool mayNull = true) {\n    import core.exception : RangeError;\n    import core.memory : GC;\n    import std.range : ElementType, isInputRange;\n    import std.traits : isImplicitlyConvertible;\n\n    alias Payload = DequePayload!T;\n    alias Range = Payload.Range;\n    alias ConstRange = Payload.ConstRange;\n    alias ImmutableRange = Payload.ImmutableRange;\n    \n    Payload* p;\n    private void I() { if (mayNull && !p) p = new Payload(); }\n    private void C() const {\n        version(assert) if (mayNull && !p) throw new RangeError();\n    }\n    static if (!mayNull) {\n        @disable this();\n    }\n     \n    private this(Payload* p) {\n        this.p = p;\n    }\n    this(U)(U[] values...) if (isImplicitlyConvertible!(U, T)) {\n        p = new Payload();\n        foreach (v; values) {\n            insertBack(v);\n        }\n    }\n     \n    this(Range)(Range r)\n    if (isInputRange!Range &&\n    isImplicitlyConvertible!(ElementType!Range, T) &&\n    !is(Range == T[])) {\n        p = new Payload();\n        foreach (v; r) {\n            insertBack(v);\n        }\n    }\n    static Deque make() { return Deque(new Payload()); }\n    @property bool havePayload() const { return (!mayNull || p); }\n     \n    @property bool empty() const { return (!havePayload || p.empty); }\n     \n    @property size_t length() const { return (havePayload ? p.length : 0); }\n     \n    alias opDollar = length;\n    ref inout(T) opIndex(size_t i) inout {C; return (*p)[i]; }\n     \n    ref inout(T) front() inout {C; return (*p)[0]; }\n     \n    ref inout(T) back() inout {C; return (*p)[$-1]; }\n    void clear() { if (p) p.clear(); }\n     \n    void insertFront(T v) {I; p.insertFront(v); }\n     \n    void insertBack(T v) {I; p.insertBack(v); }\n     \n    alias stableInsertBack = insertBack;\n     \n    void removeFront() {C; p.removeFront(); }\n     \n    void removeBack() {C; p.removeBack(); }\n     \n    Range opSlice() {I; return Range(p, 0, length); }\n}\n\n \n \n\n \n\n \n\n \n\n \n\n \n\n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\n// import dcomp.array;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                FastAppender!(E[]) buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/graph/maxflow.d */\n// module dcomp.graph.maxflow;\n\n// import dcomp.container.deque, dcomp.array;\n\n \nstruct MaxFlowInfo(C) {\n    C flow;  \n    bool[] dual;  \n}\n\n \nMaxFlowInfo!(C) maxFlow(C, C EPS, T)(T g, int s, int t) {\n    assert(s != t);\n    import std.algorithm : map;\n    import std.range : array;\n    import std.conv : to;\n    int n = g.length.to!int;\n    int[] level = new int[n];\n    int[] iter = new int[n];\n\n    void bfs() {\n        level[] = -1; level[s] = 0;\n        auto que = Deque!int();\n        que.insertBack(s);\n        while (!que.empty) {\n            int v = que.front; que.removeFront;\n            foreach (e; g[v]) {\n                if (e.cap <= EPS) continue;\n                if (level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    que.insertBack(e.to);\n                }\n            }\n        }\n    }\n\n    C dfs(int v, C f) {\n        import std.algorithm : min;\n        if (v == t) return f;\n        C res = 0;\n        auto edgeList = g[v][iter[v]..$];\n        foreach (ref e; edgeList) {\n            if (e.cap <= EPS) continue;\n            if (level[v] >= level[e.to]) continue;            \n            C d = dfs(e.to, min(f, e.cap));\n            e.cap -= d;\n            g[e.to][e.rev].cap += d;\n            res += d;\n            f -= d;\n            if (f == 0) break;\n            iter[v]++;\n        }\n        return res;\n    }\n\n    C flow = 0;\n    while (true) {\n        bfs();\n        if (level[t] < 0) break;\n        iter[] = 0;\n        while (true) {\n            C f = dfs(s, C.max);\n            if (!f) break;\n            flow += f;\n        }\n    }\n\n    auto mfInfo = MaxFlowInfo!C();\n    mfInfo.flow = flow;\n    mfInfo.dual = level.map!\"a == -1\".array;\n    return mfInfo;\n}\n\n\n \n \n\n\n \n\n \n\n/*\nThis source code generated by dcomp and include dcomp's source code.\ndcomp's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dcomp)\ndcomp's License: MIT License(https://github.com/yosupo06/dcomp/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "Bash",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mem(x,n) memset(x,n,sizeof(x))\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,l) for(auto it=(l).begin();it!=(l).end();it++)\n#define pnl printf(\"\\n\")\n#define len(x) (x).length()\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\nconst double EPS=1e-10;\n//const double PI=acos(-1.0);\nconst int INF=1<<30;\nconst LL LLINF=1ll<<60;\nconst int MOD=1e9+7;\nconst int xx[8]={1,0,-1,0,1,-1,1,-1};\nconst int yy[8]={0,1,0,-1,-1,1,1,-1};\n\n/****************************************************************************************\\\n  __    __               __ /\\/|   ___ _           _       /\\/|__               __    __\n  \\ \\  / /  _____ __ ____\\ \\/\\/   / __| |__ _ _ __(_)___  |/\\// /____ __ _____  \\ \\  / /\n   \\ \\| |  |___\\ V  V /___| |    | (__| / _` | '_ \\ / -_)    | |___\\ V  V /___|  | |/ /\n    \\_\\ |  |___|\\_/\\_/|___| |     \\___|_\\__,_| .__/_\\___|    | |___|\\_/\\_/|___|  | /_/\n       \\_\\               /_/                 |_|              \\_\\               /_/\n\\****************************************************************************************/\n\nchar input[105][105];\nint cnt[105][105];\n\nint main(){\n\tint r,c;\n\tscanf(\"%d%d\",&r,&c);\n\tgetchar();\n\tfor(int i=0;i<r;i++){\n\t\tscanf(\"%s\",input[i]);\n\t}\n\t\n\tfor(int i=0;i<r;i++){\n\t\tint mini=INF,maxi=-1;\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(input[i][j]=='X'){\n\t\t\t\tmini=min(mini,j);\n\t\t\t\tmaxi=max(maxi,j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(mini==INF&&maxi==-1) continue;\n\t\tfor(int j=mini;j<=maxi;j++){\n\t\t\tcnt[i][j]=1;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(cnt[i][j]==1){\n\t\t\t\tfor(int ii=0;ii<4;ii++){\n\t\t\t\t\tint tempx = xx[ii]+i;\n\t\t\t\t\tint tempy = yy[ii]+j;\n\t\t\t\t\t\n\t\t\t\t\tif(tempx<0||tempx>=r||tempy<0||tempy>=c){\n\t\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt[tempx][tempy]==1) continue;\n\t\t\t\t\t\n\t\t\t\t\tcnt[tempx][tempy]=2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans=0;\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(cnt[i][j]==2) ans++;\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n\t\t\n\treturn 0;\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(´・ω・`)(´・ω・`)(´・ω・`)(´・ω・`)(´・ω・`)(´・ω・`)///\nstruct edge { int to, cap, rev, cost; };\n\nconstexpr int MAX_V = 10002;\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost = 0) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n}\n\nvoid bfs(int s) {\n\tfill_n(level, MAX_V, -1);\n\tqueue<int> q;\n\tlevel[s] = 0;\n\tq.push(s);\n\twhile (!q.empty()) {\n\t\tint v = q.front(); q.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nint dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nll max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0)return flow;\n\t\tfill_n(iter, MAX_V, 0);\n\t\tint f;\n\t\twhile ((f = dfs(s, t, numeric_limits<int>::max())) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> v(h);\n\tREP(i, h)cin >> v[i];\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tREP(k, 4) {\n\t\t\t\tint ni = i + dy[2*k], nj = j + dx[2*k];\n\t\t\t\tif (ni < 0 || ni == h || nj < 0 || nj == w) {\n\t\t\t\t\tadd_edge(i*w + j + 1+h*w, 2*h*w + 1, INF);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tadd_edge(i*w + j + 1+h*w, ni*w + nj + 1, 1);\n\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (v[i][j] == 'X') {\n\t\t\t\tadd_edge(0, i*w + j + 1, INF);\n\t\t\t\tadd_edge(i*w + j + 1, i*w + j + 1 + w*h, INF);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(i*w + j + 1, i*w + j + 1 + w*h, 1);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tll ans = max_flow(0, 2 * w*h + 1);\n\tif (ans >= INF)cout << -1 << endl;\n\telse cout<<ans << endl;\n}\n"
  },
  {
    "language": "Nim",
    "code": "# ========= utils/base.nim ========= {{{\n\nwhen not declared(INCLUDE_GUARD_UTILS_BASE_NIM):\n  const INCLUDE_GUARD_UTILS_BASE_NIM = 1\n  import macros\n  macro Please(x): untyped = nnkStmtList.newTree()\n\n  Please give me AC\n  Please give me AC\n  Please give me AC\n\n  {.hints: off, overflowChecks: on.}\n\n  import strutils, sequtils, math, algorithm\n  when (not (NimMajor <= 0)) or NimMinor >= 19:\n    import sugar\n  else:\n    import future\n\n  iterator range(x, y: int): int {.inline.} =\n    var res = x\n    while res < y:\n      yield res\n      inc(res)\n  iterator range(x: int): int {.inline.} =\n    var res = 0\n    while res < x:\n      yield res\n      inc(res)\n  proc range(x, y: int): seq[int] {.inline.} =\n    toSeq(x..y-1)\n  proc range(x: int): seq[int] {.inline.} =\n    toSeq(0..x-1)\n  proc discardableId[T](x: T): T {.discardable.} =\n    return x\n  macro `:=`(x, y: untyped): untyped =\n    if (x.kind == nnkIdent):\n      return quote do:\n        when declared(`x`):\n          `x` = `y`\n        else:\n          var `x` = `y`\n        discardableId(`x`)\n    else:\n      return quote do:\n        `x` = `y`\n        discardableId(`x`)\n  when NimMajor <= 0 and NimMinor <= 17:\n    proc count[T](co: openArray[T]; obj: T): int =\n      for itm in items(co):\n        if itm == obj:\n          inc result\n  proc divmod(x, y: SomeInteger): (int, int) =\n    (x div y, x mod y)\n  proc `min=`[T](x: var T; y: T): bool {.discardable.} =\n    if x > y:\n      x = y\n      return true\n    else:\n      return false\n  proc `max=`[T](x: var T; y: T): bool {.discardable.} =\n    if x < y:\n      x = y\n      return true\n    else:\n      return false\n\n  when NimMajor <= 0 and NimMinor <= 17:\n    iterator pairs(n: NimNode): (int, NimNode) {.inline.} =\n      for i in 0 ..< n.len:\n        yield (i, n[i])\n\n  #[\n  when NimMajor <= 0 and NimMinor <= 18:\n    macro parseInnerType(x: NimNode): untyped =\n      newIdentNode(\"parse\" & x[1][1].repr)\n  else:\n    macro parseInnerType(x: typedesc): untyped =\n      newIdentNode(\"parse\" & x.getType[1][1].repr)\n  ]#\n\n  proc parseInnerType(x: NimNode): NimNode =\n    newIdentNode(\"parse\" & x[1].repr)\n\n  proc inputAsTuple(ty: NimNode): NimNode =\n    result = nnkStmtListExpr.newTree()\n    t := genSym()\n    result.add quote do: (let `t` = stdin.readLine.split)\n    p := nnkPar.newTree()\n    for i, typ_tmp in ty.pairs:\n      var ece, typ: NimNode\n      if typ_tmp.kind == nnkExprColonExpr:\n        ece = nnkExprColonExpr.newTree(typ_tmp[0])\n        typ = typ_tmp[1]\n      else:\n        ece = nnkExprColonExpr.newTree(ident(\"f\" & $i))\n        typ = typ_tmp\n      if typ.repr == \"string\":\n        ece.add quote do: `t`[`i`]\n      else:\n        parsefn := newIdentNode(\"parse\" & typ.repr)\n        ece.add quote do: `t`[`i`].`parsefn`\n      p.add ece\n    result.add p\n\n  macro inputAsType(ty: untyped): untyped =\n    if ty.kind == nnkBracketExpr:\n      if ty[1].repr == \"string\":\n        return quote do: stdin.readLine.split\n      else:\n        parsefn := parseInnerType(ty)\n        return quote do: stdin.readLine.split.map(`parsefn`)\n        #[\n          when NimMajor <= 0 and NimMinor <= 18:\n            stdin.readLine.split.map(parseInnerType(ty.getType))\n          else:\n            stdin.readLine.split.map(parseInnerType(ty))\n        ]#\n    elif ty.kind == nnkPar:\n      return inputAsTuple(ty)\n    elif ty.repr == \"string\":\n      return quote do: stdin.readLine\n    else:\n      parsefn := ident(\"parse\" & ty.repr)\n      return quote do: stdin.readLine.`parsefn`\n\n  macro input(query: untyped): untyped =\n    doAssert query.kind == nnkStmtList\n    result = nnkStmtList.newTree()\n    letSect := nnkLetSection.newTree()\n    for defs in query:\n      if defs[0].kind == nnkIdent:\n        tmp := nnkIdentDefs.newTree(defs[0], newEmptyNode())\n        typ := defs[1][0]\n        var val: NimNode\n        if typ.len <= 2:\n          val = quote do: inputAsType(`typ`)\n        else:\n          op := typ[2]\n          typ.del(2, 1)\n          val = quote do: inputAsType(`typ`).mapIt(`op`)\n        if defs[1].len > 1:\n          op := defs[1][1]\n          it := ident\"it\"\n          tmp.add quote do:\n            block:\n              var `it` = `val`\n              `op`\n        else:\n          tmp.add val\n        letSect.add tmp\n      elif defs[0].kind == nnkPar:\n        vt := nnkVarTuple.newTree()\n        for id in defs[0]:\n          vt.add id\n        vt.add newEmptyNode()\n        sle := nnkStmtListExpr.newTree()\n        t := genSym()\n        sle.add quote do: (let `t` = stdin.readLine.split)\n        p := nnkPar.newTree()\n        if defs[1][0].kind == nnkPar:\n          for i, typ in defs[1][0].pairs:\n            if typ.repr == \"string\":\n              p.add quote do: `t`[`i`]\n            else:\n              parsefn := newIdentNode(\"parse\" & typ.repr)\n              p.add quote do: `t`[`i`].`parsefn`\n        else:\n          typ := defs[1][0]\n          if typ.repr == \"string\":\n            for i in 0..<defs[0].len:\n              p.add quote do: `t`[`i`]\n          else:\n            parsefn := newIdentNode(\"parse\" & typ.repr)\n            for i in 0..<defs[0].len:\n              p.add quote do: `t`[`i`].`parsefn`\n        sle.add p\n        vt.add sle\n        letSect.add vt\n      elif defs[0].kind == nnkBracketExpr:\n        ids := nnkIdentDefs.newTree(defs[0][0], newEmptyNode())\n        cnt := defs[0][1]\n        typ := defs[1][0]\n        var input: NimNode\n        if typ.kind == nnkBracketExpr and typ.len > 2:\n          op := typ[2]\n          typ.del(2, 1)\n          input = quote do: inputAsType(`typ`).mapIt(`op`)\n        else:\n          input = quote do: inputAsType(`typ`)\n        var val: NimNode\n        if defs[0].len > 2:\n          op := defs[0][2]\n          it := ident\"it\"\n          val = quote do:\n            block:\n              var `it` = `input`\n              `op`\n        else:\n          val = input\n        if defs[1].len > 1:\n          op := defs[1][1]\n          it := ident\"it\"\n          ids.add(quote do:\n            block:\n              var `it` = newSeqWith(`cnt`, `val`)\n              `op`)\n        else:\n          ids.add(quote do: newSeqWith(`cnt`, `val`))\n        letSect.add ids\n    result.add letSect\n\n# ========= utils/base.nim ========= }}}\n\n# ========= flow/dinic.nim ========= {{{\n\n# ========= datast/deque.nim ========= {{{\n\nwhen not declared(INCLUDE_GUARD_DATAST_DEQUE_NIM):\n  const INCLUDE_GUARD_DATAST_DEQUE_NIM = 1\n  import math\n  type\n    Deque[T] = ref object\n      data: seq[T]\n      ## [head, tail)\n      head, tail, count, mask: int\n\n  proc initDeque[T](size = 4): Deque[T] =\n    assert isPowerOfTwo(size)\n    let mask = size-1\n    return Deque[T](data: newSeq[T](size), head: 0, tail: 0, count: 0, mask: mask)\n\n  template emptyCheck(deq: untyped) =\n    # Bounds check for the regular deque access.\n    when compileOption(\"boundChecks\"):\n      if unlikely(deq.count < 1):\n        raise newException(IndexError, \"Empty deque.\")\n\n  template xBoundsCheck(deq, i: untyped) =\n    # Bounds check for the array like accesses.\n    when compileOption(\"boundChecks\"): # d:release should disable this.\n      if unlikely(i >= deq.count): # x < deq.low is taken care by the Natural parameter\n        raise newException(IndexError, \"Out of bounds: \" & $i & \" > \" & $(\n            deq.count - 1))\n      if unlikely(i < 0): # when used with BackwardsIndex\n        raise newException(IndexError, \"Out of bounds: \" & $i & \" < 0\")\n\n  proc len[T](deq: Deque[T]): int {.inline.} =\n    deq.count\n\n  proc `[]`[T](deq: Deque[T]; index: int): T {.inline.} =\n    xBoundsCheck(deq, index)\n    deq.data[(deq.head + index) and deq.mask]\n\n  proc expandIfNeeded[T](deq: Deque[T]) =\n    if unlikely(deq.data.len == deq.count):\n      let lastLen = deq.data.len\n      deq.data.setLen(lastLen * 2)\n      deq.mask = (deq.mask shl 1) + 1\n      if deq.head >= deq.tail:\n        for i in deq.head..<lastLen:\n          deq.data[i+lastLen] = deq.data[i]\n        deq.head += lastLen\n\n  proc addFirst[T](deq: Deque[T]; val: T) =\n    expandIfNeeded(deq)\n    deq.count.inc\n    deq.head = (deq.head-1) and deq.mask\n    deq.data[deq.head] = val\n\n  proc addLast[T](deq: Deque[T]; val: T) =\n    expandIfNeeded(deq)\n    deq.count.inc\n    deq.data[deq.tail] = val\n    deq.tail = (deq.tail+1) and deq.mask\n\n  proc peekFirst[T](deq: Deque[T]): T {.inline.} =\n    emptyCheck(deq)\n    return deq.data[deq.head]\n\n  proc peekLast[T](deq: Deque[T]): T {.inline.} =\n    emptyCheck(deq)\n    return deq.data[(deq.tail-1) and deq.mask]\n\n  proc popFirst[T](deq: Deque[T]): T {.inline, discardable.} =\n    emptyCheck(deq)\n    deq.count.dec\n    result = deq.data[deq.head]\n    deq.head = (deq.head+1) and deq.mask\n\n  proc popLast[T](deq: Deque[T]): T {.inline, discardable.} =\n    emptyCheck(deq)\n    deq.count.dec\n    deq.tail = (deq.tail-1) and deq.mask\n    result = deq.data[deq.tail]\n\n\n\n# ========= datast/deque.nim ========= }}}\n\n\nwhen not declared(INCLUDE_GUARD_FLOW_DINIC_NIM):\n  const INCLUDE_GUARD_FLOW_DINIC_NIM = 1\n\n  import sequtils\n\n  type\n    DinicGraph[T] = seq[seq[tuple[to: int; cap: T; rev: int]]]\n    Dinic[T] = ref object\n      n: int\n      graph: DinicGraph[T]\n\n  proc initDinic[T](n: int): Dinic[T] =\n    let\n      graph: DinicGraph[T] = newSeqWith(n, newSeq[(int, T, int)](0))\n    return Dinic[T](n: n, graph: graph)\n\n  proc addEdge[T](dnc: Dinic[T]; frm, to: int; cap: T) =\n    dnc.graph[frm].add((to, cap, dnc.graph[to].len))\n    dnc.graph[to].add((frm, 0, dnc.graph[frm].len - 1))\n\n  proc calc[T](dnc: Dinic[T]; source, target: int): T =\n\n    proc bfs(graph: DinicGraph[T]): seq[int] =\n      var deq = initDeque[int](dnc.n.nextPowerOfTwo)\n      result = newSeqWith(dnc.n, -1)\n      deq.addLast(source)\n      result[source] = 0\n      while deq.len > 0:\n        let v = deq.popFirst()\n        for to, cap, _ in graph[v].items:\n          if result[to] < 0 and cap > 0:\n            result[to] = result[v] + 1\n            deq.addLast(to)\n\n    proc dfs(graph: var DinicGraph[T]; depth: seq[int]; v: int; flow: T): T =\n      if v == source: return flow\n      var flowable = flow\n      let d = depth[v]\n      for i in graph[v].len.range:\n        let (w, _, rev) = graph[v][i]\n        if depth[w] >= d: continue\n        let\n          t = dfs(graph, depth, w, min(graph[w][rev].cap, flowable))\n        graph[v][i].cap += t\n        graph[w][rev].cap -= t\n        flowable -= t\n      return flow - flowable\n\n    var graph = dnc.graph\n    while true:\n      let depth = graph.bfs()\n      if depth[target] < 0: break\n      result += graph.dfs(depth, target, result.high)\n\n# ========= flow/dinic.nim ========= }}}\n\ninput:\n  (H, W): int\n  S[H]: string\n\nvar dnc = initDinic[int](H*W*2+2)\nlet OUT = H*W\n\nfor h in range(H):\n  for w in range(W):\n    if h == 0 or h == H-1 or w == 0 or w == W-1:\n      if S[h][w] == 'X':\n        echo -1\n        quit()\n      dnc.addEdge(W*h + w + OUT, H*W*2+1, int.high)\n    if h < H-1:\n      dnc.addEdge(W*h + w + OUT, W*(h+1) + w, int.high)\n      dnc.addEdge(W*(h+1) + w + OUT, W*h + w, int.high)\n    if w < W-1:\n      dnc.addEdge(W*h + w + OUT, W*h + (w+1), int.high)\n      dnc.addEdge(W*h + (w+1) + OUT, W*h + w, int.high)\n    if S[h][w] == 'X':\n      dnc.addEdge(W*h + w, W*h + w + OUT, int.high)\n      dnc.addEdge(H*W*2, W*h + w, int.high)\n    else:\n      dnc.addEdge(W*h + w, W*h + w + OUT, 1)\n\necho dnc.calc(H*W*2, H*W*2+1)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ndef is_corner(i, j):\n\treturn i == 0 or j == 0 or i == h-1 or j == w-1\nh, w = [int(x) for x in sys.stdin.readline().split()]\nmem = []\nfor _ in range(h):\n\tmem.append(list(sys.stdin.readline().strip()))\nimposibru = False\nfor i in range(len(mem)):\n\tfor j in range(len(mem[i])):\n\t\tif mem[i][j] == 'X':\n\t\t\tif is_corner(i, j):\n\t\t\t\timposibru = True\n\t\t\t\tbreak\n\t\t\tif mem[i-1][j]=='.': mem[i-1][j]='#'\n\t\t\tif mem[i+1][j]=='.': mem[i+1][j]='#'\n\t\t\tif mem[i][j-1]=='.': mem[i][j-1]='#'\n\t\t\tif mem[i][j+1]=='.': mem[i][j+1]='#'\n\tif imposibru: break\nif imposibru:\n\tprint -1\nelse:\n\tfor i in range(len(mem)):\n\t\tfor j in range(len(mem[i])):\n\t\t\tif mem[i][j] == '#' and not is_corner(i, j) and mem[i-1][j] != '.' and mem[i+1][j] != '.' and mem[i][j-1] != '.' and mem[i][j-1] != '.':\n\t\t\t\tmem[i][j] = 'S'\n\tctr = 0\n\tfor i in range(len(mem)):\n\t\tfor j in range(len(mem[i])):\n\t\t\tif mem[i][j] == '#': ctr += 1\n\tprint ctr"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nH, W = map(int, raw_input().split())\nS_list = list()\nfor i in range(H):\n    S_list.append(raw_input())\n\n\n\nX_mat = np.zeros((H, W), dtype='int')\nS_mat_extend = np.zeros((H+2, W+2), dtype='int')\n# input\nfor h in range(H):\n    for w in range(W):\n        if S_list[h][w] == 'X':\n            X_mat[h, w] += 1\n\nres = 0\n# find -1\nif X_mat[0,:].sum() + X_mat[H-1,:].sum() + X_mat[:,0].sum() + X_mat[:,W-1].sum() > 0:\n    res -= 1\nelse:\n    # put '#' greedy\n    S_mat_extend[0:(H+0), 1:(W+1)] += X_mat\n    S_mat_extend[2:(H+2), 1:(W+1)] += X_mat\n    S_mat_extend[1:(H+1), 0:(W+0)] += X_mat\n    S_mat_extend[1:(H+1), 2:(W+2)] += X_mat\n    # check if it is necessary\n    red_mat = np.zeros((H+2, W+2), dtype='int')\n    blue_mat = np.zeros((H+2, W+2), dtype='int')\n    \n    ques1 = [np.array([0, 0])]\n    red_mat[0, 0] += 1\n    while len(ques1) > 0:\n        q = ques1.pop(0)\n        for a in [np.array([-1, 0]), np.array([1, 0]), np.array([0, 1]), np.array([0, -1])]:\n            r = q + a\n            if r[0] in range(H+2) and r[1] in range(W+2):\n                # check if dst is red\n                if red_mat[r[0], r[1]] > 0:\n                    pass\n                else:\n                    red_mat[r[0], r[1]] += 1\n                    # check if it is '#'\n                    if S_mat_extend[r[0], r[1]] == 0:\n                        ques1.append(r)\n    \n    ques2 = list()\n    for h in range(H):\n        for w in range(W):\n            if X_mat[h][w] == 1:\n                ques2.append(np.array([h+1, w+1]))\n\n    while len(ques2) > 0:\n        q = ques2.pop(0)\n        for a in [np.array([-1, 0]), np.array([1, 0]), np.array([0, 1]), np.array([0, -1])]:\n            r = q + a\n            if r[0] in range(H+2) and r[1] in range(W+2):\n                # check if dst is red\n                if blue_mat[r[0], r[1]] > 0:\n                    pass\n                else:\n                    blue_mat[r[0], r[1]] += 1\n                    # check if it is '#'\n                    if S_mat_extend[r[0], r[1]] > 0:\n                        ques2.append(r)\n                        \nprint (np.minimum(S_mat_extend, 1) * red_mat * blue_mat).sum()"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nimport collections\nimport queue\n\n\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.edges = collections.defaultdict(list)\n        self.level = [0 for _ in range(self.N)]\n        self.iter = [0 for _ in range(self.N)]\n\n    def add(self, u, v, c, directed=True):\n        if directed:\n            self.edges[u].append([v, c, len(self.edges[v])])\n            self.edges[v].append([u, 0, len(self.edges[u])-1])\n        else:  # TODO: must be Verified\n            self.edges[u].append([v, c, len(self.edges[v])])\n            self.edges[v].append([u, 0, len(self.edges[u]) - 1])\n            self.edges[v].append([u, c, len(self.edges[u])])\n            self.edges[u].append([v, 0, len(self.edges[v]) - 1])\n\n    def bfs(self, s):\n        self.level = [-1 for _ in range(self.N)]\n        self.level[s] = 0\n        que = collections.deque([s]) #queue.Queue()\n        #que.put(s)\n        while que: #.empty():\n            v = que.popleft() #.get(s)\n            for i in range(len(self.edges[v])):\n                e = self.edges[v][i]\n                if e[1] > 0 and self.level[e[0]] < 0:\n                    self.level[e[0]] = self.level[v] + 1\n                    que.append(e[0]) # put(e[0])\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        for i in range(self.iter[v], len(self.edges[v])):\n            self.iter[v] = i\n            e = self.edges[v][i]\n            if e[1] > 0 and self.level[v] < self.level[e[0]]:\n                d = self.dfs(e[0], t, min(f, e[1]))\n                if d > 0:\n                    e[1] -= d\n                    self.edges[e[0]][e[2]][1] += d\n                    return d\n        return 0\n\n    def maxFlow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.level[t] < 0:\n                return flow\n            self.iter = [0 for _ in range(self.N)]\n            f = self.dfs(s, t, float('inf'))\n            while f > 0:\n                flow += f\n                f = self.dfs(s, t, float('inf'))\n\n\nH, W = map(int, input().split())\ngraph = Dinic(2*H*W + 2)\ndelta = [-1, 1, W, -W]\ngoal = 2 * H * W + 1\nfor i in range(H):\n    S = str(input())\n    for j, s in enumerate(S):\n        curEdge = i * W + j + 1\n        if s == '.':\n            graph.add(curEdge, curEdge+H*W, 1)\n        else:\n            if i == 0 or i == H-1 or j == 0 or j == W-1:\n                print(-1)\n                quit()\n            graph.add(curEdge, curEdge+H*W, float('inf'))\n            graph.add(0, curEdge, float('inf'))\n        for d in delta:\n            if 0 < curEdge+d < 2*H*W+1:\n                graph.add(curEdge+H*W, curEdge+d, float('inf'))\n\nfor i in range(1, W+1):\n    graph.add(i+H*W, goal, float('inf'))\n    graph.add(i+(2*H-1)*W, goal, float('inf'))\n\nfor i in range(1, H-1):\n    graph.add((i+H)*W+1, goal, float('inf'))\n    graph.add((i+H+1)*W, goal, float('inf'))\n\n\nprint(graph.maxFlow(0, goal))"
  },
  {
    "language": "Python",
    "code": "\nimport numpy as np\n\nH, W = map(int, raw_input().split())\ntbl = []\nfor i in range(H):\n    _ = map(int, list(raw_input().replace('X','1').replace('.','0')))\n    tbl.append(_)\n    \n# debug (restart)\n#tbl = [[0, 0, 0, 0, 0, 0],\n#       [0, 0, 0, 0, 0, 0],\n#       [0, 0, 1, 0, 0, 0],\n#       [0, 1, 0, 0, 1, 0],\n#       [0, 0, 1, 0, 0, 0],\n#       [0, 0, 0, 0, 0, 0]]\n       \ntbl = np.array(tbl)\nr_size, c_size = H-1, W-1\nsaku = np.zeros((H,W))\nr, c = np.nonzero(tbl)\nif 0 in r or H-1 in r or 0 in c or W-1 in c:\n    print -1\nelse:\n    # mk saku             \n    for i,j in zip(r,c):\n        saku[i-1,j] =1\n        saku[i+1,j] =1\n        saku[i,j-1] =1\n        saku[i,j+1] =1\n        \n    # remove redundant saku\n    r, c = np.nonzero(saku)\n    \n    for i, j in zip(r,c):\n        r_max = max(np.arange(W)[saku[i,:]==1])\n        r_min = min(np.arange(W)[saku[i,:]==1])\n        c_max = max(np.arange(H)[saku[:,j]==1])\n        c_min = min(np.arange(H)[saku[:,j]==1])\n        if r_min < j < r_max and c_min < i < c_max:\n            saku[i,j]=0\n\n    r,c = np.nonzero(saku)\n    \n    print len(r)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport itertools\nimport networkx as nx\nH, W = map(int, sys.stdin.buffer.readline().split())\nS = b''.join(sys.stdin.buffer.read().split())\n\nsource = 2 * H * W\nsink = source + 1\n\nINF = 10**12\n\ngraph = nx.DiGraph()\ngraph.add_nodes_from(range(sink))\n\ndef add(start, end, cap):\n    graph.add_edge(start, end, capacity=cap)\n\n\nfor i in range(H * W):\n    x, y = divmod(i, W)\n    if S[i] == ord('.'):\n        add(2 * i, 2 * i + 1, 1)\n    else:\n        add(source, 2 * i + 1, INF)\n    for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n        x1, y1 = x + dx, y + dy\n        if 0 <= x1 < H and 0 <= y1 < W:\n            j = x1 * W + y1\n            add(2 * i + 1, 2 * j, 1)\n        else:\n            add(2 * i + 1, sink, INF)\nans = nx.minimum_cut_value(graph, source, sink)\nans = ans if ans < INF else -1\nif H == 2:\n    0 / 0\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nH, W = map(int, raw_input().split())\nS_list = list()\nfor i in range(H):\n    S_list.append(raw_input())\n\n# large_const\nlarge_const = 100000\n\nX_mat = np.zeros((H, W), dtype='int')\nS_mat_extend = np.zeros((H+2, W+2), dtype='int')\n\n# input\nfor h in range(H):\n    for w in range(W):\n        if S_list[h][w] == 'X':\n            X_mat[h, w] += 1\n\n# make graph\nG = dict()\ndef add_node(s, Graph=G):\n    Graph[s] = {'edges':dict()}\n    \ndef add_edge(s, t, weight=1, Graph=G):\n    Graph[s]['edges'][t] = weight\n\ndef max_flow_dinic(s, t, Graph=G):\n    G_ = Graph\n    max_flow = 0\n    while True:\n        # create level Graph(reverse)\n        # initialize\n        for v in G_.keys():\n            G_[v]['dist'] = -1\n        # dst\n        G_[t]['dist'] = 0\n        # bfs \n        que_bfs = [t]\n        dmax = large_const\n        while len(que_bfs) > 0:\n            v = que_bfs.pop(0)\n            if G_[v]['dist'] >= dmax:\n                # if too far, pass\n                pass\n            else:\n                # else update dist\n                for d in G_[v]['edges'].keys():    \n                    if G_[d]['edges'][v] > 0:\n                        if d == s:\n                            # src reached\n                            # update\n                            dmax = min(dmax, G_[v]['dist'] + 1)\n                            G_[d]['dist'] = dmax\n                        elif G_[d]['dist'] == -1:\n                            # update\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        elif G_[d]['dist'] > G_[v]['dist'] + 1:\n                            # update (may not happen)\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        else:\n                            pass\n        \n        if G_[s]['dist'] == -1:\n            break\n        else:\n            # find blocking flow with respect to current dist\n            # dfs\n            que_dfs = [[s]]\n            while len(que_dfs) > 0:\n                path = que_dfs.pop()\n                v = path[-1]\n                # add\n                for d in G_[v]['edges'].keys():\n                    if G_[v]['edges'][d] > 0 and G_[d]['dist'] == G_[v]['dist'] - 1:\n                        if d == t:\n                            # if reached\n                            path.append(d)\n                            # add flow and update graph with residual\n                            eps = min([G_[path[i]]['edges'][path[i+1]] for i in range(len(path) - 1)])\n                            max_flow += eps\n                            imax = len(path)-2\n                            for i in range(len(path) - 1):\n                                G_[path[i]]['edges'][path[i+1]] -= eps\n                                G_[path[i+1]]['edges'][path[i]] += eps\n                                if G_[path[i]]['edges'][path[i+1]] == 0:\n                                    imax = min(imax, i)\n                            # cut tree\n                            que_dfs = []\n                            path_temp = []\n                            for i in range(imax+1):\n                                path_temp.append(path[i])\n                                que_dfs.append(path_temp)\n                        else:\n                            # append to que\n                            que_dfs.append(path + [d])\n            \n    \n    return max_flow\n\n\n# src:sheeps\n# dst:outer\nadd_node('src')\nadd_node('dst')\n\n# grid\n# nodes\nfor i in range(H):\n    for j in range(W):\n        add_node(str([i, j]) + '-src')\n        add_node(str([i, j]) + '-dst')\n# edges\nfor i in range(H):\n    for j in range(W):\n        add_edge(str([i, j]) + '-dst', str([i, j]) + '-src', 1)\n        add_edge(str([i, j]) + '-src', str([i, j]) + '-dst', 0)\n        if X_mat[i, j] == 1:\n            add_edge('src', str([i, j]) + '-dst', large_const)\n            add_edge(str([i, j]) + '-dst', 'src', 0)\n            add_edge(str([i, j]) + '-dst', str([i, j]) + '-src', large_const)\n            add_edge(str([i, j]) + '-src', str([i, j]) + '-dst', 0)\n        if i > 0:\n            add_edge(str([i, j]) + '-src', str([i-1, j]) + '-dst', 1)\n            add_edge(str([i-1, j]) + '-dst', str([i, j]) + '-src', 0)\n        if i < H-1:\n            add_edge(str([i, j]) + '-src', str([i+1, j]) + '-dst', 1)\n            add_edge(str([i+1, j]) + '-dst', str([i, j]) + '-src', 0)\n        if j > 0:\n            add_edge(str([i, j]) + '-src', str([i, j-1]) + '-dst', 1)\n            add_edge(str([i, j-1]) + '-dst', str([i, j]) + '-src', 0)\n        if j < W-1:\n            add_edge(str([i, j]) + '-src', str([i, j+1]) + '-dst', 1)\n            add_edge(str([i, j+1]) + '-dst', str([i, j]) + '-src', 0)\n        if i == 0 or j == 0 or i == H-1 or j == W-1:\n            add_edge(str([i, j]) + '-src', 'dst', large_const)\n            add_edge('dst', str([i, j]) + '-src', 0)\n\nres = 0\n# find -1\nif X_mat[0,:].sum() + X_mat[H-1,:].sum() + X_mat[:,0].sum() + X_mat[:,W-1].sum() > 0:\n    res = -1\nelse:\n    res = max_flow_dinic('src', 'dst')\n\n\nprint res"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nH, W = map(int, raw_input().split())\nS_list = list()\nfor i in range(H):\n    S_list.append(raw_input())\n\n\n\nX_mat = np.zeros((H, W), dtype='int')\nS_mat_extend = np.zeros((H+2, W+2), dtype='int')\n# input\nfor h in range(H):\n    for w in range(W):\n        if S_list[h][w] == 'X':\n            X_mat[h, w] += 1\n\nres = 0\n# find -1\nif X_mat[0,:].sum() + X_mat[H-1,:].sum() + X_mat[:,0].sum() + X_mat[:,W-1].sum() > 0:\n    res -= 1\nelse:\n    # put '#' greedy\n    S_mat_extend[0:(H+0), 1:(W+1)] += X_mat\n    S_mat_extend[2:(H+2), 1:(W+1)] += X_mat\n    S_mat_extend[1:(H+1), 0:(W+0)] += X_mat\n    S_mat_extend[1:(H+1), 2:(W+2)] += X_mat\n    # check if it is necessary\n    red_mat = np.zeros((H+2, W+2), dtype='int')\n    ques = list(np.array([0,0]))\n    red_mat[0, 0] += 1\n    while len(ques) > 0:\n        q = ques.pop(0)\n        for a in [np.array([-1, 0]), np.array([1, 0]), np.array([0, 1]), np.array([0, -1])]:\n            r = q + a\n            if r[0] in range(H+2) and r[1] in range(W+2):\n                # check if dst is red\n                if red_mat[r[0], r[1]] > 0:\n                    pass\n                else:\n                    red_mat[r[0], r[1]] += 1\n                    # check if it is '#'\n                    if S_mat_extend[r[0], r[1]] > 0:\n                        res += 1\n                    else:\n                        ques.append(r)\n    \nprint res"
  },
  {
    "language": "Python",
    "code": "import pprint\nimport networkx as nx\nimport itertools\nINF = 10**10\nH, W = [int(_) for _ in input().split()]\nS = [input() for _ in range(H)]\ngraph = nx.DiGraph()\nfor h, w in itertools.product(range(H), range(W)):\n    coord = (h, w)\n    edge = (h, w + H * W)\n    if S[h][w] == 'X':\n        graph.add_edge('source', edge, capacity=INF)\n    graph.add_edge(coord, edge, capacity=1)\n    if 0 < h < H - 1 and 0 < w < W - 1:\n        for dh, dw in [[-1, 0], [1, 0], [0, -1], [0, 1]]:\n            newh, neww = h + dh, w + dw\n            newcoord = (newh, neww)\n            graph.add_edge(edge, newcoord, capacity=1)\n    else:\n        graph.add_edge(edge, 'sink', capacity=INF)\nans = nx.minimum_cut_value(graph, 'source', 'sink')\nprint(-1 if ans == INF else ans)\n"
  },
  {
    "language": "Python",
    "code": "import itertools\nimport os\nimport sys\nfrom collections import deque\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nH, W = list(map(int, sys.stdin.readline().split()))\nS = [sys.stdin.readline().rstrip() for _ in range(H)]\n\n\nclass FordFulkerson:\n    def __init__(self, graph=None, residual=None):\n        \"\"\"\n        :param list of (list of (int, int)) graph: (to, cap) の隣接リスト\n        :param list of (list of (list of (int|list))) residual: (to, cap, rev) の残余グラフ\n        \"\"\"\n        assert (graph and not residual) or (not graph and residual)\n        if graph:\n            self.graph = self.residual_graph(graph)\n        else:\n            self.graph = residual\n\n    @staticmethod\n    def residual_graph(graph):\n        \"\"\"\n        残余グラフ構築\n        :param list of (list of (int, int)) graph: (to, cap) の隣接リスト\n        :rtype: list of (list of (list of (int|list)))\n        :return: (to, cap, rev) の残余グラフ\n        \"\"\"\n        ret = [[] for _ in range(len(graph))]\n        for v in range(len(graph)):\n            for u, cap in graph[v]:\n                rev = [v, 0]\n                edge = [u, cap, rev]\n                rev.append(edge)\n                ret[v].append(edge)\n                ret[u].append(rev)\n        return ret\n\n    def _dfs(self, s, t, used, flow=float('inf')):\n        \"\"\"\n        :param int s:\n        :param int t:\n        :param list of bool used:\n        :param int flow:\n        \"\"\"\n        if s == t:\n            return flow\n        used[s] = True\n        for edge in self.graph[s]:\n            to, cap, rev = edge\n            if not used[to] and cap > 0:\n                f = self._dfs(to, t, used, min(flow, cap))\n                if f > 0:\n                    edge[1] -= f\n                    rev[1] += f\n                    return f\n        return 0\n\n    def maximum_flow(self, from_v, to_v):\n        \"\"\"\n        :param int from_v:\n        :param int to_v:\n        :return: from_v から to_v への最大流\n        \"\"\"\n        ret = 0\n        while True:\n            flow = self._dfs(from_v, to_v, [False] * len(self.graph))\n            if flow == 0:\n                break\n            ret += flow\n        return ret\n\n\ngraph = [[] for _ in range(H * W * 2 + 2)]\nst = H * W * 2\nen = H * W * 2 + 1\noffset = H * W\nfor h, w in itertools.product(range(H), range(W)):\n    pin = h * W + w\n    pout = pin + offset\n    if S[h][w] == \"X\":\n        graph[st].append((pout, IINF))\n    else:\n        graph[pin].append((pout, 1))\n    for dh, dw in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n        h2, w2 = h + dh, w + dw\n        if 0 <= h2 < H and 0 <= w2 < W:\n            qin = h2 * W + w2\n            graph[pout].append((qin, IINF))\n        else:\n            graph[pout].append((en, IINF))\n\nmincut = FordFulkerson(graph=graph).maximum_flow(st, en)\nif mincut >= IINF:\n    print(-1)\nelse:\n    print(mincut)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nH, W = map(int, raw_input().split())\ntbl = []\nfor i in range(H):\n    _ = map(int, list(raw_input().replace('X','1').replace('.','0')))\n    tbl.append(_)\ntbl = np.array(tbl)\n\nr, c = np.nonzero(tbl)\nif 0 in c or H-1 in r or 0 in c or W-1 in r:\n    print -1\nelse:\n    pass\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nH, W = map(int, raw_input().split())\nS_list = list()\nfor i in range(H):\n    S_list.append(raw_input())\n\n# large_const\nlarge_const = 100000\n\nX_mat = np.zeros((H, W), dtype='int')\nS_mat_extend = np.zeros((H+2, W+2), dtype='int')\n\n# input\nfor h in range(H):\n    for w in range(W):\n        if S_list[h][w] == 'X':\n            X_mat[h, w] += 1\n\n# make graph\nG = dict()\ndef add_node(s, Graph=G):\n    Graph[s] = {'edges':dict()}\n    \ndef add_edge(s, t, weight=1, Graph=G):\n    Graph[s]['edges'][t] = weight\n\ndef max_flow_dinic(s, t, Graph=G):\n    G_ = Graph\n    max_flow = 0\n    while True:\n        # create level Graph(reverse)\n        # initialize\n        for v in G_.keys():\n            G_[v]['dist'] = -1\n        # dst\n        G_[t]['dist'] = 0\n        # bfs \n        que_bfs = [t]\n        dmax = large_const\n        while len(que_bfs) > 0:\n            v = que_bfs.pop(0)\n            if G_[v]['dist'] >= dmax:\n                # if too far, pass\n                pass\n            else:\n                # else update dist\n                for d in G_[v]['edges'].keys():    \n                    if G_[d]['edges'][v] > 0:\n                        if d == s:\n                            # src reached\n                            # update\n                            dmax = min(dmax, G_[v]['dist'] + 1)\n                            G_[d]['dist'] = dmax\n                        elif G_[d]['dist'] == -1:\n                            # update\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        elif G_[d]['dist'] > G_[v]['dist'] + 1:\n                            # update (may not happen)\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        else:\n                            pass\n        \n        if G_[s]['dist'] == -1:\n            break\n        else:\n            # find blocking flow with respect to current dist\n            # dfs\n            que_dfs = [[s]]\n            while len(que_dfs) > 0:\n                path = que_dfs.pop()\n                # check if valid\n                if len(path) == 1:\n                    pass\n                elif G_[path[0]]['edges'][path[1]] == 0:\n                    continue\n                v = path[-1]\n                # add\n                for d in G_[v]['edges'].keys():\n                    if G_[v]['edges'][d] > 0 and G_[d]['dist'] == G_[v]['dist'] - 1:\n                        if d == t:\n                            # if reached\n                            path.append(d)\n                            # add flow and update graph with residual\n                            # eps = min([G_[path[i]]['edges'][path[i+1]] for i in range(len(path) - 1)])\n                            eps = 1\n                            max_flow += eps\n                            # imax = len(path)-2\n                            for i in range(len(path) - 1):\n                                G_[path[i]]['edges'][path[i+1]] -= eps\n                                G_[path[i+1]]['edges'][path[i]] += eps\n                                # if G_[path[i]]['edges'][path[i+1]] == 0:\n                                #     imax = min(imax, i)\n                        else:\n                            # append to que\n                            que_dfs.append(path + [d])\n            \n    \n    return max_flow\n\n\n# src:sheeps\n# dst:outer\nadd_node('src')\nadd_node('dst')\n\n# grid\n# nodes\nfor i in range(H):\n    for j in range(W):\n        if X_mat[i, j] == 1:\n            pass\n        else:\n            add_node(str([i, j]) + '-src')\n            add_node(str([i, j]) + '-dst')\n\n# edges\nfor i in range(H):\n    for j in range(W):\n        if X_mat[i, j] == 1:\n            pass\n        else:\n            add_edge(str([i, j]) + '-dst', str([i, j]) + '-src', 1)\n            add_edge(str([i, j]) + '-src', str([i, j]) + '-dst', 0)\n            for d in [[-1, 0], [1, 0], [0, -1], [0, 1]]:\n                k = i + d[0]\n                l = j + d[1]\n                if k in [-1, H] or l in [-1, W]:\n                    add_edge('src', str([i, j]) + '-dst', 1)\n                    add_edge(str([i, j]) + '-dst', 'src', 0)\n                elif X_mat[k, l] == 1:\n                    add_edge(str([i, j]) + '-src', 'dst', 1)\n                    add_edge('dst', str([i, j]) + '-src', 0)                    \n                else:\n                    add_edge(str([i, j]) + '-src', str([k, l]) + '-dst', 1)\n                    add_edge(str([k, l]) + '-dst', str([i, j]) + '-src', 0)\n\nres = 0\n# find -1\nif X_mat[0,:].sum() + X_mat[H-1,:].sum() + X_mat[:,0].sum() + X_mat[:,W-1].sum() > 0:\n    res = -1\nelse:\n    res = max_flow_dinic('src', 'dst')\n\n\nprint res"
  },
  {
    "language": "Python",
    "code": "import sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(10**9)\nfrom collections import deque\n\nclass Dinic:\n    def __init__(self,n,edges):\n        self.n=n\n        self.edges=[[] for _ in range(n)]\n        self.iter=[0]*n\n        self.level=None\n        self.graph(edges)\n    def graph(self,E):\n        edges=self.edges\n        for fr,to,cap in E:\n            edges[fr].append([to,cap,len(edges[to])])\n            edges[to].append([fr,0,len(edges[fr])-1])\n    def maxflow(self,source,sink):\n        max_flow=0\n        while True:\n            self.bfs(source)\n            if self.level[sink]<0:\n                return max_flow\n            self.iter=[0]*self.n\n            flow=self.dfs(source,sink,float('inf'))\n            while flow:\n                max_flow+=flow\n                flow=self.dfs(source,sink,float('inf'))\n    def bfs(self,source):\n        edges=self.edges\n        level=[-1]*self.n\n        level[source]=0\n        q=deque([source])\n        while q:\n            fr=q.popleft()\n            for to,cap,_ in edges[fr]:\n                if cap>0>level[to]:\n                    level[to]=level[fr]+1\n                    q.append(to)\n        self.level=level\n    def dfs(self,source,sink,flow):\n        if source==sink:\n            return flow\n        while self.iter[source]<len(self.edges[source]):\n            to,cap,rev=self.edges[source][self.iter[source]]\n            if cap>0 and self.level[source]<self.level[to]:\n                f=self.dfs(to,sink,min(flow,cap))\n                if f:\n                    self.edges[source][self.iter[source]][1]-=f\n                    self.edges[to][rev][1]+=f\n                    return f\n            self.iter[source]+=1\n        return 0\n\ninf=float('inf')\nh,w=map(int,input().split())\nEdges=[]\ndelta=(-1,1,-w,w)\nfor i in range(h):\n    S=tuple(input().strip())\n    for j,s in enumerate(S):\n        v=i*w+j+1\n        if s=='.':\n            Edges.append((v,v+h*w,1))\n        else:\n            Edges.append((v,v+h*w,inf))\n            Edges.append((0,v,inf))\n        for d in delta:\n            if v+d<=0 or v+d>=2*h*w+1:\n                continue\n            Edges.append((v+h*w,v+d,inf))\nfor i in range(1,w+1):\n    Edges.append((i+h*w,2*h*w+1,inf))\n    Edges.append((i+(2*h-1)*w,2*h*w+1,inf))\nfor i in range(1,h-1):\n    Edges.append(((i+h)*w+1,2*h*w+1,inf))\n    Edges.append(((i+h+1)*w,2*h*w+1,inf))\n\ndinic=Dinic(2*h*w+2,Edges)\nmf=dinic.maxflow(0,2*h*w+1)\nprint(-1 if mf==inf else mf)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nH, W = map(int, raw_input().split())\nS_list = list()\nfor i in range(H):\n    S_list.append(raw_input())\n\n# large_const\nlarge_const = 100000\n\nX_mat = np.zeros((H, W), dtype='int')\nS_mat_extend = np.zeros((H+2, W+2), dtype='int')\n\n# input\nfor h in range(H):\n    for w in range(W):\n        if S_list[h][w] == 'X':\n            X_mat[h, w] += 1\n\n# make graph\nG = dict()\ndef add_node(s, Graph=G):\n    Graph[s] = {'edges':dict()}\n    \ndef add_edge(s, t, weight=1, Graph=G):\n    Graph[s]['edges'][t] = weight\n\ndef max_flow_dinic(s, t, Graph=G):\n    G_ = Graph\n    max_flow = 0\n    while True:\n        # create level Graph(reverse)\n        # initialize\n        for v in G_.keys():\n            G_[v]['dist'] = -1\n        # dst\n        G_[t]['dist'] = 0\n        # bfs \n        que_bfs = [t]\n        dmax = large_const\n        while len(que_bfs) > 0:\n            v = que_bfs.pop(0)\n            if G_[v]['dist'] >= dmax:\n                # if too far, pass\n                pass\n            else:\n                # else update dist\n                for d in G_[v]['edges'].keys():    \n                    if G_[d]['edges'][v] > 0:\n                        if d == s:\n                            # src reached\n                            # update\n                            dmax = min(dmax, G_[v]['dist'] + 1)\n                            G_[d]['dist'] = dmax\n                        elif G_[d]['dist'] == -1:\n                            # update\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        elif G_[d]['dist'] > G_[v]['dist'] + 1:\n                            # update (may not happen)\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        else:\n                            pass\n        \n        if G_[s]['dist'] == -1:\n            break\n        else:\n            # find blocking flow with respect to current dist\n            # dfs\n            que_dfs = [[s]]\n            while len(que_dfs) > 0:\n                path = que_dfs.pop()\n                v = path[-1]\n                # add\n                for d in G_[v]['edges'].keys():\n                    if G_[v]['edges'][d] > 0 and G_[d]['dist'] == G_[v]['dist'] - 1:\n                        if d == t:\n                            # if reached\n                            path.append(d)\n                            # add flow and update graph with residual\n                            eps = min([G_[path[i]]['edges'][path[i+1]] for i in range(len(path) - 1)])\n                            max_flow += eps\n                            imax = len(path)-2\n                            for i in range(len(path) - 1):\n                                G_[path[i]]['edges'][path[i+1]] -= eps\n                                G_[path[i+1]]['edges'][path[i]] += eps\n                                if G_[path[i]]['edges'][path[i+1]] == 0:\n                                    imax = min(imax, i)\n                            # cut tree\n                            que_dfs = [[s]]\n                        else:\n                            # append to que\n                            que_dfs.append(path + [d])\n            \n    \n    return max_flow\n\n\n# src:sheeps\n# dst:outer\nadd_node('src')\nadd_node('dst')\n\n# grid\n# nodes\nfor i in range(H):\n    for j in range(W):\n        add_node(str([i, j]) + '-src')\n        add_node(str([i, j]) + '-dst')\n# edges\nfor i in range(H):\n    for j in range(W):\n        add_edge(str([i, j]) + '-dst', str([i, j]) + '-src', 1)\n        add_edge(str([i, j]) + '-src', str([i, j]) + '-dst', 0)\n        if X_mat[i, j] == 1:\n            add_edge(str([i, j]) + '-src', 'dst', large_const)\n            add_edge('dst', str([i, j]) + '-src', 0)\n            # add_edge('src', str([i, j]) + '-dst', large_const)\n            # add_edge(str([i, j]) + '-dst', 'src', 0)\n            add_edge(str([i, j]) + '-dst', str([i, j]) + '-src', large_const)\n            # add_edge(str([i, j]) + '-src', str([i, j]) + '-dst', 0)\n        if i > 0:\n            add_edge(str([i, j]) + '-src', str([i-1, j]) + '-dst', 1)\n            add_edge(str([i-1, j]) + '-dst', str([i, j]) + '-src', 0)\n        if i < H-1:\n            add_edge(str([i, j]) + '-src', str([i+1, j]) + '-dst', 1)\n            add_edge(str([i+1, j]) + '-dst', str([i, j]) + '-src', 0)\n        if j > 0:\n            add_edge(str([i, j]) + '-src', str([i, j-1]) + '-dst', 1)\n            add_edge(str([i, j-1]) + '-dst', str([i, j]) + '-src', 0)\n        if j < W-1:\n            add_edge(str([i, j]) + '-src', str([i, j+1]) + '-dst', 1)\n            add_edge(str([i, j+1]) + '-dst', str([i, j]) + '-src', 0)\n        if i == 0 or j == 0 or i == H-1 or j == W-1:\n            add_edge('src', str([i, j]) + '-dst', large_const)\n            add_edge(str([i, j]) + '-dst', 'src', 0)\n            # add_edge(str([i, j]) + '-src', 'dst', large_const)\n            # add_edge('dst', str([i, j]) + '-src', 0)\n\nres = 0\n# find -1\nif X_mat[0,:].sum() + X_mat[H-1,:].sum() + X_mat[:,0].sum() + X_mat[:,W-1].sum() > 0:\n    res = -1\nelse:\n    res = max_flow_dinic('src', 'dst')\n\n\nprint res"
  },
  {
    "language": "Python",
    "code": "def rotate(h,w):\n    for i in xrange(h):\n        for j in xrange(w):\n            rs[j][h-1-i]=s[i][j]\n    return rs\n\nh,w=map(int,raw_input().split())\ns=[raw_input() for _ in xrange(h)]\nrs=[[\"\"]*h for _ in xrange(w)]\nrs=rotate(h,w)\n\nfor i in xrange(h):\n    if s[i][w-1]==\"X\" or s[i][0]==\"X\":\n        print(-1)\n        exit()\nfor j in xrange(w):\n    if s[h-1][j]==\"X\" or s[0][j]==\"X\":\n        print(-1)\n        exit()\n\n#up\nfor i in xrange(h):\n    if \"X\" in s[i]:\n        up=i-1\n        cnt=s[i].count(\"X\")\n        break\nif cnt>1:\n    upl=s[up+1].index(\"X\")\n    upr=list(reversed(s[up+1])).index(\"X\")\nelse:\n    upl=upr=s[up+1].index(\"X\")\n\n#under\nfor i in xrange(h-1,-1,-1):\n    if \"X\" in s[i]:\n        un=i+1\n        cnt=s[i].count(\"X\")\n        break\nif cnt>1:\n    unl=s[un-1].index(\"X\")\n    unr=list(reversed(s[un-1])).index(\"X\")\nelse:\n    unl=unr=s[un-1].index(\"X\")\n\n#left\nfor i in xrange(w):\n    if \"X\" in rs[i]:\n        left=i-1\n        cnt=rs[i].count(\"X\")\n        break\nif cnt>1:\n    lun=rs[left+1].index(\"X\")\n    lup=list(reversed(rs[left+1])).index(\"X\")\nelse:\n    lup=lun=rs[left+1].index(\"X\")\n\n#right\nfor i in xrange(w-1,-1,-1):\n    if \"X\" in rs[i]:\n        right=i+1\n        cnt=rs[i].count(\"X\")\n        break\nif cnt>1:\n    run=rs[rihgt-1].index(\"X\")\n    rup=list(reversed(rs[right-1])).index(\"X\")\nelse:\n    rup=run=rs[right-1].index(\"X\")\n\"\"\"\nprint upl,upr\nprint unl,unr\nprint lup,lun\nprint rup,run\n\"\"\"\n#print up,un,left,right\nans=0\nif upl-left==up-lup:\n    ans+=upl-left-1\nelse:\n    ans+=min(upl-left,up-lup)-1+abs(upl-left-(up-lup))\nif lun-un==unl-left:\n    ans+=lun-un-1\nelse:\n    ans+=min(lun-un,unl-left)-1+abs(lun-un-(unl-left))\nif right-unr==run-un:\n    ans+=right-unr-1\nelse:\n    ans+=min(right-unr,run-un)-1+abs(right-unr-(run-un))\nif right-upr==up-rup:\n    ans+=right-upr-1\nelse:\n    ans+=min(right-upr,up-rup)-1+abs(right-upr-(up-rup))\nans+=upr-upl+1+unr-unl+1+lup-lun+1+rup-run+1\nprint ans"
  },
  {
    "language": "Python",
    "code": "import sys\nimport itertools\nimport networkx as nx\nH, W = map(int, sys.stdin.buffer.readline().split())\nS = b''.join(sys.stdin.buffer.read().split())\n\nsource = 2 * H * W\nsink = source + 1\n\nINF = 10**12\n\ngraph = nx.DiGraph()\n\n\ndef add(start, end, cap):\n    graph.add_edge(start, end, capacity=cap)\n\n\nfor i in range(H * W):\n    x, y = divmod(i, W)\n    if S[i] == ord('.'):\n        add(2 * i, 2 * i + 1, 1)\n    else:\n        add(source, 2 * i + 1, INF)\n    for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n        x1, y1 = x + dx, y + dy\n        if 0 <= x1 < H and 0 <= y1 < W:\n            j = x1 * W + y1\n            add(2 * i + 1, 2 * j, INF)\n        else:\n            add(2 * i + 1, sink, INF)\nans = nx.minimum_cut_value(graph, source, sink)\nans = ans if ans < INF else -1\nif H == 2:\n    0 / 0\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import bisect\nimport heapq\nimport itertools\nimport math\nimport os\nimport re\nimport string\nimport sys\nfrom collections import Counter, deque, defaultdict\nfrom copy import deepcopy\nfrom decimal import Decimal\nfrom fractions import gcd\nfrom functools import lru_cache, reduce\nfrom operator import itemgetter\n\nimport numpy as np\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nH, W = list(map(int, sys.stdin.readline().split()))\nS = [sys.stdin.readline().rstrip() for _ in range(H)]\n\n\nclass Dinic:\n    def __init__(self, graph=None, residual=None):\n        \"\"\"\n        :param list of (list of (int, int)) graph: (to, cap) の隣接リスト\n        :param list of (list of (list of (int|list))) residual: (to, cap, rev) の残余グラフ\n        \"\"\"\n        assert (graph and not residual) or (not graph and residual)\n        if graph:\n            self.graph = self.residual_graph(graph)\n        else:\n            self.graph = residual\n\n    @staticmethod\n    def residual_graph(graph):\n        \"\"\"\n        残余グラフ構築\n        :param list of (list of (int, int)) graph: (to, cap) の隣接リスト\n        :rtype: list of (list of (list of (int|list)))\n        :return: (to, cap, rev) の残余グラフ\n        \"\"\"\n        ret = [[] for _ in range(len(graph))]\n        for v in range(len(graph)):\n            for u, cap in graph[v]:\n                rev = [v, 0]\n                edge = [u, cap, rev]\n                rev.append(edge)\n                ret[v].append(edge)\n                ret[u].append(rev)\n        return ret\n\n    def _dist(self, s):\n        \"\"\"\n        :param int s:\n        :rtype: list of int\n        :return: s からの距離。残余グラフ上で到達できない場合は -1\n        \"\"\"\n        ret = [-1] * len(self.graph)\n        ret[s] = 0\n        que = deque([(s, 0)])\n        while que:\n            v, d = que.popleft()\n            for u, cap, _ in self.graph[v]:\n                if ret[u] < 0 < cap:\n                    ret[u] = d + 1\n                    que.append((u, d + 1))\n        return ret\n\n    def _dfs(self, s, t, dist, iter, flow=float('inf')):\n        \"\"\"\n        :param int s:\n        :param int t:\n        :param list of int dist:\n        :param list of int iter:\n        :param int flow:\n        \"\"\"\n        if s == t:\n            return flow\n        while iter[s] < len(self.graph[s]):\n            edge = self.graph[s][iter[s]]\n            to, cap, rev = edge\n            if dist[s] < dist[to] and cap > 0:\n                f = self._dfs(to, t, dist, iter, min(flow, cap))\n                if f > 0:\n                    edge[1] -= f\n                    rev[1] += f\n                    return f\n            iter[s] += 1\n        return 0\n\n    def maximum_flow(self, from_v, to_v):\n        \"\"\"\n        :param int from_v:\n        :param int to_v:\n        :return: from_v から to_v への最大流\n        \"\"\"\n        ret = 0\n        while True:\n            dist = self._dist(from_v)\n            if dist[to_v] < 0:\n                break\n            iter = [0] * len(self.graph)\n            while True:\n                flow = self._dfs(from_v, to_v, dist, iter)\n                if flow == 0:\n                    break\n                ret += flow\n        return ret\n\n\ngraph = [[] for _ in range(H * W * 2 + 2)]\nst = H * W * 2\nen = H * W * 2 + 1\noffset = H * W\nfor h, w in itertools.product(range(H), range(W)):\n    pin = h * W + w\n    pout = pin + offset\n    if S[h][w] == \"X\":\n        graph[st].append((pout, IINF))\n    else:\n        graph[pin].append((pout, 1))\n    for dh, dw in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n        h2, w2 = h + dh, w + dw\n        if 0 <= h2 < H and 0 <= w2 < W:\n            qin = h2 * W + w2\n            graph[pout].append((qin, IINF))\n        else:\n            graph[pout].append((en, IINF))\n\nmincut = Dinic(graph=graph).maximum_flow(st, en)\nif mincut >= IINF:\n    print(-1)\nelse:\n    print(mincut)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport itertools\nfrom scipy.sparse import csr_matrix, lil_matrix\nfrom scipy.sparse.csgraph import maximum_flow\n\nH, W = map(int, sys.stdin.buffer.readline().split())\nS = b''.join(sys.stdin.buffer.read().split())\n\nsource = 2 * H * W\nsink = source + 1\n\nINF = source * 2\n\ngraph = lil_matrix((sink + 1, sink + 1), dtype=int)\n\nfor i in range(H * W):\n    x, y = divmod(i, W)\n    if S[i] == ord('.'):\n        graph[2 * i, 2 * i + 1] = 1\n    else:\n        graph[source, 2 * i + 1] = INF\n    for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n        x1, y1 = x + dx, y + dy\n        if 0 <= x1 < H and 0 <= y1 < W:\n            j = x1 * W + y1\n            graph[2 * i + 1, 2 * j] = 1\n        else:\n            graph[2 * i + 1, sink] = INF\ngraph = graph.tocsr()\nans = maximum_flow(graph, source, sink).flow_value\nans = ans if ans < INF else -1\nif H == 2:\n    0 / 0\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import pprint\nimport networkx as nx\nimport itertools\nINF = 10**10\nH, W = [int(_) for _ in input().split()]\nS = [input() for _ in range(H)]\ngraph = nx.DiGraph()\nfor h, w in itertools.product(range(H), range(W)):\n    coord = W * h + w\n    edge = W * h + w + H * W\n    if S[h][w] == 'X':\n        graph.add_edge('source', edge, capacity=INF)\n    graph.add_edge(coord, edge, capacity=1)\n    if 0 < h < H - 1 and 0 < w < W - 1:\n        for dh, dw in [[-1, 0], [1, 0], [0, -1], [0, 1]]:\n            newh, neww = h + dh, w + dw\n            newcoord = W * newh + neww\n            graph.add_edge(edge, newcoord, capacity=1)\n    else:\n        graph.add_edge(edge, 'sink', capacity=INF)\nans = nx.minimum_cut_value(graph, 'source', 'sink')\nprint(-1 if ans == INF else ans)\n"
  },
  {
    "language": "Python",
    "code": "h, w = map(int, raw_input().split())\na = [raw_input().strip() for _ in xrange(h)]\nif a[0].count('X') or a[-1].count('X') or zip(*a)[0].count('X') or zip(*a)[-1].count('X'):\n    print -1\n    quit()\ninf = 10 ** 9\nN = h * w\ng = [[] for _ in xrange(N * 2 + 2)]\nt = 0\nso = N * 2\nsi = so + 1\ndef add_edge(f, t, cap, rcap):\n    g[f].append([t, cap, len(g[t])])\n    g[t].append([f, rcap, len(g[f]) - 1])\nfor i in xrange(h):\n    for j in xrange(w):\n        if a[i][j] == 'X':\n            add_edge(so, t + N, inf, 0)\n        if i == 0 or i == h - 1 or j == 0 or j == w - 1:\n            add_edge(t, si, inf, 0)\n        if i:\n            add_edge(t + N, t - w, 1, 0)\n        if i < h - 1:\n            add_edge(t + N, t + w, 1, 0)\n        if j:\n            add_edge(t + N, t - 1, 1, 0)\n        if j < w - 1:\n            add_edge(t + N, t + 1, 1, 0)\n        add_edge(t, t + N, 1, 0)\n        t += 1\ndef dfs(v, si, f):\n    global w\n    if v == si:\n        return f\n    d[v] = 1\n    return 0\nans = 0\nst = []\npu = st.append\npo = st.pop\nwhile 1:\n    d = [0] * (si + 1)\n    pu((so, inf, 0))\n    ret = 0\n    while st:\n        v, f, i = po()\n        if v == si:\n            ret = f\n            continue\n        d[v] = 1\n        if ret == 0:\n            for i in xrange(i, len(g[v])):\n                e = g[v][i]\n                if d[e[0]] or not e[1]:\n                   continue\n                pu((v, f, i))\n                pu((e[0], min(f, e[1]), 0))\n                break\n        else:\n            e = g[v][i]\n            g[v][i][1] -= ret\n            g[e[0]][e[2]][1] += ret\n    if not ret:\n        break\n    ans += ret\nprint ans\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nH, W = map(int, raw_input().split())\nS_list = list()\nfor i in range(H):\n    S_list.append(raw_input())\n\n# large_const\nlarge_const = 100000\n\nX_mat = np.zeros((H, W), dtype='int')\n# S_mat_extend = np.zeros((H+2, W+2), dtype='int')\n\n# input\nfor h in range(H):\n    for w in range(W):\n        if S_list[h][w] == 'X':\n            X_mat[h, w] += 1\n\n# make graph\nG = dict()\ndef add_node(s, Graph=G):\n    Graph[s] = {'edges':dict()}\n    \ndef add_edge(s, t, weight=1, Graph=G):\n    Graph[s]['edges'][t] = weight\n\ndef max_flow_dinic(s, t, Graph=G):\n    G_ = Graph\n    max_flow = 0\n    while True:\n        # create level Graph(reverse)\n        # initialize\n        for v in G_.keys():\n            G_[v]['dist'] = -1\n        # dst\n        G_[t]['dist'] = 0\n        # bfs \n        que_bfs = [t]\n        dmax = large_const\n        while len(que_bfs) > 0:\n            v = que_bfs.pop(0)\n            if G_[v]['dist'] >= dmax:\n                # if too far, pass\n                pass\n            else:\n                # else update dist\n                for d in G_[v]['edges'].keys():    \n                    if G_[d]['edges'][v] > 0:\n                        if d == s:\n                            # src reached\n                            # update\n                            dmax = min(dmax, G_[v]['dist'] + 1)\n                            G_[d]['dist'] = dmax\n                        elif G_[d]['dist'] == -1:\n                            # update\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        elif G_[d]['dist'] > G_[v]['dist'] + 1:\n                            # update (may not happen)\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        else:\n                            pass\n        \n        if G_[s]['dist'] == -1:\n            break\n        else:\n            # find blocking flow with respect to current dist\n            # dfs\n            que_dfs = [[s]]\n            while len(que_dfs) > 0:\n                path = que_dfs.pop()\n                # check if valid\n                if len(path) == 1:\n                    pass\n                elif G_[path[0]]['edges'][path[1]] == 0:\n                    continue\n                v = path[-1]\n                # add\n                for d in G_[v]['edges'].keys():\n                    if G_[v]['edges'][d] > 0 and G_[d]['dist'] == G_[v]['dist'] - 1:\n                        if d == t:\n                            # if reached\n                            path.append(d)\n                            # add flow and update graph with residual\n                            # eps = min([G_[path[i]]['edges'][path[i+1]] for i in range(len(path) - 1)])\n                            eps = 1\n                            max_flow += eps\n                            # imax = len(path)-2\n                            for i in range(len(path) - 1):\n                                G_[path[i]]['edges'][path[i+1]] -= eps\n                                G_[path[i+1]]['edges'][path[i]] += eps\n                                # if G_[path[i]]['edges'][path[i+1]] == 0:\n                                #     imax = min(imax, i)\n                        else:\n                            # append to que\n                            que_dfs.append(path + [d])\n            \n    \n    return max_flow\n\n\n# src:sheeps\n# dst:outer\nadd_node('src')\nadd_node('dst')\n\n# grid\n# nodes\nfor i in range(H):\n    for j in range(W):\n        if X_mat[i, j] == 1:\n            pass\n        else:\n            add_node(str([i, j]) + '-src')\n            add_node(str([i, j]) + '-dst')\n\n# edges\nfor i in range(H):\n    for j in range(W):\n        if X_mat[i, j] == 1:\n            pass\n        else:\n            add_edge(str([i, j]) + '-dst', str([i, j]) + '-src', 1)\n            add_edge(str([i, j]) + '-src', str([i, j]) + '-dst', 0)\n            for d in [[-1, 0], [1, 0], [0, -1], [0, 1]]:\n                k = i + d[0]\n                l = j + d[1]\n                if k in [-1, H] or l in [-1, W]:\n                    add_edge('src', str([i, j]) + '-dst', 1)\n                    add_edge(str([i, j]) + '-dst', 'src', 0)\n                elif X_mat[k, l] == 1:\n                    add_edge(str([i, j]) + '-src', 'dst', 1)\n                    add_edge('dst', str([i, j]) + '-src', 0)                    \n                else:\n                    add_edge(str([i, j]) + '-src', str([k, l]) + '-dst', 1)\n                    add_edge(str([k, l]) + '-dst', str([i, j]) + '-src', 0)\n\nres = 0\n# find -1\nif X_mat[0,:].sum() + X_mat[H-1,:].sum() + X_mat[:,0].sum() + X_mat[:,W-1].sum() > 0:\n    res = -1\nelse:\n    res = max_flow_dinic('src', 'dst')\n\n\nprint res"
  },
  {
    "language": "Python",
    "code": "import sys\nimport itertools\nimport networkx as nx\nH, W = map(int, sys.stdin.buffer.readline().split())\nS = b''.join(sys.stdin.buffer.read().split())\n\nsource = 2 * H * W\nsink = source + 1\n\nINF = source * 2\n\ngraph = nx.DiGraph()\n\nfor i in range(H * W):\n    x, y = divmod(i, W)\n    if S[i] == ord('.'):\n        graph.add_edge(2 * i, 2 * i + 1, capacity=1)\n    else:\n        graph.add_edge(source, 2 * i + 1, capacity=INF)\n    for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n        x1, y1 = x + dx, y + dy\n        if 0 <= x1 < H and 0 <= y1 < W:\n            j = x1 * W + y1\n            graph.add_edge(2 * i + 1, 2 * j, capacity=INF)\n        else:\n            graph.add_edge(2 * i + 1, sink, capacity=INF)\nans = nx.minimum_cut_value(graph, source, sink)\nans = ans if ans < INF else -1\nif H == 2:\n    0 / 0\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nclass Dinic:\n    \"\"\" 最大流(Dinic) \"\"\"\n\n    def __init__(self, n):\n        self.n = n\n        self.links = [[] for _ in range(n)]\n        self.depth = None\n        self.progress = None\n \n    def add_link(self, _from, to, cap):\n        self.links[_from].append([cap, to, len(self.links[to])])\n        self.links[to].append([0, _from, len(self.links[_from]) - 1])\n \n    def bfs(self, s):\n        from collections import deque\n\n        depth = [-1] * self.n\n        depth[s] = 0\n        q = deque([s])\n        while q:\n            v = q.popleft()\n            for cap, to, _ in self.links[v]:\n                if cap > 0 and depth[to] < 0:\n                    depth[to] = depth[v] + 1\n                    q.append(to)\n        self.depth = depth\n \n    def dfs(self, v, t, flow):\n        if v == t:\n            return flow\n        links_v = self.links[v]\n        for i in range(self.progress[v], len(links_v)):\n            self.progress[v] = i\n            cap, to, rev = link = links_v[i]\n            if cap == 0 or self.depth[v] >= self.depth[to]:\n                continue\n            d = self.dfs(to, t, min(flow, cap))\n            if d == 0:\n                continue\n            link[0] -= d\n            self.links[to][rev][0] += d\n            return d\n        return 0\n \n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.depth[t] < 0:\n                return flow\n            self.progress = [0] * self.n\n            current_flow = self.dfs(s, t, INF)\n            while current_flow > 0:\n                flow += current_flow\n                current_flow = self.dfs(s, t, INF)\n\ndef build_grid(H, W, intv, _type, space=True, padding=False):\n    # 入力がスペース区切りかどうか\n    if space:\n        _input = lambda: input().split()\n    else:\n        _input = lambda: input()\n    _list = lambda: list(map(_type, _input()))\n    # 余白の有無\n    if padding:\n        offset = 1\n    else:\n        offset = 0\n    grid = list2d(H+offset*2, W+offset*2, intv)\n    for i in range(offset, H+offset):\n        row = _list()\n        for j in range(offset, W+offset):\n            grid[i][j] = row[j-offset]\n    return grid\n\nH, W = MAP()\nHW = H * W\ngrid = build_grid(H, W, '', str, space=0)\n\n# 最大流：頂点は各マスのinとout、始点、終点\ndn = Dinic(2*H*W+2)\ns = 2 * H * W\nt = 2 * H * W + 1\n\nfor i in range(H):\n    for j in range(W):\n        # 各マス間の辺\n        if i != 0:\n            dn.add_link(HW+i*W+j, i*W+j-W, INF)\n        if i != H-1:\n            dn.add_link(HW+i*W+j, i*W+j+W, INF)\n        if j != 0:\n            dn.add_link(HW+i*W+j, i*W+j-1, INF)\n        if j != W-1:\n            dn.add_link(HW+i*W+j, i*W+j+1, INF)\n        # ヤギがいるマス\n        if grid[i][j] == 'X':\n            # 始点からヤギマスへの辺\n            dn.add_link(s, i*W+j, INF)\n            # いるマスは切れないので、in,out間のコストはINF\n            dn.add_link(i*W+j, HW+i*W+j, INF)\n        else:\n            # いないマスは切れるので、in,out間のコストは1\n            dn.add_link(i*W+j, HW+i*W+j, 1)\n        # グリッド外に出る(終点への)辺\n        if i == 0 or i == H-1 or j == 0 or j == W-1:\n            dn.add_link(HW+i*W+j, t, INF)\n\nans = dn.max_flow(s, t)\nif ans >= INF:\n    print(-1)\nelse:\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nfrom collections import deque\n\n\"\"\"\n・最小カット\n・頂点でカットする場合には、v_in, v_outに分ける\n・v_in, v_outの間に容量1の辺\n・sourceから、ヤギ_outに容量無限大の辺\n・外周_outから、sinkに容量無限大の辺\n\"\"\"\n\nclass Dinic:\n    def __init__(self, N, source, sink):\n        self.N = N\n        self.G = [[] for _ in range(N)]\n        self.source = source\n        self.sink = sink\n\n    def add_edge(self, fr, to, cap):\n        n1 = len(self.G[fr])\n        n2 = len(self.G[to])\n        self.G[fr].append([to, cap, n2])\n        self.G[to].append([fr, 0, n1]) # 逆辺を cap 0 で追加\n        \n    def add_edge_undirected(self, fr, to, cap):\n        n1 = len(self.G[fr])\n        n2 = len(self.G[to])\n        self.G[fr].append([to, cap, n2])\n        self.G[to].append([fr, cap, n1])\n        \n    def bfs(self):\n        level = [0] * self.N\n        G = self.G; source = self.source; sink = self.sink\n        q = deque([source])\n        level[source] = 1\n        pop = q.popleft; append = q.append\n        while q:\n            v = pop()\n            lv = level[v] + 1\n            for to, cap, rev in G[v]:\n                if not cap:\n                    continue\n                if level[to]:\n                    continue\n                level[to] = lv\n                if to == sink:\n                    self.level = level\n                    return\n                append(to)\n        self.level = level\n        \n    def dfs(self,v,f):\n        if v == self.sink:\n            return f\n        G = self.G\n        prog = self.progress\n        level = self.level\n        lv = level[v]\n        E = G[v]\n        for i in range(prog[v],len(E)):\n            to, cap, rev = E[i]\n            prog[v] = i\n            if not cap:\n                continue\n            if level[to] <= lv:\n                continue\n            x = f if f < cap else cap\n            ff = self.dfs(to, x)\n            if ff:\n                E[i][1] -= ff\n                G[to][rev][1] += ff\n                return ff\n        return 0\n    \n    def max_flow(self):\n        INF = 10**18\n        flow = 0\n        while True:\n            self.bfs()\n            if not self.level[self.sink]:\n                return flow\n            self.progress = [0] * self.N\n            while True:\n                f = self.dfs(self.source, INF)\n                if not f:\n                    break\n                flow += f\n        return flow\n\nH,W = map(int,readline().split())\nS = b''.join(read().split())\n\n# v_i-in: 2i\n# v_i-out: 2i+1\nsource = 2*H*W\nsink = source+1\n\nINF = 10**12\n\ndinic = Dinic(2*H*W+2,source,sink)\nadd = dinic.add_edge\nfor i in range(H*W):\n    h,w = divmod(i,W)\n    if S[i] == ord('.'):\n        add(i+i,i+i+1,1)\n    else:\n        add(source,i+i+1,INF)\n    for dh,dw in ((1,0),(-1,0),(0,1),(0,-1)):\n        h1 = h + dh; w1 = w + dw\n        if 0 <= h1 < H and 0 <= w1 < W:\n            j = h1 * W + w1\n            add(i+i+1,j+j,1)\n        else:\n            # 画面外\n            add(i+i+1,sink,INF)\n\nf = dinic.max_flow()\nanswer = f if f < INF else -1\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nimport itertools\nfrom scipy.sparse import csr_matrix, lil_matrix\nfrom scipy.sparse.csgraph import maximum_flow\n\nH, W = map(int, sys.stdin.buffer.readline().split())\nS = b''.join(sys.stdin.buffer.read().split())\n\nsource = 2 * H * W\nsink = source + 1\n\nINF = source * 2\n\ngraph = lil_matrix((sink + 1, sink + 1), dtype=int)\n\nfor i in range(H * W):\n    x, y = divmod(i, W)\n    if S[i] == ord('.'):\n        graph[2 * i, 2 * i + 1] = 1\n    else:\n        graph[source, 2 * i + 1] = INF\n    for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n        x1, y1 = x + dx, y + dy\n        if 0 <= x1 < H and 0 <= y1 < W:\n            j = x1 * W + y1\n            graph[2 * i + 1, 2 * j] = 1\n        else:\n            graph[2 * i + 1, sink] = INF\ngraph = graph.tocsr()\nans = maximum_flow(graph, source, sink).flow_value\nans = ans if ans < INF else -1\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\n\nclass Dinic:\n    def __init__(self, N, inf):\n        self.N = N\n        self.inf = inf\n        self.G = [[] for _ in range(N)]\n        self.level = [0]*N\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s):\n        self.level = [-1]*self.N\n        deq = deque([s])\n        self.level[s] = 0\n        while deq:\n            v = deq.pop()\n            lv = self.level[v] + 1\n            for w, cap, _ in self.G[v]:\n                if cap > 0 and self.level[w] == -1:\n                    self.level[w] = lv\n                    deq.appendleft(w)\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        for e in self.iter[v]:\n            w, cap, rev = e\n            if cap > 0 and self.level[v] < self.level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d > 0:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.level[t] == -1:\n                return flow\n            *self.iter, = map(iter, self.G)\n            f = self.inf\n            while f > 0:\n                f = self.dfs(s, t, self.inf)\n                flow += f\n\n\nimport sys\n\nsys.setrecursionlimit(10**7)\ndef I(): return int(sys.stdin.readline().rstrip())\ndef MI(): return map(int,sys.stdin.readline().rstrip().split())\ndef LS2(): return list(sys.stdin.readline().rstrip())  #空白なし\n\n\nH,W = MI()\nS = [LS2() for _ in range(H)]\n\nDi = Dinic(2*H*W+2,10000)\ns,t = 2*H*W,2*H*W+1\n\nfor i in range(H):\n    for j in range(W):\n        if S[i][j] == 'X':\n            Di.add_edge(s,W*i+j,10000)\n\nfor j in range(W):\n    Di.add_edge(H*W+j,t,10000)\n    Di.add_edge(H*W+W*(H-1)+j,t,10000)\nfor i in range(1,H-1):\n    Di.add_edge(H*W+W*i,t,10000)\n    Di.add_edge(H*W+W*i+(W-1),t,10000)\n\nfor i in range(H):\n    for j in range(W-1):\n        Di.add_edge(H*W+W*i+j,W*i+(j+1),10000)\n        Di.add_edge(H*W+W*i+(j+1),W*i+j,10000)\nfor i in range(H-1):\n    for j in range(W):\n        Di.add_edge(H*W+W*i+j,W*(i+1)+j,10000)\n        Di.add_edge(H*W+W*(i+1)+j,W*i+j,10000)\n\nfor i in range(H):\n    for j in range(W):\n        if S[i][j] == '.':\n            Di.add_edge(W*i+j,H*W+W*i+j,1)\n        else:\n            Di.add_edge(W*i+j,H*W+W*i+j,10000)\n\nflow = Di.flow(s,t)\nprint(flow if flow < 10000 else -1)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nH, W = map(int, raw_input().split())\nS_list = list()\nfor i in range(H):\n    S_list.append(raw_input())\n\nX_mat = np.zeros((H, W), dtype='int')\nS_mat_extend = np.zeros((H+2, W+2), dtype='int')\n# input\nfor h in range(H):\n    for w in range(W):\n        if S_list[h][w] == 'X':\n            X_mat[h, w] += 1\n\n# make graph\nG = dict()\ndef add_node(s, Graph=G):\n    Graph[s] = {'edges':dict()}\n    \ndef add_edge(s, t, weight=1, Graph=G):\n    Graph[s]['edges'][t] = weight\n\ndef shortest_path(s, t, Graph=G):\n    G_ = Graph.copy()\n    # initialize\n    for v in G_.keys():\n        G_[v]['dist'] = float('inf')\n        G_[v]['path'] = ''\n    G_[s]['dist'] = 0\n    # bfs\n    ques = [s]\n    while len(ques) > 0:\n        v = ques.pop(0)\n        for d in G_[v]['edges'].keys():\n            if G_[v]['edges'][d] > 0 and G_[v]['dist'] + G_[v]['edges'][d] < G_[d]['dist']:\n                # update\n                G_[d]['dist'] = G_[v]['dist'] + G_[v]['edges'][d]\n                G_[d]['path'] = v\n                ques.append(d)\n    path = []\n    if G_[t]['path'] != '':\n        path.append(t)\n        while True:\n            v = path[-1]\n            path.append(G_[v]['path'])\n            if G_[v]['path'] == s:\n                break\n    path.reverse()\n    return path\n\n# reverse path    \ndef minus_flow(path, Graph=G):\n    if len(path) > 0:\n        # flow\n        flow = min([Graph[path[i]]['edges'][path[i+1]] for i in range(len(path)-1)])\n        for i in range(len(path)-1):\n            Graph[path[i]]['edges'][path[i+1]] -= flow\n            # minus\n            if path[i] not in Graph[path[i+1]]['edges'].keys():\n                add_edge(path[i+1], path[i], weight=0, Graph=Graph)\n            Graph[path[i+1]]['edges'][path[i]] += flow\n        return flow\n    else:\n        return 0\n\n# src:sheeps\n# dst:outer\nadd_node('src')\nadd_node('dst')\n\n# grid\nfor i in range(H):\n    for j in range(W):\n        add_node(str([i, j]) + '-src')\n        add_node(str([i, j]) + '-dst')\n        add_edge(str([i, j]) + '-dst', str([i, j]) + '-src')\n        if X_mat[i, j] == 1:\n            add_edge('src', str([i, j]) + '-dst', 100000)\n            add_edge(str([i, j]) + '-dst', str([i, j]) + '-src', 100000)\n        if i > 0:\n            add_edge(str([i, j]) + '-src', str([i-1, j]) + '-dst')\n        if i < H-1:\n            add_edge(str([i, j]) + '-src', str([i+1, j]) + '-dst')\n        if j > 0:\n            add_edge(str([i, j]) + '-src', str([i, j-1]) + '-dst')\n        if j < W-1:\n            add_edge(str([i, j]) + '-src', str([i, j+1]) + '-dst')\n        if i == 0 or j == 0 or i == H-1 or j == W-1:\n            add_edge(str([i, j]) + '-src', 'dst')\n\nres = 0\n# find -1\nif X_mat[0,:].sum() + X_mat[H-1,:].sum() + X_mat[:,0].sum() + X_mat[:,W-1].sum() > 0:\n    res -= 1\nelse:\n    while True:\n        p = shortest_path('src', 'dst')\n        res_add = minus_flow(p)\n        if res_add == 0:\n            break\n        else:\n            res += res_add\n\nprint res"
  },
  {
    "language": "Python",
    "code": "import sys\nimport itertools\nimport networkx as nx\nH, W = [int(_) for _ in input().split()]\nS = b''.join(sys.stdin.buffer.read().split())\n\nsource = 2 * H * W\nsink = source + 1\n\nINF = 10**12\n\ngraph = nx.DiGraph()\n\n\ndef add(start, end, cap):\n    graph.add_edge(start, end, capacity=cap)\n\n\nfor i in range(H * W):\n    x, y = divmod(i, W)\n    if S[i] == ord('.'):\n        add(2 * i, 2 * i + 1, 1)\n    else:\n        add(source, 2 * i + 1, INF)\n    for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n        x1, y1 = x + dx, y + dy\n        if 0 <= x1 < H and 0 <= y1 < W:\n            j = x1 * W + y1\n            add(2 * i + 1, 2 * j, 1)\n        else:\n            add(2 * i + 1, sink, INF)\nans = nx.minimum_cut_value(graph, source, sink)\nans = ans if ans < INF else -1\nif H == 2:\n    0 / 0\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nH, W = map(int, raw_input().split())\nS_list = list()\nfor i in range(H):\n    S_list.append(raw_input())\n\n# large_const\nlarge_const = 100000\n\nX_mat = np.zeros((H, W), dtype='int')\nS_mat_extend = np.zeros((H+2, W+2), dtype='int')\n\n# input\nfor h in range(H):\n    for w in range(W):\n        if S_list[h][w] == 'X':\n            X_mat[h, w] += 1\n\n# make graph\nG = dict()\ndef add_node(s, Graph=G):\n    Graph[s] = {'edges':dict()}\n    \ndef add_edge(s, t, weight=1, Graph=G):\n    Graph[s]['edges'][t] = weight\n\ndef max_flow_dinic(s, t, Graph=G):\n    G_ = Graph\n    max_flow = 0\n    while True:\n        # create level Graph(reverse)\n        # initialize\n        for v in G_.keys():\n            G_[v]['dist'] = -1\n        # dst\n        G_[t]['dist'] = 0\n        # bfs \n        que_bfs = [t]\n        dmax = large_const\n        while len(que_bfs) > 0:\n            v = que_bfs.pop(0)\n            if G_[v]['dist'] >= dmax:\n                # if too far, pass\n                pass\n            else:\n                # else update dist\n                for d in G_[v]['edges'].keys():    \n                    if G_[d]['edges'][v] > 0:\n                        if d == s:\n                            # src reached\n                            # update\n                            dmax = min(dmax, G_[v]['dist'] + 1)\n                            G_[d]['dist'] = dmax\n                        elif G_[d]['dist'] == -1:\n                            # update\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        elif G_[d]['dist'] > G_[v]['dist'] + 1:\n                            # update (may not happen)\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        else:\n                            pass\n        \n        if G_[s]['dist'] == -1:\n            break\n        else:\n            # find blocking flow with respect to current dist\n            # dfs\n            que_dfs = [[s]]\n            while len(que_dfs) > 0:\n                path = que_dfs.pop()\n                v = path[-1]\n                # add\n                for d in G_[v]['edges'].keys():\n                    if G_[v]['edges'][d] > 0 and G_[d]['dist'] == G_[v]['dist'] - 1:\n                        if d == t:\n                            # if reached\n                            path.append(d)\n                            # add flow and update graph with residual\n                            eps = min([G_[path[i]]['edges'][path[i+1]] for i in range(len(path) - 1)])\n                            max_flow += eps\n                            imax = len(path)-2\n                            for i in range(len(path) - 1):\n                                G_[path[i]]['edges'][path[i+1]] -= eps\n                                G_[path[i+1]]['edges'][path[i]] += eps\n                                if G_[path[i]]['edges'][path[i+1]] == 0:\n                                    imax = min(imax, i)\n                            # cut tree\n                            que_dfs = [q for q in que_dfs if path[i] not in q or path[i+1] not in q]\n                        else:\n                            # append to que\n                            que_dfs.append(path + [d])\n            \n    \n    return max_flow\n\n\n# src:sheeps\n# dst:outer\nadd_node('src')\nadd_node('dst')\n\n# grid\n# nodes\nfor i in range(H):\n    for j in range(W):\n        add_node(str([i, j]) + '-src')\n        add_node(str([i, j]) + '-dst')\n# edges\nfor i in range(H):\n    for j in range(W):\n        add_edge(str([i, j]) + '-dst', str([i, j]) + '-src', 1)\n        add_edge(str([i, j]) + '-src', str([i, j]) + '-dst', 0)\n        if X_mat[i, j] == 1:\n            add_edge('src', str([i, j]) + '-dst', large_const)\n            add_edge(str([i, j]) + '-dst', 'src', 0)\n            add_edge(str([i, j]) + '-dst', str([i, j]) + '-src', large_const)\n            add_edge(str([i, j]) + '-src', str([i, j]) + '-dst', 0)\n        if i > 0:\n            add_edge(str([i, j]) + '-src', str([i-1, j]) + '-dst', 1)\n            add_edge(str([i-1, j]) + '-dst', str([i, j]) + '-src', 0)\n        if i < H-1:\n            add_edge(str([i, j]) + '-src', str([i+1, j]) + '-dst', 1)\n            add_edge(str([i+1, j]) + '-dst', str([i, j]) + '-src', 0)\n        if j > 0:\n            add_edge(str([i, j]) + '-src', str([i, j-1]) + '-dst', 1)\n            add_edge(str([i, j-1]) + '-dst', str([i, j]) + '-src', 0)\n        if j < W-1:\n            add_edge(str([i, j]) + '-src', str([i, j+1]) + '-dst', 1)\n            add_edge(str([i, j+1]) + '-dst', str([i, j]) + '-src', 0)\n        if i == 0 or j == 0 or i == H-1 or j == W-1:\n            add_edge(str([i, j]) + '-src', 'dst', large_const)\n            add_edge('dst', str([i, j]) + '-src', 0)\n\nres = 0\n# find -1\nif X_mat[0,:].sum() + X_mat[H-1,:].sum() + X_mat[:,0].sum() + X_mat[:,W-1].sum() > 0:\n    res = -1\nelse:\n    res = max_flow_dinic('src', 'dst')\n\n\nprint res"
  },
  {
    "language": "Python",
    "code": "H, W = map(int, raw_input().split())\nS_list = list()\nfor i in range(H):\n    S_list.append(raw_input())\n\n# large_const\nlarge_const = 100000\n\n# X_mat = np.zeros((H, W), dtype='int')\n\n# input\n# for h in range(H):\n#     for w in range(W):\n#         if S_list[h][w] == 'X':\n#            X_mat[h][w] += 1\n\n# make graph\nG = dict()\ndef add_node(s, Graph=G):\n    Graph[s] = {'edges':dict()}\n    \ndef add_edge(s, t, weight=1, Graph=G):\n    Graph[s]['edges'][t] = weight\n\ndef max_flow_dinic(s, t, Graph=G):\n    G_ = Graph\n    max_flow = 0\n    while True:\n        # create level Graph(reverse)\n        # initialize\n        for v in G_.keys():\n            G_[v]['dist'] = -1\n        # dst\n        G_[t]['dist'] = 0\n        # bfs \n        que_bfs = [t]\n        dmax = large_const\n        while len(que_bfs) > 0:\n            v = que_bfs.pop(0)\n            if G_[v]['dist'] >= dmax:\n                # if too far, pass\n                pass\n            else:\n                # else update dist\n                for d in G_[v]['edges'].keys():    \n                    if G_[d]['edges'][v] > 0:\n                        if d == s:\n                            # src reached\n                            # update\n                            dmax = min(dmax, G_[v]['dist'] + 1)\n                            G_[d]['dist'] = dmax\n                        elif G_[d]['dist'] == -1:\n                            # update\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        elif G_[d]['dist'] > G_[v]['dist'] + 1:\n                            # update (may not happen)\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        else:\n                            pass\n        \n        if G_[s]['dist'] == -1:\n            break\n        else:\n            # find blocking flow with respect to current dist\n            # dfs\n            que_dfs = [[s]]\n            while len(que_dfs) > 0:\n                path = que_dfs.pop()\n                # check if valid\n                if len(path) == 1:\n                    pass\n                elif G_[path[0]]['edges'][path[1]] == 0:\n                    continue\n                v = path[-1]\n                # add\n                for d in G_[v]['edges'].keys():\n                    if G_[v]['edges'][d] > 0 and G_[d]['dist'] == G_[v]['dist'] - 1:\n                        if d == t:\n                            # if reached\n                            path.append(d)\n                            # add flow and update graph with residual\n                            # eps = min([G_[path[i]]['edges'][path[i+1]] for i in range(len(path) - 1)])\n                            eps = 1\n                            max_flow += eps\n                            # imax = len(path)-2\n                            for i in range(len(path) - 1):\n                                G_[path[i]]['edges'][path[i+1]] -= eps\n                                G_[path[i+1]]['edges'][path[i]] += eps\n                                # if G_[path[i]]['edges'][path[i+1]] == 0:\n                                #     imax = min(imax, i)\n                        else:\n                            # append to que\n                            que_dfs.append(path + [d])\n            \n    \n    return max_flow\n\n\n# src:sheeps\n# dst:outer\nadd_node('src')\nadd_node('dst')\n\n# grid\n# nodes\nfor i in range(H):\n    for j in range(W):\n        if S_list[i][j] == 'X':\n            pass\n        else:\n            add_node(str([i, j]) + '-src')\n            add_node(str([i, j]) + '-dst')\n\n# edges\nfor i in range(H):\n    for j in range(W):\n        if S_list[i][j] == 'X':\n            pass\n        else:\n            add_edge(str([i, j]) + '-dst', str([i, j]) + '-src', 1)\n            add_edge(str([i, j]) + '-src', str([i, j]) + '-dst', 0)\n            for d in [[-1, 0], [1, 0], [0, -1], [0, 1]]:\n                k = i + d[0]\n                l = j + d[1]\n                if k in [-1, H] or l in [-1, W]:\n                    add_edge(str([i, j]) + '-src', 'dst', 1)\n                    add_edge('dst', str([i, j]) + '-src', 0)                     \n                elif S_list[k][l] == 'X':\n                    add_edge('src', str([i, j]) + '-dst', 1)\n                    add_edge(str([i, j]) + '-dst', 'src', 0)\n                else:\n                    add_edge(str([i, j]) + '-src', str([k, l]) + '-dst', 1)\n                    add_edge(str([k, l]) + '-dst', str([i, j]) + '-src', 0)\n\nres = 0\n# find -1\nif 'X' in S_list[0] or 'X' in S_list[H-1]:\n    res = -1\nelif 'X' in [s[0] for s in S_list] or 'X' in [s[W-1] for s in S_list]:\n    res = -1\nelse:\n    res = max_flow_dinic('src', 'dst')\n\n\nprint res"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nH, W = map(int, raw_input().split())\nS_list = list()\nfor i in range(H):\n    S_list.append(raw_input())\n\n\nX_mat = np.zeros((H, W), dtype='int')\nS_mat_extend = np.zeros((H+2, W+2), dtype='int')\n# input\nfor h in range(H):\n    for w in range(W):\n        if S_list[h][w] == 'X':\n            X_mat[h, w] += 1\n\n# make graph\nG = dict()\ndef add_node(s, Graph=G):\n    Graph[s] = {'edges':dict()}\n    \ndef add_edge(s, t, weight=1, Graph=G):\n    Graph[s]['edges'][t] = weight\n\ndef max_flow(s, t, Graph=G):\n    G_ = Graph\n    flow = 0\n    \n    while True:\n        # initialize\n        for v in G_.keys():\n            G_[v]['reach'] = -1\n            G_[v]['path'] = ''\n        G_[s]['reach'] = 1\n        # bfs\n        ques = [s]\n        while len(ques) > 0:\n            v = ques.pop()\n            for d in G_[v]['edges'].keys():\n                if G_[v]['edges'][d] > 0 and G_[d]['reach'] == -1:\n                    # update\n                    G_[d]['reach'] = 1\n                    G_[d]['path'] = v\n                    ques.append(d)\n                    if d == t:\n                        flow += 1\n                        break\n\n        if G_[t]['path'] != '':\n            y = t\n            while True:\n                x = G_[y]['path']\n                G_[x]['edges'][y] -= 1\n                if x not in Graph[y]['edges'].keys():\n                    add_edge(y, x, weight=0, Graph=G_)\n                G_[y]['edges'][x] += 1\n                if x == s:\n                    break\n                else:\n                    y = x\n        else:\n            break\n    \n    return flow\n\n\n# src:sheeps\n# dst:outer\nadd_node('src')\nadd_node('dst')\n\n# grid\nfor i in range(H):\n    for j in range(W):\n        add_node(str([i, j]) + '-src')\n        add_node(str([i, j]) + '-dst')\n        add_edge(str([i, j]) + '-dst', str([i, j]) + '-src')\n        if X_mat[i, j] == 1:\n            add_edge('src', str([i, j]) + '-dst', 100000)\n            add_edge(str([i, j]) + '-dst', str([i, j]) + '-src', 100000)\n        if i > 0:\n            add_edge(str([i, j]) + '-src', str([i-1, j]) + '-dst')\n        if i < H-1:\n            add_edge(str([i, j]) + '-src', str([i+1, j]) + '-dst')\n        if j > 0:\n            add_edge(str([i, j]) + '-src', str([i, j-1]) + '-dst')\n        if j < W-1:\n            add_edge(str([i, j]) + '-src', str([i, j+1]) + '-dst')\n        if i == 0 or j == 0 or i == H-1 or j == W-1:\n            add_edge(str([i, j]) + '-src', 'dst', 100000)\n\nres = 0\n# find -1\nif X_mat[0,:].sum() + X_mat[H-1,:].sum() + X_mat[:,0].sum() + X_mat[:,W-1].sum() > 0:\n    res = -1\nelse:\n    res = max_flow('src', 'dst')\n\n\nprint res"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nimport collections\nimport queue\n\n\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.edges = collections.defaultdict(list)\n        self.level = [0 for _ in range(self.N)]\n        self.iter = [0 for _ in range(self.N)]\n\n    def add(self, u, v, c, directed=True):\n        if directed:\n            self.edges[u].append([v, c, len(self.edges[v])])\n            self.edges[v].append([u, 0, len(self.edges[u])-1])\n        else:  # TODO: must be Verified\n            self.edges[u].append([v, c, len(self.edges[v])])\n            self.edges[v].append([u, 0, len(self.edges[u]) - 1])\n            self.edges[v].append([u, c, len(self.edges[u])])\n            self.edges[u].append([v, 0, len(self.edges[v]) - 1])\n\n    def bfs(self, s):\n        self.level = [-1 for _ in range(self.N)]\n        self.level[s] = 0\n        que = queue.Queue()\n        que.put(s)\n        while not que.empty():\n            v = que.get(s)\n            for i in range(len(self.edges[v])):\n                e = self.edges[v][i]\n                if e[1] > 0 and self.level[e[0]] < 0:\n                    self.level[e[0]] = self.level[v] + 1\n                    que.put(e[0])\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        for i in range(self.iter[v], len(self.edges[v])):\n            self.iter[v] = i\n            e = self.edges[v][i]\n            if e[1] > 0 and self.level[v] < self.level[e[0]]:\n                d = self.dfs(e[0], t, min(f, e[1]))\n                if d > 0:\n                    e[1] -= d\n                    self.edges[e[0]][e[2]][1] += d\n                    return d\n        return 0\n\n    def maxFlow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.level[t] < 0:\n                return flow\n            self.iter = [0 for _ in range(self.N)]\n            f = self.dfs(s, t, float('inf'))\n            while f > 0:\n                flow += f\n                f = self.dfs(s, t, float('inf'))\n\n\nH, W = map(int, input().split())\ngraph = Dinic(2*H*W + 2)\ndelta = [-1, 1, W, -W]\ngoal = 2 * H * W + 1\nfor i in range(H):\n    S = str(input())\n    for j, s in enumerate(S):\n        curEdge = i * W + j + 1\n        if s == '.':\n            graph.add(curEdge, curEdge+H*W, 1)\n        else:\n            if i == 0 or i == H-1 or j == 0 or j == W-1:\n                print(-1)\n                quit()\n            graph.add(curEdge, curEdge+H*W, float('inf'))\n            graph.add(0, curEdge, float('inf'))\n        for d in delta:\n            if 0 < curEdge+d < 2*H*W+1:\n                graph.add(curEdge+H*W, curEdge+d, float('inf'))\n\nfor i in range(1, W+1):\n    graph.add(i+H*W, goal, float('inf'))\n    graph.add(i+(2*H-1)*W, goal, float('inf'))\n\nfor i in range(1, H-1):\n    graph.add((i+H)*W+1, goal, float('inf'))\n    graph.add((i+H+1)*W, goal, float('inf'))\n\n\nprint(graph.maxFlow(0, goal))"
  },
  {
    "language": "Python",
    "code": "h, w = map(int, raw_input().split())\na = [raw_input().strip() for _ in xrange(h)]\nif a[0].count('X') or a[-1].count('X') or zip(*a)[0].count('X') or zip(*a)[-1].count('X'):\n    print -1\n    quit()\ninf = 10 ** 9\nN = h * w\ng = [[] for _ in xrange(N * 2 + 2)]\nt = 0\nso = N * 2\nsi = so + 1\ndef add_edge(f, t, cap, rcap):\n    g[f].append([t, cap, len(g[t])])\n    g[t].append([f, rcap, len(g[f]) - 1])\nfor i in xrange(h):\n    for j in xrange(w):\n        if a[i][j] == 'X':\n            add_edge(so, t + N, inf, 0)\n        if i == 0 or i == h - 1 or j == 0 or j == w - 1:\n            add_edge(t, si, inf, 0)\n        if i:\n            add_edge(t + N, t - w, 1, 0)\n        if i < h - 1:\n            add_edge(t + N, t + w, 1, 0)\n        if j:\n            add_edge(t + N, t - 1, 1, 0)\n        if j < w - 1:\n            add_edge(t + N, t + 1, 1, 0)\n        add_edge(t, t + N, 1, 0)\n        t += 1\ndef dfs(v, si, f):\n    global w\n    if v == si:\n        return f\n    d[v] = 1\n    for i, e in enumerate(g[v]):\n        if d[e[0]] or not e[1]:\n            continue\n        tmp = dfs(e[0], si, min(f, e[1]))\n        if tmp:\n            g[v][i][1] -= tmp\n            g[e[0]][e[2]][1] += tmp\n            return tmp\n    return 0\nans = 0\nwhile 1:\n    d = [0] * (si + 1)\n    f = dfs(so, si, inf)\n    if not f:\n        break\n    ans += f\nprint ans\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nH, W = map(int, raw_input().split())\nS_list = list()\nfor i in range(H):\n    S_list.append(raw_input())\n\nX_mat = np.zeros((H, W), dtype='int')\nS_mat_extend = np.zeros((H+2, W+2), dtype='int')\n# input\nfor h in range(H):\n    for w in range(W):\n        if S_list[h][w] == 'X':\n            X_mat[h, w] += 1\n\n# make graph\nG = dict()\ndef add_node(s, Graph=G):\n    Graph[s] = {'edges':dict()}\n    \ndef add_edge(s, t, weight=1, Graph=G):\n    Graph[s]['edges'][t] = weight\n\ndef shortest_path(s, t, Graph=G):\n    G_ = Graph.copy()\n    # initialize\n    for v in G_.keys():\n        G_[v]['dist'] = float('inf')\n        G_[v]['path'] = ''\n    G_[s]['dist'] = 0\n    # bfs\n    ques = [s]\n    while len(ques) > 0:\n        v = ques.pop(0)\n        for d in G_[v]['edges'].keys():\n            if G_[v]['edges'][d] > 0 and G_[v]['dist'] + G_[v]['edges'][d] < G_[d]['dist']:\n                # update\n                G_[d]['dist'] = G_[v]['dist'] + G_[v]['edges'][d]\n                G_[d]['path'] = v\n                ques.append(d)\n    path = []\n    if G_[t]['path'] != '':\n        path.append(t)\n        while True:\n            v = path[-1]\n            path.append(G_[v]['path'])\n            if G_[v]['path'] == s:\n                break\n    path.reverse()\n    return path\n\n# reverse path    \ndef minus_flow(path, Graph=G):\n    if len(path) > 0:\n        # flow\n        flow = min([Graph[path[i]]['edges'][path[i+1]] for i in range(len(path)-1)])\n        for i in range(len(path)-1):\n            Graph[path[i]]['edges'][path[i+1]] -= flow\n            # minus\n            if path[i] not in Graph[path[i+1]]['edges'].keys():\n                add_edge(path[i+1], path[i], weight=0, Graph=Graph)\n            Graph[path[i+1]]['edges'][path[i]] += flow\n        return flow\n    else:\n        return 0\n\n# src:sheeps\n# dst:outer\nadd_node('src')\nadd_node('dst')\n\n# grid\nfor i in range(H):\n    for j in range(W):\n        add_node(str([i, j]) + '-src')\n        add_node(str([i, j]) + '-dst')\n        add_edge(str([i, j]) + '-dst', str([i, j]) + '-src')\n        if X_mat[i, j] == 1:\n            add_edge('src', str([i, j]) + '-dst', 100000)\n            add_edge(str([i, j]) + '-dst', str([i, j]) + '-src', 100000)\n        if i > 0:\n            add_edge(str([i, j]) + '-src', str([i-1, j]) + '-dst')\n        if i < H-1:\n            add_edge(str([i, j]) + '-src', str([i+1, j]) + '-dst')\n        if j > 0:\n            add_edge(str([i, j]) + '-src', str([i, j-1]) + '-dst')\n        if j < W-1:\n            add_edge(str([i, j]) + '-src', str([i, j+1]) + '-dst')\n        if i == 0 or j == 0 or i == H-1 or j == W-1:\n            add_edge(str([i, j]) + '-src', 'dst')\n\nres = 0\nwhile True:\n    p = shortest_path('src', 'dst')\n    res_add = minus_flow(p)\n    if res_add == 0:\n        break\n    else:\n        res += res_add\n\nprint res"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nH, W = map(int, raw_input().split())\nS_list = list()\nfor i in range(H):\n    S_list.append(raw_input())\n\n\nX_mat = np.zeros((H, W), dtype='int')\nS_mat_extend = np.zeros((H+2, W+2), dtype='int')\n# input\nfor h in range(H):\n    for w in range(W):\n        if S_list[h][w] == 'X':\n            X_mat[h, w] += 1\n\n# make graph\nG = dict()\ndef add_node(s, Graph=G):\n    Graph[s] = {'edges':dict()}\n    \ndef add_edge(s, t, weight=1, Graph=G):\n    Graph[s]['edges'][t] = weight\n\ndef max_flow(s, t, Graph=G):\n    G_ = Graph\n    flow = 0\n    \n    while True:\n        # initialize\n        for v in G_.keys():\n            G_[v]['reach'] = -1\n            G_[v]['path'] = ''\n        G_[s]['reach'] = 1\n        # bfs\n        ques = [s]\n        while len(ques) > 0:\n            v = ques.pop(0)\n            for d in G_[v]['edges'].keys():\n                if G_[v]['edges'][d] > 0 and G_[d]['reach'] == -1:\n                    # update\n                    G_[d]['reach'] = 1\n                    G_[d]['path'] = v\n                    ques.append(d)\n                    if d == t:\n                        flow += 1\n                        break\n\n        if G_[t]['path'] != '':\n            y = t\n            while True:\n                x = G_[y]['path']\n                G_[x]['edges'][y] -= 1\n                if x not in Graph[y]['edges'].keys():\n                    add_edge(y, x, weight=0, Graph=G_)\n                G_[y]['edges'][x] += 1\n                if x == s:\n                    break\n                else:\n                    y = x\n        else:\n            break\n    \n    return flow\n\n\n# src:sheeps\n# dst:outer\nadd_node('src')\nadd_node('dst')\n\n# grid\nfor i in range(H):\n    for j in range(W):\n        add_node(str([i, j]) + '-src')\n        add_node(str([i, j]) + '-dst')\n        add_edge(str([i, j]) + '-dst', str([i, j]) + '-src')\n        if X_mat[i, j] == 1:\n            add_edge('src', str([i, j]) + '-dst', 100000)\n            add_edge(str([i, j]) + '-dst', str([i, j]) + '-src', 100000)\n        if i > 0:\n            add_edge(str([i, j]) + '-src', str([i-1, j]) + '-dst')\n        if i < H-1:\n            add_edge(str([i, j]) + '-src', str([i+1, j]) + '-dst')\n        if j > 0:\n            add_edge(str([i, j]) + '-src', str([i, j-1]) + '-dst')\n        if j < W-1:\n            add_edge(str([i, j]) + '-src', str([i, j+1]) + '-dst')\n        if i == 0 or j == 0 or i == H-1 or j == W-1:\n            add_edge(str([i, j]) + '-src', 'dst', 100000)\n\nres = 0\n# find -1\nif X_mat[0,:].sum() + X_mat[H-1,:].sum() + X_mat[:,0].sum() + X_mat[:,W-1].sum() > 0:\n    res = -1\nelse:\n    res = max_flow('src', 'dst')\n\n\nprint res"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nH, W = map(int, raw_input().split())\nS_list = list()\nfor i in range(H):\n    S_list.append(raw_input())\n\n# large_const\nlarge_const = 100000\n\nX_mat = np.zeros((H, W), dtype='int')\nS_mat_extend = np.zeros((H+2, W+2), dtype='int')\n\n# input\nfor h in range(H):\n    for w in range(W):\n        if S_list[h][w] == 'X':\n            X_mat[h, w] += 1\n\n# make graph\nG = dict()\ndef add_node(s, Graph=G):\n    Graph[s] = {'edges':dict()}\n    \ndef add_edge(s, t, weight=1, Graph=G):\n    Graph[s]['edges'][t] = weight\n\ndef max_flow_dinic(s, t, Graph=G):\n    G_ = Graph\n    max_flow = 0\n    while True:\n        # create level Graph(reverse)\n        # initialize\n        for v in G_.keys():\n            G_[v]['dist'] = -1\n        # dst\n        G_[t]['dist'] = 0\n        # bfs \n        que_bfs = [t]\n        dmax = large_const\n        while len(que_bfs) > 0:\n            v = que_bfs.pop(0)\n            if G_[v]['dist'] >= dmax:\n                # if too far, pass\n                pass\n            else:\n                # else update dist\n                for d in G_[v]['edges'].keys():    \n                    if G_[d]['edges'][v] > 0:\n                        if d == s:\n                            # src reached\n                            # update\n                            dmax = min(dmax, G_[v]['dist'] + 1)\n                            G_[d]['dist'] = dmax\n                        elif G_[d]['dist'] == -1:\n                            # update\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        elif G_[d]['dist'] > G_[v]['dist'] + 1:\n                            # update (may not happen)\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        else:\n                            pass\n        \n        if G_[s]['dist'] == -1:\n            break\n        else:\n            # find blocking flow with respect to current dist\n            # dfs\n            que_dfs = [[s]]\n            while len(que_dfs) > 0:\n                path = que_dfs.pop()\n                v = path[-1]\n                # add\n                for d in G_[v]['edges'].keys():\n                    if G_[v]['edges'][d] > 0 and G_[d]['dist'] == G_[v]['dist'] - 1:\n                        if d == t:\n                            # if reached\n                            path.append(d)\n                            # add flow and update graph with residual\n                            eps = min([G_[path[i]]['edges'][path[i+1]] for i in range(len(path) - 1)])\n                            max_flow += eps\n                            imax = len(path)-2\n                            for i in range(len(path) - 1):\n                                G_[path[i]]['edges'][path[i+1]] -= eps\n                                G_[path[i+1]]['edges'][path[i]] += eps\n                                if G_[path[i]]['edges'][path[i+1]] == 0:\n                                    imax = min(imax, i)\n                            # cut tree\n                            que_dfs = [[s]]\n                        else:\n                            # append to que\n                            que_dfs.append(path + [d])\n            \n    \n    return max_flow\n\n\n# src:sheeps\n# dst:outer\nadd_node('src')\nadd_node('dst')\n\n# grid\n# nodes\nfor i in range(H):\n    for j in range(W):\n        if X_mat[i, j] == 1:\n            pass\n        else:\n            add_node(str([i, j]) + '-src')\n            add_node(str([i, j]) + '-dst')\nnodes = G.keys()\n# edges\nfor i in range(H):\n    for j in range(W):\n        if X_mat[i, j] == 1:\n            pass\n        else:\n            add_edge(str([i, j]) + '-dst', str([i, j]) + '-src', 1)\n            add_edge(str([i, j]) + '-src', str([i, j]) + '-dst', 0)\n            for d in [[-1, 0], [1, 0], [0, -1], [0, 1]]:\n                k = i + d[0]\n                l = j + d[1]\n                if str([k, l]) + '-src' in nodes:\n                    add_edge(str([i, j]) + '-src', str([k, l]) + '-dst', 1)\n                    add_edge(str([k, l]) + '-dst', str([i, j]) + '-src', 0)\n                elif k in [-1, H] or l in [-1, W]:\n                    add_edge(str([i, j]) + '-src', 'dst', 1)\n                    add_edge('dst', str([i, j]) + '-src', 0)\n                else:\n                    add_edge('src', str([i, j]) + '-dst', 1)\n                    add_edge(str([i, j]) + '-dst', 'src', 0)\n\nres = 0\n# find -1\nif X_mat[0,:].sum() + X_mat[H-1,:].sum() + X_mat[:,0].sum() + X_mat[:,W-1].sum() > 0:\n    res = -1\nelse:\n    res = max_flow_dinic('src', 'dst')\n\n\nprint res"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nclass Dinic:\n    \"\"\" 最大流(Dinic) \"\"\"\n\n    def __init__(self, n):\n        self.n = n\n        self.links = [[] for _ in range(n)]\n        self.depth = None\n        self.progress = None\n \n    def add_link(self, _from, to, cap):\n        self.links[_from].append([cap, to, len(self.links[to])])\n        self.links[to].append([0, _from, len(self.links[_from]) - 1])\n \n    def bfs(self, s):\n        from collections import deque\n\n        depth = [-1] * self.n\n        depth[s] = 0\n        q = deque([s])\n        while q:\n            v = q.popleft()\n            for cap, to, _ in self.links[v]:\n                if cap > 0 and depth[to] < 0:\n                    depth[to] = depth[v] + 1\n                    q.append(to)\n        self.depth = depth\n \n    def dfs(self, v, t, flow):\n        if v == t:\n            return flow\n        links_v = self.links[v]\n        for i in range(self.progress[v], len(links_v)):\n            self.progress[v] = i\n            cap, to, rev = link = links_v[i]\n            if cap == 0 or self.depth[v] >= self.depth[to]:\n                continue\n            d = self.dfs(to, t, min(flow, cap))\n            if d == 0:\n                continue\n            link[0] -= d\n            self.links[to][rev][0] += d\n            return d\n        return 0\n \n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.depth[t] < 0:\n                return flow\n            self.progress = [0] * self.n\n            current_flow = self.dfs(s, t, INF)\n            while current_flow > 0:\n                flow += current_flow\n                current_flow = self.dfs(s, t, INF)\n\ndef build_grid(H, W, intv, _type, space=True, padding=False):\n    # 入力がスペース区切りかどうか\n    if space:\n        _input = lambda: input().split()\n    else:\n        _input = lambda: input()\n    _list = lambda: list(map(_type, _input()))\n    # 余白の有無\n    if padding:\n        offset = 1\n    else:\n        offset = 0\n    grid = list2d(H+offset*2, W+offset*2, intv)\n    for i in range(offset, H+offset):\n        row = _list()\n        for j in range(offset, W+offset):\n            grid[i][j] = row[j-offset]\n    return grid\n\nH, W = MAP()\nHW = H * W\ngrid = build_grid(H, W, '', str, space=0)\n\n# 最大流：頂点は各マスのinとout、始点、終点\ndn = Dinic(2*H*W+2)\ns = 2 * H * W\nt = 2 * H * W + 1\n\nfor i in range(H):\n    for j in range(W):\n        # 各マス間の辺\n        if i != 0:\n            dn.add_link(HW+i*W+j, i*W+j-W, INF)\n        if i != H-1:\n            dn.add_link(HW+i*W+j, i*W+j+W, INF)\n        if j != 0:\n            dn.add_link(HW+i*W+j, i*W+j-1, INF)\n        if j != W-1:\n            dn.add_link(HW+i*W+j, i*W+j+1, INF)\n        # ヤギがいるマス\n        if grid[i][j] == 'X':\n            # 始点からヤギマスへの辺\n            dn.add_link(s, i*W+j, INF)\n            # いるマスは切れないので、in,out間のコストはINF\n            dn.add_link(i*W+j, HW+i*W+j, INF)\n        else:\n            # いないマスは切れるので、in,out間のコストは1\n            dn.add_link(i*W+j, HW+i*W+j, 1)\n        # グリッド外に出る(終点への)辺\n        if i == 0 or i == H-1 or j == 0 or j == W-1:\n            dn.add_link(HW+i*W+j, t, INF)\n\nans = dn.max_flow(s, t)\nif ans >= INF:\n    print(-1)\nelse:\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nH, W = map(int, raw_input().split())\nS_list = list()\nfor i in range(H):\n    S_list.append(raw_input())\n\n# large_const\nlarge_const = 100000\n\nX_mat = np.zeros((H, W), dtype='int')\nS_mat_extend = np.zeros((H+2, W+2), dtype='int')\n\n# input\nfor h in range(H):\n    for w in range(W):\n        if S_list[h][w] == 'X':\n            X_mat[h, w] += 1\n\n# make graph\nG = dict()\ndef add_node(s, Graph=G):\n    Graph[s] = {'edges':dict()}\n    \ndef add_edge(s, t, weight=1, Graph=G):\n    Graph[s]['edges'][t] = weight\n\ndef max_flow_dinic(s, t, Graph=G):\n    G_ = Graph\n    max_flow = 0\n    while True:\n        # create level Graph(reverse)\n        # initialize\n        for v in G_.keys():\n            G_[v]['dist'] = -1\n        # dst\n        G_[t]['dist'] = 0\n        # bfs \n        que_bfs = [t]\n        dmax = large_const\n        while len(que_bfs) > 0:\n            v = que_bfs.pop(0)\n            if G_[v]['dist'] >= dmax:\n                # if too far, pass\n                pass\n            else:\n                # else update dist\n                for d in G_[v]['edges'].keys():    \n                    if G_[d]['edges'][v] > 0:\n                        if d == s:\n                            # src reached\n                            # update\n                            dmax = min(dmax, G_[v]['dist'] + 1)\n                            G_[d]['dist'] = dmax\n                        elif G_[d]['dist'] == -1:\n                            # update\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        elif G_[d]['dist'] > G_[v]['dist'] + 1:\n                            # update (may not happen)\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        else:\n                            pass\n        \n        if G_[s]['dist'] == -1:\n            break\n        else:\n            # find blocking flow with respect to current dist\n            # dfs\n            que_dfs = [[s]]\n            while len(que_dfs) > 0:\n                path = que_dfs.pop()\n                v = path[-1]\n                # add\n                for d in G_[v]['edges'].keys():\n                    if G_[v]['edges'][d] > 0 and G_[d]['dist'] == G_[v]['dist'] - 1:\n                        if d == t:\n                            # if reached\n                            path.append(d)\n                            # add flow and update graph with residual\n                            # eps = min([G_[path[i]]['edges'][path[i+1]] for i in range(len(path) - 1)])\n                            eps = 1\n                            max_flow += eps\n                            imax = len(path)-2\n                            for i in range(len(path) - 1):\n                                G_[path[i]]['edges'][path[i+1]] -= eps\n                                G_[path[i+1]]['edges'][path[i]] += eps\n                                #if G_[path[i]]['edges'][path[i+1]] == 0:\n                                #    imax = min(imax, i)\n                            # cut tree\n                            que_dfs = [[s]]\n                        else:\n                            # append to que\n                            que_dfs.append(path + [d])\n            \n    \n    return max_flow\n\n\n# src:sheeps\n# dst:outer\nadd_node('src')\nadd_node('dst')\n\n# grid\n# nodes\nfor i in range(H):\n    for j in range(W):\n        if X_mat[i, j] == 1:\n            pass\n        else:\n            add_node(str([i, j]) + '-src')\n            add_node(str([i, j]) + '-dst')\nnodes = G.keys()\n# edges\nfor i in range(H):\n    for j in range(W):\n        if X_mat[i, j] == 1:\n            pass\n        else:\n            add_edge(str([i, j]) + '-dst', str([i, j]) + '-src', 1)\n            add_edge(str([i, j]) + '-src', str([i, j]) + '-dst', 0)\n            for d in [[-1, 0], [1, 0], [0, -1], [0, 1]]:\n                k = i + d[0]\n                l = j + d[1]\n                if k in [-1, H] or l in [-1, W]:\n                    add_edge(str([i, j]) + '-src', 'dst', 1)\n                    add_edge('dst', str([i, j]) + '-src', 0)\n                elif X_mat[k, l] == 1:\n                    add_edge('src', str([i, j]) + '-dst', 1)\n                    add_edge(str([i, j]) + '-dst', 'src', 0)\n                else:\n                    add_edge(str([i, j]) + '-src', str([k, l]) + '-dst', 1)\n                    add_edge(str([k, l]) + '-dst', str([i, j]) + '-src', 0)\n\nres = 0\n# find -1\nif X_mat[0,:].sum() + X_mat[H-1,:].sum() + X_mat[:,0].sum() + X_mat[:,W-1].sum() > 0:\n    res = -1\nelse:\n    res = max_flow_dinic('src', 'dst')\n\n\nprint res"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nH, W = map(int, raw_input().split())\nS_list = list()\nfor i in range(H):\n    S_list.append(raw_input())\n\n# large_const\nlarge_const = 100000\n\nX_mat = np.zeros((H, W), dtype='int')\nS_mat_extend = np.zeros((H+2, W+2), dtype='int')\n\n# input\nfor h in range(H):\n    for w in range(W):\n        if S_list[h][w] == 'X':\n            X_mat[h, w] += 1\n\n# make graph\nG = dict()\ndef add_node(s, Graph=G):\n    Graph[s] = {'edges':dict()}\n    \ndef add_edge(s, t, weight=1, Graph=G):\n    Graph[s]['edges'][t] = weight\n\ndef max_flow_dinic(s, t, Graph=G):\n    G_ = Graph\n    max_flow = 0\n    while True:\n        # create level Graph(reverse)\n        # initialize\n        for v in G_.keys():\n            G_[v]['dist'] = -1\n        # dst\n        G_[t]['dist'] = 0\n        # bfs \n        que_bfs = [t]\n        dmax = large_const\n        while len(que_bfs) > 0:\n            v = que_bfs.pop(0)\n            if G_[v]['dist'] >= dmax:\n                # if too far, pass\n                pass\n            else:\n                # else update dist\n                for d in G_[v]['edges'].keys():    \n                    if G_[d]['edges'][v] > 0:\n                        if d == s:\n                            # src reached\n                            # update\n                            dmax = min(dmax, G_[v]['dist'] + 1)\n                            G_[d]['dist'] = dmax\n                        elif G_[d]['dist'] == -1:\n                            # update\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        elif G_[d]['dist'] > G_[v]['dist'] + 1:\n                            # update (may not happen)\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        else:\n                            pass\n        \n        if G_[s]['dist'] == -1:\n            break\n        else:\n            # find blocking flow with respect to current dist\n            # dfs\n            que_dfs = [[s]]\n            while len(que_dfs) > 0:\n                path = que_dfs.pop()\n                v = path[-1]\n                # add\n                for d in G_[v]['edges'].keys():\n                    if G_[v]['edges'][d] > 0 and G_[d]['dist'] == G_[v]['dist'] - 1:\n                        if d == t:\n                            # if reached\n                            path.append(d)\n                            # add flow and update graph with residual\n                            eps = min([G_[path[i]]['edges'][path[i+1]] for i in range(len(path) - 1)])\n                            max_flow += eps\n                            imax = len(path)-2\n                            for i in range(len(path) - 1):\n                                G_[path[i]]['edges'][path[i+1]] -= eps\n                                G_[path[i+1]]['edges'][path[i]] += eps\n                                if G_[path[i]]['edges'][path[i+1]] == 0:\n                                    imax = min(imax, i)\n                            # cut tree\n                            que_dfs = [[s]]\n                        else:\n                            # append to que\n                            que_dfs.append(path + [d])\n            \n    \n    return max_flow\n\n\n# src:sheeps\n# dst:outer\nadd_node('src')\nadd_node('dst')\n\n# grid\n# nodes\nfor i in range(H):\n    for j in range(W):\n        if X_mat[i, j] == 1:\n            pass\n        else:\n            add_node(str([i, j]) + '-src')\n            add_node(str([i, j]) + '-dst')\nnodes = G.keys()\n# edges\nfor i in range(H):\n    for j in range(W):\n        if X_mat[i, j] == 1:\n            pass\n        else:\n            add_edge(str([i, j]) + '-dst', str([i, j]) + '-src', 1)\n            add_edge(str([i, j]) + '-src', str([i, j]) + '-dst', 0)\n            for d in [[-1, 0], [1, 0], [0, -1], [0, 1]]:\n                k = i + d[0]\n                l = j + d[1]\n                if k in [-1, H] or l in [-1, W]:\n                    add_edge(str([i, j]) + '-src', 'dst', 1)\n                    add_edge('dst', str([i, j]) + '-src', 0)\n                elif X_mat[k, l] == 1:\n                    add_edge('src', str([i, j]) + '-dst', 1)\n                    add_edge(str([i, j]) + '-dst', 'src', 0)\n                else:\n                    add_edge(str([i, j]) + '-src', str([k, l]) + '-dst', 1)\n                    add_edge(str([k, l]) + '-dst', str([i, j]) + '-src', 0)\n\nres = 0\n# find -1\nif X_mat[0,:].sum() + X_mat[H-1,:].sum() + X_mat[:,0].sum() + X_mat[:,W-1].sum() > 0:\n    res = -1\nelse:\n    res = max_flow_dinic('src', 'dst')\n\n\nprint res"
  },
  {
    "language": "Python",
    "code": "H, W = map(int, raw_input().split())\nS_list = list()\nfor i in range(H):\n    S_list.append(raw_input())\n\n# large_const\nlarge_const = 100000\n\n# X_mat = np.zeros((H, W), dtype='int')\n\n# input\n# for h in range(H):\n#     for w in range(W):\n#         if S_list[h][w] == 'X':\n#            X_mat[h][w] += 1\n\n# make graph\nG = dict()\ndef add_node(s, Graph=G):\n    Graph[s] = {'edges':dict()}\n    \ndef add_edge(s, t, weight=1, Graph=G):\n    Graph[s]['edges'][t] = weight\n\ndef max_flow_dinic(s, t, Graph=G):\n    G_ = Graph\n    max_flow = 0\n    while True:\n        # create level Graph(reverse)\n        # initialize\n        for v in G_.keys():\n            G_[v]['dist'] = -1\n        # dst\n        G_[t]['dist'] = 0\n        # bfs \n        que_bfs = [t]\n        dmax = large_const\n        while len(que_bfs) > 0:\n            v = que_bfs.pop(0)\n            if G_[v]['dist'] >= dmax:\n                # if too far, pass\n                pass\n            else:\n                # else update dist\n                for d in G_[v]['edges'].keys():    \n                    if G_[d]['edges'][v] > 0:\n                        if d == s:\n                            # src reached\n                            # update\n                            dmax = min(dmax, G_[v]['dist'] + 1)\n                            G_[d]['dist'] = dmax\n                        elif G_[d]['dist'] == -1:\n                            # update\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        elif G_[d]['dist'] > G_[v]['dist'] + 1:\n                            # update (may not happen)\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        else:\n                            pass\n        \n        if G_[s]['dist'] == -1:\n            break\n        else:\n            # find blocking flow with respect to current dist\n            # dfs\n            que_dfs = [[s]]\n            while len(que_dfs) > 0:\n                path = que_dfs.pop()\n                # check if valid\n                if len(path) == 1:\n                    pass\n                elif G_[path[0]]['edges'][path[1]] == 0:\n                    continue\n                v = path[-1]\n                # add\n                for d in G_[v]['edges'].keys():\n                    if G_[v]['edges'][d] > 0 and G_[d]['dist'] == G_[v]['dist'] - 1:\n                        if d == t:\n                            # if reached\n                            path.append(d)\n                            # add flow and update graph with residual\n                            # eps = min([G_[path[i]]['edges'][path[i+1]] for i in range(len(path) - 1)])\n                            eps = 1\n                            max_flow += eps\n                            # imax = len(path)-2\n                            for i in range(len(path) - 1):\n                                G_[path[i]]['edges'][path[i+1]] -= eps\n                                G_[path[i+1]]['edges'][path[i]] += eps\n                                # if G_[path[i]]['edges'][path[i+1]] == 0:\n                                #     imax = min(imax, i)\n                        else:\n                            # append to que\n                            que_dfs.append(path + [d])\n            \n    \n    return max_flow\n\n\n# src:sheeps\n# dst:outer\nadd_node('src')\nadd_node('dst')\n\n# grid\n# nodes\nfor i in range(H):\n    for j in range(W):\n        if S_list[i][j] == 'X':\n            pass\n        else:\n            add_node(str([i, j]) + '-src')\n            add_node(str([i, j]) + '-dst')\n\n# edges\nfor i in range(H):\n    for j in range(W):\n        if S_list[i][j] == 'X':\n            pass\n        else:\n            add_edge(str([i, j]) + '-dst', str([i, j]) + '-src', 1)\n            add_edge(str([i, j]) + '-src', str([i, j]) + '-dst', 0)\n            for d in [[-1, 0], [1, 0], [0, -1], [0, 1]]:\n                k = i + d[0]\n                l = j + d[1]\n                if k in [-1, H] or l in [-1, W]:\n                    add_edge('src', str([i, j]) + '-dst', 1)\n                    add_edge(str([i, j]) + '-dst', 'src', 0)\n                elif S_list[k][l] == 'X':\n                    add_edge(str([i, j]) + '-src', 'dst', 1)\n                    add_edge('dst', str([i, j]) + '-src', 0)                    \n                else:\n                    add_edge(str([i, j]) + '-src', str([k, l]) + '-dst', 1)\n                    add_edge(str([k, l]) + '-dst', str([i, j]) + '-src', 0)\n\nres = 0\n# find -1\nif 'X' in S_list[0] or 'X' in S_list[H-1]:\n    res = -1\nelif 'X' in [s[0] for s in S_list] or 'X' in [s[W-1] for s in S_list]:\n    res = -1\nelse:\n    res = max_flow_dinic('src', 'dst')\n\n\nprint res"
  },
  {
    "language": "Python",
    "code": "# refer: https://atcoder.jp/contests/kupc2016/submissions/8828418\n# changed: line 134(135), 142(144)\nimport sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nfrom collections import deque\n\n\"\"\"\n・最小カット\n・頂点でカットする場合には、v_in, v_outに分ける\n・v_in, v_outの間に容量1の辺\n・sourceから、ヤギ_outに容量無限大の辺\n・外周_outから、sinkに容量無限大の辺\n\"\"\"\nH,W = map(int,readline().split())\nS = b''.join(read().split())\n\nclass Dinic:\n    def __init__(self, N, source, sink):\n        self.N = N\n        self.G = [[] for _ in range(N)]\n        self.source = source\n        self.sink = sink\n\n    def add_edge(self, fr, to, cap):\n        n1 = len(self.G[fr])\n        n2 = len(self.G[to])\n        self.G[fr].append([to, cap, n2])\n        self.G[to].append([fr, 0, n1]) # 逆辺を cap 0 で追加\n\n    def add_edge_undirected(self, fr, to, cap):\n        n1 = len(self.G[fr])\n        n2 = len(self.G[to])\n        self.G[fr].append([to, cap, n2])\n        self.G[to].append([fr, cap, n1])\n\n    def bfs(self):\n        level = [0] * self.N\n        G = self.G; source = self.source; sink = self.sink\n        q = deque([source])\n        level[source] = 1\n        pop = q.popleft; append = q.append\n        while q:\n            v = pop()\n            lv = level[v] + 1\n            for to, cap, rev in G[v]:\n                if not cap:\n                    continue\n                if level[to]:\n                    continue\n                level[to] = lv\n                if to == sink:\n                    self.level = level\n                    return\n                append(to)\n        self.level = level\n\n    def dfs(self):\n        INF = 10**18\n        G = self.G\n        sink = self.sink\n        prog = self.progress\n        level = self.level\n        ascend = False\n        ff = 0\n        stack = [(self.source,INF)]\n        while stack:\n            if ff:\n                # このまま更新だけして戻っていく\n                v,f = stack.pop()\n                p = prog[v]\n                to, cap, rev = G[v][p]\n                G[v][p][1] -= ff\n                G[to][rev][1] += ff\n                continue\n            v,f = stack[-1]\n            if v == sink:\n                ff = f\n                stack.pop()\n                continue\n            E = G[v]\n            lv = level[v]\n            if ascend:\n                # 流せずに戻ってきた\n                prog[v] += 1\n            find_flag = False\n            for i in range(prog[v],len(E)):\n                to, cap, rev = E[i]\n                prog[v] = i\n                if not cap:\n                    continue\n                if level[to] <= lv:\n                    continue\n                find_flag = True\n                break\n            if not find_flag:\n                ascend = True\n                stack.pop()\n                continue\n            ascend = False\n            x = f if f < cap else cap\n            stack.append((to,x))\n        return ff\n\n    def max_flow(self):\n        flow = 0\n        while True:\n            self.bfs()\n            if not self.level[self.sink]:\n                return flow\n            self.progress = [0] * self.N\n            while True:\n                f = self.dfs()\n                if not f:\n                    break\n                flow += f\n        return flow\n\n# v_i-in: 2i\n# v_i-out: 2i+1\nsource = 2*H*W\nsink = source+1\n\nINF = 10**12\n\ndinic = Dinic(2*H*W+2,source,sink)\nadd = dinic.add_edge\nfor i in range(H*W):\n    h,w = divmod(i,W)\n    if S[i] == ord('.'):\n        add(i+i,i+i+1,1)\n    else:\n        add(i+i,sink,INF)\n        # add(source,i+i+1,INF)\n    for dh,dw in ((1,0),(-1,0),(0,1),(0,-1)):\n        h1 = h + dh; w1 = w + dw\n        if 0 <= h1 < H and 0 <= w1 < W:\n            j = h1 * W + w1\n            add(i+i+1,j+j,1)\n        else:\n            # 画面外\n            add(source,i+i,INF)\n            # add(i+i+1,sink,INF)\n\ndinic.source\n\nf = dinic.max_flow()\nanswer = f if f < INF else -1\nprint(answer)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nfrom collections import defaultdict\n\n\"\"\"\n・最小カット\n・頂点でカットする場合には、v_in, v_outに分ける\n・v_in, v_outの間に容量1の辺\n・sourceから、ヤギ_outに容量無限大の辺\n・外周_outから、sinkに容量無限大の辺\n\"\"\"\n\nH,W = map(int,readline().split())\nS = b''.join(read().split())\n\nINF = 10**12\n\nsource = -1\nsink = -2\ngraph = defaultdict(dict)\nfor i in range(H*W):\n    h,w = divmod(i,W)\n    if S[i] == ord('.'):\n        graph[i+i][i+i+1] = 1\n        graph[i+i+1][i+i] = 0\n    else:\n        graph[source][i+i+1] = INF\n        graph[i+i+1][source] = 0\n    for dh,dw in ((1,0),(-1,0),(0,1),(0,-1)):\n        h1 = h + dh; w1 = w + dw\n        if 0 <= h1 < H and 0 <= w1 < W:\n            j = h1 * W + w1\n            graph[i+i+1][j+j] = 1\n            graph[j+j][i+i+1] = 0\n        else:\n            # 画面外\n            graph[i+i+1][sink] = INF\n            graph[sink][i+i+1] = 0\n\nclass Dinic():\n    def __init__(self,graph,V,source,sink):\n        self.graph = graph\n        self.sink = sink\n        self.source = source\n        self.V = V\n        self.compress()\n        \n    def compress(self):\n        self.N = len(self.V)\n        v_to_i = {x:i for i,x in enumerate(self.V)}\n        self.sink = v_to_i[self.sink]\n        self.source = v_to_i[self.source]\n        g = [dict() for _ in range(self.N)]\n        for v,e in self.graph.items():\n            vn = v_to_i[v]\n            g[vn] = {v_to_i[w]:c for w,c in e.items()}\n        self.graph = g\n        \n    def bfs(self):\n        level = [0]*self.N\n        q = [self.source]\n        level[self.source] = 1\n        d = 1\n        while q:\n            if level[self.sink]:\n                break\n            qq = []\n            d += 1\n            for v in q:\n                for w,cap in self.graph[v].items():\n                    if cap == 0:\n                        continue\n                    if level[w]:\n                        continue\n                    level[w] = d\n                    qq.append(w)\n            q = qq\n        self.level = level\n        \n    def dfs(self,v,f):\n        if v == self.sink:\n            return f\n        for w,cap in self.itr[v]:\n            if cap == 0 or self.level[w] != self.level[v] + 1:\n                continue\n            d = self.dfs(w,min(f,cap))\n            if d:\n                self.graph[v][w] -= d\n                self.graph[w][v] += d\n                return d\n        return 0\n    \n    def max_flow(self):\n        INF = 10**18\n        flow = 0\n        while True:\n            self.bfs()\n            if self.level[self.sink] == 0:\n                break\n            self.itr = [iter(e.items()) for e in self.graph]\n            while True:\n                f = self.dfs(self.source,INF)\n                if f == 0:\n                    break\n                flow += f\n        return flow\n\nf = Dinic(graph,set(graph),source,sink).max_flow()\n\nanswer = f if f < INF else -1\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nimport itertools\nimport networkx as nx\nH, W = map(int, sys.stdin.buffer.readline().split())\nS = b''.join(sys.stdin.buffer.read().split())\n\nsource = 2 * H * W\nsink = source + 1\n\nINF = source * 2\n\ngraph = nx.DiGraph()\ngraph.add_nodes_from(range(sink))\n\nfor i in range(H * W):\n    x, y = divmod(i, W)\n    if S[i] == ord('.'):\n        graph.add_edge(2 * i, 2 * i + 1, capacity=1)\n    else:\n        graph.add_edge(source, 2 * i + 1, capacity=INF)\n    for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n        x1, y1 = x + dx, y + dy\n        if 0 <= x1 < H and 0 <= y1 < W:\n            j = x1 * W + y1\n            graph.add_edge(2 * i + 1, 2 * j, capacity=INF)\n        else:\n            graph.add_edge(2 * i + 1, sink, capacity=INF)\nans = nx.minimum_cut_value(graph, source, sink)\nans = ans if ans < INF else -1\nif H == 2:\n    0 / 0\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, deque\nfrom heapq import heappop, heappush\nfrom operator import itemgetter\nimport sys\n#input = sys.stdin.readline\ndef inpl(): return list(map(int, input().split()))\nH, W = inpl()\nS = [[0]*(W+2) for _ in range(H+2)]\nG = [[0]*(W+2) for _ in range(H+2)]\nsearched = [[0]*(W+2) for _ in range(H+2)]\n\n\nfor h in range(H):\n    s = input()\n    for w in range(W):\n        S[h+1][w+1] = int(s[w] == \"X\")\n\nOK = True\nfor h in range(1, H+1):\n    if S[h][1] | S[h][W]:\n        OK = False\n\n\nfor w in range(1, W+1):\n    if S[1][w] | S[H][w]:\n        OK = False\n\nfor h in range(H+2):\n    searched[h][0] = 1\n    searched[h][W+1] = 1\nfor w in range(W+2):\n    searched[0][w] = 1\n    searched[H+1][w] = 1\n\n\nfor h in range(1, H+1):\n    for w in range(1, W+1):\n        if S[h][w]:\n            G[h+1][w] = 1\n            G[h-1][w] = 1\n            G[h][w+1] = 1\n            G[h][w-1] = 1\n\nQ = []\nfor w in range(1, W+1):\n    Q.append((1, w))\n    Q.append((H, w))\n    searched[1][w] = 1\n    searched[H][w] = 1\n\nfor h in range(2, H):\n    Q.append((h, 1))\n    Q.append((h, W))\n    searched[h][1] = 1\n    searched[h][W] = 1\n\n\nans = 0\nwhile Q:\n    h, w = Q.pop()\n    if G[h][w] == 1:\n        ans += S[h][w] == 0\n        continue\n    for dh, dw in zip([1, -1, 0, 0], [0, 0, 1, -1]):\n        nh, nw = h+dh, w+dw\n        if not searched[nh][nw]:\n            searched[nh][nw] = 1\n            Q.append((nh, nw))\n\nif OK:\n    print(ans)\nelse:\n    print(-1)"
  },
  {
    "language": "Python",
    "code": "import sys\nimport itertools\nimport networkx as nx\nH, W = map(int, sys.stdin.buffer.readline().split())\nS = b''.join(sys.stdin.buffer.read().split())\n\nsource = 2 * H * W\nsink = source + 1\n\nINF = 10**12\n\ngraph = nx.DiGraph()\n\n\ndef add(start, end, cap):\n    graph.add_edge(start, end, capacity=cap)\n\n\nfor i in range(H * W):\n    x, y = divmod(i, W)\n    if S[i] == ord('.'):\n        add(2 * i, 2 * i + 1, 1)\n    else:\n        add(source, 2 * i + 1, INF)\n    for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n        x1, y1 = x + dx, y + dy\n        if 0 <= x1 < H and 0 <= y1 < W:\n            j = x1 * W + y1\n            add(2 * i + 1, 2 * j, 1)\n        else:\n            add(2 * i + 1, sink, INF)\nans = nx.minimum_cut_value(graph, source, sink)\nans = ans if ans < INF else -1\nif H == 2:\n    0 / 0\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "\n\nX_mat = np.zeros((H, W), dtype='int')\nS_mat_extend = np.zeros((H+2, W+2), dtype='int')\n# input\nfor h in range(H):\n    for w in range(W):\n        if S_list[h][w] == 'X':\n            X_mat[h, w] += 1\n\n# make graph\nG = dict()\ndef add_node(s, Graph=G):\n    Graph[s] = {'edges':dict()}\n    \ndef add_edge(s, t, weight=1, Graph=G):\n    Graph[s]['edges'][t] = weight\n\ndef shortest_path(s, t, Graph=G):\n    G_ = Graph.copy()\n    # initialize\n    for v in G_.keys():\n        G_[v]['dist'] = float('inf')\n        G_[v]['path'] = ''\n    G_[s]['dist'] = 0\n    # bfs\n    ques = [s]\n    while len(ques) > 0:\n        v = ques.pop(0)\n        for d in G_[v]['edges'].keys():\n            if G_[v]['edges'][d] > 0 and G_[v]['dist'] + G_[v]['edges'][d] < G_[d]['dist']:\n                # update\n                G_[d]['dist'] = G_[v]['dist'] + G_[v]['edges'][d]\n                G_[d]['path'] = v\n                ques.append(d)\n    path = []\n    if G_[t]['path'] != '':\n        path.append(t)\n        while True:\n            v = path[-1]\n            path.append(G_[v]['path'])\n            if G_[v]['path'] == s:\n                break\n    path.reverse()\n    return path\n\n# reverse path    \ndef minus_flow(path, Graph=G):\n    if len(path) > 0:\n        # flow\n        flow = min([Graph[path[i]]['edges'][path[i+1]] for i in range(len(path)-1)])\n        for i in range(len(path)-1):\n            Graph[path[i]]['edges'][path[i+1]] -= flow\n            # minus\n            if path[i] not in Graph[path[i+1]]['edges'].keys():\n                add_edge(path[i+1], path[i], weight=0, Graph=Graph)\n            Graph[path[i+1]]['edges'][path[i]] += flow\n        return flow\n    else:\n        return 0\n\n# src:sheeps\n# dst:outer\nadd_node('src')\nadd_node('dst')\n\n# grid\nfor i in range(H):\n    for j in range(W):\n        add_node(str([i, j]) + '-src')\n        add_node(str([i, j]) + '-dst')\n        add_edge(str([i, j]) + '-dst', str([i, j]) + '-src')\n        if X_mat[i, j] == 1:\n            add_edge('src', str([i, j]) + '-dst', 100000)\n            add_edge(str([i, j]) + '-dst', str([i, j]) + '-src', 100000)\n        if i > 0:\n            add_edge(str([i, j]) + '-src', str([i-1, j]) + '-dst')\n        if i < H-1:\n            add_edge(str([i, j]) + '-src', str([i+1, j]) + '-dst')\n        if j > 0:\n            add_edge(str([i, j]) + '-src', str([i, j-1]) + '-dst')\n        if j < W-1:\n            add_edge(str([i, j]) + '-src', str([i, j+1]) + '-dst')\n        if i == 0 or j == 0 or i == H-1 or j == W-1:\n            add_edge(str([i, j]) + '-src', 'dst')\n\nres = 0\nwhile True:\n    p = shortest_path('src', 'dst')\n    res_add = minus_flow(p)\n    if res_add == 0:\n        break\n    else:\n        res += res_add\n\nprint res"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nH, W = map(int, raw_input().split())\nS_list = list()\nfor i in range(H):\n    S_list.append(raw_input())\n\n# large_const\nlarge_const = 100000\n\nX_mat = np.zeros((H, W), dtype='int')\nS_mat_extend = np.zeros((H+2, W+2), dtype='int')\n\n# input\nfor h in range(H):\n    for w in range(W):\n        if S_list[h][w] == 'X':\n            X_mat[h, w] += 1\n\n# make graph\nG = dict()\ndef add_node(s, Graph=G):\n    Graph[s] = {'edges':dict()}\n    \ndef add_edge(s, t, weight=1, Graph=G):\n    Graph[s]['edges'][t] = weight\n\ndef max_flow_dinic(s, t, Graph=G):\n    G_ = Graph\n    max_flow = 0\n    while True:\n        # create level Graph(reverse)\n        # initialize\n        for v in G_.keys():\n            G_[v]['dist'] = -1\n        # dst\n        G_[t]['dist'] = 0\n        # bfs \n        que_bfs = [t]\n        dmax = large_const\n        while len(que_bfs) > 0:\n            v = que_bfs.pop(0)\n            if G_[v]['dist'] >= dmax:\n                # if too far, pass\n                pass\n            else:\n                # else update dist\n                for d in G_[v]['edges'].keys():    \n                    if G_[d]['edges'][v] > 0:\n                        if d == s:\n                            # src reached\n                            # update\n                            dmax = min(dmax, G_[v]['dist'] + 1)\n                            G_[d]['dist'] = dmax\n                        elif G_[d]['dist'] == -1:\n                            # update\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        elif G_[d]['dist'] > G_[v]['dist'] + 1:\n                            # update (may not happen)\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        else:\n                            pass\n        \n        if G_[s]['dist'] == -1:\n            break\n        else:\n            # find blocking flow with respect to current dist\n            # dfs\n            que_dfs = [[s]]\n            while len(que_dfs) > 0:\n                path = que_dfs.pop()\n                v = path[-1]\n                # add\n                for d in G_[v]['edges'].keys():\n                    if G_[v]['edges'][d] > 0 and G_[d]['dist'] == G_[v]['dist'] - 1:\n                        if d == t:\n                            # if reached\n                            path.append(d)\n                            # add flow and update graph with residual\n                            eps = min([G_[path[i]]['edges'][path[i+1]] for i in range(len(path) - 1)])\n                            max_flow += eps\n                            imax = len(path)-2\n                            for i in range(len(path) - 1):\n                                G_[path[i]]['edges'][path[i+1]] -= eps\n                                G_[path[i+1]]['edges'][path[i]] += eps\n                                if G_[path[i]]['edges'][path[i+1]] == 0:\n                                    imax = min(imax, i)\n                            # cut tree\n                            que_dfs = [[s]]\n                        else:\n                            # append to que\n                            que_dfs.append(path + [d])\n            \n    \n    return max_flow\n\n\n# src:sheeps\n# dst:outer\nadd_node('src')\nadd_node('dst')\n\n# grid\n# nodes\nfor i in range(H):\n    for j in range(W):\n        add_node(str([i, j]) + '-src')\n        add_node(str([i, j]) + '-dst')\n# edges\nfor i in range(H):\n    for j in range(W):\n        add_edge(str([i, j]) + '-dst', str([i, j]) + '-src', 1)\n        add_edge(str([i, j]) + '-src', str([i, j]) + '-dst', 0)\n        if X_mat[i, j] == 1:\n            add_edge('src', str([i, j]) + '-dst', large_const)\n            add_edge(str([i, j]) + '-dst', 'src', 0)\n            add_edge(str([i, j]) + '-dst', str([i, j]) + '-src', large_const)\n            add_edge(str([i, j]) + '-src', str([i, j]) + '-dst', 0)\n        if i > 0:\n            add_edge(str([i, j]) + '-src', str([i-1, j]) + '-dst', 1)\n            add_edge(str([i-1, j]) + '-dst', str([i, j]) + '-src', 0)\n        if i < H-1:\n            add_edge(str([i, j]) + '-src', str([i+1, j]) + '-dst', 1)\n            add_edge(str([i+1, j]) + '-dst', str([i, j]) + '-src', 0)\n        if j > 0:\n            add_edge(str([i, j]) + '-src', str([i, j-1]) + '-dst', 1)\n            add_edge(str([i, j-1]) + '-dst', str([i, j]) + '-src', 0)\n        if j < W-1:\n            add_edge(str([i, j]) + '-src', str([i, j+1]) + '-dst', 1)\n            add_edge(str([i, j+1]) + '-dst', str([i, j]) + '-src', 0)\n        if i == 0 or j == 0 or i == H-1 or j == W-1:\n            add_edge(str([i, j]) + '-src', 'dst', large_const)\n            add_edge('dst', str([i, j]) + '-src', 0)\n\nres = 0\n# find -1\nif X_mat[0,:].sum() + X_mat[H-1,:].sum() + X_mat[:,0].sum() + X_mat[:,W-1].sum() > 0:\n    res = -1\nelse:\n    res = max_flow_dinic('src', 'dst')\n\n\nprint res"
  },
  {
    "language": "Python",
    "code": "import sys\nimport itertools\nimport networkx as nx\nH, W = [int(_) for _ in input().split()]\nS = b''.join(sys.stdin.buffer.read().split())\n\nsource = 2 * H * W\nsink = source + 1\n\nINF = 10**12\n\ngraph = nx.DiGraph()\n\n\ndef add(start, end, cap):\n    graph.add_edge(start, end, capacity=cap)\n\n\nfor i in range(H * W):\n    x, y = divmod(i, W)\n    if S[i] == ord('.'):\n        add(2 * i, 2 * i + 1, 1)\n    else:\n        add(source, 2 * i + 1, INF)\n    for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n        x1, y1 = x + dx, y + dy\n        if 0 <= x1 < H and 0 <= y1 < W:\n            j = x1 * W + y1\n            add(2 * i + 1, 2 * j, INF)\n        else:\n            add(2 * i + 1, sink, INF)\nans = nx.minimum_cut_value(graph, source, sink)\nans = ans if ans < INF else -1\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import copy\ntemp=input().split()\nH=int(temp[0])\nW=int(temp[1])\nendflag=False\n\nS=[[True if j==\"x\" else False for j in input()] for i in range(H)]\nfence=[[False for j in range(W+1)] for i in range(H+1)]\n\nfor i in range(H):\n\tfor j in range(W):\n\t\tif S[i][j]==True:\n\t\t\tfor k1 in range(-1,2,2):\n\t\t\t\ttry:\n\t\t\t\t\tif S[i+k1][j]==False:\n\t\t\t\t\t\tfence[i+k1][j]=True\n\t\t\t\texcept:\n\t\t\t\t\tendflag=True\n\t\t\tfor k2 in range(-1,2,2):\n\t\t\t\ttry:\n\t\t\t\t\tif S[i][j+k2]==False:\n\t\t\t\t\t\tfence[i][j+k2]=True\n\t\t\t\texcept:\n\t\t\t\t\tendflag=True\nif not endflag:\n\tfor i in range(H):\n\t\tif fence[i][-1]==True:\n\t\t\tendflag=True\n\nif not endflag:\n\tfor j in range(W):\n\t\tif fence[-1][j]==True:\n\t\t\tendflag=True\n\nif endflag:\n\tprint(\"-1\")\n\ndef makeStep(i,j):\n\tplace=[[i,j]]\n\tremoveflag=True\n\tstepped=[[False for j in range(W)] for i in range(H)]\n\twhile len(place)>0:\n\t\tnextPlace=[]\n\t\tfor p in place:\n\t\t\tif p[0]==H-1 or p[0]==0 or p[1]==W-1 or p[1]==0:\n\t\t\t\tremoveflag=False\n\t\t\t\tbreak\n\t\t\t\n\t\t\tif fence[p[0]-1][p[1]]==False and stepped[p[0]-1][p[1]]==False:\n\t\t\t\tnextPlace.append([p[0]-1,p[1]])\n\t\t\t\tstepped[p[0]-1][p[1]]=True\n\t\t\t\t\n\t\t\tif fence[p[0]+1][p[1]]==False and stepped[p[0]+1][p[1]]==False:\n\t\t\t\tnextPlace.append([p[0]+1,p[1]])\n\t\t\t\tstepped[p[0]+1][p[1]]=True\n\t\t\t\t\n\t\t\tif fence[p[0]][p[1]-1]==False and stepped[p[0]][p[1]-1]==False:\n\t\t\t\tnextPlace.append([p[0],p[1]-1])\n\t\t\t\tstepped[p[0]][p[1]-1]=True\n\t\t\t\t\n\t\t\tif fence[p[0]][p[1]+1]==False and stepped[p[0]][p[1]+1]==False:\n\t\t\t\tnextPlace.append([p[0],p[1]+1])\n\t\t\t\tstepped[p[0]][p[1]+1]=True\n\t\telse:\n\t\t\tplace=copy.deepcopy(nextPlace)\n\t\t\tcontinue\n\t\tbreak\n\treturn removeflag\n\n\t\ndef printFence():\n\tfor i in range(H):\n\t\tfor j in range(W):\n\t\t\tif fence[i][j]:\n\t\t\t\tprint(\"#\",end=\"\")\n\t\t\telse:\n\t\t\t\tprint(\".\",end=\"\")\n\t\tprint(\"\")\n\t\t\n#printFence()\nif not endflag:\n\tfor i in range(H):\n\t\tfor j in range(W):\n\t\t\tif fence[i][j]:\n\t\t\t\tif makeStep(i,j):\n\t\t\t\t\tfence[i][j]=False\n\tans=0\n\tfor i in fence:\n\t\tfor j in i:\n\t\t\tif j==True:\n\t\t\t\tans+=1\n\tprint(ans)\n#printFence()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, deque\nfrom heapq import heappop, heappush\nfrom operator import itemgetter\nimport sys\n#input = sys.stdin.readline\ndef inpl(): return list(map(int, input().split()))\nH, W = inpl()\nS = [[0]*(W+2) for _ in range(H+2)]\nG = [[0]*(W+2) for _ in range(H+2)]\nsearched = [[0]*(W+2) for _ in range(H+2)]\n\n\nfor h in range(H):\n    s = input()\n    for w in range(W):\n        S[h+1][w+1] = int(s[w] == \"X\")\n\nOK = True\nfor h in range(1, H+1):\n    if S[h][1] | S[h][W]:\n        OK = False\n\n\nfor w in range(1, W+1):\n    if S[1][w] | S[H][w]:\n        OK = False\n\nfor h in range(H+2):\n    searched[h][0] = 1\n    searched[h][W+1] = 1\nfor w in range(W+2):\n    searched[0][w] = 1\n    searched[H+1][w] = 1\n\n\nfor h in range(1, H+1):\n    for w in range(1, W+1):\n        if S[h][w]:\n            G[h+1][w] = 1\n            G[h-1][w] = 1\n            G[h][w+1] = 1\n            G[h][w-1] = 1\n\nQ = []\nfor w in range(1, W+1):\n    Q.append((1, w))\n    Q.append((H, w))\n    searched[1][w] = 1\n    searched[H][w] = 1\n\nfor h in range(2, H):\n    Q.append((h, 1))\n    Q.append((h, W))\n    searched[h][1] = 1\n    searched[h][W] = 1\n\n\nans = 0\nwhile Q:\n    h, w = Q.pop()\n    if G[h][w] == 1:\n        ans += 1\n        continue\n    for dh, dw in zip([1, -1, 0, 0], [0, 0, 1, -1]):\n        nh, nw = h+dh, w+dw\n        if not searched[nh][nw]:\n            searched[nh][nw] = 1\n            Q.append((nh, nw))\n\nif OK:\n    print(ans)\nelse:\n    print(-1)"
  },
  {
    "language": "Python",
    "code": "import itertools\nimport os\nimport sys\nfrom collections import deque\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nH, W = list(map(int, sys.stdin.readline().split()))\nS = [sys.stdin.readline().rstrip() for _ in range(H)]\n\n\nclass Dinic:\n    def __init__(self, graph=None, residual=None):\n        \"\"\"\n        :param list of (list of (int, int)) graph: (to, cap) の隣接リスト\n        :param list of (list of (list of (int|list))) residual: (to, cap, rev) の残余グラフ\n        \"\"\"\n        assert (graph and not residual) or (not graph and residual)\n        if graph:\n            self.graph = self.residual_graph(graph)\n        else:\n            self.graph = residual\n\n    @staticmethod\n    def residual_graph(graph):\n        \"\"\"\n        残余グラフ構築\n        :param list of (list of (int, int)) graph: (to, cap) の隣接リスト\n        :rtype: list of (list of (list of (int|list)))\n        :return: (to, cap, rev) の残余グラフ\n        \"\"\"\n        ret = [[] for _ in range(len(graph))]\n        for v in range(len(graph)):\n            for u, cap in graph[v]:\n                rev = [v, 0]\n                edge = [u, cap, rev]\n                rev.append(edge)\n                ret[v].append(edge)\n                ret[u].append(rev)\n        return ret\n\n    def _dist(self, s):\n        \"\"\"\n        :param int s:\n        :rtype: list of int\n        :return: s からの距離。残余グラフ上で到達できない場合は -1\n        \"\"\"\n        ret = [-1] * len(self.graph)\n        ret[s] = 0\n        que = deque([(s, 0)])\n        while que:\n            v, d = que.popleft()\n            for u, cap, _ in self.graph[v]:\n                if ret[u] < 0 < cap:\n                    ret[u] = d + 1\n                    que.append((u, d + 1))\n        return ret\n\n    def _dfs(self, s, t, dist, iter, flow=float('inf')):\n        \"\"\"\n        :param int s:\n        :param int t:\n        :param list of int dist:\n        :param list of int iter:\n        :param int flow:\n        \"\"\"\n        if s == t:\n            return flow\n        while iter[s] < len(self.graph[s]):\n            edge = self.graph[s][iter[s]]\n            to, cap, rev = edge\n            if dist[s] < dist[to] and cap > 0:\n                f = self._dfs(to, t, dist, iter, min(flow, cap))\n                if f > 0:\n                    edge[1] -= f\n                    rev[1] += f\n                    return f\n            iter[s] += 1\n        return 0\n\n    def maximum_flow(self, from_v, to_v):\n        \"\"\"\n        :param int from_v:\n        :param int to_v:\n        :return: from_v から to_v への最大流\n        \"\"\"\n        ret = 0\n        while True:\n            dist = self._dist(from_v)\n            if dist[to_v] < 0:\n                break\n            iter = [0] * len(self.graph)\n            while True:\n                flow = self._dfs(from_v, to_v, dist, iter)\n                if flow == 0:\n                    break\n                ret += flow\n        return ret\n\n\ngraph = [[] for _ in range(H * W * 2 + 2)]\nst = H * W * 2\nen = H * W * 2 + 1\noffset = H * W\nfor h, w in itertools.product(range(H), range(W)):\n    pin = h * W + w\n    pout = pin + offset\n    if S[h][w] == \"X\":\n        graph[st].append((pout, IINF))\n    else:\n        graph[pin].append((pout, 1))\n    for dh, dw in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n        h2, w2 = h + dh, w + dw\n        if 0 <= h2 < H and 0 <= w2 < W:\n            qin = h2 * W + w2\n            graph[pout].append((qin, IINF))\n        else:\n            graph[pout].append((en, IINF))\n\nmincut = Dinic(graph=graph).maximum_flow(st, en)\nif mincut >= IINF:\n    print(-1)\nelse:\n    print(mincut)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nH, W = map(int, raw_input().split())\nS_list = list()\nfor i in range(H):\n    S_list.append(raw_input())\n\n# large_const\nlarge_const = 100000\n\nX_mat = np.zeros((H, W), dtype='int')\nS_mat_extend = np.zeros((H+2, W+2), dtype='int')\n\n# input\nfor h in range(H):\n    for w in range(W):\n        if S_list[h][w] == 'X':\n            X_mat[h, w] += 1\n\n# make graph\nG = dict()\ndef add_node(s, Graph=G):\n    Graph[s] = {'edges':dict()}\n    \ndef add_edge(s, t, weight=1, Graph=G):\n    Graph[s]['edges'][t] = weight\n\ndef max_flow_dinic(s, t, Graph=G):\n    G_ = Graph\n    max_flow = 0\n    while True:\n        # create level Graph(reverse)\n        # initialize\n        for v in G_.keys():\n            G_[v]['dist'] = -1\n        # dst\n        G_[t]['dist'] = 0\n        # bfs \n        que_bfs = [t]\n        dmax = large_const\n        while len(que_bfs) > 0:\n            v = que_bfs.pop(0)\n            if G_[v]['dist'] >= dmax:\n                # if too far, pass\n                pass\n            else:\n                # else update dist\n                for d in G_[v]['edges'].keys():    \n                    if G_[d]['edges'][v] > 0:\n                        if d == s:\n                            # src reached\n                            # update\n                            dmax = min(dmax, G_[v]['dist'] + 1)\n                            G_[d]['dist'] = dmax\n                        elif G_[d]['dist'] == -1:\n                            # update\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        elif G_[d]['dist'] > G_[v]['dist'] + 1:\n                            # update (may not happen)\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        else:\n                            pass\n        \n        if G_[s]['dist'] == -1:\n            break\n        else:\n            # find blocking flow with respect to current dist\n            # dfs\n            que_dfs = [[s]]\n            while len(que_dfs) > 0:\n                path = que_dfs.pop()\n                # check if valid\n                if len(path) == 1:\n                    pass\n                elif G_[path[0]]['edges'][path[1]] == 0:\n                    continue\n                v = path[-1]\n                # add\n                for d in G_[v]['edges'].keys():\n                    if G_[v]['edges'][d] > 0 and G_[d]['dist'] == G_[v]['dist'] - 1:\n                        if d == t:\n                            # if reached\n                            path.append(d)\n                            # add flow and update graph with residual\n                            # eps = min([G_[path[i]]['edges'][path[i+1]] for i in range(len(path) - 1)])\n                            eps = 1\n                            max_flow += eps\n                            # imax = len(path)-2\n                            for i in range(len(path) - 1):\n                                G_[path[i]]['edges'][path[i+1]] -= eps\n                                G_[path[i+1]]['edges'][path[i]] += eps\n                                # if G_[path[i]]['edges'][path[i+1]] == 0:\n                                #     imax = min(imax, i)\n                        else:\n                            # append to que\n                            que_dfs.append(path + [d])\n            \n    \n    return max_flow\n\n\n# src:sheeps\n# dst:outer\nadd_node('src')\nadd_node('dst')\n\n# grid\n# nodes\nfor i in range(H):\n    for j in range(W):\n        if X_mat[i, j] == 1:\n            pass\n        else:\n            add_node(str([i, j]) + '-src')\n            add_node(str([i, j]) + '-dst')\n\n# edges\nfor i in range(H):\n    for j in range(W):\n        if X_mat[i, j] == 1:\n            pass\n        else:\n            add_edge(str([i, j]) + '-dst', str([i, j]) + '-src', 1)\n            add_edge(str([i, j]) + '-src', str([i, j]) + '-dst', 0)\n            for d in [[-1, 0], [1, 0], [0, -1], [0, 1]]:\n                k = i + d[0]\n                l = j + d[1]\n                if k in [-1, H] or l in [-1, W]:\n                    add_edge(str([i, j]) + '-src', 'dst', 1)\n                    add_edge('dst', str([i, j]) + '-src', 0)\n                elif X_mat[k, l] == 1:\n                    add_edge('src', str([i, j]) + '-dst', 1)\n                    add_edge(str([i, j]) + '-dst', 'src', 0)\n                else:\n                    add_edge(str([i, j]) + '-src', str([k, l]) + '-dst', 1)\n                    add_edge(str([k, l]) + '-dst', str([i, j]) + '-src', 0)\n\nres = 0\n# find -1\nif X_mat[0,:].sum() + X_mat[H-1,:].sum() + X_mat[:,0].sum() + X_mat[:,W-1].sum() > 0:\n    res = -1\nelse:\n    res = max_flow_dinic('src', 'dst')\n\n\nprint res"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nimport collections\nimport queue\n\n\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.edges = collections.defaultdict(list)\n        self.level = [0 for _ in range(self.N)]\n        self.iter = [0 for _ in range(self.N)]\n\n    def add(self, u, v, c, directed=True):\n        if directed:\n            self.edges[u].append([v, c, len(self.edges[v])])\n            self.edges[v].append([u, 0, len(self.edges[u])-1])\n        else:  # TODO: must be Verified\n            self.edges[u].append([v, c, len(self.edges[v])])\n            self.edges[v].append([u, 0, len(self.edges[u]) - 1])\n            self.edges[v].append([u, c, len(self.edges[u])])\n            self.edges[u].append([v, 0, len(self.edges[v]) - 1])\n\n    def bfs(self, s):\n        self.level = [-1 for _ in range(self.N)]\n        self.level[s] = 0\n        que = queue.Queue()\n        que.put(s)\n        while not que.empty():\n            v = que.get(s)\n            for i in range(len(self.edges[v])):\n                e = self.edges[v][i]\n                if e[1] > 0 and self.level[e[0]] < 0:\n                    self.level[e[0]] = self.level[v] + 1\n                    que.put(e[0])\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        for i in range(self.iter[v], len(self.edges[v])):\n            self.iter[v] = i\n            e = self.edges[v][i]\n            if e[1] > 0 and self.level[v] < self.level[e[0]]:\n                d = self.dfs(e[0], t, min(f, e[1]))\n                if d > 0:\n                    e[1] -= d\n                    self.edges[e[0]][e[2]][1] += d\n                    return d\n        return 0\n\n    def maxFlow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.level[t] < 0:\n                return flow\n            self.iter = [0 for _ in range(self.N)]\n            f = self.dfs(s, t, float('inf'))\n            while f > 0:\n                flow += f\n                f = self.dfs(s, t, float('inf'))\n\n\nH, W = map(int, input().split())\ngraph = Dinic(2*H*W + 2)\ndelta = [-1, 1, W, -W]\ngoal = 2 * H * W + 1\nfor i in range(H):\n    S = str(input())\n    for j, s in enumerate(S):\n        curEdge = i * W + j + 1\n        if s == '.':\n            graph.add(curEdge, curEdge+H*W, 1)\n        else:\n            if i == 0 or i == H-1 or j == 0 or j == W-1:\n                print(-1)\n                quit()\n            graph.add(curEdge, curEdge+H*W, float('inf'))\n            graph.add(0, curEdge, float('inf'))\n        for d in delta:\n            if 0 < curEdge+d < 2*H*W+1:\n                graph.add(curEdge+H*W, curEdge+d, float('inf'))\n\nfor i in range(1, W+1):\n    graph.add(i+H*W, goal, float('inf'))\n    graph.add(i+(2*H-1)*W, goal, float('inf'))\n\nfor i in range(1, H-1):\n    graph.add((i+H)*W+1, goal, float('inf'))\n    graph.add((i+H+1)*W, goal, float('inf'))\n\n\nprint(graph.maxFlow(0, goal))"
  },
  {
    "language": "Python",
    "code": "import sys\nimport itertools\nimport networkx as nx\nH, W = [int(_) for _ in input().split()]\nS = b''.join(sys.stdin.buffer.read().split())\n\nsource = 2 * H * W\nsink = source + 1\n\nINF = H * W * 3\n\ngraph = nx.DiGraph()\n\n\ndef add(start, end, cap):\n    graph.add_edge(start, end, capacity=cap)\n\n\nfor i in range(H * W):\n    x, y = divmod(i, W)\n    if S[i] == ord('.'):\n        add(2 * i, 2 * i + 1, 1)\n    else:\n        add(source, 2 * i + 1, INF)\n    for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n        x1, y1 = x + dx, y + dy\n        if 0 <= x1 < H and 0 <= y1 < W:\n            j = x1 * W + y1\n            add(2 * i + 1, 2 * j, INF)\n        else:\n            add(2 * i + 1, sink, INF)\nans = nx.minimum_cut_value(graph, source, sink)\nans = ans if ans < INF else -1\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nfrom collections import deque\n\n\"\"\"\n・最小カット\n・頂点でカットする場合には、v_in, v_outに分ける\n・v_in, v_outの間に容量1の辺\n・sourceから、ヤギ_outに容量無限大の辺\n・外周_outから、sinkに容量無限大の辺\n\"\"\"\n\nclass Dinic:\n    def __init__(self, N, source, sink):\n        self.N = N\n        self.G = [[] for _ in range(N)]\n        self.source = source\n        self.sink = sink\n\n    def add_edge(self, fr, to, cap):\n        n1 = len(self.G[fr])\n        n2 = len(self.G[to])\n        self.G[fr].append([to, cap, n2])\n        self.G[to].append([fr, 0, n1]) # 逆辺を cap 0 で追加\n        \n    def add_edge_undirected(self, fr, to, cap):\n        n1 = len(self.G[fr])\n        n2 = len(self.G[to])\n        self.G[fr].append([to, cap, n2])\n        self.G[to].append([fr, cap, n1])\n        \n    def bfs(self):\n        level = [0] * self.N\n        G = self.G; source = self.source; sink = self.sink\n        q = deque([source])\n        level[source] = 1\n        pop = q.popleft; append = q.append\n        while q:\n            v = pop()\n            lv = level[v] + 1\n            for to, cap, rev in G[v]:\n                if not cap:\n                    continue\n                if level[to]:\n                    continue\n                level[to] = lv\n                if to == sink:\n                    self.level = level\n                    return\n                append(to)\n        self.level = level\n        \n    def dfs(self,v,f):\n        if v == self.sink:\n            return f\n        G = self.G\n        prog = self.progress\n        level = self.level\n        lv = level[v]\n        E = G[v]\n        for i in range(prog[v],len(E)):\n            to, cap, rev = E[i]\n            prog[v] = i\n            if not cap:\n                continue\n            if level[to] <= lv:\n                continue\n            x = f if f < cap else cap\n            ff = self.dfs(to, x)\n            if ff:\n                E[i][1] -= ff\n                G[to][rev][1] += ff\n                return ff\n        return 0\n    \n    def max_flow(self):\n        INF = 10**18\n        flow = 0\n        while True:\n            self.bfs()\n            if not self.level[self.sink]:\n                return flow\n            self.progress = [0] * self.N\n            while True:\n                f = self.dfs(self.source, INF)\n                if not f:\n                    break\n                flow += f\n        return flow\n\nH,W = map(int,readline().split())\nS = b''.join(read().split())\n\n# v_i-in: 2i\n# v_i-out: 2i+1\nsource = 2*H*W\nsink = source+1\n\nINF = 10**12\n\ndinic = Dinic(2*H*W+2,source,sink)\nadd = dinic.add_edge\nfor i in range(H*W):\n    h,w = divmod(i,W)\n    if S[i] == ord('.'):\n        add(i+i,i+i+1,1)\n    else:\n        add(source,i+i+1,INF)\n    for dh,dw in ((1,0),(-1,0),(0,1),(0,-1)):\n        h1 = h + dh; w1 = w + dw\n        if 0 <= h1 < H and 0 <= w1 < W:\n            j = h1 * W + w1\n            add(i+i+1,j+j,1)\n        else:\n            # 画面外\n            add(i+i+1,sink,INF)\n\nf = dinic.max_flow()\nanswer = f if f < INF else -1\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "H, W = map(int, input().split())\nfield = [[c for c in input()] for _ in range(H)]\n\nif \"X\" in field[0]+field[1]+[l[0] for l in field]+[l[-1] for l in field]:\n    print(-1)\nelse:\n    for h in range(H):\n        for w in range(W):\n            if field[h][w]==\"X\":\n                field[h-1][w] = \"#\"\n                field[h+1][w] = \"#\"\n                field[h][w-1] = \"#\"\n                field[h][w+1] = \"#\"\n    field2 = [[x for x in line] for line in field]\n    for h in range(1, H-1):\n        for w in range(1, W-1):\n            if field[h][w] == \"#\":\n                f = True\n                for y in range(h-1, h+2):\n                    for  x in range(w-1, w+2):\n                        if field[y][x] == \".\":\n                            f = False\n                if f:\n                    field2[h][w] = \".\"\nprint(sum(1 for line in field2 for x in line if x==\"#\"))"
  },
  {
    "language": "Python",
    "code": "def rotate(h,w):\n    for i in xrange(h):\n        for j in xrange(w):\n            rs[j][h-1-i]=s[i][j]\n    return rs\n\nh,w=map(int,raw_input().split())\ns=[raw_input() for _ in xrange(h)]\nrs=[[\"\"]*h for _ in xrange(w)]\nrs=rotate(h,w)\n\nfor i in xrange(h):\n    if s[i][w-1]==\"X\" or s[i][0]==\"X\":\n        print(-1)\n        exit()\nfor j in xrange(w):\n    if s[h-1][j]==\"X\" or s[0][j]==\"X\":\n        print(-1)\n        exit()\n\n#up\nfor i in xrange(h):\n    if \"X\" in s[i]:\n        up=i-1\n        cnt=s[i].count(\"X\")\n        break\nif cnt>1:\n    upl=s[up+1].index(\"X\")\n    upr=w-1-list(reversed(s[up+1])).index(\"X\")\nelse:\n    upl=upr=s[up+1].index(\"X\")\n\n#under\nfor i in xrange(h-1,-1,-1):\n    if \"X\" in s[i]:\n        un=i+1\n        cnt=s[i].count(\"X\")\n        break\nif cnt>1:\n    unl=s[un-1].index(\"X\")\n    unr=w-1-list(reversed(s[un-1])).index(\"X\")\nelse:\n    unl=unr=s[un-1].index(\"X\")\n\n#left\nfor i in xrange(w):\n    if \"X\" in rs[i]:\n        left=i-1\n        cnt=rs[i].count(\"X\")\n        break\nif cnt>1:\n    lun=rs[left+1].index(\"X\")\n    lup=h-1-list(reversed(rs[left+1])).index(\"X\")\nelse:\n    lup=lun=rs[left+1].index(\"X\")\n\n#right\nfor i in xrange(w-1,-1,-1):\n    if \"X\" in rs[i]:\n        right=i+1\n        cnt=rs[i].count(\"X\")\n        break\nif cnt>1:\n    run=rs[right-1].index(\"X\")\n    rup=h-1-list(reversed(rs[right-1])).index(\"X\")\nelse:\n    rup=run=rs[right-1].index(\"X\")\n\"\"\"\nprint upl,upr\nprint unl,unr\nprint lup,lun\nprint rup,run\nprint up,un,left,right\n\"\"\"\nans=0\nif upl-left==up-lup:\n    ans+=upl-left-1\nelse:\n    ans+=min(upl-left,up-lup)-1+abs(upl-left-(up-lup))\nif lun-un==unl-left:\n    ans+=lun-un-1\nelse:\n    ans+=min(lun-un,unl-left)-1+abs(lun-un-(unl-left))\nif right-unr==run-un:\n    ans+=right-unr-1\nelse:\n    ans+=min(right-unr,run-un)-1+abs(right-unr-(run-un))\nif right-upr==up-rup:\n    ans+=right-upr-1\nelse:\n    ans+=min(right-upr,up-rup)-1+abs(right-upr-(up-rup))\nans+=upr-upl+1+unr-unl+1+lup-lun+1+rup-run+1\nprint ans"
  },
  {
    "language": "Python",
    "code": "\nimport numpy as np\n\nH, W = map(int, raw_input().split())\ntbl = []\nfor i in range(H):\n    _ = map(int, list(raw_input().replace('X','1').replace('.','0')))\n    tbl.append(_)\n    \n# debug (restart)\n#tbl = [[0, 0, 0, 0, 0, 0],\n#       [0, 0, 0, 0, 0, 0],\n#       [0, 0, 1, 0, 0, 0],\n#       [0, 1, 0, 0, 1, 0],\n#       [0, 0, 1, 0, 0, 0],\n#       [0, 0, 0, 0, 0, 0]]\n       \ntbl = np.array(tbl)\nr_size, c_size = H-1, W-1\nsaku = np.zeros((H,W))\nr, c = np.nonzero(tbl)\nif 0 in r or H-1 in r or 0 in c or W-1 in c:\n    print -1\nelse:\n    # mk saku             \n    for i,j in zip(r,c):\n        saku[i-1,j] =1\n        saku[i+1,j] =1\n        saku[i,j-1] =1\n        saku[i,j+1] =1\n        \n    # remove redundant saku\n    r, c = np.nonzero(saku)\n    \n    for i, j in zip(r,c):\n        r_max = max(np.arange(W)[saku[i,:]==1])\n        r_min = min(np.arange(W)[saku[i,:]==1])\n        c_max = max(np.arange(H)[saku[:,j]==1])\n        c_min = min(np.arange(H)[saku[:,j]==1])\n        if r_min < j < r_max and c_min < i < c_max:\n            saku[i,j]=0\n\nr,c = np.nonzero(saku)\n\nprint len(r)"
  },
  {
    "language": "Python",
    "code": "import itertools\nimport networkx as nx\nH, W = [int(_) for _ in input().split()]\nS = [input() for _ in range(H)]\n\nsource = 2 * H * W\nsink = source + 1\n\nINF = 10**12\n\ngraph = nx.DiGraph()\n\n\ndef add(start, end, cap):\n    graph.add_edge(start, end, capacity=cap)\n\n\nfor x, y in itertools.product(range(H), range(W)):\n    i = x * W + y\n    if S[x][y] == '.':\n        add(2 * i, 2 * i + 1, 1)\n    else:\n        add(source, 2 * i + 1, INF)\n    for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n        x1, y1 = x + dx, y + dy\n        if 0 <= x1 < H and 0 <= y1 < W:\n            j = x1 * W + y1\n            add(2 * i + 1, 2 * j, 1)\n        else:\n            add(2 * i + 1, sink, INF)\nans = nx.minimum_cut_value(graph, source, sink)\nans = ans if ans < INF else -1\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "\nH, W = map(int, raw_input().split())\nS_list = list()\nfor i in range(H):\n    S_list.append(raw_input())\n\n# large_const\nlarge_const = 100000\n\n# X_mat = np.zeros((H, W), dtype='int')\nX_mat = [[0]*W]*H\n\n# input\nfor h in range(H):\n    for w in range(W):\n        if S_list[h][w] == 'X':\n            X_mat[h, w] += 1\n\n# make graph\nG = dict()\ndef add_node(s, Graph=G):\n    Graph[s] = {'edges':dict()}\n    \ndef add_edge(s, t, weight=1, Graph=G):\n    Graph[s]['edges'][t] = weight\n\ndef max_flow_dinic(s, t, Graph=G):\n    G_ = Graph\n    max_flow = 0\n    while True:\n        # create level Graph(reverse)\n        # initialize\n        for v in G_.keys():\n            G_[v]['dist'] = -1\n        # dst\n        G_[t]['dist'] = 0\n        # bfs \n        que_bfs = [t]\n        dmax = large_const\n        while len(que_bfs) > 0:\n            v = que_bfs.pop(0)\n            if G_[v]['dist'] >= dmax:\n                # if too far, pass\n                pass\n            else:\n                # else update dist\n                for d in G_[v]['edges'].keys():    \n                    if G_[d]['edges'][v] > 0:\n                        if d == s:\n                            # src reached\n                            # update\n                            dmax = min(dmax, G_[v]['dist'] + 1)\n                            G_[d]['dist'] = dmax\n                        elif G_[d]['dist'] == -1:\n                            # update\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        elif G_[d]['dist'] > G_[v]['dist'] + 1:\n                            # update (may not happen)\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        else:\n                            pass\n        \n        if G_[s]['dist'] == -1:\n            break\n        else:\n            # find blocking flow with respect to current dist\n            # dfs\n            que_dfs = [[s]]\n            while len(que_dfs) > 0:\n                path = que_dfs.pop()\n                # check if valid\n                if len(path) == 1:\n                    pass\n                elif G_[path[0]]['edges'][path[1]] == 0:\n                    continue\n                v = path[-1]\n                # add\n                for d in G_[v]['edges'].keys():\n                    if G_[v]['edges'][d] > 0 and G_[d]['dist'] == G_[v]['dist'] - 1:\n                        if d == t:\n                            # if reached\n                            path.append(d)\n                            # add flow and update graph with residual\n                            # eps = min([G_[path[i]]['edges'][path[i+1]] for i in range(len(path) - 1)])\n                            eps = 1\n                            max_flow += eps\n                            # imax = len(path)-2\n                            for i in range(len(path) - 1):\n                                G_[path[i]]['edges'][path[i+1]] -= eps\n                                G_[path[i+1]]['edges'][path[i]] += eps\n                                # if G_[path[i]]['edges'][path[i+1]] == 0:\n                                #     imax = min(imax, i)\n                        else:\n                            # append to que\n                            que_dfs.append(path + [d])\n            \n    \n    return max_flow\n\n\n# src:sheeps\n# dst:outer\nadd_node('src')\nadd_node('dst')\n\n# grid\n# nodes\nfor i in range(H):\n    for j in range(W):\n        if X_mat[i, j] == 1:\n            pass\n        else:\n            add_node(str([i, j]) + '-src')\n            add_node(str([i, j]) + '-dst')\n\n# edges\nfor i in range(H):\n    for j in range(W):\n        if X_mat[i, j] == 1:\n            pass\n        else:\n            add_edge(str([i, j]) + '-dst', str([i, j]) + '-src', 1)\n            add_edge(str([i, j]) + '-src', str([i, j]) + '-dst', 0)\n            for d in [[-1, 0], [1, 0], [0, -1], [0, 1]]:\n                k = i + d[0]\n                l = j + d[1]\n                if k in [-1, H] or l in [-1, W]:\n                    add_edge('src', str([i, j]) + '-dst', 1)\n                    add_edge(str([i, j]) + '-dst', 'src', 0)\n                elif X_mat[k, l] == 1:\n                    add_edge(str([i, j]) + '-src', 'dst', 1)\n                    add_edge('dst', str([i, j]) + '-src', 0)                    \n                else:\n                    add_edge(str([i, j]) + '-src', str([k, l]) + '-dst', 1)\n                    add_edge(str([k, l]) + '-dst', str([i, j]) + '-src', 0)\n\nres = 0\n# find -1\nif X_mat[0,:].sum() + X_mat[H-1,:].sum() + X_mat[:,0].sum() + X_mat[:,W-1].sum() > 0:\n    res = -1\nelse:\n    res = max_flow_dinic('src', 'dst')\n\n\nprint res"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\n\nclass Dinic:\n    def __init__(self, N, inf):\n        self.N = N\n        self.inf = inf\n        self.G = [[] for _ in range(N)]\n        self.level = [0]*N\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s):\n        self.level = [-1]*self.N\n        deq = deque([s])\n        self.level[s] = 0\n        while deq:\n            v = deq.pop()\n            lv = self.level[v] + 1\n            for w, cap, _ in self.G[v]:\n                if cap > 0 and self.level[w] == -1:\n                    self.level[w] = lv\n                    deq.appendleft(w)\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        for e in self.iter[v]:\n            w, cap, rev = e\n            if cap > 0 and self.level[v] < self.level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d > 0:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.level[t] == -1:\n                return flow\n            *self.iter, = map(iter, self.G)\n            f = self.inf\n            while f > 0:\n                f = self.dfs(s, t, self.inf)\n                flow += f\n\n\nimport sys\n\nsys.setrecursionlimit(10**7)\ndef I(): return int(sys.stdin.readline().rstrip())\ndef MI(): return map(int,sys.stdin.readline().rstrip().split())\ndef LS2(): return list(sys.stdin.readline().rstrip())  #空白なし\n\n\nH,W = MI()\nS = [LS2() for _ in range(H)]\n\nDi = Dinic(2*H*W+2,10000)\ns,t = 2*H*W,2*H*W+1\n\nfor i in range(H):\n    for j in range(W):\n        if S[i][j] == 'X':\n            Di.add_edge(s,W*i+j,10000)\n\nfor j in range(W):\n    Di.add_edge(H*W+j,t,10000)\n    Di.add_edge(H*W+W*(H-1)+j,t,10000)\nfor i in range(1,H-1):\n    Di.add_edge(H*W+W*i,t,10000)\n    Di.add_edge(H*W+W*i+(W-1),t,10000)\n\nfor i in range(H):\n    for j in range(W-1):\n        Di.add_edge(H*W+W*i+j,W*i+(j+1),10000)\n        Di.add_edge(H*W+W*i+(j+1),W*i+j,10000)\nfor i in range(H-1):\n    for j in range(W):\n        Di.add_edge(H*W+W*i+j,W*(i+1)+j,10000)\n        Di.add_edge(H*W+W*(i+1)+j,W*i+j,10000)\n\nfor i in range(H):\n    for j in range(W):\n        if S[i][j] == '.':\n            Di.add_edge(W*i+j,H*W+W*i+j,1)\n        else:\n            Di.add_edge(W*i+j,H*W+W*i+j,10000)\n\nflow = Di.flow(s,t)\nprint(flow if flow != 10000 else -1)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\ndef main():\n    h, w = map(int, raw_input().split())\n    a = [raw_input().strip() for _ in xrange(h)]\n    if a[0].count('X') or a[-1].count('X') or zip(*a)[0].count('X') or zip(*a)[-1].count('X'):\n        print -1\n        quit()\n    inf = 10 ** 9\n    N = h * w\n    g = [[] for _ in xrange(N * 2 + 2)]\n    t = 0\n    so = N * 2\n    si = so + 1\n    def add_edge(f, t, cap, rcap):\n        g[f].append([t, cap, len(g[t])])\n        g[t].append([f, rcap, len(g[f]) - 1])\n    for i in xrange(h):\n        for j in xrange(w):\n            if a[i][j] == 'X':\n                add_edge(so, t + N, inf, 0)\n            if i == 0 or i == h - 1 or j == 0 or j == w - 1:\n                add_edge(t, si, inf, 0)\n            if i:\n                add_edge(t + N, t - w, 1, 0)\n            if i < h - 1:\n                add_edge(t + N, t + w, 1, 0)\n            if j:\n                add_edge(t + N, t - 1, 1, 0)\n            if j < w - 1:\n                add_edge(t + N, t + 1, 1, 0)\n            add_edge(t, t + N, 1, 0)\n            t += 1\n    def dfs(v, si, f):\n        global w\n        if v == si:\n            return f\n        d[v] = 1\n        return 0\n    ans = 0\n    st = []\n    pu = st.append\n    po = st.pop\n    while 1:\n        d = [inf] * (si + 1)\n        d[so] = 0\n        q = deque([so])\n        while q:\n            x = q.popleft()\n            for e in g[x]:\n                if e[1] and d[e[0]] == inf:\n                    d[e[0]] = d[x] + 1\n                    q.append(e[0])\n        if d[si] == inf:\n            break\n        it = [0] * (si + 1)\n        while 1:\n            pu((so, inf))\n            ret = 0\n            while st:\n                v, f = po()\n                if v == si:\n                    ret = f\n                    continue\n                if ret == 0:\n                    for i in xrange(it[v], len(g[v])):\n                        e = g[v][i]\n                        if d[v] >= d[e[0]] or not e[1]:\n                           continue\n                        pu((v, f))\n                        pu((e[0], min(f, e[1])))\n                        break\n                    it[v] = i + 1\n                else:\n                    e = g[v][it[v]-1]\n                    e[1] -= ret\n                    g[e[0]][e[2]][1] += ret\n            if not ret:\n                break\n            ans += ret\n    print ans\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, log\nfrom itertools import accumulate, permutations, combinations, product\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\n\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nclass Dinic:\n    def __init__(self, v, inf =10**10):\n        self.v = v\n        self.inf = inf\n        self.G = [[] for _ in range(v)]\n        self.level = [-1]*v  # 深さ\n        self.ite = [0]*v  # DFSでの探索が済んでいるか\n    def add_edge(self, fr, to, cap):\n        self.G[fr].append([to, cap, len(self.G[to])])\n        self.G[to].append([fr, 0, len(self.G[fr])-1])\n    def bfs(self, s):  # BFSで深さ決定,sがstart\n        self.level = [-1]*self.v  # 必要\n        self.level[s] = 0\n        Q = deque()\n        Q.append(s)\n        while Q:\n            v = Q.popleft()\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if e[1]>0 and self.level[e[0]]<0: ###capacity>0かつtoの深さ未定\n                    self.level[e[0]] = self.level[v]+1\n                    Q.append(e[0])\n    def dfs(self, v, t, f):  # DFSで増加パス探索,v開始、t終点、総フローf\n        if v==t:\n            return f\n        for i in range(self.ite[v],len(self.G[v])):\n            self.ite[v] = i\n            e = self.G[v][i]\n            if e[1]>0 and self.level[v]<self.level[e[0]]:\n                d = self.dfs(e[0], t, min(f, e[1]))\n                if d>0:\n                    e[1] -= d  # cap減少\n                    self.G[e[0]][e[2]][1] += d  # 逆辺のcap増加\n                    return d\n        return 0\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.level[t]<0:\n                return flow\n            self.ite = [0]*self.v  # DFSでの探索が済んでいるか否か\n            f =self.dfs(s,t,self.inf)\n            while f>0:\n                flow+= f\n                f = self.dfs(s,t,self.inf)\n\nH, W = MAP()\nS = [input() for _ in range(H)]\n\nD = Dinic(2*H*W+2)\ndx = [0, -1, 0, 1]\ndy = [1, 0, -1, 0]\ns = 2*H*W\nt = 2*H*W+1\nfor i in range(H):\n    for j in range(W):\n        if S[i][j] == \"X\":\n            if i == 0 or i == H-1  or j == 0 or j == W-1:\n                print(-1)\n                exit()\n            D.add_edge(s, W*i+j, INF)\n            for k in range(4):\n                ny = i+dy[k]\n                nx = j+dx[k]\n                D.add_edge(W*i+j, W*ny+nx, INF)\n        else:\n            D.add_edge(W*i+j, W*H+W*i+j, 1)\n            if i == 0 or i == H-1  or j == 0 or j == W-1:\n                D.add_edge(H*W+W*i+j, t, INF)\n            else:\n                for k in range(4):\n                    ny = i+dy[k]\n                    nx = j+dx[k]\n                    D.add_edge(H*W+W*i+j, W*ny+nx, INF)\n\nprint(D.max_flow(s, t))\n"
  },
  {
    "language": "Python",
    "code": "import itertools\nimport os\nimport sys\nfrom collections import deque\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nH, W = list(map(int, sys.stdin.readline().split()))\nS = [sys.stdin.readline().rstrip() for _ in range(H)]\n\n\nclass FordFulkerson:\n    def __init__(self, graph=None, residual=None):\n        \"\"\"\n        :param list of (list of (int, int)) graph: (to, cap) の隣接リスト\n        :param list of (list of (list of (int|list))) residual: (to, cap, rev) の残余グラフ\n        \"\"\"\n        assert (graph and not residual) or (not graph and residual)\n        if graph:\n            self.graph = self.residual_graph(graph)\n        else:\n            self.graph = residual\n\n    @staticmethod\n    def residual_graph(graph):\n        \"\"\"\n        残余グラフ構築\n        :param list of (list of (int, int)) graph: (to, cap) の隣接リスト\n        :rtype: list of (list of (list of (int|list)))\n        :return: (to, cap, rev) の残余グラフ\n        \"\"\"\n        ret = [[] for _ in range(len(graph))]\n        for v in range(len(graph)):\n            for u, cap in graph[v]:\n                rev = [v, 0]\n                edge = [u, cap, rev]\n                rev.append(edge)\n                ret[v].append(edge)\n                ret[u].append(rev)\n        return ret\n\n    def _dfs(self, s, t, used, flow=float('inf')):\n        \"\"\"\n        :param int s:\n        :param int t:\n        :param list of bool used:\n        :param int flow:\n        \"\"\"\n        if s == t:\n            return flow\n        used[s] = True\n        for edge in self.graph[s]:\n            to, cap, rev = edge\n            if not used[to] and cap > 0:\n                f = self._dfs(to, t, used, min(flow, cap))\n                if f > 0:\n                    edge[1] -= f\n                    rev[1] += f\n                    return f\n        return 0\n\n    def maximum_flow(self, from_v, to_v):\n        \"\"\"\n        :param int from_v:\n        :param int to_v:\n        :return: from_v から to_v への最大流\n        \"\"\"\n        ret = 0\n        while True:\n            flow = self._dfs(from_v, to_v, [False] * len(self.graph))\n            if flow == 0:\n                break\n            ret += flow\n        return ret\n\n\ngraph = [[] for _ in range(H * W * 2 + 2)]\nst = H * W * 2\nen = H * W * 2 + 1\noffset = H * W\nfor h, w in itertools.product(range(H), range(W)):\n    pin = h * W + w\n    pout = pin + offset\n    if S[h][w] == \"X\":\n        graph[st].append((pout, IINF))\n    else:\n        graph[pin].append((pout, 1))\n    for dh, dw in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n        h2, w2 = h + dh, w + dw\n        if 0 <= h2 < H and 0 <= w2 < W:\n            qin = h2 * W + w2\n            graph[pout].append((qin, IINF))\n        else:\n            graph[pout].append((en, IINF))\n\nmincut = FordFulkerson(graph=graph).maximum_flow(st, en)\nif mincut >= IINF:\n    print(-1)\nelse:\n    print(mincut)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport itertools\nimport networkx as nx\nH, W = map(int, sys.stdin.buffer.readline().split())\nS = b''.join(sys.stdin.buffer.read().split())\n\nsource = 2 * H * W\nsink = source + 1\n\nINF = source * 2\n\ngraph = nx.DiGraph()\n\n\ndef add(start, end, cap):\n    graph.add_edge(start, end, capacity=cap)\n\n\nfor i in range(H * W):\n    x, y = divmod(i, W)\n    if S[i] == ord('.'):\n        add(2 * i, 2 * i + 1, 1)\n    else:\n        add(source, 2 * i + 1, INF)\n    for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n        x1, y1 = x + dx, y + dy\n        if 0 <= x1 < H and 0 <= y1 < W:\n            j = x1 * W + y1\n            add(2 * i + 1, 2 * j, INF)\n        else:\n            add(2 * i + 1, sink, INF)\nans = nx.minimum_cut_value(graph, source, sink)\nans = ans if ans < INF else -1\nif H == 2:\n    0 / 0\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "# refer: https://atcoder.jp/contests/kupc2016/submissions/8828418\n# changed: line 134(137), 142(146)\nimport sys\nimport time\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nfrom collections import deque\n\n\"\"\"\n・最小カット\n・頂点でカットする場合には、v_in, v_outに分ける\n・v_in, v_outの間に容量1の辺\n・sourceから、ヤギ_outに容量無限大の辺\n・外周_outから、sinkに容量無限大の辺\n\"\"\"\ntimestart = time.time()\nH,W = map(int,readline().split())\nS = b''.join(read().split())\n\nclass Dinic:\n    def __init__(self, N, source, sink):\n        self.N = N\n        self.G = [[] for _ in range(N)]\n        self.source = source\n        self.sink = sink\n\n    def add_edge(self, fr, to, cap):\n        n1 = len(self.G[fr])\n        n2 = len(self.G[to])\n        self.G[fr].append([to, cap, n2])\n        self.G[to].append([fr, 0, n1]) # 逆辺を cap 0 で追加\n\n    def add_edge_undirected(self, fr, to, cap):\n        n1 = len(self.G[fr])\n        n2 = len(self.G[to])\n        self.G[fr].append([to, cap, n2])\n        self.G[to].append([fr, cap, n1])\n\n    def bfs(self):\n        level = [0] * self.N\n        G = self.G; source = self.source; sink = self.sink\n        q = deque([source])\n        level[source] = 1\n        pop = q.popleft; append = q.append\n        while q:\n            v = pop()\n            lv = level[v] + 1\n            for to, cap, rev in G[v]:\n                if not cap:\n                    continue\n                if level[to]:\n                    continue\n                level[to] = lv\n                if to == sink:\n                    self.level = level\n                    return\n                append(to)\n        self.level = level\n\n    def dfs(self):\n        INF = 10**18\n        G = self.G\n        sink = self.sink\n        prog = self.progress\n        level = self.level\n        ascend = False\n        ff = 0\n        stack = [(self.source,INF)]\n        while stack:\n            if ff:\n                # このまま更新だけして戻っていく\n                v,f = stack.pop()\n                p = prog[v]\n                to, cap, rev = G[v][p]\n                G[v][p][1] -= ff\n                G[to][rev][1] += ff\n                continue\n            v,f = stack[-1]\n            if v == sink:\n                ff = f\n                stack.pop()\n                continue\n            E = G[v]\n            lv = level[v]\n            if ascend:\n                # 流せずに戻ってきた\n                prog[v] += 1\n            find_flag = False\n            for i in range(prog[v],len(E)):\n                to, cap, rev = E[i]\n                prog[v] = i\n                if not cap:\n                    continue\n                if level[to] <= lv:\n                    continue\n                find_flag = True\n                break\n            if not find_flag:\n                ascend = True\n                stack.pop()\n                continue\n            ascend = False\n            x = f if f < cap else cap\n            stack.append((to,x))\n        return ff\n\n    def max_flow(self):\n        flow = 0\n        while True:\n            self.bfs()\n            if not self.level[self.sink]:\n                return flow\n            self.progress = [0] * self.N\n            while True:\n                f = self.dfs()\n                if not f:\n                    break\n                flow += f\n        return flow\n\n# v_i-in: 2i\n# v_i-out: 2i+1\nsource = 2*H*W\nsink = source+1\n\nINF = 10**12\n\ndinic = Dinic(2*H*W+2,source,sink)\nadd = dinic.add_edge\nfor i in range(H*W):\n    h,w = divmod(i,W)\n    if S[i] == ord('.'):\n        add(i+i,i+i+1,1)\n    else:\n        add(i+i,sink,INF)\n        # add(source,i+i+1,INF)\n    for dh,dw in ((1,0),(-1,0),(0,1),(0,-1)):\n        h1 = h + dh; w1 = w + dw\n        if 0 <= h1 < H and 0 <= w1 < W:\n            j = h1 * W + w1\n            add(i+i+1,j+j,1)\n        else:\n            # 画面外\n            add(source,i+i,INF)\n            # add(i+i+1,sink,INF)\n\ndinic.source\n\nf = dinic.max_flow()\nanswer = f if f < INF else -1\nprint(answer)\nelapsed_time = time.time() - timestart\nprint(elapsed_time)\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nimport collections\nimport queue\n\n\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.edges = collections.defaultdict(list)\n        self.level = [0 for _ in range(self.N)]\n        self.iter = [0 for _ in range(self.N)]\n\n    def add(self, u, v, c, directed=True):\n        if directed:\n            self.edges[u].append([v, c, len(self.edges[v])])\n            self.edges[v].append([u, 0, len(self.edges[u])-1])\n        else:  # TODO: must be Verified\n            self.edges[u].append([v, c, len(self.edges[v])])\n            self.edges[v].append([u, 0, len(self.edges[u]) - 1])\n            self.edges[v].append([u, c, len(self.edges[u])])\n            self.edges[u].append([v, 0, len(self.edges[v]) - 1])\n\n    def bfs(self, s):\n        self.level = [-1 for _ in range(self.N)]\n        self.level[s] = 0\n        que = collections.deque([s]) #queue.Queue()\n        #que.put(s)\n        while que: #.empty():\n            v = que.popleft() #.get(s)\n            for i in range(len(self.edges[v])):\n                e = self.edges[v][i]\n                if e[1] > 0 and self.level[e[0]] < 0:\n                    self.level[e[0]] = self.level[v] + 1\n                    que.append(e[0]) # put(e[0])\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        for i in range(self.iter[v], len(self.edges[v])):\n            self.iter[v] = i\n            e = self.edges[v][i]\n            if e[1] > 0 and self.level[v] < self.level[e[0]]:\n                d = self.dfs(e[0], t, min(f, e[1]))\n                if d > 0:\n                    e[1] -= d\n                    self.edges[e[0]][e[2]][1] += d\n                    return d\n        return 0\n\n    def maxFlow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.level[t] < 0:\n                return flow\n            self.iter = [0 for _ in range(self.N)]\n            f = self.dfs(s, t, float('inf'))\n            while f > 0:\n                flow += f\n                f = self.dfs(s, t, float('inf'))\n\n\nH, W = map(int, input().split())\ngraph = Dinic(2*H*W + 2)\ndelta = [-1, 1, W, -W]\ngoal = 2 * H * W + 1\nfor i in range(H):\n    S = str(input())\n    for j, s in enumerate(S):\n        curEdge = i * W + j + 1\n        if s == '.':\n            graph.add(curEdge, curEdge+H*W, 1)\n        else:\n            if i == 0 or i == H-1 or j == 0 or j == W-1:\n                print(-1)\n                quit()\n            graph.add(curEdge, curEdge+H*W, float('inf'))\n            graph.add(0, curEdge, float('inf'))\n        for d in delta:\n            if 0 < curEdge+d < 2*H*W+1:\n                graph.add(curEdge+H*W, curEdge+d, float('inf'))\n\nfor i in range(1, W+1):\n    graph.add(i+H*W, goal, float('inf'))\n    graph.add(i+(2*H-1)*W, goal, float('inf'))\n\nfor i in range(1, H-1):\n    graph.add((i+H)*W+1, goal, float('inf'))\n    graph.add((i+H+1)*W, goal, float('inf'))\n\n\nprint(graph.maxFlow(0, goal))"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nfrom collections import deque\n\n\"\"\"\n・最小カット\n・頂点でカットする場合には、v_in, v_outに分ける\n・v_in, v_outの間に容量1の辺\n・sourceから、ヤギ_outに容量無限大の辺\n・外周_outから、sinkに容量無限大の辺\n\"\"\"\n\nH,W = map(int,readline().split())\nS = b''.join(read().split())\n\nclass Dinic:\n    def __init__(self, N, source, sink):\n        self.N = N\n        self.G = [[] for _ in range(N)]\n        self.source = source\n        self.sink = sink\n\n    def add_edge(self, fr, to, cap):\n        n1 = len(self.G[fr])\n        n2 = len(self.G[to])\n        self.G[fr].append([to, cap, n2])\n        self.G[to].append([fr, 0, n1]) # 逆辺を cap 0 で追加\n        \n    def add_edge_undirected(self, fr, to, cap):\n        n1 = len(self.G[fr])\n        n2 = len(self.G[to])\n        self.G[fr].append([to, cap, n2])\n        self.G[to].append([fr, cap, n1])\n        \n    def bfs(self):\n        level = [0] * self.N\n        G = self.G; source = self.source; sink = self.sink\n        q = deque([source])\n        level[source] = 1\n        pop = q.popleft; append = q.append\n        while q:\n            v = pop()\n            lv = level[v] + 1\n            for to, cap, rev in G[v]:\n                if not cap:\n                    continue\n                if level[to]:\n                    continue\n                level[to] = lv\n                if to == sink:\n                    self.level = level\n                    return\n                append(to)\n        self.level = level\n        \n    def dfs(self):\n        INF = 10**18\n        G = self.G\n        sink = self.sink\n        prog = self.progress\n        level = self.level\n        ascend = False\n        ff = 0\n        stack = [(self.source,INF)]\n        while stack:\n            if ff:\n                # このまま更新だけして戻っていく\n                v,f = stack.pop()\n                p = prog[v]\n                to, cap, rev = G[v][p]\n                G[v][p][1] -= ff\n                G[to][rev][1] += ff\n                continue\n            v,f = stack[-1]\n            if v == sink:\n                ff = f\n                stack.pop()\n                continue\n            E = G[v]\n            lv = level[v]\n            if ascend:\n                # 流せずに戻ってきた\n                prog[v] += 1\n            find_flag = False\n            for i in range(prog[v],len(E)):\n                to, cap, rev = E[i]\n                prog[v] = i\n                if not cap:\n                    continue\n                if level[to] <= lv:\n                    continue\n                find_flag = True\n                break\n            if not find_flag:\n                ascend = True\n                stack.pop()\n                continue\n            ascend = False\n            x = f if f < cap else cap\n            stack.append((to,x))\n        return ff\n    \n    def max_flow(self):\n        flow = 0\n        while True:\n            self.bfs()\n            if not self.level[self.sink]:\n                return flow\n            self.progress = [0] * self.N\n            while True:\n                f = self.dfs()\n                if not f:\n                    break\n                flow += f\n        return flow\n\n# v_i-in: 2i\n# v_i-out: 2i+1\nsource = 2*H*W\nsink = source+1\n\nINF = 10**12\n\ndinic = Dinic(2*H*W+2,source,sink)\nadd = dinic.add_edge\nfor i in range(H*W):\n    h,w = divmod(i,W)\n    if S[i] == ord('.'):\n        add(i+i,i+i+1,1)\n    else:\n        add(source,i+i+1,INF)\n    for dh,dw in ((1,0),(-1,0),(0,1),(0,-1)):\n        h1 = h + dh; w1 = w + dw\n        if 0 <= h1 < H and 0 <= w1 < W:\n            j = h1 * W + w1\n            add(i+i+1,j+j,1)\n        else:\n            # 画面外\n            add(i+i+1,sink,INF)\n\ndinic.source\n\nf = dinic.max_flow()\nanswer = f if f < INF else -1\nprint(answer)\n\n"
  },
  {
    "language": "Python",
    "code": "import pprint\nimport networkx as nx\nimport itertools\nH, W = [int(_) for _ in input().split()]\nS = [input() for _ in range(H)]\ngraph = nx.DiGraph()\nfor h, w in itertools.product(range(H), range(W)):\n    coord = (h, w)\n    edge = (h, w, 'edge')\n    if S[h][w] == 'X':\n        graph.add_edge('source', edge, capacity=10**10)\n    graph.add_edge(coord, edge, capacity=1)\n    if 0 < h < H - 1 and 0 < w < W - 1:\n        for dh, dw in [[-1, 0], [1, 0], [0, -1], [0, 1]]:\n            newh, neww = h + dh, w + dw\n            newcoord = (newh, neww)\n            graph.add_edge(edge, newcoord, capacity=1)\n    else:\n        graph.add_edge(edge, 'sink', capacity=10**10)\nans = nx.minimum_cut_value(graph, 'source', 'sink')\nprint(-1 if ans >= 10**10 else ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, log\nfrom itertools import accumulate, permutations, combinations, product\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\n\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nclass Dinic:\n    def __init__(self, v, inf =10**10):\n        self.v = v\n        self.inf = inf\n        self.G = [[] for _ in range(v)]\n        self.level = [-1]*v  # 深さ\n        self.ite = [0]*v  # DFSでの探索が済んでいるか\n    def add_edge(self, fr, to, cap):\n        self.G[fr].append([to, cap, len(self.G[to])])\n        self.G[to].append([fr, 0, len(self.G[fr])-1])\n    def bfs(self, s):  # BFSで深さ決定,sがstart\n        self.level = [-1]*self.v  # 必要\n        self.level[s] = 0\n        Q = deque()\n        Q.append(s)\n        while Q:\n            v = Q.popleft()\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if e[1]>0 and self.level[e[0]]<0: ###capacity>0かつtoの深さ未定\n                    self.level[e[0]] = self.level[v]+1\n                    Q.append(e[0])\n    def dfs(self, v, t, f):  # DFSで増加パス探索,v開始、t終点、総フローf\n        if v==t:\n            return f\n        for i in range(self.ite[v],len(self.G[v])):\n            self.ite[v] = i\n            e = self.G[v][i]\n            if e[1]>0 and self.level[v]<self.level[e[0]]:\n                d = self.dfs(e[0], t, min(f, e[1]))\n                if d>0:\n                    e[1] -= d  # cap減少\n                    self.G[e[0]][e[2]][1] += d  # 逆辺のcap増加\n                    return d\n        return 0\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.level[t]<0:\n                return flow\n            self.ite = [0]*self.v  # DFSでの探索が済んでいるか否か\n            f =self.dfs(s,t,self.inf)\n            while f>0:\n                flow+= f\n                f = self.dfs(s,t,self.inf)\n\nH, W = MAP()\nS = [input() for _ in range(H)]\n\nD = Dinic(2*H*W+2)\ndx = [0, -1, 0, 1]\ndy = [1, 0, -1, 0]\ns = 2*H*W\nt = 2*H*W+1\nfor i in range(H):\n    for j in range(W):\n        if S[i][j] == \"X\":\n            if i == 0 or i == H-1  or j == 0 or j == W-1:\n                print(-1)\n                exit()\n            D.add_edge(s, W*i+j, INF)\n            for k in range(4):\n                ny = i+dy[k]\n                nx = j+dx[k]\n                D.add_edge(W*i+j, W*ny+nx, INF)\n        else:\n            D.add_edge(W*i+j, W*H+W*i+j, 1)\n            if i == 0 or i == H-1  or j == 0 or j == W-1:\n                D.add_edge(H*W+W*i+j, t, INF)\n            else:\n                for k in range(4):\n                    ny = i+dy[k]\n                    nx = j+dx[k]\n                    D.add_edge(H*W+W*i+j, W*ny+nx, INF)\n\nprint(D.max_flow(s, t))\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n# Here your code !\ndef main():\n    h, w = map(int, input().split())\n    arr = []\n    for i in range(h):\n        ls = list(input())\n        arr.append(ls)\n        if ls[0] == \"X\" or ls[-1] == \"X\":\n            return -1\n        if i == 0 and \"X\" in ls:\n            return -1\n        if i == h - 1 and \"X\" in ls:\n            return -1\n    cnt = 0\n    for y in range(h):\n        for x in range(w):\n            if arr[y][x] == \"X\":\n                nextcells = [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]\n                for i in range(4):\n                    tx = nextcells[i][0]\n                    ty = nextcells[i][1]\n                    if 0 <= tx < w and 0 <= ty < h:\n                        arr[ty][tx] = \"i\"\n                        cnt += 1\n    \n    return cnt\n    #print(arr)\n    \nprint(main())    \n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nfrom collections import deque\n\n\"\"\"\n・最小カット\n・頂点でカットする場合には、v_in, v_outに分ける\n・v_in, v_outの間に容量1の辺\n・sourceから、ヤギ_outに容量無限大の辺\n・外周_outから、sinkに容量無限大の辺\n\"\"\"\n\nH,W = map(int,readline().split())\nS = b''.join(read().split())\n\nclass Dinic:\n    def __init__(self, N, source, sink):\n        self.N = N\n        self.G = [[] for _ in range(N)]\n        self.source = source\n        self.sink = sink\n\n    def add_edge(self, fr, to, cap):\n        n1 = len(self.G[fr])\n        n2 = len(self.G[to])\n        self.G[fr].append([to, cap, n2])\n        self.G[to].append([fr, 0, n1]) # 逆辺を cap 0 で追加\n        \n    def add_edge_undirected(self, fr, to, cap):\n        n1 = len(self.G[fr])\n        n2 = len(self.G[to])\n        self.G[fr].append([to, cap, n2])\n        self.G[to].append([fr, cap, n1])\n        \n    def bfs(self):\n        level = [0] * self.N\n        G = self.G; source = self.source; sink = self.sink\n        q = deque([source])\n        level[source] = 1\n        pop = q.popleft; append = q.append\n        while q:\n            v = pop()\n            lv = level[v] + 1\n            for to, cap, rev in G[v]:\n                if not cap:\n                    continue\n                if level[to]:\n                    continue\n                level[to] = lv\n                if to == sink:\n                    self.level = level\n                    return\n                append(to)\n        self.level = level\n        \n    def dfs(self):\n        INF = 10**18\n        G = self.G\n        sink = self.sink\n        prog = self.progress\n        level = self.level\n        ascend = False\n        ff = 0\n        stack = [(self.source,INF)]\n        while stack:\n            if ff:\n                # このまま更新だけして戻っていく\n                v,f = stack.pop()\n                p = prog[v]\n                to, cap, rev = G[v][p]\n                G[v][p][1] -= ff\n                G[to][rev][1] += ff\n                continue\n            v,f = stack[-1]\n            if v == sink:\n                ff = f\n                stack.pop()\n                continue\n            E = G[v]\n            lv = level[v]\n            if ascend:\n                # 流せずに戻ってきた\n                prog[v] += 1\n            find_flag = False\n            for i in range(prog[v],len(E)):\n                to, cap, rev = E[i]\n                prog[v] = i\n                if not cap:\n                    continue\n                if level[to] <= lv:\n                    continue\n                find_flag = True\n                break\n            if not find_flag:\n                ascend = True\n                stack.pop()\n                continue\n            ascend = False\n            x = f if f < cap else cap\n            stack.append((to,x))\n        return ff\n    \n    def max_flow(self):\n        flow = 0\n        while True:\n            self.bfs()\n            if not self.level[self.sink]:\n                return flow\n            self.progress = [0] * self.N\n            while True:\n                f = self.dfs()\n                if not f:\n                    break\n                flow += f\n        return flow\n\n# v_i-in: 2i\n# v_i-out: 2i+1\nsource = 2*H*W\nsink = source+1\n\nINF = 10**12\n\ndinic = Dinic(2*H*W+2,source,sink)\nadd = dinic.add_edge\nfor i in range(H*W):\n    h,w = divmod(i,W)\n    if S[i] == ord('.'):\n        add(i+i,i+i+1,1)\n    else:\n        add(source,i+i+1,INF)\n    for dh,dw in ((1,0),(-1,0),(0,1),(0,-1)):\n        h1 = h + dh; w1 = w + dw\n        if 0 <= h1 < H and 0 <= w1 < W:\n            j = h1 * W + w1\n            add(i+i+1,j+j,1)\n        else:\n            # 画面外\n            add(i+i+1,sink,INF)\n\ndinic.source\n\nf = dinic.max_flow()\nanswer = f if f < INF else -1\nprint(answer)\n\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nH, W = map(int, raw_input().split())\nS_list = list()\nfor i in range(H):\n    S_list.append(raw_input())\n\n# large_const\nlarge_const = 100000\n\nX_mat = np.zeros((H, W), dtype='int')\nS_mat_extend = np.zeros((H+2, W+2), dtype='int')\n\n# input\nfor h in range(H):\n    for w in range(W):\n        if S_list[h][w] == 'X':\n            X_mat[h, w] += 1\n\n# make graph\nG = dict()\ndef add_node(s, Graph=G):\n    Graph[s] = {'edges':dict()}\n    \ndef add_edge(s, t, weight=1, Graph=G):\n    Graph[s]['edges'][t] = weight\n\ndef max_flow_dinic(s, t, Graph=G):\n    G_ = Graph\n    max_flow = 0\n    while True:\n        # create level Graph(reverse)\n        # initialize\n        for v in G_.keys():\n            G_[v]['dist'] = -1\n        # dst\n        G_[t]['dist'] = 0\n        # bfs \n        que_bfs = [t]\n        dmax = large_const\n        while len(que_bfs) > 0:\n            v = que_bfs.pop(0)\n            if G_[v]['dist'] >= dmax:\n                # if too far, pass\n                pass\n            else:\n                # else update dist\n                for d in G_[v]['edges'].keys():    \n                    if G_[d]['edges'][v] > 0:\n                        if d == s:\n                            # src reached\n                            # update\n                            dmax = min(dmax, G_[v]['dist'] + 1)\n                            G_[d]['dist'] = dmax\n                        elif G_[d]['dist'] == -1:\n                            # update\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        elif G_[d]['dist'] > G_[v]['dist'] + 1:\n                            # update (may not happen)\n                            G_[d]['dist'] = G_[v]['dist'] + 1\n                            que_bfs.append(d)\n                        else:\n                            pass\n        \n        if G_[s]['dist'] == -1:\n            break\n        else:\n            # find blocking flow with respect to current dist\n            # dfs\n            que_dfs = [[s]]\n            while len(que_dfs) > 0:\n                path = que_dfs.pop()\n                v = path[-1]\n                # add\n                for d in G_[v]['edges'].keys():\n                    if G_[v]['edges'][d] > 0 and G_[d]['dist'] == G_[v]['dist'] - 1:\n                        if d == t:\n                            # if reached\n                            path.append(d)\n                            # add flow and update graph with residual\n                            eps = min([G_[path[i]]['edges'][path[i+1]] for i in range(len(path) - 1)])\n                            if eps == 0:\n                                # print \"zero\"\n                                pass\n                            else:\n                                max_flow += eps\n                                imax = len(path)-2\n                                for i in range(len(path) - 1):\n                                    G_[path[i]]['edges'][path[i+1]] -= eps\n                                    G_[path[i+1]]['edges'][path[i]] += eps\n                                    if G_[path[i]]['edges'][path[i+1]] == 0:\n                                        imax = min(imax, i)\n                                # cut tree\n                                que_dfs = []\n                                path_temp = []\n                                for i in range(imax+1):\n                                    path_temp.append(path[i])\n                                    que_dfs.append(path_temp)\n                        else:\n                            # append to que\n                            que_dfs.append(path + [d])\n            \n    \n    return max_flow\n\n\n# src:sheeps\n# dst:outer\nadd_node('src')\nadd_node('dst')\n\n# grid\n# nodes\nfor i in range(H):\n    for j in range(W):\n        add_node(str([i, j]) + '-src')\n        add_node(str([i, j]) + '-dst')\n# edges\nfor i in range(H):\n    for j in range(W):\n        add_edge(str([i, j]) + '-dst', str([i, j]) + '-src', 1)\n        add_edge(str([i, j]) + '-src', str([i, j]) + '-dst', 0)\n        if X_mat[i, j] == 1:\n            add_edge('src', str([i, j]) + '-dst', large_const)\n            add_edge(str([i, j]) + '-dst', 'src', 0)\n            add_edge(str([i, j]) + '-dst', str([i, j]) + '-src', large_const)\n            add_edge(str([i, j]) + '-src', str([i, j]) + '-dst', 0)\n        if i > 0:\n            add_edge(str([i, j]) + '-src', str([i-1, j]) + '-dst', 1)\n            add_edge(str([i-1, j]) + '-dst', str([i, j]) + '-src', 0)\n        if i < H-1:\n            add_edge(str([i, j]) + '-src', str([i+1, j]) + '-dst', 1)\n            add_edge(str([i+1, j]) + '-dst', str([i, j]) + '-src', 0)\n        if j > 0:\n            add_edge(str([i, j]) + '-src', str([i, j-1]) + '-dst', 1)\n            add_edge(str([i, j-1]) + '-dst', str([i, j]) + '-src', 0)\n        if j < W-1:\n            add_edge(str([i, j]) + '-src', str([i, j+1]) + '-dst', 1)\n            add_edge(str([i, j+1]) + '-dst', str([i, j]) + '-src', 0)\n        if i == 0 or j == 0 or i == H-1 or j == W-1:\n            add_edge(str([i, j]) + '-src', 'dst', large_const)\n            add_edge('dst', str([i, j]) + '-src', 0)\n\nres = 0\n# find -1\nif X_mat[0,:].sum() + X_mat[H-1,:].sum() + X_mat[:,0].sum() + X_mat[:,W-1].sum() > 0:\n    res = -1\nelse:\n    res = max_flow_dinic('src', 'dst')\n\n\nprint res"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\n\nfn nxny(i: usize, j: usize, h: usize, w: usize) -> Vec<(usize, usize)>{\n    let mut nxny: Vec<(usize, usize)> = Vec::with_capacity(4);\n    if i != h - 1 { nxny.push((i + 1, j)); }\n    if j != w - 1 { nxny.push((i, j + 1)); }\n    if i != 0 { nxny.push((i - 1, j)); }\n    if j != 0 { nxny.push((i, j - 1)); }\n    nxny\n}\n\nfn main(){\n    let (h, w): (usize, usize) = readln();\n    let mut m: Vec<Vec<char>> = vec![vec!();h];\n    for i in 0..h{\n        m[i] = get_line().chars().collect();\n    }\n\n    for i in 0..h{\n        for j in 0..w{\n            if i == 0 || i == h - 1 || j == 0 || j == w - 1{\n                if m[i][j] == 'X'{\n                    println!(\"-1\");\n                    return;\n                }\n            }\n        }\n    }\n\n    let mut gr = MaxFlowGraph::new(2 * h * w + 2);\n\n    fn idx_in(i: usize, j: usize, w: usize) -> usize{\n        2 * (i * w + j)\n    }\n\n    fn idx_out(i: usize, j: usize, w: usize) -> usize{\n        2 * (i * w + j) + 1\n    }\n\n    let src_idx = idx_out(h-1, w-1, w) + 1;\n    let sink_idx = src_idx + 1;\n\n    for i in 0..h{\n        for j in 0..w{\n            gr.add_edge(idx_in(i,j,w), idx_out(i,j,w), 1);\n            for (ni, nj) in nxny(i,j,h,w){\n                gr.add_edge(idx_out(i,j,w), idx_in(ni,nj,w), INF);\n            }\n            if i == 0 || i == h - 1 || j == 0 || j == w - 1 {\n                gr.add_edge(idx_out(i,j,w), sink_idx, INF);\n            }\n            if m[i][j] == 'X' {\n                gr.add_edge(src_idx, idx_out(i,j,w), INF);\n            }\n        }\n    }\n\n    let res = gr.max_flow(src_idx, sink_idx);\n    println!(\"{}\", res);\n\n}\n\ntype Capacity = i64;\nconst INF: Capacity = 0x3f3f3f3f3f3f3f3f;\n\n#[derive(Debug, Clone, Copy)]\nstruct Edge {\n    dst: usize,\n    cap: Capacity,\n    rev: usize\n}\n\nstruct MaxFlowGraph {\n    num_v: usize,\n    adj: Vec<Vec<Edge>>,\n    level: Vec<isize>,\n    iter: Vec<usize>\n}\n\nimpl MaxFlowGraph {\n    fn new(size: usize) -> MaxFlowGraph {\n        MaxFlowGraph {\n            num_v: size,\n            adj: vec![vec!(); size],\n            level: vec![-1; size],\n            iter: vec![0; size]\n        }\n    }\n\n    fn add_edge(&mut self, src: usize, dst: usize, cap: Capacity){\n        let rev = self.adj[dst].len();\n        self.adj[src].push(Edge{dst: dst, cap: cap, rev: rev});\n        let rev = self.adj[src].len() - 1;\n        self.adj[dst].push(Edge{dst: src, cap: 0, rev: rev});\n    }\n\n    fn bfs(&mut self, src: usize){\n        self.level = vec![-1; self.num_v];\n        let mut que = VecDeque::new();\n        self.level[src] = 0;\n        que.push_back(src);\n        loop {\n            match que.pop_front() {\n                Some(v) => {\n                    for e in &self.adj[v]{\n                        if e.cap > 0 && self.level[e.dst] < 0{\n                            self.level[e.dst] = self.level[v] + 1;\n                            que.push_back(e.dst);\n                        }\n                    }\n                },\n                None => {\n                    break;\n                }\n            }\n        }\n    }\n\n    fn dfs(&mut self, v: usize, sink: usize, flow: Capacity) -> Capacity{\n        if v == sink { return flow; }\n        while self.iter[v] < self.adj[v].len(){\n            let i = self.iter[v];\n            let e = self.adj[v][i];\n            self.iter[v] += 1;\n            if e.cap > 0 && self.level[v] < self.level[e.dst]{\n                let d = self.dfs(e.dst, sink, min(flow, e.cap));\n                if d > 0 {\n                    self.adj[v][i].cap -= d;\n                    self.adj[e.dst][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    fn max_flow(&mut self, src: usize, sink: usize) -> Capacity{\n        let mut flow = 0;\n        loop {\n            self.bfs(src);\n            if self.level[sink] < 0 {\n                return flow;\n            }\n\n            self.iter = vec![0; self.num_v];\n\n            loop {\n                let f = self.dfs(src, sink, INF);\n                if f <= 0 { break; }\n                flow += f;\n            }\n        }\n    }\n}\n\n\n#[allow(dead_code)]\nfn get_line() -> String{\n    let mut buf = String::new();\n    std::io::stdin().read_line(&mut buf).unwrap();\n    buf.trim_right().to_string()\n}\n\n#[allow(dead_code)]\nfn readln<T: Read>() -> T{\n    let mut buf = String::new();\n    std::io::stdin().read_line(&mut buf).unwrap();\n    T::read(buf.trim_right())\n}\n\ntrait Read{\n    fn read(s: &str) -> Self;\n}\n\nmacro_rules! read_impl{\n    ($($t:ty)*) => ($(\n        impl Read for $t {\n            fn read(s: &str) -> $t{\n                s.parse().unwrap()\n            }\n        }\n    )*)\n}\nread_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n\nimpl<T: Read> Read for Vec<T>{\n    fn read(s: &str) -> Self {\n        s.split_whitespace().map(T::read).collect()\n    }\n}\n\nimpl<A: Read, B: Read> Read for (A, B){\n    fn read(s: &str) -> Self {\n        let tokens: Vec<_> = s.split_whitespace().collect();\n        (A::read(tokens[0]), B::read(tokens[1]))\n    }\n}\n\nimpl<A: Read, B: Read, C: Read> Read for (A, B, C){\n    fn read(s: &str) -> Self {\n        let tokens: Vec<_> = s.split_whitespace().collect();\n        (A::read(tokens[0]), B::read(tokens[1]), C::read(tokens[2]))\n    }\n}"
  }
]