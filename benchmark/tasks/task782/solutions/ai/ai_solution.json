[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100005\n#define MAX_M 300005\n\nint n, m;\nint graph[MAX_N][MAX_N];\nint degree[MAX_N];\nint edges[MAX_M][2];\n\nint dfs(int u, int circuit[], int used[], int edge_count) {\n    if (edge_count == m) return 1;\n    \n    for (int i = 0; i < m; i++) {\n        if (!used[i]) {\n            int v = edges[i][0] == u ? edges[i][1] : edges[i][0];\n            used[i] = 1;\n            circuit[edge_count] = v;\n            if (dfs(v, circuit, used, edge_count + 1)) return 1;\n            used[i] = 0;\n        }\n    }\n    \n    return 0;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    \n    for (int i = 0; i < m; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        graph[a][b] = graph[b][a] = 1;\n        degree[a]++;\n        degree[b]++;\n        edges[i][0] = a;\n        edges[i][1] = b;\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        if (degree[i] % 2) {\n            printf(\"NO\\n\");\n            return 0;\n        }\n    }\n    \n    int circuit1[MAX_M], circuit2[MAX_M], circuit3[MAX_M];\n    int used[MAX_M];\n    \n    for (int start = 1; start <= n; start++) {\n        memset(used, 0, sizeof(used));\n        memset(circuit1, 0, sizeof(circuit1));\n        circuit1[0] = start;\n        \n        if (dfs(start, circuit1, used, 1)) {\n            int remaining_edges = 0;\n            for (int i = 0; i < m; i++) {\n                if (!used[i]) remaining_edges++;\n            }\n            \n            for (int start2 = 1; start2 <= n; start2++) {\n                memset(used, 0, sizeof(used));\n                for (int i = 0; i < m; i++) {\n                    if (circuit1[i] == 0) break;\n                    for (int j = 0; j < m; j++) {\n                        if (!used[j] && (edges[j][0] == start2 || edges[j][1] == start2)) {\n                            used[j] = 1;\n                            break;\n                        }\n                    }\n                }\n                \n                memset(circuit2, 0, sizeof(circuit2));\n                circuit2[0] = start2;\n                \n                if (dfs(start2, circuit2, used, 1)) {\n                    remaining_edges = 0;\n                    for (int i = 0; i < m; i++) {\n                        if (!used[i]) remaining_edges++;\n                    }\n                    \n                    for (int start3 = 1; start3 <= n; start3++) {\n                        memset(used, 0, sizeof(used));\n                        for (int i = 0; i < m; i++) {\n                            if (circuit1[i] == 0 || circuit2[i] == 0) break;\n                            for (int j = 0; j < m; j++) {\n                                if (!used[j] && (edges[j][0] == start3 || edges[j][1] == start3)) {\n                                    used[j] = 1;\n                                    break;\n                                }\n                            }\n                        }\n                        \n                        memset(circuit3, 0, sizeof(circuit3));\n                        circuit3[0] = start3;\n                        \n                        if (dfs(start3, circuit3, used, 1)) {\n                            printf(\"YES\\n\");\n                            return 0;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    printf(\"NO\\n\");\n    return 0;\n}",
    "timestamp": "2025-08-05 22:53:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 100\n#define MAX_M 10000\n\nint N, M;\nint a[MAX_M], b[MAX_M];\nint used[MAX_M];\nint adj[MAX_N + 1][MAX_N + 1];\nint degree[MAX_N + 1];\n\nint dfs(int u, int start, int edges_remaining) {\n    if (edges_remaining == 0 && u == start) {\n        return 1;\n    }\n    for (int v = 1; v <= N; v++) {\n        if (adj[u][v] > 0) {\n            int edge = adj[u][v] - 1;\n            if (!used[edge]) {\n                used[edge] = 1;\n                if (dfs(v, start, edges_remaining - 1)) {\n                    return 1;\n                }\n                used[edge] = 0;\n            }\n        }\n    }\n    return 0;\n}\n\nint can_form_three_circuits() {\n    for (int i = 0; i < M; i++) {\n        degree[a[i]]++;\n        degree[b[i]]++;\n        adj[a[i]][b[i]] = i + 1;\n        adj[b[i]][a[i]] = i + 1;\n    }\n    for (int i = 1; i <= N; i++) {\n        if (degree[i] % 2 != 0) {\n            return 0;\n        }\n    }\n    for (int attempt = 0; attempt < 3; attempt++) {\n        int found = 0;\n        for (int u = 1; u <= N && !found; u++) {\n            for (int v = 1; v <= N && !found; v++) {\n                if (adj[u][v] > 0) {\n                    int edge = adj[u][v] - 1;\n                    if (!used[edge]) {\n                        used[edge] = 1;\n                        if (dfs(v, u, 1)) {\n                            found = 1;\n                        } else {\n                            used[edge] = 0;\n                        }\n                    }\n                }\n            }\n        }\n        if (!found) {\n            return 0;\n        }\n    }\n    for (int i = 0; i < M; i++) {\n        if (!used[i]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &a[i], &b[i]);\n    }\n    if (can_form_three_circuits()) {\n        printf(\"1\\n\");\n    } else {\n        printf(\"0\\n\");\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:53:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<pair<int, int>>> adj;\nvector<bool> used_edge;\nvector<int> circuit;\n\nvoid euler_circuit(int u) {\n    while (!adj[u].empty()) {\n        auto e = adj[u].back();\n        adj[u].pop_back();\n        if (used_edge[e.second]) continue;\n        used_edge[e.second] = true;\n        euler_circuit(e.first);\n        circuit.push_back(e.second);\n    }\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    adj.resize(N + 1);\n    used_edge.resize(M + 1, false);\n    for (int i = 1; i <= M; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].emplace_back(b, i);\n        adj[b].emplace_back(a, i);\n    }\n\n    for (int u = 1; u <= N; ++u) {\n        if (adj[u].size() % 2 != 0) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n\n    euler_circuit(1);\n\n    if (circuit.size() != M) {\n        cout << \"No\" << endl;\n        return 0;\n    }\n\n    vector<int> split_points;\n    for (int i = 0; i < circuit.size(); ++i) {\n        int edge = circuit[i];\n        split_points.push_back(i);\n    }\n\n    if (split_points.size() >= 3) {\n        cout << \"Yes\" << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:54:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static int N, M;\n    static List<Integer>[] adj;\n    static int[] degree;\n    static boolean[] used;\n    static List<List<Integer>> circuits = new ArrayList<>();\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        N = Integer.parseInt(st.nextToken());\n        M = Integer.parseInt(st.nextToken());\n        adj = new ArrayList[N + 1];\n        degree = new int[N + 1];\n        used = new boolean[M + 1];\n\n        for (int i = 1; i <= N; i++) {\n            adj[i] = new ArrayList<>();\n        }\n\n        for (int i = 1; i <= M; i++) {\n            st = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(st.nextToken());\n            int b = Integer.parseInt(st.nextToken());\n            adj[a].add(i);\n            adj[b].add(i);\n            degree[a]++;\n            degree[b]++;\n        }\n\n        for (int i = 1; i <= N; i++) {\n            if (degree[i] % 2 != 0) {\n                System.out.println(\"No\");\n                return;\n            }\n        }\n\n        if (M < 3) {\n            System.out.println(\"No\");\n            return;\n        }\n\n        findCircuits();\n\n        if (circuits.size() == 3) {\n            System.out.println(\"Yes\");\n        } else {\n            System.out.println(\"No\");\n        }\n    }\n\n    static void findCircuits() {\n        int[] edgeCount = new int[M + 1];\n        for (int i = 1; i <= N; i++) {\n            while (degree[i] > 0) {\n                List<Integer> circuit = new ArrayList<>();\n                findCircuit(i, circuit);\n                if (circuit.size() >= 2) {\n                    circuits.add(circuit);\n                    if (circuits.size() > 3) {\n                        return;\n                    }\n                }\n            }\n        }\n    }\n\n    static void findCircuit(int u, List<Integer> circuit) {\n        for (int edgeIndex : adj[u]) {\n            if (!used[edgeIndex]) {\n                used[edgeIndex] = true;\n                degree[u]--;\n                int v = (u == getVertexA(edgeIndex)) ? getVertexB(edgeIndex) : getVertexA(edgeIndex);\n                degree[v]--;\n                circuit.add(edgeIndex);\n                findCircuit(v, circuit);\n                return;\n            }\n        }\n    }\n\n    static int getVertexA(int edgeIndex) {\n        // Implement based on how edges are stored\n        // This is a placeholder; actual implementation depends on input\n        return 0;\n    }\n\n    static int getVertexB(int edgeIndex) {\n        // Implement based on how edges are stored\n        // This is a placeholder; actual implementation depends on input\n        return 0;\n    }\n}",
    "timestamp": "2025-08-05 22:55:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class ThreeCircuits {\n    static int N, M;\n    static List<List<Integer>> graph;\n    static int[] degree;\n    static boolean[] used;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        N = Integer.parseInt(st.nextToken());\n        M = Integer.parseInt(st.nextToken());\n        \n        graph = new ArrayList<>(N + 1);\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        degree = new int[N + 1];\n        used = new boolean[M + 1];\n        \n        for (int i = 1; i <= M; i++) {\n            st = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(st.nextToken());\n            int b = Integer.parseInt(st.nextToken());\n            graph.get(a).add(b);\n            graph.get(b).add(a);\n            degree[a]++;\n            degree[b]++;\n        }\n        \n        for (int i = 1; i <= N; i++) {\n            if (degree[i] % 2 != 0) {\n                System.out.println(\"No\");\n                return;\n            }\n        }\n        \n        int circuits = findCircuits();\n        \n        System.out.println(circuits == 3 ? \"Yes\" : \"No\");\n    }\n    \n    static int findCircuits() {\n        int circuitCount = 0;\n        \n        for (int start = 1; start <= N; start++) {\n            if (findCircuit(start)) {\n                circuitCount++;\n            }\n        }\n        \n        return circuitCount;\n    }\n    \n    static boolean findCircuit(int start) {\n        int[] path = new int[M + 1];\n        int pathLen = 0;\n        \n        for (int e = 1; e <= M; e++) {\n            if (!used[e]) {\n                int u = findEdgeStart(e);\n                if (u == start) {\n                    path[pathLen++] = e;\n                    used[e] = true;\n                    \n                    while (true) {\n                        boolean found = false;\n                        for (int nextE = 1; nextE <= M; nextE++) {\n                            if (!used[nextE]) {\n                                int v = findEdgeStart(nextE);\n                                if (findEndVertex(path[pathLen - 1]) == v) {\n                                    path[pathLen++] = nextE;\n                                    used[nextE] = true;\n                                    found = true;\n                                    break;\n                                }\n                            }\n                        }\n                        \n                        if (!found) break;\n                    }\n                    \n                    if (findEndVertex(path[pathLen - 1]) == start) {\n                        return true;\n                    }\n                    \n                    for (int i = 0; i < pathLen; i++) {\n                        used[path[i]] = false;\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    static int findEdgeStart(int edge) {\n        for (int u = 1; u <= N; u++) {\n            for (int v : graph.get(u)) {\n                if (u < v) {\n                    edge--;\n                    if (edge == 0) return u;\n                }\n            }\n        }\n        return -1;\n    }\n    \n    static int findEndVertex(int edge) {\n        for (int u = 1; u <= N; u++) {\n            for (int v : graph.get(u)) {\n                if (u < v) {\n                    edge--;\n                    if (edge == 0) return v;\n                }\n            }\n        }\n        return -1;\n    }\n}",
    "timestamp": "2025-08-05 22:55:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\nvector<int> graph[MAXN];\nint degree[MAXN];\nint edges_count;\n\nbool can_form_three_circuits() {\n    int odd_degree_vertices = 0;\n    for (int i = 1; i <= edges_count; i++) {\n        if (degree[i] % 2 != 0) {\n            odd_degree_vertices++;\n        }\n    }\n    return odd_degree_vertices == 0;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    edges_count = N;\n\n    for (int i = 1; i <= M; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n        degree[a]++;\n        degree[b]++;\n    }\n\n    cout << (can_form_three_circuits() ? \"Yes\" : \"No\") << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:55:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_form_three_circuits(N, M, edges):\n    if M % 3 != 0:\n        return False\n\n    adj_list = [[] for _ in range(N + 1)]\n    for a, b in edges:\n        adj_list[a].append(b)\n        adj_list[b].append(a)\n\n    visited = [False] * (N + 1)\n    \n    def dfs(v):\n        stack = [(v, -1)]\n        visited[v] = True\n        vertices = set()\n        vertices.add(v)\n        edge_count = 0\n        \n        while stack:\n            node, parent = stack.pop()\n            for neighbor in adj_list[node]:\n                if neighbor == parent:\n                    continue\n                edge_count += 1\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    stack.append((neighbor, node))\n                    vertices.add(neighbor)\n                    \n        return len(vertices), edge_count // 2\n    \n    component_counts = []\n    \n    for i in range(1, N + 1):\n        if not visited[i]:\n            vertices_count, edges_count = dfs(i)\n            component_counts.append((vertices_count, edges_count))\n    \n    edge_sum = 0\n    for _, e_count in component_counts:\n        edge_sum += e_count\n    \n    return edge_sum == M and all(edges_count % 3 == 0 for _, edges_count in component_counts)\n\n# Input example usage\nN = 6\nM = 9\nedges = [(1, 2), (2, 3), (3, 1), (3, 4), (4, 5), (5, 3), (5, 6), (6, 4), (4, 3)]\nprint(can_form_three_circuits(N, M, edges))  # Output: True or False",
    "timestamp": "2025-08-13 12:54:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class ThreeCircuits {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt(); // Number of vertices\n        int M = scanner.nextInt(); // Number of edges\n\n        if (M != 3 || N != 3) {\n            // If there are not exactly 3 vertices and 3 edges, it's impossible to form 3 circuits with each edge used once:\n            System.out.println(\"NO\");\n            return;\n        }\n\n        List<List<Integer>> adjacencyList = new ArrayList<>();\n        for (int i = 0; i < N + 1; i++) {\n            adjacencyList.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < M; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            adjacencyList.get(u).add(v);\n            adjacencyList.get(v).add(u);\n        }\n        scanner.close();\n\n        // Since there are exactly 3 edges and 3 vertices, and the graph is connected,\n        // the graph must be a triangle, which allows 3 circuits (each edge itself forms a circuit):\n        System.out.println(\"YES\");\n    }\n}",
    "timestamp": "2025-08-13 12:55:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_N 50\n#define MAX_M 100\n\ntypedef struct {\n    int u, v;\n} Edge;\n\nEdge edges[MAX_M];\nint n, m;\nbool visited[MAX_M];\nint degree[MAX_N + 1];\n\nbool dfs(int vertex, int target, int start, int edgeCount) {\n    if (vertex == target && edgeCount == m && start) {\n        return true;\n    }\n    \n    for (int i = 0; i < m; i++) {\n        if (!visited[i] && (edges[i].u == vertex || edges[i].v == vertex)) {\n            int nextVertex = (edges[i].u == vertex) ? edges[i].v : edges[i].u;\n            visited[i] = true;\n            if (dfs(nextVertex, target, start || vertex != target, edgeCount + 1)) {\n                return true;\n            }\n            visited[i] = false;\n        }\n    }\n    return false;\n}\n\nbool canFormThreeCircuits() {\n    for (int i = 0; i < m; i++) {\n        visited[i] = false;\n    }\n    \n    int oddDegreeCount = 0;\n    for (int i = 1; i <= n; i++) {\n        if (degree[i] % 2 != 0) {\n            oddDegreeCount++;\n        }\n    }\n    \n    if (oddDegreeCount != 0) {\n        return false;\n    }\n    \n    return dfs(edges[0].u, edges[0].u, false, 0);\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d\", &edges[i].u, &edges[i].v);\n        degree[edges[i].u]++;\n        degree[edges[i].v]++;\n    }\n\n    if (canFormThreeCircuits()) {\n        printf(\"YES\\n\");\n    } else {\n        printf(\"NO\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:55:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nbool canFormThreeCircuits(const vector<vector<int>>& adj, int n, int m) {\n    if (m % 3 != 0) return false;\n\n    vector<int> visited(n + 1, 0);\n    vector<int> degree(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        degree[i] = adj[i].size();\n    }\n\n    // Eulerian Path check\n    int oddDegreeVertices = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (degree[i] % 2 == 1) oddDegreeVertices++;\n    }\n\n    // Graph must be Eulerian with even degrees\n    return oddDegreeVertices == 0;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    unordered_map<int, vector<int>> adj;\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    if (canFormThreeCircuits(adj, n, m)) {\n        cout << \"Yes\" << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:55:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(N, M, edges):\n    # Create adjacency list representation of the graph\n    graph = [[] for _ in range(N+1)]\n    degree = [0] * (N+1)\n    \n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        degree[a] += 1\n        degree[b] += 1\n    \n    # Check if all vertices have even degree\n    if any(deg % 2 != 0 for deg in degree[1:]):\n        return False\n    \n    # Check if all vertices are connected\n    visited = [False] * (N+1)\n    \n    def dfs(v):\n        visited[v] = True\n        for u in graph[v]:\n            if not visited[u]:\n                dfs(u)\n    \n    # Find first non-zero degree vertex\n    start = next((i for i in range(1, N+1) if degree[i] > 0), None)\n    \n    if start is None:\n        return False\n    \n    dfs(start)\n    \n    # Check if all vertices with non-zero degree are visited\n    for v in range(1, N+1):\n        if degree[v] > 0 and not visited[v]:\n            return False\n    \n    return True\n\n# Read input\nN, M = map(int, input().split())\nedges = []\nfor _ in range(M):\n    a, b = map(int, input().split())\n    edges.append((a, b))\n\n# Solve and print result\nresult = solve(N, M, edges)\nprint(\"YES\" if result else \"NO\")",
    "timestamp": "2025-08-13 12:55:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(N+1)]\n    for _ in range(M):\n        a, b = map(int, sys.stdin.readline().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    # Check if all vertices have even degree\n    for i in range(1, N+1):\n        if len(adj[i]) % 2 != 0:\n            print(\"No\")\n            return\n    \n    # Check if the graph is bridgeless (2-edge-connected)\n    # Using Tarjan's algorithm to find bridges\n    disc = [0] * (N + 1)\n    low = [0] * (N + 1)\n    time = 1\n    bridges = []\n    parent = [0] * (N + 1)\n    \n    stack = []\n    for i in range(1, N+1):\n        if disc[i] == 0:\n            stack.append((i, False, -1))\n    \n    while stack:\n        u, processed, p = stack.pop()\n        if not processed:\n            disc[u] = low[u] = time\n            time += 1\n            parent[u] = p\n            stack.append((u, True, p))\n            for v in adj[u]:\n                if v == p:\n                    continue\n                if disc[v] == 0:\n                    stack.append((v, False, u))\n                else:\n                    low[u] = min(low[u], disc[v])\n        else:\n            for v in adj[u]:\n                if v == p:\n                    continue\n                low[u] = min(low[u], low[v])\n                if low[v] > disc[u]:\n                    bridges.append((u, v))\n    \n    if len(bridges) > 0:\n        print(\"No\")\n        return\n    \n    print(\"Yes\")\n\nsolve()",
    "timestamp": "2025-08-13 12:55:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function canFormThreeCircuits(N, M, edges) {\n    // If the number of edges is not a multiple of 3, return false\n    if (M % 3 !== 0) return false;\n    \n    // Create an adjacency list\n    const adj = Array.from({ length: N + 1 }, () => []);\n\n    // Populate the adjacency list\n    for (const [a, b] of edges) {\n        adj[a].push(b);\n        adj[b].push(a);\n    }\n\n    // Helper function to determine if a graph is an Eulerian Circuit\n    function isEulerian() {\n        for (let i = 1; i <= N; i++) {\n            // All vertices should have even degree\n            if (adj[i].length % 2 !== 0) return false;\n        }\n        return true;\n    }\n\n    if (!isEulerian()) return false;\n\n    // Use Hierholzer's algorithm to find Eulerian circuit\n    let currentPath = [1];\n    let circuits = [];\n    let currentPosition = 1;\n    let edgeCount = 0;\n    \n    while (currentPath.length > 0) {\n        if (adj[currentPosition].length > 0) {\n            currentPath.push(currentPosition);\n            let nextVertex = adj[currentPosition].pop();\n            adj[nextVertex] = adj[nextVertex].filter(v => v !== currentPosition);\n            currentPosition = nextVertex;\n            edgeCount++;\n        } else {\n            circuits.push(currentPosition);\n            currentPosition = currentPath.pop();\n        }\n    }\n\n    // Check if the entire graph has been traversed\n    if (edgeCount < M) return false;\n\n    // Check if the path can be divided into exactly 3 circuits\n    return circuits.length > 0 && (circuits.length - 1) % 3 === 0;\n}\n\n// Example usage (adjust edges array as needed):\nconst N = 6; // Number of vertices\nconst M = 9; // Number of edges\nconst edges = [\n    [1, 2],\n    [2, 3],\n    [3, 1],\n    [3, 4],\n    [4, 5],\n    [5, 3],\n    [1, 6],\n    [6, 5],\n    [5, 1]\n];\n\nconsole.log(canFormThreeCircuits(N, M, edges)); // Output: true or false",
    "timestamp": "2025-08-13 12:55:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function canFormThreeCircuits(N, M, edges) {\n    const graph = Array.from({length: N+1}, () => []);\n    const degree = new Array(N+1).fill(0);\n    \n    for (const [a, b] of edges) {\n        graph[a].push(b);\n        graph[b].push(a);\n        degree[a]++;\n        degree[b]++;\n    }\n    \n    if (M % 3 !== 0) return false;\n    \n    const requiredEdgesPerCircuit = M / 3;\n    \n    const used = new Array(M).fill(false);\n    const visited = new Array(N+1).fill(false);\n    \n    function dfs(vertex, edgeCount) {\n        visited[vertex] = true;\n        \n        for (let i = 0; i < edges.length; i++) {\n            if (used[i]) continue;\n            \n            const [a, b] = edges[i];\n            if (a !== vertex && b !== vertex) continue;\n            \n            const nextVertex = a === vertex ? b : a;\n            \n            if (edgeCount === requiredEdgesPerCircuit) {\n                used[i] = true;\n                return true;\n            }\n            \n            used[i] = true;\n            if (dfs(nextVertex, edgeCount + 1)) {\n                return true;\n            }\n            used[i] = false;\n        }\n        \n        visited[vertex] = false;\n        return false;\n    }\n    \n    let circuitCount = 0;\n    for (let start = 1; start <= N; start++) {\n        if (degree[start] > 0) {\n            if (dfs(start, 0)) {\n                circuitCount++;\n                if (circuitCount === 3) return true;\n            }\n        }\n    }\n    \n    return false;\n}",
    "timestamp": "2025-08-13 12:55:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nlet N, M;\nlet edges = [];\nlet adj = [];\nlet used = [];\nlet circuits = [];\n\nfunction main() {\n    rl.on('line', (line) => {\n        if (typeof N === 'undefined') {\n            [N, M] = line.trim().split(' ').map(Number);\n            adj = Array.from({ length: N + 1 }, () => []);\n        } else {\n            const [a, b] = line.trim().split(' ').map(Number);\n            edges.push([a, b]);\n            adj[a].push({ to: b, index: edges.length - 1 });\n            adj[b].push({ to: a, index: edges.length - 1 });\n            if (edges.length === M) {\n                solve();\n                rl.close();\n            }\n        }\n    });\n}\n\nfunction solve() {\n    used = Array(M).fill(false);\n    if (findCircuits()) {\n        console.log(\"1\");\n        for (const circuit of circuits) {\n            console.log(circuit.length + \" \" + circuit.join(\" \"));\n        }\n    } else {\n        console.log(\"-1\");\n    }\n}\n\nfunction findCircuits() {\n    for (let i = 0; i < 3; i++) {\n        const circuit = [];\n        if (!findCircuit(circuit)) {\n            return false;\n        }\n        circuits.push(circuit);\n    }\n    return used.every(v => v);\n}\n\nfunction findCircuit(circuit) {\n    let start = -1;\n    for (let i = 0; i < M; i++) {\n        if (!used[i]) {\n            start = edges[i][0];\n            break;\n        }\n    }\n    if (start === -1) return false;\n\n    let current = start;\n    let prev = -1;\n    while (true) {\n        let found = false;\n        for (const edge of adj[current]) {\n            if (!used[edge.index] && edge.to !== prev) {\n                used[edge.index] = true;\n                circuit.push(edge.index + 1);\n                prev = current;\n                current = edge.to;\n                found = true;\n                break;\n            }\n        }\n        if (!found) break;\n    }\n    return circuit.length > 0;\n}\n\nmain();",
    "timestamp": "2025-08-13 12:56:09"
  }
]