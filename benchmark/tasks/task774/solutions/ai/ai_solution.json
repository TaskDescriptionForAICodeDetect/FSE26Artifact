[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool is_piece_on_grid(int H, int W, int h, int w, char* T, char* A, int N) {\n    int dx[4] = {-1, 1, 0, 0};\n    int dy[4] = {0, 0, -1, 1};\n    \n    bool dp[H+1][W+1][N+1][2];\n    memset(dp, false, sizeof(dp));\n    \n    dp[h][w][0][0] = true;\n    \n    for (int step = 0; step < N; step++) {\n        for (int x = 1; x <= H; x++) {\n            for (int y = 1; y <= W; y++) {\n                if (!dp[x][y][step][0] && !dp[x][y][step][1]) continue;\n                \n                // Takahashi's move\n                if (T[step] == 'U' && x > 1) \n                    dp[x-1][y][step+1][1] = true;\n                if (T[step] == 'D' && x < H) \n                    dp[x+1][y][step+1][1] = true;\n                if (T[step] == 'L' && y > 1) \n                    dp[x][y-1][step+1][1] = true;\n                if (T[step] == 'R' && y < W) \n                    dp[x][y+1][step+1][1] = true;\n                \n                // No move option for Takahashi\n                dp[x][y][step+1][1] |= dp[x][y][step][0];\n                \n                // Aoki's move\n                if (A[step] == 'U' && x > 1) \n                    dp[x-1][y][step+1][0] = true;\n                if (A[step] == 'D' && x < H) \n                    dp[x+1][y][step+1][0] = true;\n                if (A[step] == 'L' && y > 1) \n                    dp[x][y-1][step+1][0] = true;\n                if (A[step] == 'R' && y < W) \n                    dp[x][y+1][step+1][0] = true;\n                \n                // No move option for Aoki\n                dp[x][y][step+1][0] |= dp[x][y][step][1];\n            }\n        }\n    }\n    \n    for (int x = 1; x <= H; x++) {\n        for (int y = 1; y <= W; y++) {\n            if (dp[x][y][N][0]) return true;\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    int H, W, N, h, w;\n    scanf(\"%d %d %d %d %d\", &H, &W, &N, &h, &w);\n    \n    char T[N+1], A[N+1];\n    scanf(\"%s %s\", T, A);\n    \n    printf(\"%s\\n\", is_piece_on_grid(H, W, h, w, T, A, N) ? \"Yes\" : \"No\");\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:51:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\ntypedef struct {\n    int x, y;\n} Position;\n\nPosition move(Position p, char dir) {\n    switch (dir) {\n        case 'L': p.x--; break;\n        case 'R': p.x++; break;\n        case 'U': p.y++; break;\n        case 'D': p.y--; break;\n    }\n    return p;\n}\n\nbool is_in_grid(Position p, int H, int W) {\n    return p.x >= 1 && p.x <= W && p.y >= 1 && p.y <= H;\n}\n\nbool can_escape(int H, int W, int N, char* S, char* T) {\n    Position p = {1, 1}; // Starting position (1,1)\n    \n    for (int i = 0; i < N; i++) {\n        // Takahashi's turn: try to escape\n        Position next = move(p, S[i]);\n        if (!is_in_grid(next, H, W)) {\n            return true; // Takahashi can escape\n        }\n        p = next;\n        \n        // Aoki's turn: try to keep in grid\n        Position next_opt = p;\n        bool can_keep = false;\n        // Try all possible moves (including not moving)\n        for (char dir : {'L', 'R', 'U', 'D', '\\0'}) {\n            Position temp = p;\n            if (dir != '\\0') {\n                temp = move(p, dir);\n            }\n            if (is_in_grid(temp, H, W)) {\n                can_keep = true;\n                next_opt = temp;\n                break;\n            }\n        }\n        if (!can_keep) {\n            return true; // Aoki cannot avoid escape\n        }\n        p = next_opt;\n    }\n    return is_in_grid(p, H, W);\n}\n\nint main() {\n    int H, W, N;\n    scanf(\"%d %d %d\", &H, &W, &N);\n    char S[N+1], T[N+1];\n    scanf(\"%s %s\", S, T);\n    \n    if (can_escape(H, W, N, S, T)) {\n        printf(\"NO\\n\");\n    } else {\n        printf(\"YES\\n\");\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:52:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint H, W, N;\nstring S, T;\n\nbool solve() {\n    // Takahashi's moves are S, Aoki's moves are T (reversed)\n    // We need to check for each position after Takahashi's move, Aoki can counter it\n    \n    // We'll track the possible range of rows and columns after each step\n    int min_row = 1, max_row = H;\n    int min_col = 1, max_col = W;\n    \n    for (int i = N - 1; i >= 0; --i) {\n        // Aoki's move first (since we're processing backwards)\n        char aoki_move = T[i];\n        if (aoki_move == 'U') {\n            max_row = min(H, max_row + 1);\n        } else if (aoki_move == 'D') {\n            min_row = max(1, min_row - 1);\n        } else if (aoki_move == 'L') {\n            max_col = min(W, max_col + 1);\n        } else if (aoki_move == 'R') {\n            min_col = max(1, min_col - 1);\n        }\n        \n        // Check if the range is invalid\n        if (min_row > max_row || min_col > max_col) {\n            return false;\n        }\n        \n        // Takahashi's move\n        char takahashi_move = S[i];\n        if (takahashi_move == 'U') {\n            min_row++;\n        } else if (takahashi_move == 'D') {\n            max_row--;\n        } else if (takahashi_move == 'L') {\n            min_col++;\n        } else if (takahashi_move == 'R') {\n            max_col--;\n        }\n        \n        // Check if the range is invalid\n        if (min_row > max_row || min_col > max_col) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    cin >> H >> W >> N;\n    cin >> S >> T;\n    \n    if (solve()) {\n        cout << \"YES\" << endl;\n    } else {\n        cout << \"NO\" << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:52:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int H = scanner.nextInt();\n        int W = scanner.nextInt();\n        int x = scanner.nextInt();\n        int y = scanner.nextInt();\n        String T = scanner.next();\n        String A = scanner.next();\n        \n        int currentX = x;\n        int currentY = y;\n        boolean possible = true;\n        \n        for (int i = 0; i < N; i++) {\n            char tMove = T.charAt(i);\n            char aMove = A.charAt(i);\n            \n            // Takahashi's turn: tries to move out\n            int newX = currentX;\n            int newY = currentY;\n            if (tMove == 'U') {\n                newX = currentX - 1;\n            } else if (tMove == 'D') {\n                newX = currentX + 1;\n            } else if (tMove == 'L') {\n                newY = currentY - 1;\n            } else if (tMove == 'R') {\n                newY = currentY + 1;\n            }\n            \n            if (newX < 1 || newX > H || newY < 1 || newY > W) {\n                possible = false;\n                break;\n            }\n            currentX = newX;\n            currentY = newY;\n            \n            // Aoki's turn: tries to keep in\n            newX = currentX;\n            newY = currentY;\n            if (aMove == 'U') {\n                newX = currentX - 1;\n            } else if (aMove == 'D') {\n                newX = currentX + 1;\n            } else if (aMove == 'L') {\n                newY = currentY - 1;\n            } else if (aMove == 'R') {\n                newY = currentY + 1;\n            }\n            \n            if (!(newX < 1 || newX > H || newY < 1 || newY > W)) {\n                currentX = newX;\n                currentY = newY;\n            }\n        }\n        \n        System.out.println(possible ? \"YES\" : \"NO\");\n    }\n}",
    "timestamp": "2025-08-05 22:53:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class GridGame {\n    public static boolean willPieceStayOnGrid(int H, int W, int rs, int cs, String takahashiMoves, String aokiMoves) {\n        int[] dx = {0, 0, 1, -1};\n        int[] dy = {1, -1, 0, 0};\n        Map<Character, Integer> dirMap = new HashMap<>();\n        dirMap.put('R', 0);\n        dirMap.put('L', 1);\n        dirMap.put('D', 2);\n        dirMap.put('U', 3);\n\n        // Dynamic programming with game theory approach\n        boolean[][][] dp = new boolean[H + 1][W + 1][takahashiMoves.length() + 1];\n        \n        // Initial state is the starting position\n        dp[rs][cs][0] = true;\n\n        for (int step = 0; step < takahashiMoves.length(); step++) {\n            for (int x = 1; x <= H; x++) {\n                for (int y = 1; y <= W; y++) {\n                    if (!dp[x][y][step]) continue;\n\n                    // Takahashi's move\n                    int nx1 = x + dx[dirMap.get(takahashiMoves.charAt(step))];\n                    int ny1 = y + dy[dirMap.get(takahashiMoves.charAt(step))];\n                    \n                    // Aoki's move\n                    int nx2 = x + dx[dirMap.get(aokiMoves.charAt(step))];\n                    int ny2 = y + dy[dirMap.get(aokiMoves.charAt(step))];\n\n                    // Takahashi's options\n                    boolean canStayWithTMove = nx1 >= 1 && nx1 <= H && ny1 >= 1 && ny1 <= W;\n                    boolean canStayWithoutTMove = true;\n\n                    // Aoki's options\n                    boolean canStayWithAMove = nx2 >= 1 && nx2 <= H && ny2 >= 1 && ny2 <= W;\n                    boolean canStayWithoutAMove = true;\n\n                    // Determine next state\n                    if (canStayWithTMove) {\n                        dp[nx1][ny1][step + 1] = true;\n                    }\n                    if (canStayWithoutTMove) {\n                        dp[x][y][step + 1] = true;\n                    }\n                    if (canStayWithAMove) {\n                        dp[nx2][ny2][step + 1] = true;\n                    }\n                    if (canStayWithoutAMove) {\n                        dp[x][y][step + 1] = true;\n                    }\n                }\n            }\n        }\n\n        // Check if piece remains on grid after all moves\n        for (int x = 1; x <= H; x++) {\n            for (int y = 1; y <= W; y++) {\n                if (dp[x][y][takahashiMoves.length()]) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int H = sc.nextInt();\n        int W = sc.nextInt();\n        int rs = sc.nextInt();\n        int cs = sc.nextInt();\n        String takahashiMoves = sc.next();\n        String aokiMoves = sc.next();\n        \n        boolean result = willPieceStayOnGrid(H, W, rs, cs, takahashiMoves, aokiMoves);\n        System.out.println(result ? \"Draw\" : \"Takahashi\");\n    }\n}",
    "timestamp": "2025-08-05 22:53:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nbool solve(int H, int W, int rs, int cs, string T, string A) {\n    vector<pair<int, int>> moves = {\n        {0, 1}, {0, -1}, {1, 0}, {-1, 0}\n    };\n    \n    map<char, int> dir = {\n        {'R', 0}, {'L', 1}, {'D', 2}, {'U', 3}\n    };\n    \n    vector<vector<vector<vector<bool>>>> dp(\n        H + 1, \n        vector<vector<vector<bool>>>(\n            W + 1, \n            vector<vector<bool>>(\n                T.length() + 1, \n                vector<bool>(A.length() + 1, false)\n            )\n        )\n    );\n    \n    dp[rs][cs][0][0] = true;\n    \n    for (int t = 0; t <= T.length(); t++) {\n        for (int a = 0; a <= A.length(); a++) {\n            for (int r = 1; r <= H; r++) {\n                for (int c = 1; c <= W; c++) {\n                    if (!dp[r][c][t][a]) continue;\n                    \n                    // Takahashi's move\n                    if (t < T.length()) {\n                        int nr = r + moves[dir[T[t]]].first;\n                        int nc = c + moves[dir[T[t]]].second;\n                        \n                        if (nr >= 1 && nr <= H && nc >= 1 && nc <= W) {\n                            dp[nr][nc][t+1][a] = true;\n                        }\n                    }\n                    \n                    // Takahashi skips\n                    if (t < T.length()) {\n                        dp[r][c][t+1][a] = true;\n                    }\n                    \n                    // Aoki's move\n                    if (a < A.length()) {\n                        int nr = r + moves[dir[A[a]]].first;\n                        int nc = c + moves[dir[A[a]]].second;\n                        \n                        if (nr >= 1 && nr <= H && nc >= 1 && nc <= W) {\n                            dp[nr][nc][t][a+1] = true;\n                        }\n                    }\n                    \n                    // Aoki skips\n                    if (a < A.length()) {\n                        dp[r][c][t][a+1] = true;\n                    }\n                }\n            }\n        }\n    }\n    \n    for (int t = 0; t <= T.length(); t++) {\n        for (int a = 0; a <= A.length(); a++) {\n            for (int r = 1; r <= H; r++) {\n                for (int c = 1; c <= W; c++) {\n                    if (dp[r][c][t][a] && t == T.length() && a == A.length()) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    int H, W, rs, cs;\n    string T, A;\n    cin >> H >> W >> rs >> cs >> T >> A;\n    \n    cout << (solve(H, W, rs, cs, T, A) ? \"Yes\" : \"No\") << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:53:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def will_piece_remain_on_grid(grid_size, initial_position, takahashi_moves, aoki_moves, steps):\n    def is_on_grid(x, y):\n        return 0 <= x < grid_size[0] and 0 <= y < grid_size[1]\n\n    def make_move(position, move):\n        if move == 'U':\n            return (position[0] - 1, position[1])\n        elif move == 'D':\n            return (position[0] + 1, position[1])\n        elif move == 'L':\n            return (position[0], position[1] - 1)\n        elif move == 'R':\n            return (position[0], position[1] + 1)\n        return position\n\n    curr_pos = initial_position\n\n    for i in range(steps):\n        # Takahashi's turn\n        candidate_position = make_move(curr_pos, takahashi_moves[i])\n        if is_on_grid(*candidate_position):\n            curr_pos = candidate_position\n\n        # Aoki's turn\n        candidate_position = make_move(curr_pos, aoki_moves[i])\n        if is_on_grid(*candidate_position):\n            curr_pos = candidate_position\n        else:\n            # Aoki will not make this move since it goes off grid\n            continue\n\n    return is_on_grid(*curr_pos)\n\n# Example usage:\n# grid_size = (5, 5)\n# initial_position = (2, 2)\n# takahashi_moves = \"UURRR\"\n# aoki_moves = \"DDLLL\"\n# steps = 5\n# print(will_piece_remain_on_grid(grid_size, initial_position, takahashi_moves, aoki_moves, steps))",
    "timestamp": "2025-08-13 12:50:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class GridGame {\n\n    public static boolean willStayOnGrid(int width, int height, int startX, int startY, String takahashiMoves, String aokiMoves) {\n        int n = takahashiMoves.length();\n        int x = startX;\n        int y = startY;\n\n        for (int i = 0; i < n; i++) {\n            char takahashiMove = takahashiMoves.charAt(i);\n            char aokiMove = aokiMoves.charAt(i);\n\n            // Takahashi's optimal move calculation\n            int tempX = x;\n            int tempY = y;\n            if (takahashiMove == 'L') tempX--;\n            if (takahashiMove == 'R') tempX++;\n            if (takahashiMove == 'U') tempY--;\n            if (takahashiMove == 'D') tempY++;\n            \n            // Check bounds for Takahashi's move\n            if (tempX < 0 || tempX >= width || tempY < 0 || tempY >= height) {\n                return false;\n            }\n\n            // Apply Takahashi's move\n            x = tempX;\n            y = tempY;\n\n            // Aoki's optimal move calculation\n            tempX = x;\n            tempY = y;\n            if (aokiMove == 'L') tempX++;\n            if (aokiMove == 'R') tempX--;\n            if (aokiMove == 'U') tempY++;\n            if (aokiMove == 'D') tempY--;\n            \n            // Check bounds for Aoki's move\n            if (tempX >= 0 && tempX < width && tempY >= 0 && tempY < height) {\n                // Apply Aoki's move\n                x = tempX;\n                y = tempY;\n            }\n        }\n\n        // Check final position\n        return x >= 0 && x < width && y >= 0 && y < height;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int width = sc.nextInt();\n        int height = sc.nextInt();\n        int startX = sc.nextInt();\n        int startY = sc.nextInt();\n        String takahashiMoves = sc.next();\n        String aokiMoves = sc.next();\n\n        boolean result = willStayOnGrid(width, height, startX, startY, takahashiMoves, aokiMoves);\n        System.out.println(result ? \"Yes\" : \"No\");\n    }\n}",
    "timestamp": "2025-08-13 12:50:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\ntypedef struct {\n    int x, y;\n} Move;\n\nbool willRemainOnGrid(int startX, int startY, int rows, int cols, int n, char *takahashi, char *aoki) {\n    Move moves[128] = {0}; // A map that binds characters to their respective movement vectors\n    moves['L'] = (Move){-1, 0};\n    moves['R'] = (Move){1, 0};\n    moves['U'] = (Move){0, -1};\n    moves['D'] = (Move){0, 1};\n    \n    int currentX = startX;\n    int currentY = startY;\n    \n    for (int i = 0; i < n; ++i) {\n        int tX = currentX + moves[takahashi[i]].x;\n        int tY = currentY + moves[takahashi[i]].y;\n        \n        int aX = currentX + moves[aoki[i]].x;\n        int aY = currentY + moves[aoki[i]].y;\n        \n        bool tOut = (tX < 0 || tX >= cols || tY < 0 || tY >= rows);\n        bool aOut = (aX < 0 || aX >= cols || aY < 0 || aY >= rows);\n        \n        if (tOut && !aOut) {\n            currentX = aX;\n            currentY = aY;\n        } else if (!tOut) {\n            currentX = tX;\n            currentY = tY;\n        }\n        \n        if (currentX < 0 || currentX >= cols || currentY < 0 || currentY >= rows) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int startX = 0, startY = 0;\n    int rows = 5, cols = 5;\n    int n = 5;\n    char takahashi[] = \"RRDDU\";\n    char aoki[] = \"LLUUU\";\n\n    if (willRemainOnGrid(startX, startY, rows, cols, n, takahashi, aoki)) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:50:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function willPieceRemainOnGrid(H, W, sy, sx, st, sa) {\n    // Initialize current position.\n    let y = sy;\n    let x = sx;\n    \n    // Define the direction vectors for moves.\n    const directions = {\n        'U': [-1, 0],\n        'D': [1, 0],\n        'L': [0, -1],\n        'R': [0, 1]\n    };\n    \n    // Check if a position is valid on the grid.\n    function isValid(y, x) {\n        return y >= 0 && y < H && x >= 0 && x < W;\n    }\n    \n    // Simulate the game for each step.\n    for (let i = 0; i < st.length; i++) {\n        // Takahashi's move: try to remove the piece from the grid.\n        let ty = y + directions[st[i]][0];\n        let tx = x + directions[st[i]][1];\n        \n        // If Takahashi's move keeps the piece in the grid, execute it.\n        if (isValid(ty, tx)) {\n            y = ty;\n            x = tx;\n        }\n        \n        // Aoki's move: try to keep the piece on the grid.\n        ty = y + directions[sa[i]][0];\n        tx = x + directions[sa[i]][1];\n        \n        // Only perform the move if it keeps the piece on the grid.\n        if (isValid(ty, tx)) {\n            y = ty;\n            x = tx;\n        }\n        \n        // If at any time the piece is outside the grid, Takahashi succeeds.\n        if (!isValid(y, x)) {\n            return false;\n        }\n    }\n    \n    // If all moves are concluded and the piece remains, Aoki succeeds.\n    return true;\n}",
    "timestamp": "2025-08-13 12:50:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(H, W, rs, cs, N, T, A):\n    def is_valid(r, c):\n        return 0 <= r < H and 0 <= c < W\n\n    # Possible moves for each direction\n    moves = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n\n    # Memoization for dynamic programming\n    memo = {}\n\n    def dp(r, c, step, turn):\n        # Key for memoization\n        key = (r, c, step, turn)\n        \n        # Check memoized result\n        if key in memo:\n            return memo[key]\n\n        # Out of bounds check\n        if not is_valid(r, c):\n            memo[key] = False\n            return False\n\n        # Game completed successfully\n        if step == N:\n            memo[key] = True\n            return True\n\n        # Takahashi's turn (minimizing)\n        if turn == 0:\n            # Try moving according to Takahashi's move\n            tr, tc = r + moves[T[step]][0], c + moves[T[step]][1]\n            # Try not moving\n            stay_result = dp(r, c, step + 1, 1)\n            move_result = dp(tr, tc, step + 1, 1)\n            # Takahashi wants to remove the piece\n            result = stay_result or move_result\n            memo[key] = result\n            return result\n\n        # Aoki's turn (maximizing)\n        else:\n            # Try moving according to Aoki's move\n            ar, ac = r + moves[A[step]][0], c + moves[A[step]][1]\n            # Try not moving\n            stay_result = dp(r, c, step + 1, 0)\n            move_result = dp(ar, ac, step + 1, 0)\n            # Aoki wants to keep the piece on the grid\n            result = stay_result and move_result\n            memo[key] = result\n            return result\n\n    # Start solving from initial position\n    return dp(rs, cs, 0, 0)\n\n# Read input\nH, W = map(int, input().split())\nrs, cs = map(int, input().split())\nrs -= 1\ncs -= 1\nN = int(input())\nT = input()\nA = input()\n\n# Print result\nprint(\"Yes\" if solve(H, W, rs, cs, N, T, A) else \"No\")",
    "timestamp": "2025-08-13 12:50:40"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(H, W, rs, cs, rd, cd, T, A) {\n    const dx = { 'R': 1, 'L': -1, 'U': 0, 'D': 0 };\n    const dy = { 'R': 0, 'L': 0, 'U': -1, 'D': 1 };\n\n    function inGrid(x, y) {\n        return x >= 0 && x < W && y >= 0 && y < H;\n    }\n\n    const memo = new Map();\n\n    function dfs(x, y, turn) {\n        if (turn === T.length) return true;\n\n        const key = `${x},${y},${turn}`;\n        if (memo.has(key)) return memo.get(key);\n\n        const candidateMoves = turn % 2 === 0 \n            ? [\n                ...[...T[turn]].map(d => ({ \n                    x: x + dx[d], \n                    y: y + dy[d], \n                    moved: true \n                })),\n                { x, y, moved: false }\n            ]\n            : [\n                ...[...A[turn]].map(d => ({ \n                    x: x + dx[d], \n                    y: y + dy[d], \n                    moved: true \n                })),\n                { x, y, moved: false }\n            ];\n\n        const result = candidateMoves.some(move => {\n            if (!inGrid(move.x, move.y) && move.moved) return false;\n            if (turn === T.length - 1 && move.moved && !inGrid(move.x, move.y)) return false;\n            return turn % 2 === 0 \n                ? dfs(move.x, move.y, turn + 1)\n                : dfs(move.x, move.y, turn + 1);\n        });\n\n        memo.set(key, result);\n        return result;\n    }\n\n    return dfs(cs - 1, rs - 1, 0) ? \"YES\" : \"NO\";\n}",
    "timestamp": "2025-08-13 12:50:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    H, W, N = map(int, sys.stdin.readline().split())\n    sr, sc = map(int, sys.stdin.readline().split())\n    S = sys.stdin.readline().strip()\n    T = sys.stdin.readline().strip()\n    \n    # Initialize the safe boundaries\n    left = 1\n    right = W\n    up = 1\n    down = H\n    \n    # Process moves from the end to the beginning\n    for i in range(N-1, -1, -1):\n        # Process Takahashi's move (T[i]) which Aoki can counter\n        if T[i] == 'L':\n            right = min(right + 1, W)\n        elif T[i] == 'R':\n            left = max(left - 1, 1)\n        elif T[i] == 'U':\n            down = min(down + 1, H)\n        elif T[i] == 'D':\n            up = max(up - 1, 1)\n        \n        # Check if current boundaries are invalid\n        if left > right or up > down:\n            print(\"NO\")\n            return\n        \n        # Process Aoki's move (S[i]) which Takahashi can exploit\n        if S[i] == 'L':\n            left += 1\n        elif S[i] == 'R':\n            right -= 1\n        elif S[i] == 'U':\n            up += 1\n        elif S[i] == 'D':\n            down -= 1\n        \n        # Check if current boundaries are invalid\n        if left > right or up > down:\n            print(\"NO\")\n            return\n    \n    # After processing all moves, check if the initial position is within the safe boundaries\n    if left <= sc <= right and up <= sr <= down:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nsolve()",
    "timestamp": "2025-08-13 12:50:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(H, W, N, sr, sc, S, T) {\n    let left = 1, right = W, up = 1, down = H;\n    \n    for (let i = N - 1; i >= 0; i--) {\n        const s = S[i], t = T[i];\n        \n        // Takahashi's move (maximize the chance to go out)\n        if (t === 'L') {\n            right = Math.min(right + 1, W);\n        } else if (t === 'R') {\n            left = Math.max(left - 1, 1);\n        } else if (t === 'U') {\n            down = Math.min(down + 1, H);\n        } else if (t === 'D') {\n            up = Math.max(up - 1, 1);\n        }\n        \n        // Check if current window is invalid\n        if (left > right || up > down) {\n            return false;\n        }\n        \n        // Aoki's move (minimize the chance to go out)\n        if (s === 'L') {\n            left++;\n        } else if (s === 'R') {\n            right--;\n        } else if (s === 'U') {\n            up++;\n        } else if (s === 'D') {\n            down--;\n        }\n        \n        // Check if current window is invalid\n        if (left > right || up > down) {\n            return false;\n        }\n    }\n    \n    return (left <= sc && sc <= right) && (up <= sr && sr <= down);\n}\n\n// Read input and call solve\nconst readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nlet input = [];\nrl.on('line', (line) => {\n    input.push(line);\n}).on('close', () => {\n    const [H, W, N] = input[0].split(' ').map(Number);\n    const [sr, sc] = input[1].split(' ').map(Number);\n    const S = input[2];\n    const T = input[3];\n    \n    const result = solve(H, W, N, sr, sc, S, T);\n    console.log(result ? 'YES' : 'NO');\n});",
    "timestamp": "2025-08-13 12:51:11"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool canStayOnGrid(int h, int w, int sr, int sc, string &takahashiMoves, string &aokiMoves) {\n    int n = takahashiMoves.size();\n\n    int minRow = sr, maxRow = sr;\n    int minCol = sc, maxCol = sc;\n\n    for (int i = n - 1; i >= 0; --i) {\n        if (aokiMoves[i] == 'U') {\n            maxRow = min(maxRow + 1, h - 1);\n        } else if (aokiMoves[i] == 'D') {\n            minRow = max(minRow - 1, 0);\n        } else if (aokiMoves[i] == 'L') {\n            maxCol = min(maxCol + 1, w - 1);\n        } else if (aokiMoves[i] == 'R') {\n            minCol = max(minCol - 1, 0);\n        }\n\n        if (takahashiMoves[i] == 'U') {\n            minRow++;\n        } else if (takahashiMoves[i] == 'D') {\n            maxRow--;\n        } else if (takahashiMoves[i] == 'L') {\n            minCol++;\n        } else if (takahashiMoves[i] == 'R') {\n            maxCol--;\n        }\n\n        if (minRow > maxRow || minCol > maxCol) {\n            return false;\n        }\n    }\n\n    return minRow <= sr && sr <= maxRow && minCol <= sc && sc <= maxCol;\n}\n\nint main() {\n    int h, w, sr, sc, n;\n    string takahashiMoves, aokiMoves;\n\n    cin >> h >> w >> sr >> sc;\n    cin >> takahashiMoves >> aokiMoves;\n\n    cout << (canStayOnGrid(h, w, sr - 1, sc - 1, takahashiMoves, aokiMoves) ? \"YES\" : \"NO\") << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:36:47"
  }
]