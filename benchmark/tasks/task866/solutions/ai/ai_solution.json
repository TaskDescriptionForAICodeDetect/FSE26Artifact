[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_N 100000\n\ntypedef struct {\n    int x, y;\n    char color;\n} Desire;\n\nint solve(int K, int N, Desire desires[]) {\n    int satisfied = 0;\n    bool used[MAX_N] = {false};\n\n    for (int pattern = 0; pattern < 2; pattern++) {\n        int current_satisfied = 0;\n\n        for (int i = 0; i < N; i++) {\n            if (used[i]) continue;\n\n            int expected_color = ((desires[i].x / K + desires[i].y / K + pattern) % 2 == 0) ? 'W' : 'B';\n            \n            if (expected_color == desires[i].color) {\n                current_satisfied++;\n                used[i] = true;\n            }\n        }\n\n        satisfied = (current_satisfied > satisfied) ? current_satisfied : satisfied;\n    }\n\n    return satisfied;\n}\n\nint main() {\n    int K, N;\n    Desire desires[MAX_N];\n\n    scanf(\"%d %d\", &K, &N);\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %c\", &desires[i].x, &desires[i].y, &desires[i].color);\n    }\n\n    printf(\"%d\\n\", solve(K, N, desires));\n    return 0;\n}",
    "timestamp": "2025-08-05 23:10:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    long long x;\n    long long y;\n    char color;\n} Desire;\n\nint compare(const void *a, const void *b) {\n    Desire *desireA = (Desire *)a;\n    Desire *desireB = (Desire *)b;\n    if (desireA->x != desireB->x) {\n        return (desireA->x > desireB->x) ? 1 : -1;\n    }\n    if (desireA->y != desireB->y) {\n        return (desireA->y > desireB->y) ? 1 : -1;\n    }\n    return 0;\n}\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n    Desire *desires = (Desire *)malloc(N * sizeof(Desire));\n    for (int i = 0; i < N; i++) {\n        long long x, y;\n        char color[2];\n        scanf(\"%lld %lld %s\", &x, &y, color);\n        desires[i].x = x;\n        desires[i].y = y;\n        desires[i].color = color[0];\n    }\n\n    int max = 0;\n    for (int a = 0; a < K; a++) {\n        for (int b = 0; b < K; b++) {\n            int count = 0;\n            for (int i = 0; i < N; i++) {\n                long long x = desires[i].x + a;\n                long long y = desires[i].y + b;\n                int mod = (x / K + y / K) % 2;\n                char expected = mod == 0 ? 'B' : 'W';\n                if (desires[i].color == expected) {\n                    count++;\n                }\n            }\n            if (count > max) {\n                max = count;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", max);\n    free(desires);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:10:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    \n    map<pair<int, int>, int> countB;\n    map<pair<int, int>, int> countW;\n    \n    for (int i = 0; i < N; ++i) {\n        int x, y;\n        char c;\n        cin >> x >> y >> c;\n        \n        int rx = (x % (2 * K) + 2 * K) % (2 * K);\n        int ry = (y % (2 * K) + 2 * K) % (2 * K);\n        \n        if (c == 'B') {\n            countB[{rx % K, ry % K}]++;\n        } else {\n            countW[{rx % K, ry % K}]++;\n        }\n    }\n    \n    int max_satisfied = 0;\n    for (int dx = 0; dx < K; ++dx) {\n        for (int dy = 0; dy < K; ++dy) {\n            int satisfied = 0;\n            for (auto &p : countB) {\n                int x = p.first.first;\n                int y = p.first.second;\n                if (((x + dx) % K + (y + dy) % K) % K == 0) {\n                    satisfied += p.second;\n                }\n            }\n            for (auto &p : countW) {\n                int x = p.first.first;\n                int y = p.first.second;\n                if (((x + dx) % K + (y + dy) % K) % K != 0) {\n                    satisfied += p.second;\n                }\n            }\n            max_satisfied = max(max_satisfied, satisfied);\n        }\n    }\n    \n    cout << max_satisfied << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:10:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int K = sc.nextInt();\n        Map<String, Integer> count = new HashMap<>();\n\n        for (int i = 0; i < N; i++) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            String c = sc.next();\n            \n            int xMod = x % (2 * K);\n            int yMod = y % (2 * K);\n            \n            if (c.equals(\"B\")) {\n                if ((xMod < K && yMod < K) || (xMod >= K && yMod >= K)) {\n                    xMod = xMod % K;\n                    yMod = yMod % K;\n                } else {\n                    xMod = xMod % K;\n                    yMod = (yMod + K) % (2 * K);\n                }\n            } else { // W\n                if ((xMod < K && yMod >= K) || (xMod >= K && yMod < K)) {\n                    xMod = xMod % K;\n                    yMod = yMod % K;\n                } else {\n                    xMod = xMod % K;\n                    yMod = (yMod + K) % (2 * K);\n                }\n            }\n            String key = xMod + \",\" + yMod;\n            count.put(key, count.getOrDefault(key, 0) + 1);\n        }\n\n        int max = 0;\n        for (int val : count.values()) {\n            if (val > max) {\n                max = val;\n            }\n        }\n        System.out.println(max);\n    }\n}",
    "timestamp": "2025-08-05 23:11:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class AtCoDeerPatternPainting {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        int K = Integer.parseInt(st.nextToken());\n        int N = Integer.parseInt(st.nextToken());\n        \n        List<Desire> desires = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            st = new StringTokenizer(br.readLine());\n            int x = Integer.parseInt(st.nextToken());\n            int y = Integer.parseInt(st.nextToken());\n            char color = st.nextToken().charAt(0);\n            desires.add(new Desire(x, y, color));\n        }\n        \n        int maxSatisfied = solve(K, desires);\n        System.out.println(maxSatisfied);\n    }\n    \n    static int solve(int K, List<Desire> desires) {\n        int satisfied = 0;\n        \n        for (int color = 0; color <= 1; color++) {\n            Map<Integer, Set<Integer>> colorMap = new HashMap<>();\n            \n            for (Desire desire : desires) {\n                char desiredColor = color == 0 ? 'W' : 'B';\n                if (desire.color == desiredColor) {\n                    int xGroup = (desire.x - 1) / K;\n                    int yGroup = (desire.y - 1) / K;\n                    \n                    colorMap.putIfAbsent(xGroup, new HashSet<>());\n                    colorMap.get(xGroup).add(yGroup);\n                }\n            }\n            \n            Set<Pair> usedGroups = new HashSet<>();\n            \n            for (Desire desire : desires) {\n                char desiredColor = color == 0 ? 'W' : 'B';\n                if (desire.color == desiredColor) {\n                    int xGroup = (desire.x - 1) / K;\n                    int yGroup = (desire.y - 1) / K;\n                    \n                    Pair group = new Pair(xGroup, yGroup);\n                    if (!usedGroups.contains(group) && \n                        colorMap.containsKey(xGroup) && \n                        colorMap.get(xGroup).contains(yGroup)) {\n                        satisfied++;\n                        usedGroups.add(group);\n                    }\n                }\n            }\n        }\n        \n        return satisfied;\n    }\n    \n    static class Desire {\n        int x, y;\n        char color;\n        \n        Desire(int x, int y, char color) {\n            this.x = x;\n            this.y = y;\n            this.color = color;\n        }\n    }\n    \n    static class Pair {\n        int x, y;\n        \n        Pair(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n        \n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Pair pair = (Pair) o;\n            return x == pair.x && y == pair.y;\n        }\n        \n        @Override\n        public int hashCode() {\n            return Objects.hash(x, y);\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:11:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int K, N;\n    cin >> K >> N;\n    \n    vector<pair<pair<int, int>, char>> desires(N);\n    for (int i = 0; i < N; i++) {\n        cin >> desires[i].first.first >> desires[i].first.second >> desires[i].second;\n    }\n    \n    unordered_map<int, unordered_map<int, char>> grid;\n    unordered_set<int> satisfied;\n    \n    for (int i = 0; i < N; i++) {\n        int x = desires[i].first.first;\n        int y = desires[i].first.second;\n        char color = desires[i].second;\n        \n        int gridX = (x - 1) / K;\n        int gridY = (y - 1) / K;\n        \n        bool canSatisfy = true;\n        \n        for (int dx = 0; dx < K; dx++) {\n            for (int dy = 0; dy < K; dy++) {\n                int checkX = gridX * K + dx + 1;\n                int checkY = gridY * K + dy + 1;\n                \n                if (grid.count(checkX) && grid[checkX].count(checkY)) {\n                    if (grid[checkX][checkY] != color) {\n                        canSatisfy = false;\n                        break;\n                    }\n                }\n            }\n            \n            if (!canSatisfy) break;\n        }\n        \n        if (canSatisfy) {\n            for (int dx = 0; dx < K; dx++) {\n                for (int dy = 0; dy < K; dy++) {\n                    int checkX = gridX * K + dx + 1;\n                    int checkY = gridY * K + dy + 1;\n                    grid[checkX][checkY] = color;\n                }\n            }\n            satisfied.insert(i);\n        }\n    }\n    \n    cout << satisfied.size() << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:11:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_satisfied_desires(N, K, desires):\n    from collections import defaultdict\n\n    black_groups = defaultdict(int)\n    white_groups = defaultdict(int)\n\n    for x, y, color in desires:\n        a, b = (x // K, y // K) if color == 'B' else (x // K + 1, y // K + 1)\n        if color == 'B':\n            black_groups[(a, b)] += 1\n        else:\n            white_groups[(a, b)] += 1\n\n    max_black = max(black_groups.values(), default=0)\n    max_white = max(white_groups.values(), default=0)\n\n    return max(max_black, max_white)\n\n\n# Example usage:\nN = 5\nK = 2\ndesires = [\n    (0, 0, 'B'),\n    (1, 1, 'B'),\n    (2, 2, 'W'),\n    (3, 3, 'W'),\n    (4, 4, 'B')\n]\n\nprint(max_satisfied_desires(N, K, desires))  # Output should be 2",
    "timestamp": "2025-08-13 13:58:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class CheckedPatternSatisfaction {\n    public static int maxSatisfiedDesires(int K, int N, List<Desire> desires) {\n        int maxSatisfied = 0;\n        Map<String, Integer> satisfactionMap = new HashMap<>();\n\n        for (Desire desire : desires) {\n            int modX = desire.x % K;\n            int modY = desire.y % K;\n            String key = modX + \"-\" + modY + \"-\" + desire.color;\n\n            satisfactionMap.put(key, satisfactionMap.getOrDefault(key, 0) + 1);\n            maxSatisfied = Math.max(maxSatisfied, satisfactionMap.get(key));\n        }\n\n        return maxSatisfied;\n    }\n\n    static class Desire {\n        int x, y;\n        char color;\n\n        public Desire(int x, int y, char color) {\n            this.x = x;\n            this.y = y;\n            this.color = color;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Example usage:\n        int K = 2;\n        int N = 5;\n        List<Desire> desires = Arrays.asList(\n            new Desire(0, 0, 'B'),\n            new Desire(1, 0, 'B'),\n            new Desire(2, 0, 'W'),\n            new Desire(0, 1, 'W'),\n            new Desire(3, 1, 'B')\n        );\n\n        int result = maxSatisfiedDesires(K, N, desires);\n        System.out.println(\"Maximum Number of Desires Satisfied: \" + result); // Output: 2\n    }\n}",
    "timestamp": "2025-08-13 13:58:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y;\n    char color;\n} Desire;\n\nint max_desires_satisfied(int K, int N, Desire desires[]) {\n    int satisfied = 0;\n    // Check each row-column group for desires\n    for(int i = 0; i < K; i++) {\n        for(int j = 0; j < K; j++) {\n            int cntB = 0, cntW = 0;\n            for(int n = 0; n < N; n++) {\n                int xi = desires[n].x % K;\n                int yi = desires[n].y % K;\n                if(xi == i && yi == j) {\n                    if(desires[n].color == 'B')\n                        cntB++;\n                    else\n                        cntW++;\n                }\n            }\n            satisfied += (cntB > cntW) ? cntB : cntW;\n        }\n    }\n    return satisfied;\n}\n\nint main() {\n    int K, N;\n    scanf(\"%d %d\", &K, &N);\n    Desire desires[N];\n    for(int i = 0; i < N; i++) {\n        char color[2];\n        scanf(\"%d %d %s\", &desires[i].x, &desires[i].y, color);\n        desires[i].color = color[0];\n    }\n    printf(\"%d\\n\", max_desires_satisfied(K, N, desires));\n    return 0;\n}",
    "timestamp": "2025-08-13 13:58:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nstruct Desire {\n    int x, y;\n    char color;\n};\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    vector<Desire> desires(N);\n    \n    for (int i = 0; i < N; ++i) {\n        cin >> desires[i].x >> desires[i].y >> desires[i].color;\n    }\n    \n    unordered_map<long long, int> blackCount, whiteCount;\n\n    for (const auto& desire : desires) {\n        int gridX = desire.x / K;\n        int gridY = desire.y / K;\n        long long key = (static_cast<long long>(gridX) << 32) | gridY;\n        \n        if (((desire.x % K) + (desire.y % K)) % 2 == 0) {\n            if (desire.color == 'B')\n                blackCount[key]++;\n            else\n                whiteCount[key]++;\n        } else {\n            if (desire.color == 'W')\n                blackCount[key]++;\n            else\n                whiteCount[key]++;\n        }\n    }\n\n    int maxDesires = 0;\n    \n    for (const auto& entry : blackCount) {\n        long long key = entry.first;\n        int black = entry.second;\n        int white = whiteCount[key];\n        maxDesires = max(maxDesires, black + white);\n    }\n\n    cout << maxDesires << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 13:58:23"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_satisfied_desires(K, desires):\n    def get_color(x, y):\n        x_block = x // K\n        y_block = y // K\n        \n        if (x_block + y_block) % 2 == 0:\n            base_color = 'W'\n        else:\n            base_color = 'B'\n        \n        return base_color\n\n    satisfied_count = 0\n    used_coordinates = set()\n\n    for x, color in desires:\n        if x in used_coordinates:\n            continue\n        \n        expected_color = get_color(x[0], x[1])\n        \n        if expected_color == color:\n            satisfied_count += 1\n            used_coordinates.add(x)\n\n    return satisfied_count\n\n# Example usage\nK = 2\ndesires = [\n    ((0, 0), 'W'),\n    ((1, 1), 'B'),\n    ((2, 2), 'W')\n]\n\nresult = max_satisfied_desires(K, desires)\nprint(result)",
    "timestamp": "2025-08-13 13:58:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    N, K = map(int, data[idx:idx+2])\n    idx +=2\n    \n    count = {}\n    \n    for _ in range(N):\n        x, y, c = data[idx], data[idx+1], data[idx+2]\n        idx +=3\n        x = int(x)\n        y = int(y)\n        # Determine the base square coordinates\n        if c == 'B':\n            base_x = (x // K) % 2\n            base_y = (y // K) % 2\n            key = (base_x, base_y)\n        else:  # 'W'\n            base_x = ((x // K) + 1) % 2\n            base_y = (y // K) % 2\n            key = (base_x, base_y)\n        count[key] = count.get(key, 0) + 1\n    \n    if not count:\n        print(0)\n        return\n    \n    max_satisfied = 0\n    # The pattern repeats every 2K x 2K, so we can check all 4 possible offsets\n    for dx in [0, 1]:\n        for dy in [0, 1]:\n            total = 0\n            for (bx, by), cnt in count.items():\n                if (bx + dx + by + dy) % 2 == 0:\n                    total += cnt\n            max_satisfied = max(max_satisfied, total, N - total)\n    \n    print(max_satisfied)\n\nsolve()",
    "timestamp": "2025-08-13 13:58:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function maxSatisfiedDesires(K, desires) {\n    let blackMap = new Map();\n    let whiteMap = new Map();\n\n    for (let [x, y, color] of desires) {\n        let gridX = Math.floor(x / K);\n        let gridY = Math.floor(y / K);\n        let key = `${gridX}-${gridY}`;\n\n        if (color === 'B') {\n            if (!blackMap.has(key)) blackMap.set(key, 0);\n            blackMap.set(key, blackMap.get(key) + 1);\n        } else {\n            if (!whiteMap.has(key)) whiteMap.set(key, 0);\n            whiteMap.set(key, whiteMap.get(key) + 1);\n        }\n    }\n\n    let maxBlack = Math.max(...blackMap.values(), 0);\n    let maxWhite = Math.max(...whiteMap.values(), 0);\n\n    return Math.max(maxBlack, maxWhite);\n}",
    "timestamp": "2025-08-13 13:58:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(K, desires) {\n    const grid = new Map();\n    const colorGrid = (x, y, color) => {\n        for (let dx = 0; dx < K; dx++) {\n            for (let dy = 0; dy < K; dy++) {\n                grid.set(`${x+dx},${y+dy}`, color);\n            }\n        }\n    };\n\n    const desireMap = new Map();\n    desires.forEach(([x, y, color]) => {\n        desireMap.set(`${x},${y}`, color);\n    });\n\n    let satisfied = 0;\n    const triedConfigurations = new Set();\n\n    const backtrack = () => {\n        const key = Array.from(desireMap.entries())\n            .map(([pos, color]) => `${pos}:${color}`)\n            .sort()\n            .join('|');\n\n        if (triedConfigurations.has(key)) return satisfied;\n        triedConfigurations.add(key);\n\n        let maxSatisfied = 0;\n        for (const [pos, desiredColor] of desireMap) {\n            grid.clear();\n            let currentSatisfied = 0;\n\n            for (const [otherPos, otherColor] of desireMap) {\n                const [x, y] = otherPos.split(',').map(Number);\n                const startX = Math.floor(x / K) * K;\n                const startY = Math.floor(y / K) * K;\n\n                colorGrid(startX, startY, otherColor);\n\n                if (grid.get(otherPos) === otherColor) {\n                    currentSatisfied++;\n                }\n            }\n\n            maxSatisfied = Math.max(maxSatisfied, currentSatisfied);\n        }\n\n        return maxSatisfied;\n    };\n\n    return backtrack();\n}",
    "timestamp": "2025-08-13 13:59:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const fs = require('fs');\nconst input = fs.readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n\nfunction solve() {\n    const [N, K] = input[0].split(' ').map(Number);\n    const desires = [];\n    for (let i = 1; i <= N; i++) {\n        const parts = input[i].split(' ');\n        const x = parseInt(parts[0], 10);\n        const y = parseInt(parts[1], 10);\n        const c = parts[2];\n        desires.push({ x, y, c });\n    }\n\n    const countMap = new Map();\n\n    for (const { x, y, c } of desires) {\n        // Determine the grid cell (kx, ky)\n        let kx = Math.floor(x / K);\n        let ky = Math.floor(y / K);\n        // Determine the position within the cell\n        const rx = x % K;\n        const ry = y % K;\n        // Check if the cell's base color is white or black (0,0 is considered (0,0) mod 2K)\n        // The base color depends on the parity of (kx + ky)\n        const baseIsWhite = (kx + ky) % 2 === 0;\n        let effectiveColor = c;\n        if (!baseIsWhite) {\n            effectiveColor = c === 'B' ? 'W' : 'B';\n        }\n        // The key is based on rx and ry, but normalized to the top-left KxK block\n        // The effective color determines the key\n        let key;\n        if (effectiveColor === 'W') {\n            key = `${rx},${ry}`;\n        } else {\n            // For black, it's the same as white but shifted by K in any direction, but since we're hashing, we can use a different key\n            // Alternatively, we can use the same key but track color\n            key = `${rx},${ry}_B`;\n        }\n        countMap.set(key, (countMap.get(key) || 0) + 1);\n    }\n\n    // Now, we need to find the maximum count for any possible KxK window\n    // But since the grid is infinite and repeating, the optimal window can be any of the possible KxK patterns\n    // The maximum is simply the highest count in the countMap\n    let maxCount = 0;\n    for (const value of countMap.values()) {\n        if (value > maxCount) {\n            maxCount = value;\n        }\n    }\n\n    console.log(maxCount);\n}\n\nsolve();",
    "timestamp": "2025-08-13 13:59:16"
  }
]